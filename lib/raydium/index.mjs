var om=Object.defineProperty,im=Object.defineProperties;var rm=Object.getOwnPropertyDescriptors;var ar=Object.getOwnPropertySymbols;var Ku=Object.prototype.hasOwnProperty,Su=Object.prototype.propertyIsEnumerable;var xu=(l,e,t)=>e in l?om(l,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):l[e]=t,v=(l,e)=>{for(var t in e||(e={}))Ku.call(e,t)&&xu(l,t,e[t]);if(ar)for(var t of ar(e))Su.call(e,t)&&xu(l,t,e[t]);return l},q=(l,e)=>im(l,rm(e));var _e=(l,e)=>{var t={};for(var n in l)Ku.call(l,n)&&e.indexOf(n)<0&&(t[n]=l[n]);if(l!=null&&ar)for(var n of ar(l))e.indexOf(n)<0&&Su.call(l,n)&&(t[n]=l[n]);return t};import{merge as Sf}from"lodash";import Hu from"axios";import{PublicKey as Lu}from"@solana/web3.js";import{get as Cu,set as sm}from"lodash";var fs=class{constructor(e){this.logLevel=e.logLevel!==void 0?e.logLevel:0,this.name=e.name}set level(e){this.logLevel=e}get time(){return Date.now().toString()}get moduleName(){return this.name}isLogLevel(e){return e<=this.logLevel}error(...e){return this.isLogLevel(0)?(console.error(this.time,this.name,"sdk logger error",...e),this):this}logWithError(...e){let t=e.map(n=>typeof n=="object"?JSON.stringify(n):n).join(", ");throw new Error(t)}warning(...e){return this.isLogLevel(1)?(console.warn(this.time,this.name,"sdk logger warning",...e),this):this}info(...e){return this.isLogLevel(2)?(console.info(this.time,this.name,"sdk logger info",...e),this):this}debug(...e){return this.isLogLevel(3)?(console.debug(this.time,this.name,"sdk logger debug",...e),this):this}},Ru={},am={};function be(l){let e=Cu(Ru,l);if(!e){let t=Cu(am,l);e=new fs({name:l,logLevel:t}),sm(Ru,l,e)}return e}import{MINT_SIZE as um,TOKEN_PROGRAM_ID as cm,getTransferFeeConfig as lm,unpackMint as mm}from"@solana/spl-token";var ys=be("Raydium_accountInfo_util");async function en(l,e,t){let{batchRequest:n,commitment:o="confirmed",chunkCount:r=100}=v({batchRequest:!1},t),i=bs(e,r),s=new Array(i.length).fill([]);if(n){let u=i.map(m=>{let p=l._buildArgs([m.map(d=>d.toBase58())],o,"base64");return{methodName:"getMultipleAccounts",args:p}}),a=bs(u,10);s=(await(await Promise.all(a.map(async m=>await l._rpcBatchRequest(m)))).flat()).map(m=>(m.error&&ys.logWithError(`failed to get info for multiple accounts, RPC_ERROR, ${m.error.message}`),m.result.value.map(p=>{if(p){let{data:d,executable:f,lamports:y,owner:b,rentEpoch:g}=p;return d.length!==2&&d[1]!=="base64"&&ys.logWithError("info must be base64 encoded, RPC_ERROR"),{data:Buffer.from(d[0],"base64"),executable:f,lamports:y,owner:new Lu(b),rentEpoch:g}}return null})))}else try{s=await Promise.all(i.map(u=>l.getMultipleAccountsInfo(u,o)))}catch(u){u instanceof Error&&ys.logWithError(`failed to get info for multiple accounts, RPC_ERROR, ${u.message}`)}return s.flat()}async function Le(l,e,t){let n=await en(l,e.map(o=>o.pubkey),t);return e.map((o,r)=>q(v({},o),{accountInfo:n[r]}))}async function xo({connection:l,mints:e,config:t}){var r,i,s;if(e.length===0)return{};let n=await Le(l,e.map(u=>({pubkey:ft(u)})),t),o={};for(let u of n){if(!u.accountInfo||u.accountInfo.data.length<um){console.log("invalid mint account",u.pubkey.toBase58());continue}let a=mm(u.pubkey,u.accountInfo,(r=u.accountInfo)==null?void 0:r.owner);o[u.pubkey.toString()]=q(v({},a),{programId:((i=u.accountInfo)==null?void 0:i.owner)||cm,feeConfig:(s=lm(a))!=null?s:void 0})}return o[Lu.default.toBase58()]=o[Z.toBase58()],o}import mn from"bn.js";import ub from"decimal.js";import Am from"big.js";import lr from"bn.js";import dm from"toformat";var pm=dm,Ho=pm;import cr from"big.js";import ym from"bn.js";import bm from"decimal.js-light";import jo from"bn.js";var Ou=9007199254740991;function ne(l){let e=be("Raydium_parseBigNumberish");if(l instanceof jo)return l;if(typeof l=="string"){if(l.match(/^-?[0-9]+$/))return new jo(l);e.logWithError(`invalid BigNumberish string: ${l}`)}return typeof l=="number"?(l%1&&e.logWithError(`BigNumberish number underflow: ${l}`),(l>=Ou||l<=-Ou)&&e.logWithError(`BigNumberish number overflow: ${l}`),new jo(String(l))):typeof l=="bigint"?new jo(l.toString()):(e.error(`invalid BigNumberish value: ${l}`),new jo(0))}var ur=be("module/fraction"),gs=Ho(cr),$o=Ho(bm),gm={[0]:$o.ROUND_DOWN,[1]:$o.ROUND_HALF_UP,[2]:$o.ROUND_UP},Pm={[0]:cr.roundDown,[1]:cr.roundHalfUp,[2]:cr.roundUp},Be=class{constructor(e,t=new ym(1)){this.numerator=ne(e),this.denominator=ne(t)}get quotient(){return this.numerator.div(this.denominator)}invert(){return new Be(this.denominator,this.numerator)}add(e){let t=e instanceof Be?e:new Be(ne(e));return this.denominator.eq(t.denominator)?new Be(this.numerator.add(t.numerator),this.denominator):new Be(this.numerator.mul(t.denominator).add(t.numerator.mul(this.denominator)),this.denominator.mul(t.denominator))}sub(e){let t=e instanceof Be?e:new Be(ne(e));return this.denominator.eq(t.denominator)?new Be(this.numerator.sub(t.numerator),this.denominator):new Be(this.numerator.mul(t.denominator).sub(t.numerator.mul(this.denominator)),this.denominator.mul(t.denominator))}mul(e){let t=e instanceof Be?e:new Be(ne(e));return new Be(this.numerator.mul(t.numerator),this.denominator.mul(t.denominator))}div(e){let t=e instanceof Be?e:new Be(ne(e));return new Be(this.numerator.mul(t.denominator),this.denominator.mul(t.numerator))}toSignificant(e,t={groupSeparator:""},n=1){Number.isInteger(e)||ur.logWithError(`${e} is not an integer.`),e<=0&&ur.logWithError(`${e} is not positive.`),$o.set({precision:e+1,rounding:gm[n]});let o=new $o(this.numerator.toString()).div(this.denominator.toString()).toSignificantDigits(e);return o.toFormat(o.decimalPlaces(),t)}toFixed(e,t={groupSeparator:""},n=1){return Number.isInteger(e)||ur.logWithError(`${e} is not an integer.`),e<0&&ur.logWithError(`${e} is negative.`),gs.DP=e,gs.RM=Pm[n]||1,new gs(this.numerator.toString()).div(this.denominator.toString()).toFormat(e,t)}isZero(){return this.numerator.isZero()}};var km=be("Raydium_amount"),Nu=Ho(Am);function wm(l,e){let t="0",n="0";if(l.includes(".")){let o=l.split(".");o.length===2?([t,n]=o,n=n.padEnd(e,"0")):km.logWithError(`invalid number string, num: ${l}`)}else t=l;return[t,n.slice(0,e)||n]}var Se=class extends Be{constructor(t,n,o=!0,r){let i=new lr(0),s=Ps.pow(new lr(t.decimals));if(o)i=ne(n);else{let u=new lr(0),a=new lr(0);if(typeof n=="string"||typeof n=="number"||typeof n=="bigint"){let[c,m]=wm(n.toString(),t.decimals);u=ne(c),a=ne(m)}u=u.mul(s),i=u.add(a)}super(i,s);this.logger=be(r||"TokenAmount"),this.token=t}get raw(){return this.numerator}isZero(){return this.raw.isZero()}gt(t){return this.token.equals(t.token)||this.logger.logWithError("gt token not equals"),this.raw.gt(t.raw)}lt(t){return this.token.equals(t.token)||this.logger.logWithError("lt token not equals"),this.raw.lt(t.raw)}add(t){return this.token.equals(t.token)||this.logger.logWithError("add token not equals"),new Se(this.token,this.raw.add(t.raw))}subtract(t){return this.token.equals(t.token)||this.logger.logWithError("sub token not equals"),new Se(this.token,this.raw.sub(t.raw))}toSignificant(t=this.token.decimals,n,o=0){return super.toSignificant(t,n,o)}toFixed(t=this.token.decimals,n,o=0){return t>this.token.decimals&&this.logger.logWithError("decimals overflow"),super.toFixed(t,n,o)}toExact(t={groupSeparator:""}){return Nu.DP=this.token.decimals,new Nu(this.numerator.toString()).div(this.denominator.toString()).toFormat(t)}};import{PublicKey as Tm}from"@solana/web3.js";import{TOKEN_PROGRAM_ID as Mu}from"@solana/spl-token";var cn={chainId:101,address:Tm.default.toBase58(),programId:Mu.toBase58(),decimals:9,symbol:"SOL",name:"solana",logoURI:"https://img-v1.raydium.io/icon/So11111111111111111111111111111111111111112.png",tags:[],priority:2,type:"raydium",extensions:{coingeckoId:"solana"}},it={chainId:101,address:"So11111111111111111111111111111111111111112",programId:Mu.toBase58(),decimals:9,symbol:"WSOL",name:"Wrapped SOL",logoURI:"https://img-v1.raydium.io/icon/So11111111111111111111111111111111111111112.png",tags:[],priority:2,type:"raydium",extensions:{coingeckoId:"solana"}};import{PublicKey as hs}from"@solana/web3.js";import{PublicKey as Ge,SystemProgram as vu,SYSVAR_RENT_PUBKEY as hm}from"@solana/web3.js";import{TOKEN_PROGRAM_ID as Im}from"@solana/spl-token";function k({pubkey:l,isSigner:e=!1,isWritable:t=!0}){return{pubkey:l,isWritable:t,isSigner:e}}var As=[k({pubkey:Im,isWritable:!1}),k({pubkey:vu.programId,isWritable:!1}),k({pubkey:hm,isWritable:!1})];function ks({publicKey:l,transformSol:e}){let t=ws(l.toString());if(t instanceof Ge)return e&&t.equals(rt)?Z:t;if(e&&t.toString()===rt.toBase58())return Z;if(typeof t=="string"){if(t===Ge.default.toBase58())return Ge.default;try{return new Ge(t)}catch{throw new Error("invalid public key")}}throw new Error("invalid public key")}function ws(l){try{return new Ge(l)}catch{return l}}var mr=new Ge("MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr"),ln=new Ge("MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr"),Ze=new Ge("SysvarRent111111111111111111111111111111111"),Ts=new Ge("SysvarC1ock11111111111111111111111111111111"),Ut=new Ge("metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s"),dr=new Ge("Sysvar1nstructions1111111111111111111111111"),pr=vu.programId,gy=new Ge("4k3Dyjzvzp8eMZWUXbBCjEvwSkkk59S5iCNLY3QrkX6R"),Py=new Ge("Ea5SjE2Y6yvCeW5dYTn7PYMuW5ikXkvbGdcmSnXeaLjS"),Ay=new Ge("SRMuApVNdxXokk5GT7XD5cUUgXMBCoAz2LHeuAoKWRt"),ky=new Ge("EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v"),wy=new Ge("Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB"),Ty=new Ge("mSoLzYCxHdYgdzU16g5QSh3i5K3z3KZK7ytfqcJm7So"),hy=new Ge("7dHbWXmci3dT8UFYWYZweBLXgycu7Y3iL6trKn1Y7ARj"),Iy=new Ge("USDH1SM1ojwWUga67PGrgFWUHibbjqMvuMaDkRJTgkX"),By=new Ge("NRVwhjBQiUPYtfDT5zRBVJajzFQHaBUNtC7SNVvqRFa"),xy=new Ge("ANAxByE6G2WjFp7A4NqtWYXb3mgruyzZYg3spfxe6Lbo"),Ky=new Ge("7vfCXTUXx5WJV5JADk17DUJ4ksgau7utNKj4b963voxs"),Z=new Ge("So11111111111111111111111111111111111111112"),rt=Ge.default;function ft(l){return ks({publicKey:l,transformSol:!0})}var Is=class{constructor({mint:e,decimals:t,symbol:n,name:o,skipMint:r=!1,isToken2022:i=!1}){if(e===rt.toBase58()||e instanceof hs&&rt.equals(e)){this.decimals=it.decimals,this.symbol=it.symbol,this.name=it.name,this.mint=new hs(it.address),this.isToken2022=!1;return}this.decimals=t,this.symbol=n||e.toString().substring(0,6),this.name=o||e.toString().substring(0,6),this.mint=r?hs.default:ks({publicKey:e}),this.isToken2022=i}equals(e){return this===e?!0:this.mint.equals(e.mint)}},Xe=Is;Xe.WSOL=new Is(q(v({},it),{mint:it.address}));var Bs=class{constructor({decimals:e,symbol:t="UNKNOWN",name:n="UNKNOWN"}){this.decimals=e,this.symbol=t,this.name=n}equals(e){return this===e}},fr=Bs;fr.SOL=new Bs(cn);import Bm from"bn.js";var Fu=new Be(new Bm(100)),st=class extends Be{toSignificant(e=5,t,n){return this.mul(Fu).toSignificant(e,t,n)}toFixed(e=2,t,n){return this.mul(Fu).toFixed(e,t,n)}};var xm=be("Raydium_price"),Kt=class extends Be{constructor(t){let{baseToken:n,quoteToken:o,numerator:r,denominator:i}=t;super(r,i);this.baseToken=n,this.quoteToken=o,this.scalar=new Be(xs(n.decimals),xs(o.decimals))}get raw(){return new Be(this.numerator,this.denominator)}get adjusted(){return super.mul(this.scalar)}invert(){return new Kt({baseToken:this.quoteToken,quoteToken:this.baseToken,denominator:this.numerator,numerator:this.denominator})}mul(t){this.quoteToken!==t.baseToken&&xm.logWithError("mul token not equals");let n=super.mul(t);return new Kt({baseToken:this.baseToken,quoteToken:t.quoteToken,denominator:n.denominator,numerator:n.numerator})}toSignificant(t=this.quoteToken.decimals,n,o){return this.adjusted.toSignificant(t,n,o)}toFixed(t=this.quoteToken.decimals,n,o){return this.adjusted.toFixed(t,n,o)}};var St=new mn(0),_u=new mn(1),gb=new mn(2),Pb=new mn(3),Ab=new mn(5),Ps=new mn(10),kb=new mn(100),wb=new mn(1e3),Tb=new mn(1e4);function xs(l){return Ps.pow(ne(l))}function yr(l,e){let t=l.divmod(e);return t.mod.isZero()?t.div:t.div.isNeg()?t.div.isubn(1):t.div.iaddn(1)}function Zo(l,e,t){return l.mul(e).add(t).sub(new mn(1)).div(t)}function br(l,e,t){return l.mul(e).div(t)}var Vu=l=>typeof l=="number";function Eu(l,e,t){let n=Vu(e)?e*((t==null?void 0:t.unit)==="s"?1e3:1):e;return new Date(l).getTime()<=n}function Wu(l,e,t){let n=Vu(e)?e*((t==null?void 0:t.unit)==="s"?1e3:1):e;return new Date(l).getTime()>n}function bs(l,e=1,t=[]){let n=[...l];if(e<=0)return t;for(;n.length;)t.push(n.splice(0,e));return t}var Ft=class{constructor(e){this._owner=e}get publicKey(){return Ft.isKeyPair(this._owner)?this._owner.publicKey:this._owner}get signer(){return Ft.isKeyPair(this._owner)?this._owner:void 0}get isKeyPair(){return Ft.isKeyPair(this._owner)}get isPublicKey(){return Ft.isPublicKey(this._owner)}static isKeyPair(e){return e.secretKey!==void 0}static isPublicKey(e){return!Ft.isKeyPair(e)}};import{PublicKey as Om}from"@solana/web3.js";import{TOKEN_PROGRAM_ID as Nm}from"@solana/spl-token";import{ComputeBudgetProgram as Du,Keypair as qu,PublicKey as Uu,Transaction as gr,TransactionMessage as Km,VersionedTransaction as Gu}from"@solana/web3.js";var G={CreateAccount:"CreateAccount",InitAccount:"InitAccount",CreateATA:"CreateATA",CloseAccount:"CloseAccount",TransferAmount:"TransferAmount",InitMint:"InitMint",MintTo:"MintTo",InitMarket:"InitMarket",Util1216OwnerClaim:"Util1216OwnerClaim",SetComputeUnitPrice:"SetComputeUnitPrice",SetComputeUnitLimit:"SetComputeUnitLimit",ClmmCreatePool:"ClmmCreatePool",ClmmOpenPosition:"ClmmOpenPosition",ClmmIncreasePosition:"ClmmIncreasePosition",ClmmDecreasePosition:"ClmmDecreasePosition",ClmmClosePosition:"ClmmClosePosition",ClmmSwapBaseIn:"ClmmSwapBaseIn",ClmmSwapBaseOut:"ClmmSwapBaseOut",ClmmInitReward:"ClmmInitReward",ClmmSetReward:"ClmmSetReward",ClmmCollectReward:"ClmmCollectReward",ClmmLockPosition:"ClmmLockPosition",ClmmHarvestLockPosition:"ClmmHarvestLockPosition",AmmV4Swap:"AmmV4Swap",AmmV4AddLiquidity:"AmmV4AddLiquidity",AmmV4RemoveLiquidity:"AmmV4RemoveLiquidity",AmmV4SimulatePoolInfo:"AmmV4SimulatePoolInfo",AmmV4SwapBaseIn:"AmmV4SwapBaseIn",AmmV4SwapBaseOut:"AmmV4SwapBaseOut",AmmV4CreatePool:"AmmV4CreatePool",AmmV4InitPool:"AmmV4InitPool",AmmV5AddLiquidity:"AmmV5AddLiquidity",AmmV5RemoveLiquidity:"AmmV5RemoveLiquidity",AmmV5SimulatePoolInfo:"AmmV5SimulatePoolInfo",AmmV5SwapBaseIn:"AmmV5SwapBaseIn",AmmV5SwapBaseOut:"AmmV5SwapBaseOut",RouteSwap:"RouteSwap",RouteSwap1:"RouteSwap1",RouteSwap2:"RouteSwap2",FarmV3Deposit:"FarmV3Deposit",FarmV3Withdraw:"FarmV3Withdraw",FarmV3CreateLedger:"FarmV3CreateLedger",FarmV4Withdraw:"FarmV4Withdraw",FarmV5Deposit:"FarmV5Deposit",FarmV5Withdraw:"FarmV5Withdraw",FarmV5CreateLedger:"FarmV5CreateLedger",FarmV6Deposit:"FarmV6Deposit",FarmV6Withdraw:"FarmV6Withdraw",FarmV6Create:"FarmV6Create",FarmV6Restart:"FarmV6Restart",FarmV6CreatorAddReward:"FarmV6CreatorAddReward",FarmV6CreatorWithdraw:"FarmV6CreatorWithdraw",CpmmCreatePool:"CpmmCreatePool",CpmmAddLiquidity:"CpmmAddLiquidity",CpmmWithdrawLiquidity:"CpmmWithdrawLiquidity",CpmmSwapBaseIn:"CpmmSwapBaseIn",CpmmSwapBaseOut:"CpmmSwapBaseOut",CpmmLockLp:"CpmmLockLp",CpmmCollectLockFee:"CpmmCollectLockFee",TransferTip:"TransferTip"};import{TOKEN_PROGRAM_ID as Sm}from"@solana/spl-token";var gn=be("Raydium_txUtil"),Xu=1644;function Jo(l){let e=[],t=[];return l.microLamports&&(e.push(Du.setComputeUnitPrice({microLamports:l.microLamports})),t.push(G.SetComputeUnitPrice)),l.units&&(e.push(Du.setComputeUnitLimit({units:l.units})),t.push(G.SetComputeUnitLimit)),{instructions:e,instructionTypes:t}}async function eo(l,e){var n,o;let t=e!=null?e:"confirmed";return(o=await((n=l.getLatestBlockhash)==null?void 0:n.call(l,{commitment:t})))==null?void 0:o.blockhash}async function ei(l,e){return l.getSignatureStatuses([e]),new Promise((t,n)=>{let o=setTimeout(n,6e4);l.onSignature(e,r=>{if(clearTimeout(o),!r.err){t("");return}n(Object.assign(r.err,{txId:e}))},"confirmed")})}function Pr(l,e){l.length<1&&gn.logWithError(`no instructions provided: ${l.toString()}`),e.length<1&&gn.logWithError(`no signers provided:, ${e.toString()}`);let t=new gr;t.recentBlockhash="11111111111111111111111111111111",t.feePayer=e[0],t.add(...l);try{return Buffer.from(t.serialize({verifySignatures:!1})).toString("base64").length<Xu}catch{return!1}}async function zu(l,e,t,n=!0){let o=new Uu("RaydiumSimuLateTransaction11111111111111111"),r=[],i=new gr;i.feePayer=o;for(let a of e)Pr([...i.instructions,a],[o])||(r.push(i),i=new gr,i.feePayer=o),i.add(a);i.instructions.length>0&&r.push(i);let s=[];try{if(s=await Cm(l,r,n),s.find(a=>a.err!==null))throw Error("rpc simulateTransaction error")}catch(a){a instanceof Error&&gn.logWithError("failed to simulate for instructions","RPC_ERROR",{message:a.message})}let u=[];for(let a of s)if(gn.debug("simulate result:",a),a.logs){let c=a.logs.filter(m=>m&&m.includes(t));gn.debug("filteredLog:",u),c.length||gn.logWithError("simulate log not match keyword","keyword",t),u.push(...c)}return u}function Yu(l,e){let t=l.match(/{["\w:,]+}/g);return!t||t.length!==1?gn.logWithError(`simulate log fail to match json, keyword: ${e}`):t[0]}function Pn(l,e){let n=new RegExp(`"${e}":(\\d+)`,"g").exec(l);return!n||n.length!==2?gn.logWithError(`simulate log fail to match key", key: ${e}`):n[1]}function oe(l,e){let[t,n]=Uu.findProgramAddressSync(l,e);return{publicKey:t,nonce:n}}async function Cm(l,e,t){let n=[];if(t){let o=await l.getLatestBlockhash(),r=[];for(let a of e){a.recentBlockhash=o.blockhash,a.lastValidBlockHeight=o.lastValidBlockHeight;let m=a._compile().serialize(),d=a._serialize(m).toString("base64");r.push(d)}let i=r.map(a=>{let c=l._buildArgs([a],void 0,"base64");return{methodName:"simulateTransaction",args:c}}),s=[],u=20;for(let a=0;a<Math.ceil(i.length/u);a++)s.push(i.slice(a*u,(a+1)*u));n=await(await Promise.all(s.map(async a=>(await l._rpcBatchRequest(a)).map(c=>c.result.value)))).flat()}else try{n=await Promise.all(e.map(async o=>await(await l.simulateTransaction(o)).value))}catch(o){o instanceof Error&&gn.logWithError("failed to get info for multiple accounts","RPC_ERROR",{message:o.message})}return n}function ti({instructions:l,payer:e,signers:t}){return Pr(l,[e,...t])}function An({instructions:l,payer:e,lookupTableAddressAccount:t,recentBlockhash:n=qu.generate().publicKey.toString()}){let r=new Km({payerKey:e,recentBlockhash:n,instructions:l}).compileToV0Message(Object.values(t!=null?t:{}));try{return Buffer.from(new Gu(r).serialize()).toString("base64").length<Xu}catch{return!1}}var Rm=l=>Buffer.isBuffer(l)?l:l instanceof Uint8Array?Buffer.from(l.buffer,l.byteOffset,l.byteLength):Buffer.from(l),Lm=l=>{let e=l.serialize({requireAllSignatures:!1,verifySignatures:!1});l instanceof Gu&&(e=Rm(e));try{return e instanceof Buffer?e.toString("base64"):Buffer.from(e).toString("base64")}catch{return e.toString("base64")}};function vn(l){let e=[];return l.forEach(t=>{t instanceof gr&&(t.recentBlockhash||(t.recentBlockhash=Sm.toBase58()),t.feePayer||(t.feePayer=qu.generate().publicKey)),e.push(Lm(t))}),console.log("simulate tx string:",e),e}function $(l,e,t){return oe([l.toBuffer(),(t!=null?t:Nm).toBuffer(),e.toBuffer()],new Om("ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL"))}import{PublicKey as se}from"@solana/web3.js";var Ks=new se("EhhTKczWMGQt46ynNeRX1WfeagwwJd7ufHvCDjRxjo5Q"),Ss=new se("CBuCnLe26faBpcBP2fktp4rp8abpcAnTWft6ZrP5Q4T"),Cs=new se("9KEPoZmtHUrBbhWN1v1KWLMkkvwY6WLtAVUCPRtRjP4z"),Ko=new se("FarmqiPv5eAj3j1GMdMCMUGXqPUvmquZtMy86QH6rzhG"),Mm=new se("CLaimxFqjHzgTJtAGHU47NPhg6qrc5sCnpC4tBLyABQS"),Rs=new se("srmqPvymJeFKQ4zGQed1GFppgkRHL9kaELCbyksJtPX"),Ar=new se("9xQeWvG816bUx9EPjHmaT23yvVM2ZWbrrpZb9PusVFin"),ni=new se("675kPX9MHTjS2zt1qfr1NYHuzeLXfQM9H24wFSUt1Mp8"),vm=new se("5quBtoiQqxF9Jv6KYKctB59NT3gtJD2Y65kdnB1Uev3h"),kr=new se("CDSr3ssLcRB6XYPJwAfFt18MZvEZp4LjHcvzBVZ45duo"),Fn=new se("CAMMCzo5YL8w4VFF8KVHrK22GGUsp5VTaW7grrKgrWqK"),So=new se("LockrWmn6K5twhz3y9w1dQERbmgSaRkfnTeTKbpofwE"),oi=new se("kN1kEznaF5Xbd8LYuqtEFcxzWSBk5Fv6ygX6SqEGJVy"),_n=new se("CDSr3ssLcRB6XYPJwAfFt18MZvEZp4LjHcvzBVZ45duo"),Fm=new se("routeUGWgWzqBWFcrCfv8tritsqukccJPu3q5GPP3xS"),Ls=new se("7YttLkHDoNj9wyDur5pM1ejNaAvT9X4eqaYcHQqtj2G5"),_m=new se("6FJon3QE27qgPVggARueB22hLvoh22VzJpXv4rBEoSLF"),Vm=new se("CC12se5To1CdEuw7fDS27B7Geo5jJyL7t5UK2B44NgiH"),Em=new se("9HzJyW1qZsEiSfMUf6L2jo3CcTKAyBmSyKdwQeYisHrC"),Wm=new se("DropEU8AvevN3UrXWXTMuz3rqnMczQVNjq3kcSdW2SQi"),Vn=new se("CPMMoo8L3F4NbTegBCKVNunggL7H1ZpdTHKxQB5qKP1C"),Os=new se("GpMZbSM2GgvTKHJirzeGfMFoaZ8UR2X7F4v8vHTvxFbL"),Dm=new se("DNXgeM9EiiaAbaWvwjHj9fQQLAX5ZsfHyvmYUNRAdNC8"),ii=new se("LockrWmn6K5twhz3y9w1dQERbmgSaRkfnTeTKbpofwE"),ri=new se("3f7GcQFG397GAaEnv51zR6tsTVihYRydnydDD1cXekxH"),et=new se("LanMV9sAd7wArD4vJFi2qDdfnVhFxYSUg6eADduJ3uj"),qm=new se("WLHv2UAZm6z4KyaaELi5pjdbJh6RESMva1Rnn8pJVVh"),Ub=new se("DRay6fNdQ5J82H7xV6uq2aV3mNrUZ1J4PgSKsWgptcm6"),Gb=new se("5xqNaZXX5eUi4p5HU4oz9i5QnwRNT2y6oN7yyn4qENeq"),Um=new se("4Bu96XjU84XjPDSpveTVf6LYGCkfW5FK7SNkREWcEfV4"),Gm=new se("6s1xP3hpbAfFoNtUNF8mfHsjr2Bd97JxFJRWLbL6aHuX"),si={IDO_PROGRAM_ID_V1:_m,IDO_PROGRAM_ID_V2:Vm,IDO_PROGRAM_ID_V3:Em,IDO_PROGRAM_ID_V4:Wm},wt={AMM_V4:ni,AMM_STABLE:vm,CLMM_PROGRAM_ID:Fn,CLMM_LOCK_PROGRAM_ID:So,CLMM_LOCK_AUTH_ID:oi,FARM_PROGRAM_ID_V3:Ks,FARM_PROGRAM_ID_V4:Ss,FARM_PROGRAM_ID_V5:Cs,FARM_PROGRAM_ID_V6:Ko,OPEN_BOOK_PROGRAM:Rs,SERUM_PROGRAM_ID_V3:Ar,UTIL1216:Mm,Router:Fm,CREATE_CPMM_POOL_PROGRAM:Vn,CREATE_CPMM_POOL_AUTH:Os,CREATE_CPMM_POOL_FEE_ACC:Dm,LOCK_CPMM_PROGRAM:ii,LOCK_CPMM_AUTH:ri,LAUNCHPAD_PROGRAM:et,LAUNCHPAD_AUTH:qm,LAUNCHPAD_PLATFORM:Um,LAUNCHPAD_CONFIG:Gm,FEE_DESTINATION_ID:Ls,MODEL_DATA_PUBKEY:_n},kn={OPEN_BOOK_PROGRAM:new se("EoTcMgcDRTJVZDMZWBoU6rhYHZfkNTVEAfz3uUJRcYGj"),SERUM_PROGRAM_ID_V3:new se("Ray1111111111111111111111111111111111111111"),AMM_V4:new se("DRaya7Kj3aMWQSy19kSjvmuwq9docCHofyP9kanQGaav"),AMM_STABLE:new se("DRayDdXc1NZQ9C3hRWmoSf8zK4iapgMnjdNZWrfwsP8m"),CLMM_PROGRAM_ID:new se("DRayAUgENGQBKVaX8owNhgzkEDyoHTGVEGHVJT1E9pfH"),CLMM_LOCK_PROGRAM_ID:new se("DRay25Usp3YJAi7beckgpGUC7mGJ2cR1AVPxhYfwVCUX"),CLMM_LOCK_AUTH_ID:new se("6Aoh8h2Lw2m5UGxYR8AdAL87jTWYeKoxM52mJRzfYwN"),CREATE_CPMM_POOL_PROGRAM:new se("DRaycpLY18LhpbydsBWbVJtxpNv9oXPgjRSfpF2bWpYb"),CREATE_CPMM_POOL_AUTH:new se("CXniRufdq5xL8t8jZAPxsPZDpuudwuJSPWnbcD5Y5Nxq"),CREATE_CPMM_POOL_FEE_ACC:new se("3oE58BKVt8KuYkGxx8zBojugnymWmBiyafWgMrnb6eYy"),LOCK_CPMM_PROGRAM:new se("DRay25Usp3YJAi7beckgpGUC7mGJ2cR1AVPxhYfwVCUX"),LOCK_CPMM_AUTH:new se("7qWVV8UY2bRJfDLP4s37YzBPKUkVB46DStYJBpYbQzu3"),UTIL1216:se.default,Router:new se("DRaybByLpbUL57LJARs3j8BitTxVfzBg351EaMr5UTCd"),FARM_PROGRAM_ID_V3:new se("DRayWyrLmEW5KEeqs8kdTMMaBabapqagaBC7KWpGtJeZ"),FARM_PROGRAM_ID_V4:new se("Ray1111111111111111111111111111111111111111"),FARM_PROGRAM_ID_V5:new se("DRayiCGSZgku1GTK6rXD6mVDdingXy6APAH1R6R5L2LC"),FARM_PROGRAM_ID_V6:new se("DRayzbYakXs45ELHkzH6vC3fuhQqTAnv5A68gdFuvZyZ"),LAUNCHPAD_PROGRAM:new se("DRay6fNdQ5J82H7xV6uq2aV3mNrUZ1J4PgSKsWgptcm6"),LAUNCHPAD_AUTH:new se("5xqNaZXX5eUi4p5HU4oz9i5QnwRNT2y6oN7yyn4qENeq"),LAUNCHPAD_PLATFORM:new se("2Jx4KTDrVSdWNazuGpcA8n3ZLTRGGBDxAWhuKe2Xcj2a"),LAUNCHPAD_CONFIG:new se("7ZR4zD7PYfY2XxoG1Gxcy2EgEeGYrpxrwzPuwdUBssEt"),FEE_DESTINATION_ID:new se("9y8ENuuZ3b19quffx9hQvRVygG5ky6snHfRvGpuSfeJy"),MODEL_DATA_PUBKEY:new se("Ray1111111111111111111111111111111111111111")};import Ve from"bn.js";var dn=1e4;function xe(l,e,t,n){if(e===void 0)return{amount:l,fee:void 0,expirationTime:void 0};let o=q(v({},e),{olderTransferFee:{epoch:BigInt(e.olderTransferFee.epoch),maximumFee:BigInt(e.olderTransferFee.maximumFee),transferFeeBasisPoints:e.olderTransferFee.transferFeeBasisPoints},newerTransferFee:{epoch:BigInt(e.newerTransferFee.epoch),maximumFee:BigInt(e.newerTransferFee.maximumFee),transferFeeBasisPoints:e.newerTransferFee.transferFeeBasisPoints}}),r=t.epoch<o.newerTransferFee.epoch?o.olderTransferFee:o.newerTransferFee,i=new Ve(r.maximumFee.toString()),s=t.epoch<o.newerTransferFee.epoch?(Number(o.newerTransferFee.epoch)*t.slotsInEpoch-t.absoluteSlot)*400/1e3:void 0;if(n)if(r.transferFeeBasisPoints===dn){let u=new Ve(r.maximumFee.toString());return{amount:l.add(u),fee:u,expirationTime:s}}else{let u=En(l.mul(new Ve(dn)),new Ve(dn-r.transferFeeBasisPoints)),a=new Ve(r.maximumFee.toString()),c=u.sub(l).gt(a)?l.add(a):u,m=En(c.mul(new Ve(r.transferFeeBasisPoints)),new Ve(dn)),p=m.gt(i)?i:m;return{amount:c,fee:p,expirationTime:s}}else{let u=En(l.mul(new Ve(r.transferFeeBasisPoints)),new Ve(dn)),a=u.gt(i)?i:u;return{amount:l,fee:a,expirationTime:s}}}function tn(l,e){return l===void 0?e:e===void 0?l:Math.min(l,e)}function En(l,e){let{div:t,mod:n}=l.divmod(e);return n.gt(new Ve(0))?t.add(new Ve(1)):t}function to(l,e){if(l.isZero())return new Ve(0);let t=l.div(e);return t.isZero()?new Ve(1):l.mod(e).gt(new Ve(0))?t.add(new Ve(1)):t}function Ns(l,e,t){if(e===void 0)return{amount:l,fee:void 0,expirationTime:void 0};let n=Math.floor(t/432e3),o=n<e.newerTransferFee.epoch?e.olderTransferFee:e.newerTransferFee,r=new Ve(o.maximumFee.toString()),i=n<e.newerTransferFee.epoch?(Number(e.newerTransferFee.epoch)*432e3-t)*400/1e3:void 0,s=En(l.mul(new Ve(o.transferFeeBasisPoints)),new Ve(dn)),u=s.gt(r)?r:s;return{amount:l,fee:u,expirationTime:i}}function Ms(l,e,t){if(e===void 0)return{amount:l,fee:void 0,expirationTime:void 0};let n=Math.floor(t/432e3),o=n<e.newerTransferFee.epoch?e.olderTransferFee:e.newerTransferFee,r=new Ve(o.maximumFee.toString()),i=n<e.newerTransferFee.epoch?(Number(e.newerTransferFee.epoch)*432e3-t)*400/1e3:void 0;if(o.transferFeeBasisPoints===dn){let s=new Ve(o.maximumFee.toString());return{amount:l.add(s),fee:s,expirationTime:i}}else{let s=En(l.mul(new Ve(dn)),new Ve(dn-o.transferFeeBasisPoints)),u=new Ve(o.maximumFee.toString()),a=s.sub(l).gt(u)?l.add(u):s,c=En(a.mul(new Ve(o.transferFeeBasisPoints)),new Ve(dn)),m=c.gt(r)?r:c;return{amount:a,fee:m,expirationTime:i}}}import{PublicKey as vs,AddressLookupTableAccount as Ro}from"@solana/web3.js";async function wr({connection:l,address:e,cluster:t="mainnet"}){let n=await en(l,[...new Set(e.map(r=>r.toString()))].map(r=>new vs(r))),o={};for(let r=0;r<e.length;r++){let i=n[r],s=e[r];if(!i)continue;let u=new Ro({key:s,state:Ro.deserialize(i.data)});o[s.toString()]=u,t==="devnet"?Co[s.toString()]=u:Wn[s.toString()]=u}return o}var Wn={},Fs=async l=>{let e="AcL1Vo8oy1ULiavEcjSUcwfBSForXMudcZvDZy5nzJkU";if(Wn[e])return Wn;let t=new vs(e),n=await l.getAccountInfo(t);return n&&(Wn[e]=new Ro({key:t,state:Ro.deserialize(n.data)})),Wn},Co={},Tr=async l=>{let e="EFhMuDw1PKEuckuFRW9PavNfTH4LKP5uKHgyXDmWpFCq";if(Co[e])return Co;let t=new vs(e),n=await l.getAccountInfo(t);return n&&(Co[e]=new Ro({key:t,state:Ro.deserialize(n.data)})),Co};import{PublicKey as no,sendAndConfirmTransaction as _s,SystemProgram as Xm,Transaction as ai,TransactionMessage as wn,VersionedTransaction as Tn}from"@solana/web3.js";import zm from"axios";var ui=2e3,ci=class{constructor(e){this.instructions=[];this.endInstructions=[];this.lookupTableAddress=[];this.signers=[];this.instructionTypes=[];this.endInstructionTypes=[];this.connection=e.connection,this.feePayer=e.feePayer,this.signAllTransactions=e.signAllTransactions,this.owner=e.owner,this.cluster=e.cluster,this.blockhashCommitment=e.blockhashCommitment,this.loopMultiTxStatus=!!e.loopMultiTxStatus}get AllTxData(){return{instructions:this.instructions,endInstructions:this.endInstructions,signers:this.signers,instructionTypes:this.instructionTypes,endInstructionTypes:this.endInstructionTypes,lookupTableAddress:this.lookupTableAddress}}get allInstructions(){return[...this.instructions,...this.endInstructions]}async getComputeBudgetConfig(){var n;let e=(await zm.get(`https://solanacompass.com/api/fees?cacheFreshTime=${3e5}`)).data,{avg:t}=(n=e==null?void 0:e[15])!=null?n:{};if(!!t)return{units:6e5,microLamports:Math.min(Math.ceil(t*1e6/6e5),25e3)}}addCustomComputeBudget(e){if(e){let{instructions:t,instructionTypes:n}=Jo(e);return this.instructions.unshift(...t),this.instructionTypes.unshift(...n),!0}return!1}addTipInstruction(e){var t;return e?(this.endInstructions.push(Xm.transfer({fromPubkey:(t=e.feePayer)!=null?t:this.feePayer,toPubkey:new no(e.address),lamports:BigInt(e.amount.toString())})),this.endInstructionTypes.push(G.TransferTip),!0):!1}async calComputeBudget({config:e,defaultIns:t}){try{let n=e||await this.getComputeBudgetConfig();if(this.addCustomComputeBudget(n))return;t&&this.instructions.unshift(...t)}catch{t&&this.instructions.unshift(...t)}}addInstruction({instructions:e=[],endInstructions:t=[],signers:n=[],instructionTypes:o=[],endInstructionTypes:r=[],lookupTableAddress:i=[]}){return this.instructions.push(...e),this.endInstructions.push(...t),this.signers.push(...n),this.instructionTypes.push(...o),this.endInstructionTypes.push(...r),this.lookupTableAddress.push(...i.filter(s=>s!==no.default.toString())),this}async versionBuild({txVersion:e,extInfo:t}){return e===0?await this.buildV0(v({},t||{})):this.build(t)}build(e){var n;let t=new ai;return this.allInstructions.length&&t.add(...this.allInstructions),t.feePayer=this.feePayer,((n=this.owner)==null?void 0:n.signer)&&!this.signers.some(o=>o.publicKey.equals(this.owner.publicKey))&&this.signers.push(this.owner.signer),{builder:this,transaction:t,signers:this.signers,instructionTypes:[...this.instructionTypes,...this.endInstructionTypes],execute:async o=>{var c;let{recentBlockHash:r,skipPreflight:i=!0,sendAndConfirm:s,notSendToRpc:u}=o||{},a=r!=null?r:await eo(this.connection,this.blockhashCommitment);if(t.recentBlockhash=a,this.signers.length&&t.sign(...this.signers),vn([t]),(c=this.owner)!=null&&c.isKeyPair)return{txId:s?await _s(this.connection,t,this.signers.find(p=>p.publicKey.equals(this.owner.publicKey))?this.signers:[...this.signers,this.owner.signer],{skipPreflight:i}):await this.connection.sendRawTransaction(t.serialize(),{skipPreflight:i}),signedTx:t};if(this.signAllTransactions){let m=await this.signAllTransactions([t]);if(this.signers.length)for(let p of m)try{p.sign(...this.signers)}catch{}return{txId:u?"":await this.connection.sendRawTransaction(m[0].serialize(),{skipPreflight:i}),signedTx:m[0]}}throw new Error("please provide owner in keypair format or signAllTransactions function")},extInfo:e||{}}}buildMultiTx(e){var a;let{extraPreBuildData:t=[],extInfo:n}=e,{transaction:o}=this.build(n),r=t.filter(c=>c.transaction.instructions.length>0),i=[o,...r.map(c=>c.transaction)],s=[this.signers,...r.map(c=>c.signers)],u=[...this.instructionTypes,...r.map(c=>c.instructionTypes).flat()];return(a=this.owner)!=null&&a.signer&&s.forEach(c=>{c.some(m=>m.publicKey.equals(this.owner.publicKey))||this.signers.push(this.owner.signer)}),{builder:this,transactions:i,signers:s,instructionTypes:u,execute:async c=>{var g;let{sequentially:m,onTxUpdate:p,skipTxCount:d=0,recentBlockHash:f,skipPreflight:y=!0}=c||{},b=f!=null?f:await eo(this.connection,this.blockhashCommitment);if((g=this.owner)!=null&&g.isKeyPair){if(m){let P=[],h=0;for(let I of i){if(++h,h<=d)continue;let T=await _s(this.connection,I,this.signers.find(w=>w.publicKey.equals(this.owner.publicKey))?this.signers:[...this.signers,this.owner.signer],{skipPreflight:y});P.push(T)}return{txIds:P,signedTxs:i}}return{txIds:await await Promise.all(i.map(async P=>(P.recentBlockhash=b,await this.connection.sendRawTransaction(P.serialize(),{skipPreflight:y})))),signedTxs:i}}if(this.signAllTransactions){let P=i.map((I,T)=>(I.recentBlockhash=b,s[T].length&&I.sign(...s[T]),I));vn(P);let h=await this.signAllTransactions(P);if(m){let I=0,T=[],w=async()=>{if(!h[I])return;let K=await this.connection.sendRawTransaction(h[I].serialize(),{skipPreflight:y});T.push({txId:K,status:"sent",signedTx:h[I]}),p==null||p([...T]),I++;let x=!1,S=null,B=null,R=C=>{S!==null&&clearInterval(S),B!==null&&this.connection.removeSignatureListener(B);let N=T.findIndex(L=>L.txId===K);if(N>-1){if(T[N].status==="error"||T[N].status==="success")return;T[N].status=C.err?"error":"success"}p==null||p([...T]),C.err||w()};this.loopMultiTxStatus&&(S=setInterval(async()=>{var C;if(x){clearInterval(S);return}try{let N=await this.connection.getTransaction(K,{commitment:"confirmed",maxSupportedTransactionVersion:0});N&&(x=!0,clearInterval(S),R({err:((C=N.meta)==null?void 0:C.err)||null}),console.log("tx status from getTransaction:",K))}catch(N){x=!0,clearInterval(S),console.error("getTransaction timeout:",N,K)}},ui)),B=this.connection.onSignature(K,C=>{if(x){this.connection.removeSignatureListener(B);return}x=!0,R(C)},"confirmed"),this.connection.getSignatureStatus(K)};return await w(),{txIds:T.map(K=>K.txId),signedTxs:h}}else{let I=[];for(let T=0;T<h.length;T+=1){let w=await this.connection.sendRawTransaction(h[T].serialize(),{skipPreflight:y});I.push(w)}return{txIds:I,signedTxs:h}}}throw new Error("please provide owner in keypair format or signAllTransactions function")},extInfo:n||{}}}async versionMultiBuild({extraPreBuildData:e,txVersion:t,extInfo:n}){return t===0?await this.buildV0MultiTx({extraPreBuildData:e,buildProps:n||{}}):this.buildMultiTx({extraPreBuildData:e,extInfo:n})}async buildV0(e){var y;let f=e||{},{lookupTableCache:t={},lookupTableAddress:n=[],forerunCreate:o,recentBlockhash:r}=f,i=_e(f,["lookupTableCache","lookupTableAddress","forerunCreate","recentBlockhash"]),s=v(v({},this.cluster==="devnet"?await Tr(this.connection):await Fs(this.connection)),t),u=Array.from(new Set([...n,...this.lookupTableAddress])),a=[];for(let b of u)s[b]===void 0&&a.push(new no(b));let c=await wr({connection:this.connection,address:a});for(let[b,g]of Object.entries(c))s[b]=g;let m=o?no.default.toBase58():r!=null?r:await eo(this.connection,this.blockhashCommitment),p=new wn({payerKey:this.feePayer,recentBlockhash:m,instructions:[...this.allInstructions]}).compileToV0Message(Object.values(s));((y=this.owner)==null?void 0:y.signer)&&!this.signers.some(b=>b.publicKey.equals(this.owner.publicKey))&&this.signers.push(this.owner.signer);let d=new Tn(p);return d.sign(this.signers),{builder:this,transaction:d,signers:this.signers,instructionTypes:[...this.instructionTypes,...this.endInstructionTypes],execute:async b=>{var I;let{skipPreflight:g=!0,sendAndConfirm:P,notSendToRpc:h}=b||{};if(vn([d]),(I=this.owner)!=null&&I.isKeyPair){let T=await this.connection.sendTransaction(d,{skipPreflight:g});return P&&await ei(this.connection,T),{txId:T,signedTx:d}}if(this.signAllTransactions){let T=await this.signAllTransactions([d]);if(this.signers.length)for(let w of T)try{w.sign(this.signers)}catch{}return{txId:h?"":await this.connection.sendTransaction(T[0],{skipPreflight:g}),signedTx:T[0]}}throw new Error("please provide owner in keypair format or signAllTransactions function")},extInfo:i||{}}}async buildV0MultiTx(e){var a;let{extraPreBuildData:t=[],buildProps:n}=e,{transaction:o}=await this.buildV0(n),r=t.filter(c=>c.builder.instructions.length>0),i=[o,...r.map(c=>c.transaction)],s=[this.signers,...r.map(c=>c.signers)],u=[...this.instructionTypes,...r.map(c=>c.instructionTypes).flat()];return(a=this.owner)!=null&&a.signer&&s.forEach(c=>{c.some(m=>m.publicKey.equals(this.owner.publicKey))||this.signers.push(this.owner.signer)}),i.forEach(async(c,m)=>{c.sign(s[m])}),{builder:this,transactions:i,signers:s,instructionTypes:u,buildProps:n,execute:async c=>{var y;let{sequentially:m,onTxUpdate:p,recentBlockHash:d,skipPreflight:f=!0}=c||{};if(d&&i.forEach(b=>b.message.recentBlockhash=d),vn(i),(y=this.owner)!=null&&y.isKeyPair){if(m){let b=[];for(let g of i){let P=await this.connection.sendTransaction(g,{skipPreflight:f});await ei(this.connection,P),b.push(P)}return{txIds:b,signedTxs:i}}return{txIds:await Promise.all(i.map(async b=>await this.connection.sendTransaction(b,{skipPreflight:f}))),signedTxs:i}}if(this.signAllTransactions){let b=await this.signAllTransactions(i);if(m){let g=0,P=[],h=async()=>{if(!b[g])return;let I=await this.connection.sendTransaction(b[g],{skipPreflight:f});P.push({txId:I,status:"sent",signedTx:b[g]}),p==null||p([...P]),g++;let T=!1,w=null,K=null,x=S=>{w!==null&&clearInterval(w),K!==null&&this.connection.removeSignatureListener(K);let B=P.findIndex(R=>R.txId===I);if(B>-1){if(P[B].status==="error"||P[B].status==="success")return;P[B].status=S.err?"error":"success"}p==null||p([...P]),S.err||h()};this.loopMultiTxStatus&&(w=setInterval(async()=>{var S;if(T){clearInterval(w);return}try{let B=await this.connection.getTransaction(I,{commitment:"confirmed",maxSupportedTransactionVersion:0});B&&(T=!0,clearInterval(w),x({err:((S=B.meta)==null?void 0:S.err)||null}),console.log("tx status from getTransaction:",I))}catch(B){T=!0,clearInterval(w),console.error("getTransaction timeout:",B,I)}},ui)),K=this.connection.onSignature(I,S=>{if(T){this.connection.removeSignatureListener(K);return}T=!0,x(S)},"confirmed"),this.connection.getSignatureStatus(I)};return h(),{txIds:[],signedTxs:b}}else{let g=[];for(let P=0;P<b.length;P+=1){let h=await this.connection.sendTransaction(b[P],{skipPreflight:f});g.push(h)}return{txIds:g,signedTxs:b}}}throw new Error("please provide owner in keypair format or signAllTransactions function")},extInfo:n||{}}}async sizeCheckBuild(e){var p;let m=e||{},{splitIns:t=[],computeBudgetConfig:n}=m,o=_e(m,["splitIns","computeBudgetConfig"]),r=n?Jo(n):{instructions:[],instructionTypes:[]},i=this.signers.reduce((d,f)=>q(v({},d),{[f.publicKey.toBase58()]:f}),{}),s=[],u=[],a=[],c=0;if(this.allInstructions.forEach(d=>{let f=[...a,d],y=n?[...r.instructions,...f]:f,g=[...new Set(f.map(P=>P.keys.filter(h=>h.isSigner).map(h=>h.pubkey.toString())).flat()).values()].map(P=>new no(P));if(d!==t[c]&&a.length<12&&(ti({instructions:y,payer:this.feePayer,signers:g})||ti({instructions:f,payer:this.feePayer,signers:g})))a.push(d);else{if(a.length===0)throw Error("item ins too big");c+=d===t[c]?1:0,ti({instructions:n?[...r.instructions,...a]:[...a],payer:this.feePayer,signers:g})?s.push(new ai().add(...r.instructions,...a)):s.push(new ai().add(...a)),u.push(Array.from(new Set(a.map(P=>P.keys.filter(h=>h.isSigner).map(h=>h.pubkey.toString())).flat())).map(P=>i[P]).filter(P=>P!==void 0)),a=[d]}}),a.length>0){let f=[...new Set(a.map(y=>y.keys.filter(b=>b.isSigner).map(b=>b.pubkey.toString())).flat()).values()].map(y=>i[y]).filter(y=>y!==void 0);ti({instructions:n?[...r.instructions,...a]:[...a],payer:this.feePayer,signers:f.map(y=>y.publicKey)})?s.push(new ai().add(...r.instructions,...a)):s.push(new ai().add(...a)),u.push(f)}return s.forEach(d=>d.feePayer=this.feePayer),(p=this.owner)!=null&&p.signer&&u.forEach(d=>{d.some(f=>f.publicKey.equals(this.owner.publicKey))||d.push(this.owner.signer)}),{builder:this,transactions:s,signers:u,instructionTypes:this.instructionTypes,execute:async d=>{var I;let{sequentially:f,onTxUpdate:y,skipTxCount:b=0,recentBlockHash:g,skipPreflight:P=!0}=d||{},h=g!=null?g:await eo(this.connection,this.blockhashCommitment);if(s.forEach(async(T,w)=>{T.recentBlockhash=h,u[w].length&&T.sign(...u[w])}),vn(s),(I=this.owner)!=null&&I.isKeyPair){if(f){let T=0,w=[];for(let K of s){if(++T,T<=b){w.push("tx skipped");continue}let x=await _s(this.connection,K,this.signers.find(S=>S.publicKey.equals(this.owner.publicKey))?this.signers:[...this.signers,this.owner.signer],{skipPreflight:P});w.push(x)}return{txIds:w,signedTxs:s}}return{txIds:await Promise.all(s.map(async T=>await this.connection.sendRawTransaction(T.serialize(),{skipPreflight:P}))),signedTxs:s}}if(this.signAllTransactions){let T=await this.signAllTransactions(s.slice(b,s.length)),w=[...s.slice(0,b),...T];if(f){let K=0,x=[],S=async()=>{if(!w[K])return;K<b&&(x.push({txId:"",status:"success",signedTx:w[K]}),y==null||y([...x]),K++,S());let B=await this.connection.sendRawTransaction(w[K].serialize(),{skipPreflight:P});x.push({txId:B,status:"sent",signedTx:w[K]}),y==null||y([...x]),K++;let R=!1,C=null,N=null,L=O=>{C!==null&&clearInterval(C),N!==null&&this.connection.removeSignatureListener(N);let E=x.findIndex(X=>X.txId===B);if(E>-1){if(x[E].status==="error"||x[E].status==="success")return;x[E].status=O.err?"error":"success"}y==null||y([...x]),O.err||S()};this.loopMultiTxStatus&&(C=setInterval(async()=>{var O;if(R){clearInterval(C);return}try{let E=await this.connection.getTransaction(B,{commitment:"confirmed",maxSupportedTransactionVersion:0});E&&(R=!0,clearInterval(C),L({err:((O=E.meta)==null?void 0:O.err)||null}),console.log("tx status from getTransaction:",B))}catch(E){R=!0,clearInterval(C),console.error("getTransaction timeout:",E,B)}},ui)),N=this.connection.onSignature(B,O=>{if(R){this.connection.removeSignatureListener(N);return}R=!0,L(O)},"confirmed"),this.connection.getSignatureStatus(B)};return await S(),{txIds:x.map(B=>B.txId),signedTxs:w}}else{let K=[];for(let x=0;x<w.length;x+=1){let S=await this.connection.sendRawTransaction(w[x].serialize(),{skipPreflight:P});K.push(S)}return{txIds:K,signedTxs:w}}}throw new Error("please provide owner in keypair format or signAllTransactions function")},extInfo:o||{}}}async sizeCheckBuildV0(e){var h;let P=e||{},{computeBudgetConfig:t,splitIns:n=[],lookupTableCache:o={},lookupTableAddress:r=[]}=P,i=_e(P,["computeBudgetConfig","splitIns","lookupTableCache","lookupTableAddress"]),s=v(v({},this.cluster==="devnet"?await Tr(this.connection):Wn),o),u=Array.from(new Set([...this.lookupTableAddress,...r])),a=[];for(let I of u)s[I]===void 0&&a.push(new no(I));let c=await wr({connection:this.connection,address:a});for(let[I,T]of Object.entries(c))s[I]=T;let m=t?Jo(t):{instructions:[],instructionTypes:[]},p=await eo(this.connection,this.blockhashCommitment),d=this.signers.reduce((I,T)=>q(v({},I),{[T.publicKey.toBase58()]:T}),{}),f=[],y=[],b=[],g=0;if(this.allInstructions.forEach(I=>{let T=[...b,I],w=t?[...m.instructions,...T]:T;if(I!==n[g]&&b.length<12&&(An({instructions:w,payer:this.feePayer,lookupTableAddressAccount:s})||An({instructions:T,payer:this.feePayer,lookupTableAddressAccount:s})))b.push(I);else{if(b.length===0)throw Error("item ins too big");g+=I===n[g]?1:0;let K={};for(let x of[...new Set(u)])s[x]!==void 0&&(K[x]=s[x]);if(t&&An({instructions:[...m.instructions,...b],payer:this.feePayer,lookupTableAddressAccount:s,recentBlockhash:p})){let x=new wn({payerKey:this.feePayer,recentBlockhash:p,instructions:[...m.instructions,...b]}).compileToV0Message(Object.values(s));f.push(new Tn(x))}else{let x=new wn({payerKey:this.feePayer,recentBlockhash:p,instructions:[...b]}).compileToV0Message(Object.values(s));f.push(new Tn(x))}y.push(Array.from(new Set(b.map(x=>x.keys.filter(S=>S.isSigner).map(S=>S.pubkey.toString())).flat())).map(x=>d[x]).filter(x=>x!==void 0)),b=[I]}}),b.length>0){let T=[...new Set(b.map(w=>w.keys.filter(K=>K.isSigner).map(K=>K.pubkey.toString())).flat()).values()].map(w=>d[w]).filter(w=>w!==void 0);if(t&&An({instructions:[...m.instructions,...b],payer:this.feePayer,lookupTableAddressAccount:s,recentBlockhash:p})){let w=new wn({payerKey:this.feePayer,recentBlockhash:p,instructions:[...m.instructions,...b]}).compileToV0Message(Object.values(s));f.push(new Tn(w))}else{let w=new wn({payerKey:this.feePayer,recentBlockhash:p,instructions:[...b]}).compileToV0Message(Object.values(s));f.push(new Tn(w))}y.push(T)}return(h=this.owner)!=null&&h.signer&&y.forEach(I=>{I.some(T=>T.publicKey.equals(this.owner.publicKey))||I.push(this.owner.signer)}),f.forEach((I,T)=>{I.sign(y[T])}),{builder:this,transactions:f,buildProps:e,signers:y,blockHash:p,instructionTypes:this.instructionTypes,execute:async I=>{var B;let{sequentially:T,onTxUpdate:w,skipTxCount:K=0,recentBlockHash:x,skipPreflight:S=!0}=I||{};if(f.map(async(R,C)=>{y[C].length&&R.sign(y[C]),x&&(R.message.recentBlockhash=x)}),vn(f),(B=this.owner)!=null&&B.isKeyPair){if(T){let R=0,C=[];for(let N of f){if(++R,R<=K){console.log("skip tx: ",R),C.push("tx skipped");continue}let L=await this.connection.sendTransaction(N,{skipPreflight:S});await ei(this.connection,L),C.push(L)}return{txIds:C,signedTxs:f}}return{txIds:await Promise.all(f.map(async R=>await this.connection.sendTransaction(R,{skipPreflight:S}))),signedTxs:f}}if(this.signAllTransactions){let R=await this.signAllTransactions(f.slice(K,f.length)),C=[...f.slice(0,K),...R];if(T){let N=0,L=[],O=async()=>{if(!C[N])return;if(N<K){L.push({txId:"",status:"success",signedTx:C[N]}),w==null||w([...L]),N++,O();return}let E=await this.connection.sendTransaction(C[N],{skipPreflight:S});L.push({txId:E,status:"sent",signedTx:C[N]}),w==null||w([...L]),N++;let X=!1,Y=null,j=null,de=re=>{Y!==null&&clearInterval(Y),j!==null&&this.connection.removeSignatureListener(j);let ce=L.findIndex(ye=>ye.txId===E);if(ce>-1){if(L[ce].status==="error"||L[ce].status==="success")return;L[ce].status=re.err?"error":"success"}w==null||w([...L]),re.err||O()};this.loopMultiTxStatus&&(Y=setInterval(async()=>{var re;if(X){clearInterval(Y);return}try{let ce=await this.connection.getTransaction(E,{commitment:"confirmed",maxSupportedTransactionVersion:0});ce&&(X=!0,clearInterval(Y),de({err:((re=ce.meta)==null?void 0:re.err)||null}),console.log("tx status from getTransaction:",E))}catch(ce){X=!0,clearInterval(Y),console.error("getTransaction timeout:",ce,E)}},ui)),j=this.connection.onSignature(E,re=>{if(X){this.connection.removeSignatureListener(j);return}X=!0,de(re)},"confirmed"),this.connection.getSignatureStatus(E)};return O(),{txIds:[],signedTxs:C}}else{let N=[];for(let L=0;L<C.length;L+=1){let O=await this.connection.sendTransaction(C[L],{skipPreflight:S});N.push(O)}return{txIds:N,signedTxs:C}}}throw new Error("please provide owner in keypair format or signAllTransactions function")},extInfo:i||{}}}async buildSniperTransaction(e){var h;let P=e||{},{computeBudgetConfig:t,splitIns:n=[],lookupTableCache:o={},lookupTableAddress:r=[]}=P,i=_e(P,["computeBudgetConfig","splitIns","lookupTableCache","lookupTableAddress"]),s=v(v({},this.cluster==="devnet"?await Tr(this.connection):await Fs(this.connection)),o),u=Array.from(new Set([...this.lookupTableAddress,...r])),a=[];for(let I of u)s[I]===void 0&&a.push(new no(I));let c=await wr({connection:this.connection,address:a});for(let[I,T]of Object.entries(c))s[I]=T;let m=t?Jo(t):{instructions:[],instructionTypes:[]},p=await eo(this.connection,this.blockhashCommitment),d=this.signers.reduce((I,T)=>q(v({},I),{[T.publicKey.toBase58()]:T}),{}),f=[],y=[],b=[],g=0;if(this.allInstructions.forEach(I=>{let T=[...b,I],w=t?[...m.instructions,...T]:T;if(I!==n[g]&&b.length<12&&(An({instructions:w,payer:this.feePayer,lookupTableAddressAccount:s})||An({instructions:T,payer:this.feePayer,lookupTableAddressAccount:s})))b.push(I);else{if(b.length===0)throw Error("item ins too big");g+=I===n[g]?1:0;let K={};for(let x of[...new Set(u)])s[x]!==void 0&&(K[x]=s[x]);if(t&&An({instructions:[...m.instructions,...b],payer:this.feePayer,lookupTableAddressAccount:s,recentBlockhash:p})){let x=new wn({payerKey:this.feePayer,recentBlockhash:p,instructions:[...m.instructions,...b]}).compileToV0Message(Object.values(s));f.push(new Tn(x))}else{let x=new wn({payerKey:this.feePayer,recentBlockhash:p,instructions:[...b]}).compileToV0Message(Object.values(s));f.push(new Tn(x))}y.push(Array.from(new Set(b.map(x=>x.keys.filter(S=>S.isSigner).map(S=>S.pubkey.toString())).flat())).map(x=>d[x]).filter(x=>x!==void 0)),b=[I]}}),b.length>0){let T=[...new Set(b.map(w=>w.keys.filter(K=>K.isSigner).map(K=>K.pubkey.toString())).flat()).values()].map(w=>d[w]).filter(w=>w!==void 0);if(t&&An({instructions:[...m.instructions,...b],payer:this.feePayer,lookupTableAddressAccount:s,recentBlockhash:p})){let w=new wn({payerKey:this.feePayer,recentBlockhash:p,instructions:[...m.instructions,...b]}).compileToV0Message(Object.values(s));f.push(new Tn(w))}else{let w=new wn({payerKey:this.feePayer,recentBlockhash:p,instructions:[...b]}).compileToV0Message(Object.values(s));f.push(new Tn(w))}y.push(T)}return(h=this.owner)!=null&&h.signer&&y.forEach(I=>{I.some(T=>T.publicKey.equals(this.owner.publicKey))||I.push(this.owner.signer)}),f.forEach((I,T)=>{I.sign(y[T])}),{builder:this,transactions:f,buildProps:e,signers:y,instructionTypes:this.instructionTypes,execute:async I=>{var B;let{sequentially:T,onTxUpdate:w,skipTxCount:K=0,recentBlockHash:x,skipPreflight:S=!0}=I||{};if(f.map(async(R,C)=>{y[C].length&&R.sign(y[C]),x&&(R.message.recentBlockhash=x)}),vn(f),(B=this.owner)!=null&&B.isKeyPair){if(T){let R=0,C=[];for(let N of f){if(++R,R<=K){console.log("skip tx: ",R),C.push("tx skipped");continue}let L=await this.connection.sendTransaction(N,{skipPreflight:S});await ei(this.connection,L),C.push(L)}return{txIds:C,signedTxs:f}}return{txIds:await Promise.all(f.map(async R=>await this.connection.sendTransaction(R,{skipPreflight:S}))),signedTxs:f}}if(this.signAllTransactions){let R=await this.signAllTransactions(f.slice(K,f.length)),C=[...f.slice(0,K),...R];if(T){let N=0,L=[],O=async()=>{if(!C[N])return;if(N<K){L.push({txId:"",status:"success",signedTx:C[N]}),w==null||w([...L]),N++,O();return}let E=await this.connection.sendTransaction(C[N],{skipPreflight:S});L.push({txId:E,status:"sent",signedTx:C[N]}),w==null||w([...L]),N++;let X=!1,Y=null,j=null,de=re=>{Y!==null&&clearInterval(Y),j!==null&&this.connection.removeSignatureListener(j);let ce=L.findIndex(ye=>ye.txId===E);if(ce>-1){if(L[ce].status==="error"||L[ce].status==="success")return;L[ce].status=re.err?"error":"success"}w==null||w([...L]),re.err||O()};this.loopMultiTxStatus&&(Y=setInterval(async()=>{var re;if(X){clearInterval(Y);return}try{let ce=await this.connection.getTransaction(E,{commitment:"confirmed",maxSupportedTransactionVersion:0});ce&&(X=!0,clearInterval(Y),de({err:((re=ce.meta)==null?void 0:re.err)||null}),console.log("tx status from getTransaction:",E))}catch(ce){X=!0,clearInterval(Y),console.error("getTransaction timeout:",ce,E)}},ui)),j=this.connection.onSignature(E,re=>{if(X){this.connection.removeSignatureListener(j);return}X=!0,de(re)},"confirmed"),this.connection.getSignatureStatus(E)};return O(),{txIds:[],signedTxs:C}}else{let N=[];for(let L=0;L<C.length;L+=1){let O=await this.connection.sendTransaction(C[L],{skipPreflight:S});N.push(O)}return{txIds:N,signedTxs:C}}}throw new Error("please provide owner in keypair format or signAllTransactions function")},extInfo:i||{}}}};import{PublicKey as Ym}from"@solana/web3.js";import Qm from"bn.js";function Hm(l){return typeof l=="object"&&l!==null&&![Xe,Se,Ym,Be,Qm,Kt,st].some(e=>typeof e=="object"&&l instanceof e)}function Ee(l){return typeof l=="string"?ws(l):Array.isArray(l)?l.map(e=>Ee(e)):Hm(l)?Object.fromEntries(Object.entries(l).map(([e,t])=>[e,Ee(t)])):l}import jm from"bn.js";var Ct=new jm(1e6);var at={BASE_HOST:"https://api-v3.raydium.io",OWNER_BASE_HOST:"https://owner-v1.raydium.io",SERVICE_BASE_HOST:"https://service.raydium.io",MONITOR_BASE_HOST:"https://monitor.raydium.io",SERVICE_1_BASE_HOST:"https://service-v1.raydium.io",SEND_TRANSACTION:"/send-transaction",FARM_ARP:"/main/farm/info",FARM_ARP_LINE:"/main/farm-apr-tv",CLMM_CONFIG:"/main/clmm-config",CPMM_CONFIG:"/main/cpmm-config",VERSION:"/main/version",CHECK_AVAILABILITY:"/v3/main/AvailabilityCheckAPI",RPCS:"/main/rpcs",INFO:"/main/info",STAKE_POOLS:"/main/stake-pools",CHAIN_TIME:"/main/chain-time",TOKEN_LIST:"/mint/list",MINT_INFO_ID:"/mint/ids",JUP_TOKEN_LIST:"https://lite-api.jup.ag/tokens/v1/tagged/verified",POOL_LIST:"/pools/info/list",POOL_SEARCH_BY_ID:"/pools/info/ids",POOL_SEARCH_MINT:"/pools/info/mint",POOL_SEARCH_LP:"/pools/info/lps",POOL_KEY_BY_ID:"/pools/key/ids",POOL_LIQUIDITY_LINE:"/pools/line/liquidity",POOL_POSITION_LINE:"/pools/line/position",FARM_INFO:"/farms/info/ids",FARM_LP_INFO:"/farms/info/lp",FARM_KEYS:"/farms/key/ids",OWNER_CREATED_FARM:"/create-pool/{owner}",OWNER_IDO:"/main/ido/{owner}",OWNER_STAKE_FARMS:"/position/stake/{owner}",OWNER_LOCK_POSITION:"/position/clmm-lock/{owner}",IDO_KEYS:"/ido/key/ids",SWAP_HOST:"https://transaction-v1.raydium.io",SWAP_COMPUTE:"/compute/",SWAP_TX:"/transaction/",MINT_PRICE:"/mint/price",MIGRATE_CONFIG:"/main/migrate-lp",PRIORITY_FEE:"/main/auto-fee",CPMM_LOCK:"https://dynamic-ipfs.raydium.io/lock/cpmm/position"},Vg=v({},at);var Qu="ray_tab_hash",Vs="ray_req_hash",$m=()=>{if(typeof window===void 0)return"";let l=sessionStorage.getItem(Qu);return l||(l=`ray-${Date.now()}`,sessionStorage.setItem(Qu,l)),l},hr=async n=>{var o=n,{logCount:l=1e3,removeLastLog:e}=o,t=_e(o,["logCount","removeLastLog"]);if(typeof window===void 0)return new Promise(i=>i());let r=JSON.parse(localStorage.getItem(Vs)||"[]").slice(0,l-1);e&&r.pop(),new Blob([JSON.stringify(t.data)]).size>1024&&(t.data=JSON.stringify(t.data).substring(0,200)+"..."),r.unshift(q(v({},t),{time:Date.now(),session:$m()}));try{localStorage.setItem(Vs,JSON.stringify(r))}catch{if(e){let i=!1,s=JSON.stringify(t.data).substring(0,100);for(r[0].data=s+(s.length>100?"...":"");!i;){r.pop();let u=JSON.stringify(t.data).substring(0,100);r[0].data=u+(u.length>100?"...":"");try{localStorage.setItem(Vs,JSON.stringify(r)),i=!0}catch{i=!1}}return new Promise(u=>u())}return hr(q(v({},t),{logCount:l,removeLastLog:!0}))}};import{TOKEN_2022_PROGRAM_ID as Zm,TOKEN_PROGRAM_ID as Jm}from"@solana/spl-token";var Ir=be("Raydium_Api"),Es=new Map;var Br=class{constructor({cluster:e,timeout:t,logRequests:n,logCount:o,urlConfigs:r}){this.cluster=e,this.urlConfigs=r||{},this.logCount=o||1e3,this.api=Hu.create({baseURL:this.urlConfigs.BASE_HOST||at.BASE_HOST,timeout:t}),this.api.interceptors.request.use(i=>{let{method:s,baseURL:u,url:a}=i;return Ir.debug(`${s==null?void 0:s.toUpperCase()} ${u}${a}`),i},i=>(Ir.error("Request failed"),Promise.reject(i))),this.api.interceptors.response.use(i=>{let{config:s,data:u,status:a}=i,{method:c,baseURL:m,url:p}=s;return n&&hr({status:a,url:`${m}${p}`,params:s.params,data:u,logCount:this.logCount}),Ir.debug(`${c==null?void 0:c.toUpperCase()} ${m}${p}  ${a}`),u},i=>{let{config:s,response:u={}}=i,{status:a}=u,{method:c,baseURL:m,url:p}=s;return n&&hr({status:a,url:`${m}${p}`,params:s.params,data:i.message,logCount:this.logCount}),Ir.error(`${c.toUpperCase()} ${m}${p} ${a||i.message}`),Promise.reject(i)})}async getClmmConfigs(){return(await this.api.get(this.urlConfigs.CLMM_CONFIG||at.CLMM_CONFIG)).data}async getCpmmConfigs(){return(await this.api.get(this.urlConfigs.CPMM_CONFIG||at.CPMM_CONFIG)).data}async getClmmPoolLines(e){return(await this.api.get(`${this.urlConfigs.POOL_LIQUIDITY_LINE||at.POOL_LIQUIDITY_LINE}?pool_id=${e}`)).data}async getBlockSlotCountForSecond(e){if(!e)return 2;let n=(await Hu.post(e,{id:"getRecentPerformanceSamples",jsonrpc:"2.0",method:"getRecentPerformanceSamples",params:[4]})).result.map(o=>o.numSlots);return n.reduce((o,r)=>o+r,0)/n.length/60}async getChainTimeOffset(){return(await this.api.get(this.urlConfigs.CHAIN_TIME||at.CHAIN_TIME)).data}async getRpcs(){return this.api.get(this.urlConfigs.RPCS||at.RPCS)}async getTokenList(){return(await this.api.get(this.urlConfigs.TOKEN_LIST||at.TOKEN_LIST)).data}async getJupTokenList(){return(await this.api.get("",{baseURL:this.urlConfigs.JUP_TOKEN_LIST||at.JUP_TOKEN_LIST})).map(t=>q(v({},t),{chainId:101,programId:t.tags.includes("token-2022")?Zm.toBase58():Jm.toBase58()}))}async getTokenInfo(e){return(await this.api.get((this.urlConfigs.MINT_INFO_ID||at.MINT_INFO_ID)+`?mints=${e.map(n=>n.toString()).join(",")}`)).data}async getPoolList(e={}){let{type:t="all",sort:n="liquidity",order:o="desc",page:r=0,pageSize:i=100}=e;return(await this.api.get((this.urlConfigs.POOL_LIST||at.POOL_LIST)+`?poolType=${t}&poolSortField=${n}&sortType=${o}&page=${r}&pageSize=${i}`)).data}async fetchPoolById(e){let{ids:t}=e;return(await this.api.get((this.urlConfigs.POOL_SEARCH_BY_ID||at.POOL_SEARCH_BY_ID)+`?ids=${t}`)).data}async fetchPoolKeysById(e){let{idList:t}=e,n=[],o=t.filter(i=>Es.has(i)?(n.push(Es.get(i)),!1):!0),r=[];return o.length&&(r=(await this.api.get((this.urlConfigs.POOL_KEY_BY_ID||at.POOL_KEY_BY_ID)+`?ids=${o.join(",")}`)).data.filter(Boolean),r.forEach(s=>{Es.set(s.id,s)})),n.concat(r)}async fetchPoolByMints(e){let{mint1:t,mint2:n,type:o="all",sort:r="default",order:i="desc",page:s=1}=e,[u,a]=[t&&ft(t).toBase58(),n&&n!=="undefined"?ft(n).toBase58():""],[c,m]=a&&u>a?[a,u]:[u,a];return(await this.api.get((this.urlConfigs.POOL_SEARCH_MINT||at.POOL_SEARCH_MINT)+`?mint1=${c}&mint2=${m}&poolType=${o}&poolSortField=${r}&sortType=${i}&pageSize=100&page=${s}`)).data}async fetchFarmInfoById(e){let{ids:t}=e;return(await this.api.get((this.urlConfigs.FARM_INFO||at.FARM_INFO)+`?ids=${t}`)).data}async fetchFarmKeysById(e){let{ids:t}=e;return(await this.api.get((this.urlConfigs.FARM_KEYS||at.FARM_KEYS)+`?ids=${t}`)).data}async fetchAvailabilityStatus(){return(await this.api.get(this.urlConfigs.CHECK_AVAILABILITY||at.CHECK_AVAILABILITY)).data}};var xr="please provide owner in load() initialization or you can set by calling raydium.setOwner(owner)",ju="please provide connection in load() initialization or set it by raydium.setConnection(connection)";import{PublicKey as Or,SystemProgram as Rd}from"@solana/web3.js";import{AccountLayout as No,createAssociatedTokenAccountIdempotentInstruction as js,TOKEN_PROGRAM_ID as Gn,TOKEN_2022_PROGRAM_ID as Ld}from"@solana/spl-token";var Ws=(...l)=>l.map(e=>{try{return typeof e=="object"?JSON.stringify(e):e}catch{return e}}).join(", "),We=class{constructor({scope:e,moduleName:t}){this.disabled=!1;this.scope=e,this.logger=be(t)}createTxBuilder(e){return this.scope.checkOwner(),new ci({connection:this.scope.connection,feePayer:e||this.scope.ownerPubKey,cluster:this.scope.cluster,owner:this.scope.owner,blockhashCommitment:this.scope.blockhashCommitment,loopMultiTxStatus:this.scope.loopMultiTxStatus,api:this.scope.api,signAllTransactions:this.scope.signAllTransactions})}createSniperTxBuilder(e,t){let n=new Ft(e);return new ci({connection:this.scope.connection,feePayer:t,cluster:this.scope.cluster,owner:n,blockhashCommitment:this.scope.blockhashCommitment,loopMultiTxStatus:this.scope.loopMultiTxStatus,api:this.scope.api,signAllTransactions:this.scope.signAllTransactions})}logDebug(...e){this.logger.debug(Ws(e))}logInfo(...e){this.logger.info(Ws(e))}logAndCreateError(...e){let t=Ws(e);throw new Error(t)}checkDisabled(){(this.disabled||!this.scope)&&this.logAndCreateError("module not working")}};import{PublicKey as Id,SystemProgram as Bd}from"@solana/web3.js";import xd from"bn.js";import{createCloseAccountInstruction as Kd,createInitializeAccountInstruction as Sd,createTransferInstruction as Cd,TOKEN_PROGRAM_ID as Oo}from"@solana/spl-token";import{Keypair as kd,PublicKey as mc}from"@solana/web3.js";import wd from"bn.js";import{TOKEN_PROGRAM_ID as Td}from"@solana/spl-token";function ed(l){return l instanceof Uint8Array||l!=null&&typeof l=="object"&&l.constructor.name==="Uint8Array"}function Ds(l,...e){if(!ed(l))throw new Error("Uint8Array expected");if(e.length>0&&!e.includes(l.length))throw new Error(`Uint8Array expected of length ${e}, not of length=${l.length}`)}function qs(l,e=!0){if(l.destroyed)throw new Error("Hash instance has been destroyed");if(e&&l.finished)throw new Error("Hash#digest() has already been called")}function $u(l,e){Ds(l);let t=e.outputLen;if(l.length<t)throw new Error(`digestInto() expects output buffer of length at least ${t}`)}var Sr=l=>new DataView(l.buffer,l.byteOffset,l.byteLength),nn=(l,e)=>l<<32-e|l>>>e;var hP=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;function td(l){if(typeof l!="string")throw new Error(`utf8ToBytes expected string, got ${typeof l}`);return new Uint8Array(new TextEncoder().encode(l))}function Us(l){return typeof l=="string"&&(l=td(l)),Ds(l),l}var Kr=class{clone(){return this._cloneInto()}},IP={}.toString;function Zu(l){let e=n=>l().update(Us(n)).digest(),t=l();return e.outputLen=t.outputLen,e.blockLen=t.blockLen,e.create=()=>l(),e}function nd(l,e,t,n){if(typeof l.setBigUint64=="function")return l.setBigUint64(e,t,n);let o=BigInt(32),r=BigInt(4294967295),i=Number(t>>o&r),s=Number(t&r),u=n?4:0,a=n?0:4;l.setUint32(e+u,i,n),l.setUint32(e+a,s,n)}var Ju=(l,e,t)=>l&e^~l&t,ec=(l,e,t)=>l&e^l&t^e&t,Cr=class extends Kr{constructor(e,t,n,o){super(),this.blockLen=e,this.outputLen=t,this.padOffset=n,this.isLE=o,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(e),this.view=Sr(this.buffer)}update(e){qs(this);let{view:t,buffer:n,blockLen:o}=this;e=Us(e);let r=e.length;for(let i=0;i<r;){let s=Math.min(o-this.pos,r-i);if(s===o){let u=Sr(e);for(;o<=r-i;i+=o)this.process(u,i);continue}n.set(e.subarray(i,i+s),this.pos),this.pos+=s,i+=s,this.pos===o&&(this.process(t,0),this.pos=0)}return this.length+=e.length,this.roundClean(),this}digestInto(e){qs(this),$u(e,this),this.finished=!0;let{buffer:t,view:n,blockLen:o,isLE:r}=this,{pos:i}=this;t[i++]=128,this.buffer.subarray(i).fill(0),this.padOffset>o-i&&(this.process(n,0),i=0);for(let m=i;m<o;m++)t[m]=0;nd(n,o-8,BigInt(this.length*8),r),this.process(n,0);let s=Sr(e),u=this.outputLen;if(u%4)throw new Error("_sha2: outputLen should be aligned to 32bit");let a=u/4,c=this.get();if(a>c.length)throw new Error("_sha2: outputLen bigger than state");for(let m=0;m<a;m++)s.setUint32(4*m,c[m],r)}digest(){let{buffer:e,outputLen:t}=this;this.digestInto(e);let n=e.slice(0,t);return this.destroy(),n}_cloneInto(e){e||(e=new this.constructor),e.set(...this.get());let{blockLen:t,buffer:n,length:o,finished:r,destroyed:i,pos:s}=this;return e.length=o,e.pos=s,e.finished=r,e.destroyed=i,o%t&&e.buffer.set(n),e}};var od=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),Dn=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),qn=new Uint32Array(64),Gs=class extends Cr{constructor(){super(64,32,8,!1),this.A=Dn[0]|0,this.B=Dn[1]|0,this.C=Dn[2]|0,this.D=Dn[3]|0,this.E=Dn[4]|0,this.F=Dn[5]|0,this.G=Dn[6]|0,this.H=Dn[7]|0}get(){let{A:e,B:t,C:n,D:o,E:r,F:i,G:s,H:u}=this;return[e,t,n,o,r,i,s,u]}set(e,t,n,o,r,i,s,u){this.A=e|0,this.B=t|0,this.C=n|0,this.D=o|0,this.E=r|0,this.F=i|0,this.G=s|0,this.H=u|0}process(e,t){for(let m=0;m<16;m++,t+=4)qn[m]=e.getUint32(t,!1);for(let m=16;m<64;m++){let p=qn[m-15],d=qn[m-2],f=nn(p,7)^nn(p,18)^p>>>3,y=nn(d,17)^nn(d,19)^d>>>10;qn[m]=y+qn[m-7]+f+qn[m-16]|0}let{A:n,B:o,C:r,D:i,E:s,F:u,G:a,H:c}=this;for(let m=0;m<64;m++){let p=nn(s,6)^nn(s,11)^nn(s,25),d=c+p+Ju(s,u,a)+od[m]+qn[m]|0,y=(nn(n,2)^nn(n,13)^nn(n,22))+ec(n,o,r)|0;c=a,a=u,u=s,s=i+d|0,i=r,r=o,o=n,n=d+y|0}n=n+this.A|0,o=o+this.B|0,r=r+this.C|0,i=i+this.D|0,s=s+this.E|0,u=u+this.F|0,a=a+this.G|0,c=c+this.H|0,this.set(n,o,r,i,s,u,a,c)}roundClean(){qn.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}};var tc=Zu(()=>new Gs);import{PublicKey as bd}from"@solana/web3.js";import sc,{isBN as ac}from"bn.js";import{bits as id,BitStructure as NP,blob as rd,Blob as MP,cstr as vP,f32 as FP,f32be as _P,f64 as VP,f64be as EP,greedy as WP,Layout as sd,ns64 as DP,ns64be as qP,nu64 as ad,nu64be as UP,offset as ud,s16 as GP,s16be as XP,s24 as zP,s24be as YP,s32 as cd,s32be as QP,s40 as HP,s40be as jP,s48 as $P,s48be as ZP,s8 as JP,seq as ld,struct as eA,Structure as md,u16 as dd,u16be as tA,u24 as nA,u24be as oA,u32 as pd,u32be as iA,u40 as rA,u40be as sA,u48 as aA,u48be as uA,u8 as fd,UInt as yd,union as cA,Union as lA,unionLayoutDiscriminator as mA,utf8 as dA}from"@solana/buffer-layout";var Rr=sd,nc=md;var Xs=yd;var oc=fd,_t=dd;var li=pd;var ic=ad;var De=cd;var rc=ld;var Te=rd;var zs=id,Ys=ud;var io=class extends Rr{constructor(t,n,o){super(t,o);this.blob=Te(t),this.signed=n}decode(t,n=0){let o=new sc(this.blob.decode(t,n),10,"le");return this.signed?o.fromTwos(this.span*8).clone():o}encode(t,n,o=0){return typeof t=="number"&&(t=new sc(t)),this.signed&&(t=t.toTwos(this.span*8)),this.blob.encode(t.toArrayLike(Buffer,"le",this.span),n,o)}},Lr=class extends Rr{constructor(t){super(8,t);this._lower=zs(li(),!1),this._upper=zs(li(),!1)}addBoolean(t){this._lower.fields.length<32?this._lower.addBoolean(t):this._upper.addBoolean(t)}decode(t,n=0){let o=this._lower.decode(t,n),r=this._upper.decode(t,n+this._lower.span);return v(v({},o),r)}encode(t,n,o=0){return this._lower.encode(t,n,o)+this._upper.encode(t,n,o+this._lower.span)}};function V(l){return new Xs(1,l)}function ct(l){return new Xs(4,l)}function A(l){return new io(8,!1,l)}function ie(l){return new io(16,!1,l)}function uc(l){return new io(1,!0,l)}function Lo(l){return new io(8,!0,l)}function cc(l){return new io(16,!0,l)}var ro=class extends Rr{constructor(t,n,o,r){super(t.span,r);this.layout=t,this.decoder=n,this.encoder=o}decode(t,n){return this.decoder(this.layout.decode(t,n))}encode(t,n,o){return this.layout.encode(this.encoder(t),n,o)}getSpan(t,n){return this.layout.getSpan(t,n)}};function M(l){return new ro(Te(32),e=>new bd(e),e=>e.toBuffer(),l)}function qe(l){return new ro(oc(),gd,Pd,l)}function gd(l){if(l===0)return!1;if(l===1)return!0;throw new Error("Invalid bool: "+l)}function Pd(l){return l?1:0}function lc(l,e){let t=li("length"),n=F([t,Q(l,Ys(t,-t.span),"values")]);return new ro(n,({values:o})=>o,o=>({values:o}),e)}function Ad(l){let e=li("length"),t=F([e,Te(Ys(e,-e.span),"data")]);return new ro(t,({data:n})=>n,n=>({data:n}),l)}function lt(l){return new ro(Ad(),e=>e.toString("utf-8"),e=>Buffer.from(e,"utf-8"),l)}var Qs=class extends nc{decode(e,t){return super.decode(e,t)}};function F(l,e,t){return new Qs(l,e,t)}function Q(l,e,t){let n,o=typeof e=="number"?e:ac(e)?e.toNumber():new Proxy(e,{get(r,i){if(!n){let s=Reflect.get(r,"count");n=ac(s)?s.toNumber():s,Reflect.set(r,"count",n)}return Reflect.get(r,i)},set(r,i,s){return i==="count"&&(n=s),Reflect.set(r,i,s)}});return rc(l,o,t)}var on=F([M("mint"),M("owner"),A("amount"),ct("delegateOption"),M("delegate"),V("state"),ct("isNativeOption"),A("isNative"),A("delegatedAmount"),ct("closeAuthorityOption"),M("closeAuthority")]);var NA=be("Raydium_Util");function dc({owner:l,solAccountResp:e,tokenAccountResp:t}){let n=[],o=[];for(let{pubkey:r,account:i}of t.value){let s=on.decode(i.data),{mint:u,amount:a}=s;n.push({publicKey:r,mint:u,amount:a,isAssociated:$(l,u,i.owner).publicKey.equals(r),isNative:!1,programId:i.owner}),o.push({pubkey:r,accountInfo:s,programId:i.owner})}return e&&n.push({mint:mc.default,amount:new wd(String(e.lamports)),isNative:!0,programId:e.owner}),{tokenAccounts:n,tokenAccountRawInfos:o}}function He({fromPublicKey:l,programId:e=Td,assignSeed:t}){let n=t?btoa(t).slice(0,32):kd.generate().publicKey.toBase58().slice(0,32);return{publicKey:hd(l,n,e),seed:n}}function hd(l,e,t){let n=Buffer.concat([l.toBuffer(),Buffer.from(e),t.toBuffer()]),o=tc(n);return new mc(o)}function Hs(l){let{mint:e,tokenAccount:t,owner:n,programId:o=Oo}=l;return Sd(t,e,n,o)}function hn(l){let{tokenAccount:e,payer:t,multiSigners:n=[],owner:o,programId:r=Oo}=l;return Kd(e,t,o,n,r)}async function Un(l){let{connection:e,amount:t,commitment:n,payer:o,owner:r,skipCloseAccount:i}=l,s=await e.getMinimumBalanceForRentExemption(on.span,n),u=ne(t).add(new xd(s)),a=He({fromPublicKey:o,programId:Oo});return{addresses:{newAccount:a.publicKey},signers:[],instructions:[Bd.createAccountWithSeed({fromPubkey:o,basePubkey:o,seed:a.seed,newAccountPubkey:a.publicKey,lamports:u.toNumber(),space:on.span,programId:Oo}),Hs({mint:new Id(it.address),tokenAccount:a.publicKey,owner:r,programId:Oo})],instructionTypes:[G.CreateAccount,G.InitAccount],endInstructionTypes:i?[]:[G.CloseAccount],endInstructions:i?[]:[hn({tokenAccount:a.publicKey,payer:o,owner:r})]}}function pc({source:l,destination:e,owner:t,amount:n,multiSigners:o=[],tokenProgram:r=Oo}){return Cd(l,e,t,BigInt(String(n)),o,r)}var mi=class extends We{constructor(t){super(t);this._tokenAccounts=[];this._tokenAccountRawInfos=[];this._accountListener=[];this._clientOwnedToken=!1;this._notSubscribeAccountChange=!1;this._accountFetchTime=0;let{tokenAccounts:n,tokenAccountRawInfos:o,notSubscribeAccountChange:r}=t;this._tokenAccounts=n||[],this._tokenAccountRawInfos=o||[],this._notSubscribeAccountChange=r!=null?r:!0,this._clientOwnedToken=!!(n||o)}get tokenAccounts(){return this._tokenAccounts}get tokenAccountRawInfos(){return this._tokenAccountRawInfos}set notSubscribeAccountChange(t){this._notSubscribeAccountChange=t}updateTokenAccount({tokenAccounts:t,tokenAccountRawInfos:n}){return t&&(this._tokenAccounts=t),n&&(this._tokenAccountRawInfos=n),this._accountChangeListenerId&&this.scope.connection.removeAccountChangeListener(this._accountChangeListenerId),this._accountChangeListenerId=void 0,this._clientOwnedToken=!0,this}addAccountChangeListener(t){return this._accountListener.push(t),this}removeAccountChangeListener(t){return this._accountListener=this._accountListener.filter(n=>n!==t),this}getAssociatedTokenAccount(t,n){return $(this.scope.ownerPubKey,t,n).publicKey}getAssociatedTokenAccountByOwner(t,n,o){return $(t,n,o).publicKey}resetTokenAccounts(){this._clientOwnedToken||(this._tokenAccounts=[],this._tokenAccountRawInfos=[])}async fetchWalletTokenAccounts(t){if(this._clientOwnedToken||!(t!=null&&t.forceUpdate)&&this._tokenAccounts.length&&Date.now()-this._accountFetchTime<(this._notSubscribeAccountChange?1e3*5:1e3*60*3))return{tokenAccounts:this._tokenAccounts,tokenAccountRawInfos:this._tokenAccountRawInfos};this.scope.checkOwner();let o=v(v({},{}),t),[r,i,s]=await Promise.all([this.scope.connection.getAccountInfo(this.scope.ownerPubKey,o.commitment),this.scope.connection.getTokenAccountsByOwner(this.scope.ownerPubKey,{programId:Gn},o.commitment),this.scope.connection.getTokenAccountsByOwner(this.scope.ownerPubKey,{programId:Ld},o.commitment)]),{tokenAccounts:u,tokenAccountRawInfos:a}=dc({owner:this.scope.ownerPubKey,solAccountResp:r,tokenAccountResp:{context:i.context,value:[...i.value,...s.value]}});return this._tokenAccounts=u,this._tokenAccountRawInfos=a,this._accountFetchTime=Date.now(),this._notSubscribeAccountChange||(this._accountChangeListenerId&&this.scope.connection.removeAccountChangeListener(this._accountChangeListenerId),this._accountChangeListenerId=this.scope.connection.onAccountChange(this.scope.ownerPubKey,()=>{this.fetchWalletTokenAccounts({forceUpdate:!0}),this._accountListener.forEach(c=>c({tokenAccounts:this._tokenAccounts,tokenAccountRawInfos:this._tokenAccountRawInfos}))},{commitment:t==null?void 0:t.commitment})),{tokenAccounts:u,tokenAccountRawInfos:a}}clearAccountChangeCkb(){this._accountChangeListenerId!==void 0&&this.scope.connection.removeAccountChangeListener(this._accountChangeListenerId)}async getCreatedTokenAccount({mint:t,programId:n=Gn,associatedOnly:o=!0}){await this.fetchWalletTokenAccounts();let r=this._tokenAccounts.filter(({mint:s})=>s==null?void 0:s.equals(t)).sort((s,u)=>s.amount.lt(u.amount)?1:-1),i=this.getAssociatedTokenAccount(t,n);for(let s of r){let{publicKey:u}=s;if(u&&(!o||o&&i.equals(u)))return u}}async getOrCreateTokenAccount(t){var y,b,g,P;await this.fetchWalletTokenAccounts();let{mint:n,createInfo:o,associatedOnly:r,owner:i,notUseTokenAccount:s=!1,skipCloseAccount:u=!1,checkCreateATAOwner:a=!1,assignSeed:c}=t;console.log("******************associatedOnly: ",r);let m=new Or(t.tokenProgram||Gn),p=this.getAssociatedTokenAccount(n,new Or(m)),d=(s?[]:this.tokenAccountRawInfos).filter(h=>h.accountInfo.mint.equals(n)&&(!r||h.pubkey.equals(p))).sort((h,I)=>h.accountInfo.amount.lt(I.accountInfo.amount)?1:-1);if(o===void 0||d.length>0)return d.length>0?{account:d[0].pubkey}:{};let f={instructions:[],endInstructions:[],signers:[],instructionTypes:[],endInstructionTypes:[]};if(r){let h=js(i,p,i,n,m),I=this.tokenAccountRawInfos.find(T=>T.pubkey.equals(p));if(a){console.log("******************checkCreateATAOwner: ",a);let T=await this.scope.connection.getAccountInfo(p);if(T===null)console.log("******************ataInfo == null: ",a),(y=f.instructions)==null||y.push(h),f.instructionTypes.push(G.CreateATA);else if(T.owner.equals(m)&&No.decode(T.data).mint.equals(n)&&No.decode(T.data).owner.equals(i))console.log("******************else empty: ");else throw Error(`create ata check error -> mint: ${n.toString()}, ata: ${p.toString()}`)}else I===void 0&&(console.log("******************_ataInTokenAcc undefined"),f.instructions.push(h),f.instructionTypes.push(G.CreateATA));if(n.equals(Z)&&o.amount){console.log("createWSolAccountInstructions*********************************");let T=await Un({connection:this.scope.connection,owner:i||this.scope.ownerPubKey,payer:o.payer||this.scope.ownerPubKey,amount:(b=o.amount)!=null?b:0,skipCloseAccount:u});f.instructions.push(...T.instructions||[]),f.endInstructions.push(...T.endInstructions||[]),f.instructionTypes.push(...T.instructionTypes||[]),f.endInstructionTypes.push(...T.endInstructionTypes||[]),o.amount&&(console.log("******************createInfo.amount"),f.instructions.push(pc({source:T.addresses.newAccount,destination:p,owner:i||this.scope.ownerPubKey,amount:o.amount,tokenProgram:Gn})),f.instructionTypes.push(G.TransferAmount))}return!u&&I===void 0&&(console.log("******************skipCloseAccount"),f.endInstructions.push(hn({owner:i,payer:o.payer||i,tokenAccount:p,programId:m})),f.endInstructionTypes.push(G.CloseAccount)),{account:p,instructionParams:f}}else{console.log("******************newTokenAccount");let h=He({fromPublicKey:i,programId:m,assignSeed:c}),I=await this.scope.connection.getMinimumBalanceForRentExemption(No.span),T=Rd.createAccountWithSeed({fromPubkey:i,basePubkey:i,seed:h.seed,newAccountPubkey:h.publicKey,lamports:I+Number((P=(g=o.amount)==null?void 0:g.toString())!=null?P:0),space:No.span,programId:m});return f.instructions.push(T,Hs({mint:n,tokenAccount:h.publicKey,owner:i||this.scope.ownerPubKey,programId:m})),f.instructionTypes.push(G.CreateAccount),f.instructionTypes.push(G.InitAccount),u||(f.endInstructions.push(hn({owner:i,payer:o.payer||i,tokenAccount:h.publicKey,programId:m})),f.endInstructionTypes.push(G.CloseAccount)),{account:h.publicKey,instructionParams:f}}}async checkOrCreateAta({mint:t,programId:n=Gn,autoUnwrapWSOLToSOL:o}){var u;await this.fetchWalletTokenAccounts();let r=(u=this.scope.account.tokenAccounts.find(({mint:a})=>(a==null?void 0:a.toBase58())===t.toBase58()))==null?void 0:u.publicKey,i=this.scope.ownerPubKey,s={};if(!r){let a=this.getAssociatedTokenAccount(t,n),c=await js(i,a,i,t,n);s.instructions=[c],s.instructionTypes=[G.CreateATA],r=a}return o&&Z.toBase58()===t.toBase58()&&(s.endInstructions=[hn({owner:i,payer:i,tokenAccount:r,programId:n})],s.endInstructionTypes=[G.CloseAccount]),{pubKey:r,newInstructions:s}}async handleTokenAccount(t){let{side:n,amount:o,mint:r,programId:i=Gn,tokenAccount:s,payer:u=this.scope.ownerPubKey,bypassAssociatedCheck:a,skipCloseAccount:c,checkCreateATAOwner:m}=t,p=this.getAssociatedTokenAccount(r,i);if(new Or(Z).equals(r)){let d=await Un({connection:this.scope.connection,owner:this.scope.ownerPubKey,payer:u,amount:o,skipCloseAccount:c});return v({tokenAccount:d.addresses.newAccount},d)}else if(!s||n==="out"&&!p.equals(s)&&!a){let d=[],f=js(this.scope.ownerPubKey,p,this.scope.ownerPubKey,r,i);if(m){let y=await this.scope.connection.getAccountInfo(p);if(y===null)d.push(f);else if(!(y.owner.equals(Gn)&&No.decode(y.data).mint.equals(r)&&No.decode(y.data).owner.equals(this.scope.ownerPubKey)))throw Error(`create ata check error -> mint: ${r.toString()}, ata: ${p.toString()}`)}else d.push(f);return{tokenAccount:p,instructions:d,instructionTypes:[G.CreateATA]}}return{tokenAccount:s}}async processTokenAccount(t){let{mint:n,programId:o=Gn,amount:r,useSOLBalance:i,handleTokenAccount:s,feePayer:u}=t,a,c=this.createTxBuilder(u);if(n.equals(new Or(Z))&&i){let m=await this.handleTokenAccount({side:"in",amount:r||0,mint:n,bypassAssociatedCheck:!0,programId:o}),{tokenAccount:d}=m,f=_e(m,["tokenAccount"]);a=d,c.addInstruction(f)}else if(a=await this.getCreatedTokenAccount({mint:n,associatedOnly:!1,programId:o}),!a&&s){let p=await this.scope.account.handleTokenAccount({side:"in",amount:0,mint:n,bypassAssociatedCheck:!0,programId:o}),{tokenAccount:d}=p,f=_e(p,["tokenAccount"]);a=d,c.addInstruction(f)}return v({tokenAccount:a},c.AllTxData)}};import{PublicKey as Ke,SystemProgram as Jd}from"@solana/web3.js";import{createAssociatedTokenAccountIdempotentInstruction as Oc}from"@solana/spl-token";import ep from"decimal.js";import{PublicKey as na}from"@solana/web3.js";var $s=F([V("instruction")]),Zs=F([V("instruction")]),Od=F([A("rewardState"),A("rewardOpenTime"),A("rewardEndTime"),A("rewardLastUpdateTime"),A("totalReward"),A("totalRewardEmissioned"),A("rewardClaimed"),A("rewardPerSecond"),ie("accRewardPerShare"),M("rewardVault"),M("rewardMint"),M("rewardSender"),A("rewardType"),Q(A(),15,"padding")]),Nd=F([A("state"),A("nonce"),M("lpVault"),M("rewardVault"),M(),M(),A(),A(),A("totalReward"),ie("perShareReward"),A("lastSlot"),A("perSlotReward")]),Md=F([A("state"),A("nonce"),M("lpVault"),M("rewardVaultA"),A("totalRewardA"),ie("perShareRewardA"),A("perSlotRewardA"),V("option"),M("rewardVaultB"),Te(7),A("totalRewardB"),ie("perShareRewardB"),A("perSlotRewardB"),A("lastSlot"),M()]),vd=F([A(),A("state"),A("nonce"),A("validRewardTokenNum"),ie("rewardMultiplier"),A("rewardPeriodMax"),A("rewardPeriodMin"),A("rewardPeriodExtend"),M("lpMint"),M("lpVault"),Q(Od,5,"rewardInfos"),M("creator"),M(),Q(A(),32,"padding")]),fc=new Proxy(Nd,{get(l,e,t){return e==="decode"?(...n)=>{let o=l.decode(...n);return q(v({},o),{version:3,rewardInfos:[{rewardVault:o.rewardVault,totalReward:o.totalReward,perSlotReward:o.perSlotReward,perShareReward:o.perShareReward}]})}:Reflect.get(l,e,t)}}),yc=new Proxy(Md,{get(l,e,t){return e==="decode"?(...n)=>{let o=l.decode(...n);return q(v({},o),{version:5,rewardInfos:[{rewardVault:o.rewardVaultA,totalReward:o.totalRewardA,perSlotReward:o.perSlotRewardA,perShareReward:o.perShareRewardA},{rewardVault:o.rewardVaultB,totalReward:o.totalRewardB,perSlotReward:o.perSlotRewardB,perShareReward:o.perShareRewardB}]})}:Reflect.get(l,e,t)}}),di=new Proxy(vd,{get(l,e,t){return e==="decode"?(...n)=>{let o=l.decode(...n);return q(v({},o),{version:6,rewardInfos:o.rewardInfos.map(r=>{var i;return q(v({},r),{rewardType:((i=Object.entries(Xn).find(s=>String(s[1])===r.rewardType.toString()))!=null?i:["Standard SPL"])[0]})})})}:Reflect.get(l,e,t)}}),Fd=F([A("isSet"),A("rewardPerSecond"),A("rewardOpenTime"),A("rewardEndTime"),A("rewardType")]),Js=F([V("instruction"),A("nonce"),Q(Fd,5,"rewardTimeInfo")]),ea=F([V("instruction"),A("rewardReopenTime"),A("rewardEndTime"),A("rewardPerSecond")]),ta=F([V("instruction"),A("isSet"),A("rewardPerSecond"),A("rewardOpenTime"),A("rewardEndTime"),A("rewardType")]),mk=F([A("state"),M("id"),M("owner"),A("deposited"),Q(A(),1,"rewardDebts")]),pi=F([A("state"),M("id"),M("owner"),A("deposited"),Q(ie(),1,"rewardDebts"),A(""),A("voteLockedBalance"),Q(A(),15)]),dk=F([A("state"),M("id"),M("owner"),A("deposited"),Q(A(),2,"rewardDebts")]),bc=F([A("state"),M("id"),M("owner"),A("deposited"),Q(ie(),2,"rewardDebts"),Q(A(),17)]),gc=F([A(),A("state"),M("id"),M("owner"),A("deposited"),Q(ie(),5,"rewardDebts"),Q(A(),16)]),Tt=F([V("instruction"),A("amount")]),_d=F([M("mint"),M("grantAuthority"),A("baselineVoteWeightScaledFactor"),A("maxExtraLockupVoteWeightScaledFactor"),A("lockupSaturationSecs"),uc("digitShift"),Q(V(),7,"reserved1"),Q(A(),7,"reserved2")]),Pc=F([Te(8),M("governanceProgramId"),M("realm"),M("realmGoverningTokenMint"),M("realmAuthority"),Q(V(),32,"reserved1"),Q(_d,4,"votingMints"),Lo("timeOffset"),V("bump"),Q(V(),7,"reserved2"),Q(A(),11,"reserved3")]),Vd=F([Lo("startTime"),Lo("endTime"),V("kind"),Q(V(),15,"reserved")]),Ed=F([Q(Vd,1,"lockup"),A("amountDeposited_native"),A("amountInitiallyLockedNative"),qe("isUsed"),qe("allowClawback"),V("votingMintConfigIdx"),Q(V(),29,"reserved")]),Ac=F([Te(8),M("voterAuthority"),M("registrar"),Q(Ed,32,"deposits"),V("voterBump"),V("voterWweightRecordBump"),Q(V(),94,"reserved")]);import{NATIVE_MINT as Wd}from"@solana/spl-token";var wk=be("Raydium_farm_config"),kc=new na("4k3Dyjzvzp8eMZWUXbBCjEvwSkkk59S5iCNLY3QrkX6R"),wc=new na("FrspKwj8i3pNmKwXreTveC4fu7KL5ZbGeXdZBe2XViu1"),Tk=Wd,hk=new na("3TRTX4dXUpp2eqxi3tvQDFYUV7SdDJjcPE3Y4mbtftaX"),Tc={3:fc,5:yc,6:di},hc={3:pi,5:bc,6:gc},oa=l=>[3,4,5,6].indexOf(l)!==-1,ia=l=>{var i;let{version:e,rewardInfos:t,rewardTokenAccountsPublicKeys:n}=l,o=`rewardInfo:${JSON.stringify(t)}, rewardAccount:${JSON.stringify(n)}`,r={3:()=>{if(t.length!==1||n.length!==1)return`rewardInfos or rewardTokenAccounts lengths not equal 1: ${o}`},5:()=>{if(t.length!==n.length)return`rewardInfos and rewardTokenAccounts lengths not equal: ${o}`},6:()=>{if(!n.length||t.length!==n.length)return`no rewardTokenAccounts or rewardInfos and rewardTokenAccounts lengths not equal: ${o}`}};return(i=r[e])==null?void 0:i.call(r)},Xn={"Standard SPL":0,"Option tokens":1},Gt={[Ks.toString()]:3,[Ss.toString()]:4,[Cs.toString()]:5,[Ko.toString()]:6,[kn.FARM_PROGRAM_ID_V3.toString()]:3,[kn.FARM_PROGRAM_ID_V4.toString()]:4,[kn.FARM_PROGRAM_ID_V5.toString()]:5,[kn.FARM_PROGRAM_ID_V6.toString()]:6};import{PublicKey as le,SystemProgram as so,SYSVAR_CLOCK_PUBKEY as vo,SYSVAR_RENT_PUBKEY as Ud,TransactionInstruction as tt}from"@solana/web3.js";import Nr from"bn.js";import{ASSOCIATED_TOKEN_PROGRAM_ID as Gd,createAssociatedTokenAccountIdempotentInstruction as Xd,TOKEN_PROGRAM_ID as Lt}from"@solana/spl-token";function ra(l,e,t){return oe([e.toBuffer(),Buffer.from("registrar","utf8"),t.toBuffer()],l)}function sa(l,e){return oe([e.toBuffer(),Buffer.from("voting_mint_seed","utf8")],l)}function aa(l,e){return oe([e.toBuffer()],l)}function ua(l,e,t){return oe([e.toBuffer(),Buffer.from("voter","utf8"),t.toBuffer()],l)}function ca(l,e,t){return oe([e.toBuffer(),Buffer.from("voter-weight-record","utf8"),t.toBuffer()],l)}function la(l,e,t,n){return oe([Buffer.from("governance","utf8"),e.toBuffer(),t.toBuffer(),n.toBuffer()],l)}import Rt from"bn.js";var fi=be("Raydium.farm.util");function yi({programId:l,poolId:e,mint:t,type:n}){let{publicKey:o}=oe([e.toBuffer(),t.toBuffer(),Buffer.from(n==="lpVault"?"lp_vault_associated_seed":n==="rewardVault"?"reward_vault_associated_seed":"","utf-8")],l);return o}function yt({programId:l,poolId:e,owner:t,version:n}){let{publicKey:o}=oe([e.toBuffer(),t.toBuffer(),Buffer.from(n===6?"farmer_info_associated_seed":"staker_info_v2_associated_seed","utf-8")],l);return o}var Ic=({programId:l,poolId:e})=>oe([e.toBuffer()],l);function Bc(l){return{isSet:new Rt(1),rewardPerSecond:ne(l.perSecond),rewardOpenTime:ne(l.openTime),rewardEndTime:ne(l.endTime),rewardType:ne(Xn[l.rewardType])}}function ma(l){return ne(l.endTime).sub(ne(l.openTime)).mul(ne(l.perSecond))}function Mo(l){let e=hc[l];return e||fi.logWithError("invalid version",l),e}function Dd(l){let e=Tc[l];return e||fi.logWithError("invalid version",l),e}function qd(l,e,t,n){if(l.version===3||l.version===5){if(l.lastSlot.gte(new Rt(t)))return l;let o=new Rt(t).sub(l.lastSlot);l.lastSlot=new Rt(t);for(let r of l.rewardInfos){if(e.amount.eq(new Rt(0)))continue;let i=r.perSlotReward.mul(o);r.perShareReward=r.perShareReward.add(i.mul(new Rt(10).pow(new Rt(l.version===3?9:15))).div(e.amount)),r.totalReward=r.totalReward.add(i)}}else if(l.version===6)for(let o of l.rewardInfos){if(o.rewardState.eq(new Rt(0)))continue;let r=Rt.min(new Rt(n),o.rewardEndTime);if(o.rewardOpenTime.gte(r))continue;let s=r.sub(o.rewardLastUpdateTime).mul(o.rewardPerSecond),u=o.totalReward.sub(o.totalRewardEmissioned);u.lt(s)?(s=u,o.rewardLastUpdateTime=o.rewardLastUpdateTime.add(u.div(o.rewardPerSecond))):o.rewardLastUpdateTime=r,!e.amount.eq(new Rt(0))&&(o.accRewardPerShare=o.accRewardPerShare.add(s.mul(l.rewardMultiplier).div(e.amount)),o.totalRewardEmissioned=o.totalRewardEmissioned.add(s))}return l}async function Wk({connection:l,farmPools:e,owner:t,config:n,chainTime:o}){let r=!1,i=!1,s=new Rt(10),u=[];for(let p of e){let d=Ee(p);d.version===6?i=!0:r=!0,u.push({pubkey:d.id,version:d.version,key:"state",poolId:d.id},{pubkey:d.lpVault,version:d.version,key:"lpVault",poolId:d.id}),t&&u.push({pubkey:yt({programId:d.programId,poolId:d.id,owner:t,version:p.version}),version:d.version,key:"ledger",poolId:d.id})}let a={},c=await Le(l,u,n);for(let{pubkey:p,version:d,key:f,poolId:y,accountInfo:b}of c){let g=y.toBase58();if(a[g]=v({},a[g]),f==="state"){let P=Dd(d);(!b||!b.data||b.data.length!==P.span)&&fi.logWithError(`invalid farm state account info, pools.id, ${p}`),a[g].state=P.decode(b.data)}else if(f==="lpVault")(!b||!b.data||b.data.length!==on.span)&&fi.logWithError(`invalid farm lp vault account info, pools.lpVault, ${p}`),a[g].lpVault=on.decode(b.data);else if(f==="ledger"){let P=Mo(d);b&&b.data&&(b.data.length!==P.span&&fi.logWithError(`invalid farm ledger account info, ledger, ${p}`),a[g].ledger=P.decode(b.data))}}let m=i||r?await l.getSlot():0;for(let p of Object.keys(a))a[p]!==void 0&&(a[p].state=qd(a[p].state,a[p].lpVault,m,o));for(let[p,{state:d,ledger:f}]of Object.entries(a))if(f){let y=d.version===6?d.rewardMultiplier:d.rewardInfos.length===1?s.pow(new Rt(9)):s.pow(new Rt(15)),b=d.rewardInfos.map((g,P)=>{let h=f.rewardDebts[P];return f.deposited.mul(d.version===6?g.accRewardPerShare:g.perShareReward).div(y).sub(h)});a[p].wrapped=q(v({},a[p].wrapped),{pendingRewards:b})}return a}function Dk(l,e=Date.now()){if(l.version===6){let t=l.state.rewardInfos;if(t.every(({rewardOpenTime:n})=>Eu(e,n.toNumber(),{unit:"s"})))return"upcoming pool";if(t.every(({rewardEndTime:n})=>Wu(e,n.toNumber(),{unit:"s"})))return"closed pool"}else{let t=l.state.rewardInfos.map(({perSlotReward:n})=>n);if(t.length===2){if(String(t[0])==="0"&&String(t[1])!=="0")return"normal fusion pool";if(String(t[0])!=="0"&&String(t[1])!=="0")return"dual fusion pool";if(String(t[0])==="0"&&String(t[1])==="0")return"closed pool"}else if(t.length===1&&String(t[0])==="0")return"closed pool"}}async function da(l,e,t,n){let o=await l.getAccountInfo(e);if(o===null)throw Error("registrar info check error");let i=Pc.decode(o.data).votingMints.findIndex(c=>c.mint.equals(n));if(i===-1)throw Error("find voter mint error");let s=await l.getAccountInfo(t);if(s===null)return{index:i,isInit:!1};let a=Ac.decode(s.data).deposits.findIndex(c=>c.isUsed&&c.votingMintConfigIdx===i);return a===-1?{index:i,isInit:!1}:{index:a,isInit:!0}}var zd=be("Raydium_farm_instruction"),bi={voterStakeRegistryCreateVoter:Buffer.from([6,24,245,52,243,255,148,25]),voterStakeRegistryCreateDepositEntry:Buffer.from([185,131,167,186,159,125,19,67]),voterStakeRegistryDeposit:Buffer.from([242,35,198,137,82,225,242,182]),voterStakeRegistryWithdraw:Buffer.from([183,18,70,156,148,109,161,34]),voterStakeRegistryUpdateVoterWeightRecord:Buffer.from([45,185,3,36,109,190,115,169])};function gi(l){let{version:e,id:t,ledger:n,programId:o,owner:r}=l,i={3:9,5:10}[e];i||zd.logWithError(`invalid farm pool version: ${e}`);let s=Buffer.alloc($s.span);$s.encode({instruction:i},s);let u=[k({pubkey:t}),k({pubkey:n}),k({pubkey:r,isWritable:!1}),k({pubkey:so.programId,isWritable:!1}),k({pubkey:Ud,isWritable:!1})];return{instruction:new tt({programId:o,keys:u,data:s}),instructionType:G.FarmV3CreateLedger}}function xc(l){var n;let e=Buffer.alloc(Js.span);Js.encode({instruction:0,nonce:new Nr(l.nonce),rewardTimeInfo:l.rewardInfoConfig},e);let t=[...As,k({pubkey:l.farmId}),k({pubkey:l.farmAuthority,isWritable:!1}),k({pubkey:l.lpVault}),k({pubkey:l.lpMint,isWritable:!1}),k({pubkey:l.lockVault}),k({pubkey:l.lockMint,isWritable:!1}),k({pubkey:(n=l.lockUserAccount)!=null?n:rt}),k({pubkey:l.owner,isWritable:!1,isSigner:!0})];for(let o of l.rewardInfo)t.push(k({pubkey:o.rewardMint,isWritable:!1}),k({pubkey:o.rewardVault}),k({pubkey:o.userRewardToken}));return{instruction:new tt({programId:l.programId,keys:t,data:e}),instructionType:G.FarmV6Create}}function Kc(l){let e=Buffer.alloc(Zs.span);Zs.encode({instruction:5},e);let t=[k({pubkey:Lt,isWritable:!1}),k({pubkey:l.id}),k({pubkey:l.authority,isWritable:!1}),k({pubkey:l.lpVault,isWritable:!1}),k({pubkey:l.rewardVault}),k({pubkey:l.userRewardToken}),k({pubkey:l.owner,isWritable:!1,isSigner:!0})];return{instruction:new tt({programId:l.programId,keys:t,data:e}),instructionType:G.FarmV6CreatorWithdraw}}function Yd(l,e,t,n,o,r,i,s,u,a,c,m,p){let d=F([V("depositEntryIndex"),A("amount")]),f=[{pubkey:e,isSigner:!1,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!1},{pubkey:Lt,isSigner:!1,isWritable:!1},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!1},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!1},{pubkey:c,isSigner:!1,isWritable:!1},{pubkey:dr,isSigner:!1,isWritable:!1}],y=Buffer.alloc(d.span);d.encode({depositEntryIndex:m,amount:p},y);let b=Buffer.from([...bi.voterStakeRegistryDeposit,...y]);return new tt({keys:f,programId:l,data:b})}function Qd(l,e,t,n){let o=F([]),r=[{pubkey:e,isSigner:!1,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:so.programId,isSigner:!1,isWritable:!1}],i=Buffer.alloc(o.span);o.encode({},i);let s=Buffer.from([...bi.voterStakeRegistryUpdateVoterWeightRecord,...i]);return new tt({keys:r,programId:l,data:s})}function Hd(l,e,t,n,o,r,i,s,u,a,c,m,p,d,f){let y=F([V("depositEntryIndex"),A("amount")]),b=[{pubkey:e,isSigner:!1,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!0,isWritable:!1},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:Lt,isSigner:!1,isWritable:!1},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!1},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:m,isSigner:!1,isWritable:!1},{pubkey:p,isSigner:!1,isWritable:!1},{pubkey:dr,isSigner:!1,isWritable:!1}],g=Buffer.alloc(y.span);y.encode({depositEntryIndex:d,amount:f},g);let P=Buffer.from([...bi.voterStakeRegistryWithdraw,...g]);return new tt({keys:b,programId:l,data:P})}function jd(l,e,t,n,o,r){let i=F([V("ins")]),s=[{pubkey:e,isSigner:!1,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!0,isWritable:!0},{pubkey:so.programId,isSigner:!1,isWritable:!1}],u=Buffer.alloc(i.span);return i.encode({ins:23},u),new tt({keys:s,programId:l,data:u})}function $d(l,e,t,n,o,r,i,s){let u=F([V("voterBump"),V("voterWeightRecordBump")]),a=[{pubkey:e,isSigner:!1,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!0,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!0,isWritable:!0},{pubkey:so.programId,isSigner:!1,isWritable:!1},{pubkey:Ze,isSigner:!1,isWritable:!1},{pubkey:dr,isSigner:!1,isWritable:!1}],c=Buffer.alloc(u.span);u.encode({voterBump:i,voterWeightRecordBump:s},c);let m=Buffer.from([...bi.voterStakeRegistryCreateVoter,...c]);return new tt({keys:a,programId:l,data:m})}function Zd(l,e,t,n,o,r,i,s,u,a,c,m){let p=F([V("depositEntryIndex"),V("kind"),V("option"),A("startTs"),ct("periods"),qe("allowClawback")]),d=[{pubkey:e,isSigner:!1,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!0,isWritable:!1},{pubkey:r,isSigner:!0,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!1},{pubkey:so.programId,isSigner:!1,isWritable:!1},{pubkey:Lt,isSigner:!1,isWritable:!1},{pubkey:Gd,isSigner:!1,isWritable:!1},{pubkey:Ze,isSigner:!1,isWritable:!1}],f=Buffer.alloc(p.span);p.encode({depositEntryIndex:s,kind:u,option:a===void 0?0:1,startTs:a,periods:c,allowClawback:m},f);let y=Buffer.from([...bi.voterStakeRegistryCreateDepositEntry,...f]);return new tt({keys:d,programId:l,data:y})}async function ow({connection:l,programId:e,governanceProgramId:t,voteWeightAddinProgramId:n,realm:o,communityTokenMint:r,owner:i,poolId:s,tokenProgram:u}){let a=ra(n,o,r).publicKey,c=yt({programId:e,poolId:s,owner:i,version:3}),m=await l.getAccountInfo(c);if(m===null)throw Error("user is not staker");let p=pi.decode(m.data),d=p.deposited.sub(p.voteLockedBalance);if(console.log("amount",d.toString()),d.eq(new Nr(0)))throw Error("user do not has new stake amount");let f=sa(e,s).publicKey,y=aa(e,s).publicKey,{publicKey:b,nonce:g}=ua(n,a,i),P=$(b,f,u).publicKey,{publicKey:h,nonce:I}=ca(n,a,i),T=la(t,o,r,i).publicKey,w=[],K=$(i,f,u).publicKey;if(await l.getAccountInfo(K)===null&&w.push(Xd(i,K,i,f)),await l.getAccountInfo(b)===null){let C=jd(t,o,i,r,i,T);w.push(C,$d(n,a,b,h,i,i,g,I))}let{index:B,isInit:R}=await da(l,a,b,f);return R||w.push(Zd(n,a,b,P,i,i,f,B,0,void 0,0,!1)),w.push(Yd(n,a,b,P,K,i,c,s,f,y,e,B,d),Qd(n,a,b,h)),w}async function iw({connection:l,programId:e,governanceProgramId:t,voteWeightAddinProgramId:n,realm:o,communityTokenMint:r,owner:i,poolId:s,tokenProgram:u}){let a=ra(n,o,r).publicKey,c=yt({programId:e,poolId:s,owner:i,version:3}),m=await l.getAccountInfo(c);if(m===null)throw Error("user is not staker");let p=pi.decode(m.data);if(p.voteLockedBalance.eq(new Nr(0)))throw Error("user has vote locked balance = 0");let d=sa(e,s).publicKey,f=aa(e,s).publicKey,{publicKey:y}=ua(n,a,i),b=$(y,d,u).publicKey,{publicKey:g}=ca(n,a,i),P=la(t,o,r,i).publicKey,h=[],{index:I,isInit:T}=await da(l,a,y,d);if(!T)throw Error("deposit entry index check error");return h.push(Hd(n,a,y,i,P,g,b,$(i,d,u).publicKey,c,s,d,f,e,I,p.voteLockedBalance)),h}function pa({payer:l,rewardVault:e,userRewardTokenPub:t,farmKeys:n,rewardInfo:o}){let r=Buffer.alloc(ea.span);ea.encode({instruction:3,rewardReopenTime:ne(o.openTime),rewardEndTime:ne(o.endTime),rewardPerSecond:ne(o.perSecond)},r);let i=[k({pubkey:Lt,isWritable:!1}),k({pubkey:n.id}),k({pubkey:n.lpVault,isWritable:!1}),k({pubkey:e}),k({pubkey:t}),k({pubkey:l,isWritable:!1,isSigner:!0})];return new tt({programId:n.programId,keys:i,data:r})}function fa({payer:l,userRewardTokenPub:e,farmKeys:t,rewardVault:n,rewardInfo:o}){let r=Buffer.alloc(ta.span);ta.encode({instruction:4,isSet:new Nr(1),rewardPerSecond:ne(o.perSecond),rewardOpenTime:ne(o.openTime),rewardEndTime:ne(o.endTime),rewardType:ne(Xn[o.rewardType])},r);let i=[...As,k({pubkey:t.id}),k({pubkey:t.authority,isWritable:!1}),k({pubkey:o.mint,isWritable:!1}),k({pubkey:n}),k({pubkey:e}),k({pubkey:l,isWritable:!1,isSigner:!0})];return new tt({programId:t.programId,keys:i,data:r})}function rw(l){let{farmInfo:e,farmKeys:t,version:n,lpAccount:o,rewardAccounts:r,owner:i,instruction:s,amount:u,deposit:a}=l,[c,m]=[new le(e.programId),new le(e.id)],p=yt({programId:c,poolId:m,owner:i,version:n}),d=Buffer.alloc(Tt.span);Tt.encode({instruction:s,amount:u},d);let f=n===6?[k({pubkey:Lt,isWritable:!1}),...a?[k({pubkey:so.programId,isWritable:!1})]:[],k({pubkey:m}),k({pubkey:new le(t.authority),isWritable:!1}),k({pubkey:new le(t.lpVault)}),k({pubkey:p}),k({pubkey:i,isWritable:!1,isSigner:!0}),k({pubkey:o})]:[k({pubkey:m}),k({pubkey:new le(t.authority),isWritable:!1}),k({pubkey:p}),k({pubkey:i,isWritable:!1,isSigner:!0}),k({pubkey:o}),k({pubkey:new le(t.lpVault)}),k({pubkey:r[0]}),k({pubkey:new le(t.rewardInfos[0].vault)}),k({pubkey:vo,isWritable:!1}),k({pubkey:Lt,isWritable:!1})];if(n===5)for(let y=1;y<t.rewardInfos.length;y++)f.push(k({pubkey:r[y]})),f.push(k({pubkey:new le(t.rewardInfos[y].vault)}));if(n===6)for(let y=0;y<t.rewardInfos.length;y++)f.push(k({pubkey:new le(t.rewardInfos[y].vault)})),f.push(k({pubkey:r[y]}));return new tt({programId:c,keys:f,data:d})}function Pi(l){let{farmInfo:e,farmKeys:t,lpAccount:n,rewardAccounts:o,owner:r,amount:i}=l,[s,u]=[new le(e.programId),new le(e.id)],a=yt({programId:s,poolId:u,owner:r,version:6}),c=Buffer.alloc(Tt.span);Tt.encode({instruction:2,amount:ne(i)},c);let m=[k({pubkey:Lt,isWritable:!1}),k({pubkey:u}),k({pubkey:new le(t.authority),isWritable:!1}),k({pubkey:new le(t.lpVault)}),k({pubkey:a}),k({pubkey:r,isWritable:!1,isSigner:!0}),k({pubkey:n})];for(let p=0;p<t.rewardInfos.length;p++)m.push(k({pubkey:new le(t.rewardInfos[p].vault)})),m.push(k({pubkey:o[p]}));return new tt({programId:s,keys:m,data:c})}function Ai(l){let{farmInfo:e,farmKeys:t,lpAccount:n,rewardAccounts:o,owner:r,amount:i,userAuxiliaryLedgers:s}=l,[u,a]=[new le(e.programId),new le(e.id)],c=yt({programId:u,poolId:a,owner:r,version:5}),m=Buffer.alloc(Tt.span);Tt.encode({instruction:12,amount:ne(i)},m);let p=[k({pubkey:a}),k({pubkey:new le(t.authority),isWritable:!1}),k({pubkey:c}),k({pubkey:r,isWritable:!1,isSigner:!0}),k({pubkey:n}),k({pubkey:new le(t.lpVault)}),k({pubkey:o[0]}),k({pubkey:new le(t.rewardInfos[0].vault)}),k({pubkey:vo,isWritable:!1}),k({pubkey:Lt,isWritable:!1})];for(let d=1;d<t.rewardInfos.length;d++)p.push(k({pubkey:o[d]})),p.push(k({pubkey:new le(t.rewardInfos[d].vault)}));if(s)for(let d of s)p.push(k({pubkey:d}));return new tt({programId:u,keys:p,data:m})}function Sc(l){let{farmInfo:e,farmKeys:t,lpAccount:n,rewardAccounts:o,owner:r,amount:i,userAuxiliaryLedgers:s}=l,[u,a]=[new le(e.programId),new le(e.id)],c=F([V("instruction"),A("amount")]),m=[k({pubkey:a}),k({pubkey:new le(t.authority),isWritable:!1}),k({pubkey:s[0]}),k({pubkey:r,isSigner:!0,isWritable:!1}),k({pubkey:n}),k({pubkey:new le(t.lpVault)}),k({pubkey:o[0]}),k({pubkey:new le(t.rewardInfos[0].vault)}),k({pubkey:vo,isWritable:!1}),k({pubkey:Lt,isWritable:!1}),k({pubkey:o[1]}),k({pubkey:new le(t.rewardInfos[1].vault)})],p=Buffer.alloc(c.span);return c.encode({instruction:2,amount:i},p),new tt({keys:m,programId:u,data:p})}function ki(l){let{farmInfo:e,farmKeys:t,lpAccount:n,rewardAccounts:o,owner:r,amount:i,userAuxiliaryLedgers:s}=l,[u,a]=[new le(e.programId),new le(e.id)],c=yt({programId:u,poolId:a,owner:r,version:3}),m=Buffer.alloc(Tt.span);Tt.encode({instruction:11,amount:ne(i)},m);let p=[k({pubkey:a}),k({pubkey:new le(t.authority),isWritable:!1}),k({pubkey:c}),k({pubkey:r,isWritable:!1,isSigner:!0}),k({pubkey:n}),k({pubkey:new le(t.lpVault)}),k({pubkey:o[0]}),k({pubkey:new le(t.rewardInfos[0].vault)}),k({pubkey:vo,isWritable:!1}),k({pubkey:Lt,isWritable:!1})];if(s)for(let d of s)p.push(k({pubkey:d}));return new tt({programId:u,keys:p,data:m})}function Cc(l){let{farmInfo:e,farmKeys:t,lpAccount:n,rewardAccounts:o,owner:r,amount:i,userAuxiliaryLedgers:s}=l,[u,a]=[new le(e.programId),new le(e.id)],c=yt({programId:u,poolId:a,owner:r,version:3}),m=Buffer.alloc(Tt.span);Tt.encode({instruction:10,amount:ne(i)},m);let p=[k({pubkey:a}),k({pubkey:new le(t.authority),isWritable:!1}),k({pubkey:c}),k({pubkey:r,isWritable:!1,isSigner:!0}),k({pubkey:n}),k({pubkey:new le(t.lpVault)}),k({pubkey:o[0]}),k({pubkey:new le(t.rewardInfos[0].vault)}),k({pubkey:vo,isWritable:!1}),k({pubkey:Lt,isWritable:!1})];if(s)for(let d of s)p.push(k({pubkey:d}));return new tt({programId:u,keys:p,data:m})}function Rc(l){let{farmInfo:e,farmKeys:t,lpAccount:n,rewardAccounts:o,owner:r,amount:i,userAuxiliaryLedgers:s}=l,[u,a]=[new le(e.programId),new le(e.id)],c=yt({programId:u,poolId:a,owner:r,version:5}),m=Buffer.alloc(Tt.span);Tt.encode({instruction:11,amount:ne(i)},m);let p=[k({pubkey:a}),k({pubkey:new le(t.authority),isWritable:!1}),k({pubkey:c}),k({pubkey:r,isWritable:!1,isSigner:!0}),k({pubkey:n}),k({pubkey:new le(t.lpVault)}),k({pubkey:o[0]}),k({pubkey:new le(t.rewardInfos[0].vault)}),k({pubkey:vo,isWritable:!1}),k({pubkey:Lt,isWritable:!1})];for(let d=1;d<t.rewardInfos.length;d++)p.push(k({pubkey:o[d]})),p.push(k({pubkey:new le(t.rewardInfos[d].vault)}));if(s)for(let d of s)p.push(k({pubkey:d}));return new tt({programId:u,keys:p,data:m})}function Lc(l){let{farmInfo:e,farmKeys:t,lpAccount:n,rewardAccounts:o,owner:r,amount:i}=l,[s,u]=[new le(e.programId),new le(e.id)],a=yt({programId:s,poolId:u,owner:r,version:6}),c=Buffer.alloc(Tt.span);Tt.encode({instruction:1,amount:ne(i)},c);let m=[k({pubkey:Lt,isWritable:!1}),k({pubkey:so.programId,isWritable:!1}),k({pubkey:u}),k({pubkey:new le(t.authority),isWritable:!1}),k({pubkey:new le(t.lpVault)}),k({pubkey:a}),k({pubkey:r,isWritable:!1,isSigner:!0}),k({pubkey:n})];for(let p=0;p<t.rewardInfos.length;p++)m.push(k({pubkey:new le(t.rewardInfos[p].vault)})),m.push(k({pubkey:o[p]}));return new tt({programId:s,keys:m,data:c})}var wi=class extends We{async _getUserRewardInfo({payer:e,rewardInfo:t}){if(t.mint.equals(rt)){let n=await Un({connection:this.scope.connection,owner:this.scope.ownerPubKey,payer:e,amount:ma(q(v({},t),{openTime:t.openTime.toString(),endTime:t.endTime.toString()}))});return{rewardPubKey:n.addresses.newAccount,newInstruction:n}}return{rewardPubKey:await this.scope.account.getCreatedTokenAccount({mint:t.mint,associatedOnly:!1})}}async create({poolInfo:e,rewardInfos:t,payer:n,programId:o=Ko,txVersion:r,feePayer:i,lockProgram:s}){var K,x;this.checkDisabled(),this.scope.checkOwner();let a={lpMint:new Ke(e.lpMint.address),lockInfo:{lockMint:(K=s==null?void 0:s.mint)!=null?K:kc,lockVault:(x=s==null?void 0:s.vault)!=null?x:wc},version:6,rewardInfos:t,programId:o},c=this.createTxBuilder(i),m=n!=null?n:this.scope.ownerPubKey,p=He({fromPublicKey:m,programId:a.programId}),d=await this.scope.connection.getMinimumBalanceForRentExemption(di.span);c.addInstruction({instructions:[Jd.createAccountWithSeed({fromPubkey:m,basePubkey:m,seed:p.seed,newAccountPubkey:p.publicKey,lamports:d,space:di.span,programId:a.programId})]});let{publicKey:f,nonce:y}=Ic({programId:new Ke(a.programId),poolId:p.publicKey}),b=yi({programId:a.programId,poolId:p.publicKey,mint:a.lpMint,type:"lpVault"}),g=[],P=[];for(let S of a.rewardInfos){S.openTime>=S.endTime&&this.logAndCreateError("start time error","rewardInfo.rewardOpenTime",S.openTime.toString()),isNaN(Xn[S.rewardType])&&this.logAndCreateError("rewardType error",S.rewardType),Number(S.perSecond)<=0&&this.logAndCreateError("rewardPerSecond error",S.perSecond),g.push(Bc(S));let{rewardPubKey:B,newInstruction:R}=await this._getUserRewardInfo({rewardInfo:S,payer:m});R&&c.addInstruction(R),B||this.logAndCreateError("cannot found target token accounts",this.scope.account.tokenAccounts);let C=S.mint.equals(rt)?new Ke(it.address):S.mint;P.push({rewardMint:C,rewardVault:yi({programId:a.programId,poolId:p.publicKey,mint:C,type:"rewardVault"}),userRewardToken:B})}let{account:h,instructionParams:I}=await this.scope.account.getOrCreateTokenAccount({mint:new Ke(a.lockInfo.lockMint),owner:this.scope.ownerPubKey,skipCloseAccount:!1,createInfo:{payer:this.scope.ownerPubKey,amount:0},associatedOnly:!1});I&&c.addInstruction(I),h||this.logAndCreateError("cannot found lock vault","tokenAccounts",this.scope.account.tokenAccounts);let{instruction:T,instructionType:w}=xc({farmId:p.publicKey,owner:this.scope.ownerPubKey,farmAuthority:f,lpVault:b,lpMint:a.lpMint,lockVault:a.lockInfo.lockVault,lockMint:a.lockInfo.lockMint,lockUserAccount:h,programId:a.programId,rewardInfo:P,rewardInfoConfig:g,nonce:y});return c.addInstruction({instructions:[T],instructionTypes:[w]}).versionBuild({txVersion:r,extInfo:{farmId:p.publicKey,farmAuthority:f,lpVault:b,lockUserAccount:h,nonce:y}})}async restartReward({farmInfo:e,payer:t,newRewardInfo:n,txVersion:o,feePayer:r}){var g;let i=Gt[e.programId];i!==6&&this.logAndCreateError("invalid farm version ",i);let s=Ee((await this.scope.api.fetchFarmKeysById({ids:e.id}))[0]),u={id:s.id,rewardInfos:e.rewardInfos,lpVault:s.lpVault,programId:s.programId};n.openTime>=n.endTime&&this.logAndCreateError("start time error","newRewardInfo",n);let a=t||this.scope.ownerPubKey,c=n.mint.equals(rt)?new Ke(it.address):n.mint,m=u.rewardInfos.findIndex(P=>new Ke(P.mint.address).equals(c)),p=s.rewardInfos[m];p||this.logAndCreateError("configuration does not exist","rewardMint",c);let d=(g=p.vault)!=null?g:rt,f=this.createTxBuilder(r),{rewardPubKey:y,newInstruction:b}=await this._getUserRewardInfo({rewardInfo:n,payer:a});return b&&f.addInstruction(b),y||this.logAndCreateError("cannot found target token accounts",this.scope.account.tokenAccounts),f.addInstruction({instructions:[pa({payer:this.scope.ownerPubKey,rewardVault:d,userRewardTokenPub:y,farmKeys:u,rewardInfo:n})],instructionTypes:[G.FarmV6Restart]}).versionBuild({txVersion:o})}async restartRewards({farmInfo:e,payer:t,newRewardInfos:n,txVersion:o,feePayer:r}){var m;let i=Gt[e.programId];i!==6&&this.logAndCreateError("invalid farm version ",i);let s=Ee((await this.scope.api.fetchFarmKeysById({ids:e.id}))[0]),u={id:s.id,rewardInfos:e.rewardInfos,lpVault:s.lpVault,programId:s.programId};n.forEach(p=>{p.openTime>=p.endTime&&this.logAndCreateError("start time error","newRewardInfo",p)});let a=t||this.scope.ownerPubKey,c=this.createTxBuilder(r);for(let p of n){let d=p.mint.equals(rt)?new Ke(it.address):p.mint,f=u.rewardInfos.findIndex(I=>new Ke(I.mint.address).equals(d)),y=s.rewardInfos[f];y||this.logAndCreateError("configuration does not exist","rewardMint",d);let b=(m=y.vault)!=null?m:rt,{rewardPubKey:g,newInstruction:P}=await this._getUserRewardInfo({rewardInfo:p,payer:a});P&&c.addInstruction(P),g||this.logAndCreateError("cannot found target token accounts",this.scope.account.tokenAccounts);let h=pa({payer:this.scope.ownerPubKey,rewardVault:b,userRewardTokenPub:g,farmKeys:u,rewardInfo:p});c.addInstruction({instructions:[h],instructionTypes:[G.FarmV6Restart]})}return c.versionBuild({txVersion:o})}async addNewRewardToken(e){let{txVersion:t,farmInfo:n,newRewardInfo:o,payer:r,feePayer:i}=e,s=Gt[n.programId];s!==6&&this.logAndCreateError("invalid farm version ",s);let u=Ee((await this.scope.api.fetchFarmKeysById({ids:n.id}))[0]),a=r!=null?r:this.scope.ownerPubKey,c=this.createTxBuilder(i),m=o.mint.equals(rt)?new Ke(it.address):o.mint,p=yi({programId:new Ke(n.programId),poolId:new Ke(n.id),mint:m,type:"rewardVault"}),{rewardPubKey:d,newInstruction:f}=await this._getUserRewardInfo({rewardInfo:o,payer:a});return f&&c.addInstruction(f),d||this.logAndCreateError("annot found target token accounts",this.scope.account.tokenAccounts),o.mint=m,c.addInstruction({instructions:[fa({payer:this.scope.ownerPubKey,userRewardTokenPub:d,farmKeys:u,rewardVault:p,rewardInfo:o})],instructionTypes:[G.FarmV6CreatorAddReward]}).versionBuild({txVersion:t})}async addNewRewardsToken(e){let{txVersion:t,farmInfo:n,newRewardInfos:o,payer:r,feePayer:i}=e,s=Gt[n.programId];s!==6&&this.logAndCreateError("invalid farm version ",s);let u=Ee((await this.scope.api.fetchFarmKeysById({ids:n.id}))[0]),a=r!=null?r:this.scope.ownerPubKey,c=this.createTxBuilder(i);for(let m of o){let p=m.mint.equals(rt)?new Ke(it.address):m.mint,d=yi({programId:new Ke(n.programId),poolId:new Ke(n.id),mint:p,type:"rewardVault"}),{rewardPubKey:f,newInstruction:y}=await this._getUserRewardInfo({rewardInfo:m,payer:a});y&&c.addInstruction(y),f||this.logAndCreateError("cannot found target token accounts",this.scope.account.tokenAccounts);let b=fa({payer:this.scope.ownerPubKey,userRewardTokenPub:f,farmKeys:u,rewardVault:d,rewardInfo:q(v({},m),{mint:p})});c.addInstruction({instructions:[b],instructionTypes:[G.FarmV6CreatorAddReward]})}return c.versionBuild({txVersion:t})}async deposit(e){let{txVersion:t,farmInfo:n,amount:o,feePayer:r,useSOLBalance:i,associatedOnly:s=!0,checkCreateATAOwner:u=!1,userAuxiliaryLedgers:a,computeBudgetConfig:c,txTipConfig:m}=e;this.scope.availability.addFarm===!1&&this.logAndCreateError("farm deposit feature disabled in your region");let{rewardInfos:p,programId:d}=n,f=Gt[d];f===4&&this.logAndCreateError("V4 has suspended deposits:",n.programId),oa(f)||this.logAndCreateError("invalid farm program:",n.programId);let[y,b]=[new Ke(n.programId),new Ke(n.id)],g=(await this.scope.api.fetchFarmKeysById({ids:n.id}))[0],P=yt({programId:y,poolId:b,owner:this.scope.ownerPubKey,version:f}),h=this.createTxBuilder(r);h.addCustomComputeBudget(c),h.addTipInstruction(m);let I={};for(let L of this.scope.account.tokenAccounts)if(s){let O=$(this.scope.ownerPubKey,L.mint,L.programId).publicKey;L.publicKey&&O.equals(L.publicKey)&&(I[L.mint.toString()]=L.publicKey)}else I[L.mint.toString()]=L.publicKey;let T=g.lpMint,w=I[T.address];w||this.logAndCreateError("you don't have any lp","lp zero",I);let K=[];for(let L of p){let O=i&&L.mint.address===Z.toString(),E=I[L.mint.address];if(!E){let{account:X,instructionParams:Y}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:L.mint.programId,mint:new Ke(L.mint.address),notUseTokenAccount:O,createInfo:{payer:r||this.scope.ownerPubKey,amount:0},owner:this.scope.ownerPubKey,skipCloseAccount:!O,associatedOnly:O?!1:s,checkCreateATAOwner:u});E=X,Y&&h.addInstruction(Y)}I[L.mint.address]=E,K.push(E)}let x,S=await this.scope.connection.getAccountInfo(P);if(S&&(x=Mo(f).decode(S.data)),n.programId!==Ko.toString()&&n.programId!==kn.FARM_PROGRAM_ID_V6.toString()&&!x){let{instruction:L,instructionType:O}=gi({id:b,programId:y,version:f,ledger:P,owner:this.scope.ownerPubKey});h.addInstruction({instructions:[L],instructionTypes:[O]})}let B=ia({version:f,rewardInfos:p,rewardTokenAccountsPublicKeys:K});B&&this.logAndCreateError(B);let R={amount:ne(o),owner:this.scope.ownerPubKey,farmInfo:n,farmKeys:g,lpAccount:w,rewardAccounts:K,userAuxiliaryLedgers:a==null?void 0:a.map(L=>new Ke(L))},C=f===6?Lc(R):f===5?Rc(R):Cc(R),N={3:G.FarmV3Deposit,5:G.FarmV5Deposit,6:G.FarmV6Deposit};return h.addInstruction({instructions:[C],instructionTypes:[N[f]]}).versionBuild({txVersion:t})}async withdraw(e){let{txVersion:t,farmInfo:n,amount:o,deposited:r,useSOLBalance:i,feePayer:s,associatedOnly:u=!0,checkCreateATAOwner:a=!1,userAuxiliaryLedgers:c,computeBudgetConfig:m,txTipConfig:p}=e,{rewardInfos:d}=n;this.scope.availability.removeFarm===!1&&this.logAndCreateError("farm withdraw feature disabled in your region");let f=Gt[n.programId];oa(f)||this.logAndCreateError("invalid farm program:",n.programId);let y=(await this.scope.api.fetchFarmKeysById({ids:n.id}))[0],b=this.createTxBuilder(s);b.addCustomComputeBudget(m),b.addTipInstruction(p);let g={};for(let B of this.scope.account.tokenAccounts)if(u){let R=$(this.scope.ownerPubKey,B.mint).publicKey;B.publicKey&&R.equals(B.publicKey)&&(g[B.mint.toString()]=B.publicKey)}else g[B.mint.toString()]=B.publicKey;if(f!==4){let B=yt({programId:new Ke(n.programId),poolId:new Ke(n.id),owner:this.scope.ownerPubKey,version:f}),R=await this.scope.connection.getAccountInfo(B);if(R)Mo(f).decode(R.data).deposited.isZero()&&this.logAndCreateError("no deposited lp",{farmId:n.id});else if(f!==6){let{instruction:C,instructionType:N}=gi({id:new Ke(y.id),programId:new Ke(y.programId),version:f,ledger:B,owner:this.scope.ownerPubKey});b.addInstruction({instructions:[C],instructionTypes:[N]})}}r&&r.isZero()&&!(c||[]).length&&this.logAndCreateError("no deposited lp",{farmId:n.id});let P=y.lpMint.address,h=i&&P===Z.toString(),I=g[P.toString()];if(!I){let{account:B,instructionParams:R}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:y.lpMint.programId,mint:new Ke(P),notUseTokenAccount:h,createInfo:{payer:s||this.scope.ownerPubKey,amount:0},owner:this.scope.ownerPubKey,skipCloseAccount:!0,associatedOnly:h?!1:u,checkCreateATAOwner:a});I=B,R&&b.addInstruction(R)}g[P.toString()]=I;let T=[];for(let B of d){let R=i&&B.mint.address===Z.toString(),C=g[B.mint.address];if(!C){let{account:N,instructionParams:L}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:B.mint.programId,mint:new Ke(B.mint.address),notUseTokenAccount:R,createInfo:{payer:s||this.scope.ownerPubKey,amount:0},owner:this.scope.ownerPubKey,skipCloseAccount:!R,associatedOnly:R?!1:u,checkCreateATAOwner:a});C=N,L&&b.addInstruction(L)}g[B.mint.address]=C,T.push(C)}let w=ia({version:f,rewardInfos:d,rewardTokenAccountsPublicKeys:T});w&&this.logAndCreateError(w);let K={amount:ne(o),owner:this.scope.ownerPubKey,farmInfo:n,farmKeys:y,lpAccount:I,rewardAccounts:T,userAuxiliaryLedgers:c==null?void 0:c.map(B=>new Ke(B))},x=f===6?Pi(K):f===5?Ai(K):f===4?Sc(K):ki(K),S={3:G.FarmV3Withdraw,4:G.FarmV4Withdraw,5:G.FarmV5Withdraw,6:G.FarmV6Withdraw};return b.addInstruction({instructions:[x],instructionTypes:[S[f]]}).versionBuild({txVersion:t})}async withdrawFarmReward({farmInfo:e,withdrawMint:t,txVersion:n,computeBudgetConfig:o,txTipConfig:r,feePayer:i}){var y;this.scope.checkOwner();let s=Ee((await this.scope.api.fetchFarmKeysById({ids:e.id}))[0]),u=Gt[e.programId];u!==6&&this.logAndCreateError("invalid farm version",u);let a=s.rewardInfos.find(b=>ft(b.mint.address).equals(ft(t)));a||this.logAndCreateError("withdraw mint error","rewardInfos",e);let c=(y=a==null?void 0:a.vault)!=null?y:rt,m=this.createTxBuilder(i),p;if(t.equals(rt)||t.equals(Ke.default)){let b=await Un({connection:this.scope.connection,owner:this.scope.ownerPubKey,payer:this.scope.ownerPubKey,amount:ma(q(v({},a),{openTime:a.openTime,endTime:a.endTime,perSecond:new ep(a.perSecond).mul(10**a.mint.decimals).toString()}))});p=b.addresses.newAccount,m.addInstruction(b)}else{let b=await this.scope.account.getCreatedTokenAccount({mint:t});b===null?(p=await this.scope.account.getAssociatedTokenAccount(t),m.addInstruction({instructions:[Oc(this.scope.ownerPubKey,p,this.scope.ownerPubKey,t)],instructionTypes:[G.CreateATA]})):p=b}let{instruction:d,instructionType:f}=Kc({programId:s.programId,id:s.id,authority:s.authority,lpVault:s.lpVault,rewardVault:c,userRewardToken:p,owner:this.scope.ownerPubKey});return m.addCustomComputeBudget(o),m.addTipInstruction(r),m.addInstruction({instructions:[d],instructionTypes:[f]}).versionBuild({txVersion:n})}async harvestAllRewards(e){let{farmInfoList:t,useSOLBalance:n,feePayer:o,associatedOnly:r=!0,checkCreateATAOwner:i=!1,userAuxiliaryLedgers:s,txVersion:u,computeBudgetConfig:a}=e,c=this.createTxBuilder(o),m={};for(let f of this.scope.account.tokenAccounts)if(r){let y=$(this.scope.ownerPubKey,f.mint).publicKey;f.publicKey&&y.equals(f.publicKey)&&(m[f.mint.toString()]=f.publicKey)}else m[f.mint.toString()]=f.publicKey;let d=(await this.scope.api.fetchFarmKeysById({ids:Object.values(t).map(f=>f.id).join(",")})).reduce((f,y)=>q(v({},f),{[y.id]:y}),{});for(let f of Object.values(t)){let{programId:y,lpMint:b,rewardInfos:g,id:P}=f,h=Gt[y],I=b.address,T=n&&I===Z.toString(),w=m[I];if(!w){let{account:C,instructionParams:N}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:b.programId,mint:new Ke(I),notUseTokenAccount:T,createInfo:{payer:o||this.scope.ownerPubKey,amount:0},owner:this.scope.ownerPubKey,skipCloseAccount:!0,associatedOnly:T?!1:r,checkCreateATAOwner:i});w=C,N&&c.addInstruction(N)}m[I.toString()]=w;let K=[];for(let C of g){let N=n&&C.mint.address===Z.toString(),L=m[C.mint.address];if(!L)if(N){let{account:O,instructionParams:E}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:C.mint.programId,mint:new Ke(C.mint.address),notUseTokenAccount:N,createInfo:{payer:o||this.scope.ownerPubKey,amount:0},owner:this.scope.ownerPubKey,skipCloseAccount:!N,associatedOnly:N?!1:r,checkCreateATAOwner:i});L=O,E&&c.addInstruction(E)}else{let O=new Ke(C.mint.address);L=this.scope.account.getAssociatedTokenAccount(O),c.addInstruction({instructions:[Oc(this.scope.ownerPubKey,L,this.scope.ownerPubKey,O)]})}m[C.mint.address]=L,K.push(L)}let x=d[P],S={amount:St,owner:this.scope.ownerPubKey,farmInfo:f,farmKeys:x,lpAccount:w,rewardAccounts:K,userAuxiliaryLedgers:s==null?void 0:s.map(C=>new Ke(C))},B=h===6?Pi(S):h===5?Ai(S):ki(S),R={3:G.FarmV3Withdraw,5:G.FarmV5Withdraw,6:G.FarmV6Withdraw};c.addInstruction({instructions:[B],instructionTypes:[R[h]]})}return u===1?c.sizeCheckBuild({computeBudgetConfig:a}):c.sizeCheckBuildV0({computeBudgetConfig:a})}};import{PublicKey as Je}from"@solana/web3.js";import{AccountLayout as Up,NATIVE_MINT as Qr,TOKEN_PROGRAM_ID as Yn}from"@solana/spl-token";import{Keypair as Wr,PublicKey as z,SystemProgram as Kn,TransactionInstruction as mt}from"@solana/web3.js";import xa from"bn.js";import{ASSOCIATED_TOKEN_PROGRAM_ID as Ci,TOKEN_2022_PROGRAM_ID as Ye,TOKEN_PROGRAM_ID as Ce}from"@solana/spl-token";import mp from"bn.js";import Vo from"decimal.js";import Xt from"bn.js";var ge=new Xt(0),Vt=new Xt(1),In=new Xt(-1),nt=new Xt(1).shln(64),Mr=new Xt(1).shln(128),Ti=nt.sub(Vt),hi=64,Nc=Mr.subn(1),bt=-443636,ht=-bt,zt=new Xt("4295048016"),Yt=new Xt("79226673521066979257578248091"),vr=new Xt("4295048017"),Fr=new Xt("79226673521066979257578248090"),Mc=16,vc="59543866431248",Fc="184467440737095516",_c="15793534762490258745",_r=new Xt(10).pow(new Xt(6)),tp=(n=>(n[n.rate_500=500]="rate_500",n[n.rate_3000=3e3]="rate_3000",n[n.rate_10000=1e4]="rate_10000",n))(tp||{}),Fw={[500]:10,[3e3]:60,[1e4]:200},_w={version:6,liquidity:ge,tickCurrent:0,feeGrowthGlobalX64A:ge,feeGrowthGlobalX64B:ge,protocolFeesTokenA:ge,protocolFeesTokenB:ge,swapInAmountTokenA:ge,swapOutAmountTokenB:ge,swapInAmountTokenB:ge,swapOutAmountTokenA:ge,tickArrayBitmap:[],rewardInfos:[],day:{volume:0,volumeFee:0,feeA:0,feeB:0,feeApr:0,rewardApr:{A:0,B:0,C:0},apr:0,priceMax:0,priceMin:0},week:{volume:0,volumeFee:0,feeA:0,feeB:0,feeApr:0,rewardApr:{A:0,B:0,C:0},apr:0,priceMax:0,priceMin:0},month:{volume:0,volumeFee:0,feeA:0,feeB:0,feeApr:0,rewardApr:{A:0,B:0,C:0},apr:0,priceMax:0,priceMin:0},tvl:0},Vc={tvl:0,volumeQuote:0,mintAmountA:0,mintAmountB:0,rewardDefaultInfos:[],farmUpcomingCount:0,farmOngoingCount:0,farmFinishedCount:0,day:{volume:0,volumeQuote:0,volumeFee:0,apr:0,feeApr:0,priceMin:0,priceMax:0,rewardApr:[0]},week:{volume:0,volumeQuote:0,volumeFee:0,apr:0,feeApr:0,priceMin:0,priceMax:0,rewardApr:[0]},month:{volume:0,volumeQuote:0,volumeFee:0,apr:0,feeApr:0,priceMin:0,priceMax:0,rewardApr:[0]},pooltype:[]},Vw=new Xt("18446744073700000000");import fe from"bn.js";import fn from"decimal.js";function Vr(l){let e=new ArrayBuffer(2);return new DataView(e).setUint16(0,l,!1),new Uint8Array(e)}function Ww(l){let e=new ArrayBuffer(2);return new DataView(e).setInt16(0,l,!1),new Uint8Array(e)}function Dw(l){let e=new ArrayBuffer(4);return new DataView(e).setUint32(0,l,!1),new Uint8Array(e)}function Er(l){let e=new ArrayBuffer(4);return new DataView(e).setInt32(0,l,!1),new Uint8Array(e)}function ya(l,e){let t=0;for(let n=l-1;n>=0&&!e.testn(n);n--)t++;return t}function ba(l,e){let t=0;for(let n=0;n<l&&!e.testn(n);n++)t++;return t}function Ii(l,e){for(let t=0;t<l;t++)if(e.testn(t))return!1;return!0}function Ec(l,e){return Ii(l,e)?null:ya(l,e)}function Wc(l,e){return Ii(l,e)?null:ba(l,e)}var np=Buffer.from("amm_config","utf8"),ga=Buffer.from("pool","utf8"),Pa=Buffer.from("pool_vault","utf8"),op=Buffer.from("pool_reward_vault","utf8"),Dc=Buffer.from("position","utf8"),ip=Buffer.from("tick_array","utf8"),rp=Buffer.from("operation","utf8"),sp=Buffer.from("pool_tick_array_bitmap_extension","utf8"),ap=Buffer.from("observation","utf8");function Xw(l,e){return oe([np,Vr(e)],l)}function qc(l,e,t,n){return oe([ga,e.toBuffer(),t.toBuffer(),n.toBuffer()],l)}function Aa(l,e,t){return oe([Pa,e.toBuffer(),t.toBuffer()],l)}function Uc(l,e,t){return oe([op,e.toBuffer(),t.toBuffer()],l)}function Pe(l,e,t){return oe([ip,e.toBuffer(),Er(t)],l)}function rn(l,e,t,n){return oe([Dc,e.toBuffer(),Er(t),Er(n)],l)}function It(l,e){return oe([Dc,e.toBuffer()],l)}function Bn(l){return oe([Buffer.from("metadata","utf8"),Ut.toBuffer(),l.toBuffer()],Ut)}function Bi(l){return oe([rp],l)}function je(l,e){return oe([sp,e.toBuffer()],l)}function Gc(l,e){return oe([ap,e.toBuffer()],l)}var Xc=Buffer.from("locked_position","utf8");function ka(l,e){return oe([Xc,e.toBuffer()],l)}function Fo(l,e){return oe([Xc,e.toBuffer()],l)}var up=Buffer.from("support_mint","utf8");function wa(l,e){return oe([up,e.toBuffer()],l)}import{PublicKey as Et}from"@solana/web3.js";import{TOKEN_2022_PROGRAM_ID as zc}from"@solana/spl-token";import Ue from"bn.js";import ke from"decimal.js";import pn from"bn.js";import Ta from"decimal.js";var xi=class{static getfeeGrowthInside(e,t,n){let o=new pn(0),r=new pn(0);e.tickCurrent>=t.tick?(o=t.feeGrowthOutsideX64A,r=t.feeGrowthOutsideX64B):(o=e.feeGrowthGlobalX64A.sub(t.feeGrowthOutsideX64A),r=e.feeGrowthGlobalX64B.sub(t.feeGrowthOutsideX64B));let i=new pn(0),s=new pn(0);e.tickCurrent<n.tick?(i=n.feeGrowthOutsideX64A,s=n.feeGrowthOutsideX64B):(i=e.feeGrowthGlobalX64A.sub(n.feeGrowthOutsideX64A),s=e.feeGrowthGlobalX64B.sub(n.feeGrowthOutsideX64B));let u=me.wrappingSubU128(me.wrappingSubU128(e.feeGrowthGlobalX64A,o),i),a=me.wrappingSubU128(me.wrappingSubU128(e.feeGrowthGlobalX64B,r),s);return{feeGrowthInsideX64A:u,feeGrowthInsideBX64:a}}static GetPositionFees(e,t,n,o){let{feeGrowthInsideX64A:r,feeGrowthInsideBX64:i}=this.getfeeGrowthInside(e,n,o),s=me.mulDivFloor(me.wrappingSubU128(r,t.feeGrowthInsideLastX64A),t.liquidity,nt),u=t.tokenFeesOwedA.add(s),a=me.mulDivFloor(me.wrappingSubU128(i,t.feeGrowthInsideLastX64B),t.liquidity,nt),c=t.tokenFeesOwedB.add(a);return{tokenFeeAmountA:u,tokenFeeAmountB:c}}static GetPositionFeesV2(e,t,n,o){let{feeGrowthInsideX64A:r,feeGrowthInsideBX64:i}=this.getfeeGrowthInside(e,n,o),s=me.mulDivFloor(me.wrappingSubU128(r,t.feeGrowthInsideLastX64A),t.liquidity,nt),u=t.tokenFeesOwedA.add(s),a=me.mulDivFloor(me.wrappingSubU128(i,t.feeGrowthInsideLastX64B),t.liquidity,nt),c=t.tokenFeesOwedB.add(a);return{tokenFeeAmountA:u,tokenFeeAmountB:c}}static GetPositionRewardsV2(e,t,n,o){let r=[],i=this.getRewardGrowthInsideV2(e.tickCurrent,n,o,e.rewardInfos);for(let s=0;s<i.length;s++){let u=i[s],a=t.rewardInfos[s],c=me.wrappingSubU128(u,a.growthInsideLastX64),m=me.mulDivFloor(c,t.liquidity,nt),p=a.rewardAmountOwed.add(m);r.push(p)}return r}static GetPositionRewards(e,t,n,o){let r=[],i=this.getRewardGrowthInside(e.tickCurrent,n,o,e.rewardInfos);for(let s=0;s<i.length;s++){let u=i[s],a=t.rewardInfos[s],c=me.wrappingSubU128(u,a.growthInsideLastX64),m=me.mulDivFloor(c,t.liquidity,nt),p=a.rewardAmountOwed.add(m);r.push(p)}return r}static getRewardGrowthInside(e,t,n,o){let r=[];for(let i=0;i<o.length;i++){let s=new pn(0);t.liquidityGross.eqn(0)?s=o[i].rewardGrowthGlobalX64:e<t.tick?s=o[i].rewardGrowthGlobalX64.sub(t.rewardGrowthsOutsideX64[i]):s=t.rewardGrowthsOutsideX64[i];let u=new pn(0);n.liquidityGross.eqn(0)||(e<n.tick?u=n.rewardGrowthsOutsideX64[i]:u=o[i].rewardGrowthGlobalX64.sub(n.rewardGrowthsOutsideX64[i])),r.push(me.wrappingSubU128(me.wrappingSubU128(o[i].rewardGrowthGlobalX64,s),u))}return r}static getRewardGrowthInsideV2(e,t,n,o){let r=[];for(let i=0;i<o.length;i++){let s=new pn(0);t.liquidityGross.eqn(0)?s=o[i].rewardGrowthGlobalX64:e<t.tick?s=o[i].rewardGrowthGlobalX64.sub(t.rewardGrowthsOutsideX64[i]):s=t.rewardGrowthsOutsideX64[i];let u=new pn(0);n.liquidityGross.eqn(0)||(e<n.tick?u=n.rewardGrowthsOutsideX64[i]:u=o[i].rewardGrowthGlobalX64.sub(n.rewardGrowthsOutsideX64[i])),r.push(me.wrappingSubU128(me.wrappingSubU128(o[i].rewardGrowthGlobalX64,s),u))}return r}static getAmountsFromLiquidity({poolInfo:e,ownerPosition:t,liquidity:n,slippage:o,add:r,epochInfo:i}){var b,g,P,h;let s=ue.priceToSqrtPriceX64(new Ta(e.price),e.mintA.decimals,e.mintB.decimals),u=ue.getSqrtPriceX64FromTick(t.tickLower),a=ue.getSqrtPriceX64FromTick(t.tickUpper),c=r?1+o:1-o,m=Ae.getAmountsFromLiquidity(s,u,a,n,r),[p,d]=[xe(m.amountA,(b=e.mintA.extensions)==null?void 0:b.feeConfig,i,!0),xe(m.amountB,(g=e.mintB.extensions)==null?void 0:g.feeConfig,i,!0)],[f,y]=[xe(new pn(new Ta(m.amountA.toString()).mul(c).toFixed(0)),(P=e.mintA.extensions)==null?void 0:P.feeConfig,i,!0),xe(new pn(new Ta(m.amountB.toString()).mul(c).toFixed(0)),(h=e.mintB.extensions)==null?void 0:h.feeConfig,i,!0)];return{liquidity:n,amountA:p,amountB:d,amountSlippageA:f,amountSlippageB:y,expirationTime:tn(p.expirationTime,d.expirationTime)}}};var cp=15,we=class{static async getTickArrays(e,t,n,o,r,i,s){let u=[],a=J.getTickArrayStartIndexByTick(o,r),c=J.getInitializedTickArrayInRange(i,s,r,a,Math.floor(cp/2));for(let d=0;d<c.length;d++){let{publicKey:f}=Pe(t,n,c[d]);u.push(f)}let m=(await en(e,u)).map(d=>d!==null?Ki.decode(d.data):null),p={};for(let d=0;d<u.length;d++){let f=m[d];f!==null&&(p[f.startTickIndex]=q(v({},f),{address:u[d]}))}return p}static nextInitializedTick(e,t,n,o,r,i){let{initializedTick:s,tickArrayAddress:u,tickArrayStartTickIndex:a}=this.nextInitializedTickInOneArray(e,t,n,o,r,i);for(;s==null||s.liquidityGross.lten(0);){if(a=J.getNextTickArrayStartIndex(a,r,i),this.checkIsValidStartIndex(a,r))throw new Error("No enough initialized tickArray");let c=n[a];if(c===void 0)continue;let{nextTick:m,tickArrayAddress:p,tickArrayStartTickIndex:d}=this.firstInitializedTickInOneArray(e,t,c,i);[s,u,a]=[m,p,d]}if(s==null)throw new Error("No invaild tickArray cache");return{nextTick:s,tickArrayAddress:u,tickArrayStartTickIndex:a}}static nextInitializedTickArray(e,t,n,o,r){let i=Math.floor(e/we.tickCount(t)),s=n?J.searchLowBitFromStart(o,r,i-1,1,t):J.searchHightBitFromStart(o,r,i+1,1,t);return s.length>0?{isExist:!0,nextStartIndex:s[0]}:{isExist:!1,nextStartIndex:0}}static firstInitializedTickInOneArray(e,t,n,o){let r;if(o){let s=ot-1;for(;s>=0;){let u=n.ticks[s];if(u.liquidityGross.gtn(0)){r=u;break}s=s-1}}else{let s=0;for(;s<ot;){let u=n.ticks[s];if(u.liquidityGross.gtn(0)){r=u;break}s=s+1}}let{publicKey:i}=Pe(e,t,n.startTickIndex);return{nextTick:r,tickArrayAddress:i,tickArrayStartTickIndex:n.startTickIndex}}static nextInitializedTickInOneArray(e,t,n,o,r,i){let s=J.getTickArrayStartIndexByTick(o,r),u=Math.floor((o-s)/r),a=n[s];if(a==null)return{initializedTick:void 0,tickArrayAddress:void 0,tickArrayStartTickIndex:s};let c;if(i)for(;u>=0;){let p=a.ticks[u];if(p.liquidityGross.gtn(0)){c=p;break}u=u-1}else for(u=u+1;u<ot;){let p=a.ticks[u];if(p.liquidityGross.gtn(0)){c=p;break}u=u+1}let{publicKey:m}=Pe(e,t,s);return{initializedTick:c,tickArrayAddress:m,tickArrayStartTickIndex:a.startTickIndex}}static getArrayStartIndex(e,t){let n=this.tickCount(t);return Math.floor(e/n)*n}static checkIsValidStartIndex(e,t){if(J.checkIsOutOfBoundary(e)){if(e>ht)return!1;let n=J.getTickArrayStartIndexByTick(bt,t);return e==n}return e%this.tickCount(t)==0}static tickCount(e){return ot*e}};var ha=14,xn=class{static maxTickInTickarrayBitmap(e){return e*ot*ao}static getBitmapTickBoundary(e,t){let n=this.maxTickInTickarrayBitmap(t),o=Math.floor(Math.abs(e)/n);e<0&&Math.abs(e)%n!=0&&(o+=1);let r=n*o;return e<0?{minValue:-r,maxValue:-r+n}:{minValue:r,maxValue:r+n}}static nextInitializedTickArrayStartIndex(e,t,n,o){if(!we.checkIsValidStartIndex(t,n))throw Error("nextInitializedTickArrayStartIndex check error");let r=this.maxTickInTickarrayBitmap(n),i=o?t-we.tickCount(n):t+we.tickCount(n);if(i<-r||i>=r)return{isInit:!1,tickIndex:t};let s=n*ot,u=i/s+512;i<0&&i%s!=0&&u--;let a=Math.abs(u);if(o){let c=e.shln(1024-a-1),m=Ec(1024,c);if(m!==null){let p=(a-m-512)*s;return{isInit:!0,tickIndex:p}}else return{isInit:!1,tickIndex:-r}}else{let c=e.shrn(a),m=Wc(1024,c);if(m!==null){let p=(a+m-512)*s;return{isInit:!0,tickIndex:p}}else return{isInit:!1,tickIndex:r-we.tickCount(n)}}}},Si=class{static getBitmapOffset(e,t){if(!we.checkIsValidStartIndex(e,t))throw new Error("No enough initialized tickArray");this.checkExtensionBoundary(e,t);let n=xn.maxTickInTickarrayBitmap(t),o=Math.floor(Math.abs(e)/n)-1;return e<0&&Math.abs(e)%n===0&&o--,o}static getBitmap(e,t,n){let o=this.getBitmapOffset(e,t);return e<0?{offset:o,tickarrayBitmap:n.negativeTickArrayBitmap[o]}:{offset:o,tickarrayBitmap:n.positiveTickArrayBitmap[o]}}static checkExtensionBoundary(e,t){let{positiveTickBoundary:n,negativeTickBoundary:o}=this.extensionTickBoundary(t);if(e>=o&&e<n)throw Error("checkExtensionBoundary -> InvalidTickArrayBoundary")}static extensionTickBoundary(e){let t=xn.maxTickInTickarrayBitmap(e),n=-t;if(ht<=t)throw Error(`extensionTickBoundary check error: ${ht}, ${t}`);if(n<=bt)throw Error(`extensionTickBoundary check error: ${n}, ${bt}`);return{positiveTickBoundary:t,negativeTickBoundary:n}}static checkTickArrayIsInit(e,t,n){let{tickarrayBitmap:o}=this.getBitmap(e,t,n),r=this.tickArrayOffsetInBitmap(e,t);return{isInitialized:J.mergeTickArrayBitmap(o).testn(r),startIndex:e}}static nextInitializedTickArrayFromOneBitmap(e,t,n,o){let r=we.tickCount(t),i=n?e-r:e+r,{tickarrayBitmap:s}=this.getBitmap(i,t,o);return this.nextInitializedTickArrayInBitmap(s,i,t,n)}static nextInitializedTickArrayInBitmap(e,t,n,o){let{minValue:r,maxValue:i}=xn.getBitmapTickBoundary(t,n),s=this.tickArrayOffsetInBitmap(t,n);if(o){let u=J.mergeTickArrayBitmap(e).shln(ao-1-s),a=Ii(512,u)?null:ya(512,u);if(a!==null){let c=t-a*we.tickCount(n);return{isInit:!0,tickIndex:c}}else return{isInit:!1,tickIndex:r}}else{let u=J.mergeTickArrayBitmap(e).shrn(s),a=Ii(512,u)?null:ba(512,u);if(a!==null){let c=t+a*we.tickCount(n);return{isInit:!0,tickIndex:c}}else return{isInit:!1,tickIndex:i-we.tickCount(n)}}}static tickArrayOffsetInBitmap(e,t){let n=Math.abs(e)%xn.maxTickInTickarrayBitmap(t),o=Math.floor(n/we.tickCount(t));return e<0&&n!=0&&(o=ao-o),o}};var ve=class{static getOutputAmountAndRemainAccounts(e,t,n,o,r,i=!1){let s=n.toBase58()===e.mintA.address,u=[],{isExist:a,startIndex:c,nextAccountMeta:m}=this.getFirstInitializedTickArray(e,s);if(!a||c===void 0||!m)throw new Error("Invalid tick array");u.push(m);let{allTrade:p,amountCalculated:d,accounts:f,sqrtPriceX64:y,feeAmount:b}=uo.swapCompute(e.programId,e.id,t,e.tickArrayBitmap,e.exBitmapInfo,s,e.ammConfig.tradeFeeRate,e.liquidity,e.tickCurrent,e.tickSpacing,e.sqrtPriceX64,o,c,r,i);return u.push(...f),{allTrade:p,expectedAmountOut:d.mul(In),remainingAccounts:u,executionPrice:y,feeAmount:b}}static getInputAmountAndRemainAccounts(e,t,n,o,r){let i=n.toBase58()===e.mintB.address,s=[],{isExist:u,startIndex:a,nextAccountMeta:c}=this.getFirstInitializedTickArray(e,i);if(!u||a===void 0||!c)throw new Error("Invalid tick array");try{let y=this.preInitializedTickArrayStartIndex(e,i);if(y.isExist){let{publicKey:b}=Pe(e.programId,e.id,y.nextStartIndex);s.push(b)}}catch{}s.push(c);let{amountCalculated:m,accounts:p,sqrtPriceX64:d,feeAmount:f}=uo.swapCompute(e.programId,e.id,t,e.tickArrayBitmap,e.exBitmapInfo,i,e.ammConfig.tradeFeeRate,e.liquidity,e.tickCurrent,e.tickSpacing,e.sqrtPriceX64,o.mul(In),a,r);return s.push(...p),{expectedAmountIn:m,remainingAccounts:s,executionPrice:d,feeAmount:f}}static getFirstInitializedTickArray(e,t){let{isInitialized:n,startIndex:o}=ve.isOverflowDefaultTickarrayBitmap(e.tickSpacing,[e.tickCurrent])?Si.checkTickArrayIsInit(we.getArrayStartIndex(e.tickCurrent,e.tickSpacing),e.tickSpacing,e.exBitmapInfo):J.checkTickArrayIsInitialized(J.mergeTickArrayBitmap(e.tickArrayBitmap),e.tickCurrent,e.tickSpacing);if(n){let{publicKey:s}=Pe(e.programId,e.id,o);return{isExist:!0,startIndex:o,nextAccountMeta:s}}let{isExist:r,nextStartIndex:i}=this.nextInitializedTickArrayStartIndex(e,we.getArrayStartIndex(e.tickCurrent,e.tickSpacing),t);if(r){let{publicKey:s}=Pe(e.programId,e.id,i);return{isExist:!0,startIndex:i,nextAccountMeta:s}}return{isExist:!1,nextAccountMeta:void 0,startIndex:void 0}}static preInitializedTickArrayStartIndex(e,t){let n=Math.floor(e.tickCurrent/we.tickCount(e.tickSpacing)),o=t?J.searchHightBitFromStart(e.tickArrayBitmap,e.exBitmapInfo,n+1,1,e.tickSpacing):J.searchLowBitFromStart(e.tickArrayBitmap,e.exBitmapInfo,n-1,1,e.tickSpacing);return o.length>0?{isExist:!0,nextStartIndex:o[0]}:{isExist:!1,nextStartIndex:0}}static nextInitializedTickArrayStartIndex(e,t,n){for(t=we.getArrayStartIndex(e.tickCurrent,e.tickSpacing);;){let{isInit:o,tickIndex:r}=xn.nextInitializedTickArrayStartIndex(J.mergeTickArrayBitmap(e.tickArrayBitmap),t,e.tickSpacing,n);if(o)return{isExist:!0,nextStartIndex:r};t=r;let{isInit:i,tickIndex:s}=Si.nextInitializedTickArrayFromOneBitmap(t,e.tickSpacing,n,e.exBitmapInfo);if(i)return{isExist:!0,nextStartIndex:s};if(t=s,t<bt||t>ht)return{isExist:!1,nextStartIndex:0}}}static async updatePoolRewardInfos({connection:e,apiPoolInfo:t,chainTime:n,poolLiquidity:o,rewardInfos:r}){var s,u,a;let i=[];for(let c=0;c<r.length;c++){let m=r[c],p=(a=(s=t.rewardDefaultInfos[c])==null?void 0:s.mint.programId)!=null?a:(u=await e.getAccountInfo(m.tokenMint))==null?void 0:u.owner;if(p===void 0)throw Error("get new reward mint info error");let d=q(v({},m),{perSecond:me.x64ToDecimal(m.emissionsPerSecondX64),remainingRewards:void 0,tokenProgramId:new Et(p)});if(d.tokenMint.equals(Et.default))continue;if(n<=d.openTime.toNumber()||o.eq(ge)){i.push(d);continue}let f=new Ue(Math.min(d.endTime.toNumber(),n)),y=f.sub(d.lastUpdateTime),b=me.mulDivFloor(y,d.emissionsPerSecondX64,o),g=d.rewardGrowthGlobalX64.add(b),P=me.mulDivFloor(y,d.emissionsPerSecondX64,nt),h=d.rewardTotalEmissioned.add(P);i.push(q(v({},d),{rewardGrowthGlobalX64:g,rewardTotalEmissioned:h,lastUpdateTime:f}))}return i}static isOverflowDefaultTickarrayBitmap(e,t){let{maxTickBoundary:n,minTickBoundary:o}=this.tickRange(e);for(let r of t){let i=J.getTickArrayStartIndexByTick(r,e);if(i>=n||i<o)return!0}return!1}static tickRange(e){let t=xn.maxTickInTickarrayBitmap(e),n=-t;return t>ht&&(t=we.getArrayStartIndex(ht,e)+we.tickCount(e)),n<bt&&(n=we.getArrayStartIndex(bt,e)),{maxTickBoundary:t,minTickBoundary:n}}static get_tick_array_offset(e,t){if(!we.checkIsValidStartIndex(e,t))throw new Error("No enough initialized tickArray");return e/we.tickCount(t)*ao}static async fetchExBitmaps({connection:e,exBitmapAddress:t,batchRequest:n}){let o=await Le(e,t.map(i=>({pubkey:i})),{batchRequest:n}),r={};for(let i of o)i.accountInfo!==null&&(r[i.pubkey.toString()]=Qc.decode(i.accountInfo.data));return r}static async fetchMultiplePoolTickArrays({connection:e,poolKeys:t,batchRequest:n}){let o={},r=[];for(let u of t){let a=J.getTickArrayStartIndexByTick(u.tickCurrent,u.tickSpacing),c=J.getInitializedTickArrayInRange(u.tickArrayBitmap,u.exBitmapInfo,u.tickSpacing,a,7);for(let m of c){let{publicKey:p}=Pe(u.programId,u.id,m);r.push({pubkey:p}),o[p.toString()]=u.id}}let i=await Le(e,r,{batchRequest:n}),s={};for(let u of i){if(!u.accountInfo)continue;let a=o[u.pubkey.toString()];if(!a)continue;s[a.toString()]===void 0&&(s[a.toString()]={});let c=Ki.decode(u.accountInfo.data);s[a.toString()][c.startTickIndex]=q(v({},c),{address:u.pubkey})}return s}static async fetchPoolsAccountPosition({pools:e,connection:t,ownerInfo:n,batchRequest:o=!1,updateOwnerRewardAndFee:r=!0}){var s;let i=[];for(let u=0;u<e.length;u++){let a=e[u];a!==null&&(i.find(c=>c.equals(a.state.programId))||i.push(a.state.programId))}if(n){let u=n.tokenAccounts.map(p=>p.accountInfo.mint),a=[];for(let p of u)for(let d of i)a.push(It(d,p).publicKey);let c=await en(t,a,{batchRequest:o}),m={};for(let p of c){if(p===null)continue;let d=_o.decode(p.data),f=d.poolId.toString(),y=e.find(x=>x.state.id.toBase58()===f);if(y===void 0)continue;let b=y.state,g=J._getTickPriceLegacy({poolInfo:b,tick:d.tickLower,baseIn:!0}),P=J._getTickPriceLegacy({poolInfo:b,tick:d.tickUpper,baseIn:!0}),{amountA:h,amountB:I}=Ae.getAmountsFromLiquidity(b.sqrtPriceX64,g.tickSqrtPriceX64,P.tickSqrtPriceX64,d.liquidity,!1),T=1/(1-Math.sqrt(Math.sqrt(g.price.div(P.price).toNumber())));y.positionAccount=[...(s=y.positionAccount)!=null?s:[],{poolId:d.poolId,nftMint:d.nftMint,priceLower:g.price,priceUpper:P.price,amountA:h,amountB:I,tickLower:d.tickLower,tickUpper:d.tickUpper,liquidity:d.liquidity,feeGrowthInsideLastX64A:d.feeGrowthInsideLastX64A,feeGrowthInsideLastX64B:d.feeGrowthInsideLastX64B,tokenFeesOwedA:d.tokenFeesOwedA,tokenFeesOwedB:d.tokenFeesOwedB,rewardInfos:d.rewardInfos.map(x=>q(v({},x),{pendingReward:new Ue(0)})),leverage:T,tokenFeeAmountA:new Ue(0),tokenFeeAmountB:new Ue(0)}];let w=await J.getTickArrayAddressByTick(y.state.programId,d.poolId,d.tickLower,y.state.tickSpacing),K=await J.getTickArrayAddressByTick(y.state.programId,d.poolId,d.tickUpper,y.state.tickSpacing);m[`${y.state.programId.toString()}-${d.poolId.toString()}-${d.tickLower}`]=w,m[`${y.state.programId.toString()}-${d.poolId.toString()}-${d.tickUpper}`]=K}if(r){let p=Object.values(m),d=await en(t,p,{batchRequest:o}),f={};for(let y=0;y<p.length;y++){let b=d[y];if(b===null)continue;let g=p[y].toString();f[g]=Ki.decode(b.data)}for(let{state:y,positionAccount:b}of e)if(!!b)for(let g of b){let P=`${y.programId.toString()}-${y.id.toString()}-${g.tickLower}`,h=`${y.programId.toString()}-${y.id.toString()}-${g.tickUpper}`,I=f[m[P].toString()],T=f[m[h].toString()],w=I.ticks[J.getTickOffsetInArray(g.tickLower,y.tickSpacing)],K=T.ticks[J.getTickOffsetInArray(g.tickUpper,y.tickSpacing)],{tokenFeeAmountA:x,tokenFeeAmountB:S}=await xi.GetPositionFees(y,g,w,K),B=await xi.GetPositionRewards(y,g,w,K);g.tokenFeeAmountA=x.gte(new Ue(0))?x:new Ue(0),g.tokenFeeAmountB=S.gte(new Ue(0))?S:new Ue(0);for(let R=0;R<B.length;R++)g.rewardInfos[R].pendingReward=B[R].gte(new Ue(0))?B[R]:new Ue(0)}}}return e}static computeAmountOut({poolInfo:e,tickArrayCache:t,baseMint:n,epochInfo:o,amountIn:r,slippage:i,priceLimit:s=new ke(0),catchLiquidityInsufficient:u=!1}){var C;let a,c=n.toBase58()===e.mintA.address,[m,p]=c?[e.mintA.extensions.feeConfig,e.mintB.extensions.feeConfig]:[e.mintB.extensions.feeConfig,e.mintA.extensions.feeConfig];s.equals(new ke(0))?a=c?zt.add(new Ue(1)):Yt.sub(new Ue(1)):a=ue.priceToSqrtPriceX64(s,e.mintA.decimals,e.mintB.decimals);let d=xe(r,m,o,!1),{allTrade:f,expectedAmountOut:y,remainingAccounts:b,executionPrice:g,feeAmount:P}=ve.getOutputAmountAndRemainAccounts(e,t,n,d.amount.sub((C=d.fee)!=null?C:ge),a,u),h=xe(y,p,o,!1),I=ue.sqrtPriceX64ToPrice(g,e.mintA.decimals,e.mintB.decimals),T=c?I:new ke(1).div(I),w=y.mul(new Ue(Math.floor((1-i)*1e10))).div(new Ue(1e10)),K=xe(w,p,o,!1),x=c?e.currentPrice:new ke(1).div(e.currentPrice),S=new ke(T).sub(x).abs(),B=x,R=new st(new ke(S).mul(10**15).toFixed(0),new ke(B).mul(10**15).toFixed(0));return{allTrade:f,realAmountIn:d,amountOut:h,minAmountOut:K,expirationTime:tn(d.expirationTime,h.expirationTime),currentPrice:e.currentPrice,executionPrice:T,priceImpact:R,fee:P,remainingAccounts:b,executionPriceX64:g}}static computeAmountOutFormat({poolInfo:e,tickArrayCache:t,amountIn:n,tokenOut:o,slippage:r,epochInfo:i,catchLiquidityInsufficient:s=!1}){let u=o.address===e.mintB.address,[a,c]=u?[e.mintA,e.mintB]:[e.mintB,e.mintA],[m,p]=[new Xe(q(v({},a),{mint:a.address,isToken2022:a.programId===zc.toBase58()})),new Xe(q(v({},c),{mint:c.address,isToken2022:c.programId===zc.toBase58()}))],{allTrade:d,realAmountIn:f,amountOut:y,minAmountOut:b,expirationTime:g,currentPrice:P,executionPrice:h,priceImpact:I,fee:T,remainingAccounts:w,executionPriceX64:K}=ve.computeAmountOut({poolInfo:e,tickArrayCache:t,baseMint:new Et(a.address),amountIn:n,slippage:r,epochInfo:i,catchLiquidityInsufficient:s}),x=q(v({},f),{amount:new Se(m,f.amount),fee:f.fee===void 0?void 0:new Se(m,f.fee)}),S=q(v({},y),{amount:new Se(p,y.amount),fee:y.fee===void 0?void 0:new Se(p,y.fee)}),B=q(v({},b),{amount:new Se(p,b.amount),fee:b.fee===void 0?void 0:new Se(p,b.fee)}),R=new Kt({baseToken:m,denominator:new Ue(10).pow(new Ue(20+m.decimals)),quoteToken:p,numerator:P.mul(new ke(10**(20+p.decimals))).toFixed(0)}),C=new Kt({baseToken:m,denominator:new Ue(10).pow(new Ue(20+m.decimals)),quoteToken:p,numerator:h.mul(new ke(10**(20+p.decimals))).toFixed(0)}),N=new Se(m,T);return{allTrade:d,realAmountIn:x,amountOut:S,minAmountOut:B,expirationTime:g,currentPrice:R,executionPrice:C,priceImpact:I,fee:N,remainingAccounts:w,executionPriceX64:K}}static computeAmountIn({poolInfo:e,tickArrayCache:t,baseMint:n,epochInfo:o,amountOut:r,slippage:i,priceLimit:s=new ke(0)}){var B;let u=n.toBase58()===e.mintA.address,a={[e.mintA.address]:e.mintA.extensions.feeConfig,[e.mintB.address]:e.mintB.extensions.feeConfig},c;s.equals(new ke(0))?c=u?Yt.sub(new Ue(1)):zt.add(new Ue(1)):c=ue.priceToSqrtPriceX64(s,e.mintA.decimals,e.mintB.decimals);let m=xe(r,a[n.toString()],o,!0),{expectedAmountIn:p,remainingAccounts:d,executionPrice:f,feeAmount:y}=ve.getInputAmountAndRemainAccounts(e,t,n,m.amount.sub((B=m.fee)!=null?B:ge),c),b=u?e.mintB.address:e.mintA.address,g=xe(p,a[b],o,!1),P=ue.sqrtPriceX64ToPrice(f,e.mintA.decimals,e.mintB.decimals),h=u?P:new ke(1).div(P),I=p.mul(new Ue(Math.floor((1+i)*1e10))).div(new Ue(1e10)),T=xe(I,a[b],o,!0),w=u?e.currentPrice:new ke(1).div(e.currentPrice),K=new ke(h).sub(w).abs(),x=w,S=new st(new ke(K).mul(10**15).toFixed(0),new ke(x).mul(10**15).toFixed(0));return{amountIn:g,maxAmountIn:T,realAmountOut:m,expirationTime:tn(g.expirationTime,m.expirationTime),currentPrice:e.currentPrice,executionPrice:h,priceImpact:S,fee:y,remainingAccounts:d}}static estimateAprsForPriceRangeMultiplier({poolInfo:e,aprType:t,positionTickLowerIndex:n,positionTickUpperIndex:o}){var f,y,b;let r=e[t],i=J.getTickPrice({poolInfo:e,tick:n,baseIn:!0}).price.toNumber(),s=J.getTickPrice({poolInfo:e,tick:o,baseIn:!0}).price.toNumber(),u=Math.max(i,r.priceMin),c=Math.min(s,r.priceMax)-u,m=s-i,p=r.priceMax-r.priceMin,d;return c<=0?d=0:m===c?d=p/c:p===c?d=c/m:d=c/p*(c/m),{feeApr:r.feeApr*d,rewardsApr:[((f=r.rewardApr[0])!=null?f:0)*d,((y=r.rewardApr[1])!=null?y:0)*d,((b=r.rewardApr[2])!=null?b:0)*d],apr:r.apr*d}}static estimateAprsForPriceRangeDelta({poolInfo:e,poolLiquidity:t,aprType:n,mintPrice:o,liquidity:r,positionTickLowerIndex:i,positionTickUpperIndex:s,chainTime:u}){let a=n==="day"?1:n==="week"?7:n==="month"?30:0,c=e[n],m=o[ft(e.mintA.address).toString()],p=o[ft(e.mintB.address).toString()],d=e.mintA.decimals,f=e.mintB.decimals;if(!c||!m||!p)return{feeApr:0,rewardsApr:[0,0,0],apr:0};let y=ue.priceToSqrtPriceX64(new ke(e.price),e.mintA.decimals,e.mintB.decimals),b=ue.getSqrtPriceX64FromTick(i),g=ue.getSqrtPriceX64FromTick(s),{amountSlippageA:P,amountSlippageB:h}=Ae.getAmountsFromLiquidityWithSlippage(y,b,g,t,!1,!1,0),{amountSlippageA:I,amountSlippageB:T}=Ae.getAmountsFromLiquidityWithSlippage(y,b,g,r,!1,!1,0),w=new ke(P.toString()).div(new ke(10).pow(d)).mul(m.value).add(new ke(h.toString()).div(new ke(10).pow(f)).mul(p.value)),K=new ke(I.toString()).div(new ke(10).pow(d)).mul(m.value).add(new ke(T.toString()).div(new ke(10).pow(f)).mul(p.value)),x=new ke(1).div(w.add(K)),B=new ke(c.volumeFee).mul(365).div(a).mul(x).mul(100).toNumber(),R=3600*24*365,C=e.rewardDefaultInfos.map(N=>{var E,X;let L=N.mint.decimals,O=o[N.mint.address];return u<((E=N.startTime)!=null?E:0)||u>((X=N.endTime)!=null?X:0)||!N.perSecond||!O||L===void 0?0:new ke(O.value).mul(new ke(N.perSecond).mul(R)).div(new ke(10).pow(L)).mul(x).mul(100).toNumber()});return{feeApr:B,rewardsApr:C,apr:B+C.reduce((N,L)=>N+L,0)}}static async getLiquidityAmountOutFromAmountIn({poolInfo:e,inputA:t,tickLower:n,tickUpper:o,amount:r,slippage:i,add:s,epochInfo:u,amountHasFee:a}){var g,P;let c=ue.priceToSqrtPriceX64(new ke(e.price),e.mintA.decimals,e.mintB.decimals),m=ue.getSqrtPriceX64FromTick(n),p=ue.getSqrtPriceX64FromTick(o),d=xe(r,(g=e[t?"mintA":"mintB"].extensions)==null?void 0:g.feeConfig,u,!a),f=new Ue(new ke(d.amount.sub((P=d.fee)!=null?P:ge).toString()).toFixed(0)),y;if(c.lte(m))y=t?Ae.getLiquidityFromTokenAmountA(m,p,f,!s):new Ue(0);else if(c.lte(p)){let h=Ae.getLiquidityFromTokenAmountA(c,p,f,!s),I=Ae.getLiquidityFromTokenAmountB(m,c,f);y=t?h:I}else y=t?new Ue(0):Ae.getLiquidityFromTokenAmountB(m,p,f);let b=await ve.getAmountsFromLiquidity({epochInfo:u,poolInfo:e,tickLower:n,tickUpper:o,liquidity:y,slippage:i,add:s});return{liquidity:y,amountA:t?d:b.amountA,amountB:t?b.amountB:d,amountSlippageA:t?d:b.amountSlippageA,amountSlippageB:t?b.amountSlippageB:d,expirationTime:b.expirationTime}}static async getAmountsFromLiquidity({epochInfo:e,poolInfo:t,tickLower:n,tickUpper:o,liquidity:r,slippage:i,add:s}){var b,g,P,h;let u=ue.getSqrtPriceX64FromTick(n),a=ue.getSqrtPriceX64FromTick(o),c=s?1+i:1-i,m=Ae.getAmountsFromLiquidity(ue.priceToSqrtPriceX64(new ke(t.price),t.mintA.decimals,t.mintB.decimals),u,a,r,s),[p,d]=[xe(m.amountA,(b=t.mintA.extensions)==null?void 0:b.feeConfig,e,!0),xe(m.amountB,(g=t.mintB.extensions)==null?void 0:g.feeConfig,e,!0)],[f,y]=[xe(m.amountA.muln(c),(P=t.mintA.extensions)==null?void 0:P.feeConfig,e,!0),xe(m.amountB.muln(c),(h=t.mintB.extensions)==null?void 0:h.feeConfig,e,!0)];return{liquidity:r,amountA:p,amountB:d,amountSlippageA:f,amountSlippageB:y,expirationTime:tn(p.expirationTime,d.expirationTime)}}static async fetchComputeMultipleClmmInfo({connection:e,poolList:t,rpcDataMap:n={}}){let o=t.filter(u=>!n[u.id]).map(u=>new Et(u.id));(await en(e,o)).forEach((u,a)=>{!u||(n[o[a].toBase58()]=co.decode(u.data))});let i=t.map(u=>je(new Et(u.programId),new Et(u.id)).publicKey),s=await ve.fetchExBitmaps({connection:e,exBitmapAddress:i,batchRequest:!1});return t.reduce((u,a)=>q(v({},u),{[a.id]:q(v({},n[a.id]),{id:new Et(a.id),version:6,programId:new Et(a.programId),mintA:a.mintA,mintB:a.mintB,ammConfig:q(v({},a.config),{id:new Et(a.config.id),fundOwner:""}),currentPrice:new ke(a.price),exBitmapAccount:je(new Et(a.programId),new Et(a.id)).publicKey,exBitmapInfo:s[je(new Et(a.programId),new Et(a.id)).publicKey.toBase58()],startTime:n[a.id].startTime.toNumber(),rewardInfos:n[a.id].rewardInfos})}),{})}static async fetchComputeClmmInfo({connection:e,poolInfo:t,rpcData:n}){return(await this.fetchComputeMultipleClmmInfo({connection:e,rpcDataMap:n?{[t.id]:n}:void 0,poolList:[t]}))[t.id]}};function LT({poolInfo:l,tickLower:e,tickUpper:t,amountA:n,amountB:o,slippage:r,add:i,epochInfo:s,amountHasFee:u}){var h,I,T,w;let[a,c,m,p]=e<t?[e,t,n,o]:[t,e,o,n],d=ue.priceToSqrtPriceX64(new ke(l.price),l.mintA.decimals,l.mintB.decimals),f=ue.getSqrtPriceX64FromTick(a),y=ue.getSqrtPriceX64FromTick(c),[b,g]=[xe(m,(h=l.mintA.extensions)==null?void 0:h.feeConfig,s,!u),xe(p,(I=l.mintB.extensions)==null?void 0:I.feeConfig,s,!u)],P=Ae.getLiquidityFromTokenAmounts(d,f,y,b.amount.sub((T=b.fee)!=null?T:ge),g.amount.sub((w=g.fee)!=null?w:ge));return Ae.getAmountsOutFromLiquidity({poolInfo:l,tickLower:e,tickUpper:t,liquidity:P,slippage:r,add:i,epochInfo:s,amountAddFee:!u})}var Ia={volume:0,volumeQuote:0,volumeFee:0,apr:0,feeApr:0,priceMin:0,priceMax:0,rewardApr:[]};function Yc(l){return q(v({},l),{type:"Concentrated",programId:l.programId.toString(),id:l.id.toString(),rewardDefaultInfos:[],rewardDefaultPoolInfos:"Clmm",price:l.currentPrice.toNumber(),mintAmountA:0,mintAmountB:0,feeRate:l.ammConfig.tradeFeeRate,openTime:l.startTime.toString(),tvl:0,day:Ia,week:Ia,month:Ia,pooltype:[],farmUpcomingCount:0,farmOngoingCount:0,farmFinishedCount:0,burnPercent:0,config:q(v({},l.ammConfig),{id:l.ammConfig.id.toString(),defaultRange:0,defaultRangePoint:[]})})}var me=class{static mulDivRoundingUp(e,t,n){let o=e.mul(t),r=o.div(n);return o.mod(n).eq(ge)||(r=r.add(Vt)),r}static mulDivFloor(e,t,n){if(n.eq(ge))throw new Error("division by 0");return e.mul(t).div(n)}static mulDivCeil(e,t,n){if(n.eq(ge))throw new Error("division by 0");return e.mul(t).add(n.sub(Vt)).div(n)}static x64ToDecimal(e,t){return new fn(e.toString()).div(fn.pow(2,64)).toDecimalPlaces(t)}static decimalToX64(e){return new fe(e.mul(fn.pow(2,64)).floor().toFixed())}static wrappingSubU128(e,t){return e.add(Mr).sub(t).mod(Mr)}};function ut(l,e){return Ba(l.mul(e),64,256)}function lp(l,e,t){let n=l.toTwos(t).shln(e);return n.imaskn(t+1),n.fromTwos(t)}function Ba(l,e,t){let n=l.toTwos(t).shrn(e);return n.imaskn(t-e+1),n.fromTwos(t-e)}var ue=class{static sqrtPriceX64ToPrice(e,t,n){return me.x64ToDecimal(e).pow(2).mul(fn.pow(10,t-n))}static priceToSqrtPriceX64(e,t,n){return me.decimalToX64(e.mul(fn.pow(10,n-t)).sqrt())}static getNextSqrtPriceX64FromInput(e,t,n,o){if(!e.gt(ge))throw new Error("sqrtPriceX64 must greater than 0");if(!t.gt(ge))throw new Error("liquidity must greater than 0");return o?this.getNextSqrtPriceFromTokenAmountARoundingUp(e,t,n,!0):this.getNextSqrtPriceFromTokenAmountBRoundingDown(e,t,n,!0)}static getNextSqrtPriceX64FromOutput(e,t,n,o){if(!e.gt(ge))throw new Error("sqrtPriceX64 must greater than 0");if(!t.gt(ge))throw new Error("liquidity must greater than 0");return o?this.getNextSqrtPriceFromTokenAmountBRoundingDown(e,t,n,!1):this.getNextSqrtPriceFromTokenAmountARoundingUp(e,t,n,!1)}static getNextSqrtPriceFromTokenAmountARoundingUp(e,t,n,o){if(n.eq(ge))return e;let r=t.shln(hi);if(o){let i=r,s=r.add(n.mul(e));return s.gte(i)?me.mulDivCeil(i,e,s):me.mulDivRoundingUp(i,Vt,i.div(e).add(n))}else{let i=n.mul(e);if(!r.gt(i))throw new Error("getNextSqrtPriceFromTokenAmountARoundingUp,liquidityLeftShift must gt amountMulSqrtPrice");let s=r.sub(i);return me.mulDivCeil(r,e,s)}}static getNextSqrtPriceFromTokenAmountBRoundingDown(e,t,n,o){let r=n.shln(hi);if(o)return e.add(r.div(t));{let i=me.mulDivRoundingUp(r,Vt,t);if(!e.gt(i))throw new Error("getNextSqrtPriceFromTokenAmountBRoundingDown sqrtPriceX64 must gt amountDivLiquidity");return e.sub(i)}}static getSqrtPriceX64FromTick(e){if(!Number.isInteger(e))throw new Error("tick must be integer");if(e<bt||e>ht)throw new Error("tick must be in MIN_TICK and MAX_TICK");let t=e<0?e*-1:e,n=(t&1)!=0?new fe("18445821805675395072"):new fe("18446744073709551616");return(t&2)!=0&&(n=ut(n,new fe("18444899583751176192"))),(t&4)!=0&&(n=ut(n,new fe("18443055278223355904"))),(t&8)!=0&&(n=ut(n,new fe("18439367220385607680"))),(t&16)!=0&&(n=ut(n,new fe("18431993317065453568"))),(t&32)!=0&&(n=ut(n,new fe("18417254355718170624"))),(t&64)!=0&&(n=ut(n,new fe("18387811781193609216"))),(t&128)!=0&&(n=ut(n,new fe("18329067761203558400"))),(t&256)!=0&&(n=ut(n,new fe("18212142134806163456"))),(t&512)!=0&&(n=ut(n,new fe("17980523815641700352"))),(t&1024)!=0&&(n=ut(n,new fe("17526086738831433728"))),(t&2048)!=0&&(n=ut(n,new fe("16651378430235570176"))),(t&4096)!=0&&(n=ut(n,new fe("15030750278694412288"))),(t&8192)!=0&&(n=ut(n,new fe("12247334978884435968"))),(t&16384)!=0&&(n=ut(n,new fe("8131365268886854656"))),(t&32768)!=0&&(n=ut(n,new fe("3584323654725218816"))),(t&65536)!=0&&(n=ut(n,new fe("696457651848324352"))),(t&131072)!=0&&(n=ut(n,new fe("26294789957507116"))),(t&262144)!=0&&(n=ut(n,new fe("37481735321082"))),e>0&&(n=Nc.div(n)),n}static getTickFromPrice(e,t,n){return ue.getTickFromSqrtPriceX64(ue.priceToSqrtPriceX64(e,t,n))}static getTickFromSqrtPriceX64(e){if(e.gt(Yt)||e.lt(zt))throw new Error("Provided sqrtPrice is not within the supported sqrtPrice range.");let t=e.bitLength()-1,n=new fe(t-64),o=lp(n,32,128),r=new fe("8000000000000000","hex"),i=0,s=new fe(0),u=t>=64?e.shrn(t-63):e.shln(63-t);for(;r.gt(new fe(0))&&i<Mc;){u=u.mul(u);let f=u.shrn(127);u=u.shrn(63+f.toNumber()),s=s.add(r.mul(f)),r=r.shrn(1),i+=1}let a=s.shrn(32),m=o.add(a).mul(new fe(vc)),p=Ba(m.sub(new fe(Fc)),64,128).toNumber(),d=Ba(m.add(new fe(_c)),64,128).toNumber();return p==d?p:ue.getSqrtPriceX64FromTick(d).lte(e)?d:p}},lo=class{static getTickWithPriceAndTickspacing(e,t,n,o){let i=ue.getTickFromSqrtPriceX64(ue.priceToSqrtPriceX64(e,n,o))/t;return i<0?i=Math.floor(i):i=Math.ceil(i),i*t}static roundPriceWithTickspacing(e,t,n,o){let r=lo.getTickWithPriceAndTickspacing(e,t,n,o),i=ue.getSqrtPriceX64FromTick(r);return ue.sqrtPriceX64ToPrice(i,n,o)}},Ae=class{static addDelta(e,t){return e.add(t)}static getTokenAmountAFromLiquidity(e,t,n,o){if(e.gt(t)&&([e,t]=[t,e]),!e.gt(ge))throw new Error("sqrtPriceX64A must greater than 0");let r=n.ushln(hi),i=t.sub(e);return o?me.mulDivRoundingUp(me.mulDivCeil(r,i,t),Vt,e):me.mulDivFloor(r,i,t).div(e)}static getTokenAmountBFromLiquidity(e,t,n,o){if(e.gt(t)&&([e,t]=[t,e]),!e.gt(ge))throw new Error("sqrtPriceX64A must greater than 0");return o?me.mulDivCeil(n,t.sub(e),nt):me.mulDivFloor(n,t.sub(e),nt)}static getLiquidityFromTokenAmountA(e,t,n,o){e.gt(t)&&([e,t]=[t,e]);let r=n.mul(e).mul(t),i=t.sub(e),s=r.div(i);return o?me.mulDivRoundingUp(s,Vt,Ti):s.shrn(hi)}static getLiquidityFromTokenAmountB(e,t,n){return e.gt(t)&&([e,t]=[t,e]),me.mulDivFloor(n,Ti,t.sub(e))}static getLiquidityFromTokenAmounts(e,t,n,o,r){if(t.gt(n)&&([t,n]=[n,t]),e.lte(t))return Ae.getLiquidityFromTokenAmountA(t,n,o,!1);if(e.lt(n)){let i=Ae.getLiquidityFromTokenAmountA(e,n,o,!1),s=Ae.getLiquidityFromTokenAmountB(t,e,r);return i.lt(s)?i:s}else return Ae.getLiquidityFromTokenAmountB(t,n,r)}static getAmountsFromLiquidity(e,t,n,o,r){if(t.gt(n)&&([t,n]=[n,t]),e.lte(t))return{amountA:Ae.getTokenAmountAFromLiquidity(t,n,o,r),amountB:new fe(0)};if(e.lt(n)){let i=Ae.getTokenAmountAFromLiquidity(e,n,o,r),s=Ae.getTokenAmountBFromLiquidity(t,e,o,r);return{amountA:i,amountB:s}}else return{amountA:new fe(0),amountB:Ae.getTokenAmountBFromLiquidity(t,n,o,r)}}static getAmountsFromLiquidityWithSlippage(e,t,n,o,r,i,s){let{amountA:u,amountB:a}=Ae.getAmountsFromLiquidity(e,t,n,o,i),c=r?1+s:1-s,m=new fe(new fn(u.toString()).mul(c).toFixed(0)),p=new fe(new fn(a.toString()).mul(c).toFixed(0));return{amountSlippageA:m,amountSlippageB:p}}static getAmountsOutFromLiquidity({poolInfo:e,tickLower:t,tickUpper:n,liquidity:o,slippage:r,add:i,epochInfo:s,amountAddFee:u}){var P,h,I,T;let a=ue.priceToSqrtPriceX64(new fn(e.price),e.mintA.decimals,e.mintB.decimals),c=ue.getSqrtPriceX64FromTick(t),m=ue.getSqrtPriceX64FromTick(n),p=i?1+r:1-r,d=Ae.getAmountsFromLiquidity(a,c,m,o,i),[f,y]=[xe(d.amountA,(P=e.mintA.extensions)==null?void 0:P.feeConfig,s,u),xe(d.amountB,(h=e.mintB.extensions)==null?void 0:h.feeConfig,s,u)],[b,g]=[xe(new fe(new fn(d.amountA.toString()).mul(p).toFixed(0)),(I=e.mintA.extensions)==null?void 0:I.feeConfig,s,u),xe(new fe(new fn(d.amountB.toString()).mul(p).toFixed(0)),(T=e.mintB.extensions)==null?void 0:T.feeConfig,s,u)];return{liquidity:o,amountA:f,amountB:y,amountSlippageA:b,amountSlippageB:g,expirationTime:tn(f.expirationTime,y.expirationTime)}}},uo=class{static swapCompute(e,t,n,o,r,i,s,u,a,c,m,p,d,f,y=!1){if(p.eq(ge))throw new Error("amountSpecified must not be 0");if(f||(f=i?zt.add(Vt):Yt.sub(Vt)),i){if(f.lt(zt))throw new Error("sqrtPriceX64 must greater than MIN_SQRT_PRICE_X64");if(f.gte(m))throw new Error("sqrtPriceX64 must smaller than current")}else{if(f.gt(Yt))throw new Error("sqrtPriceX64 must smaller than MAX_SQRT_PRICE_X64");if(f.lte(m))throw new Error("sqrtPriceX64 must greater than current")}let b=p.gt(ge),g={amountSpecifiedRemaining:p,amountCalculated:ge,sqrtPriceX64:m,tick:a>d?Math.min(d+we.tickCount(c)-1,a):d,accounts:[],liquidity:u,feeAmount:new fe(0)},P=d,h=n[d],I=0,T=!i&&h.startTickIndex===g.tick;for(;!g.amountSpecifiedRemaining.eq(ge)&&!g.sqrtPriceX64.eq(f);){I>10;let w={};w.sqrtPriceStartX64=g.sqrtPriceX64;let K=J.nextInitTick(h,g.tick,c,i,T),x=K||null,S=null;if(!(x!=null&&x.liquidityGross.gtn(0))){let R=ve.nextInitializedTickArrayStartIndex({tickCurrent:g.tick,tickSpacing:c,tickArrayBitmap:o,exBitmapInfo:r},P,i);if(!R.isExist){if(y)return{allTrade:!1,amountSpecifiedRemaining:g.amountSpecifiedRemaining,amountCalculated:g.amountCalculated,feeAmount:g.feeAmount,sqrtPriceX64:g.sqrtPriceX64,liquidity:g.liquidity,tickCurrent:g.tick,accounts:g.accounts};throw Error("swapCompute LiquidityInsufficient")}P=R.nextStartIndex;let{publicKey:C}=Pe(e,t,P);S=C,h=n[P];try{x=J.firstInitializedTick(h,i)}catch{throw Error("not found next tick info")}}w.tickNext=x.tick,w.initialized=x.liquidityGross.gtn(0),d!==P&&S&&(g.accounts.push(S),d=P),w.tickNext<bt?w.tickNext=bt:w.tickNext>ht&&(w.tickNext=ht),w.sqrtPriceNextX64=ue.getSqrtPriceX64FromTick(w.tickNext);let B;if(i&&w.sqrtPriceNextX64.lt(f)||!i&&w.sqrtPriceNextX64.gt(f)?B=f:B=w.sqrtPriceNextX64,[g.sqrtPriceX64,w.amountIn,w.amountOut,w.feeAmount]=uo.swapStepCompute(g.sqrtPriceX64,B,g.liquidity,g.amountSpecifiedRemaining,s,i),g.feeAmount=g.feeAmount.add(w.feeAmount),b?(g.amountSpecifiedRemaining=g.amountSpecifiedRemaining.sub(w.amountIn.add(w.feeAmount)),g.amountCalculated=g.amountCalculated.sub(w.amountOut)):(g.amountSpecifiedRemaining=g.amountSpecifiedRemaining.add(w.amountOut),g.amountCalculated=g.amountCalculated.add(w.amountIn.add(w.feeAmount))),g.sqrtPriceX64.eq(w.sqrtPriceNextX64)){if(w.initialized){let R=x.liquidityNet;i&&(R=R.mul(In)),g.liquidity=Ae.addDelta(g.liquidity,R)}T=w.tickNext!=g.tick&&!i&&h.startTickIndex===w.tickNext,g.tick=i?w.tickNext-1:w.tickNext}else if(g.sqrtPriceX64!=w.sqrtPriceStartX64){let R=ue.getTickFromSqrtPriceX64(g.sqrtPriceX64);T=R!=g.tick&&!i&&h.startTickIndex===R,g.tick=R}++I}try{let{nextStartIndex:w,isExist:K}=we.nextInitializedTickArray(g.tick,c,i,o,r);K&&d!==w&&(g.accounts.push(Pe(e,t,w).publicKey),d=w)}catch{}return{allTrade:!0,amountSpecifiedRemaining:ge,amountCalculated:g.amountCalculated,feeAmount:g.feeAmount,sqrtPriceX64:g.sqrtPriceX64,liquidity:g.liquidity,tickCurrent:g.tick,accounts:g.accounts}}static swapStepCompute(e,t,n,o,r,i){let s={sqrtPriceX64Next:new fe(0),amountIn:new fe(0),amountOut:new fe(0),feeAmount:new fe(0)},u=o.gte(ge);if(u){let c=me.mulDivFloor(o,_r.sub(new fe(r.toString())),_r);s.amountIn=i?Ae.getTokenAmountAFromLiquidity(t,e,n,!0):Ae.getTokenAmountBFromLiquidity(e,t,n,!0),c.gte(s.amountIn)?s.sqrtPriceX64Next=t:s.sqrtPriceX64Next=ue.getNextSqrtPriceX64FromInput(e,n,c,i)}else s.amountOut=i?Ae.getTokenAmountBFromLiquidity(t,e,n,!1):Ae.getTokenAmountAFromLiquidity(e,t,n,!1),o.mul(In).gte(s.amountOut)?s.sqrtPriceX64Next=t:s.sqrtPriceX64Next=ue.getNextSqrtPriceX64FromOutput(e,n,o.mul(In),i);let a=t.eq(s.sqrtPriceX64Next);return i?(a&&u||(s.amountIn=Ae.getTokenAmountAFromLiquidity(s.sqrtPriceX64Next,e,n,!0)),a&&!u||(s.amountOut=Ae.getTokenAmountBFromLiquidity(s.sqrtPriceX64Next,e,n,!1))):(s.amountIn=a&&u?s.amountIn:Ae.getTokenAmountBFromLiquidity(e,s.sqrtPriceX64Next,n,!0),s.amountOut=a&&!u?s.amountOut:Ae.getTokenAmountAFromLiquidity(e,s.sqrtPriceX64Next,n,!1)),!u&&s.amountOut.gt(o.mul(In))&&(s.amountOut=o.mul(In)),u&&!s.sqrtPriceX64Next.eq(t)?s.feeAmount=o.sub(s.amountIn):s.feeAmount=me.mulDivCeil(s.amountIn,new fe(r),_r.sub(new fe(r))),[s.sqrtPriceX64Next,s.amountIn,s.amountOut,s.feeAmount]}};var ot=60,ao=512,J=class{static getTickArrayAddressByTick(e,t,n,o){let r=J.getTickArrayStartIndexByTick(n,o),{publicKey:i}=Pe(e,t,r);return i}static getTickOffsetInArray(e,t){if(e%t!=0)throw new Error("tickIndex % tickSpacing not equal 0");let n=J.getTickArrayStartIndexByTick(e,t),o=Math.floor((e-n)/t);if(o<0||o>=ot)throw new Error("tick offset in array overflow");return o}static getTickArrayBitIndex(e,t){let n=we.tickCount(t),o=e/n;return e<0&&e%n!=0?o=Math.ceil(o)-1:o=Math.floor(o),o}static getTickArrayStartIndexByTick(e,t){return this.getTickArrayBitIndex(e,t)*we.tickCount(t)}static getTickArrayOffsetInBitmapByTick(e,t){let n=t*ot,o=Math.floor(e/n)+512;return Math.abs(o)}static checkTickArrayIsInitialized(e,t,n){let o=n*ot,r=Math.floor(t/o)+512,i=Math.abs(r);return{isInitialized:e.testn(i),startIndex:(i-512)*o}}static getNextTickArrayStartIndex(e,t,n){return n?e-t*ot:e+t*ot}static mergeTickArrayBitmap(e){let t=new mp(0);for(let n=0;n<e.length;n++)t=t.add(e[n].shln(64*n));return t}static getInitializedTickArrayInRange(e,t,n,o,r){let i=Math.floor(o/(n*ot));return[...J.searchLowBitFromStart(e,t,i-1,r,n),...J.searchHightBitFromStart(e,t,i,r,n)]}static getAllInitializedTickArrayStartIndex(e,t,n){return J.searchHightBitFromStart(e,t,-7680,ao,n)}static getAllInitializedTickArrayInfo(e,t,n,o,r){let i=[],s=J.getAllInitializedTickArrayStartIndex(n,o,r);for(let u of s){let{publicKey:a}=Pe(e,t,u);i.push({tickArrayStartIndex:u,tickArrayAddress:a})}return i}static getAllInitializedTickInTickArray(e){return e.ticks.filter(t=>t.liquidityGross.gtn(0))}static searchLowBitFromStart(e,t,n,o,r){let i=[...[...t.negativeTickArrayBitmap].reverse(),e.slice(0,8),e.slice(8,16),...t.positiveTickArrayBitmap].map(a=>J.mergeTickArrayBitmap(a)),s=[];for(;n>=-7680;){let a=Math.floor((n+7680)/512),c=(n+7680)%512;if(i[a].testn(c)&&s.push(n),n--,s.length===o)break}let u=we.tickCount(r);return s.map(a=>a*u)}static searchHightBitFromStart(e,t,n,o,r){let i=[...[...t.negativeTickArrayBitmap].reverse(),e.slice(0,8),e.slice(8,16),...t.positiveTickArrayBitmap].map(a=>J.mergeTickArrayBitmap(a)),s=[];for(;n<7680;){let a=Math.floor((n+7680)/512),c=(n+7680)%512;if(i[a].testn(c)&&s.push(n),n++,s.length===o)break}let u=we.tickCount(r);return s.map(a=>a*u)}static checkIsOutOfBoundary(e){return e<bt||e>ht}static nextInitTick(e,t,n,o,r){if(we.getArrayStartIndex(t,n)!=e.startTickIndex)return null;let s=Math.floor((t-e.startTickIndex)/n);if(o)for(;s>=0;){if(e.ticks[s].liquidityGross.gtn(0))return e.ticks[s];s=s-1}else for(r||(s=s+1);s<ot;){if(e.ticks[s].liquidityGross.gtn(0))return e.ticks[s];s=s+1}return null}static firstInitializedTick(e,t){if(t){let n=ot-1;for(;n>=0;){if(e.ticks[n].liquidityGross.gtn(0))return e.ticks[n];n=n-1}}else{let n=0;for(;n<ot;){if(e.ticks[n].liquidityGross.gtn(0))return e.ticks[n];n=n+1}}throw Error(`firstInitializedTick check error: ${e} - ${t}`)}static _getTickPriceLegacy({poolInfo:e,tick:t,baseIn:n}){let o=ue.getSqrtPriceX64FromTick(t),r=ue.sqrtPriceX64ToPrice(o,e.mintA.decimals,e.mintB.decimals);return n?{tick:t,price:r,tickSqrtPriceX64:o}:{tick:t,price:new Vo(1).div(r),tickSqrtPriceX64:o}}static _getPriceAndTickLegacy({poolInfo:e,price:t,baseIn:n}){let o=n?t:new Vo(1).div(t),r=lo.getTickWithPriceAndTickspacing(o,e.ammConfig.tickSpacing,e.mintA.decimals,e.mintB.decimals),i=ue.getSqrtPriceX64FromTick(r),s=ue.sqrtPriceX64ToPrice(i,e.mintA.decimals,e.mintB.decimals);return n?{tick:r,price:s}:{tick:r,price:new Vo(1).div(s)}}static getTickPrice({poolInfo:e,tick:t,baseIn:n}){let o=ue.getSqrtPriceX64FromTick(t),r=ue.sqrtPriceX64ToPrice(o,e.mintA.decimals,e.mintB.decimals);return n?{tick:t,price:r,tickSqrtPriceX64:o}:{tick:t,price:new Vo(1).div(r),tickSqrtPriceX64:o}}static getPriceAndTick({poolInfo:e,price:t,baseIn:n}){let o=n?t:new Vo(1).div(t),r=lo.getTickWithPriceAndTickspacing(o,e.config.tickSpacing,e.mintA.decimals,e.mintB.decimals),i=ue.getSqrtPriceX64FromTick(r),s=ue.sqrtPriceX64ToPrice(i,e.mintA.decimals,e.mintB.decimals);return n?{tick:r,price:s}:{tick:r,price:new Vo(1).div(s)}}};var Hc=F([Te(8),V("bump"),_t("index"),M(""),ct("protocolFeeRate"),ct("tradeFeeRate"),_t("tickSpacing"),Q(A(),8,"")]),dp=F([ct("blockTimestamp"),Lo("tickCumulative"),Q(A(),4)]),jc=F([Te(8),qe("initialized"),A("recentEpoch"),_t("observationIndex"),M("poolId"),Q(dp,100,"observations"),Q(A(),4)]),pp=F([V("rewardState"),A("openTime"),A("endTime"),A("lastUpdateTime"),ie("emissionsPerSecondX64"),A("rewardTotalEmissioned"),A("rewardClaimed"),M("tokenMint"),M("tokenVault"),M("creator"),ie("rewardGrowthGlobalX64")]),co=F([Te(8),V("bump"),M("ammConfig"),M("creator"),M("mintA"),M("mintB"),M("vaultA"),M("vaultB"),M("observationId"),V("mintDecimalsA"),V("mintDecimalsB"),_t("tickSpacing"),ie("liquidity"),ie("sqrtPriceX64"),De("tickCurrent"),ct(),ie("feeGrowthGlobalX64A"),ie("feeGrowthGlobalX64B"),A("protocolFeesTokenA"),A("protocolFeesTokenB"),ie("swapInAmountTokenA"),ie("swapOutAmountTokenB"),ie("swapInAmountTokenB"),ie("swapOutAmountTokenA"),V("status"),Q(V(),7,""),Q(pp,3,"rewardInfos"),Q(A(),16,"tickArrayBitmap"),A("totalFeesTokenA"),A("totalFeesClaimedTokenA"),A("totalFeesTokenB"),A("totalFeesClaimedTokenB"),A("fundFeesTokenA"),A("fundFeesTokenB"),A("startTime"),Q(A(),15*4-3,"padding")]),fp=F([ie("growthInsideLastX64"),A("rewardAmountOwed")]),_o=F([Te(8),V("bump"),M("nftMint"),M("poolId"),De("tickLower"),De("tickUpper"),ie("liquidity"),ie("feeGrowthInsideLastX64A"),ie("feeGrowthInsideLastX64B"),A("tokenFeesOwedA"),A("tokenFeesOwedB"),Q(fp,3,"rewardInfos"),Q(A(),8,"")]),th=F([Te(8),V("bump"),M("poolId"),De("tickLowerIndex"),De("tickUpperIndex"),ie("liquidity"),ie("feeGrowthInsideLastX64A"),ie("feeGrowthInsideLastX64B"),A("tokenFeesOwedA"),A("tokenFeesOwedB"),Q(ie(),3,"rewardGrowthInside"),Q(A(),8,"")]),yp=F([De("tick"),cc("liquidityNet"),ie("liquidityGross"),ie("feeGrowthOutsideX64A"),ie("feeGrowthOutsideX64B"),Q(ie(),3,"rewardGrowthsOutsideX64"),Q(ct(),13,"")]),Ki=F([Te(8),M("poolId"),De("startTickIndex"),Q(yp,ot,"ticks"),V("initializedTickCount"),Q(V(),115,"")]),$c=F([Te(329),Q(M(),100,"whitelistMints")]),Qc=F([Te(8),M("poolId"),Q(Q(A(),8),ha,"positiveTickArrayBitmap"),Q(Q(A(),8),ha,"negativeTickArrayBitmap")]),nh=F([A(),V("bump"),M("owner"),M("poolId"),M("positionId"),M("nftAccount"),Q(A(),8)]),Zc=F([Te(8),V("bump"),M("lockOwner"),M("poolId"),M("positionId"),M("nftAccount"),M("lockNftMint"),A("recentEpoch"),Q(A(),8)]);jc.span;var Jc=be("Raydium_Clmm"),Wt={createPool:[233,146,209,142,207,104,64,188],initReward:[95,135,192,196,242,129,230,68],setRewardEmissions:[112,52,167,75,32,201,211,137],openPosition:[77,184,74,214,112,86,241,199],openPositionWithTokenEx:[77,255,174,82,125,29,201,46],closePosition:[123,134,81,0,49,68,98,98],increaseLiquidity:[133,29,89,223,69,238,176,10],decreaseLiquidity:[58,127,188,62,79,82,196,96],swap:[43,4,237,11,26,201,30,98],collectReward:[18,237,166,197,34,16,213,144]},el=[188,37,179,131,82,150,84,73],tl=[16,72,250,198,14,162,212,19],Re=class{static createPoolInstruction(e,t,n,o,r,i,s,u,a,c,m,p,d,f){let y=F([ie("sqrtPriceX64"),A("zero")]),b=[{pubkey:n,isSigner:!0,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!1},{pubkey:a,isSigner:!1,isWritable:!1},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:p,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!1},{pubkey:m,isSigner:!1,isWritable:!1},{pubkey:Kn.programId,isSigner:!1,isWritable:!1},{pubkey:Ze,isSigner:!1,isWritable:!1},...(f==null?void 0:f.map(h=>({pubkey:h,isSigner:!1,isWritable:!1})))||[]],g=Buffer.alloc(y.span);y.encode({sqrtPriceX64:d,zero:ge},g);let P=Buffer.from([...Wt.createPool,...g]);return new mt({keys:b,programId:e,data:P})}static async createPoolInstructions(e){let{programId:t,owner:n,mintA:o,mintB:r,ammConfigId:i,initialPriceX64:s,extendMintAccount:u}=e,[a,c]=[new z(o.address),new z(r.address)],{publicKey:m}=qc(t,i,a,c),{publicKey:p}=Gc(t,m),{publicKey:d}=Aa(t,m,a),{publicKey:f}=Aa(t,m,c),y=je(t,m).publicKey,b=[this.createPoolInstruction(t,m,n,i,p,a,d,new z(o.programId||Ce),c,f,new z(r.programId||Ce),y,s,u)];return{signers:[],instructions:b,instructionTypes:[G.CreateAccount,G.ClmmCreatePool],address:{poolId:m,observationId:p,exBitmapAccount:y,mintAVault:d,mintBVault:f},lookupTableAddress:[]}}static openPositionFromLiquidityInstruction(e,t,n,o,r,i,s,u,a,c,m,p,d,f,y,b,g,P,h,I,T,w,K,x,S,B){let R=F([De("tickLowerIndex"),De("tickUpperIndex"),De("tickArrayLowerStartIndex"),De("tickArrayUpperStartIndex"),ie("liquidity"),A("amountMaxA"),A("amountMaxB"),qe("withMetadata"),V("optionBaseFlag"),qe("baseFlag")]),C=[...B?[{pubkey:B,isSigner:!1,isWritable:!0}]:[]],N=[{pubkey:t,isSigner:!0,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!0,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:m,isSigner:!1,isWritable:!0},{pubkey:p,isSigner:!1,isWritable:!0},{pubkey:d,isSigner:!1,isWritable:!0},{pubkey:f,isSigner:!1,isWritable:!0},{pubkey:y,isSigner:!1,isWritable:!0},{pubkey:Ze,isSigner:!1,isWritable:!1},{pubkey:Kn.programId,isSigner:!1,isWritable:!1},{pubkey:Ce,isSigner:!1,isWritable:!1},{pubkey:Ci,isSigner:!1,isWritable:!1},{pubkey:Ut,isSigner:!1,isWritable:!1},{pubkey:Ye,isSigner:!1,isWritable:!1},{pubkey:b,isSigner:!1,isWritable:!1},{pubkey:g,isSigner:!1,isWritable:!1},...C],L=Buffer.alloc(R.span);R.encode({tickLowerIndex:P,tickUpperIndex:h,tickArrayLowerStartIndex:I,tickArrayUpperStartIndex:T,liquidity:w,amountMaxA:K,amountMaxB:x,withMetadata:S==="create",baseFlag:!1,optionBaseFlag:0},L);let O=Buffer.from([...Wt.openPosition,...L]);return new mt({keys:N,programId:e,data:O})}static openPositionFromLiquidityInstruction22(e,t,n,o,r,i,s,u,a,c,m,p,d,f,y,b,g,P,h,I,T,w,K,x,S){let B=F([De("tickLowerIndex"),De("tickUpperIndex"),De("tickArrayLowerStartIndex"),De("tickArrayUpperStartIndex"),ie("liquidity"),A("amountMaxA"),A("amountMaxB"),qe("withMetadata"),V("optionBaseFlag"),qe("baseFlag")]),R=[...S?[{pubkey:S,isSigner:!1,isWritable:!0}]:[]],C=[{pubkey:t,isSigner:!0,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!0,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:m,isSigner:!1,isWritable:!0},{pubkey:p,isSigner:!1,isWritable:!0},{pubkey:d,isSigner:!1,isWritable:!0},{pubkey:f,isSigner:!1,isWritable:!0},{pubkey:Ze,isSigner:!1,isWritable:!1},{pubkey:Kn.programId,isSigner:!1,isWritable:!1},{pubkey:Ce,isSigner:!1,isWritable:!1},{pubkey:Ci,isSigner:!1,isWritable:!1},{pubkey:Ye,isSigner:!1,isWritable:!1},{pubkey:y,isSigner:!1,isWritable:!1},{pubkey:b,isSigner:!1,isWritable:!1},...R],N=Buffer.alloc(B.span);B.encode({tickLowerIndex:g,tickUpperIndex:P,tickArrayLowerStartIndex:h,tickArrayUpperStartIndex:I,liquidity:T,amountMaxA:w,amountMaxB:K,withMetadata:x==="create",baseFlag:!1,optionBaseFlag:0},N);let L=Buffer.from([...Wt.openPositionWithTokenEx,...N]);return new mt({keys:C,programId:e,data:L})}static async openPositionInstructions({poolInfo:e,poolKeys:t,ownerInfo:n,tickLower:o,tickUpper:r,liquidity:i,amountMaxA:s,amountMaxB:u,withMetadata:a,getEphemeralSigners:c,nft2022:m}){let p=[],[d,f]=[new z(e.programId),new z(e.id)],y;if(c)y=new z((await c(1))[0]);else{let S=Wr.generate();p.push(S),y=S.publicKey}let b=J.getTickArrayStartIndexByTick(o,e.config.tickSpacing),g=J.getTickArrayStartIndexByTick(r,e.config.tickSpacing),{publicKey:P}=Pe(d,f,b),{publicKey:h}=Pe(d,f,g),{publicKey:I}=m?$(n.wallet,y,Ye):$(n.wallet,y,Ce),{publicKey:T}=Bn(y),{publicKey:w}=It(d,y),{publicKey:K}=rn(d,f,o,r),x=m?this.openPositionFromLiquidityInstruction22(d,n.feePayer,f,n.wallet,y,I,K,P,h,w,n.tokenAccountA,n.tokenAccountB,new z(t.vault.A),new z(t.vault.B),new z(e.mintA.address),new z(e.mintB.address),o,r,b,g,i,s,u,a,ve.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing,[b,g])?je(d,f).publicKey:void 0):this.openPositionFromLiquidityInstruction(d,n.feePayer,f,n.wallet,y,I,T,K,P,h,w,n.tokenAccountA,n.tokenAccountB,new z(t.vault.A),new z(t.vault.B),new z(e.mintA.address),new z(e.mintB.address),o,r,b,g,i,s,u,a,ve.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing,[b,g])?je(d,f).publicKey:void 0);return{signers:p,instructions:[x],instructionTypes:[G.ClmmOpenPosition],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[],address:{nftMint:y,tickArrayLower:P,tickArrayUpper:h,positionNftAccount:I,metadataAccount:T,personalPosition:w,protocolPosition:K}}}static async openPositionFromBaseInstructions({poolInfo:e,poolKeys:t,ownerInfo:n,tickLower:o,tickUpper:r,base:i,baseAmount:s,otherAmountMax:u,withMetadata:a,getEphemeralSigners:c,nft2022:m}){let p=[],[d,f]=[new z(e.programId),new z(e.id)],y;if(c)y=new z((await c(1))[0]);else{let S=Wr.generate();p.push(S),y=S.publicKey}let b=J.getTickArrayStartIndexByTick(o,e.config.tickSpacing),g=J.getTickArrayStartIndexByTick(r,e.config.tickSpacing),{publicKey:P}=Pe(d,f,b),{publicKey:h}=Pe(d,f,g),{publicKey:I}=m?$(n.wallet,y,Ye):$(n.wallet,y,Ce),{publicKey:T}=Bn(y),{publicKey:w}=It(d,y),{publicKey:K}=rn(d,f,o,r),x=m?this.openPositionFromBaseInstruction22(d,n.feePayer,f,n.wallet,y,I,K,P,h,w,n.tokenAccountA,n.tokenAccountB,new z(t.vault.A),new z(t.vault.B),new z(e.mintA.address),new z(e.mintB.address),o,r,b,g,a,i,s,u,ve.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing,[b,g])?je(d,f).publicKey:void 0):this.openPositionFromBaseInstruction(d,n.feePayer,f,n.wallet,y,I,T,K,P,h,w,n.tokenAccountA,n.tokenAccountB,new z(t.vault.A),new z(t.vault.B),new z(e.mintA.address),new z(e.mintB.address),o,r,b,g,a,i,s,u,ve.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing,[b,g])?je(d,f).publicKey:void 0);return{address:{nftMint:y,tickArrayLower:P,tickArrayUpper:h,positionNftAccount:I,metadataAccount:T,personalPosition:w,protocolPosition:K},instructions:[x],signers:p,instructionTypes:[G.ClmmOpenPosition],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[]}}static openPositionFromBaseInstruction(e,t,n,o,r,i,s,u,a,c,m,p,d,f,y,b,g,P,h,I,T,w,K,x,S,B){let R=F([De("tickLowerIndex"),De("tickUpperIndex"),De("tickArrayLowerStartIndex"),De("tickArrayUpperStartIndex"),ie("liquidity"),A("amountMaxA"),A("amountMaxB"),qe("withMetadata"),V("optionBaseFlag"),qe("baseFlag")]),C=[...B?[{pubkey:B,isSigner:!1,isWritable:!0}]:[]],N=[{pubkey:t,isSigner:!0,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!0,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:m,isSigner:!1,isWritable:!0},{pubkey:p,isSigner:!1,isWritable:!0},{pubkey:d,isSigner:!1,isWritable:!0},{pubkey:f,isSigner:!1,isWritable:!0},{pubkey:y,isSigner:!1,isWritable:!0},{pubkey:Ze,isSigner:!1,isWritable:!1},{pubkey:Kn.programId,isSigner:!1,isWritable:!1},{pubkey:Ce,isSigner:!1,isWritable:!1},{pubkey:Ci,isSigner:!1,isWritable:!1},{pubkey:Ut,isSigner:!1,isWritable:!1},{pubkey:Ye,isSigner:!1,isWritable:!1},{pubkey:b,isSigner:!1,isWritable:!1},{pubkey:g,isSigner:!1,isWritable:!1},...C],L=Buffer.alloc(R.span);R.encode({tickLowerIndex:P,tickUpperIndex:h,tickArrayLowerStartIndex:I,tickArrayUpperStartIndex:T,liquidity:new xa(0),amountMaxA:K==="MintA"?x:S,amountMaxB:K==="MintA"?S:x,withMetadata:w==="create",baseFlag:K==="MintA",optionBaseFlag:1},L);let O=Buffer.from([...Wt.openPosition,...L]);return new mt({keys:N,programId:e,data:O})}static openPositionFromBaseInstruction22(e,t,n,o,r,i,s,u,a,c,m,p,d,f,y,b,g,P,h,I,T,w,K,x,S){let B=F([De("tickLowerIndex"),De("tickUpperIndex"),De("tickArrayLowerStartIndex"),De("tickArrayUpperStartIndex"),ie("liquidity"),A("amountMaxA"),A("amountMaxB"),qe("withMetadata"),V("optionBaseFlag"),qe("baseFlag")]),R=[...S?[{pubkey:S,isSigner:!1,isWritable:!0}]:[]],C=[{pubkey:t,isSigner:!0,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!0,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:m,isSigner:!1,isWritable:!0},{pubkey:p,isSigner:!1,isWritable:!0},{pubkey:d,isSigner:!1,isWritable:!0},{pubkey:f,isSigner:!1,isWritable:!0},{pubkey:Ze,isSigner:!1,isWritable:!1},{pubkey:Kn.programId,isSigner:!1,isWritable:!1},{pubkey:Ce,isSigner:!1,isWritable:!1},{pubkey:Ci,isSigner:!1,isWritable:!1},{pubkey:Ye,isSigner:!1,isWritable:!1},{pubkey:y,isSigner:!1,isWritable:!1},{pubkey:b,isSigner:!1,isWritable:!1},...R],N=Buffer.alloc(B.span);B.encode({tickLowerIndex:g,tickUpperIndex:P,tickArrayLowerStartIndex:h,tickArrayUpperStartIndex:I,liquidity:new xa(0),amountMaxA:w==="MintA"?K:x,amountMaxB:w==="MintA"?x:K,withMetadata:T==="create",baseFlag:w==="MintA",optionBaseFlag:1},N);let L=Buffer.from([...Wt.openPositionWithTokenEx,...N]);return new mt({keys:C,programId:e,data:L})}static async openPositionFromLiquidityInstructions({poolInfo:e,poolKeys:t,ownerInfo:n,tickLower:o,tickUpper:r,liquidity:i,amountMaxA:s,amountMaxB:u,withMetadata:a,getEphemeralSigners:c,nft2022:m}){let p,d=[];if(c)p=new z((await c(1))[0]);else{let S=Wr.generate();d.push(S),p=S.publicKey}let[f,y]=[new z(e.programId),new z(e.id)],b=J.getTickArrayStartIndexByTick(o,e.config.tickSpacing),g=J.getTickArrayStartIndexByTick(r,e.config.tickSpacing),{publicKey:P}=Pe(f,y,b),{publicKey:h}=Pe(f,y,g),{publicKey:I}=m?$(n.wallet,p,Ye):$(n.wallet,p,Ce),{publicKey:T}=Bn(p),{publicKey:w}=It(f,p),{publicKey:K}=rn(f,y,o,r),x=m?this.openPositionFromLiquidityInstruction22(f,n.wallet,y,n.wallet,p,I,K,P,h,w,n.tokenAccountA,n.tokenAccountB,new z(t.vault.A),new z(t.vault.B),new z(t.mintA.address),new z(t.mintB.address),o,r,b,g,i,s,u,a,ve.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing,[b,g])?je(f,y).publicKey:void 0):this.openPositionFromLiquidityInstruction(f,n.wallet,y,n.wallet,p,I,T,K,P,h,w,n.tokenAccountA,n.tokenAccountB,new z(t.vault.A),new z(t.vault.B),new z(t.mintA.address),new z(t.mintB.address),o,r,b,g,i,s,u,a,ve.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing,[b,g])?je(f,y).publicKey:void 0);return{address:{nftMint:p,tickArrayLower:P,tickArrayUpper:h,positionNftAccount:I,metadataAccount:T,personalPosition:w,protocolPosition:K},instructions:[x],signers:d,instructionTypes:[G.ClmmOpenPosition],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[]}}static closePositionInstruction(e,t,n,o,r,i){let s=F([]),u=[{pubkey:t,isSigner:!0,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:Kn.programId,isSigner:!1,isWritable:!1},{pubkey:i?Ye:Ce,isSigner:!1,isWritable:!1}],a=Buffer.alloc(s.span);s.encode({},a);let c=Buffer.from([...Wt.closePosition,...a]);return new mt({keys:u,programId:e,data:c})}static closePositionInstructions({poolInfo:e,poolKeys:t,ownerInfo:n,ownerPosition:o,nft2022:r}){let i=new z(e.programId),s=r?$(n.wallet,o.nftMint,Ye).publicKey:$(n.wallet,o.nftMint,Ce).publicKey,{publicKey:u}=It(i,o.nftMint),a=[];return a.push(this.closePositionInstruction(i,n.wallet,o.nftMint,s,u,r)),{address:{positionNftAccount:s,personalPosition:u},signers:[],instructions:a,instructionTypes:[G.ClmmClosePosition],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[]}}static increasePositionFromLiquidityInstruction(e,t,n,o,r,i,s,u,a,c,m,p,d,f,y,b,g,P){let h=F([ie("liquidity"),A("amountMaxA"),A("amountMaxB"),V("optionBaseFlag"),qe("baseFlag")]),I=[...P?[{pubkey:P,isSigner:!1,isWritable:!0}]:[]],T=[{pubkey:t,isSigner:!0,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:m,isSigner:!1,isWritable:!0},{pubkey:p,isSigner:!1,isWritable:!0},{pubkey:Ce,isSigner:!1,isWritable:!1},{pubkey:Ye,isSigner:!1,isWritable:!1},{pubkey:d,isSigner:!1,isWritable:!1},{pubkey:f,isSigner:!1,isWritable:!1},...I],w=Buffer.alloc(h.span);h.encode({liquidity:y,amountMaxA:b,amountMaxB:g,optionBaseFlag:0,baseFlag:!1},w);let K=Buffer.from([...Wt.increaseLiquidity,...w]);return new mt({keys:T,programId:e,data:K})}static increasePositionFromLiquidityInstructions({poolInfo:e,poolKeys:t,ownerPosition:n,ownerInfo:o,liquidity:r,amountMaxA:i,amountMaxB:s,nft2022:u}){let[a,c]=[new z(e.programId),new z(e.id)],m=J.getTickArrayStartIndexByTick(n.tickLower,e.config.tickSpacing),p=J.getTickArrayStartIndexByTick(n.tickUpper,e.config.tickSpacing),{publicKey:d}=Pe(a,c,m),{publicKey:f}=Pe(a,c,p),{publicKey:y}=u?$(o.wallet,n.nftMint,Ye):$(o.wallet,n.nftMint,Ce),{publicKey:b}=It(a,n.nftMint),{publicKey:g}=rn(a,c,n.tickLower,n.tickUpper),P=this.increasePositionFromLiquidityInstruction(a,o.wallet,y,b,c,g,d,f,o.tokenAccountA,o.tokenAccountB,new z(t.vault.A),new z(t.vault.B),new z(e.mintA.address),new z(e.mintB.address),r,i,s,ve.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing,[m,p])?je(a,c).publicKey:void 0);return{address:{tickArrayLower:d,tickArrayUpper:f,positionNftAccount:y,personalPosition:b,protocolPosition:g},signers:[],instructions:[P],instructionTypes:[G.ClmmIncreasePosition],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[]}}static increasePositionFromBaseInstructions({poolInfo:e,poolKeys:t,ownerPosition:n,ownerInfo:o,base:r,baseAmount:i,otherAmountMax:s,nft2022:u}){let[a,c]=[new z(e.programId),new z(e.id)],m=J.getTickArrayStartIndexByTick(n.tickLower,e.config.tickSpacing),p=J.getTickArrayStartIndexByTick(n.tickUpper,e.config.tickSpacing),{publicKey:d}=Pe(a,c,m),{publicKey:f}=Pe(a,c,p),{publicKey:y}=u?$(o.wallet,n.nftMint,Ye):$(o.wallet,n.nftMint,Ce),{publicKey:b}=It(a,n.nftMint),{publicKey:g}=rn(a,c,n.tickLower,n.tickUpper);return{address:{tickArrayLower:d,tickArrayUpper:f,positionNftAccount:y,personalPosition:b,protocolPosition:g},instructions:[this.increasePositionFromBaseInstruction(a,o.wallet,y,b,c,g,d,f,o.tokenAccountA,o.tokenAccountB,new z(t.vault.A),new z(t.vault.B),new z(e.mintA.address),new z(e.mintB.address),r,i,s,ve.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing,[m,p])?je(a,c).publicKey:void 0)],signers:[],instructionTypes:[G.ClmmIncreasePosition],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[]}}static increasePositionFromBaseInstruction(e,t,n,o,r,i,s,u,a,c,m,p,d,f,y,b,g,P){let h=F([ie("liquidity"),A("amountMaxA"),A("amountMaxB"),V("optionBaseFlag"),qe("baseFlag")]),I=[...P?[{pubkey:P,isSigner:!1,isWritable:!0}]:[]],T=[{pubkey:t,isSigner:!0,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:m,isSigner:!1,isWritable:!0},{pubkey:p,isSigner:!1,isWritable:!0},{pubkey:Ce,isSigner:!1,isWritable:!1},{pubkey:Ye,isSigner:!1,isWritable:!1},{pubkey:d,isSigner:!1,isWritable:!1},{pubkey:f,isSigner:!1,isWritable:!1},...I],w=Buffer.alloc(h.span);h.encode({liquidity:new xa(0),amountMaxA:y==="MintA"?b:g,amountMaxB:y==="MintA"?g:b,baseFlag:y==="MintA",optionBaseFlag:1},w);let K=Buffer.from([...Wt.increaseLiquidity,...w]);return new mt({keys:T,programId:e,data:K})}static decreaseLiquidityInstruction(e,t,n,o,r,i,s,u,a,c,m,p,d,f,y,b,g,P,h){let I=F([ie("liquidity"),A("amountMinA"),A("amountMinB")]),T=[...h?[{pubkey:h,isSigner:!1,isWritable:!0}]:[],...y.map(S=>[{pubkey:S.poolRewardVault,isSigner:!1,isWritable:!0},{pubkey:S.ownerRewardVault,isSigner:!1,isWritable:!0},{pubkey:S.rewardMint,isSigner:!1,isWritable:!1}]).flat()],w=[{pubkey:t,isSigner:!0,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:m,isSigner:!1,isWritable:!0},{pubkey:p,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:Ce,isSigner:!1,isWritable:!1},{pubkey:Ye,isSigner:!1,isWritable:!1},{pubkey:mr,isSigner:!1,isWritable:!1},{pubkey:d,isSigner:!1,isWritable:!1},{pubkey:f,isSigner:!1,isWritable:!1},...T],K=Buffer.alloc(I.span);I.encode({liquidity:b,amountMinA:g,amountMinB:P},K);let x=Buffer.from([...Wt.decreaseLiquidity,...K]);return new mt({keys:w,programId:e,data:x})}static decreaseLiquidityInstructions({poolInfo:e,poolKeys:t,ownerPosition:n,ownerInfo:o,liquidity:r,amountMinA:i,amountMinB:s,programId:u,nft2022:a}){let[c,m]=[new z(e.programId),new z(e.id)],p=J.getTickArrayStartIndexByTick(n.tickLower,e.config.tickSpacing),d=J.getTickArrayStartIndexByTick(n.tickUpper,e.config.tickSpacing),{publicKey:f}=Pe(c,m,p),{publicKey:y}=Pe(c,m,d),{publicKey:b}=a?$(o.wallet,n.nftMint,Ye):$(o.wallet,n.nftMint,u),{publicKey:g}=It(c,n.nftMint),{publicKey:P}=rn(c,m,n.tickLower,n.tickUpper),h=[];for(let w=0;w<e.rewardDefaultInfos.length;w++)h.push({poolRewardVault:new z(t.rewardInfos[w].vault),ownerRewardVault:o.rewardAccounts[w],rewardMint:new z(e.rewardDefaultInfos[w].mint.address)});let I=[],T=this.decreaseLiquidityInstruction(c,o.wallet,b,g,m,P,f,y,o.tokenAccountA,o.tokenAccountB,new z(t.vault.A),new z(t.vault.B),new z(e.mintA.address),new z(e.mintB.address),h,r,i,s,ve.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing,[p,d])?je(c,m).publicKey:void 0);return I.push(T),{address:{tickArrayLower:f,tickArrayUpper:y,positionNftAccount:b,personalPosition:g,protocolPosition:P},signers:[],instructions:I,instructionTypes:[G.ClmmDecreasePosition],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[]}}static swapInstruction(e,t,n,o,r,i,s,u,a,c,m,p,d,f,y,b,g){let P=F([A("amount"),A("otherAmountThreshold"),ie("sqrtPriceLimitX64"),qe("isBaseInput")]),h=[...g?[{pubkey:g,isSigner:!1,isWritable:!0}]:[],...m.map(K=>({pubkey:K,isSigner:!1,isWritable:!0}))],I=[{pubkey:t,isSigner:!0,isWritable:!1},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:p,isSigner:!1,isWritable:!0},{pubkey:Ce,isSigner:!1,isWritable:!1},{pubkey:Ye,isSigner:!1,isWritable:!1},{pubkey:mr,isSigner:!1,isWritable:!1},{pubkey:a,isSigner:!1,isWritable:!1},{pubkey:c,isSigner:!1,isWritable:!1},...h],T=Buffer.alloc(P.span);P.encode({amount:d,otherAmountThreshold:f,sqrtPriceLimitX64:y,isBaseInput:b},T);let w=Buffer.from([...Wt.swap,...T]);return new mt({keys:I,programId:e,data:w})}static makeSwapBaseInInstructions({poolInfo:e,poolKeys:t,observationId:n,ownerInfo:o,inputMint:r,amountIn:i,amountOutMin:s,sqrtPriceLimitX64:u,remainingAccounts:a}){let[c,m]=[new z(e.programId),new z(e.id)],[p,d]=[new z(t.vault.A),new z(t.vault.B)],[f,y]=[new z(e.mintA.address),new z(e.mintB.address)],b=e.mintA.address===r.toString(),g=[this.swapInstruction(c,o.wallet,m,new z(e.config.id),b?o.tokenAccountA:o.tokenAccountB,b?o.tokenAccountB:o.tokenAccountA,b?p:d,b?d:p,b?f:y,b?y:f,a,n,i,s,u,!0,je(c,m).publicKey)];return{signers:[],instructions:g,instructionTypes:[G.ClmmSwapBaseIn],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[],address:{}}}static makeSwapBaseOutInstructions({poolInfo:e,poolKeys:t,observationId:n,ownerInfo:o,outputMint:r,amountOut:i,amountInMax:s,sqrtPriceLimitX64:u,remainingAccounts:a}){let[c,m]=[new z(e.programId),new z(e.id)],[p,d]=[new z(t.vault.A),new z(t.vault.B)],[f,y]=[new z(e.mintA.address),new z(e.mintB.address)],b=e.mintA.address===r.toBase58(),g=[this.swapInstruction(c,o.wallet,m,new z(e.config.id),b?o.tokenAccountB:o.tokenAccountA,b?o.tokenAccountA:o.tokenAccountB,b?d:p,b?p:d,b?y:f,b?f:y,a,n,i,s,u,!1,je(c,m).publicKey)];return{signers:[],instructions:g,instructionTypes:[G.ClmmSwapBaseOut],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[],address:{}}}static initRewardInstruction(e,t,n,o,r,i,s,u,a,c,m,p){let d=F([A("openTime"),A("endTime"),ie("emissionsPerSecondX64")]),f=[{pubkey:t,isSigner:!0,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!1},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!1},{pubkey:Kn.programId,isSigner:!1,isWritable:!1},{pubkey:Ze,isSigner:!1,isWritable:!1}],y=Buffer.alloc(d.span);d.encode({openTime:ne(c),endTime:ne(m),emissionsPerSecondX64:p},y);let b=Buffer.from([...Wt.initReward,...y]);return new mt({keys:f,programId:e,data:b})}static initRewardInstructions({poolInfo:e,poolKeys:t,ownerInfo:n,rewardInfo:o}){let[r,i]=[new z(e.programId),new z(e.id)],s=Uc(r,i,o.mint).publicKey,u=Bi(r).publicKey,a=[this.initRewardInstruction(r,n.wallet,i,u,new z(e.config.id),n.tokenAccount,o.programId,o.mint,s,o.openTime,o.endTime,o.emissionsPerSecondX64)];return{address:{poolRewardVault:s,operationId:u},signers:[],instructions:a,instructionTypes:[G.ClmmInitReward],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[]}}static setRewardInstruction(e,t,n,o,r,i,s,u,a,c,m,p){let d=F([V("rewardIndex"),ie("emissionsPerSecondX64"),A("openTime"),A("endTime")]),f=[{pubkey:t,isSigner:!0,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:Ce,isSigner:!1,isWritable:!1},{pubkey:Ye,isSigner:!1,isWritable:!1},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0}],y=Buffer.alloc(d.span);d.encode({rewardIndex:a,emissionsPerSecondX64:p,openTime:ne(c),endTime:ne(m)},y);let b=Buffer.from([...Wt.setRewardEmissions,...y]);return new mt({keys:f,programId:e,data:b})}static setRewardInstructions({poolInfo:e,poolKeys:t,ownerInfo:n,rewardInfo:o}){let[r,i]=[new z(e.programId),new z(e.id)],s,u,a;for(let p=0;p<e.rewardDefaultInfos.length;p++)e.rewardDefaultInfos[p].mint.address===o.mint.toString()&&(s=p,u=new z(t.rewardInfos[p].vault),a=new z(t.rewardInfos[p].mint.address));(s===void 0||u===void 0)&&Jc.logWithError("reward mint check error","no reward mint",e.rewardDefaultInfos);let c=Bi(r).publicKey,m=[this.setRewardInstruction(r,n.wallet,i,c,new z(e.config.id),n.tokenAccount,u,a,s,o.openTime,o.endTime,o.emissionsPerSecondX64)];return{address:{rewardVault:u,operationId:c},signers:[],instructions:m,instructionTypes:[G.ClmmSetReward],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[]}}static collectRewardInstruction(e,t,n,o,r,i,s){let u=F([V("rewardIndex")]),a=[{pubkey:t,isSigner:!0,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!1},{pubkey:Ce,isSigner:!1,isWritable:!1},{pubkey:Ye,isSigner:!1,isWritable:!1},{pubkey:mr,isSigner:!1,isWritable:!1}],c=Buffer.alloc(u.span);u.encode({rewardIndex:s},c);let m=Buffer.from([...Wt.collectReward,...c]);return new mt({keys:a,programId:e,data:m})}static collectRewardInstructions({poolInfo:e,poolKeys:t,ownerInfo:n,rewardMint:o}){let[r,i]=[new z(e.programId),new z(e.id)],s,u;for(let c=0;c<e.rewardDefaultInfos.length;c++)e.rewardDefaultInfos[c].mint.address===o.toString()&&(s=c,u=new z(t.rewardInfos[c].vault));(s===void 0||u===void 0)&&Jc.logWithError("reward mint check error","no reward mint",e.rewardDefaultInfos);let a=[this.collectRewardInstruction(r,n.wallet,i,n.tokenAccount,u,o,s)];return{address:{rewardVault:u},signers:[],instructions:a,instructionTypes:[G.ClmmCollectReward],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[]}}static async makeLockPositions({programId:e,authProgramId:t,poolProgramId:n,payer:o,wallet:r,nftMint:i,nft2022:s,getEphemeralSigners:u}){let a=[],c;if(u)c=new z((await u(1))[0]);else{let g=Wr.generate();a.push(g),c=g.publicKey}let m=s?$(r,i,Ye).publicKey:$(r,i,Ce).publicKey,{publicKey:p}=It(n,i),d=Fo(e,c).publicKey,f=$(r,c,Ce).publicKey,y=Bn(c).publicKey,b=Re.lockPositionInstructionV2({programId:e,auth:t,payer:o,positionOwner:r,lockOwner:r,positionNftAccount:m,positionId:p,lockPositionId:d,lockNftMint:c,lockNftAccount:f,metadataAccount:y,withMetadata:!0,nft2022:s,positionNftMint:i,authPositionNftAccount:$(t,i,s?Ye:Ce).publicKey,positionNftProgram:s?Ye:Ce});return{address:{positionId:p,lockPositionId:d,lockNftAccount:f,lockNftMint:c,positionNftAccount:m,metadataAccount:y},instructions:[b],signers:a,instructionTypes:[G.ClmmLockPosition],lookupTableAddress:[]}}static lockPositionInstructionV2({programId:e,auth:t,payer:n,positionOwner:o,lockOwner:r,positionNftAccount:i,positionId:s,positionNftMint:u,authPositionNftAccount:a,positionNftProgram:c,lockPositionId:m,lockNftMint:p,lockNftAccount:d,metadataAccount:f,withMetadata:y}){let b=[{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!0,isWritable:!0},{pubkey:o,isSigner:!0,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!1},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!1},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:m,isSigner:!1,isWritable:!0},{pubkey:p,isSigner:!0,isWritable:!0},{pubkey:d,isSigner:!1,isWritable:!0},{pubkey:f,isSigner:!1,isWritable:!0},{pubkey:Ut,isSigner:!1,isWritable:!1},{pubkey:Ci,isSigner:!1,isWritable:!1},{pubkey:Ze,isSigner:!1,isWritable:!1},{pubkey:Ce,isSigner:!1,isWritable:!1},{pubkey:c,isSigner:!1,isWritable:!1},{pubkey:Kn.programId,isSigner:!1,isWritable:!1}],g=F([qe("withMetadata")]),P=Buffer.alloc(g.span);g.encode({withMetadata:y},P);let h=Buffer.from([...el,...P]);return new mt({keys:b,programId:e,data:h})}static lockPositionInstruction({programId:e,authProgramId:t,poolProgramId:n,owner:o,positionNft:r}){let{publicKey:i}=$(o,r,Ce),{publicKey:s}=It(n,r),u=[{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!0,isWritable:!1},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!1},{pubkey:ka(e,s).publicKey,isSigner:!1,isWritable:!0},{pubkey:Ce,isSigner:!1,isWritable:!1},{pubkey:Kn.programId,isSigner:!1,isWritable:!1}];return new mt({keys:u,programId:e,data:Buffer.from(el)})}static harvestLockPositionInstruction(e){let[t,n]=[new z(e.poolKeys.programId),new z(e.poolKeys.id)],o=J.getTickArrayStartIndexByTick(e.ownerPosition.tickLower,e.poolKeys.config.tickSpacing),r=J.getTickArrayStartIndexByTick(e.ownerPosition.tickUpper,e.poolKeys.config.tickSpacing),{publicKey:i}=Pe(t,n,o),{publicKey:s}=Pe(t,n,r),{publicKey:u}=$(e.owner,e.ownerPosition.nftMint,Ce),{publicKey:a}=It(t,e.ownerPosition.nftMint),{publicKey:c}=rn(t,n,e.ownerPosition.tickLower,e.ownerPosition.tickUpper),m=[];for(let f=0;f<e.poolKeys.rewardInfos.length;f++)m.push({poolRewardVault:new z(e.poolKeys.rewardInfos[f].vault),ownerRewardVault:e.ownerRewardAccounts[f],rewardMint:new z(e.poolKeys.rewardInfos[f].mint.address)});let p=[...m.map(f=>[{pubkey:f.poolRewardVault,isSigner:!1,isWritable:!0},{pubkey:f.ownerRewardVault,isSigner:!1,isWritable:!0},{pubkey:f.rewardMint,isSigner:!1,isWritable:!1}]).flat()],d=[{pubkey:e.authProgramId,isSigner:!1,isWritable:!1},{pubkey:ka(e.programId,a).publicKey,isSigner:!1,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:e.owner,isSigner:!0,isWritable:!1},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:new z(e.poolKeys.vault.A),isSigner:!1,isWritable:!0},{pubkey:new z(e.poolKeys.vault.B),isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:e.userVaultA,isSigner:!1,isWritable:!0},{pubkey:e.userVaultB,isSigner:!1,isWritable:!0},{pubkey:Ce,isSigner:!1,isWritable:!1},{pubkey:Ye,isSigner:!1,isWritable:!1},{pubkey:ln,isSigner:!1,isWritable:!1},{pubkey:new z(e.poolKeys.mintA.address),isSigner:!1,isWritable:!1},{pubkey:new z(e.poolKeys.mintB.address),isSigner:!1,isWritable:!1},...p];return new mt({keys:d,programId:e.programId,data:Buffer.from(tl)})}static harvestLockPositionInstructionV2({programId:e,auth:t,lockPositionId:n,clmmProgram:o,lockOwner:r,lockNftMint:i,lockNftAccount:s,positionNftAccount:u,positionId:a,poolId:c,protocolPosition:m,vaultA:p,vaultB:d,tickArrayLower:f,tickArrayUpper:y,userVaultA:b,userVaultB:g,mintA:P,mintB:h,rewardAccounts:I,exTickArrayBitmap:T}){let w=[...T?[{pubkey:T,isSigner:!1,isWritable:!0}]:[],...I.map(x=>[{pubkey:x.poolRewardVault,isSigner:!1,isWritable:!0},{pubkey:x.ownerRewardVault,isSigner:!1,isWritable:!0},{pubkey:x.rewardMint,isSigner:!1,isWritable:!1}]).flat()],K=[{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!0,isWritable:!1},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:m,isSigner:!1,isWritable:!0},{pubkey:p,isSigner:!1,isWritable:!0},{pubkey:d,isSigner:!1,isWritable:!0},{pubkey:f,isSigner:!1,isWritable:!0},{pubkey:y,isSigner:!1,isWritable:!0},{pubkey:b,isSigner:!1,isWritable:!0},{pubkey:g,isSigner:!1,isWritable:!0},{pubkey:Ce,isSigner:!1,isWritable:!1},{pubkey:Ye,isSigner:!1,isWritable:!1},{pubkey:ln,isSigner:!1,isWritable:!1},{pubkey:P,isSigner:!1,isWritable:!1},{pubkey:h,isSigner:!1,isWritable:!1},...w];return new mt({keys:K,programId:e,data:Buffer.from(tl)})}};var nl=F([ct("mintAuthorityOption"),M("mintAuthority"),A("supply"),V("decimals"),V("isInitialized"),ct("freezeAuthorityOption"),M("freezeAuthority")]);import{PublicKey as bp}from"@solana/web3.js";import{MintLayout as ol,TOKEN_PROGRAM_ID as gp}from"@solana/spl-token";var Ch=async({connection:l,mint:e})=>{let t=await l.getAccountInfo(new bp(e));return!t||t.data.length!==ol.span?void 0:ol.decode(t.data)},Rh=({mint:l,decimals:e,programId:t=gp,logoURI:n="",priority:o=3})=>{let r=l.toBase58().substring(0,6);return{address:l.toBase58(),decimals:e,symbol:r,logoURI:n,extensions:{},chainId:101,programId:t.toString(),name:r,tags:[],priority:o}},Dr=l=>new Xe({mint:l.address,decimals:l.decimals,symbol:l.symbol,name:l.name}),Ri=o=>{var r=o,{amount:l,isRaw:e,name:t}=r,n=_e(r,["amount","isRaw","name"]);return new Se(new Xe({mint:ft(n.address).toBase58(),decimals:n.decimals,symbol:n.symbol,name:t}),l,e,t)};function Lh(l){return l.address===cn.address?it:l}function Oh(l){return l.address===it.address?cn:l}var gt=o=>{var r=o,{address:l,programId:e,decimals:t}=r,n=_e(r,["address","programId","decimals"]);return v({chainId:101,address:ft(l).toBase58(),programId:e,logoURI:"",symbol:"",name:"",decimals:t,tags:[],extensions:n.extensions||{}},n)},zn=l=>l?q(v({},l),{transferFeeConfigAuthority:l.transferFeeConfigAuthority.toBase58(),withdrawWithheldAuthority:l.withdrawWithheldAuthority.toBase58(),withheldAmount:l.withheldAmount.toString(),olderTransferFee:q(v({},l.olderTransferFee),{epoch:l.olderTransferFee.epoch.toString(),maximumFee:l.olderTransferFee.maximumFee.toString()}),newerTransferFee:q(v({},l.newerTransferFee),{epoch:l.newerTransferFee.epoch.toString(),maximumFee:l.newerTransferFee.maximumFee.toString()})}):void 0;import il from"bn.js";var Ka=new il(25),qr=new il(1e4),Pp={4:3,5:3};import{PublicKey as Oe,SystemProgram as al,SYSVAR_RENT_PUBKEY as kp,TransactionInstruction as Sn}from"@solana/web3.js";import{ASSOCIATED_TOKEN_PROGRAM_ID as wp,TOKEN_PROGRAM_ID as Eo}from"@solana/spl-token";var Sa=F([V("instruction"),A("amountIn"),A("minAmountOut")]),Ca=F([V("instruction"),A("maxAmountIn"),A("amountOut")]),Uh=F([V("instruction"),V("nonce")]),Ra=F([V("instruction"),V("nonce"),A("startTime")]),mo=F([A("status"),A("nonce"),A("maxOrder"),A("depth"),A("baseDecimal"),A("quoteDecimal"),A("state"),A("resetFlag"),A("minSize"),A("volMaxCutRatio"),A("amountWaveRatio"),A("baseLotSize"),A("quoteLotSize"),A("minPriceMultiplier"),A("maxPriceMultiplier"),A("systemDecimalValue"),A("minSeparateNumerator"),A("minSeparateDenominator"),A("tradeFeeNumerator"),A("tradeFeeDenominator"),A("pnlNumerator"),A("pnlDenominator"),A("swapFeeNumerator"),A("swapFeeDenominator"),A("baseNeedTakePnl"),A("quoteNeedTakePnl"),A("quoteTotalPnl"),A("baseTotalPnl"),A("poolOpenTime"),A("punishPcAmount"),A("punishCoinAmount"),A("orderbookToInitTime"),ie("swapBaseInAmount"),ie("swapQuoteOutAmount"),A("swapBase2QuoteFee"),ie("swapQuoteInAmount"),ie("swapBaseOutAmount"),A("swapQuote2BaseFee"),M("baseVault"),M("quoteVault"),M("baseMint"),M("quoteMint"),M("lpMint"),M("openOrders"),M("marketId"),M("marketProgramId"),M("targetOrders"),M("withdrawQueue"),M("lpVault"),M("owner"),A("lpReserve"),Q(A(),3,"padding")]),Ap=F([A("accountType"),A("status"),A("nonce"),A("maxOrder"),A("depth"),A("baseDecimal"),A("quoteDecimal"),A("state"),A("resetFlag"),A("minSize"),A("volMaxCutRatio"),A("amountWaveRatio"),A("baseLotSize"),A("quoteLotSize"),A("minPriceMultiplier"),A("maxPriceMultiplier"),A("systemDecimalsValue"),A("abortTradeFactor"),A("priceTickMultiplier"),A("priceTick"),A("minSeparateNumerator"),A("minSeparateDenominator"),A("tradeFeeNumerator"),A("tradeFeeDenominator"),A("pnlNumerator"),A("pnlDenominator"),A("swapFeeNumerator"),A("swapFeeDenominator"),A("baseNeedTakePnl"),A("quoteNeedTakePnl"),A("quoteTotalPnl"),A("baseTotalPnl"),A("poolOpenTime"),A("punishPcAmount"),A("punishCoinAmount"),A("orderbookToInitTime"),ie("swapBaseInAmount"),ie("swapQuoteOutAmount"),ie("swapQuoteInAmount"),ie("swapBaseOutAmount"),A("swapQuote2BaseFee"),A("swapBase2QuoteFee"),M("baseVault"),M("quoteVault"),M("baseMint"),M("quoteMint"),M("lpMint"),M("modelDataAccount"),M("openOrders"),M("marketId"),M("marketProgramId"),M("targetOrders"),M("owner"),Q(A(),64,"padding")]),La=F([V("instruction"),A("baseAmountIn"),A("quoteAmountIn"),A("fixedSide"),A("otherAmountMin")]),Oa=F([V("instruction"),A("lpAmount"),A("baseAmountMin"),A("quoteAmountMin")]),Gh={4:mo,5:Ap},rl=F([A("fee")]);var sl=be("Raydium_liquidity_instruction");function ul(l){let{poolInfo:e,poolKeys:t,userKeys:n,baseAmountIn:o,quoteAmountIn:r,fixedSide:i,otherAmountMin:s,modelDataPubKey:u=_n}=l,a=Buffer.alloc(La.span);La.encode({instruction:3,baseAmountIn:ne(o),quoteAmountIn:ne(r),otherAmountMin:ne(s),fixedSide:i==="base"?St:_u},a);let c=[k({pubkey:Eo,isWritable:!1}),k({pubkey:new Oe(e.id)}),k({pubkey:new Oe(t.authority),isWritable:!1}),k({pubkey:new Oe(t.openOrders),isWritable:!1}),k({pubkey:new Oe(t.targetOrders)}),k({pubkey:new Oe(e.lpMint.address)}),k({pubkey:new Oe(t.vault.A)}),k({pubkey:new Oe(t.vault.B)})];return e.pooltype.includes("StablePool")&&c.push(k({pubkey:u})),c.push(k({pubkey:new Oe(e.marketId),isWritable:!1}),k({pubkey:n.baseTokenAccount}),k({pubkey:n.quoteTokenAccount}),k({pubkey:n.lpTokenAccount}),k({pubkey:n.owner,isWritable:!1,isSigner:!0}),k({pubkey:new Oe(t.marketEventQueue),isWritable:!1})),new Sn({programId:new Oe(e.programId),keys:c,data:a})}function Na(l){let{poolInfo:e,poolKeys:t,userKeys:n,lpAmount:o,baseAmountMin:r,quoteAmountMin:i,modelDataPubKey:s=_n}=l,u=Ee(t),a=4;if(e.pooltype.includes("StablePool")&&(a=5),a===4||a===5){let c=Buffer.alloc(Oa.span);Oa.encode({instruction:4,lpAmount:ne(o),baseAmountMin:ne(r),quoteAmountMin:ne(i)},c);let m=[k({pubkey:Eo,isWritable:!1}),k({pubkey:u.id}),k({pubkey:u.authority,isWritable:!1}),k({pubkey:u.openOrders}),k({pubkey:u.targetOrders}),k({pubkey:u.mintLp.address}),k({pubkey:u.vault.A}),k({pubkey:u.vault.B})];return a===5?m.push(k({pubkey:s})):(m.push(k({pubkey:u.id})),m.push(k({pubkey:u.id}))),m.push(k({pubkey:u.marketProgramId,isWritable:!1}),k({pubkey:u.marketId}),k({pubkey:u.marketBaseVault}),k({pubkey:u.marketQuoteVault}),k({pubkey:u.marketAuthority,isWritable:!1}),k({pubkey:n.lpTokenAccount}),k({pubkey:n.baseTokenAccount}),k({pubkey:n.quoteTokenAccount}),k({pubkey:n.owner,isWritable:!1,isSigner:!0}),k({pubkey:u.marketEventQueue}),k({pubkey:u.marketBids}),k({pubkey:u.marketAsks})),new Sn({programId:u.programId,keys:m,data:c})}return new Sn({programId:u.programId,keys:[]})}function Ma({programId:l,ammId:e,ammAuthority:t,ammOpenOrders:n,lpMint:o,coinMint:r,pcMint:i,coinVault:s,pcVault:u,withdrawQueue:a,ammTargetOrders:c,poolTempLp:m,marketProgramId:p,marketId:d,userWallet:f,userCoinVault:y,userPcVault:b,userLpVault:g,nonce:P,openTime:h,coinAmount:I,pcAmount:T,ammConfigId:w,feeDestinationId:K}){let x=F([V("instruction"),V("nonce"),A("openTime"),A("pcAmount"),A("coinAmount")]),S=[{pubkey:Eo,isSigner:!1,isWritable:!1},{pubkey:wp,isSigner:!1,isWritable:!1},{pubkey:al.programId,isSigner:!1,isWritable:!1},{pubkey:Ze,isSigner:!1,isWritable:!1},{pubkey:e,isSigner:!1,isWritable:!0},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!1},{pubkey:i,isSigner:!1,isWritable:!1},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:w,isSigner:!1,isWritable:!1},{pubkey:K,isSigner:!1,isWritable:!0},{pubkey:p,isSigner:!1,isWritable:!1},{pubkey:d,isSigner:!1,isWritable:!1},{pubkey:f,isSigner:!0,isWritable:!0},{pubkey:y,isSigner:!1,isWritable:!0},{pubkey:b,isSigner:!1,isWritable:!0},{pubkey:g,isSigner:!1,isWritable:!0}],B=Buffer.alloc(x.span);return x.encode({instruction:1,nonce:P,openTime:h,coinAmount:I,pcAmount:T},B),{instruction:new Sn({keys:S,programId:l,data:B}),instructionType:G.AmmV4CreatePool}}function tI(l){let e=F([V("instruction"),V("simulateType")]),t=Buffer.alloc(e.span);e.encode({instruction:12,simulateType:0},t);let n=[k({pubkey:new Oe(l.id),isWritable:!1}),k({pubkey:new Oe(l.authority),isWritable:!1}),k({pubkey:new Oe(l.openOrders),isWritable:!1}),k({pubkey:new Oe(l.vault.A),isWritable:!1}),k({pubkey:new Oe(l.vault.B),isWritable:!1}),k({pubkey:new Oe(l.mintLp.address),isWritable:!1}),k({pubkey:new Oe(l.marketId),isWritable:!1}),k({pubkey:new Oe(l.marketEventQueue),isWritable:!1})];return new Sn({programId:new Oe(l.programId),keys:n,data:t})}function Tp({poolKeys:l,userKeys:e,amountIn:t,minAmountOut:n,modelDataPubKey:o=_n},r){let i=Ee(l),s=Buffer.alloc(Sa.span);Sa.encode({instruction:9,amountIn:ne(t),minAmountOut:ne(n)},s);let u=[k({pubkey:Eo,isWritable:!1}),k({pubkey:i.id}),k({pubkey:i.authority,isWritable:!1}),k({pubkey:i.openOrders})];return r===4&&u.push(k({pubkey:i.targetOrders})),u.push(k({pubkey:i.vault.A}),k({pubkey:i.vault.B})),r===5&&u.push(k({pubkey:o})),u.push(k({pubkey:i.marketProgramId,isWritable:!1}),k({pubkey:i.marketId}),k({pubkey:i.marketBids}),k({pubkey:i.marketAsks}),k({pubkey:i.marketEventQueue}),k({pubkey:i.marketBaseVault}),k({pubkey:i.marketQuoteVault}),k({pubkey:i.marketAuthority,isWritable:!1}),k({pubkey:e.tokenAccountIn}),k({pubkey:e.tokenAccountOut}),k({pubkey:e.owner,isWritable:!1,isSigner:!0})),new Sn({programId:i.programId,keys:u,data:s})}function hp({poolKeys:l,userKeys:e,maxAmountIn:t,amountOut:n,modelDataPubKey:o=_n},r){let i=Ee(l),s=Buffer.alloc(Ca.span);Ca.encode({instruction:11,maxAmountIn:ne(t),amountOut:ne(n)},s);let u=[k({pubkey:Eo,isWritable:!1}),k({pubkey:i.id}),k({pubkey:i.authority,isWritable:!1}),k({pubkey:i.openOrders}),k({pubkey:i.targetOrders}),k({pubkey:i.vault.A}),k({pubkey:i.vault.B})];return r===5&&u.push(k({pubkey:o})),u.push(k({pubkey:i.marketProgramId,isWritable:!1}),k({pubkey:i.marketId}),k({pubkey:i.marketBids}),k({pubkey:i.marketAsks}),k({pubkey:i.marketEventQueue}),k({pubkey:i.marketBaseVault}),k({pubkey:i.marketQuoteVault}),k({pubkey:i.marketAuthority,isWritable:!1}),k({pubkey:e.tokenAccountIn}),k({pubkey:e.tokenAccountOut}),k({pubkey:e.owner,isWritable:!1,isSigner:!0})),new Sn({programId:i.programId,keys:u,data:s})}function Ur(l){let{poolKeys:e,version:t,userKeys:n,amountIn:o,amountOut:r,fixedSide:i}=l;if(t===4||t===5){let s={poolKeys:e,userKeys:n};if(i==="in")return Tp(q(v({},s),{amountIn:o,minAmountOut:r}),t);if(i==="out")return hp(q(v({},s),{maxAmountIn:o,amountOut:r}),t);sl.logWithError("invalid params","params",l)}throw sl.logWithError("invalid version","poolKeys.version",t),new Error("invalid version")}function nI({poolKeys:l,userKeys:e,startTime:t}){let n=Buffer.alloc(Ra.span);Ra.encode({instruction:0,nonce:5,startTime:ne(t)},n);let o=Ee(l),r=[k({pubkey:Eo,isWritable:!1}),k({pubkey:al.programId,isWritable:!1}),k({pubkey:kp,isWritable:!1}),k({pubkey:o.id}),k({pubkey:o.authority,isWritable:!1}),k({pubkey:o.openOrders}),k({pubkey:o.mintLp.address}),k({pubkey:o.mintA.address,isWritable:!1}),k({pubkey:o.mintB.address,isWritable:!1}),k({pubkey:o.vault.A,isWritable:!1}),k({pubkey:o.vault.B,isWritable:!1}),k({pubkey:o.id}),k({pubkey:o.targetOrders}),k({pubkey:e.lpTokenAccount}),k({pubkey:o.id,isWritable:!1}),k({pubkey:o.marketProgramId,isWritable:!1}),k({pubkey:o.marketId,isWritable:!1}),k({pubkey:e.payer,isSigner:!0})];return new Sn({programId:o.programId,keys:r,data:n})}function cl({poolKeys:l}){let e=F([V("instruction"),V("simulateType")]),t=Buffer.alloc(e.span);e.encode({instruction:12,simulateType:0},t);let n=[k({pubkey:new Oe(l.id),isWritable:!1}),k({pubkey:new Oe(l.authority),isWritable:!1}),k({pubkey:new Oe(l.openOrders),isWritable:!1}),k({pubkey:new Oe(l.vault.A),isWritable:!1}),k({pubkey:new Oe(l.vault.B),isWritable:!1}),k({pubkey:new Oe(l.mintLp.address),isWritable:!1}),k({pubkey:new Oe(l.marketId),isWritable:!1}),k({pubkey:new Oe(l.marketEventQueue),isWritable:!1})];return{instruction:new Sn({programId:new Oe(l.programId),keys:n,data:t})}}var fo=5e4,Ip=F([A("x"),A("y"),A("price")]),Bp=F([A("accountType"),A("status"),A("multiplier"),A("validDataCount"),Q(Ip,fo,"DataElement")]);function xp(l,e){return[0,fo-2]}function Kp(l){return[0,fo-2]}function Sp(l){return[0,fo-2]}function Cp(l,e,t){let[n,o]=xp(e,t),r=n,i=o,s=0,u=e*l.multiplier/t;for(;r<=i;){if(s=Math.floor((i+r)/2),s===0||s>=fo-2)return[s,s,!1];let a=l.DataElement[s].x*l.multiplier/l.DataElement[s].y,c=l.DataElement[s-1].x*l.multiplier/l.DataElement[s-1].y,m=l.DataElement[s+1].x*l.multiplier/l.DataElement[s+1].y;if(u===a)return[s,s,!0];if(u===c)return[s-1,s-1,!0];if(u===m)return[s+1,s+1,!0];if(u<c)i=s-1;else{if(u>c&&u<a)return[s-1,s,!0];if(u>a&&u<m)return[s,s+1,!0];r=s+1}}return[s,s,!1]}function va(l,e,t){let[n,o,r]=Cp(l,e,t);if(!r)return 0;if(n===o){let i=l.DataElement[n].x;return e*l.multiplier/i}else{let i=l.DataElement[n].x,s=l.DataElement[n].y,u=l.DataElement[o].x,a=l.DataElement[o].y,c=t*(u*s-i*a),m=i*c,p=(u-i)*(e*s-i*t)*a,d=m+p;return e*l.multiplier*c/d}}function po(l,e,t){return e*l.multiplier/t}function ll(l,e,t){return e*t/l.multiplier}function Rp(l,e){let[t,n]=Kp(e),o=t,r=n,i=0,s=e;for(;o<r;){if(i=Math.floor((r+o)/2),i<=0||i>fo-2)return[i,i,!1];let u=l.DataElement[i].x,a=l.DataElement[i-1].x,c=l.DataElement[i+1].x;if(s===u)return[i,i,!0];if(s===a)return[i-1,i-1,!0];if(s===c)return[i+1,i+1,!0];if(s<a)r=i-1;else{if(s>a&&s<u)return[i-1,i,!0];if(s>u&&s<c)return[i,i+1,!0];o=i+1}}return[i,i,!1]}function Lp(l,e){let[t,n]=Sp(e),o=t,r=n,i=0,s=e;for(;o<=r;){if(i=Math.floor((r+o)/2),i<=0||i>=fo-2)return[i,i,!1];let u=l.DataElement[i].y,a=l.DataElement[i-1].y,c=l.DataElement[i+1].y;if(s===u)return[i,i,!0];if(s===a)return[i-1,i-1,!0];if(s===c)return[i+1,i+1,!0];if(s<c)o=i+1;else{if(s<a&&s>u)return[i-1,i,!0];if(s<u&&s>c)return[i,i+1,!0];r=i-1}}return[i,i,!1]}function ml(l,e,t,n){let o=n?e+t:e-t,[r,i,s]=Rp(l,o);if(!s)return[0,0,!1,s];if(r===i)return[l.DataElement[i].price,l.DataElement[i].y,!1,s];{let u=l.DataElement[r].x,a=l.DataElement[i].x,c=l.DataElement[r].price,m=l.DataElement[i].price,p=l.DataElement[r].y,d=l.DataElement[i].y;if(e>=u&&e<=a)return n?[m,d,!0,s]:[c,p,!0,s];{let f,y;return n?(f=c+(m-c)*(e-u)/(a-u),y=p-(o-u)*l.multiplier/m):(f=c+(m-c)*(e-u)/(a-u),y=d+(a-o)*l.multiplier/c),[f,y,!1,s]}}}function Op(l,e,t,n){let o=n?e-t:e+t,[r,i,s]=Lp(l,o);if(!s)return[0,0,!1,s];if(r===i)return[l.DataElement[i].price,l.DataElement[i].x,!1,s];{let u=l.DataElement[r].x,a=l.DataElement[i].x,c=l.DataElement[r].price,m=l.DataElement[i].price,p=l.DataElement[r].y,d=l.DataElement[i].y;if(e>=d&&e<=p)return n?[m,a,!0,s]:[c,u,!0,s];{let f,y;return n?(f=c+(m-c)*(p-e)/(p-d),y=u+m*(p-o)/l.multiplier):(f=c+(m-c)*(p-e)/(p-d),y=a-c*(o-d)/l.multiplier),[f,y,!1,s]}}}function Np(l,e){let t=ml(l,e,0,!1);return t[3]?t[0]:0}function dl(l,e,t,n){let o=va(l,e,t),r=po(l,e,o),i=po(l,t,o),s=po(l,n,o),u=!0,[a,c,m,p]=ml(l,r,s,u);if(!p)return 0;if(m)return n*l.multiplier/a;{let d=i-c;return ll(l,d,o)}}function pl(l,e,t,n){let o=va(l,e,t),r=po(l,e,o),i=po(l,t,o),s=po(l,n,o),u=!1,[a,c,m,p]=Op(l,i,s,u);if(!p)return 0;if(m)return n*a/l.multiplier;{let d=r-c;return ll(l,d,o)}}function Mp(l){let e=Bp.decode(l);return{accountType:e.accountType.toNumber(),status:e.status.toNumber(),multiplier:e.multiplier.toNumber(),validDataCount:e.validDataCount.toNumber(),DataElement:e.DataElement.map(t=>({x:t.x.toNumber(),y:t.y.toNumber(),price:t.price.toNumber()}))}}function fl(l,e,t,n){let o=Np(l,po(l,e,va(l,e,t)))/l.multiplier;return n?o:1/o}var Wo=class{constructor({connection:e,modelDataPubKey:t=_n}){this._layoutData={accountType:0,status:0,multiplier:0,validDataCount:0,DataElement:[]};this.connection=e,this.modelDataPubKey=t}get stableModelData(){return this._layoutData}async initStableModelLayout(){if(this._layoutData.validDataCount===0&&this.connection){let e=await this.connection.getAccountInfo(this.modelDataPubKey);e&&(this._layoutData=Mp(e==null?void 0:e.data))}}};import{PublicKey as Oi}from"@solana/web3.js";import Li from"bn.js";import Gr from"decimal.js";import{TOKEN_PROGRAM_ID as _p}from"@solana/spl-token";import{PublicKey as vp}from"@solana/web3.js";var Fp=be("Raydium_liquidity_serum");function yl({programId:l,marketId:e}){let t=[e.toBuffer()],n=0,o;for(;n<100;){try{let r=t.concat(Buffer.from([n]),Buffer.alloc(7));o=vp.createProgramAddressSync(r,l)}catch(r){if(r instanceof TypeError)throw r;n++;continue}return{publicKey:o,nonce:n}}throw Fp.logWithError("unable to find a viable program address nonce","params",{programId:l,marketId:e}),new Error("unable to find a viable program address nonce")}function Xr({programId:l}){let{publicKey:e}=oe([Buffer.from("amm_config_account_seed","utf-8")],l);return e}function yo({name:l,programId:e,marketId:t}){let{publicKey:n}=oe([e.toBuffer(),t.toBuffer(),Buffer.from(l,"utf-8")],e);return n}function Vp({programId:l,marketId:e}){let{publicKey:t}=oe([l.toBuffer(),e.toBuffer(),Buffer.from("open_order_associated_seed","utf-8")],l);return t}function Va({programId:l}){return oe([Buffer.from([97,109,109,32,97,117,116,104,111,114,105,116,121])],l)}function Ea({version:l,marketVersion:e,marketId:t,baseMint:n,quoteMint:o,baseDecimals:r,quoteDecimals:i,programId:s,marketProgramId:u}){let a=yo({name:"amm_associated_seed",programId:s,marketId:t}),c=yo({name:"lp_mint_associated_seed",programId:s,marketId:t}),{publicKey:m,nonce:p}=Va({programId:s}),d=yo({name:"coin_vault_associated_seed",programId:s,marketId:t}),f=yo({name:"pc_vault_associated_seed",programId:s,marketId:t}),y=yo({name:"temp_lp_token_associated_seed",programId:s,marketId:t}),b=Vp({programId:s,marketId:t}),g=yo({name:"target_associated_seed",programId:s,marketId:t}),P=yo({name:"withdraw_associated_seed",programId:s,marketId:t}),{publicKey:h}=yl({programId:u,marketId:t});return{id:a,baseMint:n,quoteMint:o,lpMint:c,baseDecimals:r,quoteDecimals:i,lpDecimals:r,version:l,programId:s,authority:m,nonce:p,baseVault:d,quoteVault:f,lpVault:y,openOrders:b,targetOrders:g,withdrawQueue:P,marketVersion:e,marketProgramId:u,marketId:t,marketAuthority:h,lookupTableAccount:Oi.default,configId:Xr({programId:s})}}var Fa;async function CI({connection:l,poolKeysList:e,config:t,modelDataPubKey:n}){return e.find(r=>r.modelDataAccount)&&(Fa||(Fa=new Wo({connection:l,modelDataPubKey:n}),await Fa.initStableModelLayout())),await Promise.all(e.map(async r=>{if(r.modelDataAccount){let i=cl({poolKeys:r});return(await zu(l,[i.instruction],"GetPoolData")).map(a=>{let c=Yu(a,"GetPoolData"),m=new Li(Pn(c,"status")),p=Number(Pn(c,"coin_decimals")),d=Number(Pn(c,"pc_decimals")),f=Number(Pn(c,"lp_decimals")),y=new Li(Pn(c,"pool_coin_amount")),b=new Li(Pn(c,"pool_pc_amount")),g=new Li(Pn(c,"pool_lp_supply")),P="0";try{P=Pn(c,"pool_open_time")}catch{}return{status:m,baseDecimals:p,quoteDecimals:d,lpDecimals:f,baseReserve:y,quoteReserve:b,lpSupply:g,startTime:new Li(P)}})[0]}else{let[i,s,u,a]=await l.getMultipleAccountsInfo([new Oi(r.id),new Oi(r.vault.A),new Oi(r.vault.B),new Oi(r.mintLp.address)]);if(i===null)throw Error("fetch pool error");if(s===null)throw Error("fetch vaultAccA error");if(u===null)throw Error("fetch vaultAccB error");if(a===null)throw Error("fetch mintAccLp error");let c=mo.decode(i.data),m=on.decode(s.data),p=on.decode(u.data),d=nl.decode(a.data);return{status:c.status,baseDecimals:c.baseDecimal.toNumber(),quoteDecimals:c.quoteDecimal.toNumber(),lpDecimals:d.decimals,baseReserve:m.amount.sub(c.baseNeedTakePnl),quoteReserve:p.amount.sub(c.quoteNeedTakePnl),lpSupply:c.lpReserve,startTime:c.poolOpenTime}}}))}var _a={volume:0,volumeQuote:0,volumeFee:0,apr:0,feeApr:0,priceMin:0,priceMax:0,rewardApr:[]},zr=l=>{let e={},t=_p.toBase58();return Object.keys(l).map(n=>{let o=l[n],[r,i]=[o.baseMint.toBase58(),o.quoteMint.toBase58()];e[n]={id:n,version:4,status:o.status.toNumber(),programId:o.programId.toBase58(),mintA:gt({address:r,programId:t,decimals:o.baseDecimal.toNumber()}),mintB:gt({address:i,programId:t,decimals:o.quoteDecimal.toNumber()}),rewardDefaultInfos:[],rewardDefaultPoolInfos:"Ecosystem",price:o.poolPrice.toNumber(),mintAmountA:new Gr(o.mintAAmount.toString()).div(10**o.baseDecimal.toNumber()).toNumber(),mintAmountB:new Gr(o.mintBAmount.toString()).div(10**o.quoteDecimal.toNumber()).toNumber(),baseReserve:o.baseReserve,quoteReserve:o.quoteReserve,feeRate:new Gr(o.tradeFeeNumerator.toString()).div(o.tradeFeeDenominator.toString()).toNumber(),openTime:o.poolOpenTime.toString(),tvl:0,day:_a,week:_a,month:_a,pooltype:[],farmUpcomingCount:0,farmOngoingCount:0,farmFinishedCount:0,type:"Standard",marketId:o.marketId.toBase58(),configId:Xr({programId:o.programId}).toBase58(),lpPrice:0,lpAmount:new Gr(o.lpReserve.toString()).div(10**Math.min(o.baseDecimal.toNumber(),o.quoteDecimal.toNumber())).toNumber(),lpMint:gt({address:o.lpMint.toBase58(),programId:t,decimals:Math.min(o.baseDecimal.toNumber(),o.quoteDecimal.toNumber())}),burnPercent:0}}),e};import Qe from"bn.js";import Ne from"decimal.js";import{PublicKey as Ni}from"@solana/web3.js";import Mi from"bn.js";import{TOKEN_PROGRAM_ID as Al}from"@solana/spl-token";import{SystemProgram as bo,SYSVAR_RENT_PUBKEY as Wp,Transaction as bl,TransactionInstruction as Dp}from"@solana/web3.js";import{createInitializeAccountInstruction as gl,TOKEN_PROGRAM_ID as Pl}from"@solana/spl-token";function Ep(l="accountFlags"){let e=new Lr(l);return e.addBoolean("initialized"),e.addBoolean("market"),e.addBoolean("openOrders"),e.addBoolean("requestQueue"),e.addBoolean("eventQueue"),e.addBoolean("bids"),e.addBoolean("asks"),e}var Wa=F([Te(5),Ep("accountFlags"),M("ownAddress"),A("vaultSignerNonce"),M("baseMint"),M("quoteMint"),M("baseVault"),A("baseDepositsTotal"),A("baseFeesAccrued"),M("quoteVault"),A("quoteDepositsTotal"),A("quoteFeesAccrued"),A("quoteDustThreshold"),M("requestQueue"),M("eventQueue"),M("bids"),M("asks"),A("baseLotSize"),A("quoteLotSize"),A("feeRateBps"),A("referrerRebatesAccrued"),Te(7)]);function qp({programId:l,marketInfo:e}){let t=F([V("version"),ct("instruction"),A("baseLotSize"),A("quoteLotSize"),_t("feeRateBps"),A("vaultSignerNonce"),A("quoteDustThreshold")]),n=[{pubkey:e.id,isSigner:!1,isWritable:!0},{pubkey:e.requestQueue,isSigner:!1,isWritable:!0},{pubkey:e.eventQueue,isSigner:!1,isWritable:!0},{pubkey:e.bids,isSigner:!1,isWritable:!0},{pubkey:e.asks,isSigner:!1,isWritable:!0},{pubkey:e.baseVault,isSigner:!1,isWritable:!0},{pubkey:e.quoteVault,isSigner:!1,isWritable:!0},{pubkey:e.baseMint,isSigner:!1,isWritable:!1},{pubkey:e.quoteMint,isSigner:!1,isWritable:!1},{pubkey:e.authority?e.quoteMint:Wp,isSigner:!1,isWritable:!1}].concat(e.authority?{pubkey:e.authority,isSigner:!1,isWritable:!1}:[]).concat(e.authority&&e.pruneAuthority?{pubkey:e.pruneAuthority,isSigner:!1,isWritable:!1}:[]),o=Buffer.alloc(t.span);return t.encode({version:0,instruction:0,baseLotSize:e.baseLotSize,quoteLotSize:e.quoteLotSize,feeRateBps:e.feeRateBps,vaultSignerNonce:e.vaultSignerNonce,quoteDustThreshold:e.quoteDustThreshold},o),new Dp({keys:n,programId:l,data:o})}async function Yr({connection:l,wallet:e,marketInfo:t}){var i,s,u,a,c,m,p,d;let n=new bl,o=await l.getMinimumBalanceForRentExemption(165);n.add(bo.createAccountWithSeed({fromPubkey:e,basePubkey:e,seed:t.baseVault.seed,newAccountPubkey:t.baseVault.publicKey,lamports:o,space:165,programId:Pl}),bo.createAccountWithSeed({fromPubkey:e,basePubkey:e,seed:t.quoteVault.seed,newAccountPubkey:t.quoteVault.publicKey,lamports:o,space:165,programId:Pl}),gl(t.baseVault.publicKey,t.baseMint,t.vaultOwner),gl(t.quoteVault.publicKey,t.quoteMint,t.vaultOwner),bo.createAccountWithSeed({fromPubkey:e,basePubkey:e,seed:t.id.seed,newAccountPubkey:t.id.publicKey,lamports:await l.getMinimumBalanceForRentExemption(Wa.span),space:Wa.span,programId:t.programId}));let r=new bl;return r.add(bo.createAccountWithSeed({fromPubkey:e,basePubkey:e,seed:t.requestQueue.seed,newAccountPubkey:t.requestQueue.publicKey,lamports:t.lowestFeeMarket?6208320:await l.getMinimumBalanceForRentExemption((i=t.requestQueueSpace)!=null?i:5120+12),space:t.lowestFeeMarket?764:(s=t.requestQueueSpace)!=null?s:5120+12,programId:t.programId}),bo.createAccountWithSeed({fromPubkey:e,basePubkey:e,seed:t.eventQueue.seed,newAccountPubkey:t.eventQueue.publicKey,lamports:t.lowestFeeMarket?79594560:await l.getMinimumBalanceForRentExemption((u=t.eventQueueSpace)!=null?u:262144+12),space:t.lowestFeeMarket?11308:(a=t.eventQueueSpace)!=null?a:262144+12,programId:t.programId}),bo.createAccountWithSeed({fromPubkey:e,basePubkey:e,seed:t.bids.seed,newAccountPubkey:t.bids.publicKey,lamports:t.lowestFeeMarket?101977920:await l.getMinimumBalanceForRentExemption((c=t.orderbookQueueSpace)!=null?c:65536+12),space:t.lowestFeeMarket?14524:(m=t.orderbookQueueSpace)!=null?m:65536+12,programId:t.programId}),bo.createAccountWithSeed({fromPubkey:e,basePubkey:e,seed:t.asks.seed,newAccountPubkey:t.asks.publicKey,lamports:t.lowestFeeMarket?101977920:await l.getMinimumBalanceForRentExemption((p=t.orderbookQueueSpace)!=null?p:65536+12),space:t.lowestFeeMarket?14524:(d=t.orderbookQueueSpace)!=null?d:65536+12,programId:t.programId}),qp({programId:t.programId,marketInfo:{id:t.id.publicKey,requestQueue:t.requestQueue.publicKey,eventQueue:t.eventQueue.publicKey,bids:t.bids.publicKey,asks:t.asks.publicKey,baseVault:t.baseVault.publicKey,quoteVault:t.quoteVault.publicKey,baseMint:t.baseMint,quoteMint:t.quoteMint,baseLotSize:t.baseLotSize,quoteLotSize:t.quoteLotSize,feeRateBps:t.feeRateBps,vaultSignerNonce:t.vaultSignerNonce,quoteDustThreshold:t.quoteDustThreshold}})),[{transaction:n,signer:[],instructionTypes:[G.CreateAccount,G.CreateAccount,G.InitAccount,G.InitAccount]},{transaction:r,signer:[],instructionTypes:[G.CreateAccount,G.CreateAccount,G.CreateAccount,G.CreateAccount,G.CreateAccount,G.InitMarket]}]}var Do=class extends We{async create({baseInfo:e,quoteInfo:t,lotSize:n,tickSize:o,dexProgramId:r,requestQueueSpace:i,eventQueueSpace:s,orderbookQueueSpace:u,lowestFeeMarket:a,assignSeed:c,txVersion:m,computeBudgetConfig:p,txTipConfig:d,feePayer:f}){let y=this.scope.ownerPubKey,b=c?`${e.mint.toBase58().slice(0,10)}-${t.mint.toBase58().slice(0,10)}-${c}`:void 0,g=He({fromPublicKey:y,programId:r,assignSeed:b&&`${b}-market`}),P=He({fromPublicKey:y,programId:r,assignSeed:b&&`${b}-request`}),h=He({fromPublicKey:y,programId:r,assignSeed:b&&`${b}-event`}),I=He({fromPublicKey:y,programId:r,assignSeed:b&&`${b}-bids`}),T=He({fromPublicKey:y,programId:r,assignSeed:b&&`${b}-asks`}),w=He({fromPublicKey:y,programId:Al,assignSeed:b&&`${b}-baseVault`}),K=He({fromPublicKey:y,programId:Al,assignSeed:b&&`${b}-quoteVault`}),x=0,S=new Mi(100);function B(){let X=new Mi(0);for(;;)try{return{vaultOwner:Ni.createProgramAddressSync([g.publicKey.toBuffer(),X.toArrayLike(Buffer,"le",8)],r),vaultSignerNonce:X}}catch{if(X.iaddn(1),X.gt(new Mi(25555)))throw Error("find vault owner error")}}let{vaultOwner:R,vaultSignerNonce:C}=B(),N=new Mi(Math.round(10**e.decimals*n)),L=new Mi(Math.round(n*10**t.decimals*o));if(N.eq(St))throw Error("lot size is too small");if(L.eq(St))throw Error("tick size or lot size is too small");let O=await Yr({connection:this.scope.connection,wallet:this.scope.ownerPubKey,marketInfo:{programId:r,id:g,baseMint:e.mint,quoteMint:t.mint,baseVault:w,quoteVault:K,vaultOwner:R,requestQueue:P,eventQueue:h,bids:I,asks:T,feeRateBps:x,quoteDustThreshold:S,vaultSignerNonce:C,baseLotSize:N,quoteLotSize:L,requestQueueSpace:i,eventQueueSpace:s,orderbookQueueSpace:u,lowestFeeMarket:a}}),E=this.createTxBuilder(f);E.addInstruction({instructions:O[0].transaction.instructions,signers:O[0].signer});for await(let X of O.slice(1,O.length))E.addInstruction({instructions:X.transaction.instructions,signers:X.signer,instructionTypes:X.instructionTypes});return m===0?E.sizeCheckBuildV0({computeBudgetConfig:p,address:{marketId:g.publicKey,requestQueue:P.publicKey,eventQueue:h.publicKey,bids:I.publicKey,asks:T.publicKey,baseVault:w.publicKey,quoteVault:K.publicKey,baseMint:new Ni(e.mint),quoteMint:new Ni(t.mint)}}):E.sizeCheckBuild({computeBudgetConfig:p,address:{marketId:g.publicKey,requestQueue:P.publicKey,eventQueue:h.publicKey,bids:I.publicKey,asks:T.publicKey,baseVault:w.publicKey,quoteVault:K.publicKey,baseMint:new Ni(e.mint),quoteMint:new Ni(t.mint)}})}};var vi=class extends We{constructor(t){super(t);this.stableLayout=new Wo({connection:this.scope.connection,modelDataPubKey:this.scope.cluster==="mainnet"?void 0:kn.MODEL_DATA_PUBKEY})}async initLayout(){await this.stableLayout.initStableModelLayout()}async load(){this.checkDisabled()}computePairAmount({poolInfo:t,amount:n,slippage:o,baseIn:r}){let i=new Qe(new Ne(n).mul(10**t[r?"mintA":"mintB"].decimals).toFixed(0)),s=Dr(t[r?"mintB":"mintA"]),[u,a]=[new Qe(new Ne(t.mintAmountA).mul(10**t.mintA.decimals).toString()),new Qe(new Ne(t.mintAmountB).mul(10**t.mintB.decimals).toString())],c=new Qe(new Ne(t.lpAmount).mul(10**t.lpMint.decimals).toFixed(0,Ne.ROUND_DOWN));this.logDebug("baseReserve:",u.toString(),"quoteReserve:",a.toString()),this.logDebug("tokenIn:",r?t.mintA.symbol:t.mintB.symbol,"amountIn:",i.toString(),"anotherToken:",r?t.mintB.symbol:t.mintA.symbol,"slippage:",`${o.toSignificant()}%`,"baseReserve",u.toString(),"quoteReserve",a.toString());let m=r?"base":"quote";this.logDebug("input side:",m);let p=St;i.isZero()||(p=m==="base"?yr(i.mul(a),u):yr(i.mul(u),a)),this.logDebug("amountRaw:",p.toString(),"lpAmount:",c.toString());let d=yr(i.mul(c),m==="base"?u:a);this.logDebug("liquidity:",d.toString());let f=new st(new Qe(1)).add(o),y=new st(new Qe(1)).sub(o),b=f.mul(p).quotient,g=y.mul(p).quotient,P=new Se(s,p),h=new Se(s,b),I=new Se(s,g);return this.logDebug("anotherAmount:",P.toFixed(),"maxAnotherAmount:",h.toFixed()),{anotherAmount:P,maxAnotherAmount:h,minAnotherAmount:I,liquidity:d}}async getAmmPoolKeys(t){return(await this.scope.api.fetchPoolKeysById({idList:[t]}))[0]}async addLiquidity(t){let{poolInfo:n,poolKeys:o,amountInA:r,amountInB:i,otherAmountMin:s,fixedSide:u,config:a,txVersion:c,computeBudgetConfig:m,txTipConfig:p,feePayer:d}=t;this.scope.availability.addStandardPosition===!1&&this.logAndCreateError("add liquidity feature disabled in your region"),this.logDebug("amountInA:",r,"amountInB:",i),(r.isZero()||i.isZero())&&this.logAndCreateError("amounts must greater than zero","amountInA & amountInB",{amountInA:r.toFixed(),amountInB:i.toFixed()});let{account:f}=this.scope,{bypassAssociatedCheck:y,checkCreateATAOwner:b}=v({bypassAssociatedCheck:!1,checkCreateATAOwner:!1},a),[g,P]=[r.token,i.token],h=await f.getCreatedTokenAccount({mint:g.mint,associatedOnly:!1}),I=await f.getCreatedTokenAccount({mint:P.mint,associatedOnly:!1});!h&&!I&&this.logAndCreateError("cannot found target token accounts","tokenAccounts",f.tokenAccounts);let T=await f.getCreatedTokenAccount({mint:new Je(n.lpMint.address)}),w=[g,P],K=[h,I],x=[r.raw,i.raw],S=r.token.mint.toBase58()===n.mintA.address?"base":"quote",B="base";["quote","base"].includes(S)||this.logAndCreateError("invalid fixedSide","fixedSide",u),S==="quote"?(w.reverse(),K.reverse(),x.reverse(),B=u==="a"?"quote":"base"):S==="base"&&(B=u==="a"?"base":"quote");let[R,C]=w,[N,L]=K,[O,E]=x,X=o!=null?o:await this.getAmmPoolKeys(n.id),Y=this.createTxBuilder(d),te=await f.handleTokenAccount({side:"in",amount:O,mint:R.mint,tokenAccount:N,bypassAssociatedCheck:y,checkCreateATAOwner:b}),{tokenAccount:j}=te,de=_e(te,["tokenAccount"]);Y.addInstruction(de);let Ie=await f.handleTokenAccount({side:"in",amount:E,mint:C.mint,tokenAccount:L,bypassAssociatedCheck:y,checkCreateATAOwner:b}),{tokenAccount:re}=Ie,ce=_e(Ie,["tokenAccount"]);Y.addInstruction(ce);let ee=await f.handleTokenAccount({side:"out",amount:0,mint:new Je(n.lpMint.address),tokenAccount:T,bypassAssociatedCheck:y,checkCreateATAOwner:b}),{tokenAccount:ye}=ee,pe=_e(ee,["tokenAccount"]);return Y.addInstruction(pe),Y.addInstruction({instructions:[ul({poolInfo:n,poolKeys:X,userKeys:{baseTokenAccount:j,quoteTokenAccount:re,lpTokenAccount:ye,owner:this.scope.ownerPubKey},baseAmountIn:O,quoteAmountIn:E,otherAmountMin:s.raw,fixedSide:B})],instructionTypes:[n.pooltype.includes("StablePool")?G.AmmV5AddLiquidity:G.AmmV4AddLiquidity],lookupTableAddress:X.lookupTableAccount?[X.lookupTableAccount]:[]}),Y.addCustomComputeBudget(m),Y.addTipInstruction(p),c===0?await Y.buildV0():Y.build()}async removeLiquidity(t){this.scope.availability.removeStandardPosition===!1&&this.logAndCreateError("remove liquidity feature disabled in your region");let{poolInfo:n,poolKeys:o,lpAmount:r,baseAmountMin:i,quoteAmountMin:s,config:u,txVersion:a,computeBudgetConfig:c,txTipConfig:m,feePayer:p}=t,d=o!=null?o:await this.getAmmPoolKeys(n.id),[f,y,b]=[new Je(n.mintA.address),new Je(n.mintB.address),new Je(n.lpMint.address)];this.logDebug("lpAmount:",r),this.logDebug("baseAmountMin:",i),this.logDebug("quoteAmountMin:",s),r.isZero()&&this.logAndCreateError("amount must greater than zero","lpAmount",r.toString());let{account:g}=this.scope,P=await g.getCreatedTokenAccount({mint:b,associatedOnly:!1});P||this.logAndCreateError("cannot found lpTokenAccount","tokenAccounts",g.tokenAccounts);let h=await g.getCreatedTokenAccount({mint:f}),I=await g.getCreatedTokenAccount({mint:y}),T=this.createTxBuilder(p),{bypassAssociatedCheck:w,checkCreateATAOwner:K}=v({bypassAssociatedCheck:!1,checkCreateATAOwner:!1},u),C=await g.handleTokenAccount({side:"out",amount:0,mint:f,tokenAccount:h,bypassAssociatedCheck:w,checkCreateATAOwner:K}),{tokenAccount:x}=C,S=_e(C,["tokenAccount"]);T.addInstruction(S);let N=await g.handleTokenAccount({side:"out",amount:0,mint:y,tokenAccount:I,bypassAssociatedCheck:w,checkCreateATAOwner:K}),{tokenAccount:B}=N,R=_e(N,["tokenAccount"]);return T.addInstruction(R),T.addInstruction({instructions:[Na({poolInfo:n,poolKeys:d,userKeys:{lpTokenAccount:P,baseTokenAccount:x,quoteTokenAccount:B,owner:this.scope.ownerPubKey},lpAmount:r,baseAmountMin:i,quoteAmountMin:s})],lookupTableAddress:d.lookupTableAccount?[d.lookupTableAccount]:[],instructionTypes:[n.pooltype.includes("StablePool")?G.AmmV5RemoveLiquidity:G.AmmV4RemoveLiquidity]}),T.addCustomComputeBudget(c),T.addTipInstruction(m),a===0?await T.buildV0():T.build()}async removeAllLpAndCreateClmmPosition({poolInfo:t,clmmPoolInfo:n,removeLpAmount:o,createPositionInfo:r,farmInfo:i,userFarmLpAmount:s,base:u,computeBudgetConfig:a,payer:c,userAuxiliaryLedgers:m,tokenProgram:p=Yn,checkCreateATAOwner:d=!0,getEphemeralSigners:f,txVersion:y,feePayer:b}){if((this.scope.availability.removeStandardPosition===!1||this.scope.availability.createConcentratedPosition===!1)&&this.logAndCreateError("remove liquidity or create position feature disabled in your region"),!(t.mintA.address===n.mintA.address||t.mintA.address===n.mintB.address)||!(t.mintB.address===n.mintA.address||t.mintB.address===n.mintB.address))throw Error("mint check error");let g=this.createTxBuilder(b),P={};for(let X of this.scope.account.tokenAccountRawInfos)(P[X.accountInfo.mint.toString()]===void 0||$(this.scope.ownerPubKey,X.accountInfo.mint,Yn).publicKey.equals(X.pubkey))&&(P[X.accountInfo.mint.toString()]=X.pubkey);let h=P[t.lpMint.address];if(h===void 0)throw Error("find lp account error in trade accounts");let I=o.add(s!=null?s:new Qe(0)),T=t.mintA.address===Xe.WSOL.mint.toString(),w=t.mintB.address===Xe.WSOL.mint.toString(),{account:K,instructionParams:x}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:Yn,mint:new Je(t.mintA.address),owner:this.scope.ownerPubKey,createInfo:T?{payer:this.scope.ownerPubKey}:void 0,skipCloseAccount:!T,notUseTokenAccount:T,associatedOnly:!0,checkCreateATAOwner:d});if(g.addInstruction(x||{}),K===void 0)throw new Error("base token account not found");let{account:S,instructionParams:B}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:Yn,mint:new Je(t.mintB.address),owner:this.scope.ownerPubKey,createInfo:w?{payer:this.scope.ownerPubKey,amount:0}:void 0,skipCloseAccount:!w,notUseTokenAccount:w,associatedOnly:!0,checkCreateATAOwner:d});if(g.addInstruction(B||{}),S===void 0)throw new Error("quote token account not found");if(P[t.mintA.address]=K,P[t.mintB.address]=S,i!==void 0&&!(s!=null&&s.isZero())){let X=Gt[i.programId],Y=yt({programId:new Je(i.programId),poolId:new Je(i.id),owner:this.scope.ownerPubKey,version:X}),j,de=await this.scope.connection.getAccountInfo(Y);if(de&&(j=Mo(X).decode(de.data)),X!==6&&!j){let{instruction:ee,instructionType:Fe}=gi({id:new Je(i.id),programId:new Je(i.programId),version:X,ledger:Y,owner:this.scope.ownerPubKey});g.addInstruction({instructions:[ee],instructionTypes:[Fe]})}let re=[];for(let ee of i.rewardInfos){let Fe=ee.mint.address===Xe.WSOL.mint.toString();if(P[ee.mint.address])re.push(P[ee.mint.address]);else{let{account:ho,instructionParams:un}=await this.scope.account.getOrCreateTokenAccount({mint:new Je(ee.mint.address),tokenProgram:p,owner:this.scope.ownerPubKey,skipCloseAccount:!Fe,createInfo:{payer:c||this.scope.ownerPubKey},associatedOnly:!0,checkCreateATAOwner:d});ho||this.logAndCreateError("farm reward account not found:",ee.mint.address),un&&g.addInstruction(un),re.push(ho)}}let ce=(await this.scope.api.fetchFarmKeysById({ids:i.id}))[0],ye={userAuxiliaryLedgers:m,amount:s,owner:this.scope.ownerPubKey,farmInfo:i,farmKeys:ce,lpAccount:h,rewardAccounts:re},pe=Gt[i.programId],te=pe===6?Pi(ye):pe===5?Ai(ye):ki(ye),Ie={3:G.FarmV3Withdraw,5:G.FarmV5Withdraw,6:G.FarmV6Withdraw};g.addInstruction({instructions:[te],instructionTypes:[Ie[pe]]})}let R=await this.getAmmPoolKeys(t.id),C=Na({poolInfo:t,poolKeys:R,userKeys:{lpTokenAccount:h,baseTokenAccount:K,quoteTokenAccount:S,owner:this.scope.ownerPubKey},lpAmount:I,baseAmountMin:0,quoteAmountMin:0});g.addInstruction({instructions:[C],instructionTypes:[t.pooltype.includes("StablePool")?G.AmmV5RemoveLiquidity:G.AmmV4RemoveLiquidity],lookupTableAddress:R.lookupTableAccount?[R.lookupTableAccount]:[]});let[N,L]=t.mintA.address===n.mintA.address?[K,S]:[S,K],O=await this.scope.clmm.getClmmPoolKeys(n.id),E=await Re.openPositionFromBaseInstructions(q(v({poolInfo:n,poolKeys:O,ownerInfo:{feePayer:this.scope.ownerPubKey,wallet:this.scope.ownerPubKey,tokenAccountA:N,tokenAccountB:L},withMetadata:"create"},r),{base:u,getEphemeralSigners:f}));return g.addInstruction({instructions:[...E.instructions],signers:E.signers,instructionTypes:[...E.instructionTypes],lookupTableAddress:O.lookupTableAccount?[O.lookupTableAccount]:[]}),y===0?g.sizeCheckBuildV0({computeBudgetConfig:a}):g.sizeCheckBuild({computeBudgetConfig:a})}async createPoolV4({programId:t,marketInfo:n,baseMintInfo:o,quoteMintInfo:r,baseAmount:i,quoteAmount:s,startTime:u,ownerInfo:a,associatedOnly:c=!1,checkCreateATAOwner:m=!1,tokenProgram:p,txVersion:d,feeDestinationId:f,computeBudgetConfig:y,txTipConfig:b,feePayer:g}){var L;let P=a.feePayer||((L=this.scope.owner)==null?void 0:L.publicKey),h=a.useSOLBalance&&o.mint.equals(Qr),I=a.useSOLBalance&&r.mint.equals(Qr),T=this.createTxBuilder(g),{account:w,instructionParams:K}=await this.scope.account.getOrCreateTokenAccount({mint:o.mint,owner:this.scope.ownerPubKey,createInfo:h?{payer:P,amount:i}:void 0,notUseTokenAccount:h,skipCloseAccount:!h,associatedOnly:h?!1:c,checkCreateATAOwner:m});T.addInstruction(K||{});let{account:x,instructionParams:S}=await this.scope.account.getOrCreateTokenAccount({mint:r.mint,owner:this.scope.ownerPubKey,createInfo:I?{payer:P,amount:s}:void 0,notUseTokenAccount:I,skipCloseAccount:!I,associatedOnly:I?!1:c,checkCreateATAOwner:m});if(T.addInstruction(S||{}),w===void 0||x===void 0)throw Error("you don't has some token account");let B=Ea({version:4,marketVersion:3,marketId:n.marketId,baseMint:o.mint,quoteMint:r.mint,baseDecimals:o.decimals,quoteDecimals:r.decimals,programId:t,marketProgramId:n.programId}),R={programId:t,ammId:B.id,ammAuthority:B.authority,ammOpenOrders:B.openOrders,lpMint:B.lpMint,coinMint:B.baseMint,pcMint:B.quoteMint,coinVault:B.baseVault,pcVault:B.quoteVault,withdrawQueue:B.withdrawQueue,ammTargetOrders:B.targetOrders,poolTempLp:B.lpVault,marketProgramId:B.marketProgramId,marketId:B.marketId,ammConfigId:B.configId,feeDestinationId:f},{instruction:C,instructionType:N}=Ma(q(v({},R),{userWallet:this.scope.ownerPubKey,userCoinVault:w,userPcVault:x,userLpVault:$(this.scope.ownerPubKey,B.lpMint,p).publicKey,nonce:B.nonce,openTime:u,coinAmount:i,pcAmount:s}));return T.addInstruction({instructions:[C],instructionTypes:[N]}),T.addCustomComputeBudget(y),T.addTipInstruction(b),T.versionBuild({txVersion:d,extInfo:{address:R}})}async createMarketAndPoolV4({programId:t=ni,marketProgram:n=Rs,feeDestinationId:o=Ls,tokenProgram:r,baseMintInfo:i,quoteMintInfo:s,baseAmount:u,quoteAmount:a,startTime:c,ownerInfo:m,lowestFeeMarket:p,assignSeed:d,associatedOnly:f=!1,checkCreateATAOwner:y=!1,lotSize:b=1,tickSize:g=.01,txVersion:P,computeBudgetConfig:h,txTipConfig:I,feePayer:T}){var Io,Bo,ps;let w=this.scope.ownerPubKey,K=m.feePayer||((Io=this.scope.owner)==null?void 0:Io.publicKey),x=m.useSOLBalance&&i.mint.equals(Qr),S=m.useSOLBalance&&s.mint.equals(Qr),B=d?`${i.mint.toBase58().slice(0,7)}-${s.mint.toBase58().slice(0,7)}-${d}`:void 0,R=He({fromPublicKey:w,programId:n,assignSeed:B&&`${B}-market`}),C=He({fromPublicKey:w,programId:n,assignSeed:B&&`${B}-request`}),N=He({fromPublicKey:w,programId:n,assignSeed:B&&`${B}-event`}),L=He({fromPublicKey:w,programId:n,assignSeed:B&&`${B}-bids`}),O=He({fromPublicKey:w,programId:n,assignSeed:B&&`${B}-asks`}),E=He({fromPublicKey:w,programId:Yn,assignSeed:B&&`${B}-baseVault`}),X=He({fromPublicKey:w,programId:Yn,assignSeed:B&&`${B}-quoteVault`}),Y=0,j=new Qe(100);function de(){let vt=new Qe(0);for(;;)try{return{vaultOwner:Je.createProgramAddressSync([R.publicKey.toBuffer(),vt.toArrayLike(Buffer,"le",8)],n),vaultSignerNonce:vt}}catch{if(vt.iaddn(1),vt.gt(new Qe(25555)))throw Error("find vault owner error")}}let{vaultOwner:re,vaultSignerNonce:ce}=de(),ye=new Qe(Math.round(10**i.decimals*b)),pe=new Qe(Math.round(b*10**s.decimals*g));if(ye.eq(St))throw Error("lot size is too small");if(pe.eq(St))throw Error("tick size or lot size is too small");let te=await Yr({connection:this.scope.connection,wallet:this.scope.ownerPubKey,marketInfo:{programId:n,vaultOwner:re,baseMint:i.mint,quoteMint:s.mint,id:R,baseVault:E,quoteVault:X,requestQueue:C,eventQueue:N,bids:L,asks:O,feeRateBps:Y,quoteDustThreshold:j,vaultSignerNonce:ce,baseLotSize:ye,quoteLotSize:pe,lowestFeeMarket:p}}),Ie=this.createTxBuilder(T);Ie.addInstruction({instructions:te[0].transaction.instructions,signers:te[0].signer});for await(let vt of te.slice(1,te.length))Ie.addInstruction({instructions:vt.transaction.instructions,signers:vt.signer,instructionTypes:vt.instructionTypes});let{account:ee,instructionParams:Fe}=await this.scope.account.getOrCreateTokenAccount({mint:i.mint,owner:this.scope.ownerPubKey,createInfo:x?{payer:K,amount:u}:void 0,notUseTokenAccount:x,skipCloseAccount:!x,associatedOnly:x?!1:f,checkCreateATAOwner:y,assignSeed:x&&B?`${B}-wsol`:void 0});Ie.addInstruction(Fe||{});let{account:ho,instructionParams:un}=await this.scope.account.getOrCreateTokenAccount({mint:s.mint,owner:this.scope.ownerPubKey,createInfo:S?{payer:K,amount:a}:void 0,notUseTokenAccount:S,skipCloseAccount:!S,associatedOnly:S?!1:f,checkCreateATAOwner:y,assignSeed:S&&B?`${B}-wsol`:void 0});if(Ie.addInstruction(un||{}),ee===void 0)throw Error("you don't has base token account");if(ho===void 0)throw Error("you don't has quote token account");let Me=Ea({version:4,marketVersion:3,marketId:R.publicKey,baseMint:i.mint,quoteMint:s.mint,baseDecimals:i.decimals,quoteDecimals:s.decimals,programId:t,marketProgramId:n}),Yo={programId:t,ammId:Me.id,ammAuthority:Me.authority,ammOpenOrders:Me.openOrders,lpMint:Me.lpMint,coinMint:Me.baseMint,pcMint:Me.quoteMint,coinVault:Me.baseVault,pcVault:Me.quoteVault,withdrawQueue:Me.withdrawQueue,ammTargetOrders:Me.targetOrders,poolTempLp:Me.lpVault,marketProgramId:Me.marketProgramId,marketId:Me.marketId,ammConfigId:Me.configId,feeDestinationId:o},{instruction:ds,instructionType:Qo}=Ma(q(v({},Yo),{userWallet:this.scope.ownerPubKey,userCoinVault:ee,userPcVault:ho,userLpVault:$(this.scope.ownerPubKey,Me.lpMint,r).publicKey,nonce:Me.nonce,openTime:c,coinAmount:u,pcAmount:a}));Ie.addInstruction({instructions:[ds],instructionTypes:[Qo]});let qt=x||S?[((Bo=Fe==null?void 0:Fe.instructions)==null?void 0:Bo[0])||((ps=un==null?void 0:un.instructions)==null?void 0:ps[0])].filter(vt=>!!vt):void 0;return P===0?Ie.sizeCheckBuildV0({computeBudgetConfig:h,splitIns:qt,address:v({requestQueue:C.publicKey,eventQueue:N.publicKey,bids:L.publicKey,asks:O.publicKey,baseVault:E.publicKey,quoteVault:X.publicKey,baseMint:new Je(i.mint),quoteMint:new Je(s.mint)},Yo)}):Ie.sizeCheckBuild({computeBudgetConfig:h,splitIns:qt,address:v({requestQueue:C.publicKey,eventQueue:N.publicKey,bids:L.publicKey,asks:O.publicKey,baseVault:E.publicKey,quoteVault:X.publicKey,baseMint:new Je(i.mint),quoteMint:new Je(s.mint)},Yo)})}async getCreatePoolFee({programId:t}){let n=Xr({programId:t}),o=await this.scope.connection.getAccountInfo(n,{dataSlice:{offset:536,length:8}});if(o===null)throw Error("get config account error");return rl.decode(o.data).fee}computeAmountOut({poolInfo:t,amountIn:n,mintIn:o,mintOut:r,slippage:i}){let[s,u]=[o.toString(),r.toString()];if(s!==t.mintA.address&&s!==t.mintB.address)throw new Error("toke not match");if(u!==t.mintA.address&&u!==t.mintB.address)throw new Error("toke not match");let{baseReserve:a,quoteReserve:c}=t,m=[a,c],p=[t.mintA.decimals,t.mintB.decimals],d=s==t.mintA.address?"base":"quote";d==="quote"&&(m.reverse(),p.reverse());let[f,y]=m,[b,g]=p,P=t.version===4,h;if(P)h=new Ne(y.toString()).div(10**g).div(new Ne(f.toString()).div(10**b));else{let N=fl(this.stableLayout.stableModelData,a.toNumber(),c.toNumber(),!1);d==="quote"?h=new Ne(1e6).div(N*1e6):h=new Ne(N*1e6).div(1e6)}let I=n,T=new Qe(0),w=new Qe(0);if(!I.isZero())if(P){w=En(I.mul(Ka),qr);let N=I.sub(w),L=f.add(N);T=y.mul(N).div(L)}else{w=I.mul(new Qe(2)).div(new Qe(1e4));let N=I.sub(w);d==="quote"?T=new Qe(dl(this.stableLayout.stableModelData,c.toNumber(),a.toNumber(),N.toNumber())):T=new Qe(pl(this.stableLayout.stableModelData,c.toNumber(),a.toNumber(),N.toNumber()))}let K=new Qe(new Ne(T.toString()).mul(1-i).toFixed(0)),x=T,S=K,B=new Ne(T.toString()).div(new Ne(I.sub(w).toString()).toFixed(0));!I.isZero()&&!T.isZero()&&(B=new Ne(T.toString()).div(10**g).div(new Ne(I.sub(w).toString()).div(10**b)));let R=h.sub(B).div(h).mul(100);return{amountOut:x,minAmountOut:S,currentPrice:h,executionPrice:B,priceImpact:R,fee:w}}computeAmountIn({poolInfo:t,amountOut:n,mintIn:o,mintOut:r,slippage:i}){let{baseReserve:s,quoteReserve:u}=t;o.toString()!==t.mintA.address&&o.toString()!==t.mintB.address&&this.logAndCreateError("mintIn does not match pool"),r.toString()!==t.mintA.address&&r.toString()!==t.mintB.address&&this.logAndCreateError("mintOut does not match pool"),this.logDebug("baseReserve:",s.toString()),this.logDebug("quoteReserve:",u.toString());let a=o.toString()===t.mintA.address,[c,m]=a?[t.mintA,t.mintB]:[t.mintB,t.mintA];this.logDebug("currencyOut:",m.symbol||m.address),this.logDebug("amountOut:",new Ne(n.toString()).div(10**m.decimals).toDecimalPlaces(m.decimals).toString(),c.symbol||c.address),this.logDebug("slippage:",`${i*100}%`);let p=[s,u],d=a?"quote":"base";d==="base"&&p.reverse(),this.logDebug("output side:",d);let[f,y]=p,b=new Ne(y.toString()).div(10**t[a?"mintB":"mintA"].decimals).div(new Ne(f.toString()).div(10**t[a?"mintA":"mintB"].decimals));this.logDebug("currentPrice:",`1 ${c.symbol||c.address} \u2248 ${b.toString()} ${m.symbol||m.address}`),this.logDebug("currentPrice invert:",`1 ${m.symbol||m.address} \u2248 ${new Ne(1).div(b).toString()} ${c.symbol||c.address}`);let g=new Qe(0),P=n;if(!P.isZero()){P.gt(y)&&(P=y.sub(new Qe(1)));let S=y.sub(P);g=f.mul(P).div(S).mul(qr).div(qr.sub(Ka))}let h=new Qe(new Ne(g.toString()).mul(1+i).toFixed(0)),I=g,T=h;this.logDebug("amountIn:",new Ne(I.toString()).div(10**c.decimals).toDecimalPlaces(c.decimals).toString()),this.logDebug("maxAmountIn:",new Ne(T.toString()).div(10**c.decimals).toDecimalPlaces(c.decimals).toString());let w=null;!g.isZero()&&!P.isZero()&&(w=new Ne(P.toString()).div(10**m.decimals).div(new Ne(g.toString()).div(10**c.decimals)),this.logDebug("executionPrice:",`1 ${m.symbol||m.address} \u2248 ${w.toDecimalPlaces(Math.max(t.mintA.decimals,t.mintB.decimals)).toString()} ${c.symbol||c.address}`),this.logDebug("executionPrice invert:",`1 ${m.symbol||m.address} \u2248 ${new Ne(1).div(w).toDecimalPlaces(Math.max(t.mintA.decimals,t.mintB.decimals)).toString()} ${c.symbol||c.address}`));let K=b.mul(I.toString()),x=K.sub(n.toString()).abs().div(K);return this.logDebug("priceImpact:",`${x.toString()}%`),{amountIn:I,maxAmountIn:T,currentPrice:b,executionPrice:w,priceImpact:x}}async swap({poolInfo:t,poolKeys:n,amountIn:o,amountOut:r,inputMint:i,fixedSide:s,txVersion:u,config:a,computeBudgetConfig:c,txTipConfig:m,feePayer:p}){let d=this.createTxBuilder(p),{associatedOnly:f=!0,inputUseSolBalance:y=!0,outputUseSolBalance:b=!0}=a||{},[g,P]=i===t.mintA.address?[t.mintA,t.mintB]:[t.mintB,t.mintA],h=y&&g.address===Z.toBase58(),I=b&&P.address===Z.toBase58(),{account:T,instructionParams:w}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:Yn,mint:new Je(g.address),owner:this.scope.ownerPubKey,createInfo:h?{payer:this.scope.ownerPubKey,amount:o}:void 0,skipCloseAccount:!h,notUseTokenAccount:h,associatedOnly:f});d.addInstruction(w||{}),T||this.logAndCreateError("input token account not found",{token:g.symbol||g.address,tokenAccountIn:T,inputTokenUseSolBalance:h,associatedOnly:f});let{account:K,instructionParams:x}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:Yn,mint:new Je(P.address),owner:this.scope.ownerPubKey,createInfo:{payer:this.scope.ownerPubKey,amount:0},skipCloseAccount:!I,notUseTokenAccount:I,associatedOnly:I?!1:f});d.addInstruction(x||{}),K===void 0&&this.logAndCreateError("output token account not found",{token:P.symbol||P.address,tokenAccountOut:K,outputTokenUseSolBalance:I,associatedOnly:f});let S=n||await this.getAmmPoolKeys(t.id),B=4;return t.pooltype.includes("StablePool")&&(B=5),d.addInstruction({instructions:[Ur({version:B,poolKeys:S,userKeys:{tokenAccountIn:T,tokenAccountOut:K,owner:this.scope.ownerPubKey},amountIn:o,amountOut:r,fixedSide:s})],instructionTypes:[B===4?G.AmmV4SwapBaseIn:G.AmmV5SwapBaseIn]}),d.addCustomComputeBudget(c),d.addTipInstruction(m),d.versionBuild({txVersion:u})}async getRpcPoolInfo(t){return(await this.getRpcPoolInfos([t]))[t]}async getRpcPoolInfos(t,n){let o=await Le(this.scope.connection,t.map(c=>({pubkey:new Je(c)})),n),r={},i=[];for(let c=0;c<t.length;c++){let m=o[c];if(m===null||!m.accountInfo)throw Error("fetch pool info error: "+String(t[c]));let p=mo.decode(m.accountInfo.data);r[String(t[c])]=q(v({},p),{programId:m.accountInfo.owner}),i.push(p.baseVault,p.quoteVault)}let s={},u=await Le(this.scope.connection,i.map(c=>({pubkey:new Je(c)})),n);for(let c=0;c<i.length;c++){let m=u[c].accountInfo;if(m===null)throw Error("fetch vault info error: "+i[c]);s[String(i[c])]=new Qe(Up.decode(m.data).amount.toString())}let a={};for(let[c,m]of Object.entries(r)){let p=s[m.baseVault.toString()].sub(m.baseNeedTakePnl),d=s[m.quoteVault.toString()].sub(m.quoteNeedTakePnl);a[c]=q(v({},m),{baseReserve:p,mintAAmount:s[m.baseVault.toString()],mintBAmount:s[m.quoteVault.toString()],quoteReserve:d,poolPrice:new Ne(d.toString()).div(new Ne(10).pow(m.quoteDecimal.toString())).div(new Ne(p.toString()).div(new Ne(10).pow(m.baseDecimal.toString())))})}return a}async getPoolInfoFromRpc({poolId:t}){let n=await this.getRpcPoolInfo(t),o=zr({[t]:n}),r=o[t],i=await this.scope.tradeV2.computePoolToPoolKeys({pools:[o[t]],ammRpcData:{[t]:n}});return{poolRpcData:n,poolInfo:r,poolKeys:i[0]}}};import{PublicKey as H}from"@solana/web3.js";import Bt from"bn.js";import go from"decimal.js";import{AccountLayout as kl,createAssociatedTokenAccountIdempotentInstruction as wl,TOKEN_2022_PROGRAM_ID as Qn,TOKEN_PROGRAM_ID as Fi}from"@solana/spl-token";var _i=class extends We{constructor(e){super(e)}async getClmmPoolKeys(e){return(await this.scope.api.fetchPoolKeysById({idList:[e]}))[0]}async createPool(e){var K;let{programId:t,owner:n=((K=this.scope.owner)==null?void 0:K.publicKey)||H.default,mint1:o,mint2:r,ammConfig:i,initialPrice:s,computeBudgetConfig:u,forerunCreate:a,getObserveState:c,txVersion:m,txTipConfig:p,feePayer:d}=e,f=this.createTxBuilder(d),[y,b,g]=new Bt(new H(o.address).toBuffer()).gt(new Bt(new H(r.address).toBuffer()))?[r,o,new go(1).div(s)]:[o,r,s],P=ue.priceToSqrtPriceX64(g,y.decimals,b.decimals),h=[],I=[];y.programId===Qn.toBase58()&&I.push(wa(t,new H(y.address)).publicKey),b.programId===Qn.toBase58()&&I.push(wa(t,new H(b.address)).publicKey),(await this.scope.connection.getMultipleAccountsInfo(I)).forEach((x,S)=>{x&&h.push(I[S])});let w=await Re.createPoolInstructions({connection:this.scope.connection,programId:t,owner:n,mintA:y,mintB:b,ammConfigId:i.id,initialPriceX64:P,forerunCreate:!c&&a,extendMintAccount:h});return f.addInstruction(w),f.addCustomComputeBudget(u),f.addTipInstruction(p),f.versionBuild({txVersion:m,extInfo:{address:q(v({},w.address),{observationId:w.address.observationId.toBase58(),exBitmapAccount:w.address.exBitmapAccount.toBase58(),programId:t.toString(),id:w.address.poolId.toString(),mintA:y,mintB:b,openTime:"0",vault:{A:w.address.mintAVault.toString(),B:w.address.mintBVault.toString()},rewardInfos:[],config:{id:i.id.toString(),index:i.index,protocolFeeRate:i.protocolFeeRate,tradeFeeRate:i.tradeFeeRate,tickSpacing:i.tickSpacing,fundFeeRate:i.fundFeeRate,description:i.description,defaultRange:0,defaultRangePoint:[]}}),mockPoolInfo:v({type:"Concentrated",rewardDefaultPoolInfos:"Clmm",id:w.address.poolId.toString(),mintA:y,mintB:b,feeRate:i.tradeFeeRate,openTime:"0",programId:t.toString(),price:g.toNumber(),config:{id:i.id.toString(),index:i.index,protocolFeeRate:i.protocolFeeRate,tradeFeeRate:i.tradeFeeRate,tickSpacing:i.tickSpacing,fundFeeRate:i.fundFeeRate,description:i.description,defaultRange:0,defaultRangePoint:[]},burnPercent:0},Vc),forerunCreate:a}})}async openPositionFromBase({poolInfo:e,poolKeys:t,ownerInfo:n,tickLower:o,tickUpper:r,base:i,baseAmount:s,otherAmountMax:u,nft2022:a,associatedOnly:c=!0,checkCreateATAOwner:m=!1,withMetadata:p="create",getEphemeralSigners:d,computeBudgetConfig:f,txTipConfig:y,txVersion:b,feePayer:g}){this.scope.availability.addConcentratedPosition===!1&&this.logAndCreateError("add position feature disabled in your region"),this.scope.checkOwner();let P=this.createTxBuilder(g),h=null,I=null,T=n.useSOLBalance&&e.mintA.address===Z.toString(),w=n.useSOLBalance&&e.mintB.address===Z.toString(),[K,x]=i==="MintA"?[s,u]:[u,s],{account:S,instructionParams:B}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:e.mintA.programId,mint:new H(e.mintA.address),owner:this.scope.ownerPubKey,createInfo:T||K.isZero()?{payer:this.scope.ownerPubKey,amount:K}:void 0,skipCloseAccount:!T,notUseTokenAccount:T,associatedOnly:T?!1:c,checkCreateATAOwner:m});S&&(h=S),P.addInstruction(B||{});let{account:R,instructionParams:C}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:e.mintB.programId,mint:new H(e.mintB.address),owner:this.scope.ownerPubKey,createInfo:w||x.isZero()?{payer:this.scope.ownerPubKey,amount:x}:void 0,skipCloseAccount:!w,notUseTokenAccount:w,associatedOnly:w?!1:c,checkCreateATAOwner:m});R&&(I=R),P.addInstruction(C||{}),(!h||!I)&&this.logAndCreateError("cannot found target token accounts","tokenAccounts",{ownerTokenAccountA:h==null?void 0:h.toBase58(),ownerTokenAccountB:I==null?void 0:I.toBase58()});let N=t||await this.getClmmPoolKeys(e.id),L=await Re.openPositionFromBaseInstructions({poolInfo:e,poolKeys:N,ownerInfo:q(v({},n),{feePayer:this.scope.ownerPubKey,wallet:this.scope.ownerPubKey,tokenAccountA:h,tokenAccountB:I}),tickLower:o,tickUpper:r,base:i,baseAmount:s,otherAmountMax:u,withMetadata:p,getEphemeralSigners:d,nft2022:a});return P.addInstruction(L),P.addCustomComputeBudget(f),P.addTipInstruction(y),P.versionBuild({txVersion:b,extInfo:v({},L.address)})}async openPositionFromLiquidity({poolInfo:e,poolKeys:t,ownerInfo:n,amountMaxA:o,amountMaxB:r,tickLower:i,tickUpper:s,liquidity:u,associatedOnly:a=!0,checkCreateATAOwner:c=!1,withMetadata:m="create",txVersion:p,computeBudgetConfig:d,txTipConfig:f,getEphemeralSigners:y,nft2022:b,feePayer:g}){this.scope.availability.createConcentratedPosition===!1&&this.logAndCreateError("open position feature disabled in your region");let P=this.createTxBuilder(g),h=null,I=null,T=n.useSOLBalance&&e.mintA.address===Z.toBase58(),w=n.useSOLBalance&&e.mintB.address===Z.toBase58(),{account:K,instructionParams:x}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:e.mintA.programId,mint:new H(e.mintA.address),owner:this.scope.ownerPubKey,createInfo:T||o.isZero()?{payer:this.scope.ownerPubKey,amount:o}:void 0,skipCloseAccount:!T,notUseTokenAccount:T,associatedOnly:T?!1:a,checkCreateATAOwner:c});K&&(h=K),P.addInstruction(x||{});let{account:S,instructionParams:B}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:e.mintB.programId,mint:new H(e.mintB.address),owner:this.scope.ownerPubKey,createInfo:w||r.isZero()?{payer:this.scope.ownerPubKey,amount:r}:void 0,skipCloseAccount:!w,notUseTokenAccount:w,associatedOnly:w?!1:a,checkCreateATAOwner:c});S&&(I=S),P.addInstruction(B||{}),(h===void 0||I===void 0)&&this.logAndCreateError("cannot found target token accounts","tokenAccounts",this.scope.account.tokenAccounts);let R=t||await this.getClmmPoolKeys(e.id),C=await Re.openPositionFromLiquidityInstructions({poolInfo:e,poolKeys:R,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccountA:h,tokenAccountB:I},tickLower:i,tickUpper:s,liquidity:u,amountMaxA:o,amountMaxB:r,withMetadata:m,getEphemeralSigners:y,nft2022:b});return P.addInstruction(C),P.addCustomComputeBudget(d),P.addTipInstruction(f),P.versionBuild({txVersion:p,extInfo:{address:C.address}})}async increasePositionFromLiquidity(e){var B;let{poolInfo:t,poolKeys:n,ownerPosition:o,amountMaxA:r,amountMaxB:i,liquidity:s,ownerInfo:u,associatedOnly:a=!0,checkCreateATAOwner:c=!1,computeBudgetConfig:m,txTipConfig:p,txVersion:d,feePayer:f}=e,y=this.createTxBuilder(f),b,g,P=u.useSOLBalance&&t.mintA.address===Z.toString(),h=u.useSOLBalance&&t.mintB.address===Z.toString(),{account:I,instructionParams:T}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:t.mintA.programId,mint:new H(t.mintA.address),notUseTokenAccount:P,owner:this.scope.ownerPubKey,createInfo:P||r.isZero()?{payer:this.scope.ownerPubKey,amount:r}:void 0,skipCloseAccount:!P,associatedOnly:P?!1:a,checkCreateATAOwner:c});I&&(b=I),y.addInstruction(T||{});let{account:w,instructionParams:K}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:t.mintB.programId,mint:new H(t.mintB.address),owner:this.scope.ownerPubKey,createInfo:h||i.isZero()?{payer:this.scope.ownerPubKey,amount:i}:void 0,notUseTokenAccount:h,skipCloseAccount:!h,associatedOnly:h?!1:a,checkCreateATAOwner:c});w&&(g=w),y.addInstruction(K||{}),!b&&!g&&this.logAndCreateError("cannot found target token accounts","tokenAccounts",this.scope.account.tokenAccounts);let x=n!=null?n:await this.getClmmPoolKeys(t.id),S=Re.increasePositionFromLiquidityInstructions({poolInfo:t,poolKeys:x,ownerPosition:o,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccountA:b,tokenAccountB:g},liquidity:s,amountMaxA:r,amountMaxB:i,nft2022:(B=await this.scope.connection.getAccountInfo(o.nftMint))==null?void 0:B.owner.equals(Qn)});return y.addInstruction(S),y.addCustomComputeBudget(m),y.addTipInstruction(p),y.versionBuild({txVersion:d,extInfo:{address:S.address}})}async increasePositionFromBase(e){var S;let{poolInfo:t,ownerPosition:n,base:o,baseAmount:r,otherAmountMax:i,ownerInfo:s,associatedOnly:u=!0,checkCreateATAOwner:a=!1,computeBudgetConfig:c,txTipConfig:m,txVersion:p,feePayer:d}=e,f=this.createTxBuilder(d),y,b,g=s.useSOLBalance&&t.mintA.address===Z.toString(),P=s.useSOLBalance&&t.mintB.address===Z.toString(),{account:h,instructionParams:I}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:t.mintA.programId,mint:new H(t.mintA.address),notUseTokenAccount:g,owner:this.scope.ownerPubKey,createInfo:g||(o==="MintA"?r:i).isZero()?{payer:this.scope.ownerPubKey,amount:o==="MintA"?r:i}:void 0,skipCloseAccount:!g,associatedOnly:g?!1:u,checkCreateATAOwner:a});h&&(y=h),f.addInstruction(I||{});let{account:T,instructionParams:w}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:t.mintB.programId,mint:new H(t.mintB.address),owner:this.scope.ownerPubKey,createInfo:P||(o==="MintA"?i:r).isZero()?{payer:this.scope.ownerPubKey,amount:o==="MintA"?i:r}:void 0,notUseTokenAccount:P,skipCloseAccount:!P,associatedOnly:P?!1:u,checkCreateATAOwner:a});T&&(b=T),f.addInstruction(w||{}),!y&&!b&&this.logAndCreateError("cannot found target token accounts","tokenAccounts",this.scope.account.tokenAccounts);let K=await this.getClmmPoolKeys(t.id),x=Re.increasePositionFromBaseInstructions({poolInfo:t,poolKeys:K,ownerPosition:n,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccountA:y,tokenAccountB:b},base:o,baseAmount:r,otherAmountMax:i,nft2022:(S=await this.scope.connection.getAccountInfo(n.nftMint))==null?void 0:S.owner.equals(Qn)});return f.addInstruction(x),f.addCustomComputeBudget(c),f.addTipInstruction(m),f.versionBuild({txVersion:p,extInfo:{address:x.address}})}async decreaseLiquidity(e){var N;let{poolInfo:t,poolKeys:n,ownerPosition:o,ownerInfo:r,amountMinA:i,amountMinB:s,liquidity:u,associatedOnly:a=!0,checkCreateATAOwner:c=!1,computeBudgetConfig:m,txTipConfig:p,txVersion:d,feePayer:f}=e;this.scope.availability.removeConcentratedPosition===!1&&this.logAndCreateError("remove position feature disabled in your region");let y=this.createTxBuilder(f),b=r.useSOLBalance&&t.mintA.address===Z.toString(),g=r.useSOLBalance&&t.mintB.address===Z.toString(),P,h,{account:I,instructionParams:T}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:t.mintA.programId,mint:new H(t.mintA.address),notUseTokenAccount:b,owner:this.scope.ownerPubKey,createInfo:{payer:this.scope.ownerPubKey,amount:0},skipCloseAccount:!b,associatedOnly:b?!1:a,checkCreateATAOwner:c});P=I,T&&y.addInstruction(T);let{account:w,instructionParams:K}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:t.mintB.programId,mint:new H(t.mintB.address),notUseTokenAccount:g,owner:this.scope.ownerPubKey,createInfo:{payer:this.scope.ownerPubKey,amount:0},skipCloseAccount:!g,associatedOnly:g?!1:a,checkCreateATAOwner:c});h=w,K&&y.addInstruction(K);let x=[];for(let L of t.rewardDefaultInfos){let O=r.useSOLBalance&&L.mint.address===Z.toString(),E;if(L.mint.address===t.mintA.address)E=P;else if(L.mint.address===t.mintB.address)E=h;else{let{account:X,instructionParams:Y}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:new H(L.mint.programId),mint:new H(L.mint.address),notUseTokenAccount:O,owner:this.scope.ownerPubKey,createInfo:{payer:this.scope.ownerPubKey,amount:0},skipCloseAccount:!O,associatedOnly:O?!1:a,checkCreateATAOwner:c});E=X,Y&&y.addInstruction(Y)}x.push(E)}!P&&!h&&this.logAndCreateError("cannot found target token accounts","tokenAccounts",this.scope.account.tokenAccountRawInfos);let S=n!=null?n:await this.getClmmPoolKeys(t.id),B=(N=await this.scope.connection.getAccountInfo(o.nftMint))==null?void 0:N.owner.equals(Qn),R=await Re.decreaseLiquidityInstructions({poolInfo:t,poolKeys:S,ownerPosition:o,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccountA:P,tokenAccountB:h,rewardAccounts:x},liquidity:u,amountMinA:i,amountMinB:s,nft2022:B});y.addInstruction({instructions:R.instructions,instructionTypes:[G.ClmmDecreasePosition]});let C=v({},R.address);if(r.closePosition){let L=await Re.closePositionInstructions({poolInfo:t,poolKeys:S,ownerInfo:{wallet:this.scope.ownerPubKey},ownerPosition:o,nft2022:B});y.addInstruction({endInstructions:L.instructions,endInstructionTypes:L.instructionTypes}),C=v(v({},C),L.address)}return y.addCustomComputeBudget(m),y.addTipInstruction(p),y.versionBuild({txVersion:d,extInfo:{address:C}})}async lockPosition(e){var f;let{programId:t=So,authProgramId:n=oi,poolProgramId:o=Fn,ownerPosition:r,payer:i,computeBudgetConfig:s,txTipConfig:u,txVersion:a,getEphemeralSigners:c,feePayer:m}=e,p=this.createTxBuilder(m),d=await Re.makeLockPositions({programId:t,authProgramId:n,poolProgramId:o,wallet:this.scope.ownerPubKey,payer:i!=null?i:this.scope.ownerPubKey,nftMint:r.nftMint,getEphemeralSigners:c,nft2022:(f=await this.scope.connection.getAccountInfo(r.nftMint))==null?void 0:f.owner.equals(Qn)});return p.addInstruction(d),p.addCustomComputeBudget(s),p.addTipInstruction(u),p.versionBuild({txVersion:a,extInfo:d.address})}async harvestLockPosition(e){let{programId:t=So,authProgramId:n=oi,clmmProgram:o=Fn,poolKeys:r,lockData:i,ownerInfo:s={useSOLBalance:!0},associatedOnly:u=!0,checkCreateATAOwner:a=!1,computeBudgetConfig:c,txTipConfig:m,txVersion:p,feePayer:d}=e,f=r||await this.getClmmPoolKeys(i.poolId.toString()),y=this.createTxBuilder(d),b=await this.scope.connection.getAccountInfo(i.positionId);b||this.logger.logWithError("position not found",i.positionId);let g=_o.decode(b.data),P=s.useSOLBalance&&f.mintA.address===Z.toString(),h=s.useSOLBalance&&f.mintB.address===Z.toString(),I,T,{account:w,instructionParams:K}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:f.mintA.programId,mint:new H(f.mintA.address),notUseTokenAccount:P,owner:this.scope.ownerPubKey,createInfo:{payer:this.scope.ownerPubKey,amount:0},skipCloseAccount:!P,associatedOnly:P?!1:u,checkCreateATAOwner:a});I=w,K&&y.addInstruction(K);let{account:x,instructionParams:S}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:f.mintB.programId,mint:new H(f.mintB.address),notUseTokenAccount:h,owner:this.scope.ownerPubKey,createInfo:{payer:this.scope.ownerPubKey,amount:0},skipCloseAccount:!h,associatedOnly:h?!1:u,checkCreateATAOwner:a});T=x,S&&y.addInstruction(S);let B={},R=[];for(let re of f.rewardInfos){let ce=s.useSOLBalance&&re.mint.address===Z.toString(),ye=B[re.mint.address];if(!ye){let{account:pe,instructionParams:te}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:new H(re.mint.programId),mint:new H(re.mint.address),notUseTokenAccount:ce,owner:this.scope.ownerPubKey,skipCloseAccount:!ce,createInfo:{payer:this.scope.ownerPubKey,amount:0},associatedOnly:ce?!1:u});ye=pe,te&&y.addInstruction(te)}B[re.mint.address]=ye,R.push(ye)}let C=Fo(t,i.lockNftMint).publicKey,N=$(this.scope.ownerPubKey,i.lockNftMint,Fi).publicKey,L=J.getTickArrayStartIndexByTick(g.tickLower,f.config.tickSpacing),O=J.getTickArrayStartIndexByTick(g.tickUpper,f.config.tickSpacing),{publicKey:E}=Pe(new H(f.programId),i.poolId,L),{publicKey:X}=Pe(new H(f.programId),i.poolId,O),{publicKey:Y}=rn(new H(f.programId),i.poolId,g.tickLower,g.tickUpper),j=[];for(let re=0;re<f.rewardInfos.length;re++)j.push({poolRewardVault:new H(f.rewardInfos[re].vault),ownerRewardVault:R[re],rewardMint:new H(f.rewardInfos[re].mint.address)});let de=await Re.harvestLockPositionInstructionV2({programId:t,auth:n,lockPositionId:C,clmmProgram:o,lockOwner:this.scope.ownerPubKey,lockNftMint:i.lockNftMint,lockNftAccount:N,positionNftAccount:i.nftAccount,positionId:i.positionId,poolId:i.poolId,protocolPosition:Y,vaultA:new H(f.vault.A),vaultB:new H(f.vault.B),tickArrayLower:E,tickArrayUpper:X,userVaultA:I,userVaultB:T,mintA:new H(f.mintA.address),mintB:new H(f.mintB.address),rewardAccounts:j,exTickArrayBitmap:je(o,i.poolId).publicKey});return y.addInstruction({instructions:[de],instructionTypes:[G.ClmmHarvestLockPosition]}),y.addCustomComputeBudget(c),y.addTipInstruction(m),y.versionBuild({txVersion:p})}async closePosition({poolInfo:e,poolKeys:t,ownerPosition:n,txVersion:o,computeBudgetConfig:r,txTipConfig:i,feePayer:s}){var m;this.scope.availability.removeConcentratedPosition===!1&&this.logAndCreateError("remove position feature disabled in your region");let u=this.createTxBuilder(s),a=t!=null?t:await this.getClmmPoolKeys(e.id),c=Re.closePositionInstructions({poolInfo:e,poolKeys:a,ownerInfo:{wallet:this.scope.ownerPubKey},ownerPosition:n,nft2022:(m=await this.scope.connection.getAccountInfo(n.nftMint))==null?void 0:m.owner.equals(Qn)});return u.addCustomComputeBudget(r),u.addTipInstruction(i),u.addInstruction(c).versionBuild({txVersion:o,extInfo:{address:c.address}})}async initReward({poolInfo:e,ownerInfo:t,rewardInfo:n,associatedOnly:o=!0,checkCreateATAOwner:r=!1,computeBudgetConfig:i,txVersion:s,feePayer:u}){n.endTime<=n.openTime&&this.logAndCreateError("reward time error","rewardInfo",n);let a=this.createTxBuilder(u),c=t.useSOLBalance&&n.mint.address.toString()===Z.toString(),m=n.perSecond.mul(n.endTime-n.openTime),{account:p,instructionParams:d}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:new H(n.mint.address),mint:new H(n.mint.address),notUseTokenAccount:!!c,skipCloseAccount:!c,owner:this.scope.ownerPubKey,createInfo:c?{payer:t.feePayer||this.scope.ownerPubKey,amount:new Bt(new go(m.toFixed(0)).gte(m)?m.toFixed(0):m.add(1).toFixed(0))}:void 0,associatedOnly:c?!1:o,checkCreateATAOwner:r});d&&a.addInstruction(d),p||this.logAndCreateError("no money","ownerRewardAccount",this.scope.account.tokenAccountRawInfos);let f=await this.getClmmPoolKeys(e.id),y=Re.initRewardInstructions({poolInfo:e,poolKeys:f,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccount:p},rewardInfo:{programId:new H(n.mint.programId),mint:new H(n.mint.address),openTime:n.openTime,endTime:n.endTime,emissionsPerSecondX64:me.decimalToX64(n.perSecond)}});return a.addInstruction(y),a.addCustomComputeBudget(i),a.versionBuild({txVersion:s,extInfo:{address:y.address}})}async initRewards({poolInfo:e,poolKeys:t,ownerInfo:n,rewardInfos:o,associatedOnly:r=!0,checkCreateATAOwner:i=!1,computeBudgetConfig:s,txTipConfig:u,txVersion:a,feePayer:c}){for(let d of o)d.endTime<=d.openTime&&this.logAndCreateError("reward time error","rewardInfo",d);let m=this.createTxBuilder(c),p={};for(let d of o){let f=n.useSOLBalance&&d.mint.address===Z.toString(),y=d.perSecond.mul(d.endTime-d.openTime),{account:b,instructionParams:g}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:new H(d.mint.programId),mint:new H(d.mint.address),notUseTokenAccount:!!f,skipCloseAccount:!f,owner:this.scope.ownerPubKey,createInfo:f?{payer:n.feePayer||this.scope.ownerPubKey,amount:new Bt(new go(y.toFixed(0)).gte(y)?y.toFixed(0):y.add(1).toFixed(0))}:void 0,associatedOnly:f?!1:r,checkCreateATAOwner:i});g&&m.addInstruction(g),b||this.logAndCreateError("no money","ownerRewardAccount",this.scope.account.tokenAccountRawInfos);let P=t!=null?t:await this.getClmmPoolKeys(e.id),h=Re.initRewardInstructions({poolInfo:e,poolKeys:P,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccount:b},rewardInfo:{programId:new H(d.mint.programId),mint:new H(d.mint.address),openTime:d.openTime,endTime:d.endTime,emissionsPerSecondX64:me.decimalToX64(d.perSecond)}});p=v(v({},p),h.address),m.addInstruction(h)}return m.addCustomComputeBudget(s),m.addTipInstruction(u),m.versionBuild({txVersion:a,extInfo:{address:p}})}async setReward({poolInfo:e,ownerInfo:t,rewardInfo:n,associatedOnly:o=!0,checkCreateATAOwner:r=!1,computeBudgetConfig:i,txTipConfig:s,txVersion:u,feePayer:a}){n.endTime<=n.openTime&&this.logAndCreateError("reward time error","rewardInfo",n);let c=this.createTxBuilder(a),m=t.useSOLBalance&&n.mint.equals(Z),{account:p,instructionParams:d}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:n.programId,mint:n.mint,notUseTokenAccount:m,owner:this.scope.ownerPubKey,createInfo:m?{payer:t.feePayer||this.scope.ownerPubKey,amount:new Bt(new go(n.perSecond.mul(n.endTime-n.openTime).toFixed(0)).gte(n.perSecond.mul(n.endTime-n.openTime))?n.perSecond.mul(n.endTime-n.openTime).toFixed(0):n.perSecond.mul(n.endTime-n.openTime).add(1).toFixed(0))}:void 0,associatedOnly:m?!1:o,checkCreateATAOwner:r});d&&c.addInstruction(d),p||this.logAndCreateError("no money","ownerRewardAccount",this.scope.account.tokenAccountRawInfos);let f=await this.getClmmPoolKeys(e.id),y=Re.setRewardInstructions({poolInfo:e,poolKeys:f,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccount:p},rewardInfo:{mint:n.mint,openTime:n.openTime,endTime:n.endTime,emissionsPerSecondX64:me.decimalToX64(n.perSecond)}});return c.addInstruction(y),c.addCustomComputeBudget(i),c.addTipInstruction(s),c.versionBuild({txVersion:u,extInfo:{address:y.address}})}async setRewards({poolInfo:e,poolKeys:t,ownerInfo:n,rewardInfos:o,associatedOnly:r=!0,checkCreateATAOwner:i=!1,computeBudgetConfig:s,txTipConfig:u,txVersion:a,feePayer:c}){let m=this.createTxBuilder(c),p={};for(let d of o){d.endTime<=d.openTime&&this.logAndCreateError("reward time error","rewardInfo",d);let f=n.useSOLBalance&&d.mint.address===Z.toString(),{account:y,instructionParams:b}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:new H(d.mint.programId),mint:new H(d.mint.address),notUseTokenAccount:f,owner:this.scope.ownerPubKey,createInfo:f?{payer:n.feePayer||this.scope.ownerPubKey,amount:new Bt(new go(d.perSecond.mul(d.endTime-d.openTime).toFixed(0)).gte(d.perSecond.mul(d.endTime-d.openTime))?d.perSecond.mul(d.endTime-d.openTime).toFixed(0):d.perSecond.mul(d.endTime-d.openTime).add(1).toFixed(0))}:void 0,associatedOnly:f?!1:r,checkCreateATAOwner:i});b&&m.addInstruction(b),y||this.logAndCreateError("no money","ownerRewardAccount",this.scope.account.tokenAccountRawInfos);let g=t!=null?t:await this.getClmmPoolKeys(e.id),P=Re.setRewardInstructions({poolInfo:e,poolKeys:g,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccount:y},rewardInfo:{mint:new H(d.mint.address),openTime:d.openTime,endTime:d.endTime,emissionsPerSecondX64:me.decimalToX64(d.perSecond)}});m.addInstruction(P),p=v(v({},p),P.address)}return m.addCustomComputeBudget(s),m.addTipInstruction(u),m.versionBuild({txVersion:a,extInfo:{address:p}})}async collectReward({poolInfo:e,ownerInfo:t,rewardMint:n,associatedOnly:o=!0,checkCreateATAOwner:r=!1,computeBudgetConfig:i,txTipConfig:s,txVersion:u,feePayer:a}){let c=e.rewardDefaultInfos.find(g=>g.mint.address===n.toString());c||this.logAndCreateError("reward mint error","not found reward mint",n);let m=this.createTxBuilder(a),p=t.useSOLBalance&&n.equals(Z),{account:d,instructionParams:f}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:new H(c.mint.programId),mint:n,notUseTokenAccount:p,owner:this.scope.ownerPubKey,skipCloseAccount:!p,createInfo:{payer:t.feePayer||this.scope.ownerPubKey,amount:0},associatedOnly:p?!1:o,checkCreateATAOwner:r});f&&m.addInstruction(f),d||this.logAndCreateError("no money","ownerRewardAccount",this.scope.account.tokenAccountRawInfos);let y=await this.getClmmPoolKeys(e.id),b=Re.collectRewardInstructions({poolInfo:e,poolKeys:y,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccount:d},rewardMint:n});return m.addInstruction(b),m.addCustomComputeBudget(i),m.addTipInstruction(s),m.versionBuild({txVersion:u,extInfo:{address:b.address}})}async collectRewards({poolInfo:e,ownerInfo:t,rewardMints:n,associatedOnly:o=!0,checkCreateATAOwner:r=!1,computeBudgetConfig:i,txTipConfig:s,feePayer:u}){let a=this.createTxBuilder(u),c={};for(let m of n){let p=e.rewardDefaultInfos.find(P=>P.mint.address===m.toString());if(!p){this.logAndCreateError("reward mint error","not found reward mint",m);continue}let d=t.useSOLBalance&&m.equals(Z),{account:f,instructionParams:y}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:new H(p.mint.programId),mint:m,notUseTokenAccount:d,owner:this.scope.ownerPubKey,skipCloseAccount:!d,createInfo:{payer:t.feePayer||this.scope.ownerPubKey,amount:0},associatedOnly:d?!1:o,checkCreateATAOwner:r});f||this.logAndCreateError("no money","ownerRewardAccount",this.scope.account.tokenAccountRawInfos),y&&a.addInstruction(y);let b=await this.getClmmPoolKeys(e.id),g=Re.collectRewardInstructions({poolInfo:e,poolKeys:b,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccount:f},rewardMint:m});a.addInstruction(g),c=v(v({},c),g.address)}return a.addCustomComputeBudget(i),a.addTipInstruction(s),a.build({address:c})}async swap({poolInfo:e,poolKeys:t,inputMint:n,amountIn:o,amountOutMin:r,priceLimit:i,observationId:s,ownerInfo:u,remainingAccounts:a,associatedOnly:c=!0,checkCreateATAOwner:m=!1,txVersion:p,computeBudgetConfig:d,txTipConfig:f,feePayer:y}){let b=this.createTxBuilder(y),g=n.toString()===e.mintA.address,P=u.useSOLBalance&&e.mintA.address===Z.toBase58(),h=u.useSOLBalance&&e.mintB.address===Z.toBase58(),I;!i||i.equals(new go(0))?I=g?zt.add(new Bt(1)):Yt.sub(new Bt(1)):I=ue.priceToSqrtPriceX64(i,e.mintA.decimals,e.mintB.decimals);let T;if(!T){let{account:x,instructionParams:S}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:e.mintA.programId,mint:new H(e.mintA.address),notUseTokenAccount:P,owner:this.scope.ownerPubKey,skipCloseAccount:!P,createInfo:P||!g?{payer:u.feePayer||this.scope.ownerPubKey,amount:g?o:0}:void 0,associatedOnly:P?!1:c,checkCreateATAOwner:m});T=x,S&&b.addInstruction(S)}let w;if(!w){let{account:x,instructionParams:S}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:e.mintB.programId,mint:new H(e.mintB.address),notUseTokenAccount:h,owner:this.scope.ownerPubKey,skipCloseAccount:!h,createInfo:h||g?{payer:u.feePayer||this.scope.ownerPubKey,amount:g?0:o}:void 0,associatedOnly:h?!1:c,checkCreateATAOwner:m});w=x,S&&b.addInstruction(S)}(!T||!w)&&this.logAndCreateError("user do not have token account",{tokenA:e.mintA.symbol||e.mintA.address,tokenB:e.mintB.symbol||e.mintB.address,ownerTokenAccountA:T,ownerTokenAccountB:w,mintAUseSOLBalance:P,mintBUseSOLBalance:h,associatedOnly:c});let K=t!=null?t:await this.getClmmPoolKeys(e.id);return b.addInstruction(Re.makeSwapBaseInInstructions({poolInfo:e,poolKeys:K,observationId:s,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccountA:T,tokenAccountB:w},inputMint:new H(n),amountIn:o,amountOutMin:r,sqrtPriceLimitX64:I,remainingAccounts:a})),b.addCustomComputeBudget(d),b.addTipInstruction(f),b.versionBuild({txVersion:p})}async swapBaseOut({poolInfo:e,poolKeys:t,outputMint:n,amountOut:o,amountInMax:r,priceLimit:i,observationId:s,ownerInfo:u,remainingAccounts:a,associatedOnly:c=!0,checkCreateATAOwner:m=!1,txVersion:p,computeBudgetConfig:d,txTipConfig:f,feePayer:y}){let b=this.createTxBuilder(y),g=n.toString()===e.mintB.address,P=u.useSOLBalance&&e.mintA.address===Z.toBase58(),h=u.useSOLBalance&&e.mintB.address===Z.toBase58(),I;!i||i.equals(new go(0))?I=n.toString()===e.mintB.address?zt.add(new Bt(1)):Yt.sub(new Bt(1)):I=ue.priceToSqrtPriceX64(i,e.mintA.decimals,e.mintB.decimals);let T;if(!T){let{account:x,instructionParams:S}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:e.mintA.programId,mint:new H(e.mintA.address),notUseTokenAccount:P,owner:this.scope.ownerPubKey,skipCloseAccount:!P,createInfo:P||!g?{payer:u.feePayer||this.scope.ownerPubKey,amount:g?r:0}:void 0,associatedOnly:P?!1:c,checkCreateATAOwner:m});T=x,S&&b.addInstruction(S)}let w;if(!w){let{account:x,instructionParams:S}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:e.mintB.programId,mint:new H(e.mintB.address),notUseTokenAccount:h,owner:this.scope.ownerPubKey,skipCloseAccount:!h,createInfo:h||g?{payer:u.feePayer||this.scope.ownerPubKey,amount:g?0:r}:void 0,associatedOnly:h?!1:c,checkCreateATAOwner:m});w=x,S&&b.addInstruction(S)}(!T||!w)&&this.logAndCreateError("user do not have token account",{tokenA:e.mintA.symbol||e.mintA.address,tokenB:e.mintB.symbol||e.mintB.address,ownerTokenAccountA:T,ownerTokenAccountB:w,mintAUseSOLBalance:P,mintBUseSOLBalance:h,associatedOnly:c});let K=t!=null?t:await this.getClmmPoolKeys(e.id);return b.addInstruction(Re.makeSwapBaseOutInstructions({poolInfo:e,poolKeys:K,observationId:s,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccountA:T,tokenAccountB:w},outputMint:new H(n),amountOut:o,amountInMax:r,sqrtPriceLimitX64:I,remainingAccounts:a})),b.addCustomComputeBudget(d),b.addTipInstruction(f),b.versionBuild({txVersion:p})}async harvestAllRewards({allPoolInfo:e,allPositions:t,lockInfo:n,ownerInfo:o,associatedOnly:r=!0,checkCreateATAOwner:i=!1,programId:s,txVersion:u,computeBudgetConfig:a,feePayer:c,lockProgram:m=So,lockAuth:p=oi,clmmProgram:d=Fn}){var h,I;let f={};for(let T of this.scope.account.tokenAccountRawInfos)r?$(this.scope.ownerPubKey,T.accountInfo.mint,s).publicKey.equals(T.pubkey)&&(f[T.accountInfo.mint.toString()]=T.pubkey):f[T.accountInfo.mint.toString()]=T.pubkey;let y=Object.values(t).flat().map(T=>T.nftMint),b=await Le(this.scope.connection,y.map(T=>({pubkey:T}))),g={};b.forEach(T=>{var w,K;g[T.pubkey.toBase58()]=(K=(w=T==null?void 0:T.accountInfo)==null?void 0:w.owner)!=null?K:null});let P=this.createTxBuilder(c);for(let T of Object.values(e)){if(t[T.id]===void 0||!t[T.id].find(L=>!L.liquidity.isZero()||L.rewardInfos.find(O=>!O.rewardAmountOwed.isZero())))continue;let w=T,K=o.useSOLBalance&&w.mintA.address===Z.toString(),x=o.useSOLBalance&&w.mintB.address===Z.toString(),S=f[w.mintA.address];if(!S)if(K){let{account:L,instructionParams:O}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:w.mintA.programId,mint:new H(w.mintA.address),notUseTokenAccount:K,owner:this.scope.ownerPubKey,skipCloseAccount:!K,createInfo:{payer:o.feePayer||this.scope.ownerPubKey,amount:0},associatedOnly:K?!1:r,checkCreateATAOwner:i});S=L,O&&P.addInstruction(O)}else{let L=new H(w.mintA.address);S=this.scope.account.getAssociatedTokenAccount(L,new H(w.mintA.programId)),P.addInstruction({instructions:[wl(this.scope.ownerPubKey,S,this.scope.ownerPubKey,L,new H(w.mintA.programId))]})}let B=f[w.mintB.address];if(!B)if(x){let{account:L,instructionParams:O}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:w.mintB.programId,mint:new H(w.mintB.address),notUseTokenAccount:x,owner:this.scope.ownerPubKey,skipCloseAccount:!x,createInfo:{payer:o.feePayer||this.scope.ownerPubKey,amount:0},associatedOnly:x?!1:r,checkCreateATAOwner:i});B=L,O&&P.addInstruction(O)}else{let L=new H(w.mintB.address);B=this.scope.account.getAssociatedTokenAccount(L,new H(w.mintB.programId)),P.addInstruction({instructions:[wl(this.scope.ownerPubKey,B,this.scope.ownerPubKey,L,new H(w.mintB.programId))]})}f[w.mintA.address]=S,f[w.mintB.address]=B;let R=[];for(let L of w.rewardDefaultInfos){let O=o.useSOLBalance&&L.mint.address===Z.toString(),E=f[L.mint.address];if(!E){let{account:X,instructionParams:Y}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:new H(L.mint.programId),mint:new H(L.mint.address),notUseTokenAccount:O,owner:this.scope.ownerPubKey,skipCloseAccount:!O,createInfo:{payer:o.feePayer||this.scope.ownerPubKey,amount:0},associatedOnly:O?!1:r});E=X,Y&&P.addInstruction(Y)}f[L.mint.address]=E,R.push(E)}let C=await this.getClmmPoolKeys(w.id),N=[];for(let L=0;L<C.rewardInfos.length;L++)N.push({poolRewardVault:new H(C.rewardInfos[L].vault),ownerRewardVault:R[L],rewardMint:new H(C.rewardInfos[L].mint.address)});for(let L of t[T.id]){let O=(h=n==null?void 0:n[T.id])==null?void 0:h[L.nftMint.toBase58()];if(O){let E=$(this.scope.ownerPubKey,O.lockNftMint,Fi).publicKey,X=J.getTickArrayStartIndexByTick(L.tickLower,C.config.tickSpacing),Y=J.getTickArrayStartIndexByTick(L.tickUpper,C.config.tickSpacing),{publicKey:j}=Pe(new H(C.programId),O.poolId,X),{publicKey:de}=Pe(new H(C.programId),O.poolId,Y),{publicKey:re}=rn(new H(C.programId),O.poolId,L.tickLower,L.tickUpper),ce=Fo(m,O.lockNftMint).publicKey,ye=Re.harvestLockPositionInstructionV2({programId:m,auth:p,lockPositionId:ce,clmmProgram:d,lockOwner:this.scope.ownerPubKey,lockNftMint:O.lockNftMint,lockNftAccount:E,positionNftAccount:O.nftAccount,positionId:O.positionId,poolId:O.poolId,protocolPosition:re,vaultA:new H(C.vault.A),vaultB:new H(C.vault.B),tickArrayLower:j,tickArrayUpper:de,userVaultA:S,userVaultB:B,mintA:new H(C.mintA.address),mintB:new H(C.mintB.address),rewardAccounts:N,exTickArrayBitmap:je(d,O.poolId).publicKey});P.addInstruction({instructions:[ye],instructionTypes:[G.ClmmHarvestLockPosition],lookupTableAddress:C.lookupTableAccount?[C.lookupTableAccount]:[]})}else{let E=Re.decreaseLiquidityInstructions({poolInfo:w,poolKeys:C,ownerPosition:L,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccountA:S,tokenAccountB:B,rewardAccounts:R},liquidity:new Bt(0),amountMinA:new Bt(0),amountMinB:new Bt(0),nft2022:(I=g[L.nftMint.toBase58()])==null?void 0:I.equals(Qn)});P.addInstruction(E)}}}return u===0?P.sizeCheckBuildV0({computeBudgetConfig:a}):P.sizeCheckBuild({computeBudgetConfig:a})}async getWhiteListMint({programId:e}){let t=await this.scope.connection.getAccountInfo(Bi(e).publicKey);return t?$c.decode(t.data).whitelistMints.filter(o=>!o.equals(H.default)):[]}async getOwnerPositionInfo({programId:e=Fn}){await this.scope.account.fetchWalletTokenAccounts();let n=this.scope.account.tokenAccountRawInfos.filter(i=>i.accountInfo.amount.eq(new Bt(1))).map(i=>It(new H(e),i.accountInfo.mint).publicKey),o=await this.scope.connection.getMultipleAccountsInfo(n),r=[];return o.forEach(i=>{if(!i)return;let s=_o.decode(i.data);r.push(s)}),r}async getOwnerLockedPositionInfo({programId:e=So}){await this.scope.account.fetchWalletTokenAccounts();let n=this.scope.account.tokenAccountRawInfos.filter(u=>u.accountInfo.amount.eq(new Bt(1))).map(u=>Fo(new H(e),u.accountInfo.mint).publicKey),o=await this.scope.connection.getMultipleAccountsInfo(n),r=[];o.forEach(u=>{if(!u)return;let a=Zc.decode(u.data);r.push(a)});let i=await this.scope.connection.getMultipleAccountsInfo(r.map(u=>u.positionId)),s=[];return i.forEach(u=>{if(!u)return;let a=_o.decode(u.data);s.push(a)}),r.map((u,a)=>({position:s[a],lockInfo:u}))}async getRpcClmmPoolInfo({poolId:e}){return(await this.getRpcClmmPoolInfos({poolIds:[e]}))[String(e)]}async getRpcClmmPoolInfos({poolIds:e,config:t}){let n=await Le(this.scope.connection,e.map(r=>({pubkey:new H(r)})),t),o={};for(let r=0;r<e.length;r++){let i=n[r];if(i===null||!i.accountInfo)throw Error("fetch pool info error: "+String(e[r]));let s=co.decode(i.accountInfo.data),u=ue.sqrtPriceX64ToPrice(s.sqrtPriceX64,s.mintDecimalsA,s.mintDecimalsB).toNumber();o[String(e[r])]=q(v({},s),{currentPrice:u,programId:i.accountInfo.owner})}return o}async getComputeClmmPoolInfos({clmmPoolsRpcInfo:e,mintInfos:t}){let n=new Set(Object.keys(e).map(u=>e[u].ammConfig.toBase58())),o=await Le(this.scope.connection,Array.from(n).map(u=>({pubkey:new H(u)}))),r={};o.forEach(u=>{!u.accountInfo||(r[u.pubkey.toBase58()]=Hc.decode(u.accountInfo.data))});let i=await ve.fetchComputeMultipleClmmInfo({connection:this.scope.connection,rpcDataMap:e,poolList:Object.keys(e).map(u=>{var m,p,d,f;let[a,c]=[e[u].mintA.toBase58(),e[u].mintB.toBase58()];return{id:u,programId:e[u].programId.toBase58(),mintA:gt({address:a,decimals:e[u].mintDecimalsA,programId:t[a].programId.toBase58()||Fi.toBase58(),extensions:{feeConfig:(m=t[a])!=null&&m.feeConfig?zn((p=t[a])==null?void 0:p.feeConfig):void 0}}),mintB:gt({address:c,decimals:e[u].mintDecimalsB,programId:t[c].programId.toBase58()||Fi.toBase58(),extensions:{feeConfig:(d=t[c])!=null&&d.feeConfig?zn((f=t[c])==null?void 0:f.feeConfig):void 0}}),price:e[u].currentPrice,config:q(v({},r[e[u].ammConfig.toBase58()]),{id:e[u].ammConfig.toBase58(),fundFeeRate:0,description:"",defaultRange:0,defaultRangePoint:[]})}})}),s=await ve.fetchMultiplePoolTickArrays({connection:this.scope.connection,poolKeys:Object.values(i)});return{computeClmmPoolInfo:i,computePoolTickData:s}}async getPoolInfoFromRpc(e){var c;let t=await this.getRpcClmmPoolInfo({poolId:e}),n=new Set([t.mintA.toBase58(),t.mintB.toBase58()]),o=await xo({connection:this.scope.connection,mints:Array.from(n).map(m=>new H(m))}),{computeClmmPoolInfo:r,computePoolTickData:i}=await this.scope.clmm.getComputeClmmPoolInfos({clmmPoolsRpcInfo:{[e]:t},mintInfos:o}),s=await Le(this.scope.connection,[{pubkey:t.vaultA},{pubkey:t.vaultB}]),u=Yc(r[e]);if(!s[0].accountInfo||!s[1].accountInfo)throw new Error("pool vault data not found");u.mintAmountA=Number(kl.decode(s[0].accountInfo.data).amount.toString()),u.mintAmountB=Number(kl.decode((c=s[1].accountInfo)==null?void 0:c.data).amount.toString());let a=q(v({},r[e]),{exBitmapAccount:r[e].exBitmapAccount.toBase58(),observationId:r[e].observationId.toBase58(),id:e,programId:t.programId.toBase58(),openTime:t.startTime.toString(),vault:{A:t.vaultA.toBase58(),B:t.vaultB.toBase58()},config:u.config,rewardInfos:r[e].rewardInfos.filter(m=>!m.tokenVault.equals(H.default)).map(m=>({mint:gt({address:m.tokenMint.toBase58(),programId:Fi.toBase58(),decimals:10}),vault:m.tokenVault.toBase58()}))});return{poolInfo:u,poolKeys:a,computePoolInfo:r[e],tickData:i}}};import{PublicKey as U}from"@solana/web3.js";import{AccountLayout as uf,NATIVE_MINT as Uo,TOKEN_PROGRAM_ID as xt,createAssociatedTokenAccountIdempotentInstruction as Go}from"@solana/spl-token";import hl from"bn.js";import Hr from"bn.js";function Da(l,e){if(e.isZero())throw Error("divisor is zero");return l.mod(e)}function Gp(l,e){if(e.isZero())throw Error("rhs is zero");let t=l.div(e);return Da(l,e).gt(Vi)&&(t=t.add(new Hr(1))),[t,e]}var Vi=new Hr(0),Ei=class{static swapBaseInputWithoutFees(e,t,n){let o=e.mul(n),r=t.add(e);return o.div(r)}static swapBaseOutputWithoutFees(e,t,n){let o=t.mul(e),r=n.sub(e),[i]=Gp(o,r);return i}static lpTokensToTradingTokens(e,t,n,o,r){let i=e.mul(n).div(t),s=e.mul(o).div(t);if(r===0)return{tokenAmount0:i,tokenAmount1:s};if(r===1)return Da(e.mul(n),t).gt(Vi)&&i.gt(Vi)&&(i=i.add(new Hr(1))),Da(e.mul(o),t).gt(Vi)&&s.gt(Vi)&&(s=s.add(new Hr(1))),{tokenAmount0:i,tokenAmount1:s};throw Error("roundDirection value error")}};import Xp from"bn.js";var Ot=class{static tradingFee(e,t){return Zo(e,t,Ct)}static protocolFee(e,t){return br(e,t,Ct)}static fundFee(e,t){return br(e,t,Ct)}static creatorFee(e,t){return Zo(e,t,Ct)}static splitCreatorFee(e,t,n){return br(e,n,t.add(n))}static calculatePreFeeAmount(e,t){if(t.isZero())return e;let n=e.mul(Ct),o=Ct.sub(t);return n.add(o).sub(new Xp(1)).div(o)}};var Tl=(t=>(t[t.Floor=0]="Floor",t[t.Ceiling=1]="Ceiling",t))(Tl||{}),zp=(t=>(t[t.ZeroForOne=0]="ZeroForOne",t[t.OneForZero=1]="OneForZero",t))(zp||{}),Yp=(t=>(t[t.OneForZero=0]="OneForZero",t[t.ZeroForOne=1]="ZeroForOne",t))(Yp||{}),Wi=class{static validate_supply(e,t){if(e.isZero())throw Error("tokenAmount0 is zero");if(t.isZero())throw Error("tokenAmount1 is zero")}static swapBaseInput(e,t,n,o,r,i,s,u){let a=new hl(0),c=Ot.tradingFee(e,o),m;u?(a=Ot.creatorFee(e,r),m=e.sub(c).sub(a)):m=e.sub(c);let p=Ot.protocolFee(c,i),d=Ot.protocolFee(c,s),f=Ei.swapBaseInputWithoutFees(m,t,n),y;return u?y=f:(a=Ot.creatorFee(f,r),y=f.sub(a)),{newInputVaultAmount:t.add(m),newOutputVaultAmount:n.sub(f),inputAmount:e,outputAmount:y,tradeFee:c,protocolFee:p,fundFee:d,creatorFee:a}}static swapBaseOutput(e,t,n,o,r,i,s,u){let a,c=new hl(0),m;if(u)m=e;else{let b=Ot.calculatePreFeeAmount(e,r);c=b.sub(e),m=b}let p=Ei.swapBaseOutputWithoutFees(m,t,n),d;if(u){let b=Ot.calculatePreFeeAmount(p,o.add(r)),g=b.sub(p);c=Ot.splitCreatorFee(g,o,r),a=g.sub(c),d=b}else{let b=Ot.calculatePreFeeAmount(p,o);a=b.sub(p),d=b}let f=Ot.protocolFee(a,i),y=Ot.fundFee(a,s);return{newInputVaultAmount:t.add(p),newOutputVaultAmount:e.sub(m),inputAmount:d,outputAmount:e,tradeFee:a,protocolFee:f,fundFee:y,creatorFee:c}}};import ze from"bn.js";import Qt from"decimal.js";import{PublicKey as Ui,TransactionInstruction as Rn,Keypair as rf,SystemProgram as Ga}from"@solana/web3.js";import{ASSOCIATED_TOKEN_PROGRAM_ID as jr,TOKEN_2022_PROGRAM_ID as Xa,TOKEN_PROGRAM_ID as Cn}from"@solana/spl-token";var Qp=Buffer.from("vault_and_lp_mint_auth_seed","utf8"),Hp=Buffer.from("amm_config","utf8"),jp=Buffer.from("pool","utf8"),$p=Buffer.from("pool_lp_mint","utf8"),Zp=Buffer.from("pool_vault","utf8"),Jp=Buffer.from("observation","utf8"),ef=Buffer.from("permission","utf8");function qo(l){return oe([Qp],l)}function xx(l,e){return oe([Hp,nf(e)],l)}function qa(l,e,t,n){return oe([jp,e.toBuffer(),t.toBuffer(),n.toBuffer()],l)}function tf(l,e){return oe([$p,e.toBuffer()],l)}function Il(l,e,t){return oe([Zp,e.toBuffer(),t.toBuffer()],l)}function Di(l,e){return oe([Jp,e.toBuffer()],l)}function nf(l){let e=new ArrayBuffer(2);return new DataView(e).setUint16(0,l,!1),new Uint8Array(e)}function Ua({poolId:l,programId:e,configId:t,mintA:n,mintB:o}){let r=qo(e).publicKey,i=l||qa(e,t,n,o).publicKey,s=tf(e,i).publicKey,u=Il(e,i,n).publicKey,a=Il(e,i,o).publicKey,c=Di(e,i).publicKey;return{poolId:i,configId:t,authority:r,lpMint:s,vaultA:u,vaultB:a,observationId:c}}var of=Buffer.from("locked_liquidity","utf8");function qi(l,e){return oe([of,e.toBuffer()],l)}function Bl(l,e){return oe([ef,e.toBuffer()],l)}var sf=be("Raydium_cpmm"),Ln={initialize:[175,175,109,31,13,152,155,237],deposit:[242,35,198,137,82,225,242,182],withdraw:[183,18,70,156,148,109,161,34],swapBaseInput:[143,190,90,218,196,30,51,222],swapBaseOutput:[55,217,98,86,163,74,180,173],lockCpLiquidity:[216,157,29,78,38,51,31,26],collectCpFee:[8,30,51,199,209,184,247,133],createPermissionPda:Buffer.from([135,136,2,216,137,169,181,202]),closePermissionPda:Buffer.from([156,84,32,118,69,135,70,123]),initializeWithPermission:Buffer.from([63,55,254,65,49,178,89,121]),collectCreatorFee:Buffer.from([20,22,86,123,198,28,219,132])};function xl(l,e,t,n,o,r,i,s,u,a,c,m,p,d,f,y,b,g,P,h){let I=F([A("amountMaxA"),A("amountMaxB"),A("openTime")]),T=qa(l,t,r,i).publicKey,w=[{pubkey:e,isSigner:!0,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!o.equals(T),isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!1},{pubkey:i,isSigner:!1,isWritable:!1},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:m,isSigner:!1,isWritable:!0},{pubkey:p,isSigner:!1,isWritable:!0},{pubkey:d,isSigner:!1,isWritable:!0},{pubkey:b,isSigner:!1,isWritable:!0},{pubkey:Cn,isSigner:!1,isWritable:!1},{pubkey:f,isSigner:!1,isWritable:!1},{pubkey:y,isSigner:!1,isWritable:!1},{pubkey:jr,isSigner:!1,isWritable:!1},{pubkey:pr,isSigner:!1,isWritable:!1},{pubkey:Ze,isSigner:!1,isWritable:!1}],K=Buffer.alloc(I.span);return I.encode({amountMaxA:g,amountMaxB:P,openTime:h},K),new Rn({keys:w,programId:l,data:Buffer.from([...Ln.initialize,...K])})}function Kl(l,e,t,n,o,r,i,s,u,a,c,m,p,d,f){let y=F([A("lpAmount"),A("amountMaxA"),A("amountMaxB")]),b=[{pubkey:e,isSigner:!0,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:Cn,isSigner:!1,isWritable:!1},{pubkey:Xa,isSigner:!1,isWritable:!1},{pubkey:a,isSigner:!1,isWritable:!1},{pubkey:c,isSigner:!1,isWritable:!1},{pubkey:m,isSigner:!1,isWritable:!0}],g=Buffer.alloc(y.span);return sf.debug("cpmm deposit data",{lpAmount:p.toString(),amountMaxA:d.toString(),amountMaxB:f.toString()}),y.encode({lpAmount:p,amountMaxA:d,amountMaxB:f},g),new Rn({keys:b,programId:l,data:Buffer.from([...Ln.deposit,...g])})}function Sl(l,e,t,n,o,r,i,s,u,a,c,m,p,d,f){let y=F([A("lpAmount"),A("amountMinA"),A("amountMinB")]),b=[{pubkey:e,isSigner:!0,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:Cn,isSigner:!1,isWritable:!1},{pubkey:Xa,isSigner:!1,isWritable:!1},{pubkey:a,isSigner:!1,isWritable:!1},{pubkey:c,isSigner:!1,isWritable:!1},{pubkey:m,isSigner:!1,isWritable:!0},{pubkey:ln,isSigner:!1,isWritable:!1}],g=Buffer.alloc(y.span);return y.encode({lpAmount:p,amountMinA:d,amountMinB:f},g),new Rn({keys:b,programId:l,data:Buffer.from([...Ln.withdraw,...g])})}function $r(l,e,t,n,o,r,i,s,u,a,c,m,p,d,f,y){let b=F([A("amountIn"),A("amounOutMin")]),g=[{pubkey:e,isSigner:!0,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!1},{pubkey:c,isSigner:!1,isWritable:!1},{pubkey:m,isSigner:!1,isWritable:!1},{pubkey:p,isSigner:!1,isWritable:!1},{pubkey:d,isSigner:!1,isWritable:!0}],P=Buffer.alloc(b.span);return b.encode({amountIn:f,amounOutMin:y},P),new Rn({keys:g,programId:l,data:Buffer.from([...Ln.swapBaseInput,...P])})}function Cl(l,e,t,n,o,r,i,s,u,a,c,m,p,d,f,y){let b=F([A("amountInMax"),A("amountOut")]),g=[{pubkey:e,isSigner:!0,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!1},{pubkey:c,isSigner:!1,isWritable:!1},{pubkey:m,isSigner:!1,isWritable:!1},{pubkey:p,isSigner:!1,isWritable:!1},{pubkey:d,isSigner:!1,isWritable:!0}],P=Buffer.alloc(b.span);return b.encode({amountInMax:f,amountOut:y},P),new Rn({keys:g,programId:l,data:Buffer.from([...Ln.swapBaseOutput,...P])})}async function Rl(l){var b;let{ownerInfo:e,poolInfo:t,poolKeys:n,feeNftOwner:o,getEphemeralSigners:r}=l,i=[],[s,u]=[new Ui(t.id),new Ui(t.lpMint.address)],a;if(r)a=new Ui((await r(1))[0]);else{let g=rf.generate();i.push(g),a=g.publicKey}let{publicKey:c}=$(o,a,Cn),{publicKey:m}=Bn(a),{publicKey:p}=qi(l.lockProgram,a),{publicKey:d}=$(e.wallet,u,Cn),{publicKey:f}=$(l.lockAuthProgram,u,Cn),y=af({programId:l.lockProgram,auth:l.lockAuthProgram,payer:e.feePayer,liquidityOwner:e.wallet,nftOwner:o,nftMint:a,nftAccount:c,poolId:s,lockPda:p,mintLp:u,userLpVault:d,lockLpVault:f,poolVaultA:new Ui(n.vault.A),poolVaultB:new Ui(n.vault.B),metadataAccount:m,lpAmount:l.lpAmount,withMetadata:(b=l.withMetadata)!=null?b:!0});return{address:{nftMint:a,nftAccount:c,metadataAccount:m,lockPda:p,userLpVault:d,lockLpVault:f},instructions:[y],signers:i,instructionTypes:[G.CpmmLockLp],lookupTableAddress:[]}}function af({programId:l,auth:e,payer:t,liquidityOwner:n,nftOwner:o,nftMint:r,nftAccount:i,poolId:s,lockPda:u,mintLp:a,userLpVault:c,lockLpVault:m,poolVaultA:p,poolVaultB:d,metadataAccount:f,lpAmount:y,withMetadata:b}){let g=[{pubkey:e,isSigner:!1,isWritable:!1},{pubkey:t,isSigner:!0,isWritable:!0},{pubkey:n,isSigner:!0,isWritable:!1},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!0,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!1},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!1},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:m,isSigner:!1,isWritable:!0},{pubkey:p,isSigner:!1,isWritable:!0},{pubkey:d,isSigner:!1,isWritable:!0},{pubkey:f,isSigner:!1,isWritable:!0},{pubkey:Ze,isSigner:!1,isWritable:!1},{pubkey:Ga.programId,isSigner:!1,isWritable:!1},{pubkey:Cn,isSigner:!1,isWritable:!1},{pubkey:jr,isSigner:!1,isWritable:!1},{pubkey:Ut,isSigner:!1,isWritable:!1}],P=F([A("lpAmount"),qe("withMetadata")]),h=Buffer.alloc(P.span);P.encode({lpAmount:y,withMetadata:b},h);let I=Buffer.from([...Ln.lockCpLiquidity,...h]);return new Rn({keys:g,programId:l,data:I})}function za({programId:l,nftOwner:e,auth:t,nftAccount:n,lockPda:o,poolId:r,mintLp:i,userVaultA:s,userVaultB:u,poolVaultA:a,poolVaultB:c,mintA:m,mintB:p,lockLpVault:d,lpFeeAmount:f,cpmmProgram:y,cpmmAuthProgram:b}){let g=[{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:e,isSigner:!0,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:y!=null?y:Vn,isSigner:!1,isWritable:!1},{pubkey:b!=null?b:Os,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:m,isSigner:!1,isWritable:!1},{pubkey:p,isSigner:!1,isWritable:!1},{pubkey:d,isSigner:!1,isWritable:!0},{pubkey:Cn,isSigner:!1,isWritable:!1},{pubkey:Xa,isSigner:!1,isWritable:!1},{pubkey:ln,isSigner:!1,isWritable:!1}],P=F([A("lpFeeAmount")]),h=Buffer.alloc(P.span);P.encode({lpFeeAmount:f},h);let I=Buffer.from([...Ln.collectCpFee,...h]);return new Rn({keys:g,programId:l,data:I})}function Ya(l,e,t,n,o,r,i,s,u,a,c,m,p){let d=[{pubkey:e,isSigner:!0,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!1},{pubkey:u,isSigner:!1,isWritable:!1},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:m,isSigner:!1,isWritable:!1},{pubkey:p,isSigner:!1,isWritable:!1},{pubkey:jr,isSigner:!1,isWritable:!1},{pubkey:Ga.programId,isSigner:!1,isWritable:!1}];return new Rn({keys:d,programId:l,data:Ln.collectCreatorFee})}function Ll(l,e,t,n,o,r,i,s,u,a,c,m,p,d,f,y,b,g,P,h,I,T,w){let K=F([A("amountA"),A("amountB"),A("openTime"),V("feeOn")]),x=[{pubkey:e,isSigner:!0,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!1},{pubkey:s,isSigner:!1,isWritable:!1},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:m,isSigner:!1,isWritable:!0},{pubkey:p,isSigner:!1,isWritable:!0},{pubkey:d,isSigner:!1,isWritable:!0},{pubkey:f,isSigner:!1,isWritable:!0},{pubkey:g,isSigner:!1,isWritable:!0},{pubkey:P,isSigner:!1,isWritable:!0},{pubkey:Cn,isSigner:!1,isWritable:!1},{pubkey:y,isSigner:!1,isWritable:!1},{pubkey:b,isSigner:!1,isWritable:!1},{pubkey:jr,isSigner:!1,isWritable:!1},{pubkey:Ga.programId,isSigner:!1,isWritable:!1}],S=Buffer.alloc(K.span);return K.encode({amountA:h,amountB:I,openTime:T,feeOn:w},S),new Rn({keys:x,programId:l,data:Buffer.from([...Ln.initializeWithPermission,...S])})}var Ol=F([Te(8),V("bump"),qe("disableCreatePool"),_t("index"),A("tradeFeeRate"),A("protocolFeeRate"),A("fundFeeRate"),A("createPoolFee"),M("protocolOwner"),M("fundOwner"),A("creatorFeeRate"),Q(A(),15)]),Zr=F([Te(8),M("configId"),M("poolCreator"),M("vaultA"),M("vaultB"),M("mintLp"),M("mintA"),M("mintB"),M("mintProgramA"),M("mintProgramB"),M("observationId"),V("bump"),V("status"),V("lpDecimals"),V("mintDecimalA"),V("mintDecimalB"),A("lpAmount"),A("protocolFeesMintA"),A("protocolFeesMintB"),A("fundFeesMintA"),A("fundFeesMintB"),A("openTime"),A("epoch"),V("feeOn"),qe("enableCreatorFee"),Q(V(),6),A("creatorFeesMintA"),A("creatorFeesMintB"),Q(A(),28)]),Ex=F([Te(8),M("configId"),Q(A(),30)]);var Nl=(n=>(n[n.BothToken=0]="BothToken",n[n.OnlyTokenA=1]="OnlyTokenA",n[n.OnlyTokenB=2]="OnlyTokenB",n))(Nl||{});var Gi=class extends We{constructor(e){super(e)}async load(){this.checkDisabled()}async getCpmmPoolKeys(e){return(await this.scope.api.fetchPoolKeysById({idList:[e]}))[0]}async getRpcPoolInfo(e,t){return(await this.getRpcPoolInfos([e],t))[e]}async getRpcPoolInfos(e,t){let n=await Le(this.scope.connection,e.map(m=>({pubkey:new U(m)}))),o={},r=new Set,i=[];for(let m=0;m<e.length;m++){let p=n[m];if(p.accountInfo===null)throw Error("fetch pool info error: "+String(e[m]));let d=Zr.decode(p.accountInfo.data);o[String(e[m])]=q(v({},d),{programId:p.accountInfo.owner}),r.add(String(d.configId)),i.push(d.vaultA,d.vaultB)}let s={};if(t){let m=[...r],p=await Le(this.scope.connection,m.map(d=>({pubkey:new U(d)})));for(let d=0;d<m.length;d++){let f=p[d].accountInfo;if(f===null)throw Error("fetch pool config error: "+m[d]);s[m[d]]=Ol.decode(f.data)}}let u={},a=await Le(this.scope.connection,i.map(m=>({pubkey:new U(m)})));for(let m=0;m<i.length;m++){let p=a[m].accountInfo;if(p===null)throw Error("fetch vault info error: "+i[m]);u[String(i[m])]=new ze(uf.decode(p.data).amount.toString())}let c={};for(let[m,p]of Object.entries(o)){let d=u[p.vaultA.toString()].sub(p.protocolFeesMintA).sub(p.fundFeesMintA).sub(p.creatorFeesMintA),f=u[p.vaultB.toString()].sub(p.protocolFeesMintB).sub(p.fundFeesMintB).sub(p.creatorFeesMintB);c[m]=q(v({},p),{baseReserve:d,quoteReserve:f,vaultAAmount:u[p.vaultA.toString()],vaultBAmount:u[p.vaultB.toString()],configInfo:s[p.configId.toString()],poolPrice:new Qt(f.toString()).div(new Qt(10).pow(p.mintDecimalB)).div(new Qt(d.toString()).div(new Qt(10).pow(p.mintDecimalA)))})}return c}toComputePoolInfos({pools:e,mintInfos:t}){return Object.keys(e).reduce((n,o)=>{var u,a,c,m;let r=e[o],[i,s]=[r.mintA.toBase58(),r.mintB.toBase58()];return q(v({},n),{[o]:q(v({},r),{id:new U(o),configInfo:r.configInfo,version:7,authority:qo(r.programId).publicKey,mintA:gt({address:i,decimals:r.mintDecimalA,programId:r.mintProgramA.toBase58(),extensions:{feeConfig:(u=t[i])!=null&&u.feeConfig?zn((a=t[i])==null?void 0:a.feeConfig):void 0}}),mintB:gt({address:s,decimals:r.mintDecimalB,programId:r.mintProgramB.toBase58(),extensions:{feeConfig:(c=t[s])!=null&&c.feeConfig?zn((m=t[s])==null?void 0:m.feeConfig):void 0}})})})},{})}async getPoolInfoFromRpc(e){let t=await this.getRpcPoolInfo(e,!0),n=await xo({connection:this.scope.connection,mints:[t.mintA,t.mintB]}),o=gt({address:t.mintA.toBase58(),decimals:t.mintDecimalA,programId:t.mintProgramA.toBase58(),extensions:{feeConfig:n[t.mintA.toBase58()].feeConfig?zn(n[t.mintA.toBase58()].feeConfig):void 0}}),r=gt({address:t.mintB.toBase58(),decimals:t.mintDecimalB,programId:t.mintProgramB.toBase58(),extensions:{feeConfig:n[t.mintB.toBase58()].feeConfig?zn(n[t.mintB.toBase58()].feeConfig):void 0}}),i=gt({address:t.mintLp.toBase58(),decimals:t.lpDecimals,programId:xt.toBase58()}),s={id:t.configId.toBase58(),index:t.configInfo.index,protocolFeeRate:t.configInfo.protocolFeeRate.toNumber(),tradeFeeRate:t.configInfo.tradeFeeRate.toNumber(),fundFeeRate:t.configInfo.fundFeeRate.toNumber(),createPoolFee:t.configInfo.createPoolFee.toString()},u={volume:0,volumeQuote:0,volumeFee:0,apr:0,feeApr:0,priceMin:0,priceMax:0,rewardApr:[]};return{poolInfo:{programId:t.programId.toBase58(),id:e,type:"Standard",lpMint:i,lpPrice:0,lpAmount:t.lpAmount.toNumber(),config:s,mintA:o,mintB:r,rewardDefaultInfos:[],rewardDefaultPoolInfos:"Ecosystem",price:t.poolPrice.toNumber(),mintAmountA:new Qt(t.vaultAAmount.toString()).div(10**o.decimals).toNumber(),mintAmountB:new Qt(t.vaultBAmount.toString()).div(10**r.decimals).toNumber(),feeRate:t.configInfo.tradeFeeRate.toNumber(),openTime:t.openTime.toString(),tvl:0,burnPercent:0,day:u,week:u,month:u,pooltype:[],farmUpcomingCount:0,farmOngoingCount:0,farmFinishedCount:0},poolKeys:{programId:t.programId.toBase58(),id:e,mintA:o,mintB:r,openTime:t.openTime.toString(),vault:{A:t.vaultA.toBase58(),B:t.vaultB.toBase58()},authority:qo(t.programId).publicKey.toBase58(),mintLp:i,config:s,observationId:Di(t.programId,new U(e)).publicKey.toBase58()},rpcData:t}}async createPool(f){var y=f,{poolId:e,programId:t,poolFeeAccount:n,startTime:o,ownerInfo:r,associatedOnly:i=!1,checkCreateATAOwner:s=!1,txVersion:u,feeConfig:a,computeBudgetConfig:c,txTipConfig:m,feePayer:p}=y,d=_e(y,["poolId","programId","poolFeeAccount","startTime","ownerInfo","associatedOnly","checkCreateATAOwner","txVersion","feeConfig","computeBudgetConfig","txTipConfig","feePayer"]);var E,X,Y;let b=r.feePayer||((E=this.scope.owner)==null?void 0:E.publicKey),g=new ze(new U(d.mintA.address).toBuffer()).lte(new ze(new U(d.mintB.address).toBuffer())),[P,h]=g?[d.mintA,d.mintB]:[d.mintB,d.mintA],[I,T]=g?[d.mintAAmount,d.mintBAmount]:[d.mintBAmount,d.mintAAmount],w=r.useSOLBalance&&P.address===Uo.toBase58(),K=r.useSOLBalance&&h.address===Uo.toBase58(),[x,S]=[new U(P.address),new U(h.address)],B=this.createTxBuilder(p),{account:R,instructionParams:C}=await this.scope.account.getOrCreateTokenAccount({mint:x,tokenProgram:P.programId,owner:this.scope.ownerPubKey,createInfo:w?{payer:b,amount:I}:void 0,notUseTokenAccount:w,skipCloseAccount:!w,associatedOnly:w?!1:i,checkCreateATAOwner:s});B.addInstruction(C||{});let{account:N,instructionParams:L}=await this.scope.account.getOrCreateTokenAccount({mint:new U(h.address),tokenProgram:h.programId,owner:this.scope.ownerPubKey,createInfo:K?{payer:b,amount:T}:void 0,notUseTokenAccount:K,skipCloseAccount:!K,associatedOnly:K?!1:i,checkCreateATAOwner:s});if(B.addInstruction(L||{}),R===void 0||N===void 0)throw Error("you don't has some token account");let O=Ua({poolId:e,programId:t,configId:new U(a.id),mintA:x,mintB:S});return B.addInstruction({instructions:[xl(t,this.scope.ownerPubKey,new U(a.id),O.authority,O.poolId,x,S,O.lpMint,R,N,$(this.scope.ownerPubKey,O.lpMint).publicKey,O.vaultA,O.vaultB,n,new U((X=P.programId)!=null?X:xt),new U((Y=h.programId)!=null?Y:xt),O.observationId,I,T,o)],instructionTypes:[G.CpmmCreatePool]}),B.addCustomComputeBudget(c),B.addTipInstruction(m),B.versionBuild({txVersion:u,extInfo:{address:q(v({},O),{mintA:P,mintB:h,programId:t,poolFeeAccount:n,feeConfig:a})}})}async addLiquidity(e){let{poolInfo:t,poolKeys:n,inputAmount:o,baseIn:r,slippage:i,computeResult:s,computeBudgetConfig:u,txTipConfig:a,config:c,txVersion:m,feePayer:p}=e;this.scope.availability.addStandardPosition===!1&&this.logAndCreateError("add liquidity feature disabled in your region"),o.isZero()&&this.logAndCreateError("amounts must greater than zero","amountInA",{amountInA:o.toString()});let{account:d}=this.scope,{bypassAssociatedCheck:f,checkCreateATAOwner:y}=v({bypassAssociatedCheck:!1,checkCreateATAOwner:!1},c),b=s?void 0:await this.getRpcPoolInfo(t.id),{liquidity:g,inputAmountFee:P,anotherAmount:h}=s||this.computePairAmount({poolInfo:q(v({},t),{lpAmount:new Qt(b.lpAmount.toString()).div(10**t.lpMint.decimals).toNumber()}),baseReserve:b.baseReserve,quoteReserve:b.quoteReserve,slippage:new st(0),baseIn:r,epochInfo:await this.scope.fetchEpochInfo(),amount:new Qt(o.toString()).div(10**(r?t.mintA.decimals:t.mintB.decimals))}),I=h.amount,T=t.mintA.address===Uo.toString(),w=t.mintB.address===Uo.toString(),K=this.createTxBuilder(p),[x,S]=[new U(t.mintA.address),new U(t.mintB.address)],{account:B,instructionParams:R}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:t.mintA.programId,mint:new U(t.mintA.address),owner:this.scope.ownerPubKey,createInfo:T||(r?o:I).isZero()?{payer:this.scope.ownerPubKey,amount:r?o:I}:void 0,skipCloseAccount:!T,notUseTokenAccount:T,associatedOnly:!1,checkCreateATAOwner:y});K.addInstruction(R||{});let{account:C,instructionParams:N}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:t.mintB.programId,mint:new U(t.mintB.address),owner:this.scope.ownerPubKey,createInfo:w||(r?I:o).isZero()?{payer:this.scope.ownerPubKey,amount:r?I:o}:void 0,skipCloseAccount:!w,notUseTokenAccount:w,associatedOnly:!1,checkCreateATAOwner:y});K.addInstruction(N||{}),!B&&!C&&this.logAndCreateError("cannot found target token accounts","tokenAccounts",d.tokenAccounts);let L=await d.getCreatedTokenAccount({mint:new U(t.lpMint.address)}),j=await d.handleTokenAccount({side:"out",amount:0,mint:new U(t.lpMint.address),tokenAccount:L,bypassAssociatedCheck:f,checkCreateATAOwner:y}),{tokenAccount:O}=j,E=_e(j,["tokenAccount"]);K.addInstruction(E);let X=n!=null?n:await this.getCpmmPoolKeys(t.id),Y=new st(new ze(1)).sub(i);return K.addInstruction({instructions:[Kl(new U(t.programId),this.scope.ownerPubKey,new U(X.authority),new U(t.id),O,B,C,new U(X.vault.A),new U(X.vault.B),x,S,new U(t.lpMint.address),s?s==null?void 0:s.liquidity:Y.mul(g).quotient,r?P.amount:I,r?I:P.amount)],instructionTypes:[G.CpmmAddLiquidity],lookupTableAddress:X.lookupTableAccount?[X.lookupTableAccount]:[]}),K.addCustomComputeBudget(u),K.addTipInstruction(a),K.versionBuild({txVersion:m})}async withdrawLiquidity(e){var E,X;let{poolInfo:t,poolKeys:n,lpAmount:o,slippage:r,computeBudgetConfig:i,txTipConfig:s,txVersion:u,feePayer:a,closeWsol:c=!0}=e;this.scope.availability.addStandardPosition===!1&&this.logAndCreateError("add liquidity feature disabled in your region");let m=new st(new ze(1)).sub(r),p=await this.getRpcPoolInfo(t.id),[d,f]=[m.mul(o.mul(p.baseReserve).div(p.lpAmount)).quotient,m.mul(o.mul(p.quoteReserve).div(p.lpAmount)).quotient],y=await this.scope.fetchEpochInfo(),[b,g]=[xe(d,t.mintA.extensions.feeConfig,y,!1),xe(f,t.mintB.extensions.feeConfig,y,!1)],{account:P}=this.scope,h=this.createTxBuilder(a),[I,T]=[new U(t.mintA.address),new U(t.mintB.address)],w=I.equals(Z),K=T.equals(Z),x,S,{account:B,instructionParams:R}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:t.mintA.programId,mint:new U(t.mintA.address),notUseTokenAccount:w,owner:this.scope.ownerPubKey,createInfo:{payer:this.scope.ownerPubKey,amount:0},skipCloseAccount:!(w&&c),associatedOnly:!w,checkCreateATAOwner:!1});x=B,R&&h.addInstruction(R);let{account:C,instructionParams:N}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:t.mintB.programId,mint:new U(t.mintB.address),notUseTokenAccount:K,owner:this.scope.ownerPubKey,createInfo:{payer:this.scope.ownerPubKey,amount:0},skipCloseAccount:!(K&&c),associatedOnly:!K,checkCreateATAOwner:!1});S=C,N&&h.addInstruction(N),(!x||!S)&&this.logAndCreateError("cannot found target token accounts","tokenAccounts",P.tokenAccounts);let L=await P.getCreatedTokenAccount({mint:new U(t.lpMint.address)});L||this.logAndCreateError("cannot found lp token account","tokenAccounts",P.tokenAccounts);let O=n!=null?n:await this.getCpmmPoolKeys(t.id);return h.addInstruction({instructions:[Sl(new U(t.programId),this.scope.ownerPubKey,new U(O.authority),new U(t.id),L,x,S,new U(O.vault.A),new U(O.vault.B),I,T,new U(t.lpMint.address),o,d.sub((E=b.fee)!=null?E:new ze(0)),f.sub((X=g.fee)!=null?X:new ze(0)))],instructionTypes:[G.CpmmWithdrawLiquidity],lookupTableAddress:O.lookupTableAccount?[O.lookupTableAccount]:[]}),h.addCustomComputeBudget(i),h.addTipInstruction(s),h.versionBuild({txVersion:u})}async swap(e){var R,C,N,L,O,E;let{poolInfo:t,poolKeys:n,baseIn:o,fixedOut:r,inputAmount:i,swapResult:s,slippage:u=0,config:a,computeBudgetConfig:c,txTipConfig:m,txVersion:p,feePayer:d}=e,{bypassAssociatedCheck:f,checkCreateATAOwner:y,associatedOnly:b}=v({bypassAssociatedCheck:!1,checkCreateATAOwner:!1,associatedOnly:!0},a),g=this.createTxBuilder(d),[P,h]=[new U(t.mintA.address),new U(t.mintB.address)];r?s.inputAmount=s.inputAmount.mul(new ze((1+u)*1e4)).div(new ze(1e4)):s.outputAmount=s.outputAmount.mul(new ze((1-u)*1e4)).div(new ze(1e4));let I=t.mintA.address===Z.toBase58(),T=t.mintB.address===Z.toBase58(),{account:w,instructionParams:K}=await this.scope.account.getOrCreateTokenAccount({mint:P,tokenProgram:new U((R=t.mintA.programId)!=null?R:xt),owner:this.scope.ownerPubKey,createInfo:I||!o?{payer:this.scope.ownerPubKey,amount:o?s.inputAmount:0}:void 0,notUseTokenAccount:I,skipCloseAccount:!I,associatedOnly:I?!1:b,checkCreateATAOwner:y});K&&g.addInstruction(K);let{account:x,instructionParams:S}=await this.scope.account.getOrCreateTokenAccount({mint:h,tokenProgram:new U((C=t.mintB.programId)!=null?C:xt),owner:this.scope.ownerPubKey,createInfo:T||o?{payer:this.scope.ownerPubKey,amount:o?0:s.inputAmount}:void 0,notUseTokenAccount:T,skipCloseAccount:!T,associatedOnly:T?!1:b,checkCreateATAOwner:y});S&&g.addInstruction(S),(!w||!x)&&this.logAndCreateError("user do not have token account",{mintA:t.mintA.symbol||t.mintA.address,mintB:t.mintB.symbol||t.mintB.address,mintATokenAcc:w,mintBTokenAcc:x,mintAUseSOLBalance:I,mintBUseSOLBalance:T,associatedOnly:b});let B=n!=null?n:await this.getCpmmPoolKeys(t.id);return g.addInstruction({instructions:[r?Cl(new U(t.programId),this.scope.ownerPubKey,new U(B.authority),new U(B.config.id),new U(t.id),o?w:x,o?x:w,new U(B.vault[o?"A":"B"]),new U(B.vault[o?"B":"A"]),new U((O=t[o?"mintA":"mintB"].programId)!=null?O:xt),new U((E=t[o?"mintB":"mintA"].programId)!=null?E:xt),o?P:h,o?h:P,Di(new U(t.programId),new U(t.id)).publicKey,s.inputAmount,s.outputAmount):$r(new U(t.programId),this.scope.ownerPubKey,new U(B.authority),new U(B.config.id),new U(t.id),o?w:x,o?x:w,new U(B.vault[o?"A":"B"]),new U(B.vault[o?"B":"A"]),new U((N=t[o?"mintA":"mintB"].programId)!=null?N:xt),new U((L=t[o?"mintB":"mintA"].programId)!=null?L:xt),o?P:h,o?h:P,Di(new U(t.programId),new U(t.id)).publicKey,i,s.outputAmount)],instructionTypes:[r?G.CpmmSwapBaseOut:G.ClmmSwapBaseIn]}),g.addCustomComputeBudget(c),g.addTipInstruction(m),g.versionBuild({txVersion:p})}async lockLp(e){var p,d,f,y,b;let{poolInfo:t,lpAmount:n,computeBudgetConfig:o,txTipConfig:r,txVersion:i,feePayer:s,feeNftOwner:u}=e;n.isZero()&&this.logAndCreateError("lpAmount must greater than zero",{lpAmount:n.toString()});let a=this.createTxBuilder(s),c=(p=e.poolKeys)!=null?p:await this.getCpmmPoolKeys(t.id),m=await Rl({poolInfo:t,poolKeys:c,ownerInfo:{wallet:this.scope.ownerPubKey,feePayer:(d=e.feePayer)!=null?d:this.scope.ownerPubKey},feeNftOwner:u!=null?u:this.scope.ownerPubKey,lockProgram:(f=e.programId)!=null?f:ii,lockAuthProgram:(y=e.authProgram)!=null?y:ri,lpAmount:n,withMetadata:(b=e.withMetadata)!=null?b:!0,getEphemeralSigners:e.getEphemeralSigners});return a.addInstruction(m),a.addCustomComputeBudget(o),a.addTipInstruction(r),a.versionBuild({txVersion:i,extInfo:m.address})}async harvestLockLp(e){var C;let{poolInfo:t,lpFeeAmount:n,nftMint:o,programId:r=ii,authProgram:i=ri,cpmmProgram:s,computeBudgetConfig:u,txTipConfig:a,txVersion:c,closeWsol:m=!0}=e;n.isZero()&&this.logAndCreateError("lpFeeAmount must greater than zero",{lpAmount:n.toString()});let p=e.feePayer||this.scope.ownerPubKey,d=this.createTxBuilder(p),[f,y]=[new U(t.mintA.address),new U(t.mintB.address)],b=f.equals(Z),g=y.equals(Z),P,h,{account:I,instructionParams:T}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:t.mintA.programId,mint:new U(t.mintA.address),notUseTokenAccount:b,owner:this.scope.ownerPubKey,createInfo:{payer:this.scope.ownerPubKey,amount:0},skipCloseAccount:!(b&&m),associatedOnly:!b,checkCreateATAOwner:!1});P=I,T&&d.addInstruction(T);let{account:w,instructionParams:K}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:t.mintB.programId,mint:new U(t.mintB.address),notUseTokenAccount:g,owner:this.scope.ownerPubKey,createInfo:{payer:this.scope.ownerPubKey,amount:0},skipCloseAccount:!(g&&m),associatedOnly:!g,checkCreateATAOwner:!1});h=w,K&&d.addInstruction(K),(!P||!h)&&this.logAndCreateError("cannot found target token accounts",{tokenAccountA:P,tokenAccountB:h});let x=(C=e.poolKeys)!=null?C:await this.getCpmmPoolKeys(t.id),{publicKey:S}=$(p,o,xt),{publicKey:B}=qi(r,o),{publicKey:R}=$(i,new U(t.lpMint.address),xt);return d.addInstruction({instructions:[za({programId:r,nftOwner:this.scope.ownerPubKey,auth:i,nftMint:o,nftAccount:S,lockPda:B,poolId:new U(t.id),mintLp:new U(x.mintLp.address),userVaultA:P,userVaultB:h,poolVaultA:new U(x.vault.A),poolVaultB:new U(x.vault.B),mintA:f,mintB:y,lockLpVault:R,lpFeeAmount:n,cpmmProgram:s==null?void 0:s.programId,cpmmAuthProgram:s==null?void 0:s.authProgram})],instructionTypes:[G.CpmmCollectLockFee]}),d.addCustomComputeBudget(u),d.addTipInstruction(a),d.versionBuild({txVersion:c})}async harvestMultiLockLp(e){var p;let{lockInfo:t,programId:n=ii,authProgram:o=ri,cpmmProgram:r,computeBudgetConfig:i,txVersion:s,closeWsol:u=!0}=e,a=e.feePayer||this.scope.ownerPubKey,c=this.createTxBuilder(a),m={};for(let d of t){let{poolInfo:f,lpFeeAmount:y,nftMint:b}=d;if(y.isZero())continue;let[g,P]=[new U(f.mintA.address),new U(f.mintB.address)],h=g.equals(Z),I=P.equals(Z),T=m[f.mintA.address],w=m[f.mintB.address];if(!T)if(h){let{account:R,instructionParams:C}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:f.mintA.programId,mint:new U(f.mintA.address),notUseTokenAccount:!0,owner:this.scope.ownerPubKey,createInfo:{payer:this.scope.ownerPubKey,amount:0},skipCloseAccount:!u,associatedOnly:!1,checkCreateATAOwner:!1});T=R,C&&c.addInstruction(C),m[f.mintA.address]=R}else{let R=new U(f.mintA.address);T=this.scope.account.getAssociatedTokenAccount(R,new U(f.mintA.programId)),c.addInstruction({instructions:[Go(this.scope.ownerPubKey,T,this.scope.ownerPubKey,R,new U(f.mintA.programId))]}),m[f.mintA.address]=T}if(!w)if(I){let{account:R,instructionParams:C}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:f.mintB.programId,mint:new U(f.mintB.address),notUseTokenAccount:!0,owner:this.scope.ownerPubKey,createInfo:{payer:this.scope.ownerPubKey,amount:0},skipCloseAccount:!u,associatedOnly:!1,checkCreateATAOwner:!1});w=R,C&&c.addInstruction(C),m[f.mintB.address]=R}else{let R=new U(f.mintB.address);w=this.scope.account.getAssociatedTokenAccount(R,new U(f.mintB.programId)),c.addInstruction({instructions:[Go(this.scope.ownerPubKey,w,this.scope.ownerPubKey,R,new U(f.mintB.programId))]}),m[f.mintB.address]=w}(!T||!w)&&this.logAndCreateError("cannot found target token accounts",{tokenAccountA:T,tokenAccountB:w});let K=(p=d.poolKeys)!=null?p:await this.getCpmmPoolKeys(f.id),{publicKey:x}=$(a,b,xt),{publicKey:S}=qi(n,b),{publicKey:B}=$(o,new U(f.lpMint.address),xt);c.addInstruction({instructions:[za({programId:n,nftOwner:this.scope.ownerPubKey,auth:o,nftMint:b,nftAccount:x,lockPda:S,poolId:new U(f.id),mintLp:new U(K.mintLp.address),userVaultA:T,userVaultB:w,poolVaultA:new U(K.vault.A),poolVaultB:new U(K.vault.B),mintA:g,mintB:P,lockLpVault:B,lpFeeAmount:y,cpmmProgram:r==null?void 0:r.programId,cpmmAuthProgram:r==null?void 0:r.authProgram})],instructionTypes:[G.CpmmCollectLockFee]})}return s===0?c.sizeCheckBuildV0({computeBudgetConfig:i}):c.sizeCheckBuild({computeBudgetConfig:i})}async createPoolWithPermission(y){var b=y,{poolId:e,programId:t,poolFeeAccount:n,startTime:o,ownerInfo:r,associatedOnly:i=!1,checkCreateATAOwner:s=!1,txVersion:u,feeConfig:a,computeBudgetConfig:c,txTipConfig:m,feePayer:p,feeOn:d}=b,f=_e(b,["poolId","programId","poolFeeAccount","startTime","ownerInfo","associatedOnly","checkCreateATAOwner","txVersion","feeConfig","computeBudgetConfig","txTipConfig","feePayer","feeOn"]);var X,Y,j;console.log("***this method only available for wallet with permissions***");let g=r.feePayer||((X=this.scope.owner)==null?void 0:X.publicKey),P=new ze(new U(f.mintA.address).toBuffer()).lte(new ze(new U(f.mintB.address).toBuffer())),[h,I]=P?[f.mintA,f.mintB]:[f.mintB,f.mintA],[T,w]=P?[f.mintAAmount,f.mintBAmount]:[f.mintBAmount,f.mintAAmount],K=r.useSOLBalance&&h.address===Uo.toBase58(),x=r.useSOLBalance&&I.address===Uo.toBase58(),[S,B]=[new U(h.address),new U(I.address)],R=this.createTxBuilder(p),{account:C,instructionParams:N}=await this.scope.account.getOrCreateTokenAccount({mint:S,tokenProgram:h.programId,owner:this.scope.ownerPubKey,createInfo:K?{payer:g,amount:T}:void 0,notUseTokenAccount:K,skipCloseAccount:!K,associatedOnly:K?!1:i,checkCreateATAOwner:s});R.addInstruction(N||{});let{account:L,instructionParams:O}=await this.scope.account.getOrCreateTokenAccount({mint:new U(I.address),tokenProgram:I.programId,owner:this.scope.ownerPubKey,createInfo:x?{payer:g,amount:w}:void 0,notUseTokenAccount:x,skipCloseAccount:!x,associatedOnly:x?!1:i,checkCreateATAOwner:s});if(R.addInstruction(O||{}),C===void 0||L===void 0)throw Error("you don't has some token account");let E=Ua({poolId:e,programId:t,configId:new U(a.id),mintA:S,mintB:B});return R.addInstruction({instructions:[Ll(t,this.scope.ownerPubKey,this.scope.ownerPubKey,new U(a.id),E.authority,E.poolId,S,B,E.lpMint,C,L,$(this.scope.ownerPubKey,E.lpMint).publicKey,E.vaultA,E.vaultB,n,new U((Y=h.programId)!=null?Y:xt),new U((j=I.programId)!=null?j:xt),E.observationId,Bl(t,this.scope.ownerPubKey).publicKey,T,w,o,d)],instructionTypes:[G.CpmmCreatePool]}),R.addCustomComputeBudget(c),R.addTipInstruction(m),R.versionBuild({txVersion:u,extInfo:{address:q(v({},E),{mintA:h,mintB:I,programId:t,poolFeeAccount:n,feeConfig:a})}})}async collectCreatorFees({poolInfo:e,poolKeys:t,programId:n=Vn,txVersion:o,computeBudgetConfig:r,txTipConfig:i,feePayer:s}){let u=s||this.scope.ownerPubKey,a=this.createTxBuilder(u),c=t!=null?t:await this.getCpmmPoolKeys(e.id),[m,p,d,f]=[new U(e.mintA.address),new U(e.mintB.address),new U(e.mintA.programId),new U(e.mintB.programId)],y=this.scope.account.getAssociatedTokenAccount(m,d),b=this.scope.account.getAssociatedTokenAccount(p,f);return a.addInstruction({instructions:[Go(this.scope.ownerPubKey,y,this.scope.ownerPubKey,m,new U(e.mintA.programId)),Go(this.scope.ownerPubKey,b,this.scope.ownerPubKey,p,new U(e.mintB.programId))]}),a.addInstruction({instructions:[Ya(n,this.scope.ownerPubKey,new U(c.authority),new U(c.id),new U(c.config.id),new U(c.vault.A),new U(c.vault.B),m,p,y,b,d,f)],instructionTypes:[]}),a.addCustomComputeBudget(r),a.addTipInstruction(i),a.versionBuild({txVersion:o})}async collectMultiCreatorFees({poolInfoList:e,programId:t=Vn,txVersion:n,computeBudgetConfig:o,feePayer:r}){let i=r||this.scope.ownerPubKey,s=this.createTxBuilder(i),u={},a=await this.scope.api.fetchPoolKeysById({idList:e.map(c=>c.id)});for(let c of e){let m=a.find(P=>P.id===c.id)||await this.getCpmmPoolKeys(c.id),[p,d,f,y]=[new U(c.mintA.address),new U(c.mintB.address),new U(c.mintA.programId),new U(c.mintB.programId)],b=u[c.mintA.address]||this.scope.account.getAssociatedTokenAccount(p,f),g=u[c.mintB.address]||this.scope.account.getAssociatedTokenAccount(d,y);u[c.mintA.address]||s.addInstruction({instructions:[Go(this.scope.ownerPubKey,b,this.scope.ownerPubKey,p,f)]}),u[c.mintB.address]||s.addInstruction({instructions:[Go(this.scope.ownerPubKey,g,this.scope.ownerPubKey,d,y)]}),u[c.mintA.address]=b,u[c.mintB.address]=g,s.addInstruction({instructions:[Ya(t,this.scope.ownerPubKey,new U(m.authority),new U(m.id),new U(m.config.id),new U(m.vault.A),new U(m.vault.B),p,d,b,g,f,y)],instructionTypes:[]})}return n===0?s.sizeCheckBuildV0({computeBudgetConfig:o}):s.sizeCheckBuild({computeBudgetConfig:o})}computeSwapAmount({pool:e,amountIn:t,outputMint:n,slippage:o}){let r=n.toString()===e.mintB.address,i=e.feeOn===0||e.feeOn===2,s=r?Wi.swapBaseInput(t,r?e.baseReserve:e.quoteReserve,r?e.quoteReserve:e.baseReserve,e.configInfo.tradeFeeRate,e.configInfo.creatorFeeRate,e.configInfo.protocolFeeRate,e.configInfo.fundFeeRate,i):Wi.swapBaseOutput(t,r?e.baseReserve:e.quoteReserve,r?e.quoteReserve:e.baseReserve,e.configInfo.tradeFeeRate,e.configInfo.creatorFeeRate,e.configInfo.protocolFeeRate,e.configInfo.fundFeeRate,i),u=new Qt(s.outputAmount.toString()).div(s.inputAmount.toString()),a=s.outputAmount.mul(new ze((1-o)*1e4)).div(new ze(1e4));return{allTrade:s.inputAmount.eq(t),amountIn:t,amountOut:s.outputAmount,minAmountOut:a,executionPrice:u,fee:s.tradeFee,priceImpact:e.poolPrice.sub(u).div(e.poolPrice)}}computePairAmount({poolInfo:e,baseReserve:t,quoteReserve:n,amount:o,slippage:r,epochInfo:i,baseIn:s}){var I,T,w,K,x,S,B,R,C;let u=1-Number(r.toSignificant())/100,a=new ze(new Qt(o).mul(10**e[s?"mintA":"mintB"].decimals).mul(u).toFixed(0)),c=xe(a,e[s?"mintA":"mintB"].extensions.feeConfig,i,!1),m=a.sub((I=c.fee)!=null?I:new ze(0)),p=new ze(new Qt(e.lpAmount).mul(10**e.lpMint.decimals).toFixed(0,Qt.ROUND_DOWN));this.logDebug("baseReserve:",t.toString(),"quoteReserve:",n.toString()),this.logDebug("tokenIn:",s?e.mintA.symbol:e.mintB.symbol,"amountIn:",a.toString(),"amountInFee:",(w=(T=c.fee)==null?void 0:T.toString())!=null?w:0,"anotherToken:",s?e.mintB.symbol:e.mintA.symbol,"slippage:",`${r.toSignificant()}%`);let d=s?"base":"quote";this.logDebug("input side:",d);let f=m.mul(p).div(d==="base"?t:n),y={amount:St,fee:void 0,expirationTime:void 0};if(!m.isZero()){let N=cf(f,t,n,p);this.logDebug("lpAmountData:",{amountA:N.amountA.toString(),amountB:N.amountB.toString()}),y=xe(N[s?"amountB":"amountA"],e[s?"mintB":"mintA"].extensions.feeConfig,i,!0)}let b=new st(new ze(1)).add(r),g=new st(new ze(1)).sub(r),P=xe(b.mul(y.amount.sub((K=y.fee)!=null?K:new ze(0))).quotient,e[s?"mintB":"mintA"].extensions.feeConfig,i,!0),h=xe(g.mul(y.amount.sub((x=y.fee)!=null?x:new ze(0))).quotient,e[s?"mintB":"mintA"].extensions.feeConfig,i,!0);return this.logDebug("anotherAmount:",y.amount.toString(),"anotherAmountFee:",(B=(S=y.fee)==null?void 0:S.toString())!=null?B:0,"maxAnotherAmount:",P.amount.toString(),"maxAnotherAmountFee:",(C=(R=P.fee)==null?void 0:R.toString())!=null?C:0),{inputAmountFee:c,anotherAmount:y,maxAnotherAmount:P,minAnotherAmount:h,liquidity:f}}};function cf(l,e,t,n){let o=l.mul(e).div(n);!o.isZero()&&!l.mul(e).mod(n).isZero()&&(o=o.add(new ze(1)));let r=l.mul(t).div(n);return!r.isZero()&&!l.mul(t).mod(n).isZero()&&(r=r.add(new ze(1))),{amountA:o,amountB:r}}import{PublicKey as Po}from"@solana/web3.js";import{createTransferInstruction as El,TOKEN_PROGRAM_ID as $e,TOKEN_2022_PROGRAM_ID as ts}from"@solana/spl-token";import ns from"bn.js";import Yi from"decimal.js";var Ml={[Ar.toBase58()]:3},vl={3:Ar};var Qa=F([Te(5),Te(8),M("ownAddress"),A("vaultSignerNonce"),M("baseMint"),M("quoteMint"),M("baseVault"),A("baseDepositsTotal"),A("baseFeesAccrued"),M("quoteVault"),A("quoteDepositsTotal"),A("quoteFeesAccrued"),A("quoteDustThreshold"),M("requestQueue"),M("eventQueue"),M("bids"),M("asks"),A("baseLotSize"),A("quoteLotSize"),A("feeRateBps"),A("referrerRebatesAccrued"),Te(7)]),Fl={3:Qa};import{PublicKey as _l}from"@solana/web3.js";var Jr=be("Serum"),es=class{static getProgramId(e){let t=vl[e];return t||Jr.logWithError("invalid version","version",e),t}static getVersion(e){let t=e.toBase58(),n=Ml[t];return n||Jr.logWithError("invalid program id","programId",t),n}static getStateLayout(e){let t=Fl[e];return t||Jr.logWithError(!!t,"invalid version","version",e),t}static getLayouts(e){return{state:this.getStateLayout(e)}}static getAssociatedAuthority({programId:e,marketId:t}){let n=[t.toBuffer()],o=0,r;for(;o<100;){try{let i=n.concat(Buffer.from([o]),Buffer.alloc(7));r=_l.createProgramAddressSync(i,e)}catch(i){if(i instanceof TypeError)throw i;o++;continue}return{publicKey:r,nonce:o}}return Jr.logWithError("unable to find a viable program address nonce","params",{programId:e,marketId:t}),{publicKey:_l.default,nonce:o}}};import{PublicKey as _,SystemProgram as Xi,TransactionInstruction as zi}from"@solana/web3.js";import yn from"bn.js";import{ASSOCIATED_TOKEN_PROGRAM_ID as Ha,TOKEN_2022_PROGRAM_ID as ja,TOKEN_PROGRAM_ID as Hn}from"@solana/spl-token";function cS(l,e,t,n,o,r,i,s,u,a,c,m){let p=F([V("instruction"),A("amountIn"),A("amountOut")]),d=[{pubkey:Xi.programId,isSigner:!1,isWritable:!1},{pubkey:Hn,isSigner:!1,isWritable:!1},{pubkey:new _(t.programId),isSigner:!1,isWritable:!1},{pubkey:new _(t.id),isSigner:!1,isWritable:!0},{pubkey:new _(n.id),isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!0,isWritable:!1}];if(e.type==="Concentrated"){let y=Ee(t);d.push({pubkey:y.config.id,isSigner:!1,isWritable:!1},{pubkey:y.id,isSigner:!1,isWritable:!0},{pubkey:y.mintA.address.equals(u)?y.vault.A:y.vault.B,isSigner:!1,isWritable:!0},{pubkey:y.mintA.address.equals(u)?y.vault.B:y.vault.A,isSigner:!1,isWritable:!0},{pubkey:y.id,isSigner:!1,isWritable:!0},...m.map(b=>({pubkey:b,isSigner:!1,isWritable:!0})))}else if(e.pooltype.includes("StablePool")){let y=Ee(t);d.push({pubkey:y.authority,isSigner:!1,isWritable:!1},{pubkey:y.marketProgramId,isSigner:!1,isWritable:!1},{pubkey:y.id,isSigner:!1,isWritable:!0},{pubkey:new _("CDSr3ssLcRB6XYPJwAfFt18MZvEZp4LjHcvzBVZ45duo"),isSigner:!1,isWritable:!1},{pubkey:y.openOrders,isSigner:!1,isWritable:!0},{pubkey:y.vault.A,isSigner:!1,isWritable:!0},{pubkey:y.vault.B,isSigner:!1,isWritable:!0},{pubkey:y.marketId,isSigner:!1,isWritable:!0},{pubkey:y.marketBids,isSigner:!1,isWritable:!0},{pubkey:y.marketAsks,isSigner:!1,isWritable:!0},{pubkey:y.marketEventQueue,isSigner:!1,isWritable:!0},{pubkey:y.id,isSigner:!1,isWritable:!0},{pubkey:y.id,isSigner:!1,isWritable:!0})}else{let y=Ee(t);d.push({pubkey:y.authority,isSigner:!1,isWritable:!1},{pubkey:y.marketProgramId,isSigner:!1,isWritable:!1},{pubkey:y.marketAuthority,isSigner:!1,isWritable:!1},{pubkey:y.openOrders,isSigner:!1,isWritable:!0},{pubkey:y.vault.A,isSigner:!1,isWritable:!0},{pubkey:y.vault.B,isSigner:!1,isWritable:!0},{pubkey:y.marketId,isSigner:!1,isWritable:!0},{pubkey:y.marketBids,isSigner:!1,isWritable:!0},{pubkey:y.marketAsks,isSigner:!1,isWritable:!0},{pubkey:y.marketEventQueue,isSigner:!1,isWritable:!0},...y.marketProgramId.toString()==="srmqPvymJeFKQ4zGQed1GFppgkRHL9kaELCbyksJtPX"?[{pubkey:y.marketBaseVault,isSigner:!1,isWritable:!0},{pubkey:y.marketQuoteVault,isSigner:!1,isWritable:!0}]:[{pubkey:y.id,isSigner:!1,isWritable:!0},{pubkey:y.id,isSigner:!1,isWritable:!0}])}let f=Buffer.alloc(p.span);return p.encode({instruction:4,amountIn:a,amountOut:c},f),new zi({keys:d,programId:l,data:f})}function lS(l,e,t,n,o,r,i,s,u,a){let c=F([V("instruction")]),m=[{pubkey:Xi.programId,isSigner:!1,isWritable:!1},{pubkey:Hn,isSigner:!1,isWritable:!1},{pubkey:new _(String(n.programId)),isSigner:!1,isWritable:!1},{pubkey:new _(String(n.id)),isSigner:!1,isWritable:!0},{pubkey:new _(String(t.id)),isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!0,isWritable:!1}];if(e.type==="Concentrated"){let d=Ee(n);m.push({pubkey:d.config.id,isSigner:!1,isWritable:!1},{pubkey:d.id,isSigner:!1,isWritable:!0},{pubkey:d.mintA.address.equals(u)?d.vault.A:d.vault.B,isSigner:!1,isWritable:!0},{pubkey:d.mintA.address.equals(u)?d.vault.B:d.vault.A,isSigner:!1,isWritable:!0},{pubkey:d.id,isSigner:!1,isWritable:!0},...a.map(f=>({pubkey:f,isSigner:!1,isWritable:!0})))}else if(e.pooltype.includes("StablePool")){let d=Ee(n);m.push({pubkey:d.authority,isSigner:!1,isWritable:!1},{pubkey:d.marketProgramId,isSigner:!1,isWritable:!1},{pubkey:d.id,isSigner:!1,isWritable:!0},{pubkey:new _("CDSr3ssLcRB6XYPJwAfFt18MZvEZp4LjHcvzBVZ45duo"),isSigner:!1,isWritable:!1},{pubkey:d.openOrders,isSigner:!1,isWritable:!0},{pubkey:d.vault.A,isSigner:!1,isWritable:!0},{pubkey:d.vault.B,isSigner:!1,isWritable:!0},{pubkey:d.marketId,isSigner:!1,isWritable:!0},{pubkey:d.marketBids,isSigner:!1,isWritable:!0},{pubkey:d.marketAsks,isSigner:!1,isWritable:!0},{pubkey:d.marketEventQueue,isSigner:!1,isWritable:!0},{pubkey:d.id,isSigner:!1,isWritable:!0},{pubkey:d.id,isSigner:!1,isWritable:!0})}else{let d=Ee(n);m.push({pubkey:d.authority,isSigner:!1,isWritable:!1},{pubkey:d.marketProgramId,isSigner:!1,isWritable:!1},{pubkey:d.marketAuthority,isSigner:!1,isWritable:!1},{pubkey:d.openOrders,isSigner:!1,isWritable:!0},{pubkey:d.vault.A,isSigner:!1,isWritable:!0},{pubkey:d.vault.B,isSigner:!1,isWritable:!0},{pubkey:d.marketId,isSigner:!1,isWritable:!0},{pubkey:d.marketBids,isSigner:!1,isWritable:!0},{pubkey:d.marketAsks,isSigner:!1,isWritable:!0},{pubkey:d.marketEventQueue,isSigner:!1,isWritable:!0},...d.marketProgramId.toString()==="srmqPvymJeFKQ4zGQed1GFppgkRHL9kaELCbyksJtPX"?[{pubkey:d.marketBaseVault,isSigner:!1,isWritable:!0},{pubkey:d.marketQuoteVault,isSigner:!1,isWritable:!0}]:[{pubkey:d.id,isSigner:!1,isWritable:!0},{pubkey:d.id,isSigner:!1,isWritable:!0}])}let p=Buffer.alloc(c.span);return c.encode({instruction:5},p),new zi({keys:m,programId:l,data:p})}function lf(l,e,t,n,o,r,i,s,u,a,c,m,p,d,f){var w;let y=[],b=[k({pubkey:Hn,isWritable:!1}),k({pubkey:ja,isWritable:!1}),k({pubkey:Ha,isWritable:!1}),k({pubkey:Xi.programId,isWritable:!1}),k({pubkey:e,isSigner:!0})];b.push(k({pubkey:t})),b.push(k({pubkey:o}));let g=[u,a],P=[c,m],h=[r,i,s];for(let K=0;K<g.length;K++){let x=g[K],S=h[K]===x.mintA.address;if(b.push(k({pubkey:new _(x.programId),isWritable:!1})),K===g.length-1?b.push(k({pubkey:o})):b.push(k({pubkey:n})),b.push(k({pubkey:new _(h[K])})),b.push(k({pubkey:new _(h[K+1])})),x.version===6){let B=P[K];b.push(k({pubkey:new _(B.config.id)})),b.push(k({pubkey:new _(B.id)})),b.push(k({pubkey:new _(S?B.vault.A:B.vault.B)})),b.push(k({pubkey:new _(S?B.vault.B:B.vault.A)})),b.push(k({pubkey:new _(x.observationId)})),b.push(k({pubkey:ln})),b.push(k({pubkey:je(new _(x.programId),new _(x.id)).publicKey})),y.push($a(x.sqrtPriceX64.toString(),S));for(let R of(w=f[K])!=null?w:[])b.push(k({pubkey:new _(R)}))}else if(x.version===5){let B=P[K];b.push(k({pubkey:new _(B.id)})),b.push(k({pubkey:new _(B.authority),isWritable:!1})),b.push(k({pubkey:new _(B.marketProgramId)})),b.push(k({pubkey:new _(B.marketAuthority)})),b.push(k({pubkey:kr,isWritable:!1})),b.push(k({pubkey:new _(B.openOrders)})),b.push(k({pubkey:new _(B.vault.A)})),b.push(k({pubkey:new _(B.vault.B)})),b.push(k({pubkey:new _(B.id)})),b.push(k({pubkey:new _(B.id)})),b.push(k({pubkey:new _(B.id)})),b.push(k({pubkey:new _(B.id)})),b.push(k({pubkey:new _(B.id)})),b.push(k({pubkey:new _(B.id)})),b.push(k({pubkey:new _(B.marketId)})),b.push(k({pubkey:new _(B.marketBids)})),b.push(k({pubkey:new _(B.marketAsks)})),b.push(k({pubkey:new _(B.marketEventQueue)})),b.push(k({pubkey:new _(B.marketBaseVault)})),b.push(k({pubkey:new _(B.marketQuoteVault)}))}else if(x.version===4){let B=P[K],R=x.status!==1;b.push(k({pubkey:new _(B.id)})),b.push(k({pubkey:new _(B.authority),isWritable:!1})),b.push(k({pubkey:new _(R?B.id:B.marketProgramId)})),b.push(k({pubkey:new _(R?B.id:B.marketAuthority)})),b.push(k({pubkey:new _(R?B.id:B.openOrders)})),b.push(k({pubkey:new _(B.vault.A)})),b.push(k({pubkey:new _(B.vault.B)})),b.push(k({pubkey:new _(R?B.id:B.marketId)})),b.push(k({pubkey:new _(R?B.id:B.marketBids)})),b.push(k({pubkey:new _(R?B.id:B.marketAsks)})),b.push(k({pubkey:new _(R?B.id:B.marketEventQueue)})),b.push(k({pubkey:new _(R?B.id:B.marketBaseVault)})),b.push(k({pubkey:new _(R?B.id:B.marketQuoteVault)}))}else if(x.version===7){let B=P[K];b.push(k({pubkey:new _(B.authority)})),b.push(k({pubkey:new _(B.config.id)})),b.push(k({pubkey:new _(B.id)})),b.push(k({pubkey:new _(S?B.vault.A:B.vault.B)})),b.push(k({pubkey:new _(S?B.vault.B:B.vault.A)})),b.push(k({pubkey:new _(x.observationId)}))}else throw Error("pool type error")}let I=F([V("insId"),A("amountIn"),A("amountOut"),Q(ie(),y.length,"clmmPriceLimit")]),T=Buffer.alloc(I.span);return I.encode({insId:0,amountIn:p,amountOut:d,clmmPriceLimit:y},T),new zi({keys:b,programId:l,data:T})}function $a(l,e){if(l)if(e){let t=new yn(l).div(new yn(25));return t.gt(vr)?t:vr}else{let t=new yn(l).mul(new yn(25));return t.lt(Fr)?t:Fr}else return e?vr:Fr}function Vl({routeProgram:l,ownerInfo:e,inputMint:t,swapInfo:n}){var o,r,i,s,u,a,c;if(n.routeType==="amm")if(n.poolInfo[0].version===6){let m=n.poolKey[0],p=Ee(m),d=t.equals(p.mintA.address)?zt.add(Vt):Yt.sub(Vt);return Re.makeSwapBaseInInstructions({poolInfo:m,poolKeys:m,observationId:n.poolInfo[0].observationId,ownerInfo:{wallet:e.wallet,tokenAccountA:p.mintA.address.equals(t)?e.sourceToken:e.destinationToken,tokenAccountB:p.mintA.address.equals(t)?e.destinationToken:e.sourceToken},inputMint:t,amountIn:n.amountIn.amount.raw,amountOutMin:n.minAmountOut.amount.raw.sub((r=(o=n.minAmountOut.fee)==null?void 0:o.raw)!=null?r:new yn(0)),sqrtPriceLimitX64:d,remainingAccounts:(i=n.remainingAccounts[0])!=null?i:[]})}else if(n.poolInfo[0].version===7){let m=n.poolInfo[0],p=t.toString()===n.poolInfo[0].mintA.address;return{signers:[],instructions:[$r(m.programId,e.wallet,m.authority,m.configId,m.id,e.sourceToken,e.destinationToken,p?m.vaultA:m.vaultB,p?m.vaultB:m.vaultA,p?m.mintProgramA:m.mintProgramB,p?m.mintProgramB:m.mintProgramA,new _(m[p?"mintA":"mintB"].address),new _(m[p?"mintB":"mintA"].address),m.observationId,n.amountIn.amount.raw,n.minAmountOut.amount.raw)],lookupTableAddress:[],instructionTypes:[p?G.CpmmSwapBaseIn:G.CpmmSwapBaseOut],address:{}}}else{let m=n.poolKey[0];return{signers:[],instructions:[Ur({poolKeys:m,version:n.poolInfo[0].pooltype.includes("StablePool")?5:4,userKeys:{tokenAccountIn:e.sourceToken,tokenAccountOut:e.destinationToken,owner:e.wallet},amountIn:n.amountIn.amount.raw,amountOut:n.minAmountOut.amount.raw.sub((u=(s=n.minAmountOut.fee)==null?void 0:s.raw)!=null?u:new yn(0)),fixedSide:"in"})],lookupTableAddress:m.lookupTableAccount?[m.lookupTableAccount]:[],instructionTypes:[n.poolInfo[0].pooltype.includes("StablePool")?G.AmmV5SwapBaseIn:G.AmmV4SwapBaseIn],address:{}}}else if(n.routeType==="route"){let m=n.poolInfo[0],p=n.poolInfo[1],d=n.poolKey[0],f=n.poolKey[1];if(e.routeToken===void 0)throw Error("owner route token account check error");return{signers:[],instructions:[lf(l,e.wallet,e.sourceToken,e.routeToken,e.destinationToken,t.toString(),n.middleToken.mint.toString(),n.outputMint.toString(),m,p,d,f,n.amountIn.amount.raw,n.minAmountOut.amount.raw.sub((c=(a=n.minAmountOut.fee)==null?void 0:a.raw)!=null?c:new yn(0)),n.remainingAccounts)],instructionTypes:[G.RouteSwap],lookupTableAddress:[d.lookupTableAccount,f.lookupTableAccount].filter(y=>y!==void 0),address:{}}}else throw Error("route type error")}function mS({programId:l,wallet:e,amount:t,inputAccount:n,outputAccount:o,routeInfo:r,poolKeys:i}){var p;if(r.success===!1)throw Error("route info error");let s=[],u=[k({pubkey:Hn,isWritable:!1}),k({pubkey:ja,isWritable:!1}),k({pubkey:Ha,isWritable:!1}),k({pubkey:Xi.programId,isWritable:!1}),k({pubkey:e,isSigner:!0})],a={[r.data.inputMint]:n,[r.data.outputMint]:o};u.push(k({pubkey:a[r.data.inputMint]})),u.push(k({pubkey:a[r.data.outputMint]}));for(let d=0;d<i.length;d++){let f=r.data.routePlan[d],y=i[d],b=f.inputMint===y.mintA.address;if(u.push(k({pubkey:new _(y.programId),isWritable:!1})),d===i.length-1)u.push(k({pubkey:a[f.outputMint]}));else{let g=f.outputMint;if(a[g]===void 0){let P=$(e,new _(g),y.programId===wt.CLMM_PROGRAM_ID.toBase58()||y.programId===wt.CREATE_CPMM_POOL_PROGRAM.toBase58()?new _(b?y.mintB.programId:y.mintA.programId):Hn).publicKey;a[g]=P}u.push(k({pubkey:a[g]}))}if(u.push(k({pubkey:new _(f.inputMint)})),u.push(k({pubkey:new _(f.outputMint)})),y.programId===wt.CLMM_PROGRAM_ID.toBase58()){let g=y;u.push(k({pubkey:new _(g.config.id)})),u.push(k({pubkey:new _(g.id)})),u.push(k({pubkey:new _(b?g.vault.A:g.vault.B)})),u.push(k({pubkey:new _(b?g.vault.B:g.vault.A)})),u.push(k({pubkey:new _(g.observationId)})),u.push(k({pubkey:ln,isWritable:!1})),u.push(k({pubkey:new _(g.exBitmapAccount)})),s.push($a(f.lastPoolPriceX64,b));for(let P of(p=f.remainingAccounts)!=null?p:[])u.push(k({pubkey:new _(P)}))}else if(y.programId===wt.AMM_STABLE.toBase58()){let g=y;u.push(k({pubkey:new _(g.id)})),u.push(k({pubkey:new _(g.authority),isWritable:!1})),u.push(k({pubkey:new _(g.marketProgramId),isWritable:!1})),u.push(k({pubkey:new _(g.marketAuthority),isWritable:!1})),u.push(k({pubkey:kr,isWritable:!1})),u.push(k({pubkey:new _(g.openOrders)})),u.push(k({pubkey:new _(g.vault.A)})),u.push(k({pubkey:new _(g.vault.B)})),u.push(k({pubkey:new _(g.marketId)})),u.push(k({pubkey:new _(g.marketBids)})),u.push(k({pubkey:new _(g.marketAsks)})),u.push(k({pubkey:new _(g.marketEventQueue)})),u.push(k({pubkey:new _(g.marketBaseVault)})),u.push(k({pubkey:new _(g.marketQuoteVault)}))}else if(y.programId===wt.AMM_V4.toBase58()){let g=y;u.push(k({pubkey:new _(g.id)})),u.push(k({pubkey:new _(g.authority),isWritable:!1})),u.push(k({pubkey:new _(g.id)})),u.push(k({pubkey:new _(g.id)})),u.push(k({pubkey:new _(g.id)})),u.push(k({pubkey:new _(g.vault.A)})),u.push(k({pubkey:new _(g.vault.B)})),u.push(k({pubkey:new _(g.id)})),u.push(k({pubkey:new _(g.id)})),u.push(k({pubkey:new _(g.id)})),u.push(k({pubkey:new _(g.id)})),u.push(k({pubkey:new _(g.id)})),u.push(k({pubkey:new _(g.id)}))}else if(y.programId===wt.CREATE_CPMM_POOL_PROGRAM.toBase58()){let g=y;u.push(k({pubkey:new _(g.authority)})),u.push(k({pubkey:new _(g.config.id)})),u.push(k({pubkey:new _(g.id)})),u.push(k({pubkey:new _(b?g.vault.A:g.vault.B)})),u.push(k({pubkey:new _(b?g.vault.B:g.vault.A)})),u.push(k({pubkey:new _(g.observationId)}))}else throw Error("pool type error")}let c=F([V("insId"),A("amountIn"),A("amountOut"),Q(ie(),s.length,"clmmPriceLimit")]),m=Buffer.alloc(c.span);return c.encode({insId:0,amountIn:t,amountOut:new yn(r.data.otherAmountThreshold),clmmPriceLimit:s},m),new zi({keys:u,programId:l,data:m})}function dS({programId:l,wallet:e,inputAccount:t,outputAccount:n,routeInfo:o,poolKeys:r}){var m;if(o.success===!1)throw Error("route info error");let i=[],s=[k({pubkey:Hn,isWritable:!1}),k({pubkey:ja,isWritable:!1}),k({pubkey:Ha,isWritable:!1}),k({pubkey:Xi.programId,isWritable:!1}),k({pubkey:e,isSigner:!0})],u={[o.data.inputMint]:t,[o.data.outputMint]:n};for(let p=r.length-1;p>=0;p--){let d=o.data.routePlan[p],f=r[p],y=d.inputMint===f.mintA.address;if(s.push(k({pubkey:new _(f.programId)})),p===0)s.push(k({pubkey:u[d.inputMint]}));else{let b=d.inputMint;if(u[b]===void 0){let g=$(e,new _(b),f.programId===wt.CLMM_PROGRAM_ID.toBase58()||f.programId===wt.CREATE_CPMM_POOL_PROGRAM.toBase58()?new _(y?f.mintA.programId:f.mintB.programId):Hn).publicKey;u[b]=g}s.push(k({pubkey:u[b]}))}if(p===r.length-1)s.push(k({pubkey:u[d.outputMint]}));else{let b=d.outputMint;if(u[b]===void 0){let g=$(e,new _(b),f.programId===wt.CLMM_PROGRAM_ID.toBase58()||f.programId===wt.CREATE_CPMM_POOL_PROGRAM.toBase58()?new _(y?f.mintB.programId:f.mintA.programId):Hn).publicKey;u[b]=g}s.push(k({pubkey:u[b]}))}if(s.push(k({pubkey:new _(d.inputMint)})),s.push(k({pubkey:new _(d.outputMint)})),f.programId===wt.CLMM_PROGRAM_ID.toBase58()){let b=f;s.push(k({pubkey:new _(b.config.id)})),s.push(k({pubkey:new _(b.id)})),s.push(k({pubkey:new _(y?b.vault.A:b.vault.B)})),s.push(k({pubkey:new _(y?b.vault.B:b.vault.A)})),s.push(k({pubkey:new _(b.observationId)})),s.push(k({pubkey:ln,isWritable:!1})),s.push(k({pubkey:new _(b.exBitmapAccount)})),i.push($a(d.lastPoolPriceX64,y));for(let g of(m=d.remainingAccounts)!=null?m:[])s.push(k({pubkey:new _(g)}))}else if(f.programId===wt.AMM_STABLE.toBase58()){let b=f;s.push(k({pubkey:new _(b.id)})),s.push(k({pubkey:new _(b.authority),isWritable:!1})),s.push(k({pubkey:new _(b.marketProgramId),isWritable:!1})),s.push(k({pubkey:new _(b.marketAuthority),isWritable:!1})),s.push(k({pubkey:kr,isWritable:!1})),s.push(k({pubkey:new _(b.openOrders)})),s.push(k({pubkey:new _(b.vault.A)})),s.push(k({pubkey:new _(b.vault.B)})),s.push(k({pubkey:new _(b.marketId)})),s.push(k({pubkey:new _(b.marketBids)})),s.push(k({pubkey:new _(b.marketAsks)})),s.push(k({pubkey:new _(b.marketEventQueue)})),s.push(k({pubkey:new _(b.marketBaseVault)})),s.push(k({pubkey:new _(b.marketQuoteVault)}))}else if(f.programId===wt.AMM_V4.toBase58()){let b=f;s.push(k({pubkey:new _(b.id)})),s.push(k({pubkey:new _(b.authority),isWritable:!1})),s.push(k({pubkey:new _(b.id)})),s.push(k({pubkey:new _(b.id)})),s.push(k({pubkey:new _(b.id)})),s.push(k({pubkey:new _(b.vault.A)})),s.push(k({pubkey:new _(b.vault.B)})),s.push(k({pubkey:new _(b.id)})),s.push(k({pubkey:new _(b.id)})),s.push(k({pubkey:new _(b.id)})),s.push(k({pubkey:new _(b.id)})),s.push(k({pubkey:new _(b.id)})),s.push(k({pubkey:new _(b.id)}))}else if(f.programId===wt.CREATE_CPMM_POOL_PROGRAM.toBase58()){let b=f;s.push(k({pubkey:new _(b.authority)})),s.push(k({pubkey:new _(b.config.id)})),s.push(k({pubkey:new _(b.id)})),s.push(k({pubkey:new _(y?b.vault.A:b.vault.B)})),s.push(k({pubkey:new _(y?b.vault.B:b.vault.A)})),s.push(k({pubkey:new _(b.observationId)}))}else throw Error("pool type error")}let a=F([V("insId"),A("amountIn"),A("amountOut"),Q(ie(),i.length,"clmmPriceLimit")]),c=Buffer.alloc(a.span);return a.encode({insId:1,amountIn:new yn(o.data.otherAmountThreshold),amountOut:new yn(o.data.outputAmount),clmmPriceLimit:i},c),new zi({keys:s,programId:l,data:c})}var On=new ns(0),Qi=class extends We{constructor(e){super(e)}async getWSolAccounts(){this.scope.checkOwner(),await this.scope.account.fetchWalletTokenAccounts();let e=this.scope.account.tokenAccounts.filter(t=>t.mint.equals(Z));return e.sort((t,n)=>t.isAssociated?1:n.isAssociated||t.amount.lt(n.amount)?-1:1),e}async unWrapWSol(e){let{amount:t,tokenProgram:n,txVersion:o=1,feePayer:r}=e,i=await this.getWSolAccounts(),s=this.createTxBuilder(r);s.addCustomComputeBudget(e.computeBudgetConfig);let u=ne(t);for(let a=0;a<i.length;a++)u.gte(i[a].amount)?(s.addInstruction({instructions:[hn({tokenAccount:i[a].publicKey,payer:this.scope.ownerPubKey,owner:this.scope.ownerPubKey,programId:n})]}),u.sub(i[a].amount)):s.addInstruction({instructions:[hn({tokenAccount:i[a].publicKey,payer:this.scope.ownerPubKey,owner:this.scope.ownerPubKey,programId:n})]});return s.versionBuild({txVersion:o})}async wrapWSol(e,t,n,o){let r=this.createTxBuilder(o),i=await Un({connection:this.scope.connection,owner:this.scope.ownerPubKey,payer:this.scope.ownerPubKey,amount:e,skipCloseAccount:!0});return r.addInstruction(i),r.versionBuild({txVersion:n!=null?n:1})}async swap({swapInfo:e,swapPoolKeys:t,ownerInfo:n,computeBudgetConfig:o,routeProgram:r,txVersion:i,feePayer:s}){let u=this.createTxBuilder(s),a=e.amountIn,c=e.amountOut,m=a.amount.token.mint.equals(Z),p=c.amount.token.mint.equals(Z),d=a.amount.token.mint,f=c.amount.token.mint,{account:y,instructionParams:b}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:a.amount.token.isToken2022?ts:$e,mint:d,notUseTokenAccount:m,owner:this.scope.ownerPubKey,skipCloseAccount:!m,createInfo:m?{payer:this.scope.ownerPubKey,amount:a.amount.raw}:void 0,associatedOnly:m?!1:n.associatedOnly,checkCreateATAOwner:n.checkCreateATAOwner});if(b&&u.addInstruction(b),y===void 0)throw Error("input account check error");let g;if(e.routeType==="route"&&!p)g=this.scope.account.getAssociatedTokenAccount(f,c.amount.token.isToken2022?ts:$e);else{let{account:T,instructionParams:w}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:c.amount.token.isToken2022?ts:$e,mint:f,notUseTokenAccount:p,owner:this.scope.ownerPubKey,skipCloseAccount:!0,createInfo:{payer:this.scope.ownerPubKey,amount:0},associatedOnly:p?!1:n.associatedOnly,checkCreateATAOwner:n.checkCreateATAOwner});g=T,w&&u.addInstruction(w)}p&&u.addInstruction({endInstructions:[hn({owner:this.scope.ownerPubKey,payer:this.scope.ownerPubKey,tokenAccount:g,programId:$e})],endInstructionTypes:[G.CloseAccount]});let P;if(e.routeType==="route"){let T=e.middleToken;P=this.scope.account.getAssociatedTokenAccount(T.mint,T.isToken2022?ts:$e)}let h=t||await this.computePoolToPoolKeys({pools:e.poolInfoList}),I=Vl({routeProgram:r,inputMint:d,swapInfo:q(v({},e),{poolInfo:[...e.poolInfoList],poolKey:h,outputMint:f}),ownerInfo:{wallet:this.scope.ownerPubKey,sourceToken:y,routeToken:P,destinationToken:g}});if(e.feeConfig!==void 0){let T=this.createTxBuilder();T.addInstruction({instructions:[El(y,e.feeConfig.feeAccount,this.scope.ownerPubKey,e.feeConfig.feeAmount.toNumber())],instructionTypes:[G.TransferAmount]}),T.addInstruction(I);let{transactions:w}=i===0?await T.sizeCheckBuildV0():await T.sizeCheckBuild();w.length<2&&u.addInstruction({instructions:[El(y,e.feeConfig.feeAccount,this.scope.ownerPubKey,e.feeConfig.feeAmount.toNumber())],instructionTypes:[G.TransferAmount]})}return u.addInstruction(I),i===0?u.sizeCheckBuildV0({computeBudgetConfig:o,address:I.address}):u.sizeCheckBuild({computeBudgetConfig:o,address:I.address})}async fetchRoutePoolBasicInfo(e){let{amm:t=ni,clmm:n=Fn,cpmm:o=Vn}=e||{},r=await this.scope.connection.getProgramAccounts(t,{dataSlice:{offset:mo.offsetOf("baseMint"),length:64}}),i=F([M("baseMint"),M("quoteMint")]),s=r.map(d=>({id:d.pubkey,version:4,mintA:i.decode(d.account.data).baseMint,mintB:i.decode(d.account.data).quoteMint})),u=F([M("mintA"),M("mintB")]),c=(await this.scope.connection.getProgramAccounts(n,{filters:[{dataSize:co.span}],dataSlice:{offset:co.offsetOf("mintA"),length:64}})).map(d=>{let f=u.decode(d.account.data);return{id:d.pubkey,version:6,mintA:f.mintA,mintB:f.mintB}}),p=(await this.scope.connection.getProgramAccounts(o,{dataSlice:{offset:Zr.offsetOf("mintA"),length:64}})).map(d=>{let f=u.decode(d.account.data);return{id:d.pubkey,version:7,mintA:f.mintA,mintB:f.mintB}});return{clmmPools:c,ammPools:s,cpmmPools:p}}getAllRoute({inputMint:e,outputMint:t,clmmPools:n,ammPools:o,cpmmPools:r}){e=e.toString()===Po.default.toString()?Z:e,t=t.toString()===Po.default.toString()?Z:t;let i={},s={},u={},a=[],c={};for(let p of n!=null?n:[]){if((p.mintA.equals(e)&&p.mintB.equals(t)||p.mintA.equals(t)&&p.mintB.equals(e))&&(a.push(p),s[p.id.toString()]=p),p.mintA.equals(e)){let d=p.mintB.toString();c[d]===void 0&&(c[d]={mintProgram:$e,in:[],out:[],mDecimals:0}),c[d].in.push(p)}if(p.mintB.equals(e)){let d=p.mintA.toString();c[d]===void 0&&(c[d]={mintProgram:$e,in:[],out:[],mDecimals:0}),c[d].in.push(p)}if(p.mintA.equals(t)){let d=p.mintB.toString();c[d]===void 0&&(c[d]={mintProgram:$e,in:[],out:[],mDecimals:0}),c[d].out.push(p)}if(p.mintB.equals(t)){let d=p.mintA.toString();c[d]===void 0&&(c[d]={mintProgram:$e,in:[],out:[],mDecimals:0}),c[d].out.push(p)}}let m=[];for(let p of o)(p.mintA.equals(e)&&p.mintB.equals(t)||p.mintA.equals(t)&&p.mintB.equals(e))&&(a.push(p),i[p.id.toBase58()]=p,m.push(p)),p.mintA.equals(e)&&(c[p.mintB.toBase58()]===void 0&&(c[p.mintB.toBase58()]={mintProgram:$e,in:[],out:[],mDecimals:0}),c[p.mintB.toBase58()].in.push(p)),p.mintB.equals(e)&&(c[p.mintA.toBase58()]===void 0&&(c[p.mintA.toBase58()]={mintProgram:$e,in:[],out:[],mDecimals:0}),c[p.mintA.toBase58()].in.push(p)),p.mintA.equals(t)&&(c[p.mintB.toBase58()]===void 0&&(c[p.mintB.toBase58()]={mintProgram:$e,in:[],out:[],mDecimals:0}),c[p.mintB.toBase58()].out.push(p)),p.mintB.equals(t)&&(c[p.mintA.toBase58()]===void 0&&(c[p.mintA.toBase58()]={mintProgram:$e,in:[],out:[],mDecimals:0}),c[p.mintA.toBase58()].out.push(p));for(let p of r)(p.mintA.equals(e)&&p.mintB.equals(t)||p.mintA.equals(t)&&p.mintB.equals(e))&&(a.push(p),u[p.id.toBase58()]=p),p.mintA.equals(e)&&(c[p.mintB.toBase58()]===void 0&&(c[p.mintB.toBase58()]={mintProgram:$e,in:[],out:[],mDecimals:0}),c[p.mintB.toBase58()].in.push(p)),p.mintB.equals(e)&&(c[p.mintA.toBase58()]===void 0&&(c[p.mintA.toBase58()]={mintProgram:$e,in:[],out:[],mDecimals:0}),c[p.mintA.toBase58()].in.push(p)),p.mintA.equals(t)&&(c[p.mintB.toBase58()]===void 0&&(c[p.mintB.toBase58()]={mintProgram:$e,in:[],out:[],mDecimals:0}),c[p.mintB.toBase58()].out.push(p)),p.mintB.equals(t)&&(c[p.mintA.toBase58()]===void 0&&(c[p.mintA.toBase58()]={mintProgram:$e,in:[],out:[],mDecimals:0}),c[p.mintA.toBase58()].out.push(p));for(let p of Object.keys(c)){if(c[p].in.length===1&&c[p].out.length===1&&c[p].in[0].id.equals(c[p].out[0].id)){delete c[p];continue}if(c[p].in.length===0||c[p].out.length===0){delete c[p];continue}let d=c[p];for(let f of d.in)for(let y of d.out)f.version===6&&s[f.id.toString()]===void 0?s[f.id.toString()]=f:f.version===7&&u[f.id.toString()]===void 0?u[f.id.toString()]=f:(f.version===4||f.version===5)&&i[f.id.toString()]===void 0&&(i[f.id.toString()]=f),y.version===6&&s[y.id.toString()]===void 0?s[y.id.toString()]=y:y.version===7&&u[y.id.toString()]===void 0?u[y.id.toString()]=y:(y.version===4||y.version===5)&&i[y.id.toString()]===void 0&&(i[y.id.toString()]=y)}return{directPath:a,addLiquidityPools:m,routePathDict:c,needSimulate:Object.values(i),needTickArray:Object.values(s),cpmmPoolList:Object.values(u)}}async fetchSwapRoutesData({routes:e,inputMint:t,outputMint:n}){let o=new Set([...e.needTickArray.map(y=>[y.mintA.toBase58(),y.mintB.toBase58()]).flat(),t.toString(),n.toString()]);console.log("fetching amm pools info, total: ",e.needSimulate.length);let r=await this.scope.liquidity.getRpcPoolInfos(e.needSimulate.map(y=>y.id)),i=zr(r),s={};Object.values(i).forEach(y=>{o.delete(y.mintA.address),s[y.mintA.address]={address:new Po(y.mintA.address),programId:$e,mintAuthority:null,supply:BigInt(0),decimals:y.mintA.decimals,isInitialized:!0,freezeAuthority:null,tlvData:Buffer.from("0","hex"),feeConfig:void 0},o.delete(y.mintB.address),s[y.mintB.address]={address:new Po(y.mintB.address),programId:$e,mintAuthority:null,supply:BigInt(0),decimals:y.mintB.decimals,isInitialized:!0,freezeAuthority:null,tlvData:Buffer.from("0","hex"),feeConfig:void 0}}),console.log("fetching cpmm pools info, total: ",e.cpmmPoolList.length);let u=await this.scope.cpmm.getRpcPoolInfos(e.cpmmPoolList.map(y=>y.id.toBase58()),!0);Object.values(u).forEach(y=>{let[b,g]=[y.mintA.toBase58(),y.mintB.toBase58()];y.mintProgramA.equals($e)?(o.delete(b),s[b]={address:y.mintA,programId:y.mintProgramA,mintAuthority:null,supply:BigInt(0),decimals:y.mintDecimalA,isInitialized:!0,freezeAuthority:null,tlvData:Buffer.from("0","hex"),feeConfig:void 0}):o.add(b),y.mintProgramB.equals($e)?(o.delete(g),s[g]={address:y.mintB,programId:y.mintProgramB,mintAuthority:null,supply:BigInt(0),decimals:y.mintDecimalB,isInitialized:!0,freezeAuthority:null,tlvData:Buffer.from("0","hex"),feeConfig:void 0}):o.add(g)}),console.log("fetching mints info, total: ",o.size);let a=await xo({connection:this.scope.connection,mints:Array.from(o).map(y=>new Po(y))});s=v(v({},s),a);let c=this.scope.cpmm.toComputePoolInfos({pools:u,mintInfos:s});console.log("fetching clmm pools info, total:",e.needTickArray.length);let m=await this.scope.clmm.getRpcClmmPoolInfos({poolIds:e.needTickArray.map(y=>y.id)}),{computeClmmPoolInfo:p,computePoolTickData:d}=await this.scope.clmm.getComputeClmmPoolInfos({clmmPoolsRpcInfo:m,mintInfos:s}),f=Object.keys(e.routePathDict).reduce((y,b)=>q(v({},y),{[b]:q(v({},e.routePathDict[b]),{mintProgram:s[b].programId,mDecimals:s[b].decimals,in:e.routePathDict[b].in.map(g=>i[g.id.toBase58()]||p[g.id.toBase58()]||c[g.id.toBase58()]),out:e.routePathDict[b].out.map(g=>i[g.id.toBase58()]||p[g.id.toBase58()]||c[g.id.toBase58()])})}),{});return{mintInfos:s,ammPoolsRpcInfo:r,ammSimulateCache:i,clmmPoolsRpcInfo:m,computeClmmPoolInfo:p,computePoolTickData:d,computeCpmmData:c,routePathDict:f}}getAllRouteComputeAmountOut({inputTokenAmount:e,outputToken:t,directPath:n,routePathDict:o,simulateCache:r,tickCache:i,slippage:s,chainTime:u,epochInfo:a,feeConfig:c}){var g,P,h,I,T,w,K,x,S;let m=c===void 0?new ns(0):e.raw.mul(new ns(c.feeBps.toNumber())).div(new ns(1e4)),p=e.raw.sub(m),d=new Se(e.token,p),f=c===void 0?void 0:{feeAmount:m,feeAccount:c.feeAccount},y=q(v({},t),{address:ft(t.address).toString()}),b=[];for(let B of n)try{b.push(q(v({},this.computeAmountOut({itemPool:B,tickCache:i,simulateCache:r,chainTime:u,epochInfo:a,slippage:s,outputToken:y,amountIn:d})),{feeConfig:f}))}catch(R){this.logDebug("direct error",B.version,B.id.toString(),R.message)}this.logDebug("direct done");for(let[B,R]of Object.entries(o)){let C={chainId:101,address:B,programId:R.mintProgram.toBase58(),logoURI:"",symbol:"",name:"",decimals:R.mDecimals,tags:[],extensions:{}},N=R.in.map(O=>{try{return{pool:O,data:this.computeAmountOut({itemPool:O,tickCache:i,simulateCache:r,chainTime:u,epochInfo:a,slippage:s,outputToken:C,amountIn:d})}}catch(E){this.logDebug("route in error",O.version,O.id.toString(),E.message);return}}).sort((O,E)=>{var j,de,re,ce;let X=O===void 0?On:O.data.amountOut.amount.raw.sub((de=(j=O.data.amountOut.fee)==null?void 0:j.raw)!=null?de:On),Y=E===void 0?On:E.data.amountOut.amount.raw.sub((ce=(re=E.data.amountOut.fee)==null?void 0:re.raw)!=null?ce:On);return X.lt(Y)?1:-1})[0];if(N===void 0)continue;let L=new Se(Dr(C),N.data.amountOut.amount.raw.sub((P=(g=N.data.amountOut.fee)==null?void 0:g.raw)!=null?P:On));for(let O of R.out)try{let E=this.computeAmountOut({itemPool:O,tickCache:i,simulateCache:r,chainTime:u,epochInfo:a,slippage:s,outputToken:y,amountIn:L});b.push(q(v({},E),{allTrade:!!(N.data.allTrade&&E.allTrade),amountIn:N.data.amountIn,amountOut:E.amountOut,minAmountOut:E.minAmountOut,currentPrice:void 0,executionPrice:new Yi(new Kt({baseToken:N.data.amountIn.amount.token,denominator:N.data.amountIn.amount.raw,quoteToken:E.amountOut.amount.token,numerator:E.amountOut.amount.raw.sub((I=(h=E.amountOut.fee)==null?void 0:h.raw)!=null?I:On)}).toFixed()),priceImpact:new Yi(N.data.priceImpact.add(E.priceImpact).toFixed()),fee:[N.data.fee[0],E.fee[0]],routeType:"route",poolInfoList:[N.pool,O],remainingAccounts:[N.data.remainingAccounts[0],E.remainingAccounts[0]],minMiddleAmountFee:(T=E.amountOut.fee)!=null&&T.raw?new Se(N.data.amountOut.amount.token,((K=(w=N.data.amountOut.fee)==null?void 0:w.raw)!=null?K:On).add((S=(x=E.amountOut.fee)==null?void 0:x.raw)!=null?S:On)):void 0,middleToken:N.data.amountOut.amount.token,poolReady:N.data.poolReady&&E.poolReady,poolType:[N.data.poolType,E.poolType],feeConfig:f,expirationTime:tn(N.data.expirationTime,E.expirationTime)}))}catch(E){this.logDebug("route out error",O.version,O.id.toString(),E.message)}}return b.filter(B=>(B.allTrade||this.logDebug(`pool ${B.poolInfoList.map(R=>R.id.toString()).join(",")} filter out since not all trade`),B.allTrade)).sort((B,R)=>B.amountOut.amount.raw.sub(R.amountOut.amount.raw).gt(On)?-1:1)}computeAmountOut({itemPool:e,tickCache:t,simulateCache:n,chainTime:o,epochInfo:r,slippage:i,outputToken:s,amountIn:u}){if(e.version===6){let{allTrade:a,realAmountIn:c,amountOut:m,minAmountOut:p,expirationTime:d,currentPrice:f,executionPrice:y,priceImpact:b,fee:g,remainingAccounts:P,executionPriceX64:h}=ve.computeAmountOutFormat({poolInfo:e,tickArrayCache:t[e.id.toString()],amountIn:u.raw,tokenOut:s,slippage:i,epochInfo:r,catchLiquidityInsufficient:!0});return{allTrade:a,amountIn:c,amountOut:m,minAmountOut:p,currentPrice:new Yi(f.toFixed()),executionPrice:new Yi(y.toFixed()),priceImpact:new Yi(b.toFixed()),fee:[g],remainingAccounts:[P],routeType:"amm",poolInfoList:[e],poolReady:e.startTime<o,poolType:"CLMM",slippage:i,clmmExPriceX64:[h],expirationTime:tn(c.expirationTime,d)}}else if(e.version===7){let{allTrade:a,executionPrice:c,amountOut:m,minAmountOut:p,priceImpact:d,fee:f}=this.scope.cpmm.computeSwapAmount({pool:e,outputMint:s.address,amountIn:u.raw,slippage:i});return{allTrade:a,amountIn:{amount:u,fee:void 0,expirationTime:void 0},amountOut:{amount:Ri(q(v({},s),{amount:m})),fee:void 0,expirationTime:void 0},minAmountOut:{amount:Ri(q(v({},s),{amount:p})),fee:void 0,expirationTime:void 0},currentPrice:e.poolPrice,executionPrice:c,priceImpact:d,fee:[new Se(u.token,f)],remainingAccounts:[],routeType:"amm",poolInfoList:[e],poolReady:e.openTime.toNumber()<o,poolType:"CPMM",slippage:i,clmmExPriceX64:[void 0],expirationTime:void 0}}else{if(![1,6,7].includes(n[e.id.toString()].status))throw Error("swap error");let{amountOut:a,minAmountOut:c,currentPrice:m,executionPrice:p,priceImpact:d,fee:f}=this.scope.liquidity.computeAmountOut({poolInfo:n[e.id.toString()],amountIn:u.raw,mintIn:u.token.mint,mintOut:s.address,slippage:i});return{amountIn:{amount:u,fee:void 0,expirationTime:void 0},amountOut:{amount:Ri(q(v({},s),{amount:a})),fee:void 0,expirationTime:void 0},minAmountOut:{amount:Ri(q(v({},s),{amount:c})),fee:void 0,expirationTime:void 0},currentPrice:m,executionPrice:p,priceImpact:d,fee:[new Se(u.token,f)],routeType:"amm",poolInfoList:[e],remainingAccounts:[],poolReady:Number(n[e.id].openTime)<o,poolType:e.version===5?"STABLE":void 0,expirationTime:void 0,allTrade:!0,slippage:i,clmmExPriceX64:[void 0]}}}async computePoolToPoolKeys({pools:e,clmmRpcData:t={},ammRpcData:n={}}){let o=new Set(e.filter(a=>a.version===6&&!t[a.id.toString()]).map(a=>a.id.toString()));if(o.size>0){let a=await this.scope.clmm.getRpcClmmPoolInfos({poolIds:Array.from(o)});Object.keys(a).forEach(c=>{t[c]=a[c]})}let r=new Set(e.filter(a=>a.version===4&&!n[a.id.toString()]).map(a=>a.id.toString()));if(r.size>0){let a=await this.scope.liquidity.getRpcPoolInfos(Array.from(r));Object.keys(a).forEach(c=>{n[c]=a[c]})}let i=new Set(e.filter(a=>a.version===4).map(a=>a.marketId)),s={};i.size>0&&(await Le(this.scope.connection,Array.from(i).map(c=>({pubkey:new Po(c)})))).forEach(c=>{if(!c.accountInfo)return;let m=Qa.decode(c.accountInfo.data);s[c.pubkey.toBase58()]={marketId:c.pubkey.toString(),marketProgramId:c.accountInfo.owner.toString(),marketAuthority:es.getAssociatedAuthority({programId:c.accountInfo.owner,marketId:c.pubkey}).publicKey.toString(),marketBaseVault:m.baseVault.toString(),marketQuoteVault:m.quoteVault.toString(),marketBids:m.bids.toString(),marketAsks:m.asks.toString(),marketEventQueue:m.eventQueue.toString()}});let u=[];return e.forEach(a=>{if(a.version===6){let c=t[a.id.toString()],m={programId:a.programId.toBase58(),id:a.id.toBase58(),mintA:a.mintA,mintB:a.mintB,openTime:String(a.startTime),vault:{A:c.vaultA.toBase58(),B:c.vaultB.toBase58()},config:q(v({},a.ammConfig),{id:a.ammConfig.id.toString(),defaultRange:0,defaultRangePoint:[]}),rewardInfos:[],observationId:a.observationId.toBase58(),exBitmapAccount:a.exBitmapAccount.toBase58()};u.push(m)}else if(a.version===4){let c=n[a.id.toString()],m=v({programId:a.programId,id:a.id,mintA:a.mintA,mintB:a.mintB,openTime:String(a.openTime),vault:{A:c.baseVault.toBase58(),B:c.quoteVault.toBase58()},authority:Va({programId:new Po(a.programId)}).publicKey.toString(),openOrders:c.openOrders.toBase58(),targetOrders:c.targetOrders.toBase58(),mintLp:a.lpMint},s[a.marketId]);u.push(m)}else a.version===7&&u.push({observationId:a.observationId.toBase58(),programId:a.programId.toBase58(),id:a.id.toBase58(),mintA:a.mintA,mintB:a.mintB,openTime:String(a.openTime),authority:qo(a.programId).publicKey.toBase58(),vault:{A:a.vaultA.toBase58(),B:a.vaultB.toBase58()},mintLp:gt({address:a.mintLp.toBase58(),programId:$e.toBase58(),decimals:a.lpDecimals}),config:q(v({id:a.configId.toBase58()},a.configInfo),{protocolFeeRate:a.configInfo.protocolFeeRate.toNumber(),tradeFeeRate:a.configInfo.tradeFeeRate.toNumber(),fundFeeRate:a.configInfo.fundFeeRate.toNumber(),createPoolFee:a.configInfo.createPoolFee.toString()})})}),u}};import{PublicKey as mf,Transaction as Za,TransactionInstruction as df}from"@solana/web3.js";import{TOKEN_PROGRAM_ID as pf}from"@solana/spl-token";import Wl from"bn.js";var Pt=class extends We{static getPdaPoolId(e,t){return oe([Pt.SEED_CONFIG.pool.id,t.toBuffer()],e)}static getPdaOwnerId(e,t,n,o){return oe([Pt.SEED_CONFIG.owner.id,t.toBuffer(),n.toBuffer(),Buffer.from(new Wl(o).toArray())],e)}static async getAllInfo({connection:e,programId:t,poolIds:n,wallet:o,chainTime:r}){if(n.length===0)return[];let i=n.map(c=>Pt.getPdaPoolId(t,c).publicKey),s=[];for(let c=0;c<Pt.VERSION_PROJECT.length;c++)s.push(...i.map(m=>Pt.getPdaOwnerId(t,m,o,c).publicKey));let u=await en(e,[...i,...s]),a=[];for(let c=0;c<u.length;c++){let m=Math.floor(c/n.length),p=c%n.length,d=i[p],f=s[c],y=u[p],b=u[n.length+c];if(!(y&&b)||y.data.length!==Pt.POOL_LAYOUT.span||b.data.length!==Pt.OWNER_LAYOUT.span)continue;let g=Pt.POOL_LAYOUT.decode(y.data),P=Pt.OWNER_LAYOUT.decode(b.data),h=g.openTime.toNumber(),I=g.endTime.toNumber(),T=P.tokenInfo.map(x=>x.debtAmount.gt(new Wl(0))).filter(x=>!x).length!==3,w=r>h&&r<I&&g.status===1,K=T&&w;a.push({programId:t,poolId:d,ammId:g.ammId,ownerAccountId:f,snapshotLpAmount:P.lpAmount,project:Pt.VERSION_PROJECT[m],openTime:h,endTime:I,canClaim:K,canClaimErrorType:T?w?void 0:"outOfOperationalTime":"alreadyClaimIt",tokenInfo:g.tokenInfo.map((x,S)=>({mintAddress:x.mintAddress,mintVault:x.mintVault,mintDecimals:x.mintDecimals,perLpLoss:x.perLpLoss,debtAmount:P.tokenInfo[S].debtAmount.add(P.tokenInfo[S].claimedAmount)}))})}return a}async makeClaimTransaction({poolInfo:e,ownerInfo:t,feePayer:n}){t.wallet||this.scope.checkOwner();let o=this.createTxBuilder(n),r=t.wallet||this.scope.ownerPubKey,i=[];for(let a of e.tokenInfo){let{account:c,instructionParams:m}=await this.scope.account.getOrCreateTokenAccount({mint:a.mintAddress,owner:this.scope.ownerPubKey,notUseTokenAccount:a.mintAddress.equals(Xe.WSOL.mint),createInfo:{payer:r,amount:0},skipCloseAccount:!a.mintAddress.equals(Xe.WSOL.mint),associatedOnly:a.mintAddress.equals(Xe.WSOL.mint)?!1:t.associatedOnly});m&&o.addInstruction(m),i.push(c)}o.addInstruction({instructions:[Pt.makeClaimInstruction({programId:e.programId,poolInfo:e,ownerInfo:{wallet:r,ownerPda:e.ownerAccountId,claimAddress:i}})]});let{transaction:s,signers:u}=o.build();return[{transaction:s,signer:u}]}async makeClaimAllTransaction({poolInfos:e,ownerInfo:t,feePayer:n}){let o=this.createTxBuilder(n),r=t.wallet||this.scope.ownerPubKey,i={};for(let c of e){let m=[];for(let p of c.tokenInfo){let{account:d,instructionParams:f}=await this.scope.account.getOrCreateTokenAccount({mint:p.mintAddress,owner:this.scope.ownerPubKey,notUseTokenAccount:p.mintAddress.equals(Xe.WSOL.mint),createInfo:{payer:r,amount:0},skipCloseAccount:!p.mintAddress.equals(Xe.WSOL.mint),associatedOnly:p.mintAddress.equals(Xe.WSOL.mint)?!1:t.associatedOnly});f&&o.addInstruction(f),d&&(i[p.mintAddress.toString()]=d,m.push(d))}o.addInstruction({instructions:[Pt.makeClaimInstruction({programId:c.programId,poolInfo:c,ownerInfo:{wallet:r,ownerPda:c.ownerAccountId,claimAddress:m}})]})}let{transaction:s,signers:u}=o.build(),a=o.allInstructions;return Pr(a,[r,...u.map(c=>c.publicKey)])?[{transaction:s,signer:u}]:[{transaction:new Za().add(...a.slice(0,o.AllTxData.instructions.length-1)),signer:u},{transaction:new Za().add(...a.slice(o.AllTxData.instructions.length-1)),signer:[]},{transaction:new Za().add(...o.AllTxData.endInstructions),signer:[]}]}static makeClaimInstruction({programId:e,poolInfo:t,ownerInfo:n}){let o=F([]),r=[{pubkey:n.wallet,isSigner:!0,isWritable:!0},{pubkey:t.poolId,isSigner:!1,isWritable:!0},{pubkey:n.ownerPda,isSigner:!1,isWritable:!0},...n.claimAddress.map(u=>({pubkey:u,isSigner:!1,isWritable:!0})),...t.tokenInfo.map(({mintVault:u})=>({pubkey:u,isSigner:!1,isWritable:!0})),{pubkey:pf,isSigner:!1,isWritable:!1}],i=Buffer.alloc(o.span);o.encode({},i);let s=Buffer.from([10,66,208,184,161,6,191,98,...i]);return new df({keys:r,programId:e,data:s})}},Ht=Pt;Ht.CLAIMED_NUM=3,Ht.POOL_LAYOUT=F([Te(8),V("bump"),V("status"),A("openTime"),A("endTime"),M("ammId"),Q(F([V("mintDecimals"),M("mintAddress"),M("mintVault"),A("perLpLoss"),A("totalClaimedAmount")]),Pt.CLAIMED_NUM,"tokenInfo"),Q(A(),10,"padding")]),Ht.OWNER_LAYOUT=F([Te(8),V("bump"),V("version"),M("poolId"),M("owner"),A("lpAmount"),Q(F([M("mintAddress"),A("debtAmount"),A("claimedAmount")]),Pt.CLAIMED_NUM,"tokenInfo"),Q(A(),4,"padding")]),Ht.DEFAULT_POOL_ID=["58oQChx4yWmvKdwLLZzBi4ChoCc2fqCUWBkwMihLYQo2","6UmmUiYoBjSrhakAobJw8BvkmJtDVxaeBtbt7rxWo1mg","AVs9TA4nWDzfPJE9gGVNJMVhcQy3V9PGazuz33BfG2RA","DVa7Qmb5ct9RCpaU7UTpSaf3GVMYz17vNVU67XpdCRut","7XawhbbxtsRcQA8KTkHT9f9nc6d69UwqCDh6U5EEbEmX","6a1CsrpeZubDjEJE9s1CMVheB6HWM5d7m1cj2jkhyXhj","EoNrn8iUhwgJySD1pHu8Qxm5gSQqLK3za4m8xzD2RuEb","AceAyRTWt4PyB2pHqf2qhDgNZDtKVNaxgL8Ru3V4aN1P","6tmFJbMk5yVHFcFy7X2K8RwHjKLr6KVFLYXpgpBNeAxB"].map(e=>new mf(e)),Ht.SEED_CONFIG={pool:{id:Buffer.from("pool_seed","utf8")},owner:{id:Buffer.from("user_claim_seed","utf8")}},Ht.VERSION_PROJECT=[void 0,"Francium","Tulip","Larix"];import{PublicKey as ji}from"@solana/web3.js";import Dl from"bn.js";import{SYSVAR_CLOCK_PUBKEY as ff,TransactionInstruction as eu}from"@solana/web3.js";import{TOKEN_PROGRAM_ID as tu}from"@solana/spl-token";var Ja=F([V("instruction"),ic("amount")]),Hi=F([V("instruction")]);function rC({programId:l,amount:e,instructionKeys:t}){let n=[{pubkey:pr,isSigner:!1,isWritable:!1},{pubkey:tu,isSigner:!1,isWritable:!1},{pubkey:Ze,isSigner:!1,isWritable:!1},{pubkey:Ts,isSigner:!1,isWritable:!1},...Object.entries(t).map(([r,i])=>({pubkey:i,isSigner:r==="userOwner",isWritable:!["authority","userOwner","userIdoCheck","userStakeInfo"].includes(r)}))],o=Buffer.alloc(Ja.span);return Ja.encode({instruction:1,amount:Number(e)},o),new eu({keys:n,programId:l,data:o})}function os({programId:l},e){let t=[{pubkey:tu,isSigner:!1,isWritable:!1},{pubkey:Ts,isSigner:!1,isWritable:!1},...Object.entries(e).map(([o,r])=>({pubkey:r,isSigner:o==="userOwner",isWritable:!["authority","userOwner"].includes(o)}))],n=Buffer.alloc(Hi.span);return Hi.encode({instruction:2},n),new eu({keys:t,programId:l,data:n})}function nu(l){let{poolConfig:e,userKeys:t,side:n}=l,o=n==="base"?t.baseTokenAccount:t.quoteTokenAccount,r=n==="base"?e.baseVault:e.quoteVault,i=Buffer.alloc(Hi.span);Hi.encode({instruction:2},i);let s=[{pubkey:tu,isWritable:!1,isSigner:!1},{pubkey:ff,isWritable:!1,isSigner:!1},{pubkey:e.id,isWritable:!0,isSigner:!1},{pubkey:e.authority,isWritable:!1,isSigner:!1},{pubkey:r,isWritable:!0,isSigner:!1},{pubkey:o,isWritable:!0,isSigner:!1},{pubkey:t.ledgerAccount,isWritable:!0,isSigner:!1},{pubkey:t.owner,isWritable:!1,isSigner:!0}];return new eu({programId:e.programId,keys:s,data:i})}var yf={[si.IDO_PROGRAM_ID_V1.toString()]:1,[si.IDO_PROGRAM_ID_V2.toString()]:2,[si.IDO_PROGRAM_ID_V3.toString()]:3,[si.IDO_PROGRAM_ID_V4.toString()]:4},Xo=class extends We{async claim({ownerInfo:e,idoKeys:t,associatedOnly:n=!0,checkCreateATAOwner:o=!1,txVersion:r,feePayer:i}){let s=this.createTxBuilder(i),u=yf[t.programId];u||this.logAndCreateError("invalid version",u);let a=Ee(t),[c,m]=[!new Dl(e.coin).isZero(),!new Dl(e.pc).isZero()],p=a.projectInfo.mint.address.equals(Z),{account:d,instructionParams:f}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:a.projectInfo.mint.programId,mint:a.projectInfo.mint.address,owner:this.scope.ownerPubKey,createInfo:{payer:this.scope.ownerPubKey,amount:0},skipCloseAccount:!p,notUseTokenAccount:p,associatedOnly:p?!1:n,checkCreateATAOwner:o});!d&&c&&this.logAndCreateError("target token accounts not found","mint",t.projectInfo.mint.address),c&&f&&s.addInstruction(f);let y=a.buyInfo.mint.address.equals(Z),{account:b,instructionParams:g}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:a.buyInfo.mint.programId,mint:a.buyInfo.mint.address,owner:this.scope.ownerPubKey,createInfo:{payer:this.scope.ownerPubKey,amount:0},skipCloseAccount:!y,notUseTokenAccount:y,associatedOnly:y?!1:n,checkCreateATAOwner:o});if(!d&&m&&this.logAndCreateError("target token accounts not found","mint",t.projectInfo.mint.address),m&&g&&s.addInstruction(g),(!d||!b)&&this.logAndCreateError("target token accounts not found","mint",t.projectInfo.mint.address,t.buyInfo.mint.address),u===3)return s.addInstruction({instructions:[...c?[os({programId:a.programId},{idoId:a.id,authority:a.authority,poolTokenAccount:a.projectInfo.vault,userTokenAccount:d,userIdoInfo:new ji(e.userIdoInfo),userOwner:this.scope.ownerPubKey})]:[],...m?[os({programId:new ji(t.programId)},{idoId:a.id,authority:a.authority,poolTokenAccount:a.buyInfo.vault,userTokenAccount:b,userIdoInfo:new ji(e.userIdoInfo),userOwner:this.scope.ownerPubKey})]:[]]}).versionBuild({txVersion:r});if(u<3)return!c&&!m&&this.logAndCreateError("no claimable rewards"),s.addInstruction({instructions:[os({programId:a.programId},{idoId:a.id,authority:a.authority,poolQuoteTokenAccount:a.buyInfo.vault,poolBaseTokenAccount:a.projectInfo.vault,userQuoteTokenAccount:b,userBaseTokenAccount:d,userIdoInfo:new ji(e.userIdoInfo),userOwner:this.scope.ownerPubKey})]}).versionBuild({txVersion:r});let P={poolConfig:{id:a.id,programId:a.programId,authority:a.authority,baseVault:a.projectInfo.vault,quoteVault:a.buyInfo.vault,baseToken:t.projectInfo.mint,quoteToken:t.buyInfo.mint},userKeys:{baseTokenAccount:d,quoteTokenAccount:b,ledgerAccount:new ji(e.userIdoInfo),owner:this.scope.ownerPubKey}};return s.addInstruction({instructions:[...c?[nu(q(v({},P),{side:"base"}))]:[],...m?[nu(q(v({},P),{side:"quote"}))]:[]]}).versionBuild({txVersion:r})}};var ql=(t=>(t[t.OnlyTokenB=0]="OnlyTokenB",t[t.BothToken=1]="BothToken",t))(ql||{});var bf=Buffer.from("vault_auth_seed","utf8"),gf=Buffer.from("global_config","utf8"),Pf=Buffer.from("pool_vesting","utf8"),Af=Buffer.from("platform_config","utf8"),kf=Buffer.from("platform_fee_vault_auth_seed","utf8"),wf=Buffer.from("creator_fee_vault_auth_seed","utf8");function sn(l){return oe([bf],l)}function BC(l,e,t,n){return oe([gf,e.toBuffer(),Tf(t),Vr(n)],l)}function Ao(l,e,t){return oe([ga,e.toBuffer(),t.toBuffer()],l)}function ou(l,e,t){return oe([Pa,e.toBuffer(),t.toBuffer()],l)}function jn(l){return oe([Buffer.from("__event_authority","utf8")],l)}function Tf(l){let e=new ArrayBuffer(1);return new DataView(e).setUint8(0,l),new Uint8Array(e)}function iu(l,e){return oe([Af,e.toBuffer()],l)}function $i(l,e,t){return oe([Pf,e.toBuffer(),t.toBuffer()],l)}function $n(l,e,t){return oe([e.toBuffer(),t.toBuffer()],l)}function ru(l){return oe([kf],l)}function Zn(l,e,t){return oe([e.toBuffer(),t.toBuffer()],l)}function su(l){return oe([wf],l)}import{ASSOCIATED_TOKEN_PROGRAM_ID as is,TOKEN_2022_PROGRAM_ID as Bf,TOKEN_PROGRAM_ID as Zi}from"@solana/spl-token";import{SystemProgram as Nt,TransactionInstruction as At}from"@solana/web3.js";import Mn from"bn.js";var Nn=F([A(),A("epoch"),V("curveType"),_t("index"),A("migrateFee"),A("tradeFeeRate"),A("maxShareFeeRate"),A("minSupplyA"),A("maxLockRate"),A("minSellRateA"),A("minMigrateRateA"),A("minFundRaisingB"),M("mintB"),M("protocolFeeOwner"),M("migrateFeeOwner"),M("migrateToAmmWallet"),M("migrateToCpmmWallet"),Q(A(),16)]),hf=F([A("totalLockedAmount"),A("cliffPeriod"),A("unlockPeriod"),A("startTime"),A("totalAllocatedShare")]),jt=F([A(),A("epoch"),V("bump"),V("status"),V("mintDecimalsA"),V("mintDecimalsB"),V("migrateType"),A("supply"),A("totalSellA"),A("virtualA"),A("virtualB"),A("realA"),A("realB"),A("totalFundRaisingB"),A("protocolFee"),A("platformFee"),A("migrateFee"),hf.replicate("vestingSchedule"),M("configId"),M("platformId"),M("mintA"),M("mintB"),M("vaultA"),M("vaultB"),M("creator"),V("mintProgramFlag"),V("cpmmCreatorFeeOn"),Q(V(),62)]),SC=F([A(),A("epoch"),M("poolId"),M("beneficiary"),A("claimedAmount"),A("tokenShareAmount"),Q(A(),8)]),au=F([V("migrateType"),V("migrateCpmmFeeOn"),A("supply"),A("totalSellA"),A("totalFundRaisingB"),A("totalLockedAmount"),A("cliffPeriod"),A("unlockPeriod")]),If=F([A("epoch"),V("index"),M("configId"),au.replicate("bondingCurveParam"),Q(A(),50)]),ko=F([A(),A("epoch"),M("platformClaimFeeWallet"),M("platformLockNftWallet"),A("platformScale"),A("creatorScale"),A("burnScale"),A("feeRate"),Q(V(),64,"name"),Q(V(),256,"web"),Q(V(),256,"img"),M("cpConfigId"),A("creatorFeeRate"),M("transferFeeExtensionAuth"),Q(V(),180),lc(If,"platformCurve")]);var kt={initialize:Buffer.from([175,175,109,31,13,152,155,237]),initializeV2:Buffer.from([67,153,175,39,218,16,38,32]),buyExactIn:Buffer.from([250,234,13,123,213,156,19,236]),buyExactOut:Buffer.from([24,211,116,40,105,3,153,56]),sellExactIn:Buffer.from([149,39,222,155,211,124,152,26]),sellExactOut:Buffer.from([95,200,71,34,8,9,11,166]),createVestingAccount:Buffer.from([129,178,2,13,217,172,230,218]),claimVestedToken:Buffer.from([49,33,104,30,189,157,79,35]),createPlatformConfig:Buffer.from([176,90,196,175,253,113,220,20]),claimPlatformFee:Buffer.from([156,39,208,135,76,237,61,72]),updatePlaformConfig:Buffer.from([195,60,76,129,146,45,67,143]),initializeWithToken2022:Buffer.from([37,190,126,222,44,154,171,17]),claimPlatformFeeFromVault:Buffer.from([117,241,198,168,248,218,80,29]),claimCreatorFee:Buffer.from([26,97,138,203,132,171,141,252]),updatePlatformCurveParam:Buffer.from([138,144,138,250,220,128,4,57]),removePlatformCurveParam:Buffer.from([27,30,62,169,93,224,24,145])};function WC(l,e,t,n,o,r,i,s,u,a,c,m,p,d,f,y,b,g,P,h){throw new Error("*** launchlab initialize has been deprecated, please use initializeV2 instead! ***")}function Gl(l,e,t,n,o,r,i,s,u,a,c,m,p,d,f,y,b,g,P,h,I){let T=F([V("decimals"),lt("name"),lt("symbol"),lt("uri")]),w=F([A("totalLockedAmount"),A("cliffPeriod"),A("unlockPeriod"),V("cpmmCreatorFeeOn")]),K=F([V("index"),A("supply"),A("totalFundRaisingB"),V("migrateType")]),x=F([V("index"),A("supply"),A("totalSellA"),A("totalFundRaisingB"),V("migrateType")]),S=[{pubkey:e,isSigner:!0,isWritable:!0},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!1,isWritable:!1},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!0,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!1},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:m,isSigner:!1,isWritable:!0},{pubkey:Zi,isSigner:!1,isWritable:!1},{pubkey:Zi,isSigner:!1,isWritable:!1},{pubkey:Ut,isSigner:!1,isWritable:!1},{pubkey:Nt.programId,isSigner:!1,isWritable:!1},{pubkey:Ze,isSigner:!1,isWritable:!1},{pubkey:jn(l).publicKey,isSigner:!1,isWritable:!1},{pubkey:l,isSigner:!1,isWritable:!1}],B=Buffer.alloc(Buffer.from(d,"utf-8").length+Buffer.from(f,"utf-8").length+Buffer.from(y,"utf-8").length+4*3+1),R=Buffer.alloc(w.span),C=Buffer.alloc(b.type==="ConstantCurve"?x.span:K.span);return T.encode({decimals:p,name:d,symbol:f,uri:y},B),b.type==="ConstantCurve"?x.encode(q(v({index:0},b),{migrateType:b.migrateType==="amm"?0:1}),C):b.type==="FixedCurve"?K.encode(q(v({index:1},b),{migrateType:b.migrateType==="amm"?0:1}),C):b.type==="LinearCurve"&&K.encode(q(v({index:2},b),{migrateType:b.migrateType==="amm"?0:1}),C),w.encode({totalLockedAmount:g,cliffPeriod:P,unlockPeriod:h,cpmmCreatorFeeOn:I},R),new At({keys:S,programId:l,data:Buffer.from([...kt.initializeV2,...B,...C,...R])})}function Xl(l,e,t,n,o,r,i,s,u,a,c,m,p,d,f,y,b,g,P,h,I){let T=F([V("decimals"),lt("name"),lt("symbol"),lt("uri")]),w=F([A("totalLockedAmount"),A("cliffPeriod"),A("unlockPeriod"),V("cpmmCreatorFeeOn"),V("transferFeeExtensionParamsOption"),F([_t("transferFeeBasePoints"),A("maxinumFee")]).replicate("transferFeeExtensionParams")]),K=F([V("index"),A("supply"),A("totalFundRaisingB"),V("migrateType")]),x=F([V("index"),A("supply"),A("totalSellA"),A("totalFundRaisingB"),V("migrateType")]),S=[{pubkey:e,isSigner:!0,isWritable:!0},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!1,isWritable:!1},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!0,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!1},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:Bf,isSigner:!1,isWritable:!1},{pubkey:Zi,isSigner:!1,isWritable:!1},{pubkey:Nt.programId,isSigner:!1,isWritable:!1},{pubkey:jn(l).publicKey,isSigner:!1,isWritable:!1},{pubkey:l,isSigner:!1,isWritable:!1}],B=Buffer.alloc(Buffer.from(p,"utf-8").length+Buffer.from(d,"utf-8").length+Buffer.from(f,"utf-8").length+4*3+1),R=Buffer.alloc(w.span),C=Buffer.alloc(y.type==="ConstantCurve"?x.span:K.span);return T.encode({decimals:m,name:p,symbol:d,uri:f},B),y.type==="ConstantCurve"?x.encode(q(v({index:0},y),{migrateType:y.migrateType==="amm"?0:1}),C):y.type==="FixedCurve"?K.encode(q(v({index:1},y),{migrateType:y.migrateType==="amm"?0:1}),C):y.type==="LinearCurve"&&K.encode(q(v({index:2},y),{migrateType:y.migrateType==="amm"?0:1}),C),w.encode({totalLockedAmount:b,cliffPeriod:g,unlockPeriod:P,cpmmCreatorFeeOn:h,transferFeeExtensionParamsOption:I?1:0,transferFeeExtensionParams:I!=null?I:{transferFeeBasePoints:0,maxinumFee:new Mn(0)}},R),new At({keys:S,programId:l,data:Buffer.from([...kt.initializeWithToken2022,...B,...C,...R])})}function cu(l,e,t,n,o,r,i,s,u,a,c,m,p,d,f,y,b,g,P,h){let I=F([A("amountB"),A("minAmountA"),A("shareFeeRate")]),T=[{pubkey:e,isSigner:!0,isWritable:!0},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!1},{pubkey:m,isSigner:!1,isWritable:!1},{pubkey:p,isSigner:!1,isWritable:!1},{pubkey:d,isSigner:!1,isWritable:!1},{pubkey:jn(l).publicKey,isSigner:!1,isWritable:!1},{pubkey:l,isSigner:!1,isWritable:!1}];h&&T.push({pubkey:h,isSigner:!1,isWritable:!0}),T.push({pubkey:Nt.programId,isSigner:!1,isWritable:!1}),T.push({pubkey:f,isSigner:!1,isWritable:!0}),T.push({pubkey:y,isSigner:!1,isWritable:!0});let w=Buffer.alloc(I.span);return I.encode({amountB:b,minAmountA:g,shareFeeRate:P!=null?P:new Mn(0)},w),new At({keys:T,programId:l,data:Buffer.from([...kt.buyExactIn,...w])})}function zl(l,e,t,n,o,r,i,s,u,a,c,m,p,d,f,y,b,g,P,h){let I=F([A("amountA"),A("maxAmountB"),A("shareFeeRate")]),T=[{pubkey:e,isSigner:!0,isWritable:!0},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!1},{pubkey:m,isSigner:!1,isWritable:!1},{pubkey:p,isSigner:!1,isWritable:!1},{pubkey:d,isSigner:!1,isWritable:!1},{pubkey:jn(l).publicKey,isSigner:!1,isWritable:!1},{pubkey:l,isSigner:!1,isWritable:!1}];h&&T.push({pubkey:h,isSigner:!1,isWritable:!0}),T.push({pubkey:Nt.programId,isSigner:!1,isWritable:!1}),T.push({pubkey:f,isSigner:!1,isWritable:!0}),T.push({pubkey:y,isSigner:!1,isWritable:!0});let w=Buffer.alloc(I.span);return I.encode({amountA:b,maxAmountB:g,shareFeeRate:P!=null?P:new Mn(0)},w),new At({keys:T,programId:l,data:Buffer.from([...kt.buyExactOut,...w])})}function Yl(l,e,t,n,o,r,i,s,u,a,c,m,p,d,f,y,b,g,P,h){let I=F([A("amountA"),A("minAmountB"),A("shareFeeRate")]),T=[{pubkey:e,isSigner:!0,isWritable:!0},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!1},{pubkey:m,isSigner:!1,isWritable:!1},{pubkey:p,isSigner:!1,isWritable:!1},{pubkey:d,isSigner:!1,isWritable:!1},{pubkey:jn(l).publicKey,isSigner:!1,isWritable:!1},{pubkey:l,isSigner:!1,isWritable:!1}];h&&T.push({pubkey:h,isSigner:!1,isWritable:!0}),T.push({pubkey:Nt.programId,isSigner:!1,isWritable:!1}),T.push({pubkey:f,isSigner:!1,isWritable:!0}),T.push({pubkey:y,isSigner:!1,isWritable:!0});let w=Buffer.alloc(I.span);return I.encode({amountA:b,minAmountB:g,shareFeeRate:P!=null?P:new Mn(0)},w),new At({keys:T,programId:l,data:Buffer.from([...kt.sellExactIn,...w])})}function Ql(l,e,t,n,o,r,i,s,u,a,c,m,p,d,f,y,b,g,P,h){let I=F([A("amountB"),A("maxAmountA"),A("shareFeeRate")]),T=[{pubkey:e,isSigner:!0,isWritable:!0},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!1},{pubkey:m,isSigner:!1,isWritable:!1},{pubkey:p,isSigner:!1,isWritable:!1},{pubkey:d,isSigner:!1,isWritable:!1},{pubkey:jn(l).publicKey,isSigner:!1,isWritable:!1},{pubkey:l,isSigner:!1,isWritable:!1}];h&&T.push({pubkey:h,isSigner:!1,isWritable:!0}),T.push({pubkey:Nt.programId,isSigner:!1,isWritable:!1}),T.push({pubkey:f,isSigner:!1,isWritable:!0}),T.push({pubkey:y,isSigner:!1,isWritable:!0});let w=Buffer.alloc(I.span);return I.encode({amountB:b,maxAmountA:g,shareFeeRate:P!=null?P:new Mn(0)},w),new At({keys:T,programId:l,data:Buffer.from([...kt.sellExactOut,...w])})}function lu(l,e,t,n,o,r,i,s,u){let a=F([]),c=[{pubkey:e,isSigner:!0,isWritable:!0},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!1},{pubkey:u,isSigner:!1,isWritable:!1},{pubkey:Nt.programId,isSigner:!1,isWritable:!1},{pubkey:is,isSigner:!1,isWritable:!1}],m=Buffer.alloc(a.span);return a.encode({},m),new At({keys:c,programId:l,data:Buffer.from([...kt.claimVestedToken,...m])})}function mu(l,e,t,n,o,r){let i=F([A("shareAmount")]),s=[{pubkey:e,isSigner:!0,isWritable:!0},{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:Nt.programId,isSigner:!1,isWritable:!1}],u=Buffer.alloc(i.span);return i.encode({shareAmount:r},u),new At({keys:s,programId:l,data:Buffer.from([...kt.createVestingAccount,...u])})}function du(l,e,t,n,o,r,i,s,u){let a=[{pubkey:e,isSigner:!0,isWritable:!0},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:Nt.programId,isSigner:!1,isWritable:!0},{pubkey:is,isSigner:!1,isWritable:!0}];return new At({keys:a,programId:l,data:kt.claimPlatformFee})}function Hl(l,e,t,n,o,r,i,s,u,a,c,m,p){let d=F([A("platformScale"),A("creatorScale"),A("burnScale"),A("feeRate"),lt("name"),lt("web"),lt("img"),A("creatorFeeRate")]),f=[{pubkey:e,isSigner:!0,isWritable:!0},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:Nt.programId,isSigner:!1,isWritable:!1},{pubkey:i,isSigner:!1,isWritable:!1}],y=Buffer.alloc(8*5+Buffer.from(c,"utf-8").length+Buffer.from(m,"utf-8").length+Buffer.from(p,"utf-8").length+4*3);return d.encode({platformScale:s.platformScale,creatorScale:s.creatorScale,burnScale:s.burnScale,feeRate:u,name:c,web:m,img:p,creatorFeeRate:a},y),new At({keys:f,programId:l,data:Buffer.from([...kt.createPlatformConfig,...y])})}function jl(l,e,t,n){let o=[{pubkey:e,isSigner:!0,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!0}],r;if(n.type==="updateClaimFeeWallet"){let i=F([V("index"),M("value")]);r=Buffer.alloc(i.span),i.encode({index:0,value:n.value},r)}else if(n.type==="updateLockNftWallet"){let i=F([V("index"),M("value")]);r=Buffer.alloc(i.span),i.encode({index:1,value:n.value},r)}else if(n.type==="migrateCpLockNftScale"){let i=F([V("index"),A("platformScale"),A("creatorScale"),A("burnScale")]);r=Buffer.alloc(i.span),i.encode(v({index:2},n.value),r)}else if(n.type==="updateFeeRate"){let i=F([V("index"),A("value")]);r=Buffer.alloc(i.span),i.encode({index:3,value:n.value},r)}else if(n.type==="updateImg"||n.type==="updateName"||n.type==="updateWeb"){let i=F([V("index"),lt("value")]);r=Buffer.alloc(Buffer.from(n.value,"utf-8").length+4+1*1),n.type==="updateName"?i.encode({index:4,value:n.value},r):n.type==="updateWeb"?i.encode({index:5,value:n.value},r):n.type==="updateImg"&&i.encode({index:6,value:n.value},r)}else if(n.type==="updateCpConfigId"){o.push({pubkey:n.value,isSigner:!1,isWritable:!1});let i=F([V("index")]);r=Buffer.alloc(i.span),i.encode({index:7},r)}else if(n.type==="updateAll"){o.push({pubkey:n.value.cpConfigId,isSigner:!1,isWritable:!1});let i=F([V("index"),M("platformClaimFeeWallet"),M("platformLockNftWallet"),A("platformScale"),A("creatorScale"),A("burnScale"),A("feeRate"),lt("name"),lt("web"),lt("img"),M("transferFeeExtensionAuth"),A("creatorFeeRate")]);r=Buffer.alloc(1+32+32+8*4+4*3+Buffer.from(n.value.name,"utf-8").length+Buffer.from(n.value.web,"utf-8").length+Buffer.from(n.value.img,"utf-8").length+32+8),i.encode({index:8,platformClaimFeeWallet:n.value.platformClaimFeeWallet,platformLockNftWallet:n.value.platformLockNftWallet,platformScale:n.value.migrateCpLockNftScale.platformScale,creatorScale:n.value.migrateCpLockNftScale.creatorScale,burnScale:n.value.migrateCpLockNftScale.burnScale,feeRate:n.value.feeRate,name:n.value.name,web:n.value.web,img:n.value.img,transferFeeExtensionAuth:n.value.transferFeeExtensionAuth,creatorFeeRate:n.value.creatorFeeRate},r)}else throw Error("updateInfo params type error");return new At({keys:o,programId:l,data:Buffer.from([...kt.updatePlaformConfig,...r])})}function pu(l,e,t,n,o,r,i,s){let u=[{pubkey:t,isSigner:!0,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:e,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!1},{pubkey:s,isSigner:!1,isWritable:!1},{pubkey:Nt.programId,isSigner:!1,isWritable:!1},{pubkey:is,isSigner:!1,isWritable:!1}];return new At({keys:u,programId:l,data:kt.claimPlatformFeeFromVault})}function fu(l,e,t,n,o,r,i){let s=[{pubkey:e,isSigner:!0,isWritable:!0},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!1},{pubkey:i,isSigner:!1,isWritable:!1},{pubkey:Nt.programId,isSigner:!1,isWritable:!1},{pubkey:is,isSigner:!1,isWritable:!1}];return new At({keys:s,programId:l,data:kt.claimCreatorFee})}var Ul=255,uu=new Mn("18446744073709551615");function DC(l,e,t,n,o,r){let i=[{pubkey:e,isSigner:!0,isWritable:!0},{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:Nt.programId,isSigner:!1,isWritable:!1}],s=Buffer.alloc(1*2+8*6+V().span);return V().encode(o,s),au.encode({migrateType:r.migrateType?r.migrateType:Ul,migrateCpmmFeeOn:r.migrateCpmmFeeOn?r.migrateCpmmFeeOn:Ul,supply:r.supply?r.supply:new Mn(0),totalSellA:r.totalSellA?r.totalSellA:new Mn(0),totalFundRaisingB:r.totalFundRaisingB?r.totalFundRaisingB:new Mn(0),totalLockedAmount:r.totalLockedAmount?r.totalLockedAmount:uu,cliffPeriod:r.cliffPeriod?r.cliffPeriod:uu,unlockPeriod:r.unlockPeriod?r.unlockPeriod:uu},s,1),new At({keys:i,programId:l,data:Buffer.from([...kt.updatePlatformCurveParam,...s])})}function qC(l,e,t,n){let o=[{pubkey:e,isSigner:!0,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!0}],r=Buffer.alloc(V().span);return V().encode(n,r),new At({keys:o,programId:l,data:Buffer.from([...kt.removePlatformCurveParam,...r,1,2])})}import{NATIVE_MINT as an,TOKEN_2022_PROGRAM_ID as Zt,TOKEN_PROGRAM_ID as he,createAssociatedTokenAccountIdempotentInstruction as dt,createSyncNativeInstruction as Zl,getTransferFeeConfig as nr,unpackMint as or}from"@solana/spl-token";import ae from"bn.js";import{PublicKey as em,SystemProgram as Jl}from"@solana/web3.js";import $t from"bn.js";import $l from"decimal.js";import rs from"bn.js";import Ji from"decimal.js";var Jn=class{static getPoolInitPriceByPool({poolInfo:e,decimalA:t,decimalB:n}){throw Error()}static getPoolInitPriceByInit({a:e,b:t,decimalA:n,decimalB:o}){throw Error()}static getPoolPrice({poolInfo:e,decimalA:t,decimalB:n}){throw Error()}static getPoolEndPrice({supply:e,totalSell:t,totalLockedAmount:n,totalFundRaising:o,migrateFee:r,decimalA:i,decimalB:s}){throw Error()}static getPoolEndPriceReal({poolInfo:e,decimalA:t,decimalB:n}){throw Error()}static getInitParam({supply:e,totalFundRaising:t,totalSell:n,totalLockedAmount:o,migrateFee:r}){throw Error()}static buyExactIn({poolInfo:e,amount:t}){throw Error()}static buyExactOut({poolInfo:e,amount:t}){throw Error()}static sellExactIn({poolInfo:e,amount:t}){throw Error()}static sellExactOut({poolInfo:e,amount:t}){throw Error()}};var ss=class extends Jn{static getPoolInitPriceByPool({poolInfo:e,decimalA:t,decimalB:n}){return new Ji(e.virtualB.toString()).div(e.virtualA.toString()).mul(10**(t-n))}static getPoolInitPriceByInit({a:e,b:t,decimalA:n,decimalB:o}){return new Ji(t.toString()).div(e.toString()).mul(10**(n-o))}static getPoolPrice({poolInfo:e,decimalA:t,decimalB:n}){return new Ji(e.virtualB.add(e.realB).toString()).div(e.virtualA.sub(e.realA).toString()).mul(10**(t-n))}static getPoolEndPrice({supply:e,totalSell:t,totalLockedAmount:n,totalFundRaising:o,migrateFee:r,decimalA:i,decimalB:s}){return new Ji(o.sub(r).toString()).div(e.sub(t).sub(n).toString()).mul(10**(i-s))}static getPoolEndPriceReal({poolInfo:e,decimalA:t,decimalB:n}){let o=e.totalSellA.sub(e.realA),r=e.totalFundRaisingB.sub(e.realB);return new Ji(e.virtualB.add(e.realB.add(r)).toString()).div(e.virtualA.sub(e.realA.add(o)).toString()).mul(10**(t-n))}static getInitParam({supply:e,totalFundRaising:t,totalSell:n,totalLockedAmount:o,migrateFee:r}){if(e.lte(n))throw Error("supply need gt total sell");let i=e.sub(n).sub(o);if(i.lte(new rs(0)))throw Error("supplyMinusSellLocked <= 0");let s=t.sub(r);if(s.lte(new rs(0)))throw Error("tfMinusMf <= 0");let u=s.mul(n).mul(n).div(i),a=s.mul(n).div(i).sub(t),c=u.div(a),m=t.mul(t).div(a);if(c.lt(new rs(0))||m.lt(new rs(0)))throw Error("invalid input 0");return{a:c,b:m,c:n}}static buyExactIn({poolInfo:e,amount:t}){return this.getAmountOut({amountIn:t,inputReserve:e.virtualB.add(e.realB),outputReserve:e.virtualA.sub(e.realA)})}static buyExactOut({poolInfo:e,amount:t}){return this.getAmountIn({amountOut:t,inputReserve:e.virtualB.add(e.realB),outputReserve:e.virtualA.sub(e.realA)})}static sellExactIn({poolInfo:e,amount:t}){return this.getAmountOut({amountIn:t,inputReserve:e.virtualA.sub(e.realA),outputReserve:e.virtualB.add(e.realB)})}static sellExactOut({poolInfo:e,amount:t}){return this.getAmountIn({amountOut:t,inputReserve:e.virtualA.sub(e.realA),outputReserve:e.virtualB.add(e.realB)})}static getAmountOut({amountIn:e,inputReserve:t,outputReserve:n}){let o=e.mul(n),r=t.add(e);return o.div(r)}static getAmountIn({amountOut:e,inputReserve:t,outputReserve:n}){let o=t.mul(e),r=n.sub(e);return to(o,r)}};import as from"bn.js";import er from"decimal.js";var us=class extends Jn{static getPoolInitPriceByPool({poolInfo:e,decimalA:t,decimalB:n}){return new er(e.virtualB.toString()).div(e.virtualA.toString()).mul(10**(t-n))}static getPoolInitPriceByInit({a:e,b:t,decimalA:n,decimalB:o}){return new er(t.toString()).div(e.toString()).mul(10**(n-o))}static getPoolPrice({poolInfo:e,decimalA:t,decimalB:n}){return new er(e.virtualB.toString()).div(e.virtualA.toString()).mul(10**(t-n))}static getPoolEndPrice({supply:e,totalSell:t,totalLockedAmount:n,totalFundRaising:o,migrateFee:r,decimalA:i,decimalB:s}){return new er(o.sub(r).toString()).div(e.sub(t).sub(n).toString()).mul(10**(i-s))}static getPoolEndPriceReal({poolInfo:e,decimalA:t,decimalB:n}){let o=e.totalSellA.sub(e.realA),r=e.totalFundRaisingB.sub(e.realB);return new er(e.virtualB.add(e.realB).add(r).toString()).div(e.virtualA.sub(e.realA).add(o).toString()).mul(10**(t-n))}static getInitParam({supply:e,totalFundRaising:t,totalSell:n,totalLockedAmount:o,migrateFee:r}){let i=e.sub(o);if(i.lte(new as(0)))throw Error("invalid input 1");let s=new as(2).mul(t).sub(r),a=t.mul(i).div(s);if(a.lt(new as(0))||t.lt(new as(0)))throw Error("invalid input 0");return{a,b:t,c:a}}static buyExactIn({poolInfo:e,amount:t}){return this.getAmountOut({amountIn:t,initInput:e.virtualB,initOutput:e.virtualA})}static buyExactOut({poolInfo:e,amount:t}){return this.getAmountIn({amountOut:t,initInput:e.virtualB,initOutput:e.virtualA})}static sellExactIn({poolInfo:e,amount:t}){return this.getAmountOut({amountIn:t,initInput:e.virtualA,initOutput:e.virtualB})}static sellExactOut({poolInfo:e,amount:t}){return this.getAmountIn({amountOut:t,initInput:e.virtualA,initOutput:e.virtualB})}static getAmountOut({amountIn:e,initInput:t,initOutput:n}){return n.mul(e).div(t)}static getAmountIn({amountOut:e,initInput:t,initOutput:n}){let o=t.mul(e);return to(o,n)}};import Mt from"bn.js";import wo from"decimal.js";import zo from"bn.js";import cs from"decimal.js";var tr=class{static _multipler(e){return new cs(10).pow(e)}static getPrice({priceX64:e,decimalA:t,decimalB:n}){return new cs(e.toString()).div(this._Q64).mul(this._multipler(t)).div(this._multipler(n))}static getPriceX64({price:e,decimalA:t,decimalB:n}){let o=e.mul(this._multipler(n)).div(this._multipler(t));return new zo(o.mul(this._Q64).toFixed(0))}};tr._Q64=new cs(new zo(1).shln(64).toString());function rR({supply:l,totalFundRaisingB:e,totalLockedAmount:t,totalSellA:n,migrateType:o,decimalsA:r}){let i=l.sub(n).sub(t),s=new zo(new cs(i.mul(e).toString()).sqrt().toFixed(0));if(o==="amm"){if(s.gt(new zo(10).pow(new zo(r))))return!0}else if(o==="cpmm"){if(s.gt(new zo(100)))return!0}else throw Error("migrate type error");return!1}var ls=class extends Jn{static getPoolInitPriceByPool({poolInfo:e,decimalA:t,decimalB:n}){return new wo(0)}static getPoolInitPriceByInit({a:e,b:t,decimalA:n,decimalB:o}){return new wo(0)}static getPoolPrice({poolInfo:e,decimalA:t,decimalB:n}){return new wo(e.virtualA.mul(e.realA).toString()).div(tr._Q64).mul(10**(t-n))}static getPoolEndPrice({supply:e,totalSell:t,totalLockedAmount:n,totalFundRaising:o,migrateFee:r,decimalA:i,decimalB:s}){return new wo(o.sub(r).toString()).div(e.sub(t).sub(n).toString()).mul(10**(i-s))}static getPoolEndPriceReal({poolInfo:e,decimalA:t,decimalB:n}){let o=e.totalSellA.sub(e.realA),r=e.totalFundRaisingB.sub(e.realB);return new wo(e.virtualB.add(e.realB).add(r).toString()).div(e.virtualA.sub(e.realA).add(o).toString()).mul(10**(t-n))}static getInitParam({supply:e,totalFundRaising:t,totalSell:n,totalLockedAmount:o,migrateFee:r}){let i=e.sub(o);if(i.lte(new Mt(0)))throw Error("supplyMinusLocked need gt 0");let s=t.mul(new Mt(3)).sub(r),a=t.mul(new Mt(2)).mul(i).div(s),c=a.mul(a),m=t.mul(new Mt(2)).mul(nt).div(c);if(!m.gt(new Mt(0)))throw Error("a need gt 0");if(!Ti.gt(m))throw Error("a need lt u64 max");if(m.lt(new Mt(0))||a.lt(new Mt(0)))throw Error("invalid input 0");return{a:m,b:new Mt(0),c:a}}static buyExactIn({poolInfo:e,amount:t}){let n=e.realB.add(t),o=new Mt(2).mul(n).mul(nt).div(e.virtualA);return new Mt(new wo(o.toString()).sqrt().toFixed(0)).sub(e.realA)}static buyExactOut({poolInfo:e,amount:t}){let n=e.realA.add(t),o=n.mul(n);return to(e.virtualA.mul(o),new Mt(2).mul(nt)).sub(e.realB)}static sellExactIn({poolInfo:e,amount:t}){let n=e.realA.sub(t),o=n.mul(n),r=to(e.virtualA.mul(o),new Mt(2).mul(nt));return e.realB.sub(r)}static sellExactOut({poolInfo:e,amount:t}){let n=e.realB.sub(t),o=new Mt(2).mul(n).mul(nt).div(e.virtualA),r=new Mt(new wo(o.toString()).sqrt().toFixed(0));return e.realA.sub(r)}};var Dt=class{static getPoolCurvePointByPoolInfo({curveType:e,pointCount:t,poolInfo:n}){return this.getPoolCurvePointByInit({curveType:e,pointCount:t,supply:n.supply,totalFundRaising:n.totalFundRaisingB,totalSell:n.totalSellA,totalLockedAmount:n.vestingSchedule.totalLockedAmount,migrateFee:n.migrateFee,decimalA:n.mintDecimalsA,decimalB:n.mintDecimalsB})}static getPoolCurvePointByInit({curveType:e,pointCount:t,supply:n,totalFundRaising:o,totalSell:r,totalLockedAmount:i,migrateFee:s,decimalA:u,decimalB:a}){if(t<3)throw Error("point count < 3");let c=this.getCurve(e),m=c.getInitParam({supply:n,totalFundRaising:o,totalSell:r,totalLockedAmount:i,migrateFee:s}),p=c.getPoolInitPriceByInit(q(v({},m),{decimalA:u,decimalB:a})),d=o.div(new $t(t-1)),f=new $t(0),y=[{price:p,totalSellSupply:0}],{a:b,b:g}=m,P=f,h=f;for(let I=1;I<t;I++){let T=I!==t-1?d:o.sub(h),w=this.buyExactIn({poolInfo:{virtualA:b,virtualB:g,realA:P,realB:h,totalFundRaisingB:o,totalSellA:r},amountB:T,protocolFeeRate:f,platformFeeRate:f,curveType:e,shareFeeRate:f,creatorFeeRate:f,transferFeeConfigA:void 0,slot:0});P=P.add(w.amountA.amount),h=h.add(w.amountB);let K=this.getPrice({poolInfo:{virtualA:b,virtualB:g,realA:P,realB:h},decimalA:u,decimalB:a,curveType:e});y.push({price:K,totalSellSupply:new $l(P.toString()).div(10**u).toNumber()})}return y}static getPoolInitPriceByPool({poolInfo:e,decimalA:t,decimalB:n,curveType:o}){return this.getCurve(o).getPoolInitPriceByPool({poolInfo:e,decimalA:t,decimalB:n})}static getPoolInitPriceByInit({a:e,b:t,decimalA:n,decimalB:o,curveType:r}){return this.getCurve(r).getPoolInitPriceByInit({a:e,b:t,decimalA:n,decimalB:o})}static getPrice({poolInfo:e,curveType:t,decimalA:n,decimalB:o}){return this.getCurve(t).getPoolPrice({poolInfo:e,decimalA:n,decimalB:o})}static getEndPrice({poolInfo:e,curveType:t,decimalA:n,decimalB:o}){return this.getCurve(t).getPoolPrice({poolInfo:e,decimalA:n,decimalB:o})}static getPoolEndPriceReal({poolInfo:e,curveType:t,decimalA:n,decimalB:o}){return this.getCurve(t).getPoolEndPriceReal({poolInfo:e,decimalA:n,decimalB:o})}static checkParam({supply:e,totalFundRaising:t,totalSell:n,totalLockedAmount:o,decimals:r,config:i,migrateType:s}){if(Number(r)!==6)throw Error("decimals = 6");if(e.mul(i.maxLockRate).div(Ct).lt(o))throw Error("total lock amount gte max lock amount");if(e.lt(i.minSupplyA.mul(new $t(10**r))))throw Error("supply lt min supply");let a=e.mul(i.minSellRateA).div(Ct);if(n.lt(a))throw Error("invalid input");if(t.lt(i.minFundRaisingB))throw Error("total fund raising lt min fund raising");let c=e.sub(n).sub(o),m=e.mul(i.minMigrateRateA).div(Ct);if(c.lt(m))throw Error("migrate lt min migrate amoount");let p=e.sub(n).sub(o),d=new $t(new $l(p.mul(t).toString()).sqrt().toFixed(0));if(s==="amm"){let f=new $t(10).pow(new $t(r));if(d.lte(f))throw Error("check migrate lp error")}else if(s==="cpmm"){let f=new $t(100);if(d.lte(f))throw Error("check migrate lp error")}else throw Error("migrate type error")}static buyExactIn({poolInfo:e,amountB:t,protocolFeeRate:n,platformFeeRate:o,curveType:r,shareFeeRate:i,creatorFeeRate:s,transferFeeConfigA:u,slot:a}){let c=this.totalFeeRate({protocolFeeRate:n,platformFeeRate:o,shareFeeRate:i,creatorFeeRate:s}),m=this.calculateFee({amount:t,feeRate:c}),p=t.sub(m),d=this.getCurve(r),f=d.buyExactIn({poolInfo:e,amount:p}),y=e.totalSellA.sub(e.realA),b,g,P;if(f.gt(y)){b=y;let I=d.buyExactOut({poolInfo:e,amount:b});g=this.calculatePreFee({postFeeAmount:I,feeRate:c}),P=g.sub(I)}else b=f,g=t,P=m;let h=this.splitFee({totalFee:P,protocolFeeRate:n,platformFeeRate:o,shareFeeRate:i,creatorFeeRate:s});return{amountA:Ns(b,u,a),amountB:g,splitFee:h}}static buyExactOut({poolInfo:e,amountA:t,protocolFeeRate:n,platformFeeRate:o,curveType:r,shareFeeRate:i,creatorFeeRate:s,transferFeeConfigA:u,slot:a}){let c=e.totalSellA.sub(e.realA),m=Ms(t,u,a),p=m.fee?m.amount.add(m.fee):m.amount;t.gt(c)&&(p=c);let f=this.getCurve(r).buyExactOut({poolInfo:e,amount:p}),y=this.totalFeeRate({protocolFeeRate:n,platformFeeRate:o,shareFeeRate:i,creatorFeeRate:s}),b=this.calculatePreFee({postFeeAmount:f,feeRate:y}),g=b.sub(f),P=this.splitFee({totalFee:g,protocolFeeRate:n,platformFeeRate:o,shareFeeRate:i,creatorFeeRate:s});return{amountA:m,amountB:b,splitFee:P}}static sellExactIn({poolInfo:e,amountA:t,protocolFeeRate:n,platformFeeRate:o,curveType:r,shareFeeRate:i,creatorFeeRate:s,transferFeeConfigA:u,slot:a}){let c=this.getCurve(r),m=Ns(t,u,a),p=m.fee?m.amount.sub(m.fee):m.amount,d=c.sellExactIn({poolInfo:e,amount:p}),f=this.calculateFee({amount:d,feeRate:this.totalFeeRate({protocolFeeRate:n,platformFeeRate:o,shareFeeRate:i,creatorFeeRate:s})}),y=this.splitFee({totalFee:f,protocolFeeRate:n,platformFeeRate:o,shareFeeRate:i,creatorFeeRate:s});return{amountA:m,amountB:d.sub(f),splitFee:y}}static sellExactOut({poolInfo:e,amountB:t,protocolFeeRate:n,platformFeeRate:o,curveType:r,shareFeeRate:i,creatorFeeRate:s,transferFeeConfigA:u,slot:a}){let c=this.totalFeeRate({protocolFeeRate:n,platformFeeRate:o,shareFeeRate:i,creatorFeeRate:s}),m=this.calculatePreFee({postFeeAmount:t,feeRate:c});if(e.realB.lt(m))throw Error("Insufficient liquidity");let p=m.sub(t),f=Dt.getCurve(r).sellExactOut({poolInfo:e,amount:m});if(f.gt(e.realA))throw Error();let y=this.splitFee({totalFee:p,protocolFeeRate:n,platformFeeRate:o,shareFeeRate:i,creatorFeeRate:s});return{amountA:Ms(f,u,a),amountB:t,splitFee:y}}static splitFee({totalFee:e,protocolFeeRate:t,platformFeeRate:n,shareFeeRate:o,creatorFeeRate:r}){let i=this.totalFeeRate({protocolFeeRate:t,platformFeeRate:n,shareFeeRate:o,creatorFeeRate:r}),s=i.isZero()?new $t(0):e.mul(n).div(i),u=i.isZero()?new $t(0):e.mul(o).div(i),a=i.isZero()?new $t(0):e.mul(r).div(i),c=e.sub(s).sub(u).sub(a);return{platformFee:s,shareFee:u,protocolFee:c,creatorFee:a}}static calculateFee({amount:e,feeRate:t}){return Zo(e,t,Ct)}static calculatePreFee({postFeeAmount:e,feeRate:t}){if(t.isZero())return e;let n=e.mul(Ct),o=Ct.sub(t);return n.add(o).sub(new $t(1)).div(o)}static totalFeeRate({protocolFeeRate:e,platformFeeRate:t,shareFeeRate:n,creatorFeeRate:o}){if(e.add(t).add(n).add(o).gt(new $t(1e6)))throw Error("total fee rate gt 1_000_000");return e.add(t).add(n).add(o)}static getCurve(e){switch(e){case 0:return ss;case 1:return us;case 2:return ls}throw Error("find curve error")}};import pt from"decimal.js";var To={initPriceX64:new ae("515752397214619"),supply:new ae(1e15),totalSellA:new ae(7931e11),totalFundRaisingB:new ae(85e9),totalLockedAmount:new ae("0"),cliffPeriod:new ae("0"),unlockPeriod:new ae("0"),decimals:6,virtualA:new ae("1073471847374405"),virtualB:new ae("30050573465"),realA:new ae(0),realB:new ae(0),protocolFee:new ae(0),platformId:new em("4Bu96XjU84XjPDSpveTVf6LYGCkfW5FK7SNkREWcEfV4"),vestingSchedule:{totalLockedAmount:new ae(0),cliffPeriod:new ae(0),unlockPeriod:new ae(0),startTime:new ae(0),totalAllocatedShare:new ae(0)}},bn=new ae(1e4),ir=class extends We{constructor(e){super(e)}async sayHello(){console.log("hello")}async createLaunchpad(N){var L=N,{programId:e=et,authProgramId:t,platformId:n=To.platformId,mintA:o,decimals:r=6,mintBDecimals:i=9,name:s,symbol:u,uri:a,migrateType:c,configId:m,snipers:p,configInfo:d,platformFeeRate:f,txVersion:y,computeBudgetConfig:b,txTipConfig:g,feePayer:P,buyAmount:h,minMintAAmount:I,slippage:T,associatedOnly:w=!0,checkCreateATAOwner:K=!1,extraSigners:x,token2022:S,transferFeeExtensionParams:B,creatorFeeOn:R=0}=L,C=_e(L,["programId","authProgramId","platformId","mintA","decimals","mintBDecimals","name","symbol","uri","migrateType","configId","snipers","configInfo","platformFeeRate","txVersion","computeBudgetConfig","txTipConfig","feePayer","buyAmount","minMintAAmount","slippage","associatedOnly","checkCreateATAOwner","extraSigners","token2022","transferFeeExtensionParams","creatorFeeOn"]);var vt,sr,gu,Pu,Au,ku,wu,Tu,hu,Iu;let O=[],E=this.createTxBuilder(P);t=t!=null?t:sn(e).publicKey,S=!!B,S&&(c="cpmm");let X=d;if(!X&&m){let Jt=await this.scope.connection.getAccountInfo(m);Jt&&(X=Nn.decode(Jt.data))}X||this.logAndCreateError("config not found");let Y=X.mintB,j=X.curveType,{publicKey:de}=Ao(e,o,Y),{publicKey:re}=ou(e,de,o),{publicKey:ce}=ou(e,de,Y),{publicKey:ye}=Bn(o);console.log(`create token: ${o.toBase58()}, mintB: ${Y.toBase58()}, decimals A:${r}/B:${i}, config:${m.toBase58()}`),u.length>10&&this.logAndCreateError("Symbol length should shorter than 11"),a||this.logAndCreateError("uri should not empty");let pe=(vt=C==null?void 0:C.supply)!=null?vt:To.supply,te=(sr=C==null?void 0:C.totalSellA)!=null?sr:To.totalSellA,Ie=(gu=C==null?void 0:C.totalFundRaisingB)!=null?gu:To.totalFundRaisingB,ee=(Pu=C==null?void 0:C.totalLockedAmount)!=null?Pu:new ae(0),Fe=f;if(!f){let Jt=await this.scope.connection.getAccountInfo(n);Jt||this.logAndCreateError("platform id not found:",n.toString()),Fe=ko.decode(Jt.data).feeRate}let un=Dt.getCurve(X.curveType).getInitParam({supply:pe,totalFundRaising:Ie,totalSell:te,totalLockedAmount:ee,migrateFee:X.migrateFee}),Me={epoch:new ae(896),bump:254,status:0,mintDecimalsA:r,mintDecimalsB:i,supply:pe,totalSellA:te,mintA:new em(o),mintB:Y,virtualA:un.a,virtualB:un.b,realA:To.realA,realB:To.realB,migrateFee:X.migrateFee,migrateType:c==="amm"?0:1,protocolFee:To.protocolFee,platformFee:Fe,platformId:n,configId:m,vaultA:re,vaultB:ce,creator:this.scope.ownerPubKey,totalFundRaisingB:Ie,vestingSchedule:{totalLockedAmount:ee,cliffPeriod:new ae(0),unlockPeriod:new ae(0),startTime:new ae(0),totalAllocatedShare:new ae(0)},mintProgramFlag:S?1:0,cpmmCreatorFeeOn:R},Yo=Dt.getCurve(X.curveType),{c:ds}=Yo.getInitParam({supply:Me.supply,totalFundRaising:Me.totalFundRaisingB,totalLockedAmount:ee,totalSell:X.curveType===0?Me.totalSellA:new ae(0),migrateFee:X.migrateFee});try{Dt.checkParam({supply:Me.supply,totalFundRaising:Me.totalFundRaisingB,totalSell:ds,totalLockedAmount:ee,decimals:Me.mintDecimalsA,config:X,migrateType:c}),this.logDebug("check init params success")}catch(Jt){this.logAndCreateError(`check create mint params failed, ${Jt.message}`)}E.addInstruction({instructions:[S?Xl(e,P!=null?P:this.scope.ownerPubKey,this.scope.ownerPubKey,m,n,t,de,o,Y,re,ce,r,s,u,a||"https://",{type:j===0?"ConstantCurve":j===1?"FixedCurve":j===2?"LinearCurve":"ConstantCurve",totalSellA:te,migrateType:c,supply:pe,totalFundRaisingB:Ie},ee,(Au=C==null?void 0:C.cliffPeriod)!=null?Au:new ae(0),(ku=C==null?void 0:C.unlockPeriod)!=null?ku:new ae(0),R,B):Gl(e,P!=null?P:this.scope.ownerPubKey,this.scope.ownerPubKey,m,n,t,de,o,Y,re,ce,ye,r,s,u,a||"https://",{type:j===0?"ConstantCurve":j===1?"FixedCurve":j===2?"LinearCurve":"ConstantCurve",totalSellA:te,migrateType:c,supply:pe,totalFundRaisingB:Ie},ee,(wu=C==null?void 0:C.cliffPeriod)!=null?wu:new ae(0),(Tu=C==null?void 0:C.unlockPeriod)!=null?Tu:new ae(0),R)]});let Qo=S?await this.scope.connection.getEpochInfo():void 0,qt=B?{epoch:BigInt((Qo==null?void 0:Qo.epoch)||0),maximumFee:BigInt((hu=B==null?void 0:B.maxinumFee.toString())!=null?hu:0),transferFeeBasisPoints:(Iu=B==null?void 0:B.transferFeeBasePoints)!=null?Iu:0}:void 0,Io={amountA:{amount:new ae(0),fee:void 0,expirationTime:void 0},amountB:new ae(0),splitFee:{platformFee:new ae(0),shareFee:new ae(0),protocolFee:new ae(0),creatorFee:new ae(0)}},Bo;if(x!=null&&x.length&&E.addInstruction({signers:x}),!C.createOnly){let{builder:Jt,extInfo:tm}=await this.buyToken({programId:e,authProgramId:t,mintAProgram:S?Zt:void 0,mintA:o,mintB:Y,poolInfo:Me,buyAmount:h,minMintAAmount:I,shareFeeRate:C.shareFeeRate,shareFeeReceiver:C.shareFeeReceiver,configInfo:X,platformFeeRate:Fe,slippage:T,associatedOnly:w,checkCreateATAOwner:K,skipCheckMintA:!qt,transferFeeConfigA:qt?{transferFeeConfigAuthority:t,withdrawWithheldAuthority:t,withheldAmount:BigInt(0),olderTransferFee:qt,newerTransferFee:qt}:void 0,fromCreate:!0});console.log("FEE: ",qt),console.log("PREPARING SNIPER TRANSACTIONS");for(let Bu of p){let{builder:nm,extInfo:Cf}=await this.buyToken({programId:e,authProgramId:t,mintAProgram:S?Zt:void 0,mintA:o,mintB:Y,poolInfo:Me,buyAmount:Bu.amount,minMintAAmount:I,shareFeeRate:C.shareFeeRate,shareFeeReceiver:C.shareFeeReceiver,configInfo:X,platformFeeRate:Fe,slippage:T,sniper:Bu,associatedOnly:w,checkCreateATAOwner:K,skipCheckMintA:!qt,transferFeeConfigA:qt?{transferFeeConfigAuthority:t,withdrawWithheldAuthority:t,withheldAmount:BigInt(0),olderTransferFee:qt,newerTransferFee:qt}:void 0,fromCreate:!1});O.push(q(v({},nm.AllTxData),{blockHash:this.scope.blockhashCommitment}))}E.addInstruction(v({},Jt.AllTxData)),Io=v({},tm),Bo=(this.scope.cluster==="devnet"||y===1)&&C.shareFeeReceiver?[Jt.allInstructions[0]]:void 0}return y===0?(console.log("VERSION V0"),{tx:await E.sizeCheckBuildV0({computeBudgetConfig:b,swapInfo:Io,splitIns:Bo,address:q(v({},Me),{poolId:de})}),txs:O}):(console.log("VERSION PLAIN"),{tx:await E.sizeCheckBuild({computeBudgetConfig:b,swapInfo:Io,splitIns:Bo,address:q(v({},Me),{poolId:de})}),txs:O})}async buyTokenOriginal({programId:e=et,authProgramId:t,mintA:n,mintAProgram:o=he,mintB:r=an,poolInfo:i,configInfo:s,platformFeeRate:u,txVersion:a,computeBudgetConfig:c,txTipConfig:m,feePayer:p,buyAmount:d,minMintAAmount:f,slippage:y,sniper:b,shareFeeRate:g=new ae(0),shareFeeReceiver:P,associatedOnly:h=!0,checkCreateATAOwner:I=!1,fromCreate:T=!1,transferFeeConfigA:w,skipCheckMintA:K=!1}){var pe,te,Ie;d.lte(new ae(0))&&this.logAndCreateError("buy amount should gt 0:",d.toString());let x=b?this.createSniperTxBuilder(b.owner,b.owner.publicKey):this.createTxBuilder(p),{publicKey:S}=Ao(e,n,r);t=t!=null?t:sn(e).publicKey;let B=w;if(!K)if(console.log("!skipCheckMintA: ",K),B)console.log("TOKEN_2022_PROGRAM_ID: ",Zt),o=Zt;else{console.log("!transferFeeConfigA: ",B);let ee=await this.scope.connection.getAccountInfo(n);if(ee&&ee.owner.equals(Zt)){console.log("TOKEN_2022_PROGRAM_ID: ",K),o=ee.owner;let Fe=or(n,ee,o);B=nr(Fe)||void 0}}let R=this.scope.account.getAssociatedTokenAccount(n,o),C=T?this.scope.account.getAssociatedTokenAccount(r,he):null,N=r.equals(an);if(x.addInstruction({instructions:[dt(this.scope.ownerPubKey,R,this.scope.ownerPubKey,n,o),...T?[dt(this.scope.ownerPubKey,C,this.scope.ownerPubKey,r,he),Jl.transfer({fromPubkey:this.scope.ownerPubKey,toPubkey:C,lamports:BigInt(d.toString())}),Zl(C)]:[]]}),!T){let{account:ee,instructionParams:Fe}=await this.scope.account.getOrCreateTokenAccount({mint:r,owner:this.scope.ownerPubKey,createInfo:N?{payer:this.scope.ownerPubKey,amount:d}:void 0,skipCloseAccount:!N,notUseTokenAccount:N,associatedOnly:N?!1:h,checkCreateATAOwner:I});ee&&(C=ee),x.addInstruction(Fe||{})}C===void 0&&this.logAndCreateError(`cannot found mintB(${r.toBase58()}) token accounts`,"tokenAccounts",this.scope.account.tokenAccounts);let L=i;if(!L){let ee=await this.scope.connection.getAccountInfo(S,{commitment:"processed"});ee||this.logAndCreateError("cannot found pool:",S.toBase58()),L=jt.decode(ee.data)}let O=s,E=await Le(this.scope.connection,[O?void 0:L.configId,L.platformId].filter(Boolean).map(ee=>({pubkey:ee})));if(!O){let ee=E.find(Fe=>Fe.pubkey.equals(L.configId));(!ee||!ee.accountInfo)&&this.logAndCreateError("config not found: ",L.configId.toBase58()),O=Nn.decode(ee.accountInfo.data)}let X=E.find(ee=>ee.pubkey.equals(L.platformId));(!X||!X.accountInfo)&&this.logAndCreateError("platform info not found: ",L.configId.toBase58());let Y=ko.decode(X.accountInfo.data);u=u||Y.feeRate;let j=Dt.buyExactIn({poolInfo:L,amountB:d,protocolFeeRate:O.tradeFeeRate,platformFeeRate:u,curveType:O.curveType,shareFeeRate:g,creatorFeeRate:Y.creatorFeeRate,transferFeeConfigA:B,slot:await this.scope.connection.getSlot()}),de=new pt(j.amountA.amount.toString()).sub((te=(pe=j.amountA.fee)==null?void 0:pe.toString())!=null?te:0),re=y?new pt(bn.sub(y).toNumber()/bn.toNumber()).clampedTo(0,1):new pt(1),ce=f!=null?f:y?new ae(de.mul(re).toFixed(0)):j.amountA.amount.sub((Ie=j.amountA.fee)!=null?Ie:new ae(0));j.amountB.lt(d)&&console.log(`maximum ${n.toBase58()} amount can buy is ${j.amountA.toString()}, input ${r.toBase58()} amount: ${j.amountB.toString()}`);let ye=P?$(P,r,he).publicKey:void 0;return ye&&x.addInstruction({instructions:[dt(this.scope.ownerPubKey,ye,P,r)]}),x.addInstruction({instructions:[cu(e,this.scope.ownerPubKey,t,L.configId,L.platformId,S,R,C,L.vaultA,L.vaultB,n,r,o,he,$n(e,L.platformId,r).publicKey,Zn(e,L.creator,r).publicKey,j.amountB.lt(d)?j.amountB:d,ce,g,ye)]}),x.addCustomComputeBudget(c),x.addTipInstruction(m),x.versionBuild({txVersion:a,extInfo:q(v({},j),{decimalOutAmount:de,minDecimalOutAmount:new pt(ce.toString())})})}async buyToken({programId:e=et,authProgramId:t,mintA:n,mintAProgram:o=he,mintB:r=an,poolInfo:i,configInfo:s,platformFeeRate:u,txVersion:a,computeBudgetConfig:c,txTipConfig:m,feePayer:p,buyAmount:d,minMintAAmount:f,slippage:y,shareFeeRate:b=new ae(0),shareFeeReceiver:g,sniper:P,associatedOnly:h=!0,checkCreateATAOwner:I=!1,fromCreate:T=!1,transferFeeConfigA:w,skipCheckMintA:K=!1}){var pe,te,Ie;d.lte(new ae(0))&&this.logAndCreateError("buy amount should gt 0:",d.toString());let x=P?this.createSniperTxBuilder(P.owner,P.owner.publicKey):this.createTxBuilder(p),{publicKey:S}=Ao(e,n,r);t=t!=null?t:sn(e).publicKey;let B=w;if(!K)if(console.log("!skipCheckMintA: ",K),B)console.log("mintAProgram: ",Zt),o=Zt;else{console.log("!transferFeeConfigA: ",B);let ee=await this.scope.connection.getAccountInfo(n);if(ee&&ee.owner.equals(Zt)){console.log("!mintInfo: ",ee),o=ee.owner;let Fe=or(n,ee,o);B=nr(Fe)||void 0}}let R=P?this.scope.account.getAssociatedTokenAccountByOwner(P.owner.publicKey,n,o):this.scope.account.getAssociatedTokenAccount(n,o),C=T?P?this.scope.account.getAssociatedTokenAccountByOwner(P.owner.publicKey,r,he):this.scope.account.getAssociatedTokenAccount(r,he):null,N=r.equals(an);if(console.log("userTokenAccountA: ",R),console.log("userTokenAccountB: ",C),x.addInstruction({instructions:[dt((P==null?void 0:P.owner.publicKey)||this.scope.ownerPubKey,R,(P==null?void 0:P.owner.publicKey)||this.scope.ownerPubKey,n,o),...T?[dt((P==null?void 0:P.owner.publicKey)||this.scope.ownerPubKey,C,(P==null?void 0:P.owner.publicKey)||this.scope.ownerPubKey,r,he),Jl.transfer({fromPubkey:(P==null?void 0:P.owner.publicKey)||this.scope.ownerPubKey,toPubkey:C,lamports:BigInt(d.toString())}),Zl(C)]:[]]}),!T){let{account:ee,instructionParams:Fe}=await this.scope.account.getOrCreateTokenAccount({mint:r,owner:this.scope.ownerPubKey,createInfo:N?{payer:this.scope.ownerPubKey,amount:d}:void 0,skipCloseAccount:!N,notUseTokenAccount:N,associatedOnly:N?!1:h,checkCreateATAOwner:I});ee&&(C=ee),x.addInstruction(Fe||{})}C===void 0&&this.logAndCreateError(`cannot found mintB(${r.toBase58()}) token accounts`,"tokenAccounts",this.scope.account.tokenAccounts);let L=i;if(!L){let ee=await this.scope.connection.getAccountInfo(S,{commitment:"processed"});ee||this.logAndCreateError("cannot found pool:",S.toBase58()),L=jt.decode(ee.data)}let O=s,E=await Le(this.scope.connection,[O?void 0:L.configId,L.platformId].filter(Boolean).map(ee=>({pubkey:ee})));if(!O){let ee=E.find(Fe=>Fe.pubkey.equals(L.configId));(!ee||!ee.accountInfo)&&this.logAndCreateError("config not found: ",L.configId.toBase58()),O=Nn.decode(ee.accountInfo.data)}let X=E.find(ee=>ee.pubkey.equals(L.platformId));(!X||!X.accountInfo)&&this.logAndCreateError("platform info not found: ",L.configId.toBase58());let Y=ko.decode(X.accountInfo.data);u=u||Y.feeRate;let j=Dt.buyExactIn({poolInfo:L,amountB:d,protocolFeeRate:O.tradeFeeRate,platformFeeRate:u,curveType:O.curveType,shareFeeRate:b,creatorFeeRate:Y.creatorFeeRate,transferFeeConfigA:B,slot:await this.scope.connection.getSlot()}),de=new pt(j.amountA.amount.toString()).sub((te=(pe=j.amountA.fee)==null?void 0:pe.toString())!=null?te:0),re=y?new pt(bn.sub(y).toNumber()/bn.toNumber()).clampedTo(0,1):new pt(1),ce=f!=null?f:y?new ae(de.mul(re).toFixed(0)):j.amountA.amount.sub((Ie=j.amountA.fee)!=null?Ie:new ae(0));j.amountB.lt(d)&&console.log(`maximum ${n.toBase58()} amount can buy is ${j.amountA.toString()}, input ${r.toBase58()} amount: ${j.amountB.toString()}`);let ye=g?$(g,r,he).publicKey:void 0;return ye&&x.addInstruction({instructions:[dt((P==null?void 0:P.owner.publicKey)||this.scope.ownerPubKey,ye,g,r)]}),x.addInstruction({instructions:[cu(e,(P==null?void 0:P.owner.publicKey)||this.scope.ownerPubKey,t,L.configId,L.platformId,S,R,C,L.vaultA,L.vaultB,n,r,o,he,$n(e,L.platformId,r).publicKey,Zn(e,L.creator,r).publicKey,j.amountB.lt(d)?j.amountB:d,ce,b,ye)]}),x.addCustomComputeBudget(c),x.addTipInstruction(m),x.versionBuild({txVersion:a,extInfo:q(v({},j),{decimalOutAmount:de,minDecimalOutAmount:new pt(ce.toString())})})}async buyTokenExactOut({programId:e=et,authProgramId:t,mintA:n,mintAProgram:o=he,mintB:r=an,poolInfo:i,configInfo:s,transferFeeConfigA:u,platformFeeRate:a,txVersion:c,computeBudgetConfig:m,txTipConfig:p,feePayer:d,maxBuyAmount:f,outAmount:y,slippage:b,shareFeeRate:g=new ae(0),shareFeeReceiver:P,associatedOnly:h=!0,checkCreateATAOwner:I=!1,skipCheckMintA:T=!1}){y.lte(new ae(0))&&this.logAndCreateError("out amount should gt 0:",y.toString());let w=this.createTxBuilder(d),{publicKey:K}=Ao(e,n,r);t=t!=null?t:sn(e).publicKey;let x=i;if(!x){let pe=await this.scope.connection.getAccountInfo(K,{commitment:"processed"});pe||this.logAndCreateError("cannot found pool:",K.toBase58()),x=jt.decode(pe.data)}let S=s,B=await Le(this.scope.connection,[S?void 0:x.configId,x.platformId].filter(Boolean).map(pe=>({pubkey:pe})));if(!S){let pe=B.find(te=>te.pubkey.equals(x.configId));(!pe||!pe.accountInfo)&&this.logAndCreateError("config not found: ",x.configId.toBase58()),S=Nn.decode(pe.accountInfo.data)}let R=B.find(pe=>pe.pubkey.equals(x.platformId));(!R||!R.accountInfo)&&this.logAndCreateError("platform info not found: ",x.configId.toBase58());let C=ko.decode(R.accountInfo.data);a=a||C.feeRate;let N=u;if(!T)if(N)o=Zt;else{let pe=await this.scope.connection.getAccountInfo(n);if(pe&&pe.owner.equals(Zt)){o=pe.owner;let te=or(n,pe,o);N=nr(te)||void 0}}let L=Dt.buyExactOut({poolInfo:x,amountA:y,protocolFeeRate:S.tradeFeeRate,platformFeeRate:a,curveType:S.curveType,shareFeeRate:g,creatorFeeRate:C.creatorFeeRate,transferFeeConfigA:N,slot:await this.scope.connection.getSlot()}),O=new pt(L.amountB.toString()),E=b?new pt(bn.add(b).toNumber()/bn.toNumber()).clampedTo(0,Number.MIN_SAFE_INTEGER):new pt(1),X=(f!=null?f:b)?new ae(O.mul(E).toFixed(0)):L.amountB,Y=this.scope.account.getAssociatedTokenAccount(n,o),j=null,de=r.equals(an);w.addInstruction({instructions:[dt(this.scope.ownerPubKey,Y,this.scope.ownerPubKey,n,o)]});let{account:re,instructionParams:ce}=await this.scope.account.getOrCreateTokenAccount({mint:r,owner:this.scope.ownerPubKey,createInfo:de?{payer:this.scope.ownerPubKey,amount:L.amountB}:void 0,skipCloseAccount:!de,notUseTokenAccount:de,associatedOnly:de?!1:h,checkCreateATAOwner:I});re&&(j=re),w.addInstruction(ce||{}),j===void 0&&this.logAndCreateError(`cannot found mintB(${r.toBase58()}) token accounts`,"tokenAccounts",this.scope.account.tokenAccounts);let ye=P?$(P,r,he).publicKey:void 0;return ye&&w.addInstruction({instructions:[dt(this.scope.ownerPubKey,ye,P,r)]}),w.addInstruction({instructions:[zl(e,this.scope.ownerPubKey,t,x.configId,x.platformId,K,Y,j,x.vaultA,x.vaultB,n,r,o,he,$n(e,x.platformId,r).publicKey,Zn(e,x.creator,r).publicKey,y,X,g,ye)]}),w.addCustomComputeBudget(m),w.addTipInstruction(p),w.versionBuild({txVersion:c,extInfo:{maxSpentAmount:X,outAmount:y}})}async sellToken({programId:e=et,authProgramId:t,mintAProgram:n=he,mintA:o,mintB:r=an,poolInfo:i,configInfo:s,platformFeeRate:u,txVersion:a,computeBudgetConfig:c,txTipConfig:m,feePayer:p,sellAmount:d,minAmountB:f,slippage:y,shareFeeRate:b=new ae(0),shareFeeReceiver:g,associatedOnly:P=!0,checkCreateATAOwner:h=!1,skipCheckMintA:I=!1}){t=t!=null?t:sn(e).publicKey;let T=this.createTxBuilder(p);d.lte(new ae(0))&&this.logAndCreateError("sell amount should be gt 0");let{publicKey:w}=Ao(e,o,r),K;if(!I){let te=await this.scope.connection.getAccountInfo(o);if(te&&te.owner.equals(Zt)){n=te.owner;let Ie=or(o,te,n);K=nr(Ie)||void 0}}let x=null,S=null,B=r.equals(an),{account:R,instructionParams:C}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:n,mint:o,owner:this.scope.ownerPubKey,createInfo:void 0,skipCloseAccount:!0,notUseTokenAccount:!1,associatedOnly:P,checkCreateATAOwner:h});R&&(x=R),T.addInstruction(C||{}),x===void 0&&this.logAndCreateError("cannot found mintA token accounts","tokenAccounts",this.scope.account.tokenAccounts);let{account:N,instructionParams:L}=await this.scope.account.getOrCreateTokenAccount({mint:r,owner:this.scope.ownerPubKey,createInfo:B?{payer:this.scope.ownerPubKey,amount:0}:void 0,skipCloseAccount:!B,notUseTokenAccount:B,associatedOnly:B?!1:P,checkCreateATAOwner:h});N&&(S=N),T.addInstruction(L||{}),S===void 0&&this.logAndCreateError("cannot found mintB token accounts","tokenAccounts",this.scope.account.tokenAccounts);let O=i;if(!O){let te=await this.scope.connection.getAccountInfo(w,{commitment:"processed"});te||this.logAndCreateError("cannot found pool",w.toBase58()),O=jt.decode(te.data)}let E=s,X=await Le(this.scope.connection,[E?void 0:O.configId,O.platformId].filter(Boolean).map(te=>({pubkey:te})));if(!E){let te=X.find(Ie=>Ie.pubkey.equals(O.configId));(!te||!te.accountInfo)&&this.logAndCreateError("config not found: ",O.configId.toBase58()),E=Nn.decode(te.accountInfo.data)}let Y=X.find(te=>te.pubkey.equals(O.platformId));(!Y||!Y.accountInfo)&&this.logAndCreateError("platform info not found: ",O.configId.toBase58());let j=ko.decode(Y.accountInfo.data);u=u||j.feeRate;let de=Dt.sellExactIn({poolInfo:O,amountA:d,protocolFeeRate:E.tradeFeeRate,platformFeeRate:u,curveType:E.curveType,shareFeeRate:b,creatorFeeRate:j.creatorFeeRate,transferFeeConfigA:K,slot:await this.scope.connection.getSlot()}),re=new pt(de.amountB.toString()),ce=y?new pt(bn.sub(y).toNumber()/bn.toNumber()).clampedTo(0,1):new pt(1),ye=f!=null?f:y?new ae(re.mul(ce).toFixed(0)):de.amountB;ye.lte(new ae(0))&&this.logAndCreateError(`out ${r.toBase58()} amount should be gt 0`);let pe=g?$(g,r,he).publicKey:void 0;return pe&&T.addInstruction({instructions:[dt(this.scope.ownerPubKey,pe,g,r)]}),T.addInstruction({instructions:[Yl(e,this.scope.ownerPubKey,t,O.configId,O.platformId,w,x,S,O.vaultA,O.vaultB,o,r,n,he,$n(e,O.platformId,r).publicKey,Zn(e,O.creator,r).publicKey,de.amountA.amount.lt(d)?de.amountA.amount:d,ye,b,pe)]}),T.addCustomComputeBudget(c),T.addTipInstruction(m),T.versionBuild({txVersion:a,extInfo:{outAmount:ye}})}async sellTokenExactOut({programId:e=et,authProgramId:t,mintAProgram:n=he,mintA:o,mintB:r=an,poolInfo:i,configInfo:s,platformFeeRate:u,txVersion:a,computeBudgetConfig:c,txTipConfig:m,feePayer:p,inAmount:d,maxSellAmount:f,slippage:y,shareFeeRate:b=new ae(0),shareFeeReceiver:g,associatedOnly:P=!0,checkCreateATAOwner:h=!1,skipCheckMintA:I=!1}){t=t!=null?t:sn(e).publicKey;let T=this.createTxBuilder(p);f!=null&&f.lte(new ae(0))&&this.logAndCreateError("max sell amount should be gt 0");let{publicKey:w}=Ao(e,o,r),K;if(!I){let te=await this.scope.connection.getAccountInfo(o);if(te&&te.owner.equals(Zt)){n=te.owner;let Ie=or(o,te,n);K=nr(Ie)||void 0}}let x=null,S=null,B=r.equals(an),{account:R,instructionParams:C}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:n,mint:o,owner:this.scope.ownerPubKey,createInfo:void 0,skipCloseAccount:!0,notUseTokenAccount:!1,associatedOnly:P,checkCreateATAOwner:h});R&&(x=R),T.addInstruction(C||{}),x===void 0&&this.logAndCreateError("cannot found mintA token accounts","tokenAccounts",this.scope.account.tokenAccounts);let{account:N,instructionParams:L}=await this.scope.account.getOrCreateTokenAccount({mint:r,owner:this.scope.ownerPubKey,createInfo:B?{payer:this.scope.ownerPubKey,amount:0}:void 0,skipCloseAccount:!B,notUseTokenAccount:B,associatedOnly:B?!1:P,checkCreateATAOwner:h});N&&(S=N),T.addInstruction(L||{}),S===void 0&&this.logAndCreateError("cannot found mintB token accounts","tokenAccounts",this.scope.account.tokenAccounts);let O=i;if(!O){let te=await this.scope.connection.getAccountInfo(w,{commitment:"processed"});te||this.logAndCreateError("cannot found pool",w.toBase58()),O=jt.decode(te.data)}let E=s,X=await Le(this.scope.connection,[E?void 0:O.configId,O.platformId].filter(Boolean).map(te=>({pubkey:te})));if(!E){let te=X.find(Ie=>Ie.pubkey.equals(O.configId));(!te||!te.accountInfo)&&this.logAndCreateError("config not found: ",O.configId.toBase58()),E=Nn.decode(te.accountInfo.data)}let Y=X.find(te=>te.pubkey.equals(O.platformId));(!Y||!Y.accountInfo)&&this.logAndCreateError("platform info not found: ",O.configId.toBase58());let j=ko.decode(Y.accountInfo.data);u=u||j.feeRate;let de=Dt.sellExactOut({poolInfo:O,amountB:d,protocolFeeRate:E.tradeFeeRate,platformFeeRate:u,curveType:E.curveType,shareFeeRate:b,creatorFeeRate:j.creatorFeeRate,transferFeeConfigA:K,slot:await this.scope.connection.getSlot()}),re=new pt(de.amountA.amount.toString()),ce=y?new pt(bn.add(y).toNumber()/bn.toNumber()).clampedTo(0,Number.MAX_SAFE_INTEGER):new pt(1),ye=(f!=null?f:y)?new ae(re.mul(ce).toFixed(0)):de.amountA.amount,pe=g?$(g,r,he).publicKey:void 0;return pe&&T.addInstruction({instructions:[dt(this.scope.ownerPubKey,pe,g,r)]}),T.addInstruction({instructions:[Ql(e,this.scope.ownerPubKey,t,O.configId,O.platformId,w,x,S,O.vaultA,O.vaultB,o,r,n,he,$n(e,O.platformId,r).publicKey,Zn(e,O.creator,r).publicKey,d,ye,b,pe)]}),T.addCustomComputeBudget(c),T.addTipInstruction(m),T.versionBuild({txVersion:a,extInfo:{maxSellAmount:ye}})}async createPlatformConfig({programId:e=et,platformAdmin:t,platformClaimFeeWallet:n,platformLockNftWallet:o,cpConfigId:r,migrateCpLockNftScale:i,transferFeeExtensionAuth:s,creatorFeeRate:u,feeRate:a,name:c,web:m,img:p,txVersion:d,computeBudgetConfig:f,txTipConfig:y,feePayer:b}){let g=this.createTxBuilder(b),{publicKey:P}=iu(e,t);return g.addInstruction({instructions:[Hl(e,t,n,o,P,r,s,i,a,u,c,m,p)]}),g.addCustomComputeBudget(f),g.addTipInstruction(y),g.versionBuild({txVersion:d,extInfo:{platformId:P}})}async updatePlatformConfig({programId:e=et,platformAdmin:t,platformId:n,updateInfo:o,txVersion:r,computeBudgetConfig:i,txTipConfig:s,feePayer:u}){let a=this.createTxBuilder(u),c=n!=null?n:iu(e,t).publicKey;return a.addInstruction({instructions:[jl(e,t,c,o)]}),a.addCustomComputeBudget(i),a.addTipInstruction(s),a.versionBuild({txVersion:r})}async claimPlatformFee({programId:e=et,authProgramId:t,platformId:n,poolId:o,platformClaimFeeWallet:r,mintB:i,vaultB:s,mintBProgram:u=he,txVersion:a,computeBudgetConfig:c,txTipConfig:m,feePayer:p}){var g;let d=this.createTxBuilder(p);t=t!=null?t:sn(e).publicKey;let f=i,y=s;if(!f){let P=await this.scope.connection.getAccountInfo(o,{commitment:"processed"});P||this.logAndCreateError("cannot found pool:",o.toBase58());let h=jt.decode(P.data),I=await this.scope.connection.getAccountInfo(h.configId,{commitment:"processed"});I||this.logAndCreateError("cannot found config:",h.configId.toBase58()),f=Nn.decode(I.data).mintB,y=y!=null?y:h.vaultB}(!f||!y)&&this.logAndCreateError("cannot found mint info, mintB: ",f.toBase58(),", vaultB: ",(g=y==null?void 0:y.toBase58())!=null?g:"");let b=$(this.scope.ownerPubKey,f,he).publicKey;return d.addInstruction({instructions:[dt(this.scope.ownerPubKey,b,this.scope.ownerPubKey,f)]}),d.addInstruction({instructions:[du(e,r,t,o,n,y,b,f,u)]}),d.addCustomComputeBudget(c),d.addTipInstruction(m),d.versionBuild({txVersion:a})}async claimAllPlatformFee({programId:e=et,authProgramId:t,platformId:n,platformClaimFeeWallet:o,txVersion:r,computeBudgetConfig:i,txTipConfig:s,feePayer:u}){let a=this.createTxBuilder(u);return t=t!=null?t:sn(e).publicKey,(await this.scope.connection.getProgramAccounts(e,{filters:[{dataSize:jt.span},{memcmp:{offset:jt.offsetOf("platformId"),bytes:n.toString()}}]})).forEach(m=>{let p=jt.decode(m.account.data);if(p.platformFee.lte(new ae(0)))return;let d=$(this.scope.ownerPubKey,p.mintB,he).publicKey;a.addInstruction({instructions:[dt(this.scope.ownerPubKey,d,this.scope.ownerPubKey,p.mintB)]}),a.addInstruction({instructions:[du(e,o,t,m.pubkey,n,p.vaultB,d,p.mintB,he)]})}),a.addTipInstruction(s),r===0?a.sizeCheckBuildV0({computeBudgetConfig:i}):a.sizeCheckBuild({computeBudgetConfig:i})}async createVesting({programId:e=et,poolId:t,beneficiary:n,shareAmount:o,txVersion:r,computeBudgetConfig:i,txTipConfig:s,feePayer:u}){let a=this.createTxBuilder(u),c=await this.getRpcPoolInfo({poolId:t});o.add(c.vestingSchedule.totalAllocatedShare).gt(c.vestingSchedule.totalLockedAmount)&&this.logAndCreateError("share amount exceed total locked amount");let m=$i(e,t,n).publicKey;return a.addInstruction({instructions:[mu(e,this.scope.ownerPubKey,n,t,m,o)]}),a.addCustomComputeBudget(i),a.addTipInstruction(s),a.versionBuild({txVersion:r})}async createMultipleVesting({programId:e=et,poolId:t,beneficiaryList:n,txVersion:o,computeBudgetConfig:r,feePayer:i}){let s=this.createTxBuilder(i);n.length===0&&this.logAndCreateError("beneficiaryList is null");let u=await this.getRpcPoolInfo({poolId:t});return n.reduce((c,m)=>c.add(m.shareAmount),u.vestingSchedule.totalAllocatedShare).gt(u.vestingSchedule.totalLockedAmount)&&this.logAndCreateError("share amount exceed total locked amount"),n.forEach(c=>{let m=$i(e,t,c.wallet).publicKey;s.addInstruction({instructions:[mu(e,this.scope.ownerPubKey,c.wallet,t,m,c.shareAmount)]})}),o===0?s.sizeCheckBuildV0({computeBudgetConfig:r}):s.sizeCheckBuild({computeBudgetConfig:r})}async claimVesting({programId:e=et,poolId:t,poolInfo:n,vestingRecord:o,txVersion:r,computeBudgetConfig:i,txTipConfig:s,feePayer:u}){let a=this.createTxBuilder(u),c=sn(e).publicKey,m=o||$i(e,t,this.scope.ownerPubKey).publicKey,p=n;if(!p){let f=await this.scope.connection.getAccountInfo(t);f||this.logAndCreateError("pool not found"),p=jt.decode(f.data)}let d=$(this.scope.ownerPubKey,p.mintA,he).publicKey;return a.addInstruction({instructions:[dt(this.scope.ownerPubKey,d,this.scope.ownerPubKey,p.mintA)]}),a.addInstruction({instructions:[lu(e,this.scope.ownerPubKey,c,t,m,d,p.vaultA,p.mintA,he)]}),a.addCustomComputeBudget(i),a.addTipInstruction(s),a.versionBuild({txVersion:r})}async claimMultiVesting({programId:e=et,poolIdList:t,poolsInfo:n={},vestingRecords:o={},txVersion:r,computeBudgetConfig:i,feePayer:s}){let u=this.createTxBuilder(s),a=v({},n),c=sn(e).publicKey,m=t.filter(p=>!a[p.toBase58()]);if(m.length){let p=await this.getRpcPoolsInfo({poolIdList:m});a=v(v({},a),p.poolInfoMap)}return t.forEach(p=>{let d=p.toBase58(),f=a[d];f||this.logAndCreateError(`pool info not found: ${d}`);let y=o[d]||$i(e,p,this.scope.ownerPubKey).publicKey,b=$(this.scope.ownerPubKey,f.mintA,he).publicKey;u.addInstruction({instructions:[dt(this.scope.ownerPubKey,b,this.scope.ownerPubKey,f.mintA)]}),u.addInstruction({instructions:[lu(e,this.scope.ownerPubKey,c,p,y,b,f.vaultA,f.mintA,he)]})}),r===0?u.sizeCheckBuildV0({computeBudgetConfig:i}):u.sizeCheckBuild({computeBudgetConfig:i})}async claimVaultPlatformFee({programId:e=et,platformId:t,mintB:n,mintBProgram:o=he,claimFeeWallet:r,txVersion:i,computeBudgetConfig:s,txTipConfig:u,feePayer:a}){let c=this.createTxBuilder(a),m=$n(e,t,n).publicKey,p=ru(e).publicKey,d=this.scope.account.getAssociatedTokenAccount(n,o);return c.addInstruction({instructions:[dt(this.scope.ownerPubKey,d,this.scope.ownerPubKey,n,o),pu(e,t,r!=null?r:this.scope.ownerPubKey,p,m,d,n,o)]}),c.addCustomComputeBudget(s),c.addTipInstruction(u),c.versionBuild({txVersion:i})}async claimMultipleVaultPlatformFee({programId:e=et,platformList:t,unwrapSol:n=!0,txVersion:o,computeBudgetConfig:r,feePayer:i,associatedOnly:s=!0,checkCreateATAOwner:u=!1}){let a=this.createTxBuilder(i),c={};return t.forEach(async m=>{var b,g;let p=ru(e).publicKey,d=$n(e,m.id,m.mintB).publicKey,f=m.mintB.equals(an)&&n,y=c[m.mintB.toBase58()];if(!y){let{account:P,instructionParams:h}=await this.scope.account.getOrCreateTokenAccount({mint:m.mintB,owner:this.scope.ownerPubKey,createInfo:f?{payer:this.scope.ownerPubKey,amount:0}:void 0,skipCloseAccount:!f,notUseTokenAccount:f,associatedOnly:f?!1:s,checkCreateATAOwner:u});P&&(y=P),a.addInstruction(h||{}),y===void 0&&this.logAndCreateError(`cannot found platform ${m.id.toBase58()} mintB(${m.mintB.toBase58()}) token accounts`,"tokenAccounts",this.scope.account.tokenAccounts)}a.addInstruction({instructions:[pu(e,m.id,(b=m.claimFeeWallet)!=null?b:this.scope.ownerPubKey,d,p,y,m.mintB,(g=m.mintBProgram)!=null?g:he)]})}),o===0?a.sizeCheckBuildV0({computeBudgetConfig:r}):a.sizeCheckBuild({computeBudgetConfig:r})}async claimCreatorFee({programId:e=et,mintB:t,mintBProgram:n=he,txVersion:o,computeBudgetConfig:r,txTipConfig:i,feePayer:s}){let u=this.createTxBuilder(s),a=Zn(e,this.scope.ownerPubKey,t).publicKey,c=su(e).publicKey,m=this.scope.account.getAssociatedTokenAccount(t,n);return u.addInstruction({instructions:[dt(this.scope.ownerPubKey,m,this.scope.ownerPubKey,t,n),fu(e,this.scope.ownerPubKey,c,a,m,t,n)]}),u.addCustomComputeBudget(r),u.addTipInstruction(i),u.versionBuild({txVersion:o})}async claimMultipleCreatorFee({programId:e=et,mintBList:t,txVersion:n,computeBudgetConfig:o,feePayer:r}){let i=this.createTxBuilder(r);return t.forEach(s=>{var d;let u=s.pubKey,a=(d=s.programId)!=null?d:he,c=Zn(e,this.scope.ownerPubKey,u).publicKey,m=su(e).publicKey,p=this.scope.account.getAssociatedTokenAccount(u,a);i.addInstruction({instructions:[dt(this.scope.ownerPubKey,p,this.scope.ownerPubKey,u,a),fu(e,this.scope.ownerPubKey,m,c,p,u,a)]})}),n==0?i.sizeCheckBuildV0({computeBudgetConfig:o}):i.sizeCheckBuild({computeBudgetConfig:o})}async getRpcPoolInfo({poolId:e}){return(await this.getRpcPoolsInfo({poolIdList:[e]})).poolInfoMap[e.toBase58()]}async getRpcPoolsInfo({poolIdList:e,config:t}){let n=await Le(this.scope.connection,e.map(u=>({pubkey:u})),t),o={},r=[];for(let u=0;u<e.length;u++){let a=n[u];if(a===null||!a.accountInfo)throw Error("fetch pool info error: "+e[u].toBase58());let c=jt.decode(a.accountInfo.data);o[e[u].toBase58()]=q(v({},c),{poolId:a.accountInfo.owner}),r.push(c.configId)}let i=await Le(this.scope.connection,r.map(u=>({pubkey:u})),t),s={};for(let u=0;u<r.length;u++){let a=i[u];if(a===null||!a.accountInfo)throw Error("fetch config info error: "+r[u].toBase58());let c=Nn.decode(a.accountInfo.data);s[r[u].toBase58()]=q(v({},c),{configId:a.accountInfo.owner})}return{poolInfoMap:Object.keys(o).reduce((u,a)=>q(v({},u),{[a]:q(v({},o[a]),{configInfo:s[o[a].configId.toBase58()]})}),{})}}};import{PublicKey as xf}from"@solana/web3.js";import{MintLayout as Kf,TOKEN_2022_PROGRAM_ID as yu,TOKEN_PROGRAM_ID as bu}from"@solana/spl-token";var rr=class extends We{constructor(t){super(t);this._tokenList=[];this._tokenMap=new Map;this._blackTokenMap=new Set;this._mintGroup={official:new Set,jup:new Set,extra:new Set};this._whiteMap=new Set;this._extraTokenList=[]}async load(t){this.checkDisabled();let{forceUpdate:n=!1,type:o="strict"}=t||{},{mintList:r,blacklist:i,whiteList:s}=await this.scope.fetchV3TokenList(n),u=await this.scope.fetchJupTokenList(n);this._tokenList=[],this._tokenMap=new Map,this._blackTokenMap=new Set(i),this._mintGroup={official:new Set,jup:new Set,extra:new Set},this._whiteMap=new Set(s),this._tokenMap.set(cn.address,cn),this._mintGroup.official.add(cn.address),r.forEach(a=>{var c;this._blackTokenMap.has(a.address)||(this._tokenMap.set(a.address,q(v({},a),{type:"raydium",priority:2,programId:(c=a.programId)!=null?c:a.tags.includes("token-2022")?yu.toBase58():bu.toBase58()})),this._mintGroup.official.add(a.address))}),u.forEach(a=>{var c;this._blackTokenMap.has(a.address)||this._tokenMap.has(a.address)||(this._tokenMap.set(a.address,q(v({},a),{type:"jupiter",priority:1,programId:(c=a.programId)!=null?c:a.tags.includes("token-2022")?yu.toBase58():bu.toBase58(),tags:a.freezeAuthority?[...a.tags||[],"hasFreeze"]:a.tags})),this._mintGroup.jup.add(a.address))}),this._extraTokenList.forEach(a=>{this._blackTokenMap.has(a.address)||this._tokenMap.has(a.address)||(this._tokenMap.set(a.address,q(v({},a),{type:"extra",priority:1,programId:a.programId||a.tags.includes("token-2022")?yu.toBase58():bu.toBase58()})),this._mintGroup.extra.add(a.address))}),this._tokenList=Array.from(this._tokenMap).map(a=>a[1])}get tokenList(){return this._tokenList}get tokenMap(){return this._tokenMap}get blackTokenMap(){return this._blackTokenMap}get mintGroup(){return this._mintGroup}get whiteListMap(){return this._whiteMap}async getTokenInfo(t){if(!t)throw new Error("please input mint");let n=t.toString(),o=this._tokenMap.get(n);if(o)return o;if(n.toLocaleUpperCase()==="SOL")return cn;let r=(await this.scope.api.getTokenInfo([n]))[0];if(r)return this._mintGroup.extra.add(n),this._tokenMap.set(n,q(v({},r),{priority:2})),r;let i=await this.scope.connection.getAccountInfo(new xf(n));if(!i)throw new Error(`mint address not found: ${n}`);let s=Kf.decode(i.data),u=n.toString().substring(0,6),a={chainId:101,address:n,programId:i.owner.toBase58(),logoURI:"",symbol:u,name:u,decimals:s.decimals,tags:[],extensions:{},priority:0,type:"unknown"};return this._mintGroup.extra.add(n),this._tokenMap.set(n,a),a}};var ms=class{constructor(e){this.rawBalances=new Map;let{connection:t,cluster:n,owner:o,api:r,defaultChainTime:i,defaultChainTimeOffset:s,apiCacheTime:u,blockhashCommitment:a="confirmed",loopMultiTxStatus:c}=e;this._connection=t,this.cluster=n||"mainnet",this._owner=o?new Ft(o):void 0,this._signAllTransactions=e.signAllTransactions,this.blockhashCommitment=a,this.loopMultiTxStatus=c,this.api=r,this._apiCacheTime=u||5*60*1e3,this.logger=be("Raydium"),this.farm=new wi({scope:this,moduleName:"Raydium_Farm"}),this.account=new mi({scope:this,moduleName:"Raydium_Account",tokenAccounts:e.tokenAccounts,tokenAccountRawInfos:e.tokenAccountRawInfos}),this.liquidity=new vi({scope:this,moduleName:"Raydium_LiquidityV2"}),this.token=new rr({scope:this,moduleName:"Raydium_tokenV2"}),this.tradeV2=new Qi({scope:this,moduleName:"Raydium_tradeV2"}),this.clmm=new _i({scope:this,moduleName:"Raydium_clmm"}),this.cpmm=new Gi({scope:this,moduleName:"Raydium_cpmm"}),this.utils1216=new Ht({scope:this,moduleName:"Raydium_utils1216"}),this.marketV2=new Do({scope:this,moduleName:"Raydium_marketV2"}),this.ido=new Xo({scope:this,moduleName:"Raydium_ido"}),this.launchpad=new ir({scope:this,moduleName:"Raydium_lauchpad"}),this.availability={};let m=new Date().getTime();this.apiData={},s&&(this._chainTime={fetched:m,value:{chainTime:i||Date.now()-s,offset:s}})}static async load(e){var c;let t=Sf({cluster:"mainnet",owner:null,apiRequestInterval:3e5,apiRequestTimeout:1e4},e),{cluster:n,apiRequestTimeout:o,logCount:r,logRequests:i,urlConfigs:s}=t,u=new Br({cluster:n,timeout:o,urlConfigs:s,logCount:r,logRequests:i}),a=new ms(q(v({},t),{api:u}));return await a.fetchAvailabilityStatus((c=e.disableFeatureCheck)!=null?c:!0),e.disableLoadToken||await a.token.load({type:e.jupTokenType}),a}get owner(){return this._owner}get ownerPubKey(){if(!this._owner)throw new Error(xr);return this._owner.publicKey}setOwner(e){return this._owner=e?new Ft(e):void 0,this.account.resetTokenAccounts(),this}get connection(){if(!this._connection)throw new Error(ju);return this._connection}setConnection(e){return this._connection=e,this}get signAllTransactions(){return this._signAllTransactions}setSignAllTransactions(e){return this._signAllTransactions=e,this}checkOwner(){if(!this.owner)throw console.error(xr),new Error(xr)}isCacheInvalidate(e){return new Date().getTime()-e>this._apiCacheTime}async fetchChainTime(){try{let e=await this.api.getChainTimeOffset();this._chainTime={fetched:Date.now(),value:{chainTime:Date.now()+e.offset*1e3,offset:e.offset*1e3}}}catch{this._chainTime=void 0}}async fetchV3TokenList(e){if(this.apiData.tokenList&&!this.isCacheInvalidate(this.apiData.tokenList.fetched)&&!e)return this.apiData.tokenList.data;try{let t=await this.api.getTokenList(),n={fetched:Date.now(),data:t};return this.apiData.tokenList=n,n.data}catch(t){return console.error(t),{mintList:[],blacklist:[],whiteList:[]}}}async fetchJupTokenList(e){if(this.cluster==="devnet")return[];let t=this.apiData.jupTokenList;if(t&&!this.isCacheInvalidate(t.fetched)&&!e)return t.data;try{let n=await this.api.getJupTokenList();return this.apiData.jupTokenList={fetched:Date.now(),data:n.map(o=>q(v({},o),{mintAuthority:o.mint_authority||void 0,freezeAuthority:o.freeze_authority||void 0}))},this.apiData.jupTokenList.data}catch(n){return console.error(n),[]}}get chainTimeData(){var e;return(e=this._chainTime)==null?void 0:e.value}async chainTimeOffset(){var e;return this._chainTime&&Date.now()-this._chainTime.fetched<=1e3*60*5?this._chainTime.value.offset:(await this.fetchChainTime(),((e=this._chainTime)==null?void 0:e.value.offset)||0)}async currentBlockChainTime(){var e;return this._chainTime&&Date.now()-this._chainTime.fetched<=1e3*60*5?this._chainTime.value.chainTime:(await this.fetchChainTime(),((e=this._chainTime)==null?void 0:e.value.chainTime)||Date.now())}async fetchEpochInfo(){return this._epochInfo&&Date.now()-this._epochInfo.fetched<=1e3*30?this._epochInfo.value:(this._epochInfo={fetched:Date.now(),value:await this.connection.getEpochInfo()},this._epochInfo.value)}async fetchAvailabilityStatus(e){if(e)return{};try{let t=await this.api.fetchAvailabilityStatus(),n=t.all===!1;return this.availability={all:t.all,swap:n?!1:t.swap,createConcentratedPosition:n?!1:t.createConcentratedPosition,addConcentratedPosition:n?!1:t.addConcentratedPosition,addStandardPosition:n?!1:t.addStandardPosition,removeConcentratedPosition:n?!1:t.removeConcentratedPosition,removeStandardPosition:n?!1:t.removeStandardPosition,addFarm:n?!1:t.addFarm,removeFarm:n?!1:t.removeFarm},t}catch{return{}}}};var YL=l=>l;export{np as AMM_CONFIG_SEED,bf as AUTH_SEED,Mc as BIT_PRECISION,au as BondingCurveParam,gf as CONFIG_SEED,wf as CREATOR_FEE_VAULT_AUTH_SEED,_i as Clmm,Hc as ClmmConfigLayout,Re as ClmmInstrument,Ei as ConstantProductCurve,Ol as CpmmConfigInfoLayout,ql as CpmmCreatorFeeOn,Ot as CpmmFee,Ex as CpmmPermission,Zr as CpmmPoolInfoLayout,Dt as Curve,Jn as CurveBase,Wi as CurveCalculator,Tk as DEV_FARM_LOCK_MINT,hk as DEV_FARM_LOCK_VAULT,Ip as DataElement,ha as EXTENSION_TICKARRAY_BITMAP_SIZE,kc as FARM_LOCK_MINT,wc as FARM_LOCK_VAULT,Gt as FARM_PROGRAM_TO_VERSION,hc as FARM_VERSION_TO_LEDGER_LAYOUT,Tc as FARM_VERSION_TO_STATE_LAYOUT,_r as FEE_RATE_DENOMINATOR,cp as FETCH_TICKARRAY_COUNT,tp as Fee,Nl as FeeOn,us as FixedPriceCurve,qr as LIQUIDITY_FEES_DENOMINATOR,Ka as LIQUIDITY_FEES_NUMERATOR,Pp as LIQUIDITY_VERSION_TO_SERUM_VERSION,Gh as LIQUIDITY_VERSION_TO_STATE_LAYOUT,of as LOCK_LIQUIDITY_SEED,vc as LOG_B_2_X32,Fc as LOG_B_P_ERR_MARGIN_LOWER_X64,_c as LOG_B_P_ERR_MARGIN_UPPER_X64,ss as LaunchConstantProductCurve,Nn as LaunchpadConfig,jt as LaunchpadPool,To as LaunchpadPoolInitParam,SC as LaunchpadVesting,ls as LinearPriceCurve,Ae as LiquidityMath,Zc as LockClPositionLayoutV2,nh as LockPositionLayout,Wa as MARKET_STATE_LAYOUT_V2,Qa as MARKET_STATE_LAYOUT_V3,Fl as MARKET_VERSION_TO_STATE_LAYOUT,Yt as MAX_SQRT_PRICE_X64,Fr as MAX_SQRT_PRICE_X64_SUB_ONE,ht as MAX_TICK,zt as MIN_SQRT_PRICE_X64,vr as MIN_SQRT_PRICE_X64_ADD_ONE,bt as MIN_TICK,es as Market,tr as MathLaunch,me as MathUtil,Ti as MaxU64,Nc as MaxUint128,In as NEGATIVE_ONE,ap as OBSERVATION_SEED,Vt as ONE,rp as OPERATION_SEED,jc as ObservationInfoLayout,dp as ObservationLayout,$c as OperationLayout,kf as PLATFORM_FEE_VAULT_AUTH_SEED,Af as PLATFORM_SEED,Xc as POOL_LOCK_ID_SEED,op as POOL_REWARD_VAULT_SEED,ga as POOL_SEED,sp as POOL_TICK_ARRAY_BITMAP_SEED,Pa as POOL_VAULT_SEED,Pf as POOL_VESTING_SEED,Dc as POSITION_SEED,ko as PlatformConfig,If as PlatformCurveParam,co as PoolInfoLayout,ve as PoolUtils,_o as PositionInfoLayout,fp as PositionRewardInfoLayout,xi as PositionUtils,th as ProtocolPositionLayout,Mr as Q128,nt as Q64,ms as Raydium,pp as RewardInfo,Tl as RoundDirection,Ml as SERUM_PROGRAMID_TO_VERSION,vl as SERUM_VERSION_TO_PROGRAMID,cn as SOL_INFO,nl as SPL_MINT_LAYOUT,up as SUPPORT_MINT_SEED,ue as SqrtPriceMath,Wo as StableLayout,uo as SwapMath,ao as TICK_ARRAY_BITMAP_SIZE,ip as TICK_ARRAY_SEED,ot as TICK_ARRAY_SIZE,Fw as TICK_SPACINGS,it as TOKEN_WSOL,xn as TickArrayBitmap,Qc as TickArrayBitmapExtensionLayout,Si as TickArrayBitmapExtensionUtils,Ki as TickArrayLayout,yp as TickLayout,lo as TickMath,we as TickQuery,J as TickUtils,zp as TradeDirection,Yp as TradeDirectionOpposite,hi as U64Resolution,Vw as U64_IGNORE_RANGE,hf as VestingSchedule,Ac as Voter,Ed as VoterDepositEntry,Vd as VoterLockup,Pc as VoterRegistrar,_d as VoterVotingMintConfig,ge as ZERO,La as addLiquidityLayout,kt as anchorDataBuf,$s as associatedLedgerAccountLayout,cu as buyExactInInstruction,zl as buyExactOutInstruction,ma as calFarmRewardAmount,rR as checkPoolToAmm,fu as claimCreatorFee,Hi as claimLayout,du as claimPlatformFee,pu as claimPlatformFeeFromVault,lu as claimVestedToken,Yc as clmmComputeInfoToApiInfo,hn as closeAccountInstruction,za as collectCpFeeInstruction,af as cpmmLockPositionInstruction,gi as createAssociatedLedgerAccountInstruction,Hl as createPlatformConfig,rl as createPoolFeeLayout,Ma as createPoolV4InstructionV2,Uh as createPoolV4Layout,mu as createVestingAccount,Un as createWSolAccountInstructions,Tt as dwLayout,ta as farmAddRewardLayout,mk as farmLedgerLayoutV3_1,pi as farmLedgerLayoutV3_2,dk as farmLedgerLayoutV5_1,bc as farmLedgerLayoutV5_2,gc as farmLedgerLayoutV6_1,Bc as farmRewardInfoToConfig,Js as farmRewardLayout,ea as farmRewardRestartLayout,Fd as farmRewardTimeInfoLayout,fc as farmStateV3Layout,yc as farmStateV5Layout,di as farmStateV6Layout,Wk as fetchMultipleFarmInfoAndUpdate,CI as fetchMultipleInfo,Sa as fixedSwapInLayout,Ca as fixedSwapOutLayout,Mp as formatLayout,He as generatePubKey,Ic as getAssociatedAuthority,Xr as getAssociatedConfigId,yt as getAssociatedLedgerAccount,yi as getAssociatedLedgerPoolAccount,Vp as getAssociatedOpenOrders,Ea as getAssociatedPoolKeys,qi as getCpLockPda,xx as getCpmmPdaAmmConfigId,qa as getCpmmPdaPoolId,Ua as getCreatePoolKeys,da as getDepositEntryIndex,pl as getDxByDyBaseIn,dl as getDyByDxBaseIn,Mo as getFarmLedgerLayout,Dd as getFarmStateLayout,Va as getLiquidityAssociatedAuthority,yo as getLiquidityAssociatedId,LT as getLiquidityFromAmounts,Xw as getPdaAmmConfigId,jn as getPdaCpiEvent,su as getPdaCreatorFeeVaultAuth,Zn as getPdaCreatorVault,je as getPdaExBitmapAccount,sn as getPdaLaunchpadAuth,BC as getPdaLaunchpadConfigId,Ao as getPdaLaunchpadPoolId,ou as getPdaLaunchpadVaultId,Fo as getPdaLockClPositionIdV2,ka as getPdaLockPositionId,tf as getPdaLpMint,Bn as getPdaMetadataKey,wa as getPdaMintExAccount,Gc as getPdaObservationAccount,Di as getPdaObservationId,Bi as getPdaOperationAccount,Bl as getPdaPermissionId,It as getPdaPersonalPositionAddress,ru as getPdaPlatformFeeVaultAuth,iu as getPdaPlatformId,$n as getPdaPlatformVault,qo as getPdaPoolAuthority,qc as getPdaPoolId,Uc as getPdaPoolRewardVaulId,Aa as getPdaPoolVaultId,rn as getPdaProtocolPositionAddress,Pe as getPdaTickArrayAddress,Il as getPdaVault,$i as getPdaVestId,ra as getRegistrarAddress,fl as getStablePrice,la as getTokenOwnerRecordAddress,ua as getVoterAddress,ca as getVoterWeightRecordAddress,aa as getVotingMintAuthority,sa as getVotingTokenMint,jd as governanceCreateTokenOwnerRecord,Ww as i16ToBytes,Er as i32ToBytes,Ra as initPoolLayout,Hs as initTokenAccountInstruction,WC as initialize,qp as initializeMarket,Gl as initializeV2,Ll as initializeWithPermission,Xl as initializeWithToken2022,oa as isValidFarmVersion,Ii as isZero,Dk as judgeFarmType,ya as leadingZeros,Wc as leastSignificantBit,mo as liquidityStateV4Layout,Ap as liquidityStateV5Layout,Ur as makeAMMSwapInstruction,ul as makeAddLiquidityInstruction,fa as makeAddNewRewardInstruction,os as makeClaimInstruction,nu as makeClaimInstructionV4,Ya as makeCollectCreatorFeeInstruction,Rl as makeCpmmLockInstruction,xl as makeCreateCpmmPoolInInstruction,xc as makeCreateFarmInstruction,Yr as makeCreateMarketInstruction,Kc as makeCreatorWithdrawFarmRewardInstruction,Kl as makeDepositCpmmInInstruction,Cc as makeDepositInstructionV3,Rc as makeDepositInstructionV5,Lc as makeDepositInstructionV6,ow as makeDepositTokenInstruction,rw as makeDepositWithdrawInstruction,nI as makeInitPoolInstructionV4,rC as makePurchaseInstruction,pa as makeRestartRewardInstruction,cl as makeSimulatePoolInfoInstruction,$r as makeSwapCpmmBaseInInstruction,Cl as makeSwapCpmmBaseOutInstruction,Tp as makeSwapFixedInInstruction,hp as makeSwapFixedOutInstruction,Vl as makeSwapInstruction,pc as makeTransferInstruction,Sl as makeWithdrawCpmmInInstruction,ki as makeWithdrawInstructionV3,Sc as makeWithdrawInstructionV4,Ai as makeWithdrawInstructionV5,Pi as makeWithdrawInstructionV6,iw as makeWithdrawTokenInstruction,_w as mockCreatePoolInfo,Vc as mockV3CreatePoolInfo,Bp as modelDataInfoLayout,Ec as mostSignificantBit,dc as parseTokenAccountResp,Ch as parseTokenInfo,Xn as poolTypeV6,Ja as purchaseLayout,Nd as realFarmStateV3Layout,Md as realFarmStateV5Layout,vd as realFarmV6Layout,Na as removeLiquidityInstruction,Oa as removeLiquidityLayout,qC as removePlatformCurveParamInstruction,cS as route1Instruction,lS as route2Instruction,lf as routeInstruction,Yl as sellExactInInstruction,Ql as sellExactOut,tI as simulatePoolInfoInstruction,Lh as solToWSolToken,on as splAccountLayout,mS as swapBaseInAutoAccount,dS as swapBaseOutAutoAccount,zr as toAmmComputePoolInfo,gt as toApiV3Token,zn as toFeeConfig,Dr as toToken,Ri as toTokenAmount,Rh as toTokenInfo,ba as trailingZeros,Vr as u16ToBytes,Dw as u32ToBytes,Tf as u8ToBytes,YL as unionArr,qd as updateFarmPoolInfo,jl as updatePlatformConfig,DC as updatePlatformCurveParamInstruction,ia as validateFarmRewards,Zd as voterStakeRegistryCreateDepositEntry,$d as voterStakeRegistryCreateVoter,Yd as voterStakeRegistryDeposit,Qd as voterStakeRegistryUpdateVoterWeightRecord,Hd as voterStakeRegistryWithdraw,Oh as wSolToSolToken,Zs as withdrawRewardLayout};
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
//# sourceMappingURL=index.mjs.map