var tm=Object.defineProperty,nm=Object.defineProperties;var om=Object.getOwnPropertyDescriptors;var rr=Object.getOwnPropertySymbols;var xu=Object.prototype.hasOwnProperty,Ku=Object.prototype.propertyIsEnumerable;var Bu=(l,e,t)=>e in l?tm(l,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):l[e]=t,M=(l,e)=>{for(var t in e||(e={}))xu.call(e,t)&&Bu(l,t,e[t]);if(rr)for(var t of rr(e))Ku.call(e,t)&&Bu(l,t,e[t]);return l},q=(l,e)=>nm(l,om(e));var Fe=(l,e)=>{var t={};for(var n in l)xu.call(l,n)&&e.indexOf(n)<0&&(t[n]=l[n]);if(l!=null&&rr)for(var n of rr(l))e.indexOf(n)<0&&Ku.call(l,n)&&(t[n]=l[n]);return t};import{merge as Sf}from"lodash";import Qu from"axios";import{PublicKey as Ru}from"@solana/web3.js";import{get as Su,set as im}from"lodash";var fs=class{constructor(e){this.logLevel=e.logLevel!==void 0?e.logLevel:0,this.name=e.name}set level(e){this.logLevel=e}get time(){return Date.now().toString()}get moduleName(){return this.name}isLogLevel(e){return e<=this.logLevel}error(...e){return this.isLogLevel(0)?(console.error(this.time,this.name,"sdk logger error",...e),this):this}logWithError(...e){let t=e.map(n=>typeof n=="object"?JSON.stringify(n):n).join(", ");throw new Error(t)}warning(...e){return this.isLogLevel(1)?(console.warn(this.time,this.name,"sdk logger warning",...e),this):this}info(...e){return this.isLogLevel(2)?(console.info(this.time,this.name,"sdk logger info",...e),this):this}debug(...e){return this.isLogLevel(3)?(console.debug(this.time,this.name,"sdk logger debug",...e),this):this}},Cu={},rm={};function ye(l){let e=Su(Cu,l);if(!e){let t=Su(rm,l);e=new fs({name:l,logLevel:t}),im(Cu,l,e)}return e}import{MINT_SIZE as sm,TOKEN_PROGRAM_ID as am,getTransferFeeConfig as um,unpackMint as cm}from"@solana/spl-token";var ys=ye("Raydium_accountInfo_util");async function Zt(l,e,t){let{batchRequest:n,commitment:o="confirmed",chunkCount:r=100}=M({batchRequest:!1},t),i=bs(e,r),s=new Array(i.length).fill([]);if(n){let u=i.map(m=>{let p=l._buildArgs([m.map(d=>d.toBase58())],o,"base64");return{methodName:"getMultipleAccounts",args:p}}),a=bs(u,10);s=(await(await Promise.all(a.map(async m=>await l._rpcBatchRequest(m)))).flat()).map(m=>(m.error&&ys.logWithError(`failed to get info for multiple accounts, RPC_ERROR, ${m.error.message}`),m.result.value.map(p=>{if(p){let{data:d,executable:f,lamports:y,owner:b,rentEpoch:g}=p;return d.length!==2&&d[1]!=="base64"&&ys.logWithError("info must be base64 encoded, RPC_ERROR"),{data:Buffer.from(d[0],"base64"),executable:f,lamports:y,owner:new Ru(b),rentEpoch:g}}return null})))}else try{s=await Promise.all(i.map(u=>l.getMultipleAccountsInfo(u,o)))}catch(u){u instanceof Error&&ys.logWithError(`failed to get info for multiple accounts, RPC_ERROR, ${u.message}`)}return s.flat()}async function Ne(l,e,t){let n=await Zt(l,e.map(o=>o.pubkey),t);return e.map((o,r)=>q(M({},o),{accountInfo:n[r]}))}async function Io({connection:l,mints:e,config:t}){var r,i,s;if(e.length===0)return{};let n=await Ne(l,e.map(u=>({pubkey:dt(u)})),t),o={};for(let u of n){if(!u.accountInfo||u.accountInfo.data.length<sm){console.log("invalid mint account",u.pubkey.toBase58());continue}let a=cm(u.pubkey,u.accountInfo,(r=u.accountInfo)==null?void 0:r.owner);o[u.pubkey.toString()]=q(M({},a),{programId:((i=u.accountInfo)==null?void 0:i.owner)||am,feeConfig:(s=um(a))!=null?s:void 0})}return o[Ru.default.toBase58()]=o[$.toBase58()],o}import un from"bn.js";import ub from"decimal.js";import gm from"big.js";import ur from"bn.js";import lm from"toformat";var mm=lm,Ho=mm;import ar from"big.js";import pm from"bn.js";import fm from"decimal.js-light";import jo from"bn.js";var Lu=9007199254740991;function J(l){let e=ye("Raydium_parseBigNumberish");if(l instanceof jo)return l;if(typeof l=="string"){if(l.match(/^-?[0-9]+$/))return new jo(l);e.logWithError(`invalid BigNumberish string: ${l}`)}return typeof l=="number"?(l%1&&e.logWithError(`BigNumberish number underflow: ${l}`),(l>=Lu||l<=-Lu)&&e.logWithError(`BigNumberish number overflow: ${l}`),new jo(String(l))):typeof l=="bigint"?new jo(l.toString()):(e.error(`invalid BigNumberish value: ${l}`),new jo(0))}var sr=ye("module/fraction"),gs=Ho(ar),$o=Ho(fm),ym={[0]:$o.ROUND_DOWN,[1]:$o.ROUND_HALF_UP,[2]:$o.ROUND_UP},bm={[0]:ar.roundDown,[1]:ar.roundHalfUp,[2]:ar.roundUp},he=class{constructor(e,t=new pm(1)){this.numerator=J(e),this.denominator=J(t)}get quotient(){return this.numerator.div(this.denominator)}invert(){return new he(this.denominator,this.numerator)}add(e){let t=e instanceof he?e:new he(J(e));return this.denominator.eq(t.denominator)?new he(this.numerator.add(t.numerator),this.denominator):new he(this.numerator.mul(t.denominator).add(t.numerator.mul(this.denominator)),this.denominator.mul(t.denominator))}sub(e){let t=e instanceof he?e:new he(J(e));return this.denominator.eq(t.denominator)?new he(this.numerator.sub(t.numerator),this.denominator):new he(this.numerator.mul(t.denominator).sub(t.numerator.mul(this.denominator)),this.denominator.mul(t.denominator))}mul(e){let t=e instanceof he?e:new he(J(e));return new he(this.numerator.mul(t.numerator),this.denominator.mul(t.denominator))}div(e){let t=e instanceof he?e:new he(J(e));return new he(this.numerator.mul(t.denominator),this.denominator.mul(t.numerator))}toSignificant(e,t={groupSeparator:""},n=1){Number.isInteger(e)||sr.logWithError(`${e} is not an integer.`),e<=0&&sr.logWithError(`${e} is not positive.`),$o.set({precision:e+1,rounding:ym[n]});let o=new $o(this.numerator.toString()).div(this.denominator.toString()).toSignificantDigits(e);return o.toFormat(o.decimalPlaces(),t)}toFixed(e,t={groupSeparator:""},n=1){return Number.isInteger(e)||sr.logWithError(`${e} is not an integer.`),e<0&&sr.logWithError(`${e} is negative.`),gs.DP=e,gs.RM=bm[n]||1,new gs(this.numerator.toString()).div(this.denominator.toString()).toFormat(e,t)}isZero(){return this.numerator.isZero()}};var Pm=ye("Raydium_amount"),Ou=Ho(gm);function Am(l,e){let t="0",n="0";if(l.includes(".")){let o=l.split(".");o.length===2?([t,n]=o,n=n.padEnd(e,"0")):Pm.logWithError(`invalid number string, num: ${l}`)}else t=l;return[t,n.slice(0,e)||n]}var xe=class extends he{constructor(t,n,o=!0,r){let i=new ur(0),s=Ps.pow(new ur(t.decimals));if(o)i=J(n);else{let u=new ur(0),a=new ur(0);if(typeof n=="string"||typeof n=="number"||typeof n=="bigint"){let[c,m]=Am(n.toString(),t.decimals);u=J(c),a=J(m)}u=u.mul(s),i=u.add(a)}super(i,s);this.logger=ye(r||"TokenAmount"),this.token=t}get raw(){return this.numerator}isZero(){return this.raw.isZero()}gt(t){return this.token.equals(t.token)||this.logger.logWithError("gt token not equals"),this.raw.gt(t.raw)}lt(t){return this.token.equals(t.token)||this.logger.logWithError("lt token not equals"),this.raw.lt(t.raw)}add(t){return this.token.equals(t.token)||this.logger.logWithError("add token not equals"),new xe(this.token,this.raw.add(t.raw))}subtract(t){return this.token.equals(t.token)||this.logger.logWithError("sub token not equals"),new xe(this.token,this.raw.sub(t.raw))}toSignificant(t=this.token.decimals,n,o=0){return super.toSignificant(t,n,o)}toFixed(t=this.token.decimals,n,o=0){return t>this.token.decimals&&this.logger.logWithError("decimals overflow"),super.toFixed(t,n,o)}toExact(t={groupSeparator:""}){return Ou.DP=this.token.decimals,new Ou(this.numerator.toString()).div(this.denominator.toString()).toFormat(t)}};import{PublicKey as km}from"@solana/web3.js";import{TOKEN_PROGRAM_ID as Nu}from"@solana/spl-token";var sn={chainId:101,address:km.default.toBase58(),programId:Nu.toBase58(),decimals:9,symbol:"SOL",name:"solana",logoURI:"https://img-v1.raydium.io/icon/So11111111111111111111111111111111111111112.png",tags:[],priority:2,type:"raydium",extensions:{coingeckoId:"solana"}},it={chainId:101,address:"So11111111111111111111111111111111111111112",programId:Nu.toBase58(),decimals:9,symbol:"WSOL",name:"Wrapped SOL",logoURI:"https://img-v1.raydium.io/icon/So11111111111111111111111111111111111111112.png",tags:[],priority:2,type:"raydium",extensions:{coingeckoId:"solana"}};import{PublicKey as hs}from"@solana/web3.js";import{PublicKey as Ue,SystemProgram as Mu,SYSVAR_RENT_PUBKEY as wm}from"@solana/web3.js";import{TOKEN_PROGRAM_ID as Tm}from"@solana/spl-token";function k({pubkey:l,isSigner:e=!1,isWritable:t=!0}){return{pubkey:l,isWritable:t,isSigner:e}}var As=[k({pubkey:Tm,isWritable:!1}),k({pubkey:Mu.programId,isWritable:!1}),k({pubkey:wm,isWritable:!1})];function ks({publicKey:l,transformSol:e}){let t=ws(l.toString());if(t instanceof Ue)return e&&t.equals(rt)?$:t;if(e&&t.toString()===rt.toBase58())return $;if(typeof t=="string"){if(t===Ue.default.toBase58())return Ue.default;try{return new Ue(t)}catch{throw new Error("invalid public key")}}throw new Error("invalid public key")}function ws(l){try{return new Ue(l)}catch{return l}}var cr=new Ue("MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr"),an=new Ue("MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr"),$e=new Ue("SysvarRent111111111111111111111111111111111"),Ts=new Ue("SysvarC1ock11111111111111111111111111111111"),Dt=new Ue("metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s"),lr=new Ue("Sysvar1nstructions1111111111111111111111111"),mr=Mu.programId,gy=new Ue("4k3Dyjzvzp8eMZWUXbBCjEvwSkkk59S5iCNLY3QrkX6R"),Py=new Ue("Ea5SjE2Y6yvCeW5dYTn7PYMuW5ikXkvbGdcmSnXeaLjS"),Ay=new Ue("SRMuApVNdxXokk5GT7XD5cUUgXMBCoAz2LHeuAoKWRt"),ky=new Ue("EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v"),wy=new Ue("Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB"),Ty=new Ue("mSoLzYCxHdYgdzU16g5QSh3i5K3z3KZK7ytfqcJm7So"),hy=new Ue("7dHbWXmci3dT8UFYWYZweBLXgycu7Y3iL6trKn1Y7ARj"),Iy=new Ue("USDH1SM1ojwWUga67PGrgFWUHibbjqMvuMaDkRJTgkX"),By=new Ue("NRVwhjBQiUPYtfDT5zRBVJajzFQHaBUNtC7SNVvqRFa"),xy=new Ue("ANAxByE6G2WjFp7A4NqtWYXb3mgruyzZYg3spfxe6Lbo"),Ky=new Ue("7vfCXTUXx5WJV5JADk17DUJ4ksgau7utNKj4b963voxs"),$=new Ue("So11111111111111111111111111111111111111112"),rt=Ue.default;function dt(l){return ks({publicKey:l,transformSol:!0})}var Is=class{constructor({mint:e,decimals:t,symbol:n,name:o,skipMint:r=!1,isToken2022:i=!1}){if(e===rt.toBase58()||e instanceof hs&&rt.equals(e)){this.decimals=it.decimals,this.symbol=it.symbol,this.name=it.name,this.mint=new hs(it.address),this.isToken2022=!1;return}this.decimals=t,this.symbol=n||e.toString().substring(0,6),this.name=o||e.toString().substring(0,6),this.mint=r?hs.default:ks({publicKey:e}),this.isToken2022=i}equals(e){return this===e?!0:this.mint.equals(e.mint)}},Ge=Is;Ge.WSOL=new Is(q(M({},it),{mint:it.address}));var Bs=class{constructor({decimals:e,symbol:t="UNKNOWN",name:n="UNKNOWN"}){this.decimals=e,this.symbol=t,this.name=n}equals(e){return this===e}},dr=Bs;dr.SOL=new Bs(sn);import hm from"bn.js";var vu=new he(new hm(100)),st=class extends he{toSignificant(e=5,t,n){return this.mul(vu).toSignificant(e,t,n)}toFixed(e=2,t,n){return this.mul(vu).toFixed(e,t,n)}};var Im=ye("Raydium_price"),Bt=class extends he{constructor(t){let{baseToken:n,quoteToken:o,numerator:r,denominator:i}=t;super(r,i);this.baseToken=n,this.quoteToken=o,this.scalar=new he(xs(n.decimals),xs(o.decimals))}get raw(){return new he(this.numerator,this.denominator)}get adjusted(){return super.mul(this.scalar)}invert(){return new Bt({baseToken:this.quoteToken,quoteToken:this.baseToken,denominator:this.numerator,numerator:this.denominator})}mul(t){this.quoteToken!==t.baseToken&&Im.logWithError("mul token not equals");let n=super.mul(t);return new Bt({baseToken:this.baseToken,quoteToken:t.quoteToken,denominator:n.denominator,numerator:n.numerator})}toSignificant(t=this.quoteToken.decimals,n,o){return this.adjusted.toSignificant(t,n,o)}toFixed(t=this.quoteToken.decimals,n,o){return this.adjusted.toFixed(t,n,o)}};var xt=new un(0),Fu=new un(1),gb=new un(2),Pb=new un(3),Ab=new un(5),Ps=new un(10),kb=new un(100),wb=new un(1e3),Tb=new un(1e4);function xs(l){return Ps.pow(J(l))}function pr(l,e){let t=l.divmod(e);return t.mod.isZero()?t.div:t.div.isNeg()?t.div.isubn(1):t.div.iaddn(1)}function Zo(l,e,t){return l.mul(e).add(t).sub(new un(1)).div(t)}function fr(l,e,t){return l.mul(e).div(t)}var Vu=l=>typeof l=="number";function _u(l,e,t){let n=Vu(e)?e*((t==null?void 0:t.unit)==="s"?1e3:1):e;return new Date(l).getTime()<=n}function Eu(l,e,t){let n=Vu(e)?e*((t==null?void 0:t.unit)==="s"?1e3:1):e;return new Date(l).getTime()>n}function bs(l,e=1,t=[]){let n=[...l];if(e<=0)return t;for(;n.length;)t.push(n.splice(0,e));return t}var vt=class{constructor(e){this._owner=e}get publicKey(){return vt.isKeyPair(this._owner)?this._owner.publicKey:this._owner}get signer(){return vt.isKeyPair(this._owner)?this._owner:void 0}get isKeyPair(){return vt.isKeyPair(this._owner)}get isPublicKey(){return vt.isPublicKey(this._owner)}static isKeyPair(e){return e.secretKey!==void 0}static isPublicKey(e){return!vt.isKeyPair(e)}};import{PublicKey as Rm}from"@solana/web3.js";import{TOKEN_PROGRAM_ID as Lm}from"@solana/spl-token";import{ComputeBudgetProgram as Wu,Keypair as Du,PublicKey as qu,Transaction as yr,TransactionMessage as Bm,VersionedTransaction as Uu}from"@solana/web3.js";var G={CreateAccount:"CreateAccount",InitAccount:"InitAccount",CreateATA:"CreateATA",CloseAccount:"CloseAccount",TransferAmount:"TransferAmount",InitMint:"InitMint",MintTo:"MintTo",InitMarket:"InitMarket",Util1216OwnerClaim:"Util1216OwnerClaim",SetComputeUnitPrice:"SetComputeUnitPrice",SetComputeUnitLimit:"SetComputeUnitLimit",ClmmCreatePool:"ClmmCreatePool",ClmmOpenPosition:"ClmmOpenPosition",ClmmIncreasePosition:"ClmmIncreasePosition",ClmmDecreasePosition:"ClmmDecreasePosition",ClmmClosePosition:"ClmmClosePosition",ClmmSwapBaseIn:"ClmmSwapBaseIn",ClmmSwapBaseOut:"ClmmSwapBaseOut",ClmmInitReward:"ClmmInitReward",ClmmSetReward:"ClmmSetReward",ClmmCollectReward:"ClmmCollectReward",ClmmLockPosition:"ClmmLockPosition",ClmmHarvestLockPosition:"ClmmHarvestLockPosition",AmmV4Swap:"AmmV4Swap",AmmV4AddLiquidity:"AmmV4AddLiquidity",AmmV4RemoveLiquidity:"AmmV4RemoveLiquidity",AmmV4SimulatePoolInfo:"AmmV4SimulatePoolInfo",AmmV4SwapBaseIn:"AmmV4SwapBaseIn",AmmV4SwapBaseOut:"AmmV4SwapBaseOut",AmmV4CreatePool:"AmmV4CreatePool",AmmV4InitPool:"AmmV4InitPool",AmmV5AddLiquidity:"AmmV5AddLiquidity",AmmV5RemoveLiquidity:"AmmV5RemoveLiquidity",AmmV5SimulatePoolInfo:"AmmV5SimulatePoolInfo",AmmV5SwapBaseIn:"AmmV5SwapBaseIn",AmmV5SwapBaseOut:"AmmV5SwapBaseOut",RouteSwap:"RouteSwap",RouteSwap1:"RouteSwap1",RouteSwap2:"RouteSwap2",FarmV3Deposit:"FarmV3Deposit",FarmV3Withdraw:"FarmV3Withdraw",FarmV3CreateLedger:"FarmV3CreateLedger",FarmV4Withdraw:"FarmV4Withdraw",FarmV5Deposit:"FarmV5Deposit",FarmV5Withdraw:"FarmV5Withdraw",FarmV5CreateLedger:"FarmV5CreateLedger",FarmV6Deposit:"FarmV6Deposit",FarmV6Withdraw:"FarmV6Withdraw",FarmV6Create:"FarmV6Create",FarmV6Restart:"FarmV6Restart",FarmV6CreatorAddReward:"FarmV6CreatorAddReward",FarmV6CreatorWithdraw:"FarmV6CreatorWithdraw",CpmmCreatePool:"CpmmCreatePool",CpmmAddLiquidity:"CpmmAddLiquidity",CpmmWithdrawLiquidity:"CpmmWithdrawLiquidity",CpmmSwapBaseIn:"CpmmSwapBaseIn",CpmmSwapBaseOut:"CpmmSwapBaseOut",CpmmLockLp:"CpmmLockLp",CpmmCollectLockFee:"CpmmCollectLockFee",TransferTip:"TransferTip"};import{TOKEN_PROGRAM_ID as xm}from"@solana/spl-token";var fn=ye("Raydium_txUtil"),Gu=1644;function Jo(l){let e=[],t=[];return l.microLamports&&(e.push(Wu.setComputeUnitPrice({microLamports:l.microLamports})),t.push(G.SetComputeUnitPrice)),l.units&&(e.push(Wu.setComputeUnitLimit({units:l.units})),t.push(G.SetComputeUnitLimit)),{instructions:e,instructionTypes:t}}async function Zn(l,e){var n,o;let t=e!=null?e:"confirmed";return(o=await((n=l.getLatestBlockhash)==null?void 0:n.call(l,{commitment:t})))==null?void 0:o.blockhash}async function ei(l,e){return l.getSignatureStatuses([e]),new Promise((t,n)=>{let o=setTimeout(n,6e4);l.onSignature(e,r=>{if(clearTimeout(o),!r.err){t("");return}n(Object.assign(r.err,{txId:e}))},"confirmed")})}function br(l,e){l.length<1&&fn.logWithError(`no instructions provided: ${l.toString()}`),e.length<1&&fn.logWithError(`no signers provided:, ${e.toString()}`);let t=new yr;t.recentBlockhash="11111111111111111111111111111111",t.feePayer=e[0],t.add(...l);try{return Buffer.from(t.serialize({verifySignatures:!1})).toString("base64").length<Gu}catch{return!1}}async function Xu(l,e,t,n=!0){let o=new qu("RaydiumSimuLateTransaction11111111111111111"),r=[],i=new yr;i.feePayer=o;for(let a of e)br([...i.instructions,a],[o])||(r.push(i),i=new yr,i.feePayer=o),i.add(a);i.instructions.length>0&&r.push(i);let s=[];try{if(s=await Km(l,r,n),s.find(a=>a.err!==null))throw Error("rpc simulateTransaction error")}catch(a){a instanceof Error&&fn.logWithError("failed to simulate for instructions","RPC_ERROR",{message:a.message})}let u=[];for(let a of s)if(fn.debug("simulate result:",a),a.logs){let c=a.logs.filter(m=>m&&m.includes(t));fn.debug("filteredLog:",u),c.length||fn.logWithError("simulate log not match keyword","keyword",t),u.push(...c)}return u}function zu(l,e){let t=l.match(/{["\w:,]+}/g);return!t||t.length!==1?fn.logWithError(`simulate log fail to match json, keyword: ${e}`):t[0]}function yn(l,e){let n=new RegExp(`"${e}":(\\d+)`,"g").exec(l);return!n||n.length!==2?fn.logWithError(`simulate log fail to match key", key: ${e}`):n[1]}function te(l,e){let[t,n]=qu.findProgramAddressSync(l,e);return{publicKey:t,nonce:n}}async function Km(l,e,t){let n=[];if(t){let o=await l.getLatestBlockhash(),r=[];for(let a of e){a.recentBlockhash=o.blockhash,a.lastValidBlockHeight=o.lastValidBlockHeight;let m=a._compile().serialize(),d=a._serialize(m).toString("base64");r.push(d)}let i=r.map(a=>{let c=l._buildArgs([a],void 0,"base64");return{methodName:"simulateTransaction",args:c}}),s=[],u=20;for(let a=0;a<Math.ceil(i.length/u);a++)s.push(i.slice(a*u,(a+1)*u));n=await(await Promise.all(s.map(async a=>(await l._rpcBatchRequest(a)).map(c=>c.result.value)))).flat()}else try{n=await Promise.all(e.map(async o=>await(await l.simulateTransaction(o)).value))}catch(o){o instanceof Error&&fn.logWithError("failed to get info for multiple accounts","RPC_ERROR",{message:o.message})}return n}function ti({instructions:l,payer:e,signers:t}){return br(l,[e,...t])}function bn({instructions:l,payer:e,lookupTableAddressAccount:t,recentBlockhash:n=Du.generate().publicKey.toString()}){let r=new Bm({payerKey:e,recentBlockhash:n,instructions:l}).compileToV0Message(Object.values(t!=null?t:{}));try{return Buffer.from(new Uu(r).serialize()).toString("base64").length<Gu}catch{return!1}}var Sm=l=>Buffer.isBuffer(l)?l:l instanceof Uint8Array?Buffer.from(l.buffer,l.byteOffset,l.byteLength):Buffer.from(l),Cm=l=>{let e=l.serialize({requireAllSignatures:!1,verifySignatures:!1});l instanceof Uu&&(e=Sm(e));try{return e instanceof Buffer?e.toString("base64"):Buffer.from(e).toString("base64")}catch{return e.toString("base64")}};function On(l){let e=[];return l.forEach(t=>{t instanceof yr&&(t.recentBlockhash||(t.recentBlockhash=xm.toBase58()),t.feePayer||(t.feePayer=Du.generate().publicKey)),e.push(Cm(t))}),console.log("simulate tx string:",e),e}function j(l,e,t){return te([l.toBuffer(),(t!=null?t:Lm).toBuffer(),e.toBuffer()],new Rm("ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL"))}import{PublicKey as ie}from"@solana/web3.js";var Ks=new ie("EhhTKczWMGQt46ynNeRX1WfeagwwJd7ufHvCDjRxjo5Q"),Ss=new ie("CBuCnLe26faBpcBP2fktp4rp8abpcAnTWft6ZrP5Q4T"),Cs=new ie("9KEPoZmtHUrBbhWN1v1KWLMkkvwY6WLtAVUCPRtRjP4z"),Bo=new ie("FarmqiPv5eAj3j1GMdMCMUGXqPUvmquZtMy86QH6rzhG"),Om=new ie("CLaimxFqjHzgTJtAGHU47NPhg6qrc5sCnpC4tBLyABQS"),Rs=new ie("srmqPvymJeFKQ4zGQed1GFppgkRHL9kaELCbyksJtPX"),gr=new ie("9xQeWvG816bUx9EPjHmaT23yvVM2ZWbrrpZb9PusVFin"),ni=new ie("675kPX9MHTjS2zt1qfr1NYHuzeLXfQM9H24wFSUt1Mp8"),Nm=new ie("5quBtoiQqxF9Jv6KYKctB59NT3gtJD2Y65kdnB1Uev3h"),Pr=new ie("CDSr3ssLcRB6XYPJwAfFt18MZvEZp4LjHcvzBVZ45duo"),Nn=new ie("CAMMCzo5YL8w4VFF8KVHrK22GGUsp5VTaW7grrKgrWqK"),xo=new ie("LockrWmn6K5twhz3y9w1dQERbmgSaRkfnTeTKbpofwE"),oi=new ie("kN1kEznaF5Xbd8LYuqtEFcxzWSBk5Fv6ygX6SqEGJVy"),Mn=new ie("CDSr3ssLcRB6XYPJwAfFt18MZvEZp4LjHcvzBVZ45duo"),Mm=new ie("routeUGWgWzqBWFcrCfv8tritsqukccJPu3q5GPP3xS"),Ls=new ie("7YttLkHDoNj9wyDur5pM1ejNaAvT9X4eqaYcHQqtj2G5"),vm=new ie("6FJon3QE27qgPVggARueB22hLvoh22VzJpXv4rBEoSLF"),Fm=new ie("CC12se5To1CdEuw7fDS27B7Geo5jJyL7t5UK2B44NgiH"),Vm=new ie("9HzJyW1qZsEiSfMUf6L2jo3CcTKAyBmSyKdwQeYisHrC"),_m=new ie("DropEU8AvevN3UrXWXTMuz3rqnMczQVNjq3kcSdW2SQi"),vn=new ie("CPMMoo8L3F4NbTegBCKVNunggL7H1ZpdTHKxQB5qKP1C"),Os=new ie("GpMZbSM2GgvTKHJirzeGfMFoaZ8UR2X7F4v8vHTvxFbL"),Em=new ie("DNXgeM9EiiaAbaWvwjHj9fQQLAX5ZsfHyvmYUNRAdNC8"),ii=new ie("LockrWmn6K5twhz3y9w1dQERbmgSaRkfnTeTKbpofwE"),ri=new ie("3f7GcQFG397GAaEnv51zR6tsTVihYRydnydDD1cXekxH"),et=new ie("LanMV9sAd7wArD4vJFi2qDdfnVhFxYSUg6eADduJ3uj"),Wm=new ie("WLHv2UAZm6z4KyaaELi5pjdbJh6RESMva1Rnn8pJVVh"),Ub=new ie("DRay6fNdQ5J82H7xV6uq2aV3mNrUZ1J4PgSKsWgptcm6"),Gb=new ie("5xqNaZXX5eUi4p5HU4oz9i5QnwRNT2y6oN7yyn4qENeq"),Dm=new ie("4Bu96XjU84XjPDSpveTVf6LYGCkfW5FK7SNkREWcEfV4"),qm=new ie("6s1xP3hpbAfFoNtUNF8mfHsjr2Bd97JxFJRWLbL6aHuX"),si={IDO_PROGRAM_ID_V1:vm,IDO_PROGRAM_ID_V2:Fm,IDO_PROGRAM_ID_V3:Vm,IDO_PROGRAM_ID_V4:_m},At={AMM_V4:ni,AMM_STABLE:Nm,CLMM_PROGRAM_ID:Nn,CLMM_LOCK_PROGRAM_ID:xo,CLMM_LOCK_AUTH_ID:oi,FARM_PROGRAM_ID_V3:Ks,FARM_PROGRAM_ID_V4:Ss,FARM_PROGRAM_ID_V5:Cs,FARM_PROGRAM_ID_V6:Bo,OPEN_BOOK_PROGRAM:Rs,SERUM_PROGRAM_ID_V3:gr,UTIL1216:Om,Router:Mm,CREATE_CPMM_POOL_PROGRAM:vn,CREATE_CPMM_POOL_AUTH:Os,CREATE_CPMM_POOL_FEE_ACC:Em,LOCK_CPMM_PROGRAM:ii,LOCK_CPMM_AUTH:ri,LAUNCHPAD_PROGRAM:et,LAUNCHPAD_AUTH:Wm,LAUNCHPAD_PLATFORM:Dm,LAUNCHPAD_CONFIG:qm,FEE_DESTINATION_ID:Ls,MODEL_DATA_PUBKEY:Mn},gn={OPEN_BOOK_PROGRAM:new ie("EoTcMgcDRTJVZDMZWBoU6rhYHZfkNTVEAfz3uUJRcYGj"),SERUM_PROGRAM_ID_V3:new ie("Ray1111111111111111111111111111111111111111"),AMM_V4:new ie("DRaya7Kj3aMWQSy19kSjvmuwq9docCHofyP9kanQGaav"),AMM_STABLE:new ie("DRayDdXc1NZQ9C3hRWmoSf8zK4iapgMnjdNZWrfwsP8m"),CLMM_PROGRAM_ID:new ie("DRayAUgENGQBKVaX8owNhgzkEDyoHTGVEGHVJT1E9pfH"),CLMM_LOCK_PROGRAM_ID:new ie("DRay25Usp3YJAi7beckgpGUC7mGJ2cR1AVPxhYfwVCUX"),CLMM_LOCK_AUTH_ID:new ie("6Aoh8h2Lw2m5UGxYR8AdAL87jTWYeKoxM52mJRzfYwN"),CREATE_CPMM_POOL_PROGRAM:new ie("DRaycpLY18LhpbydsBWbVJtxpNv9oXPgjRSfpF2bWpYb"),CREATE_CPMM_POOL_AUTH:new ie("CXniRufdq5xL8t8jZAPxsPZDpuudwuJSPWnbcD5Y5Nxq"),CREATE_CPMM_POOL_FEE_ACC:new ie("3oE58BKVt8KuYkGxx8zBojugnymWmBiyafWgMrnb6eYy"),LOCK_CPMM_PROGRAM:new ie("DRay25Usp3YJAi7beckgpGUC7mGJ2cR1AVPxhYfwVCUX"),LOCK_CPMM_AUTH:new ie("7qWVV8UY2bRJfDLP4s37YzBPKUkVB46DStYJBpYbQzu3"),UTIL1216:ie.default,Router:new ie("DRaybByLpbUL57LJARs3j8BitTxVfzBg351EaMr5UTCd"),FARM_PROGRAM_ID_V3:new ie("DRayWyrLmEW5KEeqs8kdTMMaBabapqagaBC7KWpGtJeZ"),FARM_PROGRAM_ID_V4:new ie("Ray1111111111111111111111111111111111111111"),FARM_PROGRAM_ID_V5:new ie("DRayiCGSZgku1GTK6rXD6mVDdingXy6APAH1R6R5L2LC"),FARM_PROGRAM_ID_V6:new ie("DRayzbYakXs45ELHkzH6vC3fuhQqTAnv5A68gdFuvZyZ"),LAUNCHPAD_PROGRAM:new ie("DRay6fNdQ5J82H7xV6uq2aV3mNrUZ1J4PgSKsWgptcm6"),LAUNCHPAD_AUTH:new ie("5xqNaZXX5eUi4p5HU4oz9i5QnwRNT2y6oN7yyn4qENeq"),LAUNCHPAD_PLATFORM:new ie("2Jx4KTDrVSdWNazuGpcA8n3ZLTRGGBDxAWhuKe2Xcj2a"),LAUNCHPAD_CONFIG:new ie("7ZR4zD7PYfY2XxoG1Gxcy2EgEeGYrpxrwzPuwdUBssEt"),FEE_DESTINATION_ID:new ie("9y8ENuuZ3b19quffx9hQvRVygG5ky6snHfRvGpuSfeJy"),MODEL_DATA_PUBKEY:new ie("Ray1111111111111111111111111111111111111111")};import Ve from"bn.js";var cn=1e4;function Ie(l,e,t,n){if(e===void 0)return{amount:l,fee:void 0,expirationTime:void 0};let o=q(M({},e),{olderTransferFee:{epoch:BigInt(e.olderTransferFee.epoch),maximumFee:BigInt(e.olderTransferFee.maximumFee),transferFeeBasisPoints:e.olderTransferFee.transferFeeBasisPoints},newerTransferFee:{epoch:BigInt(e.newerTransferFee.epoch),maximumFee:BigInt(e.newerTransferFee.maximumFee),transferFeeBasisPoints:e.newerTransferFee.transferFeeBasisPoints}}),r=t.epoch<o.newerTransferFee.epoch?o.olderTransferFee:o.newerTransferFee,i=new Ve(r.maximumFee.toString()),s=t.epoch<o.newerTransferFee.epoch?(Number(o.newerTransferFee.epoch)*t.slotsInEpoch-t.absoluteSlot)*400/1e3:void 0;if(n)if(r.transferFeeBasisPoints===cn){let u=new Ve(r.maximumFee.toString());return{amount:l.add(u),fee:u,expirationTime:s}}else{let u=Fn(l.mul(new Ve(cn)),new Ve(cn-r.transferFeeBasisPoints)),a=new Ve(r.maximumFee.toString()),c=u.sub(l).gt(a)?l.add(a):u,m=Fn(c.mul(new Ve(r.transferFeeBasisPoints)),new Ve(cn)),p=m.gt(i)?i:m;return{amount:c,fee:p,expirationTime:s}}else{let u=Fn(l.mul(new Ve(r.transferFeeBasisPoints)),new Ve(cn)),a=u.gt(i)?i:u;return{amount:l,fee:a,expirationTime:s}}}function Jt(l,e){return l===void 0?e:e===void 0?l:Math.min(l,e)}function Fn(l,e){let{div:t,mod:n}=l.divmod(e);return n.gt(new Ve(0))?t.add(new Ve(1)):t}function Jn(l,e){if(l.isZero())return new Ve(0);let t=l.div(e);return t.isZero()?new Ve(1):l.mod(e).gt(new Ve(0))?t.add(new Ve(1)):t}function Ns(l,e,t){if(e===void 0)return{amount:l,fee:void 0,expirationTime:void 0};let n=Math.floor(t/432e3),o=n<e.newerTransferFee.epoch?e.olderTransferFee:e.newerTransferFee,r=new Ve(o.maximumFee.toString()),i=n<e.newerTransferFee.epoch?(Number(e.newerTransferFee.epoch)*432e3-t)*400/1e3:void 0,s=Fn(l.mul(new Ve(o.transferFeeBasisPoints)),new Ve(cn)),u=s.gt(r)?r:s;return{amount:l,fee:u,expirationTime:i}}function Ms(l,e,t){if(e===void 0)return{amount:l,fee:void 0,expirationTime:void 0};let n=Math.floor(t/432e3),o=n<e.newerTransferFee.epoch?e.olderTransferFee:e.newerTransferFee,r=new Ve(o.maximumFee.toString()),i=n<e.newerTransferFee.epoch?(Number(e.newerTransferFee.epoch)*432e3-t)*400/1e3:void 0;if(o.transferFeeBasisPoints===cn){let s=new Ve(o.maximumFee.toString());return{amount:l.add(s),fee:s,expirationTime:i}}else{let s=Fn(l.mul(new Ve(cn)),new Ve(cn-o.transferFeeBasisPoints)),u=new Ve(o.maximumFee.toString()),a=s.sub(l).gt(u)?l.add(u):s,c=Fn(a.mul(new Ve(o.transferFeeBasisPoints)),new Ve(cn)),m=c.gt(r)?r:c;return{amount:a,fee:m,expirationTime:i}}}import{PublicKey as vs,AddressLookupTableAccount as So}from"@solana/web3.js";async function Ar({connection:l,address:e,cluster:t="mainnet"}){let n=await Zt(l,[...new Set(e.map(r=>r.toString()))].map(r=>new vs(r))),o={};for(let r=0;r<e.length;r++){let i=n[r],s=e[r];if(!i)continue;let u=new So({key:s,state:So.deserialize(i.data)});o[s.toString()]=u,t==="devnet"?Ko[s.toString()]=u:Vn[s.toString()]=u}return o}var Vn={},Fs=async l=>{let e="AcL1Vo8oy1ULiavEcjSUcwfBSForXMudcZvDZy5nzJkU";if(Vn[e])return Vn;let t=new vs(e),n=await l.getAccountInfo(t);return n&&(Vn[e]=new So({key:t,state:So.deserialize(n.data)})),Vn},Ko={},kr=async l=>{let e="EFhMuDw1PKEuckuFRW9PavNfTH4LKP5uKHgyXDmWpFCq";if(Ko[e])return Ko;let t=new vs(e),n=await l.getAccountInfo(t);return n&&(Ko[e]=new So({key:t,state:So.deserialize(n.data)})),Ko};import{PublicKey as eo,sendAndConfirmTransaction as Vs,SystemProgram as Um,Transaction as ai,TransactionMessage as Pn,VersionedTransaction as An}from"@solana/web3.js";import Gm from"axios";var ui=2e3,ci=class{constructor(e){this.instructions=[];this.endInstructions=[];this.lookupTableAddress=[];this.signers=[];this.instructionTypes=[];this.endInstructionTypes=[];this.connection=e.connection,this.feePayer=e.feePayer,this.signAllTransactions=e.signAllTransactions,this.owner=e.owner,this.cluster=e.cluster,this.blockhashCommitment=e.blockhashCommitment,this.loopMultiTxStatus=!!e.loopMultiTxStatus}get AllTxData(){return{instructions:this.instructions,endInstructions:this.endInstructions,signers:this.signers,instructionTypes:this.instructionTypes,endInstructionTypes:this.endInstructionTypes,lookupTableAddress:this.lookupTableAddress}}get allInstructions(){return[...this.instructions,...this.endInstructions]}async getComputeBudgetConfig(){var n;let e=(await Gm.get(`https://solanacompass.com/api/fees?cacheFreshTime=${3e5}`)).data,{avg:t}=(n=e==null?void 0:e[15])!=null?n:{};if(!!t)return{units:6e5,microLamports:Math.min(Math.ceil(t*1e6/6e5),25e3)}}addCustomComputeBudget(e){if(e){let{instructions:t,instructionTypes:n}=Jo(e);return this.instructions.unshift(...t),this.instructionTypes.unshift(...n),!0}return!1}addTipInstruction(e){var t;return e?(this.endInstructions.push(Um.transfer({fromPubkey:(t=e.feePayer)!=null?t:this.feePayer,toPubkey:new eo(e.address),lamports:BigInt(e.amount.toString())})),this.endInstructionTypes.push(G.TransferTip),!0):!1}async calComputeBudget({config:e,defaultIns:t}){try{let n=e||await this.getComputeBudgetConfig();if(this.addCustomComputeBudget(n))return;t&&this.instructions.unshift(...t)}catch{t&&this.instructions.unshift(...t)}}addInstruction({instructions:e=[],endInstructions:t=[],signers:n=[],instructionTypes:o=[],endInstructionTypes:r=[],lookupTableAddress:i=[]}){return this.instructions.push(...e),this.endInstructions.push(...t),this.signers.push(...n),this.instructionTypes.push(...o),this.endInstructionTypes.push(...r),this.lookupTableAddress.push(...i.filter(s=>s!==eo.default.toString())),this}async versionBuild({txVersion:e,extInfo:t}){return e===0?await this.buildV0(M({},t||{})):this.build(t)}build(e){var n;let t=new ai;return this.allInstructions.length&&t.add(...this.allInstructions),t.feePayer=this.feePayer,((n=this.owner)==null?void 0:n.signer)&&!this.signers.some(o=>o.publicKey.equals(this.owner.publicKey))&&this.signers.push(this.owner.signer),{builder:this,transaction:t,signers:this.signers,instructionTypes:[...this.instructionTypes,...this.endInstructionTypes],execute:async o=>{var c;let{recentBlockHash:r,skipPreflight:i=!0,sendAndConfirm:s,notSendToRpc:u}=o||{},a=r!=null?r:await Zn(this.connection,this.blockhashCommitment);if(t.recentBlockhash=a,this.signers.length&&t.sign(...this.signers),On([t]),(c=this.owner)!=null&&c.isKeyPair)return{txId:s?await Vs(this.connection,t,this.signers.find(p=>p.publicKey.equals(this.owner.publicKey))?this.signers:[...this.signers,this.owner.signer],{skipPreflight:i}):await this.connection.sendRawTransaction(t.serialize(),{skipPreflight:i}),signedTx:t};if(this.signAllTransactions){let m=await this.signAllTransactions([t]);if(this.signers.length)for(let p of m)try{p.sign(...this.signers)}catch{}return{txId:u?"":await this.connection.sendRawTransaction(m[0].serialize(),{skipPreflight:i}),signedTx:m[0]}}throw new Error("please provide owner in keypair format or signAllTransactions function")},extInfo:e||{}}}buildMultiTx(e){var a;let{extraPreBuildData:t=[],extInfo:n}=e,{transaction:o}=this.build(n),r=t.filter(c=>c.transaction.instructions.length>0),i=[o,...r.map(c=>c.transaction)],s=[this.signers,...r.map(c=>c.signers)],u=[...this.instructionTypes,...r.map(c=>c.instructionTypes).flat()];return(a=this.owner)!=null&&a.signer&&s.forEach(c=>{c.some(m=>m.publicKey.equals(this.owner.publicKey))||this.signers.push(this.owner.signer)}),{builder:this,transactions:i,signers:s,instructionTypes:u,execute:async c=>{var g;let{sequentially:m,onTxUpdate:p,skipTxCount:d=0,recentBlockHash:f,skipPreflight:y=!0}=c||{},b=f!=null?f:await Zn(this.connection,this.blockhashCommitment);if((g=this.owner)!=null&&g.isKeyPair){if(m){let P=[],h=0;for(let I of i){if(++h,h<=d)continue;let T=await Vs(this.connection,I,this.signers.find(w=>w.publicKey.equals(this.owner.publicKey))?this.signers:[...this.signers,this.owner.signer],{skipPreflight:y});P.push(T)}return{txIds:P,signedTxs:i}}return{txIds:await await Promise.all(i.map(async P=>(P.recentBlockhash=b,await this.connection.sendRawTransaction(P.serialize(),{skipPreflight:y})))),signedTxs:i}}if(this.signAllTransactions){let P=i.map((I,T)=>(I.recentBlockhash=b,s[T].length&&I.sign(...s[T]),I));On(P);let h=await this.signAllTransactions(P);if(m){let I=0,T=[],w=async()=>{if(!h[I])return;let K=await this.connection.sendRawTransaction(h[I].serialize(),{skipPreflight:y});T.push({txId:K,status:"sent",signedTx:h[I]}),p==null||p([...T]),I++;let x=!1,S=null,B=null,R=C=>{S!==null&&clearInterval(S),B!==null&&this.connection.removeSignatureListener(B);let v=T.findIndex(L=>L.txId===K);if(v>-1){if(T[v].status==="error"||T[v].status==="success")return;T[v].status=C.err?"error":"success"}p==null||p([...T]),C.err||w()};this.loopMultiTxStatus&&(S=setInterval(async()=>{var C;if(x){clearInterval(S);return}try{let v=await this.connection.getTransaction(K,{commitment:"confirmed",maxSupportedTransactionVersion:0});v&&(x=!0,clearInterval(S),R({err:((C=v.meta)==null?void 0:C.err)||null}),console.log("tx status from getTransaction:",K))}catch(v){x=!0,clearInterval(S),console.error("getTransaction timeout:",v,K)}},ui)),B=this.connection.onSignature(K,C=>{if(x){this.connection.removeSignatureListener(B);return}x=!0,R(C)},"confirmed"),this.connection.getSignatureStatus(K)};return await w(),{txIds:T.map(K=>K.txId),signedTxs:h}}else{let I=[];for(let T=0;T<h.length;T+=1){let w=await this.connection.sendRawTransaction(h[T].serialize(),{skipPreflight:y});I.push(w)}return{txIds:I,signedTxs:h}}}throw new Error("please provide owner in keypair format or signAllTransactions function")},extInfo:n||{}}}async versionMultiBuild({extraPreBuildData:e,txVersion:t,extInfo:n}){return t===0?await this.buildV0MultiTx({extraPreBuildData:e,buildProps:n||{}}):this.buildMultiTx({extraPreBuildData:e,extInfo:n})}async buildV0(e){var y;let f=e||{},{lookupTableCache:t={},lookupTableAddress:n=[],forerunCreate:o,recentBlockhash:r}=f,i=Fe(f,["lookupTableCache","lookupTableAddress","forerunCreate","recentBlockhash"]),s=M(M({},this.cluster==="devnet"?await kr(this.connection):await Fs(this.connection)),t),u=Array.from(new Set([...n,...this.lookupTableAddress])),a=[];for(let b of u)s[b]===void 0&&a.push(new eo(b));let c=await Ar({connection:this.connection,address:a});for(let[b,g]of Object.entries(c))s[b]=g;let m=o?eo.default.toBase58():r!=null?r:await Zn(this.connection,this.blockhashCommitment),p=new Pn({payerKey:this.feePayer,recentBlockhash:m,instructions:[...this.allInstructions]}).compileToV0Message(Object.values(s));((y=this.owner)==null?void 0:y.signer)&&!this.signers.some(b=>b.publicKey.equals(this.owner.publicKey))&&this.signers.push(this.owner.signer);let d=new An(p);return d.sign(this.signers),{builder:this,transaction:d,signers:this.signers,instructionTypes:[...this.instructionTypes,...this.endInstructionTypes],execute:async b=>{var I;let{skipPreflight:g=!0,sendAndConfirm:P,notSendToRpc:h}=b||{};if(On([d]),(I=this.owner)!=null&&I.isKeyPair){let T=await this.connection.sendTransaction(d,{skipPreflight:g});return P&&await ei(this.connection,T),{txId:T,signedTx:d}}if(this.signAllTransactions){let T=await this.signAllTransactions([d]);if(this.signers.length)for(let w of T)try{w.sign(this.signers)}catch{}return{txId:h?"":await this.connection.sendTransaction(T[0],{skipPreflight:g}),signedTx:T[0]}}throw new Error("please provide owner in keypair format or signAllTransactions function")},extInfo:i||{}}}async buildV0MultiTx(e){var a;let{extraPreBuildData:t=[],buildProps:n}=e,{transaction:o}=await this.buildV0(n),r=t.filter(c=>c.builder.instructions.length>0),i=[o,...r.map(c=>c.transaction)],s=[this.signers,...r.map(c=>c.signers)],u=[...this.instructionTypes,...r.map(c=>c.instructionTypes).flat()];return(a=this.owner)!=null&&a.signer&&s.forEach(c=>{c.some(m=>m.publicKey.equals(this.owner.publicKey))||this.signers.push(this.owner.signer)}),i.forEach(async(c,m)=>{c.sign(s[m])}),{builder:this,transactions:i,signers:s,instructionTypes:u,buildProps:n,execute:async c=>{var y;let{sequentially:m,onTxUpdate:p,recentBlockHash:d,skipPreflight:f=!0}=c||{};if(d&&i.forEach(b=>b.message.recentBlockhash=d),On(i),(y=this.owner)!=null&&y.isKeyPair){if(m){let b=[];for(let g of i){let P=await this.connection.sendTransaction(g,{skipPreflight:f});await ei(this.connection,P),b.push(P)}return{txIds:b,signedTxs:i}}return{txIds:await Promise.all(i.map(async b=>await this.connection.sendTransaction(b,{skipPreflight:f}))),signedTxs:i}}if(this.signAllTransactions){let b=await this.signAllTransactions(i);if(m){let g=0,P=[],h=async()=>{if(!b[g])return;let I=await this.connection.sendTransaction(b[g],{skipPreflight:f});P.push({txId:I,status:"sent",signedTx:b[g]}),p==null||p([...P]),g++;let T=!1,w=null,K=null,x=S=>{w!==null&&clearInterval(w),K!==null&&this.connection.removeSignatureListener(K);let B=P.findIndex(R=>R.txId===I);if(B>-1){if(P[B].status==="error"||P[B].status==="success")return;P[B].status=S.err?"error":"success"}p==null||p([...P]),S.err||h()};this.loopMultiTxStatus&&(w=setInterval(async()=>{var S;if(T){clearInterval(w);return}try{let B=await this.connection.getTransaction(I,{commitment:"confirmed",maxSupportedTransactionVersion:0});B&&(T=!0,clearInterval(w),x({err:((S=B.meta)==null?void 0:S.err)||null}),console.log("tx status from getTransaction:",I))}catch(B){T=!0,clearInterval(w),console.error("getTransaction timeout:",B,I)}},ui)),K=this.connection.onSignature(I,S=>{if(T){this.connection.removeSignatureListener(K);return}T=!0,x(S)},"confirmed"),this.connection.getSignatureStatus(I)};return h(),{txIds:[],signedTxs:b}}else{let g=[];for(let P=0;P<b.length;P+=1){let h=await this.connection.sendTransaction(b[P],{skipPreflight:f});g.push(h)}return{txIds:g,signedTxs:b}}}throw new Error("please provide owner in keypair format or signAllTransactions function")},extInfo:n||{}}}async sizeCheckBuild(e){var p;let m=e||{},{splitIns:t=[],computeBudgetConfig:n}=m,o=Fe(m,["splitIns","computeBudgetConfig"]),r=n?Jo(n):{instructions:[],instructionTypes:[]},i=this.signers.reduce((d,f)=>q(M({},d),{[f.publicKey.toBase58()]:f}),{}),s=[],u=[],a=[],c=0;if(this.allInstructions.forEach(d=>{let f=[...a,d],y=n?[...r.instructions,...f]:f,g=[...new Set(f.map(P=>P.keys.filter(h=>h.isSigner).map(h=>h.pubkey.toString())).flat()).values()].map(P=>new eo(P));if(d!==t[c]&&a.length<12&&(ti({instructions:y,payer:this.feePayer,signers:g})||ti({instructions:f,payer:this.feePayer,signers:g})))a.push(d);else{if(a.length===0)throw Error("item ins too big");c+=d===t[c]?1:0,ti({instructions:n?[...r.instructions,...a]:[...a],payer:this.feePayer,signers:g})?s.push(new ai().add(...r.instructions,...a)):s.push(new ai().add(...a)),u.push(Array.from(new Set(a.map(P=>P.keys.filter(h=>h.isSigner).map(h=>h.pubkey.toString())).flat())).map(P=>i[P]).filter(P=>P!==void 0)),a=[d]}}),a.length>0){let f=[...new Set(a.map(y=>y.keys.filter(b=>b.isSigner).map(b=>b.pubkey.toString())).flat()).values()].map(y=>i[y]).filter(y=>y!==void 0);ti({instructions:n?[...r.instructions,...a]:[...a],payer:this.feePayer,signers:f.map(y=>y.publicKey)})?s.push(new ai().add(...r.instructions,...a)):s.push(new ai().add(...a)),u.push(f)}return s.forEach(d=>d.feePayer=this.feePayer),(p=this.owner)!=null&&p.signer&&u.forEach(d=>{d.some(f=>f.publicKey.equals(this.owner.publicKey))||d.push(this.owner.signer)}),{builder:this,transactions:s,signers:u,instructionTypes:this.instructionTypes,execute:async d=>{var I;let{sequentially:f,onTxUpdate:y,skipTxCount:b=0,recentBlockHash:g,skipPreflight:P=!0}=d||{},h=g!=null?g:await Zn(this.connection,this.blockhashCommitment);if(s.forEach(async(T,w)=>{T.recentBlockhash=h,u[w].length&&T.sign(...u[w])}),On(s),(I=this.owner)!=null&&I.isKeyPair){if(f){let T=0,w=[];for(let K of s){if(++T,T<=b){w.push("tx skipped");continue}let x=await Vs(this.connection,K,this.signers.find(S=>S.publicKey.equals(this.owner.publicKey))?this.signers:[...this.signers,this.owner.signer],{skipPreflight:P});w.push(x)}return{txIds:w,signedTxs:s}}return{txIds:await Promise.all(s.map(async T=>await this.connection.sendRawTransaction(T.serialize(),{skipPreflight:P}))),signedTxs:s}}if(this.signAllTransactions){let T=await this.signAllTransactions(s.slice(b,s.length)),w=[...s.slice(0,b),...T];if(f){let K=0,x=[],S=async()=>{if(!w[K])return;K<b&&(x.push({txId:"",status:"success",signedTx:w[K]}),y==null||y([...x]),K++,S());let B=await this.connection.sendRawTransaction(w[K].serialize(),{skipPreflight:P});x.push({txId:B,status:"sent",signedTx:w[K]}),y==null||y([...x]),K++;let R=!1,C=null,v=null,L=N=>{C!==null&&clearInterval(C),v!==null&&this.connection.removeSignatureListener(v);let E=x.findIndex(X=>X.txId===B);if(E>-1){if(x[E].status==="error"||x[E].status==="success")return;x[E].status=N.err?"error":"success"}y==null||y([...x]),N.err||S()};this.loopMultiTxStatus&&(C=setInterval(async()=>{var N;if(R){clearInterval(C);return}try{let E=await this.connection.getTransaction(B,{commitment:"confirmed",maxSupportedTransactionVersion:0});E&&(R=!0,clearInterval(C),L({err:((N=E.meta)==null?void 0:N.err)||null}),console.log("tx status from getTransaction:",B))}catch(E){R=!0,clearInterval(C),console.error("getTransaction timeout:",E,B)}},ui)),v=this.connection.onSignature(B,N=>{if(R){this.connection.removeSignatureListener(v);return}R=!0,L(N)},"confirmed"),this.connection.getSignatureStatus(B)};return await S(),{txIds:x.map(B=>B.txId),signedTxs:w}}else{let K=[];for(let x=0;x<w.length;x+=1){let S=await this.connection.sendRawTransaction(w[x].serialize(),{skipPreflight:P});K.push(S)}return{txIds:K,signedTxs:w}}}throw new Error("please provide owner in keypair format or signAllTransactions function")},extInfo:o||{}}}async sizeCheckBuildV0(e){var h;let P=e||{},{computeBudgetConfig:t,splitIns:n=[],lookupTableCache:o={},lookupTableAddress:r=[]}=P,i=Fe(P,["computeBudgetConfig","splitIns","lookupTableCache","lookupTableAddress"]),s=M(M({},this.cluster==="devnet"?await kr(this.connection):Vn),o),u=Array.from(new Set([...this.lookupTableAddress,...r])),a=[];for(let I of u)s[I]===void 0&&a.push(new eo(I));let c=await Ar({connection:this.connection,address:a});for(let[I,T]of Object.entries(c))s[I]=T;let m=t?Jo(t):{instructions:[],instructionTypes:[]},p=await Zn(this.connection,this.blockhashCommitment),d=this.signers.reduce((I,T)=>q(M({},I),{[T.publicKey.toBase58()]:T}),{}),f=[],y=[],b=[],g=0;if(this.allInstructions.forEach(I=>{let T=[...b,I],w=t?[...m.instructions,...T]:T;if(I!==n[g]&&b.length<12&&(bn({instructions:w,payer:this.feePayer,lookupTableAddressAccount:s})||bn({instructions:T,payer:this.feePayer,lookupTableAddressAccount:s})))b.push(I);else{if(b.length===0)throw Error("item ins too big");g+=I===n[g]?1:0;let K={};for(let x of[...new Set(u)])s[x]!==void 0&&(K[x]=s[x]);if(t&&bn({instructions:[...m.instructions,...b],payer:this.feePayer,lookupTableAddressAccount:s,recentBlockhash:p})){let x=new Pn({payerKey:this.feePayer,recentBlockhash:p,instructions:[...m.instructions,...b]}).compileToV0Message(Object.values(s));f.push(new An(x))}else{let x=new Pn({payerKey:this.feePayer,recentBlockhash:p,instructions:[...b]}).compileToV0Message(Object.values(s));f.push(new An(x))}y.push(Array.from(new Set(b.map(x=>x.keys.filter(S=>S.isSigner).map(S=>S.pubkey.toString())).flat())).map(x=>d[x]).filter(x=>x!==void 0)),b=[I]}}),b.length>0){let T=[...new Set(b.map(w=>w.keys.filter(K=>K.isSigner).map(K=>K.pubkey.toString())).flat()).values()].map(w=>d[w]).filter(w=>w!==void 0);if(t&&bn({instructions:[...m.instructions,...b],payer:this.feePayer,lookupTableAddressAccount:s,recentBlockhash:p})){let w=new Pn({payerKey:this.feePayer,recentBlockhash:p,instructions:[...m.instructions,...b]}).compileToV0Message(Object.values(s));f.push(new An(w))}else{let w=new Pn({payerKey:this.feePayer,recentBlockhash:p,instructions:[...b]}).compileToV0Message(Object.values(s));f.push(new An(w))}y.push(T)}return(h=this.owner)!=null&&h.signer&&y.forEach(I=>{I.some(T=>T.publicKey.equals(this.owner.publicKey))||I.push(this.owner.signer)}),f.forEach((I,T)=>{I.sign(y[T])}),{builder:this,transactions:f,buildProps:e,signers:y,blockHash:p,instructionTypes:this.instructionTypes,execute:async I=>{var B;let{sequentially:T,onTxUpdate:w,skipTxCount:K=0,recentBlockHash:x,skipPreflight:S=!0}=I||{};if(f.map(async(R,C)=>{y[C].length&&R.sign(y[C]),x&&(R.message.recentBlockhash=x)}),On(f),(B=this.owner)!=null&&B.isKeyPair){if(T){let R=0,C=[];for(let v of f){if(++R,R<=K){console.log("skip tx: ",R),C.push("tx skipped");continue}let L=await this.connection.sendTransaction(v,{skipPreflight:S});await ei(this.connection,L),C.push(L)}return{txIds:C,signedTxs:f}}return{txIds:await Promise.all(f.map(async R=>await this.connection.sendTransaction(R,{skipPreflight:S}))),signedTxs:f}}if(this.signAllTransactions){let R=await this.signAllTransactions(f.slice(K,f.length)),C=[...f.slice(0,K),...R];if(T){let v=0,L=[],N=async()=>{if(!C[v])return;if(v<K){L.push({txId:"",status:"success",signedTx:C[v]}),w==null||w([...L]),v++,N();return}let E=await this.connection.sendTransaction(C[v],{skipPreflight:S});L.push({txId:E,status:"sent",signedTx:C[v]}),w==null||w([...L]),v++;let X=!1,Q=null,ee=null,me=re=>{Q!==null&&clearInterval(Q),ee!==null&&this.connection.removeSignatureListener(ee);let ue=L.findIndex(be=>be.txId===E);if(ue>-1){if(L[ue].status==="error"||L[ue].status==="success")return;L[ue].status=re.err?"error":"success"}w==null||w([...L]),re.err||N()};this.loopMultiTxStatus&&(Q=setInterval(async()=>{var re;if(X){clearInterval(Q);return}try{let ue=await this.connection.getTransaction(E,{commitment:"confirmed",maxSupportedTransactionVersion:0});ue&&(X=!0,clearInterval(Q),me({err:((re=ue.meta)==null?void 0:re.err)||null}),console.log("tx status from getTransaction:",E))}catch(ue){X=!0,clearInterval(Q),console.error("getTransaction timeout:",ue,E)}},ui)),ee=this.connection.onSignature(E,re=>{if(X){this.connection.removeSignatureListener(ee);return}X=!0,me(re)},"confirmed"),this.connection.getSignatureStatus(E)};return N(),{txIds:[],signedTxs:C}}else{let v=[];for(let L=0;L<C.length;L+=1){let N=await this.connection.sendTransaction(C[L],{skipPreflight:S});v.push(N)}return{txIds:v,signedTxs:C}}}throw new Error("please provide owner in keypair format or signAllTransactions function")},extInfo:i||{}}}async buildSniperTransaction(e){var h;let P=e||{},{computeBudgetConfig:t,splitIns:n=[],lookupTableCache:o={},lookupTableAddress:r=[]}=P,i=Fe(P,["computeBudgetConfig","splitIns","lookupTableCache","lookupTableAddress"]),s=M(M({},this.cluster==="devnet"?await kr(this.connection):await Fs(this.connection)),o),u=Array.from(new Set([...this.lookupTableAddress,...r])),a=[];for(let I of u)s[I]===void 0&&a.push(new eo(I));let c=await Ar({connection:this.connection,address:a});for(let[I,T]of Object.entries(c))s[I]=T;let m=t?Jo(t):{instructions:[],instructionTypes:[]},p=await Zn(this.connection,this.blockhashCommitment),d=this.signers.reduce((I,T)=>q(M({},I),{[T.publicKey.toBase58()]:T}),{}),f=[],y=[],b=[],g=0;if(this.allInstructions.forEach(I=>{let T=[...b,I],w=t?[...m.instructions,...T]:T;if(I!==n[g]&&b.length<12&&(bn({instructions:w,payer:this.feePayer,lookupTableAddressAccount:s})||bn({instructions:T,payer:this.feePayer,lookupTableAddressAccount:s})))b.push(I);else{if(b.length===0)throw Error("item ins too big");g+=I===n[g]?1:0;let K={};for(let x of[...new Set(u)])s[x]!==void 0&&(K[x]=s[x]);if(t&&bn({instructions:[...m.instructions,...b],payer:this.feePayer,lookupTableAddressAccount:s,recentBlockhash:p})){let x=new Pn({payerKey:this.feePayer,recentBlockhash:p,instructions:[...m.instructions,...b]}).compileToV0Message(Object.values(s));f.push(new An(x))}else{let x=new Pn({payerKey:this.feePayer,recentBlockhash:p,instructions:[...b]}).compileToV0Message(Object.values(s));f.push(new An(x))}y.push(Array.from(new Set(b.map(x=>x.keys.filter(S=>S.isSigner).map(S=>S.pubkey.toString())).flat())).map(x=>d[x]).filter(x=>x!==void 0)),b=[I]}}),b.length>0){let T=[...new Set(b.map(w=>w.keys.filter(K=>K.isSigner).map(K=>K.pubkey.toString())).flat()).values()].map(w=>d[w]).filter(w=>w!==void 0);if(t&&bn({instructions:[...m.instructions,...b],payer:this.feePayer,lookupTableAddressAccount:s,recentBlockhash:p})){let w=new Pn({payerKey:this.feePayer,recentBlockhash:p,instructions:[...m.instructions,...b]}).compileToV0Message(Object.values(s));f.push(new An(w))}else{let w=new Pn({payerKey:this.feePayer,recentBlockhash:p,instructions:[...b]}).compileToV0Message(Object.values(s));f.push(new An(w))}y.push(T)}return(h=this.owner)!=null&&h.signer&&y.forEach(I=>{I.some(T=>T.publicKey.equals(this.owner.publicKey))||I.push(this.owner.signer)}),f.forEach((I,T)=>{I.sign(y[T])}),{builder:this,transactions:f,buildProps:e,signers:y,instructionTypes:this.instructionTypes,execute:async I=>{var B;let{sequentially:T,onTxUpdate:w,skipTxCount:K=0,recentBlockHash:x,skipPreflight:S=!0}=I||{};if(f.map(async(R,C)=>{y[C].length&&R.sign(y[C]),x&&(R.message.recentBlockhash=x)}),On(f),(B=this.owner)!=null&&B.isKeyPair){if(T){let R=0,C=[];for(let v of f){if(++R,R<=K){console.log("skip tx: ",R),C.push("tx skipped");continue}let L=await this.connection.sendTransaction(v,{skipPreflight:S});await ei(this.connection,L),C.push(L)}return{txIds:C,signedTxs:f}}return{txIds:await Promise.all(f.map(async R=>await this.connection.sendTransaction(R,{skipPreflight:S}))),signedTxs:f}}if(this.signAllTransactions){let R=await this.signAllTransactions(f.slice(K,f.length)),C=[...f.slice(0,K),...R];if(T){let v=0,L=[],N=async()=>{if(!C[v])return;if(v<K){L.push({txId:"",status:"success",signedTx:C[v]}),w==null||w([...L]),v++,N();return}let E=await this.connection.sendTransaction(C[v],{skipPreflight:S});L.push({txId:E,status:"sent",signedTx:C[v]}),w==null||w([...L]),v++;let X=!1,Q=null,ee=null,me=re=>{Q!==null&&clearInterval(Q),ee!==null&&this.connection.removeSignatureListener(ee);let ue=L.findIndex(be=>be.txId===E);if(ue>-1){if(L[ue].status==="error"||L[ue].status==="success")return;L[ue].status=re.err?"error":"success"}w==null||w([...L]),re.err||N()};this.loopMultiTxStatus&&(Q=setInterval(async()=>{var re;if(X){clearInterval(Q);return}try{let ue=await this.connection.getTransaction(E,{commitment:"confirmed",maxSupportedTransactionVersion:0});ue&&(X=!0,clearInterval(Q),me({err:((re=ue.meta)==null?void 0:re.err)||null}),console.log("tx status from getTransaction:",E))}catch(ue){X=!0,clearInterval(Q),console.error("getTransaction timeout:",ue,E)}},ui)),ee=this.connection.onSignature(E,re=>{if(X){this.connection.removeSignatureListener(ee);return}X=!0,me(re)},"confirmed"),this.connection.getSignatureStatus(E)};return N(),{txIds:[],signedTxs:C}}else{let v=[];for(let L=0;L<C.length;L+=1){let N=await this.connection.sendTransaction(C[L],{skipPreflight:S});v.push(N)}return{txIds:v,signedTxs:C}}}throw new Error("please provide owner in keypair format or signAllTransactions function")},extInfo:i||{}}}};import{PublicKey as Xm}from"@solana/web3.js";import zm from"bn.js";function Ym(l){return typeof l=="object"&&l!==null&&![Ge,xe,Xm,he,zm,Bt,st].some(e=>typeof e=="object"&&l instanceof e)}function _e(l){return typeof l=="string"?ws(l):Array.isArray(l)?l.map(e=>_e(e)):Ym(l)?Object.fromEntries(Object.entries(l).map(([e,t])=>[e,_e(t)])):l}import Qm from"bn.js";var Kt=new Qm(1e6);var at={BASE_HOST:"https://api-v3.raydium.io",OWNER_BASE_HOST:"https://owner-v1.raydium.io",SERVICE_BASE_HOST:"https://service.raydium.io",MONITOR_BASE_HOST:"https://monitor.raydium.io",SERVICE_1_BASE_HOST:"https://service-v1.raydium.io",SEND_TRANSACTION:"/send-transaction",FARM_ARP:"/main/farm/info",FARM_ARP_LINE:"/main/farm-apr-tv",CLMM_CONFIG:"/main/clmm-config",CPMM_CONFIG:"/main/cpmm-config",VERSION:"/main/version",CHECK_AVAILABILITY:"/v3/main/AvailabilityCheckAPI",RPCS:"/main/rpcs",INFO:"/main/info",STAKE_POOLS:"/main/stake-pools",CHAIN_TIME:"/main/chain-time",TOKEN_LIST:"/mint/list",MINT_INFO_ID:"/mint/ids",JUP_TOKEN_LIST:"https://lite-api.jup.ag/tokens/v1/tagged/verified",POOL_LIST:"/pools/info/list",POOL_SEARCH_BY_ID:"/pools/info/ids",POOL_SEARCH_MINT:"/pools/info/mint",POOL_SEARCH_LP:"/pools/info/lps",POOL_KEY_BY_ID:"/pools/key/ids",POOL_LIQUIDITY_LINE:"/pools/line/liquidity",POOL_POSITION_LINE:"/pools/line/position",FARM_INFO:"/farms/info/ids",FARM_LP_INFO:"/farms/info/lp",FARM_KEYS:"/farms/key/ids",OWNER_CREATED_FARM:"/create-pool/{owner}",OWNER_IDO:"/main/ido/{owner}",OWNER_STAKE_FARMS:"/position/stake/{owner}",OWNER_LOCK_POSITION:"/position/clmm-lock/{owner}",IDO_KEYS:"/ido/key/ids",SWAP_HOST:"https://transaction-v1.raydium.io",SWAP_COMPUTE:"/compute/",SWAP_TX:"/transaction/",MINT_PRICE:"/mint/price",MIGRATE_CONFIG:"/main/migrate-lp",PRIORITY_FEE:"/main/auto-fee",CPMM_LOCK:"https://dynamic-ipfs.raydium.io/lock/cpmm/position"},_g=M({},at);var Yu="ray_tab_hash",_s="ray_req_hash",Hm=()=>{if(typeof window===void 0)return"";let l=sessionStorage.getItem(Yu);return l||(l=`ray-${Date.now()}`,sessionStorage.setItem(Yu,l)),l},wr=async n=>{var o=n,{logCount:l=1e3,removeLastLog:e}=o,t=Fe(o,["logCount","removeLastLog"]);if(typeof window===void 0)return new Promise(i=>i());let r=JSON.parse(localStorage.getItem(_s)||"[]").slice(0,l-1);e&&r.pop(),new Blob([JSON.stringify(t.data)]).size>1024&&(t.data=JSON.stringify(t.data).substring(0,200)+"..."),r.unshift(q(M({},t),{time:Date.now(),session:Hm()}));try{localStorage.setItem(_s,JSON.stringify(r))}catch{if(e){let i=!1,s=JSON.stringify(t.data).substring(0,100);for(r[0].data=s+(s.length>100?"...":"");!i;){r.pop();let u=JSON.stringify(t.data).substring(0,100);r[0].data=u+(u.length>100?"...":"");try{localStorage.setItem(_s,JSON.stringify(r)),i=!0}catch{i=!1}}return new Promise(u=>u())}return wr(q(M({},t),{logCount:l,removeLastLog:!0}))}};import{TOKEN_2022_PROGRAM_ID as jm,TOKEN_PROGRAM_ID as $m}from"@solana/spl-token";var Tr=ye("Raydium_Api"),Es=new Map;var hr=class{constructor({cluster:e,timeout:t,logRequests:n,logCount:o,urlConfigs:r}){this.cluster=e,this.urlConfigs=r||{},this.logCount=o||1e3,this.api=Qu.create({baseURL:this.urlConfigs.BASE_HOST||at.BASE_HOST,timeout:t}),this.api.interceptors.request.use(i=>{let{method:s,baseURL:u,url:a}=i;return Tr.debug(`${s==null?void 0:s.toUpperCase()} ${u}${a}`),i},i=>(Tr.error("Request failed"),Promise.reject(i))),this.api.interceptors.response.use(i=>{let{config:s,data:u,status:a}=i,{method:c,baseURL:m,url:p}=s;return n&&wr({status:a,url:`${m}${p}`,params:s.params,data:u,logCount:this.logCount}),Tr.debug(`${c==null?void 0:c.toUpperCase()} ${m}${p}  ${a}`),u},i=>{let{config:s,response:u={}}=i,{status:a}=u,{method:c,baseURL:m,url:p}=s;return n&&wr({status:a,url:`${m}${p}`,params:s.params,data:i.message,logCount:this.logCount}),Tr.error(`${c.toUpperCase()} ${m}${p} ${a||i.message}`),Promise.reject(i)})}async getClmmConfigs(){return(await this.api.get(this.urlConfigs.CLMM_CONFIG||at.CLMM_CONFIG)).data}async getCpmmConfigs(){return(await this.api.get(this.urlConfigs.CPMM_CONFIG||at.CPMM_CONFIG)).data}async getClmmPoolLines(e){return(await this.api.get(`${this.urlConfigs.POOL_LIQUIDITY_LINE||at.POOL_LIQUIDITY_LINE}?pool_id=${e}`)).data}async getBlockSlotCountForSecond(e){if(!e)return 2;let n=(await Qu.post(e,{id:"getRecentPerformanceSamples",jsonrpc:"2.0",method:"getRecentPerformanceSamples",params:[4]})).result.map(o=>o.numSlots);return n.reduce((o,r)=>o+r,0)/n.length/60}async getChainTimeOffset(){return(await this.api.get(this.urlConfigs.CHAIN_TIME||at.CHAIN_TIME)).data}async getRpcs(){return this.api.get(this.urlConfigs.RPCS||at.RPCS)}async getTokenList(){return(await this.api.get(this.urlConfigs.TOKEN_LIST||at.TOKEN_LIST)).data}async getJupTokenList(){return(await this.api.get("",{baseURL:this.urlConfigs.JUP_TOKEN_LIST||at.JUP_TOKEN_LIST})).map(t=>q(M({},t),{chainId:101,programId:t.tags.includes("token-2022")?jm.toBase58():$m.toBase58()}))}async getTokenInfo(e){return(await this.api.get((this.urlConfigs.MINT_INFO_ID||at.MINT_INFO_ID)+`?mints=${e.map(n=>n.toString()).join(",")}`)).data}async getPoolList(e={}){let{type:t="all",sort:n="liquidity",order:o="desc",page:r=0,pageSize:i=100}=e;return(await this.api.get((this.urlConfigs.POOL_LIST||at.POOL_LIST)+`?poolType=${t}&poolSortField=${n}&sortType=${o}&page=${r}&pageSize=${i}`)).data}async fetchPoolById(e){let{ids:t}=e;return(await this.api.get((this.urlConfigs.POOL_SEARCH_BY_ID||at.POOL_SEARCH_BY_ID)+`?ids=${t}`)).data}async fetchPoolKeysById(e){let{idList:t}=e,n=[],o=t.filter(i=>Es.has(i)?(n.push(Es.get(i)),!1):!0),r=[];return o.length&&(r=(await this.api.get((this.urlConfigs.POOL_KEY_BY_ID||at.POOL_KEY_BY_ID)+`?ids=${o.join(",")}`)).data.filter(Boolean),r.forEach(s=>{Es.set(s.id,s)})),n.concat(r)}async fetchPoolByMints(e){let{mint1:t,mint2:n,type:o="all",sort:r="default",order:i="desc",page:s=1}=e,[u,a]=[t&&dt(t).toBase58(),n&&n!=="undefined"?dt(n).toBase58():""],[c,m]=a&&u>a?[a,u]:[u,a];return(await this.api.get((this.urlConfigs.POOL_SEARCH_MINT||at.POOL_SEARCH_MINT)+`?mint1=${c}&mint2=${m}&poolType=${o}&poolSortField=${r}&sortType=${i}&pageSize=100&page=${s}`)).data}async fetchFarmInfoById(e){let{ids:t}=e;return(await this.api.get((this.urlConfigs.FARM_INFO||at.FARM_INFO)+`?ids=${t}`)).data}async fetchFarmKeysById(e){let{ids:t}=e;return(await this.api.get((this.urlConfigs.FARM_KEYS||at.FARM_KEYS)+`?ids=${t}`)).data}async fetchAvailabilityStatus(){return(await this.api.get(this.urlConfigs.CHECK_AVAILABILITY||at.CHECK_AVAILABILITY)).data}};var Ir="please provide owner in load() initialization or you can set by calling raydium.setOwner(owner)",Hu="please provide connection in load() initialization or set it by raydium.setConnection(connection)";import{PublicKey as Rr,SystemProgram as Sd}from"@solana/web3.js";import{AccountLayout as Lo,createAssociatedTokenAccountIdempotentInstruction as js,TOKEN_PROGRAM_ID as Dn,TOKEN_2022_PROGRAM_ID as Cd}from"@solana/spl-token";var Ws=(...l)=>l.map(e=>{try{return typeof e=="object"?JSON.stringify(e):e}catch{return e}}).join(", "),Ee=class{constructor({scope:e,moduleName:t}){this.disabled=!1;this.scope=e,this.logger=ye(t)}createTxBuilder(e){return this.scope.checkOwner(),new ci({connection:this.scope.connection,feePayer:e||this.scope.ownerPubKey,cluster:this.scope.cluster,owner:this.scope.owner,blockhashCommitment:this.scope.blockhashCommitment,loopMultiTxStatus:this.scope.loopMultiTxStatus,api:this.scope.api,signAllTransactions:this.scope.signAllTransactions})}createSniperTxBuilder(e,t){let n=new vt(e);return new ci({connection:this.scope.connection,feePayer:t,cluster:this.scope.cluster,owner:n,blockhashCommitment:this.scope.blockhashCommitment,loopMultiTxStatus:this.scope.loopMultiTxStatus,api:this.scope.api,signAllTransactions:this.scope.signAllTransactions})}logDebug(...e){this.logger.debug(Ws(e))}logInfo(...e){this.logger.info(Ws(e))}logAndCreateError(...e){let t=Ws(e);throw new Error(t)}checkDisabled(){(this.disabled||!this.scope)&&this.logAndCreateError("module not working")}};import{PublicKey as Td,SystemProgram as hd}from"@solana/web3.js";import Id from"bn.js";import{createCloseAccountInstruction as Bd,createInitializeAccountInstruction as xd,createTransferInstruction as Kd,TOKEN_PROGRAM_ID as Ro}from"@solana/spl-token";import{Keypair as Pd,PublicKey as lc}from"@solana/web3.js";import Ad from"bn.js";import{TOKEN_PROGRAM_ID as kd}from"@solana/spl-token";function Zm(l){return l instanceof Uint8Array||l!=null&&typeof l=="object"&&l.constructor.name==="Uint8Array"}function Ds(l,...e){if(!Zm(l))throw new Error("Uint8Array expected");if(e.length>0&&!e.includes(l.length))throw new Error(`Uint8Array expected of length ${e}, not of length=${l.length}`)}function qs(l,e=!0){if(l.destroyed)throw new Error("Hash instance has been destroyed");if(e&&l.finished)throw new Error("Hash#digest() has already been called")}function ju(l,e){Ds(l);let t=e.outputLen;if(l.length<t)throw new Error(`digestInto() expects output buffer of length at least ${t}`)}var xr=l=>new DataView(l.buffer,l.byteOffset,l.byteLength),en=(l,e)=>l<<32-e|l>>>e;var hP=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;function Jm(l){if(typeof l!="string")throw new Error(`utf8ToBytes expected string, got ${typeof l}`);return new Uint8Array(new TextEncoder().encode(l))}function Us(l){return typeof l=="string"&&(l=Jm(l)),Ds(l),l}var Br=class{clone(){return this._cloneInto()}},IP={}.toString;function $u(l){let e=n=>l().update(Us(n)).digest(),t=l();return e.outputLen=t.outputLen,e.blockLen=t.blockLen,e.create=()=>l(),e}function ed(l,e,t,n){if(typeof l.setBigUint64=="function")return l.setBigUint64(e,t,n);let o=BigInt(32),r=BigInt(4294967295),i=Number(t>>o&r),s=Number(t&r),u=n?4:0,a=n?0:4;l.setUint32(e+u,i,n),l.setUint32(e+a,s,n)}var Zu=(l,e,t)=>l&e^~l&t,Ju=(l,e,t)=>l&e^l&t^e&t,Kr=class extends Br{constructor(e,t,n,o){super(),this.blockLen=e,this.outputLen=t,this.padOffset=n,this.isLE=o,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(e),this.view=xr(this.buffer)}update(e){qs(this);let{view:t,buffer:n,blockLen:o}=this;e=Us(e);let r=e.length;for(let i=0;i<r;){let s=Math.min(o-this.pos,r-i);if(s===o){let u=xr(e);for(;o<=r-i;i+=o)this.process(u,i);continue}n.set(e.subarray(i,i+s),this.pos),this.pos+=s,i+=s,this.pos===o&&(this.process(t,0),this.pos=0)}return this.length+=e.length,this.roundClean(),this}digestInto(e){qs(this),ju(e,this),this.finished=!0;let{buffer:t,view:n,blockLen:o,isLE:r}=this,{pos:i}=this;t[i++]=128,this.buffer.subarray(i).fill(0),this.padOffset>o-i&&(this.process(n,0),i=0);for(let m=i;m<o;m++)t[m]=0;ed(n,o-8,BigInt(this.length*8),r),this.process(n,0);let s=xr(e),u=this.outputLen;if(u%4)throw new Error("_sha2: outputLen should be aligned to 32bit");let a=u/4,c=this.get();if(a>c.length)throw new Error("_sha2: outputLen bigger than state");for(let m=0;m<a;m++)s.setUint32(4*m,c[m],r)}digest(){let{buffer:e,outputLen:t}=this;this.digestInto(e);let n=e.slice(0,t);return this.destroy(),n}_cloneInto(e){e||(e=new this.constructor),e.set(...this.get());let{blockLen:t,buffer:n,length:o,finished:r,destroyed:i,pos:s}=this;return e.length=o,e.pos=s,e.finished=r,e.destroyed=i,o%t&&e.buffer.set(n),e}};var td=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),_n=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),En=new Uint32Array(64),Gs=class extends Kr{constructor(){super(64,32,8,!1),this.A=_n[0]|0,this.B=_n[1]|0,this.C=_n[2]|0,this.D=_n[3]|0,this.E=_n[4]|0,this.F=_n[5]|0,this.G=_n[6]|0,this.H=_n[7]|0}get(){let{A:e,B:t,C:n,D:o,E:r,F:i,G:s,H:u}=this;return[e,t,n,o,r,i,s,u]}set(e,t,n,o,r,i,s,u){this.A=e|0,this.B=t|0,this.C=n|0,this.D=o|0,this.E=r|0,this.F=i|0,this.G=s|0,this.H=u|0}process(e,t){for(let m=0;m<16;m++,t+=4)En[m]=e.getUint32(t,!1);for(let m=16;m<64;m++){let p=En[m-15],d=En[m-2],f=en(p,7)^en(p,18)^p>>>3,y=en(d,17)^en(d,19)^d>>>10;En[m]=y+En[m-7]+f+En[m-16]|0}let{A:n,B:o,C:r,D:i,E:s,F:u,G:a,H:c}=this;for(let m=0;m<64;m++){let p=en(s,6)^en(s,11)^en(s,25),d=c+p+Zu(s,u,a)+td[m]+En[m]|0,y=(en(n,2)^en(n,13)^en(n,22))+Ju(n,o,r)|0;c=a,a=u,u=s,s=i+d|0,i=r,r=o,o=n,n=d+y|0}n=n+this.A|0,o=o+this.B|0,r=r+this.C|0,i=i+this.D|0,s=s+this.E|0,u=u+this.F|0,a=a+this.G|0,c=c+this.H|0,this.set(n,o,r,i,s,u,a,c)}roundClean(){En.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}};var ec=$u(()=>new Gs);import{PublicKey as fd}from"@solana/web3.js";import rc,{isBN as sc}from"bn.js";import{bits as nd,BitStructure as NP,blob as od,Blob as MP,cstr as vP,f32 as FP,f32be as VP,f64 as _P,f64be as EP,greedy as WP,Layout as id,ns64 as DP,ns64be as qP,nu64 as rd,nu64be as UP,offset as sd,s16 as GP,s16be as XP,s24 as zP,s24be as YP,s32 as ad,s32be as QP,s40 as HP,s40be as jP,s48 as $P,s48be as ZP,s8 as JP,seq as ud,struct as eA,Structure as cd,u16 as ld,u16be as tA,u24 as nA,u24be as oA,u32 as md,u32be as iA,u40 as rA,u40be as sA,u48 as aA,u48be as uA,u8 as dd,UInt as pd,union as cA,Union as lA,unionLayoutDiscriminator as mA,utf8 as dA}from"@solana/buffer-layout";var Sr=id,tc=cd;var Xs=pd;var nc=dd,Ft=ld;var li=md;var oc=rd;var We=ad;var ic=ud;var Te=od;var zs=nd,Ys=sd;var no=class extends Sr{constructor(t,n,o){super(t,o);this.blob=Te(t),this.signed=n}decode(t,n=0){let o=new rc(this.blob.decode(t,n),10,"le");return this.signed?o.fromTwos(this.span*8).clone():o}encode(t,n,o=0){return typeof t=="number"&&(t=new rc(t)),this.signed&&(t=t.toTwos(this.span*8)),this.blob.encode(t.toArrayLike(Buffer,"le",this.span),n,o)}},Cr=class extends Sr{constructor(t){super(8,t);this._lower=zs(li(),!1),this._upper=zs(li(),!1)}addBoolean(t){this._lower.fields.length<32?this._lower.addBoolean(t):this._upper.addBoolean(t)}decode(t,n=0){let o=this._lower.decode(t,n),r=this._upper.decode(t,n+this._lower.span);return M(M({},o),r)}encode(t,n,o=0){return this._lower.encode(t,n,o)+this._upper.encode(t,n,o+this._lower.span)}};function _(l){return new Xs(1,l)}function ct(l){return new Xs(4,l)}function A(l){return new no(8,!1,l)}function ne(l){return new no(16,!1,l)}function ac(l){return new no(1,!0,l)}function Co(l){return new no(8,!0,l)}function uc(l){return new no(16,!0,l)}var oo=class extends Sr{constructor(t,n,o,r){super(t.span,r);this.layout=t,this.decoder=n,this.encoder=o}decode(t,n){return this.decoder(this.layout.decode(t,n))}encode(t,n,o){return this.layout.encode(this.encoder(t),n,o)}getSpan(t,n){return this.layout.getSpan(t,n)}};function O(l){return new oo(Te(32),e=>new fd(e),e=>e.toBuffer(),l)}function De(l){return new oo(nc(),yd,bd,l)}function yd(l){if(l===0)return!1;if(l===1)return!0;throw new Error("Invalid bool: "+l)}function bd(l){return l?1:0}function cc(l,e){let t=li("length"),n=F([t,Y(l,Ys(t,-t.span),"values")]);return new oo(n,({values:o})=>o,o=>({values:o}),e)}function gd(l){let e=li("length"),t=F([e,Te(Ys(e,-e.span),"data")]);return new oo(t,({data:n})=>n,n=>({data:n}),l)}function lt(l){return new oo(gd(),e=>e.toString("utf-8"),e=>Buffer.from(e,"utf-8"),l)}var Qs=class extends tc{decode(e,t){return super.decode(e,t)}};function F(l,e,t){return new Qs(l,e,t)}function Y(l,e,t){let n,o=typeof e=="number"?e:sc(e)?e.toNumber():new Proxy(e,{get(r,i){if(!n){let s=Reflect.get(r,"count");n=sc(s)?s.toNumber():s,Reflect.set(r,"count",n)}return Reflect.get(r,i)},set(r,i,s){return i==="count"&&(n=s),Reflect.set(r,i,s)}});return ic(l,o,t)}var tn=F([O("mint"),O("owner"),A("amount"),ct("delegateOption"),O("delegate"),_("state"),ct("isNativeOption"),A("isNative"),A("delegatedAmount"),ct("closeAuthorityOption"),O("closeAuthority")]);var NA=ye("Raydium_Util");function mc({owner:l,solAccountResp:e,tokenAccountResp:t}){let n=[],o=[];for(let{pubkey:r,account:i}of t.value){let s=tn.decode(i.data),{mint:u,amount:a}=s;n.push({publicKey:r,mint:u,amount:a,isAssociated:j(l,u,i.owner).publicKey.equals(r),isNative:!1,programId:i.owner}),o.push({pubkey:r,accountInfo:s,programId:i.owner})}return e&&n.push({mint:lc.default,amount:new Ad(String(e.lamports)),isNative:!0,programId:e.owner}),{tokenAccounts:n,tokenAccountRawInfos:o}}function Qe({fromPublicKey:l,programId:e=kd,assignSeed:t}){let n=t?btoa(t).slice(0,32):Pd.generate().publicKey.toBase58().slice(0,32);return{publicKey:wd(l,n,e),seed:n}}function wd(l,e,t){let n=Buffer.concat([l.toBuffer(),Buffer.from(e),t.toBuffer()]),o=ec(n);return new lc(o)}function Hs(l){let{mint:e,tokenAccount:t,owner:n,programId:o=Ro}=l;return xd(t,e,n,o)}function kn(l){let{tokenAccount:e,payer:t,multiSigners:n=[],owner:o,programId:r=Ro}=l;return Bd(e,t,o,n,r)}async function Wn(l){let{connection:e,amount:t,commitment:n,payer:o,owner:r,skipCloseAccount:i}=l,s=await e.getMinimumBalanceForRentExemption(tn.span,n),u=J(t).add(new Id(s)),a=Qe({fromPublicKey:o,programId:Ro});return{addresses:{newAccount:a.publicKey},signers:[],instructions:[hd.createAccountWithSeed({fromPubkey:o,basePubkey:o,seed:a.seed,newAccountPubkey:a.publicKey,lamports:u.toNumber(),space:tn.span,programId:Ro}),Hs({mint:new Td(it.address),tokenAccount:a.publicKey,owner:r,programId:Ro})],instructionTypes:[G.CreateAccount,G.InitAccount],endInstructionTypes:i?[]:[G.CloseAccount],endInstructions:i?[]:[kn({tokenAccount:a.publicKey,payer:o,owner:r})]}}function dc({source:l,destination:e,owner:t,amount:n,multiSigners:o=[],tokenProgram:r=Ro}){return Kd(l,e,t,BigInt(String(n)),o,r)}var mi=class extends Ee{constructor(t){super(t);this._tokenAccounts=[];this._tokenAccountRawInfos=[];this._accountListener=[];this._clientOwnedToken=!1;this._notSubscribeAccountChange=!1;this._accountFetchTime=0;let{tokenAccounts:n,tokenAccountRawInfos:o,notSubscribeAccountChange:r}=t;this._tokenAccounts=n||[],this._tokenAccountRawInfos=o||[],this._notSubscribeAccountChange=r!=null?r:!0,this._clientOwnedToken=!!(n||o)}get tokenAccounts(){return this._tokenAccounts}get tokenAccountRawInfos(){return this._tokenAccountRawInfos}set notSubscribeAccountChange(t){this._notSubscribeAccountChange=t}updateTokenAccount({tokenAccounts:t,tokenAccountRawInfos:n}){return t&&(this._tokenAccounts=t),n&&(this._tokenAccountRawInfos=n),this._accountChangeListenerId&&this.scope.connection.removeAccountChangeListener(this._accountChangeListenerId),this._accountChangeListenerId=void 0,this._clientOwnedToken=!0,this}addAccountChangeListener(t){return this._accountListener.push(t),this}removeAccountChangeListener(t){return this._accountListener=this._accountListener.filter(n=>n!==t),this}getAssociatedTokenAccount(t,n){return j(this.scope.ownerPubKey,t,n).publicKey}getAssociatedTokenAccountByOwner(t,n,o){return j(t,n,o).publicKey}resetTokenAccounts(){this._clientOwnedToken||(this._tokenAccounts=[],this._tokenAccountRawInfos=[])}async fetchWalletTokenAccounts(t){if(this._clientOwnedToken||!(t!=null&&t.forceUpdate)&&this._tokenAccounts.length&&Date.now()-this._accountFetchTime<(this._notSubscribeAccountChange?1e3*5:1e3*60*3))return{tokenAccounts:this._tokenAccounts,tokenAccountRawInfos:this._tokenAccountRawInfos};this.scope.checkOwner();let o=M(M({},{}),t),[r,i,s]=await Promise.all([this.scope.connection.getAccountInfo(this.scope.ownerPubKey,o.commitment),this.scope.connection.getTokenAccountsByOwner(this.scope.ownerPubKey,{programId:Dn},o.commitment),this.scope.connection.getTokenAccountsByOwner(this.scope.ownerPubKey,{programId:Cd},o.commitment)]),{tokenAccounts:u,tokenAccountRawInfos:a}=mc({owner:this.scope.ownerPubKey,solAccountResp:r,tokenAccountResp:{context:i.context,value:[...i.value,...s.value]}});return this._tokenAccounts=u,this._tokenAccountRawInfos=a,this._accountFetchTime=Date.now(),this._notSubscribeAccountChange||(this._accountChangeListenerId&&this.scope.connection.removeAccountChangeListener(this._accountChangeListenerId),this._accountChangeListenerId=this.scope.connection.onAccountChange(this.scope.ownerPubKey,()=>{this.fetchWalletTokenAccounts({forceUpdate:!0}),this._accountListener.forEach(c=>c({tokenAccounts:this._tokenAccounts,tokenAccountRawInfos:this._tokenAccountRawInfos}))},{commitment:t==null?void 0:t.commitment})),{tokenAccounts:u,tokenAccountRawInfos:a}}clearAccountChangeCkb(){this._accountChangeListenerId!==void 0&&this.scope.connection.removeAccountChangeListener(this._accountChangeListenerId)}async getCreatedTokenAccount({mint:t,programId:n=Dn,associatedOnly:o=!0}){await this.fetchWalletTokenAccounts();let r=this._tokenAccounts.filter(({mint:s})=>s==null?void 0:s.equals(t)).sort((s,u)=>s.amount.lt(u.amount)?1:-1),i=this.getAssociatedTokenAccount(t,n);for(let s of r){let{publicKey:u}=s;if(u&&(!o||o&&i.equals(u)))return u}}async getOrCreateTokenAccount(t){var y,b,g,P;await this.fetchWalletTokenAccounts();let{mint:n,createInfo:o,associatedOnly:r,owner:i,notUseTokenAccount:s=!1,skipCloseAccount:u=!1,checkCreateATAOwner:a=!1,assignSeed:c}=t;console.log("******************associatedOnly: ",r);let m=new Rr(t.tokenProgram||Dn),p=this.getAssociatedTokenAccount(n,new Rr(m)),d=(s?[]:this.tokenAccountRawInfos).filter(h=>h.accountInfo.mint.equals(n)&&(!r||h.pubkey.equals(p))).sort((h,I)=>h.accountInfo.amount.lt(I.accountInfo.amount)?1:-1);if(o===void 0||d.length>0)return d.length>0?{account:d[0].pubkey}:{};let f={instructions:[],endInstructions:[],signers:[],instructionTypes:[],endInstructionTypes:[]};if(r){let h=js(i,p,i,n,m),I=this.tokenAccountRawInfos.find(T=>T.pubkey.equals(p));if(a){console.log("******************checkCreateATAOwner: ",a);let T=await this.scope.connection.getAccountInfo(p);if(T===null)console.log("******************ataInfo == null: ",a),(y=f.instructions)==null||y.push(h),f.instructionTypes.push(G.CreateATA);else if(T.owner.equals(m)&&Lo.decode(T.data).mint.equals(n)&&Lo.decode(T.data).owner.equals(i))console.log("******************else empty: ");else throw Error(`create ata check error -> mint: ${n.toString()}, ata: ${p.toString()}`)}else I===void 0&&(console.log("******************_ataInTokenAcc undefined"),f.instructions.push(h),f.instructionTypes.push(G.CreateATA));if(n.equals($)&&o.amount){console.log("createWSolAccountInstructions*********************************");let T=await Wn({connection:this.scope.connection,owner:i||this.scope.ownerPubKey,payer:o.payer||this.scope.ownerPubKey,amount:(b=o.amount)!=null?b:0,skipCloseAccount:u});f.instructions.push(...T.instructions||[]),f.endInstructions.push(...T.endInstructions||[]),f.instructionTypes.push(...T.instructionTypes||[]),f.endInstructionTypes.push(...T.endInstructionTypes||[]),o.amount&&(console.log("******************createInfo.amount"),f.instructions.push(dc({source:T.addresses.newAccount,destination:p,owner:i||this.scope.ownerPubKey,amount:o.amount,tokenProgram:Dn})),f.instructionTypes.push(G.TransferAmount))}return!u&&I===void 0&&(console.log("******************skipCloseAccount"),f.endInstructions.push(kn({owner:i,payer:o.payer||i,tokenAccount:p,programId:m})),f.endInstructionTypes.push(G.CloseAccount)),{account:p,instructionParams:f}}else{console.log("******************newTokenAccount");let h=Qe({fromPublicKey:i,programId:m,assignSeed:c}),I=await this.scope.connection.getMinimumBalanceForRentExemption(Lo.span),T=Sd.createAccountWithSeed({fromPubkey:i,basePubkey:i,seed:h.seed,newAccountPubkey:h.publicKey,lamports:I+Number((P=(g=o.amount)==null?void 0:g.toString())!=null?P:0),space:Lo.span,programId:m});return f.instructions.push(T,Hs({mint:n,tokenAccount:h.publicKey,owner:i||this.scope.ownerPubKey,programId:m})),f.instructionTypes.push(G.CreateAccount),f.instructionTypes.push(G.InitAccount),u||(f.endInstructions.push(kn({owner:i,payer:o.payer||i,tokenAccount:h.publicKey,programId:m})),f.endInstructionTypes.push(G.CloseAccount)),{account:h.publicKey,instructionParams:f}}}async checkOrCreateAta({mint:t,programId:n=Dn,autoUnwrapWSOLToSOL:o}){var u;await this.fetchWalletTokenAccounts();let r=(u=this.scope.account.tokenAccounts.find(({mint:a})=>(a==null?void 0:a.toBase58())===t.toBase58()))==null?void 0:u.publicKey,i=this.scope.ownerPubKey,s={};if(!r){let a=this.getAssociatedTokenAccount(t,n),c=await js(i,a,i,t,n);s.instructions=[c],s.instructionTypes=[G.CreateATA],r=a}return o&&$.toBase58()===t.toBase58()&&(s.endInstructions=[kn({owner:i,payer:i,tokenAccount:r,programId:n})],s.endInstructionTypes=[G.CloseAccount]),{pubKey:r,newInstructions:s}}async handleTokenAccount(t){let{side:n,amount:o,mint:r,programId:i=Dn,tokenAccount:s,payer:u=this.scope.ownerPubKey,bypassAssociatedCheck:a,skipCloseAccount:c,checkCreateATAOwner:m}=t,p=this.getAssociatedTokenAccount(r,i);if(new Rr($).equals(r)){let d=await Wn({connection:this.scope.connection,owner:this.scope.ownerPubKey,payer:u,amount:o,skipCloseAccount:c});return M({tokenAccount:d.addresses.newAccount},d)}else if(!s||n==="out"&&!p.equals(s)&&!a){let d=[],f=js(this.scope.ownerPubKey,p,this.scope.ownerPubKey,r,i);if(m){let y=await this.scope.connection.getAccountInfo(p);if(y===null)d.push(f);else if(!(y.owner.equals(Dn)&&Lo.decode(y.data).mint.equals(r)&&Lo.decode(y.data).owner.equals(this.scope.ownerPubKey)))throw Error(`create ata check error -> mint: ${r.toString()}, ata: ${p.toString()}`)}else d.push(f);return{tokenAccount:p,instructions:d,instructionTypes:[G.CreateATA]}}return{tokenAccount:s}}async processTokenAccount(t){let{mint:n,programId:o=Dn,amount:r,useSOLBalance:i,handleTokenAccount:s,feePayer:u}=t,a,c=this.createTxBuilder(u);if(n.equals(new Rr($))&&i){let m=await this.handleTokenAccount({side:"in",amount:r||0,mint:n,bypassAssociatedCheck:!0,programId:o}),{tokenAccount:d}=m,f=Fe(m,["tokenAccount"]);a=d,c.addInstruction(f)}else if(a=await this.getCreatedTokenAccount({mint:n,associatedOnly:!1,programId:o}),!a&&s){let p=await this.scope.account.handleTokenAccount({side:"in",amount:0,mint:n,bypassAssociatedCheck:!0,programId:o}),{tokenAccount:d}=p,f=Fe(p,["tokenAccount"]);a=d,c.addInstruction(f)}return M({tokenAccount:a},c.AllTxData)}};import{PublicKey as Be,SystemProgram as $d}from"@solana/web3.js";import{createAssociatedTokenAccountIdempotentInstruction as Lc}from"@solana/spl-token";import Zd from"decimal.js";import{PublicKey as na}from"@solana/web3.js";var $s=F([_("instruction")]),Zs=F([_("instruction")]),Rd=F([A("rewardState"),A("rewardOpenTime"),A("rewardEndTime"),A("rewardLastUpdateTime"),A("totalReward"),A("totalRewardEmissioned"),A("rewardClaimed"),A("rewardPerSecond"),ne("accRewardPerShare"),O("rewardVault"),O("rewardMint"),O("rewardSender"),A("rewardType"),Y(A(),15,"padding")]),Ld=F([A("state"),A("nonce"),O("lpVault"),O("rewardVault"),O(),O(),A(),A(),A("totalReward"),ne("perShareReward"),A("lastSlot"),A("perSlotReward")]),Od=F([A("state"),A("nonce"),O("lpVault"),O("rewardVaultA"),A("totalRewardA"),ne("perShareRewardA"),A("perSlotRewardA"),_("option"),O("rewardVaultB"),Te(7),A("totalRewardB"),ne("perShareRewardB"),A("perSlotRewardB"),A("lastSlot"),O()]),Nd=F([A(),A("state"),A("nonce"),A("validRewardTokenNum"),ne("rewardMultiplier"),A("rewardPeriodMax"),A("rewardPeriodMin"),A("rewardPeriodExtend"),O("lpMint"),O("lpVault"),Y(Rd,5,"rewardInfos"),O("creator"),O(),Y(A(),32,"padding")]),pc=new Proxy(Ld,{get(l,e,t){return e==="decode"?(...n)=>{let o=l.decode(...n);return q(M({},o),{version:3,rewardInfos:[{rewardVault:o.rewardVault,totalReward:o.totalReward,perSlotReward:o.perSlotReward,perShareReward:o.perShareReward}]})}:Reflect.get(l,e,t)}}),fc=new Proxy(Od,{get(l,e,t){return e==="decode"?(...n)=>{let o=l.decode(...n);return q(M({},o),{version:5,rewardInfos:[{rewardVault:o.rewardVaultA,totalReward:o.totalRewardA,perSlotReward:o.perSlotRewardA,perShareReward:o.perShareRewardA},{rewardVault:o.rewardVaultB,totalReward:o.totalRewardB,perSlotReward:o.perSlotRewardB,perShareReward:o.perShareRewardB}]})}:Reflect.get(l,e,t)}}),di=new Proxy(Nd,{get(l,e,t){return e==="decode"?(...n)=>{let o=l.decode(...n);return q(M({},o),{version:6,rewardInfos:o.rewardInfos.map(r=>{var i;return q(M({},r),{rewardType:((i=Object.entries(qn).find(s=>String(s[1])===r.rewardType.toString()))!=null?i:["Standard SPL"])[0]})})})}:Reflect.get(l,e,t)}}),Md=F([A("isSet"),A("rewardPerSecond"),A("rewardOpenTime"),A("rewardEndTime"),A("rewardType")]),Js=F([_("instruction"),A("nonce"),Y(Md,5,"rewardTimeInfo")]),ea=F([_("instruction"),A("rewardReopenTime"),A("rewardEndTime"),A("rewardPerSecond")]),ta=F([_("instruction"),A("isSet"),A("rewardPerSecond"),A("rewardOpenTime"),A("rewardEndTime"),A("rewardType")]),mk=F([A("state"),O("id"),O("owner"),A("deposited"),Y(A(),1,"rewardDebts")]),pi=F([A("state"),O("id"),O("owner"),A("deposited"),Y(ne(),1,"rewardDebts"),A(""),A("voteLockedBalance"),Y(A(),15)]),dk=F([A("state"),O("id"),O("owner"),A("deposited"),Y(A(),2,"rewardDebts")]),yc=F([A("state"),O("id"),O("owner"),A("deposited"),Y(ne(),2,"rewardDebts"),Y(A(),17)]),bc=F([A(),A("state"),O("id"),O("owner"),A("deposited"),Y(ne(),5,"rewardDebts"),Y(A(),16)]),kt=F([_("instruction"),A("amount")]),vd=F([O("mint"),O("grantAuthority"),A("baselineVoteWeightScaledFactor"),A("maxExtraLockupVoteWeightScaledFactor"),A("lockupSaturationSecs"),ac("digitShift"),Y(_(),7,"reserved1"),Y(A(),7,"reserved2")]),gc=F([Te(8),O("governanceProgramId"),O("realm"),O("realmGoverningTokenMint"),O("realmAuthority"),Y(_(),32,"reserved1"),Y(vd,4,"votingMints"),Co("timeOffset"),_("bump"),Y(_(),7,"reserved2"),Y(A(),11,"reserved3")]),Fd=F([Co("startTime"),Co("endTime"),_("kind"),Y(_(),15,"reserved")]),Vd=F([Y(Fd,1,"lockup"),A("amountDeposited_native"),A("amountInitiallyLockedNative"),De("isUsed"),De("allowClawback"),_("votingMintConfigIdx"),Y(_(),29,"reserved")]),Pc=F([Te(8),O("voterAuthority"),O("registrar"),Y(Vd,32,"deposits"),_("voterBump"),_("voterWweightRecordBump"),Y(_(),94,"reserved")]);import{NATIVE_MINT as _d}from"@solana/spl-token";var wk=ye("Raydium_farm_config"),Ac=new na("4k3Dyjzvzp8eMZWUXbBCjEvwSkkk59S5iCNLY3QrkX6R"),kc=new na("FrspKwj8i3pNmKwXreTveC4fu7KL5ZbGeXdZBe2XViu1"),Tk=_d,hk=new na("3TRTX4dXUpp2eqxi3tvQDFYUV7SdDJjcPE3Y4mbtftaX"),wc={3:pc,5:fc,6:di},Tc={3:pi,5:yc,6:bc},oa=l=>[3,4,5,6].indexOf(l)!==-1,ia=l=>{var i;let{version:e,rewardInfos:t,rewardTokenAccountsPublicKeys:n}=l,o=`rewardInfo:${JSON.stringify(t)}, rewardAccount:${JSON.stringify(n)}`,r={3:()=>{if(t.length!==1||n.length!==1)return`rewardInfos or rewardTokenAccounts lengths not equal 1: ${o}`},5:()=>{if(t.length!==n.length)return`rewardInfos and rewardTokenAccounts lengths not equal: ${o}`},6:()=>{if(!n.length||t.length!==n.length)return`no rewardTokenAccounts or rewardInfos and rewardTokenAccounts lengths not equal: ${o}`}};return(i=r[e])==null?void 0:i.call(r)},qn={"Standard SPL":0,"Option tokens":1},qt={[Ks.toString()]:3,[Ss.toString()]:4,[Cs.toString()]:5,[Bo.toString()]:6,[gn.FARM_PROGRAM_ID_V3.toString()]:3,[gn.FARM_PROGRAM_ID_V4.toString()]:4,[gn.FARM_PROGRAM_ID_V5.toString()]:5,[gn.FARM_PROGRAM_ID_V6.toString()]:6};import{PublicKey as ce,SystemProgram as io,SYSVAR_CLOCK_PUBKEY as No,SYSVAR_RENT_PUBKEY as Dd,TransactionInstruction as tt}from"@solana/web3.js";import Lr from"bn.js";import{ASSOCIATED_TOKEN_PROGRAM_ID as qd,createAssociatedTokenAccountIdempotentInstruction as Ud,TOKEN_PROGRAM_ID as Ct}from"@solana/spl-token";function ra(l,e,t){return te([e.toBuffer(),Buffer.from("registrar","utf8"),t.toBuffer()],l)}function sa(l,e){return te([e.toBuffer(),Buffer.from("voting_mint_seed","utf8")],l)}function aa(l,e){return te([e.toBuffer()],l)}function ua(l,e,t){return te([e.toBuffer(),Buffer.from("voter","utf8"),t.toBuffer()],l)}function ca(l,e,t){return te([e.toBuffer(),Buffer.from("voter-weight-record","utf8"),t.toBuffer()],l)}function la(l,e,t,n){return te([Buffer.from("governance","utf8"),e.toBuffer(),t.toBuffer(),n.toBuffer()],l)}import St from"bn.js";var fi=ye("Raydium.farm.util");function yi({programId:l,poolId:e,mint:t,type:n}){let{publicKey:o}=te([e.toBuffer(),t.toBuffer(),Buffer.from(n==="lpVault"?"lp_vault_associated_seed":n==="rewardVault"?"reward_vault_associated_seed":"","utf-8")],l);return o}function pt({programId:l,poolId:e,owner:t,version:n}){let{publicKey:o}=te([e.toBuffer(),t.toBuffer(),Buffer.from(n===6?"farmer_info_associated_seed":"staker_info_v2_associated_seed","utf-8")],l);return o}var hc=({programId:l,poolId:e})=>te([e.toBuffer()],l);function Ic(l){return{isSet:new St(1),rewardPerSecond:J(l.perSecond),rewardOpenTime:J(l.openTime),rewardEndTime:J(l.endTime),rewardType:J(qn[l.rewardType])}}function ma(l){return J(l.endTime).sub(J(l.openTime)).mul(J(l.perSecond))}function Oo(l){let e=Tc[l];return e||fi.logWithError("invalid version",l),e}function Ed(l){let e=wc[l];return e||fi.logWithError("invalid version",l),e}function Wd(l,e,t,n){if(l.version===3||l.version===5){if(l.lastSlot.gte(new St(t)))return l;let o=new St(t).sub(l.lastSlot);l.lastSlot=new St(t);for(let r of l.rewardInfos){if(e.amount.eq(new St(0)))continue;let i=r.perSlotReward.mul(o);r.perShareReward=r.perShareReward.add(i.mul(new St(10).pow(new St(l.version===3?9:15))).div(e.amount)),r.totalReward=r.totalReward.add(i)}}else if(l.version===6)for(let o of l.rewardInfos){if(o.rewardState.eq(new St(0)))continue;let r=St.min(new St(n),o.rewardEndTime);if(o.rewardOpenTime.gte(r))continue;let s=r.sub(o.rewardLastUpdateTime).mul(o.rewardPerSecond),u=o.totalReward.sub(o.totalRewardEmissioned);u.lt(s)?(s=u,o.rewardLastUpdateTime=o.rewardLastUpdateTime.add(u.div(o.rewardPerSecond))):o.rewardLastUpdateTime=r,!e.amount.eq(new St(0))&&(o.accRewardPerShare=o.accRewardPerShare.add(s.mul(l.rewardMultiplier).div(e.amount)),o.totalRewardEmissioned=o.totalRewardEmissioned.add(s))}return l}async function Wk({connection:l,farmPools:e,owner:t,config:n,chainTime:o}){let r=!1,i=!1,s=new St(10),u=[];for(let p of e){let d=_e(p);d.version===6?i=!0:r=!0,u.push({pubkey:d.id,version:d.version,key:"state",poolId:d.id},{pubkey:d.lpVault,version:d.version,key:"lpVault",poolId:d.id}),t&&u.push({pubkey:pt({programId:d.programId,poolId:d.id,owner:t,version:p.version}),version:d.version,key:"ledger",poolId:d.id})}let a={},c=await Ne(l,u,n);for(let{pubkey:p,version:d,key:f,poolId:y,accountInfo:b}of c){let g=y.toBase58();if(a[g]=M({},a[g]),f==="state"){let P=Ed(d);(!b||!b.data||b.data.length!==P.span)&&fi.logWithError(`invalid farm state account info, pools.id, ${p}`),a[g].state=P.decode(b.data)}else if(f==="lpVault")(!b||!b.data||b.data.length!==tn.span)&&fi.logWithError(`invalid farm lp vault account info, pools.lpVault, ${p}`),a[g].lpVault=tn.decode(b.data);else if(f==="ledger"){let P=Oo(d);b&&b.data&&(b.data.length!==P.span&&fi.logWithError(`invalid farm ledger account info, ledger, ${p}`),a[g].ledger=P.decode(b.data))}}let m=i||r?await l.getSlot():0;for(let p of Object.keys(a))a[p]!==void 0&&(a[p].state=Wd(a[p].state,a[p].lpVault,m,o));for(let[p,{state:d,ledger:f}]of Object.entries(a))if(f){let y=d.version===6?d.rewardMultiplier:d.rewardInfos.length===1?s.pow(new St(9)):s.pow(new St(15)),b=d.rewardInfos.map((g,P)=>{let h=f.rewardDebts[P];return f.deposited.mul(d.version===6?g.accRewardPerShare:g.perShareReward).div(y).sub(h)});a[p].wrapped=q(M({},a[p].wrapped),{pendingRewards:b})}return a}function Dk(l,e=Date.now()){if(l.version===6){let t=l.state.rewardInfos;if(t.every(({rewardOpenTime:n})=>_u(e,n.toNumber(),{unit:"s"})))return"upcoming pool";if(t.every(({rewardEndTime:n})=>Eu(e,n.toNumber(),{unit:"s"})))return"closed pool"}else{let t=l.state.rewardInfos.map(({perSlotReward:n})=>n);if(t.length===2){if(String(t[0])==="0"&&String(t[1])!=="0")return"normal fusion pool";if(String(t[0])!=="0"&&String(t[1])!=="0")return"dual fusion pool";if(String(t[0])==="0"&&String(t[1])==="0")return"closed pool"}else if(t.length===1&&String(t[0])==="0")return"closed pool"}}async function da(l,e,t,n){let o=await l.getAccountInfo(e);if(o===null)throw Error("registrar info check error");let i=gc.decode(o.data).votingMints.findIndex(c=>c.mint.equals(n));if(i===-1)throw Error("find voter mint error");let s=await l.getAccountInfo(t);if(s===null)return{index:i,isInit:!1};let a=Pc.decode(s.data).deposits.findIndex(c=>c.isUsed&&c.votingMintConfigIdx===i);return a===-1?{index:i,isInit:!1}:{index:a,isInit:!0}}var Gd=ye("Raydium_farm_instruction"),bi={voterStakeRegistryCreateVoter:Buffer.from([6,24,245,52,243,255,148,25]),voterStakeRegistryCreateDepositEntry:Buffer.from([185,131,167,186,159,125,19,67]),voterStakeRegistryDeposit:Buffer.from([242,35,198,137,82,225,242,182]),voterStakeRegistryWithdraw:Buffer.from([183,18,70,156,148,109,161,34]),voterStakeRegistryUpdateVoterWeightRecord:Buffer.from([45,185,3,36,109,190,115,169])};function gi(l){let{version:e,id:t,ledger:n,programId:o,owner:r}=l,i={3:9,5:10}[e];i||Gd.logWithError(`invalid farm pool version: ${e}`);let s=Buffer.alloc($s.span);$s.encode({instruction:i},s);let u=[k({pubkey:t}),k({pubkey:n}),k({pubkey:r,isWritable:!1}),k({pubkey:io.programId,isWritable:!1}),k({pubkey:Dd,isWritable:!1})];return{instruction:new tt({programId:o,keys:u,data:s}),instructionType:G.FarmV3CreateLedger}}function Bc(l){var n;let e=Buffer.alloc(Js.span);Js.encode({instruction:0,nonce:new Lr(l.nonce),rewardTimeInfo:l.rewardInfoConfig},e);let t=[...As,k({pubkey:l.farmId}),k({pubkey:l.farmAuthority,isWritable:!1}),k({pubkey:l.lpVault}),k({pubkey:l.lpMint,isWritable:!1}),k({pubkey:l.lockVault}),k({pubkey:l.lockMint,isWritable:!1}),k({pubkey:(n=l.lockUserAccount)!=null?n:rt}),k({pubkey:l.owner,isWritable:!1,isSigner:!0})];for(let o of l.rewardInfo)t.push(k({pubkey:o.rewardMint,isWritable:!1}),k({pubkey:o.rewardVault}),k({pubkey:o.userRewardToken}));return{instruction:new tt({programId:l.programId,keys:t,data:e}),instructionType:G.FarmV6Create}}function xc(l){let e=Buffer.alloc(Zs.span);Zs.encode({instruction:5},e);let t=[k({pubkey:Ct,isWritable:!1}),k({pubkey:l.id}),k({pubkey:l.authority,isWritable:!1}),k({pubkey:l.lpVault,isWritable:!1}),k({pubkey:l.rewardVault}),k({pubkey:l.userRewardToken}),k({pubkey:l.owner,isWritable:!1,isSigner:!0})];return{instruction:new tt({programId:l.programId,keys:t,data:e}),instructionType:G.FarmV6CreatorWithdraw}}function Xd(l,e,t,n,o,r,i,s,u,a,c,m,p){let d=F([_("depositEntryIndex"),A("amount")]),f=[{pubkey:e,isSigner:!1,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!1},{pubkey:Ct,isSigner:!1,isWritable:!1},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!1},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!1},{pubkey:c,isSigner:!1,isWritable:!1},{pubkey:lr,isSigner:!1,isWritable:!1}],y=Buffer.alloc(d.span);d.encode({depositEntryIndex:m,amount:p},y);let b=Buffer.from([...bi.voterStakeRegistryDeposit,...y]);return new tt({keys:f,programId:l,data:b})}function zd(l,e,t,n){let o=F([]),r=[{pubkey:e,isSigner:!1,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:io.programId,isSigner:!1,isWritable:!1}],i=Buffer.alloc(o.span);o.encode({},i);let s=Buffer.from([...bi.voterStakeRegistryUpdateVoterWeightRecord,...i]);return new tt({keys:r,programId:l,data:s})}function Yd(l,e,t,n,o,r,i,s,u,a,c,m,p,d,f){let y=F([_("depositEntryIndex"),A("amount")]),b=[{pubkey:e,isSigner:!1,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!0,isWritable:!1},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:Ct,isSigner:!1,isWritable:!1},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!1},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:m,isSigner:!1,isWritable:!1},{pubkey:p,isSigner:!1,isWritable:!1},{pubkey:lr,isSigner:!1,isWritable:!1}],g=Buffer.alloc(y.span);y.encode({depositEntryIndex:d,amount:f},g);let P=Buffer.from([...bi.voterStakeRegistryWithdraw,...g]);return new tt({keys:b,programId:l,data:P})}function Qd(l,e,t,n,o,r){let i=F([_("ins")]),s=[{pubkey:e,isSigner:!1,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!0,isWritable:!0},{pubkey:io.programId,isSigner:!1,isWritable:!1}],u=Buffer.alloc(i.span);return i.encode({ins:23},u),new tt({keys:s,programId:l,data:u})}function Hd(l,e,t,n,o,r,i,s){let u=F([_("voterBump"),_("voterWeightRecordBump")]),a=[{pubkey:e,isSigner:!1,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!0,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!0,isWritable:!0},{pubkey:io.programId,isSigner:!1,isWritable:!1},{pubkey:$e,isSigner:!1,isWritable:!1},{pubkey:lr,isSigner:!1,isWritable:!1}],c=Buffer.alloc(u.span);u.encode({voterBump:i,voterWeightRecordBump:s},c);let m=Buffer.from([...bi.voterStakeRegistryCreateVoter,...c]);return new tt({keys:a,programId:l,data:m})}function jd(l,e,t,n,o,r,i,s,u,a,c,m){let p=F([_("depositEntryIndex"),_("kind"),_("option"),A("startTs"),ct("periods"),De("allowClawback")]),d=[{pubkey:e,isSigner:!1,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!0,isWritable:!1},{pubkey:r,isSigner:!0,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!1},{pubkey:io.programId,isSigner:!1,isWritable:!1},{pubkey:Ct,isSigner:!1,isWritable:!1},{pubkey:qd,isSigner:!1,isWritable:!1},{pubkey:$e,isSigner:!1,isWritable:!1}],f=Buffer.alloc(p.span);p.encode({depositEntryIndex:s,kind:u,option:a===void 0?0:1,startTs:a,periods:c,allowClawback:m},f);let y=Buffer.from([...bi.voterStakeRegistryCreateDepositEntry,...f]);return new tt({keys:d,programId:l,data:y})}async function ow({connection:l,programId:e,governanceProgramId:t,voteWeightAddinProgramId:n,realm:o,communityTokenMint:r,owner:i,poolId:s,tokenProgram:u}){let a=ra(n,o,r).publicKey,c=pt({programId:e,poolId:s,owner:i,version:3}),m=await l.getAccountInfo(c);if(m===null)throw Error("user is not staker");let p=pi.decode(m.data),d=p.deposited.sub(p.voteLockedBalance);if(console.log("amount",d.toString()),d.eq(new Lr(0)))throw Error("user do not has new stake amount");let f=sa(e,s).publicKey,y=aa(e,s).publicKey,{publicKey:b,nonce:g}=ua(n,a,i),P=j(b,f,u).publicKey,{publicKey:h,nonce:I}=ca(n,a,i),T=la(t,o,r,i).publicKey,w=[],K=j(i,f,u).publicKey;if(await l.getAccountInfo(K)===null&&w.push(Ud(i,K,i,f)),await l.getAccountInfo(b)===null){let C=Qd(t,o,i,r,i,T);w.push(C,Hd(n,a,b,h,i,i,g,I))}let{index:B,isInit:R}=await da(l,a,b,f);return R||w.push(jd(n,a,b,P,i,i,f,B,0,void 0,0,!1)),w.push(Xd(n,a,b,P,K,i,c,s,f,y,e,B,d),zd(n,a,b,h)),w}async function iw({connection:l,programId:e,governanceProgramId:t,voteWeightAddinProgramId:n,realm:o,communityTokenMint:r,owner:i,poolId:s,tokenProgram:u}){let a=ra(n,o,r).publicKey,c=pt({programId:e,poolId:s,owner:i,version:3}),m=await l.getAccountInfo(c);if(m===null)throw Error("user is not staker");let p=pi.decode(m.data);if(p.voteLockedBalance.eq(new Lr(0)))throw Error("user has vote locked balance = 0");let d=sa(e,s).publicKey,f=aa(e,s).publicKey,{publicKey:y}=ua(n,a,i),b=j(y,d,u).publicKey,{publicKey:g}=ca(n,a,i),P=la(t,o,r,i).publicKey,h=[],{index:I,isInit:T}=await da(l,a,y,d);if(!T)throw Error("deposit entry index check error");return h.push(Yd(n,a,y,i,P,g,b,j(i,d,u).publicKey,c,s,d,f,e,I,p.voteLockedBalance)),h}function pa({payer:l,rewardVault:e,userRewardTokenPub:t,farmKeys:n,rewardInfo:o}){let r=Buffer.alloc(ea.span);ea.encode({instruction:3,rewardReopenTime:J(o.openTime),rewardEndTime:J(o.endTime),rewardPerSecond:J(o.perSecond)},r);let i=[k({pubkey:Ct,isWritable:!1}),k({pubkey:n.id}),k({pubkey:n.lpVault,isWritable:!1}),k({pubkey:e}),k({pubkey:t}),k({pubkey:l,isWritable:!1,isSigner:!0})];return new tt({programId:n.programId,keys:i,data:r})}function fa({payer:l,userRewardTokenPub:e,farmKeys:t,rewardVault:n,rewardInfo:o}){let r=Buffer.alloc(ta.span);ta.encode({instruction:4,isSet:new Lr(1),rewardPerSecond:J(o.perSecond),rewardOpenTime:J(o.openTime),rewardEndTime:J(o.endTime),rewardType:J(qn[o.rewardType])},r);let i=[...As,k({pubkey:t.id}),k({pubkey:t.authority,isWritable:!1}),k({pubkey:o.mint,isWritable:!1}),k({pubkey:n}),k({pubkey:e}),k({pubkey:l,isWritable:!1,isSigner:!0})];return new tt({programId:t.programId,keys:i,data:r})}function rw(l){let{farmInfo:e,farmKeys:t,version:n,lpAccount:o,rewardAccounts:r,owner:i,instruction:s,amount:u,deposit:a}=l,[c,m]=[new ce(e.programId),new ce(e.id)],p=pt({programId:c,poolId:m,owner:i,version:n}),d=Buffer.alloc(kt.span);kt.encode({instruction:s,amount:u},d);let f=n===6?[k({pubkey:Ct,isWritable:!1}),...a?[k({pubkey:io.programId,isWritable:!1})]:[],k({pubkey:m}),k({pubkey:new ce(t.authority),isWritable:!1}),k({pubkey:new ce(t.lpVault)}),k({pubkey:p}),k({pubkey:i,isWritable:!1,isSigner:!0}),k({pubkey:o})]:[k({pubkey:m}),k({pubkey:new ce(t.authority),isWritable:!1}),k({pubkey:p}),k({pubkey:i,isWritable:!1,isSigner:!0}),k({pubkey:o}),k({pubkey:new ce(t.lpVault)}),k({pubkey:r[0]}),k({pubkey:new ce(t.rewardInfos[0].vault)}),k({pubkey:No,isWritable:!1}),k({pubkey:Ct,isWritable:!1})];if(n===5)for(let y=1;y<t.rewardInfos.length;y++)f.push(k({pubkey:r[y]})),f.push(k({pubkey:new ce(t.rewardInfos[y].vault)}));if(n===6)for(let y=0;y<t.rewardInfos.length;y++)f.push(k({pubkey:new ce(t.rewardInfos[y].vault)})),f.push(k({pubkey:r[y]}));return new tt({programId:c,keys:f,data:d})}function Pi(l){let{farmInfo:e,farmKeys:t,lpAccount:n,rewardAccounts:o,owner:r,amount:i}=l,[s,u]=[new ce(e.programId),new ce(e.id)],a=pt({programId:s,poolId:u,owner:r,version:6}),c=Buffer.alloc(kt.span);kt.encode({instruction:2,amount:J(i)},c);let m=[k({pubkey:Ct,isWritable:!1}),k({pubkey:u}),k({pubkey:new ce(t.authority),isWritable:!1}),k({pubkey:new ce(t.lpVault)}),k({pubkey:a}),k({pubkey:r,isWritable:!1,isSigner:!0}),k({pubkey:n})];for(let p=0;p<t.rewardInfos.length;p++)m.push(k({pubkey:new ce(t.rewardInfos[p].vault)})),m.push(k({pubkey:o[p]}));return new tt({programId:s,keys:m,data:c})}function Ai(l){let{farmInfo:e,farmKeys:t,lpAccount:n,rewardAccounts:o,owner:r,amount:i,userAuxiliaryLedgers:s}=l,[u,a]=[new ce(e.programId),new ce(e.id)],c=pt({programId:u,poolId:a,owner:r,version:5}),m=Buffer.alloc(kt.span);kt.encode({instruction:12,amount:J(i)},m);let p=[k({pubkey:a}),k({pubkey:new ce(t.authority),isWritable:!1}),k({pubkey:c}),k({pubkey:r,isWritable:!1,isSigner:!0}),k({pubkey:n}),k({pubkey:new ce(t.lpVault)}),k({pubkey:o[0]}),k({pubkey:new ce(t.rewardInfos[0].vault)}),k({pubkey:No,isWritable:!1}),k({pubkey:Ct,isWritable:!1})];for(let d=1;d<t.rewardInfos.length;d++)p.push(k({pubkey:o[d]})),p.push(k({pubkey:new ce(t.rewardInfos[d].vault)}));if(s)for(let d of s)p.push(k({pubkey:d}));return new tt({programId:u,keys:p,data:m})}function Kc(l){let{farmInfo:e,farmKeys:t,lpAccount:n,rewardAccounts:o,owner:r,amount:i,userAuxiliaryLedgers:s}=l,[u,a]=[new ce(e.programId),new ce(e.id)],c=F([_("instruction"),A("amount")]),m=[k({pubkey:a}),k({pubkey:new ce(t.authority),isWritable:!1}),k({pubkey:s[0]}),k({pubkey:r,isSigner:!0,isWritable:!1}),k({pubkey:n}),k({pubkey:new ce(t.lpVault)}),k({pubkey:o[0]}),k({pubkey:new ce(t.rewardInfos[0].vault)}),k({pubkey:No,isWritable:!1}),k({pubkey:Ct,isWritable:!1}),k({pubkey:o[1]}),k({pubkey:new ce(t.rewardInfos[1].vault)})],p=Buffer.alloc(c.span);return c.encode({instruction:2,amount:i},p),new tt({keys:m,programId:u,data:p})}function ki(l){let{farmInfo:e,farmKeys:t,lpAccount:n,rewardAccounts:o,owner:r,amount:i,userAuxiliaryLedgers:s}=l,[u,a]=[new ce(e.programId),new ce(e.id)],c=pt({programId:u,poolId:a,owner:r,version:3}),m=Buffer.alloc(kt.span);kt.encode({instruction:11,amount:J(i)},m);let p=[k({pubkey:a}),k({pubkey:new ce(t.authority),isWritable:!1}),k({pubkey:c}),k({pubkey:r,isWritable:!1,isSigner:!0}),k({pubkey:n}),k({pubkey:new ce(t.lpVault)}),k({pubkey:o[0]}),k({pubkey:new ce(t.rewardInfos[0].vault)}),k({pubkey:No,isWritable:!1}),k({pubkey:Ct,isWritable:!1})];if(s)for(let d of s)p.push(k({pubkey:d}));return new tt({programId:u,keys:p,data:m})}function Sc(l){let{farmInfo:e,farmKeys:t,lpAccount:n,rewardAccounts:o,owner:r,amount:i,userAuxiliaryLedgers:s}=l,[u,a]=[new ce(e.programId),new ce(e.id)],c=pt({programId:u,poolId:a,owner:r,version:3}),m=Buffer.alloc(kt.span);kt.encode({instruction:10,amount:J(i)},m);let p=[k({pubkey:a}),k({pubkey:new ce(t.authority),isWritable:!1}),k({pubkey:c}),k({pubkey:r,isWritable:!1,isSigner:!0}),k({pubkey:n}),k({pubkey:new ce(t.lpVault)}),k({pubkey:o[0]}),k({pubkey:new ce(t.rewardInfos[0].vault)}),k({pubkey:No,isWritable:!1}),k({pubkey:Ct,isWritable:!1})];if(s)for(let d of s)p.push(k({pubkey:d}));return new tt({programId:u,keys:p,data:m})}function Cc(l){let{farmInfo:e,farmKeys:t,lpAccount:n,rewardAccounts:o,owner:r,amount:i,userAuxiliaryLedgers:s}=l,[u,a]=[new ce(e.programId),new ce(e.id)],c=pt({programId:u,poolId:a,owner:r,version:5}),m=Buffer.alloc(kt.span);kt.encode({instruction:11,amount:J(i)},m);let p=[k({pubkey:a}),k({pubkey:new ce(t.authority),isWritable:!1}),k({pubkey:c}),k({pubkey:r,isWritable:!1,isSigner:!0}),k({pubkey:n}),k({pubkey:new ce(t.lpVault)}),k({pubkey:o[0]}),k({pubkey:new ce(t.rewardInfos[0].vault)}),k({pubkey:No,isWritable:!1}),k({pubkey:Ct,isWritable:!1})];for(let d=1;d<t.rewardInfos.length;d++)p.push(k({pubkey:o[d]})),p.push(k({pubkey:new ce(t.rewardInfos[d].vault)}));if(s)for(let d of s)p.push(k({pubkey:d}));return new tt({programId:u,keys:p,data:m})}function Rc(l){let{farmInfo:e,farmKeys:t,lpAccount:n,rewardAccounts:o,owner:r,amount:i}=l,[s,u]=[new ce(e.programId),new ce(e.id)],a=pt({programId:s,poolId:u,owner:r,version:6}),c=Buffer.alloc(kt.span);kt.encode({instruction:1,amount:J(i)},c);let m=[k({pubkey:Ct,isWritable:!1}),k({pubkey:io.programId,isWritable:!1}),k({pubkey:u}),k({pubkey:new ce(t.authority),isWritable:!1}),k({pubkey:new ce(t.lpVault)}),k({pubkey:a}),k({pubkey:r,isWritable:!1,isSigner:!0}),k({pubkey:n})];for(let p=0;p<t.rewardInfos.length;p++)m.push(k({pubkey:new ce(t.rewardInfos[p].vault)})),m.push(k({pubkey:o[p]}));return new tt({programId:s,keys:m,data:c})}var wi=class extends Ee{async _getUserRewardInfo({payer:e,rewardInfo:t}){if(t.mint.equals(rt)){let n=await Wn({connection:this.scope.connection,owner:this.scope.ownerPubKey,payer:e,amount:ma(q(M({},t),{openTime:t.openTime.toString(),endTime:t.endTime.toString()}))});return{rewardPubKey:n.addresses.newAccount,newInstruction:n}}return{rewardPubKey:await this.scope.account.getCreatedTokenAccount({mint:t.mint,associatedOnly:!1})}}async create({poolInfo:e,rewardInfos:t,payer:n,programId:o=Bo,txVersion:r,feePayer:i,lockProgram:s}){var K,x;this.checkDisabled(),this.scope.checkOwner();let a={lpMint:new Be(e.lpMint.address),lockInfo:{lockMint:(K=s==null?void 0:s.mint)!=null?K:Ac,lockVault:(x=s==null?void 0:s.vault)!=null?x:kc},version:6,rewardInfos:t,programId:o},c=this.createTxBuilder(i),m=n!=null?n:this.scope.ownerPubKey,p=Qe({fromPublicKey:m,programId:a.programId}),d=await this.scope.connection.getMinimumBalanceForRentExemption(di.span);c.addInstruction({instructions:[$d.createAccountWithSeed({fromPubkey:m,basePubkey:m,seed:p.seed,newAccountPubkey:p.publicKey,lamports:d,space:di.span,programId:a.programId})]});let{publicKey:f,nonce:y}=hc({programId:new Be(a.programId),poolId:p.publicKey}),b=yi({programId:a.programId,poolId:p.publicKey,mint:a.lpMint,type:"lpVault"}),g=[],P=[];for(let S of a.rewardInfos){S.openTime>=S.endTime&&this.logAndCreateError("start time error","rewardInfo.rewardOpenTime",S.openTime.toString()),isNaN(qn[S.rewardType])&&this.logAndCreateError("rewardType error",S.rewardType),Number(S.perSecond)<=0&&this.logAndCreateError("rewardPerSecond error",S.perSecond),g.push(Ic(S));let{rewardPubKey:B,newInstruction:R}=await this._getUserRewardInfo({rewardInfo:S,payer:m});R&&c.addInstruction(R),B||this.logAndCreateError("cannot found target token accounts",this.scope.account.tokenAccounts);let C=S.mint.equals(rt)?new Be(it.address):S.mint;P.push({rewardMint:C,rewardVault:yi({programId:a.programId,poolId:p.publicKey,mint:C,type:"rewardVault"}),userRewardToken:B})}let{account:h,instructionParams:I}=await this.scope.account.getOrCreateTokenAccount({mint:new Be(a.lockInfo.lockMint),owner:this.scope.ownerPubKey,skipCloseAccount:!1,createInfo:{payer:this.scope.ownerPubKey,amount:0},associatedOnly:!1});I&&c.addInstruction(I),h||this.logAndCreateError("cannot found lock vault","tokenAccounts",this.scope.account.tokenAccounts);let{instruction:T,instructionType:w}=Bc({farmId:p.publicKey,owner:this.scope.ownerPubKey,farmAuthority:f,lpVault:b,lpMint:a.lpMint,lockVault:a.lockInfo.lockVault,lockMint:a.lockInfo.lockMint,lockUserAccount:h,programId:a.programId,rewardInfo:P,rewardInfoConfig:g,nonce:y});return c.addInstruction({instructions:[T],instructionTypes:[w]}).versionBuild({txVersion:r,extInfo:{farmId:p.publicKey,farmAuthority:f,lpVault:b,lockUserAccount:h,nonce:y}})}async restartReward({farmInfo:e,payer:t,newRewardInfo:n,txVersion:o,feePayer:r}){var g;let i=qt[e.programId];i!==6&&this.logAndCreateError("invalid farm version ",i);let s=_e((await this.scope.api.fetchFarmKeysById({ids:e.id}))[0]),u={id:s.id,rewardInfos:e.rewardInfos,lpVault:s.lpVault,programId:s.programId};n.openTime>=n.endTime&&this.logAndCreateError("start time error","newRewardInfo",n);let a=t||this.scope.ownerPubKey,c=n.mint.equals(rt)?new Be(it.address):n.mint,m=u.rewardInfos.findIndex(P=>new Be(P.mint.address).equals(c)),p=s.rewardInfos[m];p||this.logAndCreateError("configuration does not exist","rewardMint",c);let d=(g=p.vault)!=null?g:rt,f=this.createTxBuilder(r),{rewardPubKey:y,newInstruction:b}=await this._getUserRewardInfo({rewardInfo:n,payer:a});return b&&f.addInstruction(b),y||this.logAndCreateError("cannot found target token accounts",this.scope.account.tokenAccounts),f.addInstruction({instructions:[pa({payer:this.scope.ownerPubKey,rewardVault:d,userRewardTokenPub:y,farmKeys:u,rewardInfo:n})],instructionTypes:[G.FarmV6Restart]}).versionBuild({txVersion:o})}async restartRewards({farmInfo:e,payer:t,newRewardInfos:n,txVersion:o,feePayer:r}){var m;let i=qt[e.programId];i!==6&&this.logAndCreateError("invalid farm version ",i);let s=_e((await this.scope.api.fetchFarmKeysById({ids:e.id}))[0]),u={id:s.id,rewardInfos:e.rewardInfos,lpVault:s.lpVault,programId:s.programId};n.forEach(p=>{p.openTime>=p.endTime&&this.logAndCreateError("start time error","newRewardInfo",p)});let a=t||this.scope.ownerPubKey,c=this.createTxBuilder(r);for(let p of n){let d=p.mint.equals(rt)?new Be(it.address):p.mint,f=u.rewardInfos.findIndex(I=>new Be(I.mint.address).equals(d)),y=s.rewardInfos[f];y||this.logAndCreateError("configuration does not exist","rewardMint",d);let b=(m=y.vault)!=null?m:rt,{rewardPubKey:g,newInstruction:P}=await this._getUserRewardInfo({rewardInfo:p,payer:a});P&&c.addInstruction(P),g||this.logAndCreateError("cannot found target token accounts",this.scope.account.tokenAccounts);let h=pa({payer:this.scope.ownerPubKey,rewardVault:b,userRewardTokenPub:g,farmKeys:u,rewardInfo:p});c.addInstruction({instructions:[h],instructionTypes:[G.FarmV6Restart]})}return c.versionBuild({txVersion:o})}async addNewRewardToken(e){let{txVersion:t,farmInfo:n,newRewardInfo:o,payer:r,feePayer:i}=e,s=qt[n.programId];s!==6&&this.logAndCreateError("invalid farm version ",s);let u=_e((await this.scope.api.fetchFarmKeysById({ids:n.id}))[0]),a=r!=null?r:this.scope.ownerPubKey,c=this.createTxBuilder(i),m=o.mint.equals(rt)?new Be(it.address):o.mint,p=yi({programId:new Be(n.programId),poolId:new Be(n.id),mint:m,type:"rewardVault"}),{rewardPubKey:d,newInstruction:f}=await this._getUserRewardInfo({rewardInfo:o,payer:a});return f&&c.addInstruction(f),d||this.logAndCreateError("annot found target token accounts",this.scope.account.tokenAccounts),o.mint=m,c.addInstruction({instructions:[fa({payer:this.scope.ownerPubKey,userRewardTokenPub:d,farmKeys:u,rewardVault:p,rewardInfo:o})],instructionTypes:[G.FarmV6CreatorAddReward]}).versionBuild({txVersion:t})}async addNewRewardsToken(e){let{txVersion:t,farmInfo:n,newRewardInfos:o,payer:r,feePayer:i}=e,s=qt[n.programId];s!==6&&this.logAndCreateError("invalid farm version ",s);let u=_e((await this.scope.api.fetchFarmKeysById({ids:n.id}))[0]),a=r!=null?r:this.scope.ownerPubKey,c=this.createTxBuilder(i);for(let m of o){let p=m.mint.equals(rt)?new Be(it.address):m.mint,d=yi({programId:new Be(n.programId),poolId:new Be(n.id),mint:p,type:"rewardVault"}),{rewardPubKey:f,newInstruction:y}=await this._getUserRewardInfo({rewardInfo:m,payer:a});y&&c.addInstruction(y),f||this.logAndCreateError("cannot found target token accounts",this.scope.account.tokenAccounts);let b=fa({payer:this.scope.ownerPubKey,userRewardTokenPub:f,farmKeys:u,rewardVault:d,rewardInfo:q(M({},m),{mint:p})});c.addInstruction({instructions:[b],instructionTypes:[G.FarmV6CreatorAddReward]})}return c.versionBuild({txVersion:t})}async deposit(e){let{txVersion:t,farmInfo:n,amount:o,feePayer:r,useSOLBalance:i,associatedOnly:s=!0,checkCreateATAOwner:u=!1,userAuxiliaryLedgers:a,computeBudgetConfig:c,txTipConfig:m}=e;this.scope.availability.addFarm===!1&&this.logAndCreateError("farm deposit feature disabled in your region");let{rewardInfos:p,programId:d}=n,f=qt[d];f===4&&this.logAndCreateError("V4 has suspended deposits:",n.programId),oa(f)||this.logAndCreateError("invalid farm program:",n.programId);let[y,b]=[new Be(n.programId),new Be(n.id)],g=(await this.scope.api.fetchFarmKeysById({ids:n.id}))[0],P=pt({programId:y,poolId:b,owner:this.scope.ownerPubKey,version:f}),h=this.createTxBuilder(r);h.addCustomComputeBudget(c),h.addTipInstruction(m);let I={};for(let L of this.scope.account.tokenAccounts)if(s){let N=j(this.scope.ownerPubKey,L.mint,L.programId).publicKey;L.publicKey&&N.equals(L.publicKey)&&(I[L.mint.toString()]=L.publicKey)}else I[L.mint.toString()]=L.publicKey;let T=g.lpMint,w=I[T.address];w||this.logAndCreateError("you don't have any lp","lp zero",I);let K=[];for(let L of p){let N=i&&L.mint.address===$.toString(),E=I[L.mint.address];if(!E){let{account:X,instructionParams:Q}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:L.mint.programId,mint:new Be(L.mint.address),notUseTokenAccount:N,createInfo:{payer:r||this.scope.ownerPubKey,amount:0},owner:this.scope.ownerPubKey,skipCloseAccount:!N,associatedOnly:N?!1:s,checkCreateATAOwner:u});E=X,Q&&h.addInstruction(Q)}I[L.mint.address]=E,K.push(E)}let x,S=await this.scope.connection.getAccountInfo(P);if(S&&(x=Oo(f).decode(S.data)),n.programId!==Bo.toString()&&n.programId!==gn.FARM_PROGRAM_ID_V6.toString()&&!x){let{instruction:L,instructionType:N}=gi({id:b,programId:y,version:f,ledger:P,owner:this.scope.ownerPubKey});h.addInstruction({instructions:[L],instructionTypes:[N]})}let B=ia({version:f,rewardInfos:p,rewardTokenAccountsPublicKeys:K});B&&this.logAndCreateError(B);let R={amount:J(o),owner:this.scope.ownerPubKey,farmInfo:n,farmKeys:g,lpAccount:w,rewardAccounts:K,userAuxiliaryLedgers:a==null?void 0:a.map(L=>new Be(L))},C=f===6?Rc(R):f===5?Cc(R):Sc(R),v={3:G.FarmV3Deposit,5:G.FarmV5Deposit,6:G.FarmV6Deposit};return h.addInstruction({instructions:[C],instructionTypes:[v[f]]}).versionBuild({txVersion:t})}async withdraw(e){let{txVersion:t,farmInfo:n,amount:o,deposited:r,useSOLBalance:i,feePayer:s,associatedOnly:u=!0,checkCreateATAOwner:a=!1,userAuxiliaryLedgers:c,computeBudgetConfig:m,txTipConfig:p}=e,{rewardInfos:d}=n;this.scope.availability.removeFarm===!1&&this.logAndCreateError("farm withdraw feature disabled in your region");let f=qt[n.programId];oa(f)||this.logAndCreateError("invalid farm program:",n.programId);let y=(await this.scope.api.fetchFarmKeysById({ids:n.id}))[0],b=this.createTxBuilder(s);b.addCustomComputeBudget(m),b.addTipInstruction(p);let g={};for(let B of this.scope.account.tokenAccounts)if(u){let R=j(this.scope.ownerPubKey,B.mint).publicKey;B.publicKey&&R.equals(B.publicKey)&&(g[B.mint.toString()]=B.publicKey)}else g[B.mint.toString()]=B.publicKey;if(f!==4){let B=pt({programId:new Be(n.programId),poolId:new Be(n.id),owner:this.scope.ownerPubKey,version:f}),R=await this.scope.connection.getAccountInfo(B);if(R)Oo(f).decode(R.data).deposited.isZero()&&this.logAndCreateError("no deposited lp",{farmId:n.id});else if(f!==6){let{instruction:C,instructionType:v}=gi({id:new Be(y.id),programId:new Be(y.programId),version:f,ledger:B,owner:this.scope.ownerPubKey});b.addInstruction({instructions:[C],instructionTypes:[v]})}}r&&r.isZero()&&!(c||[]).length&&this.logAndCreateError("no deposited lp",{farmId:n.id});let P=y.lpMint.address,h=i&&P===$.toString(),I=g[P.toString()];if(!I){let{account:B,instructionParams:R}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:y.lpMint.programId,mint:new Be(P),notUseTokenAccount:h,createInfo:{payer:s||this.scope.ownerPubKey,amount:0},owner:this.scope.ownerPubKey,skipCloseAccount:!0,associatedOnly:h?!1:u,checkCreateATAOwner:a});I=B,R&&b.addInstruction(R)}g[P.toString()]=I;let T=[];for(let B of d){let R=i&&B.mint.address===$.toString(),C=g[B.mint.address];if(!C){let{account:v,instructionParams:L}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:B.mint.programId,mint:new Be(B.mint.address),notUseTokenAccount:R,createInfo:{payer:s||this.scope.ownerPubKey,amount:0},owner:this.scope.ownerPubKey,skipCloseAccount:!R,associatedOnly:R?!1:u,checkCreateATAOwner:a});C=v,L&&b.addInstruction(L)}g[B.mint.address]=C,T.push(C)}let w=ia({version:f,rewardInfos:d,rewardTokenAccountsPublicKeys:T});w&&this.logAndCreateError(w);let K={amount:J(o),owner:this.scope.ownerPubKey,farmInfo:n,farmKeys:y,lpAccount:I,rewardAccounts:T,userAuxiliaryLedgers:c==null?void 0:c.map(B=>new Be(B))},x=f===6?Pi(K):f===5?Ai(K):f===4?Kc(K):ki(K),S={3:G.FarmV3Withdraw,4:G.FarmV4Withdraw,5:G.FarmV5Withdraw,6:G.FarmV6Withdraw};return b.addInstruction({instructions:[x],instructionTypes:[S[f]]}).versionBuild({txVersion:t})}async withdrawFarmReward({farmInfo:e,withdrawMint:t,txVersion:n,computeBudgetConfig:o,txTipConfig:r,feePayer:i}){var y;this.scope.checkOwner();let s=_e((await this.scope.api.fetchFarmKeysById({ids:e.id}))[0]),u=qt[e.programId];u!==6&&this.logAndCreateError("invalid farm version",u);let a=s.rewardInfos.find(b=>dt(b.mint.address).equals(dt(t)));a||this.logAndCreateError("withdraw mint error","rewardInfos",e);let c=(y=a==null?void 0:a.vault)!=null?y:rt,m=this.createTxBuilder(i),p;if(t.equals(rt)||t.equals(Be.default)){let b=await Wn({connection:this.scope.connection,owner:this.scope.ownerPubKey,payer:this.scope.ownerPubKey,amount:ma(q(M({},a),{openTime:a.openTime,endTime:a.endTime,perSecond:new Zd(a.perSecond).mul(10**a.mint.decimals).toString()}))});p=b.addresses.newAccount,m.addInstruction(b)}else{let b=await this.scope.account.getCreatedTokenAccount({mint:t});b===null?(p=await this.scope.account.getAssociatedTokenAccount(t),m.addInstruction({instructions:[Lc(this.scope.ownerPubKey,p,this.scope.ownerPubKey,t)],instructionTypes:[G.CreateATA]})):p=b}let{instruction:d,instructionType:f}=xc({programId:s.programId,id:s.id,authority:s.authority,lpVault:s.lpVault,rewardVault:c,userRewardToken:p,owner:this.scope.ownerPubKey});return m.addCustomComputeBudget(o),m.addTipInstruction(r),m.addInstruction({instructions:[d],instructionTypes:[f]}).versionBuild({txVersion:n})}async harvestAllRewards(e){let{farmInfoList:t,useSOLBalance:n,feePayer:o,associatedOnly:r=!0,checkCreateATAOwner:i=!1,userAuxiliaryLedgers:s,txVersion:u,computeBudgetConfig:a}=e,c=this.createTxBuilder(o),m={};for(let f of this.scope.account.tokenAccounts)if(r){let y=j(this.scope.ownerPubKey,f.mint).publicKey;f.publicKey&&y.equals(f.publicKey)&&(m[f.mint.toString()]=f.publicKey)}else m[f.mint.toString()]=f.publicKey;let d=(await this.scope.api.fetchFarmKeysById({ids:Object.values(t).map(f=>f.id).join(",")})).reduce((f,y)=>q(M({},f),{[y.id]:y}),{});for(let f of Object.values(t)){let{programId:y,lpMint:b,rewardInfos:g,id:P}=f,h=qt[y],I=b.address,T=n&&I===$.toString(),w=m[I];if(!w){let{account:C,instructionParams:v}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:b.programId,mint:new Be(I),notUseTokenAccount:T,createInfo:{payer:o||this.scope.ownerPubKey,amount:0},owner:this.scope.ownerPubKey,skipCloseAccount:!0,associatedOnly:T?!1:r,checkCreateATAOwner:i});w=C,v&&c.addInstruction(v)}m[I.toString()]=w;let K=[];for(let C of g){let v=n&&C.mint.address===$.toString(),L=m[C.mint.address];if(!L)if(v){let{account:N,instructionParams:E}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:C.mint.programId,mint:new Be(C.mint.address),notUseTokenAccount:v,createInfo:{payer:o||this.scope.ownerPubKey,amount:0},owner:this.scope.ownerPubKey,skipCloseAccount:!v,associatedOnly:v?!1:r,checkCreateATAOwner:i});L=N,E&&c.addInstruction(E)}else{let N=new Be(C.mint.address);L=this.scope.account.getAssociatedTokenAccount(N),c.addInstruction({instructions:[Lc(this.scope.ownerPubKey,L,this.scope.ownerPubKey,N)]})}m[C.mint.address]=L,K.push(L)}let x=d[P],S={amount:xt,owner:this.scope.ownerPubKey,farmInfo:f,farmKeys:x,lpAccount:w,rewardAccounts:K,userAuxiliaryLedgers:s==null?void 0:s.map(C=>new Be(C))},B=h===6?Pi(S):h===5?Ai(S):ki(S),R={3:G.FarmV3Withdraw,5:G.FarmV5Withdraw,6:G.FarmV6Withdraw};c.addInstruction({instructions:[B],instructionTypes:[R[h]]})}return u===1?c.sizeCheckBuild({computeBudgetConfig:a}):c.sizeCheckBuildV0({computeBudgetConfig:a})}};import{PublicKey as Ze}from"@solana/web3.js";import{AccountLayout as Dp,NATIVE_MINT as zr,TOKEN_PROGRAM_ID as Gn}from"@solana/spl-token";import{Keypair as _r,PublicKey as z,SystemProgram as In,TransactionInstruction as mt}from"@solana/web3.js";import xa from"bn.js";import{ASSOCIATED_TOKEN_PROGRAM_ID as Ci,TOKEN_2022_PROGRAM_ID as ze,TOKEN_PROGRAM_ID as Ke}from"@solana/spl-token";import cp from"bn.js";import Fo from"decimal.js";import Ut from"bn.js";var ge=new Ut(0),Vt=new Ut(1),wn=new Ut(-1),nt=new Ut(1).shln(64),Or=new Ut(1).shln(128),Ti=nt.sub(Vt),hi=64,Oc=Or.subn(1),ft=-443636,wt=-ft,Gt=new Ut("4295048016"),Xt=new Ut("79226673521066979257578248091"),Nr=new Ut("4295048017"),Mr=new Ut("79226673521066979257578248090"),Nc=16,Mc="59543866431248",vc="184467440737095516",Fc="15793534762490258745",vr=new Ut(10).pow(new Ut(6)),Jd=(n=>(n[n.rate_500=500]="rate_500",n[n.rate_3000=3e3]="rate_3000",n[n.rate_10000=1e4]="rate_10000",n))(Jd||{}),Fw={[500]:10,[3e3]:60,[1e4]:200},Vw={version:6,liquidity:ge,tickCurrent:0,feeGrowthGlobalX64A:ge,feeGrowthGlobalX64B:ge,protocolFeesTokenA:ge,protocolFeesTokenB:ge,swapInAmountTokenA:ge,swapOutAmountTokenB:ge,swapInAmountTokenB:ge,swapOutAmountTokenA:ge,tickArrayBitmap:[],rewardInfos:[],day:{volume:0,volumeFee:0,feeA:0,feeB:0,feeApr:0,rewardApr:{A:0,B:0,C:0},apr:0,priceMax:0,priceMin:0},week:{volume:0,volumeFee:0,feeA:0,feeB:0,feeApr:0,rewardApr:{A:0,B:0,C:0},apr:0,priceMax:0,priceMin:0},month:{volume:0,volumeFee:0,feeA:0,feeB:0,feeApr:0,rewardApr:{A:0,B:0,C:0},apr:0,priceMax:0,priceMin:0},tvl:0},Vc={tvl:0,volumeQuote:0,mintAmountA:0,mintAmountB:0,rewardDefaultInfos:[],farmUpcomingCount:0,farmOngoingCount:0,farmFinishedCount:0,day:{volume:0,volumeQuote:0,volumeFee:0,apr:0,feeApr:0,priceMin:0,priceMax:0,rewardApr:[0]},week:{volume:0,volumeQuote:0,volumeFee:0,apr:0,feeApr:0,priceMin:0,priceMax:0,rewardApr:[0]},month:{volume:0,volumeQuote:0,volumeFee:0,apr:0,feeApr:0,priceMin:0,priceMax:0,rewardApr:[0]},pooltype:[]},_w=new Ut("18446744073700000000");import pe from"bn.js";import mn from"decimal.js";function Fr(l){let e=new ArrayBuffer(2);return new DataView(e).setUint16(0,l,!1),new Uint8Array(e)}function Ww(l){let e=new ArrayBuffer(2);return new DataView(e).setInt16(0,l,!1),new Uint8Array(e)}function Dw(l){let e=new ArrayBuffer(4);return new DataView(e).setUint32(0,l,!1),new Uint8Array(e)}function Vr(l){let e=new ArrayBuffer(4);return new DataView(e).setInt32(0,l,!1),new Uint8Array(e)}function ya(l,e){let t=0;for(let n=l-1;n>=0&&!e.testn(n);n--)t++;return t}function ba(l,e){let t=0;for(let n=0;n<l&&!e.testn(n);n++)t++;return t}function Ii(l,e){for(let t=0;t<l;t++)if(e.testn(t))return!1;return!0}function _c(l,e){return Ii(l,e)?null:ya(l,e)}function Ec(l,e){return Ii(l,e)?null:ba(l,e)}var ep=Buffer.from("amm_config","utf8"),ga=Buffer.from("pool","utf8"),Pa=Buffer.from("pool_vault","utf8"),tp=Buffer.from("pool_reward_vault","utf8"),Wc=Buffer.from("position","utf8"),np=Buffer.from("tick_array","utf8"),op=Buffer.from("operation","utf8"),ip=Buffer.from("pool_tick_array_bitmap_extension","utf8"),rp=Buffer.from("observation","utf8");function Xw(l,e){return te([ep,Fr(e)],l)}function Dc(l,e,t,n){return te([ga,e.toBuffer(),t.toBuffer(),n.toBuffer()],l)}function Aa(l,e,t){return te([Pa,e.toBuffer(),t.toBuffer()],l)}function qc(l,e,t){return te([tp,e.toBuffer(),t.toBuffer()],l)}function Pe(l,e,t){return te([np,e.toBuffer(),Vr(t)],l)}function nn(l,e,t,n){return te([Wc,e.toBuffer(),Vr(t),Vr(n)],l)}function Tt(l,e){return te([Wc,e.toBuffer()],l)}function Tn(l){return te([Buffer.from("metadata","utf8"),Dt.toBuffer(),l.toBuffer()],Dt)}function Bi(l){return te([op],l)}function He(l,e){return te([ip,e.toBuffer()],l)}function Uc(l,e){return te([rp,e.toBuffer()],l)}var Gc=Buffer.from("locked_position","utf8");function ka(l,e){return te([Gc,e.toBuffer()],l)}function Mo(l,e){return te([Gc,e.toBuffer()],l)}var sp=Buffer.from("support_mint","utf8");function wa(l,e){return te([sp,e.toBuffer()],l)}import{PublicKey as _t}from"@solana/web3.js";import{TOKEN_2022_PROGRAM_ID as Xc}from"@solana/spl-token";import qe from"bn.js";import ke from"decimal.js";import ln from"bn.js";import Ta from"decimal.js";var xi=class{static getfeeGrowthInside(e,t,n){let o=new ln(0),r=new ln(0);e.tickCurrent>=t.tick?(o=t.feeGrowthOutsideX64A,r=t.feeGrowthOutsideX64B):(o=e.feeGrowthGlobalX64A.sub(t.feeGrowthOutsideX64A),r=e.feeGrowthGlobalX64B.sub(t.feeGrowthOutsideX64B));let i=new ln(0),s=new ln(0);e.tickCurrent<n.tick?(i=n.feeGrowthOutsideX64A,s=n.feeGrowthOutsideX64B):(i=e.feeGrowthGlobalX64A.sub(n.feeGrowthOutsideX64A),s=e.feeGrowthGlobalX64B.sub(n.feeGrowthOutsideX64B));let u=le.wrappingSubU128(le.wrappingSubU128(e.feeGrowthGlobalX64A,o),i),a=le.wrappingSubU128(le.wrappingSubU128(e.feeGrowthGlobalX64B,r),s);return{feeGrowthInsideX64A:u,feeGrowthInsideBX64:a}}static GetPositionFees(e,t,n,o){let{feeGrowthInsideX64A:r,feeGrowthInsideBX64:i}=this.getfeeGrowthInside(e,n,o),s=le.mulDivFloor(le.wrappingSubU128(r,t.feeGrowthInsideLastX64A),t.liquidity,nt),u=t.tokenFeesOwedA.add(s),a=le.mulDivFloor(le.wrappingSubU128(i,t.feeGrowthInsideLastX64B),t.liquidity,nt),c=t.tokenFeesOwedB.add(a);return{tokenFeeAmountA:u,tokenFeeAmountB:c}}static GetPositionFeesV2(e,t,n,o){let{feeGrowthInsideX64A:r,feeGrowthInsideBX64:i}=this.getfeeGrowthInside(e,n,o),s=le.mulDivFloor(le.wrappingSubU128(r,t.feeGrowthInsideLastX64A),t.liquidity,nt),u=t.tokenFeesOwedA.add(s),a=le.mulDivFloor(le.wrappingSubU128(i,t.feeGrowthInsideLastX64B),t.liquidity,nt),c=t.tokenFeesOwedB.add(a);return{tokenFeeAmountA:u,tokenFeeAmountB:c}}static GetPositionRewardsV2(e,t,n,o){let r=[],i=this.getRewardGrowthInsideV2(e.tickCurrent,n,o,e.rewardInfos);for(let s=0;s<i.length;s++){let u=i[s],a=t.rewardInfos[s],c=le.wrappingSubU128(u,a.growthInsideLastX64),m=le.mulDivFloor(c,t.liquidity,nt),p=a.rewardAmountOwed.add(m);r.push(p)}return r}static GetPositionRewards(e,t,n,o){let r=[],i=this.getRewardGrowthInside(e.tickCurrent,n,o,e.rewardInfos);for(let s=0;s<i.length;s++){let u=i[s],a=t.rewardInfos[s],c=le.wrappingSubU128(u,a.growthInsideLastX64),m=le.mulDivFloor(c,t.liquidity,nt),p=a.rewardAmountOwed.add(m);r.push(p)}return r}static getRewardGrowthInside(e,t,n,o){let r=[];for(let i=0;i<o.length;i++){let s=new ln(0);t.liquidityGross.eqn(0)?s=o[i].rewardGrowthGlobalX64:e<t.tick?s=o[i].rewardGrowthGlobalX64.sub(t.rewardGrowthsOutsideX64[i]):s=t.rewardGrowthsOutsideX64[i];let u=new ln(0);n.liquidityGross.eqn(0)||(e<n.tick?u=n.rewardGrowthsOutsideX64[i]:u=o[i].rewardGrowthGlobalX64.sub(n.rewardGrowthsOutsideX64[i])),r.push(le.wrappingSubU128(le.wrappingSubU128(o[i].rewardGrowthGlobalX64,s),u))}return r}static getRewardGrowthInsideV2(e,t,n,o){let r=[];for(let i=0;i<o.length;i++){let s=new ln(0);t.liquidityGross.eqn(0)?s=o[i].rewardGrowthGlobalX64:e<t.tick?s=o[i].rewardGrowthGlobalX64.sub(t.rewardGrowthsOutsideX64[i]):s=t.rewardGrowthsOutsideX64[i];let u=new ln(0);n.liquidityGross.eqn(0)||(e<n.tick?u=n.rewardGrowthsOutsideX64[i]:u=o[i].rewardGrowthGlobalX64.sub(n.rewardGrowthsOutsideX64[i])),r.push(le.wrappingSubU128(le.wrappingSubU128(o[i].rewardGrowthGlobalX64,s),u))}return r}static getAmountsFromLiquidity({poolInfo:e,ownerPosition:t,liquidity:n,slippage:o,add:r,epochInfo:i}){var b,g,P,h;let s=se.priceToSqrtPriceX64(new Ta(e.price),e.mintA.decimals,e.mintB.decimals),u=se.getSqrtPriceX64FromTick(t.tickLower),a=se.getSqrtPriceX64FromTick(t.tickUpper),c=r?1+o:1-o,m=Ae.getAmountsFromLiquidity(s,u,a,n,r),[p,d]=[Ie(m.amountA,(b=e.mintA.extensions)==null?void 0:b.feeConfig,i,!0),Ie(m.amountB,(g=e.mintB.extensions)==null?void 0:g.feeConfig,i,!0)],[f,y]=[Ie(new ln(new Ta(m.amountA.toString()).mul(c).toFixed(0)),(P=e.mintA.extensions)==null?void 0:P.feeConfig,i,!0),Ie(new ln(new Ta(m.amountB.toString()).mul(c).toFixed(0)),(h=e.mintB.extensions)==null?void 0:h.feeConfig,i,!0)];return{liquidity:n,amountA:p,amountB:d,amountSlippageA:f,amountSlippageB:y,expirationTime:Jt(p.expirationTime,d.expirationTime)}}};var ap=15,we=class{static async getTickArrays(e,t,n,o,r,i,s){let u=[],a=Z.getTickArrayStartIndexByTick(o,r),c=Z.getInitializedTickArrayInRange(i,s,r,a,Math.floor(ap/2));for(let d=0;d<c.length;d++){let{publicKey:f}=Pe(t,n,c[d]);u.push(f)}let m=(await Zt(e,u)).map(d=>d!==null?Ki.decode(d.data):null),p={};for(let d=0;d<u.length;d++){let f=m[d];f!==null&&(p[f.startTickIndex]=q(M({},f),{address:u[d]}))}return p}static nextInitializedTick(e,t,n,o,r,i){let{initializedTick:s,tickArrayAddress:u,tickArrayStartTickIndex:a}=this.nextInitializedTickInOneArray(e,t,n,o,r,i);for(;s==null||s.liquidityGross.lten(0);){if(a=Z.getNextTickArrayStartIndex(a,r,i),this.checkIsValidStartIndex(a,r))throw new Error("No enough initialized tickArray");let c=n[a];if(c===void 0)continue;let{nextTick:m,tickArrayAddress:p,tickArrayStartTickIndex:d}=this.firstInitializedTickInOneArray(e,t,c,i);[s,u,a]=[m,p,d]}if(s==null)throw new Error("No invaild tickArray cache");return{nextTick:s,tickArrayAddress:u,tickArrayStartTickIndex:a}}static nextInitializedTickArray(e,t,n,o,r){let i=Math.floor(e/we.tickCount(t)),s=n?Z.searchLowBitFromStart(o,r,i-1,1,t):Z.searchHightBitFromStart(o,r,i+1,1,t);return s.length>0?{isExist:!0,nextStartIndex:s[0]}:{isExist:!1,nextStartIndex:0}}static firstInitializedTickInOneArray(e,t,n,o){let r;if(o){let s=ot-1;for(;s>=0;){let u=n.ticks[s];if(u.liquidityGross.gtn(0)){r=u;break}s=s-1}}else{let s=0;for(;s<ot;){let u=n.ticks[s];if(u.liquidityGross.gtn(0)){r=u;break}s=s+1}}let{publicKey:i}=Pe(e,t,n.startTickIndex);return{nextTick:r,tickArrayAddress:i,tickArrayStartTickIndex:n.startTickIndex}}static nextInitializedTickInOneArray(e,t,n,o,r,i){let s=Z.getTickArrayStartIndexByTick(o,r),u=Math.floor((o-s)/r),a=n[s];if(a==null)return{initializedTick:void 0,tickArrayAddress:void 0,tickArrayStartTickIndex:s};let c;if(i)for(;u>=0;){let p=a.ticks[u];if(p.liquidityGross.gtn(0)){c=p;break}u=u-1}else for(u=u+1;u<ot;){let p=a.ticks[u];if(p.liquidityGross.gtn(0)){c=p;break}u=u+1}let{publicKey:m}=Pe(e,t,s);return{initializedTick:c,tickArrayAddress:m,tickArrayStartTickIndex:a.startTickIndex}}static getArrayStartIndex(e,t){let n=this.tickCount(t);return Math.floor(e/n)*n}static checkIsValidStartIndex(e,t){if(Z.checkIsOutOfBoundary(e)){if(e>wt)return!1;let n=Z.getTickArrayStartIndexByTick(ft,t);return e==n}return e%this.tickCount(t)==0}static tickCount(e){return ot*e}};var ha=14,hn=class{static maxTickInTickarrayBitmap(e){return e*ot*ro}static getBitmapTickBoundary(e,t){let n=this.maxTickInTickarrayBitmap(t),o=Math.floor(Math.abs(e)/n);e<0&&Math.abs(e)%n!=0&&(o+=1);let r=n*o;return e<0?{minValue:-r,maxValue:-r+n}:{minValue:r,maxValue:r+n}}static nextInitializedTickArrayStartIndex(e,t,n,o){if(!we.checkIsValidStartIndex(t,n))throw Error("nextInitializedTickArrayStartIndex check error");let r=this.maxTickInTickarrayBitmap(n),i=o?t-we.tickCount(n):t+we.tickCount(n);if(i<-r||i>=r)return{isInit:!1,tickIndex:t};let s=n*ot,u=i/s+512;i<0&&i%s!=0&&u--;let a=Math.abs(u);if(o){let c=e.shln(1024-a-1),m=_c(1024,c);if(m!==null){let p=(a-m-512)*s;return{isInit:!0,tickIndex:p}}else return{isInit:!1,tickIndex:-r}}else{let c=e.shrn(a),m=Ec(1024,c);if(m!==null){let p=(a+m-512)*s;return{isInit:!0,tickIndex:p}}else return{isInit:!1,tickIndex:r-we.tickCount(n)}}}},Si=class{static getBitmapOffset(e,t){if(!we.checkIsValidStartIndex(e,t))throw new Error("No enough initialized tickArray");this.checkExtensionBoundary(e,t);let n=hn.maxTickInTickarrayBitmap(t),o=Math.floor(Math.abs(e)/n)-1;return e<0&&Math.abs(e)%n===0&&o--,o}static getBitmap(e,t,n){let o=this.getBitmapOffset(e,t);return e<0?{offset:o,tickarrayBitmap:n.negativeTickArrayBitmap[o]}:{offset:o,tickarrayBitmap:n.positiveTickArrayBitmap[o]}}static checkExtensionBoundary(e,t){let{positiveTickBoundary:n,negativeTickBoundary:o}=this.extensionTickBoundary(t);if(e>=o&&e<n)throw Error("checkExtensionBoundary -> InvalidTickArrayBoundary")}static extensionTickBoundary(e){let t=hn.maxTickInTickarrayBitmap(e),n=-t;if(wt<=t)throw Error(`extensionTickBoundary check error: ${wt}, ${t}`);if(n<=ft)throw Error(`extensionTickBoundary check error: ${n}, ${ft}`);return{positiveTickBoundary:t,negativeTickBoundary:n}}static checkTickArrayIsInit(e,t,n){let{tickarrayBitmap:o}=this.getBitmap(e,t,n),r=this.tickArrayOffsetInBitmap(e,t);return{isInitialized:Z.mergeTickArrayBitmap(o).testn(r),startIndex:e}}static nextInitializedTickArrayFromOneBitmap(e,t,n,o){let r=we.tickCount(t),i=n?e-r:e+r,{tickarrayBitmap:s}=this.getBitmap(i,t,o);return this.nextInitializedTickArrayInBitmap(s,i,t,n)}static nextInitializedTickArrayInBitmap(e,t,n,o){let{minValue:r,maxValue:i}=hn.getBitmapTickBoundary(t,n),s=this.tickArrayOffsetInBitmap(t,n);if(o){let u=Z.mergeTickArrayBitmap(e).shln(ro-1-s),a=Ii(512,u)?null:ya(512,u);if(a!==null){let c=t-a*we.tickCount(n);return{isInit:!0,tickIndex:c}}else return{isInit:!1,tickIndex:r}}else{let u=Z.mergeTickArrayBitmap(e).shrn(s),a=Ii(512,u)?null:ba(512,u);if(a!==null){let c=t+a*we.tickCount(n);return{isInit:!0,tickIndex:c}}else return{isInit:!1,tickIndex:i-we.tickCount(n)}}}static tickArrayOffsetInBitmap(e,t){let n=Math.abs(e)%hn.maxTickInTickarrayBitmap(t),o=Math.floor(n/we.tickCount(t));return e<0&&n!=0&&(o=ro-o),o}};var ve=class{static getOutputAmountAndRemainAccounts(e,t,n,o,r,i=!1){let s=n.toBase58()===e.mintA.address,u=[],{isExist:a,startIndex:c,nextAccountMeta:m}=this.getFirstInitializedTickArray(e,s);if(!a||c===void 0||!m)throw new Error("Invalid tick array");u.push(m);let{allTrade:p,amountCalculated:d,accounts:f,sqrtPriceX64:y,feeAmount:b}=so.swapCompute(e.programId,e.id,t,e.tickArrayBitmap,e.exBitmapInfo,s,e.ammConfig.tradeFeeRate,e.liquidity,e.tickCurrent,e.tickSpacing,e.sqrtPriceX64,o,c,r,i);return u.push(...f),{allTrade:p,expectedAmountOut:d.mul(wn),remainingAccounts:u,executionPrice:y,feeAmount:b}}static getInputAmountAndRemainAccounts(e,t,n,o,r){let i=n.toBase58()===e.mintB.address,s=[],{isExist:u,startIndex:a,nextAccountMeta:c}=this.getFirstInitializedTickArray(e,i);if(!u||a===void 0||!c)throw new Error("Invalid tick array");try{let y=this.preInitializedTickArrayStartIndex(e,i);if(y.isExist){let{publicKey:b}=Pe(e.programId,e.id,y.nextStartIndex);s.push(b)}}catch{}s.push(c);let{amountCalculated:m,accounts:p,sqrtPriceX64:d,feeAmount:f}=so.swapCompute(e.programId,e.id,t,e.tickArrayBitmap,e.exBitmapInfo,i,e.ammConfig.tradeFeeRate,e.liquidity,e.tickCurrent,e.tickSpacing,e.sqrtPriceX64,o.mul(wn),a,r);return s.push(...p),{expectedAmountIn:m,remainingAccounts:s,executionPrice:d,feeAmount:f}}static getFirstInitializedTickArray(e,t){let{isInitialized:n,startIndex:o}=ve.isOverflowDefaultTickarrayBitmap(e.tickSpacing,[e.tickCurrent])?Si.checkTickArrayIsInit(we.getArrayStartIndex(e.tickCurrent,e.tickSpacing),e.tickSpacing,e.exBitmapInfo):Z.checkTickArrayIsInitialized(Z.mergeTickArrayBitmap(e.tickArrayBitmap),e.tickCurrent,e.tickSpacing);if(n){let{publicKey:s}=Pe(e.programId,e.id,o);return{isExist:!0,startIndex:o,nextAccountMeta:s}}let{isExist:r,nextStartIndex:i}=this.nextInitializedTickArrayStartIndex(e,we.getArrayStartIndex(e.tickCurrent,e.tickSpacing),t);if(r){let{publicKey:s}=Pe(e.programId,e.id,i);return{isExist:!0,startIndex:i,nextAccountMeta:s}}return{isExist:!1,nextAccountMeta:void 0,startIndex:void 0}}static preInitializedTickArrayStartIndex(e,t){let n=Math.floor(e.tickCurrent/we.tickCount(e.tickSpacing)),o=t?Z.searchHightBitFromStart(e.tickArrayBitmap,e.exBitmapInfo,n+1,1,e.tickSpacing):Z.searchLowBitFromStart(e.tickArrayBitmap,e.exBitmapInfo,n-1,1,e.tickSpacing);return o.length>0?{isExist:!0,nextStartIndex:o[0]}:{isExist:!1,nextStartIndex:0}}static nextInitializedTickArrayStartIndex(e,t,n){for(t=we.getArrayStartIndex(e.tickCurrent,e.tickSpacing);;){let{isInit:o,tickIndex:r}=hn.nextInitializedTickArrayStartIndex(Z.mergeTickArrayBitmap(e.tickArrayBitmap),t,e.tickSpacing,n);if(o)return{isExist:!0,nextStartIndex:r};t=r;let{isInit:i,tickIndex:s}=Si.nextInitializedTickArrayFromOneBitmap(t,e.tickSpacing,n,e.exBitmapInfo);if(i)return{isExist:!0,nextStartIndex:s};if(t=s,t<ft||t>wt)return{isExist:!1,nextStartIndex:0}}}static async updatePoolRewardInfos({connection:e,apiPoolInfo:t,chainTime:n,poolLiquidity:o,rewardInfos:r}){var s,u,a;let i=[];for(let c=0;c<r.length;c++){let m=r[c],p=(a=(s=t.rewardDefaultInfos[c])==null?void 0:s.mint.programId)!=null?a:(u=await e.getAccountInfo(m.tokenMint))==null?void 0:u.owner;if(p===void 0)throw Error("get new reward mint info error");let d=q(M({},m),{perSecond:le.x64ToDecimal(m.emissionsPerSecondX64),remainingRewards:void 0,tokenProgramId:new _t(p)});if(d.tokenMint.equals(_t.default))continue;if(n<=d.openTime.toNumber()||o.eq(ge)){i.push(d);continue}let f=new qe(Math.min(d.endTime.toNumber(),n)),y=f.sub(d.lastUpdateTime),b=le.mulDivFloor(y,d.emissionsPerSecondX64,o),g=d.rewardGrowthGlobalX64.add(b),P=le.mulDivFloor(y,d.emissionsPerSecondX64,nt),h=d.rewardTotalEmissioned.add(P);i.push(q(M({},d),{rewardGrowthGlobalX64:g,rewardTotalEmissioned:h,lastUpdateTime:f}))}return i}static isOverflowDefaultTickarrayBitmap(e,t){let{maxTickBoundary:n,minTickBoundary:o}=this.tickRange(e);for(let r of t){let i=Z.getTickArrayStartIndexByTick(r,e);if(i>=n||i<o)return!0}return!1}static tickRange(e){let t=hn.maxTickInTickarrayBitmap(e),n=-t;return t>wt&&(t=we.getArrayStartIndex(wt,e)+we.tickCount(e)),n<ft&&(n=we.getArrayStartIndex(ft,e)),{maxTickBoundary:t,minTickBoundary:n}}static get_tick_array_offset(e,t){if(!we.checkIsValidStartIndex(e,t))throw new Error("No enough initialized tickArray");return e/we.tickCount(t)*ro}static async fetchExBitmaps({connection:e,exBitmapAddress:t,batchRequest:n}){let o=await Ne(e,t.map(i=>({pubkey:i})),{batchRequest:n}),r={};for(let i of o)i.accountInfo!==null&&(r[i.pubkey.toString()]=Yc.decode(i.accountInfo.data));return r}static async fetchMultiplePoolTickArrays({connection:e,poolKeys:t,batchRequest:n}){let o={},r=[];for(let u of t){let a=Z.getTickArrayStartIndexByTick(u.tickCurrent,u.tickSpacing),c=Z.getInitializedTickArrayInRange(u.tickArrayBitmap,u.exBitmapInfo,u.tickSpacing,a,7);for(let m of c){let{publicKey:p}=Pe(u.programId,u.id,m);r.push({pubkey:p}),o[p.toString()]=u.id}}let i=await Ne(e,r,{batchRequest:n}),s={};for(let u of i){if(!u.accountInfo)continue;let a=o[u.pubkey.toString()];if(!a)continue;s[a.toString()]===void 0&&(s[a.toString()]={});let c=Ki.decode(u.accountInfo.data);s[a.toString()][c.startTickIndex]=q(M({},c),{address:u.pubkey})}return s}static async fetchPoolsAccountPosition({pools:e,connection:t,ownerInfo:n,batchRequest:o=!1,updateOwnerRewardAndFee:r=!0}){var s;let i=[];for(let u=0;u<e.length;u++){let a=e[u];a!==null&&(i.find(c=>c.equals(a.state.programId))||i.push(a.state.programId))}if(n){let u=n.tokenAccounts.map(p=>p.accountInfo.mint),a=[];for(let p of u)for(let d of i)a.push(Tt(d,p).publicKey);let c=await Zt(t,a,{batchRequest:o}),m={};for(let p of c){if(p===null)continue;let d=vo.decode(p.data),f=d.poolId.toString(),y=e.find(x=>x.state.id.toBase58()===f);if(y===void 0)continue;let b=y.state,g=Z._getTickPriceLegacy({poolInfo:b,tick:d.tickLower,baseIn:!0}),P=Z._getTickPriceLegacy({poolInfo:b,tick:d.tickUpper,baseIn:!0}),{amountA:h,amountB:I}=Ae.getAmountsFromLiquidity(b.sqrtPriceX64,g.tickSqrtPriceX64,P.tickSqrtPriceX64,d.liquidity,!1),T=1/(1-Math.sqrt(Math.sqrt(g.price.div(P.price).toNumber())));y.positionAccount=[...(s=y.positionAccount)!=null?s:[],{poolId:d.poolId,nftMint:d.nftMint,priceLower:g.price,priceUpper:P.price,amountA:h,amountB:I,tickLower:d.tickLower,tickUpper:d.tickUpper,liquidity:d.liquidity,feeGrowthInsideLastX64A:d.feeGrowthInsideLastX64A,feeGrowthInsideLastX64B:d.feeGrowthInsideLastX64B,tokenFeesOwedA:d.tokenFeesOwedA,tokenFeesOwedB:d.tokenFeesOwedB,rewardInfos:d.rewardInfos.map(x=>q(M({},x),{pendingReward:new qe(0)})),leverage:T,tokenFeeAmountA:new qe(0),tokenFeeAmountB:new qe(0)}];let w=await Z.getTickArrayAddressByTick(y.state.programId,d.poolId,d.tickLower,y.state.tickSpacing),K=await Z.getTickArrayAddressByTick(y.state.programId,d.poolId,d.tickUpper,y.state.tickSpacing);m[`${y.state.programId.toString()}-${d.poolId.toString()}-${d.tickLower}`]=w,m[`${y.state.programId.toString()}-${d.poolId.toString()}-${d.tickUpper}`]=K}if(r){let p=Object.values(m),d=await Zt(t,p,{batchRequest:o}),f={};for(let y=0;y<p.length;y++){let b=d[y];if(b===null)continue;let g=p[y].toString();f[g]=Ki.decode(b.data)}for(let{state:y,positionAccount:b}of e)if(!!b)for(let g of b){let P=`${y.programId.toString()}-${y.id.toString()}-${g.tickLower}`,h=`${y.programId.toString()}-${y.id.toString()}-${g.tickUpper}`,I=f[m[P].toString()],T=f[m[h].toString()],w=I.ticks[Z.getTickOffsetInArray(g.tickLower,y.tickSpacing)],K=T.ticks[Z.getTickOffsetInArray(g.tickUpper,y.tickSpacing)],{tokenFeeAmountA:x,tokenFeeAmountB:S}=await xi.GetPositionFees(y,g,w,K),B=await xi.GetPositionRewards(y,g,w,K);g.tokenFeeAmountA=x.gte(new qe(0))?x:new qe(0),g.tokenFeeAmountB=S.gte(new qe(0))?S:new qe(0);for(let R=0;R<B.length;R++)g.rewardInfos[R].pendingReward=B[R].gte(new qe(0))?B[R]:new qe(0)}}}return e}static computeAmountOut({poolInfo:e,tickArrayCache:t,baseMint:n,epochInfo:o,amountIn:r,slippage:i,priceLimit:s=new ke(0),catchLiquidityInsufficient:u=!1}){var C;let a,c=n.toBase58()===e.mintA.address,[m,p]=c?[e.mintA.extensions.feeConfig,e.mintB.extensions.feeConfig]:[e.mintB.extensions.feeConfig,e.mintA.extensions.feeConfig];s.equals(new ke(0))?a=c?Gt.add(new qe(1)):Xt.sub(new qe(1)):a=se.priceToSqrtPriceX64(s,e.mintA.decimals,e.mintB.decimals);let d=Ie(r,m,o,!1),{allTrade:f,expectedAmountOut:y,remainingAccounts:b,executionPrice:g,feeAmount:P}=ve.getOutputAmountAndRemainAccounts(e,t,n,d.amount.sub((C=d.fee)!=null?C:ge),a,u),h=Ie(y,p,o,!1),I=se.sqrtPriceX64ToPrice(g,e.mintA.decimals,e.mintB.decimals),T=c?I:new ke(1).div(I),w=y.mul(new qe(Math.floor((1-i)*1e10))).div(new qe(1e10)),K=Ie(w,p,o,!1),x=c?e.currentPrice:new ke(1).div(e.currentPrice),S=new ke(T).sub(x).abs(),B=x,R=new st(new ke(S).mul(10**15).toFixed(0),new ke(B).mul(10**15).toFixed(0));return{allTrade:f,realAmountIn:d,amountOut:h,minAmountOut:K,expirationTime:Jt(d.expirationTime,h.expirationTime),currentPrice:e.currentPrice,executionPrice:T,priceImpact:R,fee:P,remainingAccounts:b,executionPriceX64:g}}static computeAmountOutFormat({poolInfo:e,tickArrayCache:t,amountIn:n,tokenOut:o,slippage:r,epochInfo:i,catchLiquidityInsufficient:s=!1}){let u=o.address===e.mintB.address,[a,c]=u?[e.mintA,e.mintB]:[e.mintB,e.mintA],[m,p]=[new Ge(q(M({},a),{mint:a.address,isToken2022:a.programId===Xc.toBase58()})),new Ge(q(M({},c),{mint:c.address,isToken2022:c.programId===Xc.toBase58()}))],{allTrade:d,realAmountIn:f,amountOut:y,minAmountOut:b,expirationTime:g,currentPrice:P,executionPrice:h,priceImpact:I,fee:T,remainingAccounts:w,executionPriceX64:K}=ve.computeAmountOut({poolInfo:e,tickArrayCache:t,baseMint:new _t(a.address),amountIn:n,slippage:r,epochInfo:i,catchLiquidityInsufficient:s}),x=q(M({},f),{amount:new xe(m,f.amount),fee:f.fee===void 0?void 0:new xe(m,f.fee)}),S=q(M({},y),{amount:new xe(p,y.amount),fee:y.fee===void 0?void 0:new xe(p,y.fee)}),B=q(M({},b),{amount:new xe(p,b.amount),fee:b.fee===void 0?void 0:new xe(p,b.fee)}),R=new Bt({baseToken:m,denominator:new qe(10).pow(new qe(20+m.decimals)),quoteToken:p,numerator:P.mul(new ke(10**(20+p.decimals))).toFixed(0)}),C=new Bt({baseToken:m,denominator:new qe(10).pow(new qe(20+m.decimals)),quoteToken:p,numerator:h.mul(new ke(10**(20+p.decimals))).toFixed(0)}),v=new xe(m,T);return{allTrade:d,realAmountIn:x,amountOut:S,minAmountOut:B,expirationTime:g,currentPrice:R,executionPrice:C,priceImpact:I,fee:v,remainingAccounts:w,executionPriceX64:K}}static computeAmountIn({poolInfo:e,tickArrayCache:t,baseMint:n,epochInfo:o,amountOut:r,slippage:i,priceLimit:s=new ke(0)}){var B;let u=n.toBase58()===e.mintA.address,a={[e.mintA.address]:e.mintA.extensions.feeConfig,[e.mintB.address]:e.mintB.extensions.feeConfig},c;s.equals(new ke(0))?c=u?Xt.sub(new qe(1)):Gt.add(new qe(1)):c=se.priceToSqrtPriceX64(s,e.mintA.decimals,e.mintB.decimals);let m=Ie(r,a[n.toString()],o,!0),{expectedAmountIn:p,remainingAccounts:d,executionPrice:f,feeAmount:y}=ve.getInputAmountAndRemainAccounts(e,t,n,m.amount.sub((B=m.fee)!=null?B:ge),c),b=u?e.mintB.address:e.mintA.address,g=Ie(p,a[b],o,!1),P=se.sqrtPriceX64ToPrice(f,e.mintA.decimals,e.mintB.decimals),h=u?P:new ke(1).div(P),I=p.mul(new qe(Math.floor((1+i)*1e10))).div(new qe(1e10)),T=Ie(I,a[b],o,!0),w=u?e.currentPrice:new ke(1).div(e.currentPrice),K=new ke(h).sub(w).abs(),x=w,S=new st(new ke(K).mul(10**15).toFixed(0),new ke(x).mul(10**15).toFixed(0));return{amountIn:g,maxAmountIn:T,realAmountOut:m,expirationTime:Jt(g.expirationTime,m.expirationTime),currentPrice:e.currentPrice,executionPrice:h,priceImpact:S,fee:y,remainingAccounts:d}}static estimateAprsForPriceRangeMultiplier({poolInfo:e,aprType:t,positionTickLowerIndex:n,positionTickUpperIndex:o}){var f,y,b;let r=e[t],i=Z.getTickPrice({poolInfo:e,tick:n,baseIn:!0}).price.toNumber(),s=Z.getTickPrice({poolInfo:e,tick:o,baseIn:!0}).price.toNumber(),u=Math.max(i,r.priceMin),c=Math.min(s,r.priceMax)-u,m=s-i,p=r.priceMax-r.priceMin,d;return c<=0?d=0:m===c?d=p/c:p===c?d=c/m:d=c/p*(c/m),{feeApr:r.feeApr*d,rewardsApr:[((f=r.rewardApr[0])!=null?f:0)*d,((y=r.rewardApr[1])!=null?y:0)*d,((b=r.rewardApr[2])!=null?b:0)*d],apr:r.apr*d}}static estimateAprsForPriceRangeDelta({poolInfo:e,poolLiquidity:t,aprType:n,mintPrice:o,liquidity:r,positionTickLowerIndex:i,positionTickUpperIndex:s,chainTime:u}){let a=n==="day"?1:n==="week"?7:n==="month"?30:0,c=e[n],m=o[dt(e.mintA.address).toString()],p=o[dt(e.mintB.address).toString()],d=e.mintA.decimals,f=e.mintB.decimals;if(!c||!m||!p)return{feeApr:0,rewardsApr:[0,0,0],apr:0};let y=se.priceToSqrtPriceX64(new ke(e.price),e.mintA.decimals,e.mintB.decimals),b=se.getSqrtPriceX64FromTick(i),g=se.getSqrtPriceX64FromTick(s),{amountSlippageA:P,amountSlippageB:h}=Ae.getAmountsFromLiquidityWithSlippage(y,b,g,t,!1,!1,0),{amountSlippageA:I,amountSlippageB:T}=Ae.getAmountsFromLiquidityWithSlippage(y,b,g,r,!1,!1,0),w=new ke(P.toString()).div(new ke(10).pow(d)).mul(m.value).add(new ke(h.toString()).div(new ke(10).pow(f)).mul(p.value)),K=new ke(I.toString()).div(new ke(10).pow(d)).mul(m.value).add(new ke(T.toString()).div(new ke(10).pow(f)).mul(p.value)),x=new ke(1).div(w.add(K)),B=new ke(c.volumeFee).mul(365).div(a).mul(x).mul(100).toNumber(),R=3600*24*365,C=e.rewardDefaultInfos.map(v=>{var E,X;let L=v.mint.decimals,N=o[v.mint.address];return u<((E=v.startTime)!=null?E:0)||u>((X=v.endTime)!=null?X:0)||!v.perSecond||!N||L===void 0?0:new ke(N.value).mul(new ke(v.perSecond).mul(R)).div(new ke(10).pow(L)).mul(x).mul(100).toNumber()});return{feeApr:B,rewardsApr:C,apr:B+C.reduce((v,L)=>v+L,0)}}static async getLiquidityAmountOutFromAmountIn({poolInfo:e,inputA:t,tickLower:n,tickUpper:o,amount:r,slippage:i,add:s,epochInfo:u,amountHasFee:a}){var g,P;let c=se.priceToSqrtPriceX64(new ke(e.price),e.mintA.decimals,e.mintB.decimals),m=se.getSqrtPriceX64FromTick(n),p=se.getSqrtPriceX64FromTick(o),d=Ie(r,(g=e[t?"mintA":"mintB"].extensions)==null?void 0:g.feeConfig,u,!a),f=new qe(new ke(d.amount.sub((P=d.fee)!=null?P:ge).toString()).toFixed(0)),y;if(c.lte(m))y=t?Ae.getLiquidityFromTokenAmountA(m,p,f,!s):new qe(0);else if(c.lte(p)){let h=Ae.getLiquidityFromTokenAmountA(c,p,f,!s),I=Ae.getLiquidityFromTokenAmountB(m,c,f);y=t?h:I}else y=t?new qe(0):Ae.getLiquidityFromTokenAmountB(m,p,f);let b=await ve.getAmountsFromLiquidity({epochInfo:u,poolInfo:e,tickLower:n,tickUpper:o,liquidity:y,slippage:i,add:s});return{liquidity:y,amountA:t?d:b.amountA,amountB:t?b.amountB:d,amountSlippageA:t?d:b.amountSlippageA,amountSlippageB:t?b.amountSlippageB:d,expirationTime:b.expirationTime}}static async getAmountsFromLiquidity({epochInfo:e,poolInfo:t,tickLower:n,tickUpper:o,liquidity:r,slippage:i,add:s}){var b,g,P,h;let u=se.getSqrtPriceX64FromTick(n),a=se.getSqrtPriceX64FromTick(o),c=s?1+i:1-i,m=Ae.getAmountsFromLiquidity(se.priceToSqrtPriceX64(new ke(t.price),t.mintA.decimals,t.mintB.decimals),u,a,r,s),[p,d]=[Ie(m.amountA,(b=t.mintA.extensions)==null?void 0:b.feeConfig,e,!0),Ie(m.amountB,(g=t.mintB.extensions)==null?void 0:g.feeConfig,e,!0)],[f,y]=[Ie(m.amountA.muln(c),(P=t.mintA.extensions)==null?void 0:P.feeConfig,e,!0),Ie(m.amountB.muln(c),(h=t.mintB.extensions)==null?void 0:h.feeConfig,e,!0)];return{liquidity:r,amountA:p,amountB:d,amountSlippageA:f,amountSlippageB:y,expirationTime:Jt(p.expirationTime,d.expirationTime)}}static async fetchComputeMultipleClmmInfo({connection:e,poolList:t,rpcDataMap:n={}}){let o=t.filter(u=>!n[u.id]).map(u=>new _t(u.id));(await Zt(e,o)).forEach((u,a)=>{!u||(n[o[a].toBase58()]=ao.decode(u.data))});let i=t.map(u=>He(new _t(u.programId),new _t(u.id)).publicKey),s=await ve.fetchExBitmaps({connection:e,exBitmapAddress:i,batchRequest:!1});return t.reduce((u,a)=>q(M({},u),{[a.id]:q(M({},n[a.id]),{id:new _t(a.id),version:6,programId:new _t(a.programId),mintA:a.mintA,mintB:a.mintB,ammConfig:q(M({},a.config),{id:new _t(a.config.id),fundOwner:""}),currentPrice:new ke(a.price),exBitmapAccount:He(new _t(a.programId),new _t(a.id)).publicKey,exBitmapInfo:s[He(new _t(a.programId),new _t(a.id)).publicKey.toBase58()],startTime:n[a.id].startTime.toNumber(),rewardInfos:n[a.id].rewardInfos})}),{})}static async fetchComputeClmmInfo({connection:e,poolInfo:t,rpcData:n}){return(await this.fetchComputeMultipleClmmInfo({connection:e,rpcDataMap:n?{[t.id]:n}:void 0,poolList:[t]}))[t.id]}};function LT({poolInfo:l,tickLower:e,tickUpper:t,amountA:n,amountB:o,slippage:r,add:i,epochInfo:s,amountHasFee:u}){var h,I,T,w;let[a,c,m,p]=e<t?[e,t,n,o]:[t,e,o,n],d=se.priceToSqrtPriceX64(new ke(l.price),l.mintA.decimals,l.mintB.decimals),f=se.getSqrtPriceX64FromTick(a),y=se.getSqrtPriceX64FromTick(c),[b,g]=[Ie(m,(h=l.mintA.extensions)==null?void 0:h.feeConfig,s,!u),Ie(p,(I=l.mintB.extensions)==null?void 0:I.feeConfig,s,!u)],P=Ae.getLiquidityFromTokenAmounts(d,f,y,b.amount.sub((T=b.fee)!=null?T:ge),g.amount.sub((w=g.fee)!=null?w:ge));return Ae.getAmountsOutFromLiquidity({poolInfo:l,tickLower:e,tickUpper:t,liquidity:P,slippage:r,add:i,epochInfo:s,amountAddFee:!u})}var Ia={volume:0,volumeQuote:0,volumeFee:0,apr:0,feeApr:0,priceMin:0,priceMax:0,rewardApr:[]};function zc(l){return q(M({},l),{type:"Concentrated",programId:l.programId.toString(),id:l.id.toString(),rewardDefaultInfos:[],rewardDefaultPoolInfos:"Clmm",price:l.currentPrice.toNumber(),mintAmountA:0,mintAmountB:0,feeRate:l.ammConfig.tradeFeeRate,openTime:l.startTime.toString(),tvl:0,day:Ia,week:Ia,month:Ia,pooltype:[],farmUpcomingCount:0,farmOngoingCount:0,farmFinishedCount:0,burnPercent:0,config:q(M({},l.ammConfig),{id:l.ammConfig.id.toString(),defaultRange:0,defaultRangePoint:[]})})}var le=class{static mulDivRoundingUp(e,t,n){let o=e.mul(t),r=o.div(n);return o.mod(n).eq(ge)||(r=r.add(Vt)),r}static mulDivFloor(e,t,n){if(n.eq(ge))throw new Error("division by 0");return e.mul(t).div(n)}static mulDivCeil(e,t,n){if(n.eq(ge))throw new Error("division by 0");return e.mul(t).add(n.sub(Vt)).div(n)}static x64ToDecimal(e,t){return new mn(e.toString()).div(mn.pow(2,64)).toDecimalPlaces(t)}static decimalToX64(e){return new pe(e.mul(mn.pow(2,64)).floor().toFixed())}static wrappingSubU128(e,t){return e.add(Or).sub(t).mod(Or)}};function ut(l,e){return Ba(l.mul(e),64,256)}function up(l,e,t){let n=l.toTwos(t).shln(e);return n.imaskn(t+1),n.fromTwos(t)}function Ba(l,e,t){let n=l.toTwos(t).shrn(e);return n.imaskn(t-e+1),n.fromTwos(t-e)}var se=class{static sqrtPriceX64ToPrice(e,t,n){return le.x64ToDecimal(e).pow(2).mul(mn.pow(10,t-n))}static priceToSqrtPriceX64(e,t,n){return le.decimalToX64(e.mul(mn.pow(10,n-t)).sqrt())}static getNextSqrtPriceX64FromInput(e,t,n,o){if(!e.gt(ge))throw new Error("sqrtPriceX64 must greater than 0");if(!t.gt(ge))throw new Error("liquidity must greater than 0");return o?this.getNextSqrtPriceFromTokenAmountARoundingUp(e,t,n,!0):this.getNextSqrtPriceFromTokenAmountBRoundingDown(e,t,n,!0)}static getNextSqrtPriceX64FromOutput(e,t,n,o){if(!e.gt(ge))throw new Error("sqrtPriceX64 must greater than 0");if(!t.gt(ge))throw new Error("liquidity must greater than 0");return o?this.getNextSqrtPriceFromTokenAmountBRoundingDown(e,t,n,!1):this.getNextSqrtPriceFromTokenAmountARoundingUp(e,t,n,!1)}static getNextSqrtPriceFromTokenAmountARoundingUp(e,t,n,o){if(n.eq(ge))return e;let r=t.shln(hi);if(o){let i=r,s=r.add(n.mul(e));return s.gte(i)?le.mulDivCeil(i,e,s):le.mulDivRoundingUp(i,Vt,i.div(e).add(n))}else{let i=n.mul(e);if(!r.gt(i))throw new Error("getNextSqrtPriceFromTokenAmountARoundingUp,liquidityLeftShift must gt amountMulSqrtPrice");let s=r.sub(i);return le.mulDivCeil(r,e,s)}}static getNextSqrtPriceFromTokenAmountBRoundingDown(e,t,n,o){let r=n.shln(hi);if(o)return e.add(r.div(t));{let i=le.mulDivRoundingUp(r,Vt,t);if(!e.gt(i))throw new Error("getNextSqrtPriceFromTokenAmountBRoundingDown sqrtPriceX64 must gt amountDivLiquidity");return e.sub(i)}}static getSqrtPriceX64FromTick(e){if(!Number.isInteger(e))throw new Error("tick must be integer");if(e<ft||e>wt)throw new Error("tick must be in MIN_TICK and MAX_TICK");let t=e<0?e*-1:e,n=(t&1)!=0?new pe("18445821805675395072"):new pe("18446744073709551616");return(t&2)!=0&&(n=ut(n,new pe("18444899583751176192"))),(t&4)!=0&&(n=ut(n,new pe("18443055278223355904"))),(t&8)!=0&&(n=ut(n,new pe("18439367220385607680"))),(t&16)!=0&&(n=ut(n,new pe("18431993317065453568"))),(t&32)!=0&&(n=ut(n,new pe("18417254355718170624"))),(t&64)!=0&&(n=ut(n,new pe("18387811781193609216"))),(t&128)!=0&&(n=ut(n,new pe("18329067761203558400"))),(t&256)!=0&&(n=ut(n,new pe("18212142134806163456"))),(t&512)!=0&&(n=ut(n,new pe("17980523815641700352"))),(t&1024)!=0&&(n=ut(n,new pe("17526086738831433728"))),(t&2048)!=0&&(n=ut(n,new pe("16651378430235570176"))),(t&4096)!=0&&(n=ut(n,new pe("15030750278694412288"))),(t&8192)!=0&&(n=ut(n,new pe("12247334978884435968"))),(t&16384)!=0&&(n=ut(n,new pe("8131365268886854656"))),(t&32768)!=0&&(n=ut(n,new pe("3584323654725218816"))),(t&65536)!=0&&(n=ut(n,new pe("696457651848324352"))),(t&131072)!=0&&(n=ut(n,new pe("26294789957507116"))),(t&262144)!=0&&(n=ut(n,new pe("37481735321082"))),e>0&&(n=Oc.div(n)),n}static getTickFromPrice(e,t,n){return se.getTickFromSqrtPriceX64(se.priceToSqrtPriceX64(e,t,n))}static getTickFromSqrtPriceX64(e){if(e.gt(Xt)||e.lt(Gt))throw new Error("Provided sqrtPrice is not within the supported sqrtPrice range.");let t=e.bitLength()-1,n=new pe(t-64),o=up(n,32,128),r=new pe("8000000000000000","hex"),i=0,s=new pe(0),u=t>=64?e.shrn(t-63):e.shln(63-t);for(;r.gt(new pe(0))&&i<Nc;){u=u.mul(u);let f=u.shrn(127);u=u.shrn(63+f.toNumber()),s=s.add(r.mul(f)),r=r.shrn(1),i+=1}let a=s.shrn(32),m=o.add(a).mul(new pe(Mc)),p=Ba(m.sub(new pe(vc)),64,128).toNumber(),d=Ba(m.add(new pe(Fc)),64,128).toNumber();return p==d?p:se.getSqrtPriceX64FromTick(d).lte(e)?d:p}},uo=class{static getTickWithPriceAndTickspacing(e,t,n,o){let i=se.getTickFromSqrtPriceX64(se.priceToSqrtPriceX64(e,n,o))/t;return i<0?i=Math.floor(i):i=Math.ceil(i),i*t}static roundPriceWithTickspacing(e,t,n,o){let r=uo.getTickWithPriceAndTickspacing(e,t,n,o),i=se.getSqrtPriceX64FromTick(r);return se.sqrtPriceX64ToPrice(i,n,o)}},Ae=class{static addDelta(e,t){return e.add(t)}static getTokenAmountAFromLiquidity(e,t,n,o){if(e.gt(t)&&([e,t]=[t,e]),!e.gt(ge))throw new Error("sqrtPriceX64A must greater than 0");let r=n.ushln(hi),i=t.sub(e);return o?le.mulDivRoundingUp(le.mulDivCeil(r,i,t),Vt,e):le.mulDivFloor(r,i,t).div(e)}static getTokenAmountBFromLiquidity(e,t,n,o){if(e.gt(t)&&([e,t]=[t,e]),!e.gt(ge))throw new Error("sqrtPriceX64A must greater than 0");return o?le.mulDivCeil(n,t.sub(e),nt):le.mulDivFloor(n,t.sub(e),nt)}static getLiquidityFromTokenAmountA(e,t,n,o){e.gt(t)&&([e,t]=[t,e]);let r=n.mul(e).mul(t),i=t.sub(e),s=r.div(i);return o?le.mulDivRoundingUp(s,Vt,Ti):s.shrn(hi)}static getLiquidityFromTokenAmountB(e,t,n){return e.gt(t)&&([e,t]=[t,e]),le.mulDivFloor(n,Ti,t.sub(e))}static getLiquidityFromTokenAmounts(e,t,n,o,r){if(t.gt(n)&&([t,n]=[n,t]),e.lte(t))return Ae.getLiquidityFromTokenAmountA(t,n,o,!1);if(e.lt(n)){let i=Ae.getLiquidityFromTokenAmountA(e,n,o,!1),s=Ae.getLiquidityFromTokenAmountB(t,e,r);return i.lt(s)?i:s}else return Ae.getLiquidityFromTokenAmountB(t,n,r)}static getAmountsFromLiquidity(e,t,n,o,r){if(t.gt(n)&&([t,n]=[n,t]),e.lte(t))return{amountA:Ae.getTokenAmountAFromLiquidity(t,n,o,r),amountB:new pe(0)};if(e.lt(n)){let i=Ae.getTokenAmountAFromLiquidity(e,n,o,r),s=Ae.getTokenAmountBFromLiquidity(t,e,o,r);return{amountA:i,amountB:s}}else return{amountA:new pe(0),amountB:Ae.getTokenAmountBFromLiquidity(t,n,o,r)}}static getAmountsFromLiquidityWithSlippage(e,t,n,o,r,i,s){let{amountA:u,amountB:a}=Ae.getAmountsFromLiquidity(e,t,n,o,i),c=r?1+s:1-s,m=new pe(new mn(u.toString()).mul(c).toFixed(0)),p=new pe(new mn(a.toString()).mul(c).toFixed(0));return{amountSlippageA:m,amountSlippageB:p}}static getAmountsOutFromLiquidity({poolInfo:e,tickLower:t,tickUpper:n,liquidity:o,slippage:r,add:i,epochInfo:s,amountAddFee:u}){var P,h,I,T;let a=se.priceToSqrtPriceX64(new mn(e.price),e.mintA.decimals,e.mintB.decimals),c=se.getSqrtPriceX64FromTick(t),m=se.getSqrtPriceX64FromTick(n),p=i?1+r:1-r,d=Ae.getAmountsFromLiquidity(a,c,m,o,i),[f,y]=[Ie(d.amountA,(P=e.mintA.extensions)==null?void 0:P.feeConfig,s,u),Ie(d.amountB,(h=e.mintB.extensions)==null?void 0:h.feeConfig,s,u)],[b,g]=[Ie(new pe(new mn(d.amountA.toString()).mul(p).toFixed(0)),(I=e.mintA.extensions)==null?void 0:I.feeConfig,s,u),Ie(new pe(new mn(d.amountB.toString()).mul(p).toFixed(0)),(T=e.mintB.extensions)==null?void 0:T.feeConfig,s,u)];return{liquidity:o,amountA:f,amountB:y,amountSlippageA:b,amountSlippageB:g,expirationTime:Jt(f.expirationTime,y.expirationTime)}}},so=class{static swapCompute(e,t,n,o,r,i,s,u,a,c,m,p,d,f,y=!1){if(p.eq(ge))throw new Error("amountSpecified must not be 0");if(f||(f=i?Gt.add(Vt):Xt.sub(Vt)),i){if(f.lt(Gt))throw new Error("sqrtPriceX64 must greater than MIN_SQRT_PRICE_X64");if(f.gte(m))throw new Error("sqrtPriceX64 must smaller than current")}else{if(f.gt(Xt))throw new Error("sqrtPriceX64 must smaller than MAX_SQRT_PRICE_X64");if(f.lte(m))throw new Error("sqrtPriceX64 must greater than current")}let b=p.gt(ge),g={amountSpecifiedRemaining:p,amountCalculated:ge,sqrtPriceX64:m,tick:a>d?Math.min(d+we.tickCount(c)-1,a):d,accounts:[],liquidity:u,feeAmount:new pe(0)},P=d,h=n[d],I=0,T=!i&&h.startTickIndex===g.tick;for(;!g.amountSpecifiedRemaining.eq(ge)&&!g.sqrtPriceX64.eq(f);){I>10;let w={};w.sqrtPriceStartX64=g.sqrtPriceX64;let K=Z.nextInitTick(h,g.tick,c,i,T),x=K||null,S=null;if(!(x!=null&&x.liquidityGross.gtn(0))){let R=ve.nextInitializedTickArrayStartIndex({tickCurrent:g.tick,tickSpacing:c,tickArrayBitmap:o,exBitmapInfo:r},P,i);if(!R.isExist){if(y)return{allTrade:!1,amountSpecifiedRemaining:g.amountSpecifiedRemaining,amountCalculated:g.amountCalculated,feeAmount:g.feeAmount,sqrtPriceX64:g.sqrtPriceX64,liquidity:g.liquidity,tickCurrent:g.tick,accounts:g.accounts};throw Error("swapCompute LiquidityInsufficient")}P=R.nextStartIndex;let{publicKey:C}=Pe(e,t,P);S=C,h=n[P];try{x=Z.firstInitializedTick(h,i)}catch{throw Error("not found next tick info")}}w.tickNext=x.tick,w.initialized=x.liquidityGross.gtn(0),d!==P&&S&&(g.accounts.push(S),d=P),w.tickNext<ft?w.tickNext=ft:w.tickNext>wt&&(w.tickNext=wt),w.sqrtPriceNextX64=se.getSqrtPriceX64FromTick(w.tickNext);let B;if(i&&w.sqrtPriceNextX64.lt(f)||!i&&w.sqrtPriceNextX64.gt(f)?B=f:B=w.sqrtPriceNextX64,[g.sqrtPriceX64,w.amountIn,w.amountOut,w.feeAmount]=so.swapStepCompute(g.sqrtPriceX64,B,g.liquidity,g.amountSpecifiedRemaining,s,i),g.feeAmount=g.feeAmount.add(w.feeAmount),b?(g.amountSpecifiedRemaining=g.amountSpecifiedRemaining.sub(w.amountIn.add(w.feeAmount)),g.amountCalculated=g.amountCalculated.sub(w.amountOut)):(g.amountSpecifiedRemaining=g.amountSpecifiedRemaining.add(w.amountOut),g.amountCalculated=g.amountCalculated.add(w.amountIn.add(w.feeAmount))),g.sqrtPriceX64.eq(w.sqrtPriceNextX64)){if(w.initialized){let R=x.liquidityNet;i&&(R=R.mul(wn)),g.liquidity=Ae.addDelta(g.liquidity,R)}T=w.tickNext!=g.tick&&!i&&h.startTickIndex===w.tickNext,g.tick=i?w.tickNext-1:w.tickNext}else if(g.sqrtPriceX64!=w.sqrtPriceStartX64){let R=se.getTickFromSqrtPriceX64(g.sqrtPriceX64);T=R!=g.tick&&!i&&h.startTickIndex===R,g.tick=R}++I}try{let{nextStartIndex:w,isExist:K}=we.nextInitializedTickArray(g.tick,c,i,o,r);K&&d!==w&&(g.accounts.push(Pe(e,t,w).publicKey),d=w)}catch{}return{allTrade:!0,amountSpecifiedRemaining:ge,amountCalculated:g.amountCalculated,feeAmount:g.feeAmount,sqrtPriceX64:g.sqrtPriceX64,liquidity:g.liquidity,tickCurrent:g.tick,accounts:g.accounts}}static swapStepCompute(e,t,n,o,r,i){let s={sqrtPriceX64Next:new pe(0),amountIn:new pe(0),amountOut:new pe(0),feeAmount:new pe(0)},u=o.gte(ge);if(u){let c=le.mulDivFloor(o,vr.sub(new pe(r.toString())),vr);s.amountIn=i?Ae.getTokenAmountAFromLiquidity(t,e,n,!0):Ae.getTokenAmountBFromLiquidity(e,t,n,!0),c.gte(s.amountIn)?s.sqrtPriceX64Next=t:s.sqrtPriceX64Next=se.getNextSqrtPriceX64FromInput(e,n,c,i)}else s.amountOut=i?Ae.getTokenAmountBFromLiquidity(t,e,n,!1):Ae.getTokenAmountAFromLiquidity(e,t,n,!1),o.mul(wn).gte(s.amountOut)?s.sqrtPriceX64Next=t:s.sqrtPriceX64Next=se.getNextSqrtPriceX64FromOutput(e,n,o.mul(wn),i);let a=t.eq(s.sqrtPriceX64Next);return i?(a&&u||(s.amountIn=Ae.getTokenAmountAFromLiquidity(s.sqrtPriceX64Next,e,n,!0)),a&&!u||(s.amountOut=Ae.getTokenAmountBFromLiquidity(s.sqrtPriceX64Next,e,n,!1))):(s.amountIn=a&&u?s.amountIn:Ae.getTokenAmountBFromLiquidity(e,s.sqrtPriceX64Next,n,!0),s.amountOut=a&&!u?s.amountOut:Ae.getTokenAmountAFromLiquidity(e,s.sqrtPriceX64Next,n,!1)),!u&&s.amountOut.gt(o.mul(wn))&&(s.amountOut=o.mul(wn)),u&&!s.sqrtPriceX64Next.eq(t)?s.feeAmount=o.sub(s.amountIn):s.feeAmount=le.mulDivCeil(s.amountIn,new pe(r),vr.sub(new pe(r))),[s.sqrtPriceX64Next,s.amountIn,s.amountOut,s.feeAmount]}};var ot=60,ro=512,Z=class{static getTickArrayAddressByTick(e,t,n,o){let r=Z.getTickArrayStartIndexByTick(n,o),{publicKey:i}=Pe(e,t,r);return i}static getTickOffsetInArray(e,t){if(e%t!=0)throw new Error("tickIndex % tickSpacing not equal 0");let n=Z.getTickArrayStartIndexByTick(e,t),o=Math.floor((e-n)/t);if(o<0||o>=ot)throw new Error("tick offset in array overflow");return o}static getTickArrayBitIndex(e,t){let n=we.tickCount(t),o=e/n;return e<0&&e%n!=0?o=Math.ceil(o)-1:o=Math.floor(o),o}static getTickArrayStartIndexByTick(e,t){return this.getTickArrayBitIndex(e,t)*we.tickCount(t)}static getTickArrayOffsetInBitmapByTick(e,t){let n=t*ot,o=Math.floor(e/n)+512;return Math.abs(o)}static checkTickArrayIsInitialized(e,t,n){let o=n*ot,r=Math.floor(t/o)+512,i=Math.abs(r);return{isInitialized:e.testn(i),startIndex:(i-512)*o}}static getNextTickArrayStartIndex(e,t,n){return n?e-t*ot:e+t*ot}static mergeTickArrayBitmap(e){let t=new cp(0);for(let n=0;n<e.length;n++)t=t.add(e[n].shln(64*n));return t}static getInitializedTickArrayInRange(e,t,n,o,r){let i=Math.floor(o/(n*ot));return[...Z.searchLowBitFromStart(e,t,i-1,r,n),...Z.searchHightBitFromStart(e,t,i,r,n)]}static getAllInitializedTickArrayStartIndex(e,t,n){return Z.searchHightBitFromStart(e,t,-7680,ro,n)}static getAllInitializedTickArrayInfo(e,t,n,o,r){let i=[],s=Z.getAllInitializedTickArrayStartIndex(n,o,r);for(let u of s){let{publicKey:a}=Pe(e,t,u);i.push({tickArrayStartIndex:u,tickArrayAddress:a})}return i}static getAllInitializedTickInTickArray(e){return e.ticks.filter(t=>t.liquidityGross.gtn(0))}static searchLowBitFromStart(e,t,n,o,r){let i=[...[...t.negativeTickArrayBitmap].reverse(),e.slice(0,8),e.slice(8,16),...t.positiveTickArrayBitmap].map(a=>Z.mergeTickArrayBitmap(a)),s=[];for(;n>=-7680;){let a=Math.floor((n+7680)/512),c=(n+7680)%512;if(i[a].testn(c)&&s.push(n),n--,s.length===o)break}let u=we.tickCount(r);return s.map(a=>a*u)}static searchHightBitFromStart(e,t,n,o,r){let i=[...[...t.negativeTickArrayBitmap].reverse(),e.slice(0,8),e.slice(8,16),...t.positiveTickArrayBitmap].map(a=>Z.mergeTickArrayBitmap(a)),s=[];for(;n<7680;){let a=Math.floor((n+7680)/512),c=(n+7680)%512;if(i[a].testn(c)&&s.push(n),n++,s.length===o)break}let u=we.tickCount(r);return s.map(a=>a*u)}static checkIsOutOfBoundary(e){return e<ft||e>wt}static nextInitTick(e,t,n,o,r){if(we.getArrayStartIndex(t,n)!=e.startTickIndex)return null;let s=Math.floor((t-e.startTickIndex)/n);if(o)for(;s>=0;){if(e.ticks[s].liquidityGross.gtn(0))return e.ticks[s];s=s-1}else for(r||(s=s+1);s<ot;){if(e.ticks[s].liquidityGross.gtn(0))return e.ticks[s];s=s+1}return null}static firstInitializedTick(e,t){if(t){let n=ot-1;for(;n>=0;){if(e.ticks[n].liquidityGross.gtn(0))return e.ticks[n];n=n-1}}else{let n=0;for(;n<ot;){if(e.ticks[n].liquidityGross.gtn(0))return e.ticks[n];n=n+1}}throw Error(`firstInitializedTick check error: ${e} - ${t}`)}static _getTickPriceLegacy({poolInfo:e,tick:t,baseIn:n}){let o=se.getSqrtPriceX64FromTick(t),r=se.sqrtPriceX64ToPrice(o,e.mintA.decimals,e.mintB.decimals);return n?{tick:t,price:r,tickSqrtPriceX64:o}:{tick:t,price:new Fo(1).div(r),tickSqrtPriceX64:o}}static _getPriceAndTickLegacy({poolInfo:e,price:t,baseIn:n}){let o=n?t:new Fo(1).div(t),r=uo.getTickWithPriceAndTickspacing(o,e.ammConfig.tickSpacing,e.mintA.decimals,e.mintB.decimals),i=se.getSqrtPriceX64FromTick(r),s=se.sqrtPriceX64ToPrice(i,e.mintA.decimals,e.mintB.decimals);return n?{tick:r,price:s}:{tick:r,price:new Fo(1).div(s)}}static getTickPrice({poolInfo:e,tick:t,baseIn:n}){let o=se.getSqrtPriceX64FromTick(t),r=se.sqrtPriceX64ToPrice(o,e.mintA.decimals,e.mintB.decimals);return n?{tick:t,price:r,tickSqrtPriceX64:o}:{tick:t,price:new Fo(1).div(r),tickSqrtPriceX64:o}}static getPriceAndTick({poolInfo:e,price:t,baseIn:n}){let o=n?t:new Fo(1).div(t),r=uo.getTickWithPriceAndTickspacing(o,e.config.tickSpacing,e.mintA.decimals,e.mintB.decimals),i=se.getSqrtPriceX64FromTick(r),s=se.sqrtPriceX64ToPrice(i,e.mintA.decimals,e.mintB.decimals);return n?{tick:r,price:s}:{tick:r,price:new Fo(1).div(s)}}};var Qc=F([Te(8),_("bump"),Ft("index"),O(""),ct("protocolFeeRate"),ct("tradeFeeRate"),Ft("tickSpacing"),Y(A(),8,"")]),lp=F([ct("blockTimestamp"),Co("tickCumulative"),Y(A(),4)]),Hc=F([Te(8),De("initialized"),A("recentEpoch"),Ft("observationIndex"),O("poolId"),Y(lp,100,"observations"),Y(A(),4)]),mp=F([_("rewardState"),A("openTime"),A("endTime"),A("lastUpdateTime"),ne("emissionsPerSecondX64"),A("rewardTotalEmissioned"),A("rewardClaimed"),O("tokenMint"),O("tokenVault"),O("creator"),ne("rewardGrowthGlobalX64")]),ao=F([Te(8),_("bump"),O("ammConfig"),O("creator"),O("mintA"),O("mintB"),O("vaultA"),O("vaultB"),O("observationId"),_("mintDecimalsA"),_("mintDecimalsB"),Ft("tickSpacing"),ne("liquidity"),ne("sqrtPriceX64"),We("tickCurrent"),ct(),ne("feeGrowthGlobalX64A"),ne("feeGrowthGlobalX64B"),A("protocolFeesTokenA"),A("protocolFeesTokenB"),ne("swapInAmountTokenA"),ne("swapOutAmountTokenB"),ne("swapInAmountTokenB"),ne("swapOutAmountTokenA"),_("status"),Y(_(),7,""),Y(mp,3,"rewardInfos"),Y(A(),16,"tickArrayBitmap"),A("totalFeesTokenA"),A("totalFeesClaimedTokenA"),A("totalFeesTokenB"),A("totalFeesClaimedTokenB"),A("fundFeesTokenA"),A("fundFeesTokenB"),A("startTime"),Y(A(),15*4-3,"padding")]),dp=F([ne("growthInsideLastX64"),A("rewardAmountOwed")]),vo=F([Te(8),_("bump"),O("nftMint"),O("poolId"),We("tickLower"),We("tickUpper"),ne("liquidity"),ne("feeGrowthInsideLastX64A"),ne("feeGrowthInsideLastX64B"),A("tokenFeesOwedA"),A("tokenFeesOwedB"),Y(dp,3,"rewardInfos"),Y(A(),8,"")]),th=F([Te(8),_("bump"),O("poolId"),We("tickLowerIndex"),We("tickUpperIndex"),ne("liquidity"),ne("feeGrowthInsideLastX64A"),ne("feeGrowthInsideLastX64B"),A("tokenFeesOwedA"),A("tokenFeesOwedB"),Y(ne(),3,"rewardGrowthInside"),Y(A(),8,"")]),pp=F([We("tick"),uc("liquidityNet"),ne("liquidityGross"),ne("feeGrowthOutsideX64A"),ne("feeGrowthOutsideX64B"),Y(ne(),3,"rewardGrowthsOutsideX64"),Y(ct(),13,"")]),Ki=F([Te(8),O("poolId"),We("startTickIndex"),Y(pp,ot,"ticks"),_("initializedTickCount"),Y(_(),115,"")]),jc=F([Te(329),Y(O(),100,"whitelistMints")]),Yc=F([Te(8),O("poolId"),Y(Y(A(),8),ha,"positiveTickArrayBitmap"),Y(Y(A(),8),ha,"negativeTickArrayBitmap")]),nh=F([A(),_("bump"),O("owner"),O("poolId"),O("positionId"),O("nftAccount"),Y(A(),8)]),$c=F([Te(8),_("bump"),O("lockOwner"),O("poolId"),O("positionId"),O("nftAccount"),O("lockNftMint"),A("recentEpoch"),Y(A(),8)]);Hc.span;var Zc=ye("Raydium_Clmm"),Et={createPool:[233,146,209,142,207,104,64,188],initReward:[95,135,192,196,242,129,230,68],setRewardEmissions:[112,52,167,75,32,201,211,137],openPosition:[77,184,74,214,112,86,241,199],openPositionWithTokenEx:[77,255,174,82,125,29,201,46],closePosition:[123,134,81,0,49,68,98,98],increaseLiquidity:[133,29,89,223,69,238,176,10],decreaseLiquidity:[58,127,188,62,79,82,196,96],swap:[43,4,237,11,26,201,30,98],collectReward:[18,237,166,197,34,16,213,144]},Jc=[188,37,179,131,82,150,84,73],el=[16,72,250,198,14,162,212,19],Se=class{static createPoolInstruction(e,t,n,o,r,i,s,u,a,c,m,p,d,f){let y=F([ne("sqrtPriceX64"),A("zero")]),b=[{pubkey:n,isSigner:!0,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!1},{pubkey:a,isSigner:!1,isWritable:!1},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:p,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!1},{pubkey:m,isSigner:!1,isWritable:!1},{pubkey:In.programId,isSigner:!1,isWritable:!1},{pubkey:$e,isSigner:!1,isWritable:!1},...(f==null?void 0:f.map(h=>({pubkey:h,isSigner:!1,isWritable:!1})))||[]],g=Buffer.alloc(y.span);y.encode({sqrtPriceX64:d,zero:ge},g);let P=Buffer.from([...Et.createPool,...g]);return new mt({keys:b,programId:e,data:P})}static async createPoolInstructions(e){let{programId:t,owner:n,mintA:o,mintB:r,ammConfigId:i,initialPriceX64:s,extendMintAccount:u}=e,[a,c]=[new z(o.address),new z(r.address)],{publicKey:m}=Dc(t,i,a,c),{publicKey:p}=Uc(t,m),{publicKey:d}=Aa(t,m,a),{publicKey:f}=Aa(t,m,c),y=He(t,m).publicKey,b=[this.createPoolInstruction(t,m,n,i,p,a,d,new z(o.programId||Ke),c,f,new z(r.programId||Ke),y,s,u)];return{signers:[],instructions:b,instructionTypes:[G.CreateAccount,G.ClmmCreatePool],address:{poolId:m,observationId:p,exBitmapAccount:y,mintAVault:d,mintBVault:f},lookupTableAddress:[]}}static openPositionFromLiquidityInstruction(e,t,n,o,r,i,s,u,a,c,m,p,d,f,y,b,g,P,h,I,T,w,K,x,S,B){let R=F([We("tickLowerIndex"),We("tickUpperIndex"),We("tickArrayLowerStartIndex"),We("tickArrayUpperStartIndex"),ne("liquidity"),A("amountMaxA"),A("amountMaxB"),De("withMetadata"),_("optionBaseFlag"),De("baseFlag")]),C=[...B?[{pubkey:B,isSigner:!1,isWritable:!0}]:[]],v=[{pubkey:t,isSigner:!0,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!0,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:m,isSigner:!1,isWritable:!0},{pubkey:p,isSigner:!1,isWritable:!0},{pubkey:d,isSigner:!1,isWritable:!0},{pubkey:f,isSigner:!1,isWritable:!0},{pubkey:y,isSigner:!1,isWritable:!0},{pubkey:$e,isSigner:!1,isWritable:!1},{pubkey:In.programId,isSigner:!1,isWritable:!1},{pubkey:Ke,isSigner:!1,isWritable:!1},{pubkey:Ci,isSigner:!1,isWritable:!1},{pubkey:Dt,isSigner:!1,isWritable:!1},{pubkey:ze,isSigner:!1,isWritable:!1},{pubkey:b,isSigner:!1,isWritable:!1},{pubkey:g,isSigner:!1,isWritable:!1},...C],L=Buffer.alloc(R.span);R.encode({tickLowerIndex:P,tickUpperIndex:h,tickArrayLowerStartIndex:I,tickArrayUpperStartIndex:T,liquidity:w,amountMaxA:K,amountMaxB:x,withMetadata:S==="create",baseFlag:!1,optionBaseFlag:0},L);let N=Buffer.from([...Et.openPosition,...L]);return new mt({keys:v,programId:e,data:N})}static openPositionFromLiquidityInstruction22(e,t,n,o,r,i,s,u,a,c,m,p,d,f,y,b,g,P,h,I,T,w,K,x,S){let B=F([We("tickLowerIndex"),We("tickUpperIndex"),We("tickArrayLowerStartIndex"),We("tickArrayUpperStartIndex"),ne("liquidity"),A("amountMaxA"),A("amountMaxB"),De("withMetadata"),_("optionBaseFlag"),De("baseFlag")]),R=[...S?[{pubkey:S,isSigner:!1,isWritable:!0}]:[]],C=[{pubkey:t,isSigner:!0,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!0,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:m,isSigner:!1,isWritable:!0},{pubkey:p,isSigner:!1,isWritable:!0},{pubkey:d,isSigner:!1,isWritable:!0},{pubkey:f,isSigner:!1,isWritable:!0},{pubkey:$e,isSigner:!1,isWritable:!1},{pubkey:In.programId,isSigner:!1,isWritable:!1},{pubkey:Ke,isSigner:!1,isWritable:!1},{pubkey:Ci,isSigner:!1,isWritable:!1},{pubkey:ze,isSigner:!1,isWritable:!1},{pubkey:y,isSigner:!1,isWritable:!1},{pubkey:b,isSigner:!1,isWritable:!1},...R],v=Buffer.alloc(B.span);B.encode({tickLowerIndex:g,tickUpperIndex:P,tickArrayLowerStartIndex:h,tickArrayUpperStartIndex:I,liquidity:T,amountMaxA:w,amountMaxB:K,withMetadata:x==="create",baseFlag:!1,optionBaseFlag:0},v);let L=Buffer.from([...Et.openPositionWithTokenEx,...v]);return new mt({keys:C,programId:e,data:L})}static async openPositionInstructions({poolInfo:e,poolKeys:t,ownerInfo:n,tickLower:o,tickUpper:r,liquidity:i,amountMaxA:s,amountMaxB:u,withMetadata:a,getEphemeralSigners:c,nft2022:m}){let p=[],[d,f]=[new z(e.programId),new z(e.id)],y;if(c)y=new z((await c(1))[0]);else{let S=_r.generate();p.push(S),y=S.publicKey}let b=Z.getTickArrayStartIndexByTick(o,e.config.tickSpacing),g=Z.getTickArrayStartIndexByTick(r,e.config.tickSpacing),{publicKey:P}=Pe(d,f,b),{publicKey:h}=Pe(d,f,g),{publicKey:I}=m?j(n.wallet,y,ze):j(n.wallet,y,Ke),{publicKey:T}=Tn(y),{publicKey:w}=Tt(d,y),{publicKey:K}=nn(d,f,o,r),x=m?this.openPositionFromLiquidityInstruction22(d,n.feePayer,f,n.wallet,y,I,K,P,h,w,n.tokenAccountA,n.tokenAccountB,new z(t.vault.A),new z(t.vault.B),new z(e.mintA.address),new z(e.mintB.address),o,r,b,g,i,s,u,a,ve.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing,[b,g])?He(d,f).publicKey:void 0):this.openPositionFromLiquidityInstruction(d,n.feePayer,f,n.wallet,y,I,T,K,P,h,w,n.tokenAccountA,n.tokenAccountB,new z(t.vault.A),new z(t.vault.B),new z(e.mintA.address),new z(e.mintB.address),o,r,b,g,i,s,u,a,ve.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing,[b,g])?He(d,f).publicKey:void 0);return{signers:p,instructions:[x],instructionTypes:[G.ClmmOpenPosition],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[],address:{nftMint:y,tickArrayLower:P,tickArrayUpper:h,positionNftAccount:I,metadataAccount:T,personalPosition:w,protocolPosition:K}}}static async openPositionFromBaseInstructions({poolInfo:e,poolKeys:t,ownerInfo:n,tickLower:o,tickUpper:r,base:i,baseAmount:s,otherAmountMax:u,withMetadata:a,getEphemeralSigners:c,nft2022:m}){let p=[],[d,f]=[new z(e.programId),new z(e.id)],y;if(c)y=new z((await c(1))[0]);else{let S=_r.generate();p.push(S),y=S.publicKey}let b=Z.getTickArrayStartIndexByTick(o,e.config.tickSpacing),g=Z.getTickArrayStartIndexByTick(r,e.config.tickSpacing),{publicKey:P}=Pe(d,f,b),{publicKey:h}=Pe(d,f,g),{publicKey:I}=m?j(n.wallet,y,ze):j(n.wallet,y,Ke),{publicKey:T}=Tn(y),{publicKey:w}=Tt(d,y),{publicKey:K}=nn(d,f,o,r),x=m?this.openPositionFromBaseInstruction22(d,n.feePayer,f,n.wallet,y,I,K,P,h,w,n.tokenAccountA,n.tokenAccountB,new z(t.vault.A),new z(t.vault.B),new z(e.mintA.address),new z(e.mintB.address),o,r,b,g,a,i,s,u,ve.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing,[b,g])?He(d,f).publicKey:void 0):this.openPositionFromBaseInstruction(d,n.feePayer,f,n.wallet,y,I,T,K,P,h,w,n.tokenAccountA,n.tokenAccountB,new z(t.vault.A),new z(t.vault.B),new z(e.mintA.address),new z(e.mintB.address),o,r,b,g,a,i,s,u,ve.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing,[b,g])?He(d,f).publicKey:void 0);return{address:{nftMint:y,tickArrayLower:P,tickArrayUpper:h,positionNftAccount:I,metadataAccount:T,personalPosition:w,protocolPosition:K},instructions:[x],signers:p,instructionTypes:[G.ClmmOpenPosition],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[]}}static openPositionFromBaseInstruction(e,t,n,o,r,i,s,u,a,c,m,p,d,f,y,b,g,P,h,I,T,w,K,x,S,B){let R=F([We("tickLowerIndex"),We("tickUpperIndex"),We("tickArrayLowerStartIndex"),We("tickArrayUpperStartIndex"),ne("liquidity"),A("amountMaxA"),A("amountMaxB"),De("withMetadata"),_("optionBaseFlag"),De("baseFlag")]),C=[...B?[{pubkey:B,isSigner:!1,isWritable:!0}]:[]],v=[{pubkey:t,isSigner:!0,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!0,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:m,isSigner:!1,isWritable:!0},{pubkey:p,isSigner:!1,isWritable:!0},{pubkey:d,isSigner:!1,isWritable:!0},{pubkey:f,isSigner:!1,isWritable:!0},{pubkey:y,isSigner:!1,isWritable:!0},{pubkey:$e,isSigner:!1,isWritable:!1},{pubkey:In.programId,isSigner:!1,isWritable:!1},{pubkey:Ke,isSigner:!1,isWritable:!1},{pubkey:Ci,isSigner:!1,isWritable:!1},{pubkey:Dt,isSigner:!1,isWritable:!1},{pubkey:ze,isSigner:!1,isWritable:!1},{pubkey:b,isSigner:!1,isWritable:!1},{pubkey:g,isSigner:!1,isWritable:!1},...C],L=Buffer.alloc(R.span);R.encode({tickLowerIndex:P,tickUpperIndex:h,tickArrayLowerStartIndex:I,tickArrayUpperStartIndex:T,liquidity:new xa(0),amountMaxA:K==="MintA"?x:S,amountMaxB:K==="MintA"?S:x,withMetadata:w==="create",baseFlag:K==="MintA",optionBaseFlag:1},L);let N=Buffer.from([...Et.openPosition,...L]);return new mt({keys:v,programId:e,data:N})}static openPositionFromBaseInstruction22(e,t,n,o,r,i,s,u,a,c,m,p,d,f,y,b,g,P,h,I,T,w,K,x,S){let B=F([We("tickLowerIndex"),We("tickUpperIndex"),We("tickArrayLowerStartIndex"),We("tickArrayUpperStartIndex"),ne("liquidity"),A("amountMaxA"),A("amountMaxB"),De("withMetadata"),_("optionBaseFlag"),De("baseFlag")]),R=[...S?[{pubkey:S,isSigner:!1,isWritable:!0}]:[]],C=[{pubkey:t,isSigner:!0,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!0,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:m,isSigner:!1,isWritable:!0},{pubkey:p,isSigner:!1,isWritable:!0},{pubkey:d,isSigner:!1,isWritable:!0},{pubkey:f,isSigner:!1,isWritable:!0},{pubkey:$e,isSigner:!1,isWritable:!1},{pubkey:In.programId,isSigner:!1,isWritable:!1},{pubkey:Ke,isSigner:!1,isWritable:!1},{pubkey:Ci,isSigner:!1,isWritable:!1},{pubkey:ze,isSigner:!1,isWritable:!1},{pubkey:y,isSigner:!1,isWritable:!1},{pubkey:b,isSigner:!1,isWritable:!1},...R],v=Buffer.alloc(B.span);B.encode({tickLowerIndex:g,tickUpperIndex:P,tickArrayLowerStartIndex:h,tickArrayUpperStartIndex:I,liquidity:new xa(0),amountMaxA:w==="MintA"?K:x,amountMaxB:w==="MintA"?x:K,withMetadata:T==="create",baseFlag:w==="MintA",optionBaseFlag:1},v);let L=Buffer.from([...Et.openPositionWithTokenEx,...v]);return new mt({keys:C,programId:e,data:L})}static async openPositionFromLiquidityInstructions({poolInfo:e,poolKeys:t,ownerInfo:n,tickLower:o,tickUpper:r,liquidity:i,amountMaxA:s,amountMaxB:u,withMetadata:a,getEphemeralSigners:c,nft2022:m}){let p,d=[];if(c)p=new z((await c(1))[0]);else{let S=_r.generate();d.push(S),p=S.publicKey}let[f,y]=[new z(e.programId),new z(e.id)],b=Z.getTickArrayStartIndexByTick(o,e.config.tickSpacing),g=Z.getTickArrayStartIndexByTick(r,e.config.tickSpacing),{publicKey:P}=Pe(f,y,b),{publicKey:h}=Pe(f,y,g),{publicKey:I}=m?j(n.wallet,p,ze):j(n.wallet,p,Ke),{publicKey:T}=Tn(p),{publicKey:w}=Tt(f,p),{publicKey:K}=nn(f,y,o,r),x=m?this.openPositionFromLiquidityInstruction22(f,n.wallet,y,n.wallet,p,I,K,P,h,w,n.tokenAccountA,n.tokenAccountB,new z(t.vault.A),new z(t.vault.B),new z(t.mintA.address),new z(t.mintB.address),o,r,b,g,i,s,u,a,ve.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing,[b,g])?He(f,y).publicKey:void 0):this.openPositionFromLiquidityInstruction(f,n.wallet,y,n.wallet,p,I,T,K,P,h,w,n.tokenAccountA,n.tokenAccountB,new z(t.vault.A),new z(t.vault.B),new z(t.mintA.address),new z(t.mintB.address),o,r,b,g,i,s,u,a,ve.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing,[b,g])?He(f,y).publicKey:void 0);return{address:{nftMint:p,tickArrayLower:P,tickArrayUpper:h,positionNftAccount:I,metadataAccount:T,personalPosition:w,protocolPosition:K},instructions:[x],signers:d,instructionTypes:[G.ClmmOpenPosition],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[]}}static closePositionInstruction(e,t,n,o,r,i){let s=F([]),u=[{pubkey:t,isSigner:!0,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:In.programId,isSigner:!1,isWritable:!1},{pubkey:i?ze:Ke,isSigner:!1,isWritable:!1}],a=Buffer.alloc(s.span);s.encode({},a);let c=Buffer.from([...Et.closePosition,...a]);return new mt({keys:u,programId:e,data:c})}static closePositionInstructions({poolInfo:e,poolKeys:t,ownerInfo:n,ownerPosition:o,nft2022:r}){let i=new z(e.programId),s=r?j(n.wallet,o.nftMint,ze).publicKey:j(n.wallet,o.nftMint,Ke).publicKey,{publicKey:u}=Tt(i,o.nftMint),a=[];return a.push(this.closePositionInstruction(i,n.wallet,o.nftMint,s,u,r)),{address:{positionNftAccount:s,personalPosition:u},signers:[],instructions:a,instructionTypes:[G.ClmmClosePosition],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[]}}static increasePositionFromLiquidityInstruction(e,t,n,o,r,i,s,u,a,c,m,p,d,f,y,b,g,P){let h=F([ne("liquidity"),A("amountMaxA"),A("amountMaxB"),_("optionBaseFlag"),De("baseFlag")]),I=[...P?[{pubkey:P,isSigner:!1,isWritable:!0}]:[]],T=[{pubkey:t,isSigner:!0,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:m,isSigner:!1,isWritable:!0},{pubkey:p,isSigner:!1,isWritable:!0},{pubkey:Ke,isSigner:!1,isWritable:!1},{pubkey:ze,isSigner:!1,isWritable:!1},{pubkey:d,isSigner:!1,isWritable:!1},{pubkey:f,isSigner:!1,isWritable:!1},...I],w=Buffer.alloc(h.span);h.encode({liquidity:y,amountMaxA:b,amountMaxB:g,optionBaseFlag:0,baseFlag:!1},w);let K=Buffer.from([...Et.increaseLiquidity,...w]);return new mt({keys:T,programId:e,data:K})}static increasePositionFromLiquidityInstructions({poolInfo:e,poolKeys:t,ownerPosition:n,ownerInfo:o,liquidity:r,amountMaxA:i,amountMaxB:s,nft2022:u}){let[a,c]=[new z(e.programId),new z(e.id)],m=Z.getTickArrayStartIndexByTick(n.tickLower,e.config.tickSpacing),p=Z.getTickArrayStartIndexByTick(n.tickUpper,e.config.tickSpacing),{publicKey:d}=Pe(a,c,m),{publicKey:f}=Pe(a,c,p),{publicKey:y}=u?j(o.wallet,n.nftMint,ze):j(o.wallet,n.nftMint,Ke),{publicKey:b}=Tt(a,n.nftMint),{publicKey:g}=nn(a,c,n.tickLower,n.tickUpper),P=this.increasePositionFromLiquidityInstruction(a,o.wallet,y,b,c,g,d,f,o.tokenAccountA,o.tokenAccountB,new z(t.vault.A),new z(t.vault.B),new z(e.mintA.address),new z(e.mintB.address),r,i,s,ve.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing,[m,p])?He(a,c).publicKey:void 0);return{address:{tickArrayLower:d,tickArrayUpper:f,positionNftAccount:y,personalPosition:b,protocolPosition:g},signers:[],instructions:[P],instructionTypes:[G.ClmmIncreasePosition],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[]}}static increasePositionFromBaseInstructions({poolInfo:e,poolKeys:t,ownerPosition:n,ownerInfo:o,base:r,baseAmount:i,otherAmountMax:s,nft2022:u}){let[a,c]=[new z(e.programId),new z(e.id)],m=Z.getTickArrayStartIndexByTick(n.tickLower,e.config.tickSpacing),p=Z.getTickArrayStartIndexByTick(n.tickUpper,e.config.tickSpacing),{publicKey:d}=Pe(a,c,m),{publicKey:f}=Pe(a,c,p),{publicKey:y}=u?j(o.wallet,n.nftMint,ze):j(o.wallet,n.nftMint,Ke),{publicKey:b}=Tt(a,n.nftMint),{publicKey:g}=nn(a,c,n.tickLower,n.tickUpper);return{address:{tickArrayLower:d,tickArrayUpper:f,positionNftAccount:y,personalPosition:b,protocolPosition:g},instructions:[this.increasePositionFromBaseInstruction(a,o.wallet,y,b,c,g,d,f,o.tokenAccountA,o.tokenAccountB,new z(t.vault.A),new z(t.vault.B),new z(e.mintA.address),new z(e.mintB.address),r,i,s,ve.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing,[m,p])?He(a,c).publicKey:void 0)],signers:[],instructionTypes:[G.ClmmIncreasePosition],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[]}}static increasePositionFromBaseInstruction(e,t,n,o,r,i,s,u,a,c,m,p,d,f,y,b,g,P){let h=F([ne("liquidity"),A("amountMaxA"),A("amountMaxB"),_("optionBaseFlag"),De("baseFlag")]),I=[...P?[{pubkey:P,isSigner:!1,isWritable:!0}]:[]],T=[{pubkey:t,isSigner:!0,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:m,isSigner:!1,isWritable:!0},{pubkey:p,isSigner:!1,isWritable:!0},{pubkey:Ke,isSigner:!1,isWritable:!1},{pubkey:ze,isSigner:!1,isWritable:!1},{pubkey:d,isSigner:!1,isWritable:!1},{pubkey:f,isSigner:!1,isWritable:!1},...I],w=Buffer.alloc(h.span);h.encode({liquidity:new xa(0),amountMaxA:y==="MintA"?b:g,amountMaxB:y==="MintA"?g:b,baseFlag:y==="MintA",optionBaseFlag:1},w);let K=Buffer.from([...Et.increaseLiquidity,...w]);return new mt({keys:T,programId:e,data:K})}static decreaseLiquidityInstruction(e,t,n,o,r,i,s,u,a,c,m,p,d,f,y,b,g,P,h){let I=F([ne("liquidity"),A("amountMinA"),A("amountMinB")]),T=[...h?[{pubkey:h,isSigner:!1,isWritable:!0}]:[],...y.map(S=>[{pubkey:S.poolRewardVault,isSigner:!1,isWritable:!0},{pubkey:S.ownerRewardVault,isSigner:!1,isWritable:!0},{pubkey:S.rewardMint,isSigner:!1,isWritable:!1}]).flat()],w=[{pubkey:t,isSigner:!0,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:m,isSigner:!1,isWritable:!0},{pubkey:p,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:Ke,isSigner:!1,isWritable:!1},{pubkey:ze,isSigner:!1,isWritable:!1},{pubkey:cr,isSigner:!1,isWritable:!1},{pubkey:d,isSigner:!1,isWritable:!1},{pubkey:f,isSigner:!1,isWritable:!1},...T],K=Buffer.alloc(I.span);I.encode({liquidity:b,amountMinA:g,amountMinB:P},K);let x=Buffer.from([...Et.decreaseLiquidity,...K]);return new mt({keys:w,programId:e,data:x})}static decreaseLiquidityInstructions({poolInfo:e,poolKeys:t,ownerPosition:n,ownerInfo:o,liquidity:r,amountMinA:i,amountMinB:s,programId:u,nft2022:a}){let[c,m]=[new z(e.programId),new z(e.id)],p=Z.getTickArrayStartIndexByTick(n.tickLower,e.config.tickSpacing),d=Z.getTickArrayStartIndexByTick(n.tickUpper,e.config.tickSpacing),{publicKey:f}=Pe(c,m,p),{publicKey:y}=Pe(c,m,d),{publicKey:b}=a?j(o.wallet,n.nftMint,ze):j(o.wallet,n.nftMint,u),{publicKey:g}=Tt(c,n.nftMint),{publicKey:P}=nn(c,m,n.tickLower,n.tickUpper),h=[];for(let w=0;w<e.rewardDefaultInfos.length;w++)h.push({poolRewardVault:new z(t.rewardInfos[w].vault),ownerRewardVault:o.rewardAccounts[w],rewardMint:new z(e.rewardDefaultInfos[w].mint.address)});let I=[],T=this.decreaseLiquidityInstruction(c,o.wallet,b,g,m,P,f,y,o.tokenAccountA,o.tokenAccountB,new z(t.vault.A),new z(t.vault.B),new z(e.mintA.address),new z(e.mintB.address),h,r,i,s,ve.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing,[p,d])?He(c,m).publicKey:void 0);return I.push(T),{address:{tickArrayLower:f,tickArrayUpper:y,positionNftAccount:b,personalPosition:g,protocolPosition:P},signers:[],instructions:I,instructionTypes:[G.ClmmDecreasePosition],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[]}}static swapInstruction(e,t,n,o,r,i,s,u,a,c,m,p,d,f,y,b,g){let P=F([A("amount"),A("otherAmountThreshold"),ne("sqrtPriceLimitX64"),De("isBaseInput")]),h=[...g?[{pubkey:g,isSigner:!1,isWritable:!0}]:[],...m.map(K=>({pubkey:K,isSigner:!1,isWritable:!0}))],I=[{pubkey:t,isSigner:!0,isWritable:!1},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:p,isSigner:!1,isWritable:!0},{pubkey:Ke,isSigner:!1,isWritable:!1},{pubkey:ze,isSigner:!1,isWritable:!1},{pubkey:cr,isSigner:!1,isWritable:!1},{pubkey:a,isSigner:!1,isWritable:!1},{pubkey:c,isSigner:!1,isWritable:!1},...h],T=Buffer.alloc(P.span);P.encode({amount:d,otherAmountThreshold:f,sqrtPriceLimitX64:y,isBaseInput:b},T);let w=Buffer.from([...Et.swap,...T]);return new mt({keys:I,programId:e,data:w})}static makeSwapBaseInInstructions({poolInfo:e,poolKeys:t,observationId:n,ownerInfo:o,inputMint:r,amountIn:i,amountOutMin:s,sqrtPriceLimitX64:u,remainingAccounts:a}){let[c,m]=[new z(e.programId),new z(e.id)],[p,d]=[new z(t.vault.A),new z(t.vault.B)],[f,y]=[new z(e.mintA.address),new z(e.mintB.address)],b=e.mintA.address===r.toString(),g=[this.swapInstruction(c,o.wallet,m,new z(e.config.id),b?o.tokenAccountA:o.tokenAccountB,b?o.tokenAccountB:o.tokenAccountA,b?p:d,b?d:p,b?f:y,b?y:f,a,n,i,s,u,!0,He(c,m).publicKey)];return{signers:[],instructions:g,instructionTypes:[G.ClmmSwapBaseIn],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[],address:{}}}static makeSwapBaseOutInstructions({poolInfo:e,poolKeys:t,observationId:n,ownerInfo:o,outputMint:r,amountOut:i,amountInMax:s,sqrtPriceLimitX64:u,remainingAccounts:a}){let[c,m]=[new z(e.programId),new z(e.id)],[p,d]=[new z(t.vault.A),new z(t.vault.B)],[f,y]=[new z(e.mintA.address),new z(e.mintB.address)],b=e.mintA.address===r.toBase58(),g=[this.swapInstruction(c,o.wallet,m,new z(e.config.id),b?o.tokenAccountB:o.tokenAccountA,b?o.tokenAccountA:o.tokenAccountB,b?d:p,b?p:d,b?y:f,b?f:y,a,n,i,s,u,!1,He(c,m).publicKey)];return{signers:[],instructions:g,instructionTypes:[G.ClmmSwapBaseOut],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[],address:{}}}static initRewardInstruction(e,t,n,o,r,i,s,u,a,c,m,p){let d=F([A("openTime"),A("endTime"),ne("emissionsPerSecondX64")]),f=[{pubkey:t,isSigner:!0,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!1},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!1},{pubkey:In.programId,isSigner:!1,isWritable:!1},{pubkey:$e,isSigner:!1,isWritable:!1}],y=Buffer.alloc(d.span);d.encode({openTime:J(c),endTime:J(m),emissionsPerSecondX64:p},y);let b=Buffer.from([...Et.initReward,...y]);return new mt({keys:f,programId:e,data:b})}static initRewardInstructions({poolInfo:e,poolKeys:t,ownerInfo:n,rewardInfo:o}){let[r,i]=[new z(e.programId),new z(e.id)],s=qc(r,i,o.mint).publicKey,u=Bi(r).publicKey,a=[this.initRewardInstruction(r,n.wallet,i,u,new z(e.config.id),n.tokenAccount,o.programId,o.mint,s,o.openTime,o.endTime,o.emissionsPerSecondX64)];return{address:{poolRewardVault:s,operationId:u},signers:[],instructions:a,instructionTypes:[G.ClmmInitReward],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[]}}static setRewardInstruction(e,t,n,o,r,i,s,u,a,c,m,p){let d=F([_("rewardIndex"),ne("emissionsPerSecondX64"),A("openTime"),A("endTime")]),f=[{pubkey:t,isSigner:!0,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:Ke,isSigner:!1,isWritable:!1},{pubkey:ze,isSigner:!1,isWritable:!1},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0}],y=Buffer.alloc(d.span);d.encode({rewardIndex:a,emissionsPerSecondX64:p,openTime:J(c),endTime:J(m)},y);let b=Buffer.from([...Et.setRewardEmissions,...y]);return new mt({keys:f,programId:e,data:b})}static setRewardInstructions({poolInfo:e,poolKeys:t,ownerInfo:n,rewardInfo:o}){let[r,i]=[new z(e.programId),new z(e.id)],s,u,a;for(let p=0;p<e.rewardDefaultInfos.length;p++)e.rewardDefaultInfos[p].mint.address===o.mint.toString()&&(s=p,u=new z(t.rewardInfos[p].vault),a=new z(t.rewardInfos[p].mint.address));(s===void 0||u===void 0)&&Zc.logWithError("reward mint check error","no reward mint",e.rewardDefaultInfos);let c=Bi(r).publicKey,m=[this.setRewardInstruction(r,n.wallet,i,c,new z(e.config.id),n.tokenAccount,u,a,s,o.openTime,o.endTime,o.emissionsPerSecondX64)];return{address:{rewardVault:u,operationId:c},signers:[],instructions:m,instructionTypes:[G.ClmmSetReward],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[]}}static collectRewardInstruction(e,t,n,o,r,i,s){let u=F([_("rewardIndex")]),a=[{pubkey:t,isSigner:!0,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!1},{pubkey:Ke,isSigner:!1,isWritable:!1},{pubkey:ze,isSigner:!1,isWritable:!1},{pubkey:cr,isSigner:!1,isWritable:!1}],c=Buffer.alloc(u.span);u.encode({rewardIndex:s},c);let m=Buffer.from([...Et.collectReward,...c]);return new mt({keys:a,programId:e,data:m})}static collectRewardInstructions({poolInfo:e,poolKeys:t,ownerInfo:n,rewardMint:o}){let[r,i]=[new z(e.programId),new z(e.id)],s,u;for(let c=0;c<e.rewardDefaultInfos.length;c++)e.rewardDefaultInfos[c].mint.address===o.toString()&&(s=c,u=new z(t.rewardInfos[c].vault));(s===void 0||u===void 0)&&Zc.logWithError("reward mint check error","no reward mint",e.rewardDefaultInfos);let a=[this.collectRewardInstruction(r,n.wallet,i,n.tokenAccount,u,o,s)];return{address:{rewardVault:u},signers:[],instructions:a,instructionTypes:[G.ClmmCollectReward],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[]}}static async makeLockPositions({programId:e,authProgramId:t,poolProgramId:n,payer:o,wallet:r,nftMint:i,nft2022:s,getEphemeralSigners:u}){let a=[],c;if(u)c=new z((await u(1))[0]);else{let g=_r.generate();a.push(g),c=g.publicKey}let m=s?j(r,i,ze).publicKey:j(r,i,Ke).publicKey,{publicKey:p}=Tt(n,i),d=Mo(e,c).publicKey,f=j(r,c,Ke).publicKey,y=Tn(c).publicKey,b=Se.lockPositionInstructionV2({programId:e,auth:t,payer:o,positionOwner:r,lockOwner:r,positionNftAccount:m,positionId:p,lockPositionId:d,lockNftMint:c,lockNftAccount:f,metadataAccount:y,withMetadata:!0,nft2022:s,positionNftMint:i,authPositionNftAccount:j(t,i,s?ze:Ke).publicKey,positionNftProgram:s?ze:Ke});return{address:{positionId:p,lockPositionId:d,lockNftAccount:f,lockNftMint:c,positionNftAccount:m,metadataAccount:y},instructions:[b],signers:a,instructionTypes:[G.ClmmLockPosition],lookupTableAddress:[]}}static lockPositionInstructionV2({programId:e,auth:t,payer:n,positionOwner:o,lockOwner:r,positionNftAccount:i,positionId:s,positionNftMint:u,authPositionNftAccount:a,positionNftProgram:c,lockPositionId:m,lockNftMint:p,lockNftAccount:d,metadataAccount:f,withMetadata:y}){let b=[{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!0,isWritable:!0},{pubkey:o,isSigner:!0,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!1},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!1},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:m,isSigner:!1,isWritable:!0},{pubkey:p,isSigner:!0,isWritable:!0},{pubkey:d,isSigner:!1,isWritable:!0},{pubkey:f,isSigner:!1,isWritable:!0},{pubkey:Dt,isSigner:!1,isWritable:!1},{pubkey:Ci,isSigner:!1,isWritable:!1},{pubkey:$e,isSigner:!1,isWritable:!1},{pubkey:Ke,isSigner:!1,isWritable:!1},{pubkey:c,isSigner:!1,isWritable:!1},{pubkey:In.programId,isSigner:!1,isWritable:!1}],g=F([De("withMetadata")]),P=Buffer.alloc(g.span);g.encode({withMetadata:y},P);let h=Buffer.from([...Jc,...P]);return new mt({keys:b,programId:e,data:h})}static lockPositionInstruction({programId:e,authProgramId:t,poolProgramId:n,owner:o,positionNft:r}){let{publicKey:i}=j(o,r,Ke),{publicKey:s}=Tt(n,r),u=[{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!0,isWritable:!1},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!1},{pubkey:ka(e,s).publicKey,isSigner:!1,isWritable:!0},{pubkey:Ke,isSigner:!1,isWritable:!1},{pubkey:In.programId,isSigner:!1,isWritable:!1}];return new mt({keys:u,programId:e,data:Buffer.from(Jc)})}static harvestLockPositionInstruction(e){let[t,n]=[new z(e.poolKeys.programId),new z(e.poolKeys.id)],o=Z.getTickArrayStartIndexByTick(e.ownerPosition.tickLower,e.poolKeys.config.tickSpacing),r=Z.getTickArrayStartIndexByTick(e.ownerPosition.tickUpper,e.poolKeys.config.tickSpacing),{publicKey:i}=Pe(t,n,o),{publicKey:s}=Pe(t,n,r),{publicKey:u}=j(e.owner,e.ownerPosition.nftMint,Ke),{publicKey:a}=Tt(t,e.ownerPosition.nftMint),{publicKey:c}=nn(t,n,e.ownerPosition.tickLower,e.ownerPosition.tickUpper),m=[];for(let f=0;f<e.poolKeys.rewardInfos.length;f++)m.push({poolRewardVault:new z(e.poolKeys.rewardInfos[f].vault),ownerRewardVault:e.ownerRewardAccounts[f],rewardMint:new z(e.poolKeys.rewardInfos[f].mint.address)});let p=[...m.map(f=>[{pubkey:f.poolRewardVault,isSigner:!1,isWritable:!0},{pubkey:f.ownerRewardVault,isSigner:!1,isWritable:!0},{pubkey:f.rewardMint,isSigner:!1,isWritable:!1}]).flat()],d=[{pubkey:e.authProgramId,isSigner:!1,isWritable:!1},{pubkey:ka(e.programId,a).publicKey,isSigner:!1,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:e.owner,isSigner:!0,isWritable:!1},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:new z(e.poolKeys.vault.A),isSigner:!1,isWritable:!0},{pubkey:new z(e.poolKeys.vault.B),isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:e.userVaultA,isSigner:!1,isWritable:!0},{pubkey:e.userVaultB,isSigner:!1,isWritable:!0},{pubkey:Ke,isSigner:!1,isWritable:!1},{pubkey:ze,isSigner:!1,isWritable:!1},{pubkey:an,isSigner:!1,isWritable:!1},{pubkey:new z(e.poolKeys.mintA.address),isSigner:!1,isWritable:!1},{pubkey:new z(e.poolKeys.mintB.address),isSigner:!1,isWritable:!1},...p];return new mt({keys:d,programId:e.programId,data:Buffer.from(el)})}static harvestLockPositionInstructionV2({programId:e,auth:t,lockPositionId:n,clmmProgram:o,lockOwner:r,lockNftMint:i,lockNftAccount:s,positionNftAccount:u,positionId:a,poolId:c,protocolPosition:m,vaultA:p,vaultB:d,tickArrayLower:f,tickArrayUpper:y,userVaultA:b,userVaultB:g,mintA:P,mintB:h,rewardAccounts:I,exTickArrayBitmap:T}){let w=[...T?[{pubkey:T,isSigner:!1,isWritable:!0}]:[],...I.map(x=>[{pubkey:x.poolRewardVault,isSigner:!1,isWritable:!0},{pubkey:x.ownerRewardVault,isSigner:!1,isWritable:!0},{pubkey:x.rewardMint,isSigner:!1,isWritable:!1}]).flat()],K=[{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!0,isWritable:!1},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:m,isSigner:!1,isWritable:!0},{pubkey:p,isSigner:!1,isWritable:!0},{pubkey:d,isSigner:!1,isWritable:!0},{pubkey:f,isSigner:!1,isWritable:!0},{pubkey:y,isSigner:!1,isWritable:!0},{pubkey:b,isSigner:!1,isWritable:!0},{pubkey:g,isSigner:!1,isWritable:!0},{pubkey:Ke,isSigner:!1,isWritable:!1},{pubkey:ze,isSigner:!1,isWritable:!1},{pubkey:an,isSigner:!1,isWritable:!1},{pubkey:P,isSigner:!1,isWritable:!1},{pubkey:h,isSigner:!1,isWritable:!1},...w];return new mt({keys:K,programId:e,data:Buffer.from(el)})}};var tl=F([ct("mintAuthorityOption"),O("mintAuthority"),A("supply"),_("decimals"),_("isInitialized"),ct("freezeAuthorityOption"),O("freezeAuthority")]);import{PublicKey as fp}from"@solana/web3.js";import{MintLayout as nl,TOKEN_PROGRAM_ID as yp}from"@solana/spl-token";var Ch=async({connection:l,mint:e})=>{let t=await l.getAccountInfo(new fp(e));return!t||t.data.length!==nl.span?void 0:nl.decode(t.data)},Rh=({mint:l,decimals:e,programId:t=yp,logoURI:n="",priority:o=3})=>{let r=l.toBase58().substring(0,6);return{address:l.toBase58(),decimals:e,symbol:r,logoURI:n,extensions:{},chainId:101,programId:t.toString(),name:r,tags:[],priority:o}},Er=l=>new Ge({mint:l.address,decimals:l.decimals,symbol:l.symbol,name:l.name}),Ri=o=>{var r=o,{amount:l,isRaw:e,name:t}=r,n=Fe(r,["amount","isRaw","name"]);return new xe(new Ge({mint:dt(n.address).toBase58(),decimals:n.decimals,symbol:n.symbol,name:t}),l,e,t)};function Lh(l){return l.address===sn.address?it:l}function Oh(l){return l.address===it.address?sn:l}var yt=o=>{var r=o,{address:l,programId:e,decimals:t}=r,n=Fe(r,["address","programId","decimals"]);return M({chainId:101,address:dt(l).toBase58(),programId:e,logoURI:"",symbol:"",name:"",decimals:t,tags:[],extensions:n.extensions||{}},n)},Un=l=>l?q(M({},l),{transferFeeConfigAuthority:l.transferFeeConfigAuthority.toBase58(),withdrawWithheldAuthority:l.withdrawWithheldAuthority.toBase58(),withheldAmount:l.withheldAmount.toString(),olderTransferFee:q(M({},l.olderTransferFee),{epoch:l.olderTransferFee.epoch.toString(),maximumFee:l.olderTransferFee.maximumFee.toString()}),newerTransferFee:q(M({},l.newerTransferFee),{epoch:l.newerTransferFee.epoch.toString(),maximumFee:l.newerTransferFee.maximumFee.toString()})}):void 0;import ol from"bn.js";var Ka=new ol(25),Wr=new ol(1e4),bp={4:3,5:3};import{PublicKey as Re,SystemProgram as sl,SYSVAR_RENT_PUBKEY as Pp,TransactionInstruction as Bn}from"@solana/web3.js";import{ASSOCIATED_TOKEN_PROGRAM_ID as Ap,TOKEN_PROGRAM_ID as Vo}from"@solana/spl-token";var Sa=F([_("instruction"),A("amountIn"),A("minAmountOut")]),Ca=F([_("instruction"),A("maxAmountIn"),A("amountOut")]),Uh=F([_("instruction"),_("nonce")]),Ra=F([_("instruction"),_("nonce"),A("startTime")]),co=F([A("status"),A("nonce"),A("maxOrder"),A("depth"),A("baseDecimal"),A("quoteDecimal"),A("state"),A("resetFlag"),A("minSize"),A("volMaxCutRatio"),A("amountWaveRatio"),A("baseLotSize"),A("quoteLotSize"),A("minPriceMultiplier"),A("maxPriceMultiplier"),A("systemDecimalValue"),A("minSeparateNumerator"),A("minSeparateDenominator"),A("tradeFeeNumerator"),A("tradeFeeDenominator"),A("pnlNumerator"),A("pnlDenominator"),A("swapFeeNumerator"),A("swapFeeDenominator"),A("baseNeedTakePnl"),A("quoteNeedTakePnl"),A("quoteTotalPnl"),A("baseTotalPnl"),A("poolOpenTime"),A("punishPcAmount"),A("punishCoinAmount"),A("orderbookToInitTime"),ne("swapBaseInAmount"),ne("swapQuoteOutAmount"),A("swapBase2QuoteFee"),ne("swapQuoteInAmount"),ne("swapBaseOutAmount"),A("swapQuote2BaseFee"),O("baseVault"),O("quoteVault"),O("baseMint"),O("quoteMint"),O("lpMint"),O("openOrders"),O("marketId"),O("marketProgramId"),O("targetOrders"),O("withdrawQueue"),O("lpVault"),O("owner"),A("lpReserve"),Y(A(),3,"padding")]),gp=F([A("accountType"),A("status"),A("nonce"),A("maxOrder"),A("depth"),A("baseDecimal"),A("quoteDecimal"),A("state"),A("resetFlag"),A("minSize"),A("volMaxCutRatio"),A("amountWaveRatio"),A("baseLotSize"),A("quoteLotSize"),A("minPriceMultiplier"),A("maxPriceMultiplier"),A("systemDecimalsValue"),A("abortTradeFactor"),A("priceTickMultiplier"),A("priceTick"),A("minSeparateNumerator"),A("minSeparateDenominator"),A("tradeFeeNumerator"),A("tradeFeeDenominator"),A("pnlNumerator"),A("pnlDenominator"),A("swapFeeNumerator"),A("swapFeeDenominator"),A("baseNeedTakePnl"),A("quoteNeedTakePnl"),A("quoteTotalPnl"),A("baseTotalPnl"),A("poolOpenTime"),A("punishPcAmount"),A("punishCoinAmount"),A("orderbookToInitTime"),ne("swapBaseInAmount"),ne("swapQuoteOutAmount"),ne("swapQuoteInAmount"),ne("swapBaseOutAmount"),A("swapQuote2BaseFee"),A("swapBase2QuoteFee"),O("baseVault"),O("quoteVault"),O("baseMint"),O("quoteMint"),O("lpMint"),O("modelDataAccount"),O("openOrders"),O("marketId"),O("marketProgramId"),O("targetOrders"),O("owner"),Y(A(),64,"padding")]),La=F([_("instruction"),A("baseAmountIn"),A("quoteAmountIn"),A("fixedSide"),A("otherAmountMin")]),Oa=F([_("instruction"),A("lpAmount"),A("baseAmountMin"),A("quoteAmountMin")]),Gh={4:co,5:gp},il=F([A("fee")]);var rl=ye("Raydium_liquidity_instruction");function al(l){let{poolInfo:e,poolKeys:t,userKeys:n,baseAmountIn:o,quoteAmountIn:r,fixedSide:i,otherAmountMin:s,modelDataPubKey:u=Mn}=l,a=Buffer.alloc(La.span);La.encode({instruction:3,baseAmountIn:J(o),quoteAmountIn:J(r),otherAmountMin:J(s),fixedSide:i==="base"?xt:Fu},a);let c=[k({pubkey:Vo,isWritable:!1}),k({pubkey:new Re(e.id)}),k({pubkey:new Re(t.authority),isWritable:!1}),k({pubkey:new Re(t.openOrders),isWritable:!1}),k({pubkey:new Re(t.targetOrders)}),k({pubkey:new Re(e.lpMint.address)}),k({pubkey:new Re(t.vault.A)}),k({pubkey:new Re(t.vault.B)})];return e.pooltype.includes("StablePool")&&c.push(k({pubkey:u})),c.push(k({pubkey:new Re(e.marketId),isWritable:!1}),k({pubkey:n.baseTokenAccount}),k({pubkey:n.quoteTokenAccount}),k({pubkey:n.lpTokenAccount}),k({pubkey:n.owner,isWritable:!1,isSigner:!0}),k({pubkey:new Re(t.marketEventQueue),isWritable:!1})),new Bn({programId:new Re(e.programId),keys:c,data:a})}function Na(l){let{poolInfo:e,poolKeys:t,userKeys:n,lpAmount:o,baseAmountMin:r,quoteAmountMin:i,modelDataPubKey:s=Mn}=l,u=_e(t),a=4;if(e.pooltype.includes("StablePool")&&(a=5),a===4||a===5){let c=Buffer.alloc(Oa.span);Oa.encode({instruction:4,lpAmount:J(o),baseAmountMin:J(r),quoteAmountMin:J(i)},c);let m=[k({pubkey:Vo,isWritable:!1}),k({pubkey:u.id}),k({pubkey:u.authority,isWritable:!1}),k({pubkey:u.openOrders}),k({pubkey:u.targetOrders}),k({pubkey:u.mintLp.address}),k({pubkey:u.vault.A}),k({pubkey:u.vault.B})];return a===5?m.push(k({pubkey:s})):(m.push(k({pubkey:u.id})),m.push(k({pubkey:u.id}))),m.push(k({pubkey:u.marketProgramId,isWritable:!1}),k({pubkey:u.marketId}),k({pubkey:u.marketBaseVault}),k({pubkey:u.marketQuoteVault}),k({pubkey:u.marketAuthority,isWritable:!1}),k({pubkey:n.lpTokenAccount}),k({pubkey:n.baseTokenAccount}),k({pubkey:n.quoteTokenAccount}),k({pubkey:n.owner,isWritable:!1,isSigner:!0}),k({pubkey:u.marketEventQueue}),k({pubkey:u.marketBids}),k({pubkey:u.marketAsks})),new Bn({programId:u.programId,keys:m,data:c})}return new Bn({programId:u.programId,keys:[]})}function Ma({programId:l,ammId:e,ammAuthority:t,ammOpenOrders:n,lpMint:o,coinMint:r,pcMint:i,coinVault:s,pcVault:u,withdrawQueue:a,ammTargetOrders:c,poolTempLp:m,marketProgramId:p,marketId:d,userWallet:f,userCoinVault:y,userPcVault:b,userLpVault:g,nonce:P,openTime:h,coinAmount:I,pcAmount:T,ammConfigId:w,feeDestinationId:K}){let x=F([_("instruction"),_("nonce"),A("openTime"),A("pcAmount"),A("coinAmount")]),S=[{pubkey:Vo,isSigner:!1,isWritable:!1},{pubkey:Ap,isSigner:!1,isWritable:!1},{pubkey:sl.programId,isSigner:!1,isWritable:!1},{pubkey:$e,isSigner:!1,isWritable:!1},{pubkey:e,isSigner:!1,isWritable:!0},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!1},{pubkey:i,isSigner:!1,isWritable:!1},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:w,isSigner:!1,isWritable:!1},{pubkey:K,isSigner:!1,isWritable:!0},{pubkey:p,isSigner:!1,isWritable:!1},{pubkey:d,isSigner:!1,isWritable:!1},{pubkey:f,isSigner:!0,isWritable:!0},{pubkey:y,isSigner:!1,isWritable:!0},{pubkey:b,isSigner:!1,isWritable:!0},{pubkey:g,isSigner:!1,isWritable:!0}],B=Buffer.alloc(x.span);return x.encode({instruction:1,nonce:P,openTime:h,coinAmount:I,pcAmount:T},B),{instruction:new Bn({keys:S,programId:l,data:B}),instructionType:G.AmmV4CreatePool}}function tI(l){let e=F([_("instruction"),_("simulateType")]),t=Buffer.alloc(e.span);e.encode({instruction:12,simulateType:0},t);let n=[k({pubkey:new Re(l.id),isWritable:!1}),k({pubkey:new Re(l.authority),isWritable:!1}),k({pubkey:new Re(l.openOrders),isWritable:!1}),k({pubkey:new Re(l.vault.A),isWritable:!1}),k({pubkey:new Re(l.vault.B),isWritable:!1}),k({pubkey:new Re(l.mintLp.address),isWritable:!1}),k({pubkey:new Re(l.marketId),isWritable:!1}),k({pubkey:new Re(l.marketEventQueue),isWritable:!1})];return new Bn({programId:new Re(l.programId),keys:n,data:t})}function kp({poolKeys:l,userKeys:e,amountIn:t,minAmountOut:n,modelDataPubKey:o=Mn},r){let i=_e(l),s=Buffer.alloc(Sa.span);Sa.encode({instruction:9,amountIn:J(t),minAmountOut:J(n)},s);let u=[k({pubkey:Vo,isWritable:!1}),k({pubkey:i.id}),k({pubkey:i.authority,isWritable:!1}),k({pubkey:i.openOrders})];return r===4&&u.push(k({pubkey:i.targetOrders})),u.push(k({pubkey:i.vault.A}),k({pubkey:i.vault.B})),r===5&&u.push(k({pubkey:o})),u.push(k({pubkey:i.marketProgramId,isWritable:!1}),k({pubkey:i.marketId}),k({pubkey:i.marketBids}),k({pubkey:i.marketAsks}),k({pubkey:i.marketEventQueue}),k({pubkey:i.marketBaseVault}),k({pubkey:i.marketQuoteVault}),k({pubkey:i.marketAuthority,isWritable:!1}),k({pubkey:e.tokenAccountIn}),k({pubkey:e.tokenAccountOut}),k({pubkey:e.owner,isWritable:!1,isSigner:!0})),new Bn({programId:i.programId,keys:u,data:s})}function wp({poolKeys:l,userKeys:e,maxAmountIn:t,amountOut:n,modelDataPubKey:o=Mn},r){let i=_e(l),s=Buffer.alloc(Ca.span);Ca.encode({instruction:11,maxAmountIn:J(t),amountOut:J(n)},s);let u=[k({pubkey:Vo,isWritable:!1}),k({pubkey:i.id}),k({pubkey:i.authority,isWritable:!1}),k({pubkey:i.openOrders}),k({pubkey:i.targetOrders}),k({pubkey:i.vault.A}),k({pubkey:i.vault.B})];return r===5&&u.push(k({pubkey:o})),u.push(k({pubkey:i.marketProgramId,isWritable:!1}),k({pubkey:i.marketId}),k({pubkey:i.marketBids}),k({pubkey:i.marketAsks}),k({pubkey:i.marketEventQueue}),k({pubkey:i.marketBaseVault}),k({pubkey:i.marketQuoteVault}),k({pubkey:i.marketAuthority,isWritable:!1}),k({pubkey:e.tokenAccountIn}),k({pubkey:e.tokenAccountOut}),k({pubkey:e.owner,isWritable:!1,isSigner:!0})),new Bn({programId:i.programId,keys:u,data:s})}function Dr(l){let{poolKeys:e,version:t,userKeys:n,amountIn:o,amountOut:r,fixedSide:i}=l;if(t===4||t===5){let s={poolKeys:e,userKeys:n};if(i==="in")return kp(q(M({},s),{amountIn:o,minAmountOut:r}),t);if(i==="out")return wp(q(M({},s),{maxAmountIn:o,amountOut:r}),t);rl.logWithError("invalid params","params",l)}throw rl.logWithError("invalid version","poolKeys.version",t),new Error("invalid version")}function nI({poolKeys:l,userKeys:e,startTime:t}){let n=Buffer.alloc(Ra.span);Ra.encode({instruction:0,nonce:5,startTime:J(t)},n);let o=_e(l),r=[k({pubkey:Vo,isWritable:!1}),k({pubkey:sl.programId,isWritable:!1}),k({pubkey:Pp,isWritable:!1}),k({pubkey:o.id}),k({pubkey:o.authority,isWritable:!1}),k({pubkey:o.openOrders}),k({pubkey:o.mintLp.address}),k({pubkey:o.mintA.address,isWritable:!1}),k({pubkey:o.mintB.address,isWritable:!1}),k({pubkey:o.vault.A,isWritable:!1}),k({pubkey:o.vault.B,isWritable:!1}),k({pubkey:o.id}),k({pubkey:o.targetOrders}),k({pubkey:e.lpTokenAccount}),k({pubkey:o.id,isWritable:!1}),k({pubkey:o.marketProgramId,isWritable:!1}),k({pubkey:o.marketId,isWritable:!1}),k({pubkey:e.payer,isSigner:!0})];return new Bn({programId:o.programId,keys:r,data:n})}function ul({poolKeys:l}){let e=F([_("instruction"),_("simulateType")]),t=Buffer.alloc(e.span);e.encode({instruction:12,simulateType:0},t);let n=[k({pubkey:new Re(l.id),isWritable:!1}),k({pubkey:new Re(l.authority),isWritable:!1}),k({pubkey:new Re(l.openOrders),isWritable:!1}),k({pubkey:new Re(l.vault.A),isWritable:!1}),k({pubkey:new Re(l.vault.B),isWritable:!1}),k({pubkey:new Re(l.mintLp.address),isWritable:!1}),k({pubkey:new Re(l.marketId),isWritable:!1}),k({pubkey:new Re(l.marketEventQueue),isWritable:!1})];return{instruction:new Bn({programId:new Re(l.programId),keys:n,data:t})}}var mo=5e4,Tp=F([A("x"),A("y"),A("price")]),hp=F([A("accountType"),A("status"),A("multiplier"),A("validDataCount"),Y(Tp,mo,"DataElement")]);function Ip(l,e){return[0,mo-2]}function Bp(l){return[0,mo-2]}function xp(l){return[0,mo-2]}function Kp(l,e,t){let[n,o]=Ip(e,t),r=n,i=o,s=0,u=e*l.multiplier/t;for(;r<=i;){if(s=Math.floor((i+r)/2),s===0||s>=mo-2)return[s,s,!1];let a=l.DataElement[s].x*l.multiplier/l.DataElement[s].y,c=l.DataElement[s-1].x*l.multiplier/l.DataElement[s-1].y,m=l.DataElement[s+1].x*l.multiplier/l.DataElement[s+1].y;if(u===a)return[s,s,!0];if(u===c)return[s-1,s-1,!0];if(u===m)return[s+1,s+1,!0];if(u<c)i=s-1;else{if(u>c&&u<a)return[s-1,s,!0];if(u>a&&u<m)return[s,s+1,!0];r=s+1}}return[s,s,!1]}function va(l,e,t){let[n,o,r]=Kp(l,e,t);if(!r)return 0;if(n===o){let i=l.DataElement[n].x;return e*l.multiplier/i}else{let i=l.DataElement[n].x,s=l.DataElement[n].y,u=l.DataElement[o].x,a=l.DataElement[o].y,c=t*(u*s-i*a),m=i*c,p=(u-i)*(e*s-i*t)*a,d=m+p;return e*l.multiplier*c/d}}function lo(l,e,t){return e*l.multiplier/t}function cl(l,e,t){return e*t/l.multiplier}function Sp(l,e){let[t,n]=Bp(e),o=t,r=n,i=0,s=e;for(;o<r;){if(i=Math.floor((r+o)/2),i<=0||i>mo-2)return[i,i,!1];let u=l.DataElement[i].x,a=l.DataElement[i-1].x,c=l.DataElement[i+1].x;if(s===u)return[i,i,!0];if(s===a)return[i-1,i-1,!0];if(s===c)return[i+1,i+1,!0];if(s<a)r=i-1;else{if(s>a&&s<u)return[i-1,i,!0];if(s>u&&s<c)return[i,i+1,!0];o=i+1}}return[i,i,!1]}function Cp(l,e){let[t,n]=xp(e),o=t,r=n,i=0,s=e;for(;o<=r;){if(i=Math.floor((r+o)/2),i<=0||i>=mo-2)return[i,i,!1];let u=l.DataElement[i].y,a=l.DataElement[i-1].y,c=l.DataElement[i+1].y;if(s===u)return[i,i,!0];if(s===a)return[i-1,i-1,!0];if(s===c)return[i+1,i+1,!0];if(s<c)o=i+1;else{if(s<a&&s>u)return[i-1,i,!0];if(s<u&&s>c)return[i,i+1,!0];r=i-1}}return[i,i,!1]}function ll(l,e,t,n){let o=n?e+t:e-t,[r,i,s]=Sp(l,o);if(!s)return[0,0,!1,s];if(r===i)return[l.DataElement[i].price,l.DataElement[i].y,!1,s];{let u=l.DataElement[r].x,a=l.DataElement[i].x,c=l.DataElement[r].price,m=l.DataElement[i].price,p=l.DataElement[r].y,d=l.DataElement[i].y;if(e>=u&&e<=a)return n?[m,d,!0,s]:[c,p,!0,s];{let f,y;return n?(f=c+(m-c)*(e-u)/(a-u),y=p-(o-u)*l.multiplier/m):(f=c+(m-c)*(e-u)/(a-u),y=d+(a-o)*l.multiplier/c),[f,y,!1,s]}}}function Rp(l,e,t,n){let o=n?e-t:e+t,[r,i,s]=Cp(l,o);if(!s)return[0,0,!1,s];if(r===i)return[l.DataElement[i].price,l.DataElement[i].x,!1,s];{let u=l.DataElement[r].x,a=l.DataElement[i].x,c=l.DataElement[r].price,m=l.DataElement[i].price,p=l.DataElement[r].y,d=l.DataElement[i].y;if(e>=d&&e<=p)return n?[m,a,!0,s]:[c,u,!0,s];{let f,y;return n?(f=c+(m-c)*(p-e)/(p-d),y=u+m*(p-o)/l.multiplier):(f=c+(m-c)*(p-e)/(p-d),y=a-c*(o-d)/l.multiplier),[f,y,!1,s]}}}function Lp(l,e){let t=ll(l,e,0,!1);return t[3]?t[0]:0}function ml(l,e,t,n){let o=va(l,e,t),r=lo(l,e,o),i=lo(l,t,o),s=lo(l,n,o),u=!0,[a,c,m,p]=ll(l,r,s,u);if(!p)return 0;if(m)return n*l.multiplier/a;{let d=i-c;return cl(l,d,o)}}function dl(l,e,t,n){let o=va(l,e,t),r=lo(l,e,o),i=lo(l,t,o),s=lo(l,n,o),u=!1,[a,c,m,p]=Rp(l,i,s,u);if(!p)return 0;if(m)return n*a/l.multiplier;{let d=r-c;return cl(l,d,o)}}function Op(l){let e=hp.decode(l);return{accountType:e.accountType.toNumber(),status:e.status.toNumber(),multiplier:e.multiplier.toNumber(),validDataCount:e.validDataCount.toNumber(),DataElement:e.DataElement.map(t=>({x:t.x.toNumber(),y:t.y.toNumber(),price:t.price.toNumber()}))}}function pl(l,e,t,n){let o=Lp(l,lo(l,e,va(l,e,t)))/l.multiplier;return n?o:1/o}var _o=class{constructor({connection:e,modelDataPubKey:t=Mn}){this._layoutData={accountType:0,status:0,multiplier:0,validDataCount:0,DataElement:[]};this.connection=e,this.modelDataPubKey=t}get stableModelData(){return this._layoutData}async initStableModelLayout(){if(this._layoutData.validDataCount===0&&this.connection){let e=await this.connection.getAccountInfo(this.modelDataPubKey);e&&(this._layoutData=Op(e==null?void 0:e.data))}}};import{PublicKey as Oi}from"@solana/web3.js";import Li from"bn.js";import qr from"decimal.js";import{TOKEN_PROGRAM_ID as vp}from"@solana/spl-token";import{PublicKey as Np}from"@solana/web3.js";var Mp=ye("Raydium_liquidity_serum");function fl({programId:l,marketId:e}){let t=[e.toBuffer()],n=0,o;for(;n<100;){try{let r=t.concat(Buffer.from([n]),Buffer.alloc(7));o=Np.createProgramAddressSync(r,l)}catch(r){if(r instanceof TypeError)throw r;n++;continue}return{publicKey:o,nonce:n}}throw Mp.logWithError("unable to find a viable program address nonce","params",{programId:l,marketId:e}),new Error("unable to find a viable program address nonce")}function Ur({programId:l}){let{publicKey:e}=te([Buffer.from("amm_config_account_seed","utf-8")],l);return e}function po({name:l,programId:e,marketId:t}){let{publicKey:n}=te([e.toBuffer(),t.toBuffer(),Buffer.from(l,"utf-8")],e);return n}function Fp({programId:l,marketId:e}){let{publicKey:t}=te([l.toBuffer(),e.toBuffer(),Buffer.from("open_order_associated_seed","utf-8")],l);return t}function _a({programId:l}){return te([Buffer.from([97,109,109,32,97,117,116,104,111,114,105,116,121])],l)}function Ea({version:l,marketVersion:e,marketId:t,baseMint:n,quoteMint:o,baseDecimals:r,quoteDecimals:i,programId:s,marketProgramId:u}){let a=po({name:"amm_associated_seed",programId:s,marketId:t}),c=po({name:"lp_mint_associated_seed",programId:s,marketId:t}),{publicKey:m,nonce:p}=_a({programId:s}),d=po({name:"coin_vault_associated_seed",programId:s,marketId:t}),f=po({name:"pc_vault_associated_seed",programId:s,marketId:t}),y=po({name:"temp_lp_token_associated_seed",programId:s,marketId:t}),b=Fp({programId:s,marketId:t}),g=po({name:"target_associated_seed",programId:s,marketId:t}),P=po({name:"withdraw_associated_seed",programId:s,marketId:t}),{publicKey:h}=fl({programId:u,marketId:t});return{id:a,baseMint:n,quoteMint:o,lpMint:c,baseDecimals:r,quoteDecimals:i,lpDecimals:r,version:l,programId:s,authority:m,nonce:p,baseVault:d,quoteVault:f,lpVault:y,openOrders:b,targetOrders:g,withdrawQueue:P,marketVersion:e,marketProgramId:u,marketId:t,marketAuthority:h,lookupTableAccount:Oi.default,configId:Ur({programId:s})}}var Fa;async function CI({connection:l,poolKeysList:e,config:t,modelDataPubKey:n}){return e.find(r=>r.modelDataAccount)&&(Fa||(Fa=new _o({connection:l,modelDataPubKey:n}),await Fa.initStableModelLayout())),await Promise.all(e.map(async r=>{if(r.modelDataAccount){let i=ul({poolKeys:r});return(await Xu(l,[i.instruction],"GetPoolData")).map(a=>{let c=zu(a,"GetPoolData"),m=new Li(yn(c,"status")),p=Number(yn(c,"coin_decimals")),d=Number(yn(c,"pc_decimals")),f=Number(yn(c,"lp_decimals")),y=new Li(yn(c,"pool_coin_amount")),b=new Li(yn(c,"pool_pc_amount")),g=new Li(yn(c,"pool_lp_supply")),P="0";try{P=yn(c,"pool_open_time")}catch{}return{status:m,baseDecimals:p,quoteDecimals:d,lpDecimals:f,baseReserve:y,quoteReserve:b,lpSupply:g,startTime:new Li(P)}})[0]}else{let[i,s,u,a]=await l.getMultipleAccountsInfo([new Oi(r.id),new Oi(r.vault.A),new Oi(r.vault.B),new Oi(r.mintLp.address)]);if(i===null)throw Error("fetch pool error");if(s===null)throw Error("fetch vaultAccA error");if(u===null)throw Error("fetch vaultAccB error");if(a===null)throw Error("fetch mintAccLp error");let c=co.decode(i.data),m=tn.decode(s.data),p=tn.decode(u.data),d=tl.decode(a.data);return{status:c.status,baseDecimals:c.baseDecimal.toNumber(),quoteDecimals:c.quoteDecimal.toNumber(),lpDecimals:d.decimals,baseReserve:m.amount.sub(c.baseNeedTakePnl),quoteReserve:p.amount.sub(c.quoteNeedTakePnl),lpSupply:c.lpReserve,startTime:c.poolOpenTime}}}))}var Va={volume:0,volumeQuote:0,volumeFee:0,apr:0,feeApr:0,priceMin:0,priceMax:0,rewardApr:[]},Gr=l=>{let e={},t=vp.toBase58();return Object.keys(l).map(n=>{let o=l[n],[r,i]=[o.baseMint.toBase58(),o.quoteMint.toBase58()];e[n]={id:n,version:4,status:o.status.toNumber(),programId:o.programId.toBase58(),mintA:yt({address:r,programId:t,decimals:o.baseDecimal.toNumber()}),mintB:yt({address:i,programId:t,decimals:o.quoteDecimal.toNumber()}),rewardDefaultInfos:[],rewardDefaultPoolInfos:"Ecosystem",price:o.poolPrice.toNumber(),mintAmountA:new qr(o.mintAAmount.toString()).div(10**o.baseDecimal.toNumber()).toNumber(),mintAmountB:new qr(o.mintBAmount.toString()).div(10**o.quoteDecimal.toNumber()).toNumber(),baseReserve:o.baseReserve,quoteReserve:o.quoteReserve,feeRate:new qr(o.tradeFeeNumerator.toString()).div(o.tradeFeeDenominator.toString()).toNumber(),openTime:o.poolOpenTime.toString(),tvl:0,day:Va,week:Va,month:Va,pooltype:[],farmUpcomingCount:0,farmOngoingCount:0,farmFinishedCount:0,type:"Standard",marketId:o.marketId.toBase58(),configId:Ur({programId:o.programId}).toBase58(),lpPrice:0,lpAmount:new qr(o.lpReserve.toString()).div(10**Math.min(o.baseDecimal.toNumber(),o.quoteDecimal.toNumber())).toNumber(),lpMint:yt({address:o.lpMint.toBase58(),programId:t,decimals:Math.min(o.baseDecimal.toNumber(),o.quoteDecimal.toNumber())}),burnPercent:0}}),e};import Ye from"bn.js";import Le from"decimal.js";import{PublicKey as Ni}from"@solana/web3.js";import Mi from"bn.js";import{TOKEN_PROGRAM_ID as Pl}from"@solana/spl-token";import{SystemProgram as fo,SYSVAR_RENT_PUBKEY as _p,Transaction as yl,TransactionInstruction as Ep}from"@solana/web3.js";import{createInitializeAccountInstruction as bl,TOKEN_PROGRAM_ID as gl}from"@solana/spl-token";function Vp(l="accountFlags"){let e=new Cr(l);return e.addBoolean("initialized"),e.addBoolean("market"),e.addBoolean("openOrders"),e.addBoolean("requestQueue"),e.addBoolean("eventQueue"),e.addBoolean("bids"),e.addBoolean("asks"),e}var Wa=F([Te(5),Vp("accountFlags"),O("ownAddress"),A("vaultSignerNonce"),O("baseMint"),O("quoteMint"),O("baseVault"),A("baseDepositsTotal"),A("baseFeesAccrued"),O("quoteVault"),A("quoteDepositsTotal"),A("quoteFeesAccrued"),A("quoteDustThreshold"),O("requestQueue"),O("eventQueue"),O("bids"),O("asks"),A("baseLotSize"),A("quoteLotSize"),A("feeRateBps"),A("referrerRebatesAccrued"),Te(7)]);function Wp({programId:l,marketInfo:e}){let t=F([_("version"),ct("instruction"),A("baseLotSize"),A("quoteLotSize"),Ft("feeRateBps"),A("vaultSignerNonce"),A("quoteDustThreshold")]),n=[{pubkey:e.id,isSigner:!1,isWritable:!0},{pubkey:e.requestQueue,isSigner:!1,isWritable:!0},{pubkey:e.eventQueue,isSigner:!1,isWritable:!0},{pubkey:e.bids,isSigner:!1,isWritable:!0},{pubkey:e.asks,isSigner:!1,isWritable:!0},{pubkey:e.baseVault,isSigner:!1,isWritable:!0},{pubkey:e.quoteVault,isSigner:!1,isWritable:!0},{pubkey:e.baseMint,isSigner:!1,isWritable:!1},{pubkey:e.quoteMint,isSigner:!1,isWritable:!1},{pubkey:e.authority?e.quoteMint:_p,isSigner:!1,isWritable:!1}].concat(e.authority?{pubkey:e.authority,isSigner:!1,isWritable:!1}:[]).concat(e.authority&&e.pruneAuthority?{pubkey:e.pruneAuthority,isSigner:!1,isWritable:!1}:[]),o=Buffer.alloc(t.span);return t.encode({version:0,instruction:0,baseLotSize:e.baseLotSize,quoteLotSize:e.quoteLotSize,feeRateBps:e.feeRateBps,vaultSignerNonce:e.vaultSignerNonce,quoteDustThreshold:e.quoteDustThreshold},o),new Ep({keys:n,programId:l,data:o})}async function Xr({connection:l,wallet:e,marketInfo:t}){var i,s,u,a,c,m,p,d;let n=new yl,o=await l.getMinimumBalanceForRentExemption(165);n.add(fo.createAccountWithSeed({fromPubkey:e,basePubkey:e,seed:t.baseVault.seed,newAccountPubkey:t.baseVault.publicKey,lamports:o,space:165,programId:gl}),fo.createAccountWithSeed({fromPubkey:e,basePubkey:e,seed:t.quoteVault.seed,newAccountPubkey:t.quoteVault.publicKey,lamports:o,space:165,programId:gl}),bl(t.baseVault.publicKey,t.baseMint,t.vaultOwner),bl(t.quoteVault.publicKey,t.quoteMint,t.vaultOwner),fo.createAccountWithSeed({fromPubkey:e,basePubkey:e,seed:t.id.seed,newAccountPubkey:t.id.publicKey,lamports:await l.getMinimumBalanceForRentExemption(Wa.span),space:Wa.span,programId:t.programId}));let r=new yl;return r.add(fo.createAccountWithSeed({fromPubkey:e,basePubkey:e,seed:t.requestQueue.seed,newAccountPubkey:t.requestQueue.publicKey,lamports:t.lowestFeeMarket?6208320:await l.getMinimumBalanceForRentExemption((i=t.requestQueueSpace)!=null?i:5120+12),space:t.lowestFeeMarket?764:(s=t.requestQueueSpace)!=null?s:5120+12,programId:t.programId}),fo.createAccountWithSeed({fromPubkey:e,basePubkey:e,seed:t.eventQueue.seed,newAccountPubkey:t.eventQueue.publicKey,lamports:t.lowestFeeMarket?79594560:await l.getMinimumBalanceForRentExemption((u=t.eventQueueSpace)!=null?u:262144+12),space:t.lowestFeeMarket?11308:(a=t.eventQueueSpace)!=null?a:262144+12,programId:t.programId}),fo.createAccountWithSeed({fromPubkey:e,basePubkey:e,seed:t.bids.seed,newAccountPubkey:t.bids.publicKey,lamports:t.lowestFeeMarket?101977920:await l.getMinimumBalanceForRentExemption((c=t.orderbookQueueSpace)!=null?c:65536+12),space:t.lowestFeeMarket?14524:(m=t.orderbookQueueSpace)!=null?m:65536+12,programId:t.programId}),fo.createAccountWithSeed({fromPubkey:e,basePubkey:e,seed:t.asks.seed,newAccountPubkey:t.asks.publicKey,lamports:t.lowestFeeMarket?101977920:await l.getMinimumBalanceForRentExemption((p=t.orderbookQueueSpace)!=null?p:65536+12),space:t.lowestFeeMarket?14524:(d=t.orderbookQueueSpace)!=null?d:65536+12,programId:t.programId}),Wp({programId:t.programId,marketInfo:{id:t.id.publicKey,requestQueue:t.requestQueue.publicKey,eventQueue:t.eventQueue.publicKey,bids:t.bids.publicKey,asks:t.asks.publicKey,baseVault:t.baseVault.publicKey,quoteVault:t.quoteVault.publicKey,baseMint:t.baseMint,quoteMint:t.quoteMint,baseLotSize:t.baseLotSize,quoteLotSize:t.quoteLotSize,feeRateBps:t.feeRateBps,vaultSignerNonce:t.vaultSignerNonce,quoteDustThreshold:t.quoteDustThreshold}})),[{transaction:n,signer:[],instructionTypes:[G.CreateAccount,G.CreateAccount,G.InitAccount,G.InitAccount]},{transaction:r,signer:[],instructionTypes:[G.CreateAccount,G.CreateAccount,G.CreateAccount,G.CreateAccount,G.CreateAccount,G.InitMarket]}]}var Eo=class extends Ee{async create({baseInfo:e,quoteInfo:t,lotSize:n,tickSize:o,dexProgramId:r,requestQueueSpace:i,eventQueueSpace:s,orderbookQueueSpace:u,lowestFeeMarket:a,assignSeed:c,txVersion:m,computeBudgetConfig:p,txTipConfig:d,feePayer:f}){let y=this.scope.ownerPubKey,b=c?`${e.mint.toBase58().slice(0,10)}-${t.mint.toBase58().slice(0,10)}-${c}`:void 0,g=Qe({fromPublicKey:y,programId:r,assignSeed:b&&`${b}-market`}),P=Qe({fromPublicKey:y,programId:r,assignSeed:b&&`${b}-request`}),h=Qe({fromPublicKey:y,programId:r,assignSeed:b&&`${b}-event`}),I=Qe({fromPublicKey:y,programId:r,assignSeed:b&&`${b}-bids`}),T=Qe({fromPublicKey:y,programId:r,assignSeed:b&&`${b}-asks`}),w=Qe({fromPublicKey:y,programId:Pl,assignSeed:b&&`${b}-baseVault`}),K=Qe({fromPublicKey:y,programId:Pl,assignSeed:b&&`${b}-quoteVault`}),x=0,S=new Mi(100);function B(){let X=new Mi(0);for(;;)try{return{vaultOwner:Ni.createProgramAddressSync([g.publicKey.toBuffer(),X.toArrayLike(Buffer,"le",8)],r),vaultSignerNonce:X}}catch{if(X.iaddn(1),X.gt(new Mi(25555)))throw Error("find vault owner error")}}let{vaultOwner:R,vaultSignerNonce:C}=B(),v=new Mi(Math.round(10**e.decimals*n)),L=new Mi(Math.round(n*10**t.decimals*o));if(v.eq(xt))throw Error("lot size is too small");if(L.eq(xt))throw Error("tick size or lot size is too small");let N=await Xr({connection:this.scope.connection,wallet:this.scope.ownerPubKey,marketInfo:{programId:r,id:g,baseMint:e.mint,quoteMint:t.mint,baseVault:w,quoteVault:K,vaultOwner:R,requestQueue:P,eventQueue:h,bids:I,asks:T,feeRateBps:x,quoteDustThreshold:S,vaultSignerNonce:C,baseLotSize:v,quoteLotSize:L,requestQueueSpace:i,eventQueueSpace:s,orderbookQueueSpace:u,lowestFeeMarket:a}}),E=this.createTxBuilder(f);E.addInstruction({instructions:N[0].transaction.instructions,signers:N[0].signer});for await(let X of N.slice(1,N.length))E.addInstruction({instructions:X.transaction.instructions,signers:X.signer,instructionTypes:X.instructionTypes});return m===0?E.sizeCheckBuildV0({computeBudgetConfig:p,address:{marketId:g.publicKey,requestQueue:P.publicKey,eventQueue:h.publicKey,bids:I.publicKey,asks:T.publicKey,baseVault:w.publicKey,quoteVault:K.publicKey,baseMint:new Ni(e.mint),quoteMint:new Ni(t.mint)}}):E.sizeCheckBuild({computeBudgetConfig:p,address:{marketId:g.publicKey,requestQueue:P.publicKey,eventQueue:h.publicKey,bids:I.publicKey,asks:T.publicKey,baseVault:w.publicKey,quoteVault:K.publicKey,baseMint:new Ni(e.mint),quoteMint:new Ni(t.mint)}})}};var vi=class extends Ee{constructor(t){super(t);this.stableLayout=new _o({connection:this.scope.connection,modelDataPubKey:this.scope.cluster==="mainnet"?void 0:gn.MODEL_DATA_PUBKEY})}async initLayout(){await this.stableLayout.initStableModelLayout()}async load(){this.checkDisabled()}computePairAmount({poolInfo:t,amount:n,slippage:o,baseIn:r}){let i=new Ye(new Le(n).mul(10**t[r?"mintA":"mintB"].decimals).toFixed(0)),s=Er(t[r?"mintB":"mintA"]),[u,a]=[new Ye(new Le(t.mintAmountA).mul(10**t.mintA.decimals).toString()),new Ye(new Le(t.mintAmountB).mul(10**t.mintB.decimals).toString())],c=new Ye(new Le(t.lpAmount).mul(10**t.lpMint.decimals).toFixed(0,Le.ROUND_DOWN));this.logDebug("baseReserve:",u.toString(),"quoteReserve:",a.toString()),this.logDebug("tokenIn:",r?t.mintA.symbol:t.mintB.symbol,"amountIn:",i.toString(),"anotherToken:",r?t.mintB.symbol:t.mintA.symbol,"slippage:",`${o.toSignificant()}%`,"baseReserve",u.toString(),"quoteReserve",a.toString());let m=r?"base":"quote";this.logDebug("input side:",m);let p=xt;i.isZero()||(p=m==="base"?pr(i.mul(a),u):pr(i.mul(u),a)),this.logDebug("amountRaw:",p.toString(),"lpAmount:",c.toString());let d=pr(i.mul(c),m==="base"?u:a);this.logDebug("liquidity:",d.toString());let f=new st(new Ye(1)).add(o),y=new st(new Ye(1)).sub(o),b=f.mul(p).quotient,g=y.mul(p).quotient,P=new xe(s,p),h=new xe(s,b),I=new xe(s,g);return this.logDebug("anotherAmount:",P.toFixed(),"maxAnotherAmount:",h.toFixed()),{anotherAmount:P,maxAnotherAmount:h,minAnotherAmount:I,liquidity:d}}async getAmmPoolKeys(t){return(await this.scope.api.fetchPoolKeysById({idList:[t]}))[0]}async addLiquidity(t){let{poolInfo:n,poolKeys:o,amountInA:r,amountInB:i,otherAmountMin:s,fixedSide:u,config:a,txVersion:c,computeBudgetConfig:m,txTipConfig:p,feePayer:d}=t;this.scope.availability.addStandardPosition===!1&&this.logAndCreateError("add liquidity feature disabled in your region"),this.logDebug("amountInA:",r,"amountInB:",i),(r.isZero()||i.isZero())&&this.logAndCreateError("amounts must greater than zero","amountInA & amountInB",{amountInA:r.toFixed(),amountInB:i.toFixed()});let{account:f}=this.scope,{bypassAssociatedCheck:y,checkCreateATAOwner:b}=M({bypassAssociatedCheck:!1,checkCreateATAOwner:!1},a),[g,P]=[r.token,i.token],h=await f.getCreatedTokenAccount({mint:g.mint,associatedOnly:!1}),I=await f.getCreatedTokenAccount({mint:P.mint,associatedOnly:!1});!h&&!I&&this.logAndCreateError("cannot found target token accounts","tokenAccounts",f.tokenAccounts);let T=await f.getCreatedTokenAccount({mint:new Ze(n.lpMint.address)}),w=[g,P],K=[h,I],x=[r.raw,i.raw],S=r.token.mint.toBase58()===n.mintA.address?"base":"quote",B="base";["quote","base"].includes(S)||this.logAndCreateError("invalid fixedSide","fixedSide",u),S==="quote"?(w.reverse(),K.reverse(),x.reverse(),B=u==="a"?"quote":"base"):S==="base"&&(B=u==="a"?"base":"quote");let[R,C]=w,[v,L]=K,[N,E]=x,X=o!=null?o:await this.getAmmPoolKeys(n.id),Q=this.createTxBuilder(d),oe=await f.handleTokenAccount({side:"in",amount:N,mint:R.mint,tokenAccount:v,bypassAssociatedCheck:y,checkCreateATAOwner:b}),{tokenAccount:ee}=oe,me=Fe(oe,["tokenAccount"]);Q.addInstruction(me);let Ce=await f.handleTokenAccount({side:"in",amount:E,mint:C.mint,tokenAccount:L,bypassAssociatedCheck:y,checkCreateATAOwner:b}),{tokenAccount:re}=Ce,ue=Fe(Ce,["tokenAccount"]);Q.addInstruction(ue);let fe=await f.handleTokenAccount({side:"out",amount:0,mint:new Ze(n.lpMint.address),tokenAccount:T,bypassAssociatedCheck:y,checkCreateATAOwner:b}),{tokenAccount:be}=fe,de=Fe(fe,["tokenAccount"]);return Q.addInstruction(de),Q.addInstruction({instructions:[al({poolInfo:n,poolKeys:X,userKeys:{baseTokenAccount:ee,quoteTokenAccount:re,lpTokenAccount:be,owner:this.scope.ownerPubKey},baseAmountIn:N,quoteAmountIn:E,otherAmountMin:s.raw,fixedSide:B})],instructionTypes:[n.pooltype.includes("StablePool")?G.AmmV5AddLiquidity:G.AmmV4AddLiquidity],lookupTableAddress:X.lookupTableAccount?[X.lookupTableAccount]:[]}),Q.addCustomComputeBudget(m),Q.addTipInstruction(p),c===0?await Q.buildV0():Q.build()}async removeLiquidity(t){this.scope.availability.removeStandardPosition===!1&&this.logAndCreateError("remove liquidity feature disabled in your region");let{poolInfo:n,poolKeys:o,lpAmount:r,baseAmountMin:i,quoteAmountMin:s,config:u,txVersion:a,computeBudgetConfig:c,txTipConfig:m,feePayer:p}=t,d=o!=null?o:await this.getAmmPoolKeys(n.id),[f,y,b]=[new Ze(n.mintA.address),new Ze(n.mintB.address),new Ze(n.lpMint.address)];this.logDebug("lpAmount:",r),this.logDebug("baseAmountMin:",i),this.logDebug("quoteAmountMin:",s),r.isZero()&&this.logAndCreateError("amount must greater than zero","lpAmount",r.toString());let{account:g}=this.scope,P=await g.getCreatedTokenAccount({mint:b,associatedOnly:!1});P||this.logAndCreateError("cannot found lpTokenAccount","tokenAccounts",g.tokenAccounts);let h=await g.getCreatedTokenAccount({mint:f}),I=await g.getCreatedTokenAccount({mint:y}),T=this.createTxBuilder(p),{bypassAssociatedCheck:w,checkCreateATAOwner:K}=M({bypassAssociatedCheck:!1,checkCreateATAOwner:!1},u),C=await g.handleTokenAccount({side:"out",amount:0,mint:f,tokenAccount:h,bypassAssociatedCheck:w,checkCreateATAOwner:K}),{tokenAccount:x}=C,S=Fe(C,["tokenAccount"]);T.addInstruction(S);let v=await g.handleTokenAccount({side:"out",amount:0,mint:y,tokenAccount:I,bypassAssociatedCheck:w,checkCreateATAOwner:K}),{tokenAccount:B}=v,R=Fe(v,["tokenAccount"]);return T.addInstruction(R),T.addInstruction({instructions:[Na({poolInfo:n,poolKeys:d,userKeys:{lpTokenAccount:P,baseTokenAccount:x,quoteTokenAccount:B,owner:this.scope.ownerPubKey},lpAmount:r,baseAmountMin:i,quoteAmountMin:s})],lookupTableAddress:d.lookupTableAccount?[d.lookupTableAccount]:[],instructionTypes:[n.pooltype.includes("StablePool")?G.AmmV5RemoveLiquidity:G.AmmV4RemoveLiquidity]}),T.addCustomComputeBudget(c),T.addTipInstruction(m),a===0?await T.buildV0():T.build()}async removeAllLpAndCreateClmmPosition({poolInfo:t,clmmPoolInfo:n,removeLpAmount:o,createPositionInfo:r,farmInfo:i,userFarmLpAmount:s,base:u,computeBudgetConfig:a,payer:c,userAuxiliaryLedgers:m,tokenProgram:p=Gn,checkCreateATAOwner:d=!0,getEphemeralSigners:f,txVersion:y,feePayer:b}){if((this.scope.availability.removeStandardPosition===!1||this.scope.availability.createConcentratedPosition===!1)&&this.logAndCreateError("remove liquidity or create position feature disabled in your region"),!(t.mintA.address===n.mintA.address||t.mintA.address===n.mintB.address)||!(t.mintB.address===n.mintA.address||t.mintB.address===n.mintB.address))throw Error("mint check error");let g=this.createTxBuilder(b),P={};for(let X of this.scope.account.tokenAccountRawInfos)(P[X.accountInfo.mint.toString()]===void 0||j(this.scope.ownerPubKey,X.accountInfo.mint,Gn).publicKey.equals(X.pubkey))&&(P[X.accountInfo.mint.toString()]=X.pubkey);let h=P[t.lpMint.address];if(h===void 0)throw Error("find lp account error in trade accounts");let I=o.add(s!=null?s:new Ye(0)),T=t.mintA.address===Ge.WSOL.mint.toString(),w=t.mintB.address===Ge.WSOL.mint.toString(),{account:K,instructionParams:x}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:Gn,mint:new Ze(t.mintA.address),owner:this.scope.ownerPubKey,createInfo:T?{payer:this.scope.ownerPubKey}:void 0,skipCloseAccount:!T,notUseTokenAccount:T,associatedOnly:!0,checkCreateATAOwner:d});if(g.addInstruction(x||{}),K===void 0)throw new Error("base token account not found");let{account:S,instructionParams:B}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:Gn,mint:new Ze(t.mintB.address),owner:this.scope.ownerPubKey,createInfo:w?{payer:this.scope.ownerPubKey,amount:0}:void 0,skipCloseAccount:!w,notUseTokenAccount:w,associatedOnly:!0,checkCreateATAOwner:d});if(g.addInstruction(B||{}),S===void 0)throw new Error("quote token account not found");if(P[t.mintA.address]=K,P[t.mintB.address]=S,i!==void 0&&!(s!=null&&s.isZero())){let X=qt[i.programId],Q=pt({programId:new Ze(i.programId),poolId:new Ze(i.id),owner:this.scope.ownerPubKey,version:X}),ee,me=await this.scope.connection.getAccountInfo(Q);if(me&&(ee=Oo(X).decode(me.data)),X!==6&&!ee){let{instruction:fe,instructionType:Je}=gi({id:new Ze(i.id),programId:new Ze(i.programId),version:X,ledger:Q,owner:this.scope.ownerPubKey});g.addInstruction({instructions:[fe],instructionTypes:[Je]})}let re=[];for(let fe of i.rewardInfos){let Je=fe.mint.address===Ge.WSOL.mint.toString();if(P[fe.mint.address])re.push(P[fe.mint.address]);else{let{account:wo,instructionParams:rn}=await this.scope.account.getOrCreateTokenAccount({mint:new Ze(fe.mint.address),tokenProgram:p,owner:this.scope.ownerPubKey,skipCloseAccount:!Je,createInfo:{payer:c||this.scope.ownerPubKey},associatedOnly:!0,checkCreateATAOwner:d});wo||this.logAndCreateError("farm reward account not found:",fe.mint.address),rn&&g.addInstruction(rn),re.push(wo)}}let ue=(await this.scope.api.fetchFarmKeysById({ids:i.id}))[0],be={userAuxiliaryLedgers:m,amount:s,owner:this.scope.ownerPubKey,farmInfo:i,farmKeys:ue,lpAccount:h,rewardAccounts:re},de=qt[i.programId],oe=de===6?Pi(be):de===5?Ai(be):ki(be),Ce={3:G.FarmV3Withdraw,5:G.FarmV5Withdraw,6:G.FarmV6Withdraw};g.addInstruction({instructions:[oe],instructionTypes:[Ce[de]]})}let R=await this.getAmmPoolKeys(t.id),C=Na({poolInfo:t,poolKeys:R,userKeys:{lpTokenAccount:h,baseTokenAccount:K,quoteTokenAccount:S,owner:this.scope.ownerPubKey},lpAmount:I,baseAmountMin:0,quoteAmountMin:0});g.addInstruction({instructions:[C],instructionTypes:[t.pooltype.includes("StablePool")?G.AmmV5RemoveLiquidity:G.AmmV4RemoveLiquidity],lookupTableAddress:R.lookupTableAccount?[R.lookupTableAccount]:[]});let[v,L]=t.mintA.address===n.mintA.address?[K,S]:[S,K],N=await this.scope.clmm.getClmmPoolKeys(n.id),E=await Se.openPositionFromBaseInstructions(q(M({poolInfo:n,poolKeys:N,ownerInfo:{feePayer:this.scope.ownerPubKey,wallet:this.scope.ownerPubKey,tokenAccountA:v,tokenAccountB:L},withMetadata:"create"},r),{base:u,getEphemeralSigners:f}));return g.addInstruction({instructions:[...E.instructions],signers:E.signers,instructionTypes:[...E.instructionTypes],lookupTableAddress:N.lookupTableAccount?[N.lookupTableAccount]:[]}),y===0?g.sizeCheckBuildV0({computeBudgetConfig:a}):g.sizeCheckBuild({computeBudgetConfig:a})}async createPoolV4({programId:t,marketInfo:n,baseMintInfo:o,quoteMintInfo:r,baseAmount:i,quoteAmount:s,startTime:u,ownerInfo:a,associatedOnly:c=!1,checkCreateATAOwner:m=!1,tokenProgram:p,txVersion:d,feeDestinationId:f,computeBudgetConfig:y,txTipConfig:b,feePayer:g}){var L;let P=a.feePayer||((L=this.scope.owner)==null?void 0:L.publicKey),h=a.useSOLBalance&&o.mint.equals(zr),I=a.useSOLBalance&&r.mint.equals(zr),T=this.createTxBuilder(g),{account:w,instructionParams:K}=await this.scope.account.getOrCreateTokenAccount({mint:o.mint,owner:this.scope.ownerPubKey,createInfo:h?{payer:P,amount:i}:void 0,notUseTokenAccount:h,skipCloseAccount:!h,associatedOnly:h?!1:c,checkCreateATAOwner:m});T.addInstruction(K||{});let{account:x,instructionParams:S}=await this.scope.account.getOrCreateTokenAccount({mint:r.mint,owner:this.scope.ownerPubKey,createInfo:I?{payer:P,amount:s}:void 0,notUseTokenAccount:I,skipCloseAccount:!I,associatedOnly:I?!1:c,checkCreateATAOwner:m});if(T.addInstruction(S||{}),w===void 0||x===void 0)throw Error("you don't has some token account");let B=Ea({version:4,marketVersion:3,marketId:n.marketId,baseMint:o.mint,quoteMint:r.mint,baseDecimals:o.decimals,quoteDecimals:r.decimals,programId:t,marketProgramId:n.programId}),R={programId:t,ammId:B.id,ammAuthority:B.authority,ammOpenOrders:B.openOrders,lpMint:B.lpMint,coinMint:B.baseMint,pcMint:B.quoteMint,coinVault:B.baseVault,pcVault:B.quoteVault,withdrawQueue:B.withdrawQueue,ammTargetOrders:B.targetOrders,poolTempLp:B.lpVault,marketProgramId:B.marketProgramId,marketId:B.marketId,ammConfigId:B.configId,feeDestinationId:f},{instruction:C,instructionType:v}=Ma(q(M({},R),{userWallet:this.scope.ownerPubKey,userCoinVault:w,userPcVault:x,userLpVault:j(this.scope.ownerPubKey,B.lpMint,p).publicKey,nonce:B.nonce,openTime:u,coinAmount:i,pcAmount:s}));return T.addInstruction({instructions:[C],instructionTypes:[v]}),T.addCustomComputeBudget(y),T.addTipInstruction(b),T.versionBuild({txVersion:d,extInfo:{address:R}})}async createMarketAndPoolV4({programId:t=ni,marketProgram:n=Rs,feeDestinationId:o=Ls,tokenProgram:r,baseMintInfo:i,quoteMintInfo:s,baseAmount:u,quoteAmount:a,startTime:c,ownerInfo:m,lowestFeeMarket:p,assignSeed:d,associatedOnly:f=!1,checkCreateATAOwner:y=!1,lotSize:b=1,tickSize:g=.01,txVersion:P,computeBudgetConfig:h,txTipConfig:I,feePayer:T}){var To,ho,ps;let w=this.scope.ownerPubKey,K=m.feePayer||((To=this.scope.owner)==null?void 0:To.publicKey),x=m.useSOLBalance&&i.mint.equals(zr),S=m.useSOLBalance&&s.mint.equals(zr),B=d?`${i.mint.toBase58().slice(0,7)}-${s.mint.toBase58().slice(0,7)}-${d}`:void 0,R=Qe({fromPublicKey:w,programId:n,assignSeed:B&&`${B}-market`}),C=Qe({fromPublicKey:w,programId:n,assignSeed:B&&`${B}-request`}),v=Qe({fromPublicKey:w,programId:n,assignSeed:B&&`${B}-event`}),L=Qe({fromPublicKey:w,programId:n,assignSeed:B&&`${B}-bids`}),N=Qe({fromPublicKey:w,programId:n,assignSeed:B&&`${B}-asks`}),E=Qe({fromPublicKey:w,programId:Gn,assignSeed:B&&`${B}-baseVault`}),X=Qe({fromPublicKey:w,programId:Gn,assignSeed:B&&`${B}-quoteVault`}),Q=0,ee=new Ye(100);function me(){let Mt=new Ye(0);for(;;)try{return{vaultOwner:Ze.createProgramAddressSync([R.publicKey.toBuffer(),Mt.toArrayLike(Buffer,"le",8)],n),vaultSignerNonce:Mt}}catch{if(Mt.iaddn(1),Mt.gt(new Ye(25555)))throw Error("find vault owner error")}}let{vaultOwner:re,vaultSignerNonce:ue}=me(),be=new Ye(Math.round(10**i.decimals*b)),de=new Ye(Math.round(b*10**s.decimals*g));if(be.eq(xt))throw Error("lot size is too small");if(de.eq(xt))throw Error("tick size or lot size is too small");let oe=await Xr({connection:this.scope.connection,wallet:this.scope.ownerPubKey,marketInfo:{programId:n,vaultOwner:re,baseMint:i.mint,quoteMint:s.mint,id:R,baseVault:E,quoteVault:X,requestQueue:C,eventQueue:v,bids:L,asks:N,feeRateBps:Q,quoteDustThreshold:ee,vaultSignerNonce:ue,baseLotSize:be,quoteLotSize:de,lowestFeeMarket:p}}),Ce=this.createTxBuilder(T);Ce.addInstruction({instructions:oe[0].transaction.instructions,signers:oe[0].signer});for await(let Mt of oe.slice(1,oe.length))Ce.addInstruction({instructions:Mt.transaction.instructions,signers:Mt.signer,instructionTypes:Mt.instructionTypes});let{account:fe,instructionParams:Je}=await this.scope.account.getOrCreateTokenAccount({mint:i.mint,owner:this.scope.ownerPubKey,createInfo:x?{payer:K,amount:u}:void 0,notUseTokenAccount:x,skipCloseAccount:!x,associatedOnly:x?!1:f,checkCreateATAOwner:y,assignSeed:x&&B?`${B}-wsol`:void 0});Ce.addInstruction(Je||{});let{account:wo,instructionParams:rn}=await this.scope.account.getOrCreateTokenAccount({mint:s.mint,owner:this.scope.ownerPubKey,createInfo:S?{payer:K,amount:a}:void 0,notUseTokenAccount:S,skipCloseAccount:!S,associatedOnly:S?!1:f,checkCreateATAOwner:y,assignSeed:S&&B?`${B}-wsol`:void 0});if(Ce.addInstruction(rn||{}),fe===void 0)throw Error("you don't has base token account");if(wo===void 0)throw Error("you don't has quote token account");let Oe=Ea({version:4,marketVersion:3,marketId:R.publicKey,baseMint:i.mint,quoteMint:s.mint,baseDecimals:i.decimals,quoteDecimals:s.decimals,programId:t,marketProgramId:n}),Yo={programId:t,ammId:Oe.id,ammAuthority:Oe.authority,ammOpenOrders:Oe.openOrders,lpMint:Oe.lpMint,coinMint:Oe.baseMint,pcMint:Oe.quoteMint,coinVault:Oe.baseVault,pcVault:Oe.quoteVault,withdrawQueue:Oe.withdrawQueue,ammTargetOrders:Oe.targetOrders,poolTempLp:Oe.lpVault,marketProgramId:Oe.marketProgramId,marketId:Oe.marketId,ammConfigId:Oe.configId,feeDestinationId:o},{instruction:ds,instructionType:Qo}=Ma(q(M({},Yo),{userWallet:this.scope.ownerPubKey,userCoinVault:fe,userPcVault:wo,userLpVault:j(this.scope.ownerPubKey,Oe.lpMint,r).publicKey,nonce:Oe.nonce,openTime:c,coinAmount:u,pcAmount:a}));Ce.addInstruction({instructions:[ds],instructionTypes:[Qo]});let jt=x||S?[((ho=Je==null?void 0:Je.instructions)==null?void 0:ho[0])||((ps=rn==null?void 0:rn.instructions)==null?void 0:ps[0])].filter(Mt=>!!Mt):void 0;return P===0?Ce.sizeCheckBuildV0({computeBudgetConfig:h,splitIns:jt,address:M({requestQueue:C.publicKey,eventQueue:v.publicKey,bids:L.publicKey,asks:N.publicKey,baseVault:E.publicKey,quoteVault:X.publicKey,baseMint:new Ze(i.mint),quoteMint:new Ze(s.mint)},Yo)}):Ce.sizeCheckBuild({computeBudgetConfig:h,splitIns:jt,address:M({requestQueue:C.publicKey,eventQueue:v.publicKey,bids:L.publicKey,asks:N.publicKey,baseVault:E.publicKey,quoteVault:X.publicKey,baseMint:new Ze(i.mint),quoteMint:new Ze(s.mint)},Yo)})}async getCreatePoolFee({programId:t}){let n=Ur({programId:t}),o=await this.scope.connection.getAccountInfo(n,{dataSlice:{offset:536,length:8}});if(o===null)throw Error("get config account error");return il.decode(o.data).fee}computeAmountOut({poolInfo:t,amountIn:n,mintIn:o,mintOut:r,slippage:i}){let[s,u]=[o.toString(),r.toString()];if(s!==t.mintA.address&&s!==t.mintB.address)throw new Error("toke not match");if(u!==t.mintA.address&&u!==t.mintB.address)throw new Error("toke not match");let{baseReserve:a,quoteReserve:c}=t,m=[a,c],p=[t.mintA.decimals,t.mintB.decimals],d=s==t.mintA.address?"base":"quote";d==="quote"&&(m.reverse(),p.reverse());let[f,y]=m,[b,g]=p,P=t.version===4,h;if(P)h=new Le(y.toString()).div(10**g).div(new Le(f.toString()).div(10**b));else{let v=pl(this.stableLayout.stableModelData,a.toNumber(),c.toNumber(),!1);d==="quote"?h=new Le(1e6).div(v*1e6):h=new Le(v*1e6).div(1e6)}let I=n,T=new Ye(0),w=new Ye(0);if(!I.isZero())if(P){w=Fn(I.mul(Ka),Wr);let v=I.sub(w),L=f.add(v);T=y.mul(v).div(L)}else{w=I.mul(new Ye(2)).div(new Ye(1e4));let v=I.sub(w);d==="quote"?T=new Ye(ml(this.stableLayout.stableModelData,c.toNumber(),a.toNumber(),v.toNumber())):T=new Ye(dl(this.stableLayout.stableModelData,c.toNumber(),a.toNumber(),v.toNumber()))}let K=new Ye(new Le(T.toString()).mul(1-i).toFixed(0)),x=T,S=K,B=new Le(T.toString()).div(new Le(I.sub(w).toString()).toFixed(0));!I.isZero()&&!T.isZero()&&(B=new Le(T.toString()).div(10**g).div(new Le(I.sub(w).toString()).div(10**b)));let R=h.sub(B).div(h).mul(100);return{amountOut:x,minAmountOut:S,currentPrice:h,executionPrice:B,priceImpact:R,fee:w}}computeAmountIn({poolInfo:t,amountOut:n,mintIn:o,mintOut:r,slippage:i}){let{baseReserve:s,quoteReserve:u}=t;o.toString()!==t.mintA.address&&o.toString()!==t.mintB.address&&this.logAndCreateError("mintIn does not match pool"),r.toString()!==t.mintA.address&&r.toString()!==t.mintB.address&&this.logAndCreateError("mintOut does not match pool"),this.logDebug("baseReserve:",s.toString()),this.logDebug("quoteReserve:",u.toString());let a=o.toString()===t.mintA.address,[c,m]=a?[t.mintA,t.mintB]:[t.mintB,t.mintA];this.logDebug("currencyOut:",m.symbol||m.address),this.logDebug("amountOut:",new Le(n.toString()).div(10**m.decimals).toDecimalPlaces(m.decimals).toString(),c.symbol||c.address),this.logDebug("slippage:",`${i*100}%`);let p=[s,u],d=a?"quote":"base";d==="base"&&p.reverse(),this.logDebug("output side:",d);let[f,y]=p,b=new Le(y.toString()).div(10**t[a?"mintB":"mintA"].decimals).div(new Le(f.toString()).div(10**t[a?"mintA":"mintB"].decimals));this.logDebug("currentPrice:",`1 ${c.symbol||c.address} \u2248 ${b.toString()} ${m.symbol||m.address}`),this.logDebug("currentPrice invert:",`1 ${m.symbol||m.address} \u2248 ${new Le(1).div(b).toString()} ${c.symbol||c.address}`);let g=new Ye(0),P=n;if(!P.isZero()){P.gt(y)&&(P=y.sub(new Ye(1)));let S=y.sub(P);g=f.mul(P).div(S).mul(Wr).div(Wr.sub(Ka))}let h=new Ye(new Le(g.toString()).mul(1+i).toFixed(0)),I=g,T=h;this.logDebug("amountIn:",new Le(I.toString()).div(10**c.decimals).toDecimalPlaces(c.decimals).toString()),this.logDebug("maxAmountIn:",new Le(T.toString()).div(10**c.decimals).toDecimalPlaces(c.decimals).toString());let w=null;!g.isZero()&&!P.isZero()&&(w=new Le(P.toString()).div(10**m.decimals).div(new Le(g.toString()).div(10**c.decimals)),this.logDebug("executionPrice:",`1 ${m.symbol||m.address} \u2248 ${w.toDecimalPlaces(Math.max(t.mintA.decimals,t.mintB.decimals)).toString()} ${c.symbol||c.address}`),this.logDebug("executionPrice invert:",`1 ${m.symbol||m.address} \u2248 ${new Le(1).div(w).toDecimalPlaces(Math.max(t.mintA.decimals,t.mintB.decimals)).toString()} ${c.symbol||c.address}`));let K=b.mul(I.toString()),x=K.sub(n.toString()).abs().div(K);return this.logDebug("priceImpact:",`${x.toString()}%`),{amountIn:I,maxAmountIn:T,currentPrice:b,executionPrice:w,priceImpact:x}}async swap({poolInfo:t,poolKeys:n,amountIn:o,amountOut:r,inputMint:i,fixedSide:s,txVersion:u,config:a,computeBudgetConfig:c,txTipConfig:m,feePayer:p}){let d=this.createTxBuilder(p),{associatedOnly:f=!0,inputUseSolBalance:y=!0,outputUseSolBalance:b=!0}=a||{},[g,P]=i===t.mintA.address?[t.mintA,t.mintB]:[t.mintB,t.mintA],h=y&&g.address===$.toBase58(),I=b&&P.address===$.toBase58(),{account:T,instructionParams:w}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:Gn,mint:new Ze(g.address),owner:this.scope.ownerPubKey,createInfo:h?{payer:this.scope.ownerPubKey,amount:o}:void 0,skipCloseAccount:!h,notUseTokenAccount:h,associatedOnly:f});d.addInstruction(w||{}),T||this.logAndCreateError("input token account not found",{token:g.symbol||g.address,tokenAccountIn:T,inputTokenUseSolBalance:h,associatedOnly:f});let{account:K,instructionParams:x}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:Gn,mint:new Ze(P.address),owner:this.scope.ownerPubKey,createInfo:{payer:this.scope.ownerPubKey,amount:0},skipCloseAccount:!I,notUseTokenAccount:I,associatedOnly:I?!1:f});d.addInstruction(x||{}),K===void 0&&this.logAndCreateError("output token account not found",{token:P.symbol||P.address,tokenAccountOut:K,outputTokenUseSolBalance:I,associatedOnly:f});let S=n||await this.getAmmPoolKeys(t.id),B=4;return t.pooltype.includes("StablePool")&&(B=5),d.addInstruction({instructions:[Dr({version:B,poolKeys:S,userKeys:{tokenAccountIn:T,tokenAccountOut:K,owner:this.scope.ownerPubKey},amountIn:o,amountOut:r,fixedSide:s})],instructionTypes:[B===4?G.AmmV4SwapBaseIn:G.AmmV5SwapBaseIn]}),d.addCustomComputeBudget(c),d.addTipInstruction(m),d.versionBuild({txVersion:u})}async getRpcPoolInfo(t){return(await this.getRpcPoolInfos([t]))[t]}async getRpcPoolInfos(t,n){let o=await Ne(this.scope.connection,t.map(c=>({pubkey:new Ze(c)})),n),r={},i=[];for(let c=0;c<t.length;c++){let m=o[c];if(m===null||!m.accountInfo)throw Error("fetch pool info error: "+String(t[c]));let p=co.decode(m.accountInfo.data);r[String(t[c])]=q(M({},p),{programId:m.accountInfo.owner}),i.push(p.baseVault,p.quoteVault)}let s={},u=await Ne(this.scope.connection,i.map(c=>({pubkey:new Ze(c)})),n);for(let c=0;c<i.length;c++){let m=u[c].accountInfo;if(m===null)throw Error("fetch vault info error: "+i[c]);s[String(i[c])]=new Ye(Dp.decode(m.data).amount.toString())}let a={};for(let[c,m]of Object.entries(r)){let p=s[m.baseVault.toString()].sub(m.baseNeedTakePnl),d=s[m.quoteVault.toString()].sub(m.quoteNeedTakePnl);a[c]=q(M({},m),{baseReserve:p,mintAAmount:s[m.baseVault.toString()],mintBAmount:s[m.quoteVault.toString()],quoteReserve:d,poolPrice:new Le(d.toString()).div(new Le(10).pow(m.quoteDecimal.toString())).div(new Le(p.toString()).div(new Le(10).pow(m.baseDecimal.toString())))})}return a}async getPoolInfoFromRpc({poolId:t}){let n=await this.getRpcPoolInfo(t),o=Gr({[t]:n}),r=o[t],i=await this.scope.tradeV2.computePoolToPoolKeys({pools:[o[t]],ammRpcData:{[t]:n}});return{poolRpcData:n,poolInfo:r,poolKeys:i[0]}}};import{PublicKey as H}from"@solana/web3.js";import ht from"bn.js";import yo from"decimal.js";import{AccountLayout as Al,createAssociatedTokenAccountIdempotentInstruction as kl,TOKEN_2022_PROGRAM_ID as Xn,TOKEN_PROGRAM_ID as Fi}from"@solana/spl-token";var Vi=class extends Ee{constructor(e){super(e)}async getClmmPoolKeys(e){return(await this.scope.api.fetchPoolKeysById({idList:[e]}))[0]}async createPool(e){var K;let{programId:t,owner:n=((K=this.scope.owner)==null?void 0:K.publicKey)||H.default,mint1:o,mint2:r,ammConfig:i,initialPrice:s,computeBudgetConfig:u,forerunCreate:a,getObserveState:c,txVersion:m,txTipConfig:p,feePayer:d}=e,f=this.createTxBuilder(d),[y,b,g]=new ht(new H(o.address).toBuffer()).gt(new ht(new H(r.address).toBuffer()))?[r,o,new yo(1).div(s)]:[o,r,s],P=se.priceToSqrtPriceX64(g,y.decimals,b.decimals),h=[],I=[];y.programId===Xn.toBase58()&&I.push(wa(t,new H(y.address)).publicKey),b.programId===Xn.toBase58()&&I.push(wa(t,new H(b.address)).publicKey),(await this.scope.connection.getMultipleAccountsInfo(I)).forEach((x,S)=>{x&&h.push(I[S])});let w=await Se.createPoolInstructions({connection:this.scope.connection,programId:t,owner:n,mintA:y,mintB:b,ammConfigId:i.id,initialPriceX64:P,forerunCreate:!c&&a,extendMintAccount:h});return f.addInstruction(w),f.addCustomComputeBudget(u),f.addTipInstruction(p),f.versionBuild({txVersion:m,extInfo:{address:q(M({},w.address),{observationId:w.address.observationId.toBase58(),exBitmapAccount:w.address.exBitmapAccount.toBase58(),programId:t.toString(),id:w.address.poolId.toString(),mintA:y,mintB:b,openTime:"0",vault:{A:w.address.mintAVault.toString(),B:w.address.mintBVault.toString()},rewardInfos:[],config:{id:i.id.toString(),index:i.index,protocolFeeRate:i.protocolFeeRate,tradeFeeRate:i.tradeFeeRate,tickSpacing:i.tickSpacing,fundFeeRate:i.fundFeeRate,description:i.description,defaultRange:0,defaultRangePoint:[]}}),mockPoolInfo:M({type:"Concentrated",rewardDefaultPoolInfos:"Clmm",id:w.address.poolId.toString(),mintA:y,mintB:b,feeRate:i.tradeFeeRate,openTime:"0",programId:t.toString(),price:g.toNumber(),config:{id:i.id.toString(),index:i.index,protocolFeeRate:i.protocolFeeRate,tradeFeeRate:i.tradeFeeRate,tickSpacing:i.tickSpacing,fundFeeRate:i.fundFeeRate,description:i.description,defaultRange:0,defaultRangePoint:[]},burnPercent:0},Vc),forerunCreate:a}})}async openPositionFromBase({poolInfo:e,poolKeys:t,ownerInfo:n,tickLower:o,tickUpper:r,base:i,baseAmount:s,otherAmountMax:u,nft2022:a,associatedOnly:c=!0,checkCreateATAOwner:m=!1,withMetadata:p="create",getEphemeralSigners:d,computeBudgetConfig:f,txTipConfig:y,txVersion:b,feePayer:g}){this.scope.availability.addConcentratedPosition===!1&&this.logAndCreateError("add position feature disabled in your region"),this.scope.checkOwner();let P=this.createTxBuilder(g),h=null,I=null,T=n.useSOLBalance&&e.mintA.address===$.toString(),w=n.useSOLBalance&&e.mintB.address===$.toString(),[K,x]=i==="MintA"?[s,u]:[u,s],{account:S,instructionParams:B}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:e.mintA.programId,mint:new H(e.mintA.address),owner:this.scope.ownerPubKey,createInfo:T||K.isZero()?{payer:this.scope.ownerPubKey,amount:K}:void 0,skipCloseAccount:!T,notUseTokenAccount:T,associatedOnly:T?!1:c,checkCreateATAOwner:m});S&&(h=S),P.addInstruction(B||{});let{account:R,instructionParams:C}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:e.mintB.programId,mint:new H(e.mintB.address),owner:this.scope.ownerPubKey,createInfo:w||x.isZero()?{payer:this.scope.ownerPubKey,amount:x}:void 0,skipCloseAccount:!w,notUseTokenAccount:w,associatedOnly:w?!1:c,checkCreateATAOwner:m});R&&(I=R),P.addInstruction(C||{}),(!h||!I)&&this.logAndCreateError("cannot found target token accounts","tokenAccounts",{ownerTokenAccountA:h==null?void 0:h.toBase58(),ownerTokenAccountB:I==null?void 0:I.toBase58()});let v=t||await this.getClmmPoolKeys(e.id),L=await Se.openPositionFromBaseInstructions({poolInfo:e,poolKeys:v,ownerInfo:q(M({},n),{feePayer:this.scope.ownerPubKey,wallet:this.scope.ownerPubKey,tokenAccountA:h,tokenAccountB:I}),tickLower:o,tickUpper:r,base:i,baseAmount:s,otherAmountMax:u,withMetadata:p,getEphemeralSigners:d,nft2022:a});return P.addInstruction(L),P.addCustomComputeBudget(f),P.addTipInstruction(y),P.versionBuild({txVersion:b,extInfo:M({},L.address)})}async openPositionFromLiquidity({poolInfo:e,poolKeys:t,ownerInfo:n,amountMaxA:o,amountMaxB:r,tickLower:i,tickUpper:s,liquidity:u,associatedOnly:a=!0,checkCreateATAOwner:c=!1,withMetadata:m="create",txVersion:p,computeBudgetConfig:d,txTipConfig:f,getEphemeralSigners:y,nft2022:b,feePayer:g}){this.scope.availability.createConcentratedPosition===!1&&this.logAndCreateError("open position feature disabled in your region");let P=this.createTxBuilder(g),h=null,I=null,T=n.useSOLBalance&&e.mintA.address===$.toBase58(),w=n.useSOLBalance&&e.mintB.address===$.toBase58(),{account:K,instructionParams:x}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:e.mintA.programId,mint:new H(e.mintA.address),owner:this.scope.ownerPubKey,createInfo:T||o.isZero()?{payer:this.scope.ownerPubKey,amount:o}:void 0,skipCloseAccount:!T,notUseTokenAccount:T,associatedOnly:T?!1:a,checkCreateATAOwner:c});K&&(h=K),P.addInstruction(x||{});let{account:S,instructionParams:B}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:e.mintB.programId,mint:new H(e.mintB.address),owner:this.scope.ownerPubKey,createInfo:w||r.isZero()?{payer:this.scope.ownerPubKey,amount:r}:void 0,skipCloseAccount:!w,notUseTokenAccount:w,associatedOnly:w?!1:a,checkCreateATAOwner:c});S&&(I=S),P.addInstruction(B||{}),(h===void 0||I===void 0)&&this.logAndCreateError("cannot found target token accounts","tokenAccounts",this.scope.account.tokenAccounts);let R=t||await this.getClmmPoolKeys(e.id),C=await Se.openPositionFromLiquidityInstructions({poolInfo:e,poolKeys:R,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccountA:h,tokenAccountB:I},tickLower:i,tickUpper:s,liquidity:u,amountMaxA:o,amountMaxB:r,withMetadata:m,getEphemeralSigners:y,nft2022:b});return P.addInstruction(C),P.addCustomComputeBudget(d),P.addTipInstruction(f),P.versionBuild({txVersion:p,extInfo:{address:C.address}})}async increasePositionFromLiquidity(e){var B;let{poolInfo:t,poolKeys:n,ownerPosition:o,amountMaxA:r,amountMaxB:i,liquidity:s,ownerInfo:u,associatedOnly:a=!0,checkCreateATAOwner:c=!1,computeBudgetConfig:m,txTipConfig:p,txVersion:d,feePayer:f}=e,y=this.createTxBuilder(f),b,g,P=u.useSOLBalance&&t.mintA.address===$.toString(),h=u.useSOLBalance&&t.mintB.address===$.toString(),{account:I,instructionParams:T}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:t.mintA.programId,mint:new H(t.mintA.address),notUseTokenAccount:P,owner:this.scope.ownerPubKey,createInfo:P||r.isZero()?{payer:this.scope.ownerPubKey,amount:r}:void 0,skipCloseAccount:!P,associatedOnly:P?!1:a,checkCreateATAOwner:c});I&&(b=I),y.addInstruction(T||{});let{account:w,instructionParams:K}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:t.mintB.programId,mint:new H(t.mintB.address),owner:this.scope.ownerPubKey,createInfo:h||i.isZero()?{payer:this.scope.ownerPubKey,amount:i}:void 0,notUseTokenAccount:h,skipCloseAccount:!h,associatedOnly:h?!1:a,checkCreateATAOwner:c});w&&(g=w),y.addInstruction(K||{}),!b&&!g&&this.logAndCreateError("cannot found target token accounts","tokenAccounts",this.scope.account.tokenAccounts);let x=n!=null?n:await this.getClmmPoolKeys(t.id),S=Se.increasePositionFromLiquidityInstructions({poolInfo:t,poolKeys:x,ownerPosition:o,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccountA:b,tokenAccountB:g},liquidity:s,amountMaxA:r,amountMaxB:i,nft2022:(B=await this.scope.connection.getAccountInfo(o.nftMint))==null?void 0:B.owner.equals(Xn)});return y.addInstruction(S),y.addCustomComputeBudget(m),y.addTipInstruction(p),y.versionBuild({txVersion:d,extInfo:{address:S.address}})}async increasePositionFromBase(e){var S;let{poolInfo:t,ownerPosition:n,base:o,baseAmount:r,otherAmountMax:i,ownerInfo:s,associatedOnly:u=!0,checkCreateATAOwner:a=!1,computeBudgetConfig:c,txTipConfig:m,txVersion:p,feePayer:d}=e,f=this.createTxBuilder(d),y,b,g=s.useSOLBalance&&t.mintA.address===$.toString(),P=s.useSOLBalance&&t.mintB.address===$.toString(),{account:h,instructionParams:I}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:t.mintA.programId,mint:new H(t.mintA.address),notUseTokenAccount:g,owner:this.scope.ownerPubKey,createInfo:g||(o==="MintA"?r:i).isZero()?{payer:this.scope.ownerPubKey,amount:o==="MintA"?r:i}:void 0,skipCloseAccount:!g,associatedOnly:g?!1:u,checkCreateATAOwner:a});h&&(y=h),f.addInstruction(I||{});let{account:T,instructionParams:w}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:t.mintB.programId,mint:new H(t.mintB.address),owner:this.scope.ownerPubKey,createInfo:P||(o==="MintA"?i:r).isZero()?{payer:this.scope.ownerPubKey,amount:o==="MintA"?i:r}:void 0,notUseTokenAccount:P,skipCloseAccount:!P,associatedOnly:P?!1:u,checkCreateATAOwner:a});T&&(b=T),f.addInstruction(w||{}),!y&&!b&&this.logAndCreateError("cannot found target token accounts","tokenAccounts",this.scope.account.tokenAccounts);let K=await this.getClmmPoolKeys(t.id),x=Se.increasePositionFromBaseInstructions({poolInfo:t,poolKeys:K,ownerPosition:n,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccountA:y,tokenAccountB:b},base:o,baseAmount:r,otherAmountMax:i,nft2022:(S=await this.scope.connection.getAccountInfo(n.nftMint))==null?void 0:S.owner.equals(Xn)});return f.addInstruction(x),f.addCustomComputeBudget(c),f.addTipInstruction(m),f.versionBuild({txVersion:p,extInfo:{address:x.address}})}async decreaseLiquidity(e){var v;let{poolInfo:t,poolKeys:n,ownerPosition:o,ownerInfo:r,amountMinA:i,amountMinB:s,liquidity:u,associatedOnly:a=!0,checkCreateATAOwner:c=!1,computeBudgetConfig:m,txTipConfig:p,txVersion:d,feePayer:f}=e;this.scope.availability.removeConcentratedPosition===!1&&this.logAndCreateError("remove position feature disabled in your region");let y=this.createTxBuilder(f),b=r.useSOLBalance&&t.mintA.address===$.toString(),g=r.useSOLBalance&&t.mintB.address===$.toString(),P,h,{account:I,instructionParams:T}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:t.mintA.programId,mint:new H(t.mintA.address),notUseTokenAccount:b,owner:this.scope.ownerPubKey,createInfo:{payer:this.scope.ownerPubKey,amount:0},skipCloseAccount:!b,associatedOnly:b?!1:a,checkCreateATAOwner:c});P=I,T&&y.addInstruction(T);let{account:w,instructionParams:K}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:t.mintB.programId,mint:new H(t.mintB.address),notUseTokenAccount:g,owner:this.scope.ownerPubKey,createInfo:{payer:this.scope.ownerPubKey,amount:0},skipCloseAccount:!g,associatedOnly:g?!1:a,checkCreateATAOwner:c});h=w,K&&y.addInstruction(K);let x=[];for(let L of t.rewardDefaultInfos){let N=r.useSOLBalance&&L.mint.address===$.toString(),E;if(L.mint.address===t.mintA.address)E=P;else if(L.mint.address===t.mintB.address)E=h;else{let{account:X,instructionParams:Q}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:new H(L.mint.programId),mint:new H(L.mint.address),notUseTokenAccount:N,owner:this.scope.ownerPubKey,createInfo:{payer:this.scope.ownerPubKey,amount:0},skipCloseAccount:!N,associatedOnly:N?!1:a,checkCreateATAOwner:c});E=X,Q&&y.addInstruction(Q)}x.push(E)}!P&&!h&&this.logAndCreateError("cannot found target token accounts","tokenAccounts",this.scope.account.tokenAccountRawInfos);let S=n!=null?n:await this.getClmmPoolKeys(t.id),B=(v=await this.scope.connection.getAccountInfo(o.nftMint))==null?void 0:v.owner.equals(Xn),R=await Se.decreaseLiquidityInstructions({poolInfo:t,poolKeys:S,ownerPosition:o,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccountA:P,tokenAccountB:h,rewardAccounts:x},liquidity:u,amountMinA:i,amountMinB:s,nft2022:B});y.addInstruction({instructions:R.instructions,instructionTypes:[G.ClmmDecreasePosition]});let C=M({},R.address);if(r.closePosition){let L=await Se.closePositionInstructions({poolInfo:t,poolKeys:S,ownerInfo:{wallet:this.scope.ownerPubKey},ownerPosition:o,nft2022:B});y.addInstruction({endInstructions:L.instructions,endInstructionTypes:L.instructionTypes}),C=M(M({},C),L.address)}return y.addCustomComputeBudget(m),y.addTipInstruction(p),y.versionBuild({txVersion:d,extInfo:{address:C}})}async lockPosition(e){var f;let{programId:t=xo,authProgramId:n=oi,poolProgramId:o=Nn,ownerPosition:r,payer:i,computeBudgetConfig:s,txTipConfig:u,txVersion:a,getEphemeralSigners:c,feePayer:m}=e,p=this.createTxBuilder(m),d=await Se.makeLockPositions({programId:t,authProgramId:n,poolProgramId:o,wallet:this.scope.ownerPubKey,payer:i!=null?i:this.scope.ownerPubKey,nftMint:r.nftMint,getEphemeralSigners:c,nft2022:(f=await this.scope.connection.getAccountInfo(r.nftMint))==null?void 0:f.owner.equals(Xn)});return p.addInstruction(d),p.addCustomComputeBudget(s),p.addTipInstruction(u),p.versionBuild({txVersion:a,extInfo:d.address})}async harvestLockPosition(e){let{programId:t=xo,authProgramId:n=oi,clmmProgram:o=Nn,poolKeys:r,lockData:i,ownerInfo:s={useSOLBalance:!0},associatedOnly:u=!0,checkCreateATAOwner:a=!1,computeBudgetConfig:c,txTipConfig:m,txVersion:p,feePayer:d}=e,f=r||await this.getClmmPoolKeys(i.poolId.toString()),y=this.createTxBuilder(d),b=await this.scope.connection.getAccountInfo(i.positionId);b||this.logger.logWithError("position not found",i.positionId);let g=vo.decode(b.data),P=s.useSOLBalance&&f.mintA.address===$.toString(),h=s.useSOLBalance&&f.mintB.address===$.toString(),I,T,{account:w,instructionParams:K}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:f.mintA.programId,mint:new H(f.mintA.address),notUseTokenAccount:P,owner:this.scope.ownerPubKey,createInfo:{payer:this.scope.ownerPubKey,amount:0},skipCloseAccount:!P,associatedOnly:P?!1:u,checkCreateATAOwner:a});I=w,K&&y.addInstruction(K);let{account:x,instructionParams:S}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:f.mintB.programId,mint:new H(f.mintB.address),notUseTokenAccount:h,owner:this.scope.ownerPubKey,createInfo:{payer:this.scope.ownerPubKey,amount:0},skipCloseAccount:!h,associatedOnly:h?!1:u,checkCreateATAOwner:a});T=x,S&&y.addInstruction(S);let B={},R=[];for(let re of f.rewardInfos){let ue=s.useSOLBalance&&re.mint.address===$.toString(),be=B[re.mint.address];if(!be){let{account:de,instructionParams:oe}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:new H(re.mint.programId),mint:new H(re.mint.address),notUseTokenAccount:ue,owner:this.scope.ownerPubKey,skipCloseAccount:!ue,createInfo:{payer:this.scope.ownerPubKey,amount:0},associatedOnly:ue?!1:u});be=de,oe&&y.addInstruction(oe)}B[re.mint.address]=be,R.push(be)}let C=Mo(t,i.lockNftMint).publicKey,v=j(this.scope.ownerPubKey,i.lockNftMint,Fi).publicKey,L=Z.getTickArrayStartIndexByTick(g.tickLower,f.config.tickSpacing),N=Z.getTickArrayStartIndexByTick(g.tickUpper,f.config.tickSpacing),{publicKey:E}=Pe(new H(f.programId),i.poolId,L),{publicKey:X}=Pe(new H(f.programId),i.poolId,N),{publicKey:Q}=nn(new H(f.programId),i.poolId,g.tickLower,g.tickUpper),ee=[];for(let re=0;re<f.rewardInfos.length;re++)ee.push({poolRewardVault:new H(f.rewardInfos[re].vault),ownerRewardVault:R[re],rewardMint:new H(f.rewardInfos[re].mint.address)});let me=await Se.harvestLockPositionInstructionV2({programId:t,auth:n,lockPositionId:C,clmmProgram:o,lockOwner:this.scope.ownerPubKey,lockNftMint:i.lockNftMint,lockNftAccount:v,positionNftAccount:i.nftAccount,positionId:i.positionId,poolId:i.poolId,protocolPosition:Q,vaultA:new H(f.vault.A),vaultB:new H(f.vault.B),tickArrayLower:E,tickArrayUpper:X,userVaultA:I,userVaultB:T,mintA:new H(f.mintA.address),mintB:new H(f.mintB.address),rewardAccounts:ee,exTickArrayBitmap:He(o,i.poolId).publicKey});return y.addInstruction({instructions:[me],instructionTypes:[G.ClmmHarvestLockPosition]}),y.addCustomComputeBudget(c),y.addTipInstruction(m),y.versionBuild({txVersion:p})}async closePosition({poolInfo:e,poolKeys:t,ownerPosition:n,txVersion:o,computeBudgetConfig:r,txTipConfig:i,feePayer:s}){var m;this.scope.availability.removeConcentratedPosition===!1&&this.logAndCreateError("remove position feature disabled in your region");let u=this.createTxBuilder(s),a=t!=null?t:await this.getClmmPoolKeys(e.id),c=Se.closePositionInstructions({poolInfo:e,poolKeys:a,ownerInfo:{wallet:this.scope.ownerPubKey},ownerPosition:n,nft2022:(m=await this.scope.connection.getAccountInfo(n.nftMint))==null?void 0:m.owner.equals(Xn)});return u.addCustomComputeBudget(r),u.addTipInstruction(i),u.addInstruction(c).versionBuild({txVersion:o,extInfo:{address:c.address}})}async initReward({poolInfo:e,ownerInfo:t,rewardInfo:n,associatedOnly:o=!0,checkCreateATAOwner:r=!1,computeBudgetConfig:i,txVersion:s,feePayer:u}){n.endTime<=n.openTime&&this.logAndCreateError("reward time error","rewardInfo",n);let a=this.createTxBuilder(u),c=t.useSOLBalance&&n.mint.address.toString()===$.toString(),m=n.perSecond.mul(n.endTime-n.openTime),{account:p,instructionParams:d}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:new H(n.mint.address),mint:new H(n.mint.address),notUseTokenAccount:!!c,skipCloseAccount:!c,owner:this.scope.ownerPubKey,createInfo:c?{payer:t.feePayer||this.scope.ownerPubKey,amount:new ht(new yo(m.toFixed(0)).gte(m)?m.toFixed(0):m.add(1).toFixed(0))}:void 0,associatedOnly:c?!1:o,checkCreateATAOwner:r});d&&a.addInstruction(d),p||this.logAndCreateError("no money","ownerRewardAccount",this.scope.account.tokenAccountRawInfos);let f=await this.getClmmPoolKeys(e.id),y=Se.initRewardInstructions({poolInfo:e,poolKeys:f,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccount:p},rewardInfo:{programId:new H(n.mint.programId),mint:new H(n.mint.address),openTime:n.openTime,endTime:n.endTime,emissionsPerSecondX64:le.decimalToX64(n.perSecond)}});return a.addInstruction(y),a.addCustomComputeBudget(i),a.versionBuild({txVersion:s,extInfo:{address:y.address}})}async initRewards({poolInfo:e,poolKeys:t,ownerInfo:n,rewardInfos:o,associatedOnly:r=!0,checkCreateATAOwner:i=!1,computeBudgetConfig:s,txTipConfig:u,txVersion:a,feePayer:c}){for(let d of o)d.endTime<=d.openTime&&this.logAndCreateError("reward time error","rewardInfo",d);let m=this.createTxBuilder(c),p={};for(let d of o){let f=n.useSOLBalance&&d.mint.address===$.toString(),y=d.perSecond.mul(d.endTime-d.openTime),{account:b,instructionParams:g}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:new H(d.mint.programId),mint:new H(d.mint.address),notUseTokenAccount:!!f,skipCloseAccount:!f,owner:this.scope.ownerPubKey,createInfo:f?{payer:n.feePayer||this.scope.ownerPubKey,amount:new ht(new yo(y.toFixed(0)).gte(y)?y.toFixed(0):y.add(1).toFixed(0))}:void 0,associatedOnly:f?!1:r,checkCreateATAOwner:i});g&&m.addInstruction(g),b||this.logAndCreateError("no money","ownerRewardAccount",this.scope.account.tokenAccountRawInfos);let P=t!=null?t:await this.getClmmPoolKeys(e.id),h=Se.initRewardInstructions({poolInfo:e,poolKeys:P,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccount:b},rewardInfo:{programId:new H(d.mint.programId),mint:new H(d.mint.address),openTime:d.openTime,endTime:d.endTime,emissionsPerSecondX64:le.decimalToX64(d.perSecond)}});p=M(M({},p),h.address),m.addInstruction(h)}return m.addCustomComputeBudget(s),m.addTipInstruction(u),m.versionBuild({txVersion:a,extInfo:{address:p}})}async setReward({poolInfo:e,ownerInfo:t,rewardInfo:n,associatedOnly:o=!0,checkCreateATAOwner:r=!1,computeBudgetConfig:i,txTipConfig:s,txVersion:u,feePayer:a}){n.endTime<=n.openTime&&this.logAndCreateError("reward time error","rewardInfo",n);let c=this.createTxBuilder(a),m=t.useSOLBalance&&n.mint.equals($),{account:p,instructionParams:d}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:n.programId,mint:n.mint,notUseTokenAccount:m,owner:this.scope.ownerPubKey,createInfo:m?{payer:t.feePayer||this.scope.ownerPubKey,amount:new ht(new yo(n.perSecond.mul(n.endTime-n.openTime).toFixed(0)).gte(n.perSecond.mul(n.endTime-n.openTime))?n.perSecond.mul(n.endTime-n.openTime).toFixed(0):n.perSecond.mul(n.endTime-n.openTime).add(1).toFixed(0))}:void 0,associatedOnly:m?!1:o,checkCreateATAOwner:r});d&&c.addInstruction(d),p||this.logAndCreateError("no money","ownerRewardAccount",this.scope.account.tokenAccountRawInfos);let f=await this.getClmmPoolKeys(e.id),y=Se.setRewardInstructions({poolInfo:e,poolKeys:f,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccount:p},rewardInfo:{mint:n.mint,openTime:n.openTime,endTime:n.endTime,emissionsPerSecondX64:le.decimalToX64(n.perSecond)}});return c.addInstruction(y),c.addCustomComputeBudget(i),c.addTipInstruction(s),c.versionBuild({txVersion:u,extInfo:{address:y.address}})}async setRewards({poolInfo:e,poolKeys:t,ownerInfo:n,rewardInfos:o,associatedOnly:r=!0,checkCreateATAOwner:i=!1,computeBudgetConfig:s,txTipConfig:u,txVersion:a,feePayer:c}){let m=this.createTxBuilder(c),p={};for(let d of o){d.endTime<=d.openTime&&this.logAndCreateError("reward time error","rewardInfo",d);let f=n.useSOLBalance&&d.mint.address===$.toString(),{account:y,instructionParams:b}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:new H(d.mint.programId),mint:new H(d.mint.address),notUseTokenAccount:f,owner:this.scope.ownerPubKey,createInfo:f?{payer:n.feePayer||this.scope.ownerPubKey,amount:new ht(new yo(d.perSecond.mul(d.endTime-d.openTime).toFixed(0)).gte(d.perSecond.mul(d.endTime-d.openTime))?d.perSecond.mul(d.endTime-d.openTime).toFixed(0):d.perSecond.mul(d.endTime-d.openTime).add(1).toFixed(0))}:void 0,associatedOnly:f?!1:r,checkCreateATAOwner:i});b&&m.addInstruction(b),y||this.logAndCreateError("no money","ownerRewardAccount",this.scope.account.tokenAccountRawInfos);let g=t!=null?t:await this.getClmmPoolKeys(e.id),P=Se.setRewardInstructions({poolInfo:e,poolKeys:g,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccount:y},rewardInfo:{mint:new H(d.mint.address),openTime:d.openTime,endTime:d.endTime,emissionsPerSecondX64:le.decimalToX64(d.perSecond)}});m.addInstruction(P),p=M(M({},p),P.address)}return m.addCustomComputeBudget(s),m.addTipInstruction(u),m.versionBuild({txVersion:a,extInfo:{address:p}})}async collectReward({poolInfo:e,ownerInfo:t,rewardMint:n,associatedOnly:o=!0,checkCreateATAOwner:r=!1,computeBudgetConfig:i,txTipConfig:s,txVersion:u,feePayer:a}){let c=e.rewardDefaultInfos.find(g=>g.mint.address===n.toString());c||this.logAndCreateError("reward mint error","not found reward mint",n);let m=this.createTxBuilder(a),p=t.useSOLBalance&&n.equals($),{account:d,instructionParams:f}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:new H(c.mint.programId),mint:n,notUseTokenAccount:p,owner:this.scope.ownerPubKey,skipCloseAccount:!p,createInfo:{payer:t.feePayer||this.scope.ownerPubKey,amount:0},associatedOnly:p?!1:o,checkCreateATAOwner:r});f&&m.addInstruction(f),d||this.logAndCreateError("no money","ownerRewardAccount",this.scope.account.tokenAccountRawInfos);let y=await this.getClmmPoolKeys(e.id),b=Se.collectRewardInstructions({poolInfo:e,poolKeys:y,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccount:d},rewardMint:n});return m.addInstruction(b),m.addCustomComputeBudget(i),m.addTipInstruction(s),m.versionBuild({txVersion:u,extInfo:{address:b.address}})}async collectRewards({poolInfo:e,ownerInfo:t,rewardMints:n,associatedOnly:o=!0,checkCreateATAOwner:r=!1,computeBudgetConfig:i,txTipConfig:s,feePayer:u}){let a=this.createTxBuilder(u),c={};for(let m of n){let p=e.rewardDefaultInfos.find(P=>P.mint.address===m.toString());if(!p){this.logAndCreateError("reward mint error","not found reward mint",m);continue}let d=t.useSOLBalance&&m.equals($),{account:f,instructionParams:y}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:new H(p.mint.programId),mint:m,notUseTokenAccount:d,owner:this.scope.ownerPubKey,skipCloseAccount:!d,createInfo:{payer:t.feePayer||this.scope.ownerPubKey,amount:0},associatedOnly:d?!1:o,checkCreateATAOwner:r});f||this.logAndCreateError("no money","ownerRewardAccount",this.scope.account.tokenAccountRawInfos),y&&a.addInstruction(y);let b=await this.getClmmPoolKeys(e.id),g=Se.collectRewardInstructions({poolInfo:e,poolKeys:b,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccount:f},rewardMint:m});a.addInstruction(g),c=M(M({},c),g.address)}return a.addCustomComputeBudget(i),a.addTipInstruction(s),a.build({address:c})}async swap({poolInfo:e,poolKeys:t,inputMint:n,amountIn:o,amountOutMin:r,priceLimit:i,observationId:s,ownerInfo:u,remainingAccounts:a,associatedOnly:c=!0,checkCreateATAOwner:m=!1,txVersion:p,computeBudgetConfig:d,txTipConfig:f,feePayer:y}){let b=this.createTxBuilder(y),g=n.toString()===e.mintA.address,P=u.useSOLBalance&&e.mintA.address===$.toBase58(),h=u.useSOLBalance&&e.mintB.address===$.toBase58(),I;!i||i.equals(new yo(0))?I=g?Gt.add(new ht(1)):Xt.sub(new ht(1)):I=se.priceToSqrtPriceX64(i,e.mintA.decimals,e.mintB.decimals);let T;if(!T){let{account:x,instructionParams:S}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:e.mintA.programId,mint:new H(e.mintA.address),notUseTokenAccount:P,owner:this.scope.ownerPubKey,skipCloseAccount:!P,createInfo:P||!g?{payer:u.feePayer||this.scope.ownerPubKey,amount:g?o:0}:void 0,associatedOnly:P?!1:c,checkCreateATAOwner:m});T=x,S&&b.addInstruction(S)}let w;if(!w){let{account:x,instructionParams:S}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:e.mintB.programId,mint:new H(e.mintB.address),notUseTokenAccount:h,owner:this.scope.ownerPubKey,skipCloseAccount:!h,createInfo:h||g?{payer:u.feePayer||this.scope.ownerPubKey,amount:g?0:o}:void 0,associatedOnly:h?!1:c,checkCreateATAOwner:m});w=x,S&&b.addInstruction(S)}(!T||!w)&&this.logAndCreateError("user do not have token account",{tokenA:e.mintA.symbol||e.mintA.address,tokenB:e.mintB.symbol||e.mintB.address,ownerTokenAccountA:T,ownerTokenAccountB:w,mintAUseSOLBalance:P,mintBUseSOLBalance:h,associatedOnly:c});let K=t!=null?t:await this.getClmmPoolKeys(e.id);return b.addInstruction(Se.makeSwapBaseInInstructions({poolInfo:e,poolKeys:K,observationId:s,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccountA:T,tokenAccountB:w},inputMint:new H(n),amountIn:o,amountOutMin:r,sqrtPriceLimitX64:I,remainingAccounts:a})),b.addCustomComputeBudget(d),b.addTipInstruction(f),b.versionBuild({txVersion:p})}async swapBaseOut({poolInfo:e,poolKeys:t,outputMint:n,amountOut:o,amountInMax:r,priceLimit:i,observationId:s,ownerInfo:u,remainingAccounts:a,associatedOnly:c=!0,checkCreateATAOwner:m=!1,txVersion:p,computeBudgetConfig:d,txTipConfig:f,feePayer:y}){let b=this.createTxBuilder(y),g=n.toString()===e.mintB.address,P=u.useSOLBalance&&e.mintA.address===$.toBase58(),h=u.useSOLBalance&&e.mintB.address===$.toBase58(),I;!i||i.equals(new yo(0))?I=n.toString()===e.mintB.address?Gt.add(new ht(1)):Xt.sub(new ht(1)):I=se.priceToSqrtPriceX64(i,e.mintA.decimals,e.mintB.decimals);let T;if(!T){let{account:x,instructionParams:S}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:e.mintA.programId,mint:new H(e.mintA.address),notUseTokenAccount:P,owner:this.scope.ownerPubKey,skipCloseAccount:!P,createInfo:P||!g?{payer:u.feePayer||this.scope.ownerPubKey,amount:g?r:0}:void 0,associatedOnly:P?!1:c,checkCreateATAOwner:m});T=x,S&&b.addInstruction(S)}let w;if(!w){let{account:x,instructionParams:S}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:e.mintB.programId,mint:new H(e.mintB.address),notUseTokenAccount:h,owner:this.scope.ownerPubKey,skipCloseAccount:!h,createInfo:h||g?{payer:u.feePayer||this.scope.ownerPubKey,amount:g?0:r}:void 0,associatedOnly:h?!1:c,checkCreateATAOwner:m});w=x,S&&b.addInstruction(S)}(!T||!w)&&this.logAndCreateError("user do not have token account",{tokenA:e.mintA.symbol||e.mintA.address,tokenB:e.mintB.symbol||e.mintB.address,ownerTokenAccountA:T,ownerTokenAccountB:w,mintAUseSOLBalance:P,mintBUseSOLBalance:h,associatedOnly:c});let K=t!=null?t:await this.getClmmPoolKeys(e.id);return b.addInstruction(Se.makeSwapBaseOutInstructions({poolInfo:e,poolKeys:K,observationId:s,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccountA:T,tokenAccountB:w},outputMint:new H(n),amountOut:o,amountInMax:r,sqrtPriceLimitX64:I,remainingAccounts:a})),b.addCustomComputeBudget(d),b.addTipInstruction(f),b.versionBuild({txVersion:p})}async harvestAllRewards({allPoolInfo:e,allPositions:t,lockInfo:n,ownerInfo:o,associatedOnly:r=!0,checkCreateATAOwner:i=!1,programId:s,txVersion:u,computeBudgetConfig:a,feePayer:c,lockProgram:m=xo,lockAuth:p=oi,clmmProgram:d=Nn}){var h,I;let f={};for(let T of this.scope.account.tokenAccountRawInfos)r?j(this.scope.ownerPubKey,T.accountInfo.mint,s).publicKey.equals(T.pubkey)&&(f[T.accountInfo.mint.toString()]=T.pubkey):f[T.accountInfo.mint.toString()]=T.pubkey;let y=Object.values(t).flat().map(T=>T.nftMint),b=await Ne(this.scope.connection,y.map(T=>({pubkey:T}))),g={};b.forEach(T=>{var w,K;g[T.pubkey.toBase58()]=(K=(w=T==null?void 0:T.accountInfo)==null?void 0:w.owner)!=null?K:null});let P=this.createTxBuilder(c);for(let T of Object.values(e)){if(t[T.id]===void 0||!t[T.id].find(L=>!L.liquidity.isZero()||L.rewardInfos.find(N=>!N.rewardAmountOwed.isZero())))continue;let w=T,K=o.useSOLBalance&&w.mintA.address===$.toString(),x=o.useSOLBalance&&w.mintB.address===$.toString(),S=f[w.mintA.address];if(!S)if(K){let{account:L,instructionParams:N}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:w.mintA.programId,mint:new H(w.mintA.address),notUseTokenAccount:K,owner:this.scope.ownerPubKey,skipCloseAccount:!K,createInfo:{payer:o.feePayer||this.scope.ownerPubKey,amount:0},associatedOnly:K?!1:r,checkCreateATAOwner:i});S=L,N&&P.addInstruction(N)}else{let L=new H(w.mintA.address);S=this.scope.account.getAssociatedTokenAccount(L,new H(w.mintA.programId)),P.addInstruction({instructions:[kl(this.scope.ownerPubKey,S,this.scope.ownerPubKey,L,new H(w.mintA.programId))]})}let B=f[w.mintB.address];if(!B)if(x){let{account:L,instructionParams:N}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:w.mintB.programId,mint:new H(w.mintB.address),notUseTokenAccount:x,owner:this.scope.ownerPubKey,skipCloseAccount:!x,createInfo:{payer:o.feePayer||this.scope.ownerPubKey,amount:0},associatedOnly:x?!1:r,checkCreateATAOwner:i});B=L,N&&P.addInstruction(N)}else{let L=new H(w.mintB.address);B=this.scope.account.getAssociatedTokenAccount(L,new H(w.mintB.programId)),P.addInstruction({instructions:[kl(this.scope.ownerPubKey,B,this.scope.ownerPubKey,L,new H(w.mintB.programId))]})}f[w.mintA.address]=S,f[w.mintB.address]=B;let R=[];for(let L of w.rewardDefaultInfos){let N=o.useSOLBalance&&L.mint.address===$.toString(),E=f[L.mint.address];if(!E){let{account:X,instructionParams:Q}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:new H(L.mint.programId),mint:new H(L.mint.address),notUseTokenAccount:N,owner:this.scope.ownerPubKey,skipCloseAccount:!N,createInfo:{payer:o.feePayer||this.scope.ownerPubKey,amount:0},associatedOnly:N?!1:r});E=X,Q&&P.addInstruction(Q)}f[L.mint.address]=E,R.push(E)}let C=await this.getClmmPoolKeys(w.id),v=[];for(let L=0;L<C.rewardInfos.length;L++)v.push({poolRewardVault:new H(C.rewardInfos[L].vault),ownerRewardVault:R[L],rewardMint:new H(C.rewardInfos[L].mint.address)});for(let L of t[T.id]){let N=(h=n==null?void 0:n[T.id])==null?void 0:h[L.nftMint.toBase58()];if(N){let E=j(this.scope.ownerPubKey,N.lockNftMint,Fi).publicKey,X=Z.getTickArrayStartIndexByTick(L.tickLower,C.config.tickSpacing),Q=Z.getTickArrayStartIndexByTick(L.tickUpper,C.config.tickSpacing),{publicKey:ee}=Pe(new H(C.programId),N.poolId,X),{publicKey:me}=Pe(new H(C.programId),N.poolId,Q),{publicKey:re}=nn(new H(C.programId),N.poolId,L.tickLower,L.tickUpper),ue=Mo(m,N.lockNftMint).publicKey,be=Se.harvestLockPositionInstructionV2({programId:m,auth:p,lockPositionId:ue,clmmProgram:d,lockOwner:this.scope.ownerPubKey,lockNftMint:N.lockNftMint,lockNftAccount:E,positionNftAccount:N.nftAccount,positionId:N.positionId,poolId:N.poolId,protocolPosition:re,vaultA:new H(C.vault.A),vaultB:new H(C.vault.B),tickArrayLower:ee,tickArrayUpper:me,userVaultA:S,userVaultB:B,mintA:new H(C.mintA.address),mintB:new H(C.mintB.address),rewardAccounts:v,exTickArrayBitmap:He(d,N.poolId).publicKey});P.addInstruction({instructions:[be],instructionTypes:[G.ClmmHarvestLockPosition],lookupTableAddress:C.lookupTableAccount?[C.lookupTableAccount]:[]})}else{let E=Se.decreaseLiquidityInstructions({poolInfo:w,poolKeys:C,ownerPosition:L,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccountA:S,tokenAccountB:B,rewardAccounts:R},liquidity:new ht(0),amountMinA:new ht(0),amountMinB:new ht(0),nft2022:(I=g[L.nftMint.toBase58()])==null?void 0:I.equals(Xn)});P.addInstruction(E)}}}return u===0?P.sizeCheckBuildV0({computeBudgetConfig:a}):P.sizeCheckBuild({computeBudgetConfig:a})}async getWhiteListMint({programId:e}){let t=await this.scope.connection.getAccountInfo(Bi(e).publicKey);return t?jc.decode(t.data).whitelistMints.filter(o=>!o.equals(H.default)):[]}async getOwnerPositionInfo({programId:e=Nn}){await this.scope.account.fetchWalletTokenAccounts();let n=this.scope.account.tokenAccountRawInfos.filter(i=>i.accountInfo.amount.eq(new ht(1))).map(i=>Tt(new H(e),i.accountInfo.mint).publicKey),o=await this.scope.connection.getMultipleAccountsInfo(n),r=[];return o.forEach(i=>{if(!i)return;let s=vo.decode(i.data);r.push(s)}),r}async getOwnerLockedPositionInfo({programId:e=xo}){await this.scope.account.fetchWalletTokenAccounts();let n=this.scope.account.tokenAccountRawInfos.filter(u=>u.accountInfo.amount.eq(new ht(1))).map(u=>Mo(new H(e),u.accountInfo.mint).publicKey),o=await this.scope.connection.getMultipleAccountsInfo(n),r=[];o.forEach(u=>{if(!u)return;let a=$c.decode(u.data);r.push(a)});let i=await this.scope.connection.getMultipleAccountsInfo(r.map(u=>u.positionId)),s=[];return i.forEach(u=>{if(!u)return;let a=vo.decode(u.data);s.push(a)}),r.map((u,a)=>({position:s[a],lockInfo:u}))}async getRpcClmmPoolInfo({poolId:e}){return(await this.getRpcClmmPoolInfos({poolIds:[e]}))[String(e)]}async getRpcClmmPoolInfos({poolIds:e,config:t}){let n=await Ne(this.scope.connection,e.map(r=>({pubkey:new H(r)})),t),o={};for(let r=0;r<e.length;r++){let i=n[r];if(i===null||!i.accountInfo)throw Error("fetch pool info error: "+String(e[r]));let s=ao.decode(i.accountInfo.data),u=se.sqrtPriceX64ToPrice(s.sqrtPriceX64,s.mintDecimalsA,s.mintDecimalsB).toNumber();o[String(e[r])]=q(M({},s),{currentPrice:u,programId:i.accountInfo.owner})}return o}async getComputeClmmPoolInfos({clmmPoolsRpcInfo:e,mintInfos:t}){let n=new Set(Object.keys(e).map(u=>e[u].ammConfig.toBase58())),o=await Ne(this.scope.connection,Array.from(n).map(u=>({pubkey:new H(u)}))),r={};o.forEach(u=>{!u.accountInfo||(r[u.pubkey.toBase58()]=Qc.decode(u.accountInfo.data))});let i=await ve.fetchComputeMultipleClmmInfo({connection:this.scope.connection,rpcDataMap:e,poolList:Object.keys(e).map(u=>{var m,p,d,f;let[a,c]=[e[u].mintA.toBase58(),e[u].mintB.toBase58()];return{id:u,programId:e[u].programId.toBase58(),mintA:yt({address:a,decimals:e[u].mintDecimalsA,programId:t[a].programId.toBase58()||Fi.toBase58(),extensions:{feeConfig:(m=t[a])!=null&&m.feeConfig?Un((p=t[a])==null?void 0:p.feeConfig):void 0}}),mintB:yt({address:c,decimals:e[u].mintDecimalsB,programId:t[c].programId.toBase58()||Fi.toBase58(),extensions:{feeConfig:(d=t[c])!=null&&d.feeConfig?Un((f=t[c])==null?void 0:f.feeConfig):void 0}}),price:e[u].currentPrice,config:q(M({},r[e[u].ammConfig.toBase58()]),{id:e[u].ammConfig.toBase58(),fundFeeRate:0,description:"",defaultRange:0,defaultRangePoint:[]})}})}),s=await ve.fetchMultiplePoolTickArrays({connection:this.scope.connection,poolKeys:Object.values(i)});return{computeClmmPoolInfo:i,computePoolTickData:s}}async getPoolInfoFromRpc(e){var c;let t=await this.getRpcClmmPoolInfo({poolId:e}),n=new Set([t.mintA.toBase58(),t.mintB.toBase58()]),o=await Io({connection:this.scope.connection,mints:Array.from(n).map(m=>new H(m))}),{computeClmmPoolInfo:r,computePoolTickData:i}=await this.scope.clmm.getComputeClmmPoolInfos({clmmPoolsRpcInfo:{[e]:t},mintInfos:o}),s=await Ne(this.scope.connection,[{pubkey:t.vaultA},{pubkey:t.vaultB}]),u=zc(r[e]);if(!s[0].accountInfo||!s[1].accountInfo)throw new Error("pool vault data not found");u.mintAmountA=Number(Al.decode(s[0].accountInfo.data).amount.toString()),u.mintAmountB=Number(Al.decode((c=s[1].accountInfo)==null?void 0:c.data).amount.toString());let a=q(M({},r[e]),{exBitmapAccount:r[e].exBitmapAccount.toBase58(),observationId:r[e].observationId.toBase58(),id:e,programId:t.programId.toBase58(),openTime:t.startTime.toString(),vault:{A:t.vaultA.toBase58(),B:t.vaultB.toBase58()},config:u.config,rewardInfos:r[e].rewardInfos.filter(m=>!m.tokenVault.equals(H.default)).map(m=>({mint:yt({address:m.tokenMint.toBase58(),programId:Fi.toBase58(),decimals:10}),vault:m.tokenVault.toBase58()}))});return{poolInfo:u,poolKeys:a,computePoolInfo:r[e],tickData:i}}};import{PublicKey as U}from"@solana/web3.js";import{AccountLayout as sf,NATIVE_MINT as Do,TOKEN_PROGRAM_ID as It,createAssociatedTokenAccountIdempotentInstruction as qo}from"@solana/spl-token";import Tl from"bn.js";import Yr from"bn.js";function Da(l,e){if(e.isZero())throw Error("divisor is zero");return l.mod(e)}function qp(l,e){if(e.isZero())throw Error("rhs is zero");let t=l.div(e);return Da(l,e).gt(_i)&&(t=t.add(new Yr(1))),[t,e]}var _i=new Yr(0),Ei=class{static swapBaseInputWithoutFees(e,t,n){let o=e.mul(n),r=t.add(e);return o.div(r)}static swapBaseOutputWithoutFees(e,t,n){let o=t.mul(e),r=n.sub(e),[i]=qp(o,r);return i}static lpTokensToTradingTokens(e,t,n,o,r){let i=e.mul(n).div(t),s=e.mul(o).div(t);if(r===0)return{tokenAmount0:i,tokenAmount1:s};if(r===1)return Da(e.mul(n),t).gt(_i)&&i.gt(_i)&&(i=i.add(new Yr(1))),Da(e.mul(o),t).gt(_i)&&s.gt(_i)&&(s=s.add(new Yr(1))),{tokenAmount0:i,tokenAmount1:s};throw Error("roundDirection value error")}};import Up from"bn.js";var Rt=class{static tradingFee(e,t){return Zo(e,t,Kt)}static protocolFee(e,t){return fr(e,t,Kt)}static fundFee(e,t){return fr(e,t,Kt)}static creatorFee(e,t){return Zo(e,t,Kt)}static splitCreatorFee(e,t,n){return fr(e,n,t.add(n))}static calculatePreFeeAmount(e,t){if(t.isZero())return e;let n=e.mul(Kt),o=Kt.sub(t);return n.add(o).sub(new Up(1)).div(o)}};var wl=(t=>(t[t.Floor=0]="Floor",t[t.Ceiling=1]="Ceiling",t))(wl||{}),Gp=(t=>(t[t.ZeroForOne=0]="ZeroForOne",t[t.OneForZero=1]="OneForZero",t))(Gp||{}),Xp=(t=>(t[t.OneForZero=0]="OneForZero",t[t.ZeroForOne=1]="ZeroForOne",t))(Xp||{}),Wi=class{static validate_supply(e,t){if(e.isZero())throw Error("tokenAmount0 is zero");if(t.isZero())throw Error("tokenAmount1 is zero")}static swapBaseInput(e,t,n,o,r,i,s,u){let a=new Tl(0),c=Rt.tradingFee(e,o),m;u?(a=Rt.creatorFee(e,r),m=e.sub(c).sub(a)):m=e.sub(c);let p=Rt.protocolFee(c,i),d=Rt.protocolFee(c,s),f=Ei.swapBaseInputWithoutFees(m,t,n),y;return u?y=f:(a=Rt.creatorFee(f,r),y=f.sub(a)),{newInputVaultAmount:t.add(m),newOutputVaultAmount:n.sub(f),inputAmount:e,outputAmount:y,tradeFee:c,protocolFee:p,fundFee:d,creatorFee:a}}static swapBaseOutput(e,t,n,o,r,i,s,u){let a,c=new Tl(0),m;if(u)m=e;else{let b=Rt.calculatePreFeeAmount(e,r);c=b.sub(e),m=b}let p=Ei.swapBaseOutputWithoutFees(m,t,n),d;if(u){let b=Rt.calculatePreFeeAmount(p,o.add(r)),g=b.sub(p);c=Rt.splitCreatorFee(g,o,r),a=g.sub(c),d=b}else{let b=Rt.calculatePreFeeAmount(p,o);a=b.sub(p),d=b}let f=Rt.protocolFee(a,i),y=Rt.fundFee(a,s);return{newInputVaultAmount:t.add(p),newOutputVaultAmount:e.sub(m),inputAmount:d,outputAmount:e,tradeFee:a,protocolFee:f,fundFee:y,creatorFee:c}}};import Xe from"bn.js";import zt from"decimal.js";import{PublicKey as Ui,TransactionInstruction as Kn,Keypair as nf,SystemProgram as Ga}from"@solana/web3.js";import{ASSOCIATED_TOKEN_PROGRAM_ID as Qr,TOKEN_2022_PROGRAM_ID as Xa,TOKEN_PROGRAM_ID as xn}from"@solana/spl-token";var zp=Buffer.from("vault_and_lp_mint_auth_seed","utf8"),Yp=Buffer.from("amm_config","utf8"),Qp=Buffer.from("pool","utf8"),Hp=Buffer.from("pool_lp_mint","utf8"),jp=Buffer.from("pool_vault","utf8"),$p=Buffer.from("observation","utf8"),Zp=Buffer.from("permission","utf8");function Wo(l){return te([zp],l)}function xx(l,e){return te([Yp,ef(e)],l)}function qa(l,e,t,n){return te([Qp,e.toBuffer(),t.toBuffer(),n.toBuffer()],l)}function Jp(l,e){return te([Hp,e.toBuffer()],l)}function hl(l,e,t){return te([jp,e.toBuffer(),t.toBuffer()],l)}function Di(l,e){return te([$p,e.toBuffer()],l)}function ef(l){let e=new ArrayBuffer(2);return new DataView(e).setUint16(0,l,!1),new Uint8Array(e)}function Ua({poolId:l,programId:e,configId:t,mintA:n,mintB:o}){let r=Wo(e).publicKey,i=l||qa(e,t,n,o).publicKey,s=Jp(e,i).publicKey,u=hl(e,i,n).publicKey,a=hl(e,i,o).publicKey,c=Di(e,i).publicKey;return{poolId:i,configId:t,authority:r,lpMint:s,vaultA:u,vaultB:a,observationId:c}}var tf=Buffer.from("locked_liquidity","utf8");function qi(l,e){return te([tf,e.toBuffer()],l)}function Il(l,e){return te([Zp,e.toBuffer()],l)}var of=ye("Raydium_cpmm"),Sn={initialize:[175,175,109,31,13,152,155,237],deposit:[242,35,198,137,82,225,242,182],withdraw:[183,18,70,156,148,109,161,34],swapBaseInput:[143,190,90,218,196,30,51,222],swapBaseOutput:[55,217,98,86,163,74,180,173],lockCpLiquidity:[216,157,29,78,38,51,31,26],collectCpFee:[8,30,51,199,209,184,247,133],createPermissionPda:Buffer.from([135,136,2,216,137,169,181,202]),closePermissionPda:Buffer.from([156,84,32,118,69,135,70,123]),initializeWithPermission:Buffer.from([63,55,254,65,49,178,89,121]),collectCreatorFee:Buffer.from([20,22,86,123,198,28,219,132])};function Bl(l,e,t,n,o,r,i,s,u,a,c,m,p,d,f,y,b,g,P,h){let I=F([A("amountMaxA"),A("amountMaxB"),A("openTime")]),T=qa(l,t,r,i).publicKey,w=[{pubkey:e,isSigner:!0,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!o.equals(T),isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!1},{pubkey:i,isSigner:!1,isWritable:!1},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:m,isSigner:!1,isWritable:!0},{pubkey:p,isSigner:!1,isWritable:!0},{pubkey:d,isSigner:!1,isWritable:!0},{pubkey:b,isSigner:!1,isWritable:!0},{pubkey:xn,isSigner:!1,isWritable:!1},{pubkey:f,isSigner:!1,isWritable:!1},{pubkey:y,isSigner:!1,isWritable:!1},{pubkey:Qr,isSigner:!1,isWritable:!1},{pubkey:mr,isSigner:!1,isWritable:!1},{pubkey:$e,isSigner:!1,isWritable:!1}],K=Buffer.alloc(I.span);return I.encode({amountMaxA:g,amountMaxB:P,openTime:h},K),new Kn({keys:w,programId:l,data:Buffer.from([...Sn.initialize,...K])})}function xl(l,e,t,n,o,r,i,s,u,a,c,m,p,d,f){let y=F([A("lpAmount"),A("amountMaxA"),A("amountMaxB")]),b=[{pubkey:e,isSigner:!0,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:xn,isSigner:!1,isWritable:!1},{pubkey:Xa,isSigner:!1,isWritable:!1},{pubkey:a,isSigner:!1,isWritable:!1},{pubkey:c,isSigner:!1,isWritable:!1},{pubkey:m,isSigner:!1,isWritable:!0}],g=Buffer.alloc(y.span);return of.debug("cpmm deposit data",{lpAmount:p.toString(),amountMaxA:d.toString(),amountMaxB:f.toString()}),y.encode({lpAmount:p,amountMaxA:d,amountMaxB:f},g),new Kn({keys:b,programId:l,data:Buffer.from([...Sn.deposit,...g])})}function Kl(l,e,t,n,o,r,i,s,u,a,c,m,p,d,f){let y=F([A("lpAmount"),A("amountMinA"),A("amountMinB")]),b=[{pubkey:e,isSigner:!0,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:xn,isSigner:!1,isWritable:!1},{pubkey:Xa,isSigner:!1,isWritable:!1},{pubkey:a,isSigner:!1,isWritable:!1},{pubkey:c,isSigner:!1,isWritable:!1},{pubkey:m,isSigner:!1,isWritable:!0},{pubkey:an,isSigner:!1,isWritable:!1}],g=Buffer.alloc(y.span);return y.encode({lpAmount:p,amountMinA:d,amountMinB:f},g),new Kn({keys:b,programId:l,data:Buffer.from([...Sn.withdraw,...g])})}function Hr(l,e,t,n,o,r,i,s,u,a,c,m,p,d,f,y){let b=F([A("amountIn"),A("amounOutMin")]),g=[{pubkey:e,isSigner:!0,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!1},{pubkey:c,isSigner:!1,isWritable:!1},{pubkey:m,isSigner:!1,isWritable:!1},{pubkey:p,isSigner:!1,isWritable:!1},{pubkey:d,isSigner:!1,isWritable:!0}],P=Buffer.alloc(b.span);return b.encode({amountIn:f,amounOutMin:y},P),new Kn({keys:g,programId:l,data:Buffer.from([...Sn.swapBaseInput,...P])})}function Sl(l,e,t,n,o,r,i,s,u,a,c,m,p,d,f,y){let b=F([A("amountInMax"),A("amountOut")]),g=[{pubkey:e,isSigner:!0,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!1},{pubkey:c,isSigner:!1,isWritable:!1},{pubkey:m,isSigner:!1,isWritable:!1},{pubkey:p,isSigner:!1,isWritable:!1},{pubkey:d,isSigner:!1,isWritable:!0}],P=Buffer.alloc(b.span);return b.encode({amountInMax:f,amountOut:y},P),new Kn({keys:g,programId:l,data:Buffer.from([...Sn.swapBaseOutput,...P])})}async function Cl(l){var b;let{ownerInfo:e,poolInfo:t,poolKeys:n,feeNftOwner:o,getEphemeralSigners:r}=l,i=[],[s,u]=[new Ui(t.id),new Ui(t.lpMint.address)],a;if(r)a=new Ui((await r(1))[0]);else{let g=nf.generate();i.push(g),a=g.publicKey}let{publicKey:c}=j(o,a,xn),{publicKey:m}=Tn(a),{publicKey:p}=qi(l.lockProgram,a),{publicKey:d}=j(e.wallet,u,xn),{publicKey:f}=j(l.lockAuthProgram,u,xn),y=rf({programId:l.lockProgram,auth:l.lockAuthProgram,payer:e.feePayer,liquidityOwner:e.wallet,nftOwner:o,nftMint:a,nftAccount:c,poolId:s,lockPda:p,mintLp:u,userLpVault:d,lockLpVault:f,poolVaultA:new Ui(n.vault.A),poolVaultB:new Ui(n.vault.B),metadataAccount:m,lpAmount:l.lpAmount,withMetadata:(b=l.withMetadata)!=null?b:!0});return{address:{nftMint:a,nftAccount:c,metadataAccount:m,lockPda:p,userLpVault:d,lockLpVault:f},instructions:[y],signers:i,instructionTypes:[G.CpmmLockLp],lookupTableAddress:[]}}function rf({programId:l,auth:e,payer:t,liquidityOwner:n,nftOwner:o,nftMint:r,nftAccount:i,poolId:s,lockPda:u,mintLp:a,userLpVault:c,lockLpVault:m,poolVaultA:p,poolVaultB:d,metadataAccount:f,lpAmount:y,withMetadata:b}){let g=[{pubkey:e,isSigner:!1,isWritable:!1},{pubkey:t,isSigner:!0,isWritable:!0},{pubkey:n,isSigner:!0,isWritable:!1},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!0,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!1},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!1},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:m,isSigner:!1,isWritable:!0},{pubkey:p,isSigner:!1,isWritable:!0},{pubkey:d,isSigner:!1,isWritable:!0},{pubkey:f,isSigner:!1,isWritable:!0},{pubkey:$e,isSigner:!1,isWritable:!1},{pubkey:Ga.programId,isSigner:!1,isWritable:!1},{pubkey:xn,isSigner:!1,isWritable:!1},{pubkey:Qr,isSigner:!1,isWritable:!1},{pubkey:Dt,isSigner:!1,isWritable:!1}],P=F([A("lpAmount"),De("withMetadata")]),h=Buffer.alloc(P.span);P.encode({lpAmount:y,withMetadata:b},h);let I=Buffer.from([...Sn.lockCpLiquidity,...h]);return new Kn({keys:g,programId:l,data:I})}function za({programId:l,nftOwner:e,auth:t,nftAccount:n,lockPda:o,poolId:r,mintLp:i,userVaultA:s,userVaultB:u,poolVaultA:a,poolVaultB:c,mintA:m,mintB:p,lockLpVault:d,lpFeeAmount:f,cpmmProgram:y,cpmmAuthProgram:b}){let g=[{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:e,isSigner:!0,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:y!=null?y:vn,isSigner:!1,isWritable:!1},{pubkey:b!=null?b:Os,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:m,isSigner:!1,isWritable:!1},{pubkey:p,isSigner:!1,isWritable:!1},{pubkey:d,isSigner:!1,isWritable:!0},{pubkey:xn,isSigner:!1,isWritable:!1},{pubkey:Xa,isSigner:!1,isWritable:!1},{pubkey:an,isSigner:!1,isWritable:!1}],P=F([A("lpFeeAmount")]),h=Buffer.alloc(P.span);P.encode({lpFeeAmount:f},h);let I=Buffer.from([...Sn.collectCpFee,...h]);return new Kn({keys:g,programId:l,data:I})}function Ya(l,e,t,n,o,r,i,s,u,a,c,m,p){let d=[{pubkey:e,isSigner:!0,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!1},{pubkey:u,isSigner:!1,isWritable:!1},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:m,isSigner:!1,isWritable:!1},{pubkey:p,isSigner:!1,isWritable:!1},{pubkey:Qr,isSigner:!1,isWritable:!1},{pubkey:Ga.programId,isSigner:!1,isWritable:!1}];return new Kn({keys:d,programId:l,data:Sn.collectCreatorFee})}function Rl(l,e,t,n,o,r,i,s,u,a,c,m,p,d,f,y,b,g,P,h,I,T,w){let K=F([A("amountA"),A("amountB"),A("openTime"),_("feeOn")]),x=[{pubkey:e,isSigner:!0,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!1},{pubkey:s,isSigner:!1,isWritable:!1},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:m,isSigner:!1,isWritable:!0},{pubkey:p,isSigner:!1,isWritable:!0},{pubkey:d,isSigner:!1,isWritable:!0},{pubkey:f,isSigner:!1,isWritable:!0},{pubkey:g,isSigner:!1,isWritable:!0},{pubkey:P,isSigner:!1,isWritable:!0},{pubkey:xn,isSigner:!1,isWritable:!1},{pubkey:y,isSigner:!1,isWritable:!1},{pubkey:b,isSigner:!1,isWritable:!1},{pubkey:Qr,isSigner:!1,isWritable:!1},{pubkey:Ga.programId,isSigner:!1,isWritable:!1}],S=Buffer.alloc(K.span);return K.encode({amountA:h,amountB:I,openTime:T,feeOn:w},S),new Kn({keys:x,programId:l,data:Buffer.from([...Sn.initializeWithPermission,...S])})}var Ll=F([Te(8),_("bump"),De("disableCreatePool"),Ft("index"),A("tradeFeeRate"),A("protocolFeeRate"),A("fundFeeRate"),A("createPoolFee"),O("protocolOwner"),O("fundOwner"),A("creatorFeeRate"),Y(A(),15)]),jr=F([Te(8),O("configId"),O("poolCreator"),O("vaultA"),O("vaultB"),O("mintLp"),O("mintA"),O("mintB"),O("mintProgramA"),O("mintProgramB"),O("observationId"),_("bump"),_("status"),_("lpDecimals"),_("mintDecimalA"),_("mintDecimalB"),A("lpAmount"),A("protocolFeesMintA"),A("protocolFeesMintB"),A("fundFeesMintA"),A("fundFeesMintB"),A("openTime"),A("epoch"),_("feeOn"),De("enableCreatorFee"),Y(_(),6),A("creatorFeesMintA"),A("creatorFeesMintB"),Y(A(),28)]),Ex=F([Te(8),O("configId"),Y(A(),30)]);var Ol=(n=>(n[n.BothToken=0]="BothToken",n[n.OnlyTokenA=1]="OnlyTokenA",n[n.OnlyTokenB=2]="OnlyTokenB",n))(Ol||{});var Gi=class extends Ee{constructor(e){super(e)}async load(){this.checkDisabled()}async getCpmmPoolKeys(e){return(await this.scope.api.fetchPoolKeysById({idList:[e]}))[0]}async getRpcPoolInfo(e,t){return(await this.getRpcPoolInfos([e],t))[e]}async getRpcPoolInfos(e,t){let n=await Ne(this.scope.connection,e.map(m=>({pubkey:new U(m)}))),o={},r=new Set,i=[];for(let m=0;m<e.length;m++){let p=n[m];if(p.accountInfo===null)throw Error("fetch pool info error: "+String(e[m]));let d=jr.decode(p.accountInfo.data);o[String(e[m])]=q(M({},d),{programId:p.accountInfo.owner}),r.add(String(d.configId)),i.push(d.vaultA,d.vaultB)}let s={};if(t){let m=[...r],p=await Ne(this.scope.connection,m.map(d=>({pubkey:new U(d)})));for(let d=0;d<m.length;d++){let f=p[d].accountInfo;if(f===null)throw Error("fetch pool config error: "+m[d]);s[m[d]]=Ll.decode(f.data)}}let u={},a=await Ne(this.scope.connection,i.map(m=>({pubkey:new U(m)})));for(let m=0;m<i.length;m++){let p=a[m].accountInfo;if(p===null)throw Error("fetch vault info error: "+i[m]);u[String(i[m])]=new Xe(sf.decode(p.data).amount.toString())}let c={};for(let[m,p]of Object.entries(o)){let d=u[p.vaultA.toString()].sub(p.protocolFeesMintA).sub(p.fundFeesMintA).sub(p.creatorFeesMintA),f=u[p.vaultB.toString()].sub(p.protocolFeesMintB).sub(p.fundFeesMintB).sub(p.creatorFeesMintB);c[m]=q(M({},p),{baseReserve:d,quoteReserve:f,vaultAAmount:u[p.vaultA.toString()],vaultBAmount:u[p.vaultB.toString()],configInfo:s[p.configId.toString()],poolPrice:new zt(f.toString()).div(new zt(10).pow(p.mintDecimalB)).div(new zt(d.toString()).div(new zt(10).pow(p.mintDecimalA)))})}return c}toComputePoolInfos({pools:e,mintInfos:t}){return Object.keys(e).reduce((n,o)=>{var u,a,c,m;let r=e[o],[i,s]=[r.mintA.toBase58(),r.mintB.toBase58()];return q(M({},n),{[o]:q(M({},r),{id:new U(o),configInfo:r.configInfo,version:7,authority:Wo(r.programId).publicKey,mintA:yt({address:i,decimals:r.mintDecimalA,programId:r.mintProgramA.toBase58(),extensions:{feeConfig:(u=t[i])!=null&&u.feeConfig?Un((a=t[i])==null?void 0:a.feeConfig):void 0}}),mintB:yt({address:s,decimals:r.mintDecimalB,programId:r.mintProgramB.toBase58(),extensions:{feeConfig:(c=t[s])!=null&&c.feeConfig?Un((m=t[s])==null?void 0:m.feeConfig):void 0}})})})},{})}async getPoolInfoFromRpc(e){let t=await this.getRpcPoolInfo(e,!0),n=await Io({connection:this.scope.connection,mints:[t.mintA,t.mintB]}),o=yt({address:t.mintA.toBase58(),decimals:t.mintDecimalA,programId:t.mintProgramA.toBase58(),extensions:{feeConfig:n[t.mintA.toBase58()].feeConfig?Un(n[t.mintA.toBase58()].feeConfig):void 0}}),r=yt({address:t.mintB.toBase58(),decimals:t.mintDecimalB,programId:t.mintProgramB.toBase58(),extensions:{feeConfig:n[t.mintB.toBase58()].feeConfig?Un(n[t.mintB.toBase58()].feeConfig):void 0}}),i=yt({address:t.mintLp.toBase58(),decimals:t.lpDecimals,programId:It.toBase58()}),s={id:t.configId.toBase58(),index:t.configInfo.index,protocolFeeRate:t.configInfo.protocolFeeRate.toNumber(),tradeFeeRate:t.configInfo.tradeFeeRate.toNumber(),fundFeeRate:t.configInfo.fundFeeRate.toNumber(),createPoolFee:t.configInfo.createPoolFee.toString()},u={volume:0,volumeQuote:0,volumeFee:0,apr:0,feeApr:0,priceMin:0,priceMax:0,rewardApr:[]};return{poolInfo:{programId:t.programId.toBase58(),id:e,type:"Standard",lpMint:i,lpPrice:0,lpAmount:t.lpAmount.toNumber(),config:s,mintA:o,mintB:r,rewardDefaultInfos:[],rewardDefaultPoolInfos:"Ecosystem",price:t.poolPrice.toNumber(),mintAmountA:new zt(t.vaultAAmount.toString()).div(10**o.decimals).toNumber(),mintAmountB:new zt(t.vaultBAmount.toString()).div(10**r.decimals).toNumber(),feeRate:t.configInfo.tradeFeeRate.toNumber(),openTime:t.openTime.toString(),tvl:0,burnPercent:0,day:u,week:u,month:u,pooltype:[],farmUpcomingCount:0,farmOngoingCount:0,farmFinishedCount:0},poolKeys:{programId:t.programId.toBase58(),id:e,mintA:o,mintB:r,openTime:t.openTime.toString(),vault:{A:t.vaultA.toBase58(),B:t.vaultB.toBase58()},authority:Wo(t.programId).publicKey.toBase58(),mintLp:i,config:s,observationId:Di(t.programId,new U(e)).publicKey.toBase58()},rpcData:t}}async createPool(f){var y=f,{poolId:e,programId:t,poolFeeAccount:n,startTime:o,ownerInfo:r,associatedOnly:i=!1,checkCreateATAOwner:s=!1,txVersion:u,feeConfig:a,computeBudgetConfig:c,txTipConfig:m,feePayer:p}=y,d=Fe(y,["poolId","programId","poolFeeAccount","startTime","ownerInfo","associatedOnly","checkCreateATAOwner","txVersion","feeConfig","computeBudgetConfig","txTipConfig","feePayer"]);var E,X,Q;let b=r.feePayer||((E=this.scope.owner)==null?void 0:E.publicKey),g=new Xe(new U(d.mintA.address).toBuffer()).lte(new Xe(new U(d.mintB.address).toBuffer())),[P,h]=g?[d.mintA,d.mintB]:[d.mintB,d.mintA],[I,T]=g?[d.mintAAmount,d.mintBAmount]:[d.mintBAmount,d.mintAAmount],w=r.useSOLBalance&&P.address===Do.toBase58(),K=r.useSOLBalance&&h.address===Do.toBase58(),[x,S]=[new U(P.address),new U(h.address)],B=this.createTxBuilder(p),{account:R,instructionParams:C}=await this.scope.account.getOrCreateTokenAccount({mint:x,tokenProgram:P.programId,owner:this.scope.ownerPubKey,createInfo:w?{payer:b,amount:I}:void 0,notUseTokenAccount:w,skipCloseAccount:!w,associatedOnly:w?!1:i,checkCreateATAOwner:s});B.addInstruction(C||{});let{account:v,instructionParams:L}=await this.scope.account.getOrCreateTokenAccount({mint:new U(h.address),tokenProgram:h.programId,owner:this.scope.ownerPubKey,createInfo:K?{payer:b,amount:T}:void 0,notUseTokenAccount:K,skipCloseAccount:!K,associatedOnly:K?!1:i,checkCreateATAOwner:s});if(B.addInstruction(L||{}),R===void 0||v===void 0)throw Error("you don't has some token account");let N=Ua({poolId:e,programId:t,configId:new U(a.id),mintA:x,mintB:S});return B.addInstruction({instructions:[Bl(t,this.scope.ownerPubKey,new U(a.id),N.authority,N.poolId,x,S,N.lpMint,R,v,j(this.scope.ownerPubKey,N.lpMint).publicKey,N.vaultA,N.vaultB,n,new U((X=P.programId)!=null?X:It),new U((Q=h.programId)!=null?Q:It),N.observationId,I,T,o)],instructionTypes:[G.CpmmCreatePool]}),B.addCustomComputeBudget(c),B.addTipInstruction(m),B.versionBuild({txVersion:u,extInfo:{address:q(M({},N),{mintA:P,mintB:h,programId:t,poolFeeAccount:n,feeConfig:a})}})}async addLiquidity(e){let{poolInfo:t,poolKeys:n,inputAmount:o,baseIn:r,slippage:i,computeResult:s,computeBudgetConfig:u,txTipConfig:a,config:c,txVersion:m,feePayer:p}=e;this.scope.availability.addStandardPosition===!1&&this.logAndCreateError("add liquidity feature disabled in your region"),o.isZero()&&this.logAndCreateError("amounts must greater than zero","amountInA",{amountInA:o.toString()});let{account:d}=this.scope,{bypassAssociatedCheck:f,checkCreateATAOwner:y}=M({bypassAssociatedCheck:!1,checkCreateATAOwner:!1},c),b=s?void 0:await this.getRpcPoolInfo(t.id),{liquidity:g,inputAmountFee:P,anotherAmount:h}=s||this.computePairAmount({poolInfo:q(M({},t),{lpAmount:new zt(b.lpAmount.toString()).div(10**t.lpMint.decimals).toNumber()}),baseReserve:b.baseReserve,quoteReserve:b.quoteReserve,slippage:new st(0),baseIn:r,epochInfo:await this.scope.fetchEpochInfo(),amount:new zt(o.toString()).div(10**(r?t.mintA.decimals:t.mintB.decimals))}),I=h.amount,T=t.mintA.address===Do.toString(),w=t.mintB.address===Do.toString(),K=this.createTxBuilder(p),[x,S]=[new U(t.mintA.address),new U(t.mintB.address)],{account:B,instructionParams:R}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:t.mintA.programId,mint:new U(t.mintA.address),owner:this.scope.ownerPubKey,createInfo:T||(r?o:I).isZero()?{payer:this.scope.ownerPubKey,amount:r?o:I}:void 0,skipCloseAccount:!T,notUseTokenAccount:T,associatedOnly:!1,checkCreateATAOwner:y});K.addInstruction(R||{});let{account:C,instructionParams:v}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:t.mintB.programId,mint:new U(t.mintB.address),owner:this.scope.ownerPubKey,createInfo:w||(r?I:o).isZero()?{payer:this.scope.ownerPubKey,amount:r?I:o}:void 0,skipCloseAccount:!w,notUseTokenAccount:w,associatedOnly:!1,checkCreateATAOwner:y});K.addInstruction(v||{}),!B&&!C&&this.logAndCreateError("cannot found target token accounts","tokenAccounts",d.tokenAccounts);let L=await d.getCreatedTokenAccount({mint:new U(t.lpMint.address)}),ee=await d.handleTokenAccount({side:"out",amount:0,mint:new U(t.lpMint.address),tokenAccount:L,bypassAssociatedCheck:f,checkCreateATAOwner:y}),{tokenAccount:N}=ee,E=Fe(ee,["tokenAccount"]);K.addInstruction(E);let X=n!=null?n:await this.getCpmmPoolKeys(t.id),Q=new st(new Xe(1)).sub(i);return K.addInstruction({instructions:[xl(new U(t.programId),this.scope.ownerPubKey,new U(X.authority),new U(t.id),N,B,C,new U(X.vault.A),new U(X.vault.B),x,S,new U(t.lpMint.address),s?s==null?void 0:s.liquidity:Q.mul(g).quotient,r?P.amount:I,r?I:P.amount)],instructionTypes:[G.CpmmAddLiquidity],lookupTableAddress:X.lookupTableAccount?[X.lookupTableAccount]:[]}),K.addCustomComputeBudget(u),K.addTipInstruction(a),K.versionBuild({txVersion:m})}async withdrawLiquidity(e){var E,X;let{poolInfo:t,poolKeys:n,lpAmount:o,slippage:r,computeBudgetConfig:i,txTipConfig:s,txVersion:u,feePayer:a,closeWsol:c=!0}=e;this.scope.availability.addStandardPosition===!1&&this.logAndCreateError("add liquidity feature disabled in your region");let m=new st(new Xe(1)).sub(r),p=await this.getRpcPoolInfo(t.id),[d,f]=[m.mul(o.mul(p.baseReserve).div(p.lpAmount)).quotient,m.mul(o.mul(p.quoteReserve).div(p.lpAmount)).quotient],y=await this.scope.fetchEpochInfo(),[b,g]=[Ie(d,t.mintA.extensions.feeConfig,y,!1),Ie(f,t.mintB.extensions.feeConfig,y,!1)],{account:P}=this.scope,h=this.createTxBuilder(a),[I,T]=[new U(t.mintA.address),new U(t.mintB.address)],w=I.equals($),K=T.equals($),x,S,{account:B,instructionParams:R}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:t.mintA.programId,mint:new U(t.mintA.address),notUseTokenAccount:w,owner:this.scope.ownerPubKey,createInfo:{payer:this.scope.ownerPubKey,amount:0},skipCloseAccount:!(w&&c),associatedOnly:!w,checkCreateATAOwner:!1});x=B,R&&h.addInstruction(R);let{account:C,instructionParams:v}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:t.mintB.programId,mint:new U(t.mintB.address),notUseTokenAccount:K,owner:this.scope.ownerPubKey,createInfo:{payer:this.scope.ownerPubKey,amount:0},skipCloseAccount:!(K&&c),associatedOnly:!K,checkCreateATAOwner:!1});S=C,v&&h.addInstruction(v),(!x||!S)&&this.logAndCreateError("cannot found target token accounts","tokenAccounts",P.tokenAccounts);let L=await P.getCreatedTokenAccount({mint:new U(t.lpMint.address)});L||this.logAndCreateError("cannot found lp token account","tokenAccounts",P.tokenAccounts);let N=n!=null?n:await this.getCpmmPoolKeys(t.id);return h.addInstruction({instructions:[Kl(new U(t.programId),this.scope.ownerPubKey,new U(N.authority),new U(t.id),L,x,S,new U(N.vault.A),new U(N.vault.B),I,T,new U(t.lpMint.address),o,d.sub((E=b.fee)!=null?E:new Xe(0)),f.sub((X=g.fee)!=null?X:new Xe(0)))],instructionTypes:[G.CpmmWithdrawLiquidity],lookupTableAddress:N.lookupTableAccount?[N.lookupTableAccount]:[]}),h.addCustomComputeBudget(i),h.addTipInstruction(s),h.versionBuild({txVersion:u})}async swap(e){var R,C,v,L,N,E;let{poolInfo:t,poolKeys:n,baseIn:o,fixedOut:r,inputAmount:i,swapResult:s,slippage:u=0,config:a,computeBudgetConfig:c,txTipConfig:m,txVersion:p,feePayer:d}=e,{bypassAssociatedCheck:f,checkCreateATAOwner:y,associatedOnly:b}=M({bypassAssociatedCheck:!1,checkCreateATAOwner:!1,associatedOnly:!0},a),g=this.createTxBuilder(d),[P,h]=[new U(t.mintA.address),new U(t.mintB.address)];r?s.inputAmount=s.inputAmount.mul(new Xe((1+u)*1e4)).div(new Xe(1e4)):s.outputAmount=s.outputAmount.mul(new Xe((1-u)*1e4)).div(new Xe(1e4));let I=t.mintA.address===$.toBase58(),T=t.mintB.address===$.toBase58(),{account:w,instructionParams:K}=await this.scope.account.getOrCreateTokenAccount({mint:P,tokenProgram:new U((R=t.mintA.programId)!=null?R:It),owner:this.scope.ownerPubKey,createInfo:I||!o?{payer:this.scope.ownerPubKey,amount:o?s.inputAmount:0}:void 0,notUseTokenAccount:I,skipCloseAccount:!I,associatedOnly:I?!1:b,checkCreateATAOwner:y});K&&g.addInstruction(K);let{account:x,instructionParams:S}=await this.scope.account.getOrCreateTokenAccount({mint:h,tokenProgram:new U((C=t.mintB.programId)!=null?C:It),owner:this.scope.ownerPubKey,createInfo:T||o?{payer:this.scope.ownerPubKey,amount:o?0:s.inputAmount}:void 0,notUseTokenAccount:T,skipCloseAccount:!T,associatedOnly:T?!1:b,checkCreateATAOwner:y});S&&g.addInstruction(S),(!w||!x)&&this.logAndCreateError("user do not have token account",{mintA:t.mintA.symbol||t.mintA.address,mintB:t.mintB.symbol||t.mintB.address,mintATokenAcc:w,mintBTokenAcc:x,mintAUseSOLBalance:I,mintBUseSOLBalance:T,associatedOnly:b});let B=n!=null?n:await this.getCpmmPoolKeys(t.id);return g.addInstruction({instructions:[r?Sl(new U(t.programId),this.scope.ownerPubKey,new U(B.authority),new U(B.config.id),new U(t.id),o?w:x,o?x:w,new U(B.vault[o?"A":"B"]),new U(B.vault[o?"B":"A"]),new U((N=t[o?"mintA":"mintB"].programId)!=null?N:It),new U((E=t[o?"mintB":"mintA"].programId)!=null?E:It),o?P:h,o?h:P,Di(new U(t.programId),new U(t.id)).publicKey,s.inputAmount,s.outputAmount):Hr(new U(t.programId),this.scope.ownerPubKey,new U(B.authority),new U(B.config.id),new U(t.id),o?w:x,o?x:w,new U(B.vault[o?"A":"B"]),new U(B.vault[o?"B":"A"]),new U((v=t[o?"mintA":"mintB"].programId)!=null?v:It),new U((L=t[o?"mintB":"mintA"].programId)!=null?L:It),o?P:h,o?h:P,Di(new U(t.programId),new U(t.id)).publicKey,i,s.outputAmount)],instructionTypes:[r?G.CpmmSwapBaseOut:G.ClmmSwapBaseIn]}),g.addCustomComputeBudget(c),g.addTipInstruction(m),g.versionBuild({txVersion:p})}async lockLp(e){var p,d,f,y,b;let{poolInfo:t,lpAmount:n,computeBudgetConfig:o,txTipConfig:r,txVersion:i,feePayer:s,feeNftOwner:u}=e;n.isZero()&&this.logAndCreateError("lpAmount must greater than zero",{lpAmount:n.toString()});let a=this.createTxBuilder(s),c=(p=e.poolKeys)!=null?p:await this.getCpmmPoolKeys(t.id),m=await Cl({poolInfo:t,poolKeys:c,ownerInfo:{wallet:this.scope.ownerPubKey,feePayer:(d=e.feePayer)!=null?d:this.scope.ownerPubKey},feeNftOwner:u!=null?u:this.scope.ownerPubKey,lockProgram:(f=e.programId)!=null?f:ii,lockAuthProgram:(y=e.authProgram)!=null?y:ri,lpAmount:n,withMetadata:(b=e.withMetadata)!=null?b:!0,getEphemeralSigners:e.getEphemeralSigners});return a.addInstruction(m),a.addCustomComputeBudget(o),a.addTipInstruction(r),a.versionBuild({txVersion:i,extInfo:m.address})}async harvestLockLp(e){var C;let{poolInfo:t,lpFeeAmount:n,nftMint:o,programId:r=ii,authProgram:i=ri,cpmmProgram:s,computeBudgetConfig:u,txTipConfig:a,txVersion:c,closeWsol:m=!0}=e;n.isZero()&&this.logAndCreateError("lpFeeAmount must greater than zero",{lpAmount:n.toString()});let p=e.feePayer||this.scope.ownerPubKey,d=this.createTxBuilder(p),[f,y]=[new U(t.mintA.address),new U(t.mintB.address)],b=f.equals($),g=y.equals($),P,h,{account:I,instructionParams:T}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:t.mintA.programId,mint:new U(t.mintA.address),notUseTokenAccount:b,owner:this.scope.ownerPubKey,createInfo:{payer:this.scope.ownerPubKey,amount:0},skipCloseAccount:!(b&&m),associatedOnly:!b,checkCreateATAOwner:!1});P=I,T&&d.addInstruction(T);let{account:w,instructionParams:K}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:t.mintB.programId,mint:new U(t.mintB.address),notUseTokenAccount:g,owner:this.scope.ownerPubKey,createInfo:{payer:this.scope.ownerPubKey,amount:0},skipCloseAccount:!(g&&m),associatedOnly:!g,checkCreateATAOwner:!1});h=w,K&&d.addInstruction(K),(!P||!h)&&this.logAndCreateError("cannot found target token accounts",{tokenAccountA:P,tokenAccountB:h});let x=(C=e.poolKeys)!=null?C:await this.getCpmmPoolKeys(t.id),{publicKey:S}=j(p,o,It),{publicKey:B}=qi(r,o),{publicKey:R}=j(i,new U(t.lpMint.address),It);return d.addInstruction({instructions:[za({programId:r,nftOwner:this.scope.ownerPubKey,auth:i,nftMint:o,nftAccount:S,lockPda:B,poolId:new U(t.id),mintLp:new U(x.mintLp.address),userVaultA:P,userVaultB:h,poolVaultA:new U(x.vault.A),poolVaultB:new U(x.vault.B),mintA:f,mintB:y,lockLpVault:R,lpFeeAmount:n,cpmmProgram:s==null?void 0:s.programId,cpmmAuthProgram:s==null?void 0:s.authProgram})],instructionTypes:[G.CpmmCollectLockFee]}),d.addCustomComputeBudget(u),d.addTipInstruction(a),d.versionBuild({txVersion:c})}async harvestMultiLockLp(e){var p;let{lockInfo:t,programId:n=ii,authProgram:o=ri,cpmmProgram:r,computeBudgetConfig:i,txVersion:s,closeWsol:u=!0}=e,a=e.feePayer||this.scope.ownerPubKey,c=this.createTxBuilder(a),m={};for(let d of t){let{poolInfo:f,lpFeeAmount:y,nftMint:b}=d;if(y.isZero())continue;let[g,P]=[new U(f.mintA.address),new U(f.mintB.address)],h=g.equals($),I=P.equals($),T=m[f.mintA.address],w=m[f.mintB.address];if(!T)if(h){let{account:R,instructionParams:C}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:f.mintA.programId,mint:new U(f.mintA.address),notUseTokenAccount:!0,owner:this.scope.ownerPubKey,createInfo:{payer:this.scope.ownerPubKey,amount:0},skipCloseAccount:!u,associatedOnly:!1,checkCreateATAOwner:!1});T=R,C&&c.addInstruction(C),m[f.mintA.address]=R}else{let R=new U(f.mintA.address);T=this.scope.account.getAssociatedTokenAccount(R,new U(f.mintA.programId)),c.addInstruction({instructions:[qo(this.scope.ownerPubKey,T,this.scope.ownerPubKey,R,new U(f.mintA.programId))]}),m[f.mintA.address]=T}if(!w)if(I){let{account:R,instructionParams:C}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:f.mintB.programId,mint:new U(f.mintB.address),notUseTokenAccount:!0,owner:this.scope.ownerPubKey,createInfo:{payer:this.scope.ownerPubKey,amount:0},skipCloseAccount:!u,associatedOnly:!1,checkCreateATAOwner:!1});w=R,C&&c.addInstruction(C),m[f.mintB.address]=R}else{let R=new U(f.mintB.address);w=this.scope.account.getAssociatedTokenAccount(R,new U(f.mintB.programId)),c.addInstruction({instructions:[qo(this.scope.ownerPubKey,w,this.scope.ownerPubKey,R,new U(f.mintB.programId))]}),m[f.mintB.address]=w}(!T||!w)&&this.logAndCreateError("cannot found target token accounts",{tokenAccountA:T,tokenAccountB:w});let K=(p=d.poolKeys)!=null?p:await this.getCpmmPoolKeys(f.id),{publicKey:x}=j(a,b,It),{publicKey:S}=qi(n,b),{publicKey:B}=j(o,new U(f.lpMint.address),It);c.addInstruction({instructions:[za({programId:n,nftOwner:this.scope.ownerPubKey,auth:o,nftMint:b,nftAccount:x,lockPda:S,poolId:new U(f.id),mintLp:new U(K.mintLp.address),userVaultA:T,userVaultB:w,poolVaultA:new U(K.vault.A),poolVaultB:new U(K.vault.B),mintA:g,mintB:P,lockLpVault:B,lpFeeAmount:y,cpmmProgram:r==null?void 0:r.programId,cpmmAuthProgram:r==null?void 0:r.authProgram})],instructionTypes:[G.CpmmCollectLockFee]})}return s===0?c.sizeCheckBuildV0({computeBudgetConfig:i}):c.sizeCheckBuild({computeBudgetConfig:i})}async createPoolWithPermission(y){var b=y,{poolId:e,programId:t,poolFeeAccount:n,startTime:o,ownerInfo:r,associatedOnly:i=!1,checkCreateATAOwner:s=!1,txVersion:u,feeConfig:a,computeBudgetConfig:c,txTipConfig:m,feePayer:p,feeOn:d}=b,f=Fe(b,["poolId","programId","poolFeeAccount","startTime","ownerInfo","associatedOnly","checkCreateATAOwner","txVersion","feeConfig","computeBudgetConfig","txTipConfig","feePayer","feeOn"]);var X,Q,ee;console.log("***this method only available for wallet with permissions***");let g=r.feePayer||((X=this.scope.owner)==null?void 0:X.publicKey),P=new Xe(new U(f.mintA.address).toBuffer()).lte(new Xe(new U(f.mintB.address).toBuffer())),[h,I]=P?[f.mintA,f.mintB]:[f.mintB,f.mintA],[T,w]=P?[f.mintAAmount,f.mintBAmount]:[f.mintBAmount,f.mintAAmount],K=r.useSOLBalance&&h.address===Do.toBase58(),x=r.useSOLBalance&&I.address===Do.toBase58(),[S,B]=[new U(h.address),new U(I.address)],R=this.createTxBuilder(p),{account:C,instructionParams:v}=await this.scope.account.getOrCreateTokenAccount({mint:S,tokenProgram:h.programId,owner:this.scope.ownerPubKey,createInfo:K?{payer:g,amount:T}:void 0,notUseTokenAccount:K,skipCloseAccount:!K,associatedOnly:K?!1:i,checkCreateATAOwner:s});R.addInstruction(v||{});let{account:L,instructionParams:N}=await this.scope.account.getOrCreateTokenAccount({mint:new U(I.address),tokenProgram:I.programId,owner:this.scope.ownerPubKey,createInfo:x?{payer:g,amount:w}:void 0,notUseTokenAccount:x,skipCloseAccount:!x,associatedOnly:x?!1:i,checkCreateATAOwner:s});if(R.addInstruction(N||{}),C===void 0||L===void 0)throw Error("you don't has some token account");let E=Ua({poolId:e,programId:t,configId:new U(a.id),mintA:S,mintB:B});return R.addInstruction({instructions:[Rl(t,this.scope.ownerPubKey,this.scope.ownerPubKey,new U(a.id),E.authority,E.poolId,S,B,E.lpMint,C,L,j(this.scope.ownerPubKey,E.lpMint).publicKey,E.vaultA,E.vaultB,n,new U((Q=h.programId)!=null?Q:It),new U((ee=I.programId)!=null?ee:It),E.observationId,Il(t,this.scope.ownerPubKey).publicKey,T,w,o,d)],instructionTypes:[G.CpmmCreatePool]}),R.addCustomComputeBudget(c),R.addTipInstruction(m),R.versionBuild({txVersion:u,extInfo:{address:q(M({},E),{mintA:h,mintB:I,programId:t,poolFeeAccount:n,feeConfig:a})}})}async collectCreatorFees({poolInfo:e,poolKeys:t,programId:n=vn,txVersion:o,computeBudgetConfig:r,txTipConfig:i,feePayer:s}){let u=s||this.scope.ownerPubKey,a=this.createTxBuilder(u),c=t!=null?t:await this.getCpmmPoolKeys(e.id),[m,p,d,f]=[new U(e.mintA.address),new U(e.mintB.address),new U(e.mintA.programId),new U(e.mintB.programId)],y=this.scope.account.getAssociatedTokenAccount(m,d),b=this.scope.account.getAssociatedTokenAccount(p,f);return a.addInstruction({instructions:[qo(this.scope.ownerPubKey,y,this.scope.ownerPubKey,m,new U(e.mintA.programId)),qo(this.scope.ownerPubKey,b,this.scope.ownerPubKey,p,new U(e.mintB.programId))]}),a.addInstruction({instructions:[Ya(n,this.scope.ownerPubKey,new U(c.authority),new U(c.id),new U(c.config.id),new U(c.vault.A),new U(c.vault.B),m,p,y,b,d,f)],instructionTypes:[]}),a.addCustomComputeBudget(r),a.addTipInstruction(i),a.versionBuild({txVersion:o})}async collectMultiCreatorFees({poolInfoList:e,programId:t=vn,txVersion:n,computeBudgetConfig:o,feePayer:r}){let i=r||this.scope.ownerPubKey,s=this.createTxBuilder(i),u={},a=await this.scope.api.fetchPoolKeysById({idList:e.map(c=>c.id)});for(let c of e){let m=a.find(P=>P.id===c.id)||await this.getCpmmPoolKeys(c.id),[p,d,f,y]=[new U(c.mintA.address),new U(c.mintB.address),new U(c.mintA.programId),new U(c.mintB.programId)],b=u[c.mintA.address]||this.scope.account.getAssociatedTokenAccount(p,f),g=u[c.mintB.address]||this.scope.account.getAssociatedTokenAccount(d,y);u[c.mintA.address]||s.addInstruction({instructions:[qo(this.scope.ownerPubKey,b,this.scope.ownerPubKey,p,f)]}),u[c.mintB.address]||s.addInstruction({instructions:[qo(this.scope.ownerPubKey,g,this.scope.ownerPubKey,d,y)]}),u[c.mintA.address]=b,u[c.mintB.address]=g,s.addInstruction({instructions:[Ya(t,this.scope.ownerPubKey,new U(m.authority),new U(m.id),new U(m.config.id),new U(m.vault.A),new U(m.vault.B),p,d,b,g,f,y)],instructionTypes:[]})}return n===0?s.sizeCheckBuildV0({computeBudgetConfig:o}):s.sizeCheckBuild({computeBudgetConfig:o})}computeSwapAmount({pool:e,amountIn:t,outputMint:n,slippage:o}){let r=n.toString()===e.mintB.address,i=e.feeOn===0||e.feeOn===2,s=r?Wi.swapBaseInput(t,r?e.baseReserve:e.quoteReserve,r?e.quoteReserve:e.baseReserve,e.configInfo.tradeFeeRate,e.configInfo.creatorFeeRate,e.configInfo.protocolFeeRate,e.configInfo.fundFeeRate,i):Wi.swapBaseOutput(t,r?e.baseReserve:e.quoteReserve,r?e.quoteReserve:e.baseReserve,e.configInfo.tradeFeeRate,e.configInfo.creatorFeeRate,e.configInfo.protocolFeeRate,e.configInfo.fundFeeRate,i),u=new zt(s.outputAmount.toString()).div(s.inputAmount.toString()),a=s.outputAmount.mul(new Xe((1-o)*1e4)).div(new Xe(1e4));return{allTrade:s.inputAmount.eq(t),amountIn:t,amountOut:s.outputAmount,minAmountOut:a,executionPrice:u,fee:s.tradeFee,priceImpact:e.poolPrice.sub(u).div(e.poolPrice)}}computePairAmount({poolInfo:e,baseReserve:t,quoteReserve:n,amount:o,slippage:r,epochInfo:i,baseIn:s}){var I,T,w,K,x,S,B,R,C;let u=1-Number(r.toSignificant())/100,a=new Xe(new zt(o).mul(10**e[s?"mintA":"mintB"].decimals).mul(u).toFixed(0)),c=Ie(a,e[s?"mintA":"mintB"].extensions.feeConfig,i,!1),m=a.sub((I=c.fee)!=null?I:new Xe(0)),p=new Xe(new zt(e.lpAmount).mul(10**e.lpMint.decimals).toFixed(0,zt.ROUND_DOWN));this.logDebug("baseReserve:",t.toString(),"quoteReserve:",n.toString()),this.logDebug("tokenIn:",s?e.mintA.symbol:e.mintB.symbol,"amountIn:",a.toString(),"amountInFee:",(w=(T=c.fee)==null?void 0:T.toString())!=null?w:0,"anotherToken:",s?e.mintB.symbol:e.mintA.symbol,"slippage:",`${r.toSignificant()}%`);let d=s?"base":"quote";this.logDebug("input side:",d);let f=m.mul(p).div(d==="base"?t:n),y={amount:xt,fee:void 0,expirationTime:void 0};if(!m.isZero()){let v=af(f,t,n,p);this.logDebug("lpAmountData:",{amountA:v.amountA.toString(),amountB:v.amountB.toString()}),y=Ie(v[s?"amountB":"amountA"],e[s?"mintB":"mintA"].extensions.feeConfig,i,!0)}let b=new st(new Xe(1)).add(r),g=new st(new Xe(1)).sub(r),P=Ie(b.mul(y.amount.sub((K=y.fee)!=null?K:new Xe(0))).quotient,e[s?"mintB":"mintA"].extensions.feeConfig,i,!0),h=Ie(g.mul(y.amount.sub((x=y.fee)!=null?x:new Xe(0))).quotient,e[s?"mintB":"mintA"].extensions.feeConfig,i,!0);return this.logDebug("anotherAmount:",y.amount.toString(),"anotherAmountFee:",(B=(S=y.fee)==null?void 0:S.toString())!=null?B:0,"maxAnotherAmount:",P.amount.toString(),"maxAnotherAmountFee:",(C=(R=P.fee)==null?void 0:R.toString())!=null?C:0),{inputAmountFee:c,anotherAmount:y,maxAnotherAmount:P,minAnotherAmount:h,liquidity:f}}};function af(l,e,t,n){let o=l.mul(e).div(n);!o.isZero()&&!l.mul(e).mod(n).isZero()&&(o=o.add(new Xe(1)));let r=l.mul(t).div(n);return!r.isZero()&&!l.mul(t).mod(n).isZero()&&(r=r.add(new Xe(1))),{amountA:o,amountB:r}}import{PublicKey as bo}from"@solana/web3.js";import{createTransferInstruction as _l,TOKEN_PROGRAM_ID as je,TOKEN_2022_PROGRAM_ID as Jr}from"@solana/spl-token";import es from"bn.js";import Yi from"decimal.js";var Nl={[gr.toBase58()]:3},Ml={3:gr};var Qa=F([Te(5),Te(8),O("ownAddress"),A("vaultSignerNonce"),O("baseMint"),O("quoteMint"),O("baseVault"),A("baseDepositsTotal"),A("baseFeesAccrued"),O("quoteVault"),A("quoteDepositsTotal"),A("quoteFeesAccrued"),A("quoteDustThreshold"),O("requestQueue"),O("eventQueue"),O("bids"),O("asks"),A("baseLotSize"),A("quoteLotSize"),A("feeRateBps"),A("referrerRebatesAccrued"),Te(7)]),vl={3:Qa};import{PublicKey as Fl}from"@solana/web3.js";var $r=ye("Serum"),Zr=class{static getProgramId(e){let t=Ml[e];return t||$r.logWithError("invalid version","version",e),t}static getVersion(e){let t=e.toBase58(),n=Nl[t];return n||$r.logWithError("invalid program id","programId",t),n}static getStateLayout(e){let t=vl[e];return t||$r.logWithError(!!t,"invalid version","version",e),t}static getLayouts(e){return{state:this.getStateLayout(e)}}static getAssociatedAuthority({programId:e,marketId:t}){let n=[t.toBuffer()],o=0,r;for(;o<100;){try{let i=n.concat(Buffer.from([o]),Buffer.alloc(7));r=Fl.createProgramAddressSync(i,e)}catch(i){if(i instanceof TypeError)throw i;o++;continue}return{publicKey:r,nonce:o}}return $r.logWithError("unable to find a viable program address nonce","params",{programId:e,marketId:t}),{publicKey:Fl.default,nonce:o}}};import{PublicKey as V,SystemProgram as Xi,TransactionInstruction as zi}from"@solana/web3.js";import dn from"bn.js";import{ASSOCIATED_TOKEN_PROGRAM_ID as Ha,TOKEN_2022_PROGRAM_ID as ja,TOKEN_PROGRAM_ID as zn}from"@solana/spl-token";function cS(l,e,t,n,o,r,i,s,u,a,c,m){let p=F([_("instruction"),A("amountIn"),A("amountOut")]),d=[{pubkey:Xi.programId,isSigner:!1,isWritable:!1},{pubkey:zn,isSigner:!1,isWritable:!1},{pubkey:new V(t.programId),isSigner:!1,isWritable:!1},{pubkey:new V(t.id),isSigner:!1,isWritable:!0},{pubkey:new V(n.id),isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!0,isWritable:!1}];if(e.type==="Concentrated"){let y=_e(t);d.push({pubkey:y.config.id,isSigner:!1,isWritable:!1},{pubkey:y.id,isSigner:!1,isWritable:!0},{pubkey:y.mintA.address.equals(u)?y.vault.A:y.vault.B,isSigner:!1,isWritable:!0},{pubkey:y.mintA.address.equals(u)?y.vault.B:y.vault.A,isSigner:!1,isWritable:!0},{pubkey:y.id,isSigner:!1,isWritable:!0},...m.map(b=>({pubkey:b,isSigner:!1,isWritable:!0})))}else if(e.pooltype.includes("StablePool")){let y=_e(t);d.push({pubkey:y.authority,isSigner:!1,isWritable:!1},{pubkey:y.marketProgramId,isSigner:!1,isWritable:!1},{pubkey:y.id,isSigner:!1,isWritable:!0},{pubkey:new V("CDSr3ssLcRB6XYPJwAfFt18MZvEZp4LjHcvzBVZ45duo"),isSigner:!1,isWritable:!1},{pubkey:y.openOrders,isSigner:!1,isWritable:!0},{pubkey:y.vault.A,isSigner:!1,isWritable:!0},{pubkey:y.vault.B,isSigner:!1,isWritable:!0},{pubkey:y.marketId,isSigner:!1,isWritable:!0},{pubkey:y.marketBids,isSigner:!1,isWritable:!0},{pubkey:y.marketAsks,isSigner:!1,isWritable:!0},{pubkey:y.marketEventQueue,isSigner:!1,isWritable:!0},{pubkey:y.id,isSigner:!1,isWritable:!0},{pubkey:y.id,isSigner:!1,isWritable:!0})}else{let y=_e(t);d.push({pubkey:y.authority,isSigner:!1,isWritable:!1},{pubkey:y.marketProgramId,isSigner:!1,isWritable:!1},{pubkey:y.marketAuthority,isSigner:!1,isWritable:!1},{pubkey:y.openOrders,isSigner:!1,isWritable:!0},{pubkey:y.vault.A,isSigner:!1,isWritable:!0},{pubkey:y.vault.B,isSigner:!1,isWritable:!0},{pubkey:y.marketId,isSigner:!1,isWritable:!0},{pubkey:y.marketBids,isSigner:!1,isWritable:!0},{pubkey:y.marketAsks,isSigner:!1,isWritable:!0},{pubkey:y.marketEventQueue,isSigner:!1,isWritable:!0},...y.marketProgramId.toString()==="srmqPvymJeFKQ4zGQed1GFppgkRHL9kaELCbyksJtPX"?[{pubkey:y.marketBaseVault,isSigner:!1,isWritable:!0},{pubkey:y.marketQuoteVault,isSigner:!1,isWritable:!0}]:[{pubkey:y.id,isSigner:!1,isWritable:!0},{pubkey:y.id,isSigner:!1,isWritable:!0}])}let f=Buffer.alloc(p.span);return p.encode({instruction:4,amountIn:a,amountOut:c},f),new zi({keys:d,programId:l,data:f})}function lS(l,e,t,n,o,r,i,s,u,a){let c=F([_("instruction")]),m=[{pubkey:Xi.programId,isSigner:!1,isWritable:!1},{pubkey:zn,isSigner:!1,isWritable:!1},{pubkey:new V(String(n.programId)),isSigner:!1,isWritable:!1},{pubkey:new V(String(n.id)),isSigner:!1,isWritable:!0},{pubkey:new V(String(t.id)),isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!0,isWritable:!1}];if(e.type==="Concentrated"){let d=_e(n);m.push({pubkey:d.config.id,isSigner:!1,isWritable:!1},{pubkey:d.id,isSigner:!1,isWritable:!0},{pubkey:d.mintA.address.equals(u)?d.vault.A:d.vault.B,isSigner:!1,isWritable:!0},{pubkey:d.mintA.address.equals(u)?d.vault.B:d.vault.A,isSigner:!1,isWritable:!0},{pubkey:d.id,isSigner:!1,isWritable:!0},...a.map(f=>({pubkey:f,isSigner:!1,isWritable:!0})))}else if(e.pooltype.includes("StablePool")){let d=_e(n);m.push({pubkey:d.authority,isSigner:!1,isWritable:!1},{pubkey:d.marketProgramId,isSigner:!1,isWritable:!1},{pubkey:d.id,isSigner:!1,isWritable:!0},{pubkey:new V("CDSr3ssLcRB6XYPJwAfFt18MZvEZp4LjHcvzBVZ45duo"),isSigner:!1,isWritable:!1},{pubkey:d.openOrders,isSigner:!1,isWritable:!0},{pubkey:d.vault.A,isSigner:!1,isWritable:!0},{pubkey:d.vault.B,isSigner:!1,isWritable:!0},{pubkey:d.marketId,isSigner:!1,isWritable:!0},{pubkey:d.marketBids,isSigner:!1,isWritable:!0},{pubkey:d.marketAsks,isSigner:!1,isWritable:!0},{pubkey:d.marketEventQueue,isSigner:!1,isWritable:!0},{pubkey:d.id,isSigner:!1,isWritable:!0},{pubkey:d.id,isSigner:!1,isWritable:!0})}else{let d=_e(n);m.push({pubkey:d.authority,isSigner:!1,isWritable:!1},{pubkey:d.marketProgramId,isSigner:!1,isWritable:!1},{pubkey:d.marketAuthority,isSigner:!1,isWritable:!1},{pubkey:d.openOrders,isSigner:!1,isWritable:!0},{pubkey:d.vault.A,isSigner:!1,isWritable:!0},{pubkey:d.vault.B,isSigner:!1,isWritable:!0},{pubkey:d.marketId,isSigner:!1,isWritable:!0},{pubkey:d.marketBids,isSigner:!1,isWritable:!0},{pubkey:d.marketAsks,isSigner:!1,isWritable:!0},{pubkey:d.marketEventQueue,isSigner:!1,isWritable:!0},...d.marketProgramId.toString()==="srmqPvymJeFKQ4zGQed1GFppgkRHL9kaELCbyksJtPX"?[{pubkey:d.marketBaseVault,isSigner:!1,isWritable:!0},{pubkey:d.marketQuoteVault,isSigner:!1,isWritable:!0}]:[{pubkey:d.id,isSigner:!1,isWritable:!0},{pubkey:d.id,isSigner:!1,isWritable:!0}])}let p=Buffer.alloc(c.span);return c.encode({instruction:5},p),new zi({keys:m,programId:l,data:p})}function uf(l,e,t,n,o,r,i,s,u,a,c,m,p,d,f){var w;let y=[],b=[k({pubkey:zn,isWritable:!1}),k({pubkey:ja,isWritable:!1}),k({pubkey:Ha,isWritable:!1}),k({pubkey:Xi.programId,isWritable:!1}),k({pubkey:e,isSigner:!0})];b.push(k({pubkey:t})),b.push(k({pubkey:o}));let g=[u,a],P=[c,m],h=[r,i,s];for(let K=0;K<g.length;K++){let x=g[K],S=h[K]===x.mintA.address;if(b.push(k({pubkey:new V(x.programId),isWritable:!1})),K===g.length-1?b.push(k({pubkey:o})):b.push(k({pubkey:n})),b.push(k({pubkey:new V(h[K])})),b.push(k({pubkey:new V(h[K+1])})),x.version===6){let B=P[K];b.push(k({pubkey:new V(B.config.id)})),b.push(k({pubkey:new V(B.id)})),b.push(k({pubkey:new V(S?B.vault.A:B.vault.B)})),b.push(k({pubkey:new V(S?B.vault.B:B.vault.A)})),b.push(k({pubkey:new V(x.observationId)})),b.push(k({pubkey:an})),b.push(k({pubkey:He(new V(x.programId),new V(x.id)).publicKey})),y.push($a(x.sqrtPriceX64.toString(),S));for(let R of(w=f[K])!=null?w:[])b.push(k({pubkey:new V(R)}))}else if(x.version===5){let B=P[K];b.push(k({pubkey:new V(B.id)})),b.push(k({pubkey:new V(B.authority),isWritable:!1})),b.push(k({pubkey:new V(B.marketProgramId)})),b.push(k({pubkey:new V(B.marketAuthority)})),b.push(k({pubkey:Pr,isWritable:!1})),b.push(k({pubkey:new V(B.openOrders)})),b.push(k({pubkey:new V(B.vault.A)})),b.push(k({pubkey:new V(B.vault.B)})),b.push(k({pubkey:new V(B.id)})),b.push(k({pubkey:new V(B.id)})),b.push(k({pubkey:new V(B.id)})),b.push(k({pubkey:new V(B.id)})),b.push(k({pubkey:new V(B.id)})),b.push(k({pubkey:new V(B.id)})),b.push(k({pubkey:new V(B.marketId)})),b.push(k({pubkey:new V(B.marketBids)})),b.push(k({pubkey:new V(B.marketAsks)})),b.push(k({pubkey:new V(B.marketEventQueue)})),b.push(k({pubkey:new V(B.marketBaseVault)})),b.push(k({pubkey:new V(B.marketQuoteVault)}))}else if(x.version===4){let B=P[K],R=x.status!==1;b.push(k({pubkey:new V(B.id)})),b.push(k({pubkey:new V(B.authority),isWritable:!1})),b.push(k({pubkey:new V(R?B.id:B.marketProgramId)})),b.push(k({pubkey:new V(R?B.id:B.marketAuthority)})),b.push(k({pubkey:new V(R?B.id:B.openOrders)})),b.push(k({pubkey:new V(B.vault.A)})),b.push(k({pubkey:new V(B.vault.B)})),b.push(k({pubkey:new V(R?B.id:B.marketId)})),b.push(k({pubkey:new V(R?B.id:B.marketBids)})),b.push(k({pubkey:new V(R?B.id:B.marketAsks)})),b.push(k({pubkey:new V(R?B.id:B.marketEventQueue)})),b.push(k({pubkey:new V(R?B.id:B.marketBaseVault)})),b.push(k({pubkey:new V(R?B.id:B.marketQuoteVault)}))}else if(x.version===7){let B=P[K];b.push(k({pubkey:new V(B.authority)})),b.push(k({pubkey:new V(B.config.id)})),b.push(k({pubkey:new V(B.id)})),b.push(k({pubkey:new V(S?B.vault.A:B.vault.B)})),b.push(k({pubkey:new V(S?B.vault.B:B.vault.A)})),b.push(k({pubkey:new V(x.observationId)}))}else throw Error("pool type error")}let I=F([_("insId"),A("amountIn"),A("amountOut"),Y(ne(),y.length,"clmmPriceLimit")]),T=Buffer.alloc(I.span);return I.encode({insId:0,amountIn:p,amountOut:d,clmmPriceLimit:y},T),new zi({keys:b,programId:l,data:T})}function $a(l,e){if(l)if(e){let t=new dn(l).div(new dn(25));return t.gt(Nr)?t:Nr}else{let t=new dn(l).mul(new dn(25));return t.lt(Mr)?t:Mr}else return e?Nr:Mr}function Vl({routeProgram:l,ownerInfo:e,inputMint:t,swapInfo:n}){var o,r,i,s,u,a,c;if(n.routeType==="amm")if(n.poolInfo[0].version===6){let m=n.poolKey[0],p=_e(m),d=t.equals(p.mintA.address)?Gt.add(Vt):Xt.sub(Vt);return Se.makeSwapBaseInInstructions({poolInfo:m,poolKeys:m,observationId:n.poolInfo[0].observationId,ownerInfo:{wallet:e.wallet,tokenAccountA:p.mintA.address.equals(t)?e.sourceToken:e.destinationToken,tokenAccountB:p.mintA.address.equals(t)?e.destinationToken:e.sourceToken},inputMint:t,amountIn:n.amountIn.amount.raw,amountOutMin:n.minAmountOut.amount.raw.sub((r=(o=n.minAmountOut.fee)==null?void 0:o.raw)!=null?r:new dn(0)),sqrtPriceLimitX64:d,remainingAccounts:(i=n.remainingAccounts[0])!=null?i:[]})}else if(n.poolInfo[0].version===7){let m=n.poolInfo[0],p=t.toString()===n.poolInfo[0].mintA.address;return{signers:[],instructions:[Hr(m.programId,e.wallet,m.authority,m.configId,m.id,e.sourceToken,e.destinationToken,p?m.vaultA:m.vaultB,p?m.vaultB:m.vaultA,p?m.mintProgramA:m.mintProgramB,p?m.mintProgramB:m.mintProgramA,new V(m[p?"mintA":"mintB"].address),new V(m[p?"mintB":"mintA"].address),m.observationId,n.amountIn.amount.raw,n.minAmountOut.amount.raw)],lookupTableAddress:[],instructionTypes:[p?G.CpmmSwapBaseIn:G.CpmmSwapBaseOut],address:{}}}else{let m=n.poolKey[0];return{signers:[],instructions:[Dr({poolKeys:m,version:n.poolInfo[0].pooltype.includes("StablePool")?5:4,userKeys:{tokenAccountIn:e.sourceToken,tokenAccountOut:e.destinationToken,owner:e.wallet},amountIn:n.amountIn.amount.raw,amountOut:n.minAmountOut.amount.raw.sub((u=(s=n.minAmountOut.fee)==null?void 0:s.raw)!=null?u:new dn(0)),fixedSide:"in"})],lookupTableAddress:m.lookupTableAccount?[m.lookupTableAccount]:[],instructionTypes:[n.poolInfo[0].pooltype.includes("StablePool")?G.AmmV5SwapBaseIn:G.AmmV4SwapBaseIn],address:{}}}else if(n.routeType==="route"){let m=n.poolInfo[0],p=n.poolInfo[1],d=n.poolKey[0],f=n.poolKey[1];if(e.routeToken===void 0)throw Error("owner route token account check error");return{signers:[],instructions:[uf(l,e.wallet,e.sourceToken,e.routeToken,e.destinationToken,t.toString(),n.middleToken.mint.toString(),n.outputMint.toString(),m,p,d,f,n.amountIn.amount.raw,n.minAmountOut.amount.raw.sub((c=(a=n.minAmountOut.fee)==null?void 0:a.raw)!=null?c:new dn(0)),n.remainingAccounts)],instructionTypes:[G.RouteSwap],lookupTableAddress:[d.lookupTableAccount,f.lookupTableAccount].filter(y=>y!==void 0),address:{}}}else throw Error("route type error")}function mS({programId:l,wallet:e,amount:t,inputAccount:n,outputAccount:o,routeInfo:r,poolKeys:i}){var p;if(r.success===!1)throw Error("route info error");let s=[],u=[k({pubkey:zn,isWritable:!1}),k({pubkey:ja,isWritable:!1}),k({pubkey:Ha,isWritable:!1}),k({pubkey:Xi.programId,isWritable:!1}),k({pubkey:e,isSigner:!0})],a={[r.data.inputMint]:n,[r.data.outputMint]:o};u.push(k({pubkey:a[r.data.inputMint]})),u.push(k({pubkey:a[r.data.outputMint]}));for(let d=0;d<i.length;d++){let f=r.data.routePlan[d],y=i[d],b=f.inputMint===y.mintA.address;if(u.push(k({pubkey:new V(y.programId),isWritable:!1})),d===i.length-1)u.push(k({pubkey:a[f.outputMint]}));else{let g=f.outputMint;if(a[g]===void 0){let P=j(e,new V(g),y.programId===At.CLMM_PROGRAM_ID.toBase58()||y.programId===At.CREATE_CPMM_POOL_PROGRAM.toBase58()?new V(b?y.mintB.programId:y.mintA.programId):zn).publicKey;a[g]=P}u.push(k({pubkey:a[g]}))}if(u.push(k({pubkey:new V(f.inputMint)})),u.push(k({pubkey:new V(f.outputMint)})),y.programId===At.CLMM_PROGRAM_ID.toBase58()){let g=y;u.push(k({pubkey:new V(g.config.id)})),u.push(k({pubkey:new V(g.id)})),u.push(k({pubkey:new V(b?g.vault.A:g.vault.B)})),u.push(k({pubkey:new V(b?g.vault.B:g.vault.A)})),u.push(k({pubkey:new V(g.observationId)})),u.push(k({pubkey:an,isWritable:!1})),u.push(k({pubkey:new V(g.exBitmapAccount)})),s.push($a(f.lastPoolPriceX64,b));for(let P of(p=f.remainingAccounts)!=null?p:[])u.push(k({pubkey:new V(P)}))}else if(y.programId===At.AMM_STABLE.toBase58()){let g=y;u.push(k({pubkey:new V(g.id)})),u.push(k({pubkey:new V(g.authority),isWritable:!1})),u.push(k({pubkey:new V(g.marketProgramId),isWritable:!1})),u.push(k({pubkey:new V(g.marketAuthority),isWritable:!1})),u.push(k({pubkey:Pr,isWritable:!1})),u.push(k({pubkey:new V(g.openOrders)})),u.push(k({pubkey:new V(g.vault.A)})),u.push(k({pubkey:new V(g.vault.B)})),u.push(k({pubkey:new V(g.marketId)})),u.push(k({pubkey:new V(g.marketBids)})),u.push(k({pubkey:new V(g.marketAsks)})),u.push(k({pubkey:new V(g.marketEventQueue)})),u.push(k({pubkey:new V(g.marketBaseVault)})),u.push(k({pubkey:new V(g.marketQuoteVault)}))}else if(y.programId===At.AMM_V4.toBase58()){let g=y;u.push(k({pubkey:new V(g.id)})),u.push(k({pubkey:new V(g.authority),isWritable:!1})),u.push(k({pubkey:new V(g.id)})),u.push(k({pubkey:new V(g.id)})),u.push(k({pubkey:new V(g.id)})),u.push(k({pubkey:new V(g.vault.A)})),u.push(k({pubkey:new V(g.vault.B)})),u.push(k({pubkey:new V(g.id)})),u.push(k({pubkey:new V(g.id)})),u.push(k({pubkey:new V(g.id)})),u.push(k({pubkey:new V(g.id)})),u.push(k({pubkey:new V(g.id)})),u.push(k({pubkey:new V(g.id)}))}else if(y.programId===At.CREATE_CPMM_POOL_PROGRAM.toBase58()){let g=y;u.push(k({pubkey:new V(g.authority)})),u.push(k({pubkey:new V(g.config.id)})),u.push(k({pubkey:new V(g.id)})),u.push(k({pubkey:new V(b?g.vault.A:g.vault.B)})),u.push(k({pubkey:new V(b?g.vault.B:g.vault.A)})),u.push(k({pubkey:new V(g.observationId)}))}else throw Error("pool type error")}let c=F([_("insId"),A("amountIn"),A("amountOut"),Y(ne(),s.length,"clmmPriceLimit")]),m=Buffer.alloc(c.span);return c.encode({insId:0,amountIn:t,amountOut:new dn(r.data.otherAmountThreshold),clmmPriceLimit:s},m),new zi({keys:u,programId:l,data:m})}function dS({programId:l,wallet:e,inputAccount:t,outputAccount:n,routeInfo:o,poolKeys:r}){var m;if(o.success===!1)throw Error("route info error");let i=[],s=[k({pubkey:zn,isWritable:!1}),k({pubkey:ja,isWritable:!1}),k({pubkey:Ha,isWritable:!1}),k({pubkey:Xi.programId,isWritable:!1}),k({pubkey:e,isSigner:!0})],u={[o.data.inputMint]:t,[o.data.outputMint]:n};for(let p=r.length-1;p>=0;p--){let d=o.data.routePlan[p],f=r[p],y=d.inputMint===f.mintA.address;if(s.push(k({pubkey:new V(f.programId)})),p===0)s.push(k({pubkey:u[d.inputMint]}));else{let b=d.inputMint;if(u[b]===void 0){let g=j(e,new V(b),f.programId===At.CLMM_PROGRAM_ID.toBase58()||f.programId===At.CREATE_CPMM_POOL_PROGRAM.toBase58()?new V(y?f.mintA.programId:f.mintB.programId):zn).publicKey;u[b]=g}s.push(k({pubkey:u[b]}))}if(p===r.length-1)s.push(k({pubkey:u[d.outputMint]}));else{let b=d.outputMint;if(u[b]===void 0){let g=j(e,new V(b),f.programId===At.CLMM_PROGRAM_ID.toBase58()||f.programId===At.CREATE_CPMM_POOL_PROGRAM.toBase58()?new V(y?f.mintB.programId:f.mintA.programId):zn).publicKey;u[b]=g}s.push(k({pubkey:u[b]}))}if(s.push(k({pubkey:new V(d.inputMint)})),s.push(k({pubkey:new V(d.outputMint)})),f.programId===At.CLMM_PROGRAM_ID.toBase58()){let b=f;s.push(k({pubkey:new V(b.config.id)})),s.push(k({pubkey:new V(b.id)})),s.push(k({pubkey:new V(y?b.vault.A:b.vault.B)})),s.push(k({pubkey:new V(y?b.vault.B:b.vault.A)})),s.push(k({pubkey:new V(b.observationId)})),s.push(k({pubkey:an,isWritable:!1})),s.push(k({pubkey:new V(b.exBitmapAccount)})),i.push($a(d.lastPoolPriceX64,y));for(let g of(m=d.remainingAccounts)!=null?m:[])s.push(k({pubkey:new V(g)}))}else if(f.programId===At.AMM_STABLE.toBase58()){let b=f;s.push(k({pubkey:new V(b.id)})),s.push(k({pubkey:new V(b.authority),isWritable:!1})),s.push(k({pubkey:new V(b.marketProgramId),isWritable:!1})),s.push(k({pubkey:new V(b.marketAuthority),isWritable:!1})),s.push(k({pubkey:Pr,isWritable:!1})),s.push(k({pubkey:new V(b.openOrders)})),s.push(k({pubkey:new V(b.vault.A)})),s.push(k({pubkey:new V(b.vault.B)})),s.push(k({pubkey:new V(b.marketId)})),s.push(k({pubkey:new V(b.marketBids)})),s.push(k({pubkey:new V(b.marketAsks)})),s.push(k({pubkey:new V(b.marketEventQueue)})),s.push(k({pubkey:new V(b.marketBaseVault)})),s.push(k({pubkey:new V(b.marketQuoteVault)}))}else if(f.programId===At.AMM_V4.toBase58()){let b=f;s.push(k({pubkey:new V(b.id)})),s.push(k({pubkey:new V(b.authority),isWritable:!1})),s.push(k({pubkey:new V(b.id)})),s.push(k({pubkey:new V(b.id)})),s.push(k({pubkey:new V(b.id)})),s.push(k({pubkey:new V(b.vault.A)})),s.push(k({pubkey:new V(b.vault.B)})),s.push(k({pubkey:new V(b.id)})),s.push(k({pubkey:new V(b.id)})),s.push(k({pubkey:new V(b.id)})),s.push(k({pubkey:new V(b.id)})),s.push(k({pubkey:new V(b.id)})),s.push(k({pubkey:new V(b.id)}))}else if(f.programId===At.CREATE_CPMM_POOL_PROGRAM.toBase58()){let b=f;s.push(k({pubkey:new V(b.authority)})),s.push(k({pubkey:new V(b.config.id)})),s.push(k({pubkey:new V(b.id)})),s.push(k({pubkey:new V(y?b.vault.A:b.vault.B)})),s.push(k({pubkey:new V(y?b.vault.B:b.vault.A)})),s.push(k({pubkey:new V(b.observationId)}))}else throw Error("pool type error")}let a=F([_("insId"),A("amountIn"),A("amountOut"),Y(ne(),i.length,"clmmPriceLimit")]),c=Buffer.alloc(a.span);return a.encode({insId:1,amountIn:new dn(o.data.otherAmountThreshold),amountOut:new dn(o.data.outputAmount),clmmPriceLimit:i},c),new zi({keys:s,programId:l,data:c})}var Cn=new es(0),Qi=class extends Ee{constructor(e){super(e)}async getWSolAccounts(){this.scope.checkOwner(),await this.scope.account.fetchWalletTokenAccounts();let e=this.scope.account.tokenAccounts.filter(t=>t.mint.equals($));return e.sort((t,n)=>t.isAssociated?1:n.isAssociated||t.amount.lt(n.amount)?-1:1),e}async unWrapWSol(e){let{amount:t,tokenProgram:n,txVersion:o=1,feePayer:r}=e,i=await this.getWSolAccounts(),s=this.createTxBuilder(r);s.addCustomComputeBudget(e.computeBudgetConfig);let u=J(t);for(let a=0;a<i.length;a++)u.gte(i[a].amount)?(s.addInstruction({instructions:[kn({tokenAccount:i[a].publicKey,payer:this.scope.ownerPubKey,owner:this.scope.ownerPubKey,programId:n})]}),u.sub(i[a].amount)):s.addInstruction({instructions:[kn({tokenAccount:i[a].publicKey,payer:this.scope.ownerPubKey,owner:this.scope.ownerPubKey,programId:n})]});return s.versionBuild({txVersion:o})}async wrapWSol(e,t,n,o){let r=this.createTxBuilder(o),i=await Wn({connection:this.scope.connection,owner:this.scope.ownerPubKey,payer:this.scope.ownerPubKey,amount:e,skipCloseAccount:!0});return r.addInstruction(i),r.versionBuild({txVersion:n!=null?n:1})}async swap({swapInfo:e,swapPoolKeys:t,ownerInfo:n,computeBudgetConfig:o,routeProgram:r,txVersion:i,feePayer:s}){let u=this.createTxBuilder(s),a=e.amountIn,c=e.amountOut,m=a.amount.token.mint.equals($),p=c.amount.token.mint.equals($),d=a.amount.token.mint,f=c.amount.token.mint,{account:y,instructionParams:b}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:a.amount.token.isToken2022?Jr:je,mint:d,notUseTokenAccount:m,owner:this.scope.ownerPubKey,skipCloseAccount:!m,createInfo:m?{payer:this.scope.ownerPubKey,amount:a.amount.raw}:void 0,associatedOnly:m?!1:n.associatedOnly,checkCreateATAOwner:n.checkCreateATAOwner});if(b&&u.addInstruction(b),y===void 0)throw Error("input account check error");let g;if(e.routeType==="route"&&!p)g=this.scope.account.getAssociatedTokenAccount(f,c.amount.token.isToken2022?Jr:je);else{let{account:T,instructionParams:w}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:c.amount.token.isToken2022?Jr:je,mint:f,notUseTokenAccount:p,owner:this.scope.ownerPubKey,skipCloseAccount:!0,createInfo:{payer:this.scope.ownerPubKey,amount:0},associatedOnly:p?!1:n.associatedOnly,checkCreateATAOwner:n.checkCreateATAOwner});g=T,w&&u.addInstruction(w)}p&&u.addInstruction({endInstructions:[kn({owner:this.scope.ownerPubKey,payer:this.scope.ownerPubKey,tokenAccount:g,programId:je})],endInstructionTypes:[G.CloseAccount]});let P;if(e.routeType==="route"){let T=e.middleToken;P=this.scope.account.getAssociatedTokenAccount(T.mint,T.isToken2022?Jr:je)}let h=t||await this.computePoolToPoolKeys({pools:e.poolInfoList}),I=Vl({routeProgram:r,inputMint:d,swapInfo:q(M({},e),{poolInfo:[...e.poolInfoList],poolKey:h,outputMint:f}),ownerInfo:{wallet:this.scope.ownerPubKey,sourceToken:y,routeToken:P,destinationToken:g}});if(e.feeConfig!==void 0){let T=this.createTxBuilder();T.addInstruction({instructions:[_l(y,e.feeConfig.feeAccount,this.scope.ownerPubKey,e.feeConfig.feeAmount.toNumber())],instructionTypes:[G.TransferAmount]}),T.addInstruction(I);let{transactions:w}=i===0?await T.sizeCheckBuildV0():await T.sizeCheckBuild();w.length<2&&u.addInstruction({instructions:[_l(y,e.feeConfig.feeAccount,this.scope.ownerPubKey,e.feeConfig.feeAmount.toNumber())],instructionTypes:[G.TransferAmount]})}return u.addInstruction(I),i===0?u.sizeCheckBuildV0({computeBudgetConfig:o,address:I.address}):u.sizeCheckBuild({computeBudgetConfig:o,address:I.address})}async fetchRoutePoolBasicInfo(e){let{amm:t=ni,clmm:n=Nn,cpmm:o=vn}=e||{},r=await this.scope.connection.getProgramAccounts(t,{dataSlice:{offset:co.offsetOf("baseMint"),length:64}}),i=F([O("baseMint"),O("quoteMint")]),s=r.map(d=>({id:d.pubkey,version:4,mintA:i.decode(d.account.data).baseMint,mintB:i.decode(d.account.data).quoteMint})),u=F([O("mintA"),O("mintB")]),c=(await this.scope.connection.getProgramAccounts(n,{filters:[{dataSize:ao.span}],dataSlice:{offset:ao.offsetOf("mintA"),length:64}})).map(d=>{let f=u.decode(d.account.data);return{id:d.pubkey,version:6,mintA:f.mintA,mintB:f.mintB}}),p=(await this.scope.connection.getProgramAccounts(o,{dataSlice:{offset:jr.offsetOf("mintA"),length:64}})).map(d=>{let f=u.decode(d.account.data);return{id:d.pubkey,version:7,mintA:f.mintA,mintB:f.mintB}});return{clmmPools:c,ammPools:s,cpmmPools:p}}getAllRoute({inputMint:e,outputMint:t,clmmPools:n,ammPools:o,cpmmPools:r}){e=e.toString()===bo.default.toString()?$:e,t=t.toString()===bo.default.toString()?$:t;let i={},s={},u={},a=[],c={};for(let p of n!=null?n:[]){if((p.mintA.equals(e)&&p.mintB.equals(t)||p.mintA.equals(t)&&p.mintB.equals(e))&&(a.push(p),s[p.id.toString()]=p),p.mintA.equals(e)){let d=p.mintB.toString();c[d]===void 0&&(c[d]={mintProgram:je,in:[],out:[],mDecimals:0}),c[d].in.push(p)}if(p.mintB.equals(e)){let d=p.mintA.toString();c[d]===void 0&&(c[d]={mintProgram:je,in:[],out:[],mDecimals:0}),c[d].in.push(p)}if(p.mintA.equals(t)){let d=p.mintB.toString();c[d]===void 0&&(c[d]={mintProgram:je,in:[],out:[],mDecimals:0}),c[d].out.push(p)}if(p.mintB.equals(t)){let d=p.mintA.toString();c[d]===void 0&&(c[d]={mintProgram:je,in:[],out:[],mDecimals:0}),c[d].out.push(p)}}let m=[];for(let p of o)(p.mintA.equals(e)&&p.mintB.equals(t)||p.mintA.equals(t)&&p.mintB.equals(e))&&(a.push(p),i[p.id.toBase58()]=p,m.push(p)),p.mintA.equals(e)&&(c[p.mintB.toBase58()]===void 0&&(c[p.mintB.toBase58()]={mintProgram:je,in:[],out:[],mDecimals:0}),c[p.mintB.toBase58()].in.push(p)),p.mintB.equals(e)&&(c[p.mintA.toBase58()]===void 0&&(c[p.mintA.toBase58()]={mintProgram:je,in:[],out:[],mDecimals:0}),c[p.mintA.toBase58()].in.push(p)),p.mintA.equals(t)&&(c[p.mintB.toBase58()]===void 0&&(c[p.mintB.toBase58()]={mintProgram:je,in:[],out:[],mDecimals:0}),c[p.mintB.toBase58()].out.push(p)),p.mintB.equals(t)&&(c[p.mintA.toBase58()]===void 0&&(c[p.mintA.toBase58()]={mintProgram:je,in:[],out:[],mDecimals:0}),c[p.mintA.toBase58()].out.push(p));for(let p of r)(p.mintA.equals(e)&&p.mintB.equals(t)||p.mintA.equals(t)&&p.mintB.equals(e))&&(a.push(p),u[p.id.toBase58()]=p),p.mintA.equals(e)&&(c[p.mintB.toBase58()]===void 0&&(c[p.mintB.toBase58()]={mintProgram:je,in:[],out:[],mDecimals:0}),c[p.mintB.toBase58()].in.push(p)),p.mintB.equals(e)&&(c[p.mintA.toBase58()]===void 0&&(c[p.mintA.toBase58()]={mintProgram:je,in:[],out:[],mDecimals:0}),c[p.mintA.toBase58()].in.push(p)),p.mintA.equals(t)&&(c[p.mintB.toBase58()]===void 0&&(c[p.mintB.toBase58()]={mintProgram:je,in:[],out:[],mDecimals:0}),c[p.mintB.toBase58()].out.push(p)),p.mintB.equals(t)&&(c[p.mintA.toBase58()]===void 0&&(c[p.mintA.toBase58()]={mintProgram:je,in:[],out:[],mDecimals:0}),c[p.mintA.toBase58()].out.push(p));for(let p of Object.keys(c)){if(c[p].in.length===1&&c[p].out.length===1&&c[p].in[0].id.equals(c[p].out[0].id)){delete c[p];continue}if(c[p].in.length===0||c[p].out.length===0){delete c[p];continue}let d=c[p];for(let f of d.in)for(let y of d.out)f.version===6&&s[f.id.toString()]===void 0?s[f.id.toString()]=f:f.version===7&&u[f.id.toString()]===void 0?u[f.id.toString()]=f:(f.version===4||f.version===5)&&i[f.id.toString()]===void 0&&(i[f.id.toString()]=f),y.version===6&&s[y.id.toString()]===void 0?s[y.id.toString()]=y:y.version===7&&u[y.id.toString()]===void 0?u[y.id.toString()]=y:(y.version===4||y.version===5)&&i[y.id.toString()]===void 0&&(i[y.id.toString()]=y)}return{directPath:a,addLiquidityPools:m,routePathDict:c,needSimulate:Object.values(i),needTickArray:Object.values(s),cpmmPoolList:Object.values(u)}}async fetchSwapRoutesData({routes:e,inputMint:t,outputMint:n}){let o=new Set([...e.needTickArray.map(y=>[y.mintA.toBase58(),y.mintB.toBase58()]).flat(),t.toString(),n.toString()]);console.log("fetching amm pools info, total: ",e.needSimulate.length);let r=await this.scope.liquidity.getRpcPoolInfos(e.needSimulate.map(y=>y.id)),i=Gr(r),s={};Object.values(i).forEach(y=>{o.delete(y.mintA.address),s[y.mintA.address]={address:new bo(y.mintA.address),programId:je,mintAuthority:null,supply:BigInt(0),decimals:y.mintA.decimals,isInitialized:!0,freezeAuthority:null,tlvData:Buffer.from("0","hex"),feeConfig:void 0},o.delete(y.mintB.address),s[y.mintB.address]={address:new bo(y.mintB.address),programId:je,mintAuthority:null,supply:BigInt(0),decimals:y.mintB.decimals,isInitialized:!0,freezeAuthority:null,tlvData:Buffer.from("0","hex"),feeConfig:void 0}}),console.log("fetching cpmm pools info, total: ",e.cpmmPoolList.length);let u=await this.scope.cpmm.getRpcPoolInfos(e.cpmmPoolList.map(y=>y.id.toBase58()),!0);Object.values(u).forEach(y=>{let[b,g]=[y.mintA.toBase58(),y.mintB.toBase58()];y.mintProgramA.equals(je)?(o.delete(b),s[b]={address:y.mintA,programId:y.mintProgramA,mintAuthority:null,supply:BigInt(0),decimals:y.mintDecimalA,isInitialized:!0,freezeAuthority:null,tlvData:Buffer.from("0","hex"),feeConfig:void 0}):o.add(b),y.mintProgramB.equals(je)?(o.delete(g),s[g]={address:y.mintB,programId:y.mintProgramB,mintAuthority:null,supply:BigInt(0),decimals:y.mintDecimalB,isInitialized:!0,freezeAuthority:null,tlvData:Buffer.from("0","hex"),feeConfig:void 0}):o.add(g)}),console.log("fetching mints info, total: ",o.size);let a=await Io({connection:this.scope.connection,mints:Array.from(o).map(y=>new bo(y))});s=M(M({},s),a);let c=this.scope.cpmm.toComputePoolInfos({pools:u,mintInfos:s});console.log("fetching clmm pools info, total:",e.needTickArray.length);let m=await this.scope.clmm.getRpcClmmPoolInfos({poolIds:e.needTickArray.map(y=>y.id)}),{computeClmmPoolInfo:p,computePoolTickData:d}=await this.scope.clmm.getComputeClmmPoolInfos({clmmPoolsRpcInfo:m,mintInfos:s}),f=Object.keys(e.routePathDict).reduce((y,b)=>q(M({},y),{[b]:q(M({},e.routePathDict[b]),{mintProgram:s[b].programId,mDecimals:s[b].decimals,in:e.routePathDict[b].in.map(g=>i[g.id.toBase58()]||p[g.id.toBase58()]||c[g.id.toBase58()]),out:e.routePathDict[b].out.map(g=>i[g.id.toBase58()]||p[g.id.toBase58()]||c[g.id.toBase58()])})}),{});return{mintInfos:s,ammPoolsRpcInfo:r,ammSimulateCache:i,clmmPoolsRpcInfo:m,computeClmmPoolInfo:p,computePoolTickData:d,computeCpmmData:c,routePathDict:f}}getAllRouteComputeAmountOut({inputTokenAmount:e,outputToken:t,directPath:n,routePathDict:o,simulateCache:r,tickCache:i,slippage:s,chainTime:u,epochInfo:a,feeConfig:c}){var g,P,h,I,T,w,K,x,S;let m=c===void 0?new es(0):e.raw.mul(new es(c.feeBps.toNumber())).div(new es(1e4)),p=e.raw.sub(m),d=new xe(e.token,p),f=c===void 0?void 0:{feeAmount:m,feeAccount:c.feeAccount},y=q(M({},t),{address:dt(t.address).toString()}),b=[];for(let B of n)try{b.push(q(M({},this.computeAmountOut({itemPool:B,tickCache:i,simulateCache:r,chainTime:u,epochInfo:a,slippage:s,outputToken:y,amountIn:d})),{feeConfig:f}))}catch(R){this.logDebug("direct error",B.version,B.id.toString(),R.message)}this.logDebug("direct done");for(let[B,R]of Object.entries(o)){let C={chainId:101,address:B,programId:R.mintProgram.toBase58(),logoURI:"",symbol:"",name:"",decimals:R.mDecimals,tags:[],extensions:{}},v=R.in.map(N=>{try{return{pool:N,data:this.computeAmountOut({itemPool:N,tickCache:i,simulateCache:r,chainTime:u,epochInfo:a,slippage:s,outputToken:C,amountIn:d})}}catch(E){this.logDebug("route in error",N.version,N.id.toString(),E.message);return}}).sort((N,E)=>{var ee,me,re,ue;let X=N===void 0?Cn:N.data.amountOut.amount.raw.sub((me=(ee=N.data.amountOut.fee)==null?void 0:ee.raw)!=null?me:Cn),Q=E===void 0?Cn:E.data.amountOut.amount.raw.sub((ue=(re=E.data.amountOut.fee)==null?void 0:re.raw)!=null?ue:Cn);return X.lt(Q)?1:-1})[0];if(v===void 0)continue;let L=new xe(Er(C),v.data.amountOut.amount.raw.sub((P=(g=v.data.amountOut.fee)==null?void 0:g.raw)!=null?P:Cn));for(let N of R.out)try{let E=this.computeAmountOut({itemPool:N,tickCache:i,simulateCache:r,chainTime:u,epochInfo:a,slippage:s,outputToken:y,amountIn:L});b.push(q(M({},E),{allTrade:!!(v.data.allTrade&&E.allTrade),amountIn:v.data.amountIn,amountOut:E.amountOut,minAmountOut:E.minAmountOut,currentPrice:void 0,executionPrice:new Yi(new Bt({baseToken:v.data.amountIn.amount.token,denominator:v.data.amountIn.amount.raw,quoteToken:E.amountOut.amount.token,numerator:E.amountOut.amount.raw.sub((I=(h=E.amountOut.fee)==null?void 0:h.raw)!=null?I:Cn)}).toFixed()),priceImpact:new Yi(v.data.priceImpact.add(E.priceImpact).toFixed()),fee:[v.data.fee[0],E.fee[0]],routeType:"route",poolInfoList:[v.pool,N],remainingAccounts:[v.data.remainingAccounts[0],E.remainingAccounts[0]],minMiddleAmountFee:(T=E.amountOut.fee)!=null&&T.raw?new xe(v.data.amountOut.amount.token,((K=(w=v.data.amountOut.fee)==null?void 0:w.raw)!=null?K:Cn).add((S=(x=E.amountOut.fee)==null?void 0:x.raw)!=null?S:Cn)):void 0,middleToken:v.data.amountOut.amount.token,poolReady:v.data.poolReady&&E.poolReady,poolType:[v.data.poolType,E.poolType],feeConfig:f,expirationTime:Jt(v.data.expirationTime,E.expirationTime)}))}catch(E){this.logDebug("route out error",N.version,N.id.toString(),E.message)}}return b.filter(B=>(B.allTrade||this.logDebug(`pool ${B.poolInfoList.map(R=>R.id.toString()).join(",")} filter out since not all trade`),B.allTrade)).sort((B,R)=>B.amountOut.amount.raw.sub(R.amountOut.amount.raw).gt(Cn)?-1:1)}computeAmountOut({itemPool:e,tickCache:t,simulateCache:n,chainTime:o,epochInfo:r,slippage:i,outputToken:s,amountIn:u}){if(e.version===6){let{allTrade:a,realAmountIn:c,amountOut:m,minAmountOut:p,expirationTime:d,currentPrice:f,executionPrice:y,priceImpact:b,fee:g,remainingAccounts:P,executionPriceX64:h}=ve.computeAmountOutFormat({poolInfo:e,tickArrayCache:t[e.id.toString()],amountIn:u.raw,tokenOut:s,slippage:i,epochInfo:r,catchLiquidityInsufficient:!0});return{allTrade:a,amountIn:c,amountOut:m,minAmountOut:p,currentPrice:new Yi(f.toFixed()),executionPrice:new Yi(y.toFixed()),priceImpact:new Yi(b.toFixed()),fee:[g],remainingAccounts:[P],routeType:"amm",poolInfoList:[e],poolReady:e.startTime<o,poolType:"CLMM",slippage:i,clmmExPriceX64:[h],expirationTime:Jt(c.expirationTime,d)}}else if(e.version===7){let{allTrade:a,executionPrice:c,amountOut:m,minAmountOut:p,priceImpact:d,fee:f}=this.scope.cpmm.computeSwapAmount({pool:e,outputMint:s.address,amountIn:u.raw,slippage:i});return{allTrade:a,amountIn:{amount:u,fee:void 0,expirationTime:void 0},amountOut:{amount:Ri(q(M({},s),{amount:m})),fee:void 0,expirationTime:void 0},minAmountOut:{amount:Ri(q(M({},s),{amount:p})),fee:void 0,expirationTime:void 0},currentPrice:e.poolPrice,executionPrice:c,priceImpact:d,fee:[new xe(u.token,f)],remainingAccounts:[],routeType:"amm",poolInfoList:[e],poolReady:e.openTime.toNumber()<o,poolType:"CPMM",slippage:i,clmmExPriceX64:[void 0],expirationTime:void 0}}else{if(![1,6,7].includes(n[e.id.toString()].status))throw Error("swap error");let{amountOut:a,minAmountOut:c,currentPrice:m,executionPrice:p,priceImpact:d,fee:f}=this.scope.liquidity.computeAmountOut({poolInfo:n[e.id.toString()],amountIn:u.raw,mintIn:u.token.mint,mintOut:s.address,slippage:i});return{amountIn:{amount:u,fee:void 0,expirationTime:void 0},amountOut:{amount:Ri(q(M({},s),{amount:a})),fee:void 0,expirationTime:void 0},minAmountOut:{amount:Ri(q(M({},s),{amount:c})),fee:void 0,expirationTime:void 0},currentPrice:m,executionPrice:p,priceImpact:d,fee:[new xe(u.token,f)],routeType:"amm",poolInfoList:[e],remainingAccounts:[],poolReady:Number(n[e.id].openTime)<o,poolType:e.version===5?"STABLE":void 0,expirationTime:void 0,allTrade:!0,slippage:i,clmmExPriceX64:[void 0]}}}async computePoolToPoolKeys({pools:e,clmmRpcData:t={},ammRpcData:n={}}){let o=new Set(e.filter(a=>a.version===6&&!t[a.id.toString()]).map(a=>a.id.toString()));if(o.size>0){let a=await this.scope.clmm.getRpcClmmPoolInfos({poolIds:Array.from(o)});Object.keys(a).forEach(c=>{t[c]=a[c]})}let r=new Set(e.filter(a=>a.version===4&&!n[a.id.toString()]).map(a=>a.id.toString()));if(r.size>0){let a=await this.scope.liquidity.getRpcPoolInfos(Array.from(r));Object.keys(a).forEach(c=>{n[c]=a[c]})}let i=new Set(e.filter(a=>a.version===4).map(a=>a.marketId)),s={};i.size>0&&(await Ne(this.scope.connection,Array.from(i).map(c=>({pubkey:new bo(c)})))).forEach(c=>{if(!c.accountInfo)return;let m=Qa.decode(c.accountInfo.data);s[c.pubkey.toBase58()]={marketId:c.pubkey.toString(),marketProgramId:c.accountInfo.owner.toString(),marketAuthority:Zr.getAssociatedAuthority({programId:c.accountInfo.owner,marketId:c.pubkey}).publicKey.toString(),marketBaseVault:m.baseVault.toString(),marketQuoteVault:m.quoteVault.toString(),marketBids:m.bids.toString(),marketAsks:m.asks.toString(),marketEventQueue:m.eventQueue.toString()}});let u=[];return e.forEach(a=>{if(a.version===6){let c=t[a.id.toString()],m={programId:a.programId.toBase58(),id:a.id.toBase58(),mintA:a.mintA,mintB:a.mintB,openTime:String(a.startTime),vault:{A:c.vaultA.toBase58(),B:c.vaultB.toBase58()},config:q(M({},a.ammConfig),{id:a.ammConfig.id.toString(),defaultRange:0,defaultRangePoint:[]}),rewardInfos:[],observationId:a.observationId.toBase58(),exBitmapAccount:a.exBitmapAccount.toBase58()};u.push(m)}else if(a.version===4){let c=n[a.id.toString()],m=M({programId:a.programId,id:a.id,mintA:a.mintA,mintB:a.mintB,openTime:String(a.openTime),vault:{A:c.baseVault.toBase58(),B:c.quoteVault.toBase58()},authority:_a({programId:new bo(a.programId)}).publicKey.toString(),openOrders:c.openOrders.toBase58(),targetOrders:c.targetOrders.toBase58(),mintLp:a.lpMint},s[a.marketId]);u.push(m)}else a.version===7&&u.push({observationId:a.observationId.toBase58(),programId:a.programId.toBase58(),id:a.id.toBase58(),mintA:a.mintA,mintB:a.mintB,openTime:String(a.openTime),authority:Wo(a.programId).publicKey.toBase58(),vault:{A:a.vaultA.toBase58(),B:a.vaultB.toBase58()},mintLp:yt({address:a.mintLp.toBase58(),programId:je.toBase58(),decimals:a.lpDecimals}),config:q(M({id:a.configId.toBase58()},a.configInfo),{protocolFeeRate:a.configInfo.protocolFeeRate.toNumber(),tradeFeeRate:a.configInfo.tradeFeeRate.toNumber(),fundFeeRate:a.configInfo.fundFeeRate.toNumber(),createPoolFee:a.configInfo.createPoolFee.toString()})})}),u}};import{PublicKey as cf,Transaction as Za,TransactionInstruction as lf}from"@solana/web3.js";import{TOKEN_PROGRAM_ID as mf}from"@solana/spl-token";import El from"bn.js";var bt=class extends Ee{static getPdaPoolId(e,t){return te([bt.SEED_CONFIG.pool.id,t.toBuffer()],e)}static getPdaOwnerId(e,t,n,o){return te([bt.SEED_CONFIG.owner.id,t.toBuffer(),n.toBuffer(),Buffer.from(new El(o).toArray())],e)}static async getAllInfo({connection:e,programId:t,poolIds:n,wallet:o,chainTime:r}){if(n.length===0)return[];let i=n.map(c=>bt.getPdaPoolId(t,c).publicKey),s=[];for(let c=0;c<bt.VERSION_PROJECT.length;c++)s.push(...i.map(m=>bt.getPdaOwnerId(t,m,o,c).publicKey));let u=await Zt(e,[...i,...s]),a=[];for(let c=0;c<u.length;c++){let m=Math.floor(c/n.length),p=c%n.length,d=i[p],f=s[c],y=u[p],b=u[n.length+c];if(!(y&&b)||y.data.length!==bt.POOL_LAYOUT.span||b.data.length!==bt.OWNER_LAYOUT.span)continue;let g=bt.POOL_LAYOUT.decode(y.data),P=bt.OWNER_LAYOUT.decode(b.data),h=g.openTime.toNumber(),I=g.endTime.toNumber(),T=P.tokenInfo.map(x=>x.debtAmount.gt(new El(0))).filter(x=>!x).length!==3,w=r>h&&r<I&&g.status===1,K=T&&w;a.push({programId:t,poolId:d,ammId:g.ammId,ownerAccountId:f,snapshotLpAmount:P.lpAmount,project:bt.VERSION_PROJECT[m],openTime:h,endTime:I,canClaim:K,canClaimErrorType:T?w?void 0:"outOfOperationalTime":"alreadyClaimIt",tokenInfo:g.tokenInfo.map((x,S)=>({mintAddress:x.mintAddress,mintVault:x.mintVault,mintDecimals:x.mintDecimals,perLpLoss:x.perLpLoss,debtAmount:P.tokenInfo[S].debtAmount.add(P.tokenInfo[S].claimedAmount)}))})}return a}async makeClaimTransaction({poolInfo:e,ownerInfo:t,feePayer:n}){t.wallet||this.scope.checkOwner();let o=this.createTxBuilder(n),r=t.wallet||this.scope.ownerPubKey,i=[];for(let a of e.tokenInfo){let{account:c,instructionParams:m}=await this.scope.account.getOrCreateTokenAccount({mint:a.mintAddress,owner:this.scope.ownerPubKey,notUseTokenAccount:a.mintAddress.equals(Ge.WSOL.mint),createInfo:{payer:r,amount:0},skipCloseAccount:!a.mintAddress.equals(Ge.WSOL.mint),associatedOnly:a.mintAddress.equals(Ge.WSOL.mint)?!1:t.associatedOnly});m&&o.addInstruction(m),i.push(c)}o.addInstruction({instructions:[bt.makeClaimInstruction({programId:e.programId,poolInfo:e,ownerInfo:{wallet:r,ownerPda:e.ownerAccountId,claimAddress:i}})]});let{transaction:s,signers:u}=o.build();return[{transaction:s,signer:u}]}async makeClaimAllTransaction({poolInfos:e,ownerInfo:t,feePayer:n}){let o=this.createTxBuilder(n),r=t.wallet||this.scope.ownerPubKey,i={};for(let c of e){let m=[];for(let p of c.tokenInfo){let{account:d,instructionParams:f}=await this.scope.account.getOrCreateTokenAccount({mint:p.mintAddress,owner:this.scope.ownerPubKey,notUseTokenAccount:p.mintAddress.equals(Ge.WSOL.mint),createInfo:{payer:r,amount:0},skipCloseAccount:!p.mintAddress.equals(Ge.WSOL.mint),associatedOnly:p.mintAddress.equals(Ge.WSOL.mint)?!1:t.associatedOnly});f&&o.addInstruction(f),d&&(i[p.mintAddress.toString()]=d,m.push(d))}o.addInstruction({instructions:[bt.makeClaimInstruction({programId:c.programId,poolInfo:c,ownerInfo:{wallet:r,ownerPda:c.ownerAccountId,claimAddress:m}})]})}let{transaction:s,signers:u}=o.build(),a=o.allInstructions;return br(a,[r,...u.map(c=>c.publicKey)])?[{transaction:s,signer:u}]:[{transaction:new Za().add(...a.slice(0,o.AllTxData.instructions.length-1)),signer:u},{transaction:new Za().add(...a.slice(o.AllTxData.instructions.length-1)),signer:[]},{transaction:new Za().add(...o.AllTxData.endInstructions),signer:[]}]}static makeClaimInstruction({programId:e,poolInfo:t,ownerInfo:n}){let o=F([]),r=[{pubkey:n.wallet,isSigner:!0,isWritable:!0},{pubkey:t.poolId,isSigner:!1,isWritable:!0},{pubkey:n.ownerPda,isSigner:!1,isWritable:!0},...n.claimAddress.map(u=>({pubkey:u,isSigner:!1,isWritable:!0})),...t.tokenInfo.map(({mintVault:u})=>({pubkey:u,isSigner:!1,isWritable:!0})),{pubkey:mf,isSigner:!1,isWritable:!1}],i=Buffer.alloc(o.span);o.encode({},i);let s=Buffer.from([10,66,208,184,161,6,191,98,...i]);return new lf({keys:r,programId:e,data:s})}},Yt=bt;Yt.CLAIMED_NUM=3,Yt.POOL_LAYOUT=F([Te(8),_("bump"),_("status"),A("openTime"),A("endTime"),O("ammId"),Y(F([_("mintDecimals"),O("mintAddress"),O("mintVault"),A("perLpLoss"),A("totalClaimedAmount")]),bt.CLAIMED_NUM,"tokenInfo"),Y(A(),10,"padding")]),Yt.OWNER_LAYOUT=F([Te(8),_("bump"),_("version"),O("poolId"),O("owner"),A("lpAmount"),Y(F([O("mintAddress"),A("debtAmount"),A("claimedAmount")]),bt.CLAIMED_NUM,"tokenInfo"),Y(A(),4,"padding")]),Yt.DEFAULT_POOL_ID=["58oQChx4yWmvKdwLLZzBi4ChoCc2fqCUWBkwMihLYQo2","6UmmUiYoBjSrhakAobJw8BvkmJtDVxaeBtbt7rxWo1mg","AVs9TA4nWDzfPJE9gGVNJMVhcQy3V9PGazuz33BfG2RA","DVa7Qmb5ct9RCpaU7UTpSaf3GVMYz17vNVU67XpdCRut","7XawhbbxtsRcQA8KTkHT9f9nc6d69UwqCDh6U5EEbEmX","6a1CsrpeZubDjEJE9s1CMVheB6HWM5d7m1cj2jkhyXhj","EoNrn8iUhwgJySD1pHu8Qxm5gSQqLK3za4m8xzD2RuEb","AceAyRTWt4PyB2pHqf2qhDgNZDtKVNaxgL8Ru3V4aN1P","6tmFJbMk5yVHFcFy7X2K8RwHjKLr6KVFLYXpgpBNeAxB"].map(e=>new cf(e)),Yt.SEED_CONFIG={pool:{id:Buffer.from("pool_seed","utf8")},owner:{id:Buffer.from("user_claim_seed","utf8")}},Yt.VERSION_PROJECT=[void 0,"Francium","Tulip","Larix"];import{PublicKey as ji}from"@solana/web3.js";import Wl from"bn.js";import{SYSVAR_CLOCK_PUBKEY as df,TransactionInstruction as eu}from"@solana/web3.js";import{TOKEN_PROGRAM_ID as tu}from"@solana/spl-token";var Ja=F([_("instruction"),oc("amount")]),Hi=F([_("instruction")]);function rC({programId:l,amount:e,instructionKeys:t}){let n=[{pubkey:mr,isSigner:!1,isWritable:!1},{pubkey:tu,isSigner:!1,isWritable:!1},{pubkey:$e,isSigner:!1,isWritable:!1},{pubkey:Ts,isSigner:!1,isWritable:!1},...Object.entries(t).map(([r,i])=>({pubkey:i,isSigner:r==="userOwner",isWritable:!["authority","userOwner","userIdoCheck","userStakeInfo"].includes(r)}))],o=Buffer.alloc(Ja.span);return Ja.encode({instruction:1,amount:Number(e)},o),new eu({keys:n,programId:l,data:o})}function ts({programId:l},e){let t=[{pubkey:tu,isSigner:!1,isWritable:!1},{pubkey:Ts,isSigner:!1,isWritable:!1},...Object.entries(e).map(([o,r])=>({pubkey:r,isSigner:o==="userOwner",isWritable:!["authority","userOwner"].includes(o)}))],n=Buffer.alloc(Hi.span);return Hi.encode({instruction:2},n),new eu({keys:t,programId:l,data:n})}function nu(l){let{poolConfig:e,userKeys:t,side:n}=l,o=n==="base"?t.baseTokenAccount:t.quoteTokenAccount,r=n==="base"?e.baseVault:e.quoteVault,i=Buffer.alloc(Hi.span);Hi.encode({instruction:2},i);let s=[{pubkey:tu,isWritable:!1,isSigner:!1},{pubkey:df,isWritable:!1,isSigner:!1},{pubkey:e.id,isWritable:!0,isSigner:!1},{pubkey:e.authority,isWritable:!1,isSigner:!1},{pubkey:r,isWritable:!0,isSigner:!1},{pubkey:o,isWritable:!0,isSigner:!1},{pubkey:t.ledgerAccount,isWritable:!0,isSigner:!1},{pubkey:t.owner,isWritable:!1,isSigner:!0}];return new eu({programId:e.programId,keys:s,data:i})}var pf={[si.IDO_PROGRAM_ID_V1.toString()]:1,[si.IDO_PROGRAM_ID_V2.toString()]:2,[si.IDO_PROGRAM_ID_V3.toString()]:3,[si.IDO_PROGRAM_ID_V4.toString()]:4},Uo=class extends Ee{async claim({ownerInfo:e,idoKeys:t,associatedOnly:n=!0,checkCreateATAOwner:o=!1,txVersion:r,feePayer:i}){let s=this.createTxBuilder(i),u=pf[t.programId];u||this.logAndCreateError("invalid version",u);let a=_e(t),[c,m]=[!new Wl(e.coin).isZero(),!new Wl(e.pc).isZero()],p=a.projectInfo.mint.address.equals($),{account:d,instructionParams:f}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:a.projectInfo.mint.programId,mint:a.projectInfo.mint.address,owner:this.scope.ownerPubKey,createInfo:{payer:this.scope.ownerPubKey,amount:0},skipCloseAccount:!p,notUseTokenAccount:p,associatedOnly:p?!1:n,checkCreateATAOwner:o});!d&&c&&this.logAndCreateError("target token accounts not found","mint",t.projectInfo.mint.address),c&&f&&s.addInstruction(f);let y=a.buyInfo.mint.address.equals($),{account:b,instructionParams:g}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:a.buyInfo.mint.programId,mint:a.buyInfo.mint.address,owner:this.scope.ownerPubKey,createInfo:{payer:this.scope.ownerPubKey,amount:0},skipCloseAccount:!y,notUseTokenAccount:y,associatedOnly:y?!1:n,checkCreateATAOwner:o});if(!d&&m&&this.logAndCreateError("target token accounts not found","mint",t.projectInfo.mint.address),m&&g&&s.addInstruction(g),(!d||!b)&&this.logAndCreateError("target token accounts not found","mint",t.projectInfo.mint.address,t.buyInfo.mint.address),u===3)return s.addInstruction({instructions:[...c?[ts({programId:a.programId},{idoId:a.id,authority:a.authority,poolTokenAccount:a.projectInfo.vault,userTokenAccount:d,userIdoInfo:new ji(e.userIdoInfo),userOwner:this.scope.ownerPubKey})]:[],...m?[ts({programId:new ji(t.programId)},{idoId:a.id,authority:a.authority,poolTokenAccount:a.buyInfo.vault,userTokenAccount:b,userIdoInfo:new ji(e.userIdoInfo),userOwner:this.scope.ownerPubKey})]:[]]}).versionBuild({txVersion:r});if(u<3)return!c&&!m&&this.logAndCreateError("no claimable rewards"),s.addInstruction({instructions:[ts({programId:a.programId},{idoId:a.id,authority:a.authority,poolQuoteTokenAccount:a.buyInfo.vault,poolBaseTokenAccount:a.projectInfo.vault,userQuoteTokenAccount:b,userBaseTokenAccount:d,userIdoInfo:new ji(e.userIdoInfo),userOwner:this.scope.ownerPubKey})]}).versionBuild({txVersion:r});let P={poolConfig:{id:a.id,programId:a.programId,authority:a.authority,baseVault:a.projectInfo.vault,quoteVault:a.buyInfo.vault,baseToken:t.projectInfo.mint,quoteToken:t.buyInfo.mint},userKeys:{baseTokenAccount:d,quoteTokenAccount:b,ledgerAccount:new ji(e.userIdoInfo),owner:this.scope.ownerPubKey}};return s.addInstruction({instructions:[...c?[nu(q(M({},P),{side:"base"}))]:[],...m?[nu(q(M({},P),{side:"quote"}))]:[]]}).versionBuild({txVersion:r})}};var Dl=(t=>(t[t.OnlyTokenB=0]="OnlyTokenB",t[t.BothToken=1]="BothToken",t))(Dl||{});var ff=Buffer.from("vault_auth_seed","utf8"),yf=Buffer.from("global_config","utf8"),bf=Buffer.from("pool_vesting","utf8"),gf=Buffer.from("platform_config","utf8"),Pf=Buffer.from("platform_fee_vault_auth_seed","utf8"),Af=Buffer.from("creator_fee_vault_auth_seed","utf8");function pn(l){return te([ff],l)}function BC(l,e,t,n){return te([yf,e.toBuffer(),kf(t),Fr(n)],l)}function Go(l,e,t){return te([ga,e.toBuffer(),t.toBuffer()],l)}function ou(l,e,t){return te([Pa,e.toBuffer(),t.toBuffer()],l)}function Yn(l){return te([Buffer.from("__event_authority","utf8")],l)}function kf(l){let e=new ArrayBuffer(1);return new DataView(e).setUint8(0,l),new Uint8Array(e)}function iu(l,e){return te([gf,e.toBuffer()],l)}function $i(l,e,t){return te([bf,e.toBuffer(),t.toBuffer()],l)}function go(l,e,t){return te([e.toBuffer(),t.toBuffer()],l)}function ru(l){return te([Pf],l)}function Po(l,e,t){return te([e.toBuffer(),t.toBuffer()],l)}function su(l){return te([Af],l)}import{ASSOCIATED_TOKEN_PROGRAM_ID as ns,TOKEN_2022_PROGRAM_ID as hf,TOKEN_PROGRAM_ID as Zi}from"@solana/spl-token";import{SystemProgram as Lt,TransactionInstruction as gt}from"@solana/web3.js";import Rn from"bn.js";var Qn=F([A(),A("epoch"),_("curveType"),Ft("index"),A("migrateFee"),A("tradeFeeRate"),A("maxShareFeeRate"),A("minSupplyA"),A("maxLockRate"),A("minSellRateA"),A("minMigrateRateA"),A("minFundRaisingB"),O("mintB"),O("protocolFeeOwner"),O("migrateFeeOwner"),O("migrateToAmmWallet"),O("migrateToCpmmWallet"),Y(A(),16)]),wf=F([A("totalLockedAmount"),A("cliffPeriod"),A("unlockPeriod"),A("startTime"),A("totalAllocatedShare")]),on=F([A(),A("epoch"),_("bump"),_("status"),_("mintDecimalsA"),_("mintDecimalsB"),_("migrateType"),A("supply"),A("totalSellA"),A("virtualA"),A("virtualB"),A("realA"),A("realB"),A("totalFundRaisingB"),A("protocolFee"),A("platformFee"),A("migrateFee"),wf.replicate("vestingSchedule"),O("configId"),O("platformId"),O("mintA"),O("mintB"),O("vaultA"),O("vaultB"),O("creator"),_("mintProgramFlag"),_("cpmmCreatorFeeOn"),Y(_(),62)]),SC=F([A(),A("epoch"),O("poolId"),O("beneficiary"),A("claimedAmount"),A("tokenShareAmount"),Y(A(),8)]),au=F([_("migrateType"),_("migrateCpmmFeeOn"),A("supply"),A("totalSellA"),A("totalFundRaisingB"),A("totalLockedAmount"),A("cliffPeriod"),A("unlockPeriod")]),Tf=F([A("epoch"),_("index"),O("configId"),au.replicate("bondingCurveParam"),Y(A(),50)]),Xo=F([A(),A("epoch"),O("platformClaimFeeWallet"),O("platformLockNftWallet"),A("platformScale"),A("creatorScale"),A("burnScale"),A("feeRate"),Y(_(),64,"name"),Y(_(),256,"web"),Y(_(),256,"img"),O("cpConfigId"),A("creatorFeeRate"),O("transferFeeExtensionAuth"),Y(_(),180),cc(Tf,"platformCurve")]);var Pt={initialize:Buffer.from([175,175,109,31,13,152,155,237]),initializeV2:Buffer.from([67,153,175,39,218,16,38,32]),buyExactIn:Buffer.from([250,234,13,123,213,156,19,236]),buyExactOut:Buffer.from([24,211,116,40,105,3,153,56]),sellExactIn:Buffer.from([149,39,222,155,211,124,152,26]),sellExactOut:Buffer.from([95,200,71,34,8,9,11,166]),createVestingAccount:Buffer.from([129,178,2,13,217,172,230,218]),claimVestedToken:Buffer.from([49,33,104,30,189,157,79,35]),createPlatformConfig:Buffer.from([176,90,196,175,253,113,220,20]),claimPlatformFee:Buffer.from([156,39,208,135,76,237,61,72]),updatePlaformConfig:Buffer.from([195,60,76,129,146,45,67,143]),initializeWithToken2022:Buffer.from([37,190,126,222,44,154,171,17]),claimPlatformFeeFromVault:Buffer.from([117,241,198,168,248,218,80,29]),claimCreatorFee:Buffer.from([26,97,138,203,132,171,141,252]),updatePlatformCurveParam:Buffer.from([138,144,138,250,220,128,4,57]),removePlatformCurveParam:Buffer.from([27,30,62,169,93,224,24,145])};function WC(l,e,t,n,o,r,i,s,u,a,c,m,p,d,f,y,b,g,P,h){throw new Error("*** launchlab initialize has been deprecated, please use initializeV2 instead! ***")}function Ul(l,e,t,n,o,r,i,s,u,a,c,m,p,d,f,y,b,g,P,h,I){let T=F([_("decimals"),lt("name"),lt("symbol"),lt("uri")]),w=F([A("totalLockedAmount"),A("cliffPeriod"),A("unlockPeriod"),_("cpmmCreatorFeeOn")]),K=F([_("index"),A("supply"),A("totalFundRaisingB"),_("migrateType")]),x=F([_("index"),A("supply"),A("totalSellA"),A("totalFundRaisingB"),_("migrateType")]),S=[{pubkey:e,isSigner:!0,isWritable:!0},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!1,isWritable:!1},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!0,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!1},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:m,isSigner:!1,isWritable:!0},{pubkey:Zi,isSigner:!1,isWritable:!1},{pubkey:Zi,isSigner:!1,isWritable:!1},{pubkey:Dt,isSigner:!1,isWritable:!1},{pubkey:Lt.programId,isSigner:!1,isWritable:!1},{pubkey:$e,isSigner:!1,isWritable:!1},{pubkey:Yn(l).publicKey,isSigner:!1,isWritable:!1},{pubkey:l,isSigner:!1,isWritable:!1}],B=Buffer.alloc(Buffer.from(d,"utf-8").length+Buffer.from(f,"utf-8").length+Buffer.from(y,"utf-8").length+4*3+1),R=Buffer.alloc(w.span),C=Buffer.alloc(b.type==="ConstantCurve"?x.span:K.span);return T.encode({decimals:p,name:d,symbol:f,uri:y},B),b.type==="ConstantCurve"?x.encode(q(M({index:0},b),{migrateType:b.migrateType==="amm"?0:1}),C):b.type==="FixedCurve"?K.encode(q(M({index:1},b),{migrateType:b.migrateType==="amm"?0:1}),C):b.type==="LinearCurve"&&K.encode(q(M({index:2},b),{migrateType:b.migrateType==="amm"?0:1}),C),w.encode({totalLockedAmount:g,cliffPeriod:P,unlockPeriod:h,cpmmCreatorFeeOn:I},R),new gt({keys:S,programId:l,data:Buffer.from([...Pt.initializeV2,...B,...C,...R])})}function Gl(l,e,t,n,o,r,i,s,u,a,c,m,p,d,f,y,b,g,P,h,I){let T=F([_("decimals"),lt("name"),lt("symbol"),lt("uri")]),w=F([A("totalLockedAmount"),A("cliffPeriod"),A("unlockPeriod"),_("cpmmCreatorFeeOn"),_("transferFeeExtensionParamsOption"),F([Ft("transferFeeBasePoints"),A("maxinumFee")]).replicate("transferFeeExtensionParams")]),K=F([_("index"),A("supply"),A("totalFundRaisingB"),_("migrateType")]),x=F([_("index"),A("supply"),A("totalSellA"),A("totalFundRaisingB"),_("migrateType")]),S=[{pubkey:e,isSigner:!0,isWritable:!0},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!1,isWritable:!1},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!0,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!1},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:hf,isSigner:!1,isWritable:!1},{pubkey:Zi,isSigner:!1,isWritable:!1},{pubkey:Lt.programId,isSigner:!1,isWritable:!1},{pubkey:Yn(l).publicKey,isSigner:!1,isWritable:!1},{pubkey:l,isSigner:!1,isWritable:!1}],B=Buffer.alloc(Buffer.from(p,"utf-8").length+Buffer.from(d,"utf-8").length+Buffer.from(f,"utf-8").length+4*3+1),R=Buffer.alloc(w.span),C=Buffer.alloc(y.type==="ConstantCurve"?x.span:K.span);return T.encode({decimals:m,name:p,symbol:d,uri:f},B),y.type==="ConstantCurve"?x.encode(q(M({index:0},y),{migrateType:y.migrateType==="amm"?0:1}),C):y.type==="FixedCurve"?K.encode(q(M({index:1},y),{migrateType:y.migrateType==="amm"?0:1}),C):y.type==="LinearCurve"&&K.encode(q(M({index:2},y),{migrateType:y.migrateType==="amm"?0:1}),C),w.encode({totalLockedAmount:b,cliffPeriod:g,unlockPeriod:P,cpmmCreatorFeeOn:h,transferFeeExtensionParamsOption:I?1:0,transferFeeExtensionParams:I!=null?I:{transferFeeBasePoints:0,maxinumFee:new Rn(0)}},R),new gt({keys:S,programId:l,data:Buffer.from([...Pt.initializeWithToken2022,...B,...C,...R])})}function Xl(l,e,t,n,o,r,i,s,u,a,c,m,p,d,f,y,b,g,P,h){let I=F([A("amountB"),A("minAmountA"),A("shareFeeRate")]),T=[{pubkey:e,isSigner:!0,isWritable:!0},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!1},{pubkey:m,isSigner:!1,isWritable:!1},{pubkey:p,isSigner:!1,isWritable:!1},{pubkey:d,isSigner:!1,isWritable:!1},{pubkey:Yn(l).publicKey,isSigner:!1,isWritable:!1},{pubkey:l,isSigner:!1,isWritable:!1}];h&&T.push({pubkey:h,isSigner:!1,isWritable:!0}),T.push({pubkey:Lt.programId,isSigner:!1,isWritable:!1}),T.push({pubkey:f,isSigner:!1,isWritable:!0}),T.push({pubkey:y,isSigner:!1,isWritable:!0});let w=Buffer.alloc(I.span);return I.encode({amountB:b,minAmountA:g,shareFeeRate:P!=null?P:new Rn(0)},w),new gt({keys:T,programId:l,data:Buffer.from([...Pt.buyExactIn,...w])})}function zl(l,e,t,n,o,r,i,s,u,a,c,m,p,d,f,y,b,g,P,h){let I=F([A("amountA"),A("maxAmountB"),A("shareFeeRate")]),T=[{pubkey:e,isSigner:!0,isWritable:!0},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!1},{pubkey:m,isSigner:!1,isWritable:!1},{pubkey:p,isSigner:!1,isWritable:!1},{pubkey:d,isSigner:!1,isWritable:!1},{pubkey:Yn(l).publicKey,isSigner:!1,isWritable:!1},{pubkey:l,isSigner:!1,isWritable:!1}];h&&T.push({pubkey:h,isSigner:!1,isWritable:!0}),T.push({pubkey:Lt.programId,isSigner:!1,isWritable:!1}),T.push({pubkey:f,isSigner:!1,isWritable:!0}),T.push({pubkey:y,isSigner:!1,isWritable:!0});let w=Buffer.alloc(I.span);return I.encode({amountA:b,maxAmountB:g,shareFeeRate:P!=null?P:new Rn(0)},w),new gt({keys:T,programId:l,data:Buffer.from([...Pt.buyExactOut,...w])})}function Yl(l,e,t,n,o,r,i,s,u,a,c,m,p,d,f,y,b,g,P,h){let I=F([A("amountA"),A("minAmountB"),A("shareFeeRate")]),T=[{pubkey:e,isSigner:!0,isWritable:!0},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!1},{pubkey:m,isSigner:!1,isWritable:!1},{pubkey:p,isSigner:!1,isWritable:!1},{pubkey:d,isSigner:!1,isWritable:!1},{pubkey:Yn(l).publicKey,isSigner:!1,isWritable:!1},{pubkey:l,isSigner:!1,isWritable:!1}];h&&T.push({pubkey:h,isSigner:!1,isWritable:!0}),T.push({pubkey:Lt.programId,isSigner:!1,isWritable:!1}),T.push({pubkey:f,isSigner:!1,isWritable:!0}),T.push({pubkey:y,isSigner:!1,isWritable:!0});let w=Buffer.alloc(I.span);return I.encode({amountA:b,minAmountB:g,shareFeeRate:P!=null?P:new Rn(0)},w),new gt({keys:T,programId:l,data:Buffer.from([...Pt.sellExactIn,...w])})}function Ql(l,e,t,n,o,r,i,s,u,a,c,m,p,d,f,y,b,g,P,h){let I=F([A("amountB"),A("maxAmountA"),A("shareFeeRate")]),T=[{pubkey:e,isSigner:!0,isWritable:!0},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!1},{pubkey:m,isSigner:!1,isWritable:!1},{pubkey:p,isSigner:!1,isWritable:!1},{pubkey:d,isSigner:!1,isWritable:!1},{pubkey:Yn(l).publicKey,isSigner:!1,isWritable:!1},{pubkey:l,isSigner:!1,isWritable:!1}];h&&T.push({pubkey:h,isSigner:!1,isWritable:!0}),T.push({pubkey:Lt.programId,isSigner:!1,isWritable:!1}),T.push({pubkey:f,isSigner:!1,isWritable:!0}),T.push({pubkey:y,isSigner:!1,isWritable:!0});let w=Buffer.alloc(I.span);return I.encode({amountB:b,maxAmountA:g,shareFeeRate:P!=null?P:new Rn(0)},w),new gt({keys:T,programId:l,data:Buffer.from([...Pt.sellExactOut,...w])})}function cu(l,e,t,n,o,r,i,s,u){let a=F([]),c=[{pubkey:e,isSigner:!0,isWritable:!0},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!1},{pubkey:u,isSigner:!1,isWritable:!1},{pubkey:Lt.programId,isSigner:!1,isWritable:!1},{pubkey:ns,isSigner:!1,isWritable:!1}],m=Buffer.alloc(a.span);return a.encode({},m),new gt({keys:c,programId:l,data:Buffer.from([...Pt.claimVestedToken,...m])})}function lu(l,e,t,n,o,r){let i=F([A("shareAmount")]),s=[{pubkey:e,isSigner:!0,isWritable:!0},{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:Lt.programId,isSigner:!1,isWritable:!1}],u=Buffer.alloc(i.span);return i.encode({shareAmount:r},u),new gt({keys:s,programId:l,data:Buffer.from([...Pt.createVestingAccount,...u])})}function mu(l,e,t,n,o,r,i,s,u){let a=[{pubkey:e,isSigner:!0,isWritable:!0},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:Lt.programId,isSigner:!1,isWritable:!0},{pubkey:ns,isSigner:!1,isWritable:!0}];return new gt({keys:a,programId:l,data:Pt.claimPlatformFee})}function Hl(l,e,t,n,o,r,i,s,u,a,c,m,p){let d=F([A("platformScale"),A("creatorScale"),A("burnScale"),A("feeRate"),lt("name"),lt("web"),lt("img"),A("creatorFeeRate")]),f=[{pubkey:e,isSigner:!0,isWritable:!0},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:Lt.programId,isSigner:!1,isWritable:!1},{pubkey:i,isSigner:!1,isWritable:!1}],y=Buffer.alloc(8*5+Buffer.from(c,"utf-8").length+Buffer.from(m,"utf-8").length+Buffer.from(p,"utf-8").length+4*3);return d.encode({platformScale:s.platformScale,creatorScale:s.creatorScale,burnScale:s.burnScale,feeRate:u,name:c,web:m,img:p,creatorFeeRate:a},y),new gt({keys:f,programId:l,data:Buffer.from([...Pt.createPlatformConfig,...y])})}function jl(l,e,t,n){let o=[{pubkey:e,isSigner:!0,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!0}],r;if(n.type==="updateClaimFeeWallet"){let i=F([_("index"),O("value")]);r=Buffer.alloc(i.span),i.encode({index:0,value:n.value},r)}else if(n.type==="updateLockNftWallet"){let i=F([_("index"),O("value")]);r=Buffer.alloc(i.span),i.encode({index:1,value:n.value},r)}else if(n.type==="migrateCpLockNftScale"){let i=F([_("index"),A("platformScale"),A("creatorScale"),A("burnScale")]);r=Buffer.alloc(i.span),i.encode(M({index:2},n.value),r)}else if(n.type==="updateFeeRate"){let i=F([_("index"),A("value")]);r=Buffer.alloc(i.span),i.encode({index:3,value:n.value},r)}else if(n.type==="updateImg"||n.type==="updateName"||n.type==="updateWeb"){let i=F([_("index"),lt("value")]);r=Buffer.alloc(Buffer.from(n.value,"utf-8").length+4+1*1),n.type==="updateName"?i.encode({index:4,value:n.value},r):n.type==="updateWeb"?i.encode({index:5,value:n.value},r):n.type==="updateImg"&&i.encode({index:6,value:n.value},r)}else if(n.type==="updateCpConfigId"){o.push({pubkey:n.value,isSigner:!1,isWritable:!1});let i=F([_("index")]);r=Buffer.alloc(i.span),i.encode({index:7},r)}else if(n.type==="updateAll"){o.push({pubkey:n.value.cpConfigId,isSigner:!1,isWritable:!1});let i=F([_("index"),O("platformClaimFeeWallet"),O("platformLockNftWallet"),A("platformScale"),A("creatorScale"),A("burnScale"),A("feeRate"),lt("name"),lt("web"),lt("img"),O("transferFeeExtensionAuth"),A("creatorFeeRate")]);r=Buffer.alloc(1+32+32+8*4+4*3+Buffer.from(n.value.name,"utf-8").length+Buffer.from(n.value.web,"utf-8").length+Buffer.from(n.value.img,"utf-8").length+32+8),i.encode({index:8,platformClaimFeeWallet:n.value.platformClaimFeeWallet,platformLockNftWallet:n.value.platformLockNftWallet,platformScale:n.value.migrateCpLockNftScale.platformScale,creatorScale:n.value.migrateCpLockNftScale.creatorScale,burnScale:n.value.migrateCpLockNftScale.burnScale,feeRate:n.value.feeRate,name:n.value.name,web:n.value.web,img:n.value.img,transferFeeExtensionAuth:n.value.transferFeeExtensionAuth,creatorFeeRate:n.value.creatorFeeRate},r)}else throw Error("updateInfo params type error");return new gt({keys:o,programId:l,data:Buffer.from([...Pt.updatePlaformConfig,...r])})}function du(l,e,t,n,o,r,i,s){let u=[{pubkey:t,isSigner:!0,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:e,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!1},{pubkey:s,isSigner:!1,isWritable:!1},{pubkey:Lt.programId,isSigner:!1,isWritable:!1},{pubkey:ns,isSigner:!1,isWritable:!1}];return new gt({keys:u,programId:l,data:Pt.claimPlatformFeeFromVault})}function pu(l,e,t,n,o,r,i){let s=[{pubkey:e,isSigner:!0,isWritable:!0},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!1},{pubkey:i,isSigner:!1,isWritable:!1},{pubkey:Lt.programId,isSigner:!1,isWritable:!1},{pubkey:ns,isSigner:!1,isWritable:!1}];return new gt({keys:s,programId:l,data:Pt.claimCreatorFee})}var ql=255,uu=new Rn("18446744073709551615");function DC(l,e,t,n,o,r){let i=[{pubkey:e,isSigner:!0,isWritable:!0},{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:Lt.programId,isSigner:!1,isWritable:!1}],s=Buffer.alloc(1*2+8*6+_().span);return _().encode(o,s),au.encode({migrateType:r.migrateType?r.migrateType:ql,migrateCpmmFeeOn:r.migrateCpmmFeeOn?r.migrateCpmmFeeOn:ql,supply:r.supply?r.supply:new Rn(0),totalSellA:r.totalSellA?r.totalSellA:new Rn(0),totalFundRaisingB:r.totalFundRaisingB?r.totalFundRaisingB:new Rn(0),totalLockedAmount:r.totalLockedAmount?r.totalLockedAmount:uu,cliffPeriod:r.cliffPeriod?r.cliffPeriod:uu,unlockPeriod:r.unlockPeriod?r.unlockPeriod:uu},s,1),new gt({keys:i,programId:l,data:Buffer.from([...Pt.updatePlatformCurveParam,...s])})}function qC(l,e,t,n){let o=[{pubkey:e,isSigner:!0,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!0}],r=Buffer.alloc(_().span);return _().encode(n,r),new gt({keys:o,programId:l,data:Buffer.from([...Pt.removePlatformCurveParam,...r,1,2])})}import{NATIVE_MINT as Ln,TOKEN_2022_PROGRAM_ID as jn,TOKEN_PROGRAM_ID as Me,createAssociatedTokenAccountIdempotentInstruction as Nt,createSyncNativeInstruction as If,getTransferFeeConfig as cs,unpackMint as ls}from"@solana/spl-token";import ae from"bn.js";import{PublicKey as Zl,SystemProgram as Bf}from"@solana/web3.js";import Qt from"bn.js";import $l from"decimal.js";import os from"bn.js";import Ji from"decimal.js";var Hn=class{static getPoolInitPriceByPool({poolInfo:e,decimalA:t,decimalB:n}){throw Error()}static getPoolInitPriceByInit({a:e,b:t,decimalA:n,decimalB:o}){throw Error()}static getPoolPrice({poolInfo:e,decimalA:t,decimalB:n}){throw Error()}static getPoolEndPrice({supply:e,totalSell:t,totalLockedAmount:n,totalFundRaising:o,migrateFee:r,decimalA:i,decimalB:s}){throw Error()}static getPoolEndPriceReal({poolInfo:e,decimalA:t,decimalB:n}){throw Error()}static getInitParam({supply:e,totalFundRaising:t,totalSell:n,totalLockedAmount:o,migrateFee:r}){throw Error()}static buyExactIn({poolInfo:e,amount:t}){throw Error()}static buyExactOut({poolInfo:e,amount:t}){throw Error()}static sellExactIn({poolInfo:e,amount:t}){throw Error()}static sellExactOut({poolInfo:e,amount:t}){throw Error()}};var is=class extends Hn{static getPoolInitPriceByPool({poolInfo:e,decimalA:t,decimalB:n}){return new Ji(e.virtualB.toString()).div(e.virtualA.toString()).mul(10**(t-n))}static getPoolInitPriceByInit({a:e,b:t,decimalA:n,decimalB:o}){return new Ji(t.toString()).div(e.toString()).mul(10**(n-o))}static getPoolPrice({poolInfo:e,decimalA:t,decimalB:n}){return new Ji(e.virtualB.add(e.realB).toString()).div(e.virtualA.sub(e.realA).toString()).mul(10**(t-n))}static getPoolEndPrice({supply:e,totalSell:t,totalLockedAmount:n,totalFundRaising:o,migrateFee:r,decimalA:i,decimalB:s}){return new Ji(o.sub(r).toString()).div(e.sub(t).sub(n).toString()).mul(10**(i-s))}static getPoolEndPriceReal({poolInfo:e,decimalA:t,decimalB:n}){let o=e.totalSellA.sub(e.realA),r=e.totalFundRaisingB.sub(e.realB);return new Ji(e.virtualB.add(e.realB.add(r)).toString()).div(e.virtualA.sub(e.realA.add(o)).toString()).mul(10**(t-n))}static getInitParam({supply:e,totalFundRaising:t,totalSell:n,totalLockedAmount:o,migrateFee:r}){if(e.lte(n))throw Error("supply need gt total sell");let i=e.sub(n).sub(o);if(i.lte(new os(0)))throw Error("supplyMinusSellLocked <= 0");let s=t.sub(r);if(s.lte(new os(0)))throw Error("tfMinusMf <= 0");let u=s.mul(n).mul(n).div(i),a=s.mul(n).div(i).sub(t),c=u.div(a),m=t.mul(t).div(a);if(c.lt(new os(0))||m.lt(new os(0)))throw Error("invalid input 0");return{a:c,b:m,c:n}}static buyExactIn({poolInfo:e,amount:t}){return this.getAmountOut({amountIn:t,inputReserve:e.virtualB.add(e.realB),outputReserve:e.virtualA.sub(e.realA)})}static buyExactOut({poolInfo:e,amount:t}){return this.getAmountIn({amountOut:t,inputReserve:e.virtualB.add(e.realB),outputReserve:e.virtualA.sub(e.realA)})}static sellExactIn({poolInfo:e,amount:t}){return this.getAmountOut({amountIn:t,inputReserve:e.virtualA.sub(e.realA),outputReserve:e.virtualB.add(e.realB)})}static sellExactOut({poolInfo:e,amount:t}){return this.getAmountIn({amountOut:t,inputReserve:e.virtualA.sub(e.realA),outputReserve:e.virtualB.add(e.realB)})}static getAmountOut({amountIn:e,inputReserve:t,outputReserve:n}){let o=e.mul(n),r=t.add(e);return o.div(r)}static getAmountIn({amountOut:e,inputReserve:t,outputReserve:n}){let o=t.mul(e),r=n.sub(e);return Jn(o,r)}};import rs from"bn.js";import er from"decimal.js";var ss=class extends Hn{static getPoolInitPriceByPool({poolInfo:e,decimalA:t,decimalB:n}){return new er(e.virtualB.toString()).div(e.virtualA.toString()).mul(10**(t-n))}static getPoolInitPriceByInit({a:e,b:t,decimalA:n,decimalB:o}){return new er(t.toString()).div(e.toString()).mul(10**(n-o))}static getPoolPrice({poolInfo:e,decimalA:t,decimalB:n}){return new er(e.virtualB.toString()).div(e.virtualA.toString()).mul(10**(t-n))}static getPoolEndPrice({supply:e,totalSell:t,totalLockedAmount:n,totalFundRaising:o,migrateFee:r,decimalA:i,decimalB:s}){return new er(o.sub(r).toString()).div(e.sub(t).sub(n).toString()).mul(10**(i-s))}static getPoolEndPriceReal({poolInfo:e,decimalA:t,decimalB:n}){let o=e.totalSellA.sub(e.realA),r=e.totalFundRaisingB.sub(e.realB);return new er(e.virtualB.add(e.realB).add(r).toString()).div(e.virtualA.sub(e.realA).add(o).toString()).mul(10**(t-n))}static getInitParam({supply:e,totalFundRaising:t,totalSell:n,totalLockedAmount:o,migrateFee:r}){let i=e.sub(o);if(i.lte(new rs(0)))throw Error("invalid input 1");let s=new rs(2).mul(t).sub(r),a=t.mul(i).div(s);if(a.lt(new rs(0))||t.lt(new rs(0)))throw Error("invalid input 0");return{a,b:t,c:a}}static buyExactIn({poolInfo:e,amount:t}){return this.getAmountOut({amountIn:t,initInput:e.virtualB,initOutput:e.virtualA})}static buyExactOut({poolInfo:e,amount:t}){return this.getAmountIn({amountOut:t,initInput:e.virtualB,initOutput:e.virtualA})}static sellExactIn({poolInfo:e,amount:t}){return this.getAmountOut({amountIn:t,initInput:e.virtualA,initOutput:e.virtualB})}static sellExactOut({poolInfo:e,amount:t}){return this.getAmountIn({amountOut:t,initInput:e.virtualA,initOutput:e.virtualB})}static getAmountOut({amountIn:e,initInput:t,initOutput:n}){return n.mul(e).div(t)}static getAmountIn({amountOut:e,initInput:t,initOutput:n}){let o=t.mul(e);return Jn(o,n)}};import Ot from"bn.js";import Ao from"decimal.js";import zo from"bn.js";import as from"decimal.js";var tr=class{static _multipler(e){return new as(10).pow(e)}static getPrice({priceX64:e,decimalA:t,decimalB:n}){return new as(e.toString()).div(this._Q64).mul(this._multipler(t)).div(this._multipler(n))}static getPriceX64({price:e,decimalA:t,decimalB:n}){let o=e.mul(this._multipler(n)).div(this._multipler(t));return new zo(o.mul(this._Q64).toFixed(0))}};tr._Q64=new as(new zo(1).shln(64).toString());function rR({supply:l,totalFundRaisingB:e,totalLockedAmount:t,totalSellA:n,migrateType:o,decimalsA:r}){let i=l.sub(n).sub(t),s=new zo(new as(i.mul(e).toString()).sqrt().toFixed(0));if(o==="amm"){if(s.gt(new zo(10).pow(new zo(r))))return!0}else if(o==="cpmm"){if(s.gt(new zo(100)))return!0}else throw Error("migrate type error");return!1}var us=class extends Hn{static getPoolInitPriceByPool({poolInfo:e,decimalA:t,decimalB:n}){return new Ao(0)}static getPoolInitPriceByInit({a:e,b:t,decimalA:n,decimalB:o}){return new Ao(0)}static getPoolPrice({poolInfo:e,decimalA:t,decimalB:n}){return new Ao(e.virtualA.mul(e.realA).toString()).div(tr._Q64).mul(10**(t-n))}static getPoolEndPrice({supply:e,totalSell:t,totalLockedAmount:n,totalFundRaising:o,migrateFee:r,decimalA:i,decimalB:s}){return new Ao(o.sub(r).toString()).div(e.sub(t).sub(n).toString()).mul(10**(i-s))}static getPoolEndPriceReal({poolInfo:e,decimalA:t,decimalB:n}){let o=e.totalSellA.sub(e.realA),r=e.totalFundRaisingB.sub(e.realB);return new Ao(e.virtualB.add(e.realB).add(r).toString()).div(e.virtualA.sub(e.realA).add(o).toString()).mul(10**(t-n))}static getInitParam({supply:e,totalFundRaising:t,totalSell:n,totalLockedAmount:o,migrateFee:r}){let i=e.sub(o);if(i.lte(new Ot(0)))throw Error("supplyMinusLocked need gt 0");let s=t.mul(new Ot(3)).sub(r),a=t.mul(new Ot(2)).mul(i).div(s),c=a.mul(a),m=t.mul(new Ot(2)).mul(nt).div(c);if(!m.gt(new Ot(0)))throw Error("a need gt 0");if(!Ti.gt(m))throw Error("a need lt u64 max");if(m.lt(new Ot(0))||a.lt(new Ot(0)))throw Error("invalid input 0");return{a:m,b:new Ot(0),c:a}}static buyExactIn({poolInfo:e,amount:t}){let n=e.realB.add(t),o=new Ot(2).mul(n).mul(nt).div(e.virtualA);return new Ot(new Ao(o.toString()).sqrt().toFixed(0)).sub(e.realA)}static buyExactOut({poolInfo:e,amount:t}){let n=e.realA.add(t),o=n.mul(n);return Jn(e.virtualA.mul(o),new Ot(2).mul(nt)).sub(e.realB)}static sellExactIn({poolInfo:e,amount:t}){let n=e.realA.sub(t),o=n.mul(n),r=Jn(e.virtualA.mul(o),new Ot(2).mul(nt));return e.realB.sub(r)}static sellExactOut({poolInfo:e,amount:t}){let n=e.realB.sub(t),o=new Ot(2).mul(n).mul(nt).div(e.virtualA),r=new Ot(new Ao(o.toString()).sqrt().toFixed(0));return e.realA.sub(r)}};var Ht=class{static getPoolCurvePointByPoolInfo({curveType:e,pointCount:t,poolInfo:n}){return this.getPoolCurvePointByInit({curveType:e,pointCount:t,supply:n.supply,totalFundRaising:n.totalFundRaisingB,totalSell:n.totalSellA,totalLockedAmount:n.vestingSchedule.totalLockedAmount,migrateFee:n.migrateFee,decimalA:n.mintDecimalsA,decimalB:n.mintDecimalsB})}static getPoolCurvePointByInit({curveType:e,pointCount:t,supply:n,totalFundRaising:o,totalSell:r,totalLockedAmount:i,migrateFee:s,decimalA:u,decimalB:a}){if(t<3)throw Error("point count < 3");let c=this.getCurve(e),m=c.getInitParam({supply:n,totalFundRaising:o,totalSell:r,totalLockedAmount:i,migrateFee:s}),p=c.getPoolInitPriceByInit(q(M({},m),{decimalA:u,decimalB:a})),d=o.div(new Qt(t-1)),f=new Qt(0),y=[{price:p,totalSellSupply:0}],{a:b,b:g}=m,P=f,h=f;for(let I=1;I<t;I++){let T=I!==t-1?d:o.sub(h),w=this.buyExactIn({poolInfo:{virtualA:b,virtualB:g,realA:P,realB:h,totalFundRaisingB:o,totalSellA:r},amountB:T,protocolFeeRate:f,platformFeeRate:f,curveType:e,shareFeeRate:f,creatorFeeRate:f,transferFeeConfigA:void 0,slot:0});P=P.add(w.amountA.amount),h=h.add(w.amountB);let K=this.getPrice({poolInfo:{virtualA:b,virtualB:g,realA:P,realB:h},decimalA:u,decimalB:a,curveType:e});y.push({price:K,totalSellSupply:new $l(P.toString()).div(10**u).toNumber()})}return y}static getPoolInitPriceByPool({poolInfo:e,decimalA:t,decimalB:n,curveType:o}){return this.getCurve(o).getPoolInitPriceByPool({poolInfo:e,decimalA:t,decimalB:n})}static getPoolInitPriceByInit({a:e,b:t,decimalA:n,decimalB:o,curveType:r}){return this.getCurve(r).getPoolInitPriceByInit({a:e,b:t,decimalA:n,decimalB:o})}static getPrice({poolInfo:e,curveType:t,decimalA:n,decimalB:o}){return this.getCurve(t).getPoolPrice({poolInfo:e,decimalA:n,decimalB:o})}static getEndPrice({poolInfo:e,curveType:t,decimalA:n,decimalB:o}){return this.getCurve(t).getPoolPrice({poolInfo:e,decimalA:n,decimalB:o})}static getPoolEndPriceReal({poolInfo:e,curveType:t,decimalA:n,decimalB:o}){return this.getCurve(t).getPoolEndPriceReal({poolInfo:e,decimalA:n,decimalB:o})}static checkParam({supply:e,totalFundRaising:t,totalSell:n,totalLockedAmount:o,decimals:r,config:i,migrateType:s}){if(Number(r)!==6)throw Error("decimals = 6");if(e.mul(i.maxLockRate).div(Kt).lt(o))throw Error("total lock amount gte max lock amount");if(e.lt(i.minSupplyA.mul(new Qt(10**r))))throw Error("supply lt min supply");let a=e.mul(i.minSellRateA).div(Kt);if(n.lt(a))throw Error("invalid input");if(t.lt(i.minFundRaisingB))throw Error("total fund raising lt min fund raising");let c=e.sub(n).sub(o),m=e.mul(i.minMigrateRateA).div(Kt);if(c.lt(m))throw Error("migrate lt min migrate amoount");let p=e.sub(n).sub(o),d=new Qt(new $l(p.mul(t).toString()).sqrt().toFixed(0));if(s==="amm"){let f=new Qt(10).pow(new Qt(r));if(d.lte(f))throw Error("check migrate lp error")}else if(s==="cpmm"){let f=new Qt(100);if(d.lte(f))throw Error("check migrate lp error")}else throw Error("migrate type error")}static buyExactIn({poolInfo:e,amountB:t,protocolFeeRate:n,platformFeeRate:o,curveType:r,shareFeeRate:i,creatorFeeRate:s,transferFeeConfigA:u,slot:a}){let c=this.totalFeeRate({protocolFeeRate:n,platformFeeRate:o,shareFeeRate:i,creatorFeeRate:s}),m=this.calculateFee({amount:t,feeRate:c}),p=t.sub(m),d=this.getCurve(r),f=d.buyExactIn({poolInfo:e,amount:p}),y=e.totalSellA.sub(e.realA),b,g,P;if(f.gt(y)){b=y;let I=d.buyExactOut({poolInfo:e,amount:b});g=this.calculatePreFee({postFeeAmount:I,feeRate:c}),P=g.sub(I)}else b=f,g=t,P=m;let h=this.splitFee({totalFee:P,protocolFeeRate:n,platformFeeRate:o,shareFeeRate:i,creatorFeeRate:s});return{amountA:Ns(b,u,a),amountB:g,splitFee:h}}static buyExactOut({poolInfo:e,amountA:t,protocolFeeRate:n,platformFeeRate:o,curveType:r,shareFeeRate:i,creatorFeeRate:s,transferFeeConfigA:u,slot:a}){let c=e.totalSellA.sub(e.realA),m=Ms(t,u,a),p=m.fee?m.amount.add(m.fee):m.amount;t.gt(c)&&(p=c);let f=this.getCurve(r).buyExactOut({poolInfo:e,amount:p}),y=this.totalFeeRate({protocolFeeRate:n,platformFeeRate:o,shareFeeRate:i,creatorFeeRate:s}),b=this.calculatePreFee({postFeeAmount:f,feeRate:y}),g=b.sub(f),P=this.splitFee({totalFee:g,protocolFeeRate:n,platformFeeRate:o,shareFeeRate:i,creatorFeeRate:s});return{amountA:m,amountB:b,splitFee:P}}static sellExactIn({poolInfo:e,amountA:t,protocolFeeRate:n,platformFeeRate:o,curveType:r,shareFeeRate:i,creatorFeeRate:s,transferFeeConfigA:u,slot:a}){let c=this.getCurve(r),m=Ns(t,u,a),p=m.fee?m.amount.sub(m.fee):m.amount,d=c.sellExactIn({poolInfo:e,amount:p}),f=this.calculateFee({amount:d,feeRate:this.totalFeeRate({protocolFeeRate:n,platformFeeRate:o,shareFeeRate:i,creatorFeeRate:s})}),y=this.splitFee({totalFee:f,protocolFeeRate:n,platformFeeRate:o,shareFeeRate:i,creatorFeeRate:s});return{amountA:m,amountB:d.sub(f),splitFee:y}}static sellExactOut({poolInfo:e,amountB:t,protocolFeeRate:n,platformFeeRate:o,curveType:r,shareFeeRate:i,creatorFeeRate:s,transferFeeConfigA:u,slot:a}){let c=this.totalFeeRate({protocolFeeRate:n,platformFeeRate:o,shareFeeRate:i,creatorFeeRate:s}),m=this.calculatePreFee({postFeeAmount:t,feeRate:c});if(e.realB.lt(m))throw Error("Insufficient liquidity");let p=m.sub(t),f=Ht.getCurve(r).sellExactOut({poolInfo:e,amount:m});if(f.gt(e.realA))throw Error();let y=this.splitFee({totalFee:p,protocolFeeRate:n,platformFeeRate:o,shareFeeRate:i,creatorFeeRate:s});return{amountA:Ms(f,u,a),amountB:t,splitFee:y}}static splitFee({totalFee:e,protocolFeeRate:t,platformFeeRate:n,shareFeeRate:o,creatorFeeRate:r}){let i=this.totalFeeRate({protocolFeeRate:t,platformFeeRate:n,shareFeeRate:o,creatorFeeRate:r}),s=i.isZero()?new Qt(0):e.mul(n).div(i),u=i.isZero()?new Qt(0):e.mul(o).div(i),a=i.isZero()?new Qt(0):e.mul(r).div(i),c=e.sub(s).sub(u).sub(a);return{platformFee:s,shareFee:u,protocolFee:c,creatorFee:a}}static calculateFee({amount:e,feeRate:t}){return Zo(e,t,Kt)}static calculatePreFee({postFeeAmount:e,feeRate:t}){if(t.isZero())return e;let n=e.mul(Kt),o=Kt.sub(t);return n.add(o).sub(new Qt(1)).div(o)}static totalFeeRate({protocolFeeRate:e,platformFeeRate:t,shareFeeRate:n,creatorFeeRate:o}){if(e.add(t).add(n).add(o).gt(new Qt(1e6)))throw Error("total fee rate gt 1_000_000");return e.add(t).add(n).add(o)}static getCurve(e){switch(e){case 0:return is;case 1:return ss;case 2:return us}throw Error("find curve error")}};import Wt from"decimal.js";var ko={initPriceX64:new ae("515752397214619"),supply:new ae(1e15),totalSellA:new ae(7931e11),totalFundRaisingB:new ae(85e9),totalLockedAmount:new ae("0"),cliffPeriod:new ae("0"),unlockPeriod:new ae("0"),decimals:6,virtualA:new ae("1073471847374405"),virtualB:new ae("30050573465"),realA:new ae(0),realB:new ae(0),protocolFee:new ae(0),platformId:new Zl("4Bu96XjU84XjPDSpveTVf6LYGCkfW5FK7SNkREWcEfV4"),vestingSchedule:{totalLockedAmount:new ae(0),cliffPeriod:new ae(0),unlockPeriod:new ae(0),startTime:new ae(0),totalAllocatedShare:new ae(0)}},$n=new ae(1e4),nr=class extends Ee{constructor(e){super(e)}async sayHello(){console.log("hello")}async createLaunchpad(v){var L=v,{programId:e=et,authProgramId:t,platformId:n=ko.platformId,mintA:o,decimals:r=6,mintBDecimals:i=9,name:s,symbol:u,uri:a,migrateType:c,configId:m,snipers:p,configInfo:d,platformFeeRate:f,txVersion:y,computeBudgetConfig:b,txTipConfig:g,feePayer:P,buyAmount:h,minMintAAmount:I,slippage:T,associatedOnly:w=!0,checkCreateATAOwner:K=!1,extraSigners:x,token2022:S,transferFeeExtensionParams:B,creatorFeeOn:R=0}=L,C=Fe(L,["programId","authProgramId","platformId","mintA","decimals","mintBDecimals","name","symbol","uri","migrateType","configId","snipers","configInfo","platformFeeRate","txVersion","computeBudgetConfig","txTipConfig","feePayer","buyAmount","minMintAAmount","slippage","associatedOnly","checkCreateATAOwner","extraSigners","token2022","transferFeeExtensionParams","creatorFeeOn"]);var Mt,ir,bu,gu,Pu,Au,ku,wu,Tu,hu;let N=[],E=this.createTxBuilder(P);t=t!=null?t:pn(e).publicKey,S=!!B,S&&(c="cpmm");let X=d;if(!X&&m){let $t=await this.scope.connection.getAccountInfo(m);$t&&(X=Qn.decode($t.data))}X||this.logAndCreateError("config not found");let Q=X.mintB,ee=X.curveType,{publicKey:me}=Go(e,o,Q),{publicKey:re}=ou(e,me,o),{publicKey:ue}=ou(e,me,Q),{publicKey:be}=Tn(o);this.logDebug(`create token: ${o.toBase58()}, mintB: ${Q.toBase58()}, decimals A:${r}/B:${i}, config:${m.toBase58()}`),u.length>10&&this.logAndCreateError("Symbol length should shorter than 11"),a||this.logAndCreateError("uri should not empty");let de=(Mt=C==null?void 0:C.supply)!=null?Mt:ko.supply,oe=(ir=C==null?void 0:C.totalSellA)!=null?ir:ko.totalSellA,Ce=(bu=C==null?void 0:C.totalFundRaisingB)!=null?bu:ko.totalFundRaisingB,fe=(gu=C==null?void 0:C.totalLockedAmount)!=null?gu:new ae(0),Je=f;if(!f){let $t=await this.scope.connection.getAccountInfo(n);$t||this.logAndCreateError("platform id not found:",n.toString()),Je=Xo.decode($t.data).feeRate}let rn=Ht.getCurve(X.curveType).getInitParam({supply:de,totalFundRaising:Ce,totalSell:oe,totalLockedAmount:fe,migrateFee:X.migrateFee}),Oe={epoch:new ae(896),bump:254,status:0,mintDecimalsA:r,mintDecimalsB:i,supply:de,totalSellA:oe,mintA:new Zl(o),mintB:Q,virtualA:rn.a,virtualB:rn.b,realA:ko.realA,realB:ko.realB,migrateFee:X.migrateFee,migrateType:c==="amm"?0:1,protocolFee:ko.protocolFee,platformFee:Je,platformId:n,configId:m,vaultA:re,vaultB:ue,creator:this.scope.ownerPubKey,totalFundRaisingB:Ce,vestingSchedule:{totalLockedAmount:fe,cliffPeriod:new ae(0),unlockPeriod:new ae(0),startTime:new ae(0),totalAllocatedShare:new ae(0)},mintProgramFlag:S?1:0,cpmmCreatorFeeOn:R},Yo=Ht.getCurve(X.curveType),{c:ds}=Yo.getInitParam({supply:Oe.supply,totalFundRaising:Oe.totalFundRaisingB,totalLockedAmount:fe,totalSell:X.curveType===0?Oe.totalSellA:new ae(0),migrateFee:X.migrateFee});try{Ht.checkParam({supply:Oe.supply,totalFundRaising:Oe.totalFundRaisingB,totalSell:ds,totalLockedAmount:fe,decimals:Oe.mintDecimalsA,config:X,migrateType:c}),this.logDebug("check init params success")}catch($t){this.logAndCreateError(`check create mint params failed, ${$t.message}`)}E.addInstruction({instructions:[S?Gl(e,P!=null?P:this.scope.ownerPubKey,this.scope.ownerPubKey,m,n,t,me,o,Q,re,ue,r,s,u,a||"https://",{type:ee===0?"ConstantCurve":ee===1?"FixedCurve":ee===2?"LinearCurve":"ConstantCurve",totalSellA:oe,migrateType:c,supply:de,totalFundRaisingB:Ce},fe,(Pu=C==null?void 0:C.cliffPeriod)!=null?Pu:new ae(0),(Au=C==null?void 0:C.unlockPeriod)!=null?Au:new ae(0),R,B):Ul(e,P!=null?P:this.scope.ownerPubKey,this.scope.ownerPubKey,m,n,t,me,o,Q,re,ue,be,r,s,u,a||"https://",{type:ee===0?"ConstantCurve":ee===1?"FixedCurve":ee===2?"LinearCurve":"ConstantCurve",totalSellA:oe,migrateType:c,supply:de,totalFundRaisingB:Ce},fe,(ku=C==null?void 0:C.cliffPeriod)!=null?ku:new ae(0),(wu=C==null?void 0:C.unlockPeriod)!=null?wu:new ae(0),R)]});let Qo=S?await this.scope.connection.getEpochInfo():void 0,jt=B?{epoch:BigInt((Qo==null?void 0:Qo.epoch)||0),maximumFee:BigInt((Tu=B==null?void 0:B.maxinumFee.toString())!=null?Tu:0),transferFeeBasisPoints:(hu=B==null?void 0:B.transferFeeBasePoints)!=null?hu:0}:void 0,To={amountA:{amount:new ae(0),fee:void 0,expirationTime:void 0},amountB:new ae(0),splitFee:{platformFee:new ae(0),shareFee:new ae(0),protocolFee:new ae(0),creatorFee:new ae(0)}},ho;if(x!=null&&x.length&&E.addInstruction({signers:x}),!C.createOnly){let{builder:$t,extInfo:Jl}=await this.buyToken({programId:e,authProgramId:t,mintAProgram:S?jn:void 0,mintA:o,mintB:Q,poolInfo:Oe,buyAmount:h,minMintAAmount:I,shareFeeRate:C.shareFeeRate,shareFeeReceiver:C.shareFeeReceiver,configInfo:X,platformFeeRate:Je,slippage:T,associatedOnly:w,checkCreateATAOwner:K,skipCheckMintA:!jt,transferFeeConfigA:jt?{transferFeeConfigAuthority:t,withdrawWithheldAuthority:t,withheldAmount:BigInt(0),olderTransferFee:jt,newerTransferFee:jt}:void 0,fromCreate:!0});console.log("PREPARING SNIPER TRANSACTIONS");for(let Iu of p){let{builder:em,extInfo:Cf}=await this.buyToken({programId:e,authProgramId:t,mintAProgram:S?jn:void 0,mintA:o,mintB:Q,poolInfo:Oe,buyAmount:Iu.amount,minMintAAmount:I,shareFeeRate:C.shareFeeRate,shareFeeReceiver:C.shareFeeReceiver,configInfo:X,platformFeeRate:Je,slippage:T,sniper:Iu,associatedOnly:w,checkCreateATAOwner:K,skipCheckMintA:!jt,transferFeeConfigA:jt?{transferFeeConfigAuthority:t,withdrawWithheldAuthority:t,withheldAmount:BigInt(0),olderTransferFee:jt,newerTransferFee:jt}:void 0,fromCreate:!0});N.push(q(M({},em.AllTxData),{blockHash:this.scope.blockhashCommitment}))}E.addInstruction(M({},$t.AllTxData)),To=M({},Jl),ho=(this.scope.cluster==="devnet"||y===1)&&C.shareFeeReceiver?[$t.allInstructions[0]]:void 0}return E.addTipInstruction(g),y===0?(console.log("VERSION V0"),{tx:await E.sizeCheckBuildV0({computeBudgetConfig:b,swapInfo:To,splitIns:ho,address:q(M({},Oe),{poolId:me})}),txs:N}):(console.log("VERSION PLAIN"),{tx:await E.sizeCheckBuild({computeBudgetConfig:b,swapInfo:To,splitIns:ho,address:q(M({},Oe),{poolId:me})}),txs:N})}async buyToken({programId:e=et,authProgramId:t,mintA:n,mintAProgram:o=Me,mintB:r=Ln,poolInfo:i,configInfo:s,platformFeeRate:u,txVersion:a,computeBudgetConfig:c,txTipConfig:m,feePayer:p,buyAmount:d,minMintAAmount:f,slippage:y,shareFeeRate:b=new ae(0),shareFeeReceiver:g,sniper:P,associatedOnly:h=!0,checkCreateATAOwner:I=!1,fromCreate:T=!1,transferFeeConfigA:w,skipCheckMintA:K=!1}){var de,oe,Ce;d.lte(new ae(0))&&this.logAndCreateError("buy amount should gt 0:",d.toString());let x=P?this.createSniperTxBuilder(P.owner,P.owner.publicKey):this.createTxBuilder(p),{publicKey:S}=Go(e,n,r);t=t!=null?t:pn(e).publicKey;let B=w;if(!K)if(B)o=jn;else{let fe=await this.scope.connection.getAccountInfo(n);if(fe&&fe.owner.equals(jn)){o=fe.owner;let Je=ls(n,fe,o);B=cs(Je)||void 0}}let R=P?this.scope.account.getAssociatedTokenAccountByOwner(P.owner.publicKey,n,o):this.scope.account.getAssociatedTokenAccount(n,o),C=T?P?this.scope.account.getAssociatedTokenAccountByOwner(P.owner.publicKey,r,Me):this.scope.account.getAssociatedTokenAccount(r,Me):null,v=r.equals(Ln);if(console.log("userTokenAccountA: ",R),console.log("mintAProgram: ",o),x.addInstruction({instructions:[Nt((P==null?void 0:P.owner.publicKey)||this.scope.ownerPubKey,R,(P==null?void 0:P.owner.publicKey)||this.scope.ownerPubKey,n,o),...T?[Nt((P==null?void 0:P.owner.publicKey)||this.scope.ownerPubKey,C,(P==null?void 0:P.owner.publicKey)||this.scope.ownerPubKey,r,Me),Bf.transfer({fromPubkey:(P==null?void 0:P.owner.publicKey)||this.scope.ownerPubKey,toPubkey:C,lamports:BigInt(d.toString())}),If(C)]:[]]}),!T){let{account:fe,instructionParams:Je}=await this.scope.account.getOrCreateTokenAccount({mint:r,owner:this.scope.ownerPubKey,createInfo:v?{payer:this.scope.ownerPubKey,amount:d}:void 0,skipCloseAccount:!v,notUseTokenAccount:v,associatedOnly:v?!1:h,checkCreateATAOwner:I});fe&&(C=fe),x.addInstruction(Je||{})}C===void 0&&this.logAndCreateError(`cannot found mintB(${r.toBase58()}) token accounts`,"tokenAccounts",this.scope.account.tokenAccounts);let L=i;if(!L){let fe=await this.scope.connection.getAccountInfo(S,{commitment:"processed"});fe||this.logAndCreateError("cannot found pool:",S.toBase58()),L=on.decode(fe.data)}let N=s,E=await Ne(this.scope.connection,[N?void 0:L.configId,L.platformId].filter(Boolean).map(fe=>({pubkey:fe})));if(!N){let fe=E.find(Je=>Je.pubkey.equals(L.configId));(!fe||!fe.accountInfo)&&this.logAndCreateError("config not found: ",L.configId.toBase58()),N=Qn.decode(fe.accountInfo.data)}let X=E.find(fe=>fe.pubkey.equals(L.platformId));(!X||!X.accountInfo)&&this.logAndCreateError("platform info not found: ",L.configId.toBase58());let Q=Xo.decode(X.accountInfo.data);u=u||Q.feeRate;let ee=Ht.buyExactIn({poolInfo:L,amountB:d,protocolFeeRate:N.tradeFeeRate,platformFeeRate:u,curveType:N.curveType,shareFeeRate:b,creatorFeeRate:Q.creatorFeeRate,transferFeeConfigA:B,slot:await this.scope.connection.getSlot()}),me=new Wt(ee.amountA.amount.toString()).sub((oe=(de=ee.amountA.fee)==null?void 0:de.toString())!=null?oe:0),re=y?new Wt($n.sub(y).toNumber()/$n.toNumber()).clampedTo(0,1):new Wt(1),ue=f!=null?f:y?new ae(me.mul(re).toFixed(0)):ee.amountA.amount.sub((Ce=ee.amountA.fee)!=null?Ce:new ae(0));ee.amountB.lt(d)&&console.log(`maximum ${n.toBase58()} amount can buy is ${ee.amountA.toString()}, input ${r.toBase58()} amount: ${ee.amountB.toString()}`);let be=g?j(g,r,Me).publicKey:void 0;return be&&x.addInstruction({instructions:[Nt((P==null?void 0:P.owner.publicKey)||this.scope.ownerPubKey,be,g,r)]}),x.addInstruction({instructions:[Xl(e,(P==null?void 0:P.owner.publicKey)||this.scope.ownerPubKey,t,L.configId,L.platformId,S,R,C,L.vaultA,L.vaultB,n,r,o,Me,go(e,L.platformId,r).publicKey,Po(e,L.creator,r).publicKey,ee.amountB.lt(d)?ee.amountB:d,ue,b,be)]}),x.addCustomComputeBudget(c),console.log("Adding Tip Config: ",m),x.addTipInstruction(m),x.versionBuild({txVersion:a,extInfo:q(M({},ee),{decimalOutAmount:me,minDecimalOutAmount:new Wt(ue.toString())})})}async buyTokenExactOut({programId:e=et,authProgramId:t,mintA:n,mintAProgram:o=Me,mintB:r=Ln,poolInfo:i,configInfo:s,transferFeeConfigA:u,platformFeeRate:a,txVersion:c,computeBudgetConfig:m,txTipConfig:p,feePayer:d,maxBuyAmount:f,outAmount:y,slippage:b,shareFeeRate:g=new ae(0),shareFeeReceiver:P,associatedOnly:h=!0,checkCreateATAOwner:I=!1,skipCheckMintA:T=!1}){y.lte(new ae(0))&&this.logAndCreateError("out amount should gt 0:",y.toString());let w=this.createTxBuilder(d),{publicKey:K}=Go(e,n,r);t=t!=null?t:pn(e).publicKey;let x=i;if(!x){let de=await this.scope.connection.getAccountInfo(K,{commitment:"processed"});de||this.logAndCreateError("cannot found pool:",K.toBase58()),x=on.decode(de.data)}let S=s,B=await Ne(this.scope.connection,[S?void 0:x.configId,x.platformId].filter(Boolean).map(de=>({pubkey:de})));if(!S){let de=B.find(oe=>oe.pubkey.equals(x.configId));(!de||!de.accountInfo)&&this.logAndCreateError("config not found: ",x.configId.toBase58()),S=Qn.decode(de.accountInfo.data)}let R=B.find(de=>de.pubkey.equals(x.platformId));(!R||!R.accountInfo)&&this.logAndCreateError("platform info not found: ",x.configId.toBase58());let C=Xo.decode(R.accountInfo.data);a=a||C.feeRate;let v=u;if(!T)if(v)o=jn;else{let de=await this.scope.connection.getAccountInfo(n);if(de&&de.owner.equals(jn)){o=de.owner;let oe=ls(n,de,o);v=cs(oe)||void 0}}let L=Ht.buyExactOut({poolInfo:x,amountA:y,protocolFeeRate:S.tradeFeeRate,platformFeeRate:a,curveType:S.curveType,shareFeeRate:g,creatorFeeRate:C.creatorFeeRate,transferFeeConfigA:v,slot:await this.scope.connection.getSlot()}),N=new Wt(L.amountB.toString()),E=b?new Wt($n.add(b).toNumber()/$n.toNumber()).clampedTo(0,Number.MIN_SAFE_INTEGER):new Wt(1),X=(f!=null?f:b)?new ae(N.mul(E).toFixed(0)):L.amountB,Q=this.scope.account.getAssociatedTokenAccount(n,o),ee=null,me=r.equals(Ln);w.addInstruction({instructions:[Nt(this.scope.ownerPubKey,Q,this.scope.ownerPubKey,n,o)]});let{account:re,instructionParams:ue}=await this.scope.account.getOrCreateTokenAccount({mint:r,owner:this.scope.ownerPubKey,createInfo:me?{payer:this.scope.ownerPubKey,amount:L.amountB}:void 0,skipCloseAccount:!me,notUseTokenAccount:me,associatedOnly:me?!1:h,checkCreateATAOwner:I});re&&(ee=re),w.addInstruction(ue||{}),ee===void 0&&this.logAndCreateError(`cannot found mintB(${r.toBase58()}) token accounts`,"tokenAccounts",this.scope.account.tokenAccounts);let be=P?j(P,r,Me).publicKey:void 0;return be&&w.addInstruction({instructions:[Nt(this.scope.ownerPubKey,be,P,r)]}),w.addInstruction({instructions:[zl(e,this.scope.ownerPubKey,t,x.configId,x.platformId,K,Q,ee,x.vaultA,x.vaultB,n,r,o,Me,go(e,x.platformId,r).publicKey,Po(e,x.creator,r).publicKey,y,X,g,be)]}),w.addCustomComputeBudget(m),w.addTipInstruction(p),w.versionBuild({txVersion:c,extInfo:{maxSpentAmount:X,outAmount:y}})}async sellToken({programId:e=et,authProgramId:t,mintAProgram:n=Me,mintA:o,mintB:r=Ln,poolInfo:i,configInfo:s,platformFeeRate:u,txVersion:a,computeBudgetConfig:c,txTipConfig:m,feePayer:p,sellAmount:d,minAmountB:f,slippage:y,shareFeeRate:b=new ae(0),shareFeeReceiver:g,associatedOnly:P=!0,checkCreateATAOwner:h=!1,skipCheckMintA:I=!1}){t=t!=null?t:pn(e).publicKey;let T=this.createTxBuilder(p);d.lte(new ae(0))&&this.logAndCreateError("sell amount should be gt 0");let{publicKey:w}=Go(e,o,r),K;if(!I){let oe=await this.scope.connection.getAccountInfo(o);if(oe&&oe.owner.equals(jn)){n=oe.owner;let Ce=ls(o,oe,n);K=cs(Ce)||void 0}}let x=null,S=null,B=r.equals(Ln),{account:R,instructionParams:C}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:n,mint:o,owner:this.scope.ownerPubKey,createInfo:void 0,skipCloseAccount:!0,notUseTokenAccount:!1,associatedOnly:P,checkCreateATAOwner:h});R&&(x=R),T.addInstruction(C||{}),x===void 0&&this.logAndCreateError("cannot found mintA token accounts","tokenAccounts",this.scope.account.tokenAccounts);let{account:v,instructionParams:L}=await this.scope.account.getOrCreateTokenAccount({mint:r,owner:this.scope.ownerPubKey,createInfo:B?{payer:this.scope.ownerPubKey,amount:0}:void 0,skipCloseAccount:!B,notUseTokenAccount:B,associatedOnly:B?!1:P,checkCreateATAOwner:h});v&&(S=v),T.addInstruction(L||{}),S===void 0&&this.logAndCreateError("cannot found mintB token accounts","tokenAccounts",this.scope.account.tokenAccounts);let N=i;if(!N){let oe=await this.scope.connection.getAccountInfo(w,{commitment:"processed"});oe||this.logAndCreateError("cannot found pool",w.toBase58()),N=on.decode(oe.data)}let E=s,X=await Ne(this.scope.connection,[E?void 0:N.configId,N.platformId].filter(Boolean).map(oe=>({pubkey:oe})));if(!E){let oe=X.find(Ce=>Ce.pubkey.equals(N.configId));(!oe||!oe.accountInfo)&&this.logAndCreateError("config not found: ",N.configId.toBase58()),E=Qn.decode(oe.accountInfo.data)}let Q=X.find(oe=>oe.pubkey.equals(N.platformId));(!Q||!Q.accountInfo)&&this.logAndCreateError("platform info not found: ",N.configId.toBase58());let ee=Xo.decode(Q.accountInfo.data);u=u||ee.feeRate;let me=Ht.sellExactIn({poolInfo:N,amountA:d,protocolFeeRate:E.tradeFeeRate,platformFeeRate:u,curveType:E.curveType,shareFeeRate:b,creatorFeeRate:ee.creatorFeeRate,transferFeeConfigA:K,slot:await this.scope.connection.getSlot()}),re=new Wt(me.amountB.toString()),ue=y?new Wt($n.sub(y).toNumber()/$n.toNumber()).clampedTo(0,1):new Wt(1),be=f!=null?f:y?new ae(re.mul(ue).toFixed(0)):me.amountB;be.lte(new ae(0))&&this.logAndCreateError(`out ${r.toBase58()} amount should be gt 0`);let de=g?j(g,r,Me).publicKey:void 0;return de&&T.addInstruction({instructions:[Nt(this.scope.ownerPubKey,de,g,r)]}),T.addInstruction({instructions:[Yl(e,this.scope.ownerPubKey,t,N.configId,N.platformId,w,x,S,N.vaultA,N.vaultB,o,r,n,Me,go(e,N.platformId,r).publicKey,Po(e,N.creator,r).publicKey,me.amountA.amount.lt(d)?me.amountA.amount:d,be,b,de)]}),T.addCustomComputeBudget(c),T.addTipInstruction(m),T.versionBuild({txVersion:a,extInfo:{outAmount:be}})}async sellTokenExactOut({programId:e=et,authProgramId:t,mintAProgram:n=Me,mintA:o,mintB:r=Ln,poolInfo:i,configInfo:s,platformFeeRate:u,txVersion:a,computeBudgetConfig:c,txTipConfig:m,feePayer:p,inAmount:d,maxSellAmount:f,slippage:y,shareFeeRate:b=new ae(0),shareFeeReceiver:g,associatedOnly:P=!0,checkCreateATAOwner:h=!1,skipCheckMintA:I=!1}){t=t!=null?t:pn(e).publicKey;let T=this.createTxBuilder(p);f!=null&&f.lte(new ae(0))&&this.logAndCreateError("max sell amount should be gt 0");let{publicKey:w}=Go(e,o,r),K;if(!I){let oe=await this.scope.connection.getAccountInfo(o);if(oe&&oe.owner.equals(jn)){n=oe.owner;let Ce=ls(o,oe,n);K=cs(Ce)||void 0}}let x=null,S=null,B=r.equals(Ln),{account:R,instructionParams:C}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:n,mint:o,owner:this.scope.ownerPubKey,createInfo:void 0,skipCloseAccount:!0,notUseTokenAccount:!1,associatedOnly:P,checkCreateATAOwner:h});R&&(x=R),T.addInstruction(C||{}),x===void 0&&this.logAndCreateError("cannot found mintA token accounts","tokenAccounts",this.scope.account.tokenAccounts);let{account:v,instructionParams:L}=await this.scope.account.getOrCreateTokenAccount({mint:r,owner:this.scope.ownerPubKey,createInfo:B?{payer:this.scope.ownerPubKey,amount:0}:void 0,skipCloseAccount:!B,notUseTokenAccount:B,associatedOnly:B?!1:P,checkCreateATAOwner:h});v&&(S=v),T.addInstruction(L||{}),S===void 0&&this.logAndCreateError("cannot found mintB token accounts","tokenAccounts",this.scope.account.tokenAccounts);let N=i;if(!N){let oe=await this.scope.connection.getAccountInfo(w,{commitment:"processed"});oe||this.logAndCreateError("cannot found pool",w.toBase58()),N=on.decode(oe.data)}let E=s,X=await Ne(this.scope.connection,[E?void 0:N.configId,N.platformId].filter(Boolean).map(oe=>({pubkey:oe})));if(!E){let oe=X.find(Ce=>Ce.pubkey.equals(N.configId));(!oe||!oe.accountInfo)&&this.logAndCreateError("config not found: ",N.configId.toBase58()),E=Qn.decode(oe.accountInfo.data)}let Q=X.find(oe=>oe.pubkey.equals(N.platformId));(!Q||!Q.accountInfo)&&this.logAndCreateError("platform info not found: ",N.configId.toBase58());let ee=Xo.decode(Q.accountInfo.data);u=u||ee.feeRate;let me=Ht.sellExactOut({poolInfo:N,amountB:d,protocolFeeRate:E.tradeFeeRate,platformFeeRate:u,curveType:E.curveType,shareFeeRate:b,creatorFeeRate:ee.creatorFeeRate,transferFeeConfigA:K,slot:await this.scope.connection.getSlot()}),re=new Wt(me.amountA.amount.toString()),ue=y?new Wt($n.add(y).toNumber()/$n.toNumber()).clampedTo(0,Number.MAX_SAFE_INTEGER):new Wt(1),be=(f!=null?f:y)?new ae(re.mul(ue).toFixed(0)):me.amountA.amount,de=g?j(g,r,Me).publicKey:void 0;return de&&T.addInstruction({instructions:[Nt(this.scope.ownerPubKey,de,g,r)]}),T.addInstruction({instructions:[Ql(e,this.scope.ownerPubKey,t,N.configId,N.platformId,w,x,S,N.vaultA,N.vaultB,o,r,n,Me,go(e,N.platformId,r).publicKey,Po(e,N.creator,r).publicKey,d,be,b,de)]}),T.addCustomComputeBudget(c),T.addTipInstruction(m),T.versionBuild({txVersion:a,extInfo:{maxSellAmount:be}})}async createPlatformConfig({programId:e=et,platformAdmin:t,platformClaimFeeWallet:n,platformLockNftWallet:o,cpConfigId:r,migrateCpLockNftScale:i,transferFeeExtensionAuth:s,creatorFeeRate:u,feeRate:a,name:c,web:m,img:p,txVersion:d,computeBudgetConfig:f,txTipConfig:y,feePayer:b}){let g=this.createTxBuilder(b),{publicKey:P}=iu(e,t);return g.addInstruction({instructions:[Hl(e,t,n,o,P,r,s,i,a,u,c,m,p)]}),g.addCustomComputeBudget(f),g.addTipInstruction(y),g.versionBuild({txVersion:d,extInfo:{platformId:P}})}async updatePlatformConfig({programId:e=et,platformAdmin:t,platformId:n,updateInfo:o,txVersion:r,computeBudgetConfig:i,txTipConfig:s,feePayer:u}){let a=this.createTxBuilder(u),c=n!=null?n:iu(e,t).publicKey;return a.addInstruction({instructions:[jl(e,t,c,o)]}),a.addCustomComputeBudget(i),a.addTipInstruction(s),a.versionBuild({txVersion:r})}async claimPlatformFee({programId:e=et,authProgramId:t,platformId:n,poolId:o,platformClaimFeeWallet:r,mintB:i,vaultB:s,mintBProgram:u=Me,txVersion:a,computeBudgetConfig:c,txTipConfig:m,feePayer:p}){var g;let d=this.createTxBuilder(p);t=t!=null?t:pn(e).publicKey;let f=i,y=s;if(!f){let P=await this.scope.connection.getAccountInfo(o,{commitment:"processed"});P||this.logAndCreateError("cannot found pool:",o.toBase58());let h=on.decode(P.data),I=await this.scope.connection.getAccountInfo(h.configId,{commitment:"processed"});I||this.logAndCreateError("cannot found config:",h.configId.toBase58()),f=Qn.decode(I.data).mintB,y=y!=null?y:h.vaultB}(!f||!y)&&this.logAndCreateError("cannot found mint info, mintB: ",f.toBase58(),", vaultB: ",(g=y==null?void 0:y.toBase58())!=null?g:"");let b=j(this.scope.ownerPubKey,f,Me).publicKey;return d.addInstruction({instructions:[Nt(this.scope.ownerPubKey,b,this.scope.ownerPubKey,f)]}),d.addInstruction({instructions:[mu(e,r,t,o,n,y,b,f,u)]}),d.addCustomComputeBudget(c),d.addTipInstruction(m),d.versionBuild({txVersion:a})}async claimAllPlatformFee({programId:e=et,authProgramId:t,platformId:n,platformClaimFeeWallet:o,txVersion:r,computeBudgetConfig:i,txTipConfig:s,feePayer:u}){let a=this.createTxBuilder(u);return t=t!=null?t:pn(e).publicKey,(await this.scope.connection.getProgramAccounts(e,{filters:[{dataSize:on.span},{memcmp:{offset:on.offsetOf("platformId"),bytes:n.toString()}}]})).forEach(m=>{let p=on.decode(m.account.data);if(p.platformFee.lte(new ae(0)))return;let d=j(this.scope.ownerPubKey,p.mintB,Me).publicKey;a.addInstruction({instructions:[Nt(this.scope.ownerPubKey,d,this.scope.ownerPubKey,p.mintB)]}),a.addInstruction({instructions:[mu(e,o,t,m.pubkey,n,p.vaultB,d,p.mintB,Me)]})}),a.addTipInstruction(s),r===0?a.sizeCheckBuildV0({computeBudgetConfig:i}):a.sizeCheckBuild({computeBudgetConfig:i})}async createVesting({programId:e=et,poolId:t,beneficiary:n,shareAmount:o,txVersion:r,computeBudgetConfig:i,txTipConfig:s,feePayer:u}){let a=this.createTxBuilder(u),c=await this.getRpcPoolInfo({poolId:t});o.add(c.vestingSchedule.totalAllocatedShare).gt(c.vestingSchedule.totalLockedAmount)&&this.logAndCreateError("share amount exceed total locked amount");let m=$i(e,t,n).publicKey;return a.addInstruction({instructions:[lu(e,this.scope.ownerPubKey,n,t,m,o)]}),a.addCustomComputeBudget(i),a.addTipInstruction(s),a.versionBuild({txVersion:r})}async createMultipleVesting({programId:e=et,poolId:t,beneficiaryList:n,txVersion:o,computeBudgetConfig:r,feePayer:i}){let s=this.createTxBuilder(i);n.length===0&&this.logAndCreateError("beneficiaryList is null");let u=await this.getRpcPoolInfo({poolId:t});return n.reduce((c,m)=>c.add(m.shareAmount),u.vestingSchedule.totalAllocatedShare).gt(u.vestingSchedule.totalLockedAmount)&&this.logAndCreateError("share amount exceed total locked amount"),n.forEach(c=>{let m=$i(e,t,c.wallet).publicKey;s.addInstruction({instructions:[lu(e,this.scope.ownerPubKey,c.wallet,t,m,c.shareAmount)]})}),o===0?s.sizeCheckBuildV0({computeBudgetConfig:r}):s.sizeCheckBuild({computeBudgetConfig:r})}async claimVesting({programId:e=et,poolId:t,poolInfo:n,vestingRecord:o,txVersion:r,computeBudgetConfig:i,txTipConfig:s,feePayer:u}){let a=this.createTxBuilder(u),c=pn(e).publicKey,m=o||$i(e,t,this.scope.ownerPubKey).publicKey,p=n;if(!p){let f=await this.scope.connection.getAccountInfo(t);f||this.logAndCreateError("pool not found"),p=on.decode(f.data)}let d=j(this.scope.ownerPubKey,p.mintA,Me).publicKey;return a.addInstruction({instructions:[Nt(this.scope.ownerPubKey,d,this.scope.ownerPubKey,p.mintA)]}),a.addInstruction({instructions:[cu(e,this.scope.ownerPubKey,c,t,m,d,p.vaultA,p.mintA,Me)]}),a.addCustomComputeBudget(i),a.addTipInstruction(s),a.versionBuild({txVersion:r})}async claimMultiVesting({programId:e=et,poolIdList:t,poolsInfo:n={},vestingRecords:o={},txVersion:r,computeBudgetConfig:i,feePayer:s}){let u=this.createTxBuilder(s),a=M({},n),c=pn(e).publicKey,m=t.filter(p=>!a[p.toBase58()]);if(m.length){let p=await this.getRpcPoolsInfo({poolIdList:m});a=M(M({},a),p.poolInfoMap)}return t.forEach(p=>{let d=p.toBase58(),f=a[d];f||this.logAndCreateError(`pool info not found: ${d}`);let y=o[d]||$i(e,p,this.scope.ownerPubKey).publicKey,b=j(this.scope.ownerPubKey,f.mintA,Me).publicKey;u.addInstruction({instructions:[Nt(this.scope.ownerPubKey,b,this.scope.ownerPubKey,f.mintA)]}),u.addInstruction({instructions:[cu(e,this.scope.ownerPubKey,c,p,y,b,f.vaultA,f.mintA,Me)]})}),r===0?u.sizeCheckBuildV0({computeBudgetConfig:i}):u.sizeCheckBuild({computeBudgetConfig:i})}async claimVaultPlatformFee({programId:e=et,platformId:t,mintB:n,mintBProgram:o=Me,claimFeeWallet:r,txVersion:i,computeBudgetConfig:s,txTipConfig:u,feePayer:a}){let c=this.createTxBuilder(a),m=go(e,t,n).publicKey,p=ru(e).publicKey,d=this.scope.account.getAssociatedTokenAccount(n,o);return c.addInstruction({instructions:[Nt(this.scope.ownerPubKey,d,this.scope.ownerPubKey,n,o),du(e,t,r!=null?r:this.scope.ownerPubKey,p,m,d,n,o)]}),c.addCustomComputeBudget(s),c.addTipInstruction(u),c.versionBuild({txVersion:i})}async claimMultipleVaultPlatformFee({programId:e=et,platformList:t,unwrapSol:n=!0,txVersion:o,computeBudgetConfig:r,feePayer:i,associatedOnly:s=!0,checkCreateATAOwner:u=!1}){let a=this.createTxBuilder(i),c={};return t.forEach(async m=>{var b,g;let p=ru(e).publicKey,d=go(e,m.id,m.mintB).publicKey,f=m.mintB.equals(Ln)&&n,y=c[m.mintB.toBase58()];if(!y){let{account:P,instructionParams:h}=await this.scope.account.getOrCreateTokenAccount({mint:m.mintB,owner:this.scope.ownerPubKey,createInfo:f?{payer:this.scope.ownerPubKey,amount:0}:void 0,skipCloseAccount:!f,notUseTokenAccount:f,associatedOnly:f?!1:s,checkCreateATAOwner:u});P&&(y=P),a.addInstruction(h||{}),y===void 0&&this.logAndCreateError(`cannot found platform ${m.id.toBase58()} mintB(${m.mintB.toBase58()}) token accounts`,"tokenAccounts",this.scope.account.tokenAccounts)}a.addInstruction({instructions:[du(e,m.id,(b=m.claimFeeWallet)!=null?b:this.scope.ownerPubKey,d,p,y,m.mintB,(g=m.mintBProgram)!=null?g:Me)]})}),o===0?a.sizeCheckBuildV0({computeBudgetConfig:r}):a.sizeCheckBuild({computeBudgetConfig:r})}async claimCreatorFee({programId:e=et,mintB:t,mintBProgram:n=Me,txVersion:o,computeBudgetConfig:r,txTipConfig:i,feePayer:s}){let u=this.createTxBuilder(s),a=Po(e,this.scope.ownerPubKey,t).publicKey,c=su(e).publicKey,m=this.scope.account.getAssociatedTokenAccount(t,n);return u.addInstruction({instructions:[Nt(this.scope.ownerPubKey,m,this.scope.ownerPubKey,t,n),pu(e,this.scope.ownerPubKey,c,a,m,t,n)]}),u.addCustomComputeBudget(r),u.addTipInstruction(i),u.versionBuild({txVersion:o})}async claimMultipleCreatorFee({programId:e=et,mintBList:t,txVersion:n,computeBudgetConfig:o,feePayer:r}){let i=this.createTxBuilder(r);return t.forEach(s=>{var d;let u=s.pubKey,a=(d=s.programId)!=null?d:Me,c=Po(e,this.scope.ownerPubKey,u).publicKey,m=su(e).publicKey,p=this.scope.account.getAssociatedTokenAccount(u,a);i.addInstruction({instructions:[Nt(this.scope.ownerPubKey,p,this.scope.ownerPubKey,u,a),pu(e,this.scope.ownerPubKey,m,c,p,u,a)]})}),n==0?i.sizeCheckBuildV0({computeBudgetConfig:o}):i.sizeCheckBuild({computeBudgetConfig:o})}async getRpcPoolInfo({poolId:e}){return(await this.getRpcPoolsInfo({poolIdList:[e]})).poolInfoMap[e.toBase58()]}async getRpcPoolsInfo({poolIdList:e,config:t}){let n=await Ne(this.scope.connection,e.map(u=>({pubkey:u})),t),o={},r=[];for(let u=0;u<e.length;u++){let a=n[u];if(a===null||!a.accountInfo)throw Error("fetch pool info error: "+e[u].toBase58());let c=on.decode(a.accountInfo.data);o[e[u].toBase58()]=q(M({},c),{poolId:a.accountInfo.owner}),r.push(c.configId)}let i=await Ne(this.scope.connection,r.map(u=>({pubkey:u})),t),s={};for(let u=0;u<r.length;u++){let a=i[u];if(a===null||!a.accountInfo)throw Error("fetch config info error: "+r[u].toBase58());let c=Qn.decode(a.accountInfo.data);s[r[u].toBase58()]=q(M({},c),{configId:a.accountInfo.owner})}return{poolInfoMap:Object.keys(o).reduce((u,a)=>q(M({},u),{[a]:q(M({},o[a]),{configInfo:s[o[a].configId.toBase58()]})}),{})}}};import{PublicKey as xf}from"@solana/web3.js";import{MintLayout as Kf,TOKEN_2022_PROGRAM_ID as fu,TOKEN_PROGRAM_ID as yu}from"@solana/spl-token";var or=class extends Ee{constructor(t){super(t);this._tokenList=[];this._tokenMap=new Map;this._blackTokenMap=new Set;this._mintGroup={official:new Set,jup:new Set,extra:new Set};this._whiteMap=new Set;this._extraTokenList=[]}async load(t){this.checkDisabled();let{forceUpdate:n=!1,type:o="strict"}=t||{},{mintList:r,blacklist:i,whiteList:s}=await this.scope.fetchV3TokenList(n),u=await this.scope.fetchJupTokenList(n);this._tokenList=[],this._tokenMap=new Map,this._blackTokenMap=new Set(i),this._mintGroup={official:new Set,jup:new Set,extra:new Set},this._whiteMap=new Set(s),this._tokenMap.set(sn.address,sn),this._mintGroup.official.add(sn.address),r.forEach(a=>{var c;this._blackTokenMap.has(a.address)||(this._tokenMap.set(a.address,q(M({},a),{type:"raydium",priority:2,programId:(c=a.programId)!=null?c:a.tags.includes("token-2022")?fu.toBase58():yu.toBase58()})),this._mintGroup.official.add(a.address))}),u.forEach(a=>{var c;this._blackTokenMap.has(a.address)||this._tokenMap.has(a.address)||(this._tokenMap.set(a.address,q(M({},a),{type:"jupiter",priority:1,programId:(c=a.programId)!=null?c:a.tags.includes("token-2022")?fu.toBase58():yu.toBase58(),tags:a.freezeAuthority?[...a.tags||[],"hasFreeze"]:a.tags})),this._mintGroup.jup.add(a.address))}),this._extraTokenList.forEach(a=>{this._blackTokenMap.has(a.address)||this._tokenMap.has(a.address)||(this._tokenMap.set(a.address,q(M({},a),{type:"extra",priority:1,programId:a.programId||a.tags.includes("token-2022")?fu.toBase58():yu.toBase58()})),this._mintGroup.extra.add(a.address))}),this._tokenList=Array.from(this._tokenMap).map(a=>a[1])}get tokenList(){return this._tokenList}get tokenMap(){return this._tokenMap}get blackTokenMap(){return this._blackTokenMap}get mintGroup(){return this._mintGroup}get whiteListMap(){return this._whiteMap}async getTokenInfo(t){if(!t)throw new Error("please input mint");let n=t.toString(),o=this._tokenMap.get(n);if(o)return o;if(n.toLocaleUpperCase()==="SOL")return sn;let r=(await this.scope.api.getTokenInfo([n]))[0];if(r)return this._mintGroup.extra.add(n),this._tokenMap.set(n,q(M({},r),{priority:2})),r;let i=await this.scope.connection.getAccountInfo(new xf(n));if(!i)throw new Error(`mint address not found: ${n}`);let s=Kf.decode(i.data),u=n.toString().substring(0,6),a={chainId:101,address:n,programId:i.owner.toBase58(),logoURI:"",symbol:u,name:u,decimals:s.decimals,tags:[],extensions:{},priority:0,type:"unknown"};return this._mintGroup.extra.add(n),this._tokenMap.set(n,a),a}};var ms=class{constructor(e){this.rawBalances=new Map;let{connection:t,cluster:n,owner:o,api:r,defaultChainTime:i,defaultChainTimeOffset:s,apiCacheTime:u,blockhashCommitment:a="confirmed",loopMultiTxStatus:c}=e;this._connection=t,this.cluster=n||"mainnet",this._owner=o?new vt(o):void 0,this._signAllTransactions=e.signAllTransactions,this.blockhashCommitment=a,this.loopMultiTxStatus=c,this.api=r,this._apiCacheTime=u||5*60*1e3,this.logger=ye("Raydium"),this.farm=new wi({scope:this,moduleName:"Raydium_Farm"}),this.account=new mi({scope:this,moduleName:"Raydium_Account",tokenAccounts:e.tokenAccounts,tokenAccountRawInfos:e.tokenAccountRawInfos}),this.liquidity=new vi({scope:this,moduleName:"Raydium_LiquidityV2"}),this.token=new or({scope:this,moduleName:"Raydium_tokenV2"}),this.tradeV2=new Qi({scope:this,moduleName:"Raydium_tradeV2"}),this.clmm=new Vi({scope:this,moduleName:"Raydium_clmm"}),this.cpmm=new Gi({scope:this,moduleName:"Raydium_cpmm"}),this.utils1216=new Yt({scope:this,moduleName:"Raydium_utils1216"}),this.marketV2=new Eo({scope:this,moduleName:"Raydium_marketV2"}),this.ido=new Uo({scope:this,moduleName:"Raydium_ido"}),this.launchpad=new nr({scope:this,moduleName:"Raydium_lauchpad"}),this.availability={};let m=new Date().getTime();this.apiData={},s&&(this._chainTime={fetched:m,value:{chainTime:i||Date.now()-s,offset:s}})}static async load(e){var c;let t=Sf({cluster:"mainnet",owner:null,apiRequestInterval:3e5,apiRequestTimeout:1e4},e),{cluster:n,apiRequestTimeout:o,logCount:r,logRequests:i,urlConfigs:s}=t,u=new hr({cluster:n,timeout:o,urlConfigs:s,logCount:r,logRequests:i}),a=new ms(q(M({},t),{api:u}));return await a.fetchAvailabilityStatus((c=e.disableFeatureCheck)!=null?c:!0),e.disableLoadToken||await a.token.load({type:e.jupTokenType}),a}get owner(){return this._owner}get ownerPubKey(){if(!this._owner)throw new Error(Ir);return this._owner.publicKey}setOwner(e){return this._owner=e?new vt(e):void 0,this.account.resetTokenAccounts(),this}get connection(){if(!this._connection)throw new Error(Hu);return this._connection}setConnection(e){return this._connection=e,this}get signAllTransactions(){return this._signAllTransactions}setSignAllTransactions(e){return this._signAllTransactions=e,this}checkOwner(){if(!this.owner)throw console.error(Ir),new Error(Ir)}isCacheInvalidate(e){return new Date().getTime()-e>this._apiCacheTime}async fetchChainTime(){try{let e=await this.api.getChainTimeOffset();this._chainTime={fetched:Date.now(),value:{chainTime:Date.now()+e.offset*1e3,offset:e.offset*1e3}}}catch{this._chainTime=void 0}}async fetchV3TokenList(e){if(this.apiData.tokenList&&!this.isCacheInvalidate(this.apiData.tokenList.fetched)&&!e)return this.apiData.tokenList.data;try{let t=await this.api.getTokenList(),n={fetched:Date.now(),data:t};return this.apiData.tokenList=n,n.data}catch(t){return console.error(t),{mintList:[],blacklist:[],whiteList:[]}}}async fetchJupTokenList(e){if(this.cluster==="devnet")return[];let t=this.apiData.jupTokenList;if(t&&!this.isCacheInvalidate(t.fetched)&&!e)return t.data;try{let n=await this.api.getJupTokenList();return this.apiData.jupTokenList={fetched:Date.now(),data:n.map(o=>q(M({},o),{mintAuthority:o.mint_authority||void 0,freezeAuthority:o.freeze_authority||void 0}))},this.apiData.jupTokenList.data}catch(n){return console.error(n),[]}}get chainTimeData(){var e;return(e=this._chainTime)==null?void 0:e.value}async chainTimeOffset(){var e;return this._chainTime&&Date.now()-this._chainTime.fetched<=1e3*60*5?this._chainTime.value.offset:(await this.fetchChainTime(),((e=this._chainTime)==null?void 0:e.value.offset)||0)}async currentBlockChainTime(){var e;return this._chainTime&&Date.now()-this._chainTime.fetched<=1e3*60*5?this._chainTime.value.chainTime:(await this.fetchChainTime(),((e=this._chainTime)==null?void 0:e.value.chainTime)||Date.now())}async fetchEpochInfo(){return this._epochInfo&&Date.now()-this._epochInfo.fetched<=1e3*30?this._epochInfo.value:(this._epochInfo={fetched:Date.now(),value:await this.connection.getEpochInfo()},this._epochInfo.value)}async fetchAvailabilityStatus(e){if(e)return{};try{let t=await this.api.fetchAvailabilityStatus(),n=t.all===!1;return this.availability={all:t.all,swap:n?!1:t.swap,createConcentratedPosition:n?!1:t.createConcentratedPosition,addConcentratedPosition:n?!1:t.addConcentratedPosition,addStandardPosition:n?!1:t.addStandardPosition,removeConcentratedPosition:n?!1:t.removeConcentratedPosition,removeStandardPosition:n?!1:t.removeStandardPosition,addFarm:n?!1:t.addFarm,removeFarm:n?!1:t.removeFarm},t}catch{return{}}}};var YL=l=>l;export{ep as AMM_CONFIG_SEED,ff as AUTH_SEED,Nc as BIT_PRECISION,au as BondingCurveParam,yf as CONFIG_SEED,Af as CREATOR_FEE_VAULT_AUTH_SEED,Vi as Clmm,Qc as ClmmConfigLayout,Se as ClmmInstrument,Ei as ConstantProductCurve,Ll as CpmmConfigInfoLayout,Dl as CpmmCreatorFeeOn,Rt as CpmmFee,Ex as CpmmPermission,jr as CpmmPoolInfoLayout,Ht as Curve,Hn as CurveBase,Wi as CurveCalculator,Tk as DEV_FARM_LOCK_MINT,hk as DEV_FARM_LOCK_VAULT,Tp as DataElement,ha as EXTENSION_TICKARRAY_BITMAP_SIZE,Ac as FARM_LOCK_MINT,kc as FARM_LOCK_VAULT,qt as FARM_PROGRAM_TO_VERSION,Tc as FARM_VERSION_TO_LEDGER_LAYOUT,wc as FARM_VERSION_TO_STATE_LAYOUT,vr as FEE_RATE_DENOMINATOR,ap as FETCH_TICKARRAY_COUNT,Jd as Fee,Ol as FeeOn,ss as FixedPriceCurve,Wr as LIQUIDITY_FEES_DENOMINATOR,Ka as LIQUIDITY_FEES_NUMERATOR,bp as LIQUIDITY_VERSION_TO_SERUM_VERSION,Gh as LIQUIDITY_VERSION_TO_STATE_LAYOUT,tf as LOCK_LIQUIDITY_SEED,Mc as LOG_B_2_X32,vc as LOG_B_P_ERR_MARGIN_LOWER_X64,Fc as LOG_B_P_ERR_MARGIN_UPPER_X64,is as LaunchConstantProductCurve,Qn as LaunchpadConfig,on as LaunchpadPool,ko as LaunchpadPoolInitParam,SC as LaunchpadVesting,us as LinearPriceCurve,Ae as LiquidityMath,$c as LockClPositionLayoutV2,nh as LockPositionLayout,Wa as MARKET_STATE_LAYOUT_V2,Qa as MARKET_STATE_LAYOUT_V3,vl as MARKET_VERSION_TO_STATE_LAYOUT,Xt as MAX_SQRT_PRICE_X64,Mr as MAX_SQRT_PRICE_X64_SUB_ONE,wt as MAX_TICK,Gt as MIN_SQRT_PRICE_X64,Nr as MIN_SQRT_PRICE_X64_ADD_ONE,ft as MIN_TICK,Zr as Market,tr as MathLaunch,le as MathUtil,Ti as MaxU64,Oc as MaxUint128,wn as NEGATIVE_ONE,rp as OBSERVATION_SEED,Vt as ONE,op as OPERATION_SEED,Hc as ObservationInfoLayout,lp as ObservationLayout,jc as OperationLayout,Pf as PLATFORM_FEE_VAULT_AUTH_SEED,gf as PLATFORM_SEED,Gc as POOL_LOCK_ID_SEED,tp as POOL_REWARD_VAULT_SEED,ga as POOL_SEED,ip as POOL_TICK_ARRAY_BITMAP_SEED,Pa as POOL_VAULT_SEED,bf as POOL_VESTING_SEED,Wc as POSITION_SEED,Xo as PlatformConfig,Tf as PlatformCurveParam,ao as PoolInfoLayout,ve as PoolUtils,vo as PositionInfoLayout,dp as PositionRewardInfoLayout,xi as PositionUtils,th as ProtocolPositionLayout,Or as Q128,nt as Q64,ms as Raydium,mp as RewardInfo,wl as RoundDirection,Nl as SERUM_PROGRAMID_TO_VERSION,Ml as SERUM_VERSION_TO_PROGRAMID,sn as SOL_INFO,tl as SPL_MINT_LAYOUT,sp as SUPPORT_MINT_SEED,se as SqrtPriceMath,_o as StableLayout,so as SwapMath,ro as TICK_ARRAY_BITMAP_SIZE,np as TICK_ARRAY_SEED,ot as TICK_ARRAY_SIZE,Fw as TICK_SPACINGS,it as TOKEN_WSOL,hn as TickArrayBitmap,Yc as TickArrayBitmapExtensionLayout,Si as TickArrayBitmapExtensionUtils,Ki as TickArrayLayout,pp as TickLayout,uo as TickMath,we as TickQuery,Z as TickUtils,Gp as TradeDirection,Xp as TradeDirectionOpposite,hi as U64Resolution,_w as U64_IGNORE_RANGE,wf as VestingSchedule,Pc as Voter,Vd as VoterDepositEntry,Fd as VoterLockup,gc as VoterRegistrar,vd as VoterVotingMintConfig,ge as ZERO,La as addLiquidityLayout,Pt as anchorDataBuf,$s as associatedLedgerAccountLayout,Xl as buyExactInInstruction,zl as buyExactOutInstruction,ma as calFarmRewardAmount,rR as checkPoolToAmm,pu as claimCreatorFee,Hi as claimLayout,mu as claimPlatformFee,du as claimPlatformFeeFromVault,cu as claimVestedToken,zc as clmmComputeInfoToApiInfo,kn as closeAccountInstruction,za as collectCpFeeInstruction,rf as cpmmLockPositionInstruction,gi as createAssociatedLedgerAccountInstruction,Hl as createPlatformConfig,il as createPoolFeeLayout,Ma as createPoolV4InstructionV2,Uh as createPoolV4Layout,lu as createVestingAccount,Wn as createWSolAccountInstructions,kt as dwLayout,ta as farmAddRewardLayout,mk as farmLedgerLayoutV3_1,pi as farmLedgerLayoutV3_2,dk as farmLedgerLayoutV5_1,yc as farmLedgerLayoutV5_2,bc as farmLedgerLayoutV6_1,Ic as farmRewardInfoToConfig,Js as farmRewardLayout,ea as farmRewardRestartLayout,Md as farmRewardTimeInfoLayout,pc as farmStateV3Layout,fc as farmStateV5Layout,di as farmStateV6Layout,Wk as fetchMultipleFarmInfoAndUpdate,CI as fetchMultipleInfo,Sa as fixedSwapInLayout,Ca as fixedSwapOutLayout,Op as formatLayout,Qe as generatePubKey,hc as getAssociatedAuthority,Ur as getAssociatedConfigId,pt as getAssociatedLedgerAccount,yi as getAssociatedLedgerPoolAccount,Fp as getAssociatedOpenOrders,Ea as getAssociatedPoolKeys,qi as getCpLockPda,xx as getCpmmPdaAmmConfigId,qa as getCpmmPdaPoolId,Ua as getCreatePoolKeys,da as getDepositEntryIndex,dl as getDxByDyBaseIn,ml as getDyByDxBaseIn,Oo as getFarmLedgerLayout,Ed as getFarmStateLayout,_a as getLiquidityAssociatedAuthority,po as getLiquidityAssociatedId,LT as getLiquidityFromAmounts,Xw as getPdaAmmConfigId,Yn as getPdaCpiEvent,su as getPdaCreatorFeeVaultAuth,Po as getPdaCreatorVault,He as getPdaExBitmapAccount,pn as getPdaLaunchpadAuth,BC as getPdaLaunchpadConfigId,Go as getPdaLaunchpadPoolId,ou as getPdaLaunchpadVaultId,Mo as getPdaLockClPositionIdV2,ka as getPdaLockPositionId,Jp as getPdaLpMint,Tn as getPdaMetadataKey,wa as getPdaMintExAccount,Uc as getPdaObservationAccount,Di as getPdaObservationId,Bi as getPdaOperationAccount,Il as getPdaPermissionId,Tt as getPdaPersonalPositionAddress,ru as getPdaPlatformFeeVaultAuth,iu as getPdaPlatformId,go as getPdaPlatformVault,Wo as getPdaPoolAuthority,Dc as getPdaPoolId,qc as getPdaPoolRewardVaulId,Aa as getPdaPoolVaultId,nn as getPdaProtocolPositionAddress,Pe as getPdaTickArrayAddress,hl as getPdaVault,$i as getPdaVestId,ra as getRegistrarAddress,pl as getStablePrice,la as getTokenOwnerRecordAddress,ua as getVoterAddress,ca as getVoterWeightRecordAddress,aa as getVotingMintAuthority,sa as getVotingTokenMint,Qd as governanceCreateTokenOwnerRecord,Ww as i16ToBytes,Vr as i32ToBytes,Ra as initPoolLayout,Hs as initTokenAccountInstruction,WC as initialize,Wp as initializeMarket,Ul as initializeV2,Rl as initializeWithPermission,Gl as initializeWithToken2022,oa as isValidFarmVersion,Ii as isZero,Dk as judgeFarmType,ya as leadingZeros,Ec as leastSignificantBit,co as liquidityStateV4Layout,gp as liquidityStateV5Layout,Dr as makeAMMSwapInstruction,al as makeAddLiquidityInstruction,fa as makeAddNewRewardInstruction,ts as makeClaimInstruction,nu as makeClaimInstructionV4,Ya as makeCollectCreatorFeeInstruction,Cl as makeCpmmLockInstruction,Bl as makeCreateCpmmPoolInInstruction,Bc as makeCreateFarmInstruction,Xr as makeCreateMarketInstruction,xc as makeCreatorWithdrawFarmRewardInstruction,xl as makeDepositCpmmInInstruction,Sc as makeDepositInstructionV3,Cc as makeDepositInstructionV5,Rc as makeDepositInstructionV6,ow as makeDepositTokenInstruction,rw as makeDepositWithdrawInstruction,nI as makeInitPoolInstructionV4,rC as makePurchaseInstruction,pa as makeRestartRewardInstruction,ul as makeSimulatePoolInfoInstruction,Hr as makeSwapCpmmBaseInInstruction,Sl as makeSwapCpmmBaseOutInstruction,kp as makeSwapFixedInInstruction,wp as makeSwapFixedOutInstruction,Vl as makeSwapInstruction,dc as makeTransferInstruction,Kl as makeWithdrawCpmmInInstruction,ki as makeWithdrawInstructionV3,Kc as makeWithdrawInstructionV4,Ai as makeWithdrawInstructionV5,Pi as makeWithdrawInstructionV6,iw as makeWithdrawTokenInstruction,Vw as mockCreatePoolInfo,Vc as mockV3CreatePoolInfo,hp as modelDataInfoLayout,_c as mostSignificantBit,mc as parseTokenAccountResp,Ch as parseTokenInfo,qn as poolTypeV6,Ja as purchaseLayout,Ld as realFarmStateV3Layout,Od as realFarmStateV5Layout,Nd as realFarmV6Layout,Na as removeLiquidityInstruction,Oa as removeLiquidityLayout,qC as removePlatformCurveParamInstruction,cS as route1Instruction,lS as route2Instruction,uf as routeInstruction,Yl as sellExactInInstruction,Ql as sellExactOut,tI as simulatePoolInfoInstruction,Lh as solToWSolToken,tn as splAccountLayout,mS as swapBaseInAutoAccount,dS as swapBaseOutAutoAccount,Gr as toAmmComputePoolInfo,yt as toApiV3Token,Un as toFeeConfig,Er as toToken,Ri as toTokenAmount,Rh as toTokenInfo,ba as trailingZeros,Fr as u16ToBytes,Dw as u32ToBytes,kf as u8ToBytes,YL as unionArr,Wd as updateFarmPoolInfo,jl as updatePlatformConfig,DC as updatePlatformCurveParamInstruction,ia as validateFarmRewards,jd as voterStakeRegistryCreateDepositEntry,Hd as voterStakeRegistryCreateVoter,Xd as voterStakeRegistryDeposit,zd as voterStakeRegistryUpdateVoterWeightRecord,Yd as voterStakeRegistryWithdraw,Oh as wSolToSolToken,Zs as withdrawRewardLayout};
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
//# sourceMappingURL=index.mjs.map