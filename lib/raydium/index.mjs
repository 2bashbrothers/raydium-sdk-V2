var Yl=Object.defineProperty,jl=Object.defineProperties;var Hl=Object.getOwnPropertyDescriptors;var $i=Object.getOwnPropertySymbols;var Pu=Object.prototype.hasOwnProperty,ku=Object.prototype.propertyIsEnumerable;var Au=(c,e,t)=>e in c?Yl(c,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):c[e]=t,v=(c,e)=>{for(var t in e||(e={}))Pu.call(e,t)&&Au(c,t,e[t]);if($i)for(var t of $i(e))ku.call(e,t)&&Au(c,t,e[t]);return c},q=(c,e)=>jl(c,Hl(e));var Ee=(c,e)=>{var t={};for(var n in c)Pu.call(c,n)&&e.indexOf(n)<0&&(t[n]=c[n]);if(c!=null&&$i)for(var n of $i(c))e.indexOf(n)<0&&ku.call(c,n)&&(t[n]=c[n]);return t};import{merge as ff}from"lodash";import qu from"axios";import{PublicKey as hu}from"@solana/web3.js";import{get as wu,set as Zl}from"lodash";var ps=class{constructor(e){this.logLevel=e.logLevel!==void 0?e.logLevel:0,this.name=e.name}set level(e){this.logLevel=e}get time(){return Date.now().toString()}get moduleName(){return this.name}isLogLevel(e){return e<=this.logLevel}error(...e){return this.isLogLevel(0)?(console.error(this.time,this.name,"sdk logger error",...e),this):this}logWithError(...e){let t=e.map(n=>typeof n=="object"?JSON.stringify(n):n).join(", ");throw new Error(t)}warning(...e){return this.isLogLevel(1)?(console.warn(this.time,this.name,"sdk logger warning",...e),this):this}info(...e){return this.isLogLevel(2)?(console.info(this.time,this.name,"sdk logger info",...e),this):this}debug(...e){return this.isLogLevel(3)?(console.debug(this.time,this.name,"sdk logger debug",...e),this):this}},Tu={},$l={};function ye(c){let e=wu(Tu,c);if(!e){let t=wu($l,c);e=new ps({name:c,logLevel:t}),Zl(Tu,c,e)}return e}import{MINT_SIZE as Jl,TOKEN_PROGRAM_ID as em,getTransferFeeConfig as tm,unpackMint as nm}from"@solana/spl-token";var fs=ye("Raydium_accountInfo_util");async function Ht(c,e,t){let{batchRequest:n,commitment:o="confirmed",chunkCount:s=100}=v({batchRequest:!1},t),i=ys(e,s),r=new Array(i.length).fill([]);if(n){let u=i.map(m=>{let p=c._buildArgs([m.map(d=>d.toBase58())],o,"base64");return{methodName:"getMultipleAccounts",args:p}}),a=ys(u,10);r=(await(await Promise.all(a.map(async m=>await c._rpcBatchRequest(m)))).flat()).map(m=>(m.error&&fs.logWithError(`failed to get info for multiple accounts, RPC_ERROR, ${m.error.message}`),m.result.value.map(p=>{if(p){let{data:d,executable:f,lamports:y,owner:b,rentEpoch:g}=p;return d.length!==2&&d[1]!=="base64"&&fs.logWithError("info must be base64 encoded, RPC_ERROR"),{data:Buffer.from(d[0],"base64"),executable:f,lamports:y,owner:new hu(b),rentEpoch:g}}return null})))}else try{r=await Promise.all(i.map(u=>c.getMultipleAccountsInfo(u,o)))}catch(u){u instanceof Error&&fs.logWithError(`failed to get info for multiple accounts, RPC_ERROR, ${u.message}`)}return r.flat()}async function Le(c,e,t){let n=await Ht(c,e.map(o=>o.pubkey),t);return e.map((o,s)=>q(v({},o),{accountInfo:n[s]}))}async function Ao({connection:c,mints:e,config:t}){var s,i,r;if(e.length===0)return{};let n=await Le(c,e.map(u=>({pubkey:dt(u)})),t),o={};for(let u of n){if(!u.accountInfo||u.accountInfo.data.length<Jl){console.log("invalid mint account",u.pubkey.toBase58());continue}let a=nm(u.pubkey,u.accountInfo,(s=u.accountInfo)==null?void 0:s.owner);o[u.pubkey.toString()]=q(v({},a),{programId:((i=u.accountInfo)==null?void 0:i.owner)||em,feeConfig:(r=tm(a))!=null?r:void 0})}return o[hu.default.toBase58()]=o[Z.toBase58()],o}import cn from"bn.js";import Jy from"decimal.js";import lm from"big.js";import tr from"bn.js";import om from"toformat";var im=om,Go=im;import er from"big.js";import sm from"bn.js";import am from"decimal.js-light";import Xo from"bn.js";var Iu=9007199254740991;function J(c){let e=ye("Raydium_parseBigNumberish");if(c instanceof Xo)return c;if(typeof c=="string"){if(c.match(/^-?[0-9]+$/))return new Xo(c);e.logWithError(`invalid BigNumberish string: ${c}`)}return typeof c=="number"?(c%1&&e.logWithError(`BigNumberish number underflow: ${c}`),(c>=Iu||c<=-Iu)&&e.logWithError(`BigNumberish number overflow: ${c}`),new Xo(String(c))):typeof c=="bigint"?new Xo(c.toString()):(e.error(`invalid BigNumberish value: ${c}`),new Xo(0))}var Ji=ye("module/fraction"),bs=Go(er),zo=Go(am),um={[0]:zo.ROUND_DOWN,[1]:zo.ROUND_HALF_UP,[2]:zo.ROUND_UP},cm={[0]:er.roundDown,[1]:er.roundHalfUp,[2]:er.roundUp},we=class{constructor(e,t=new sm(1)){this.numerator=J(e),this.denominator=J(t)}get quotient(){return this.numerator.div(this.denominator)}invert(){return new we(this.denominator,this.numerator)}add(e){let t=e instanceof we?e:new we(J(e));return this.denominator.eq(t.denominator)?new we(this.numerator.add(t.numerator),this.denominator):new we(this.numerator.mul(t.denominator).add(t.numerator.mul(this.denominator)),this.denominator.mul(t.denominator))}sub(e){let t=e instanceof we?e:new we(J(e));return this.denominator.eq(t.denominator)?new we(this.numerator.sub(t.numerator),this.denominator):new we(this.numerator.mul(t.denominator).sub(t.numerator.mul(this.denominator)),this.denominator.mul(t.denominator))}mul(e){let t=e instanceof we?e:new we(J(e));return new we(this.numerator.mul(t.numerator),this.denominator.mul(t.denominator))}div(e){let t=e instanceof we?e:new we(J(e));return new we(this.numerator.mul(t.denominator),this.denominator.mul(t.numerator))}toSignificant(e,t={groupSeparator:""},n=1){Number.isInteger(e)||Ji.logWithError(`${e} is not an integer.`),e<=0&&Ji.logWithError(`${e} is not positive.`),zo.set({precision:e+1,rounding:um[n]});let o=new zo(this.numerator.toString()).div(this.denominator.toString()).toSignificantDigits(e);return o.toFormat(o.decimalPlaces(),t)}toFixed(e,t={groupSeparator:""},n=1){return Number.isInteger(e)||Ji.logWithError(`${e} is not an integer.`),e<0&&Ji.logWithError(`${e} is negative.`),bs.DP=e,bs.RM=cm[n]||1,new bs(this.numerator.toString()).div(this.denominator.toString()).toFormat(e,t)}isZero(){return this.numerator.isZero()}};var mm=ye("Raydium_amount"),Bu=Go(lm);function dm(c,e){let t="0",n="0";if(c.includes(".")){let o=c.split(".");o.length===2?([t,n]=o,n=n.padEnd(e,"0")):mm.logWithError(`invalid number string, num: ${c}`)}else t=c;return[t,n.slice(0,e)||n]}var xe=class extends we{constructor(t,n,o=!0,s){let i=new tr(0),r=gs.pow(new tr(t.decimals));if(o)i=J(n);else{let u=new tr(0),a=new tr(0);if(typeof n=="string"||typeof n=="number"||typeof n=="bigint"){let[l,m]=dm(n.toString(),t.decimals);u=J(l),a=J(m)}u=u.mul(r),i=u.add(a)}super(i,r);this.logger=ye(s||"TokenAmount"),this.token=t}get raw(){return this.numerator}isZero(){return this.raw.isZero()}gt(t){return this.token.equals(t.token)||this.logger.logWithError("gt token not equals"),this.raw.gt(t.raw)}lt(t){return this.token.equals(t.token)||this.logger.logWithError("lt token not equals"),this.raw.lt(t.raw)}add(t){return this.token.equals(t.token)||this.logger.logWithError("add token not equals"),new xe(this.token,this.raw.add(t.raw))}subtract(t){return this.token.equals(t.token)||this.logger.logWithError("sub token not equals"),new xe(this.token,this.raw.sub(t.raw))}toSignificant(t=this.token.decimals,n,o=0){return super.toSignificant(t,n,o)}toFixed(t=this.token.decimals,n,o=0){return t>this.token.decimals&&this.logger.logWithError("decimals overflow"),super.toFixed(t,n,o)}toExact(t={groupSeparator:""}){return Bu.DP=this.token.decimals,new Bu(this.numerator.toString()).div(this.denominator.toString()).toFormat(t)}};import{PublicKey as pm}from"@solana/web3.js";import{TOKEN_PROGRAM_ID as xu}from"@solana/spl-token";var an={chainId:101,address:pm.default.toBase58(),programId:xu.toBase58(),decimals:9,symbol:"SOL",name:"solana",logoURI:"https://img-v1.raydium.io/icon/So11111111111111111111111111111111111111112.png",tags:[],priority:2,type:"raydium",extensions:{coingeckoId:"solana"}},it={chainId:101,address:"So11111111111111111111111111111111111111112",programId:xu.toBase58(),decimals:9,symbol:"WSOL",name:"Wrapped SOL",logoURI:"https://img-v1.raydium.io/icon/So11111111111111111111111111111111111111112.png",tags:[],priority:2,type:"raydium",extensions:{coingeckoId:"solana"}};import{PublicKey as Ts}from"@solana/web3.js";import{PublicKey as De,SystemProgram as Su,SYSVAR_RENT_PUBKEY as fm}from"@solana/web3.js";import{TOKEN_PROGRAM_ID as ym}from"@solana/spl-token";function P({pubkey:c,isSigner:e=!1,isWritable:t=!0}){return{pubkey:c,isWritable:t,isSigner:e}}var As=[P({pubkey:ym,isWritable:!1}),P({pubkey:Su.programId,isWritable:!1}),P({pubkey:fm,isWritable:!1})];function Ps({publicKey:c,transformSol:e}){let t=ks(c.toString());if(t instanceof De)return e&&t.equals(rt)?Z:t;if(e&&t.toString()===rt.toBase58())return Z;if(typeof t=="string"){if(t===De.default.toBase58())return De.default;try{return new De(t)}catch{throw new Error("invalid public key")}}throw new Error("invalid public key")}function ks(c){try{return new De(c)}catch{return c}}var nr=new De("MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr"),un=new De("MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr"),$e=new De("SysvarRent111111111111111111111111111111111"),ws=new De("SysvarC1ock11111111111111111111111111111111"),Zt=new De("metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s"),or=new De("Sysvar1nstructions1111111111111111111111111"),ir=Su.programId,oy=new De("4k3Dyjzvzp8eMZWUXbBCjEvwSkkk59S5iCNLY3QrkX6R"),iy=new De("Ea5SjE2Y6yvCeW5dYTn7PYMuW5ikXkvbGdcmSnXeaLjS"),ry=new De("SRMuApVNdxXokk5GT7XD5cUUgXMBCoAz2LHeuAoKWRt"),sy=new De("EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v"),ay=new De("Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB"),uy=new De("mSoLzYCxHdYgdzU16g5QSh3i5K3z3KZK7ytfqcJm7So"),cy=new De("7dHbWXmci3dT8UFYWYZweBLXgycu7Y3iL6trKn1Y7ARj"),ly=new De("USDH1SM1ojwWUga67PGrgFWUHibbjqMvuMaDkRJTgkX"),my=new De("NRVwhjBQiUPYtfDT5zRBVJajzFQHaBUNtC7SNVvqRFa"),dy=new De("ANAxByE6G2WjFp7A4NqtWYXb3mgruyzZYg3spfxe6Lbo"),py=new De("7vfCXTUXx5WJV5JADk17DUJ4ksgau7utNKj4b963voxs"),Z=new De("So11111111111111111111111111111111111111112"),rt=De.default;function dt(c){return Ps({publicKey:c,transformSol:!0})}var hs=class{constructor({mint:e,decimals:t,symbol:n,name:o,skipMint:s=!1,isToken2022:i=!1}){if(e===rt.toBase58()||e instanceof Ts&&rt.equals(e)){this.decimals=it.decimals,this.symbol=it.symbol,this.name=it.name,this.mint=new Ts(it.address),this.isToken2022=!1;return}this.decimals=t,this.symbol=n||e.toString().substring(0,6),this.name=o||e.toString().substring(0,6),this.mint=s?Ts.default:Ps({publicKey:e}),this.isToken2022=i}equals(e){return this===e?!0:this.mint.equals(e.mint)}},We=hs;We.WSOL=new hs(q(v({},it),{mint:it.address}));var Is=class{constructor({decimals:e,symbol:t="UNKNOWN",name:n="UNKNOWN"}){this.decimals=e,this.symbol=t,this.name=n}equals(e){return this===e}},rr=Is;rr.SOL=new Is(an);import bm from"bn.js";var Ku=new we(new bm(100)),st=class extends we{toSignificant(e=5,t,n){return this.mul(Ku).toSignificant(e,t,n)}toFixed(e=2,t,n){return this.mul(Ku).toFixed(e,t,n)}};var gm=ye("Raydium_price"),Tt=class extends we{constructor(t){let{baseToken:n,quoteToken:o,numerator:s,denominator:i}=t;super(s,i);this.baseToken=n,this.quoteToken=o,this.scalar=new we(Bs(n.decimals),Bs(o.decimals))}get raw(){return new we(this.numerator,this.denominator)}get adjusted(){return super.mul(this.scalar)}invert(){return new Tt({baseToken:this.quoteToken,quoteToken:this.baseToken,denominator:this.numerator,numerator:this.denominator})}mul(t){this.quoteToken!==t.baseToken&&gm.logWithError("mul token not equals");let n=super.mul(t);return new Tt({baseToken:this.baseToken,quoteToken:t.quoteToken,denominator:n.denominator,numerator:n.numerator})}toSignificant(t=this.quoteToken.decimals,n,o){return this.adjusted.toSignificant(t,n,o)}toFixed(t=this.quoteToken.decimals,n,o){return this.adjusted.toFixed(t,n,o)}};import{PublicKey as Am}from"@solana/web3.js";import Pm from"bn.js";function Cu(c){return typeof c=="object"&&c!==null&&![We,xe,Am,we,Pm,Tt,st].some(e=>typeof e=="object"&&c instanceof e)}function Me(c){return typeof c=="string"?ks(c):Array.isArray(c)?c.map(e=>Me(e)):Cu(c)?Object.fromEntries(Object.entries(c).map(([e,t])=>[e,Me(t)])):c}var ht=new cn(0),Ru=new cn(1),cb=new cn(2),lb=new cn(3),mb=new cn(5),gs=new cn(10),db=new cn(100),pb=new cn(1e3),fb=new cn(1e4);function Bs(c){return gs.pow(J(c))}function sr(c,e){let t=c.divmod(e);return t.mod.isZero()?t.div:t.div.isNeg()?t.div.isubn(1):t.div.iaddn(1)}function ar(c,e,t){return c.mul(e).add(t).sub(new cn(1)).div(t)}function xs(c,e,t){return c.mul(e).div(t)}var Lu=c=>typeof c=="number";function Ou(c,e,t){let n=Lu(e)?e*((t==null?void 0:t.unit)==="s"?1e3:1):e;return new Date(c).getTime()<=n}function Nu(c,e,t){let n=Lu(e)?e*((t==null?void 0:t.unit)==="s"?1e3:1):e;return new Date(c).getTime()>n}function ys(c,e=1,t=[]){let n=[...c];if(e<=0)return t;for(;n.length;)t.push(n.splice(0,e));return t}var Ct=class{constructor(e){this._owner=e}get publicKey(){return Ct.isKeyPair(this._owner)?this._owner.publicKey:this._owner}get signer(){return Ct.isKeyPair(this._owner)?this._owner:void 0}get isKeyPair(){return Ct.isKeyPair(this._owner)}get isPublicKey(){return Ct.isPublicKey(this._owner)}static isKeyPair(e){return e.secretKey!==void 0}static isPublicKey(e){return!Ct.isKeyPair(e)}};import{PublicKey as Bm}from"@solana/web3.js";import{TOKEN_PROGRAM_ID as xm}from"@solana/spl-token";import{ComputeBudgetProgram as Mu,Keypair as vu,PublicKey as Fu,Transaction as ur,TransactionMessage as km,VersionedTransaction as Vu}from"@solana/web3.js";var U={CreateAccount:"CreateAccount",InitAccount:"InitAccount",CreateATA:"CreateATA",CloseAccount:"CloseAccount",TransferAmount:"TransferAmount",InitMint:"InitMint",MintTo:"MintTo",InitMarket:"InitMarket",Util1216OwnerClaim:"Util1216OwnerClaim",SetComputeUnitPrice:"SetComputeUnitPrice",SetComputeUnitLimit:"SetComputeUnitLimit",ClmmCreatePool:"ClmmCreatePool",ClmmOpenPosition:"ClmmOpenPosition",ClmmIncreasePosition:"ClmmIncreasePosition",ClmmDecreasePosition:"ClmmDecreasePosition",ClmmClosePosition:"ClmmClosePosition",ClmmSwapBaseIn:"ClmmSwapBaseIn",ClmmSwapBaseOut:"ClmmSwapBaseOut",ClmmInitReward:"ClmmInitReward",ClmmSetReward:"ClmmSetReward",ClmmCollectReward:"ClmmCollectReward",ClmmLockPosition:"ClmmLockPosition",ClmmHarvestLockPosition:"ClmmHarvestLockPosition",AmmV4Swap:"AmmV4Swap",AmmV4AddLiquidity:"AmmV4AddLiquidity",AmmV4RemoveLiquidity:"AmmV4RemoveLiquidity",AmmV4SimulatePoolInfo:"AmmV4SimulatePoolInfo",AmmV4SwapBaseIn:"AmmV4SwapBaseIn",AmmV4SwapBaseOut:"AmmV4SwapBaseOut",AmmV4CreatePool:"AmmV4CreatePool",AmmV4InitPool:"AmmV4InitPool",AmmV5AddLiquidity:"AmmV5AddLiquidity",AmmV5RemoveLiquidity:"AmmV5RemoveLiquidity",AmmV5SimulatePoolInfo:"AmmV5SimulatePoolInfo",AmmV5SwapBaseIn:"AmmV5SwapBaseIn",AmmV5SwapBaseOut:"AmmV5SwapBaseOut",RouteSwap:"RouteSwap",RouteSwap1:"RouteSwap1",RouteSwap2:"RouteSwap2",FarmV3Deposit:"FarmV3Deposit",FarmV3Withdraw:"FarmV3Withdraw",FarmV3CreateLedger:"FarmV3CreateLedger",FarmV4Withdraw:"FarmV4Withdraw",FarmV5Deposit:"FarmV5Deposit",FarmV5Withdraw:"FarmV5Withdraw",FarmV5CreateLedger:"FarmV5CreateLedger",FarmV6Deposit:"FarmV6Deposit",FarmV6Withdraw:"FarmV6Withdraw",FarmV6Create:"FarmV6Create",FarmV6Restart:"FarmV6Restart",FarmV6CreatorAddReward:"FarmV6CreatorAddReward",FarmV6CreatorWithdraw:"FarmV6CreatorWithdraw",CpmmCreatePool:"CpmmCreatePool",CpmmAddLiquidity:"CpmmAddLiquidity",CpmmWithdrawLiquidity:"CpmmWithdrawLiquidity",CpmmSwapBaseIn:"CpmmSwapBaseIn",CpmmSwapBaseOut:"CpmmSwapBaseOut",CpmmLockLp:"CpmmLockLp",CpmmCollectLockFee:"CpmmCollectLockFee",TransferTip:"TransferTip"};import{TOKEN_PROGRAM_ID as wm}from"@solana/spl-token";var yn=ye("Raydium_txUtil"),_u=1644;function Qo(c){let e=[],t=[];return c.microLamports&&(e.push(Mu.setComputeUnitPrice({microLamports:c.microLamports})),t.push(U.SetComputeUnitPrice)),c.units&&(e.push(Mu.setComputeUnitLimit({units:c.units})),t.push(U.SetComputeUnitLimit)),{instructions:e,instructionTypes:t}}async function zn(c,e){var n,o;let t=e!=null?e:"confirmed";return(o=await((n=c.getLatestBlockhash)==null?void 0:n.call(c,{commitment:t})))==null?void 0:o.blockhash}async function Yo(c,e){return c.getSignatureStatuses([e]),new Promise((t,n)=>{let o=setTimeout(n,6e4);c.onSignature(e,s=>{if(clearTimeout(o),!s.err){t("");return}n(Object.assign(s.err,{txId:e}))},"confirmed")})}function cr(c,e){c.length<1&&yn.logWithError(`no instructions provided: ${c.toString()}`),e.length<1&&yn.logWithError(`no signers provided:, ${e.toString()}`);let t=new ur;t.recentBlockhash="11111111111111111111111111111111",t.feePayer=e[0],t.add(...c);try{return Buffer.from(t.serialize({verifySignatures:!1})).toString("base64").length<_u}catch{return!1}}async function Eu(c,e,t,n=!0){let o=new Fu("RaydiumSimuLateTransaction11111111111111111"),s=[],i=new ur;i.feePayer=o;for(let a of e)cr([...i.instructions,a],[o])||(s.push(i),i=new ur,i.feePayer=o),i.add(a);i.instructions.length>0&&s.push(i);let r=[];try{if(r=await Tm(c,s,n),r.find(a=>a.err!==null))throw Error("rpc simulateTransaction error")}catch(a){a instanceof Error&&yn.logWithError("failed to simulate for instructions","RPC_ERROR",{message:a.message})}let u=[];for(let a of r)if(yn.debug("simulate result:",a),a.logs){let l=a.logs.filter(m=>m&&m.includes(t));yn.debug("filteredLog:",u),l.length||yn.logWithError("simulate log not match keyword","keyword",t),u.push(...l)}return u}function Du(c,e){let t=c.match(/{["\w:,]+}/g);return!t||t.length!==1?yn.logWithError(`simulate log fail to match json, keyword: ${e}`):t[0]}function bn(c,e){let n=new RegExp(`"${e}":(\\d+)`,"g").exec(c);return!n||n.length!==2?yn.logWithError(`simulate log fail to match key", key: ${e}`):n[1]}function ne(c,e){let[t,n]=Fu.findProgramAddressSync(c,e);return{publicKey:t,nonce:n}}async function Tm(c,e,t){let n=[];if(t){let o=await c.getLatestBlockhash(),s=[];for(let a of e){a.recentBlockhash=o.blockhash,a.lastValidBlockHeight=o.lastValidBlockHeight;let m=a._compile().serialize(),d=a._serialize(m).toString("base64");s.push(d)}let i=s.map(a=>{let l=c._buildArgs([a],void 0,"base64");return{methodName:"simulateTransaction",args:l}}),r=[],u=20;for(let a=0;a<Math.ceil(i.length/u);a++)r.push(i.slice(a*u,(a+1)*u));n=await(await Promise.all(r.map(async a=>(await c._rpcBatchRequest(a)).map(l=>l.result.value)))).flat()}else try{n=await Promise.all(e.map(async o=>await(await c.simulateTransaction(o)).value))}catch(o){o instanceof Error&&yn.logWithError("failed to get info for multiple accounts","RPC_ERROR",{message:o.message})}return n}function jo({instructions:c,payer:e,signers:t}){return cr(c,[e,...t])}function gn({instructions:c,payer:e,lookupTableAddressAccount:t,recentBlockhash:n=vu.generate().publicKey.toString()}){let s=new km({payerKey:e,recentBlockhash:n,instructions:c}).compileToV0Message(Object.values(t!=null?t:{}));try{return Buffer.from(new Vu(s).serialize()).toString("base64").length<_u}catch{return!1}}var hm=c=>Buffer.isBuffer(c)?c:c instanceof Uint8Array?Buffer.from(c.buffer,c.byteOffset,c.byteLength):Buffer.from(c),Im=c=>{let e=c.serialize({requireAllSignatures:!1,verifySignatures:!1});c instanceof Vu&&(e=hm(e));try{return e instanceof Buffer?e.toString("base64"):Buffer.from(e).toString("base64")}catch{return e.toString("base64")}};function Cn(c){let e=[];return c.forEach(t=>{t instanceof ur&&(t.recentBlockhash||(t.recentBlockhash=wm.toBase58()),t.feePayer||(t.feePayer=vu.generate().publicKey)),e.push(Im(t))}),console.log("simulate tx string:",e),e}function H(c,e,t){return ne([c.toBuffer(),(t!=null?t:xm).toBuffer(),e.toBuffer()],new Bm("ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL"))}import{PublicKey as oe}from"@solana/web3.js";var Ss=new oe("EhhTKczWMGQt46ynNeRX1WfeagwwJd7ufHvCDjRxjo5Q"),Ks=new oe("CBuCnLe26faBpcBP2fktp4rp8abpcAnTWft6ZrP5Q4T"),Cs=new oe("9KEPoZmtHUrBbhWN1v1KWLMkkvwY6WLtAVUCPRtRjP4z"),Po=new oe("FarmqiPv5eAj3j1GMdMCMUGXqPUvmquZtMy86QH6rzhG"),Sm=new oe("CLaimxFqjHzgTJtAGHU47NPhg6qrc5sCnpC4tBLyABQS"),Rs=new oe("srmqPvymJeFKQ4zGQed1GFppgkRHL9kaELCbyksJtPX"),lr=new oe("9xQeWvG816bUx9EPjHmaT23yvVM2ZWbrrpZb9PusVFin"),Ho=new oe("675kPX9MHTjS2zt1qfr1NYHuzeLXfQM9H24wFSUt1Mp8"),Km=new oe("5quBtoiQqxF9Jv6KYKctB59NT3gtJD2Y65kdnB1Uev3h"),mr=new oe("CDSr3ssLcRB6XYPJwAfFt18MZvEZp4LjHcvzBVZ45duo"),Rn=new oe("CAMMCzo5YL8w4VFF8KVHrK22GGUsp5VTaW7grrKgrWqK"),ko=new oe("LockrWmn6K5twhz3y9w1dQERbmgSaRkfnTeTKbpofwE"),Zo=new oe("kN1kEznaF5Xbd8LYuqtEFcxzWSBk5Fv6ygX6SqEGJVy"),Ln=new oe("CDSr3ssLcRB6XYPJwAfFt18MZvEZp4LjHcvzBVZ45duo"),Cm=new oe("routeUGWgWzqBWFcrCfv8tritsqukccJPu3q5GPP3xS"),Ls=new oe("7YttLkHDoNj9wyDur5pM1ejNaAvT9X4eqaYcHQqtj2G5"),Rm=new oe("6FJon3QE27qgPVggARueB22hLvoh22VzJpXv4rBEoSLF"),Lm=new oe("CC12se5To1CdEuw7fDS27B7Geo5jJyL7t5UK2B44NgiH"),Om=new oe("9HzJyW1qZsEiSfMUf6L2jo3CcTKAyBmSyKdwQeYisHrC"),Nm=new oe("DropEU8AvevN3UrXWXTMuz3rqnMczQVNjq3kcSdW2SQi"),$o=new oe("CPMMoo8L3F4NbTegBCKVNunggL7H1ZpdTHKxQB5qKP1C"),Os=new oe("GpMZbSM2GgvTKHJirzeGfMFoaZ8UR2X7F4v8vHTvxFbL"),Mm=new oe("DNXgeM9EiiaAbaWvwjHj9fQQLAX5ZsfHyvmYUNRAdNC8"),Jo=new oe("LockrWmn6K5twhz3y9w1dQERbmgSaRkfnTeTKbpofwE"),ei=new oe("3f7GcQFG397GAaEnv51zR6tsTVihYRydnydDD1cXekxH"),at=new oe("LanMV9sAd7wArD4vJFi2qDdfnVhFxYSUg6eADduJ3uj"),vm=new oe("WLHv2UAZm6z4KyaaELi5pjdbJh6RESMva1Rnn8pJVVh"),vb=new oe("DRay6fNdQ5J82H7xV6uq2aV3mNrUZ1J4PgSKsWgptcm6"),Fb=new oe("5xqNaZXX5eUi4p5HU4oz9i5QnwRNT2y6oN7yyn4qENeq"),Fm=new oe("4Bu96XjU84XjPDSpveTVf6LYGCkfW5FK7SNkREWcEfV4"),Vm=new oe("6s1xP3hpbAfFoNtUNF8mfHsjr2Bd97JxFJRWLbL6aHuX"),ti={IDO_PROGRAM_ID_V1:Rm,IDO_PROGRAM_ID_V2:Lm,IDO_PROGRAM_ID_V3:Om,IDO_PROGRAM_ID_V4:Nm},gt={AMM_V4:Ho,AMM_STABLE:Km,CLMM_PROGRAM_ID:Rn,CLMM_LOCK_PROGRAM_ID:ko,CLMM_LOCK_AUTH_ID:Zo,FARM_PROGRAM_ID_V3:Ss,FARM_PROGRAM_ID_V4:Ks,FARM_PROGRAM_ID_V5:Cs,FARM_PROGRAM_ID_V6:Po,OPEN_BOOK_PROGRAM:Rs,SERUM_PROGRAM_ID_V3:lr,UTIL1216:Sm,Router:Cm,CREATE_CPMM_POOL_PROGRAM:$o,CREATE_CPMM_POOL_AUTH:Os,CREATE_CPMM_POOL_FEE_ACC:Mm,LOCK_CPMM_PROGRAM:Jo,LOCK_CPMM_AUTH:ei,LAUNCHPAD_PROGRAM:at,LAUNCHPAD_AUTH:vm,LAUNCHPAD_PLATFORM:Fm,LAUNCHPAD_CONFIG:Vm,FEE_DESTINATION_ID:Ls,MODEL_DATA_PUBKEY:Ln},An={OPEN_BOOK_PROGRAM:new oe("EoTcMgcDRTJVZDMZWBoU6rhYHZfkNTVEAfz3uUJRcYGj"),SERUM_PROGRAM_ID_V3:new oe("Ray1111111111111111111111111111111111111111"),AMM_V4:new oe("DRaya7Kj3aMWQSy19kSjvmuwq9docCHofyP9kanQGaav"),AMM_STABLE:new oe("DRayDdXc1NZQ9C3hRWmoSf8zK4iapgMnjdNZWrfwsP8m"),CLMM_PROGRAM_ID:new oe("DRayAUgENGQBKVaX8owNhgzkEDyoHTGVEGHVJT1E9pfH"),CLMM_LOCK_PROGRAM_ID:new oe("DRay25Usp3YJAi7beckgpGUC7mGJ2cR1AVPxhYfwVCUX"),CLMM_LOCK_AUTH_ID:new oe("6Aoh8h2Lw2m5UGxYR8AdAL87jTWYeKoxM52mJRzfYwN"),CREATE_CPMM_POOL_PROGRAM:new oe("DRaycpLY18LhpbydsBWbVJtxpNv9oXPgjRSfpF2bWpYb"),CREATE_CPMM_POOL_AUTH:new oe("CXniRufdq5xL8t8jZAPxsPZDpuudwuJSPWnbcD5Y5Nxq"),CREATE_CPMM_POOL_FEE_ACC:new oe("3oE58BKVt8KuYkGxx8zBojugnymWmBiyafWgMrnb6eYy"),LOCK_CPMM_PROGRAM:new oe("DRay25Usp3YJAi7beckgpGUC7mGJ2cR1AVPxhYfwVCUX"),LOCK_CPMM_AUTH:new oe("7qWVV8UY2bRJfDLP4s37YzBPKUkVB46DStYJBpYbQzu3"),UTIL1216:oe.default,Router:new oe("DRaybByLpbUL57LJARs3j8BitTxVfzBg351EaMr5UTCd"),FARM_PROGRAM_ID_V3:new oe("DRayWyrLmEW5KEeqs8kdTMMaBabapqagaBC7KWpGtJeZ"),FARM_PROGRAM_ID_V4:new oe("Ray1111111111111111111111111111111111111111"),FARM_PROGRAM_ID_V5:new oe("DRayiCGSZgku1GTK6rXD6mVDdingXy6APAH1R6R5L2LC"),FARM_PROGRAM_ID_V6:new oe("DRayzbYakXs45ELHkzH6vC3fuhQqTAnv5A68gdFuvZyZ"),LAUNCHPAD_PROGRAM:new oe("DRay6fNdQ5J82H7xV6uq2aV3mNrUZ1J4PgSKsWgptcm6"),LAUNCHPAD_AUTH:new oe("5xqNaZXX5eUi4p5HU4oz9i5QnwRNT2y6oN7yyn4qENeq"),LAUNCHPAD_PLATFORM:new oe("2Jx4KTDrVSdWNazuGpcA8n3ZLTRGGBDxAWhuKe2Xcj2a"),LAUNCHPAD_CONFIG:new oe("7ZR4zD7PYfY2XxoG1Gxcy2EgEeGYrpxrwzPuwdUBssEt"),FEE_DESTINATION_ID:new oe("9y8ENuuZ3b19quffx9hQvRVygG5ky6snHfRvGpuSfeJy"),MODEL_DATA_PUBKEY:new oe("Ray1111111111111111111111111111111111111111")};import ve from"bn.js";var ln=1e4;function Te(c,e,t,n){if(e===void 0)return{amount:c,fee:void 0,expirationTime:void 0};let o=q(v({},e),{olderTransferFee:{epoch:BigInt(e.olderTransferFee.epoch),maximumFee:BigInt(e.olderTransferFee.maximumFee),transferFeeBasisPoints:e.olderTransferFee.transferFeeBasisPoints},newerTransferFee:{epoch:BigInt(e.newerTransferFee.epoch),maximumFee:BigInt(e.newerTransferFee.maximumFee),transferFeeBasisPoints:e.newerTransferFee.transferFeeBasisPoints}}),s=t.epoch<o.newerTransferFee.epoch?o.olderTransferFee:o.newerTransferFee,i=new ve(s.maximumFee.toString()),r=t.epoch<o.newerTransferFee.epoch?(Number(o.newerTransferFee.epoch)*t.slotsInEpoch-t.absoluteSlot)*400/1e3:void 0;if(n)if(s.transferFeeBasisPoints===ln){let u=new ve(s.maximumFee.toString());return{amount:c.add(u),fee:u,expirationTime:r}}else{let u=$t(c.mul(new ve(ln)),new ve(ln-s.transferFeeBasisPoints)),a=new ve(s.maximumFee.toString()),l=u.sub(c).gt(a)?c.add(a):u,m=$t(l.mul(new ve(s.transferFeeBasisPoints)),new ve(ln)),p=m.gt(i)?i:m;return{amount:l,fee:p,expirationTime:r}}else{let u=$t(c.mul(new ve(s.transferFeeBasisPoints)),new ve(ln)),a=u.gt(i)?i:u;return{amount:c,fee:a,expirationTime:r}}}function Jt(c,e){return c===void 0?e:e===void 0?c:Math.min(c,e)}function $t(c,e){let{div:t,mod:n}=c.divmod(e);return n.gt(new ve(0))?t.add(new ve(1)):t}function Qn(c,e){if(c.isZero())return new ve(0);let t=c.div(e);return t.isZero()?new ve(1):c.mod(e).gt(new ve(0))?t.add(new ve(1)):t}function Ns(c,e,t){if(e===void 0)return{amount:c,fee:void 0,expirationTime:void 0};let n=Math.floor(t/432e3),o=n<e.newerTransferFee.epoch?e.olderTransferFee:e.newerTransferFee,s=new ve(o.maximumFee.toString()),i=n<e.newerTransferFee.epoch?(Number(e.newerTransferFee.epoch)*432e3-t)*400/1e3:void 0,r=$t(c.mul(new ve(o.transferFeeBasisPoints)),new ve(ln)),u=r.gt(s)?s:r;return{amount:c,fee:u,expirationTime:i}}function Ms(c,e,t){if(e===void 0)return{amount:c,fee:void 0,expirationTime:void 0};let n=Math.floor(t/432e3),o=n<e.newerTransferFee.epoch?e.olderTransferFee:e.newerTransferFee,s=new ve(o.maximumFee.toString()),i=n<e.newerTransferFee.epoch?(Number(e.newerTransferFee.epoch)*432e3-t)*400/1e3:void 0;if(o.transferFeeBasisPoints===ln){let r=new ve(o.maximumFee.toString());return{amount:c.add(r),fee:r,expirationTime:i}}else{let r=$t(c.mul(new ve(ln)),new ve(ln-o.transferFeeBasisPoints)),u=new ve(o.maximumFee.toString()),a=r.sub(c).gt(u)?c.add(u):r,l=$t(a.mul(new ve(o.transferFeeBasisPoints)),new ve(ln)),m=l.gt(s)?s:l;return{amount:a,fee:m,expirationTime:i}}}import{PublicKey as vs,AddressLookupTableAccount as To}from"@solana/web3.js";async function dr({connection:c,address:e,cluster:t="mainnet"}){let n=await Ht(c,[...new Set(e.map(s=>s.toString()))].map(s=>new vs(s))),o={};for(let s=0;s<e.length;s++){let i=n[s],r=e[s];if(!i)continue;let u=new To({key:r,state:To.deserialize(i.data)});o[r.toString()]=u,t==="devnet"?wo[r.toString()]=u:ni[r.toString()]=u}return o}var ni={AcL1Vo8oy1ULiavEcjSUcwfBSForXMudcZvDZy5nzJkU:new To({key:new vs("AcL1Vo8oy1ULiavEcjSUcwfBSForXMudcZvDZy5nzJkU"),state:To.deserialize(Buffer.from("AQAAAP//////////I1rcEwAAAAAvAQYwun9CU6c5Ikm2pAj+D9IEnCOR45nK+SFTGSdpd6J6AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAbd9uHXZaGT2cvhRs7reawctIXtX1s3kTqM9YV+/wCpBt324e51j94YQl285GzN2rYa/E2DuQ0n/r35KNihi/wFSlNQ+F3IgtYUpVZyeIopbd8eq6vQpgZ4iEky9O72oAVKU1qZKSEGTSTocWDaOHx8NbXdvJK7geQfqEBBBUSNBqfVFxksXFEhjMlMPUrxf1ja7gibof1E49vZigAAAAAGp9UXGMd0yShWY5hpHV62i164o5tLbVxzVVshAAAAAIyXJY9OJInxuz0QKRSODYMLWhOZ2v8QhASOe9jb6fhZC3BlsePRfEU4nVJ/awTDzVi4bHMaoP21SbbRvAP4KUbIScv+6Yw2LHF/6K0ZjUPibbSWXCirYPGuuVl7zT789IUPLW4CpHr4JNCatp3ELXDLKMv6JJ+37le50lbBJ2LvBkX2T9y7AHdNGviJAqQNtlDUDCnauQRWybsLji6nPM8Qkw5asQRvCdB3MbX6IEBwytOrpM32l4jQygKG9TKgR0vZScQ2AsM/IHeQ7RajUkyhuZdc8SGiqQz/7H34torNR/Wir3sl0ruUrVxJWEZfUg+QLNAxxODdBi53/OP7Ioil1cqeBM9dtZC3FLov4yyxWRM/wcGStyJX/QfTnLBAHqkqWotPKVlShCVQqpP9W5W1rOao65IMk5QuQ2kMIOxzDMKAy2vjGSxQODgBz0QwGA+eP4ZjIjrIAQaXENv31QfLlOdXSRCkaybRniDHF4C8YcwhcvsqrOVuTP4B2Na+9wLdtrB31uz2rtlFI5kahdsnp/d1SrASDInYCtTYtdoke4kX+hoKWcEWM4Tle8pTUkUVv4BxS6fje/EzKBE4Qu/YsA/yfEEFGcr8Z57VKDw8uQzpiru7g4lvjnfapW62W030syevD8k07SGoxUHiuT/ai7gAHWWhDsVmg/C63ajgpkH7Sn3GdutArDTfyqOkdqv4/IPC/EFFy7mGkfDd2C57N5a/4jC+BbmJy7wQaSEZr0CQU88lPtUxIVvzGjC95b8Ooss2TqmkrayGKofkPMGQn7Ux+9lfwBSNfxwH8NgbpqC/7LNlV4I7nCvsXf3p+ohQk9NrAJb2KAFpUqEIJ9ZBV7BYDzHF/ORKYlgtvPnXjudZQ6CEo5OzUDaNIomTCCsvhD16TxJjsbgne1kGnQPCFSoaxUbq2V1bPMFQ3VYP6wDZ9bKStCFKx9A3tNbwZFC5ZGAN83MFK7XoTy+OmmcFEr6rLOjfSuTfPvHJkSVxW6Qllwkl67XcBi5v00u2gQsbu+38sp+rd5pA/LvyWj4P94ZGZwc1tE2P88xekCLcAwZGb+UhFzL/7K26csOb57yM5bvF9xJrLEObOkAAAAAn+HWRkdcPKyFFMnVwEoD7vnD0jCKFIU1sImubYCxNTSVzsKpaQX+fzNxrLAI3L14JQnJx/D6Uk2LADIHGqnGELzjEbkBDAlaM77NkXMPfqXNLSveCkWI7UEgNs31WEWB6XHSYI/v5DklHOb4QTtDOR804PVbi3fjloZeLR2F8d4FuZmMMO7ck3Fnkn2zEMG5gOmqsygb6PjTitArVl52NhcSznTxVnguaIJxiZkAnurDmn3MWR0PC2GLghp2KJqHCc6QQ85odeIjFHKOlRlJyeSXVJmL8vb1UgOzsbJPVP8p6zM4M3C1Sd7uWIHP33G42AP2Zg8ucn/n6meQjjD266JgCWdxZD6PXs9CsnIeL7SSG0/6lGb9xfP0ZcWkCXB/3hjxHYVXjra/GPOeXGk0fLLKjCbk+mgs2w6d2oCwimBipTzuoZ30GiI8ij8VRzD5CzMWtu2m21eDBIfjGAEo4pQeNNonKcqzV/cleX8ySZLOHsz8PtBCrLqF+VkLm9hOzIT+6i/nIf6keR4GWKMOD4AvqfpjHoD4DuhBpz8P28+DxkGrDXXr/nr20x291VPvcTU/b+b+o2kC9G0kcXeTlLjU6a2TQXWlZ4gBUdBl1jgT7mObSTpLblNiXZsLkbmVXZwvFKXua5cUKlWed/w30skmEUraTuQqtqr5fHZPW9n57EmeTif6LjHL2YJFZkQU+TrJmFzqzmF4/b8OwrPQAprl8mX3q4LUIdAS/a+11B6DWD1Xk2++Sn94dLC4xjkO4Wtlw8c4XuzciVbepHOmnoWzVu/0y3KCrLCSfQxQ3br8DJCoVzhgtPsS2nZZjsBGIZgnU0QpMv+2MnRsnKwdp1VsrCX84j/qvaZn4WhKunippgTbN2EUs0tPTP55Qfgj+nKmjtWW5IYs72FrEwJKYoNfsmqaF4o5pf4v9zgPwVwY/5I4XJKUL2L25m9kAQcW/K+H1RTFEUoj8Z4ajpOmAB/dG0COmCphVMW2CCMvnxhcGiSgPnpDuWu6qiJ7NG7ye5kvHgefgqPLeicspNJ5EpL3XiRNLM2tmJLI1awAwOyd6iHv0dCkMYRKaa6rcaZeYwmKCkckm0kM2JNmnmmAaBQQ7mwmIM0IMxX4f5W6j9PqZWcJxF7r17T/lQBAmcjoupRiJifbnXCNUv9GhpRF19WcBdeKbivRJVlGop6I2RS6lGImJ9udcI1S/0aGlEXX1ZwF14puK9ElWUainojZFYVHLHD6dIP2ESjqBzg3ol1/wB7+/ylGwd9LS7wSZ2A630CJSVKwH47K9P4bB8PEQP8BwjMFa7xQHOqZFP1XqaQ==","base64"))})},wo={},pr=async c=>{let e="EFhMuDw1PKEuckuFRW9PavNfTH4LKP5uKHgyXDmWpFCq";if(wo[e])return wo;let t=new vs(e),n=await c.getAccountInfo(t);return n&&(wo[e]=new To({key:t,state:To.deserialize(n.data)})),wo};import{PublicKey as Yn,sendAndConfirmTransaction as Fs,SystemProgram as _m,Transaction as oi,TransactionMessage as Pn,VersionedTransaction as kn}from"@solana/web3.js";import Em from"axios";var ii=2e3,ri=class{constructor(e){this.instructions=[];this.endInstructions=[];this.lookupTableAddress=[];this.signers=[];this.instructionTypes=[];this.endInstructionTypes=[];this.connection=e.connection,this.feePayer=e.feePayer,this.signAllTransactions=e.signAllTransactions,this.owner=e.owner,this.cluster=e.cluster,this.blockhashCommitment=e.blockhashCommitment,this.loopMultiTxStatus=!!e.loopMultiTxStatus}get AllTxData(){return{instructions:this.instructions,endInstructions:this.endInstructions,signers:this.signers,instructionTypes:this.instructionTypes,endInstructionTypes:this.endInstructionTypes,lookupTableAddress:this.lookupTableAddress}}get allInstructions(){return[...this.instructions,...this.endInstructions]}async getComputeBudgetConfig(){var n;let e=(await Em.get(`https://solanacompass.com/api/fees?cacheFreshTime=${3e5}`)).data,{avg:t}=(n=e==null?void 0:e[15])!=null?n:{};if(!!t)return{units:6e5,microLamports:Math.min(Math.ceil(t*1e6/6e5),25e3)}}addCustomComputeBudget(e){if(e){let{instructions:t,instructionTypes:n}=Qo(e);return this.instructions.unshift(...t),this.instructionTypes.unshift(...n),!0}return!1}addTipInstruction(e){var t;return e?(this.endInstructions.push(_m.transfer({fromPubkey:(t=e.feePayer)!=null?t:this.feePayer,toPubkey:new Yn(e.address),lamports:BigInt(e.amount.toString())})),this.endInstructionTypes.push(U.TransferTip),!0):!1}async calComputeBudget({config:e,defaultIns:t}){try{let n=e||await this.getComputeBudgetConfig();if(this.addCustomComputeBudget(n))return;t&&this.instructions.unshift(...t)}catch{t&&this.instructions.unshift(...t)}}addInstruction({instructions:e=[],endInstructions:t=[],signers:n=[],instructionTypes:o=[],endInstructionTypes:s=[],lookupTableAddress:i=[]}){return this.instructions.push(...e),this.endInstructions.push(...t),this.signers.push(...n),this.instructionTypes.push(...o),this.endInstructionTypes.push(...s),this.lookupTableAddress.push(...i.filter(r=>r!==Yn.default.toString())),this}async versionBuild({txVersion:e,extInfo:t}){return e===0?await this.buildV0(v({},t||{})):this.build(t)}build(e){var n;let t=new oi;return this.allInstructions.length&&t.add(...this.allInstructions),t.feePayer=this.feePayer,((n=this.owner)==null?void 0:n.signer)&&!this.signers.some(o=>o.publicKey.equals(this.owner.publicKey))&&this.signers.push(this.owner.signer),{builder:this,transaction:t,signers:this.signers,instructionTypes:[...this.instructionTypes,...this.endInstructionTypes],execute:async o=>{var l;let{recentBlockHash:s,skipPreflight:i=!0,sendAndConfirm:r,notSendToRpc:u}=o||{},a=s!=null?s:await zn(this.connection,this.blockhashCommitment);if(t.recentBlockhash=a,this.signers.length&&t.sign(...this.signers),Cn([t]),(l=this.owner)!=null&&l.isKeyPair)return{txId:r?await Fs(this.connection,t,this.signers.find(p=>p.publicKey.equals(this.owner.publicKey))?this.signers:[...this.signers,this.owner.signer],{skipPreflight:i}):await this.connection.sendRawTransaction(t.serialize(),{skipPreflight:i}),signedTx:t};if(this.signAllTransactions){let m=await this.signAllTransactions([t]);if(this.signers.length)for(let p of m)try{p.sign(...this.signers)}catch{}return{txId:u?"":await this.connection.sendRawTransaction(m[0].serialize(),{skipPreflight:i}),signedTx:m[0]}}throw new Error("please provide owner in keypair format or signAllTransactions function")},extInfo:e||{}}}buildMultiTx(e){var a;let{extraPreBuildData:t=[],extInfo:n}=e,{transaction:o}=this.build(n),s=t.filter(l=>l.transaction.instructions.length>0),i=[o,...s.map(l=>l.transaction)],r=[this.signers,...s.map(l=>l.signers)],u=[...this.instructionTypes,...s.map(l=>l.instructionTypes).flat()];return(a=this.owner)!=null&&a.signer&&r.forEach(l=>{l.some(m=>m.publicKey.equals(this.owner.publicKey))||this.signers.push(this.owner.signer)}),{builder:this,transactions:i,signers:r,instructionTypes:u,execute:async l=>{var g;let{sequentially:m,onTxUpdate:p,skipTxCount:d=0,recentBlockHash:f,skipPreflight:y=!0}=l||{},b=f!=null?f:await zn(this.connection,this.blockhashCommitment);if((g=this.owner)!=null&&g.isKeyPair){if(m){let A=[],h=0;for(let I of i){if(++h,h<=d)continue;let T=await Fs(this.connection,I,this.signers.find(w=>w.publicKey.equals(this.owner.publicKey))?this.signers:[...this.signers,this.owner.signer],{skipPreflight:y});A.push(T)}return{txIds:A,signedTxs:i}}return{txIds:await await Promise.all(i.map(async A=>(A.recentBlockhash=b,await this.connection.sendRawTransaction(A.serialize(),{skipPreflight:y})))),signedTxs:i}}if(this.signAllTransactions){let A=i.map((I,T)=>(I.recentBlockhash=b,r[T].length&&I.sign(...r[T]),I));Cn(A);let h=await this.signAllTransactions(A);if(m){let I=0,T=[],w=async()=>{if(!h[I])return;let S=await this.connection.sendRawTransaction(h[I].serialize(),{skipPreflight:y});T.push({txId:S,status:"sent",signedTx:h[I]}),p==null||p([...T]),I++;let x=!1,K=null,B=null,C=O=>{K!==null&&clearInterval(K),B!==null&&this.connection.removeSignatureListener(B);let M=T.findIndex(L=>L.txId===S);if(M>-1){if(T[M].status==="error"||T[M].status==="success")return;T[M].status=O.err?"error":"success"}p==null||p([...T]),O.err||w()};this.loopMultiTxStatus&&(K=setInterval(async()=>{var O;if(x){clearInterval(K);return}try{let M=await this.connection.getTransaction(S,{commitment:"confirmed",maxSupportedTransactionVersion:0});M&&(x=!0,clearInterval(K),C({err:((O=M.meta)==null?void 0:O.err)||null}),console.log("tx status from getTransaction:",S))}catch(M){x=!0,clearInterval(K),console.error("getTransaction timeout:",M,S)}},ii)),B=this.connection.onSignature(S,O=>{if(x){this.connection.removeSignatureListener(B);return}x=!0,C(O)},"confirmed"),this.connection.getSignatureStatus(S)};return await w(),{txIds:T.map(S=>S.txId),signedTxs:h}}else{let I=[];for(let T=0;T<h.length;T+=1){let w=await this.connection.sendRawTransaction(h[T].serialize(),{skipPreflight:y});I.push(w)}return{txIds:I,signedTxs:h}}}throw new Error("please provide owner in keypair format or signAllTransactions function")},extInfo:n||{}}}async versionMultiBuild({extraPreBuildData:e,txVersion:t,extInfo:n}){return t===0?await this.buildV0MultiTx({extraPreBuildData:e,buildProps:n||{}}):this.buildMultiTx({extraPreBuildData:e,extInfo:n})}async buildV0(e){var y;let f=e||{},{lookupTableCache:t={},lookupTableAddress:n=[],forerunCreate:o,recentBlockhash:s}=f,i=Ee(f,["lookupTableCache","lookupTableAddress","forerunCreate","recentBlockhash"]),r=v(v({},this.cluster==="devnet"?await pr(this.connection):ni),t),u=Array.from(new Set([...n,...this.lookupTableAddress])),a=[];for(let b of u)r[b]===void 0&&a.push(new Yn(b));let l=await dr({connection:this.connection,address:a});for(let[b,g]of Object.entries(l))r[b]=g;let m=o?Yn.default.toBase58():s!=null?s:await zn(this.connection,this.blockhashCommitment),p=new Pn({payerKey:this.feePayer,recentBlockhash:m,instructions:[...this.allInstructions]}).compileToV0Message(Object.values(r));((y=this.owner)==null?void 0:y.signer)&&!this.signers.some(b=>b.publicKey.equals(this.owner.publicKey))&&this.signers.push(this.owner.signer);let d=new kn(p);return d.sign(this.signers),{builder:this,transaction:d,signers:this.signers,instructionTypes:[...this.instructionTypes,...this.endInstructionTypes],execute:async b=>{var I;let{skipPreflight:g=!0,sendAndConfirm:A,notSendToRpc:h}=b||{};if(Cn([d]),(I=this.owner)!=null&&I.isKeyPair){let T=await this.connection.sendTransaction(d,{skipPreflight:g});return A&&await Yo(this.connection,T),{txId:T,signedTx:d}}if(this.signAllTransactions){let T=await this.signAllTransactions([d]);if(this.signers.length)for(let w of T)try{w.sign(this.signers)}catch{}return{txId:h?"":await this.connection.sendTransaction(T[0],{skipPreflight:g}),signedTx:T[0]}}throw new Error("please provide owner in keypair format or signAllTransactions function")},extInfo:i||{}}}async buildV0MultiTx(e){var a;let{extraPreBuildData:t=[],buildProps:n}=e,{transaction:o}=await this.buildV0(n),s=t.filter(l=>l.builder.instructions.length>0),i=[o,...s.map(l=>l.transaction)],r=[this.signers,...s.map(l=>l.signers)],u=[...this.instructionTypes,...s.map(l=>l.instructionTypes).flat()];return(a=this.owner)!=null&&a.signer&&r.forEach(l=>{l.some(m=>m.publicKey.equals(this.owner.publicKey))||this.signers.push(this.owner.signer)}),i.forEach(async(l,m)=>{l.sign(r[m])}),{builder:this,transactions:i,signers:r,instructionTypes:u,buildProps:n,execute:async l=>{var y;let{sequentially:m,onTxUpdate:p,recentBlockHash:d,skipPreflight:f=!0}=l||{};if(d&&i.forEach(b=>b.message.recentBlockhash=d),Cn(i),(y=this.owner)!=null&&y.isKeyPair){if(m){let b=[];for(let g of i){let A=await this.connection.sendTransaction(g,{skipPreflight:f});await Yo(this.connection,A),b.push(A)}return{txIds:b,signedTxs:i}}return{txIds:await Promise.all(i.map(async b=>await this.connection.sendTransaction(b,{skipPreflight:f}))),signedTxs:i}}if(this.signAllTransactions){let b=await this.signAllTransactions(i);if(m){let g=0,A=[],h=async()=>{if(!b[g])return;let I=await this.connection.sendTransaction(b[g],{skipPreflight:f});A.push({txId:I,status:"sent",signedTx:b[g]}),p==null||p([...A]),g++;let T=!1,w=null,S=null,x=K=>{w!==null&&clearInterval(w),S!==null&&this.connection.removeSignatureListener(S);let B=A.findIndex(C=>C.txId===I);if(B>-1){if(A[B].status==="error"||A[B].status==="success")return;A[B].status=K.err?"error":"success"}p==null||p([...A]),K.err||h()};this.loopMultiTxStatus&&(w=setInterval(async()=>{var K;if(T){clearInterval(w);return}try{let B=await this.connection.getTransaction(I,{commitment:"confirmed",maxSupportedTransactionVersion:0});B&&(T=!0,clearInterval(w),x({err:((K=B.meta)==null?void 0:K.err)||null}),console.log("tx status from getTransaction:",I))}catch(B){T=!0,clearInterval(w),console.error("getTransaction timeout:",B,I)}},ii)),S=this.connection.onSignature(I,K=>{if(T){this.connection.removeSignatureListener(S);return}T=!0,x(K)},"confirmed"),this.connection.getSignatureStatus(I)};return h(),{txIds:[],signedTxs:b}}else{let g=[];for(let A=0;A<b.length;A+=1){let h=await this.connection.sendTransaction(b[A],{skipPreflight:f});g.push(h)}return{txIds:g,signedTxs:b}}}throw new Error("please provide owner in keypair format or signAllTransactions function")},extInfo:n||{}}}async sizeCheckBuild(e){var p;let m=e||{},{splitIns:t=[],computeBudgetConfig:n}=m,o=Ee(m,["splitIns","computeBudgetConfig"]),s=n?Qo(n):{instructions:[],instructionTypes:[]},i=this.signers.reduce((d,f)=>q(v({},d),{[f.publicKey.toBase58()]:f}),{}),r=[],u=[],a=[],l=0;if(this.allInstructions.forEach(d=>{let f=[...a,d],y=n?[...s.instructions,...f]:f,g=[...new Set(f.map(A=>A.keys.filter(h=>h.isSigner).map(h=>h.pubkey.toString())).flat()).values()].map(A=>new Yn(A));if(d!==t[l]&&a.length<12&&(jo({instructions:y,payer:this.feePayer,signers:g})||jo({instructions:f,payer:this.feePayer,signers:g})))a.push(d);else{if(a.length===0)throw Error("item ins too big");l+=d===t[l]?1:0,jo({instructions:n?[...s.instructions,...a]:[...a],payer:this.feePayer,signers:g})?r.push(new oi().add(...s.instructions,...a)):r.push(new oi().add(...a)),u.push(Array.from(new Set(a.map(A=>A.keys.filter(h=>h.isSigner).map(h=>h.pubkey.toString())).flat())).map(A=>i[A]).filter(A=>A!==void 0)),a=[d]}}),a.length>0){let f=[...new Set(a.map(y=>y.keys.filter(b=>b.isSigner).map(b=>b.pubkey.toString())).flat()).values()].map(y=>i[y]).filter(y=>y!==void 0);jo({instructions:n?[...s.instructions,...a]:[...a],payer:this.feePayer,signers:f.map(y=>y.publicKey)})?r.push(new oi().add(...s.instructions,...a)):r.push(new oi().add(...a)),u.push(f)}return r.forEach(d=>d.feePayer=this.feePayer),(p=this.owner)!=null&&p.signer&&u.forEach(d=>{d.some(f=>f.publicKey.equals(this.owner.publicKey))||d.push(this.owner.signer)}),{builder:this,transactions:r,signers:u,instructionTypes:this.instructionTypes,execute:async d=>{var I;let{sequentially:f,onTxUpdate:y,skipTxCount:b=0,recentBlockHash:g,skipPreflight:A=!0}=d||{},h=g!=null?g:await zn(this.connection,this.blockhashCommitment);if(r.forEach(async(T,w)=>{T.recentBlockhash=h,u[w].length&&T.sign(...u[w])}),Cn(r),(I=this.owner)!=null&&I.isKeyPair){if(f){let T=0,w=[];for(let S of r){if(++T,T<=b){w.push("tx skipped");continue}let x=await Fs(this.connection,S,this.signers.find(K=>K.publicKey.equals(this.owner.publicKey))?this.signers:[...this.signers,this.owner.signer],{skipPreflight:A});w.push(x)}return{txIds:w,signedTxs:r}}return{txIds:await Promise.all(r.map(async T=>await this.connection.sendRawTransaction(T.serialize(),{skipPreflight:A}))),signedTxs:r}}if(this.signAllTransactions){let T=await this.signAllTransactions(r.slice(b,r.length)),w=[...r.slice(0,b),...T];if(f){let S=0,x=[],K=async()=>{if(!w[S])return;S<b&&(x.push({txId:"",status:"success",signedTx:w[S]}),y==null||y([...x]),S++,K());let B=await this.connection.sendRawTransaction(w[S].serialize(),{skipPreflight:A});x.push({txId:B,status:"sent",signedTx:w[S]}),y==null||y([...x]),S++;let C=!1,O=null,M=null,L=R=>{O!==null&&clearInterval(O),M!==null&&this.connection.removeSignatureListener(M);let _=x.findIndex(X=>X.txId===B);if(_>-1){if(x[_].status==="error"||x[_].status==="success")return;x[_].status=R.err?"error":"success"}y==null||y([...x]),R.err||K()};this.loopMultiTxStatus&&(O=setInterval(async()=>{var R;if(C){clearInterval(O);return}try{let _=await this.connection.getTransaction(B,{commitment:"confirmed",maxSupportedTransactionVersion:0});_&&(C=!0,clearInterval(O),L({err:((R=_.meta)==null?void 0:R.err)||null}),console.log("tx status from getTransaction:",B))}catch(_){C=!0,clearInterval(O),console.error("getTransaction timeout:",_,B)}},ii)),M=this.connection.onSignature(B,R=>{if(C){this.connection.removeSignatureListener(M);return}C=!0,L(R)},"confirmed"),this.connection.getSignatureStatus(B)};return await K(),{txIds:x.map(B=>B.txId),signedTxs:w}}else{let S=[];for(let x=0;x<w.length;x+=1){let K=await this.connection.sendRawTransaction(w[x].serialize(),{skipPreflight:A});S.push(K)}return{txIds:S,signedTxs:w}}}throw new Error("please provide owner in keypair format or signAllTransactions function")},extInfo:o||{}}}async sizeCheckBuildV0(e){var h;let A=e||{},{computeBudgetConfig:t,splitIns:n=[],lookupTableCache:o={},lookupTableAddress:s=[]}=A,i=Ee(A,["computeBudgetConfig","splitIns","lookupTableCache","lookupTableAddress"]),r=v(v({},this.cluster==="devnet"?await pr(this.connection):ni),o),u=Array.from(new Set([...this.lookupTableAddress,...s])),a=[];for(let I of u)r[I]===void 0&&a.push(new Yn(I));let l=await dr({connection:this.connection,address:a});for(let[I,T]of Object.entries(l))r[I]=T;let m=t?Qo(t):{instructions:[],instructionTypes:[]},p=await zn(this.connection,this.blockhashCommitment),d=this.signers.reduce((I,T)=>q(v({},I),{[T.publicKey.toBase58()]:T}),{}),f=[],y=[],b=[],g=0;if(this.allInstructions.forEach(I=>{let T=[...b,I],w=t?[...m.instructions,...T]:T;if(I!==n[g]&&b.length<12&&(gn({instructions:w,payer:this.feePayer,lookupTableAddressAccount:r})||gn({instructions:T,payer:this.feePayer,lookupTableAddressAccount:r})))b.push(I);else{if(b.length===0)throw Error("item ins too big");g+=I===n[g]?1:0;let S={};for(let x of[...new Set(u)])r[x]!==void 0&&(S[x]=r[x]);if(t&&gn({instructions:[...m.instructions,...b],payer:this.feePayer,lookupTableAddressAccount:r,recentBlockhash:p})){let x=new Pn({payerKey:this.feePayer,recentBlockhash:p,instructions:[...m.instructions,...b]}).compileToV0Message(Object.values(r));f.push(new kn(x))}else{let x=new Pn({payerKey:this.feePayer,recentBlockhash:p,instructions:[...b]}).compileToV0Message(Object.values(r));f.push(new kn(x))}y.push(Array.from(new Set(b.map(x=>x.keys.filter(K=>K.isSigner).map(K=>K.pubkey.toString())).flat())).map(x=>d[x]).filter(x=>x!==void 0)),b=[I]}}),b.length>0){let T=[...new Set(b.map(w=>w.keys.filter(S=>S.isSigner).map(S=>S.pubkey.toString())).flat()).values()].map(w=>d[w]).filter(w=>w!==void 0);if(t&&gn({instructions:[...m.instructions,...b],payer:this.feePayer,lookupTableAddressAccount:r,recentBlockhash:p})){let w=new Pn({payerKey:this.feePayer,recentBlockhash:p,instructions:[...m.instructions,...b]}).compileToV0Message(Object.values(r));f.push(new kn(w))}else{let w=new Pn({payerKey:this.feePayer,recentBlockhash:p,instructions:[...b]}).compileToV0Message(Object.values(r));f.push(new kn(w))}y.push(T)}return(h=this.owner)!=null&&h.signer&&y.forEach(I=>{I.some(T=>T.publicKey.equals(this.owner.publicKey))||I.push(this.owner.signer)}),f.forEach((I,T)=>{I.sign(y[T])}),{builder:this,transactions:f,buildProps:e,signers:y,blockHash:p,instructionTypes:this.instructionTypes,execute:async I=>{var B;let{sequentially:T,onTxUpdate:w,skipTxCount:S=0,recentBlockHash:x,skipPreflight:K=!0}=I||{};if(f.map(async(C,O)=>{y[O].length&&C.sign(y[O]),x&&(C.message.recentBlockhash=x)}),Cn(f),(B=this.owner)!=null&&B.isKeyPair){if(T){let C=0,O=[];for(let M of f){if(++C,C<=S){console.log("skip tx: ",C),O.push("tx skipped");continue}let L=await this.connection.sendTransaction(M,{skipPreflight:K});await Yo(this.connection,L),O.push(L)}return{txIds:O,signedTxs:f}}return{txIds:await Promise.all(f.map(async C=>await this.connection.sendTransaction(C,{skipPreflight:K}))),signedTxs:f}}if(this.signAllTransactions){let C=await this.signAllTransactions(f.slice(S,f.length)),O=[...f.slice(0,S),...C];if(T){let M=0,L=[],R=async()=>{if(!O[M])return;if(M<S){L.push({txId:"",status:"success",signedTx:O[M]}),w==null||w([...L]),M++,R();return}let _=await this.connection.sendTransaction(O[M],{skipPreflight:K});L.push({txId:_,status:"sent",signedTx:O[M]}),w==null||w([...L]),M++;let X=!1,j=null,ae=null,ue=ie=>{j!==null&&clearInterval(j),ae!==null&&this.connection.removeSignatureListener(ae);let me=L.findIndex(fe=>fe.txId===_);if(me>-1){if(L[me].status==="error"||L[me].status==="success")return;L[me].status=ie.err?"error":"success"}w==null||w([...L]),ie.err||R()};this.loopMultiTxStatus&&(j=setInterval(async()=>{var ie;if(X){clearInterval(j);return}try{let me=await this.connection.getTransaction(_,{commitment:"confirmed",maxSupportedTransactionVersion:0});me&&(X=!0,clearInterval(j),ue({err:((ie=me.meta)==null?void 0:ie.err)||null}),console.log("tx status from getTransaction:",_))}catch(me){X=!0,clearInterval(j),console.error("getTransaction timeout:",me,_)}},ii)),ae=this.connection.onSignature(_,ie=>{if(X){this.connection.removeSignatureListener(ae);return}X=!0,ue(ie)},"confirmed"),this.connection.getSignatureStatus(_)};return R(),{txIds:[],signedTxs:O}}else{let M=[];for(let L=0;L<O.length;L+=1){let R=await this.connection.sendTransaction(O[L],{skipPreflight:K});M.push(R)}return{txIds:M,signedTxs:O}}}throw new Error("please provide owner in keypair format or signAllTransactions function")},extInfo:i||{}}}async buildSniperTransaction(e){var h;let A=e||{},{computeBudgetConfig:t,splitIns:n=[],lookupTableCache:o={},lookupTableAddress:s=[]}=A,i=Ee(A,["computeBudgetConfig","splitIns","lookupTableCache","lookupTableAddress"]),r=v(v({},this.cluster==="devnet"?await pr(this.connection):ni),o),u=Array.from(new Set([...this.lookupTableAddress,...s])),a=[];for(let I of u)r[I]===void 0&&a.push(new Yn(I));let l=await dr({connection:this.connection,address:a});for(let[I,T]of Object.entries(l))r[I]=T;let m=t?Qo(t):{instructions:[],instructionTypes:[]},p=await zn(this.connection,this.blockhashCommitment),d=this.signers.reduce((I,T)=>q(v({},I),{[T.publicKey.toBase58()]:T}),{}),f=[],y=[],b=[],g=0;if(this.allInstructions.forEach(I=>{let T=[...b,I],w=t?[...m.instructions,...T]:T;if(I!==n[g]&&b.length<12&&(gn({instructions:w,payer:this.feePayer,lookupTableAddressAccount:r})||gn({instructions:T,payer:this.feePayer,lookupTableAddressAccount:r})))b.push(I);else{if(b.length===0)throw Error("item ins too big");g+=I===n[g]?1:0;let S={};for(let x of[...new Set(u)])r[x]!==void 0&&(S[x]=r[x]);if(t&&gn({instructions:[...m.instructions,...b],payer:this.feePayer,lookupTableAddressAccount:r,recentBlockhash:p})){let x=new Pn({payerKey:this.feePayer,recentBlockhash:p,instructions:[...m.instructions,...b]}).compileToV0Message(Object.values(r));f.push(new kn(x))}else{let x=new Pn({payerKey:this.feePayer,recentBlockhash:p,instructions:[...b]}).compileToV0Message(Object.values(r));f.push(new kn(x))}y.push(Array.from(new Set(b.map(x=>x.keys.filter(K=>K.isSigner).map(K=>K.pubkey.toString())).flat())).map(x=>d[x]).filter(x=>x!==void 0)),b=[I]}}),b.length>0){let T=[...new Set(b.map(w=>w.keys.filter(S=>S.isSigner).map(S=>S.pubkey.toString())).flat()).values()].map(w=>d[w]).filter(w=>w!==void 0);if(t&&gn({instructions:[...m.instructions,...b],payer:this.feePayer,lookupTableAddressAccount:r,recentBlockhash:p})){let w=new Pn({payerKey:this.feePayer,recentBlockhash:p,instructions:[...m.instructions,...b]}).compileToV0Message(Object.values(r));f.push(new kn(w))}else{let w=new Pn({payerKey:this.feePayer,recentBlockhash:p,instructions:[...b]}).compileToV0Message(Object.values(r));f.push(new kn(w))}y.push(T)}return(h=this.owner)!=null&&h.signer&&y.forEach(I=>{I.some(T=>T.publicKey.equals(this.owner.publicKey))||I.push(this.owner.signer)}),f.forEach((I,T)=>{I.sign(y[T])}),{builder:this,transactions:f,buildProps:e,signers:y,instructionTypes:this.instructionTypes,execute:async I=>{var B;let{sequentially:T,onTxUpdate:w,skipTxCount:S=0,recentBlockHash:x,skipPreflight:K=!0}=I||{};if(f.map(async(C,O)=>{y[O].length&&C.sign(y[O]),x&&(C.message.recentBlockhash=x)}),Cn(f),(B=this.owner)!=null&&B.isKeyPair){if(T){let C=0,O=[];for(let M of f){if(++C,C<=S){console.log("skip tx: ",C),O.push("tx skipped");continue}let L=await this.connection.sendTransaction(M,{skipPreflight:K});await Yo(this.connection,L),O.push(L)}return{txIds:O,signedTxs:f}}return{txIds:await Promise.all(f.map(async C=>await this.connection.sendTransaction(C,{skipPreflight:K}))),signedTxs:f}}if(this.signAllTransactions){let C=await this.signAllTransactions(f.slice(S,f.length)),O=[...f.slice(0,S),...C];if(T){let M=0,L=[],R=async()=>{if(!O[M])return;if(M<S){L.push({txId:"",status:"success",signedTx:O[M]}),w==null||w([...L]),M++,R();return}let _=await this.connection.sendTransaction(O[M],{skipPreflight:K});L.push({txId:_,status:"sent",signedTx:O[M]}),w==null||w([...L]),M++;let X=!1,j=null,ae=null,ue=ie=>{j!==null&&clearInterval(j),ae!==null&&this.connection.removeSignatureListener(ae);let me=L.findIndex(fe=>fe.txId===_);if(me>-1){if(L[me].status==="error"||L[me].status==="success")return;L[me].status=ie.err?"error":"success"}w==null||w([...L]),ie.err||R()};this.loopMultiTxStatus&&(j=setInterval(async()=>{var ie;if(X){clearInterval(j);return}try{let me=await this.connection.getTransaction(_,{commitment:"confirmed",maxSupportedTransactionVersion:0});me&&(X=!0,clearInterval(j),ue({err:((ie=me.meta)==null?void 0:ie.err)||null}),console.log("tx status from getTransaction:",_))}catch(me){X=!0,clearInterval(j),console.error("getTransaction timeout:",me,_)}},ii)),ae=this.connection.onSignature(_,ie=>{if(X){this.connection.removeSignatureListener(ae);return}X=!0,ue(ie)},"confirmed"),this.connection.getSignatureStatus(_)};return R(),{txIds:[],signedTxs:O}}else{let M=[];for(let L=0;L<O.length;L+=1){let R=await this.connection.sendTransaction(O[L],{skipPreflight:K});M.push(R)}return{txIds:M,signedTxs:O}}}throw new Error("please provide owner in keypair format or signAllTransactions function")},extInfo:i||{}}}};import Dm from"bn.js";var en=new Dm(1e6);var ut={BASE_HOST:"https://api-v3.raydium.io",OWNER_BASE_HOST:"https://owner-v1.raydium.io",SERVICE_BASE_HOST:"https://service.raydium.io",MONITOR_BASE_HOST:"https://monitor.raydium.io",SERVICE_1_BASE_HOST:"https://service-v1.raydium.io",SEND_TRANSACTION:"/send-transaction",FARM_ARP:"/main/farm/info",FARM_ARP_LINE:"/main/farm-apr-tv",CLMM_CONFIG:"/main/clmm-config",CPMM_CONFIG:"/main/cpmm-config",VERSION:"/main/version",CHECK_AVAILABILITY:"/v3/main/AvailabilityCheckAPI",RPCS:"/main/rpcs",INFO:"/main/info",STAKE_POOLS:"/main/stake-pools",CHAIN_TIME:"/main/chain-time",TOKEN_LIST:"/mint/list",MINT_INFO_ID:"/mint/ids",JUP_TOKEN_LIST:"https://lite-api.jup.ag/tokens/v1/tagged/verified",POOL_LIST:"/pools/info/list",POOL_SEARCH_BY_ID:"/pools/info/ids",POOL_SEARCH_MINT:"/pools/info/mint",POOL_SEARCH_LP:"/pools/info/lps",POOL_KEY_BY_ID:"/pools/key/ids",POOL_LIQUIDITY_LINE:"/pools/line/liquidity",POOL_POSITION_LINE:"/pools/line/position",FARM_INFO:"/farms/info/ids",FARM_LP_INFO:"/farms/info/lp",FARM_KEYS:"/farms/key/ids",OWNER_CREATED_FARM:"/create-pool/{owner}",OWNER_IDO:"/main/ido/{owner}",OWNER_STAKE_FARMS:"/position/stake/{owner}",OWNER_LOCK_POSITION:"/position/clmm-lock/{owner}",IDO_KEYS:"/ido/key/ids",SWAP_HOST:"https://transaction-v1.raydium.io",SWAP_COMPUTE:"/compute/",SWAP_TX:"/transaction/",MINT_PRICE:"/mint/price",MIGRATE_CONFIG:"/main/migrate-lp",PRIORITY_FEE:"/main/auto-fee",CPMM_LOCK:"https://dynamic-ipfs.raydium.io/lock/cpmm/position"},Ig=v({},ut);var Wu="ray_tab_hash",Vs="ray_req_hash",Wm=()=>{if(typeof window===void 0)return"";let c=sessionStorage.getItem(Wu);return c||(c=`ray-${Date.now()}`,sessionStorage.setItem(Wu,c)),c},fr=async n=>{var o=n,{logCount:c=1e3,removeLastLog:e}=o,t=Ee(o,["logCount","removeLastLog"]);if(typeof window===void 0)return new Promise(i=>i());let s=JSON.parse(localStorage.getItem(Vs)||"[]").slice(0,c-1);e&&s.pop(),new Blob([JSON.stringify(t.data)]).size>1024&&(t.data=JSON.stringify(t.data).substring(0,200)+"..."),s.unshift(q(v({},t),{time:Date.now(),session:Wm()}));try{localStorage.setItem(Vs,JSON.stringify(s))}catch{if(e){let i=!1,r=JSON.stringify(t.data).substring(0,100);for(s[0].data=r+(r.length>100?"...":"");!i;){s.pop();let u=JSON.stringify(t.data).substring(0,100);s[0].data=u+(u.length>100?"...":"");try{localStorage.setItem(Vs,JSON.stringify(s)),i=!0}catch{i=!1}}return new Promise(u=>u())}return fr(q(v({},t),{logCount:c,removeLastLog:!0}))}};import{TOKEN_2022_PROGRAM_ID as qm,TOKEN_PROGRAM_ID as Um}from"@solana/spl-token";var yr=ye("Raydium_Api"),_s=new Map;var br=class{constructor({cluster:e,timeout:t,logRequests:n,logCount:o,urlConfigs:s}){this.cluster=e,this.urlConfigs=s||{},this.logCount=o||1e3,this.api=qu.create({baseURL:this.urlConfigs.BASE_HOST||ut.BASE_HOST,timeout:t}),this.api.interceptors.request.use(i=>{let{method:r,baseURL:u,url:a}=i;return yr.debug(`${r==null?void 0:r.toUpperCase()} ${u}${a}`),i},i=>(yr.error("Request failed"),Promise.reject(i))),this.api.interceptors.response.use(i=>{let{config:r,data:u,status:a}=i,{method:l,baseURL:m,url:p}=r;return n&&fr({status:a,url:`${m}${p}`,params:r.params,data:u,logCount:this.logCount}),yr.debug(`${l==null?void 0:l.toUpperCase()} ${m}${p}  ${a}`),u},i=>{let{config:r,response:u={}}=i,{status:a}=u,{method:l,baseURL:m,url:p}=r;return n&&fr({status:a,url:`${m}${p}`,params:r.params,data:i.message,logCount:this.logCount}),yr.error(`${l.toUpperCase()} ${m}${p} ${a||i.message}`),Promise.reject(i)})}async getClmmConfigs(){return(await this.api.get(this.urlConfigs.CLMM_CONFIG||ut.CLMM_CONFIG)).data}async getCpmmConfigs(){return(await this.api.get(this.urlConfigs.CPMM_CONFIG||ut.CPMM_CONFIG)).data}async getClmmPoolLines(e){return(await this.api.get(`${this.urlConfigs.POOL_LIQUIDITY_LINE||ut.POOL_LIQUIDITY_LINE}?pool_id=${e}`)).data}async getBlockSlotCountForSecond(e){if(!e)return 2;let n=(await qu.post(e,{id:"getRecentPerformanceSamples",jsonrpc:"2.0",method:"getRecentPerformanceSamples",params:[4]})).result.map(o=>o.numSlots);return n.reduce((o,s)=>o+s,0)/n.length/60}async getChainTimeOffset(){return(await this.api.get(this.urlConfigs.CHAIN_TIME||ut.CHAIN_TIME)).data}async getRpcs(){return this.api.get(this.urlConfigs.RPCS||ut.RPCS)}async getTokenList(){return(await this.api.get(this.urlConfigs.TOKEN_LIST||ut.TOKEN_LIST)).data}async getJupTokenList(){return(await this.api.get("",{baseURL:this.urlConfigs.JUP_TOKEN_LIST||ut.JUP_TOKEN_LIST})).map(t=>q(v({},t),{chainId:101,programId:t.tags.includes("token-2022")?qm.toBase58():Um.toBase58()}))}async getTokenInfo(e){return(await this.api.get((this.urlConfigs.MINT_INFO_ID||ut.MINT_INFO_ID)+`?mints=${e.map(n=>n.toString()).join(",")}`)).data}async getPoolList(e={}){let{type:t="all",sort:n="liquidity",order:o="desc",page:s=0,pageSize:i=100}=e;return(await this.api.get((this.urlConfigs.POOL_LIST||ut.POOL_LIST)+`?poolType=${t}&poolSortField=${n}&sortType=${o}&page=${s}&pageSize=${i}`)).data}async fetchPoolById(e){let{ids:t}=e;return(await this.api.get((this.urlConfigs.POOL_SEARCH_BY_ID||ut.POOL_SEARCH_BY_ID)+`?ids=${t}`)).data}async fetchPoolKeysById(e){let{idList:t}=e,n=[],o=t.filter(i=>_s.has(i)?(n.push(_s.get(i)),!1):!0),s=[];return o.length&&(s=(await this.api.get((this.urlConfigs.POOL_KEY_BY_ID||ut.POOL_KEY_BY_ID)+`?ids=${o.join(",")}`)).data.filter(Boolean),s.forEach(r=>{_s.set(r.id,r)})),n.concat(s)}async fetchPoolByMints(e){let{mint1:t,mint2:n,type:o="all",sort:s="default",order:i="desc",page:r=1}=e,[u,a]=[t&&dt(t).toBase58(),n&&n!=="undefined"?dt(n).toBase58():""],[l,m]=a&&u>a?[a,u]:[u,a];return(await this.api.get((this.urlConfigs.POOL_SEARCH_MINT||ut.POOL_SEARCH_MINT)+`?mint1=${l}&mint2=${m}&poolType=${o}&poolSortField=${s}&sortType=${i}&pageSize=100&page=${r}`)).data}async fetchFarmInfoById(e){let{ids:t}=e;return(await this.api.get((this.urlConfigs.FARM_INFO||ut.FARM_INFO)+`?ids=${t}`)).data}async fetchFarmKeysById(e){let{ids:t}=e;return(await this.api.get((this.urlConfigs.FARM_KEYS||ut.FARM_KEYS)+`?ids=${t}`)).data}async fetchAvailabilityStatus(){return(await this.api.get(this.urlConfigs.CHECK_AVAILABILITY||ut.CHECK_AVAILABILITY)).data}};var gr="please provide owner in load() initialization or you can set by calling raydium.setOwner(owner)",Uu="please provide connection in load() initialization or set it by raydium.setConnection(connection)";import{PublicKey as Ir,SystemProgram as kd}from"@solana/web3.js";import{AccountLayout as xo,createAssociatedTokenAccountIdempotentInstruction as Ys,TOKEN_PROGRAM_ID as vn,TOKEN_2022_PROGRAM_ID as wd}from"@solana/spl-token";var Es=(...c)=>c.map(e=>{try{return typeof e=="object"?JSON.stringify(e):e}catch{return e}}).join(", "),Fe=class{constructor({scope:e,moduleName:t}){this.disabled=!1;this.scope=e,this.logger=ye(t)}createTxBuilder(e){return this.scope.checkOwner(),new ri({connection:this.scope.connection,feePayer:e||this.scope.ownerPubKey,cluster:this.scope.cluster,owner:this.scope.owner,blockhashCommitment:this.scope.blockhashCommitment,loopMultiTxStatus:this.scope.loopMultiTxStatus,api:this.scope.api,signAllTransactions:this.scope.signAllTransactions})}createSniperTxBuilder(e,t){let n=new Ct(e);return new ri({connection:this.scope.connection,feePayer:t,cluster:this.scope.cluster,owner:n,blockhashCommitment:this.scope.blockhashCommitment,loopMultiTxStatus:this.scope.loopMultiTxStatus,api:this.scope.api,signAllTransactions:this.scope.signAllTransactions})}logDebug(...e){this.logger.debug(Es(e))}logInfo(...e){this.logger.info(Es(e))}logAndCreateError(...e){let t=Es(e);throw new Error(t)}checkDisabled(){(this.disabled||!this.scope)&&this.logAndCreateError("module not working")}};import{PublicKey as fd,SystemProgram as yd}from"@solana/web3.js";import bd from"bn.js";import{createCloseAccountInstruction as gd,createInitializeAccountInstruction as Ad,createTransferInstruction as Pd,TOKEN_PROGRAM_ID as Bo}from"@solana/spl-token";import{Keypair as ld,PublicKey as ic}from"@solana/web3.js";import md from"bn.js";import{TOKEN_PROGRAM_ID as dd}from"@solana/spl-token";function Gm(c){return c instanceof Uint8Array||c!=null&&typeof c=="object"&&c.constructor.name==="Uint8Array"}function Ds(c,...e){if(!Gm(c))throw new Error("Uint8Array expected");if(e.length>0&&!e.includes(c.length))throw new Error(`Uint8Array expected of length ${e}, not of length=${c.length}`)}function Ws(c,e=!0){if(c.destroyed)throw new Error("Hash instance has been destroyed");if(e&&c.finished)throw new Error("Hash#digest() has already been called")}function Gu(c,e){Ds(c);let t=e.outputLen;if(c.length<t)throw new Error(`digestInto() expects output buffer of length at least ${t}`)}var Pr=c=>new DataView(c.buffer,c.byteOffset,c.byteLength),tn=(c,e)=>c<<32-e|c>>>e;var lA=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;function Xm(c){if(typeof c!="string")throw new Error(`utf8ToBytes expected string, got ${typeof c}`);return new Uint8Array(new TextEncoder().encode(c))}function qs(c){return typeof c=="string"&&(c=Xm(c)),Ds(c),c}var Ar=class{clone(){return this._cloneInto()}},mA={}.toString;function Xu(c){let e=n=>c().update(qs(n)).digest(),t=c();return e.outputLen=t.outputLen,e.blockLen=t.blockLen,e.create=()=>c(),e}function zm(c,e,t,n){if(typeof c.setBigUint64=="function")return c.setBigUint64(e,t,n);let o=BigInt(32),s=BigInt(4294967295),i=Number(t>>o&s),r=Number(t&s),u=n?4:0,a=n?0:4;c.setUint32(e+u,i,n),c.setUint32(e+a,r,n)}var zu=(c,e,t)=>c&e^~c&t,Qu=(c,e,t)=>c&e^c&t^e&t,kr=class extends Ar{constructor(e,t,n,o){super(),this.blockLen=e,this.outputLen=t,this.padOffset=n,this.isLE=o,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(e),this.view=Pr(this.buffer)}update(e){Ws(this);let{view:t,buffer:n,blockLen:o}=this;e=qs(e);let s=e.length;for(let i=0;i<s;){let r=Math.min(o-this.pos,s-i);if(r===o){let u=Pr(e);for(;o<=s-i;i+=o)this.process(u,i);continue}n.set(e.subarray(i,i+r),this.pos),this.pos+=r,i+=r,this.pos===o&&(this.process(t,0),this.pos=0)}return this.length+=e.length,this.roundClean(),this}digestInto(e){Ws(this),Gu(e,this),this.finished=!0;let{buffer:t,view:n,blockLen:o,isLE:s}=this,{pos:i}=this;t[i++]=128,this.buffer.subarray(i).fill(0),this.padOffset>o-i&&(this.process(n,0),i=0);for(let m=i;m<o;m++)t[m]=0;zm(n,o-8,BigInt(this.length*8),s),this.process(n,0);let r=Pr(e),u=this.outputLen;if(u%4)throw new Error("_sha2: outputLen should be aligned to 32bit");let a=u/4,l=this.get();if(a>l.length)throw new Error("_sha2: outputLen bigger than state");for(let m=0;m<a;m++)r.setUint32(4*m,l[m],s)}digest(){let{buffer:e,outputLen:t}=this;this.digestInto(e);let n=e.slice(0,t);return this.destroy(),n}_cloneInto(e){e||(e=new this.constructor),e.set(...this.get());let{blockLen:t,buffer:n,length:o,finished:s,destroyed:i,pos:r}=this;return e.length=o,e.pos=r,e.finished=s,e.destroyed=i,o%t&&e.buffer.set(n),e}};var Qm=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),On=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),Nn=new Uint32Array(64),Us=class extends kr{constructor(){super(64,32,8,!1),this.A=On[0]|0,this.B=On[1]|0,this.C=On[2]|0,this.D=On[3]|0,this.E=On[4]|0,this.F=On[5]|0,this.G=On[6]|0,this.H=On[7]|0}get(){let{A:e,B:t,C:n,D:o,E:s,F:i,G:r,H:u}=this;return[e,t,n,o,s,i,r,u]}set(e,t,n,o,s,i,r,u){this.A=e|0,this.B=t|0,this.C=n|0,this.D=o|0,this.E=s|0,this.F=i|0,this.G=r|0,this.H=u|0}process(e,t){for(let m=0;m<16;m++,t+=4)Nn[m]=e.getUint32(t,!1);for(let m=16;m<64;m++){let p=Nn[m-15],d=Nn[m-2],f=tn(p,7)^tn(p,18)^p>>>3,y=tn(d,17)^tn(d,19)^d>>>10;Nn[m]=y+Nn[m-7]+f+Nn[m-16]|0}let{A:n,B:o,C:s,D:i,E:r,F:u,G:a,H:l}=this;for(let m=0;m<64;m++){let p=tn(r,6)^tn(r,11)^tn(r,25),d=l+p+zu(r,u,a)+Qm[m]+Nn[m]|0,y=(tn(n,2)^tn(n,13)^tn(n,22))+Qu(n,o,s)|0;l=a,a=u,u=r,r=i+d|0,i=s,s=o,o=n,n=d+y|0}n=n+this.A|0,o=o+this.B|0,s=s+this.C|0,i=i+this.D|0,r=r+this.E|0,u=u+this.F|0,a=a+this.G|0,l=l+this.H|0,this.set(n,o,s,i,r,u,a,l)}roundClean(){Nn.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}};var Yu=Xu(()=>new Us);import{PublicKey as sd}from"@solana/web3.js";import ec,{isBN as tc}from"bn.js";import{bits as Ym,BitStructure as kA,blob as jm,Blob as wA,cstr as TA,f32 as hA,f32be as IA,f64 as BA,f64be as xA,greedy as SA,Layout as Hm,ns64 as KA,ns64be as CA,nu64 as Zm,nu64be as RA,offset as $m,s16 as LA,s16be as OA,s24 as NA,s24be as MA,s32 as Jm,s32be as vA,s40 as FA,s40be as VA,s48 as _A,s48be as EA,s8 as DA,seq as ed,struct as WA,Structure as td,u16 as nd,u16be as qA,u24 as UA,u24be as GA,u32 as od,u32be as XA,u40 as zA,u40be as QA,u48 as YA,u48be as jA,u8 as id,UInt as rd,union as HA,Union as ZA,unionLayoutDiscriminator as $A,utf8 as JA}from"@solana/buffer-layout";var wr=Hm,ju=td;var Gs=rd;var Hu=id,Rt=nd;var Tr=od;var Zu=Zm;var Ve=Jm;var $u=ed;var he=jm;var Xs=Ym,Ju=$m;var Hn=class extends wr{constructor(t,n,o){super(t,o);this.blob=he(t),this.signed=n}decode(t,n=0){let o=new ec(this.blob.decode(t,n),10,"le");return this.signed?o.fromTwos(this.span*8).clone():o}encode(t,n,o=0){return typeof t=="number"&&(t=new ec(t)),this.signed&&(t=t.toTwos(this.span*8)),this.blob.encode(t.toArrayLike(Buffer,"le",this.span),n,o)}},hr=class extends wr{constructor(t){super(8,t);this._lower=Xs(Tr(),!1),this._upper=Xs(Tr(),!1)}addBoolean(t){this._lower.fields.length<32?this._lower.addBoolean(t):this._upper.addBoolean(t)}decode(t,n=0){let o=this._lower.decode(t,n),s=this._upper.decode(t,n+this._lower.span);return v(v({},o),s)}encode(t,n,o=0){return this._lower.encode(t,n,o)+this._upper.encode(t,n,o+this._lower.span)}};function E(c){return new Gs(1,c)}function lt(c){return new Gs(4,c)}function k(c){return new Hn(8,!1,c)}function ee(c){return new Hn(16,!1,c)}function nc(c){return new Hn(1,!0,c)}function Io(c){return new Hn(8,!0,c)}function oc(c){return new Hn(16,!0,c)}var ho=class extends wr{constructor(t,n,o,s){super(t.span,s);this.layout=t,this.decoder=n,this.encoder=o}decode(t,n){return this.decoder(this.layout.decode(t,n))}encode(t,n,o){return this.layout.encode(this.encoder(t),n,o)}getSpan(t,n){return this.layout.getSpan(t,n)}};function N(c){return new ho(he(32),e=>new sd(e),e=>e.toBuffer(),c)}function qe(c){return new ho(Hu(),ad,ud,c)}function ad(c){if(c===0)return!1;if(c===1)return!0;throw new Error("Invalid bool: "+c)}function ud(c){return c?1:0}function cd(c){let e=Tr("length"),t=V([e,he(Ju(e,-e.span),"data")]);return new ho(t,({data:n})=>n,n=>({data:n}),c)}function It(c){return new ho(cd(),e=>e.toString("utf-8"),e=>Buffer.from(e,"utf-8"),c)}var zs=class extends ju{decode(e,t){return super.decode(e,t)}};function V(c,e,t){return new zs(c,e,t)}function Y(c,e,t){let n,o=typeof e=="number"?e:tc(e)?e.toNumber():new Proxy(e,{get(s,i){if(!n){let r=Reflect.get(s,"count");n=tc(r)?r.toNumber():r,Reflect.set(s,"count",n)}return Reflect.get(s,i)},set(s,i,r){return i==="count"&&(n=r),Reflect.set(s,i,r)}});return $u(c,o,t)}var nn=V([N("mint"),N("owner"),k("amount"),lt("delegateOption"),N("delegate"),E("state"),lt("isNativeOption"),k("isNative"),k("delegatedAmount"),lt("closeAuthorityOption"),N("closeAuthority")]);var kP=ye("Raydium_Util");function rc({owner:c,solAccountResp:e,tokenAccountResp:t}){let n=[],o=[];for(let{pubkey:s,account:i}of t.value){let r=nn.decode(i.data),{mint:u,amount:a}=r;n.push({publicKey:s,mint:u,amount:a,isAssociated:H(c,u,i.owner).publicKey.equals(s),isNative:!1,programId:i.owner}),o.push({pubkey:s,accountInfo:r,programId:i.owner})}return e&&n.push({mint:ic.default,amount:new md(String(e.lamports)),isNative:!0,programId:e.owner}),{tokenAccounts:n,tokenAccountRawInfos:o}}function Qe({fromPublicKey:c,programId:e=dd,assignSeed:t}){let n=t?btoa(t).slice(0,32):ld.generate().publicKey.toBase58().slice(0,32);return{publicKey:pd(c,n,e),seed:n}}function pd(c,e,t){let n=Buffer.concat([c.toBuffer(),Buffer.from(e),t.toBuffer()]),o=Yu(n);return new ic(o)}function Qs(c){let{mint:e,tokenAccount:t,owner:n,programId:o=Bo}=c;return Ad(t,e,n,o)}function wn(c){let{tokenAccount:e,payer:t,multiSigners:n=[],owner:o,programId:s=Bo}=c;return gd(e,t,o,n,s)}async function Mn(c){let{connection:e,amount:t,commitment:n,payer:o,owner:s,skipCloseAccount:i}=c,r=await e.getMinimumBalanceForRentExemption(nn.span,n),u=J(t).add(new bd(r)),a=Qe({fromPublicKey:o,programId:Bo});return{addresses:{newAccount:a.publicKey},signers:[],instructions:[yd.createAccountWithSeed({fromPubkey:o,basePubkey:o,seed:a.seed,newAccountPubkey:a.publicKey,lamports:u.toNumber(),space:nn.span,programId:Bo}),Qs({mint:new fd(it.address),tokenAccount:a.publicKey,owner:s,programId:Bo})],instructionTypes:[U.CreateAccount,U.InitAccount],endInstructionTypes:i?[]:[U.CloseAccount],endInstructions:i?[]:[wn({tokenAccount:a.publicKey,payer:o,owner:s})]}}function sc({source:c,destination:e,owner:t,amount:n,multiSigners:o=[],tokenProgram:s=Bo}){return Pd(c,e,t,BigInt(String(n)),o,s)}var si=class extends Fe{constructor(t){super(t);this._tokenAccounts=[];this._tokenAccountRawInfos=[];this._accountListener=[];this._clientOwnedToken=!1;this._notSubscribeAccountChange=!1;this._accountFetchTime=0;let{tokenAccounts:n,tokenAccountRawInfos:o,notSubscribeAccountChange:s}=t;this._tokenAccounts=n||[],this._tokenAccountRawInfos=o||[],this._notSubscribeAccountChange=s!=null?s:!0,this._clientOwnedToken=!!(n||o)}get tokenAccounts(){return this._tokenAccounts}get tokenAccountRawInfos(){return this._tokenAccountRawInfos}set notSubscribeAccountChange(t){this._notSubscribeAccountChange=t}updateTokenAccount({tokenAccounts:t,tokenAccountRawInfos:n}){return t&&(this._tokenAccounts=t),n&&(this._tokenAccountRawInfos=n),this._accountChangeListenerId&&this.scope.connection.removeAccountChangeListener(this._accountChangeListenerId),this._accountChangeListenerId=void 0,this._clientOwnedToken=!0,this}addAccountChangeListener(t){return this._accountListener.push(t),this}removeAccountChangeListener(t){return this._accountListener=this._accountListener.filter(n=>n!==t),this}getAssociatedTokenAccount(t,n){return H(this.scope.ownerPubKey,t,n).publicKey}getAssociatedTokenAccountByOwner(t,n,o){return H(t,n,o).publicKey}resetTokenAccounts(){this._clientOwnedToken||(this._tokenAccounts=[],this._tokenAccountRawInfos=[])}async fetchWalletTokenAccounts(t){if(this._clientOwnedToken||!(t!=null&&t.forceUpdate)&&this._tokenAccounts.length&&Date.now()-this._accountFetchTime<(this._notSubscribeAccountChange?1e3*5:1e3*60*3))return{tokenAccounts:this._tokenAccounts,tokenAccountRawInfos:this._tokenAccountRawInfos};this.scope.checkOwner();let o=v(v({},{}),t),[s,i,r]=await Promise.all([this.scope.connection.getAccountInfo(this.scope.ownerPubKey,o.commitment),this.scope.connection.getTokenAccountsByOwner(this.scope.ownerPubKey,{programId:vn},o.commitment),this.scope.connection.getTokenAccountsByOwner(this.scope.ownerPubKey,{programId:wd},o.commitment)]),{tokenAccounts:u,tokenAccountRawInfos:a}=rc({owner:this.scope.ownerPubKey,solAccountResp:s,tokenAccountResp:{context:i.context,value:[...i.value,...r.value]}});return this._tokenAccounts=u,this._tokenAccountRawInfos=a,this._accountFetchTime=Date.now(),this._notSubscribeAccountChange||(this._accountChangeListenerId&&this.scope.connection.removeAccountChangeListener(this._accountChangeListenerId),this._accountChangeListenerId=this.scope.connection.onAccountChange(this.scope.ownerPubKey,()=>{this.fetchWalletTokenAccounts({forceUpdate:!0}),this._accountListener.forEach(l=>l({tokenAccounts:this._tokenAccounts,tokenAccountRawInfos:this._tokenAccountRawInfos}))},{commitment:t==null?void 0:t.commitment})),{tokenAccounts:u,tokenAccountRawInfos:a}}clearAccountChangeCkb(){this._accountChangeListenerId!==void 0&&this.scope.connection.removeAccountChangeListener(this._accountChangeListenerId)}async getCreatedTokenAccount({mint:t,programId:n=vn,associatedOnly:o=!0}){await this.fetchWalletTokenAccounts();let s=this._tokenAccounts.filter(({mint:r})=>r==null?void 0:r.equals(t)).sort((r,u)=>r.amount.lt(u.amount)?1:-1),i=this.getAssociatedTokenAccount(t,n);for(let r of s){let{publicKey:u}=r;if(u&&(!o||o&&i.equals(u)))return u}}async getOrCreateTokenAccount(t){var y,b,g,A;await this.fetchWalletTokenAccounts();let{mint:n,createInfo:o,associatedOnly:s,owner:i,notUseTokenAccount:r=!1,skipCloseAccount:u=!1,checkCreateATAOwner:a=!1,assignSeed:l}=t,m=new Ir(t.tokenProgram||vn),p=this.getAssociatedTokenAccount(n,new Ir(m)),d=(r?[]:this.tokenAccountRawInfos).filter(h=>h.accountInfo.mint.equals(n)&&(!s||h.pubkey.equals(p))).sort((h,I)=>h.accountInfo.amount.lt(I.accountInfo.amount)?1:-1);if(o===void 0||d.length>0)return d.length>0?{account:d[0].pubkey}:{};let f={instructions:[],endInstructions:[],signers:[],instructionTypes:[],endInstructionTypes:[]};if(s){let h=Ys(i,p,i,n,m),I=this.tokenAccountRawInfos.find(T=>T.pubkey.equals(p));if(a){let T=await this.scope.connection.getAccountInfo(p);if(T===null)(y=f.instructions)==null||y.push(h),f.instructionTypes.push(U.CreateATA);else if(!(T.owner.equals(m)&&xo.decode(T.data).mint.equals(n)&&xo.decode(T.data).owner.equals(i)))throw Error(`create ata check error -> mint: ${n.toString()}, ata: ${p.toString()}`)}else I===void 0&&(f.instructions.push(h),f.instructionTypes.push(U.CreateATA));if(n.equals(Z)&&o.amount){let T=await Mn({connection:this.scope.connection,owner:this.scope.ownerPubKey,payer:o.payer||this.scope.ownerPubKey,amount:(b=o.amount)!=null?b:0,skipCloseAccount:u});f.instructions.push(...T.instructions||[]),f.endInstructions.push(...T.endInstructions||[]),f.instructionTypes.push(...T.instructionTypes||[]),f.endInstructionTypes.push(...T.endInstructionTypes||[]),o.amount&&(f.instructions.push(sc({source:T.addresses.newAccount,destination:p,owner:this.scope.ownerPubKey,amount:o.amount,tokenProgram:vn})),f.instructionTypes.push(U.TransferAmount))}return!u&&I===void 0&&(f.endInstructions.push(wn({owner:i,payer:o.payer||i,tokenAccount:p,programId:m})),f.endInstructionTypes.push(U.CloseAccount)),{account:p,instructionParams:f}}else{let h=Qe({fromPublicKey:i,programId:m,assignSeed:l}),I=await this.scope.connection.getMinimumBalanceForRentExemption(xo.span),T=kd.createAccountWithSeed({fromPubkey:i,basePubkey:i,seed:h.seed,newAccountPubkey:h.publicKey,lamports:I+Number((A=(g=o.amount)==null?void 0:g.toString())!=null?A:0),space:xo.span,programId:m});return f.instructions.push(T,Qs({mint:n,tokenAccount:h.publicKey,owner:this.scope.ownerPubKey,programId:m})),f.instructionTypes.push(U.CreateAccount),f.instructionTypes.push(U.InitAccount),u||(f.endInstructions.push(wn({owner:i,payer:o.payer||i,tokenAccount:h.publicKey,programId:m})),f.endInstructionTypes.push(U.CloseAccount)),{account:h.publicKey,instructionParams:f}}}async checkOrCreateAta({mint:t,programId:n=vn,autoUnwrapWSOLToSOL:o}){var u;await this.fetchWalletTokenAccounts();let s=(u=this.scope.account.tokenAccounts.find(({mint:a})=>(a==null?void 0:a.toBase58())===t.toBase58()))==null?void 0:u.publicKey,i=this.scope.ownerPubKey,r={};if(!s){let a=this.getAssociatedTokenAccount(t,n),l=await Ys(i,a,i,t,n);r.instructions=[l],r.instructionTypes=[U.CreateATA],s=a}return o&&Z.toBase58()===t.toBase58()&&(r.endInstructions=[wn({owner:i,payer:i,tokenAccount:s,programId:n})],r.endInstructionTypes=[U.CloseAccount]),{pubKey:s,newInstructions:r}}async handleTokenAccount(t){let{side:n,amount:o,mint:s,programId:i=vn,tokenAccount:r,payer:u=this.scope.ownerPubKey,bypassAssociatedCheck:a,skipCloseAccount:l,checkCreateATAOwner:m}=t,p=this.getAssociatedTokenAccount(s,i);if(new Ir(Z).equals(s)){let d=await Mn({connection:this.scope.connection,owner:this.scope.ownerPubKey,payer:u,amount:o,skipCloseAccount:l});return v({tokenAccount:d.addresses.newAccount},d)}else if(!r||n==="out"&&!p.equals(r)&&!a){let d=[],f=Ys(this.scope.ownerPubKey,p,this.scope.ownerPubKey,s,i);if(m){let y=await this.scope.connection.getAccountInfo(p);if(y===null)d.push(f);else if(!(y.owner.equals(vn)&&xo.decode(y.data).mint.equals(s)&&xo.decode(y.data).owner.equals(this.scope.ownerPubKey)))throw Error(`create ata check error -> mint: ${s.toString()}, ata: ${p.toString()}`)}else d.push(f);return{tokenAccount:p,instructions:d,instructionTypes:[U.CreateATA]}}return{tokenAccount:r}}async processTokenAccount(t){let{mint:n,programId:o=vn,amount:s,useSOLBalance:i,handleTokenAccount:r,feePayer:u}=t,a,l=this.createTxBuilder(u);if(n.equals(new Ir(Z))&&i){let m=await this.handleTokenAccount({side:"in",amount:s||0,mint:n,bypassAssociatedCheck:!0,programId:o}),{tokenAccount:d}=m,f=Ee(m,["tokenAccount"]);a=d,l.addInstruction(f)}else if(a=await this.getCreatedTokenAccount({mint:n,associatedOnly:!1,programId:o}),!a&&r){let p=await this.scope.account.handleTokenAccount({side:"in",amount:0,mint:n,bypassAssociatedCheck:!0,programId:o}),{tokenAccount:d}=p,f=Ee(p,["tokenAccount"]);a=d,l.addInstruction(f)}return v({tokenAccount:a},l.AllTxData)}};import{PublicKey as Be,SystemProgram as Ud}from"@solana/web3.js";import{createAssociatedTokenAccountIdempotentInstruction as Bc}from"@solana/spl-token";import Gd from"decimal.js";import{PublicKey as ea}from"@solana/web3.js";var js=V([E("instruction")]),Hs=V([E("instruction")]),Td=V([k("rewardState"),k("rewardOpenTime"),k("rewardEndTime"),k("rewardLastUpdateTime"),k("totalReward"),k("totalRewardEmissioned"),k("rewardClaimed"),k("rewardPerSecond"),ee("accRewardPerShare"),N("rewardVault"),N("rewardMint"),N("rewardSender"),k("rewardType"),Y(k(),15,"padding")]),hd=V([k("state"),k("nonce"),N("lpVault"),N("rewardVault"),N(),N(),k(),k(),k("totalReward"),ee("perShareReward"),k("lastSlot"),k("perSlotReward")]),Id=V([k("state"),k("nonce"),N("lpVault"),N("rewardVaultA"),k("totalRewardA"),ee("perShareRewardA"),k("perSlotRewardA"),E("option"),N("rewardVaultB"),he(7),k("totalRewardB"),ee("perShareRewardB"),k("perSlotRewardB"),k("lastSlot"),N()]),Bd=V([k(),k("state"),k("nonce"),k("validRewardTokenNum"),ee("rewardMultiplier"),k("rewardPeriodMax"),k("rewardPeriodMin"),k("rewardPeriodExtend"),N("lpMint"),N("lpVault"),Y(Td,5,"rewardInfos"),N("creator"),N(),Y(k(),32,"padding")]),ac=new Proxy(hd,{get(c,e,t){return e==="decode"?(...n)=>{let o=c.decode(...n);return q(v({},o),{version:3,rewardInfos:[{rewardVault:o.rewardVault,totalReward:o.totalReward,perSlotReward:o.perSlotReward,perShareReward:o.perShareReward}]})}:Reflect.get(c,e,t)}}),uc=new Proxy(Id,{get(c,e,t){return e==="decode"?(...n)=>{let o=c.decode(...n);return q(v({},o),{version:5,rewardInfos:[{rewardVault:o.rewardVaultA,totalReward:o.totalRewardA,perSlotReward:o.perSlotRewardA,perShareReward:o.perShareRewardA},{rewardVault:o.rewardVaultB,totalReward:o.totalRewardB,perSlotReward:o.perSlotRewardB,perShareReward:o.perShareRewardB}]})}:Reflect.get(c,e,t)}}),ai=new Proxy(Bd,{get(c,e,t){return e==="decode"?(...n)=>{let o=c.decode(...n);return q(v({},o),{version:6,rewardInfos:o.rewardInfos.map(s=>{var i;return q(v({},s),{rewardType:((i=Object.entries(Fn).find(r=>String(r[1])===s.rewardType.toString()))!=null?i:["Standard SPL"])[0]})})})}:Reflect.get(c,e,t)}}),xd=V([k("isSet"),k("rewardPerSecond"),k("rewardOpenTime"),k("rewardEndTime"),k("rewardType")]),Zs=V([E("instruction"),k("nonce"),Y(xd,5,"rewardTimeInfo")]),$s=V([E("instruction"),k("rewardReopenTime"),k("rewardEndTime"),k("rewardPerSecond")]),Js=V([E("instruction"),k("isSet"),k("rewardPerSecond"),k("rewardOpenTime"),k("rewardEndTime"),k("rewardType")]),$P=V([k("state"),N("id"),N("owner"),k("deposited"),Y(k(),1,"rewardDebts")]),ui=V([k("state"),N("id"),N("owner"),k("deposited"),Y(ee(),1,"rewardDebts"),k(""),k("voteLockedBalance"),Y(k(),15)]),JP=V([k("state"),N("id"),N("owner"),k("deposited"),Y(k(),2,"rewardDebts")]),cc=V([k("state"),N("id"),N("owner"),k("deposited"),Y(ee(),2,"rewardDebts"),Y(k(),17)]),lc=V([k(),k("state"),N("id"),N("owner"),k("deposited"),Y(ee(),5,"rewardDebts"),Y(k(),16)]),At=V([E("instruction"),k("amount")]),Sd=V([N("mint"),N("grantAuthority"),k("baselineVoteWeightScaledFactor"),k("maxExtraLockupVoteWeightScaledFactor"),k("lockupSaturationSecs"),nc("digitShift"),Y(E(),7,"reserved1"),Y(k(),7,"reserved2")]),mc=V([he(8),N("governanceProgramId"),N("realm"),N("realmGoverningTokenMint"),N("realmAuthority"),Y(E(),32,"reserved1"),Y(Sd,4,"votingMints"),Io("timeOffset"),E("bump"),Y(E(),7,"reserved2"),Y(k(),11,"reserved3")]),Kd=V([Io("startTime"),Io("endTime"),E("kind"),Y(E(),15,"reserved")]),Cd=V([Y(Kd,1,"lockup"),k("amountDeposited_native"),k("amountInitiallyLockedNative"),qe("isUsed"),qe("allowClawback"),E("votingMintConfigIdx"),Y(E(),29,"reserved")]),dc=V([he(8),N("voterAuthority"),N("registrar"),Y(Cd,32,"deposits"),E("voterBump"),E("voterWweightRecordBump"),Y(E(),94,"reserved")]);import{NATIVE_MINT as Rd}from"@solana/spl-token";var uk=ye("Raydium_farm_config"),pc=new ea("4k3Dyjzvzp8eMZWUXbBCjEvwSkkk59S5iCNLY3QrkX6R"),fc=new ea("FrspKwj8i3pNmKwXreTveC4fu7KL5ZbGeXdZBe2XViu1"),ck=Rd,lk=new ea("3TRTX4dXUpp2eqxi3tvQDFYUV7SdDJjcPE3Y4mbtftaX"),yc={3:ac,5:uc,6:ai},bc={3:ui,5:cc,6:lc},ta=c=>[3,4,5,6].indexOf(c)!==-1,na=c=>{var i;let{version:e,rewardInfos:t,rewardTokenAccountsPublicKeys:n}=c,o=`rewardInfo:${JSON.stringify(t)}, rewardAccount:${JSON.stringify(n)}`,s={3:()=>{if(t.length!==1||n.length!==1)return`rewardInfos or rewardTokenAccounts lengths not equal 1: ${o}`},5:()=>{if(t.length!==n.length)return`rewardInfos and rewardTokenAccounts lengths not equal: ${o}`},6:()=>{if(!n.length||t.length!==n.length)return`no rewardTokenAccounts or rewardInfos and rewardTokenAccounts lengths not equal: ${o}`}};return(i=s[e])==null?void 0:i.call(s)},Fn={"Standard SPL":0,"Option tokens":1},Et={[Ss.toString()]:3,[Ks.toString()]:4,[Cs.toString()]:5,[Po.toString()]:6,[An.FARM_PROGRAM_ID_V3.toString()]:3,[An.FARM_PROGRAM_ID_V4.toString()]:4,[An.FARM_PROGRAM_ID_V5.toString()]:5,[An.FARM_PROGRAM_ID_V6.toString()]:6};import{PublicKey as ce,SystemProgram as Zn,SYSVAR_CLOCK_PUBKEY as Ko,SYSVAR_RENT_PUBKEY as Nd,TransactionInstruction as Je}from"@solana/web3.js";import Br from"bn.js";import{ASSOCIATED_TOKEN_PROGRAM_ID as Md,createAssociatedTokenAccountIdempotentInstruction as vd,TOKEN_PROGRAM_ID as xt}from"@solana/spl-token";function oa(c,e,t){return ne([e.toBuffer(),Buffer.from("registrar","utf8"),t.toBuffer()],c)}function ia(c,e){return ne([e.toBuffer(),Buffer.from("voting_mint_seed","utf8")],c)}function ra(c,e){return ne([e.toBuffer()],c)}function sa(c,e,t){return ne([e.toBuffer(),Buffer.from("voter","utf8"),t.toBuffer()],c)}function aa(c,e,t){return ne([e.toBuffer(),Buffer.from("voter-weight-record","utf8"),t.toBuffer()],c)}function ua(c,e,t,n){return ne([Buffer.from("governance","utf8"),e.toBuffer(),t.toBuffer(),n.toBuffer()],c)}import Bt from"bn.js";var ci=ye("Raydium.farm.util");function li({programId:c,poolId:e,mint:t,type:n}){let{publicKey:o}=ne([e.toBuffer(),t.toBuffer(),Buffer.from(n==="lpVault"?"lp_vault_associated_seed":n==="rewardVault"?"reward_vault_associated_seed":"","utf-8")],c);return o}function pt({programId:c,poolId:e,owner:t,version:n}){let{publicKey:o}=ne([e.toBuffer(),t.toBuffer(),Buffer.from(n===6?"farmer_info_associated_seed":"staker_info_v2_associated_seed","utf-8")],c);return o}var gc=({programId:c,poolId:e})=>ne([e.toBuffer()],c);function Ac(c){return{isSet:new Bt(1),rewardPerSecond:J(c.perSecond),rewardOpenTime:J(c.openTime),rewardEndTime:J(c.endTime),rewardType:J(Fn[c.rewardType])}}function ca(c){return J(c.endTime).sub(J(c.openTime)).mul(J(c.perSecond))}function So(c){let e=bc[c];return e||ci.logWithError("invalid version",c),e}function Ld(c){let e=yc[c];return e||ci.logWithError("invalid version",c),e}function Od(c,e,t,n){if(c.version===3||c.version===5){if(c.lastSlot.gte(new Bt(t)))return c;let o=new Bt(t).sub(c.lastSlot);c.lastSlot=new Bt(t);for(let s of c.rewardInfos){if(e.amount.eq(new Bt(0)))continue;let i=s.perSlotReward.mul(o);s.perShareReward=s.perShareReward.add(i.mul(new Bt(10).pow(new Bt(c.version===3?9:15))).div(e.amount)),s.totalReward=s.totalReward.add(i)}}else if(c.version===6)for(let o of c.rewardInfos){if(o.rewardState.eq(new Bt(0)))continue;let s=Bt.min(new Bt(n),o.rewardEndTime);if(o.rewardOpenTime.gte(s))continue;let r=s.sub(o.rewardLastUpdateTime).mul(o.rewardPerSecond),u=o.totalReward.sub(o.totalRewardEmissioned);u.lt(r)?(r=u,o.rewardLastUpdateTime=o.rewardLastUpdateTime.add(u.div(o.rewardPerSecond))):o.rewardLastUpdateTime=s,!e.amount.eq(new Bt(0))&&(o.accRewardPerShare=o.accRewardPerShare.add(r.mul(c.rewardMultiplier).div(e.amount)),o.totalRewardEmissioned=o.totalRewardEmissioned.add(r))}return c}async function Sk({connection:c,farmPools:e,owner:t,config:n,chainTime:o}){let s=!1,i=!1,r=new Bt(10),u=[];for(let p of e){let d=Me(p);d.version===6?i=!0:s=!0,u.push({pubkey:d.id,version:d.version,key:"state",poolId:d.id},{pubkey:d.lpVault,version:d.version,key:"lpVault",poolId:d.id}),t&&u.push({pubkey:pt({programId:d.programId,poolId:d.id,owner:t,version:p.version}),version:d.version,key:"ledger",poolId:d.id})}let a={},l=await Le(c,u,n);for(let{pubkey:p,version:d,key:f,poolId:y,accountInfo:b}of l){let g=y.toBase58();if(a[g]=v({},a[g]),f==="state"){let A=Ld(d);(!b||!b.data||b.data.length!==A.span)&&ci.logWithError(`invalid farm state account info, pools.id, ${p}`),a[g].state=A.decode(b.data)}else if(f==="lpVault")(!b||!b.data||b.data.length!==nn.span)&&ci.logWithError(`invalid farm lp vault account info, pools.lpVault, ${p}`),a[g].lpVault=nn.decode(b.data);else if(f==="ledger"){let A=So(d);b&&b.data&&(b.data.length!==A.span&&ci.logWithError(`invalid farm ledger account info, ledger, ${p}`),a[g].ledger=A.decode(b.data))}}let m=i||s?await c.getSlot():0;for(let p of Object.keys(a))a[p]!==void 0&&(a[p].state=Od(a[p].state,a[p].lpVault,m,o));for(let[p,{state:d,ledger:f}]of Object.entries(a))if(f){let y=d.version===6?d.rewardMultiplier:d.rewardInfos.length===1?r.pow(new Bt(9)):r.pow(new Bt(15)),b=d.rewardInfos.map((g,A)=>{let h=f.rewardDebts[A];return f.deposited.mul(d.version===6?g.accRewardPerShare:g.perShareReward).div(y).sub(h)});a[p].wrapped=q(v({},a[p].wrapped),{pendingRewards:b})}return a}function Kk(c,e=Date.now()){if(c.version===6){let t=c.state.rewardInfos;if(t.every(({rewardOpenTime:n})=>Ou(e,n.toNumber(),{unit:"s"})))return"upcoming pool";if(t.every(({rewardEndTime:n})=>Nu(e,n.toNumber(),{unit:"s"})))return"closed pool"}else{let t=c.state.rewardInfos.map(({perSlotReward:n})=>n);if(t.length===2){if(String(t[0])==="0"&&String(t[1])!=="0")return"normal fusion pool";if(String(t[0])!=="0"&&String(t[1])!=="0")return"dual fusion pool";if(String(t[0])==="0"&&String(t[1])==="0")return"closed pool"}else if(t.length===1&&String(t[0])==="0")return"closed pool"}}async function la(c,e,t,n){let o=await c.getAccountInfo(e);if(o===null)throw Error("registrar info check error");let i=mc.decode(o.data).votingMints.findIndex(l=>l.mint.equals(n));if(i===-1)throw Error("find voter mint error");let r=await c.getAccountInfo(t);if(r===null)return{index:i,isInit:!1};let a=dc.decode(r.data).deposits.findIndex(l=>l.isUsed&&l.votingMintConfigIdx===i);return a===-1?{index:i,isInit:!1}:{index:a,isInit:!0}}var Fd=ye("Raydium_farm_instruction"),mi={voterStakeRegistryCreateVoter:Buffer.from([6,24,245,52,243,255,148,25]),voterStakeRegistryCreateDepositEntry:Buffer.from([185,131,167,186,159,125,19,67]),voterStakeRegistryDeposit:Buffer.from([242,35,198,137,82,225,242,182]),voterStakeRegistryWithdraw:Buffer.from([183,18,70,156,148,109,161,34]),voterStakeRegistryUpdateVoterWeightRecord:Buffer.from([45,185,3,36,109,190,115,169])};function di(c){let{version:e,id:t,ledger:n,programId:o,owner:s}=c,i={3:9,5:10}[e];i||Fd.logWithError(`invalid farm pool version: ${e}`);let r=Buffer.alloc(js.span);js.encode({instruction:i},r);let u=[P({pubkey:t}),P({pubkey:n}),P({pubkey:s,isWritable:!1}),P({pubkey:Zn.programId,isWritable:!1}),P({pubkey:Nd,isWritable:!1})];return{instruction:new Je({programId:o,keys:u,data:r}),instructionType:U.FarmV3CreateLedger}}function Pc(c){var n;let e=Buffer.alloc(Zs.span);Zs.encode({instruction:0,nonce:new Br(c.nonce),rewardTimeInfo:c.rewardInfoConfig},e);let t=[...As,P({pubkey:c.farmId}),P({pubkey:c.farmAuthority,isWritable:!1}),P({pubkey:c.lpVault}),P({pubkey:c.lpMint,isWritable:!1}),P({pubkey:c.lockVault}),P({pubkey:c.lockMint,isWritable:!1}),P({pubkey:(n=c.lockUserAccount)!=null?n:rt}),P({pubkey:c.owner,isWritable:!1,isSigner:!0})];for(let o of c.rewardInfo)t.push(P({pubkey:o.rewardMint,isWritable:!1}),P({pubkey:o.rewardVault}),P({pubkey:o.userRewardToken}));return{instruction:new Je({programId:c.programId,keys:t,data:e}),instructionType:U.FarmV6Create}}function kc(c){let e=Buffer.alloc(Hs.span);Hs.encode({instruction:5},e);let t=[P({pubkey:xt,isWritable:!1}),P({pubkey:c.id}),P({pubkey:c.authority,isWritable:!1}),P({pubkey:c.lpVault,isWritable:!1}),P({pubkey:c.rewardVault}),P({pubkey:c.userRewardToken}),P({pubkey:c.owner,isWritable:!1,isSigner:!0})];return{instruction:new Je({programId:c.programId,keys:t,data:e}),instructionType:U.FarmV6CreatorWithdraw}}function Vd(c,e,t,n,o,s,i,r,u,a,l,m,p){let d=V([E("depositEntryIndex"),k("amount")]),f=[{pubkey:e,isSigner:!1,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!1},{pubkey:xt,isSigner:!1,isWritable:!1},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!1},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!1},{pubkey:l,isSigner:!1,isWritable:!1},{pubkey:or,isSigner:!1,isWritable:!1}],y=Buffer.alloc(d.span);d.encode({depositEntryIndex:m,amount:p},y);let b=Buffer.from([...mi.voterStakeRegistryDeposit,...y]);return new Je({keys:f,programId:c,data:b})}function _d(c,e,t,n){let o=V([]),s=[{pubkey:e,isSigner:!1,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:Zn.programId,isSigner:!1,isWritable:!1}],i=Buffer.alloc(o.span);o.encode({},i);let r=Buffer.from([...mi.voterStakeRegistryUpdateVoterWeightRecord,...i]);return new Je({keys:s,programId:c,data:r})}function Ed(c,e,t,n,o,s,i,r,u,a,l,m,p,d,f){let y=V([E("depositEntryIndex"),k("amount")]),b=[{pubkey:e,isSigner:!1,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!0,isWritable:!1},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:xt,isSigner:!1,isWritable:!1},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!1},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:m,isSigner:!1,isWritable:!1},{pubkey:p,isSigner:!1,isWritable:!1},{pubkey:or,isSigner:!1,isWritable:!1}],g=Buffer.alloc(y.span);y.encode({depositEntryIndex:d,amount:f},g);let A=Buffer.from([...mi.voterStakeRegistryWithdraw,...g]);return new Je({keys:b,programId:c,data:A})}function Dd(c,e,t,n,o,s){let i=V([E("ins")]),r=[{pubkey:e,isSigner:!1,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!0,isWritable:!0},{pubkey:Zn.programId,isSigner:!1,isWritable:!1}],u=Buffer.alloc(i.span);return i.encode({ins:23},u),new Je({keys:r,programId:c,data:u})}function Wd(c,e,t,n,o,s,i,r){let u=V([E("voterBump"),E("voterWeightRecordBump")]),a=[{pubkey:e,isSigner:!1,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!0,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!0,isWritable:!0},{pubkey:Zn.programId,isSigner:!1,isWritable:!1},{pubkey:$e,isSigner:!1,isWritable:!1},{pubkey:or,isSigner:!1,isWritable:!1}],l=Buffer.alloc(u.span);u.encode({voterBump:i,voterWeightRecordBump:r},l);let m=Buffer.from([...mi.voterStakeRegistryCreateVoter,...l]);return new Je({keys:a,programId:c,data:m})}function qd(c,e,t,n,o,s,i,r,u,a,l,m){let p=V([E("depositEntryIndex"),E("kind"),E("option"),k("startTs"),lt("periods"),qe("allowClawback")]),d=[{pubkey:e,isSigner:!1,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!0,isWritable:!1},{pubkey:s,isSigner:!0,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!1},{pubkey:Zn.programId,isSigner:!1,isWritable:!1},{pubkey:xt,isSigner:!1,isWritable:!1},{pubkey:Md,isSigner:!1,isWritable:!1},{pubkey:$e,isSigner:!1,isWritable:!1}],f=Buffer.alloc(p.span);p.encode({depositEntryIndex:r,kind:u,option:a===void 0?0:1,startTs:a,periods:l,allowClawback:m},f);let y=Buffer.from([...mi.voterStakeRegistryCreateDepositEntry,...f]);return new Je({keys:d,programId:c,data:y})}async function Gk({connection:c,programId:e,governanceProgramId:t,voteWeightAddinProgramId:n,realm:o,communityTokenMint:s,owner:i,poolId:r,tokenProgram:u}){let a=oa(n,o,s).publicKey,l=pt({programId:e,poolId:r,owner:i,version:3}),m=await c.getAccountInfo(l);if(m===null)throw Error("user is not staker");let p=ui.decode(m.data),d=p.deposited.sub(p.voteLockedBalance);if(console.log("amount",d.toString()),d.eq(new Br(0)))throw Error("user do not has new stake amount");let f=ia(e,r).publicKey,y=ra(e,r).publicKey,{publicKey:b,nonce:g}=sa(n,a,i),A=H(b,f,u).publicKey,{publicKey:h,nonce:I}=aa(n,a,i),T=ua(t,o,s,i).publicKey,w=[],S=H(i,f,u).publicKey;if(await c.getAccountInfo(S)===null&&w.push(vd(i,S,i,f)),await c.getAccountInfo(b)===null){let O=Dd(t,o,i,s,i,T);w.push(O,Wd(n,a,b,h,i,i,g,I))}let{index:B,isInit:C}=await la(c,a,b,f);return C||w.push(qd(n,a,b,A,i,i,f,B,0,void 0,0,!1)),w.push(Vd(n,a,b,A,S,i,l,r,f,y,e,B,d),_d(n,a,b,h)),w}async function Xk({connection:c,programId:e,governanceProgramId:t,voteWeightAddinProgramId:n,realm:o,communityTokenMint:s,owner:i,poolId:r,tokenProgram:u}){let a=oa(n,o,s).publicKey,l=pt({programId:e,poolId:r,owner:i,version:3}),m=await c.getAccountInfo(l);if(m===null)throw Error("user is not staker");let p=ui.decode(m.data);if(p.voteLockedBalance.eq(new Br(0)))throw Error("user has vote locked balance = 0");let d=ia(e,r).publicKey,f=ra(e,r).publicKey,{publicKey:y}=sa(n,a,i),b=H(y,d,u).publicKey,{publicKey:g}=aa(n,a,i),A=ua(t,o,s,i).publicKey,h=[],{index:I,isInit:T}=await la(c,a,y,d);if(!T)throw Error("deposit entry index check error");return h.push(Ed(n,a,y,i,A,g,b,H(i,d,u).publicKey,l,r,d,f,e,I,p.voteLockedBalance)),h}function ma({payer:c,rewardVault:e,userRewardTokenPub:t,farmKeys:n,rewardInfo:o}){let s=Buffer.alloc($s.span);$s.encode({instruction:3,rewardReopenTime:J(o.openTime),rewardEndTime:J(o.endTime),rewardPerSecond:J(o.perSecond)},s);let i=[P({pubkey:xt,isWritable:!1}),P({pubkey:n.id}),P({pubkey:n.lpVault,isWritable:!1}),P({pubkey:e}),P({pubkey:t}),P({pubkey:c,isWritable:!1,isSigner:!0})];return new Je({programId:n.programId,keys:i,data:s})}function da({payer:c,userRewardTokenPub:e,farmKeys:t,rewardVault:n,rewardInfo:o}){let s=Buffer.alloc(Js.span);Js.encode({instruction:4,isSet:new Br(1),rewardPerSecond:J(o.perSecond),rewardOpenTime:J(o.openTime),rewardEndTime:J(o.endTime),rewardType:J(Fn[o.rewardType])},s);let i=[...As,P({pubkey:t.id}),P({pubkey:t.authority,isWritable:!1}),P({pubkey:o.mint,isWritable:!1}),P({pubkey:n}),P({pubkey:e}),P({pubkey:c,isWritable:!1,isSigner:!0})];return new Je({programId:t.programId,keys:i,data:s})}function zk(c){let{farmInfo:e,farmKeys:t,version:n,lpAccount:o,rewardAccounts:s,owner:i,instruction:r,amount:u,deposit:a}=c,[l,m]=[new ce(e.programId),new ce(e.id)],p=pt({programId:l,poolId:m,owner:i,version:n}),d=Buffer.alloc(At.span);At.encode({instruction:r,amount:u},d);let f=n===6?[P({pubkey:xt,isWritable:!1}),...a?[P({pubkey:Zn.programId,isWritable:!1})]:[],P({pubkey:m}),P({pubkey:new ce(t.authority),isWritable:!1}),P({pubkey:new ce(t.lpVault)}),P({pubkey:p}),P({pubkey:i,isWritable:!1,isSigner:!0}),P({pubkey:o})]:[P({pubkey:m}),P({pubkey:new ce(t.authority),isWritable:!1}),P({pubkey:p}),P({pubkey:i,isWritable:!1,isSigner:!0}),P({pubkey:o}),P({pubkey:new ce(t.lpVault)}),P({pubkey:s[0]}),P({pubkey:new ce(t.rewardInfos[0].vault)}),P({pubkey:Ko,isWritable:!1}),P({pubkey:xt,isWritable:!1})];if(n===5)for(let y=1;y<t.rewardInfos.length;y++)f.push(P({pubkey:s[y]})),f.push(P({pubkey:new ce(t.rewardInfos[y].vault)}));if(n===6)for(let y=0;y<t.rewardInfos.length;y++)f.push(P({pubkey:new ce(t.rewardInfos[y].vault)})),f.push(P({pubkey:s[y]}));return new Je({programId:l,keys:f,data:d})}function pi(c){let{farmInfo:e,farmKeys:t,lpAccount:n,rewardAccounts:o,owner:s,amount:i}=c,[r,u]=[new ce(e.programId),new ce(e.id)],a=pt({programId:r,poolId:u,owner:s,version:6}),l=Buffer.alloc(At.span);At.encode({instruction:2,amount:J(i)},l);let m=[P({pubkey:xt,isWritable:!1}),P({pubkey:u}),P({pubkey:new ce(t.authority),isWritable:!1}),P({pubkey:new ce(t.lpVault)}),P({pubkey:a}),P({pubkey:s,isWritable:!1,isSigner:!0}),P({pubkey:n})];for(let p=0;p<t.rewardInfos.length;p++)m.push(P({pubkey:new ce(t.rewardInfos[p].vault)})),m.push(P({pubkey:o[p]}));return new Je({programId:r,keys:m,data:l})}function fi(c){let{farmInfo:e,farmKeys:t,lpAccount:n,rewardAccounts:o,owner:s,amount:i,userAuxiliaryLedgers:r}=c,[u,a]=[new ce(e.programId),new ce(e.id)],l=pt({programId:u,poolId:a,owner:s,version:5}),m=Buffer.alloc(At.span);At.encode({instruction:12,amount:J(i)},m);let p=[P({pubkey:a}),P({pubkey:new ce(t.authority),isWritable:!1}),P({pubkey:l}),P({pubkey:s,isWritable:!1,isSigner:!0}),P({pubkey:n}),P({pubkey:new ce(t.lpVault)}),P({pubkey:o[0]}),P({pubkey:new ce(t.rewardInfos[0].vault)}),P({pubkey:Ko,isWritable:!1}),P({pubkey:xt,isWritable:!1})];for(let d=1;d<t.rewardInfos.length;d++)p.push(P({pubkey:o[d]})),p.push(P({pubkey:new ce(t.rewardInfos[d].vault)}));if(r)for(let d of r)p.push(P({pubkey:d}));return new Je({programId:u,keys:p,data:m})}function wc(c){let{farmInfo:e,farmKeys:t,lpAccount:n,rewardAccounts:o,owner:s,amount:i,userAuxiliaryLedgers:r}=c,[u,a]=[new ce(e.programId),new ce(e.id)],l=V([E("instruction"),k("amount")]),m=[P({pubkey:a}),P({pubkey:new ce(t.authority),isWritable:!1}),P({pubkey:r[0]}),P({pubkey:s,isSigner:!0,isWritable:!1}),P({pubkey:n}),P({pubkey:new ce(t.lpVault)}),P({pubkey:o[0]}),P({pubkey:new ce(t.rewardInfos[0].vault)}),P({pubkey:Ko,isWritable:!1}),P({pubkey:xt,isWritable:!1}),P({pubkey:o[1]}),P({pubkey:new ce(t.rewardInfos[1].vault)})],p=Buffer.alloc(l.span);return l.encode({instruction:2,amount:i},p),new Je({keys:m,programId:u,data:p})}function yi(c){let{farmInfo:e,farmKeys:t,lpAccount:n,rewardAccounts:o,owner:s,amount:i,userAuxiliaryLedgers:r}=c,[u,a]=[new ce(e.programId),new ce(e.id)],l=pt({programId:u,poolId:a,owner:s,version:3}),m=Buffer.alloc(At.span);At.encode({instruction:11,amount:J(i)},m);let p=[P({pubkey:a}),P({pubkey:new ce(t.authority),isWritable:!1}),P({pubkey:l}),P({pubkey:s,isWritable:!1,isSigner:!0}),P({pubkey:n}),P({pubkey:new ce(t.lpVault)}),P({pubkey:o[0]}),P({pubkey:new ce(t.rewardInfos[0].vault)}),P({pubkey:Ko,isWritable:!1}),P({pubkey:xt,isWritable:!1})];if(r)for(let d of r)p.push(P({pubkey:d}));return new Je({programId:u,keys:p,data:m})}function Tc(c){let{farmInfo:e,farmKeys:t,lpAccount:n,rewardAccounts:o,owner:s,amount:i,userAuxiliaryLedgers:r}=c,[u,a]=[new ce(e.programId),new ce(e.id)],l=pt({programId:u,poolId:a,owner:s,version:3}),m=Buffer.alloc(At.span);At.encode({instruction:10,amount:J(i)},m);let p=[P({pubkey:a}),P({pubkey:new ce(t.authority),isWritable:!1}),P({pubkey:l}),P({pubkey:s,isWritable:!1,isSigner:!0}),P({pubkey:n}),P({pubkey:new ce(t.lpVault)}),P({pubkey:o[0]}),P({pubkey:new ce(t.rewardInfos[0].vault)}),P({pubkey:Ko,isWritable:!1}),P({pubkey:xt,isWritable:!1})];if(r)for(let d of r)p.push(P({pubkey:d}));return new Je({programId:u,keys:p,data:m})}function hc(c){let{farmInfo:e,farmKeys:t,lpAccount:n,rewardAccounts:o,owner:s,amount:i,userAuxiliaryLedgers:r}=c,[u,a]=[new ce(e.programId),new ce(e.id)],l=pt({programId:u,poolId:a,owner:s,version:5}),m=Buffer.alloc(At.span);At.encode({instruction:11,amount:J(i)},m);let p=[P({pubkey:a}),P({pubkey:new ce(t.authority),isWritable:!1}),P({pubkey:l}),P({pubkey:s,isWritable:!1,isSigner:!0}),P({pubkey:n}),P({pubkey:new ce(t.lpVault)}),P({pubkey:o[0]}),P({pubkey:new ce(t.rewardInfos[0].vault)}),P({pubkey:Ko,isWritable:!1}),P({pubkey:xt,isWritable:!1})];for(let d=1;d<t.rewardInfos.length;d++)p.push(P({pubkey:o[d]})),p.push(P({pubkey:new ce(t.rewardInfos[d].vault)}));if(r)for(let d of r)p.push(P({pubkey:d}));return new Je({programId:u,keys:p,data:m})}function Ic(c){let{farmInfo:e,farmKeys:t,lpAccount:n,rewardAccounts:o,owner:s,amount:i}=c,[r,u]=[new ce(e.programId),new ce(e.id)],a=pt({programId:r,poolId:u,owner:s,version:6}),l=Buffer.alloc(At.span);At.encode({instruction:1,amount:J(i)},l);let m=[P({pubkey:xt,isWritable:!1}),P({pubkey:Zn.programId,isWritable:!1}),P({pubkey:u}),P({pubkey:new ce(t.authority),isWritable:!1}),P({pubkey:new ce(t.lpVault)}),P({pubkey:a}),P({pubkey:s,isWritable:!1,isSigner:!0}),P({pubkey:n})];for(let p=0;p<t.rewardInfos.length;p++)m.push(P({pubkey:new ce(t.rewardInfos[p].vault)})),m.push(P({pubkey:o[p]}));return new Je({programId:r,keys:m,data:l})}var bi=class extends Fe{async _getUserRewardInfo({payer:e,rewardInfo:t}){if(t.mint.equals(rt)){let n=await Mn({connection:this.scope.connection,owner:this.scope.ownerPubKey,payer:e,amount:ca(q(v({},t),{openTime:t.openTime.toString(),endTime:t.endTime.toString()}))});return{rewardPubKey:n.addresses.newAccount,newInstruction:n}}return{rewardPubKey:await this.scope.account.getCreatedTokenAccount({mint:t.mint,associatedOnly:!1})}}async create({poolInfo:e,rewardInfos:t,payer:n,programId:o=Po,txVersion:s,feePayer:i,lockProgram:r}){var S,x;this.checkDisabled(),this.scope.checkOwner();let a={lpMint:new Be(e.lpMint.address),lockInfo:{lockMint:(S=r==null?void 0:r.mint)!=null?S:pc,lockVault:(x=r==null?void 0:r.vault)!=null?x:fc},version:6,rewardInfos:t,programId:o},l=this.createTxBuilder(i),m=n!=null?n:this.scope.ownerPubKey,p=Qe({fromPublicKey:m,programId:a.programId}),d=await this.scope.connection.getMinimumBalanceForRentExemption(ai.span);l.addInstruction({instructions:[Ud.createAccountWithSeed({fromPubkey:m,basePubkey:m,seed:p.seed,newAccountPubkey:p.publicKey,lamports:d,space:ai.span,programId:a.programId})]});let{publicKey:f,nonce:y}=gc({programId:new Be(a.programId),poolId:p.publicKey}),b=li({programId:a.programId,poolId:p.publicKey,mint:a.lpMint,type:"lpVault"}),g=[],A=[];for(let K of a.rewardInfos){K.openTime>=K.endTime&&this.logAndCreateError("start time error","rewardInfo.rewardOpenTime",K.openTime.toString()),isNaN(Fn[K.rewardType])&&this.logAndCreateError("rewardType error",K.rewardType),Number(K.perSecond)<=0&&this.logAndCreateError("rewardPerSecond error",K.perSecond),g.push(Ac(K));let{rewardPubKey:B,newInstruction:C}=await this._getUserRewardInfo({rewardInfo:K,payer:m});C&&l.addInstruction(C),B||this.logAndCreateError("cannot found target token accounts",this.scope.account.tokenAccounts);let O=K.mint.equals(rt)?new Be(it.address):K.mint;A.push({rewardMint:O,rewardVault:li({programId:a.programId,poolId:p.publicKey,mint:O,type:"rewardVault"}),userRewardToken:B})}let{account:h,instructionParams:I}=await this.scope.account.getOrCreateTokenAccount({mint:new Be(a.lockInfo.lockMint),owner:this.scope.ownerPubKey,skipCloseAccount:!1,createInfo:{payer:this.scope.ownerPubKey,amount:0},associatedOnly:!1});I&&l.addInstruction(I),h||this.logAndCreateError("cannot found lock vault","tokenAccounts",this.scope.account.tokenAccounts);let{instruction:T,instructionType:w}=Pc({farmId:p.publicKey,owner:this.scope.ownerPubKey,farmAuthority:f,lpVault:b,lpMint:a.lpMint,lockVault:a.lockInfo.lockVault,lockMint:a.lockInfo.lockMint,lockUserAccount:h,programId:a.programId,rewardInfo:A,rewardInfoConfig:g,nonce:y});return l.addInstruction({instructions:[T],instructionTypes:[w]}).versionBuild({txVersion:s,extInfo:{farmId:p.publicKey,farmAuthority:f,lpVault:b,lockUserAccount:h,nonce:y}})}async restartReward({farmInfo:e,payer:t,newRewardInfo:n,txVersion:o,feePayer:s}){var g;let i=Et[e.programId];i!==6&&this.logAndCreateError("invalid farm version ",i);let r=Me((await this.scope.api.fetchFarmKeysById({ids:e.id}))[0]),u={id:r.id,rewardInfos:e.rewardInfos,lpVault:r.lpVault,programId:r.programId};n.openTime>=n.endTime&&this.logAndCreateError("start time error","newRewardInfo",n);let a=t||this.scope.ownerPubKey,l=n.mint.equals(rt)?new Be(it.address):n.mint,m=u.rewardInfos.findIndex(A=>new Be(A.mint.address).equals(l)),p=r.rewardInfos[m];p||this.logAndCreateError("configuration does not exist","rewardMint",l);let d=(g=p.vault)!=null?g:rt,f=this.createTxBuilder(s),{rewardPubKey:y,newInstruction:b}=await this._getUserRewardInfo({rewardInfo:n,payer:a});return b&&f.addInstruction(b),y||this.logAndCreateError("cannot found target token accounts",this.scope.account.tokenAccounts),f.addInstruction({instructions:[ma({payer:this.scope.ownerPubKey,rewardVault:d,userRewardTokenPub:y,farmKeys:u,rewardInfo:n})],instructionTypes:[U.FarmV6Restart]}).versionBuild({txVersion:o})}async restartRewards({farmInfo:e,payer:t,newRewardInfos:n,txVersion:o,feePayer:s}){var m;let i=Et[e.programId];i!==6&&this.logAndCreateError("invalid farm version ",i);let r=Me((await this.scope.api.fetchFarmKeysById({ids:e.id}))[0]),u={id:r.id,rewardInfos:e.rewardInfos,lpVault:r.lpVault,programId:r.programId};n.forEach(p=>{p.openTime>=p.endTime&&this.logAndCreateError("start time error","newRewardInfo",p)});let a=t||this.scope.ownerPubKey,l=this.createTxBuilder(s);for(let p of n){let d=p.mint.equals(rt)?new Be(it.address):p.mint,f=u.rewardInfos.findIndex(I=>new Be(I.mint.address).equals(d)),y=r.rewardInfos[f];y||this.logAndCreateError("configuration does not exist","rewardMint",d);let b=(m=y.vault)!=null?m:rt,{rewardPubKey:g,newInstruction:A}=await this._getUserRewardInfo({rewardInfo:p,payer:a});A&&l.addInstruction(A),g||this.logAndCreateError("cannot found target token accounts",this.scope.account.tokenAccounts);let h=ma({payer:this.scope.ownerPubKey,rewardVault:b,userRewardTokenPub:g,farmKeys:u,rewardInfo:p});l.addInstruction({instructions:[h],instructionTypes:[U.FarmV6Restart]})}return l.versionBuild({txVersion:o})}async addNewRewardToken(e){let{txVersion:t,farmInfo:n,newRewardInfo:o,payer:s,feePayer:i}=e,r=Et[n.programId];r!==6&&this.logAndCreateError("invalid farm version ",r);let u=Me((await this.scope.api.fetchFarmKeysById({ids:n.id}))[0]),a=s!=null?s:this.scope.ownerPubKey,l=this.createTxBuilder(i),m=o.mint.equals(rt)?new Be(it.address):o.mint,p=li({programId:new Be(n.programId),poolId:new Be(n.id),mint:m,type:"rewardVault"}),{rewardPubKey:d,newInstruction:f}=await this._getUserRewardInfo({rewardInfo:o,payer:a});return f&&l.addInstruction(f),d||this.logAndCreateError("annot found target token accounts",this.scope.account.tokenAccounts),o.mint=m,l.addInstruction({instructions:[da({payer:this.scope.ownerPubKey,userRewardTokenPub:d,farmKeys:u,rewardVault:p,rewardInfo:o})],instructionTypes:[U.FarmV6CreatorAddReward]}).versionBuild({txVersion:t})}async addNewRewardsToken(e){let{txVersion:t,farmInfo:n,newRewardInfos:o,payer:s,feePayer:i}=e,r=Et[n.programId];r!==6&&this.logAndCreateError("invalid farm version ",r);let u=Me((await this.scope.api.fetchFarmKeysById({ids:n.id}))[0]),a=s!=null?s:this.scope.ownerPubKey,l=this.createTxBuilder(i);for(let m of o){let p=m.mint.equals(rt)?new Be(it.address):m.mint,d=li({programId:new Be(n.programId),poolId:new Be(n.id),mint:p,type:"rewardVault"}),{rewardPubKey:f,newInstruction:y}=await this._getUserRewardInfo({rewardInfo:m,payer:a});y&&l.addInstruction(y),f||this.logAndCreateError("cannot found target token accounts",this.scope.account.tokenAccounts);let b=da({payer:this.scope.ownerPubKey,userRewardTokenPub:f,farmKeys:u,rewardVault:d,rewardInfo:q(v({},m),{mint:p})});l.addInstruction({instructions:[b],instructionTypes:[U.FarmV6CreatorAddReward]})}return l.versionBuild({txVersion:t})}async deposit(e){let{txVersion:t,farmInfo:n,amount:o,feePayer:s,useSOLBalance:i,associatedOnly:r=!0,checkCreateATAOwner:u=!1,userAuxiliaryLedgers:a,computeBudgetConfig:l,txTipConfig:m}=e;this.scope.availability.addFarm===!1&&this.logAndCreateError("farm deposit feature disabled in your region");let{rewardInfos:p,programId:d}=n,f=Et[d];f===4&&this.logAndCreateError("V4 has suspended deposits:",n.programId),ta(f)||this.logAndCreateError("invalid farm program:",n.programId);let[y,b]=[new Be(n.programId),new Be(n.id)],g=(await this.scope.api.fetchFarmKeysById({ids:n.id}))[0],A=pt({programId:y,poolId:b,owner:this.scope.ownerPubKey,version:f}),h=this.createTxBuilder(s);h.addCustomComputeBudget(l),h.addTipInstruction(m);let I={};for(let L of this.scope.account.tokenAccounts)if(r){let R=H(this.scope.ownerPubKey,L.mint,L.programId).publicKey;L.publicKey&&R.equals(L.publicKey)&&(I[L.mint.toString()]=L.publicKey)}else I[L.mint.toString()]=L.publicKey;let T=g.lpMint,w=I[T.address];w||this.logAndCreateError("you don't have any lp","lp zero",I);let S=[];for(let L of p){let R=i&&L.mint.address===Z.toString(),_=I[L.mint.address];if(!_){let{account:X,instructionParams:j}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:L.mint.programId,mint:new Be(L.mint.address),notUseTokenAccount:R,createInfo:{payer:s||this.scope.ownerPubKey,amount:0},owner:this.scope.ownerPubKey,skipCloseAccount:!R,associatedOnly:R?!1:r,checkCreateATAOwner:u});_=X,j&&h.addInstruction(j)}I[L.mint.address]=_,S.push(_)}let x,K=await this.scope.connection.getAccountInfo(A);if(K&&(x=So(f).decode(K.data)),n.programId!==Po.toString()&&n.programId!==An.FARM_PROGRAM_ID_V6.toString()&&!x){let{instruction:L,instructionType:R}=di({id:b,programId:y,version:f,ledger:A,owner:this.scope.ownerPubKey});h.addInstruction({instructions:[L],instructionTypes:[R]})}let B=na({version:f,rewardInfos:p,rewardTokenAccountsPublicKeys:S});B&&this.logAndCreateError(B);let C={amount:J(o),owner:this.scope.ownerPubKey,farmInfo:n,farmKeys:g,lpAccount:w,rewardAccounts:S,userAuxiliaryLedgers:a==null?void 0:a.map(L=>new Be(L))},O=f===6?Ic(C):f===5?hc(C):Tc(C),M={3:U.FarmV3Deposit,5:U.FarmV5Deposit,6:U.FarmV6Deposit};return h.addInstruction({instructions:[O],instructionTypes:[M[f]]}).versionBuild({txVersion:t})}async withdraw(e){let{txVersion:t,farmInfo:n,amount:o,deposited:s,useSOLBalance:i,feePayer:r,associatedOnly:u=!0,checkCreateATAOwner:a=!1,userAuxiliaryLedgers:l,computeBudgetConfig:m,txTipConfig:p}=e,{rewardInfos:d}=n;this.scope.availability.removeFarm===!1&&this.logAndCreateError("farm withdraw feature disabled in your region");let f=Et[n.programId];ta(f)||this.logAndCreateError("invalid farm program:",n.programId);let y=(await this.scope.api.fetchFarmKeysById({ids:n.id}))[0],b=this.createTxBuilder(r);b.addCustomComputeBudget(m),b.addTipInstruction(p);let g={};for(let B of this.scope.account.tokenAccounts)if(u){let C=H(this.scope.ownerPubKey,B.mint).publicKey;B.publicKey&&C.equals(B.publicKey)&&(g[B.mint.toString()]=B.publicKey)}else g[B.mint.toString()]=B.publicKey;if(f!==4){let B=pt({programId:new Be(n.programId),poolId:new Be(n.id),owner:this.scope.ownerPubKey,version:f}),C=await this.scope.connection.getAccountInfo(B);if(C)So(f).decode(C.data).deposited.isZero()&&this.logAndCreateError("no deposited lp",{farmId:n.id});else if(f!==6){let{instruction:O,instructionType:M}=di({id:new Be(y.id),programId:new Be(y.programId),version:f,ledger:B,owner:this.scope.ownerPubKey});b.addInstruction({instructions:[O],instructionTypes:[M]})}}s&&s.isZero()&&!(l||[]).length&&this.logAndCreateError("no deposited lp",{farmId:n.id});let A=y.lpMint.address,h=i&&A===Z.toString(),I=g[A.toString()];if(!I){let{account:B,instructionParams:C}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:y.lpMint.programId,mint:new Be(A),notUseTokenAccount:h,createInfo:{payer:r||this.scope.ownerPubKey,amount:0},owner:this.scope.ownerPubKey,skipCloseAccount:!0,associatedOnly:h?!1:u,checkCreateATAOwner:a});I=B,C&&b.addInstruction(C)}g[A.toString()]=I;let T=[];for(let B of d){let C=i&&B.mint.address===Z.toString(),O=g[B.mint.address];if(!O){let{account:M,instructionParams:L}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:B.mint.programId,mint:new Be(B.mint.address),notUseTokenAccount:C,createInfo:{payer:r||this.scope.ownerPubKey,amount:0},owner:this.scope.ownerPubKey,skipCloseAccount:!C,associatedOnly:C?!1:u,checkCreateATAOwner:a});O=M,L&&b.addInstruction(L)}g[B.mint.address]=O,T.push(O)}let w=na({version:f,rewardInfos:d,rewardTokenAccountsPublicKeys:T});w&&this.logAndCreateError(w);let S={amount:J(o),owner:this.scope.ownerPubKey,farmInfo:n,farmKeys:y,lpAccount:I,rewardAccounts:T,userAuxiliaryLedgers:l==null?void 0:l.map(B=>new Be(B))},x=f===6?pi(S):f===5?fi(S):f===4?wc(S):yi(S),K={3:U.FarmV3Withdraw,4:U.FarmV4Withdraw,5:U.FarmV5Withdraw,6:U.FarmV6Withdraw};return b.addInstruction({instructions:[x],instructionTypes:[K[f]]}).versionBuild({txVersion:t})}async withdrawFarmReward({farmInfo:e,withdrawMint:t,txVersion:n,computeBudgetConfig:o,txTipConfig:s,feePayer:i}){var y;this.scope.checkOwner();let r=Me((await this.scope.api.fetchFarmKeysById({ids:e.id}))[0]),u=Et[e.programId];u!==6&&this.logAndCreateError("invalid farm version",u);let a=r.rewardInfos.find(b=>dt(b.mint.address).equals(dt(t)));a||this.logAndCreateError("withdraw mint error","rewardInfos",e);let l=(y=a==null?void 0:a.vault)!=null?y:rt,m=this.createTxBuilder(i),p;if(t.equals(rt)||t.equals(Be.default)){let b=await Mn({connection:this.scope.connection,owner:this.scope.ownerPubKey,payer:this.scope.ownerPubKey,amount:ca(q(v({},a),{openTime:a.openTime,endTime:a.endTime,perSecond:new Gd(a.perSecond).mul(10**a.mint.decimals).toString()}))});p=b.addresses.newAccount,m.addInstruction(b)}else{let b=await this.scope.account.getCreatedTokenAccount({mint:t});b===null?(p=await this.scope.account.getAssociatedTokenAccount(t),m.addInstruction({instructions:[Bc(this.scope.ownerPubKey,p,this.scope.ownerPubKey,t)],instructionTypes:[U.CreateATA]})):p=b}let{instruction:d,instructionType:f}=kc({programId:r.programId,id:r.id,authority:r.authority,lpVault:r.lpVault,rewardVault:l,userRewardToken:p,owner:this.scope.ownerPubKey});return m.addCustomComputeBudget(o),m.addTipInstruction(s),m.addInstruction({instructions:[d],instructionTypes:[f]}).versionBuild({txVersion:n})}async harvestAllRewards(e){let{farmInfoList:t,useSOLBalance:n,feePayer:o,associatedOnly:s=!0,checkCreateATAOwner:i=!1,userAuxiliaryLedgers:r,txVersion:u,computeBudgetConfig:a}=e,l=this.createTxBuilder(o),m={};for(let f of this.scope.account.tokenAccounts)if(s){let y=H(this.scope.ownerPubKey,f.mint).publicKey;f.publicKey&&y.equals(f.publicKey)&&(m[f.mint.toString()]=f.publicKey)}else m[f.mint.toString()]=f.publicKey;let d=(await this.scope.api.fetchFarmKeysById({ids:Object.values(t).map(f=>f.id).join(",")})).reduce((f,y)=>q(v({},f),{[y.id]:y}),{});for(let f of Object.values(t)){let{programId:y,lpMint:b,rewardInfos:g,id:A}=f,h=Et[y],I=b.address,T=n&&I===Z.toString(),w=m[I];if(!w){let{account:O,instructionParams:M}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:b.programId,mint:new Be(I),notUseTokenAccount:T,createInfo:{payer:o||this.scope.ownerPubKey,amount:0},owner:this.scope.ownerPubKey,skipCloseAccount:!0,associatedOnly:T?!1:s,checkCreateATAOwner:i});w=O,M&&l.addInstruction(M)}m[I.toString()]=w;let S=[];for(let O of g){let M=n&&O.mint.address===Z.toString(),L=m[O.mint.address];if(!L)if(M){let{account:R,instructionParams:_}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:O.mint.programId,mint:new Be(O.mint.address),notUseTokenAccount:M,createInfo:{payer:o||this.scope.ownerPubKey,amount:0},owner:this.scope.ownerPubKey,skipCloseAccount:!M,associatedOnly:M?!1:s,checkCreateATAOwner:i});L=R,_&&l.addInstruction(_)}else{let R=new Be(O.mint.address);L=this.scope.account.getAssociatedTokenAccount(R),l.addInstruction({instructions:[Bc(this.scope.ownerPubKey,L,this.scope.ownerPubKey,R)]})}m[O.mint.address]=L,S.push(L)}let x=d[A],K={amount:ht,owner:this.scope.ownerPubKey,farmInfo:f,farmKeys:x,lpAccount:w,rewardAccounts:S,userAuxiliaryLedgers:r==null?void 0:r.map(O=>new Be(O))},B=h===6?pi(K):h===5?fi(K):yi(K),C={3:U.FarmV3Withdraw,5:U.FarmV5Withdraw,6:U.FarmV6Withdraw};l.addInstruction({instructions:[B],instructionTypes:[C[h]]})}return u===1?l.sizeCheckBuild({computeBudgetConfig:a}):l.sizeCheckBuildV0({computeBudgetConfig:a})}};import{PublicKey as Ze}from"@solana/web3.js";import{AccountLayout as Np,NATIVE_MINT as Dr,TOKEN_PROGRAM_ID as _n}from"@solana/spl-token";import{Keypair as Or,PublicKey as G,SystemProgram as Bn,TransactionInstruction as mt}from"@solana/web3.js";import Ia from"bn.js";import{ASSOCIATED_TOKEN_PROGRAM_ID as Ii,TOKEN_2022_PROGRAM_ID as Ue,TOKEN_PROGRAM_ID as Se}from"@solana/spl-token";import tp from"bn.js";import Lo from"decimal.js";import Dt from"bn.js";var be=new Dt(0),Lt=new Dt(1),Tn=new Dt(-1),et=new Dt(1).shln(64),xr=new Dt(1).shln(128),gi=et.sub(Lt),Ai=64,xc=xr.subn(1),ft=-443636,Pt=-ft,Wt=new Dt("4295048016"),qt=new Dt("79226673521066979257578248091"),Sr=new Dt("4295048017"),Kr=new Dt("79226673521066979257578248090"),Sc=16,Kc="59543866431248",Cc="184467440737095516",Rc="15793534762490258745",Cr=new Dt(10).pow(new Dt(6)),Xd=(n=>(n[n.rate_500=500]="rate_500",n[n.rate_3000=3e3]="rate_3000",n[n.rate_10000=1e4]="rate_10000",n))(Xd||{}),hw={[500]:10,[3e3]:60,[1e4]:200},Iw={version:6,liquidity:be,tickCurrent:0,feeGrowthGlobalX64A:be,feeGrowthGlobalX64B:be,protocolFeesTokenA:be,protocolFeesTokenB:be,swapInAmountTokenA:be,swapOutAmountTokenB:be,swapInAmountTokenB:be,swapOutAmountTokenA:be,tickArrayBitmap:[],rewardInfos:[],day:{volume:0,volumeFee:0,feeA:0,feeB:0,feeApr:0,rewardApr:{A:0,B:0,C:0},apr:0,priceMax:0,priceMin:0},week:{volume:0,volumeFee:0,feeA:0,feeB:0,feeApr:0,rewardApr:{A:0,B:0,C:0},apr:0,priceMax:0,priceMin:0},month:{volume:0,volumeFee:0,feeA:0,feeB:0,feeApr:0,rewardApr:{A:0,B:0,C:0},apr:0,priceMax:0,priceMin:0},tvl:0},Lc={tvl:0,volumeQuote:0,mintAmountA:0,mintAmountB:0,rewardDefaultInfos:[],farmUpcomingCount:0,farmOngoingCount:0,farmFinishedCount:0,day:{volume:0,volumeQuote:0,volumeFee:0,apr:0,feeApr:0,priceMin:0,priceMax:0,rewardApr:[0]},week:{volume:0,volumeQuote:0,volumeFee:0,apr:0,feeApr:0,priceMin:0,priceMax:0,rewardApr:[0]},month:{volume:0,volumeQuote:0,volumeFee:0,apr:0,feeApr:0,priceMin:0,priceMax:0,rewardApr:[0]},pooltype:[]},Bw=new Dt("18446744073700000000");import pe from"bn.js";import dn from"decimal.js";function Rr(c){let e=new ArrayBuffer(2);return new DataView(e).setUint16(0,c,!1),new Uint8Array(e)}function Sw(c){let e=new ArrayBuffer(2);return new DataView(e).setInt16(0,c,!1),new Uint8Array(e)}function Kw(c){let e=new ArrayBuffer(4);return new DataView(e).setUint32(0,c,!1),new Uint8Array(e)}function Lr(c){let e=new ArrayBuffer(4);return new DataView(e).setInt32(0,c,!1),new Uint8Array(e)}function pa(c,e){let t=0;for(let n=c-1;n>=0&&!e.testn(n);n--)t++;return t}function fa(c,e){let t=0;for(let n=0;n<c&&!e.testn(n);n++)t++;return t}function Pi(c,e){for(let t=0;t<c;t++)if(e.testn(t))return!1;return!0}function Oc(c,e){return Pi(c,e)?null:pa(c,e)}function Nc(c,e){return Pi(c,e)?null:fa(c,e)}var zd=Buffer.from("amm_config","utf8"),ya=Buffer.from("pool","utf8"),ba=Buffer.from("pool_vault","utf8"),Qd=Buffer.from("pool_reward_vault","utf8"),Mc=Buffer.from("position","utf8"),Yd=Buffer.from("tick_array","utf8"),jd=Buffer.from("operation","utf8"),Hd=Buffer.from("pool_tick_array_bitmap_extension","utf8"),Zd=Buffer.from("observation","utf8");function Ow(c,e){return ne([zd,Rr(e)],c)}function vc(c,e,t,n){return ne([ya,e.toBuffer(),t.toBuffer(),n.toBuffer()],c)}function ga(c,e,t){return ne([ba,e.toBuffer(),t.toBuffer()],c)}function Fc(c,e,t){return ne([Qd,e.toBuffer(),t.toBuffer()],c)}function ge(c,e,t){return ne([Yd,e.toBuffer(),Lr(t)],c)}function on(c,e,t,n){return ne([Mc,e.toBuffer(),Lr(t),Lr(n)],c)}function kt(c,e){return ne([Mc,e.toBuffer()],c)}function hn(c){return ne([Buffer.from("metadata","utf8"),Zt.toBuffer(),c.toBuffer()],Zt)}function ki(c){return ne([jd],c)}function Ye(c,e){return ne([Hd,e.toBuffer()],c)}function Vc(c,e){return ne([Zd,e.toBuffer()],c)}var _c=Buffer.from("locked_position","utf8");function Aa(c,e){return ne([_c,e.toBuffer()],c)}function Co(c,e){return ne([_c,e.toBuffer()],c)}var $d=Buffer.from("support_mint","utf8");function Pa(c,e){return ne([$d,e.toBuffer()],c)}import{PublicKey as Ot}from"@solana/web3.js";import{TOKEN_2022_PROGRAM_ID as Ec}from"@solana/spl-token";import _e from"bn.js";import Pe from"decimal.js";import mn from"bn.js";import ka from"decimal.js";var wi=class{static getfeeGrowthInside(e,t,n){let o=new mn(0),s=new mn(0);e.tickCurrent>=t.tick?(o=t.feeGrowthOutsideX64A,s=t.feeGrowthOutsideX64B):(o=e.feeGrowthGlobalX64A.sub(t.feeGrowthOutsideX64A),s=e.feeGrowthGlobalX64B.sub(t.feeGrowthOutsideX64B));let i=new mn(0),r=new mn(0);e.tickCurrent<n.tick?(i=n.feeGrowthOutsideX64A,r=n.feeGrowthOutsideX64B):(i=e.feeGrowthGlobalX64A.sub(n.feeGrowthOutsideX64A),r=e.feeGrowthGlobalX64B.sub(n.feeGrowthOutsideX64B));let u=le.wrappingSubU128(le.wrappingSubU128(e.feeGrowthGlobalX64A,o),i),a=le.wrappingSubU128(le.wrappingSubU128(e.feeGrowthGlobalX64B,s),r);return{feeGrowthInsideX64A:u,feeGrowthInsideBX64:a}}static GetPositionFees(e,t,n,o){let{feeGrowthInsideX64A:s,feeGrowthInsideBX64:i}=this.getfeeGrowthInside(e,n,o),r=le.mulDivFloor(le.wrappingSubU128(s,t.feeGrowthInsideLastX64A),t.liquidity,et),u=t.tokenFeesOwedA.add(r),a=le.mulDivFloor(le.wrappingSubU128(i,t.feeGrowthInsideLastX64B),t.liquidity,et),l=t.tokenFeesOwedB.add(a);return{tokenFeeAmountA:u,tokenFeeAmountB:l}}static GetPositionFeesV2(e,t,n,o){let{feeGrowthInsideX64A:s,feeGrowthInsideBX64:i}=this.getfeeGrowthInside(e,n,o),r=le.mulDivFloor(le.wrappingSubU128(s,t.feeGrowthInsideLastX64A),t.liquidity,et),u=t.tokenFeesOwedA.add(r),a=le.mulDivFloor(le.wrappingSubU128(i,t.feeGrowthInsideLastX64B),t.liquidity,et),l=t.tokenFeesOwedB.add(a);return{tokenFeeAmountA:u,tokenFeeAmountB:l}}static GetPositionRewardsV2(e,t,n,o){let s=[],i=this.getRewardGrowthInsideV2(e.tickCurrent,n,o,e.rewardInfos);for(let r=0;r<i.length;r++){let u=i[r],a=t.rewardInfos[r],l=le.wrappingSubU128(u,a.growthInsideLastX64),m=le.mulDivFloor(l,t.liquidity,et),p=a.rewardAmountOwed.add(m);s.push(p)}return s}static GetPositionRewards(e,t,n,o){let s=[],i=this.getRewardGrowthInside(e.tickCurrent,n,o,e.rewardInfos);for(let r=0;r<i.length;r++){let u=i[r],a=t.rewardInfos[r],l=le.wrappingSubU128(u,a.growthInsideLastX64),m=le.mulDivFloor(l,t.liquidity,et),p=a.rewardAmountOwed.add(m);s.push(p)}return s}static getRewardGrowthInside(e,t,n,o){let s=[];for(let i=0;i<o.length;i++){let r=new mn(0);t.liquidityGross.eqn(0)?r=o[i].rewardGrowthGlobalX64:e<t.tick?r=o[i].rewardGrowthGlobalX64.sub(t.rewardGrowthsOutsideX64[i]):r=t.rewardGrowthsOutsideX64[i];let u=new mn(0);n.liquidityGross.eqn(0)||(e<n.tick?u=n.rewardGrowthsOutsideX64[i]:u=o[i].rewardGrowthGlobalX64.sub(n.rewardGrowthsOutsideX64[i])),s.push(le.wrappingSubU128(le.wrappingSubU128(o[i].rewardGrowthGlobalX64,r),u))}return s}static getRewardGrowthInsideV2(e,t,n,o){let s=[];for(let i=0;i<o.length;i++){let r=new mn(0);t.liquidityGross.eqn(0)?r=o[i].rewardGrowthGlobalX64:e<t.tick?r=o[i].rewardGrowthGlobalX64.sub(t.rewardGrowthsOutsideX64[i]):r=t.rewardGrowthsOutsideX64[i];let u=new mn(0);n.liquidityGross.eqn(0)||(e<n.tick?u=n.rewardGrowthsOutsideX64[i]:u=o[i].rewardGrowthGlobalX64.sub(n.rewardGrowthsOutsideX64[i])),s.push(le.wrappingSubU128(le.wrappingSubU128(o[i].rewardGrowthGlobalX64,r),u))}return s}static getAmountsFromLiquidity({poolInfo:e,ownerPosition:t,liquidity:n,slippage:o,add:s,epochInfo:i}){var b,g,A,h;let r=re.priceToSqrtPriceX64(new ka(e.price),e.mintA.decimals,e.mintB.decimals),u=re.getSqrtPriceX64FromTick(t.tickLower),a=re.getSqrtPriceX64FromTick(t.tickUpper),l=s?1+o:1-o,m=Ae.getAmountsFromLiquidity(r,u,a,n,s),[p,d]=[Te(m.amountA,(b=e.mintA.extensions)==null?void 0:b.feeConfig,i,!0),Te(m.amountB,(g=e.mintB.extensions)==null?void 0:g.feeConfig,i,!0)],[f,y]=[Te(new mn(new ka(m.amountA.toString()).mul(l).toFixed(0)),(A=e.mintA.extensions)==null?void 0:A.feeConfig,i,!0),Te(new mn(new ka(m.amountB.toString()).mul(l).toFixed(0)),(h=e.mintB.extensions)==null?void 0:h.feeConfig,i,!0)];return{liquidity:n,amountA:p,amountB:d,amountSlippageA:f,amountSlippageB:y,expirationTime:Jt(p.expirationTime,d.expirationTime)}}};var Jd=15,ke=class{static async getTickArrays(e,t,n,o,s,i,r){let u=[],a=$.getTickArrayStartIndexByTick(o,s),l=$.getInitializedTickArrayInRange(i,r,s,a,Math.floor(Jd/2));for(let d=0;d<l.length;d++){let{publicKey:f}=ge(t,n,l[d]);u.push(f)}let m=(await Ht(e,u)).map(d=>d!==null?Ti.decode(d.data):null),p={};for(let d=0;d<u.length;d++){let f=m[d];f!==null&&(p[f.startTickIndex]=q(v({},f),{address:u[d]}))}return p}static nextInitializedTick(e,t,n,o,s,i){let{initializedTick:r,tickArrayAddress:u,tickArrayStartTickIndex:a}=this.nextInitializedTickInOneArray(e,t,n,o,s,i);for(;r==null||r.liquidityGross.lten(0);){if(a=$.getNextTickArrayStartIndex(a,s,i),this.checkIsValidStartIndex(a,s))throw new Error("No enough initialized tickArray");let l=n[a];if(l===void 0)continue;let{nextTick:m,tickArrayAddress:p,tickArrayStartTickIndex:d}=this.firstInitializedTickInOneArray(e,t,l,i);[r,u,a]=[m,p,d]}if(r==null)throw new Error("No invaild tickArray cache");return{nextTick:r,tickArrayAddress:u,tickArrayStartTickIndex:a}}static nextInitializedTickArray(e,t,n,o,s){let i=Math.floor(e/ke.tickCount(t)),r=n?$.searchLowBitFromStart(o,s,i-1,1,t):$.searchHightBitFromStart(o,s,i+1,1,t);return r.length>0?{isExist:!0,nextStartIndex:r[0]}:{isExist:!1,nextStartIndex:0}}static firstInitializedTickInOneArray(e,t,n,o){let s;if(o){let r=tt-1;for(;r>=0;){let u=n.ticks[r];if(u.liquidityGross.gtn(0)){s=u;break}r=r-1}}else{let r=0;for(;r<tt;){let u=n.ticks[r];if(u.liquidityGross.gtn(0)){s=u;break}r=r+1}}let{publicKey:i}=ge(e,t,n.startTickIndex);return{nextTick:s,tickArrayAddress:i,tickArrayStartTickIndex:n.startTickIndex}}static nextInitializedTickInOneArray(e,t,n,o,s,i){let r=$.getTickArrayStartIndexByTick(o,s),u=Math.floor((o-r)/s),a=n[r];if(a==null)return{initializedTick:void 0,tickArrayAddress:void 0,tickArrayStartTickIndex:r};let l;if(i)for(;u>=0;){let p=a.ticks[u];if(p.liquidityGross.gtn(0)){l=p;break}u=u-1}else for(u=u+1;u<tt;){let p=a.ticks[u];if(p.liquidityGross.gtn(0)){l=p;break}u=u+1}let{publicKey:m}=ge(e,t,r);return{initializedTick:l,tickArrayAddress:m,tickArrayStartTickIndex:a.startTickIndex}}static getArrayStartIndex(e,t){let n=this.tickCount(t);return Math.floor(e/n)*n}static checkIsValidStartIndex(e,t){if($.checkIsOutOfBoundary(e)){if(e>Pt)return!1;let n=$.getTickArrayStartIndexByTick(ft,t);return e==n}return e%this.tickCount(t)==0}static tickCount(e){return tt*e}};var wa=14,In=class{static maxTickInTickarrayBitmap(e){return e*tt*$n}static getBitmapTickBoundary(e,t){let n=this.maxTickInTickarrayBitmap(t),o=Math.floor(Math.abs(e)/n);e<0&&Math.abs(e)%n!=0&&(o+=1);let s=n*o;return e<0?{minValue:-s,maxValue:-s+n}:{minValue:s,maxValue:s+n}}static nextInitializedTickArrayStartIndex(e,t,n,o){if(!ke.checkIsValidStartIndex(t,n))throw Error("nextInitializedTickArrayStartIndex check error");let s=this.maxTickInTickarrayBitmap(n),i=o?t-ke.tickCount(n):t+ke.tickCount(n);if(i<-s||i>=s)return{isInit:!1,tickIndex:t};let r=n*tt,u=i/r+512;i<0&&i%r!=0&&u--;let a=Math.abs(u);if(o){let l=e.shln(1024-a-1),m=Oc(1024,l);if(m!==null){let p=(a-m-512)*r;return{isInit:!0,tickIndex:p}}else return{isInit:!1,tickIndex:-s}}else{let l=e.shrn(a),m=Nc(1024,l);if(m!==null){let p=(a+m-512)*r;return{isInit:!0,tickIndex:p}}else return{isInit:!1,tickIndex:s-ke.tickCount(n)}}}},hi=class{static getBitmapOffset(e,t){if(!ke.checkIsValidStartIndex(e,t))throw new Error("No enough initialized tickArray");this.checkExtensionBoundary(e,t);let n=In.maxTickInTickarrayBitmap(t),o=Math.floor(Math.abs(e)/n)-1;return e<0&&Math.abs(e)%n===0&&o--,o}static getBitmap(e,t,n){let o=this.getBitmapOffset(e,t);return e<0?{offset:o,tickarrayBitmap:n.negativeTickArrayBitmap[o]}:{offset:o,tickarrayBitmap:n.positiveTickArrayBitmap[o]}}static checkExtensionBoundary(e,t){let{positiveTickBoundary:n,negativeTickBoundary:o}=this.extensionTickBoundary(t);if(e>=o&&e<n)throw Error("checkExtensionBoundary -> InvalidTickArrayBoundary")}static extensionTickBoundary(e){let t=In.maxTickInTickarrayBitmap(e),n=-t;if(Pt<=t)throw Error(`extensionTickBoundary check error: ${Pt}, ${t}`);if(n<=ft)throw Error(`extensionTickBoundary check error: ${n}, ${ft}`);return{positiveTickBoundary:t,negativeTickBoundary:n}}static checkTickArrayIsInit(e,t,n){let{tickarrayBitmap:o}=this.getBitmap(e,t,n),s=this.tickArrayOffsetInBitmap(e,t);return{isInitialized:$.mergeTickArrayBitmap(o).testn(s),startIndex:e}}static nextInitializedTickArrayFromOneBitmap(e,t,n,o){let s=ke.tickCount(t),i=n?e-s:e+s,{tickarrayBitmap:r}=this.getBitmap(i,t,o);return this.nextInitializedTickArrayInBitmap(r,i,t,n)}static nextInitializedTickArrayInBitmap(e,t,n,o){let{minValue:s,maxValue:i}=In.getBitmapTickBoundary(t,n),r=this.tickArrayOffsetInBitmap(t,n);if(o){let u=$.mergeTickArrayBitmap(e).shln($n-1-r),a=Pi(512,u)?null:pa(512,u);if(a!==null){let l=t-a*ke.tickCount(n);return{isInit:!0,tickIndex:l}}else return{isInit:!1,tickIndex:s}}else{let u=$.mergeTickArrayBitmap(e).shrn(r),a=Pi(512,u)?null:fa(512,u);if(a!==null){let l=t+a*ke.tickCount(n);return{isInit:!0,tickIndex:l}}else return{isInit:!1,tickIndex:i-ke.tickCount(n)}}}static tickArrayOffsetInBitmap(e,t){let n=Math.abs(e)%In.maxTickInTickarrayBitmap(t),o=Math.floor(n/ke.tickCount(t));return e<0&&n!=0&&(o=$n-o),o}};var Oe=class{static getOutputAmountAndRemainAccounts(e,t,n,o,s,i=!1){let r=n.toBase58()===e.mintA.address,u=[],{isExist:a,startIndex:l,nextAccountMeta:m}=this.getFirstInitializedTickArray(e,r);if(!a||l===void 0||!m)throw new Error("Invalid tick array");u.push(m);let{allTrade:p,amountCalculated:d,accounts:f,sqrtPriceX64:y,feeAmount:b}=Jn.swapCompute(e.programId,e.id,t,e.tickArrayBitmap,e.exBitmapInfo,r,e.ammConfig.tradeFeeRate,e.liquidity,e.tickCurrent,e.tickSpacing,e.sqrtPriceX64,o,l,s,i);return u.push(...f),{allTrade:p,expectedAmountOut:d.mul(Tn),remainingAccounts:u,executionPrice:y,feeAmount:b}}static getInputAmountAndRemainAccounts(e,t,n,o,s){let i=n.toBase58()===e.mintB.address,r=[],{isExist:u,startIndex:a,nextAccountMeta:l}=this.getFirstInitializedTickArray(e,i);if(!u||a===void 0||!l)throw new Error("Invalid tick array");try{let y=this.preInitializedTickArrayStartIndex(e,i);if(y.isExist){let{publicKey:b}=ge(e.programId,e.id,y.nextStartIndex);r.push(b)}}catch{}r.push(l);let{amountCalculated:m,accounts:p,sqrtPriceX64:d,feeAmount:f}=Jn.swapCompute(e.programId,e.id,t,e.tickArrayBitmap,e.exBitmapInfo,i,e.ammConfig.tradeFeeRate,e.liquidity,e.tickCurrent,e.tickSpacing,e.sqrtPriceX64,o.mul(Tn),a,s);return r.push(...p),{expectedAmountIn:m,remainingAccounts:r,executionPrice:d,feeAmount:f}}static getFirstInitializedTickArray(e,t){let{isInitialized:n,startIndex:o}=Oe.isOverflowDefaultTickarrayBitmap(e.tickSpacing,[e.tickCurrent])?hi.checkTickArrayIsInit(ke.getArrayStartIndex(e.tickCurrent,e.tickSpacing),e.tickSpacing,e.exBitmapInfo):$.checkTickArrayIsInitialized($.mergeTickArrayBitmap(e.tickArrayBitmap),e.tickCurrent,e.tickSpacing);if(n){let{publicKey:r}=ge(e.programId,e.id,o);return{isExist:!0,startIndex:o,nextAccountMeta:r}}let{isExist:s,nextStartIndex:i}=this.nextInitializedTickArrayStartIndex(e,ke.getArrayStartIndex(e.tickCurrent,e.tickSpacing),t);if(s){let{publicKey:r}=ge(e.programId,e.id,i);return{isExist:!0,startIndex:i,nextAccountMeta:r}}return{isExist:!1,nextAccountMeta:void 0,startIndex:void 0}}static preInitializedTickArrayStartIndex(e,t){let n=Math.floor(e.tickCurrent/ke.tickCount(e.tickSpacing)),o=t?$.searchHightBitFromStart(e.tickArrayBitmap,e.exBitmapInfo,n+1,1,e.tickSpacing):$.searchLowBitFromStart(e.tickArrayBitmap,e.exBitmapInfo,n-1,1,e.tickSpacing);return o.length>0?{isExist:!0,nextStartIndex:o[0]}:{isExist:!1,nextStartIndex:0}}static nextInitializedTickArrayStartIndex(e,t,n){for(t=ke.getArrayStartIndex(e.tickCurrent,e.tickSpacing);;){let{isInit:o,tickIndex:s}=In.nextInitializedTickArrayStartIndex($.mergeTickArrayBitmap(e.tickArrayBitmap),t,e.tickSpacing,n);if(o)return{isExist:!0,nextStartIndex:s};t=s;let{isInit:i,tickIndex:r}=hi.nextInitializedTickArrayFromOneBitmap(t,e.tickSpacing,n,e.exBitmapInfo);if(i)return{isExist:!0,nextStartIndex:r};if(t=r,t<ft||t>Pt)return{isExist:!1,nextStartIndex:0}}}static async updatePoolRewardInfos({connection:e,apiPoolInfo:t,chainTime:n,poolLiquidity:o,rewardInfos:s}){var r,u,a;let i=[];for(let l=0;l<s.length;l++){let m=s[l],p=(a=(r=t.rewardDefaultInfos[l])==null?void 0:r.mint.programId)!=null?a:(u=await e.getAccountInfo(m.tokenMint))==null?void 0:u.owner;if(p===void 0)throw Error("get new reward mint info error");let d=q(v({},m),{perSecond:le.x64ToDecimal(m.emissionsPerSecondX64),remainingRewards:void 0,tokenProgramId:new Ot(p)});if(d.tokenMint.equals(Ot.default))continue;if(n<=d.openTime.toNumber()||o.eq(be)){i.push(d);continue}let f=new _e(Math.min(d.endTime.toNumber(),n)),y=f.sub(d.lastUpdateTime),b=le.mulDivFloor(y,d.emissionsPerSecondX64,o),g=d.rewardGrowthGlobalX64.add(b),A=le.mulDivFloor(y,d.emissionsPerSecondX64,et),h=d.rewardTotalEmissioned.add(A);i.push(q(v({},d),{rewardGrowthGlobalX64:g,rewardTotalEmissioned:h,lastUpdateTime:f}))}return i}static isOverflowDefaultTickarrayBitmap(e,t){let{maxTickBoundary:n,minTickBoundary:o}=this.tickRange(e);for(let s of t){let i=$.getTickArrayStartIndexByTick(s,e);if(i>=n||i<o)return!0}return!1}static tickRange(e){let t=In.maxTickInTickarrayBitmap(e),n=-t;return t>Pt&&(t=ke.getArrayStartIndex(Pt,e)+ke.tickCount(e)),n<ft&&(n=ke.getArrayStartIndex(ft,e)),{maxTickBoundary:t,minTickBoundary:n}}static get_tick_array_offset(e,t){if(!ke.checkIsValidStartIndex(e,t))throw new Error("No enough initialized tickArray");return e/ke.tickCount(t)*$n}static async fetchExBitmaps({connection:e,exBitmapAddress:t,batchRequest:n}){let o=await Le(e,t.map(i=>({pubkey:i})),{batchRequest:n}),s={};for(let i of o)i.accountInfo!==null&&(s[i.pubkey.toString()]=Wc.decode(i.accountInfo.data));return s}static async fetchMultiplePoolTickArrays({connection:e,poolKeys:t,batchRequest:n}){let o={},s=[];for(let u of t){let a=$.getTickArrayStartIndexByTick(u.tickCurrent,u.tickSpacing),l=$.getInitializedTickArrayInRange(u.tickArrayBitmap,u.exBitmapInfo,u.tickSpacing,a,7);for(let m of l){let{publicKey:p}=ge(u.programId,u.id,m);s.push({pubkey:p}),o[p.toString()]=u.id}}let i=await Le(e,s,{batchRequest:n}),r={};for(let u of i){if(!u.accountInfo)continue;let a=o[u.pubkey.toString()];if(!a)continue;r[a.toString()]===void 0&&(r[a.toString()]={});let l=Ti.decode(u.accountInfo.data);r[a.toString()][l.startTickIndex]=q(v({},l),{address:u.pubkey})}return r}static async fetchPoolsAccountPosition({pools:e,connection:t,ownerInfo:n,batchRequest:o=!1,updateOwnerRewardAndFee:s=!0}){var r;let i=[];for(let u=0;u<e.length;u++){let a=e[u];a!==null&&(i.find(l=>l.equals(a.state.programId))||i.push(a.state.programId))}if(n){let u=n.tokenAccounts.map(p=>p.accountInfo.mint),a=[];for(let p of u)for(let d of i)a.push(kt(d,p).publicKey);let l=await Ht(t,a,{batchRequest:o}),m={};for(let p of l){if(p===null)continue;let d=Ro.decode(p.data),f=d.poolId.toString(),y=e.find(x=>x.state.id.toBase58()===f);if(y===void 0)continue;let b=y.state,g=$._getTickPriceLegacy({poolInfo:b,tick:d.tickLower,baseIn:!0}),A=$._getTickPriceLegacy({poolInfo:b,tick:d.tickUpper,baseIn:!0}),{amountA:h,amountB:I}=Ae.getAmountsFromLiquidity(b.sqrtPriceX64,g.tickSqrtPriceX64,A.tickSqrtPriceX64,d.liquidity,!1),T=1/(1-Math.sqrt(Math.sqrt(g.price.div(A.price).toNumber())));y.positionAccount=[...(r=y.positionAccount)!=null?r:[],{poolId:d.poolId,nftMint:d.nftMint,priceLower:g.price,priceUpper:A.price,amountA:h,amountB:I,tickLower:d.tickLower,tickUpper:d.tickUpper,liquidity:d.liquidity,feeGrowthInsideLastX64A:d.feeGrowthInsideLastX64A,feeGrowthInsideLastX64B:d.feeGrowthInsideLastX64B,tokenFeesOwedA:d.tokenFeesOwedA,tokenFeesOwedB:d.tokenFeesOwedB,rewardInfos:d.rewardInfos.map(x=>q(v({},x),{pendingReward:new _e(0)})),leverage:T,tokenFeeAmountA:new _e(0),tokenFeeAmountB:new _e(0)}];let w=await $.getTickArrayAddressByTick(y.state.programId,d.poolId,d.tickLower,y.state.tickSpacing),S=await $.getTickArrayAddressByTick(y.state.programId,d.poolId,d.tickUpper,y.state.tickSpacing);m[`${y.state.programId.toString()}-${d.poolId.toString()}-${d.tickLower}`]=w,m[`${y.state.programId.toString()}-${d.poolId.toString()}-${d.tickUpper}`]=S}if(s){let p=Object.values(m),d=await Ht(t,p,{batchRequest:o}),f={};for(let y=0;y<p.length;y++){let b=d[y];if(b===null)continue;let g=p[y].toString();f[g]=Ti.decode(b.data)}for(let{state:y,positionAccount:b}of e)if(!!b)for(let g of b){let A=`${y.programId.toString()}-${y.id.toString()}-${g.tickLower}`,h=`${y.programId.toString()}-${y.id.toString()}-${g.tickUpper}`,I=f[m[A].toString()],T=f[m[h].toString()],w=I.ticks[$.getTickOffsetInArray(g.tickLower,y.tickSpacing)],S=T.ticks[$.getTickOffsetInArray(g.tickUpper,y.tickSpacing)],{tokenFeeAmountA:x,tokenFeeAmountB:K}=await wi.GetPositionFees(y,g,w,S),B=await wi.GetPositionRewards(y,g,w,S);g.tokenFeeAmountA=x.gte(new _e(0))?x:new _e(0),g.tokenFeeAmountB=K.gte(new _e(0))?K:new _e(0);for(let C=0;C<B.length;C++)g.rewardInfos[C].pendingReward=B[C].gte(new _e(0))?B[C]:new _e(0)}}}return e}static computeAmountOut({poolInfo:e,tickArrayCache:t,baseMint:n,epochInfo:o,amountIn:s,slippage:i,priceLimit:r=new Pe(0),catchLiquidityInsufficient:u=!1}){var O;let a,l=n.toBase58()===e.mintA.address,[m,p]=l?[e.mintA.extensions.feeConfig,e.mintB.extensions.feeConfig]:[e.mintB.extensions.feeConfig,e.mintA.extensions.feeConfig];r.equals(new Pe(0))?a=l?Wt.add(new _e(1)):qt.sub(new _e(1)):a=re.priceToSqrtPriceX64(r,e.mintA.decimals,e.mintB.decimals);let d=Te(s,m,o,!1),{allTrade:f,expectedAmountOut:y,remainingAccounts:b,executionPrice:g,feeAmount:A}=Oe.getOutputAmountAndRemainAccounts(e,t,n,d.amount.sub((O=d.fee)!=null?O:be),a,u),h=Te(y,p,o,!1),I=re.sqrtPriceX64ToPrice(g,e.mintA.decimals,e.mintB.decimals),T=l?I:new Pe(1).div(I),w=y.mul(new _e(Math.floor((1-i)*1e10))).div(new _e(1e10)),S=Te(w,p,o,!1),x=l?e.currentPrice:new Pe(1).div(e.currentPrice),K=new Pe(T).sub(x).abs(),B=x,C=new st(new Pe(K).mul(10**15).toFixed(0),new Pe(B).mul(10**15).toFixed(0));return{allTrade:f,realAmountIn:d,amountOut:h,minAmountOut:S,expirationTime:Jt(d.expirationTime,h.expirationTime),currentPrice:e.currentPrice,executionPrice:T,priceImpact:C,fee:A,remainingAccounts:b,executionPriceX64:g}}static computeAmountOutFormat({poolInfo:e,tickArrayCache:t,amountIn:n,tokenOut:o,slippage:s,epochInfo:i,catchLiquidityInsufficient:r=!1}){let u=o.address===e.mintB.address,[a,l]=u?[e.mintA,e.mintB]:[e.mintB,e.mintA],[m,p]=[new We(q(v({},a),{mint:a.address,isToken2022:a.programId===Ec.toBase58()})),new We(q(v({},l),{mint:l.address,isToken2022:l.programId===Ec.toBase58()}))],{allTrade:d,realAmountIn:f,amountOut:y,minAmountOut:b,expirationTime:g,currentPrice:A,executionPrice:h,priceImpact:I,fee:T,remainingAccounts:w,executionPriceX64:S}=Oe.computeAmountOut({poolInfo:e,tickArrayCache:t,baseMint:new Ot(a.address),amountIn:n,slippage:s,epochInfo:i,catchLiquidityInsufficient:r}),x=q(v({},f),{amount:new xe(m,f.amount),fee:f.fee===void 0?void 0:new xe(m,f.fee)}),K=q(v({},y),{amount:new xe(p,y.amount),fee:y.fee===void 0?void 0:new xe(p,y.fee)}),B=q(v({},b),{amount:new xe(p,b.amount),fee:b.fee===void 0?void 0:new xe(p,b.fee)}),C=new Tt({baseToken:m,denominator:new _e(10).pow(new _e(20+m.decimals)),quoteToken:p,numerator:A.mul(new Pe(10**(20+p.decimals))).toFixed(0)}),O=new Tt({baseToken:m,denominator:new _e(10).pow(new _e(20+m.decimals)),quoteToken:p,numerator:h.mul(new Pe(10**(20+p.decimals))).toFixed(0)}),M=new xe(m,T);return{allTrade:d,realAmountIn:x,amountOut:K,minAmountOut:B,expirationTime:g,currentPrice:C,executionPrice:O,priceImpact:I,fee:M,remainingAccounts:w,executionPriceX64:S}}static computeAmountIn({poolInfo:e,tickArrayCache:t,baseMint:n,epochInfo:o,amountOut:s,slippage:i,priceLimit:r=new Pe(0)}){var B;let u=n.toBase58()===e.mintA.address,a={[e.mintA.address]:e.mintA.extensions.feeConfig,[e.mintB.address]:e.mintB.extensions.feeConfig},l;r.equals(new Pe(0))?l=u?qt.sub(new _e(1)):Wt.add(new _e(1)):l=re.priceToSqrtPriceX64(r,e.mintA.decimals,e.mintB.decimals);let m=Te(s,a[n.toString()],o,!0),{expectedAmountIn:p,remainingAccounts:d,executionPrice:f,feeAmount:y}=Oe.getInputAmountAndRemainAccounts(e,t,n,m.amount.sub((B=m.fee)!=null?B:be),l),b=u?e.mintB.address:e.mintA.address,g=Te(p,a[b],o,!1),A=re.sqrtPriceX64ToPrice(f,e.mintA.decimals,e.mintB.decimals),h=u?A:new Pe(1).div(A),I=p.mul(new _e(Math.floor((1+i)*1e10))).div(new _e(1e10)),T=Te(I,a[b],o,!0),w=u?e.currentPrice:new Pe(1).div(e.currentPrice),S=new Pe(h).sub(w).abs(),x=w,K=new st(new Pe(S).mul(10**15).toFixed(0),new Pe(x).mul(10**15).toFixed(0));return{amountIn:g,maxAmountIn:T,realAmountOut:m,expirationTime:Jt(g.expirationTime,m.expirationTime),currentPrice:e.currentPrice,executionPrice:h,priceImpact:K,fee:y,remainingAccounts:d}}static estimateAprsForPriceRangeMultiplier({poolInfo:e,aprType:t,positionTickLowerIndex:n,positionTickUpperIndex:o}){var f,y,b;let s=e[t],i=$.getTickPrice({poolInfo:e,tick:n,baseIn:!0}).price.toNumber(),r=$.getTickPrice({poolInfo:e,tick:o,baseIn:!0}).price.toNumber(),u=Math.max(i,s.priceMin),l=Math.min(r,s.priceMax)-u,m=r-i,p=s.priceMax-s.priceMin,d;return l<=0?d=0:m===l?d=p/l:p===l?d=l/m:d=l/p*(l/m),{feeApr:s.feeApr*d,rewardsApr:[((f=s.rewardApr[0])!=null?f:0)*d,((y=s.rewardApr[1])!=null?y:0)*d,((b=s.rewardApr[2])!=null?b:0)*d],apr:s.apr*d}}static estimateAprsForPriceRangeDelta({poolInfo:e,poolLiquidity:t,aprType:n,mintPrice:o,liquidity:s,positionTickLowerIndex:i,positionTickUpperIndex:r,chainTime:u}){let a=n==="day"?1:n==="week"?7:n==="month"?30:0,l=e[n],m=o[dt(e.mintA.address).toString()],p=o[dt(e.mintB.address).toString()],d=e.mintA.decimals,f=e.mintB.decimals;if(!l||!m||!p)return{feeApr:0,rewardsApr:[0,0,0],apr:0};let y=re.priceToSqrtPriceX64(new Pe(e.price),e.mintA.decimals,e.mintB.decimals),b=re.getSqrtPriceX64FromTick(i),g=re.getSqrtPriceX64FromTick(r),{amountSlippageA:A,amountSlippageB:h}=Ae.getAmountsFromLiquidityWithSlippage(y,b,g,t,!1,!1,0),{amountSlippageA:I,amountSlippageB:T}=Ae.getAmountsFromLiquidityWithSlippage(y,b,g,s,!1,!1,0),w=new Pe(A.toString()).div(new Pe(10).pow(d)).mul(m.value).add(new Pe(h.toString()).div(new Pe(10).pow(f)).mul(p.value)),S=new Pe(I.toString()).div(new Pe(10).pow(d)).mul(m.value).add(new Pe(T.toString()).div(new Pe(10).pow(f)).mul(p.value)),x=new Pe(1).div(w.add(S)),B=new Pe(l.volumeFee).mul(365).div(a).mul(x).mul(100).toNumber(),C=3600*24*365,O=e.rewardDefaultInfos.map(M=>{var _,X;let L=M.mint.decimals,R=o[M.mint.address];return u<((_=M.startTime)!=null?_:0)||u>((X=M.endTime)!=null?X:0)||!M.perSecond||!R||L===void 0?0:new Pe(R.value).mul(new Pe(M.perSecond).mul(C)).div(new Pe(10).pow(L)).mul(x).mul(100).toNumber()});return{feeApr:B,rewardsApr:O,apr:B+O.reduce((M,L)=>M+L,0)}}static async getLiquidityAmountOutFromAmountIn({poolInfo:e,inputA:t,tickLower:n,tickUpper:o,amount:s,slippage:i,add:r,epochInfo:u,amountHasFee:a}){var g,A;let l=re.priceToSqrtPriceX64(new Pe(e.price),e.mintA.decimals,e.mintB.decimals),m=re.getSqrtPriceX64FromTick(n),p=re.getSqrtPriceX64FromTick(o),d=Te(s,(g=e[t?"mintA":"mintB"].extensions)==null?void 0:g.feeConfig,u,!a),f=new _e(new Pe(d.amount.sub((A=d.fee)!=null?A:be).toString()).toFixed(0)),y;if(l.lte(m))y=t?Ae.getLiquidityFromTokenAmountA(m,p,f,!r):new _e(0);else if(l.lte(p)){let h=Ae.getLiquidityFromTokenAmountA(l,p,f,!r),I=Ae.getLiquidityFromTokenAmountB(m,l,f);y=t?h:I}else y=t?new _e(0):Ae.getLiquidityFromTokenAmountB(m,p,f);let b=await Oe.getAmountsFromLiquidity({epochInfo:u,poolInfo:e,tickLower:n,tickUpper:o,liquidity:y,slippage:i,add:r});return{liquidity:y,amountA:t?d:b.amountA,amountB:t?b.amountB:d,amountSlippageA:t?d:b.amountSlippageA,amountSlippageB:t?b.amountSlippageB:d,expirationTime:b.expirationTime}}static async getAmountsFromLiquidity({epochInfo:e,poolInfo:t,tickLower:n,tickUpper:o,liquidity:s,slippage:i,add:r}){var b,g,A,h;let u=re.getSqrtPriceX64FromTick(n),a=re.getSqrtPriceX64FromTick(o),l=r?1+i:1-i,m=Ae.getAmountsFromLiquidity(re.priceToSqrtPriceX64(new Pe(t.price),t.mintA.decimals,t.mintB.decimals),u,a,s,r),[p,d]=[Te(m.amountA,(b=t.mintA.extensions)==null?void 0:b.feeConfig,e,!0),Te(m.amountB,(g=t.mintB.extensions)==null?void 0:g.feeConfig,e,!0)],[f,y]=[Te(m.amountA.muln(l),(A=t.mintA.extensions)==null?void 0:A.feeConfig,e,!0),Te(m.amountB.muln(l),(h=t.mintB.extensions)==null?void 0:h.feeConfig,e,!0)];return{liquidity:s,amountA:p,amountB:d,amountSlippageA:f,amountSlippageB:y,expirationTime:Jt(p.expirationTime,d.expirationTime)}}static async fetchComputeMultipleClmmInfo({connection:e,poolList:t,rpcDataMap:n={}}){let o=t.filter(u=>!n[u.id]).map(u=>new Ot(u.id));(await Ht(e,o)).forEach((u,a)=>{!u||(n[o[a].toBase58()]=eo.decode(u.data))});let i=t.map(u=>Ye(new Ot(u.programId),new Ot(u.id)).publicKey),r=await Oe.fetchExBitmaps({connection:e,exBitmapAddress:i,batchRequest:!1});return t.reduce((u,a)=>q(v({},u),{[a.id]:q(v({},n[a.id]),{id:new Ot(a.id),version:6,programId:new Ot(a.programId),mintA:a.mintA,mintB:a.mintB,ammConfig:q(v({},a.config),{id:new Ot(a.config.id),fundOwner:""}),currentPrice:new Pe(a.price),exBitmapAccount:Ye(new Ot(a.programId),new Ot(a.id)).publicKey,exBitmapInfo:r[Ye(new Ot(a.programId),new Ot(a.id)).publicKey.toBase58()],startTime:n[a.id].startTime.toNumber(),rewardInfos:n[a.id].rewardInfos})}),{})}static async fetchComputeClmmInfo({connection:e,poolInfo:t,rpcData:n}){return(await this.fetchComputeMultipleClmmInfo({connection:e,rpcDataMap:n?{[t.id]:n}:void 0,poolList:[t]}))[t.id]}};function gT({poolInfo:c,tickLower:e,tickUpper:t,amountA:n,amountB:o,slippage:s,add:i,epochInfo:r,amountHasFee:u}){var h,I,T,w;let[a,l,m,p]=e<t?[e,t,n,o]:[t,e,o,n],d=re.priceToSqrtPriceX64(new Pe(c.price),c.mintA.decimals,c.mintB.decimals),f=re.getSqrtPriceX64FromTick(a),y=re.getSqrtPriceX64FromTick(l),[b,g]=[Te(m,(h=c.mintA.extensions)==null?void 0:h.feeConfig,r,!u),Te(p,(I=c.mintB.extensions)==null?void 0:I.feeConfig,r,!u)],A=Ae.getLiquidityFromTokenAmounts(d,f,y,b.amount.sub((T=b.fee)!=null?T:be),g.amount.sub((w=g.fee)!=null?w:be));return Ae.getAmountsOutFromLiquidity({poolInfo:c,tickLower:e,tickUpper:t,liquidity:A,slippage:s,add:i,epochInfo:r,amountAddFee:!u})}var Ta={volume:0,volumeQuote:0,volumeFee:0,apr:0,feeApr:0,priceMin:0,priceMax:0,rewardApr:[]};function Dc(c){return q(v({},c),{type:"Concentrated",programId:c.programId.toString(),id:c.id.toString(),rewardDefaultInfos:[],rewardDefaultPoolInfos:"Clmm",price:c.currentPrice.toNumber(),mintAmountA:0,mintAmountB:0,feeRate:c.ammConfig.tradeFeeRate,openTime:c.startTime.toString(),tvl:0,day:Ta,week:Ta,month:Ta,pooltype:[],farmUpcomingCount:0,farmOngoingCount:0,farmFinishedCount:0,burnPercent:0,config:q(v({},c.ammConfig),{id:c.ammConfig.id.toString(),defaultRange:0,defaultRangePoint:[]})})}var le=class{static mulDivRoundingUp(e,t,n){let o=e.mul(t),s=o.div(n);return o.mod(n).eq(be)||(s=s.add(Lt)),s}static mulDivFloor(e,t,n){if(n.eq(be))throw new Error("division by 0");return e.mul(t).div(n)}static mulDivCeil(e,t,n){if(n.eq(be))throw new Error("division by 0");return e.mul(t).add(n.sub(Lt)).div(n)}static x64ToDecimal(e,t){return new dn(e.toString()).div(dn.pow(2,64)).toDecimalPlaces(t)}static decimalToX64(e){return new pe(e.mul(dn.pow(2,64)).floor().toFixed())}static wrappingSubU128(e,t){return e.add(xr).sub(t).mod(xr)}};function ct(c,e){return ha(c.mul(e),64,256)}function ep(c,e,t){let n=c.toTwos(t).shln(e);return n.imaskn(t+1),n.fromTwos(t)}function ha(c,e,t){let n=c.toTwos(t).shrn(e);return n.imaskn(t-e+1),n.fromTwos(t-e)}var re=class{static sqrtPriceX64ToPrice(e,t,n){return le.x64ToDecimal(e).pow(2).mul(dn.pow(10,t-n))}static priceToSqrtPriceX64(e,t,n){return le.decimalToX64(e.mul(dn.pow(10,n-t)).sqrt())}static getNextSqrtPriceX64FromInput(e,t,n,o){if(!e.gt(be))throw new Error("sqrtPriceX64 must greater than 0");if(!t.gt(be))throw new Error("liquidity must greater than 0");return o?this.getNextSqrtPriceFromTokenAmountARoundingUp(e,t,n,!0):this.getNextSqrtPriceFromTokenAmountBRoundingDown(e,t,n,!0)}static getNextSqrtPriceX64FromOutput(e,t,n,o){if(!e.gt(be))throw new Error("sqrtPriceX64 must greater than 0");if(!t.gt(be))throw new Error("liquidity must greater than 0");return o?this.getNextSqrtPriceFromTokenAmountBRoundingDown(e,t,n,!1):this.getNextSqrtPriceFromTokenAmountARoundingUp(e,t,n,!1)}static getNextSqrtPriceFromTokenAmountARoundingUp(e,t,n,o){if(n.eq(be))return e;let s=t.shln(Ai);if(o){let i=s,r=s.add(n.mul(e));return r.gte(i)?le.mulDivCeil(i,e,r):le.mulDivRoundingUp(i,Lt,i.div(e).add(n))}else{let i=n.mul(e);if(!s.gt(i))throw new Error("getNextSqrtPriceFromTokenAmountARoundingUp,liquidityLeftShift must gt amountMulSqrtPrice");let r=s.sub(i);return le.mulDivCeil(s,e,r)}}static getNextSqrtPriceFromTokenAmountBRoundingDown(e,t,n,o){let s=n.shln(Ai);if(o)return e.add(s.div(t));{let i=le.mulDivRoundingUp(s,Lt,t);if(!e.gt(i))throw new Error("getNextSqrtPriceFromTokenAmountBRoundingDown sqrtPriceX64 must gt amountDivLiquidity");return e.sub(i)}}static getSqrtPriceX64FromTick(e){if(!Number.isInteger(e))throw new Error("tick must be integer");if(e<ft||e>Pt)throw new Error("tick must be in MIN_TICK and MAX_TICK");let t=e<0?e*-1:e,n=(t&1)!=0?new pe("18445821805675395072"):new pe("18446744073709551616");return(t&2)!=0&&(n=ct(n,new pe("18444899583751176192"))),(t&4)!=0&&(n=ct(n,new pe("18443055278223355904"))),(t&8)!=0&&(n=ct(n,new pe("18439367220385607680"))),(t&16)!=0&&(n=ct(n,new pe("18431993317065453568"))),(t&32)!=0&&(n=ct(n,new pe("18417254355718170624"))),(t&64)!=0&&(n=ct(n,new pe("18387811781193609216"))),(t&128)!=0&&(n=ct(n,new pe("18329067761203558400"))),(t&256)!=0&&(n=ct(n,new pe("18212142134806163456"))),(t&512)!=0&&(n=ct(n,new pe("17980523815641700352"))),(t&1024)!=0&&(n=ct(n,new pe("17526086738831433728"))),(t&2048)!=0&&(n=ct(n,new pe("16651378430235570176"))),(t&4096)!=0&&(n=ct(n,new pe("15030750278694412288"))),(t&8192)!=0&&(n=ct(n,new pe("12247334978884435968"))),(t&16384)!=0&&(n=ct(n,new pe("8131365268886854656"))),(t&32768)!=0&&(n=ct(n,new pe("3584323654725218816"))),(t&65536)!=0&&(n=ct(n,new pe("696457651848324352"))),(t&131072)!=0&&(n=ct(n,new pe("26294789957507116"))),(t&262144)!=0&&(n=ct(n,new pe("37481735321082"))),e>0&&(n=xc.div(n)),n}static getTickFromPrice(e,t,n){return re.getTickFromSqrtPriceX64(re.priceToSqrtPriceX64(e,t,n))}static getTickFromSqrtPriceX64(e){if(e.gt(qt)||e.lt(Wt))throw new Error("Provided sqrtPrice is not within the supported sqrtPrice range.");let t=e.bitLength()-1,n=new pe(t-64),o=ep(n,32,128),s=new pe("8000000000000000","hex"),i=0,r=new pe(0),u=t>=64?e.shrn(t-63):e.shln(63-t);for(;s.gt(new pe(0))&&i<Sc;){u=u.mul(u);let f=u.shrn(127);u=u.shrn(63+f.toNumber()),r=r.add(s.mul(f)),s=s.shrn(1),i+=1}let a=r.shrn(32),m=o.add(a).mul(new pe(Kc)),p=ha(m.sub(new pe(Cc)),64,128).toNumber(),d=ha(m.add(new pe(Rc)),64,128).toNumber();return p==d?p:re.getSqrtPriceX64FromTick(d).lte(e)?d:p}},to=class{static getTickWithPriceAndTickspacing(e,t,n,o){let i=re.getTickFromSqrtPriceX64(re.priceToSqrtPriceX64(e,n,o))/t;return i<0?i=Math.floor(i):i=Math.ceil(i),i*t}static roundPriceWithTickspacing(e,t,n,o){let s=to.getTickWithPriceAndTickspacing(e,t,n,o),i=re.getSqrtPriceX64FromTick(s);return re.sqrtPriceX64ToPrice(i,n,o)}},Ae=class{static addDelta(e,t){return e.add(t)}static getTokenAmountAFromLiquidity(e,t,n,o){if(e.gt(t)&&([e,t]=[t,e]),!e.gt(be))throw new Error("sqrtPriceX64A must greater than 0");let s=n.ushln(Ai),i=t.sub(e);return o?le.mulDivRoundingUp(le.mulDivCeil(s,i,t),Lt,e):le.mulDivFloor(s,i,t).div(e)}static getTokenAmountBFromLiquidity(e,t,n,o){if(e.gt(t)&&([e,t]=[t,e]),!e.gt(be))throw new Error("sqrtPriceX64A must greater than 0");return o?le.mulDivCeil(n,t.sub(e),et):le.mulDivFloor(n,t.sub(e),et)}static getLiquidityFromTokenAmountA(e,t,n,o){e.gt(t)&&([e,t]=[t,e]);let s=n.mul(e).mul(t),i=t.sub(e),r=s.div(i);return o?le.mulDivRoundingUp(r,Lt,gi):r.shrn(Ai)}static getLiquidityFromTokenAmountB(e,t,n){return e.gt(t)&&([e,t]=[t,e]),le.mulDivFloor(n,gi,t.sub(e))}static getLiquidityFromTokenAmounts(e,t,n,o,s){if(t.gt(n)&&([t,n]=[n,t]),e.lte(t))return Ae.getLiquidityFromTokenAmountA(t,n,o,!1);if(e.lt(n)){let i=Ae.getLiquidityFromTokenAmountA(e,n,o,!1),r=Ae.getLiquidityFromTokenAmountB(t,e,s);return i.lt(r)?i:r}else return Ae.getLiquidityFromTokenAmountB(t,n,s)}static getAmountsFromLiquidity(e,t,n,o,s){if(t.gt(n)&&([t,n]=[n,t]),e.lte(t))return{amountA:Ae.getTokenAmountAFromLiquidity(t,n,o,s),amountB:new pe(0)};if(e.lt(n)){let i=Ae.getTokenAmountAFromLiquidity(e,n,o,s),r=Ae.getTokenAmountBFromLiquidity(t,e,o,s);return{amountA:i,amountB:r}}else return{amountA:new pe(0),amountB:Ae.getTokenAmountBFromLiquidity(t,n,o,s)}}static getAmountsFromLiquidityWithSlippage(e,t,n,o,s,i,r){let{amountA:u,amountB:a}=Ae.getAmountsFromLiquidity(e,t,n,o,i),l=s?1+r:1-r,m=new pe(new dn(u.toString()).mul(l).toFixed(0)),p=new pe(new dn(a.toString()).mul(l).toFixed(0));return{amountSlippageA:m,amountSlippageB:p}}static getAmountsOutFromLiquidity({poolInfo:e,tickLower:t,tickUpper:n,liquidity:o,slippage:s,add:i,epochInfo:r,amountAddFee:u}){var A,h,I,T;let a=re.priceToSqrtPriceX64(new dn(e.price),e.mintA.decimals,e.mintB.decimals),l=re.getSqrtPriceX64FromTick(t),m=re.getSqrtPriceX64FromTick(n),p=i?1+s:1-s,d=Ae.getAmountsFromLiquidity(a,l,m,o,i),[f,y]=[Te(d.amountA,(A=e.mintA.extensions)==null?void 0:A.feeConfig,r,u),Te(d.amountB,(h=e.mintB.extensions)==null?void 0:h.feeConfig,r,u)],[b,g]=[Te(new pe(new dn(d.amountA.toString()).mul(p).toFixed(0)),(I=e.mintA.extensions)==null?void 0:I.feeConfig,r,u),Te(new pe(new dn(d.amountB.toString()).mul(p).toFixed(0)),(T=e.mintB.extensions)==null?void 0:T.feeConfig,r,u)];return{liquidity:o,amountA:f,amountB:y,amountSlippageA:b,amountSlippageB:g,expirationTime:Jt(f.expirationTime,y.expirationTime)}}},Jn=class{static swapCompute(e,t,n,o,s,i,r,u,a,l,m,p,d,f,y=!1){if(p.eq(be))throw new Error("amountSpecified must not be 0");if(f||(f=i?Wt.add(Lt):qt.sub(Lt)),i){if(f.lt(Wt))throw new Error("sqrtPriceX64 must greater than MIN_SQRT_PRICE_X64");if(f.gte(m))throw new Error("sqrtPriceX64 must smaller than current")}else{if(f.gt(qt))throw new Error("sqrtPriceX64 must smaller than MAX_SQRT_PRICE_X64");if(f.lte(m))throw new Error("sqrtPriceX64 must greater than current")}let b=p.gt(be),g={amountSpecifiedRemaining:p,amountCalculated:be,sqrtPriceX64:m,tick:a>d?Math.min(d+ke.tickCount(l)-1,a):d,accounts:[],liquidity:u,feeAmount:new pe(0)},A=d,h=n[d],I=0,T=!i&&h.startTickIndex===g.tick;for(;!g.amountSpecifiedRemaining.eq(be)&&!g.sqrtPriceX64.eq(f);){I>10;let w={};w.sqrtPriceStartX64=g.sqrtPriceX64;let S=$.nextInitTick(h,g.tick,l,i,T),x=S||null,K=null;if(!(x!=null&&x.liquidityGross.gtn(0))){let C=Oe.nextInitializedTickArrayStartIndex({tickCurrent:g.tick,tickSpacing:l,tickArrayBitmap:o,exBitmapInfo:s},A,i);if(!C.isExist){if(y)return{allTrade:!1,amountSpecifiedRemaining:g.amountSpecifiedRemaining,amountCalculated:g.amountCalculated,feeAmount:g.feeAmount,sqrtPriceX64:g.sqrtPriceX64,liquidity:g.liquidity,tickCurrent:g.tick,accounts:g.accounts};throw Error("swapCompute LiquidityInsufficient")}A=C.nextStartIndex;let{publicKey:O}=ge(e,t,A);K=O,h=n[A];try{x=$.firstInitializedTick(h,i)}catch{throw Error("not found next tick info")}}w.tickNext=x.tick,w.initialized=x.liquidityGross.gtn(0),d!==A&&K&&(g.accounts.push(K),d=A),w.tickNext<ft?w.tickNext=ft:w.tickNext>Pt&&(w.tickNext=Pt),w.sqrtPriceNextX64=re.getSqrtPriceX64FromTick(w.tickNext);let B;if(i&&w.sqrtPriceNextX64.lt(f)||!i&&w.sqrtPriceNextX64.gt(f)?B=f:B=w.sqrtPriceNextX64,[g.sqrtPriceX64,w.amountIn,w.amountOut,w.feeAmount]=Jn.swapStepCompute(g.sqrtPriceX64,B,g.liquidity,g.amountSpecifiedRemaining,r,i),g.feeAmount=g.feeAmount.add(w.feeAmount),b?(g.amountSpecifiedRemaining=g.amountSpecifiedRemaining.sub(w.amountIn.add(w.feeAmount)),g.amountCalculated=g.amountCalculated.sub(w.amountOut)):(g.amountSpecifiedRemaining=g.amountSpecifiedRemaining.add(w.amountOut),g.amountCalculated=g.amountCalculated.add(w.amountIn.add(w.feeAmount))),g.sqrtPriceX64.eq(w.sqrtPriceNextX64)){if(w.initialized){let C=x.liquidityNet;i&&(C=C.mul(Tn)),g.liquidity=Ae.addDelta(g.liquidity,C)}T=w.tickNext!=g.tick&&!i&&h.startTickIndex===w.tickNext,g.tick=i?w.tickNext-1:w.tickNext}else if(g.sqrtPriceX64!=w.sqrtPriceStartX64){let C=re.getTickFromSqrtPriceX64(g.sqrtPriceX64);T=C!=g.tick&&!i&&h.startTickIndex===C,g.tick=C}++I}try{let{nextStartIndex:w,isExist:S}=ke.nextInitializedTickArray(g.tick,l,i,o,s);S&&d!==w&&(g.accounts.push(ge(e,t,w).publicKey),d=w)}catch{}return{allTrade:!0,amountSpecifiedRemaining:be,amountCalculated:g.amountCalculated,feeAmount:g.feeAmount,sqrtPriceX64:g.sqrtPriceX64,liquidity:g.liquidity,tickCurrent:g.tick,accounts:g.accounts}}static swapStepCompute(e,t,n,o,s,i){let r={sqrtPriceX64Next:new pe(0),amountIn:new pe(0),amountOut:new pe(0),feeAmount:new pe(0)},u=o.gte(be);if(u){let l=le.mulDivFloor(o,Cr.sub(new pe(s.toString())),Cr);r.amountIn=i?Ae.getTokenAmountAFromLiquidity(t,e,n,!0):Ae.getTokenAmountBFromLiquidity(e,t,n,!0),l.gte(r.amountIn)?r.sqrtPriceX64Next=t:r.sqrtPriceX64Next=re.getNextSqrtPriceX64FromInput(e,n,l,i)}else r.amountOut=i?Ae.getTokenAmountBFromLiquidity(t,e,n,!1):Ae.getTokenAmountAFromLiquidity(e,t,n,!1),o.mul(Tn).gte(r.amountOut)?r.sqrtPriceX64Next=t:r.sqrtPriceX64Next=re.getNextSqrtPriceX64FromOutput(e,n,o.mul(Tn),i);let a=t.eq(r.sqrtPriceX64Next);return i?(a&&u||(r.amountIn=Ae.getTokenAmountAFromLiquidity(r.sqrtPriceX64Next,e,n,!0)),a&&!u||(r.amountOut=Ae.getTokenAmountBFromLiquidity(r.sqrtPriceX64Next,e,n,!1))):(r.amountIn=a&&u?r.amountIn:Ae.getTokenAmountBFromLiquidity(e,r.sqrtPriceX64Next,n,!0),r.amountOut=a&&!u?r.amountOut:Ae.getTokenAmountAFromLiquidity(e,r.sqrtPriceX64Next,n,!1)),!u&&r.amountOut.gt(o.mul(Tn))&&(r.amountOut=o.mul(Tn)),u&&!r.sqrtPriceX64Next.eq(t)?r.feeAmount=o.sub(r.amountIn):r.feeAmount=le.mulDivCeil(r.amountIn,new pe(s),Cr.sub(new pe(s))),[r.sqrtPriceX64Next,r.amountIn,r.amountOut,r.feeAmount]}};var tt=60,$n=512,$=class{static getTickArrayAddressByTick(e,t,n,o){let s=$.getTickArrayStartIndexByTick(n,o),{publicKey:i}=ge(e,t,s);return i}static getTickOffsetInArray(e,t){if(e%t!=0)throw new Error("tickIndex % tickSpacing not equal 0");let n=$.getTickArrayStartIndexByTick(e,t),o=Math.floor((e-n)/t);if(o<0||o>=tt)throw new Error("tick offset in array overflow");return o}static getTickArrayBitIndex(e,t){let n=ke.tickCount(t),o=e/n;return e<0&&e%n!=0?o=Math.ceil(o)-1:o=Math.floor(o),o}static getTickArrayStartIndexByTick(e,t){return this.getTickArrayBitIndex(e,t)*ke.tickCount(t)}static getTickArrayOffsetInBitmapByTick(e,t){let n=t*tt,o=Math.floor(e/n)+512;return Math.abs(o)}static checkTickArrayIsInitialized(e,t,n){let o=n*tt,s=Math.floor(t/o)+512,i=Math.abs(s);return{isInitialized:e.testn(i),startIndex:(i-512)*o}}static getNextTickArrayStartIndex(e,t,n){return n?e-t*tt:e+t*tt}static mergeTickArrayBitmap(e){let t=new tp(0);for(let n=0;n<e.length;n++)t=t.add(e[n].shln(64*n));return t}static getInitializedTickArrayInRange(e,t,n,o,s){let i=Math.floor(o/(n*tt));return[...$.searchLowBitFromStart(e,t,i-1,s,n),...$.searchHightBitFromStart(e,t,i,s,n)]}static getAllInitializedTickArrayStartIndex(e,t,n){return $.searchHightBitFromStart(e,t,-7680,$n,n)}static getAllInitializedTickArrayInfo(e,t,n,o,s){let i=[],r=$.getAllInitializedTickArrayStartIndex(n,o,s);for(let u of r){let{publicKey:a}=ge(e,t,u);i.push({tickArrayStartIndex:u,tickArrayAddress:a})}return i}static getAllInitializedTickInTickArray(e){return e.ticks.filter(t=>t.liquidityGross.gtn(0))}static searchLowBitFromStart(e,t,n,o,s){let i=[...[...t.negativeTickArrayBitmap].reverse(),e.slice(0,8),e.slice(8,16),...t.positiveTickArrayBitmap].map(a=>$.mergeTickArrayBitmap(a)),r=[];for(;n>=-7680;){let a=Math.floor((n+7680)/512),l=(n+7680)%512;if(i[a].testn(l)&&r.push(n),n--,r.length===o)break}let u=ke.tickCount(s);return r.map(a=>a*u)}static searchHightBitFromStart(e,t,n,o,s){let i=[...[...t.negativeTickArrayBitmap].reverse(),e.slice(0,8),e.slice(8,16),...t.positiveTickArrayBitmap].map(a=>$.mergeTickArrayBitmap(a)),r=[];for(;n<7680;){let a=Math.floor((n+7680)/512),l=(n+7680)%512;if(i[a].testn(l)&&r.push(n),n++,r.length===o)break}let u=ke.tickCount(s);return r.map(a=>a*u)}static checkIsOutOfBoundary(e){return e<ft||e>Pt}static nextInitTick(e,t,n,o,s){if(ke.getArrayStartIndex(t,n)!=e.startTickIndex)return null;let r=Math.floor((t-e.startTickIndex)/n);if(o)for(;r>=0;){if(e.ticks[r].liquidityGross.gtn(0))return e.ticks[r];r=r-1}else for(s||(r=r+1);r<tt;){if(e.ticks[r].liquidityGross.gtn(0))return e.ticks[r];r=r+1}return null}static firstInitializedTick(e,t){if(t){let n=tt-1;for(;n>=0;){if(e.ticks[n].liquidityGross.gtn(0))return e.ticks[n];n=n-1}}else{let n=0;for(;n<tt;){if(e.ticks[n].liquidityGross.gtn(0))return e.ticks[n];n=n+1}}throw Error(`firstInitializedTick check error: ${e} - ${t}`)}static _getTickPriceLegacy({poolInfo:e,tick:t,baseIn:n}){let o=re.getSqrtPriceX64FromTick(t),s=re.sqrtPriceX64ToPrice(o,e.mintA.decimals,e.mintB.decimals);return n?{tick:t,price:s,tickSqrtPriceX64:o}:{tick:t,price:new Lo(1).div(s),tickSqrtPriceX64:o}}static _getPriceAndTickLegacy({poolInfo:e,price:t,baseIn:n}){let o=n?t:new Lo(1).div(t),s=to.getTickWithPriceAndTickspacing(o,e.ammConfig.tickSpacing,e.mintA.decimals,e.mintB.decimals),i=re.getSqrtPriceX64FromTick(s),r=re.sqrtPriceX64ToPrice(i,e.mintA.decimals,e.mintB.decimals);return n?{tick:s,price:r}:{tick:s,price:new Lo(1).div(r)}}static getTickPrice({poolInfo:e,tick:t,baseIn:n}){let o=re.getSqrtPriceX64FromTick(t),s=re.sqrtPriceX64ToPrice(o,e.mintA.decimals,e.mintB.decimals);return n?{tick:t,price:s,tickSqrtPriceX64:o}:{tick:t,price:new Lo(1).div(s),tickSqrtPriceX64:o}}static getPriceAndTick({poolInfo:e,price:t,baseIn:n}){let o=n?t:new Lo(1).div(t),s=to.getTickWithPriceAndTickspacing(o,e.config.tickSpacing,e.mintA.decimals,e.mintB.decimals),i=re.getSqrtPriceX64FromTick(s),r=re.sqrtPriceX64ToPrice(i,e.mintA.decimals,e.mintB.decimals);return n?{tick:s,price:r}:{tick:s,price:new Lo(1).div(r)}}};var qc=V([he(8),E("bump"),Rt("index"),N(""),lt("protocolFeeRate"),lt("tradeFeeRate"),Rt("tickSpacing"),Y(k(),8,"")]),np=V([lt("blockTimestamp"),Io("tickCumulative"),Y(k(),4)]),Uc=V([he(8),qe("initialized"),k("recentEpoch"),Rt("observationIndex"),N("poolId"),Y(np,100,"observations"),Y(k(),4)]),op=V([E("rewardState"),k("openTime"),k("endTime"),k("lastUpdateTime"),ee("emissionsPerSecondX64"),k("rewardTotalEmissioned"),k("rewardClaimed"),N("tokenMint"),N("tokenVault"),N("creator"),ee("rewardGrowthGlobalX64")]),eo=V([he(8),E("bump"),N("ammConfig"),N("creator"),N("mintA"),N("mintB"),N("vaultA"),N("vaultB"),N("observationId"),E("mintDecimalsA"),E("mintDecimalsB"),Rt("tickSpacing"),ee("liquidity"),ee("sqrtPriceX64"),Ve("tickCurrent"),lt(),ee("feeGrowthGlobalX64A"),ee("feeGrowthGlobalX64B"),k("protocolFeesTokenA"),k("protocolFeesTokenB"),ee("swapInAmountTokenA"),ee("swapOutAmountTokenB"),ee("swapInAmountTokenB"),ee("swapOutAmountTokenA"),E("status"),Y(E(),7,""),Y(op,3,"rewardInfos"),Y(k(),16,"tickArrayBitmap"),k("totalFeesTokenA"),k("totalFeesClaimedTokenA"),k("totalFeesTokenB"),k("totalFeesClaimedTokenB"),k("fundFeesTokenA"),k("fundFeesTokenB"),k("startTime"),Y(k(),15*4-3,"padding")]),ip=V([ee("growthInsideLastX64"),k("rewardAmountOwed")]),Ro=V([he(8),E("bump"),N("nftMint"),N("poolId"),Ve("tickLower"),Ve("tickUpper"),ee("liquidity"),ee("feeGrowthInsideLastX64A"),ee("feeGrowthInsideLastX64B"),k("tokenFeesOwedA"),k("tokenFeesOwedB"),Y(ip,3,"rewardInfos"),Y(k(),8,"")]),WT=V([he(8),E("bump"),N("poolId"),Ve("tickLowerIndex"),Ve("tickUpperIndex"),ee("liquidity"),ee("feeGrowthInsideLastX64A"),ee("feeGrowthInsideLastX64B"),k("tokenFeesOwedA"),k("tokenFeesOwedB"),Y(ee(),3,"rewardGrowthInside"),Y(k(),8,"")]),rp=V([Ve("tick"),oc("liquidityNet"),ee("liquidityGross"),ee("feeGrowthOutsideX64A"),ee("feeGrowthOutsideX64B"),Y(ee(),3,"rewardGrowthsOutsideX64"),Y(lt(),13,"")]),Ti=V([he(8),N("poolId"),Ve("startTickIndex"),Y(rp,tt,"ticks"),E("initializedTickCount"),Y(E(),115,"")]),Gc=V([he(329),Y(N(),100,"whitelistMints")]),Wc=V([he(8),N("poolId"),Y(Y(k(),8),wa,"positiveTickArrayBitmap"),Y(Y(k(),8),wa,"negativeTickArrayBitmap")]),qT=V([k(),E("bump"),N("owner"),N("poolId"),N("positionId"),N("nftAccount"),Y(k(),8)]),Xc=V([he(8),E("bump"),N("lockOwner"),N("poolId"),N("positionId"),N("nftAccount"),N("lockNftMint"),k("recentEpoch"),Y(k(),8)]);Uc.span;var zc=ye("Raydium_Clmm"),Nt={createPool:[233,146,209,142,207,104,64,188],initReward:[95,135,192,196,242,129,230,68],setRewardEmissions:[112,52,167,75,32,201,211,137],openPosition:[77,184,74,214,112,86,241,199],openPositionWithTokenEx:[77,255,174,82,125,29,201,46],closePosition:[123,134,81,0,49,68,98,98],increaseLiquidity:[133,29,89,223,69,238,176,10],decreaseLiquidity:[58,127,188,62,79,82,196,96],swap:[43,4,237,11,26,201,30,98],collectReward:[18,237,166,197,34,16,213,144]},Qc=[188,37,179,131,82,150,84,73],Yc=[16,72,250,198,14,162,212,19],Ke=class{static createPoolInstruction(e,t,n,o,s,i,r,u,a,l,m,p,d,f){let y=V([ee("sqrtPriceX64"),k("zero")]),b=[{pubkey:n,isSigner:!0,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!1},{pubkey:a,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:p,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!1},{pubkey:m,isSigner:!1,isWritable:!1},{pubkey:Bn.programId,isSigner:!1,isWritable:!1},{pubkey:$e,isSigner:!1,isWritable:!1},...(f==null?void 0:f.map(h=>({pubkey:h,isSigner:!1,isWritable:!1})))||[]],g=Buffer.alloc(y.span);y.encode({sqrtPriceX64:d,zero:be},g);let A=Buffer.from([...Nt.createPool,...g]);return new mt({keys:b,programId:e,data:A})}static async createPoolInstructions(e){let{programId:t,owner:n,mintA:o,mintB:s,ammConfigId:i,initialPriceX64:r,extendMintAccount:u}=e,[a,l]=[new G(o.address),new G(s.address)],{publicKey:m}=vc(t,i,a,l),{publicKey:p}=Vc(t,m),{publicKey:d}=ga(t,m,a),{publicKey:f}=ga(t,m,l),y=Ye(t,m).publicKey,b=[this.createPoolInstruction(t,m,n,i,p,a,d,new G(o.programId||Se),l,f,new G(s.programId||Se),y,r,u)];return{signers:[],instructions:b,instructionTypes:[U.CreateAccount,U.ClmmCreatePool],address:{poolId:m,observationId:p,exBitmapAccount:y,mintAVault:d,mintBVault:f},lookupTableAddress:[]}}static openPositionFromLiquidityInstruction(e,t,n,o,s,i,r,u,a,l,m,p,d,f,y,b,g,A,h,I,T,w,S,x,K,B){let C=V([Ve("tickLowerIndex"),Ve("tickUpperIndex"),Ve("tickArrayLowerStartIndex"),Ve("tickArrayUpperStartIndex"),ee("liquidity"),k("amountMaxA"),k("amountMaxB"),qe("withMetadata"),E("optionBaseFlag"),qe("baseFlag")]),O=[...B?[{pubkey:B,isSigner:!1,isWritable:!0}]:[]],M=[{pubkey:t,isSigner:!0,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:s,isSigner:!0,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:m,isSigner:!1,isWritable:!0},{pubkey:p,isSigner:!1,isWritable:!0},{pubkey:d,isSigner:!1,isWritable:!0},{pubkey:f,isSigner:!1,isWritable:!0},{pubkey:y,isSigner:!1,isWritable:!0},{pubkey:$e,isSigner:!1,isWritable:!1},{pubkey:Bn.programId,isSigner:!1,isWritable:!1},{pubkey:Se,isSigner:!1,isWritable:!1},{pubkey:Ii,isSigner:!1,isWritable:!1},{pubkey:Zt,isSigner:!1,isWritable:!1},{pubkey:Ue,isSigner:!1,isWritable:!1},{pubkey:b,isSigner:!1,isWritable:!1},{pubkey:g,isSigner:!1,isWritable:!1},...O],L=Buffer.alloc(C.span);C.encode({tickLowerIndex:A,tickUpperIndex:h,tickArrayLowerStartIndex:I,tickArrayUpperStartIndex:T,liquidity:w,amountMaxA:S,amountMaxB:x,withMetadata:K==="create",baseFlag:!1,optionBaseFlag:0},L);let R=Buffer.from([...Nt.openPosition,...L]);return new mt({keys:M,programId:e,data:R})}static openPositionFromLiquidityInstruction22(e,t,n,o,s,i,r,u,a,l,m,p,d,f,y,b,g,A,h,I,T,w,S,x,K){let B=V([Ve("tickLowerIndex"),Ve("tickUpperIndex"),Ve("tickArrayLowerStartIndex"),Ve("tickArrayUpperStartIndex"),ee("liquidity"),k("amountMaxA"),k("amountMaxB"),qe("withMetadata"),E("optionBaseFlag"),qe("baseFlag")]),C=[...K?[{pubkey:K,isSigner:!1,isWritable:!0}]:[]],O=[{pubkey:t,isSigner:!0,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:s,isSigner:!0,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:m,isSigner:!1,isWritable:!0},{pubkey:p,isSigner:!1,isWritable:!0},{pubkey:d,isSigner:!1,isWritable:!0},{pubkey:f,isSigner:!1,isWritable:!0},{pubkey:$e,isSigner:!1,isWritable:!1},{pubkey:Bn.programId,isSigner:!1,isWritable:!1},{pubkey:Se,isSigner:!1,isWritable:!1},{pubkey:Ii,isSigner:!1,isWritable:!1},{pubkey:Ue,isSigner:!1,isWritable:!1},{pubkey:y,isSigner:!1,isWritable:!1},{pubkey:b,isSigner:!1,isWritable:!1},...C],M=Buffer.alloc(B.span);B.encode({tickLowerIndex:g,tickUpperIndex:A,tickArrayLowerStartIndex:h,tickArrayUpperStartIndex:I,liquidity:T,amountMaxA:w,amountMaxB:S,withMetadata:x==="create",baseFlag:!1,optionBaseFlag:0},M);let L=Buffer.from([...Nt.openPositionWithTokenEx,...M]);return new mt({keys:O,programId:e,data:L})}static async openPositionInstructions({poolInfo:e,poolKeys:t,ownerInfo:n,tickLower:o,tickUpper:s,liquidity:i,amountMaxA:r,amountMaxB:u,withMetadata:a,getEphemeralSigners:l,nft2022:m}){let p=[],[d,f]=[new G(e.programId),new G(e.id)],y;if(l)y=new G((await l(1))[0]);else{let K=Or.generate();p.push(K),y=K.publicKey}let b=$.getTickArrayStartIndexByTick(o,e.config.tickSpacing),g=$.getTickArrayStartIndexByTick(s,e.config.tickSpacing),{publicKey:A}=ge(d,f,b),{publicKey:h}=ge(d,f,g),{publicKey:I}=m?H(n.wallet,y,Ue):H(n.wallet,y,Se),{publicKey:T}=hn(y),{publicKey:w}=kt(d,y),{publicKey:S}=on(d,f,o,s),x=m?this.openPositionFromLiquidityInstruction22(d,n.feePayer,f,n.wallet,y,I,S,A,h,w,n.tokenAccountA,n.tokenAccountB,new G(t.vault.A),new G(t.vault.B),new G(e.mintA.address),new G(e.mintB.address),o,s,b,g,i,r,u,a,Oe.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing,[b,g])?Ye(d,f).publicKey:void 0):this.openPositionFromLiquidityInstruction(d,n.feePayer,f,n.wallet,y,I,T,S,A,h,w,n.tokenAccountA,n.tokenAccountB,new G(t.vault.A),new G(t.vault.B),new G(e.mintA.address),new G(e.mintB.address),o,s,b,g,i,r,u,a,Oe.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing,[b,g])?Ye(d,f).publicKey:void 0);return{signers:p,instructions:[x],instructionTypes:[U.ClmmOpenPosition],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[],address:{nftMint:y,tickArrayLower:A,tickArrayUpper:h,positionNftAccount:I,metadataAccount:T,personalPosition:w,protocolPosition:S}}}static async openPositionFromBaseInstructions({poolInfo:e,poolKeys:t,ownerInfo:n,tickLower:o,tickUpper:s,base:i,baseAmount:r,otherAmountMax:u,withMetadata:a,getEphemeralSigners:l,nft2022:m}){let p=[],[d,f]=[new G(e.programId),new G(e.id)],y;if(l)y=new G((await l(1))[0]);else{let K=Or.generate();p.push(K),y=K.publicKey}let b=$.getTickArrayStartIndexByTick(o,e.config.tickSpacing),g=$.getTickArrayStartIndexByTick(s,e.config.tickSpacing),{publicKey:A}=ge(d,f,b),{publicKey:h}=ge(d,f,g),{publicKey:I}=m?H(n.wallet,y,Ue):H(n.wallet,y,Se),{publicKey:T}=hn(y),{publicKey:w}=kt(d,y),{publicKey:S}=on(d,f,o,s),x=m?this.openPositionFromBaseInstruction22(d,n.feePayer,f,n.wallet,y,I,S,A,h,w,n.tokenAccountA,n.tokenAccountB,new G(t.vault.A),new G(t.vault.B),new G(e.mintA.address),new G(e.mintB.address),o,s,b,g,a,i,r,u,Oe.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing,[b,g])?Ye(d,f).publicKey:void 0):this.openPositionFromBaseInstruction(d,n.feePayer,f,n.wallet,y,I,T,S,A,h,w,n.tokenAccountA,n.tokenAccountB,new G(t.vault.A),new G(t.vault.B),new G(e.mintA.address),new G(e.mintB.address),o,s,b,g,a,i,r,u,Oe.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing,[b,g])?Ye(d,f).publicKey:void 0);return{address:{nftMint:y,tickArrayLower:A,tickArrayUpper:h,positionNftAccount:I,metadataAccount:T,personalPosition:w,protocolPosition:S},instructions:[x],signers:p,instructionTypes:[U.ClmmOpenPosition],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[]}}static openPositionFromBaseInstruction(e,t,n,o,s,i,r,u,a,l,m,p,d,f,y,b,g,A,h,I,T,w,S,x,K,B){let C=V([Ve("tickLowerIndex"),Ve("tickUpperIndex"),Ve("tickArrayLowerStartIndex"),Ve("tickArrayUpperStartIndex"),ee("liquidity"),k("amountMaxA"),k("amountMaxB"),qe("withMetadata"),E("optionBaseFlag"),qe("baseFlag")]),O=[...B?[{pubkey:B,isSigner:!1,isWritable:!0}]:[]],M=[{pubkey:t,isSigner:!0,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:s,isSigner:!0,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:m,isSigner:!1,isWritable:!0},{pubkey:p,isSigner:!1,isWritable:!0},{pubkey:d,isSigner:!1,isWritable:!0},{pubkey:f,isSigner:!1,isWritable:!0},{pubkey:y,isSigner:!1,isWritable:!0},{pubkey:$e,isSigner:!1,isWritable:!1},{pubkey:Bn.programId,isSigner:!1,isWritable:!1},{pubkey:Se,isSigner:!1,isWritable:!1},{pubkey:Ii,isSigner:!1,isWritable:!1},{pubkey:Zt,isSigner:!1,isWritable:!1},{pubkey:Ue,isSigner:!1,isWritable:!1},{pubkey:b,isSigner:!1,isWritable:!1},{pubkey:g,isSigner:!1,isWritable:!1},...O],L=Buffer.alloc(C.span);C.encode({tickLowerIndex:A,tickUpperIndex:h,tickArrayLowerStartIndex:I,tickArrayUpperStartIndex:T,liquidity:new Ia(0),amountMaxA:S==="MintA"?x:K,amountMaxB:S==="MintA"?K:x,withMetadata:w==="create",baseFlag:S==="MintA",optionBaseFlag:1},L);let R=Buffer.from([...Nt.openPosition,...L]);return new mt({keys:M,programId:e,data:R})}static openPositionFromBaseInstruction22(e,t,n,o,s,i,r,u,a,l,m,p,d,f,y,b,g,A,h,I,T,w,S,x,K){let B=V([Ve("tickLowerIndex"),Ve("tickUpperIndex"),Ve("tickArrayLowerStartIndex"),Ve("tickArrayUpperStartIndex"),ee("liquidity"),k("amountMaxA"),k("amountMaxB"),qe("withMetadata"),E("optionBaseFlag"),qe("baseFlag")]),C=[...K?[{pubkey:K,isSigner:!1,isWritable:!0}]:[]],O=[{pubkey:t,isSigner:!0,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:s,isSigner:!0,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:m,isSigner:!1,isWritable:!0},{pubkey:p,isSigner:!1,isWritable:!0},{pubkey:d,isSigner:!1,isWritable:!0},{pubkey:f,isSigner:!1,isWritable:!0},{pubkey:$e,isSigner:!1,isWritable:!1},{pubkey:Bn.programId,isSigner:!1,isWritable:!1},{pubkey:Se,isSigner:!1,isWritable:!1},{pubkey:Ii,isSigner:!1,isWritable:!1},{pubkey:Ue,isSigner:!1,isWritable:!1},{pubkey:y,isSigner:!1,isWritable:!1},{pubkey:b,isSigner:!1,isWritable:!1},...C],M=Buffer.alloc(B.span);B.encode({tickLowerIndex:g,tickUpperIndex:A,tickArrayLowerStartIndex:h,tickArrayUpperStartIndex:I,liquidity:new Ia(0),amountMaxA:w==="MintA"?S:x,amountMaxB:w==="MintA"?x:S,withMetadata:T==="create",baseFlag:w==="MintA",optionBaseFlag:1},M);let L=Buffer.from([...Nt.openPositionWithTokenEx,...M]);return new mt({keys:O,programId:e,data:L})}static async openPositionFromLiquidityInstructions({poolInfo:e,poolKeys:t,ownerInfo:n,tickLower:o,tickUpper:s,liquidity:i,amountMaxA:r,amountMaxB:u,withMetadata:a,getEphemeralSigners:l,nft2022:m}){let p,d=[];if(l)p=new G((await l(1))[0]);else{let K=Or.generate();d.push(K),p=K.publicKey}let[f,y]=[new G(e.programId),new G(e.id)],b=$.getTickArrayStartIndexByTick(o,e.config.tickSpacing),g=$.getTickArrayStartIndexByTick(s,e.config.tickSpacing),{publicKey:A}=ge(f,y,b),{publicKey:h}=ge(f,y,g),{publicKey:I}=m?H(n.wallet,p,Ue):H(n.wallet,p,Se),{publicKey:T}=hn(p),{publicKey:w}=kt(f,p),{publicKey:S}=on(f,y,o,s),x=m?this.openPositionFromLiquidityInstruction22(f,n.wallet,y,n.wallet,p,I,S,A,h,w,n.tokenAccountA,n.tokenAccountB,new G(t.vault.A),new G(t.vault.B),new G(t.mintA.address),new G(t.mintB.address),o,s,b,g,i,r,u,a,Oe.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing,[b,g])?Ye(f,y).publicKey:void 0):this.openPositionFromLiquidityInstruction(f,n.wallet,y,n.wallet,p,I,T,S,A,h,w,n.tokenAccountA,n.tokenAccountB,new G(t.vault.A),new G(t.vault.B),new G(t.mintA.address),new G(t.mintB.address),o,s,b,g,i,r,u,a,Oe.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing,[b,g])?Ye(f,y).publicKey:void 0);return{address:{nftMint:p,tickArrayLower:A,tickArrayUpper:h,positionNftAccount:I,metadataAccount:T,personalPosition:w,protocolPosition:S},instructions:[x],signers:d,instructionTypes:[U.ClmmOpenPosition],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[]}}static closePositionInstruction(e,t,n,o,s,i){let r=V([]),u=[{pubkey:t,isSigner:!0,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:Bn.programId,isSigner:!1,isWritable:!1},{pubkey:i?Ue:Se,isSigner:!1,isWritable:!1}],a=Buffer.alloc(r.span);r.encode({},a);let l=Buffer.from([...Nt.closePosition,...a]);return new mt({keys:u,programId:e,data:l})}static closePositionInstructions({poolInfo:e,poolKeys:t,ownerInfo:n,ownerPosition:o,nft2022:s}){let i=new G(e.programId),r=s?H(n.wallet,o.nftMint,Ue).publicKey:H(n.wallet,o.nftMint,Se).publicKey,{publicKey:u}=kt(i,o.nftMint),a=[];return a.push(this.closePositionInstruction(i,n.wallet,o.nftMint,r,u,s)),{address:{positionNftAccount:r,personalPosition:u},signers:[],instructions:a,instructionTypes:[U.ClmmClosePosition],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[]}}static increasePositionFromLiquidityInstruction(e,t,n,o,s,i,r,u,a,l,m,p,d,f,y,b,g,A){let h=V([ee("liquidity"),k("amountMaxA"),k("amountMaxB"),E("optionBaseFlag"),qe("baseFlag")]),I=[...A?[{pubkey:A,isSigner:!1,isWritable:!0}]:[]],T=[{pubkey:t,isSigner:!0,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:m,isSigner:!1,isWritable:!0},{pubkey:p,isSigner:!1,isWritable:!0},{pubkey:Se,isSigner:!1,isWritable:!1},{pubkey:Ue,isSigner:!1,isWritable:!1},{pubkey:d,isSigner:!1,isWritable:!1},{pubkey:f,isSigner:!1,isWritable:!1},...I],w=Buffer.alloc(h.span);h.encode({liquidity:y,amountMaxA:b,amountMaxB:g,optionBaseFlag:0,baseFlag:!1},w);let S=Buffer.from([...Nt.increaseLiquidity,...w]);return new mt({keys:T,programId:e,data:S})}static increasePositionFromLiquidityInstructions({poolInfo:e,poolKeys:t,ownerPosition:n,ownerInfo:o,liquidity:s,amountMaxA:i,amountMaxB:r,nft2022:u}){let[a,l]=[new G(e.programId),new G(e.id)],m=$.getTickArrayStartIndexByTick(n.tickLower,e.config.tickSpacing),p=$.getTickArrayStartIndexByTick(n.tickUpper,e.config.tickSpacing),{publicKey:d}=ge(a,l,m),{publicKey:f}=ge(a,l,p),{publicKey:y}=u?H(o.wallet,n.nftMint,Ue):H(o.wallet,n.nftMint,Se),{publicKey:b}=kt(a,n.nftMint),{publicKey:g}=on(a,l,n.tickLower,n.tickUpper),A=this.increasePositionFromLiquidityInstruction(a,o.wallet,y,b,l,g,d,f,o.tokenAccountA,o.tokenAccountB,new G(t.vault.A),new G(t.vault.B),new G(e.mintA.address),new G(e.mintB.address),s,i,r,Oe.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing,[m,p])?Ye(a,l).publicKey:void 0);return{address:{tickArrayLower:d,tickArrayUpper:f,positionNftAccount:y,personalPosition:b,protocolPosition:g},signers:[],instructions:[A],instructionTypes:[U.ClmmIncreasePosition],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[]}}static increasePositionFromBaseInstructions({poolInfo:e,poolKeys:t,ownerPosition:n,ownerInfo:o,base:s,baseAmount:i,otherAmountMax:r,nft2022:u}){let[a,l]=[new G(e.programId),new G(e.id)],m=$.getTickArrayStartIndexByTick(n.tickLower,e.config.tickSpacing),p=$.getTickArrayStartIndexByTick(n.tickUpper,e.config.tickSpacing),{publicKey:d}=ge(a,l,m),{publicKey:f}=ge(a,l,p),{publicKey:y}=u?H(o.wallet,n.nftMint,Ue):H(o.wallet,n.nftMint,Se),{publicKey:b}=kt(a,n.nftMint),{publicKey:g}=on(a,l,n.tickLower,n.tickUpper);return{address:{tickArrayLower:d,tickArrayUpper:f,positionNftAccount:y,personalPosition:b,protocolPosition:g},instructions:[this.increasePositionFromBaseInstruction(a,o.wallet,y,b,l,g,d,f,o.tokenAccountA,o.tokenAccountB,new G(t.vault.A),new G(t.vault.B),new G(e.mintA.address),new G(e.mintB.address),s,i,r,Oe.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing,[m,p])?Ye(a,l).publicKey:void 0)],signers:[],instructionTypes:[U.ClmmIncreasePosition],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[]}}static increasePositionFromBaseInstruction(e,t,n,o,s,i,r,u,a,l,m,p,d,f,y,b,g,A){let h=V([ee("liquidity"),k("amountMaxA"),k("amountMaxB"),E("optionBaseFlag"),qe("baseFlag")]),I=[...A?[{pubkey:A,isSigner:!1,isWritable:!0}]:[]],T=[{pubkey:t,isSigner:!0,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:m,isSigner:!1,isWritable:!0},{pubkey:p,isSigner:!1,isWritable:!0},{pubkey:Se,isSigner:!1,isWritable:!1},{pubkey:Ue,isSigner:!1,isWritable:!1},{pubkey:d,isSigner:!1,isWritable:!1},{pubkey:f,isSigner:!1,isWritable:!1},...I],w=Buffer.alloc(h.span);h.encode({liquidity:new Ia(0),amountMaxA:y==="MintA"?b:g,amountMaxB:y==="MintA"?g:b,baseFlag:y==="MintA",optionBaseFlag:1},w);let S=Buffer.from([...Nt.increaseLiquidity,...w]);return new mt({keys:T,programId:e,data:S})}static decreaseLiquidityInstruction(e,t,n,o,s,i,r,u,a,l,m,p,d,f,y,b,g,A,h){let I=V([ee("liquidity"),k("amountMinA"),k("amountMinB")]),T=[...h?[{pubkey:h,isSigner:!1,isWritable:!0}]:[],...y.map(K=>[{pubkey:K.poolRewardVault,isSigner:!1,isWritable:!0},{pubkey:K.ownerRewardVault,isSigner:!1,isWritable:!0},{pubkey:K.rewardMint,isSigner:!1,isWritable:!1}]).flat()],w=[{pubkey:t,isSigner:!0,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:m,isSigner:!1,isWritable:!0},{pubkey:p,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:Se,isSigner:!1,isWritable:!1},{pubkey:Ue,isSigner:!1,isWritable:!1},{pubkey:nr,isSigner:!1,isWritable:!1},{pubkey:d,isSigner:!1,isWritable:!1},{pubkey:f,isSigner:!1,isWritable:!1},...T],S=Buffer.alloc(I.span);I.encode({liquidity:b,amountMinA:g,amountMinB:A},S);let x=Buffer.from([...Nt.decreaseLiquidity,...S]);return new mt({keys:w,programId:e,data:x})}static decreaseLiquidityInstructions({poolInfo:e,poolKeys:t,ownerPosition:n,ownerInfo:o,liquidity:s,amountMinA:i,amountMinB:r,programId:u,nft2022:a}){let[l,m]=[new G(e.programId),new G(e.id)],p=$.getTickArrayStartIndexByTick(n.tickLower,e.config.tickSpacing),d=$.getTickArrayStartIndexByTick(n.tickUpper,e.config.tickSpacing),{publicKey:f}=ge(l,m,p),{publicKey:y}=ge(l,m,d),{publicKey:b}=a?H(o.wallet,n.nftMint,Ue):H(o.wallet,n.nftMint,u),{publicKey:g}=kt(l,n.nftMint),{publicKey:A}=on(l,m,n.tickLower,n.tickUpper),h=[];for(let w=0;w<e.rewardDefaultInfos.length;w++)h.push({poolRewardVault:new G(t.rewardInfos[w].vault),ownerRewardVault:o.rewardAccounts[w],rewardMint:new G(e.rewardDefaultInfos[w].mint.address)});let I=[],T=this.decreaseLiquidityInstruction(l,o.wallet,b,g,m,A,f,y,o.tokenAccountA,o.tokenAccountB,new G(t.vault.A),new G(t.vault.B),new G(e.mintA.address),new G(e.mintB.address),h,s,i,r,Oe.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing,[p,d])?Ye(l,m).publicKey:void 0);return I.push(T),{address:{tickArrayLower:f,tickArrayUpper:y,positionNftAccount:b,personalPosition:g,protocolPosition:A},signers:[],instructions:I,instructionTypes:[U.ClmmDecreasePosition],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[]}}static swapInstruction(e,t,n,o,s,i,r,u,a,l,m,p,d,f,y,b,g){let A=V([k("amount"),k("otherAmountThreshold"),ee("sqrtPriceLimitX64"),qe("isBaseInput")]),h=[...g?[{pubkey:g,isSigner:!1,isWritable:!0}]:[],...m.map(S=>({pubkey:S,isSigner:!1,isWritable:!0}))],I=[{pubkey:t,isSigner:!0,isWritable:!1},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:p,isSigner:!1,isWritable:!0},{pubkey:Se,isSigner:!1,isWritable:!1},{pubkey:Ue,isSigner:!1,isWritable:!1},{pubkey:nr,isSigner:!1,isWritable:!1},{pubkey:a,isSigner:!1,isWritable:!1},{pubkey:l,isSigner:!1,isWritable:!1},...h],T=Buffer.alloc(A.span);A.encode({amount:d,otherAmountThreshold:f,sqrtPriceLimitX64:y,isBaseInput:b},T);let w=Buffer.from([...Nt.swap,...T]);return new mt({keys:I,programId:e,data:w})}static makeSwapBaseInInstructions({poolInfo:e,poolKeys:t,observationId:n,ownerInfo:o,inputMint:s,amountIn:i,amountOutMin:r,sqrtPriceLimitX64:u,remainingAccounts:a}){let[l,m]=[new G(e.programId),new G(e.id)],[p,d]=[new G(t.vault.A),new G(t.vault.B)],[f,y]=[new G(e.mintA.address),new G(e.mintB.address)],b=e.mintA.address===s.toString(),g=[this.swapInstruction(l,o.wallet,m,new G(e.config.id),b?o.tokenAccountA:o.tokenAccountB,b?o.tokenAccountB:o.tokenAccountA,b?p:d,b?d:p,b?f:y,b?y:f,a,n,i,r,u,!0,Ye(l,m).publicKey)];return{signers:[],instructions:g,instructionTypes:[U.ClmmSwapBaseIn],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[],address:{}}}static makeSwapBaseOutInstructions({poolInfo:e,poolKeys:t,observationId:n,ownerInfo:o,outputMint:s,amountOut:i,amountInMax:r,sqrtPriceLimitX64:u,remainingAccounts:a}){let[l,m]=[new G(e.programId),new G(e.id)],[p,d]=[new G(t.vault.A),new G(t.vault.B)],[f,y]=[new G(e.mintA.address),new G(e.mintB.address)],b=e.mintA.address===s.toBase58(),g=[this.swapInstruction(l,o.wallet,m,new G(e.config.id),b?o.tokenAccountB:o.tokenAccountA,b?o.tokenAccountA:o.tokenAccountB,b?d:p,b?p:d,b?y:f,b?f:y,a,n,i,r,u,!1,Ye(l,m).publicKey)];return{signers:[],instructions:g,instructionTypes:[U.ClmmSwapBaseOut],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[],address:{}}}static initRewardInstruction(e,t,n,o,s,i,r,u,a,l,m,p){let d=V([k("openTime"),k("endTime"),ee("emissionsPerSecondX64")]),f=[{pubkey:t,isSigner:!0,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!1},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!1},{pubkey:Bn.programId,isSigner:!1,isWritable:!1},{pubkey:$e,isSigner:!1,isWritable:!1}],y=Buffer.alloc(d.span);d.encode({openTime:J(l),endTime:J(m),emissionsPerSecondX64:p},y);let b=Buffer.from([...Nt.initReward,...y]);return new mt({keys:f,programId:e,data:b})}static initRewardInstructions({poolInfo:e,poolKeys:t,ownerInfo:n,rewardInfo:o}){let[s,i]=[new G(e.programId),new G(e.id)],r=Fc(s,i,o.mint).publicKey,u=ki(s).publicKey,a=[this.initRewardInstruction(s,n.wallet,i,u,new G(e.config.id),n.tokenAccount,o.programId,o.mint,r,o.openTime,o.endTime,o.emissionsPerSecondX64)];return{address:{poolRewardVault:r,operationId:u},signers:[],instructions:a,instructionTypes:[U.ClmmInitReward],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[]}}static setRewardInstruction(e,t,n,o,s,i,r,u,a,l,m,p){let d=V([E("rewardIndex"),ee("emissionsPerSecondX64"),k("openTime"),k("endTime")]),f=[{pubkey:t,isSigner:!0,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:Se,isSigner:!1,isWritable:!1},{pubkey:Ue,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0}],y=Buffer.alloc(d.span);d.encode({rewardIndex:a,emissionsPerSecondX64:p,openTime:J(l),endTime:J(m)},y);let b=Buffer.from([...Nt.setRewardEmissions,...y]);return new mt({keys:f,programId:e,data:b})}static setRewardInstructions({poolInfo:e,poolKeys:t,ownerInfo:n,rewardInfo:o}){let[s,i]=[new G(e.programId),new G(e.id)],r,u,a;for(let p=0;p<e.rewardDefaultInfos.length;p++)e.rewardDefaultInfos[p].mint.address===o.mint.toString()&&(r=p,u=new G(t.rewardInfos[p].vault),a=new G(t.rewardInfos[p].mint.address));(r===void 0||u===void 0)&&zc.logWithError("reward mint check error","no reward mint",e.rewardDefaultInfos);let l=ki(s).publicKey,m=[this.setRewardInstruction(s,n.wallet,i,l,new G(e.config.id),n.tokenAccount,u,a,r,o.openTime,o.endTime,o.emissionsPerSecondX64)];return{address:{rewardVault:u,operationId:l},signers:[],instructions:m,instructionTypes:[U.ClmmSetReward],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[]}}static collectRewardInstruction(e,t,n,o,s,i,r){let u=V([E("rewardIndex")]),a=[{pubkey:t,isSigner:!0,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!1},{pubkey:Se,isSigner:!1,isWritable:!1},{pubkey:Ue,isSigner:!1,isWritable:!1},{pubkey:nr,isSigner:!1,isWritable:!1}],l=Buffer.alloc(u.span);u.encode({rewardIndex:r},l);let m=Buffer.from([...Nt.collectReward,...l]);return new mt({keys:a,programId:e,data:m})}static collectRewardInstructions({poolInfo:e,poolKeys:t,ownerInfo:n,rewardMint:o}){let[s,i]=[new G(e.programId),new G(e.id)],r,u;for(let l=0;l<e.rewardDefaultInfos.length;l++)e.rewardDefaultInfos[l].mint.address===o.toString()&&(r=l,u=new G(t.rewardInfos[l].vault));(r===void 0||u===void 0)&&zc.logWithError("reward mint check error","no reward mint",e.rewardDefaultInfos);let a=[this.collectRewardInstruction(s,n.wallet,i,n.tokenAccount,u,o,r)];return{address:{rewardVault:u},signers:[],instructions:a,instructionTypes:[U.ClmmCollectReward],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[]}}static async makeLockPositions({programId:e,authProgramId:t,poolProgramId:n,payer:o,wallet:s,nftMint:i,nft2022:r,getEphemeralSigners:u}){let a=[],l;if(u)l=new G((await u(1))[0]);else{let g=Or.generate();a.push(g),l=g.publicKey}let m=r?H(s,i,Ue).publicKey:H(s,i,Se).publicKey,{publicKey:p}=kt(n,i),d=Co(e,l).publicKey,f=H(s,l,Se).publicKey,y=hn(l).publicKey,b=Ke.lockPositionInstructionV2({programId:e,auth:t,payer:o,positionOwner:s,lockOwner:s,positionNftAccount:m,positionId:p,lockPositionId:d,lockNftMint:l,lockNftAccount:f,metadataAccount:y,withMetadata:!0,nft2022:r,positionNftMint:i,authPositionNftAccount:H(t,i,r?Ue:Se).publicKey,positionNftProgram:r?Ue:Se});return{address:{positionId:p,lockPositionId:d,lockNftAccount:f,lockNftMint:l,positionNftAccount:m,metadataAccount:y},instructions:[b],signers:a,instructionTypes:[U.ClmmLockPosition],lookupTableAddress:[]}}static lockPositionInstructionV2({programId:e,auth:t,payer:n,positionOwner:o,lockOwner:s,positionNftAccount:i,positionId:r,positionNftMint:u,authPositionNftAccount:a,positionNftProgram:l,lockPositionId:m,lockNftMint:p,lockNftAccount:d,metadataAccount:f,withMetadata:y}){let b=[{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!0,isWritable:!0},{pubkey:o,isSigner:!0,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!1},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!1},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:m,isSigner:!1,isWritable:!0},{pubkey:p,isSigner:!0,isWritable:!0},{pubkey:d,isSigner:!1,isWritable:!0},{pubkey:f,isSigner:!1,isWritable:!0},{pubkey:Zt,isSigner:!1,isWritable:!1},{pubkey:Ii,isSigner:!1,isWritable:!1},{pubkey:$e,isSigner:!1,isWritable:!1},{pubkey:Se,isSigner:!1,isWritable:!1},{pubkey:l,isSigner:!1,isWritable:!1},{pubkey:Bn.programId,isSigner:!1,isWritable:!1}],g=V([qe("withMetadata")]),A=Buffer.alloc(g.span);g.encode({withMetadata:y},A);let h=Buffer.from([...Qc,...A]);return new mt({keys:b,programId:e,data:h})}static lockPositionInstruction({programId:e,authProgramId:t,poolProgramId:n,owner:o,positionNft:s}){let{publicKey:i}=H(o,s,Se),{publicKey:r}=kt(n,s),u=[{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!0,isWritable:!1},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!1},{pubkey:Aa(e,r).publicKey,isSigner:!1,isWritable:!0},{pubkey:Se,isSigner:!1,isWritable:!1},{pubkey:Bn.programId,isSigner:!1,isWritable:!1}];return new mt({keys:u,programId:e,data:Buffer.from(Qc)})}static harvestLockPositionInstruction(e){let[t,n]=[new G(e.poolKeys.programId),new G(e.poolKeys.id)],o=$.getTickArrayStartIndexByTick(e.ownerPosition.tickLower,e.poolKeys.config.tickSpacing),s=$.getTickArrayStartIndexByTick(e.ownerPosition.tickUpper,e.poolKeys.config.tickSpacing),{publicKey:i}=ge(t,n,o),{publicKey:r}=ge(t,n,s),{publicKey:u}=H(e.owner,e.ownerPosition.nftMint,Se),{publicKey:a}=kt(t,e.ownerPosition.nftMint),{publicKey:l}=on(t,n,e.ownerPosition.tickLower,e.ownerPosition.tickUpper),m=[];for(let f=0;f<e.poolKeys.rewardInfos.length;f++)m.push({poolRewardVault:new G(e.poolKeys.rewardInfos[f].vault),ownerRewardVault:e.ownerRewardAccounts[f],rewardMint:new G(e.poolKeys.rewardInfos[f].mint.address)});let p=[...m.map(f=>[{pubkey:f.poolRewardVault,isSigner:!1,isWritable:!0},{pubkey:f.ownerRewardVault,isSigner:!1,isWritable:!0},{pubkey:f.rewardMint,isSigner:!1,isWritable:!1}]).flat()],d=[{pubkey:e.authProgramId,isSigner:!1,isWritable:!1},{pubkey:Aa(e.programId,a).publicKey,isSigner:!1,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:e.owner,isSigner:!0,isWritable:!1},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:new G(e.poolKeys.vault.A),isSigner:!1,isWritable:!0},{pubkey:new G(e.poolKeys.vault.B),isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:e.userVaultA,isSigner:!1,isWritable:!0},{pubkey:e.userVaultB,isSigner:!1,isWritable:!0},{pubkey:Se,isSigner:!1,isWritable:!1},{pubkey:Ue,isSigner:!1,isWritable:!1},{pubkey:un,isSigner:!1,isWritable:!1},{pubkey:new G(e.poolKeys.mintA.address),isSigner:!1,isWritable:!1},{pubkey:new G(e.poolKeys.mintB.address),isSigner:!1,isWritable:!1},...p];return new mt({keys:d,programId:e.programId,data:Buffer.from(Yc)})}static harvestLockPositionInstructionV2({programId:e,auth:t,lockPositionId:n,clmmProgram:o,lockOwner:s,lockNftMint:i,lockNftAccount:r,positionNftAccount:u,positionId:a,poolId:l,protocolPosition:m,vaultA:p,vaultB:d,tickArrayLower:f,tickArrayUpper:y,userVaultA:b,userVaultB:g,mintA:A,mintB:h,rewardAccounts:I,exTickArrayBitmap:T}){let w=[...T?[{pubkey:T,isSigner:!1,isWritable:!0}]:[],...I.map(x=>[{pubkey:x.poolRewardVault,isSigner:!1,isWritable:!0},{pubkey:x.ownerRewardVault,isSigner:!1,isWritable:!0},{pubkey:x.rewardMint,isSigner:!1,isWritable:!1}]).flat()],S=[{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:s,isSigner:!0,isWritable:!1},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:m,isSigner:!1,isWritable:!0},{pubkey:p,isSigner:!1,isWritable:!0},{pubkey:d,isSigner:!1,isWritable:!0},{pubkey:f,isSigner:!1,isWritable:!0},{pubkey:y,isSigner:!1,isWritable:!0},{pubkey:b,isSigner:!1,isWritable:!0},{pubkey:g,isSigner:!1,isWritable:!0},{pubkey:Se,isSigner:!1,isWritable:!1},{pubkey:Ue,isSigner:!1,isWritable:!1},{pubkey:un,isSigner:!1,isWritable:!1},{pubkey:A,isSigner:!1,isWritable:!1},{pubkey:h,isSigner:!1,isWritable:!1},...w];return new mt({keys:S,programId:e,data:Buffer.from(Yc)})}};var jc=V([lt("mintAuthorityOption"),N("mintAuthority"),k("supply"),E("decimals"),E("isInitialized"),lt("freezeAuthorityOption"),N("freezeAuthority")]);import{PublicKey as sp}from"@solana/web3.js";import{MintLayout as Hc,TOKEN_PROGRAM_ID as ap}from"@solana/spl-token";var yh=async({connection:c,mint:e})=>{let t=await c.getAccountInfo(new sp(e));return!t||t.data.length!==Hc.span?void 0:Hc.decode(t.data)},bh=({mint:c,decimals:e,programId:t=ap,logoURI:n="",priority:o=3})=>{let s=c.toBase58().substring(0,6);return{address:c.toBase58(),decimals:e,symbol:s,logoURI:n,extensions:{},chainId:101,programId:t.toString(),name:s,tags:[],priority:o}},Nr=c=>new We({mint:c.address,decimals:c.decimals,symbol:c.symbol,name:c.name}),Bi=o=>{var s=o,{amount:c,isRaw:e,name:t}=s,n=Ee(s,["amount","isRaw","name"]);return new xe(new We({mint:dt(n.address).toBase58(),decimals:n.decimals,symbol:n.symbol,name:t}),c,e,t)};function gh(c){return c.address===an.address?it:c}function Ah(c){return c.address===it.address?an:c}var yt=o=>{var s=o,{address:c,programId:e,decimals:t}=s,n=Ee(s,["address","programId","decimals"]);return v({chainId:101,address:dt(c).toBase58(),programId:e,logoURI:"",symbol:"",name:"",decimals:t,tags:[],extensions:n.extensions||{}},n)},Vn=c=>c?q(v({},c),{transferFeeConfigAuthority:c.transferFeeConfigAuthority.toBase58(),withdrawWithheldAuthority:c.withdrawWithheldAuthority.toBase58(),withheldAmount:c.withheldAmount.toString(),olderTransferFee:q(v({},c.olderTransferFee),{epoch:c.olderTransferFee.epoch.toString(),maximumFee:c.olderTransferFee.maximumFee.toString()}),newerTransferFee:q(v({},c.newerTransferFee),{epoch:c.newerTransferFee.epoch.toString(),maximumFee:c.newerTransferFee.maximumFee.toString()})}):void 0;import Zc from"bn.js";var Ba=new Zc(25),Mr=new Zc(1e4),up={4:3,5:3};import{PublicKey as Ce,SystemProgram as el,SYSVAR_RENT_PUBKEY as lp,TransactionInstruction as xn}from"@solana/web3.js";import{ASSOCIATED_TOKEN_PROGRAM_ID as mp,TOKEN_PROGRAM_ID as Oo}from"@solana/spl-token";var xa=V([E("instruction"),k("amountIn"),k("minAmountOut")]),Sa=V([E("instruction"),k("maxAmountIn"),k("amountOut")]),Ch=V([E("instruction"),E("nonce")]),Ka=V([E("instruction"),E("nonce"),k("startTime")]),no=V([k("status"),k("nonce"),k("maxOrder"),k("depth"),k("baseDecimal"),k("quoteDecimal"),k("state"),k("resetFlag"),k("minSize"),k("volMaxCutRatio"),k("amountWaveRatio"),k("baseLotSize"),k("quoteLotSize"),k("minPriceMultiplier"),k("maxPriceMultiplier"),k("systemDecimalValue"),k("minSeparateNumerator"),k("minSeparateDenominator"),k("tradeFeeNumerator"),k("tradeFeeDenominator"),k("pnlNumerator"),k("pnlDenominator"),k("swapFeeNumerator"),k("swapFeeDenominator"),k("baseNeedTakePnl"),k("quoteNeedTakePnl"),k("quoteTotalPnl"),k("baseTotalPnl"),k("poolOpenTime"),k("punishPcAmount"),k("punishCoinAmount"),k("orderbookToInitTime"),ee("swapBaseInAmount"),ee("swapQuoteOutAmount"),k("swapBase2QuoteFee"),ee("swapQuoteInAmount"),ee("swapBaseOutAmount"),k("swapQuote2BaseFee"),N("baseVault"),N("quoteVault"),N("baseMint"),N("quoteMint"),N("lpMint"),N("openOrders"),N("marketId"),N("marketProgramId"),N("targetOrders"),N("withdrawQueue"),N("lpVault"),N("owner"),k("lpReserve"),Y(k(),3,"padding")]),cp=V([k("accountType"),k("status"),k("nonce"),k("maxOrder"),k("depth"),k("baseDecimal"),k("quoteDecimal"),k("state"),k("resetFlag"),k("minSize"),k("volMaxCutRatio"),k("amountWaveRatio"),k("baseLotSize"),k("quoteLotSize"),k("minPriceMultiplier"),k("maxPriceMultiplier"),k("systemDecimalsValue"),k("abortTradeFactor"),k("priceTickMultiplier"),k("priceTick"),k("minSeparateNumerator"),k("minSeparateDenominator"),k("tradeFeeNumerator"),k("tradeFeeDenominator"),k("pnlNumerator"),k("pnlDenominator"),k("swapFeeNumerator"),k("swapFeeDenominator"),k("baseNeedTakePnl"),k("quoteNeedTakePnl"),k("quoteTotalPnl"),k("baseTotalPnl"),k("poolOpenTime"),k("punishPcAmount"),k("punishCoinAmount"),k("orderbookToInitTime"),ee("swapBaseInAmount"),ee("swapQuoteOutAmount"),ee("swapQuoteInAmount"),ee("swapBaseOutAmount"),k("swapQuote2BaseFee"),k("swapBase2QuoteFee"),N("baseVault"),N("quoteVault"),N("baseMint"),N("quoteMint"),N("lpMint"),N("modelDataAccount"),N("openOrders"),N("marketId"),N("marketProgramId"),N("targetOrders"),N("owner"),Y(k(),64,"padding")]),Ca=V([E("instruction"),k("baseAmountIn"),k("quoteAmountIn"),k("fixedSide"),k("otherAmountMin")]),Ra=V([E("instruction"),k("lpAmount"),k("baseAmountMin"),k("quoteAmountMin")]),Rh={4:no,5:cp},$c=V([k("fee")]);var Jc=ye("Raydium_liquidity_instruction");function tl(c){let{poolInfo:e,poolKeys:t,userKeys:n,baseAmountIn:o,quoteAmountIn:s,fixedSide:i,otherAmountMin:r,modelDataPubKey:u=Ln}=c,a=Buffer.alloc(Ca.span);Ca.encode({instruction:3,baseAmountIn:J(o),quoteAmountIn:J(s),otherAmountMin:J(r),fixedSide:i==="base"?ht:Ru},a);let l=[P({pubkey:Oo,isWritable:!1}),P({pubkey:new Ce(e.id)}),P({pubkey:new Ce(t.authority),isWritable:!1}),P({pubkey:new Ce(t.openOrders),isWritable:!1}),P({pubkey:new Ce(t.targetOrders)}),P({pubkey:new Ce(e.lpMint.address)}),P({pubkey:new Ce(t.vault.A)}),P({pubkey:new Ce(t.vault.B)})];return e.pooltype.includes("StablePool")&&l.push(P({pubkey:u})),l.push(P({pubkey:new Ce(e.marketId),isWritable:!1}),P({pubkey:n.baseTokenAccount}),P({pubkey:n.quoteTokenAccount}),P({pubkey:n.lpTokenAccount}),P({pubkey:n.owner,isWritable:!1,isSigner:!0}),P({pubkey:new Ce(t.marketEventQueue),isWritable:!1})),new xn({programId:new Ce(e.programId),keys:l,data:a})}function La(c){let{poolInfo:e,poolKeys:t,userKeys:n,lpAmount:o,baseAmountMin:s,quoteAmountMin:i,modelDataPubKey:r=Ln}=c,u=Me(t),a=4;if(e.pooltype.includes("StablePool")&&(a=5),a===4||a===5){let l=Buffer.alloc(Ra.span);Ra.encode({instruction:4,lpAmount:J(o),baseAmountMin:J(s),quoteAmountMin:J(i)},l);let m=[P({pubkey:Oo,isWritable:!1}),P({pubkey:u.id}),P({pubkey:u.authority,isWritable:!1}),P({pubkey:u.openOrders}),P({pubkey:u.targetOrders}),P({pubkey:u.mintLp.address}),P({pubkey:u.vault.A}),P({pubkey:u.vault.B})];return a===5?m.push(P({pubkey:r})):(m.push(P({pubkey:u.id})),m.push(P({pubkey:u.id}))),m.push(P({pubkey:u.marketProgramId,isWritable:!1}),P({pubkey:u.marketId}),P({pubkey:u.marketBaseVault}),P({pubkey:u.marketQuoteVault}),P({pubkey:u.marketAuthority,isWritable:!1}),P({pubkey:n.lpTokenAccount}),P({pubkey:n.baseTokenAccount}),P({pubkey:n.quoteTokenAccount}),P({pubkey:n.owner,isWritable:!1,isSigner:!0}),P({pubkey:u.marketEventQueue}),P({pubkey:u.marketBids}),P({pubkey:u.marketAsks})),new xn({programId:u.programId,keys:m,data:l})}return new xn({programId:u.programId,keys:[]})}function Oa({programId:c,ammId:e,ammAuthority:t,ammOpenOrders:n,lpMint:o,coinMint:s,pcMint:i,coinVault:r,pcVault:u,withdrawQueue:a,ammTargetOrders:l,poolTempLp:m,marketProgramId:p,marketId:d,userWallet:f,userCoinVault:y,userPcVault:b,userLpVault:g,nonce:A,openTime:h,coinAmount:I,pcAmount:T,ammConfigId:w,feeDestinationId:S}){let x=V([E("instruction"),E("nonce"),k("openTime"),k("pcAmount"),k("coinAmount")]),K=[{pubkey:Oo,isSigner:!1,isWritable:!1},{pubkey:mp,isSigner:!1,isWritable:!1},{pubkey:el.programId,isSigner:!1,isWritable:!1},{pubkey:$e,isSigner:!1,isWritable:!1},{pubkey:e,isSigner:!1,isWritable:!0},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!1},{pubkey:i,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:w,isSigner:!1,isWritable:!1},{pubkey:S,isSigner:!1,isWritable:!0},{pubkey:p,isSigner:!1,isWritable:!1},{pubkey:d,isSigner:!1,isWritable:!1},{pubkey:f,isSigner:!0,isWritable:!0},{pubkey:y,isSigner:!1,isWritable:!0},{pubkey:b,isSigner:!1,isWritable:!0},{pubkey:g,isSigner:!1,isWritable:!0}],B=Buffer.alloc(x.span);return x.encode({instruction:1,nonce:A,openTime:h,coinAmount:I,pcAmount:T},B),{instruction:new xn({keys:K,programId:c,data:B}),instructionType:U.AmmV4CreatePool}}function Wh(c){let e=V([E("instruction"),E("simulateType")]),t=Buffer.alloc(e.span);e.encode({instruction:12,simulateType:0},t);let n=[P({pubkey:new Ce(c.id),isWritable:!1}),P({pubkey:new Ce(c.authority),isWritable:!1}),P({pubkey:new Ce(c.openOrders),isWritable:!1}),P({pubkey:new Ce(c.vault.A),isWritable:!1}),P({pubkey:new Ce(c.vault.B),isWritable:!1}),P({pubkey:new Ce(c.mintLp.address),isWritable:!1}),P({pubkey:new Ce(c.marketId),isWritable:!1}),P({pubkey:new Ce(c.marketEventQueue),isWritable:!1})];return new xn({programId:new Ce(c.programId),keys:n,data:t})}function dp({poolKeys:c,userKeys:e,amountIn:t,minAmountOut:n,modelDataPubKey:o=Ln},s){let i=Me(c),r=Buffer.alloc(xa.span);xa.encode({instruction:9,amountIn:J(t),minAmountOut:J(n)},r);let u=[P({pubkey:Oo,isWritable:!1}),P({pubkey:i.id}),P({pubkey:i.authority,isWritable:!1}),P({pubkey:i.openOrders})];return s===4&&u.push(P({pubkey:i.targetOrders})),u.push(P({pubkey:i.vault.A}),P({pubkey:i.vault.B})),s===5&&u.push(P({pubkey:o})),u.push(P({pubkey:i.marketProgramId,isWritable:!1}),P({pubkey:i.marketId}),P({pubkey:i.marketBids}),P({pubkey:i.marketAsks}),P({pubkey:i.marketEventQueue}),P({pubkey:i.marketBaseVault}),P({pubkey:i.marketQuoteVault}),P({pubkey:i.marketAuthority,isWritable:!1}),P({pubkey:e.tokenAccountIn}),P({pubkey:e.tokenAccountOut}),P({pubkey:e.owner,isWritable:!1,isSigner:!0})),new xn({programId:i.programId,keys:u,data:r})}function pp({poolKeys:c,userKeys:e,maxAmountIn:t,amountOut:n,modelDataPubKey:o=Ln},s){let i=Me(c),r=Buffer.alloc(Sa.span);Sa.encode({instruction:11,maxAmountIn:J(t),amountOut:J(n)},r);let u=[P({pubkey:Oo,isWritable:!1}),P({pubkey:i.id}),P({pubkey:i.authority,isWritable:!1}),P({pubkey:i.openOrders}),P({pubkey:i.targetOrders}),P({pubkey:i.vault.A}),P({pubkey:i.vault.B})];return s===5&&u.push(P({pubkey:o})),u.push(P({pubkey:i.marketProgramId,isWritable:!1}),P({pubkey:i.marketId}),P({pubkey:i.marketBids}),P({pubkey:i.marketAsks}),P({pubkey:i.marketEventQueue}),P({pubkey:i.marketBaseVault}),P({pubkey:i.marketQuoteVault}),P({pubkey:i.marketAuthority,isWritable:!1}),P({pubkey:e.tokenAccountIn}),P({pubkey:e.tokenAccountOut}),P({pubkey:e.owner,isWritable:!1,isSigner:!0})),new xn({programId:i.programId,keys:u,data:r})}function vr(c){let{poolKeys:e,version:t,userKeys:n,amountIn:o,amountOut:s,fixedSide:i}=c;if(t===4||t===5){let r={poolKeys:e,userKeys:n};if(i==="in")return dp(q(v({},r),{amountIn:o,minAmountOut:s}),t);if(i==="out")return pp(q(v({},r),{maxAmountIn:o,amountOut:s}),t);Jc.logWithError("invalid params","params",c)}throw Jc.logWithError("invalid version","poolKeys.version",t),new Error("invalid version")}function qh({poolKeys:c,userKeys:e,startTime:t}){let n=Buffer.alloc(Ka.span);Ka.encode({instruction:0,nonce:5,startTime:J(t)},n);let o=Me(c),s=[P({pubkey:Oo,isWritable:!1}),P({pubkey:el.programId,isWritable:!1}),P({pubkey:lp,isWritable:!1}),P({pubkey:o.id}),P({pubkey:o.authority,isWritable:!1}),P({pubkey:o.openOrders}),P({pubkey:o.mintLp.address}),P({pubkey:o.mintA.address,isWritable:!1}),P({pubkey:o.mintB.address,isWritable:!1}),P({pubkey:o.vault.A,isWritable:!1}),P({pubkey:o.vault.B,isWritable:!1}),P({pubkey:o.id}),P({pubkey:o.targetOrders}),P({pubkey:e.lpTokenAccount}),P({pubkey:o.id,isWritable:!1}),P({pubkey:o.marketProgramId,isWritable:!1}),P({pubkey:o.marketId,isWritable:!1}),P({pubkey:e.payer,isSigner:!0})];return new xn({programId:o.programId,keys:s,data:n})}function nl({poolKeys:c}){let e=V([E("instruction"),E("simulateType")]),t=Buffer.alloc(e.span);e.encode({instruction:12,simulateType:0},t);let n=[P({pubkey:new Ce(c.id),isWritable:!1}),P({pubkey:new Ce(c.authority),isWritable:!1}),P({pubkey:new Ce(c.openOrders),isWritable:!1}),P({pubkey:new Ce(c.vault.A),isWritable:!1}),P({pubkey:new Ce(c.vault.B),isWritable:!1}),P({pubkey:new Ce(c.mintLp.address),isWritable:!1}),P({pubkey:new Ce(c.marketId),isWritable:!1}),P({pubkey:new Ce(c.marketEventQueue),isWritable:!1})];return{instruction:new xn({programId:new Ce(c.programId),keys:n,data:t})}}var io=5e4,fp=V([k("x"),k("y"),k("price")]),yp=V([k("accountType"),k("status"),k("multiplier"),k("validDataCount"),Y(fp,io,"DataElement")]);function bp(c,e){return[0,io-2]}function gp(c){return[0,io-2]}function Ap(c){return[0,io-2]}function Pp(c,e,t){let[n,o]=bp(e,t),s=n,i=o,r=0,u=e*c.multiplier/t;for(;s<=i;){if(r=Math.floor((i+s)/2),r===0||r>=io-2)return[r,r,!1];let a=c.DataElement[r].x*c.multiplier/c.DataElement[r].y,l=c.DataElement[r-1].x*c.multiplier/c.DataElement[r-1].y,m=c.DataElement[r+1].x*c.multiplier/c.DataElement[r+1].y;if(u===a)return[r,r,!0];if(u===l)return[r-1,r-1,!0];if(u===m)return[r+1,r+1,!0];if(u<l)i=r-1;else{if(u>l&&u<a)return[r-1,r,!0];if(u>a&&u<m)return[r,r+1,!0];s=r+1}}return[r,r,!1]}function Na(c,e,t){let[n,o,s]=Pp(c,e,t);if(!s)return 0;if(n===o){let i=c.DataElement[n].x;return e*c.multiplier/i}else{let i=c.DataElement[n].x,r=c.DataElement[n].y,u=c.DataElement[o].x,a=c.DataElement[o].y,l=t*(u*r-i*a),m=i*l,p=(u-i)*(e*r-i*t)*a,d=m+p;return e*c.multiplier*l/d}}function oo(c,e,t){return e*c.multiplier/t}function ol(c,e,t){return e*t/c.multiplier}function kp(c,e){let[t,n]=gp(e),o=t,s=n,i=0,r=e;for(;o<s;){if(i=Math.floor((s+o)/2),i<=0||i>io-2)return[i,i,!1];let u=c.DataElement[i].x,a=c.DataElement[i-1].x,l=c.DataElement[i+1].x;if(r===u)return[i,i,!0];if(r===a)return[i-1,i-1,!0];if(r===l)return[i+1,i+1,!0];if(r<a)s=i-1;else{if(r>a&&r<u)return[i-1,i,!0];if(r>u&&r<l)return[i,i+1,!0];o=i+1}}return[i,i,!1]}function wp(c,e){let[t,n]=Ap(e),o=t,s=n,i=0,r=e;for(;o<=s;){if(i=Math.floor((s+o)/2),i<=0||i>=io-2)return[i,i,!1];let u=c.DataElement[i].y,a=c.DataElement[i-1].y,l=c.DataElement[i+1].y;if(r===u)return[i,i,!0];if(r===a)return[i-1,i-1,!0];if(r===l)return[i+1,i+1,!0];if(r<l)o=i+1;else{if(r<a&&r>u)return[i-1,i,!0];if(r<u&&r>l)return[i,i+1,!0];s=i-1}}return[i,i,!1]}function il(c,e,t,n){let o=n?e+t:e-t,[s,i,r]=kp(c,o);if(!r)return[0,0,!1,r];if(s===i)return[c.DataElement[i].price,c.DataElement[i].y,!1,r];{let u=c.DataElement[s].x,a=c.DataElement[i].x,l=c.DataElement[s].price,m=c.DataElement[i].price,p=c.DataElement[s].y,d=c.DataElement[i].y;if(e>=u&&e<=a)return n?[m,d,!0,r]:[l,p,!0,r];{let f,y;return n?(f=l+(m-l)*(e-u)/(a-u),y=p-(o-u)*c.multiplier/m):(f=l+(m-l)*(e-u)/(a-u),y=d+(a-o)*c.multiplier/l),[f,y,!1,r]}}}function Tp(c,e,t,n){let o=n?e-t:e+t,[s,i,r]=wp(c,o);if(!r)return[0,0,!1,r];if(s===i)return[c.DataElement[i].price,c.DataElement[i].x,!1,r];{let u=c.DataElement[s].x,a=c.DataElement[i].x,l=c.DataElement[s].price,m=c.DataElement[i].price,p=c.DataElement[s].y,d=c.DataElement[i].y;if(e>=d&&e<=p)return n?[m,a,!0,r]:[l,u,!0,r];{let f,y;return n?(f=l+(m-l)*(p-e)/(p-d),y=u+m*(p-o)/c.multiplier):(f=l+(m-l)*(p-e)/(p-d),y=a-l*(o-d)/c.multiplier),[f,y,!1,r]}}}function hp(c,e){let t=il(c,e,0,!1);return t[3]?t[0]:0}function rl(c,e,t,n){let o=Na(c,e,t),s=oo(c,e,o),i=oo(c,t,o),r=oo(c,n,o),u=!0,[a,l,m,p]=il(c,s,r,u);if(!p)return 0;if(m)return n*c.multiplier/a;{let d=i-l;return ol(c,d,o)}}function sl(c,e,t,n){let o=Na(c,e,t),s=oo(c,e,o),i=oo(c,t,o),r=oo(c,n,o),u=!1,[a,l,m,p]=Tp(c,i,r,u);if(!p)return 0;if(m)return n*a/c.multiplier;{let d=s-l;return ol(c,d,o)}}function Ip(c){let e=yp.decode(c);return{accountType:e.accountType.toNumber(),status:e.status.toNumber(),multiplier:e.multiplier.toNumber(),validDataCount:e.validDataCount.toNumber(),DataElement:e.DataElement.map(t=>({x:t.x.toNumber(),y:t.y.toNumber(),price:t.price.toNumber()}))}}function al(c,e,t,n){let o=hp(c,oo(c,e,Na(c,e,t)))/c.multiplier;return n?o:1/o}var No=class{constructor({connection:e,modelDataPubKey:t=Ln}){this._layoutData={accountType:0,status:0,multiplier:0,validDataCount:0,DataElement:[]};this.connection=e,this.modelDataPubKey=t}get stableModelData(){return this._layoutData}async initStableModelLayout(){if(this._layoutData.validDataCount===0&&this.connection){let e=await this.connection.getAccountInfo(this.modelDataPubKey);e&&(this._layoutData=Ip(e==null?void 0:e.data))}}};import{PublicKey as Si}from"@solana/web3.js";import xi from"bn.js";import Fr from"decimal.js";import{TOKEN_PROGRAM_ID as Sp}from"@solana/spl-token";import{PublicKey as Bp}from"@solana/web3.js";var xp=ye("Raydium_liquidity_serum");function ul({programId:c,marketId:e}){let t=[e.toBuffer()],n=0,o;for(;n<100;){try{let s=t.concat(Buffer.from([n]),Buffer.alloc(7));o=Bp.createProgramAddressSync(s,c)}catch(s){if(s instanceof TypeError)throw s;n++;continue}return{publicKey:o,nonce:n}}throw xp.logWithError("unable to find a viable program address nonce","params",{programId:c,marketId:e}),new Error("unable to find a viable program address nonce")}function Vr({programId:c}){let{publicKey:e}=ne([Buffer.from("amm_config_account_seed","utf-8")],c);return e}function ro({name:c,programId:e,marketId:t}){let{publicKey:n}=ne([e.toBuffer(),t.toBuffer(),Buffer.from(c,"utf-8")],e);return n}function Kp({programId:c,marketId:e}){let{publicKey:t}=ne([c.toBuffer(),e.toBuffer(),Buffer.from("open_order_associated_seed","utf-8")],c);return t}function Fa({programId:c}){return ne([Buffer.from([97,109,109,32,97,117,116,104,111,114,105,116,121])],c)}function Va({version:c,marketVersion:e,marketId:t,baseMint:n,quoteMint:o,baseDecimals:s,quoteDecimals:i,programId:r,marketProgramId:u}){let a=ro({name:"amm_associated_seed",programId:r,marketId:t}),l=ro({name:"lp_mint_associated_seed",programId:r,marketId:t}),{publicKey:m,nonce:p}=Fa({programId:r}),d=ro({name:"coin_vault_associated_seed",programId:r,marketId:t}),f=ro({name:"pc_vault_associated_seed",programId:r,marketId:t}),y=ro({name:"temp_lp_token_associated_seed",programId:r,marketId:t}),b=Kp({programId:r,marketId:t}),g=ro({name:"target_associated_seed",programId:r,marketId:t}),A=ro({name:"withdraw_associated_seed",programId:r,marketId:t}),{publicKey:h}=ul({programId:u,marketId:t});return{id:a,baseMint:n,quoteMint:o,lpMint:l,baseDecimals:s,quoteDecimals:i,lpDecimals:s,version:c,programId:r,authority:m,nonce:p,baseVault:d,quoteVault:f,lpVault:y,openOrders:b,targetOrders:g,withdrawQueue:A,marketVersion:e,marketProgramId:u,marketId:t,marketAuthority:h,lookupTableAccount:Si.default,configId:Vr({programId:r})}}var Ma;async function yI({connection:c,poolKeysList:e,config:t,modelDataPubKey:n}){return e.find(s=>s.modelDataAccount)&&(Ma||(Ma=new No({connection:c,modelDataPubKey:n}),await Ma.initStableModelLayout())),await Promise.all(e.map(async s=>{if(s.modelDataAccount){let i=nl({poolKeys:s});return(await Eu(c,[i.instruction],"GetPoolData")).map(a=>{let l=Du(a,"GetPoolData"),m=new xi(bn(l,"status")),p=Number(bn(l,"coin_decimals")),d=Number(bn(l,"pc_decimals")),f=Number(bn(l,"lp_decimals")),y=new xi(bn(l,"pool_coin_amount")),b=new xi(bn(l,"pool_pc_amount")),g=new xi(bn(l,"pool_lp_supply")),A="0";try{A=bn(l,"pool_open_time")}catch{}return{status:m,baseDecimals:p,quoteDecimals:d,lpDecimals:f,baseReserve:y,quoteReserve:b,lpSupply:g,startTime:new xi(A)}})[0]}else{let[i,r,u,a]=await c.getMultipleAccountsInfo([new Si(s.id),new Si(s.vault.A),new Si(s.vault.B),new Si(s.mintLp.address)]);if(i===null)throw Error("fetch pool error");if(r===null)throw Error("fetch vaultAccA error");if(u===null)throw Error("fetch vaultAccB error");if(a===null)throw Error("fetch mintAccLp error");let l=no.decode(i.data),m=nn.decode(r.data),p=nn.decode(u.data),d=jc.decode(a.data);return{status:l.status,baseDecimals:l.baseDecimal.toNumber(),quoteDecimals:l.quoteDecimal.toNumber(),lpDecimals:d.decimals,baseReserve:m.amount.sub(l.baseNeedTakePnl),quoteReserve:p.amount.sub(l.quoteNeedTakePnl),lpSupply:l.lpReserve,startTime:l.poolOpenTime}}}))}var va={volume:0,volumeQuote:0,volumeFee:0,apr:0,feeApr:0,priceMin:0,priceMax:0,rewardApr:[]},_r=c=>{let e={},t=Sp.toBase58();return Object.keys(c).map(n=>{let o=c[n],[s,i]=[o.baseMint.toBase58(),o.quoteMint.toBase58()];e[n]={id:n,version:4,status:o.status.toNumber(),programId:o.programId.toBase58(),mintA:yt({address:s,programId:t,decimals:o.baseDecimal.toNumber()}),mintB:yt({address:i,programId:t,decimals:o.quoteDecimal.toNumber()}),rewardDefaultInfos:[],rewardDefaultPoolInfos:"Ecosystem",price:o.poolPrice.toNumber(),mintAmountA:new Fr(o.mintAAmount.toString()).div(10**o.baseDecimal.toNumber()).toNumber(),mintAmountB:new Fr(o.mintBAmount.toString()).div(10**o.quoteDecimal.toNumber()).toNumber(),baseReserve:o.baseReserve,quoteReserve:o.quoteReserve,feeRate:new Fr(o.tradeFeeNumerator.toString()).div(o.tradeFeeDenominator.toString()).toNumber(),openTime:o.poolOpenTime.toString(),tvl:0,day:va,week:va,month:va,pooltype:[],farmUpcomingCount:0,farmOngoingCount:0,farmFinishedCount:0,type:"Standard",marketId:o.marketId.toBase58(),configId:Vr({programId:o.programId}).toBase58(),lpPrice:0,lpAmount:new Fr(o.lpReserve.toString()).div(10**Math.min(o.baseDecimal.toNumber(),o.quoteDecimal.toNumber())).toNumber(),lpMint:yt({address:o.lpMint.toBase58(),programId:t,decimals:Math.min(o.baseDecimal.toNumber(),o.quoteDecimal.toNumber())}),burnPercent:0}}),e};import Ge from"bn.js";import Re from"decimal.js";import{PublicKey as Ki}from"@solana/web3.js";import Ci from"bn.js";import{TOKEN_PROGRAM_ID as dl}from"@solana/spl-token";import{SystemProgram as so,SYSVAR_RENT_PUBKEY as Rp,Transaction as cl,TransactionInstruction as Lp}from"@solana/web3.js";import{createInitializeAccountInstruction as ll,TOKEN_PROGRAM_ID as ml}from"@solana/spl-token";function Cp(c="accountFlags"){let e=new hr(c);return e.addBoolean("initialized"),e.addBoolean("market"),e.addBoolean("openOrders"),e.addBoolean("requestQueue"),e.addBoolean("eventQueue"),e.addBoolean("bids"),e.addBoolean("asks"),e}var _a=V([he(5),Cp("accountFlags"),N("ownAddress"),k("vaultSignerNonce"),N("baseMint"),N("quoteMint"),N("baseVault"),k("baseDepositsTotal"),k("baseFeesAccrued"),N("quoteVault"),k("quoteDepositsTotal"),k("quoteFeesAccrued"),k("quoteDustThreshold"),N("requestQueue"),N("eventQueue"),N("bids"),N("asks"),k("baseLotSize"),k("quoteLotSize"),k("feeRateBps"),k("referrerRebatesAccrued"),he(7)]);function Op({programId:c,marketInfo:e}){let t=V([E("version"),lt("instruction"),k("baseLotSize"),k("quoteLotSize"),Rt("feeRateBps"),k("vaultSignerNonce"),k("quoteDustThreshold")]),n=[{pubkey:e.id,isSigner:!1,isWritable:!0},{pubkey:e.requestQueue,isSigner:!1,isWritable:!0},{pubkey:e.eventQueue,isSigner:!1,isWritable:!0},{pubkey:e.bids,isSigner:!1,isWritable:!0},{pubkey:e.asks,isSigner:!1,isWritable:!0},{pubkey:e.baseVault,isSigner:!1,isWritable:!0},{pubkey:e.quoteVault,isSigner:!1,isWritable:!0},{pubkey:e.baseMint,isSigner:!1,isWritable:!1},{pubkey:e.quoteMint,isSigner:!1,isWritable:!1},{pubkey:e.authority?e.quoteMint:Rp,isSigner:!1,isWritable:!1}].concat(e.authority?{pubkey:e.authority,isSigner:!1,isWritable:!1}:[]).concat(e.authority&&e.pruneAuthority?{pubkey:e.pruneAuthority,isSigner:!1,isWritable:!1}:[]),o=Buffer.alloc(t.span);return t.encode({version:0,instruction:0,baseLotSize:e.baseLotSize,quoteLotSize:e.quoteLotSize,feeRateBps:e.feeRateBps,vaultSignerNonce:e.vaultSignerNonce,quoteDustThreshold:e.quoteDustThreshold},o),new Lp({keys:n,programId:c,data:o})}async function Er({connection:c,wallet:e,marketInfo:t}){var i,r,u,a,l,m,p,d;let n=new cl,o=await c.getMinimumBalanceForRentExemption(165);n.add(so.createAccountWithSeed({fromPubkey:e,basePubkey:e,seed:t.baseVault.seed,newAccountPubkey:t.baseVault.publicKey,lamports:o,space:165,programId:ml}),so.createAccountWithSeed({fromPubkey:e,basePubkey:e,seed:t.quoteVault.seed,newAccountPubkey:t.quoteVault.publicKey,lamports:o,space:165,programId:ml}),ll(t.baseVault.publicKey,t.baseMint,t.vaultOwner),ll(t.quoteVault.publicKey,t.quoteMint,t.vaultOwner),so.createAccountWithSeed({fromPubkey:e,basePubkey:e,seed:t.id.seed,newAccountPubkey:t.id.publicKey,lamports:await c.getMinimumBalanceForRentExemption(_a.span),space:_a.span,programId:t.programId}));let s=new cl;return s.add(so.createAccountWithSeed({fromPubkey:e,basePubkey:e,seed:t.requestQueue.seed,newAccountPubkey:t.requestQueue.publicKey,lamports:t.lowestFeeMarket?6208320:await c.getMinimumBalanceForRentExemption((i=t.requestQueueSpace)!=null?i:5120+12),space:t.lowestFeeMarket?764:(r=t.requestQueueSpace)!=null?r:5120+12,programId:t.programId}),so.createAccountWithSeed({fromPubkey:e,basePubkey:e,seed:t.eventQueue.seed,newAccountPubkey:t.eventQueue.publicKey,lamports:t.lowestFeeMarket?79594560:await c.getMinimumBalanceForRentExemption((u=t.eventQueueSpace)!=null?u:262144+12),space:t.lowestFeeMarket?11308:(a=t.eventQueueSpace)!=null?a:262144+12,programId:t.programId}),so.createAccountWithSeed({fromPubkey:e,basePubkey:e,seed:t.bids.seed,newAccountPubkey:t.bids.publicKey,lamports:t.lowestFeeMarket?101977920:await c.getMinimumBalanceForRentExemption((l=t.orderbookQueueSpace)!=null?l:65536+12),space:t.lowestFeeMarket?14524:(m=t.orderbookQueueSpace)!=null?m:65536+12,programId:t.programId}),so.createAccountWithSeed({fromPubkey:e,basePubkey:e,seed:t.asks.seed,newAccountPubkey:t.asks.publicKey,lamports:t.lowestFeeMarket?101977920:await c.getMinimumBalanceForRentExemption((p=t.orderbookQueueSpace)!=null?p:65536+12),space:t.lowestFeeMarket?14524:(d=t.orderbookQueueSpace)!=null?d:65536+12,programId:t.programId}),Op({programId:t.programId,marketInfo:{id:t.id.publicKey,requestQueue:t.requestQueue.publicKey,eventQueue:t.eventQueue.publicKey,bids:t.bids.publicKey,asks:t.asks.publicKey,baseVault:t.baseVault.publicKey,quoteVault:t.quoteVault.publicKey,baseMint:t.baseMint,quoteMint:t.quoteMint,baseLotSize:t.baseLotSize,quoteLotSize:t.quoteLotSize,feeRateBps:t.feeRateBps,vaultSignerNonce:t.vaultSignerNonce,quoteDustThreshold:t.quoteDustThreshold}})),[{transaction:n,signer:[],instructionTypes:[U.CreateAccount,U.CreateAccount,U.InitAccount,U.InitAccount]},{transaction:s,signer:[],instructionTypes:[U.CreateAccount,U.CreateAccount,U.CreateAccount,U.CreateAccount,U.CreateAccount,U.InitMarket]}]}var Mo=class extends Fe{async create({baseInfo:e,quoteInfo:t,lotSize:n,tickSize:o,dexProgramId:s,requestQueueSpace:i,eventQueueSpace:r,orderbookQueueSpace:u,lowestFeeMarket:a,assignSeed:l,txVersion:m,computeBudgetConfig:p,txTipConfig:d,feePayer:f}){let y=this.scope.ownerPubKey,b=l?`${e.mint.toBase58().slice(0,10)}-${t.mint.toBase58().slice(0,10)}-${l}`:void 0,g=Qe({fromPublicKey:y,programId:s,assignSeed:b&&`${b}-market`}),A=Qe({fromPublicKey:y,programId:s,assignSeed:b&&`${b}-request`}),h=Qe({fromPublicKey:y,programId:s,assignSeed:b&&`${b}-event`}),I=Qe({fromPublicKey:y,programId:s,assignSeed:b&&`${b}-bids`}),T=Qe({fromPublicKey:y,programId:s,assignSeed:b&&`${b}-asks`}),w=Qe({fromPublicKey:y,programId:dl,assignSeed:b&&`${b}-baseVault`}),S=Qe({fromPublicKey:y,programId:dl,assignSeed:b&&`${b}-quoteVault`}),x=0,K=new Ci(100);function B(){let X=new Ci(0);for(;;)try{return{vaultOwner:Ki.createProgramAddressSync([g.publicKey.toBuffer(),X.toArrayLike(Buffer,"le",8)],s),vaultSignerNonce:X}}catch{if(X.iaddn(1),X.gt(new Ci(25555)))throw Error("find vault owner error")}}let{vaultOwner:C,vaultSignerNonce:O}=B(),M=new Ci(Math.round(10**e.decimals*n)),L=new Ci(Math.round(n*10**t.decimals*o));if(M.eq(ht))throw Error("lot size is too small");if(L.eq(ht))throw Error("tick size or lot size is too small");let R=await Er({connection:this.scope.connection,wallet:this.scope.ownerPubKey,marketInfo:{programId:s,id:g,baseMint:e.mint,quoteMint:t.mint,baseVault:w,quoteVault:S,vaultOwner:C,requestQueue:A,eventQueue:h,bids:I,asks:T,feeRateBps:x,quoteDustThreshold:K,vaultSignerNonce:O,baseLotSize:M,quoteLotSize:L,requestQueueSpace:i,eventQueueSpace:r,orderbookQueueSpace:u,lowestFeeMarket:a}}),_=this.createTxBuilder(f);_.addInstruction({instructions:R[0].transaction.instructions,signers:R[0].signer});for await(let X of R.slice(1,R.length))_.addInstruction({instructions:X.transaction.instructions,signers:X.signer,instructionTypes:X.instructionTypes});return m===0?_.sizeCheckBuildV0({computeBudgetConfig:p,address:{marketId:g.publicKey,requestQueue:A.publicKey,eventQueue:h.publicKey,bids:I.publicKey,asks:T.publicKey,baseVault:w.publicKey,quoteVault:S.publicKey,baseMint:new Ki(e.mint),quoteMint:new Ki(t.mint)}}):_.sizeCheckBuild({computeBudgetConfig:p,address:{marketId:g.publicKey,requestQueue:A.publicKey,eventQueue:h.publicKey,bids:I.publicKey,asks:T.publicKey,baseVault:w.publicKey,quoteVault:S.publicKey,baseMint:new Ki(e.mint),quoteMint:new Ki(t.mint)}})}};var Ri=class extends Fe{constructor(t){super(t);this.stableLayout=new No({connection:this.scope.connection,modelDataPubKey:this.scope.cluster==="mainnet"?void 0:An.MODEL_DATA_PUBKEY})}async initLayout(){await this.stableLayout.initStableModelLayout()}async load(){this.checkDisabled()}computePairAmount({poolInfo:t,amount:n,slippage:o,baseIn:s}){let i=new Ge(new Re(n).mul(10**t[s?"mintA":"mintB"].decimals).toFixed(0)),r=Nr(t[s?"mintB":"mintA"]),[u,a]=[new Ge(new Re(t.mintAmountA).mul(10**t.mintA.decimals).toString()),new Ge(new Re(t.mintAmountB).mul(10**t.mintB.decimals).toString())],l=new Ge(new Re(t.lpAmount).mul(10**t.lpMint.decimals).toFixed(0,Re.ROUND_DOWN));this.logDebug("baseReserve:",u.toString(),"quoteReserve:",a.toString()),this.logDebug("tokenIn:",s?t.mintA.symbol:t.mintB.symbol,"amountIn:",i.toString(),"anotherToken:",s?t.mintB.symbol:t.mintA.symbol,"slippage:",`${o.toSignificant()}%`,"baseReserve",u.toString(),"quoteReserve",a.toString());let m=s?"base":"quote";this.logDebug("input side:",m);let p=ht;i.isZero()||(p=m==="base"?sr(i.mul(a),u):sr(i.mul(u),a)),this.logDebug("amountRaw:",p.toString(),"lpAmount:",l.toString());let d=sr(i.mul(l),m==="base"?u:a);this.logDebug("liquidity:",d.toString());let f=new st(new Ge(1)).add(o),y=new st(new Ge(1)).sub(o),b=f.mul(p).quotient,g=y.mul(p).quotient,A=new xe(r,p),h=new xe(r,b),I=new xe(r,g);return this.logDebug("anotherAmount:",A.toFixed(),"maxAnotherAmount:",h.toFixed()),{anotherAmount:A,maxAnotherAmount:h,minAnotherAmount:I,liquidity:d}}async getAmmPoolKeys(t){return(await this.scope.api.fetchPoolKeysById({idList:[t]}))[0]}async addLiquidity(t){let{poolInfo:n,poolKeys:o,amountInA:s,amountInB:i,otherAmountMin:r,fixedSide:u,config:a,txVersion:l,computeBudgetConfig:m,txTipConfig:p,feePayer:d}=t;this.scope.availability.addStandardPosition===!1&&this.logAndCreateError("add liquidity feature disabled in your region"),this.logDebug("amountInA:",s,"amountInB:",i),(s.isZero()||i.isZero())&&this.logAndCreateError("amounts must greater than zero","amountInA & amountInB",{amountInA:s.toFixed(),amountInB:i.toFixed()});let{account:f}=this.scope,{bypassAssociatedCheck:y,checkCreateATAOwner:b}=v({bypassAssociatedCheck:!1,checkCreateATAOwner:!1},a),[g,A]=[s.token,i.token],h=await f.getCreatedTokenAccount({mint:g.mint,associatedOnly:!1}),I=await f.getCreatedTokenAccount({mint:A.mint,associatedOnly:!1});!h&&!I&&this.logAndCreateError("cannot found target token accounts","tokenAccounts",f.tokenAccounts);let T=await f.getCreatedTokenAccount({mint:new Ze(n.lpMint.address)}),w=[g,A],S=[h,I],x=[s.raw,i.raw],K=s.token.mint.toBase58()===n.mintA.address?"base":"quote",B="base";["quote","base"].includes(K)||this.logAndCreateError("invalid fixedSide","fixedSide",u),K==="quote"?(w.reverse(),S.reverse(),x.reverse(),B=u==="a"?"quote":"base"):K==="base"&&(B=u==="a"?"base":"quote");let[C,O]=w,[M,L]=S,[R,_]=x,X=o!=null?o:await this.getAmmPoolKeys(n.id),j=this.createTxBuilder(d),te=await f.handleTokenAccount({side:"in",amount:R,mint:C.mint,tokenAccount:M,bypassAssociatedCheck:y,checkCreateATAOwner:b}),{tokenAccount:ae}=te,ue=Ee(te,["tokenAccount"]);j.addInstruction(ue);let Ie=await f.handleTokenAccount({side:"in",amount:_,mint:O.mint,tokenAccount:L,bypassAssociatedCheck:y,checkCreateATAOwner:b}),{tokenAccount:ie}=Ie,me=Ee(Ie,["tokenAccount"]);j.addInstruction(me);let ze=await f.handleTokenAccount({side:"out",amount:0,mint:new Ze(n.lpMint.address),tokenAccount:T,bypassAssociatedCheck:y,checkCreateATAOwner:b}),{tokenAccount:fe}=ze,de=Ee(ze,["tokenAccount"]);return j.addInstruction(de),j.addInstruction({instructions:[tl({poolInfo:n,poolKeys:X,userKeys:{baseTokenAccount:ae,quoteTokenAccount:ie,lpTokenAccount:fe,owner:this.scope.ownerPubKey},baseAmountIn:R,quoteAmountIn:_,otherAmountMin:r.raw,fixedSide:B})],instructionTypes:[n.pooltype.includes("StablePool")?U.AmmV5AddLiquidity:U.AmmV4AddLiquidity],lookupTableAddress:X.lookupTableAccount?[X.lookupTableAccount]:[]}),j.addCustomComputeBudget(m),j.addTipInstruction(p),l===0?await j.buildV0():j.build()}async removeLiquidity(t){this.scope.availability.removeStandardPosition===!1&&this.logAndCreateError("remove liquidity feature disabled in your region");let{poolInfo:n,poolKeys:o,lpAmount:s,baseAmountMin:i,quoteAmountMin:r,config:u,txVersion:a,computeBudgetConfig:l,txTipConfig:m,feePayer:p}=t,d=o!=null?o:await this.getAmmPoolKeys(n.id),[f,y,b]=[new Ze(n.mintA.address),new Ze(n.mintB.address),new Ze(n.lpMint.address)];this.logDebug("lpAmount:",s),this.logDebug("baseAmountMin:",i),this.logDebug("quoteAmountMin:",r),s.isZero()&&this.logAndCreateError("amount must greater than zero","lpAmount",s.toString());let{account:g}=this.scope,A=await g.getCreatedTokenAccount({mint:b,associatedOnly:!1});A||this.logAndCreateError("cannot found lpTokenAccount","tokenAccounts",g.tokenAccounts);let h=await g.getCreatedTokenAccount({mint:f}),I=await g.getCreatedTokenAccount({mint:y}),T=this.createTxBuilder(p),{bypassAssociatedCheck:w,checkCreateATAOwner:S}=v({bypassAssociatedCheck:!1,checkCreateATAOwner:!1},u),O=await g.handleTokenAccount({side:"out",amount:0,mint:f,tokenAccount:h,bypassAssociatedCheck:w,checkCreateATAOwner:S}),{tokenAccount:x}=O,K=Ee(O,["tokenAccount"]);T.addInstruction(K);let M=await g.handleTokenAccount({side:"out",amount:0,mint:y,tokenAccount:I,bypassAssociatedCheck:w,checkCreateATAOwner:S}),{tokenAccount:B}=M,C=Ee(M,["tokenAccount"]);return T.addInstruction(C),T.addInstruction({instructions:[La({poolInfo:n,poolKeys:d,userKeys:{lpTokenAccount:A,baseTokenAccount:x,quoteTokenAccount:B,owner:this.scope.ownerPubKey},lpAmount:s,baseAmountMin:i,quoteAmountMin:r})],lookupTableAddress:d.lookupTableAccount?[d.lookupTableAccount]:[],instructionTypes:[n.pooltype.includes("StablePool")?U.AmmV5RemoveLiquidity:U.AmmV4RemoveLiquidity]}),T.addCustomComputeBudget(l),T.addTipInstruction(m),a===0?await T.buildV0():T.build()}async removeAllLpAndCreateClmmPosition({poolInfo:t,clmmPoolInfo:n,removeLpAmount:o,createPositionInfo:s,farmInfo:i,userFarmLpAmount:r,base:u,computeBudgetConfig:a,payer:l,userAuxiliaryLedgers:m,tokenProgram:p=_n,checkCreateATAOwner:d=!0,getEphemeralSigners:f,txVersion:y,feePayer:b}){if((this.scope.availability.removeStandardPosition===!1||this.scope.availability.createConcentratedPosition===!1)&&this.logAndCreateError("remove liquidity or create position feature disabled in your region"),!(t.mintA.address===n.mintA.address||t.mintA.address===n.mintB.address)||!(t.mintB.address===n.mintA.address||t.mintB.address===n.mintB.address))throw Error("mint check error");let g=this.createTxBuilder(b),A={};for(let X of this.scope.account.tokenAccountRawInfos)(A[X.accountInfo.mint.toString()]===void 0||H(this.scope.ownerPubKey,X.accountInfo.mint,_n).publicKey.equals(X.pubkey))&&(A[X.accountInfo.mint.toString()]=X.pubkey);let h=A[t.lpMint.address];if(h===void 0)throw Error("find lp account error in trade accounts");let I=o.add(r!=null?r:new Ge(0)),T=t.mintA.address===We.WSOL.mint.toString(),w=t.mintB.address===We.WSOL.mint.toString(),{account:S,instructionParams:x}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:_n,mint:new Ze(t.mintA.address),owner:this.scope.ownerPubKey,createInfo:T?{payer:this.scope.ownerPubKey}:void 0,skipCloseAccount:!T,notUseTokenAccount:T,associatedOnly:!0,checkCreateATAOwner:d});if(g.addInstruction(x||{}),S===void 0)throw new Error("base token account not found");let{account:K,instructionParams:B}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:_n,mint:new Ze(t.mintB.address),owner:this.scope.ownerPubKey,createInfo:w?{payer:this.scope.ownerPubKey,amount:0}:void 0,skipCloseAccount:!w,notUseTokenAccount:w,associatedOnly:!0,checkCreateATAOwner:d});if(g.addInstruction(B||{}),K===void 0)throw new Error("quote token account not found");if(A[t.mintA.address]=S,A[t.mintB.address]=K,i!==void 0&&!(r!=null&&r.isZero())){let X=Et[i.programId],j=pt({programId:new Ze(i.programId),poolId:new Ze(i.id),owner:this.scope.ownerPubKey,version:X}),ae,ue=await this.scope.connection.getAccountInfo(j);if(ue&&(ae=So(X).decode(ue.data)),X!==6&&!ae){let{instruction:ze,instructionType:Ne}=di({id:new Ze(i.id),programId:new Ze(i.programId),version:X,ledger:j,owner:this.scope.ownerPubKey});g.addInstruction({instructions:[ze],instructionTypes:[Ne]})}let ie=[];for(let ze of i.rewardInfos){let Ne=ze.mint.address===We.WSOL.mint.toString();if(A[ze.mint.address])ie.push(A[ze.mint.address]);else{let{account:_t,instructionParams:nt}=await this.scope.account.getOrCreateTokenAccount({mint:new Ze(ze.mint.address),tokenProgram:p,owner:this.scope.ownerPubKey,skipCloseAccount:!Ne,createInfo:{payer:l||this.scope.ownerPubKey},associatedOnly:!0,checkCreateATAOwner:d});_t||this.logAndCreateError("farm reward account not found:",ze.mint.address),nt&&g.addInstruction(nt),ie.push(_t)}}let me=(await this.scope.api.fetchFarmKeysById({ids:i.id}))[0],fe={userAuxiliaryLedgers:m,amount:r,owner:this.scope.ownerPubKey,farmInfo:i,farmKeys:me,lpAccount:h,rewardAccounts:ie},de=Et[i.programId],te=de===6?pi(fe):de===5?fi(fe):yi(fe),Ie={3:U.FarmV3Withdraw,5:U.FarmV5Withdraw,6:U.FarmV6Withdraw};g.addInstruction({instructions:[te],instructionTypes:[Ie[de]]})}let C=await this.getAmmPoolKeys(t.id),O=La({poolInfo:t,poolKeys:C,userKeys:{lpTokenAccount:h,baseTokenAccount:S,quoteTokenAccount:K,owner:this.scope.ownerPubKey},lpAmount:I,baseAmountMin:0,quoteAmountMin:0});g.addInstruction({instructions:[O],instructionTypes:[t.pooltype.includes("StablePool")?U.AmmV5RemoveLiquidity:U.AmmV4RemoveLiquidity],lookupTableAddress:C.lookupTableAccount?[C.lookupTableAccount]:[]});let[M,L]=t.mintA.address===n.mintA.address?[S,K]:[K,S],R=await this.scope.clmm.getClmmPoolKeys(n.id),_=await Ke.openPositionFromBaseInstructions(q(v({poolInfo:n,poolKeys:R,ownerInfo:{feePayer:this.scope.ownerPubKey,wallet:this.scope.ownerPubKey,tokenAccountA:M,tokenAccountB:L},withMetadata:"create"},s),{base:u,getEphemeralSigners:f}));return g.addInstruction({instructions:[..._.instructions],signers:_.signers,instructionTypes:[..._.instructionTypes],lookupTableAddress:R.lookupTableAccount?[R.lookupTableAccount]:[]}),y===0?g.sizeCheckBuildV0({computeBudgetConfig:a}):g.sizeCheckBuild({computeBudgetConfig:a})}async createPoolV4({programId:t,marketInfo:n,baseMintInfo:o,quoteMintInfo:s,baseAmount:i,quoteAmount:r,startTime:u,ownerInfo:a,associatedOnly:l=!1,checkCreateATAOwner:m=!1,tokenProgram:p,txVersion:d,feeDestinationId:f,computeBudgetConfig:y,txTipConfig:b,feePayer:g}){var L;let A=a.feePayer||((L=this.scope.owner)==null?void 0:L.publicKey),h=a.useSOLBalance&&o.mint.equals(Dr),I=a.useSOLBalance&&s.mint.equals(Dr),T=this.createTxBuilder(g),{account:w,instructionParams:S}=await this.scope.account.getOrCreateTokenAccount({mint:o.mint,owner:this.scope.ownerPubKey,createInfo:h?{payer:A,amount:i}:void 0,notUseTokenAccount:h,skipCloseAccount:!h,associatedOnly:h?!1:l,checkCreateATAOwner:m});T.addInstruction(S||{});let{account:x,instructionParams:K}=await this.scope.account.getOrCreateTokenAccount({mint:s.mint,owner:this.scope.ownerPubKey,createInfo:I?{payer:A,amount:r}:void 0,notUseTokenAccount:I,skipCloseAccount:!I,associatedOnly:I?!1:l,checkCreateATAOwner:m});if(T.addInstruction(K||{}),w===void 0||x===void 0)throw Error("you don't has some token account");let B=Va({version:4,marketVersion:3,marketId:n.marketId,baseMint:o.mint,quoteMint:s.mint,baseDecimals:o.decimals,quoteDecimals:s.decimals,programId:t,marketProgramId:n.programId}),C={programId:t,ammId:B.id,ammAuthority:B.authority,ammOpenOrders:B.openOrders,lpMint:B.lpMint,coinMint:B.baseMint,pcMint:B.quoteMint,coinVault:B.baseVault,pcVault:B.quoteVault,withdrawQueue:B.withdrawQueue,ammTargetOrders:B.targetOrders,poolTempLp:B.lpVault,marketProgramId:B.marketProgramId,marketId:B.marketId,ammConfigId:B.configId,feeDestinationId:f},{instruction:O,instructionType:M}=Oa(q(v({},C),{userWallet:this.scope.ownerPubKey,userCoinVault:w,userPcVault:x,userLpVault:H(this.scope.ownerPubKey,B.lpMint,p).publicKey,nonce:B.nonce,openTime:u,coinAmount:i,pcAmount:r}));return T.addInstruction({instructions:[O],instructionTypes:[M]}),T.addCustomComputeBudget(y),T.addTipInstruction(b),T.versionBuild({txVersion:d,extInfo:{address:C}})}async createMarketAndPoolV4({programId:t=Ho,marketProgram:n=Rs,feeDestinationId:o=Ls,tokenProgram:s,baseMintInfo:i,quoteMintInfo:r,baseAmount:u,quoteAmount:a,startTime:l,ownerInfo:m,lowestFeeMarket:p,assignSeed:d,associatedOnly:f=!1,checkCreateATAOwner:y=!1,lotSize:b=1,tickSize:g=.01,txVersion:A,computeBudgetConfig:h,txTipConfig:I,feePayer:T}){var go,ls,ms;let w=this.scope.ownerPubKey,S=m.feePayer||((go=this.scope.owner)==null?void 0:go.publicKey),x=m.useSOLBalance&&i.mint.equals(Dr),K=m.useSOLBalance&&r.mint.equals(Dr),B=d?`${i.mint.toBase58().slice(0,7)}-${r.mint.toBase58().slice(0,7)}-${d}`:void 0,C=Qe({fromPublicKey:w,programId:n,assignSeed:B&&`${B}-market`}),O=Qe({fromPublicKey:w,programId:n,assignSeed:B&&`${B}-request`}),M=Qe({fromPublicKey:w,programId:n,assignSeed:B&&`${B}-event`}),L=Qe({fromPublicKey:w,programId:n,assignSeed:B&&`${B}-bids`}),R=Qe({fromPublicKey:w,programId:n,assignSeed:B&&`${B}-asks`}),_=Qe({fromPublicKey:w,programId:_n,assignSeed:B&&`${B}-baseVault`}),X=Qe({fromPublicKey:w,programId:_n,assignSeed:B&&`${B}-quoteVault`}),j=0,ae=new Ge(100);function ue(){let Kt=new Ge(0);for(;;)try{return{vaultOwner:Ze.createProgramAddressSync([C.publicKey.toBuffer(),Kt.toArrayLike(Buffer,"le",8)],n),vaultSignerNonce:Kt}}catch{if(Kt.iaddn(1),Kt.gt(new Ge(25555)))throw Error("find vault owner error")}}let{vaultOwner:ie,vaultSignerNonce:me}=ue(),fe=new Ge(Math.round(10**i.decimals*b)),de=new Ge(Math.round(b*10**r.decimals*g));if(fe.eq(ht))throw Error("lot size is too small");if(de.eq(ht))throw Error("tick size or lot size is too small");let te=await Er({connection:this.scope.connection,wallet:this.scope.ownerPubKey,marketInfo:{programId:n,vaultOwner:ie,baseMint:i.mint,quoteMint:r.mint,id:C,baseVault:_,quoteVault:X,requestQueue:O,eventQueue:M,bids:L,asks:R,feeRateBps:j,quoteDustThreshold:ae,vaultSignerNonce:me,baseLotSize:fe,quoteLotSize:de,lowestFeeMarket:p}}),Ie=this.createTxBuilder(T);Ie.addInstruction({instructions:te[0].transaction.instructions,signers:te[0].signer});for await(let Kt of te.slice(1,te.length))Ie.addInstruction({instructions:Kt.transaction.instructions,signers:Kt.signer,instructionTypes:Kt.instructionTypes});let{account:ze,instructionParams:Ne}=await this.scope.account.getOrCreateTokenAccount({mint:i.mint,owner:this.scope.ownerPubKey,createInfo:x?{payer:S,amount:u}:void 0,notUseTokenAccount:x,skipCloseAccount:!x,associatedOnly:x?!1:f,checkCreateATAOwner:y,assignSeed:x&&B?`${B}-wsol`:void 0});Ie.addInstruction(Ne||{});let{account:_t,instructionParams:nt}=await this.scope.account.getOrCreateTokenAccount({mint:r.mint,owner:this.scope.ownerPubKey,createInfo:K?{payer:S,amount:a}:void 0,notUseTokenAccount:K,skipCloseAccount:!K,associatedOnly:K?!1:f,checkCreateATAOwner:y,assignSeed:K&&B?`${B}-wsol`:void 0});if(Ie.addInstruction(nt||{}),ze===void 0)throw Error("you don't has base token account");if(_t===void 0)throw Error("you don't has quote token account");let ot=Va({version:4,marketVersion:3,marketId:C.publicKey,baseMint:i.mint,quoteMint:r.mint,baseDecimals:i.decimals,quoteDecimals:r.decimals,programId:t,marketProgramId:n}),qo={programId:t,ammId:ot.id,ammAuthority:ot.authority,ammOpenOrders:ot.openOrders,lpMint:ot.lpMint,coinMint:ot.baseMint,pcMint:ot.quoteMint,coinVault:ot.baseVault,pcVault:ot.quoteVault,withdrawQueue:ot.withdrawQueue,ammTargetOrders:ot.targetOrders,poolTempLp:ot.lpVault,marketProgramId:ot.marketProgramId,marketId:ot.marketId,ammConfigId:ot.configId,feeDestinationId:o},{instruction:Uo,instructionType:sn}=Oa(q(v({},qo),{userWallet:this.scope.ownerPubKey,userCoinVault:ze,userPcVault:_t,userLpVault:H(this.scope.ownerPubKey,ot.lpMint,s).publicKey,nonce:ot.nonce,openTime:l,coinAmount:u,pcAmount:a}));Ie.addInstruction({instructions:[Uo],instructionTypes:[sn]});let bo=x||K?[((ls=Ne==null?void 0:Ne.instructions)==null?void 0:ls[0])||((ms=nt==null?void 0:nt.instructions)==null?void 0:ms[0])].filter(Kt=>!!Kt):void 0;return A===0?Ie.sizeCheckBuildV0({computeBudgetConfig:h,splitIns:bo,address:v({requestQueue:O.publicKey,eventQueue:M.publicKey,bids:L.publicKey,asks:R.publicKey,baseVault:_.publicKey,quoteVault:X.publicKey,baseMint:new Ze(i.mint),quoteMint:new Ze(r.mint)},qo)}):Ie.sizeCheckBuild({computeBudgetConfig:h,splitIns:bo,address:v({requestQueue:O.publicKey,eventQueue:M.publicKey,bids:L.publicKey,asks:R.publicKey,baseVault:_.publicKey,quoteVault:X.publicKey,baseMint:new Ze(i.mint),quoteMint:new Ze(r.mint)},qo)})}async getCreatePoolFee({programId:t}){let n=Vr({programId:t}),o=await this.scope.connection.getAccountInfo(n,{dataSlice:{offset:536,length:8}});if(o===null)throw Error("get config account error");return $c.decode(o.data).fee}computeAmountOut({poolInfo:t,amountIn:n,mintIn:o,mintOut:s,slippage:i}){let[r,u]=[o.toString(),s.toString()];if(r!==t.mintA.address&&r!==t.mintB.address)throw new Error("toke not match");if(u!==t.mintA.address&&u!==t.mintB.address)throw new Error("toke not match");let{baseReserve:a,quoteReserve:l}=t,m=[a,l],p=[t.mintA.decimals,t.mintB.decimals],d=r==t.mintA.address?"base":"quote";d==="quote"&&(m.reverse(),p.reverse());let[f,y]=m,[b,g]=p,A=t.version===4,h;if(A)h=new Re(y.toString()).div(10**g).div(new Re(f.toString()).div(10**b));else{let M=al(this.stableLayout.stableModelData,a.toNumber(),l.toNumber(),!1);d==="quote"?h=new Re(1e6).div(M*1e6):h=new Re(M*1e6).div(1e6)}let I=n,T=new Ge(0),w=new Ge(0);if(!I.isZero())if(A){w=$t(I.mul(Ba),Mr);let M=I.sub(w),L=f.add(M);T=y.mul(M).div(L)}else{w=I.mul(new Ge(2)).div(new Ge(1e4));let M=I.sub(w);d==="quote"?T=new Ge(rl(this.stableLayout.stableModelData,l.toNumber(),a.toNumber(),M.toNumber())):T=new Ge(sl(this.stableLayout.stableModelData,l.toNumber(),a.toNumber(),M.toNumber()))}let S=new Ge(new Re(T.toString()).mul(1-i).toFixed(0)),x=T,K=S,B=new Re(T.toString()).div(new Re(I.sub(w).toString()).toFixed(0));!I.isZero()&&!T.isZero()&&(B=new Re(T.toString()).div(10**g).div(new Re(I.sub(w).toString()).div(10**b)));let C=h.sub(B).div(h).mul(100);return{amountOut:x,minAmountOut:K,currentPrice:h,executionPrice:B,priceImpact:C,fee:w}}computeAmountIn({poolInfo:t,amountOut:n,mintIn:o,mintOut:s,slippage:i}){let{baseReserve:r,quoteReserve:u}=t;o.toString()!==t.mintA.address&&o.toString()!==t.mintB.address&&this.logAndCreateError("mintIn does not match pool"),s.toString()!==t.mintA.address&&s.toString()!==t.mintB.address&&this.logAndCreateError("mintOut does not match pool"),this.logDebug("baseReserve:",r.toString()),this.logDebug("quoteReserve:",u.toString());let a=o.toString()===t.mintA.address,[l,m]=a?[t.mintA,t.mintB]:[t.mintB,t.mintA];this.logDebug("currencyOut:",m.symbol||m.address),this.logDebug("amountOut:",new Re(n.toString()).div(10**m.decimals).toDecimalPlaces(m.decimals).toString(),l.symbol||l.address),this.logDebug("slippage:",`${i*100}%`);let p=[r,u],d=a?"quote":"base";d==="base"&&p.reverse(),this.logDebug("output side:",d);let[f,y]=p,b=new Re(y.toString()).div(10**t[a?"mintB":"mintA"].decimals).div(new Re(f.toString()).div(10**t[a?"mintA":"mintB"].decimals));this.logDebug("currentPrice:",`1 ${l.symbol||l.address} \u2248 ${b.toString()} ${m.symbol||m.address}`),this.logDebug("currentPrice invert:",`1 ${m.symbol||m.address} \u2248 ${new Re(1).div(b).toString()} ${l.symbol||l.address}`);let g=new Ge(0),A=n;if(!A.isZero()){A.gt(y)&&(A=y.sub(new Ge(1)));let K=y.sub(A);g=f.mul(A).div(K).mul(Mr).div(Mr.sub(Ba))}let h=new Ge(new Re(g.toString()).mul(1+i).toFixed(0)),I=g,T=h;this.logDebug("amountIn:",new Re(I.toString()).div(10**l.decimals).toDecimalPlaces(l.decimals).toString()),this.logDebug("maxAmountIn:",new Re(T.toString()).div(10**l.decimals).toDecimalPlaces(l.decimals).toString());let w=null;!g.isZero()&&!A.isZero()&&(w=new Re(A.toString()).div(10**m.decimals).div(new Re(g.toString()).div(10**l.decimals)),this.logDebug("executionPrice:",`1 ${m.symbol||m.address} \u2248 ${w.toDecimalPlaces(Math.max(t.mintA.decimals,t.mintB.decimals)).toString()} ${l.symbol||l.address}`),this.logDebug("executionPrice invert:",`1 ${m.symbol||m.address} \u2248 ${new Re(1).div(w).toDecimalPlaces(Math.max(t.mintA.decimals,t.mintB.decimals)).toString()} ${l.symbol||l.address}`));let S=b.mul(I.toString()),x=S.sub(n.toString()).abs().div(S);return this.logDebug("priceImpact:",`${x.toString()}%`),{amountIn:I,maxAmountIn:T,currentPrice:b,executionPrice:w,priceImpact:x}}async swap({poolInfo:t,poolKeys:n,amountIn:o,amountOut:s,inputMint:i,fixedSide:r,txVersion:u,config:a,computeBudgetConfig:l,txTipConfig:m,feePayer:p}){let d=this.createTxBuilder(p),{associatedOnly:f=!0,inputUseSolBalance:y=!0,outputUseSolBalance:b=!0}=a||{},[g,A]=i===t.mintA.address?[t.mintA,t.mintB]:[t.mintB,t.mintA],h=y&&g.address===Z.toBase58(),I=b&&A.address===Z.toBase58(),{account:T,instructionParams:w}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:_n,mint:new Ze(g.address),owner:this.scope.ownerPubKey,createInfo:h?{payer:this.scope.ownerPubKey,amount:o}:void 0,skipCloseAccount:!h,notUseTokenAccount:h,associatedOnly:f});d.addInstruction(w||{}),T||this.logAndCreateError("input token account not found",{token:g.symbol||g.address,tokenAccountIn:T,inputTokenUseSolBalance:h,associatedOnly:f});let{account:S,instructionParams:x}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:_n,mint:new Ze(A.address),owner:this.scope.ownerPubKey,createInfo:{payer:this.scope.ownerPubKey,amount:0},skipCloseAccount:!I,notUseTokenAccount:I,associatedOnly:I?!1:f});d.addInstruction(x||{}),S===void 0&&this.logAndCreateError("output token account not found",{token:A.symbol||A.address,tokenAccountOut:S,outputTokenUseSolBalance:I,associatedOnly:f});let K=n||await this.getAmmPoolKeys(t.id),B=4;return t.pooltype.includes("StablePool")&&(B=5),d.addInstruction({instructions:[vr({version:B,poolKeys:K,userKeys:{tokenAccountIn:T,tokenAccountOut:S,owner:this.scope.ownerPubKey},amountIn:o,amountOut:s,fixedSide:r})],instructionTypes:[B===4?U.AmmV4SwapBaseIn:U.AmmV5SwapBaseIn]}),d.addCustomComputeBudget(l),d.addTipInstruction(m),d.versionBuild({txVersion:u})}async getRpcPoolInfo(t){return(await this.getRpcPoolInfos([t]))[t]}async getRpcPoolInfos(t,n){let o=await Le(this.scope.connection,t.map(l=>({pubkey:new Ze(l)})),n),s={},i=[];for(let l=0;l<t.length;l++){let m=o[l];if(m===null||!m.accountInfo)throw Error("fetch pool info error: "+String(t[l]));let p=no.decode(m.accountInfo.data);s[String(t[l])]=q(v({},p),{programId:m.accountInfo.owner}),i.push(p.baseVault,p.quoteVault)}let r={},u=await Le(this.scope.connection,i.map(l=>({pubkey:new Ze(l)})),n);for(let l=0;l<i.length;l++){let m=u[l].accountInfo;if(m===null)throw Error("fetch vault info error: "+i[l]);r[String(i[l])]=new Ge(Np.decode(m.data).amount.toString())}let a={};for(let[l,m]of Object.entries(s)){let p=r[m.baseVault.toString()].sub(m.baseNeedTakePnl),d=r[m.quoteVault.toString()].sub(m.quoteNeedTakePnl);a[l]=q(v({},m),{baseReserve:p,mintAAmount:r[m.baseVault.toString()],mintBAmount:r[m.quoteVault.toString()],quoteReserve:d,poolPrice:new Re(d.toString()).div(new Re(10).pow(m.quoteDecimal.toString())).div(new Re(p.toString()).div(new Re(10).pow(m.baseDecimal.toString())))})}return a}async getPoolInfoFromRpc({poolId:t}){let n=await this.getRpcPoolInfo(t),o=_r({[t]:n}),s=o[t],i=await this.scope.tradeV2.computePoolToPoolKeys({pools:[o[t]],ammRpcData:{[t]:n}});return{poolRpcData:n,poolInfo:s,poolKeys:i[0]}}};import{PublicKey as Q}from"@solana/web3.js";import wt from"bn.js";import ao from"decimal.js";import{AccountLayout as pl,createAssociatedTokenAccountIdempotentInstruction as fl,TOKEN_2022_PROGRAM_ID as En,TOKEN_PROGRAM_ID as Li}from"@solana/spl-token";var Oi=class extends Fe{constructor(e){super(e)}async getClmmPoolKeys(e){return(await this.scope.api.fetchPoolKeysById({idList:[e]}))[0]}async createPool(e){var S;let{programId:t,owner:n=((S=this.scope.owner)==null?void 0:S.publicKey)||Q.default,mint1:o,mint2:s,ammConfig:i,initialPrice:r,computeBudgetConfig:u,forerunCreate:a,getObserveState:l,txVersion:m,txTipConfig:p,feePayer:d}=e,f=this.createTxBuilder(d),[y,b,g]=new wt(new Q(o.address).toBuffer()).gt(new wt(new Q(s.address).toBuffer()))?[s,o,new ao(1).div(r)]:[o,s,r],A=re.priceToSqrtPriceX64(g,y.decimals,b.decimals),h=[],I=[];y.programId===En.toBase58()&&I.push(Pa(t,new Q(y.address)).publicKey),b.programId===En.toBase58()&&I.push(Pa(t,new Q(b.address)).publicKey),(await this.scope.connection.getMultipleAccountsInfo(I)).forEach((x,K)=>{x&&h.push(I[K])});let w=await Ke.createPoolInstructions({connection:this.scope.connection,programId:t,owner:n,mintA:y,mintB:b,ammConfigId:i.id,initialPriceX64:A,forerunCreate:!l&&a,extendMintAccount:h});return f.addInstruction(w),f.addCustomComputeBudget(u),f.addTipInstruction(p),f.versionBuild({txVersion:m,extInfo:{address:q(v({},w.address),{observationId:w.address.observationId.toBase58(),exBitmapAccount:w.address.exBitmapAccount.toBase58(),programId:t.toString(),id:w.address.poolId.toString(),mintA:y,mintB:b,openTime:"0",vault:{A:w.address.mintAVault.toString(),B:w.address.mintBVault.toString()},rewardInfos:[],config:{id:i.id.toString(),index:i.index,protocolFeeRate:i.protocolFeeRate,tradeFeeRate:i.tradeFeeRate,tickSpacing:i.tickSpacing,fundFeeRate:i.fundFeeRate,description:i.description,defaultRange:0,defaultRangePoint:[]}}),mockPoolInfo:v({type:"Concentrated",rewardDefaultPoolInfos:"Clmm",id:w.address.poolId.toString(),mintA:y,mintB:b,feeRate:i.tradeFeeRate,openTime:"0",programId:t.toString(),price:g.toNumber(),config:{id:i.id.toString(),index:i.index,protocolFeeRate:i.protocolFeeRate,tradeFeeRate:i.tradeFeeRate,tickSpacing:i.tickSpacing,fundFeeRate:i.fundFeeRate,description:i.description,defaultRange:0,defaultRangePoint:[]},burnPercent:0},Lc),forerunCreate:a}})}async openPositionFromBase({poolInfo:e,poolKeys:t,ownerInfo:n,tickLower:o,tickUpper:s,base:i,baseAmount:r,otherAmountMax:u,nft2022:a,associatedOnly:l=!0,checkCreateATAOwner:m=!1,withMetadata:p="create",getEphemeralSigners:d,computeBudgetConfig:f,txTipConfig:y,txVersion:b,feePayer:g}){this.scope.availability.addConcentratedPosition===!1&&this.logAndCreateError("add position feature disabled in your region"),this.scope.checkOwner();let A=this.createTxBuilder(g),h=null,I=null,T=n.useSOLBalance&&e.mintA.address===Z.toString(),w=n.useSOLBalance&&e.mintB.address===Z.toString(),[S,x]=i==="MintA"?[r,u]:[u,r],{account:K,instructionParams:B}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:e.mintA.programId,mint:new Q(e.mintA.address),owner:this.scope.ownerPubKey,createInfo:T||S.isZero()?{payer:this.scope.ownerPubKey,amount:S}:void 0,skipCloseAccount:!T,notUseTokenAccount:T,associatedOnly:T?!1:l,checkCreateATAOwner:m});K&&(h=K),A.addInstruction(B||{});let{account:C,instructionParams:O}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:e.mintB.programId,mint:new Q(e.mintB.address),owner:this.scope.ownerPubKey,createInfo:w||x.isZero()?{payer:this.scope.ownerPubKey,amount:x}:void 0,skipCloseAccount:!w,notUseTokenAccount:w,associatedOnly:w?!1:l,checkCreateATAOwner:m});C&&(I=C),A.addInstruction(O||{}),(!h||!I)&&this.logAndCreateError("cannot found target token accounts","tokenAccounts",{ownerTokenAccountA:h==null?void 0:h.toBase58(),ownerTokenAccountB:I==null?void 0:I.toBase58()});let M=t||await this.getClmmPoolKeys(e.id),L=await Ke.openPositionFromBaseInstructions({poolInfo:e,poolKeys:M,ownerInfo:q(v({},n),{feePayer:this.scope.ownerPubKey,wallet:this.scope.ownerPubKey,tokenAccountA:h,tokenAccountB:I}),tickLower:o,tickUpper:s,base:i,baseAmount:r,otherAmountMax:u,withMetadata:p,getEphemeralSigners:d,nft2022:a});return A.addInstruction(L),A.addCustomComputeBudget(f),A.addTipInstruction(y),A.versionBuild({txVersion:b,extInfo:v({},L.address)})}async openPositionFromLiquidity({poolInfo:e,poolKeys:t,ownerInfo:n,amountMaxA:o,amountMaxB:s,tickLower:i,tickUpper:r,liquidity:u,associatedOnly:a=!0,checkCreateATAOwner:l=!1,withMetadata:m="create",txVersion:p,computeBudgetConfig:d,txTipConfig:f,getEphemeralSigners:y,nft2022:b,feePayer:g}){this.scope.availability.createConcentratedPosition===!1&&this.logAndCreateError("open position feature disabled in your region");let A=this.createTxBuilder(g),h=null,I=null,T=n.useSOLBalance&&e.mintA.address===Z.toBase58(),w=n.useSOLBalance&&e.mintB.address===Z.toBase58(),{account:S,instructionParams:x}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:e.mintA.programId,mint:new Q(e.mintA.address),owner:this.scope.ownerPubKey,createInfo:T||o.isZero()?{payer:this.scope.ownerPubKey,amount:o}:void 0,skipCloseAccount:!T,notUseTokenAccount:T,associatedOnly:T?!1:a,checkCreateATAOwner:l});S&&(h=S),A.addInstruction(x||{});let{account:K,instructionParams:B}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:e.mintB.programId,mint:new Q(e.mintB.address),owner:this.scope.ownerPubKey,createInfo:w||s.isZero()?{payer:this.scope.ownerPubKey,amount:s}:void 0,skipCloseAccount:!w,notUseTokenAccount:w,associatedOnly:w?!1:a,checkCreateATAOwner:l});K&&(I=K),A.addInstruction(B||{}),(h===void 0||I===void 0)&&this.logAndCreateError("cannot found target token accounts","tokenAccounts",this.scope.account.tokenAccounts);let C=t||await this.getClmmPoolKeys(e.id),O=await Ke.openPositionFromLiquidityInstructions({poolInfo:e,poolKeys:C,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccountA:h,tokenAccountB:I},tickLower:i,tickUpper:r,liquidity:u,amountMaxA:o,amountMaxB:s,withMetadata:m,getEphemeralSigners:y,nft2022:b});return A.addInstruction(O),A.addCustomComputeBudget(d),A.addTipInstruction(f),A.versionBuild({txVersion:p,extInfo:{address:O.address}})}async increasePositionFromLiquidity(e){var B;let{poolInfo:t,poolKeys:n,ownerPosition:o,amountMaxA:s,amountMaxB:i,liquidity:r,ownerInfo:u,associatedOnly:a=!0,checkCreateATAOwner:l=!1,computeBudgetConfig:m,txTipConfig:p,txVersion:d,feePayer:f}=e,y=this.createTxBuilder(f),b,g,A=u.useSOLBalance&&t.mintA.address===Z.toString(),h=u.useSOLBalance&&t.mintB.address===Z.toString(),{account:I,instructionParams:T}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:t.mintA.programId,mint:new Q(t.mintA.address),notUseTokenAccount:A,owner:this.scope.ownerPubKey,createInfo:A||s.isZero()?{payer:this.scope.ownerPubKey,amount:s}:void 0,skipCloseAccount:!A,associatedOnly:A?!1:a,checkCreateATAOwner:l});I&&(b=I),y.addInstruction(T||{});let{account:w,instructionParams:S}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:t.mintB.programId,mint:new Q(t.mintB.address),owner:this.scope.ownerPubKey,createInfo:h||i.isZero()?{payer:this.scope.ownerPubKey,amount:i}:void 0,notUseTokenAccount:h,skipCloseAccount:!h,associatedOnly:h?!1:a,checkCreateATAOwner:l});w&&(g=w),y.addInstruction(S||{}),!b&&!g&&this.logAndCreateError("cannot found target token accounts","tokenAccounts",this.scope.account.tokenAccounts);let x=n!=null?n:await this.getClmmPoolKeys(t.id),K=Ke.increasePositionFromLiquidityInstructions({poolInfo:t,poolKeys:x,ownerPosition:o,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccountA:b,tokenAccountB:g},liquidity:r,amountMaxA:s,amountMaxB:i,nft2022:(B=await this.scope.connection.getAccountInfo(o.nftMint))==null?void 0:B.owner.equals(En)});return y.addInstruction(K),y.addCustomComputeBudget(m),y.addTipInstruction(p),y.versionBuild({txVersion:d,extInfo:{address:K.address}})}async increasePositionFromBase(e){var K;let{poolInfo:t,ownerPosition:n,base:o,baseAmount:s,otherAmountMax:i,ownerInfo:r,associatedOnly:u=!0,checkCreateATAOwner:a=!1,computeBudgetConfig:l,txTipConfig:m,txVersion:p,feePayer:d}=e,f=this.createTxBuilder(d),y,b,g=r.useSOLBalance&&t.mintA.address===Z.toString(),A=r.useSOLBalance&&t.mintB.address===Z.toString(),{account:h,instructionParams:I}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:t.mintA.programId,mint:new Q(t.mintA.address),notUseTokenAccount:g,owner:this.scope.ownerPubKey,createInfo:g||(o==="MintA"?s:i).isZero()?{payer:this.scope.ownerPubKey,amount:o==="MintA"?s:i}:void 0,skipCloseAccount:!g,associatedOnly:g?!1:u,checkCreateATAOwner:a});h&&(y=h),f.addInstruction(I||{});let{account:T,instructionParams:w}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:t.mintB.programId,mint:new Q(t.mintB.address),owner:this.scope.ownerPubKey,createInfo:A||(o==="MintA"?i:s).isZero()?{payer:this.scope.ownerPubKey,amount:o==="MintA"?i:s}:void 0,notUseTokenAccount:A,skipCloseAccount:!A,associatedOnly:A?!1:u,checkCreateATAOwner:a});T&&(b=T),f.addInstruction(w||{}),!y&&!b&&this.logAndCreateError("cannot found target token accounts","tokenAccounts",this.scope.account.tokenAccounts);let S=await this.getClmmPoolKeys(t.id),x=Ke.increasePositionFromBaseInstructions({poolInfo:t,poolKeys:S,ownerPosition:n,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccountA:y,tokenAccountB:b},base:o,baseAmount:s,otherAmountMax:i,nft2022:(K=await this.scope.connection.getAccountInfo(n.nftMint))==null?void 0:K.owner.equals(En)});return f.addInstruction(x),f.addCustomComputeBudget(l),f.addTipInstruction(m),f.versionBuild({txVersion:p,extInfo:{address:x.address}})}async decreaseLiquidity(e){var M;let{poolInfo:t,poolKeys:n,ownerPosition:o,ownerInfo:s,amountMinA:i,amountMinB:r,liquidity:u,associatedOnly:a=!0,checkCreateATAOwner:l=!1,computeBudgetConfig:m,txTipConfig:p,txVersion:d,feePayer:f}=e;this.scope.availability.removeConcentratedPosition===!1&&this.logAndCreateError("remove position feature disabled in your region");let y=this.createTxBuilder(f),b=s.useSOLBalance&&t.mintA.address===Z.toString(),g=s.useSOLBalance&&t.mintB.address===Z.toString(),A,h,{account:I,instructionParams:T}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:t.mintA.programId,mint:new Q(t.mintA.address),notUseTokenAccount:b,owner:this.scope.ownerPubKey,createInfo:{payer:this.scope.ownerPubKey,amount:0},skipCloseAccount:!b,associatedOnly:b?!1:a,checkCreateATAOwner:l});A=I,T&&y.addInstruction(T);let{account:w,instructionParams:S}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:t.mintB.programId,mint:new Q(t.mintB.address),notUseTokenAccount:g,owner:this.scope.ownerPubKey,createInfo:{payer:this.scope.ownerPubKey,amount:0},skipCloseAccount:!g,associatedOnly:g?!1:a,checkCreateATAOwner:l});h=w,S&&y.addInstruction(S);let x=[];for(let L of t.rewardDefaultInfos){let R=s.useSOLBalance&&L.mint.address===Z.toString(),_;if(L.mint.address===t.mintA.address)_=A;else if(L.mint.address===t.mintB.address)_=h;else{let{account:X,instructionParams:j}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:new Q(L.mint.programId),mint:new Q(L.mint.address),notUseTokenAccount:R,owner:this.scope.ownerPubKey,createInfo:{payer:this.scope.ownerPubKey,amount:0},skipCloseAccount:!R,associatedOnly:R?!1:a,checkCreateATAOwner:l});_=X,j&&y.addInstruction(j)}x.push(_)}!A&&!h&&this.logAndCreateError("cannot found target token accounts","tokenAccounts",this.scope.account.tokenAccountRawInfos);let K=n!=null?n:await this.getClmmPoolKeys(t.id),B=(M=await this.scope.connection.getAccountInfo(o.nftMint))==null?void 0:M.owner.equals(En),C=await Ke.decreaseLiquidityInstructions({poolInfo:t,poolKeys:K,ownerPosition:o,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccountA:A,tokenAccountB:h,rewardAccounts:x},liquidity:u,amountMinA:i,amountMinB:r,nft2022:B});y.addInstruction({instructions:C.instructions,instructionTypes:[U.ClmmDecreasePosition]});let O=v({},C.address);if(s.closePosition){let L=await Ke.closePositionInstructions({poolInfo:t,poolKeys:K,ownerInfo:{wallet:this.scope.ownerPubKey},ownerPosition:o,nft2022:B});y.addInstruction({endInstructions:L.instructions,endInstructionTypes:L.instructionTypes}),O=v(v({},O),L.address)}return y.addCustomComputeBudget(m),y.addTipInstruction(p),y.versionBuild({txVersion:d,extInfo:{address:O}})}async lockPosition(e){var f;let{programId:t=ko,authProgramId:n=Zo,poolProgramId:o=Rn,ownerPosition:s,payer:i,computeBudgetConfig:r,txTipConfig:u,txVersion:a,getEphemeralSigners:l,feePayer:m}=e,p=this.createTxBuilder(m),d=await Ke.makeLockPositions({programId:t,authProgramId:n,poolProgramId:o,wallet:this.scope.ownerPubKey,payer:i!=null?i:this.scope.ownerPubKey,nftMint:s.nftMint,getEphemeralSigners:l,nft2022:(f=await this.scope.connection.getAccountInfo(s.nftMint))==null?void 0:f.owner.equals(En)});return p.addInstruction(d),p.addCustomComputeBudget(r),p.addTipInstruction(u),p.versionBuild({txVersion:a,extInfo:d.address})}async harvestLockPosition(e){let{programId:t=ko,authProgramId:n=Zo,clmmProgram:o=Rn,poolKeys:s,lockData:i,ownerInfo:r={useSOLBalance:!0},associatedOnly:u=!0,checkCreateATAOwner:a=!1,computeBudgetConfig:l,txTipConfig:m,txVersion:p,feePayer:d}=e,f=s||await this.getClmmPoolKeys(i.poolId.toString()),y=this.createTxBuilder(d),b=await this.scope.connection.getAccountInfo(i.positionId);b||this.logger.logWithError("position not found",i.positionId);let g=Ro.decode(b.data),A=r.useSOLBalance&&f.mintA.address===Z.toString(),h=r.useSOLBalance&&f.mintB.address===Z.toString(),I,T,{account:w,instructionParams:S}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:f.mintA.programId,mint:new Q(f.mintA.address),notUseTokenAccount:A,owner:this.scope.ownerPubKey,createInfo:{payer:this.scope.ownerPubKey,amount:0},skipCloseAccount:!A,associatedOnly:A?!1:u,checkCreateATAOwner:a});I=w,S&&y.addInstruction(S);let{account:x,instructionParams:K}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:f.mintB.programId,mint:new Q(f.mintB.address),notUseTokenAccount:h,owner:this.scope.ownerPubKey,createInfo:{payer:this.scope.ownerPubKey,amount:0},skipCloseAccount:!h,associatedOnly:h?!1:u,checkCreateATAOwner:a});T=x,K&&y.addInstruction(K);let B={},C=[];for(let ie of f.rewardInfos){let me=r.useSOLBalance&&ie.mint.address===Z.toString(),fe=B[ie.mint.address];if(!fe){let{account:de,instructionParams:te}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:new Q(ie.mint.programId),mint:new Q(ie.mint.address),notUseTokenAccount:me,owner:this.scope.ownerPubKey,skipCloseAccount:!me,createInfo:{payer:this.scope.ownerPubKey,amount:0},associatedOnly:me?!1:u});fe=de,te&&y.addInstruction(te)}B[ie.mint.address]=fe,C.push(fe)}let O=Co(t,i.lockNftMint).publicKey,M=H(this.scope.ownerPubKey,i.lockNftMint,Li).publicKey,L=$.getTickArrayStartIndexByTick(g.tickLower,f.config.tickSpacing),R=$.getTickArrayStartIndexByTick(g.tickUpper,f.config.tickSpacing),{publicKey:_}=ge(new Q(f.programId),i.poolId,L),{publicKey:X}=ge(new Q(f.programId),i.poolId,R),{publicKey:j}=on(new Q(f.programId),i.poolId,g.tickLower,g.tickUpper),ae=[];for(let ie=0;ie<f.rewardInfos.length;ie++)ae.push({poolRewardVault:new Q(f.rewardInfos[ie].vault),ownerRewardVault:C[ie],rewardMint:new Q(f.rewardInfos[ie].mint.address)});let ue=await Ke.harvestLockPositionInstructionV2({programId:t,auth:n,lockPositionId:O,clmmProgram:o,lockOwner:this.scope.ownerPubKey,lockNftMint:i.lockNftMint,lockNftAccount:M,positionNftAccount:i.nftAccount,positionId:i.positionId,poolId:i.poolId,protocolPosition:j,vaultA:new Q(f.vault.A),vaultB:new Q(f.vault.B),tickArrayLower:_,tickArrayUpper:X,userVaultA:I,userVaultB:T,mintA:new Q(f.mintA.address),mintB:new Q(f.mintB.address),rewardAccounts:ae,exTickArrayBitmap:Ye(o,i.poolId).publicKey});return y.addInstruction({instructions:[ue],instructionTypes:[U.ClmmHarvestLockPosition]}),y.addCustomComputeBudget(l),y.addTipInstruction(m),y.versionBuild({txVersion:p})}async closePosition({poolInfo:e,poolKeys:t,ownerPosition:n,txVersion:o,computeBudgetConfig:s,txTipConfig:i,feePayer:r}){var m;this.scope.availability.removeConcentratedPosition===!1&&this.logAndCreateError("remove position feature disabled in your region");let u=this.createTxBuilder(r),a=t!=null?t:await this.getClmmPoolKeys(e.id),l=Ke.closePositionInstructions({poolInfo:e,poolKeys:a,ownerInfo:{wallet:this.scope.ownerPubKey},ownerPosition:n,nft2022:(m=await this.scope.connection.getAccountInfo(n.nftMint))==null?void 0:m.owner.equals(En)});return u.addCustomComputeBudget(s),u.addTipInstruction(i),u.addInstruction(l).versionBuild({txVersion:o,extInfo:{address:l.address}})}async initReward({poolInfo:e,ownerInfo:t,rewardInfo:n,associatedOnly:o=!0,checkCreateATAOwner:s=!1,computeBudgetConfig:i,txVersion:r,feePayer:u}){n.endTime<=n.openTime&&this.logAndCreateError("reward time error","rewardInfo",n);let a=this.createTxBuilder(u),l=t.useSOLBalance&&n.mint.address.toString()===Z.toString(),m=n.perSecond.mul(n.endTime-n.openTime),{account:p,instructionParams:d}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:new Q(n.mint.address),mint:new Q(n.mint.address),notUseTokenAccount:!!l,skipCloseAccount:!l,owner:this.scope.ownerPubKey,createInfo:l?{payer:t.feePayer||this.scope.ownerPubKey,amount:new wt(new ao(m.toFixed(0)).gte(m)?m.toFixed(0):m.add(1).toFixed(0))}:void 0,associatedOnly:l?!1:o,checkCreateATAOwner:s});d&&a.addInstruction(d),p||this.logAndCreateError("no money","ownerRewardAccount",this.scope.account.tokenAccountRawInfos);let f=await this.getClmmPoolKeys(e.id),y=Ke.initRewardInstructions({poolInfo:e,poolKeys:f,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccount:p},rewardInfo:{programId:new Q(n.mint.programId),mint:new Q(n.mint.address),openTime:n.openTime,endTime:n.endTime,emissionsPerSecondX64:le.decimalToX64(n.perSecond)}});return a.addInstruction(y),a.addCustomComputeBudget(i),a.versionBuild({txVersion:r,extInfo:{address:y.address}})}async initRewards({poolInfo:e,poolKeys:t,ownerInfo:n,rewardInfos:o,associatedOnly:s=!0,checkCreateATAOwner:i=!1,computeBudgetConfig:r,txTipConfig:u,txVersion:a,feePayer:l}){for(let d of o)d.endTime<=d.openTime&&this.logAndCreateError("reward time error","rewardInfo",d);let m=this.createTxBuilder(l),p={};for(let d of o){let f=n.useSOLBalance&&d.mint.address===Z.toString(),y=d.perSecond.mul(d.endTime-d.openTime),{account:b,instructionParams:g}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:new Q(d.mint.programId),mint:new Q(d.mint.address),notUseTokenAccount:!!f,skipCloseAccount:!f,owner:this.scope.ownerPubKey,createInfo:f?{payer:n.feePayer||this.scope.ownerPubKey,amount:new wt(new ao(y.toFixed(0)).gte(y)?y.toFixed(0):y.add(1).toFixed(0))}:void 0,associatedOnly:f?!1:s,checkCreateATAOwner:i});g&&m.addInstruction(g),b||this.logAndCreateError("no money","ownerRewardAccount",this.scope.account.tokenAccountRawInfos);let A=t!=null?t:await this.getClmmPoolKeys(e.id),h=Ke.initRewardInstructions({poolInfo:e,poolKeys:A,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccount:b},rewardInfo:{programId:new Q(d.mint.programId),mint:new Q(d.mint.address),openTime:d.openTime,endTime:d.endTime,emissionsPerSecondX64:le.decimalToX64(d.perSecond)}});p=v(v({},p),h.address),m.addInstruction(h)}return m.addCustomComputeBudget(r),m.addTipInstruction(u),m.versionBuild({txVersion:a,extInfo:{address:p}})}async setReward({poolInfo:e,ownerInfo:t,rewardInfo:n,associatedOnly:o=!0,checkCreateATAOwner:s=!1,computeBudgetConfig:i,txTipConfig:r,txVersion:u,feePayer:a}){n.endTime<=n.openTime&&this.logAndCreateError("reward time error","rewardInfo",n);let l=this.createTxBuilder(a),m=t.useSOLBalance&&n.mint.equals(Z),{account:p,instructionParams:d}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:n.programId,mint:n.mint,notUseTokenAccount:m,owner:this.scope.ownerPubKey,createInfo:m?{payer:t.feePayer||this.scope.ownerPubKey,amount:new wt(new ao(n.perSecond.mul(n.endTime-n.openTime).toFixed(0)).gte(n.perSecond.mul(n.endTime-n.openTime))?n.perSecond.mul(n.endTime-n.openTime).toFixed(0):n.perSecond.mul(n.endTime-n.openTime).add(1).toFixed(0))}:void 0,associatedOnly:m?!1:o,checkCreateATAOwner:s});d&&l.addInstruction(d),p||this.logAndCreateError("no money","ownerRewardAccount",this.scope.account.tokenAccountRawInfos);let f=await this.getClmmPoolKeys(e.id),y=Ke.setRewardInstructions({poolInfo:e,poolKeys:f,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccount:p},rewardInfo:{mint:n.mint,openTime:n.openTime,endTime:n.endTime,emissionsPerSecondX64:le.decimalToX64(n.perSecond)}});return l.addInstruction(y),l.addCustomComputeBudget(i),l.addTipInstruction(r),l.versionBuild({txVersion:u,extInfo:{address:y.address}})}async setRewards({poolInfo:e,poolKeys:t,ownerInfo:n,rewardInfos:o,associatedOnly:s=!0,checkCreateATAOwner:i=!1,computeBudgetConfig:r,txTipConfig:u,txVersion:a,feePayer:l}){let m=this.createTxBuilder(l),p={};for(let d of o){d.endTime<=d.openTime&&this.logAndCreateError("reward time error","rewardInfo",d);let f=n.useSOLBalance&&d.mint.address===Z.toString(),{account:y,instructionParams:b}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:new Q(d.mint.programId),mint:new Q(d.mint.address),notUseTokenAccount:f,owner:this.scope.ownerPubKey,createInfo:f?{payer:n.feePayer||this.scope.ownerPubKey,amount:new wt(new ao(d.perSecond.mul(d.endTime-d.openTime).toFixed(0)).gte(d.perSecond.mul(d.endTime-d.openTime))?d.perSecond.mul(d.endTime-d.openTime).toFixed(0):d.perSecond.mul(d.endTime-d.openTime).add(1).toFixed(0))}:void 0,associatedOnly:f?!1:s,checkCreateATAOwner:i});b&&m.addInstruction(b),y||this.logAndCreateError("no money","ownerRewardAccount",this.scope.account.tokenAccountRawInfos);let g=t!=null?t:await this.getClmmPoolKeys(e.id),A=Ke.setRewardInstructions({poolInfo:e,poolKeys:g,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccount:y},rewardInfo:{mint:new Q(d.mint.address),openTime:d.openTime,endTime:d.endTime,emissionsPerSecondX64:le.decimalToX64(d.perSecond)}});m.addInstruction(A),p=v(v({},p),A.address)}return m.addCustomComputeBudget(r),m.addTipInstruction(u),m.versionBuild({txVersion:a,extInfo:{address:p}})}async collectReward({poolInfo:e,ownerInfo:t,rewardMint:n,associatedOnly:o=!0,checkCreateATAOwner:s=!1,computeBudgetConfig:i,txTipConfig:r,txVersion:u,feePayer:a}){let l=e.rewardDefaultInfos.find(g=>g.mint.address===n.toString());l||this.logAndCreateError("reward mint error","not found reward mint",n);let m=this.createTxBuilder(a),p=t.useSOLBalance&&n.equals(Z),{account:d,instructionParams:f}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:new Q(l.mint.programId),mint:n,notUseTokenAccount:p,owner:this.scope.ownerPubKey,skipCloseAccount:!p,createInfo:{payer:t.feePayer||this.scope.ownerPubKey,amount:0},associatedOnly:p?!1:o,checkCreateATAOwner:s});f&&m.addInstruction(f),d||this.logAndCreateError("no money","ownerRewardAccount",this.scope.account.tokenAccountRawInfos);let y=await this.getClmmPoolKeys(e.id),b=Ke.collectRewardInstructions({poolInfo:e,poolKeys:y,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccount:d},rewardMint:n});return m.addInstruction(b),m.addCustomComputeBudget(i),m.addTipInstruction(r),m.versionBuild({txVersion:u,extInfo:{address:b.address}})}async collectRewards({poolInfo:e,ownerInfo:t,rewardMints:n,associatedOnly:o=!0,checkCreateATAOwner:s=!1,computeBudgetConfig:i,txTipConfig:r,feePayer:u}){let a=this.createTxBuilder(u),l={};for(let m of n){let p=e.rewardDefaultInfos.find(A=>A.mint.address===m.toString());if(!p){this.logAndCreateError("reward mint error","not found reward mint",m);continue}let d=t.useSOLBalance&&m.equals(Z),{account:f,instructionParams:y}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:new Q(p.mint.programId),mint:m,notUseTokenAccount:d,owner:this.scope.ownerPubKey,skipCloseAccount:!d,createInfo:{payer:t.feePayer||this.scope.ownerPubKey,amount:0},associatedOnly:d?!1:o,checkCreateATAOwner:s});f||this.logAndCreateError("no money","ownerRewardAccount",this.scope.account.tokenAccountRawInfos),y&&a.addInstruction(y);let b=await this.getClmmPoolKeys(e.id),g=Ke.collectRewardInstructions({poolInfo:e,poolKeys:b,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccount:f},rewardMint:m});a.addInstruction(g),l=v(v({},l),g.address)}return a.addCustomComputeBudget(i),a.addTipInstruction(r),a.build({address:l})}async swap({poolInfo:e,poolKeys:t,inputMint:n,amountIn:o,amountOutMin:s,priceLimit:i,observationId:r,ownerInfo:u,remainingAccounts:a,associatedOnly:l=!0,checkCreateATAOwner:m=!1,txVersion:p,computeBudgetConfig:d,txTipConfig:f,feePayer:y}){let b=this.createTxBuilder(y),g=n.toString()===e.mintA.address,A=u.useSOLBalance&&e.mintA.address===Z.toBase58(),h=u.useSOLBalance&&e.mintB.address===Z.toBase58(),I;!i||i.equals(new ao(0))?I=g?Wt.add(new wt(1)):qt.sub(new wt(1)):I=re.priceToSqrtPriceX64(i,e.mintA.decimals,e.mintB.decimals);let T;if(!T){let{account:x,instructionParams:K}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:e.mintA.programId,mint:new Q(e.mintA.address),notUseTokenAccount:A,owner:this.scope.ownerPubKey,skipCloseAccount:!A,createInfo:A||!g?{payer:u.feePayer||this.scope.ownerPubKey,amount:g?o:0}:void 0,associatedOnly:A?!1:l,checkCreateATAOwner:m});T=x,K&&b.addInstruction(K)}let w;if(!w){let{account:x,instructionParams:K}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:e.mintB.programId,mint:new Q(e.mintB.address),notUseTokenAccount:h,owner:this.scope.ownerPubKey,skipCloseAccount:!h,createInfo:h||g?{payer:u.feePayer||this.scope.ownerPubKey,amount:g?0:o}:void 0,associatedOnly:h?!1:l,checkCreateATAOwner:m});w=x,K&&b.addInstruction(K)}(!T||!w)&&this.logAndCreateError("user do not have token account",{tokenA:e.mintA.symbol||e.mintA.address,tokenB:e.mintB.symbol||e.mintB.address,ownerTokenAccountA:T,ownerTokenAccountB:w,mintAUseSOLBalance:A,mintBUseSOLBalance:h,associatedOnly:l});let S=t!=null?t:await this.getClmmPoolKeys(e.id);return b.addInstruction(Ke.makeSwapBaseInInstructions({poolInfo:e,poolKeys:S,observationId:r,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccountA:T,tokenAccountB:w},inputMint:new Q(n),amountIn:o,amountOutMin:s,sqrtPriceLimitX64:I,remainingAccounts:a})),b.addCustomComputeBudget(d),b.addTipInstruction(f),b.versionBuild({txVersion:p})}async swapBaseOut({poolInfo:e,poolKeys:t,outputMint:n,amountOut:o,amountInMax:s,priceLimit:i,observationId:r,ownerInfo:u,remainingAccounts:a,associatedOnly:l=!0,checkCreateATAOwner:m=!1,txVersion:p,computeBudgetConfig:d,txTipConfig:f,feePayer:y}){let b=this.createTxBuilder(y),g=n.toString()===e.mintB.address,A=u.useSOLBalance&&e.mintA.address===Z.toBase58(),h=u.useSOLBalance&&e.mintB.address===Z.toBase58(),I;!i||i.equals(new ao(0))?I=n.toString()===e.mintB.address?Wt.add(new wt(1)):qt.sub(new wt(1)):I=re.priceToSqrtPriceX64(i,e.mintA.decimals,e.mintB.decimals);let T;if(!T){let{account:x,instructionParams:K}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:e.mintA.programId,mint:new Q(e.mintA.address),notUseTokenAccount:A,owner:this.scope.ownerPubKey,skipCloseAccount:!A,createInfo:A||!g?{payer:u.feePayer||this.scope.ownerPubKey,amount:g?s:0}:void 0,associatedOnly:A?!1:l,checkCreateATAOwner:m});T=x,K&&b.addInstruction(K)}let w;if(!w){let{account:x,instructionParams:K}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:e.mintB.programId,mint:new Q(e.mintB.address),notUseTokenAccount:h,owner:this.scope.ownerPubKey,skipCloseAccount:!h,createInfo:h||g?{payer:u.feePayer||this.scope.ownerPubKey,amount:g?0:s}:void 0,associatedOnly:h?!1:l,checkCreateATAOwner:m});w=x,K&&b.addInstruction(K)}(!T||!w)&&this.logAndCreateError("user do not have token account",{tokenA:e.mintA.symbol||e.mintA.address,tokenB:e.mintB.symbol||e.mintB.address,ownerTokenAccountA:T,ownerTokenAccountB:w,mintAUseSOLBalance:A,mintBUseSOLBalance:h,associatedOnly:l});let S=t!=null?t:await this.getClmmPoolKeys(e.id);return b.addInstruction(Ke.makeSwapBaseOutInstructions({poolInfo:e,poolKeys:S,observationId:r,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccountA:T,tokenAccountB:w},outputMint:new Q(n),amountOut:o,amountInMax:s,sqrtPriceLimitX64:I,remainingAccounts:a})),b.addCustomComputeBudget(d),b.addTipInstruction(f),b.versionBuild({txVersion:p})}async harvestAllRewards({allPoolInfo:e,allPositions:t,lockInfo:n,ownerInfo:o,associatedOnly:s=!0,checkCreateATAOwner:i=!1,programId:r,txVersion:u,computeBudgetConfig:a,feePayer:l,lockProgram:m=ko,lockAuth:p=Zo,clmmProgram:d=Rn}){var h,I;let f={};for(let T of this.scope.account.tokenAccountRawInfos)s?H(this.scope.ownerPubKey,T.accountInfo.mint,r).publicKey.equals(T.pubkey)&&(f[T.accountInfo.mint.toString()]=T.pubkey):f[T.accountInfo.mint.toString()]=T.pubkey;let y=Object.values(t).flat().map(T=>T.nftMint),b=await Le(this.scope.connection,y.map(T=>({pubkey:T}))),g={};b.forEach(T=>{var w,S;g[T.pubkey.toBase58()]=(S=(w=T==null?void 0:T.accountInfo)==null?void 0:w.owner)!=null?S:null});let A=this.createTxBuilder(l);for(let T of Object.values(e)){if(t[T.id]===void 0||!t[T.id].find(L=>!L.liquidity.isZero()||L.rewardInfos.find(R=>!R.rewardAmountOwed.isZero())))continue;let w=T,S=o.useSOLBalance&&w.mintA.address===Z.toString(),x=o.useSOLBalance&&w.mintB.address===Z.toString(),K=f[w.mintA.address];if(!K)if(S){let{account:L,instructionParams:R}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:w.mintA.programId,mint:new Q(w.mintA.address),notUseTokenAccount:S,owner:this.scope.ownerPubKey,skipCloseAccount:!S,createInfo:{payer:o.feePayer||this.scope.ownerPubKey,amount:0},associatedOnly:S?!1:s,checkCreateATAOwner:i});K=L,R&&A.addInstruction(R)}else{let L=new Q(w.mintA.address);K=this.scope.account.getAssociatedTokenAccount(L,new Q(w.mintA.programId)),A.addInstruction({instructions:[fl(this.scope.ownerPubKey,K,this.scope.ownerPubKey,L,new Q(w.mintA.programId))]})}let B=f[w.mintB.address];if(!B)if(x){let{account:L,instructionParams:R}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:w.mintB.programId,mint:new Q(w.mintB.address),notUseTokenAccount:x,owner:this.scope.ownerPubKey,skipCloseAccount:!x,createInfo:{payer:o.feePayer||this.scope.ownerPubKey,amount:0},associatedOnly:x?!1:s,checkCreateATAOwner:i});B=L,R&&A.addInstruction(R)}else{let L=new Q(w.mintB.address);B=this.scope.account.getAssociatedTokenAccount(L,new Q(w.mintB.programId)),A.addInstruction({instructions:[fl(this.scope.ownerPubKey,B,this.scope.ownerPubKey,L,new Q(w.mintB.programId))]})}f[w.mintA.address]=K,f[w.mintB.address]=B;let C=[];for(let L of w.rewardDefaultInfos){let R=o.useSOLBalance&&L.mint.address===Z.toString(),_=f[L.mint.address];if(!_){let{account:X,instructionParams:j}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:new Q(L.mint.programId),mint:new Q(L.mint.address),notUseTokenAccount:R,owner:this.scope.ownerPubKey,skipCloseAccount:!R,createInfo:{payer:o.feePayer||this.scope.ownerPubKey,amount:0},associatedOnly:R?!1:s});_=X,j&&A.addInstruction(j)}f[L.mint.address]=_,C.push(_)}let O=await this.getClmmPoolKeys(w.id),M=[];for(let L=0;L<O.rewardInfos.length;L++)M.push({poolRewardVault:new Q(O.rewardInfos[L].vault),ownerRewardVault:C[L],rewardMint:new Q(O.rewardInfos[L].mint.address)});for(let L of t[T.id]){let R=(h=n==null?void 0:n[T.id])==null?void 0:h[L.nftMint.toBase58()];if(R){let _=H(this.scope.ownerPubKey,R.lockNftMint,Li).publicKey,X=$.getTickArrayStartIndexByTick(L.tickLower,O.config.tickSpacing),j=$.getTickArrayStartIndexByTick(L.tickUpper,O.config.tickSpacing),{publicKey:ae}=ge(new Q(O.programId),R.poolId,X),{publicKey:ue}=ge(new Q(O.programId),R.poolId,j),{publicKey:ie}=on(new Q(O.programId),R.poolId,L.tickLower,L.tickUpper),me=Co(m,R.lockNftMint).publicKey,fe=Ke.harvestLockPositionInstructionV2({programId:m,auth:p,lockPositionId:me,clmmProgram:d,lockOwner:this.scope.ownerPubKey,lockNftMint:R.lockNftMint,lockNftAccount:_,positionNftAccount:R.nftAccount,positionId:R.positionId,poolId:R.poolId,protocolPosition:ie,vaultA:new Q(O.vault.A),vaultB:new Q(O.vault.B),tickArrayLower:ae,tickArrayUpper:ue,userVaultA:K,userVaultB:B,mintA:new Q(O.mintA.address),mintB:new Q(O.mintB.address),rewardAccounts:M,exTickArrayBitmap:Ye(d,R.poolId).publicKey});A.addInstruction({instructions:[fe],instructionTypes:[U.ClmmHarvestLockPosition],lookupTableAddress:O.lookupTableAccount?[O.lookupTableAccount]:[]})}else{let _=Ke.decreaseLiquidityInstructions({poolInfo:w,poolKeys:O,ownerPosition:L,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccountA:K,tokenAccountB:B,rewardAccounts:C},liquidity:new wt(0),amountMinA:new wt(0),amountMinB:new wt(0),nft2022:(I=g[L.nftMint.toBase58()])==null?void 0:I.equals(En)});A.addInstruction(_)}}}return u===0?A.sizeCheckBuildV0({computeBudgetConfig:a}):A.sizeCheckBuild({computeBudgetConfig:a})}async getWhiteListMint({programId:e}){let t=await this.scope.connection.getAccountInfo(ki(e).publicKey);return t?Gc.decode(t.data).whitelistMints.filter(o=>!o.equals(Q.default)):[]}async getOwnerPositionInfo({programId:e=Rn}){await this.scope.account.fetchWalletTokenAccounts();let n=this.scope.account.tokenAccountRawInfos.filter(i=>i.accountInfo.amount.eq(new wt(1))).map(i=>kt(new Q(e),i.accountInfo.mint).publicKey),o=await this.scope.connection.getMultipleAccountsInfo(n),s=[];return o.forEach(i=>{if(!i)return;let r=Ro.decode(i.data);s.push(r)}),s}async getOwnerLockedPositionInfo({programId:e=ko}){await this.scope.account.fetchWalletTokenAccounts();let n=this.scope.account.tokenAccountRawInfos.filter(u=>u.accountInfo.amount.eq(new wt(1))).map(u=>Co(new Q(e),u.accountInfo.mint).publicKey),o=await this.scope.connection.getMultipleAccountsInfo(n),s=[];o.forEach(u=>{if(!u)return;let a=Xc.decode(u.data);s.push(a)});let i=await this.scope.connection.getMultipleAccountsInfo(s.map(u=>u.positionId)),r=[];return i.forEach(u=>{if(!u)return;let a=Ro.decode(u.data);r.push(a)}),s.map((u,a)=>({position:r[a],lockInfo:u}))}async getRpcClmmPoolInfo({poolId:e}){return(await this.getRpcClmmPoolInfos({poolIds:[e]}))[String(e)]}async getRpcClmmPoolInfos({poolIds:e,config:t}){let n=await Le(this.scope.connection,e.map(s=>({pubkey:new Q(s)})),t),o={};for(let s=0;s<e.length;s++){let i=n[s];if(i===null||!i.accountInfo)throw Error("fetch pool info error: "+String(e[s]));let r=eo.decode(i.accountInfo.data),u=re.sqrtPriceX64ToPrice(r.sqrtPriceX64,r.mintDecimalsA,r.mintDecimalsB).toNumber();o[String(e[s])]=q(v({},r),{currentPrice:u,programId:i.accountInfo.owner})}return o}async getComputeClmmPoolInfos({clmmPoolsRpcInfo:e,mintInfos:t}){let n=new Set(Object.keys(e).map(u=>e[u].ammConfig.toBase58())),o=await Le(this.scope.connection,Array.from(n).map(u=>({pubkey:new Q(u)}))),s={};o.forEach(u=>{!u.accountInfo||(s[u.pubkey.toBase58()]=qc.decode(u.accountInfo.data))});let i=await Oe.fetchComputeMultipleClmmInfo({connection:this.scope.connection,rpcDataMap:e,poolList:Object.keys(e).map(u=>{var m,p,d,f;let[a,l]=[e[u].mintA.toBase58(),e[u].mintB.toBase58()];return{id:u,programId:e[u].programId.toBase58(),mintA:yt({address:a,decimals:e[u].mintDecimalsA,programId:t[a].programId.toBase58()||Li.toBase58(),extensions:{feeConfig:(m=t[a])!=null&&m.feeConfig?Vn((p=t[a])==null?void 0:p.feeConfig):void 0}}),mintB:yt({address:l,decimals:e[u].mintDecimalsB,programId:t[l].programId.toBase58()||Li.toBase58(),extensions:{feeConfig:(d=t[l])!=null&&d.feeConfig?Vn((f=t[l])==null?void 0:f.feeConfig):void 0}}),price:e[u].currentPrice,config:q(v({},s[e[u].ammConfig.toBase58()]),{id:e[u].ammConfig.toBase58(),fundFeeRate:0,description:"",defaultRange:0,defaultRangePoint:[]})}})}),r=await Oe.fetchMultiplePoolTickArrays({connection:this.scope.connection,poolKeys:Object.values(i)});return{computeClmmPoolInfo:i,computePoolTickData:r}}async getPoolInfoFromRpc(e){var l;let t=await this.getRpcClmmPoolInfo({poolId:e}),n=new Set([t.mintA.toBase58(),t.mintB.toBase58()]),o=await Ao({connection:this.scope.connection,mints:Array.from(n).map(m=>new Q(m))}),{computeClmmPoolInfo:s,computePoolTickData:i}=await this.scope.clmm.getComputeClmmPoolInfos({clmmPoolsRpcInfo:{[e]:t},mintInfos:o}),r=await Le(this.scope.connection,[{pubkey:t.vaultA},{pubkey:t.vaultB}]),u=Dc(s[e]);if(!r[0].accountInfo||!r[1].accountInfo)throw new Error("pool vault data not found");u.mintAmountA=Number(pl.decode(r[0].accountInfo.data).amount.toString()),u.mintAmountB=Number(pl.decode((l=r[1].accountInfo)==null?void 0:l.data).amount.toString());let a=q(v({},s[e]),{exBitmapAccount:s[e].exBitmapAccount.toBase58(),observationId:s[e].observationId.toBase58(),id:e,programId:t.programId.toBase58(),openTime:t.startTime.toString(),vault:{A:t.vaultA.toBase58(),B:t.vaultB.toBase58()},config:u.config,rewardInfos:s[e].rewardInfos.filter(m=>!m.tokenVault.equals(Q.default)).map(m=>({mint:yt({address:m.tokenMint.toBase58(),programId:Li.toBase58(),decimals:10}),vault:m.tokenVault.toBase58()}))});return{poolInfo:u,poolKeys:a,computePoolInfo:s[e],tickData:i}}};import{PublicKey as z}from"@solana/web3.js";import{AccountLayout as Yp,NATIVE_MINT as Yr,TOKEN_PROGRAM_ID as Mt,createAssociatedTokenAccountIdempotentInstruction as Bl}from"@solana/spl-token";import Ea from"bn.js";import Gr from"decimal.js-light";import Ni from"bn.js";function Wr(c,e){if(e.isZero())throw Error("divisor is zero");return c.mod(e)}function Mp(c,e){if(e.isZero())throw Error("rhs is zero");let t=c.div(e);if(t.isZero())throw Error("quotient is zero");let n=Wr(c,e);return n.gt(vo)&&(t=t.add(new Ni(1)),e=c.div(t),n=Wr(c,t),n.gt(vo)&&(e=e.add(new Ni(1)))),[t,e]}var vo=new Ni(0),qr=class{static swapWithoutFees(e,t,n){let o=t.mul(n),s=t.add(e),[i]=Mp(o,s),r=n.sub(i);if(r.isZero())throw Error("destinationAmountSwapped is zero");return{destinationAmountSwapped:r}}static lpTokensToTradingTokens(e,t,n,o,s){let i=e.mul(n).div(t),r=e.mul(o).div(t);if(s===0)return{tokenAmount0:i,tokenAmount1:r};if(s===1)return Wr(e.mul(n),t).gt(vo)&&i.gt(vo)&&(i=i.add(new Ni(1))),Wr(e.mul(o),t).gt(vo)&&r.gt(vo)&&(r=r.add(new Ni(1))),{tokenAmount0:i,tokenAmount1:r};throw Error("roundDirection value error")}};var Ur=class{static tradingFee(e,t){return ar(e,t,en)}static protocolFee(e,t){return xs(e,t,en)}static fundFee(e,t){return xs(e,t,en)}};var yl=(t=>(t[t.Floor=0]="Floor",t[t.Ceiling=1]="Ceiling",t))(yl||{}),Xr=class{static validate_supply(e,t){if(e.isZero())throw Error("tokenAmount0 is zero");if(t.isZero())throw Error("tokenAmount1 is zero")}static swap(e,t,n,o){let s=Ur.tradingFee(e,o),i=e.sub(s),{destinationAmountSwapped:r}=qr.swapWithoutFees(i,t,n);return{newSwapDestinationAmount:n.sub(r),sourceAmountSwapped:e,destinationAmountSwapped:r,tradeFee:s}}static swapBaseOut({poolMintA:e,poolMintB:t,tradeFeeRate:n,baseReserve:o,quoteReserve:s,outputMint:i,outputAmount:r}){let[u,a,l,m,p]=t.address===i.toString()?[o,s,e.decimals,t.decimals,e.address]:[s,o,t.decimals,e.decimals,t.address],d=new Gr(a.toString()).div(10**m).div(new Gr(u.toString()).div(10**l)),f=r.gte(a)?a.sub(new Ea(1)):r,y=a.sub(f),b=$t(u.mul(f),y),g=$t(b.mul(new Ea(1e6)),new Ea(1e6).sub(n)),A=g.sub(b),h=new Gr(f.toString()).div(10**m).div(new Gr(g.toString()).div(10**l)),I=d.isZero()?0:h.sub(d).div(d).abs().toNumber();return{amountRealOut:f,amountIn:g,amountInWithoutFee:b,tradeFee:A,priceImpact:I}}};import je from"bn.js";import Ut from"decimal.js";import{PublicKey as Fi,TransactionInstruction as uo,Keypair as Gp,SystemProgram as Xp}from"@solana/web3.js";import{ASSOCIATED_TOKEN_PROGRAM_ID as Al,TOKEN_2022_PROGRAM_ID as Wa,TOKEN_PROGRAM_ID as Dn}from"@solana/spl-token";var vp=Buffer.from("vault_and_lp_mint_auth_seed","utf8"),Fp=Buffer.from("amm_config","utf8"),Vp=Buffer.from("pool","utf8"),_p=Buffer.from("pool_lp_mint","utf8"),Ep=Buffer.from("pool_vault","utf8"),Dp=Buffer.from("observation","utf8");function Fo(c){return ne([vp],c)}function fx(c,e){return ne([Fp,qp(e)],c)}function Da(c,e,t,n){return ne([Vp,e.toBuffer(),t.toBuffer(),n.toBuffer()],c)}function Wp(c,e){return ne([_p,e.toBuffer()],c)}function bl(c,e,t){return ne([Ep,e.toBuffer(),t.toBuffer()],c)}function Mi(c,e){return ne([Dp,e.toBuffer()],c)}function qp(c){let e=new ArrayBuffer(2);return new DataView(e).setUint16(0,c,!1),new Uint8Array(e)}function gl({poolId:c,programId:e,configId:t,mintA:n,mintB:o}){let s=Fo(e).publicKey,i=c||Da(e,t,n,o).publicKey,r=Wp(e,i).publicKey,u=bl(e,i,n).publicKey,a=bl(e,i,o).publicKey,l=Mi(e,i).publicKey;return{poolId:i,configId:t,authority:s,lpMint:r,vaultA:u,vaultB:a,observationId:l}}var Up=Buffer.from("locked_liquidity","utf8");function vi(c,e){return ne([Up,e.toBuffer()],c)}var zp=ye("Raydium_cpmm"),co={initialize:[175,175,109,31,13,152,155,237],deposit:[242,35,198,137,82,225,242,182],withdraw:[183,18,70,156,148,109,161,34],swapBaseInput:[143,190,90,218,196,30,51,222],swapBaseOutput:[55,217,98,86,163,74,180,173],lockCpLiquidity:[216,157,29,78,38,51,31,26],collectCpFee:[8,30,51,199,209,184,247,133]};function Pl(c,e,t,n,o,s,i,r,u,a,l,m,p,d,f,y,b,g,A,h){let I=V([k("amountMaxA"),k("amountMaxB"),k("openTime")]),T=Da(c,t,s,i).publicKey,w=[{pubkey:e,isSigner:!0,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!o.equals(T),isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!1},{pubkey:i,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:m,isSigner:!1,isWritable:!0},{pubkey:p,isSigner:!1,isWritable:!0},{pubkey:d,isSigner:!1,isWritable:!0},{pubkey:b,isSigner:!1,isWritable:!0},{pubkey:Dn,isSigner:!1,isWritable:!1},{pubkey:f,isSigner:!1,isWritable:!1},{pubkey:y,isSigner:!1,isWritable:!1},{pubkey:Al,isSigner:!1,isWritable:!1},{pubkey:ir,isSigner:!1,isWritable:!1},{pubkey:$e,isSigner:!1,isWritable:!1}],S=Buffer.alloc(I.span);return I.encode({amountMaxA:g,amountMaxB:A,openTime:h},S),new uo({keys:w,programId:c,data:Buffer.from([...co.initialize,...S])})}function kl(c,e,t,n,o,s,i,r,u,a,l,m,p,d,f){let y=V([k("lpAmount"),k("amountMaxA"),k("amountMaxB")]),b=[{pubkey:e,isSigner:!0,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:Dn,isSigner:!1,isWritable:!1},{pubkey:Wa,isSigner:!1,isWritable:!1},{pubkey:a,isSigner:!1,isWritable:!1},{pubkey:l,isSigner:!1,isWritable:!1},{pubkey:m,isSigner:!1,isWritable:!0}],g=Buffer.alloc(y.span);return zp.debug("cpmm deposit data",{lpAmount:p.toString(),amountMaxA:d.toString(),amountMaxB:f.toString()}),y.encode({lpAmount:p,amountMaxA:d,amountMaxB:f},g),new uo({keys:b,programId:c,data:Buffer.from([...co.deposit,...g])})}function wl(c,e,t,n,o,s,i,r,u,a,l,m,p,d,f){let y=V([k("lpAmount"),k("amountMinA"),k("amountMinB")]),b=[{pubkey:e,isSigner:!0,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:Dn,isSigner:!1,isWritable:!1},{pubkey:Wa,isSigner:!1,isWritable:!1},{pubkey:a,isSigner:!1,isWritable:!1},{pubkey:l,isSigner:!1,isWritable:!1},{pubkey:m,isSigner:!1,isWritable:!0},{pubkey:un,isSigner:!1,isWritable:!1}],g=Buffer.alloc(y.span);return y.encode({lpAmount:p,amountMinA:d,amountMinB:f},g),new uo({keys:b,programId:c,data:Buffer.from([...co.withdraw,...g])})}function zr(c,e,t,n,o,s,i,r,u,a,l,m,p,d,f,y){let b=V([k("amountIn"),k("amounOutMin")]),g=[{pubkey:e,isSigner:!0,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!1},{pubkey:l,isSigner:!1,isWritable:!1},{pubkey:m,isSigner:!1,isWritable:!1},{pubkey:p,isSigner:!1,isWritable:!1},{pubkey:d,isSigner:!1,isWritable:!0}],A=Buffer.alloc(b.span);return b.encode({amountIn:f,amounOutMin:y},A),new uo({keys:g,programId:c,data:Buffer.from([...co.swapBaseInput,...A])})}function Tl(c,e,t,n,o,s,i,r,u,a,l,m,p,d,f,y){let b=V([k("amountInMax"),k("amountOut")]),g=[{pubkey:e,isSigner:!0,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!1},{pubkey:l,isSigner:!1,isWritable:!1},{pubkey:m,isSigner:!1,isWritable:!1},{pubkey:p,isSigner:!1,isWritable:!1},{pubkey:d,isSigner:!1,isWritable:!0}],A=Buffer.alloc(b.span);return b.encode({amountInMax:f,amountOut:y},A),new uo({keys:g,programId:c,data:Buffer.from([...co.swapBaseOutput,...A])})}async function hl(c){var b;let{ownerInfo:e,poolInfo:t,poolKeys:n,feeNftOwner:o,getEphemeralSigners:s}=c,i=[],[r,u]=[new Fi(t.id),new Fi(t.lpMint.address)],a;if(s)a=new Fi((await s(1))[0]);else{let g=Gp.generate();i.push(g),a=g.publicKey}let{publicKey:l}=H(o,a,Dn),{publicKey:m}=hn(a),{publicKey:p}=vi(c.lockProgram,a),{publicKey:d}=H(e.wallet,u,Dn),{publicKey:f}=H(c.lockAuthProgram,u,Dn),y=Qp({programId:c.lockProgram,auth:c.lockAuthProgram,payer:e.feePayer,liquidityOwner:e.wallet,nftOwner:o,nftMint:a,nftAccount:l,poolId:r,lockPda:p,mintLp:u,userLpVault:d,lockLpVault:f,poolVaultA:new Fi(n.vault.A),poolVaultB:new Fi(n.vault.B),metadataAccount:m,lpAmount:c.lpAmount,withMetadata:(b=c.withMetadata)!=null?b:!0});return{address:{nftMint:a,nftAccount:l,metadataAccount:m,lockPda:p,userLpVault:d,lockLpVault:f},instructions:[y],signers:i,instructionTypes:[U.CpmmLockLp],lookupTableAddress:[]}}function Qp({programId:c,auth:e,payer:t,liquidityOwner:n,nftOwner:o,nftMint:s,nftAccount:i,poolId:r,lockPda:u,mintLp:a,userLpVault:l,lockLpVault:m,poolVaultA:p,poolVaultB:d,metadataAccount:f,lpAmount:y,withMetadata:b}){let g=[{pubkey:e,isSigner:!1,isWritable:!1},{pubkey:t,isSigner:!0,isWritable:!0},{pubkey:n,isSigner:!0,isWritable:!1},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:s,isSigner:!0,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!1},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!1},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:m,isSigner:!1,isWritable:!0},{pubkey:p,isSigner:!1,isWritable:!0},{pubkey:d,isSigner:!1,isWritable:!0},{pubkey:f,isSigner:!1,isWritable:!0},{pubkey:$e,isSigner:!1,isWritable:!1},{pubkey:Xp.programId,isSigner:!1,isWritable:!1},{pubkey:Dn,isSigner:!1,isWritable:!1},{pubkey:Al,isSigner:!1,isWritable:!1},{pubkey:Zt,isSigner:!1,isWritable:!1}],A=V([k("lpAmount"),qe("withMetadata")]),h=Buffer.alloc(A.span);A.encode({lpAmount:y,withMetadata:b},h);let I=Buffer.from([...co.lockCpLiquidity,...h]);return new uo({keys:g,programId:c,data:I})}function qa({programId:c,nftOwner:e,auth:t,nftAccount:n,lockPda:o,poolId:s,mintLp:i,userVaultA:r,userVaultB:u,poolVaultA:a,poolVaultB:l,mintA:m,mintB:p,lockLpVault:d,lpFeeAmount:f,cpmmProgram:y,cpmmAuthProgram:b}){let g=[{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:e,isSigner:!0,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:y!=null?y:$o,isSigner:!1,isWritable:!1},{pubkey:b!=null?b:Os,isSigner:!1,isWritable:!1},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:m,isSigner:!1,isWritable:!1},{pubkey:p,isSigner:!1,isWritable:!1},{pubkey:d,isSigner:!1,isWritable:!0},{pubkey:Dn,isSigner:!1,isWritable:!1},{pubkey:Wa,isSigner:!1,isWritable:!1},{pubkey:un,isSigner:!1,isWritable:!1}],A=V([k("lpFeeAmount")]),h=Buffer.alloc(A.span);A.encode({lpFeeAmount:f},h);let I=Buffer.from([...co.collectCpFee,...h]);return new uo({keys:g,programId:c,data:I})}var Il=V([he(8),E("bump"),qe("disableCreatePool"),Rt("index"),k("tradeFeeRate"),k("protocolFeeRate"),k("fundFeeRate"),k("createPoolFee"),N("protocolOwner"),N("fundOwner"),Y(k(),16)]),Qr=V([he(8),N("configId"),N("poolCreator"),N("vaultA"),N("vaultB"),N("mintLp"),N("mintA"),N("mintB"),N("mintProgramA"),N("mintProgramB"),N("observationId"),E("bump"),E("status"),E("lpDecimals"),E("mintDecimalA"),E("mintDecimalB"),k("lpAmount"),k("protocolFeesMintA"),k("protocolFeesMintB"),k("fundFeesMintA"),k("fundFeesMintB"),k("openTime"),Y(k(),32)]);var Vi=class extends Fe{constructor(e){super(e)}async load(){this.checkDisabled()}async getCpmmPoolKeys(e){return(await this.scope.api.fetchPoolKeysById({idList:[e]}))[0]}async getRpcPoolInfo(e,t){return(await this.getRpcPoolInfos([e],t))[e]}async getRpcPoolInfos(e,t){let n=await Le(this.scope.connection,e.map(m=>({pubkey:new z(m)}))),o={},s=new Set,i=[];for(let m=0;m<e.length;m++){let p=n[m];if(p.accountInfo===null)throw Error("fetch pool info error: "+String(e[m]));let d=Qr.decode(p.accountInfo.data);o[String(e[m])]=q(v({},d),{programId:p.accountInfo.owner}),s.add(String(d.configId)),i.push(d.vaultA,d.vaultB)}let r={};if(t){let m=[...s],p=await Le(this.scope.connection,m.map(d=>({pubkey:new z(d)})));for(let d=0;d<m.length;d++){let f=p[d].accountInfo;if(f===null)throw Error("fetch pool config error: "+m[d]);r[m[d]]=Il.decode(f.data)}}let u={},a=await Le(this.scope.connection,i.map(m=>({pubkey:new z(m)})));for(let m=0;m<i.length;m++){let p=a[m].accountInfo;if(p===null)throw Error("fetch vault info error: "+i[m]);u[String(i[m])]=new je(Yp.decode(p.data).amount.toString())}let l={};for(let[m,p]of Object.entries(o)){let d=u[p.vaultA.toString()].sub(p.protocolFeesMintA).sub(p.fundFeesMintA),f=u[p.vaultB.toString()].sub(p.protocolFeesMintB).sub(p.fundFeesMintB);l[m]=q(v({},p),{baseReserve:d,quoteReserve:f,vaultAAmount:u[p.vaultA.toString()],vaultBAmount:u[p.vaultB.toString()],configInfo:r[p.configId.toString()],poolPrice:new Ut(f.toString()).div(new Ut(10).pow(p.mintDecimalB)).div(new Ut(d.toString()).div(new Ut(10).pow(p.mintDecimalA)))})}return l}toComputePoolInfos({pools:e,mintInfos:t}){return Object.keys(e).reduce((n,o)=>{var u,a,l,m;let s=e[o],[i,r]=[s.mintA.toBase58(),s.mintB.toBase58()];return q(v({},n),{[o]:q(v({},s),{id:new z(o),configInfo:s.configInfo,version:7,authority:Fo(s.programId).publicKey,mintA:yt({address:i,decimals:s.mintDecimalA,programId:s.mintProgramA.toBase58(),extensions:{feeConfig:(u=t[i])!=null&&u.feeConfig?Vn((a=t[i])==null?void 0:a.feeConfig):void 0}}),mintB:yt({address:r,decimals:s.mintDecimalB,programId:s.mintProgramB.toBase58(),extensions:{feeConfig:(l=t[r])!=null&&l.feeConfig?Vn((m=t[r])==null?void 0:m.feeConfig):void 0}})})})},{})}async getPoolInfoFromRpc(e){let t=await this.getRpcPoolInfo(e,!0),n=await Ao({connection:this.scope.connection,mints:[t.mintA,t.mintB]}),o=yt({address:t.mintA.toBase58(),decimals:t.mintDecimalA,programId:t.mintProgramA.toBase58(),extensions:{feeConfig:n[t.mintA.toBase58()].feeConfig?Vn(n[t.mintA.toBase58()].feeConfig):void 0}}),s=yt({address:t.mintB.toBase58(),decimals:t.mintDecimalB,programId:t.mintProgramB.toBase58(),extensions:{feeConfig:n[t.mintB.toBase58()].feeConfig?Vn(n[t.mintB.toBase58()].feeConfig):void 0}}),i=yt({address:t.mintLp.toBase58(),decimals:t.lpDecimals,programId:Mt.toBase58()}),r={id:t.configId.toBase58(),index:t.configInfo.index,protocolFeeRate:t.configInfo.protocolFeeRate.toNumber(),tradeFeeRate:t.configInfo.tradeFeeRate.toNumber(),fundFeeRate:t.configInfo.fundFeeRate.toNumber(),createPoolFee:t.configInfo.createPoolFee.toString()},u={volume:0,volumeQuote:0,volumeFee:0,apr:0,feeApr:0,priceMin:0,priceMax:0,rewardApr:[]};return{poolInfo:{programId:t.programId.toBase58(),id:e,type:"Standard",lpMint:i,lpPrice:0,lpAmount:t.lpAmount.toNumber(),config:r,mintA:o,mintB:s,rewardDefaultInfos:[],rewardDefaultPoolInfos:"Ecosystem",price:t.poolPrice.toNumber(),mintAmountA:new Ut(t.vaultAAmount.toString()).div(10**o.decimals).toNumber(),mintAmountB:new Ut(t.vaultBAmount.toString()).div(10**s.decimals).toNumber(),feeRate:t.configInfo.tradeFeeRate.toNumber(),openTime:t.openTime.toString(),tvl:0,burnPercent:0,day:u,week:u,month:u,pooltype:[],farmUpcomingCount:0,farmOngoingCount:0,farmFinishedCount:0},poolKeys:{programId:t.programId.toBase58(),id:e,mintA:o,mintB:s,openTime:t.openTime.toString(),vault:{A:t.vaultA.toBase58(),B:t.vaultB.toBase58()},authority:Fo(t.programId).publicKey.toBase58(),mintLp:i,config:r,observationId:Mi(t.programId,new z(e)).publicKey.toBase58()},rpcData:t}}async createPool(f){var y=f,{poolId:e,programId:t,poolFeeAccount:n,startTime:o,ownerInfo:s,associatedOnly:i=!1,checkCreateATAOwner:r=!1,txVersion:u,feeConfig:a,computeBudgetConfig:l,txTipConfig:m,feePayer:p}=y,d=Ee(y,["poolId","programId","poolFeeAccount","startTime","ownerInfo","associatedOnly","checkCreateATAOwner","txVersion","feeConfig","computeBudgetConfig","txTipConfig","feePayer"]);var _,X,j;let b=s.feePayer||((_=this.scope.owner)==null?void 0:_.publicKey),g=new je(new z(d.mintA.address).toBuffer()).lte(new je(new z(d.mintB.address).toBuffer())),[A,h]=g?[d.mintA,d.mintB]:[d.mintB,d.mintA],[I,T]=g?[d.mintAAmount,d.mintBAmount]:[d.mintBAmount,d.mintAAmount],w=s.useSOLBalance&&A.address===Yr.toBase58(),S=s.useSOLBalance&&h.address===Yr.toBase58(),[x,K]=[new z(A.address),new z(h.address)],B=this.createTxBuilder(p),{account:C,instructionParams:O}=await this.scope.account.getOrCreateTokenAccount({mint:x,tokenProgram:A.programId,owner:this.scope.ownerPubKey,createInfo:w?{payer:b,amount:I}:void 0,notUseTokenAccount:w,skipCloseAccount:!w,associatedOnly:w?!1:i,checkCreateATAOwner:r});B.addInstruction(O||{});let{account:M,instructionParams:L}=await this.scope.account.getOrCreateTokenAccount({mint:new z(h.address),tokenProgram:h.programId,owner:this.scope.ownerPubKey,createInfo:S?{payer:b,amount:T}:void 0,notUseTokenAccount:S,skipCloseAccount:!S,associatedOnly:S?!1:i,checkCreateATAOwner:r});if(B.addInstruction(L||{}),C===void 0||M===void 0)throw Error("you don't has some token account");let R=gl({poolId:e,programId:t,configId:new z(a.id),mintA:x,mintB:K});return B.addInstruction({instructions:[Pl(t,this.scope.ownerPubKey,new z(a.id),R.authority,R.poolId,x,K,R.lpMint,C,M,H(this.scope.ownerPubKey,R.lpMint).publicKey,R.vaultA,R.vaultB,n,new z((X=A.programId)!=null?X:Mt),new z((j=h.programId)!=null?j:Mt),R.observationId,I,T,o)],instructionTypes:[U.CpmmCreatePool]}),B.addCustomComputeBudget(l),B.addTipInstruction(m),B.versionBuild({txVersion:u,extInfo:{address:q(v({},R),{mintA:A,mintB:h,programId:t,poolFeeAccount:n,feeConfig:a})}})}async addLiquidity(e){let{poolInfo:t,poolKeys:n,inputAmount:o,baseIn:s,slippage:i,computeResult:r,computeBudgetConfig:u,txTipConfig:a,config:l,txVersion:m,feePayer:p}=e;this.scope.availability.addStandardPosition===!1&&this.logAndCreateError("add liquidity feature disabled in your region"),o.isZero()&&this.logAndCreateError("amounts must greater than zero","amountInA",{amountInA:o.toString()});let{account:d}=this.scope,{bypassAssociatedCheck:f,checkCreateATAOwner:y}=v({bypassAssociatedCheck:!1,checkCreateATAOwner:!1},l),b=r?void 0:await this.getRpcPoolInfo(t.id),{liquidity:g,inputAmountFee:A,anotherAmount:h}=r||this.computePairAmount({poolInfo:q(v({},t),{lpAmount:new Ut(b.lpAmount.toString()).div(10**t.lpMint.decimals).toNumber()}),baseReserve:b.baseReserve,quoteReserve:b.quoteReserve,slippage:new st(0),baseIn:s,epochInfo:await this.scope.fetchEpochInfo(),amount:new Ut(o.toString()).div(10**(s?t.mintA.decimals:t.mintB.decimals))}),I=h.amount,T=t.mintA.address===Yr.toString(),w=t.mintB.address===Yr.toString(),S=this.createTxBuilder(p),[x,K]=[new z(t.mintA.address),new z(t.mintB.address)],{account:B,instructionParams:C}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:t.mintA.programId,mint:new z(t.mintA.address),owner:this.scope.ownerPubKey,createInfo:T||(s?o:I).isZero()?{payer:this.scope.ownerPubKey,amount:s?o:I}:void 0,skipCloseAccount:!T,notUseTokenAccount:T,associatedOnly:!1,checkCreateATAOwner:y});S.addInstruction(C||{});let{account:O,instructionParams:M}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:t.mintB.programId,mint:new z(t.mintB.address),owner:this.scope.ownerPubKey,createInfo:w||(s?I:o).isZero()?{payer:this.scope.ownerPubKey,amount:s?I:o}:void 0,skipCloseAccount:!w,notUseTokenAccount:w,associatedOnly:!1,checkCreateATAOwner:y});S.addInstruction(M||{}),!B&&!O&&this.logAndCreateError("cannot found target token accounts","tokenAccounts",d.tokenAccounts);let L=await d.getCreatedTokenAccount({mint:new z(t.lpMint.address)}),ae=await d.handleTokenAccount({side:"out",amount:0,mint:new z(t.lpMint.address),tokenAccount:L,bypassAssociatedCheck:f,checkCreateATAOwner:y}),{tokenAccount:R}=ae,_=Ee(ae,["tokenAccount"]);S.addInstruction(_);let X=n!=null?n:await this.getCpmmPoolKeys(t.id),j=new st(new je(1)).sub(i);return S.addInstruction({instructions:[kl(new z(t.programId),this.scope.ownerPubKey,new z(X.authority),new z(t.id),R,B,O,new z(X.vault.A),new z(X.vault.B),x,K,new z(t.lpMint.address),r?r==null?void 0:r.liquidity:j.mul(g).quotient,s?A.amount:I,s?I:A.amount)],instructionTypes:[U.CpmmAddLiquidity],lookupTableAddress:X.lookupTableAccount?[X.lookupTableAccount]:[]}),S.addCustomComputeBudget(u),S.addTipInstruction(a),S.versionBuild({txVersion:m})}async withdrawLiquidity(e){var _,X;let{poolInfo:t,poolKeys:n,lpAmount:o,slippage:s,computeBudgetConfig:i,txTipConfig:r,txVersion:u,feePayer:a,closeWsol:l=!0}=e;this.scope.availability.addStandardPosition===!1&&this.logAndCreateError("add liquidity feature disabled in your region");let m=new st(new je(1)).sub(s),p=await this.getRpcPoolInfo(t.id),[d,f]=[m.mul(o.mul(p.baseReserve).div(p.lpAmount)).quotient,m.mul(o.mul(p.quoteReserve).div(p.lpAmount)).quotient],y=await this.scope.fetchEpochInfo(),[b,g]=[Te(d,t.mintA.extensions.feeConfig,y,!1),Te(f,t.mintB.extensions.feeConfig,y,!1)],{account:A}=this.scope,h=this.createTxBuilder(a),[I,T]=[new z(t.mintA.address),new z(t.mintB.address)],w=I.equals(Z),S=T.equals(Z),x,K,{account:B,instructionParams:C}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:t.mintA.programId,mint:new z(t.mintA.address),notUseTokenAccount:w,owner:this.scope.ownerPubKey,createInfo:{payer:this.scope.ownerPubKey,amount:0},skipCloseAccount:!(w&&l),associatedOnly:!w,checkCreateATAOwner:!1});x=B,C&&h.addInstruction(C);let{account:O,instructionParams:M}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:t.mintB.programId,mint:new z(t.mintB.address),notUseTokenAccount:S,owner:this.scope.ownerPubKey,createInfo:{payer:this.scope.ownerPubKey,amount:0},skipCloseAccount:!(S&&l),associatedOnly:!S,checkCreateATAOwner:!1});K=O,M&&h.addInstruction(M),(!x||!K)&&this.logAndCreateError("cannot found target token accounts","tokenAccounts",A.tokenAccounts);let L=await A.getCreatedTokenAccount({mint:new z(t.lpMint.address)});L||this.logAndCreateError("cannot found lp token account","tokenAccounts",A.tokenAccounts);let R=n!=null?n:await this.getCpmmPoolKeys(t.id);return h.addInstruction({instructions:[wl(new z(t.programId),this.scope.ownerPubKey,new z(R.authority),new z(t.id),L,x,K,new z(R.vault.A),new z(R.vault.B),I,T,new z(t.lpMint.address),o,d.sub((_=b.fee)!=null?_:new je(0)),f.sub((X=g.fee)!=null?X:new je(0)))],instructionTypes:[U.CpmmWithdrawLiquidity],lookupTableAddress:R.lookupTableAccount?[R.lookupTableAccount]:[]}),h.addCustomComputeBudget(i),h.addTipInstruction(r),h.versionBuild({txVersion:u})}async swap(e){var C,O,M,L,R,_;let{poolInfo:t,poolKeys:n,baseIn:o,fixedOut:s,inputAmount:i,swapResult:r,slippage:u=0,config:a,computeBudgetConfig:l,txTipConfig:m,txVersion:p,feePayer:d}=e,{bypassAssociatedCheck:f,checkCreateATAOwner:y,associatedOnly:b}=v({bypassAssociatedCheck:!1,checkCreateATAOwner:!1,associatedOnly:!0},a),g=this.createTxBuilder(d),[A,h]=[new z(t.mintA.address),new z(t.mintB.address)];s?r.sourceAmountSwapped=r.sourceAmountSwapped.mul(new je((1+u)*1e4)).div(new je(1e4)):r.destinationAmountSwapped=r.destinationAmountSwapped.mul(new je((1-u)*1e4)).div(new je(1e4));let I=t.mintA.address===Z.toBase58(),T=t.mintB.address===Z.toBase58(),{account:w,instructionParams:S}=await this.scope.account.getOrCreateTokenAccount({mint:A,tokenProgram:new z((C=t.mintA.programId)!=null?C:Mt),owner:this.scope.ownerPubKey,createInfo:I||!o?{payer:this.scope.ownerPubKey,amount:o?r.sourceAmountSwapped:0}:void 0,notUseTokenAccount:I,skipCloseAccount:!I,associatedOnly:I?!1:b,checkCreateATAOwner:y});S&&g.addInstruction(S);let{account:x,instructionParams:K}=await this.scope.account.getOrCreateTokenAccount({mint:h,tokenProgram:new z((O=t.mintB.programId)!=null?O:Mt),owner:this.scope.ownerPubKey,createInfo:T||o?{payer:this.scope.ownerPubKey,amount:o?0:r.sourceAmountSwapped}:void 0,notUseTokenAccount:T,skipCloseAccount:!T,associatedOnly:T?!1:b,checkCreateATAOwner:y});K&&g.addInstruction(K),(!w||!x)&&this.logAndCreateError("user do not have token account",{mintA:t.mintA.symbol||t.mintA.address,mintB:t.mintB.symbol||t.mintB.address,mintATokenAcc:w,mintBTokenAcc:x,mintAUseSOLBalance:I,mintBUseSOLBalance:T,associatedOnly:b});let B=n!=null?n:await this.getCpmmPoolKeys(t.id);return g.addInstruction({instructions:[s?Tl(new z(t.programId),this.scope.ownerPubKey,new z(B.authority),new z(B.config.id),new z(t.id),o?w:x,o?x:w,new z(B.vault[o?"A":"B"]),new z(B.vault[o?"B":"A"]),new z((R=t[o?"mintA":"mintB"].programId)!=null?R:Mt),new z((_=t[o?"mintB":"mintA"].programId)!=null?_:Mt),o?A:h,o?h:A,Mi(new z(t.programId),new z(t.id)).publicKey,r.sourceAmountSwapped,r.destinationAmountSwapped):zr(new z(t.programId),this.scope.ownerPubKey,new z(B.authority),new z(B.config.id),new z(t.id),o?w:x,o?x:w,new z(B.vault[o?"A":"B"]),new z(B.vault[o?"B":"A"]),new z((M=t[o?"mintA":"mintB"].programId)!=null?M:Mt),new z((L=t[o?"mintB":"mintA"].programId)!=null?L:Mt),o?A:h,o?h:A,Mi(new z(t.programId),new z(t.id)).publicKey,i,r.destinationAmountSwapped)],instructionTypes:[s?U.CpmmSwapBaseOut:U.ClmmSwapBaseIn]}),g.addCustomComputeBudget(l),g.addTipInstruction(m),g.versionBuild({txVersion:p})}async lockLp(e){var p,d,f,y,b;let{poolInfo:t,lpAmount:n,computeBudgetConfig:o,txTipConfig:s,txVersion:i,feePayer:r,feeNftOwner:u}=e;n.isZero()&&this.logAndCreateError("lpAmount must greater than zero",{lpAmount:n.toString()});let a=this.createTxBuilder(r),l=(p=e.poolKeys)!=null?p:await this.getCpmmPoolKeys(t.id),m=await hl({poolInfo:t,poolKeys:l,ownerInfo:{wallet:this.scope.ownerPubKey,feePayer:(d=e.feePayer)!=null?d:this.scope.ownerPubKey},feeNftOwner:u!=null?u:this.scope.ownerPubKey,lockProgram:(f=e.programId)!=null?f:Jo,lockAuthProgram:(y=e.authProgram)!=null?y:ei,lpAmount:n,withMetadata:(b=e.withMetadata)!=null?b:!0,getEphemeralSigners:e.getEphemeralSigners});return a.addInstruction(m),a.addCustomComputeBudget(o),a.addTipInstruction(s),a.versionBuild({txVersion:i,extInfo:m.address})}async harvestLockLp(e){var O;let{poolInfo:t,lpFeeAmount:n,nftMint:o,programId:s=Jo,authProgram:i=ei,cpmmProgram:r,computeBudgetConfig:u,txTipConfig:a,txVersion:l,closeWsol:m=!0}=e;n.isZero()&&this.logAndCreateError("lpFeeAmount must greater than zero",{lpAmount:n.toString()});let p=e.feePayer||this.scope.ownerPubKey,d=this.createTxBuilder(p),[f,y]=[new z(t.mintA.address),new z(t.mintB.address)],b=f.equals(Z),g=y.equals(Z),A,h,{account:I,instructionParams:T}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:t.mintA.programId,mint:new z(t.mintA.address),notUseTokenAccount:b,owner:this.scope.ownerPubKey,createInfo:{payer:this.scope.ownerPubKey,amount:0},skipCloseAccount:!(b&&m),associatedOnly:!b,checkCreateATAOwner:!1});A=I,T&&d.addInstruction(T);let{account:w,instructionParams:S}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:t.mintB.programId,mint:new z(t.mintB.address),notUseTokenAccount:g,owner:this.scope.ownerPubKey,createInfo:{payer:this.scope.ownerPubKey,amount:0},skipCloseAccount:!(g&&m),associatedOnly:!g,checkCreateATAOwner:!1});h=w,S&&d.addInstruction(S),(!A||!h)&&this.logAndCreateError("cannot found target token accounts",{tokenAccountA:A,tokenAccountB:h});let x=(O=e.poolKeys)!=null?O:await this.getCpmmPoolKeys(t.id),{publicKey:K}=H(p,o,Mt),{publicKey:B}=vi(s,o),{publicKey:C}=H(i,new z(t.lpMint.address),Mt);return d.addInstruction({instructions:[qa({programId:s,nftOwner:this.scope.ownerPubKey,auth:i,nftMint:o,nftAccount:K,lockPda:B,poolId:new z(t.id),mintLp:new z(x.mintLp.address),userVaultA:A,userVaultB:h,poolVaultA:new z(x.vault.A),poolVaultB:new z(x.vault.B),mintA:f,mintB:y,lockLpVault:C,lpFeeAmount:n,cpmmProgram:r==null?void 0:r.programId,cpmmAuthProgram:r==null?void 0:r.authProgram})],instructionTypes:[U.CpmmCollectLockFee]}),d.addCustomComputeBudget(u),d.addTipInstruction(a),d.versionBuild({txVersion:l})}async harvestMultiLockLp(e){let{lockInfo:t,programId:n=Jo,authProgram:o=ei,cpmmProgram:s,computeBudgetConfig:i,txVersion:r,closeWsol:u=!0}=e,a=e.feePayer||this.scope.ownerPubKey,l=this.createTxBuilder(a),m={};return t.forEach(async p=>{var B;let{poolInfo:d,lpFeeAmount:f,nftMint:y}=p;if(f.isZero())return;let[b,g]=[new z(d.mintA.address),new z(d.mintB.address)],A=b.equals(Z),h=g.equals(Z),I=m[d.mintA.address],T=m[d.mintB.address];if(!I)if(A){let{account:C,instructionParams:O}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:d.mintA.programId,mint:new z(d.mintA.address),notUseTokenAccount:!0,owner:this.scope.ownerPubKey,createInfo:{payer:this.scope.ownerPubKey,amount:0},skipCloseAccount:!u,associatedOnly:!1,checkCreateATAOwner:!1});I=C,O&&l.addInstruction(O),m[d.mintA.address]=C}else{let C=new z(d.mintA.address);I=this.scope.account.getAssociatedTokenAccount(C,new z(d.mintA.programId)),l.addInstruction({instructions:[Bl(this.scope.ownerPubKey,I,this.scope.ownerPubKey,C)]}),m[d.mintA.address]=I}if(!T)if(h){let{account:C,instructionParams:O}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:d.mintB.programId,mint:new z(d.mintB.address),notUseTokenAccount:!0,owner:this.scope.ownerPubKey,createInfo:{payer:this.scope.ownerPubKey,amount:0},skipCloseAccount:!u,associatedOnly:!1,checkCreateATAOwner:!1});T=C,O&&l.addInstruction(O),m[d.mintB.address]=C}else{let C=new z(d.mintB.address);T=this.scope.account.getAssociatedTokenAccount(C,new z(d.mintB.programId)),l.addInstruction({instructions:[Bl(this.scope.ownerPubKey,T,this.scope.ownerPubKey,C)]}),m[d.mintB.address]=T}(!I||!T)&&this.logAndCreateError("cannot found target token accounts",{tokenAccountA:I,tokenAccountB:T});let w=(B=p.poolKeys)!=null?B:await this.getCpmmPoolKeys(d.id),{publicKey:S}=H(a,y,Mt),{publicKey:x}=vi(n,y),{publicKey:K}=H(o,new z(d.lpMint.address),Mt);l.addInstruction({instructions:[qa({programId:n,nftOwner:this.scope.ownerPubKey,auth:o,nftMint:y,nftAccount:S,lockPda:x,poolId:new z(d.id),mintLp:new z(w.mintLp.address),userVaultA:I,userVaultB:T,poolVaultA:new z(w.vault.A),poolVaultB:new z(w.vault.B),mintA:b,mintB:g,lockLpVault:K,lpFeeAmount:f,cpmmProgram:s==null?void 0:s.programId,cpmmAuthProgram:s==null?void 0:s.authProgram})],instructionTypes:[U.CpmmCollectLockFee]})}),r===0?l.sizeCheckBuildV0({computeBudgetConfig:i}):l.sizeCheckBuild({computeBudgetConfig:i})}computeSwapAmount({pool:e,amountIn:t,outputMint:n,slippage:o}){let s=n.toString()===e.mintB.address,i=Xr.swap(t,s?e.baseReserve:e.quoteReserve,s?e.quoteReserve:e.baseReserve,e.configInfo.tradeFeeRate),r=new Ut(i.destinationAmountSwapped.toString()).div(i.sourceAmountSwapped.toString()),u=i.destinationAmountSwapped.mul(new je((1-o)*1e4)).div(new je(1e4));return{allTrade:i.sourceAmountSwapped.eq(t),amountIn:t,amountOut:i.destinationAmountSwapped,minAmountOut:u,executionPrice:r,fee:i.tradeFee,priceImpact:e.poolPrice.sub(r).div(e.poolPrice)}}computePairAmount({poolInfo:e,baseReserve:t,quoteReserve:n,amount:o,slippage:s,epochInfo:i,baseIn:r}){var I,T,w,S,x,K,B,C,O;let u=1-Number(s.toSignificant())/100,a=new je(new Ut(o).mul(10**e[r?"mintA":"mintB"].decimals).mul(u).toFixed(0)),l=Te(a,e[r?"mintA":"mintB"].extensions.feeConfig,i,!1),m=a.sub((I=l.fee)!=null?I:new je(0)),p=new je(new Ut(e.lpAmount).mul(10**e.lpMint.decimals).toFixed(0,Ut.ROUND_DOWN));this.logDebug("baseReserve:",t.toString(),"quoteReserve:",n.toString()),this.logDebug("tokenIn:",r?e.mintA.symbol:e.mintB.symbol,"amountIn:",a.toString(),"amountInFee:",(w=(T=l.fee)==null?void 0:T.toString())!=null?w:0,"anotherToken:",r?e.mintB.symbol:e.mintA.symbol,"slippage:",`${s.toSignificant()}%`);let d=r?"base":"quote";this.logDebug("input side:",d);let f=m.mul(p).div(d==="base"?t:n),y={amount:ht,fee:void 0,expirationTime:void 0};if(!m.isZero()){let M=jp(f,t,n,p);this.logDebug("lpAmountData:",{amountA:M.amountA.toString(),amountB:M.amountB.toString()}),y=Te(M[r?"amountB":"amountA"],e[r?"mintB":"mintA"].extensions.feeConfig,i,!0)}let b=new st(new je(1)).add(s),g=new st(new je(1)).sub(s),A=Te(b.mul(y.amount.sub((S=y.fee)!=null?S:new je(0))).quotient,e[r?"mintB":"mintA"].extensions.feeConfig,i,!0),h=Te(g.mul(y.amount.sub((x=y.fee)!=null?x:new je(0))).quotient,e[r?"mintB":"mintA"].extensions.feeConfig,i,!0);return this.logDebug("anotherAmount:",y.amount.toString(),"anotherAmountFee:",(B=(K=y.fee)==null?void 0:K.toString())!=null?B:0,"maxAnotherAmount:",A.amount.toString(),"maxAnotherAmountFee:",(O=(C=A.fee)==null?void 0:C.toString())!=null?O:0),{inputAmountFee:l,anotherAmount:y,maxAnotherAmount:A,minAnotherAmount:h,liquidity:f}}};function jp(c,e,t,n){let o=c.mul(e).div(n);!o.isZero()&&!c.mul(e).mod(n).isZero()&&(o=o.add(new je(1)));let s=c.mul(t).div(n);return!s.isZero()&&!c.mul(t).mod(n).isZero()&&(s=s.add(new je(1))),{amountA:o,amountB:s}}import{PublicKey as lo}from"@solana/web3.js";import{createTransferInstruction as Ll,TOKEN_PROGRAM_ID as He,TOKEN_2022_PROGRAM_ID as Zr}from"@solana/spl-token";import $r from"bn.js";import Di from"decimal.js";var xl={[lr.toBase58()]:3},Sl={3:lr};var Ua=V([he(5),he(8),N("ownAddress"),k("vaultSignerNonce"),N("baseMint"),N("quoteMint"),N("baseVault"),k("baseDepositsTotal"),k("baseFeesAccrued"),N("quoteVault"),k("quoteDepositsTotal"),k("quoteFeesAccrued"),k("quoteDustThreshold"),N("requestQueue"),N("eventQueue"),N("bids"),N("asks"),k("baseLotSize"),k("quoteLotSize"),k("feeRateBps"),k("referrerRebatesAccrued"),he(7)]),Kl={3:Ua};import{PublicKey as Cl}from"@solana/web3.js";var jr=ye("Serum"),Hr=class{static getProgramId(e){let t=Sl[e];return t||jr.logWithError("invalid version","version",e),t}static getVersion(e){let t=e.toBase58(),n=xl[t];return n||jr.logWithError("invalid program id","programId",t),n}static getStateLayout(e){let t=Kl[e];return t||jr.logWithError(!!t,"invalid version","version",e),t}static getLayouts(e){return{state:this.getStateLayout(e)}}static getAssociatedAuthority({programId:e,marketId:t}){let n=[t.toBuffer()],o=0,s;for(;o<100;){try{let i=n.concat(Buffer.from([o]),Buffer.alloc(7));s=Cl.createProgramAddressSync(i,e)}catch(i){if(i instanceof TypeError)throw i;o++;continue}return{publicKey:s,nonce:o}}return jr.logWithError("unable to find a viable program address nonce","params",{programId:e,marketId:t}),{publicKey:Cl.default,nonce:o}}};import{PublicKey as F,SystemProgram as _i,TransactionInstruction as Ei}from"@solana/web3.js";import pn from"bn.js";import{ASSOCIATED_TOKEN_PROGRAM_ID as Ga,TOKEN_2022_PROGRAM_ID as Xa,TOKEN_PROGRAM_ID as Wn}from"@solana/spl-token";function MS(c,e,t,n,o,s,i,r,u,a,l,m){let p=V([E("instruction"),k("amountIn"),k("amountOut")]),d=[{pubkey:_i.programId,isSigner:!1,isWritable:!1},{pubkey:Wn,isSigner:!1,isWritable:!1},{pubkey:new F(t.programId),isSigner:!1,isWritable:!1},{pubkey:new F(t.id),isSigner:!1,isWritable:!0},{pubkey:new F(n.id),isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!0,isWritable:!1}];if(e.type==="Concentrated"){let y=Me(t);d.push({pubkey:y.config.id,isSigner:!1,isWritable:!1},{pubkey:y.id,isSigner:!1,isWritable:!0},{pubkey:y.mintA.address.equals(u)?y.vault.A:y.vault.B,isSigner:!1,isWritable:!0},{pubkey:y.mintA.address.equals(u)?y.vault.B:y.vault.A,isSigner:!1,isWritable:!0},{pubkey:y.id,isSigner:!1,isWritable:!0},...m.map(b=>({pubkey:b,isSigner:!1,isWritable:!0})))}else if(e.pooltype.includes("StablePool")){let y=Me(t);d.push({pubkey:y.authority,isSigner:!1,isWritable:!1},{pubkey:y.marketProgramId,isSigner:!1,isWritable:!1},{pubkey:y.id,isSigner:!1,isWritable:!0},{pubkey:new F("CDSr3ssLcRB6XYPJwAfFt18MZvEZp4LjHcvzBVZ45duo"),isSigner:!1,isWritable:!1},{pubkey:y.openOrders,isSigner:!1,isWritable:!0},{pubkey:y.vault.A,isSigner:!1,isWritable:!0},{pubkey:y.vault.B,isSigner:!1,isWritable:!0},{pubkey:y.marketId,isSigner:!1,isWritable:!0},{pubkey:y.marketBids,isSigner:!1,isWritable:!0},{pubkey:y.marketAsks,isSigner:!1,isWritable:!0},{pubkey:y.marketEventQueue,isSigner:!1,isWritable:!0},{pubkey:y.id,isSigner:!1,isWritable:!0},{pubkey:y.id,isSigner:!1,isWritable:!0})}else{let y=Me(t);d.push({pubkey:y.authority,isSigner:!1,isWritable:!1},{pubkey:y.marketProgramId,isSigner:!1,isWritable:!1},{pubkey:y.marketAuthority,isSigner:!1,isWritable:!1},{pubkey:y.openOrders,isSigner:!1,isWritable:!0},{pubkey:y.vault.A,isSigner:!1,isWritable:!0},{pubkey:y.vault.B,isSigner:!1,isWritable:!0},{pubkey:y.marketId,isSigner:!1,isWritable:!0},{pubkey:y.marketBids,isSigner:!1,isWritable:!0},{pubkey:y.marketAsks,isSigner:!1,isWritable:!0},{pubkey:y.marketEventQueue,isSigner:!1,isWritable:!0},...y.marketProgramId.toString()==="srmqPvymJeFKQ4zGQed1GFppgkRHL9kaELCbyksJtPX"?[{pubkey:y.marketBaseVault,isSigner:!1,isWritable:!0},{pubkey:y.marketQuoteVault,isSigner:!1,isWritable:!0}]:[{pubkey:y.id,isSigner:!1,isWritable:!0},{pubkey:y.id,isSigner:!1,isWritable:!0}])}let f=Buffer.alloc(p.span);return p.encode({instruction:4,amountIn:a,amountOut:l},f),new Ei({keys:d,programId:c,data:f})}function vS(c,e,t,n,o,s,i,r,u,a){let l=V([E("instruction")]),m=[{pubkey:_i.programId,isSigner:!1,isWritable:!1},{pubkey:Wn,isSigner:!1,isWritable:!1},{pubkey:new F(String(n.programId)),isSigner:!1,isWritable:!1},{pubkey:new F(String(n.id)),isSigner:!1,isWritable:!0},{pubkey:new F(String(t.id)),isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!0,isWritable:!1}];if(e.type==="Concentrated"){let d=Me(n);m.push({pubkey:d.config.id,isSigner:!1,isWritable:!1},{pubkey:d.id,isSigner:!1,isWritable:!0},{pubkey:d.mintA.address.equals(u)?d.vault.A:d.vault.B,isSigner:!1,isWritable:!0},{pubkey:d.mintA.address.equals(u)?d.vault.B:d.vault.A,isSigner:!1,isWritable:!0},{pubkey:d.id,isSigner:!1,isWritable:!0},...a.map(f=>({pubkey:f,isSigner:!1,isWritable:!0})))}else if(e.pooltype.includes("StablePool")){let d=Me(n);m.push({pubkey:d.authority,isSigner:!1,isWritable:!1},{pubkey:d.marketProgramId,isSigner:!1,isWritable:!1},{pubkey:d.id,isSigner:!1,isWritable:!0},{pubkey:new F("CDSr3ssLcRB6XYPJwAfFt18MZvEZp4LjHcvzBVZ45duo"),isSigner:!1,isWritable:!1},{pubkey:d.openOrders,isSigner:!1,isWritable:!0},{pubkey:d.vault.A,isSigner:!1,isWritable:!0},{pubkey:d.vault.B,isSigner:!1,isWritable:!0},{pubkey:d.marketId,isSigner:!1,isWritable:!0},{pubkey:d.marketBids,isSigner:!1,isWritable:!0},{pubkey:d.marketAsks,isSigner:!1,isWritable:!0},{pubkey:d.marketEventQueue,isSigner:!1,isWritable:!0},{pubkey:d.id,isSigner:!1,isWritable:!0},{pubkey:d.id,isSigner:!1,isWritable:!0})}else{let d=Me(n);m.push({pubkey:d.authority,isSigner:!1,isWritable:!1},{pubkey:d.marketProgramId,isSigner:!1,isWritable:!1},{pubkey:d.marketAuthority,isSigner:!1,isWritable:!1},{pubkey:d.openOrders,isSigner:!1,isWritable:!0},{pubkey:d.vault.A,isSigner:!1,isWritable:!0},{pubkey:d.vault.B,isSigner:!1,isWritable:!0},{pubkey:d.marketId,isSigner:!1,isWritable:!0},{pubkey:d.marketBids,isSigner:!1,isWritable:!0},{pubkey:d.marketAsks,isSigner:!1,isWritable:!0},{pubkey:d.marketEventQueue,isSigner:!1,isWritable:!0},...d.marketProgramId.toString()==="srmqPvymJeFKQ4zGQed1GFppgkRHL9kaELCbyksJtPX"?[{pubkey:d.marketBaseVault,isSigner:!1,isWritable:!0},{pubkey:d.marketQuoteVault,isSigner:!1,isWritable:!0}]:[{pubkey:d.id,isSigner:!1,isWritable:!0},{pubkey:d.id,isSigner:!1,isWritable:!0}])}let p=Buffer.alloc(l.span);return l.encode({instruction:5},p),new Ei({keys:m,programId:c,data:p})}function Hp(c,e,t,n,o,s,i,r,u,a,l,m,p,d,f){var w;let y=[],b=[P({pubkey:Wn,isWritable:!1}),P({pubkey:Xa,isWritable:!1}),P({pubkey:Ga,isWritable:!1}),P({pubkey:_i.programId,isWritable:!1}),P({pubkey:e,isSigner:!0})];b.push(P({pubkey:t})),b.push(P({pubkey:o}));let g=[u,a],A=[l,m],h=[s,i,r];for(let S=0;S<g.length;S++){let x=g[S],K=h[S]===x.mintA.address;if(b.push(P({pubkey:new F(x.programId),isWritable:!1})),S===g.length-1?b.push(P({pubkey:o})):b.push(P({pubkey:n})),b.push(P({pubkey:new F(h[S])})),b.push(P({pubkey:new F(h[S+1])})),x.version===6){let B=A[S];b.push(P({pubkey:new F(B.config.id)})),b.push(P({pubkey:new F(B.id)})),b.push(P({pubkey:new F(K?B.vault.A:B.vault.B)})),b.push(P({pubkey:new F(K?B.vault.B:B.vault.A)})),b.push(P({pubkey:new F(x.observationId)})),b.push(P({pubkey:un})),b.push(P({pubkey:Ye(new F(x.programId),new F(x.id)).publicKey})),y.push(za(x.sqrtPriceX64.toString(),K));for(let C of(w=f[S])!=null?w:[])b.push(P({pubkey:new F(C)}))}else if(x.version===5){let B=A[S];b.push(P({pubkey:new F(B.id)})),b.push(P({pubkey:new F(B.authority),isWritable:!1})),b.push(P({pubkey:new F(B.marketProgramId)})),b.push(P({pubkey:new F(B.marketAuthority)})),b.push(P({pubkey:mr,isWritable:!1})),b.push(P({pubkey:new F(B.openOrders)})),b.push(P({pubkey:new F(B.vault.A)})),b.push(P({pubkey:new F(B.vault.B)})),b.push(P({pubkey:new F(B.id)})),b.push(P({pubkey:new F(B.id)})),b.push(P({pubkey:new F(B.id)})),b.push(P({pubkey:new F(B.id)})),b.push(P({pubkey:new F(B.id)})),b.push(P({pubkey:new F(B.id)})),b.push(P({pubkey:new F(B.marketId)})),b.push(P({pubkey:new F(B.marketBids)})),b.push(P({pubkey:new F(B.marketAsks)})),b.push(P({pubkey:new F(B.marketEventQueue)})),b.push(P({pubkey:new F(B.marketBaseVault)})),b.push(P({pubkey:new F(B.marketQuoteVault)}))}else if(x.version===4){let B=A[S],C=x.status!==1;b.push(P({pubkey:new F(B.id)})),b.push(P({pubkey:new F(B.authority),isWritable:!1})),b.push(P({pubkey:new F(C?B.id:B.marketProgramId)})),b.push(P({pubkey:new F(C?B.id:B.marketAuthority)})),b.push(P({pubkey:new F(C?B.id:B.openOrders)})),b.push(P({pubkey:new F(B.vault.A)})),b.push(P({pubkey:new F(B.vault.B)})),b.push(P({pubkey:new F(C?B.id:B.marketId)})),b.push(P({pubkey:new F(C?B.id:B.marketBids)})),b.push(P({pubkey:new F(C?B.id:B.marketAsks)})),b.push(P({pubkey:new F(C?B.id:B.marketEventQueue)})),b.push(P({pubkey:new F(C?B.id:B.marketBaseVault)})),b.push(P({pubkey:new F(C?B.id:B.marketQuoteVault)}))}else if(x.version===7){let B=A[S];b.push(P({pubkey:new F(B.authority)})),b.push(P({pubkey:new F(B.config.id)})),b.push(P({pubkey:new F(B.id)})),b.push(P({pubkey:new F(K?B.vault.A:B.vault.B)})),b.push(P({pubkey:new F(K?B.vault.B:B.vault.A)})),b.push(P({pubkey:new F(x.observationId)}))}else throw Error("pool type error")}let I=V([E("insId"),k("amountIn"),k("amountOut"),Y(ee(),y.length,"clmmPriceLimit")]),T=Buffer.alloc(I.span);return I.encode({insId:0,amountIn:p,amountOut:d,clmmPriceLimit:y},T),new Ei({keys:b,programId:c,data:T})}function za(c,e){if(c)if(e){let t=new pn(c).div(new pn(25));return t.gt(Sr)?t:Sr}else{let t=new pn(c).mul(new pn(25));return t.lt(Kr)?t:Kr}else return e?Sr:Kr}function Rl({routeProgram:c,ownerInfo:e,inputMint:t,swapInfo:n}){var o,s,i,r,u,a,l;if(n.routeType==="amm")if(n.poolInfo[0].version===6){let m=n.poolKey[0],p=Me(m),d=t.equals(p.mintA.address)?Wt.add(Lt):qt.sub(Lt);return Ke.makeSwapBaseInInstructions({poolInfo:m,poolKeys:m,observationId:n.poolInfo[0].observationId,ownerInfo:{wallet:e.wallet,tokenAccountA:p.mintA.address.equals(t)?e.sourceToken:e.destinationToken,tokenAccountB:p.mintA.address.equals(t)?e.destinationToken:e.sourceToken},inputMint:t,amountIn:n.amountIn.amount.raw,amountOutMin:n.minAmountOut.amount.raw.sub((s=(o=n.minAmountOut.fee)==null?void 0:o.raw)!=null?s:new pn(0)),sqrtPriceLimitX64:d,remainingAccounts:(i=n.remainingAccounts[0])!=null?i:[]})}else if(n.poolInfo[0].version===7){let m=n.poolInfo[0],p=t.toString()===n.poolInfo[0].mintA.address;return{signers:[],instructions:[zr(m.programId,e.wallet,m.authority,m.configId,m.id,e.sourceToken,e.destinationToken,p?m.vaultA:m.vaultB,p?m.vaultB:m.vaultA,p?m.mintProgramA:m.mintProgramB,p?m.mintProgramB:m.mintProgramA,new F(m[p?"mintA":"mintB"].address),new F(m[p?"mintB":"mintA"].address),m.observationId,n.amountIn.amount.raw,n.minAmountOut.amount.raw)],lookupTableAddress:[],instructionTypes:[p?U.CpmmSwapBaseIn:U.CpmmSwapBaseOut],address:{}}}else{let m=n.poolKey[0];return{signers:[],instructions:[vr({poolKeys:m,version:n.poolInfo[0].pooltype.includes("StablePool")?5:4,userKeys:{tokenAccountIn:e.sourceToken,tokenAccountOut:e.destinationToken,owner:e.wallet},amountIn:n.amountIn.amount.raw,amountOut:n.minAmountOut.amount.raw.sub((u=(r=n.minAmountOut.fee)==null?void 0:r.raw)!=null?u:new pn(0)),fixedSide:"in"})],lookupTableAddress:m.lookupTableAccount?[m.lookupTableAccount]:[],instructionTypes:[n.poolInfo[0].pooltype.includes("StablePool")?U.AmmV5SwapBaseIn:U.AmmV4SwapBaseIn],address:{}}}else if(n.routeType==="route"){let m=n.poolInfo[0],p=n.poolInfo[1],d=n.poolKey[0],f=n.poolKey[1];if(e.routeToken===void 0)throw Error("owner route token account check error");return{signers:[],instructions:[Hp(c,e.wallet,e.sourceToken,e.routeToken,e.destinationToken,t.toString(),n.middleToken.mint.toString(),n.outputMint.toString(),m,p,d,f,n.amountIn.amount.raw,n.minAmountOut.amount.raw.sub((l=(a=n.minAmountOut.fee)==null?void 0:a.raw)!=null?l:new pn(0)),n.remainingAccounts)],instructionTypes:[U.RouteSwap],lookupTableAddress:[d.lookupTableAccount,f.lookupTableAccount].filter(y=>y!==void 0),address:{}}}else throw Error("route type error")}function FS({programId:c,wallet:e,amount:t,inputAccount:n,outputAccount:o,routeInfo:s,poolKeys:i}){var p;if(s.success===!1)throw Error("route info error");let r=[],u=[P({pubkey:Wn,isWritable:!1}),P({pubkey:Xa,isWritable:!1}),P({pubkey:Ga,isWritable:!1}),P({pubkey:_i.programId,isWritable:!1}),P({pubkey:e,isSigner:!0})],a={[s.data.inputMint]:n,[s.data.outputMint]:o};u.push(P({pubkey:a[s.data.inputMint]})),u.push(P({pubkey:a[s.data.outputMint]}));for(let d=0;d<i.length;d++){let f=s.data.routePlan[d],y=i[d],b=f.inputMint===y.mintA.address;if(u.push(P({pubkey:new F(y.programId),isWritable:!1})),d===i.length-1)u.push(P({pubkey:a[f.outputMint]}));else{let g=f.outputMint;if(a[g]===void 0){let A=H(e,new F(g),y.programId===gt.CLMM_PROGRAM_ID.toBase58()||y.programId===gt.CREATE_CPMM_POOL_PROGRAM.toBase58()?new F(b?y.mintB.programId:y.mintA.programId):Wn).publicKey;a[g]=A}u.push(P({pubkey:a[g]}))}if(u.push(P({pubkey:new F(f.inputMint)})),u.push(P({pubkey:new F(f.outputMint)})),y.programId===gt.CLMM_PROGRAM_ID.toBase58()){let g=y;u.push(P({pubkey:new F(g.config.id)})),u.push(P({pubkey:new F(g.id)})),u.push(P({pubkey:new F(b?g.vault.A:g.vault.B)})),u.push(P({pubkey:new F(b?g.vault.B:g.vault.A)})),u.push(P({pubkey:new F(g.observationId)})),u.push(P({pubkey:un,isWritable:!1})),u.push(P({pubkey:new F(g.exBitmapAccount)})),r.push(za(f.lastPoolPriceX64,b));for(let A of(p=f.remainingAccounts)!=null?p:[])u.push(P({pubkey:new F(A)}))}else if(y.programId===gt.AMM_STABLE.toBase58()){let g=y;u.push(P({pubkey:new F(g.id)})),u.push(P({pubkey:new F(g.authority),isWritable:!1})),u.push(P({pubkey:new F(g.marketProgramId),isWritable:!1})),u.push(P({pubkey:new F(g.marketAuthority),isWritable:!1})),u.push(P({pubkey:mr,isWritable:!1})),u.push(P({pubkey:new F(g.openOrders)})),u.push(P({pubkey:new F(g.vault.A)})),u.push(P({pubkey:new F(g.vault.B)})),u.push(P({pubkey:new F(g.marketId)})),u.push(P({pubkey:new F(g.marketBids)})),u.push(P({pubkey:new F(g.marketAsks)})),u.push(P({pubkey:new F(g.marketEventQueue)})),u.push(P({pubkey:new F(g.marketBaseVault)})),u.push(P({pubkey:new F(g.marketQuoteVault)}))}else if(y.programId===gt.AMM_V4.toBase58()){let g=y;u.push(P({pubkey:new F(g.id)})),u.push(P({pubkey:new F(g.authority),isWritable:!1})),u.push(P({pubkey:new F(g.id)})),u.push(P({pubkey:new F(g.id)})),u.push(P({pubkey:new F(g.id)})),u.push(P({pubkey:new F(g.vault.A)})),u.push(P({pubkey:new F(g.vault.B)})),u.push(P({pubkey:new F(g.id)})),u.push(P({pubkey:new F(g.id)})),u.push(P({pubkey:new F(g.id)})),u.push(P({pubkey:new F(g.id)})),u.push(P({pubkey:new F(g.id)})),u.push(P({pubkey:new F(g.id)}))}else if(y.programId===gt.CREATE_CPMM_POOL_PROGRAM.toBase58()){let g=y;u.push(P({pubkey:new F(g.authority)})),u.push(P({pubkey:new F(g.config.id)})),u.push(P({pubkey:new F(g.id)})),u.push(P({pubkey:new F(b?g.vault.A:g.vault.B)})),u.push(P({pubkey:new F(b?g.vault.B:g.vault.A)})),u.push(P({pubkey:new F(g.observationId)}))}else throw Error("pool type error")}let l=V([E("insId"),k("amountIn"),k("amountOut"),Y(ee(),r.length,"clmmPriceLimit")]),m=Buffer.alloc(l.span);return l.encode({insId:0,amountIn:t,amountOut:new pn(s.data.otherAmountThreshold),clmmPriceLimit:r},m),new Ei({keys:u,programId:c,data:m})}function VS({programId:c,wallet:e,inputAccount:t,outputAccount:n,routeInfo:o,poolKeys:s}){var m;if(o.success===!1)throw Error("route info error");let i=[],r=[P({pubkey:Wn,isWritable:!1}),P({pubkey:Xa,isWritable:!1}),P({pubkey:Ga,isWritable:!1}),P({pubkey:_i.programId,isWritable:!1}),P({pubkey:e,isSigner:!0})],u={[o.data.inputMint]:t,[o.data.outputMint]:n};for(let p=s.length-1;p>=0;p--){let d=o.data.routePlan[p],f=s[p],y=d.inputMint===f.mintA.address;if(r.push(P({pubkey:new F(f.programId)})),p===0)r.push(P({pubkey:u[d.inputMint]}));else{let b=d.inputMint;if(u[b]===void 0){let g=H(e,new F(b),f.programId===gt.CLMM_PROGRAM_ID.toBase58()||f.programId===gt.CREATE_CPMM_POOL_PROGRAM.toBase58()?new F(y?f.mintA.programId:f.mintB.programId):Wn).publicKey;u[b]=g}r.push(P({pubkey:u[b]}))}if(p===s.length-1)r.push(P({pubkey:u[d.outputMint]}));else{let b=d.outputMint;if(u[b]===void 0){let g=H(e,new F(b),f.programId===gt.CLMM_PROGRAM_ID.toBase58()||f.programId===gt.CREATE_CPMM_POOL_PROGRAM.toBase58()?new F(y?f.mintB.programId:f.mintA.programId):Wn).publicKey;u[b]=g}r.push(P({pubkey:u[b]}))}if(r.push(P({pubkey:new F(d.inputMint)})),r.push(P({pubkey:new F(d.outputMint)})),f.programId===gt.CLMM_PROGRAM_ID.toBase58()){let b=f;r.push(P({pubkey:new F(b.config.id)})),r.push(P({pubkey:new F(b.id)})),r.push(P({pubkey:new F(y?b.vault.A:b.vault.B)})),r.push(P({pubkey:new F(y?b.vault.B:b.vault.A)})),r.push(P({pubkey:new F(b.observationId)})),r.push(P({pubkey:un,isWritable:!1})),r.push(P({pubkey:new F(b.exBitmapAccount)})),i.push(za(d.lastPoolPriceX64,y));for(let g of(m=d.remainingAccounts)!=null?m:[])r.push(P({pubkey:new F(g)}))}else if(f.programId===gt.AMM_STABLE.toBase58()){let b=f;r.push(P({pubkey:new F(b.id)})),r.push(P({pubkey:new F(b.authority),isWritable:!1})),r.push(P({pubkey:new F(b.marketProgramId),isWritable:!1})),r.push(P({pubkey:new F(b.marketAuthority),isWritable:!1})),r.push(P({pubkey:mr,isWritable:!1})),r.push(P({pubkey:new F(b.openOrders)})),r.push(P({pubkey:new F(b.vault.A)})),r.push(P({pubkey:new F(b.vault.B)})),r.push(P({pubkey:new F(b.marketId)})),r.push(P({pubkey:new F(b.marketBids)})),r.push(P({pubkey:new F(b.marketAsks)})),r.push(P({pubkey:new F(b.marketEventQueue)})),r.push(P({pubkey:new F(b.marketBaseVault)})),r.push(P({pubkey:new F(b.marketQuoteVault)}))}else if(f.programId===gt.AMM_V4.toBase58()){let b=f;r.push(P({pubkey:new F(b.id)})),r.push(P({pubkey:new F(b.authority),isWritable:!1})),r.push(P({pubkey:new F(b.id)})),r.push(P({pubkey:new F(b.id)})),r.push(P({pubkey:new F(b.id)})),r.push(P({pubkey:new F(b.vault.A)})),r.push(P({pubkey:new F(b.vault.B)})),r.push(P({pubkey:new F(b.id)})),r.push(P({pubkey:new F(b.id)})),r.push(P({pubkey:new F(b.id)})),r.push(P({pubkey:new F(b.id)})),r.push(P({pubkey:new F(b.id)})),r.push(P({pubkey:new F(b.id)}))}else if(f.programId===gt.CREATE_CPMM_POOL_PROGRAM.toBase58()){let b=f;r.push(P({pubkey:new F(b.authority)})),r.push(P({pubkey:new F(b.config.id)})),r.push(P({pubkey:new F(b.id)})),r.push(P({pubkey:new F(y?b.vault.A:b.vault.B)})),r.push(P({pubkey:new F(y?b.vault.B:b.vault.A)})),r.push(P({pubkey:new F(b.observationId)}))}else throw Error("pool type error")}let a=V([E("insId"),k("amountIn"),k("amountOut"),Y(ee(),i.length,"clmmPriceLimit")]),l=Buffer.alloc(a.span);return a.encode({insId:1,amountIn:new pn(o.data.otherAmountThreshold),amountOut:new pn(o.data.outputAmount),clmmPriceLimit:i},l),new Ei({keys:r,programId:c,data:l})}var Sn=new $r(0),Wi=class extends Fe{constructor(e){super(e)}async getWSolAccounts(){this.scope.checkOwner(),await this.scope.account.fetchWalletTokenAccounts();let e=this.scope.account.tokenAccounts.filter(t=>t.mint.equals(Z));return e.sort((t,n)=>t.isAssociated?1:n.isAssociated||t.amount.lt(n.amount)?-1:1),e}async unWrapWSol(e){let{amount:t,tokenProgram:n,txVersion:o=1,feePayer:s}=e,i=await this.getWSolAccounts(),r=this.createTxBuilder(s);r.addCustomComputeBudget(e.computeBudgetConfig);let u=J(t);for(let a=0;a<i.length;a++)u.gte(i[a].amount)?(r.addInstruction({instructions:[wn({tokenAccount:i[a].publicKey,payer:this.scope.ownerPubKey,owner:this.scope.ownerPubKey,programId:n})]}),u.sub(i[a].amount)):r.addInstruction({instructions:[wn({tokenAccount:i[a].publicKey,payer:this.scope.ownerPubKey,owner:this.scope.ownerPubKey,programId:n})]});return r.versionBuild({txVersion:o})}async wrapWSol(e,t,n,o){let s=this.createTxBuilder(o),i=await Mn({connection:this.scope.connection,owner:this.scope.ownerPubKey,payer:this.scope.ownerPubKey,amount:e,skipCloseAccount:!0});return s.addInstruction(i),s.versionBuild({txVersion:n!=null?n:1})}async swap({swapInfo:e,swapPoolKeys:t,ownerInfo:n,computeBudgetConfig:o,routeProgram:s,txVersion:i,feePayer:r}){let u=this.createTxBuilder(r),a=e.amountIn,l=e.amountOut,m=a.amount.token.mint.equals(Z),p=l.amount.token.mint.equals(Z),d=a.amount.token.mint,f=l.amount.token.mint,{account:y,instructionParams:b}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:a.amount.token.isToken2022?Zr:He,mint:d,notUseTokenAccount:m,owner:this.scope.ownerPubKey,skipCloseAccount:!m,createInfo:m?{payer:this.scope.ownerPubKey,amount:a.amount.raw}:void 0,associatedOnly:m?!1:n.associatedOnly,checkCreateATAOwner:n.checkCreateATAOwner});if(b&&u.addInstruction(b),y===void 0)throw Error("input account check error");let g;if(e.routeType==="route"&&!p)g=this.scope.account.getAssociatedTokenAccount(f,l.amount.token.isToken2022?Zr:He);else{let{account:T,instructionParams:w}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:l.amount.token.isToken2022?Zr:He,mint:f,notUseTokenAccount:p,owner:this.scope.ownerPubKey,skipCloseAccount:!0,createInfo:{payer:this.scope.ownerPubKey,amount:0},associatedOnly:p?!1:n.associatedOnly,checkCreateATAOwner:n.checkCreateATAOwner});g=T,w&&u.addInstruction(w)}p&&u.addInstruction({endInstructions:[wn({owner:this.scope.ownerPubKey,payer:this.scope.ownerPubKey,tokenAccount:g,programId:He})],endInstructionTypes:[U.CloseAccount]});let A;if(e.routeType==="route"){let T=e.middleToken;A=this.scope.account.getAssociatedTokenAccount(T.mint,T.isToken2022?Zr:He)}let h=t||await this.computePoolToPoolKeys({pools:e.poolInfoList}),I=Rl({routeProgram:s,inputMint:d,swapInfo:q(v({},e),{poolInfo:[...e.poolInfoList],poolKey:h,outputMint:f}),ownerInfo:{wallet:this.scope.ownerPubKey,sourceToken:y,routeToken:A,destinationToken:g}});if(e.feeConfig!==void 0){let T=this.createTxBuilder();T.addInstruction({instructions:[Ll(y,e.feeConfig.feeAccount,this.scope.ownerPubKey,e.feeConfig.feeAmount.toNumber())],instructionTypes:[U.TransferAmount]}),T.addInstruction(I);let{transactions:w}=i===0?await T.sizeCheckBuildV0():await T.sizeCheckBuild();w.length<2&&u.addInstruction({instructions:[Ll(y,e.feeConfig.feeAccount,this.scope.ownerPubKey,e.feeConfig.feeAmount.toNumber())],instructionTypes:[U.TransferAmount]})}return u.addInstruction(I),i===0?u.sizeCheckBuildV0({computeBudgetConfig:o,address:I.address}):u.sizeCheckBuild({computeBudgetConfig:o,address:I.address})}async fetchRoutePoolBasicInfo(e){let{amm:t=Ho,clmm:n=Rn,cpmm:o=$o}=e||{},s=await this.scope.connection.getProgramAccounts(t,{dataSlice:{offset:no.offsetOf("baseMint"),length:64}}),i=V([N("baseMint"),N("quoteMint")]),r=s.map(d=>({id:d.pubkey,version:4,mintA:i.decode(d.account.data).baseMint,mintB:i.decode(d.account.data).quoteMint})),u=V([N("mintA"),N("mintB")]),l=(await this.scope.connection.getProgramAccounts(n,{filters:[{dataSize:eo.span}],dataSlice:{offset:eo.offsetOf("mintA"),length:64}})).map(d=>{let f=u.decode(d.account.data);return{id:d.pubkey,version:6,mintA:f.mintA,mintB:f.mintB}}),p=(await this.scope.connection.getProgramAccounts(o,{dataSlice:{offset:Qr.offsetOf("mintA"),length:64}})).map(d=>{let f=u.decode(d.account.data);return{id:d.pubkey,version:7,mintA:f.mintA,mintB:f.mintB}});return{clmmPools:l,ammPools:r,cpmmPools:p}}getAllRoute({inputMint:e,outputMint:t,clmmPools:n,ammPools:o,cpmmPools:s}){e=e.toString()===lo.default.toString()?Z:e,t=t.toString()===lo.default.toString()?Z:t;let i={},r={},u={},a=[],l={};for(let p of n!=null?n:[]){if((p.mintA.equals(e)&&p.mintB.equals(t)||p.mintA.equals(t)&&p.mintB.equals(e))&&(a.push(p),r[p.id.toString()]=p),p.mintA.equals(e)){let d=p.mintB.toString();l[d]===void 0&&(l[d]={mintProgram:He,in:[],out:[],mDecimals:0}),l[d].in.push(p)}if(p.mintB.equals(e)){let d=p.mintA.toString();l[d]===void 0&&(l[d]={mintProgram:He,in:[],out:[],mDecimals:0}),l[d].in.push(p)}if(p.mintA.equals(t)){let d=p.mintB.toString();l[d]===void 0&&(l[d]={mintProgram:He,in:[],out:[],mDecimals:0}),l[d].out.push(p)}if(p.mintB.equals(t)){let d=p.mintA.toString();l[d]===void 0&&(l[d]={mintProgram:He,in:[],out:[],mDecimals:0}),l[d].out.push(p)}}let m=[];for(let p of o)(p.mintA.equals(e)&&p.mintB.equals(t)||p.mintA.equals(t)&&p.mintB.equals(e))&&(a.push(p),i[p.id.toBase58()]=p,m.push(p)),p.mintA.equals(e)&&(l[p.mintB.toBase58()]===void 0&&(l[p.mintB.toBase58()]={mintProgram:He,in:[],out:[],mDecimals:0}),l[p.mintB.toBase58()].in.push(p)),p.mintB.equals(e)&&(l[p.mintA.toBase58()]===void 0&&(l[p.mintA.toBase58()]={mintProgram:He,in:[],out:[],mDecimals:0}),l[p.mintA.toBase58()].in.push(p)),p.mintA.equals(t)&&(l[p.mintB.toBase58()]===void 0&&(l[p.mintB.toBase58()]={mintProgram:He,in:[],out:[],mDecimals:0}),l[p.mintB.toBase58()].out.push(p)),p.mintB.equals(t)&&(l[p.mintA.toBase58()]===void 0&&(l[p.mintA.toBase58()]={mintProgram:He,in:[],out:[],mDecimals:0}),l[p.mintA.toBase58()].out.push(p));for(let p of s)(p.mintA.equals(e)&&p.mintB.equals(t)||p.mintA.equals(t)&&p.mintB.equals(e))&&(a.push(p),u[p.id.toBase58()]=p),p.mintA.equals(e)&&(l[p.mintB.toBase58()]===void 0&&(l[p.mintB.toBase58()]={mintProgram:He,in:[],out:[],mDecimals:0}),l[p.mintB.toBase58()].in.push(p)),p.mintB.equals(e)&&(l[p.mintA.toBase58()]===void 0&&(l[p.mintA.toBase58()]={mintProgram:He,in:[],out:[],mDecimals:0}),l[p.mintA.toBase58()].in.push(p)),p.mintA.equals(t)&&(l[p.mintB.toBase58()]===void 0&&(l[p.mintB.toBase58()]={mintProgram:He,in:[],out:[],mDecimals:0}),l[p.mintB.toBase58()].out.push(p)),p.mintB.equals(t)&&(l[p.mintA.toBase58()]===void 0&&(l[p.mintA.toBase58()]={mintProgram:He,in:[],out:[],mDecimals:0}),l[p.mintA.toBase58()].out.push(p));for(let p of Object.keys(l)){if(l[p].in.length===1&&l[p].out.length===1&&l[p].in[0].id.equals(l[p].out[0].id)){delete l[p];continue}if(l[p].in.length===0||l[p].out.length===0){delete l[p];continue}let d=l[p];for(let f of d.in)for(let y of d.out)f.version===6&&r[f.id.toString()]===void 0?r[f.id.toString()]=f:f.version===7&&u[f.id.toString()]===void 0?u[f.id.toString()]=f:(f.version===4||f.version===5)&&i[f.id.toString()]===void 0&&(i[f.id.toString()]=f),y.version===6&&r[y.id.toString()]===void 0?r[y.id.toString()]=y:y.version===7&&u[y.id.toString()]===void 0?u[y.id.toString()]=y:(y.version===4||y.version===5)&&i[y.id.toString()]===void 0&&(i[y.id.toString()]=y)}return{directPath:a,addLiquidityPools:m,routePathDict:l,needSimulate:Object.values(i),needTickArray:Object.values(r),cpmmPoolList:Object.values(u)}}async fetchSwapRoutesData({routes:e,inputMint:t,outputMint:n}){let o=new Set([...e.needTickArray.map(y=>[y.mintA.toBase58(),y.mintB.toBase58()]).flat(),t.toString(),n.toString()]);console.log("fetching amm pools info, total: ",e.needSimulate.length);let s=await this.scope.liquidity.getRpcPoolInfos(e.needSimulate.map(y=>y.id)),i=_r(s),r={};Object.values(i).forEach(y=>{o.delete(y.mintA.address),r[y.mintA.address]={address:new lo(y.mintA.address),programId:He,mintAuthority:null,supply:BigInt(0),decimals:y.mintA.decimals,isInitialized:!0,freezeAuthority:null,tlvData:Buffer.from("0","hex"),feeConfig:void 0},o.delete(y.mintB.address),r[y.mintB.address]={address:new lo(y.mintB.address),programId:He,mintAuthority:null,supply:BigInt(0),decimals:y.mintB.decimals,isInitialized:!0,freezeAuthority:null,tlvData:Buffer.from("0","hex"),feeConfig:void 0}}),console.log("fetching cpmm pools info, total: ",e.cpmmPoolList.length);let u=await this.scope.cpmm.getRpcPoolInfos(e.cpmmPoolList.map(y=>y.id.toBase58()),!0);Object.values(u).forEach(y=>{let[b,g]=[y.mintA.toBase58(),y.mintB.toBase58()];y.mintProgramA.equals(He)?(o.delete(b),r[b]={address:y.mintA,programId:y.mintProgramA,mintAuthority:null,supply:BigInt(0),decimals:y.mintDecimalA,isInitialized:!0,freezeAuthority:null,tlvData:Buffer.from("0","hex"),feeConfig:void 0}):o.add(b),y.mintProgramB.equals(He)?(o.delete(g),r[g]={address:y.mintB,programId:y.mintProgramB,mintAuthority:null,supply:BigInt(0),decimals:y.mintDecimalB,isInitialized:!0,freezeAuthority:null,tlvData:Buffer.from("0","hex"),feeConfig:void 0}):o.add(g)}),console.log("fetching mints info, total: ",o.size);let a=await Ao({connection:this.scope.connection,mints:Array.from(o).map(y=>new lo(y))});r=v(v({},r),a);let l=this.scope.cpmm.toComputePoolInfos({pools:u,mintInfos:r});console.log("fetching clmm pools info, total:",e.needTickArray.length);let m=await this.scope.clmm.getRpcClmmPoolInfos({poolIds:e.needTickArray.map(y=>y.id)}),{computeClmmPoolInfo:p,computePoolTickData:d}=await this.scope.clmm.getComputeClmmPoolInfos({clmmPoolsRpcInfo:m,mintInfos:r}),f=Object.keys(e.routePathDict).reduce((y,b)=>q(v({},y),{[b]:q(v({},e.routePathDict[b]),{mintProgram:r[b].programId,mDecimals:r[b].decimals,in:e.routePathDict[b].in.map(g=>i[g.id.toBase58()]||p[g.id.toBase58()]||l[g.id.toBase58()]),out:e.routePathDict[b].out.map(g=>i[g.id.toBase58()]||p[g.id.toBase58()]||l[g.id.toBase58()])})}),{});return{mintInfos:r,ammPoolsRpcInfo:s,ammSimulateCache:i,clmmPoolsRpcInfo:m,computeClmmPoolInfo:p,computePoolTickData:d,computeCpmmData:l,routePathDict:f}}getAllRouteComputeAmountOut({inputTokenAmount:e,outputToken:t,directPath:n,routePathDict:o,simulateCache:s,tickCache:i,slippage:r,chainTime:u,epochInfo:a,feeConfig:l}){var g,A,h,I,T,w,S,x,K;let m=l===void 0?new $r(0):e.raw.mul(new $r(l.feeBps.toNumber())).div(new $r(1e4)),p=e.raw.sub(m),d=new xe(e.token,p),f=l===void 0?void 0:{feeAmount:m,feeAccount:l.feeAccount},y=q(v({},t),{address:dt(t.address).toString()}),b=[];for(let B of n)try{b.push(q(v({},this.computeAmountOut({itemPool:B,tickCache:i,simulateCache:s,chainTime:u,epochInfo:a,slippage:r,outputToken:y,amountIn:d})),{feeConfig:f}))}catch(C){this.logDebug("direct error",B.version,B.id.toString(),C.message)}this.logDebug("direct done");for(let[B,C]of Object.entries(o)){let O={chainId:101,address:B,programId:C.mintProgram.toBase58(),logoURI:"",symbol:"",name:"",decimals:C.mDecimals,tags:[],extensions:{}},M=C.in.map(R=>{try{return{pool:R,data:this.computeAmountOut({itemPool:R,tickCache:i,simulateCache:s,chainTime:u,epochInfo:a,slippage:r,outputToken:O,amountIn:d})}}catch(_){this.logDebug("route in error",R.version,R.id.toString(),_.message);return}}).sort((R,_)=>{var ae,ue,ie,me;let X=R===void 0?Sn:R.data.amountOut.amount.raw.sub((ue=(ae=R.data.amountOut.fee)==null?void 0:ae.raw)!=null?ue:Sn),j=_===void 0?Sn:_.data.amountOut.amount.raw.sub((me=(ie=_.data.amountOut.fee)==null?void 0:ie.raw)!=null?me:Sn);return X.lt(j)?1:-1})[0];if(M===void 0)continue;let L=new xe(Nr(O),M.data.amountOut.amount.raw.sub((A=(g=M.data.amountOut.fee)==null?void 0:g.raw)!=null?A:Sn));for(let R of C.out)try{let _=this.computeAmountOut({itemPool:R,tickCache:i,simulateCache:s,chainTime:u,epochInfo:a,slippage:r,outputToken:y,amountIn:L});b.push(q(v({},_),{allTrade:!!(M.data.allTrade&&_.allTrade),amountIn:M.data.amountIn,amountOut:_.amountOut,minAmountOut:_.minAmountOut,currentPrice:void 0,executionPrice:new Di(new Tt({baseToken:M.data.amountIn.amount.token,denominator:M.data.amountIn.amount.raw,quoteToken:_.amountOut.amount.token,numerator:_.amountOut.amount.raw.sub((I=(h=_.amountOut.fee)==null?void 0:h.raw)!=null?I:Sn)}).toFixed()),priceImpact:new Di(M.data.priceImpact.add(_.priceImpact).toFixed()),fee:[M.data.fee[0],_.fee[0]],routeType:"route",poolInfoList:[M.pool,R],remainingAccounts:[M.data.remainingAccounts[0],_.remainingAccounts[0]],minMiddleAmountFee:(T=_.amountOut.fee)!=null&&T.raw?new xe(M.data.amountOut.amount.token,((S=(w=M.data.amountOut.fee)==null?void 0:w.raw)!=null?S:Sn).add((K=(x=_.amountOut.fee)==null?void 0:x.raw)!=null?K:Sn)):void 0,middleToken:M.data.amountOut.amount.token,poolReady:M.data.poolReady&&_.poolReady,poolType:[M.data.poolType,_.poolType],feeConfig:f,expirationTime:Jt(M.data.expirationTime,_.expirationTime)}))}catch(_){this.logDebug("route out error",R.version,R.id.toString(),_.message)}}return b.filter(B=>(B.allTrade||this.logDebug(`pool ${B.poolInfoList.map(C=>C.id.toString()).join(",")} filter out since not all trade`),B.allTrade)).sort((B,C)=>B.amountOut.amount.raw.sub(C.amountOut.amount.raw).gt(Sn)?-1:1)}computeAmountOut({itemPool:e,tickCache:t,simulateCache:n,chainTime:o,epochInfo:s,slippage:i,outputToken:r,amountIn:u}){if(e.version===6){let{allTrade:a,realAmountIn:l,amountOut:m,minAmountOut:p,expirationTime:d,currentPrice:f,executionPrice:y,priceImpact:b,fee:g,remainingAccounts:A,executionPriceX64:h}=Oe.computeAmountOutFormat({poolInfo:e,tickArrayCache:t[e.id.toString()],amountIn:u.raw,tokenOut:r,slippage:i,epochInfo:s,catchLiquidityInsufficient:!0});return{allTrade:a,amountIn:l,amountOut:m,minAmountOut:p,currentPrice:new Di(f.toFixed()),executionPrice:new Di(y.toFixed()),priceImpact:new Di(b.toFixed()),fee:[g],remainingAccounts:[A],routeType:"amm",poolInfoList:[e],poolReady:e.startTime<o,poolType:"CLMM",slippage:i,clmmExPriceX64:[h],expirationTime:Jt(l.expirationTime,d)}}else if(e.version===7){let{allTrade:a,executionPrice:l,amountOut:m,minAmountOut:p,priceImpact:d,fee:f}=this.scope.cpmm.computeSwapAmount({pool:e,outputMint:r.address,amountIn:u.raw,slippage:i});return{allTrade:a,amountIn:{amount:u,fee:void 0,expirationTime:void 0},amountOut:{amount:Bi(q(v({},r),{amount:m})),fee:void 0,expirationTime:void 0},minAmountOut:{amount:Bi(q(v({},r),{amount:p})),fee:void 0,expirationTime:void 0},currentPrice:e.poolPrice,executionPrice:l,priceImpact:d,fee:[new xe(u.token,f)],remainingAccounts:[],routeType:"amm",poolInfoList:[e],poolReady:e.openTime.toNumber()<o,poolType:"CPMM",slippage:i,clmmExPriceX64:[void 0],expirationTime:void 0}}else{if(![1,6,7].includes(n[e.id.toString()].status))throw Error("swap error");let{amountOut:a,minAmountOut:l,currentPrice:m,executionPrice:p,priceImpact:d,fee:f}=this.scope.liquidity.computeAmountOut({poolInfo:n[e.id.toString()],amountIn:u.raw,mintIn:u.token.mint,mintOut:r.address,slippage:i});return{amountIn:{amount:u,fee:void 0,expirationTime:void 0},amountOut:{amount:Bi(q(v({},r),{amount:a})),fee:void 0,expirationTime:void 0},minAmountOut:{amount:Bi(q(v({},r),{amount:l})),fee:void 0,expirationTime:void 0},currentPrice:m,executionPrice:p,priceImpact:d,fee:[new xe(u.token,f)],routeType:"amm",poolInfoList:[e],remainingAccounts:[],poolReady:Number(n[e.id].openTime)<o,poolType:e.version===5?"STABLE":void 0,expirationTime:void 0,allTrade:!0,slippage:i,clmmExPriceX64:[void 0]}}}async computePoolToPoolKeys({pools:e,clmmRpcData:t={},ammRpcData:n={}}){let o=new Set(e.filter(a=>a.version===6&&!t[a.id.toString()]).map(a=>a.id.toString()));if(o.size>0){let a=await this.scope.clmm.getRpcClmmPoolInfos({poolIds:Array.from(o)});Object.keys(a).forEach(l=>{t[l]=a[l]})}let s=new Set(e.filter(a=>a.version===4&&!n[a.id.toString()]).map(a=>a.id.toString()));if(s.size>0){let a=await this.scope.liquidity.getRpcPoolInfos(Array.from(s));Object.keys(a).forEach(l=>{n[l]=a[l]})}let i=new Set(e.filter(a=>a.version===4).map(a=>a.marketId)),r={};i.size>0&&(await Le(this.scope.connection,Array.from(i).map(l=>({pubkey:new lo(l)})))).forEach(l=>{if(!l.accountInfo)return;let m=Ua.decode(l.accountInfo.data);r[l.pubkey.toBase58()]={marketId:l.pubkey.toString(),marketProgramId:l.accountInfo.owner.toString(),marketAuthority:Hr.getAssociatedAuthority({programId:l.accountInfo.owner,marketId:l.pubkey}).publicKey.toString(),marketBaseVault:m.baseVault.toString(),marketQuoteVault:m.quoteVault.toString(),marketBids:m.bids.toString(),marketAsks:m.asks.toString(),marketEventQueue:m.eventQueue.toString()}});let u=[];return e.forEach(a=>{if(a.version===6){let l=t[a.id.toString()],m={programId:a.programId.toBase58(),id:a.id.toBase58(),mintA:a.mintA,mintB:a.mintB,openTime:String(a.startTime),vault:{A:l.vaultA.toBase58(),B:l.vaultB.toBase58()},config:q(v({},a.ammConfig),{id:a.ammConfig.id.toString(),defaultRange:0,defaultRangePoint:[]}),rewardInfos:[],observationId:a.observationId.toBase58(),exBitmapAccount:a.exBitmapAccount.toBase58()};u.push(m)}else if(a.version===4){let l=n[a.id.toString()],m=v({programId:a.programId,id:a.id,mintA:a.mintA,mintB:a.mintB,openTime:String(a.openTime),vault:{A:l.baseVault.toBase58(),B:l.quoteVault.toBase58()},authority:Fa({programId:new lo(a.programId)}).publicKey.toString(),openOrders:l.openOrders.toBase58(),targetOrders:l.targetOrders.toBase58(),mintLp:a.lpMint},r[a.marketId]);u.push(m)}else a.version===7&&u.push({observationId:a.observationId.toBase58(),programId:a.programId.toBase58(),id:a.id.toBase58(),mintA:a.mintA,mintB:a.mintB,openTime:String(a.openTime),authority:Fo(a.programId).publicKey.toBase58(),vault:{A:a.vaultA.toBase58(),B:a.vaultB.toBase58()},mintLp:yt({address:a.mintLp.toBase58(),programId:He.toBase58(),decimals:a.lpDecimals}),config:q(v({id:a.configId.toBase58()},a.configInfo),{protocolFeeRate:a.configInfo.protocolFeeRate.toNumber(),tradeFeeRate:a.configInfo.tradeFeeRate.toNumber(),fundFeeRate:a.configInfo.fundFeeRate.toNumber(),createPoolFee:a.configInfo.createPoolFee.toString()})})}),u}};import{PublicKey as Zp,Transaction as Qa,TransactionInstruction as $p}from"@solana/web3.js";import{TOKEN_PROGRAM_ID as Jp}from"@solana/spl-token";import Ol from"bn.js";var bt=class extends Fe{static getPdaPoolId(e,t){return ne([bt.SEED_CONFIG.pool.id,t.toBuffer()],e)}static getPdaOwnerId(e,t,n,o){return ne([bt.SEED_CONFIG.owner.id,t.toBuffer(),n.toBuffer(),Buffer.from(new Ol(o).toArray())],e)}static async getAllInfo({connection:e,programId:t,poolIds:n,wallet:o,chainTime:s}){if(n.length===0)return[];let i=n.map(l=>bt.getPdaPoolId(t,l).publicKey),r=[];for(let l=0;l<bt.VERSION_PROJECT.length;l++)r.push(...i.map(m=>bt.getPdaOwnerId(t,m,o,l).publicKey));let u=await Ht(e,[...i,...r]),a=[];for(let l=0;l<u.length;l++){let m=Math.floor(l/n.length),p=l%n.length,d=i[p],f=r[l],y=u[p],b=u[n.length+l];if(!(y&&b)||y.data.length!==bt.POOL_LAYOUT.span||b.data.length!==bt.OWNER_LAYOUT.span)continue;let g=bt.POOL_LAYOUT.decode(y.data),A=bt.OWNER_LAYOUT.decode(b.data),h=g.openTime.toNumber(),I=g.endTime.toNumber(),T=A.tokenInfo.map(x=>x.debtAmount.gt(new Ol(0))).filter(x=>!x).length!==3,w=s>h&&s<I&&g.status===1,S=T&&w;a.push({programId:t,poolId:d,ammId:g.ammId,ownerAccountId:f,snapshotLpAmount:A.lpAmount,project:bt.VERSION_PROJECT[m],openTime:h,endTime:I,canClaim:S,canClaimErrorType:T?w?void 0:"outOfOperationalTime":"alreadyClaimIt",tokenInfo:g.tokenInfo.map((x,K)=>({mintAddress:x.mintAddress,mintVault:x.mintVault,mintDecimals:x.mintDecimals,perLpLoss:x.perLpLoss,debtAmount:A.tokenInfo[K].debtAmount.add(A.tokenInfo[K].claimedAmount)}))})}return a}async makeClaimTransaction({poolInfo:e,ownerInfo:t,feePayer:n}){t.wallet||this.scope.checkOwner();let o=this.createTxBuilder(n),s=t.wallet||this.scope.ownerPubKey,i=[];for(let a of e.tokenInfo){let{account:l,instructionParams:m}=await this.scope.account.getOrCreateTokenAccount({mint:a.mintAddress,owner:this.scope.ownerPubKey,notUseTokenAccount:a.mintAddress.equals(We.WSOL.mint),createInfo:{payer:s,amount:0},skipCloseAccount:!a.mintAddress.equals(We.WSOL.mint),associatedOnly:a.mintAddress.equals(We.WSOL.mint)?!1:t.associatedOnly});m&&o.addInstruction(m),i.push(l)}o.addInstruction({instructions:[bt.makeClaimInstruction({programId:e.programId,poolInfo:e,ownerInfo:{wallet:s,ownerPda:e.ownerAccountId,claimAddress:i}})]});let{transaction:r,signers:u}=o.build();return[{transaction:r,signer:u}]}async makeClaimAllTransaction({poolInfos:e,ownerInfo:t,feePayer:n}){let o=this.createTxBuilder(n),s=t.wallet||this.scope.ownerPubKey,i={};for(let l of e){let m=[];for(let p of l.tokenInfo){let{account:d,instructionParams:f}=await this.scope.account.getOrCreateTokenAccount({mint:p.mintAddress,owner:this.scope.ownerPubKey,notUseTokenAccount:p.mintAddress.equals(We.WSOL.mint),createInfo:{payer:s,amount:0},skipCloseAccount:!p.mintAddress.equals(We.WSOL.mint),associatedOnly:p.mintAddress.equals(We.WSOL.mint)?!1:t.associatedOnly});f&&o.addInstruction(f),d&&(i[p.mintAddress.toString()]=d,m.push(d))}o.addInstruction({instructions:[bt.makeClaimInstruction({programId:l.programId,poolInfo:l,ownerInfo:{wallet:s,ownerPda:l.ownerAccountId,claimAddress:m}})]})}let{transaction:r,signers:u}=o.build(),a=o.allInstructions;return cr(a,[s,...u.map(l=>l.publicKey)])?[{transaction:r,signer:u}]:[{transaction:new Qa().add(...a.slice(0,o.AllTxData.instructions.length-1)),signer:u},{transaction:new Qa().add(...a.slice(o.AllTxData.instructions.length-1)),signer:[]},{transaction:new Qa().add(...o.AllTxData.endInstructions),signer:[]}]}static makeClaimInstruction({programId:e,poolInfo:t,ownerInfo:n}){let o=V([]),s=[{pubkey:n.wallet,isSigner:!0,isWritable:!0},{pubkey:t.poolId,isSigner:!1,isWritable:!0},{pubkey:n.ownerPda,isSigner:!1,isWritable:!0},...n.claimAddress.map(u=>({pubkey:u,isSigner:!1,isWritable:!0})),...t.tokenInfo.map(({mintVault:u})=>({pubkey:u,isSigner:!1,isWritable:!0})),{pubkey:Jp,isSigner:!1,isWritable:!1}],i=Buffer.alloc(o.span);o.encode({},i);let r=Buffer.from([10,66,208,184,161,6,191,98,...i]);return new $p({keys:s,programId:e,data:r})}},Gt=bt;Gt.CLAIMED_NUM=3,Gt.POOL_LAYOUT=V([he(8),E("bump"),E("status"),k("openTime"),k("endTime"),N("ammId"),Y(V([E("mintDecimals"),N("mintAddress"),N("mintVault"),k("perLpLoss"),k("totalClaimedAmount")]),bt.CLAIMED_NUM,"tokenInfo"),Y(k(),10,"padding")]),Gt.OWNER_LAYOUT=V([he(8),E("bump"),E("version"),N("poolId"),N("owner"),k("lpAmount"),Y(V([N("mintAddress"),k("debtAmount"),k("claimedAmount")]),bt.CLAIMED_NUM,"tokenInfo"),Y(k(),4,"padding")]),Gt.DEFAULT_POOL_ID=["58oQChx4yWmvKdwLLZzBi4ChoCc2fqCUWBkwMihLYQo2","6UmmUiYoBjSrhakAobJw8BvkmJtDVxaeBtbt7rxWo1mg","AVs9TA4nWDzfPJE9gGVNJMVhcQy3V9PGazuz33BfG2RA","DVa7Qmb5ct9RCpaU7UTpSaf3GVMYz17vNVU67XpdCRut","7XawhbbxtsRcQA8KTkHT9f9nc6d69UwqCDh6U5EEbEmX","6a1CsrpeZubDjEJE9s1CMVheB6HWM5d7m1cj2jkhyXhj","EoNrn8iUhwgJySD1pHu8Qxm5gSQqLK3za4m8xzD2RuEb","AceAyRTWt4PyB2pHqf2qhDgNZDtKVNaxgL8Ru3V4aN1P","6tmFJbMk5yVHFcFy7X2K8RwHjKLr6KVFLYXpgpBNeAxB"].map(e=>new Zp(e)),Gt.SEED_CONFIG={pool:{id:Buffer.from("pool_seed","utf8")},owner:{id:Buffer.from("user_claim_seed","utf8")}},Gt.VERSION_PROJECT=[void 0,"Francium","Tulip","Larix"];import{PublicKey as Ui}from"@solana/web3.js";import Nl from"bn.js";import{SYSVAR_CLOCK_PUBKEY as ef,TransactionInstruction as ja}from"@solana/web3.js";import{TOKEN_PROGRAM_ID as Ha}from"@solana/spl-token";var Ya=V([E("instruction"),Zu("amount")]),qi=V([E("instruction")]);function RK({programId:c,amount:e,instructionKeys:t}){let n=[{pubkey:ir,isSigner:!1,isWritable:!1},{pubkey:Ha,isSigner:!1,isWritable:!1},{pubkey:$e,isSigner:!1,isWritable:!1},{pubkey:ws,isSigner:!1,isWritable:!1},...Object.entries(t).map(([s,i])=>({pubkey:i,isSigner:s==="userOwner",isWritable:!["authority","userOwner","userIdoCheck","userStakeInfo"].includes(s)}))],o=Buffer.alloc(Ya.span);return Ya.encode({instruction:1,amount:Number(e)},o),new ja({keys:n,programId:c,data:o})}function Jr({programId:c},e){let t=[{pubkey:Ha,isSigner:!1,isWritable:!1},{pubkey:ws,isSigner:!1,isWritable:!1},...Object.entries(e).map(([o,s])=>({pubkey:s,isSigner:o==="userOwner",isWritable:!["authority","userOwner"].includes(o)}))],n=Buffer.alloc(qi.span);return qi.encode({instruction:2},n),new ja({keys:t,programId:c,data:n})}function Za(c){let{poolConfig:e,userKeys:t,side:n}=c,o=n==="base"?t.baseTokenAccount:t.quoteTokenAccount,s=n==="base"?e.baseVault:e.quoteVault,i=Buffer.alloc(qi.span);qi.encode({instruction:2},i);let r=[{pubkey:Ha,isWritable:!1,isSigner:!1},{pubkey:ef,isWritable:!1,isSigner:!1},{pubkey:e.id,isWritable:!0,isSigner:!1},{pubkey:e.authority,isWritable:!1,isSigner:!1},{pubkey:s,isWritable:!0,isSigner:!1},{pubkey:o,isWritable:!0,isSigner:!1},{pubkey:t.ledgerAccount,isWritable:!0,isSigner:!1},{pubkey:t.owner,isWritable:!1,isSigner:!0}];return new ja({programId:e.programId,keys:r,data:i})}var tf={[ti.IDO_PROGRAM_ID_V1.toString()]:1,[ti.IDO_PROGRAM_ID_V2.toString()]:2,[ti.IDO_PROGRAM_ID_V3.toString()]:3,[ti.IDO_PROGRAM_ID_V4.toString()]:4},Vo=class extends Fe{async claim({ownerInfo:e,idoKeys:t,associatedOnly:n=!0,checkCreateATAOwner:o=!1,txVersion:s,feePayer:i}){let r=this.createTxBuilder(i),u=tf[t.programId];u||this.logAndCreateError("invalid version",u);let a=Me(t),[l,m]=[!new Nl(e.coin).isZero(),!new Nl(e.pc).isZero()],p=a.projectInfo.mint.address.equals(Z),{account:d,instructionParams:f}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:a.projectInfo.mint.programId,mint:a.projectInfo.mint.address,owner:this.scope.ownerPubKey,createInfo:{payer:this.scope.ownerPubKey,amount:0},skipCloseAccount:!p,notUseTokenAccount:p,associatedOnly:p?!1:n,checkCreateATAOwner:o});!d&&l&&this.logAndCreateError("target token accounts not found","mint",t.projectInfo.mint.address),l&&f&&r.addInstruction(f);let y=a.buyInfo.mint.address.equals(Z),{account:b,instructionParams:g}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:a.buyInfo.mint.programId,mint:a.buyInfo.mint.address,owner:this.scope.ownerPubKey,createInfo:{payer:this.scope.ownerPubKey,amount:0},skipCloseAccount:!y,notUseTokenAccount:y,associatedOnly:y?!1:n,checkCreateATAOwner:o});if(!d&&m&&this.logAndCreateError("target token accounts not found","mint",t.projectInfo.mint.address),m&&g&&r.addInstruction(g),(!d||!b)&&this.logAndCreateError("target token accounts not found","mint",t.projectInfo.mint.address,t.buyInfo.mint.address),u===3)return r.addInstruction({instructions:[...l?[Jr({programId:a.programId},{idoId:a.id,authority:a.authority,poolTokenAccount:a.projectInfo.vault,userTokenAccount:d,userIdoInfo:new Ui(e.userIdoInfo),userOwner:this.scope.ownerPubKey})]:[],...m?[Jr({programId:new Ui(t.programId)},{idoId:a.id,authority:a.authority,poolTokenAccount:a.buyInfo.vault,userTokenAccount:b,userIdoInfo:new Ui(e.userIdoInfo),userOwner:this.scope.ownerPubKey})]:[]]}).versionBuild({txVersion:s});if(u<3)return!l&&!m&&this.logAndCreateError("no claimable rewards"),r.addInstruction({instructions:[Jr({programId:a.programId},{idoId:a.id,authority:a.authority,poolQuoteTokenAccount:a.buyInfo.vault,poolBaseTokenAccount:a.projectInfo.vault,userQuoteTokenAccount:b,userBaseTokenAccount:d,userIdoInfo:new Ui(e.userIdoInfo),userOwner:this.scope.ownerPubKey})]}).versionBuild({txVersion:s});let A={poolConfig:{id:a.id,programId:a.programId,authority:a.authority,baseVault:a.projectInfo.vault,quoteVault:a.buyInfo.vault,baseToken:t.projectInfo.mint,quoteToken:t.buyInfo.mint},userKeys:{baseTokenAccount:d,quoteTokenAccount:b,ledgerAccount:new Ui(e.userIdoInfo),owner:this.scope.ownerPubKey}};return r.addInstruction({instructions:[...l?[Za(q(v({},A),{side:"base"}))]:[],...m?[Za(q(v({},A),{side:"quote"}))]:[]]}).versionBuild({txVersion:s})}};var nf=Buffer.from("vault_auth_seed","utf8"),of=Buffer.from("global_config","utf8"),rf=Buffer.from("pool_vesting","utf8"),sf=Buffer.from("platform_config","utf8"),af=Buffer.from("platform_fee_vault_auth_seed","utf8"),uf=Buffer.from("creator_fee_vault_auth_seed","utf8");function fn(c){return ne([nf],c)}function jK(c,e,t,n){return ne([of,e.toBuffer(),cf(t),Rr(n)],c)}function _o(c,e,t){return ne([ya,e.toBuffer(),t.toBuffer()],c)}function $a(c,e,t){return ne([ba,e.toBuffer(),t.toBuffer()],c)}function mo(c){return ne([Buffer.from("__event_authority","utf8")],c)}function cf(c){let e=new ArrayBuffer(1);return new DataView(e).setUint8(0,c),new Uint8Array(e)}function Ja(c,e){return ne([sf,e.toBuffer()],c)}function Gi(c,e,t){return ne([rf,e.toBuffer(),t.toBuffer()],c)}function po(c,e,t){return ne([e.toBuffer(),t.toBuffer()],c)}function eu(c){return ne([af],c)}function Eo(c,e,t){return ne([e.toBuffer(),t.toBuffer()],c)}function Ml(c){return ne([uf],c)}import{SystemProgram as Xt,TransactionInstruction as vt}from"@solana/web3.js";import{ASSOCIATED_TOKEN_PROGRAM_ID as es,TOKEN_2022_PROGRAM_ID as lf,TOKEN_PROGRAM_ID as tu}from"@solana/spl-token";import Xi from"bn.js";var Ft={initialize:Buffer.from([175,175,109,31,13,152,155,237]),buyExactIn:Buffer.from([250,234,13,123,213,156,19,236]),buyExactOut:Buffer.from([24,211,116,40,105,3,153,56]),sellExactIn:Buffer.from([149,39,222,155,211,124,152,26]),sellExactOut:Buffer.from([95,200,71,34,8,9,11,166]),createVestingAccount:Buffer.from([129,178,2,13,217,172,230,218]),claimVestedToken:Buffer.from([49,33,104,30,189,157,79,35]),createPlatformConfig:Buffer.from([176,90,196,175,253,113,220,20]),claimPlatformFee:Buffer.from([156,39,208,135,76,237,61,72]),updatePlaformConfig:Buffer.from([195,60,76,129,146,45,67,143]),initializeWithToken2022:Buffer.from([37,190,126,222,44,154,171,17]),claimPlatformFeeFromVault:Buffer.from([117,241,198,168,248,218,80,29]),claimCreatorFee:Buffer.from([26,97,138,203,132,171,141,252])};function vl(c,e,t,n,o,s,i,r,u,a,l,m,p,d,f,y,b,g,A,h){let I=V([E("decimals"),It("name"),It("symbol"),It("uri")]),T=V([k("totalLockedAmount"),k("cliffPeriod"),k("unlockPeriod")]),w=V([E("index"),k("supply"),k("totalFundRaisingB"),E("migrateType")]),S=V([E("index"),k("supply"),k("totalSellA"),k("totalFundRaisingB"),E("migrateType")]),x=[{pubkey:e,isSigner:!0,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:s,isSigner:!1,isWritable:!1},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!0,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!1},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:m,isSigner:!1,isWritable:!0},{pubkey:tu,isSigner:!1,isWritable:!1},{pubkey:tu,isSigner:!1,isWritable:!1},{pubkey:Zt,isSigner:!1,isWritable:!1},{pubkey:Xt.programId,isSigner:!1,isWritable:!1},{pubkey:$e,isSigner:!1,isWritable:!1},{pubkey:mo(c).publicKey,isSigner:!1,isWritable:!1},{pubkey:c,isSigner:!1,isWritable:!1}],K=Buffer.alloc(Buffer.from(d,"utf-8").length+Buffer.from(f,"utf-8").length+Buffer.from(y,"utf-8").length+4*3+1),B=Buffer.alloc(T.span),C=Buffer.alloc(b.type==="ConstantCurve"?S.span:w.span);return I.encode({decimals:p,name:d,symbol:f,uri:y},K),b.type==="ConstantCurve"?S.encode(q(v({index:0},b),{migrateType:b.migrateType==="amm"?0:1}),C):b.type==="FixedCurve"?w.encode(q(v({index:1},b),{migrateType:b.migrateType==="amm"?0:1}),C):b.type==="LinearCurve"&&w.encode(q(v({index:2},b),{migrateType:b.migrateType==="amm"?0:1}),C),T.encode({totalLockedAmount:g,cliffPeriod:A,unlockPeriod:h},B),new vt({keys:x,programId:c,data:Buffer.from([...Ft.initialize,...K,...C,...B])})}function Fl(c,e,t,n,o,s,i,r,u,a,l,m,p,d,f,y,b,g,A,h){let I=V([E("decimals"),It("name"),It("symbol"),It("uri")]),T=V([k("totalLockedAmount"),k("cliffPeriod"),k("unlockPeriod"),E("transferFeeExtensionParamsOption"),V([Rt("transferFeeBasePoints"),k("maxinumFee")]).replicate("transferFeeExtensionParams")]),w=V([E("index"),k("supply"),k("totalFundRaisingB"),E("migrateType")]),S=V([E("index"),k("supply"),k("totalSellA"),k("totalFundRaisingB"),E("migrateType")]),x=[{pubkey:e,isSigner:!0,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:s,isSigner:!1,isWritable:!1},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!0,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!1},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:lf,isSigner:!1,isWritable:!1},{pubkey:tu,isSigner:!1,isWritable:!1},{pubkey:Xt.programId,isSigner:!1,isWritable:!1},{pubkey:mo(c).publicKey,isSigner:!1,isWritable:!1},{pubkey:c,isSigner:!1,isWritable:!1}],K=Buffer.alloc(Buffer.from(p,"utf-8").length+Buffer.from(d,"utf-8").length+Buffer.from(f,"utf-8").length+4*3+1),B=Buffer.alloc(T.span),C=Buffer.alloc(y.type==="ConstantCurve"?S.span:w.span);return I.encode({decimals:m,name:p,symbol:d,uri:f},K),y.type==="ConstantCurve"?S.encode(q(v({index:0},y),{migrateType:y.migrateType==="amm"?0:1}),C):y.type==="FixedCurve"?w.encode(q(v({index:1},y),{migrateType:y.migrateType==="amm"?0:1}),C):y.type==="LinearCurve"&&w.encode(q(v({index:2},y),{migrateType:y.migrateType==="amm"?0:1}),C),T.encode({totalLockedAmount:b,cliffPeriod:g,unlockPeriod:A,transferFeeExtensionParamsOption:h?1:0,transferFeeExtensionParams:h!=null?h:{transferFeeBasePoints:0,maxinumFee:new Xi(0)}},B),new vt({keys:x,programId:c,data:Buffer.from([...Ft.initializeWithToken2022,...K,...C,...B])})}function Vl(c,e,t,n,o,s,i,r,u,a,l,m,p,d,f,y,b,g,A,h){let I=V([k("amountB"),k("minAmountA"),k("shareFeeRate")]),T=[{pubkey:e,isSigner:!0,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!1},{pubkey:m,isSigner:!1,isWritable:!1},{pubkey:p,isSigner:!1,isWritable:!1},{pubkey:d,isSigner:!1,isWritable:!1},{pubkey:mo(c).publicKey,isSigner:!1,isWritable:!1},{pubkey:c,isSigner:!1,isWritable:!1}];h&&T.push({pubkey:h,isSigner:!1,isWritable:!0}),T.push({pubkey:Xt.programId,isSigner:!1,isWritable:!1}),T.push({pubkey:f,isSigner:!1,isWritable:!0}),T.push({pubkey:y,isSigner:!1,isWritable:!0});let w=Buffer.alloc(I.span);return I.encode({amountB:b,minAmountA:g,shareFeeRate:A!=null?A:new Xi(0)},w),new vt({keys:T,programId:c,data:Buffer.from([...Ft.buyExactIn,...w])})}function _l(c,e,t,n,o,s,i,r,u,a,l,m,p,d,f,y,b,g,A,h){let I=V([k("amountA"),k("maxAmountB"),k("shareFeeRate")]),T=[{pubkey:e,isSigner:!0,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!1},{pubkey:m,isSigner:!1,isWritable:!1},{pubkey:p,isSigner:!1,isWritable:!1},{pubkey:d,isSigner:!1,isWritable:!1},{pubkey:mo(c).publicKey,isSigner:!1,isWritable:!1},{pubkey:c,isSigner:!1,isWritable:!1}];h&&T.push({pubkey:h,isSigner:!1,isWritable:!0}),T.push({pubkey:Xt.programId,isSigner:!1,isWritable:!1}),T.push({pubkey:f,isSigner:!1,isWritable:!0}),T.push({pubkey:y,isSigner:!1,isWritable:!0});let w=Buffer.alloc(I.span);return I.encode({amountA:b,maxAmountB:g,shareFeeRate:A!=null?A:new Xi(0)},w),new vt({keys:T,programId:c,data:Buffer.from([...Ft.buyExactOut,...w])})}function El(c,e,t,n,o,s,i,r,u,a,l,m,p,d,f,y,b,g,A,h){let I=V([k("amountA"),k("minAmountB"),k("shareFeeRate")]),T=[{pubkey:e,isSigner:!0,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!1},{pubkey:m,isSigner:!1,isWritable:!1},{pubkey:p,isSigner:!1,isWritable:!1},{pubkey:d,isSigner:!1,isWritable:!1},{pubkey:mo(c).publicKey,isSigner:!1,isWritable:!1},{pubkey:c,isSigner:!1,isWritable:!1}];h&&T.push({pubkey:h,isSigner:!1,isWritable:!0}),T.push({pubkey:Xt.programId,isSigner:!1,isWritable:!1}),T.push({pubkey:f,isSigner:!1,isWritable:!0}),T.push({pubkey:y,isSigner:!1,isWritable:!0});let w=Buffer.alloc(I.span);return I.encode({amountA:b,minAmountB:g,shareFeeRate:A!=null?A:new Xi(0)},w),new vt({keys:T,programId:c,data:Buffer.from([...Ft.sellExactIn,...w])})}function Dl(c,e,t,n,o,s,i,r,u,a,l,m,p,d,f,y,b,g,A,h){let I=V([k("amountB"),k("maxAmountA"),k("shareFeeRate")]),T=[{pubkey:e,isSigner:!0,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!1},{pubkey:m,isSigner:!1,isWritable:!1},{pubkey:p,isSigner:!1,isWritable:!1},{pubkey:d,isSigner:!1,isWritable:!1},{pubkey:mo(c).publicKey,isSigner:!1,isWritable:!1},{pubkey:c,isSigner:!1,isWritable:!1}];h&&T.push({pubkey:h,isSigner:!1,isWritable:!0}),T.push({pubkey:Xt.programId,isSigner:!1,isWritable:!1}),T.push({pubkey:f,isSigner:!1,isWritable:!0}),T.push({pubkey:y,isSigner:!1,isWritable:!0});let w=Buffer.alloc(I.span);return I.encode({amountB:b,maxAmountA:g,shareFeeRate:A!=null?A:new Xi(0)},w),new vt({keys:T,programId:c,data:Buffer.from([...Ft.sellExactOut,...w])})}function nu(c,e,t,n,o,s,i,r,u){let a=V([]),l=[{pubkey:e,isSigner:!0,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!1},{pubkey:u,isSigner:!1,isWritable:!1},{pubkey:Xt.programId,isSigner:!1,isWritable:!1},{pubkey:es,isSigner:!1,isWritable:!1}],m=Buffer.alloc(a.span);return a.encode({},m),new vt({keys:l,programId:c,data:Buffer.from([...Ft.claimVestedToken,...m])})}function ou(c,e,t,n,o,s){let i=V([k("shareAmount")]),r=[{pubkey:e,isSigner:!0,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:Xt.programId,isSigner:!1,isWritable:!1}],u=Buffer.alloc(i.span);return i.encode({shareAmount:s},u),new vt({keys:r,programId:c,data:Buffer.from([...Ft.createVestingAccount,...u])})}function iu(c,e,t,n,o,s,i,r,u){let a=[{pubkey:e,isSigner:!0,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:Xt.programId,isSigner:!1,isWritable:!0},{pubkey:es,isSigner:!1,isWritable:!0}];return new vt({keys:a,programId:c,data:Ft.claimPlatformFee})}function Wl(c,e,t,n,o,s,i,r,u,a,l,m,p){let d=V([k("platformScale"),k("creatorScale"),k("burnScale"),k("feeRate"),It("name"),It("web"),It("img"),k("creatorFeeRate")]),f=[{pubkey:e,isSigner:!0,isWritable:!0},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:Xt.programId,isSigner:!1,isWritable:!1},{pubkey:i,isSigner:!1,isWritable:!1}],y=Buffer.alloc(8*5+Buffer.from(l,"utf-8").length+Buffer.from(m,"utf-8").length+Buffer.from(p,"utf-8").length+4*3);return d.encode({platformScale:r.platformScale,creatorScale:r.creatorScale,burnScale:r.burnScale,feeRate:u,name:l,web:m,img:p,creatorFeeRate:a},y),new vt({keys:f,programId:c,data:Buffer.from([...Ft.createPlatformConfig,...y])})}function ql(c,e,t,n){let o=[{pubkey:e,isSigner:!0,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!0}],s;if(n.type==="updateClaimFeeWallet"){let i=V([E("index"),N("value")]);s=Buffer.alloc(i.span),i.encode({index:0,value:n.value},s)}else if(n.type==="updateLockNftWallet"){let i=V([E("index"),N("value")]);s=Buffer.alloc(i.span),i.encode({index:1,value:n.value},s)}else if(n.type==="migrateCpLockNftScale"){let i=V([E("index"),k("platformScale"),k("creatorScale"),k("burnScale")]);s=Buffer.alloc(i.span),i.encode(v({index:2},n.value),s)}else if(n.type==="updateFeeRate"){let i=V([E("index"),k("value")]);s=Buffer.alloc(i.span),i.encode({index:3,value:n.value},s)}else if(n.type==="updateImg"||n.type==="updateName"||n.type==="updateWeb"){let i=V([E("index"),It("value")]);s=Buffer.alloc(Buffer.from(n.value,"utf-8").length+4+1*1),n.type==="updateName"?i.encode({index:4,value:n.value},s):n.type==="updateWeb"?i.encode({index:5,value:n.value},s):n.type==="updateImg"&&i.encode({index:6,value:n.value},s)}else if(n.type==="updateCpConfigId"){o.push({pubkey:n.value,isSigner:!1,isWritable:!1});let i=V([E("index")]);s=Buffer.alloc(i.span),i.encode({index:7},s)}else if(n.type==="updateAll"){o.push({pubkey:n.value.cpConfigId,isSigner:!1,isWritable:!1});let i=V([E("index"),N("platformClaimFeeWallet"),N("platformLockNftWallet"),k("platformScale"),k("creatorScale"),k("burnScale"),k("feeRate"),It("name"),It("web"),It("img"),N("transferFeeExtensionAuth"),k("creatorFeeRate")]);s=Buffer.alloc(1+32+32+8*4+4*3+Buffer.from(n.value.name,"utf-8").length+Buffer.from(n.value.web,"utf-8").length+Buffer.from(n.value.img,"utf-8").length),i.encode({index:8,platformClaimFeeWallet:n.value.platformClaimFeeWallet,platformLockNftWallet:n.value.platformLockNftWallet,platformScale:n.value.migrateCpLockNftScale.platformScale,creatorScale:n.value.migrateCpLockNftScale.creatorScale,burnScale:n.value.migrateCpLockNftScale.burnScale,feeRate:n.value.feeRate,name:n.value.name,web:n.value.web,img:n.value.img,transferFeeExtensionAuth:n.value.transferFeeExtensionAuth,creatorFeeRate:n.value.creatorFeeRate},s)}else throw Error("updateInfo params type error");return new vt({keys:o,programId:c,data:Buffer.from([...Ft.updatePlaformConfig,...s])})}function ru(c,e,t,n,o,s,i,r){let u=[{pubkey:t,isSigner:!0,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:e,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!1,isWritable:!1},{pubkey:Xt.programId,isSigner:!1,isWritable:!1},{pubkey:es,isSigner:!1,isWritable:!1}];return new vt({keys:u,programId:c,data:Ft.claimPlatformFeeFromVault})}function Ul(c,e,t,n,o,s,i){let r=[{pubkey:e,isSigner:!0,isWritable:!0},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!1},{pubkey:i,isSigner:!1,isWritable:!1},{pubkey:Xt.programId,isSigner:!1,isWritable:!1},{pubkey:es,isSigner:!1,isWritable:!1}];return new vt({keys:r,programId:c,data:Ft.claimCreatorFee})}import{NATIVE_MINT as Kn,TOKEN_2022_PROGRAM_ID as Gn,TOKEN_PROGRAM_ID as Xe,createAssociatedTokenAccountIdempotentInstruction as Yt,getTransferFeeConfig as as,unpackMint as us}from"@solana/spl-token";import se from"bn.js";import{PublicKey as su}from"@solana/web3.js";var qn=V([k(),k("epoch"),E("curveType"),Rt("index"),k("migrateFee"),k("tradeFeeRate"),k("maxShareFeeRate"),k("minSupplyA"),k("maxLockRate"),k("minSellRateA"),k("minMigrateRateA"),k("minFundRaisingB"),N("mintB"),N("protocolFeeOwner"),N("migrateFeeOwner"),N("migrateToAmmWallet"),N("migrateToCpmmWallet"),Y(k(),16)]),mf=V([k("totalLockedAmount"),k("cliffPeriod"),k("unlockPeriod"),k("startTime"),k("totalAllocatedShare")]),rn=V([k(),k("epoch"),E("bump"),E("status"),E("mintDecimalsA"),E("mintDecimalsB"),E("migrateType"),k("supply"),k("totalSellA"),k("virtualA"),k("virtualB"),k("realA"),k("realB"),k("totalFundRaisingB"),k("protocolFee"),k("platformFee"),k("migrateFee"),mf.replicate("vestingSchedule"),N("configId"),N("platformId"),N("mintA"),N("mintB"),N("vaultA"),N("vaultB"),N("creator"),E("mintProgramFlag"),Y(E(),63)]),aC=V([k(),k("epoch"),N("poolId"),N("beneficiary"),k("claimedAmount"),k("tokenShareAmount"),Y(k(),8)]),Do=V([k(),k("epoch"),N("platformClaimFeeWallet"),N("platformLockNftWallet"),k("platformScale"),k("creatorScale"),k("burnScale"),k("feeRate"),Y(E(),64,"name"),Y(E(),256,"web"),Y(E(),256,"img"),N("cpConfigId"),k("creatorFeeRate"),N("transferFeeExtensionAuth"),Y(E(),184)]);import zt from"bn.js";import Gl from"decimal.js";import ts from"bn.js";import zi from"decimal.js";var Un=class{static getPoolInitPriceByPool({poolInfo:e,decimalA:t,decimalB:n}){throw Error()}static getPoolInitPriceByInit({a:e,b:t,decimalA:n,decimalB:o}){throw Error()}static getPoolPrice({poolInfo:e,decimalA:t,decimalB:n}){throw Error()}static getPoolEndPrice({supply:e,totalSell:t,totalLockedAmount:n,totalFundRaising:o,migrateFee:s,decimalA:i,decimalB:r}){throw Error()}static getPoolEndPriceReal({poolInfo:e,decimalA:t,decimalB:n}){throw Error()}static getInitParam({supply:e,totalFundRaising:t,totalSell:n,totalLockedAmount:o,migrateFee:s}){throw Error()}static buyExactIn({poolInfo:e,amount:t}){throw Error()}static buyExactOut({poolInfo:e,amount:t}){throw Error()}static sellExactIn({poolInfo:e,amount:t}){throw Error()}static sellExactOut({poolInfo:e,amount:t}){throw Error()}};var ns=class extends Un{static getPoolInitPriceByPool({poolInfo:e,decimalA:t,decimalB:n}){return new zi(e.virtualB.toString()).div(e.virtualA.toString()).mul(10**(t-n))}static getPoolInitPriceByInit({a:e,b:t,decimalA:n,decimalB:o}){return new zi(t.toString()).div(e.toString()).mul(10**(n-o))}static getPoolPrice({poolInfo:e,decimalA:t,decimalB:n}){return new zi(e.virtualB.add(e.realB).toString()).div(e.virtualA.sub(e.realA).toString()).mul(10**(t-n))}static getPoolEndPrice({supply:e,totalSell:t,totalLockedAmount:n,totalFundRaising:o,migrateFee:s,decimalA:i,decimalB:r}){return new zi(o.sub(s).toString()).div(e.sub(t).sub(n).toString()).mul(10**(i-r))}static getPoolEndPriceReal({poolInfo:e,decimalA:t,decimalB:n}){let o=e.totalSellA.sub(e.realA),s=e.totalFundRaisingB.sub(e.realB);return new zi(e.virtualB.add(e.realB.add(s)).toString()).div(e.virtualA.sub(e.realA.add(o)).toString()).mul(10**(t-n))}static getInitParam({supply:e,totalFundRaising:t,totalSell:n,totalLockedAmount:o,migrateFee:s}){if(e.lte(n))throw Error("supply need gt total sell");let i=e.sub(n).sub(o);if(i.lte(new ts(0)))throw Error("supplyMinusSellLocked <= 0");let r=t.sub(s);if(r.lte(new ts(0)))throw Error("tfMinusMf <= 0");let u=r.mul(n).mul(n).div(i),a=r.mul(n).div(i).sub(t),l=u.div(a),m=t.mul(t).div(a);if(l.lt(new ts(0))||m.lt(new ts(0)))throw Error("invalid input 0");return{a:l,b:m,c:n}}static buyExactIn({poolInfo:e,amount:t}){return this.getAmountOut({amountIn:t,inputReserve:e.virtualB.add(e.realB),outputReserve:e.virtualA.sub(e.realA)})}static buyExactOut({poolInfo:e,amount:t}){return this.getAmountIn({amountOut:t,inputReserve:e.virtualB.add(e.realB),outputReserve:e.virtualA.sub(e.realA)})}static sellExactIn({poolInfo:e,amount:t}){return this.getAmountOut({amountIn:t,inputReserve:e.virtualA.sub(e.realA),outputReserve:e.virtualB.add(e.realB)})}static sellExactOut({poolInfo:e,amount:t}){return this.getAmountIn({amountOut:t,inputReserve:e.virtualA.sub(e.realA),outputReserve:e.virtualB.add(e.realB)})}static getAmountOut({amountIn:e,inputReserve:t,outputReserve:n}){let o=e.mul(n),s=t.add(e);return o.div(s)}static getAmountIn({amountOut:e,inputReserve:t,outputReserve:n}){let o=t.mul(e),s=n.sub(e);return Qn(o,s)}};import os from"bn.js";import Qi from"decimal.js";var is=class extends Un{static getPoolInitPriceByPool({poolInfo:e,decimalA:t,decimalB:n}){return new Qi(e.virtualB.toString()).div(e.virtualA.toString()).mul(10**(t-n))}static getPoolInitPriceByInit({a:e,b:t,decimalA:n,decimalB:o}){return new Qi(t.toString()).div(e.toString()).mul(10**(n-o))}static getPoolPrice({poolInfo:e,decimalA:t,decimalB:n}){return new Qi(e.virtualB.toString()).div(e.virtualA.toString()).mul(10**(t-n))}static getPoolEndPrice({supply:e,totalSell:t,totalLockedAmount:n,totalFundRaising:o,migrateFee:s,decimalA:i,decimalB:r}){return new Qi(o.sub(s).toString()).div(e.sub(t).sub(n).toString()).mul(10**(i-r))}static getPoolEndPriceReal({poolInfo:e,decimalA:t,decimalB:n}){let o=e.totalSellA.sub(e.realA),s=e.totalFundRaisingB.sub(e.realB);return new Qi(e.virtualB.add(e.realB).add(s).toString()).div(e.virtualA.sub(e.realA).add(o).toString()).mul(10**(t-n))}static getInitParam({supply:e,totalFundRaising:t,totalSell:n,totalLockedAmount:o,migrateFee:s}){let i=e.sub(o);if(i.lte(new os(0)))throw Error("invalid input 1");let r=new os(2).mul(t).sub(s),a=t.mul(i).div(r);if(a.lt(new os(0))||t.lt(new os(0)))throw Error("invalid input 0");return{a,b:t,c:a}}static buyExactIn({poolInfo:e,amount:t}){return this.getAmountOut({amountIn:t,initInput:e.virtualB,initOutput:e.virtualA})}static buyExactOut({poolInfo:e,amount:t}){return this.getAmountIn({amountOut:t,initInput:e.virtualB,initOutput:e.virtualA})}static sellExactIn({poolInfo:e,amount:t}){return this.getAmountOut({amountIn:t,initInput:e.virtualA,initOutput:e.virtualB})}static sellExactOut({poolInfo:e,amount:t}){return this.getAmountIn({amountOut:t,initInput:e.virtualA,initOutput:e.virtualB})}static getAmountOut({amountIn:e,initInput:t,initOutput:n}){return n.mul(e).div(t)}static getAmountIn({amountOut:e,initInput:t,initOutput:n}){let o=t.mul(e);return Qn(o,n)}};import St from"bn.js";import fo from"decimal.js";import Wo from"bn.js";import rs from"decimal.js";var Yi=class{static _multipler(e){return new rs(10).pow(e)}static getPrice({priceX64:e,decimalA:t,decimalB:n}){return new rs(e.toString()).div(this._Q64).mul(this._multipler(t)).div(this._multipler(n))}static getPriceX64({price:e,decimalA:t,decimalB:n}){let o=e.mul(this._multipler(n)).div(this._multipler(t));return new Wo(o.mul(this._Q64).toFixed(0))}};Yi._Q64=new rs(new Wo(1).shln(64).toString());function IC({supply:c,totalFundRaisingB:e,totalLockedAmount:t,totalSellA:n,migrateType:o,decimalsA:s}){let i=c.sub(n).sub(t),r=new Wo(new rs(i.mul(e).toString()).sqrt().toFixed(0));if(o==="amm"){if(r.gt(new Wo(10).pow(new Wo(s))))return!0}else if(o==="cpmm"){if(r.gt(new Wo(100)))return!0}else throw Error("migrate type error");return!1}var ss=class extends Un{static getPoolInitPriceByPool({poolInfo:e,decimalA:t,decimalB:n}){return new fo(0)}static getPoolInitPriceByInit({a:e,b:t,decimalA:n,decimalB:o}){return new fo(0)}static getPoolPrice({poolInfo:e,decimalA:t,decimalB:n}){return new fo(e.virtualA.mul(e.realA).toString()).div(Yi._Q64).mul(10**(t-n))}static getPoolEndPrice({supply:e,totalSell:t,totalLockedAmount:n,totalFundRaising:o,migrateFee:s,decimalA:i,decimalB:r}){return new fo(o.sub(s).toString()).div(e.sub(t).sub(n).toString()).mul(10**(i-r))}static getPoolEndPriceReal({poolInfo:e,decimalA:t,decimalB:n}){let o=e.totalSellA.sub(e.realA),s=e.totalFundRaisingB.sub(e.realB);return new fo(e.virtualB.add(e.realB).add(s).toString()).div(e.virtualA.sub(e.realA).add(o).toString()).mul(10**(t-n))}static getInitParam({supply:e,totalFundRaising:t,totalSell:n,totalLockedAmount:o,migrateFee:s}){let i=e.sub(o);if(i.lte(new St(0)))throw Error("supplyMinusLocked need gt 0");let r=t.mul(new St(3)).sub(s),a=t.mul(new St(2)).mul(i).div(r),l=a.mul(a),m=t.mul(new St(2)).mul(et).div(l);if(!m.gt(new St(0)))throw Error("a need gt 0");if(!gi.gt(m))throw Error("a need lt u64 max");if(m.lt(new St(0))||a.lt(new St(0)))throw Error("invalid input 0");return{a:m,b:new St(0),c:a}}static buyExactIn({poolInfo:e,amount:t}){let n=e.realB.add(t),o=new St(2).mul(n).mul(et).div(e.virtualA);return new St(new fo(o.toString()).sqrt().toFixed(0)).sub(e.realA)}static buyExactOut({poolInfo:e,amount:t}){let n=e.realA.add(t),o=n.mul(n);return Qn(e.virtualA.mul(o),new St(2).mul(et)).sub(e.realB)}static sellExactIn({poolInfo:e,amount:t}){let n=e.realA.sub(t),o=n.mul(n),s=Qn(e.virtualA.mul(o),new St(2).mul(et));return e.realB.sub(s)}static sellExactOut({poolInfo:e,amount:t}){let n=e.realB.sub(t),o=new St(2).mul(n).mul(et).div(e.virtualA),s=new St(new fo(o.toString()).sqrt().toFixed(0));return e.realA.sub(s)}};var Qt=class{static getPoolCurvePointByPoolInfo({curveType:e,pointCount:t,poolInfo:n}){return this.getPoolCurvePointByInit({curveType:e,pointCount:t,supply:n.supply,totalFundRaising:n.totalFundRaisingB,totalSell:n.totalSellA,totalLockedAmount:n.vestingSchedule.totalLockedAmount,migrateFee:n.migrateFee,decimalA:n.mintDecimalsA,decimalB:n.mintDecimalsB})}static getPoolCurvePointByInit({curveType:e,pointCount:t,supply:n,totalFundRaising:o,totalSell:s,totalLockedAmount:i,migrateFee:r,decimalA:u,decimalB:a}){if(t<3)throw Error("point count < 3");let l=this.getCurve(e),m=l.getInitParam({supply:n,totalFundRaising:o,totalSell:s,totalLockedAmount:i,migrateFee:r}),p=l.getPoolInitPriceByInit(q(v({},m),{decimalA:u,decimalB:a})),d=o.div(new zt(t-1)),f=new zt(0),y=[{price:p,totalSellSupply:0}],{a:b,b:g}=m,A=f,h=f;for(let I=1;I<t;I++){let T=I!==t-1?d:o.sub(h),w=this.buyExactIn({poolInfo:{virtualA:b,virtualB:g,realA:A,realB:h,totalFundRaisingB:o,totalSellA:s},amountB:T,protocolFeeRate:f,platformFeeRate:f,curveType:e,shareFeeRate:f,creatorFeeRate:f,transferFeeConfigA:void 0,slot:0});A=A.add(w.amountA.amount),h=h.add(w.amountB);let S=this.getPrice({poolInfo:{virtualA:b,virtualB:g,realA:A,realB:h},decimalA:u,decimalB:a,curveType:e});y.push({price:S,totalSellSupply:new Gl(A.toString()).div(10**u).toNumber()})}return y}static getPoolInitPriceByPool({poolInfo:e,decimalA:t,decimalB:n,curveType:o}){return this.getCurve(o).getPoolInitPriceByPool({poolInfo:e,decimalA:t,decimalB:n})}static getPoolInitPriceByInit({a:e,b:t,decimalA:n,decimalB:o,curveType:s}){return this.getCurve(s).getPoolInitPriceByInit({a:e,b:t,decimalA:n,decimalB:o})}static getPrice({poolInfo:e,curveType:t,decimalA:n,decimalB:o}){return this.getCurve(t).getPoolPrice({poolInfo:e,decimalA:n,decimalB:o})}static getEndPrice({poolInfo:e,curveType:t,decimalA:n,decimalB:o}){return this.getCurve(t).getPoolPrice({poolInfo:e,decimalA:n,decimalB:o})}static getPoolEndPriceReal({poolInfo:e,curveType:t,decimalA:n,decimalB:o}){return this.getCurve(t).getPoolEndPriceReal({poolInfo:e,decimalA:n,decimalB:o})}static checkParam({supply:e,totalFundRaising:t,totalSell:n,totalLockedAmount:o,decimals:s,config:i,migrateType:r}){if(Number(s)!==6)throw Error("decimals = 6");if(e.mul(i.maxLockRate).div(en).lt(o))throw Error("total lock amount gte max lock amount");if(e.lt(i.minSupplyA.mul(new zt(10**s))))throw Error("supply lt min supply");let a=e.mul(i.minSellRateA).div(en);if(n.lt(a))throw Error("invalid input");if(t.lt(i.minFundRaisingB))throw Error("total fund raising lt min fund raising");let l=e.sub(n).sub(o),m=e.mul(i.minMigrateRateA).div(en);if(l.lt(m))throw Error("migrate lt min migrate amoount");let p=e.sub(n).sub(o),d=new zt(new Gl(p.mul(t).toString()).sqrt().toFixed(0));if(r==="amm"){let f=new zt(10).pow(new zt(s));if(d.lte(f))throw Error("check migrate lp error")}else if(r==="cpmm"){let f=new zt(100);if(d.lte(f))throw Error("check migrate lp error")}else throw Error("migrate type error")}static buyExactIn({poolInfo:e,amountB:t,protocolFeeRate:n,platformFeeRate:o,curveType:s,shareFeeRate:i,creatorFeeRate:r,transferFeeConfigA:u,slot:a}){let l=this.totalFeeRate({protocolFeeRate:n,platformFeeRate:o,shareFeeRate:i,creatorFeeRate:r}),m=this.calculateFee({amount:t,feeRate:l}),p=t.sub(m),d=this.getCurve(s),f=d.buyExactIn({poolInfo:e,amount:p}),y=e.totalSellA.sub(e.realA),b,g,A;if(f.gt(y)){b=y;let I=d.buyExactOut({poolInfo:e,amount:b});g=this.calculatePreFee({postFeeAmount:I,feeRate:l}),A=g.sub(I)}else b=f,g=t,A=m;let h=this.splitFee({totalFee:A,protocolFeeRate:n,platformFeeRate:o,shareFeeRate:i,creatorFeeRate:r});return{amountA:Ns(b,u,a),amountB:g,splitFee:h}}static buyExactOut({poolInfo:e,amountA:t,protocolFeeRate:n,platformFeeRate:o,curveType:s,shareFeeRate:i,creatorFeeRate:r,transferFeeConfigA:u,slot:a}){let l=e.totalSellA.sub(e.realA),m=Ms(t,u,a),p=m.fee?m.amount.add(m.fee):m.amount;t.gt(l)&&(p=l);let f=this.getCurve(s).buyExactOut({poolInfo:e,amount:p}),y=this.totalFeeRate({protocolFeeRate:n,platformFeeRate:o,shareFeeRate:i,creatorFeeRate:r}),b=this.calculatePreFee({postFeeAmount:f,feeRate:y}),g=b.sub(f),A=this.splitFee({totalFee:g,protocolFeeRate:n,platformFeeRate:o,shareFeeRate:i,creatorFeeRate:r});return{amountA:m,amountB:b,splitFee:A}}static sellExactIn({poolInfo:e,amountA:t,protocolFeeRate:n,platformFeeRate:o,curveType:s,shareFeeRate:i,creatorFeeRate:r,transferFeeConfigA:u,slot:a}){let l=this.getCurve(s),m=Ns(t,u,a),p=m.fee?m.amount.sub(m.fee):m.amount,d=l.sellExactIn({poolInfo:e,amount:p}),f=this.calculateFee({amount:d,feeRate:this.totalFeeRate({protocolFeeRate:n,platformFeeRate:o,shareFeeRate:i,creatorFeeRate:r})}),y=this.splitFee({totalFee:f,protocolFeeRate:n,platformFeeRate:o,shareFeeRate:i,creatorFeeRate:r});return{amountA:m,amountB:d.sub(f),splitFee:y}}static sellExactOut({poolInfo:e,amountB:t,protocolFeeRate:n,platformFeeRate:o,curveType:s,shareFeeRate:i,creatorFeeRate:r,transferFeeConfigA:u,slot:a}){let l=this.totalFeeRate({protocolFeeRate:n,platformFeeRate:o,shareFeeRate:i,creatorFeeRate:r}),m=this.calculatePreFee({postFeeAmount:t,feeRate:l});if(e.realB.lt(m))throw Error("Insufficient liquidity");let p=m.sub(t),f=Qt.getCurve(s).sellExactOut({poolInfo:e,amount:m});if(f.gt(e.realA))throw Error();let y=this.splitFee({totalFee:p,protocolFeeRate:n,platformFeeRate:o,shareFeeRate:i,creatorFeeRate:r});return{amountA:Ms(f,u,a),amountB:t,splitFee:y}}static splitFee({totalFee:e,protocolFeeRate:t,platformFeeRate:n,shareFeeRate:o,creatorFeeRate:s}){let i=this.totalFeeRate({protocolFeeRate:t,platformFeeRate:n,shareFeeRate:o,creatorFeeRate:s}),r=i.isZero()?new zt(0):e.mul(n).div(i),u=i.isZero()?new zt(0):e.mul(o).div(i),a=i.isZero()?new zt(0):e.mul(s).div(i),l=e.sub(r).sub(u).sub(a);return{platformFee:r,shareFee:u,protocolFee:l,creatorFee:a}}static calculateFee({amount:e,feeRate:t}){return ar(e,t,en)}static calculatePreFee({postFeeAmount:e,feeRate:t}){if(t.isZero())return e;let n=e.mul(en),o=en.sub(t);return n.add(o).sub(new zt(1)).div(o)}static totalFeeRate({protocolFeeRate:e,platformFeeRate:t,shareFeeRate:n,creatorFeeRate:o}){if(e.add(t).add(n).add(o).gt(new zt(1e6)))throw Error("total fee rate gt 1_000_000");return e.add(t).add(n).add(o)}static getCurve(e){switch(e){case 0:return ns;case 1:return is;case 2:return ss}throw Error("find curve error")}};import Vt from"decimal.js";var yo={initPriceX64:new se("515752397214619"),supply:new se(1e15),totalSellA:new se(7931e11),totalFundRaisingB:new se(85e9),totalLockedAmount:new se("0"),cliffPeriod:new se("0"),unlockPeriod:new se("0"),decimals:6,virtualA:new se("1073471847374405"),virtualB:new se("30050573465"),realA:new se(0),realB:new se(0),protocolFee:new se(0),platformId:new su("4Bu96XjU84XjPDSpveTVf6LYGCkfW5FK7SNkREWcEfV4"),vestingSchedule:{totalLockedAmount:new se(0),cliffPeriod:new se(0),unlockPeriod:new se(0),startTime:new se(0),totalAllocatedShare:new se(0)}},Xn=new se(1e4),ji=class extends Fe{constructor(e){super(e)}async sayHello(){console.log("hello")}async createLaunchpad(O){var M=O,{programId:e=at,authProgramId:t,platformId:n=yo.platformId,mintA:o,decimals:s=6,mintBDecimals:i=9,name:r,symbol:u,uri:a,migrateType:l,configId:m,snipers:p,configInfo:d,platformFeeRate:f,txVersion:y,computeBudgetConfig:b,txTipConfig:g,feePayer:A,buyAmount:h,minMintAAmount:I,slippage:T,associatedOnly:w=!0,checkCreateATAOwner:S=!1,extraSigners:x,token2022:K,transferFeeExtensionParams:B}=M,C=Ee(M,["programId","authProgramId","platformId","mintA","decimals","mintBDecimals","name","symbol","uri","migrateType","configId","snipers","configInfo","platformFeeRate","txVersion","computeBudgetConfig","txTipConfig","feePayer","buyAmount","minMintAAmount","slippage","associatedOnly","checkCreateATAOwner","extraSigners","token2022","transferFeeExtensionParams"]);var Kt,Zi,cu,lu,mu,du,pu,fu,yu,bu,gu;let L=[],R=this.createTxBuilder(A);t=t!=null?t:fn(e).publicKey,K=!!B,K&&(l="cpmm");let _=d;if(!_&&m){let jt=await this.scope.connection.getAccountInfo(m);jt&&(_=qn.decode(jt.data))}_||this.logAndCreateError("config not found");let X=_.mintB,j=_.curveType,{publicKey:ae}=_o(e,o,X),{publicKey:ue}=$a(e,ae,o),{publicKey:ie}=$a(e,ae,X),{publicKey:me}=hn(o);this.logDebug(`create token: ${o.toBase58()}, mintB: ${X.toBase58()}, decimals A:${s}/B:${i}, config:${m.toBase58()}`),u.length>10&&this.logAndCreateError("Symbol length should shorter than 11"),a||this.logAndCreateError("uri should not empty");let fe=(Kt=C==null?void 0:C.supply)!=null?Kt:yo.supply,de=(Zi=C==null?void 0:C.totalSellA)!=null?Zi:yo.totalSellA,te=(cu=C==null?void 0:C.totalFundRaisingB)!=null?cu:yo.totalFundRaisingB,Ie=(lu=C==null?void 0:C.totalLockedAmount)!=null?lu:new se(0),ze=f;if(!f){let jt=await this.scope.connection.getAccountInfo(n);jt||this.logAndCreateError("platform id not found:",n.toString()),ze=Do.decode(jt.data).feeRate}let _t=Qt.getCurve(_.curveType).getInitParam({supply:fe,totalFundRaising:te,totalSell:de,totalLockedAmount:Ie,migrateFee:_.migrateFee}),nt={epoch:new se(896),bump:254,status:0,mintDecimalsA:s,mintDecimalsB:i,supply:fe,totalSellA:de,mintA:new su(o),mintB:X,virtualA:_t.a,virtualB:_t.b,realA:yo.realA,realB:yo.realB,migrateFee:_.migrateFee,migrateType:l==="amm"?0:1,protocolFee:yo.protocolFee,platformFee:ze,platformId:n,configId:m,vaultA:ue,vaultB:ie,creator:this.scope.ownerPubKey,totalFundRaisingB:te,vestingSchedule:{totalLockedAmount:Ie,cliffPeriod:new se(0),unlockPeriod:new se(0),startTime:new se(0),totalAllocatedShare:new se(0)},mintProgramFlag:K?1:0},ot=Qt.getCurve(_.curveType),{c:qo}=ot.getInitParam({supply:nt.supply,totalFundRaising:nt.totalFundRaisingB,totalLockedAmount:Ie,totalSell:_.curveType===0?nt.totalSellA:new se(0),migrateFee:_.migrateFee});try{Qt.checkParam({supply:nt.supply,totalFundRaising:nt.totalFundRaisingB,totalSell:qo,totalLockedAmount:Ie,decimals:nt.mintDecimalsA,config:_,migrateType:l}),this.logDebug("check init params success")}catch(jt){this.logAndCreateError(`check create mint params failed, ${jt.message}`)}R.addInstruction({instructions:[K?Fl(e,A!=null?A:this.scope.ownerPubKey,this.scope.ownerPubKey,m,n,t,ae,o,X,ue,ie,s,r,u,a||"https://",{type:j===0?"ConstantCurve":j===1?"FixedCurve":j===2?"LinearCurve":"ConstantCurve",totalSellA:de,migrateType:l,supply:fe,totalFundRaisingB:te},Ie,(mu=C==null?void 0:C.cliffPeriod)!=null?mu:new se(0),(du=C==null?void 0:C.unlockPeriod)!=null?du:new se(0),B):vl(e,A!=null?A:this.scope.ownerPubKey,this.scope.ownerPubKey,m,n,t,ae,o,X,ue,ie,me,s,r,u,a||"https://",{type:j===0?"ConstantCurve":j===1?"FixedCurve":j===2?"LinearCurve":"ConstantCurve",totalSellA:de,migrateType:l,supply:fe,totalFundRaisingB:te},Ie,(pu=C==null?void 0:C.cliffPeriod)!=null?pu:new se(0),(fu=C==null?void 0:C.unlockPeriod)!=null?fu:new se(0))]});let Uo=K?await this.scope.connection.getEpochInfo():void 0,sn=B?{epoch:BigInt((Uo==null?void 0:Uo.epoch)||0),maximumFee:BigInt((yu=B==null?void 0:B.maxinumFee.toString())!=null?yu:0),transferFeeBasisPoints:(bu=B==null?void 0:B.transferFeeBasePoints)!=null?bu:0}:void 0,bo={amountA:{amount:new se(0),fee:void 0,expirationTime:void 0},amountB:new se(0),splitFee:{platformFee:new se(0),shareFee:new se(0),protocolFee:new se(0),creatorFee:new se(0)}},go;if(x!=null&&x.length&&R.addInstruction({signers:x}),!C.createOnly){let{builder:jt,extInfo:Xl}=await this.buyToken({programId:e,authProgramId:t,mintAProgram:K?Gn:void 0,mintA:o,mintB:X,poolInfo:nt,buyAmount:h,minMintAAmount:I,shareFeeRate:C.shareFeeRate,shareFeeReceiver:C.shareFeeReceiver,configInfo:_,platformFeeRate:ze,slippage:T,associatedOnly:w,checkCreateATAOwner:S,skipCheckMintA:!sn,transferFeeConfigA:sn?{transferFeeConfigAuthority:t,withdrawWithheldAuthority:t,withheldAmount:BigInt(0),olderTransferFee:sn,newerTransferFee:sn}:void 0});console.log("PREPARING SNIPER TRANSACTIONS");for(let ds of p){let zl={feePayer:(gu=ds.owner)==null?void 0:gu.publicKey,address:new su("HFqU5x63VTqvQss8hp11i4wVV8bD44PvwucfZ2bU7gRe"),amount:new se(1e5)},{builder:Ql,extInfo:yf}=await this.buyToken({programId:e,authProgramId:t,mintAProgram:K?Gn:void 0,mintA:o,mintB:X,poolInfo:nt,buyAmount:ds.amount,minMintAAmount:I,shareFeeRate:C.shareFeeRate,shareFeeReceiver:C.shareFeeReceiver,configInfo:_,platformFeeRate:ze,slippage:T,sniper:ds,txTipConfig:zl,associatedOnly:w,checkCreateATAOwner:S,skipCheckMintA:!sn,transferFeeConfigA:sn?{transferFeeConfigAuthority:t,withdrawWithheldAuthority:t,withheldAmount:BigInt(0),olderTransferFee:sn,newerTransferFee:sn}:void 0});L.push(q(v({},Ql.AllTxData),{blockHash:this.scope.blockhashCommitment}))}R.addInstruction(v({},jt.AllTxData)),bo=v({},Xl),go=(this.scope.cluster==="devnet"||y===1)&&C.shareFeeReceiver?[jt.allInstructions[0]]:void 0}let ls=await R.addTipInstruction(g);return y===0?(console.log("VERSION V0"),{tx:await R.sizeCheckBuildV0({computeBudgetConfig:b,swapInfo:bo,splitIns:go,address:q(v({},nt),{poolId:ae})}),txs:L}):(console.log("VERSION PLAIN"),{tx:await R.sizeCheckBuild({computeBudgetConfig:b,swapInfo:bo,splitIns:go,address:q(v({},nt),{poolId:ae})}),txs:L})}async buyToken({programId:e=at,authProgramId:t,mintA:n,mintAProgram:o=Xe,mintB:s=Kn,poolInfo:i,configInfo:r,platformFeeRate:u,txVersion:a,computeBudgetConfig:l,txTipConfig:m,feePayer:p,buyAmount:d,minMintAAmount:f,slippage:y,shareFeeRate:b=new se(0),shareFeeReceiver:g,sniper:A,associatedOnly:h=!0,checkCreateATAOwner:I=!1,transferFeeConfigA:T,skipCheckMintA:w=!1}){var te,Ie,ze;d.lte(new se(0))&&this.logAndCreateError("buy amount should gt 0:",d.toString());let S=A?this.createSniperTxBuilder(A.owner,A.owner.publicKey):this.createTxBuilder(p),{publicKey:x}=_o(e,n,s);t=t!=null?t:fn(e).publicKey;let K=T;if(!w)if(K)o=Gn;else{let Ne=await this.scope.connection.getAccountInfo(n);if(Ne&&Ne.owner.equals(Gn)){o=Ne.owner;let _t=us(n,Ne,o);K=as(_t)||void 0}}let B=A?this.scope.account.getAssociatedTokenAccountByOwner(A.owner.publicKey,n,o):this.scope.account.getAssociatedTokenAccount(n,o),C=null,O=s.equals(Kn);console.log("userTokenAccountA: ",B),console.log("mintAProgram: ",o),S.addInstruction({instructions:[Yt((A==null?void 0:A.owner.publicKey)||this.scope.ownerPubKey,B,(A==null?void 0:A.owner.publicKey)||this.scope.ownerPubKey,n,o)]});let{account:M,instructionParams:L}=await this.scope.account.getOrCreateTokenAccount({mint:s,owner:(A==null?void 0:A.owner.publicKey)||this.scope.ownerPubKey,createInfo:O?{payer:(A==null?void 0:A.owner.publicKey)||this.scope.ownerPubKey,amount:d}:void 0,skipCloseAccount:!O,notUseTokenAccount:O,associatedOnly:O?!1:h,checkCreateATAOwner:I});M&&(C=M),S.addInstruction(L||{}),C===void 0&&this.logAndCreateError(`cannot found mintB(${s.toBase58()}) token accounts`,"tokenAccounts",this.scope.account.tokenAccounts);let R=i;if(!R){let Ne=await this.scope.connection.getAccountInfo(x,{commitment:"processed"});Ne||this.logAndCreateError("cannot found pool:",x.toBase58()),R=rn.decode(Ne.data)}let _=r,X=await Le(this.scope.connection,[_?void 0:R.configId,R.platformId].filter(Boolean).map(Ne=>({pubkey:Ne})));if(!_){let Ne=X.find(_t=>_t.pubkey.equals(R.configId));(!Ne||!Ne.accountInfo)&&this.logAndCreateError("config not found: ",R.configId.toBase58()),_=qn.decode(Ne.accountInfo.data)}let j=X.find(Ne=>Ne.pubkey.equals(R.platformId));(!j||!j.accountInfo)&&this.logAndCreateError("platform info not found: ",R.configId.toBase58());let ae=Do.decode(j.accountInfo.data);u=u||ae.feeRate;let ue=Qt.buyExactIn({poolInfo:R,amountB:d,protocolFeeRate:_.tradeFeeRate,platformFeeRate:u,curveType:_.curveType,shareFeeRate:b,creatorFeeRate:ae.creatorFeeRate,transferFeeConfigA:K,slot:await this.scope.connection.getSlot()}),ie=new Vt(ue.amountA.amount.toString()).sub((Ie=(te=ue.amountA.fee)==null?void 0:te.toString())!=null?Ie:0),me=y?new Vt(Xn.sub(y).toNumber()/Xn.toNumber()).clampedTo(0,1):new Vt(1),fe=f!=null?f:y?new se(ie.mul(me).toFixed(0)):ue.amountA.amount.sub((ze=ue.amountA.fee)!=null?ze:new se(0));ue.amountB.lt(d)&&console.log(`maximum ${n.toBase58()} amount can buy is ${ue.amountA.toString()}, input ${s.toBase58()} amount: ${ue.amountB.toString()}`);let de=g?H(g,s,Xe).publicKey:void 0;return de&&S.addInstruction({instructions:[Yt((A==null?void 0:A.owner.publicKey)||this.scope.ownerPubKey,de,g,s)]}),S.addInstruction({instructions:[Vl(e,(A==null?void 0:A.owner.publicKey)||this.scope.ownerPubKey,t,R.configId,R.platformId,x,B,C,R.vaultA,R.vaultB,n,s,o,Xe,po(e,R.platformId,s).publicKey,Eo(e,R.creator,s).publicKey,ue.amountB.lt(d)?ue.amountB:d,fe,b,de)]}),S.addCustomComputeBudget(l),S.addTipInstruction(m),S.versionBuild({txVersion:a,extInfo:q(v({},ue),{decimalOutAmount:ie,minDecimalOutAmount:new Vt(fe.toString())})})}async buyTokenExactOut({programId:e=at,authProgramId:t,mintA:n,mintAProgram:o=Xe,mintB:s=Kn,poolInfo:i,configInfo:r,transferFeeConfigA:u,platformFeeRate:a,txVersion:l,computeBudgetConfig:m,txTipConfig:p,feePayer:d,maxBuyAmount:f,outAmount:y,slippage:b,shareFeeRate:g=new se(0),shareFeeReceiver:A,associatedOnly:h=!0,checkCreateATAOwner:I=!1,skipCheckMintA:T=!1}){y.lte(new se(0))&&this.logAndCreateError("out amount should gt 0:",y.toString());let w=this.createTxBuilder(d),{publicKey:S}=_o(e,n,s);t=t!=null?t:fn(e).publicKey;let x=i;if(!x){let de=await this.scope.connection.getAccountInfo(S,{commitment:"processed"});de||this.logAndCreateError("cannot found pool:",S.toBase58()),x=rn.decode(de.data)}let K=r,B=await Le(this.scope.connection,[K?void 0:x.configId,x.platformId].filter(Boolean).map(de=>({pubkey:de})));if(!K){let de=B.find(te=>te.pubkey.equals(x.configId));(!de||!de.accountInfo)&&this.logAndCreateError("config not found: ",x.configId.toBase58()),K=qn.decode(de.accountInfo.data)}let C=B.find(de=>de.pubkey.equals(x.platformId));(!C||!C.accountInfo)&&this.logAndCreateError("platform info not found: ",x.configId.toBase58());let O=Do.decode(C.accountInfo.data);a=a||O.feeRate;let M=u;if(!T)if(M)o=Gn;else{let de=await this.scope.connection.getAccountInfo(n);if(de&&de.owner.equals(Gn)){o=de.owner;let te=us(n,de,o);M=as(te)||void 0}}let L=Qt.buyExactOut({poolInfo:x,amountA:y,protocolFeeRate:K.tradeFeeRate,platformFeeRate:a,curveType:K.curveType,shareFeeRate:g,creatorFeeRate:O.creatorFeeRate,transferFeeConfigA:M,slot:await this.scope.connection.getSlot()}),R=new Vt(L.amountB.toString()),_=b?new Vt(Xn.add(b).toNumber()/Xn.toNumber()).clampedTo(0,Number.MIN_SAFE_INTEGER):new Vt(1),X=(f!=null?f:b)?new se(R.mul(_).toFixed(0)):L.amountB,j=this.scope.account.getAssociatedTokenAccount(n,o),ae=null,ue=s.equals(Kn);w.addInstruction({instructions:[Yt(this.scope.ownerPubKey,j,this.scope.ownerPubKey,n,o)]});let{account:ie,instructionParams:me}=await this.scope.account.getOrCreateTokenAccount({mint:s,owner:this.scope.ownerPubKey,createInfo:ue?{payer:this.scope.ownerPubKey,amount:L.amountB}:void 0,skipCloseAccount:!ue,notUseTokenAccount:ue,associatedOnly:ue?!1:h,checkCreateATAOwner:I});ie&&(ae=ie),w.addInstruction(me||{}),ae===void 0&&this.logAndCreateError(`cannot found mintB(${s.toBase58()}) token accounts`,"tokenAccounts",this.scope.account.tokenAccounts);let fe=A?H(A,s,Xe).publicKey:void 0;return fe&&w.addInstruction({instructions:[Yt(this.scope.ownerPubKey,fe,A,s)]}),w.addInstruction({instructions:[_l(e,this.scope.ownerPubKey,t,x.configId,x.platformId,S,j,ae,x.vaultA,x.vaultB,n,s,o,Xe,po(e,x.platformId,s).publicKey,Eo(e,x.creator,s).publicKey,y,X,g,fe)]}),w.addCustomComputeBudget(m),w.addTipInstruction(p),w.versionBuild({txVersion:l,extInfo:{maxSpentAmount:X,outAmount:y}})}async sellToken({programId:e=at,authProgramId:t,mintAProgram:n=Xe,mintA:o,mintB:s=Kn,poolInfo:i,configInfo:r,platformFeeRate:u,txVersion:a,computeBudgetConfig:l,txTipConfig:m,feePayer:p,sellAmount:d,minAmountB:f,slippage:y,shareFeeRate:b=new se(0),shareFeeReceiver:g,associatedOnly:A=!0,checkCreateATAOwner:h=!1,skipCheckMintA:I=!1}){t=t!=null?t:fn(e).publicKey;let T=this.createTxBuilder(p);d.lte(new se(0))&&this.logAndCreateError("sell amount should be gt 0");let{publicKey:w}=_o(e,o,s),S;if(!I){let te=await this.scope.connection.getAccountInfo(o);if(te&&te.owner.equals(Gn)){n=te.owner;let Ie=us(o,te,n);S=as(Ie)||void 0}}let x=null,K=null,B=s.equals(Kn),{account:C,instructionParams:O}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:n,mint:o,owner:this.scope.ownerPubKey,createInfo:void 0,skipCloseAccount:!0,notUseTokenAccount:!1,associatedOnly:A,checkCreateATAOwner:h});C&&(x=C),T.addInstruction(O||{}),x===void 0&&this.logAndCreateError("cannot found mintA token accounts","tokenAccounts",this.scope.account.tokenAccounts);let{account:M,instructionParams:L}=await this.scope.account.getOrCreateTokenAccount({mint:s,owner:this.scope.ownerPubKey,createInfo:B?{payer:this.scope.ownerPubKey,amount:0}:void 0,skipCloseAccount:!B,notUseTokenAccount:B,associatedOnly:B?!1:A,checkCreateATAOwner:h});M&&(K=M),T.addInstruction(L||{}),K===void 0&&this.logAndCreateError("cannot found mintB token accounts","tokenAccounts",this.scope.account.tokenAccounts);let R=i;if(!R){let te=await this.scope.connection.getAccountInfo(w,{commitment:"processed"});te||this.logAndCreateError("cannot found pool",w.toBase58()),R=rn.decode(te.data)}let _=r,X=await Le(this.scope.connection,[_?void 0:R.configId,R.platformId].filter(Boolean).map(te=>({pubkey:te})));if(!_){let te=X.find(Ie=>Ie.pubkey.equals(R.configId));(!te||!te.accountInfo)&&this.logAndCreateError("config not found: ",R.configId.toBase58()),_=qn.decode(te.accountInfo.data)}let j=X.find(te=>te.pubkey.equals(R.platformId));(!j||!j.accountInfo)&&this.logAndCreateError("platform info not found: ",R.configId.toBase58());let ae=Do.decode(j.accountInfo.data);u=u||ae.feeRate;let ue=Qt.sellExactIn({poolInfo:R,amountA:d,protocolFeeRate:_.tradeFeeRate,platformFeeRate:u,curveType:_.curveType,shareFeeRate:b,creatorFeeRate:ae.creatorFeeRate,transferFeeConfigA:S,slot:await this.scope.connection.getSlot()}),ie=new Vt(ue.amountB.toString()),me=y?new Vt(Xn.sub(y).toNumber()/Xn.toNumber()).clampedTo(0,1):new Vt(1),fe=f!=null?f:y?new se(ie.mul(me).toFixed(0)):ue.amountB;fe.lte(new se(0))&&this.logAndCreateError(`out ${s.toBase58()} amount should be gt 0`);let de=g?H(g,s,Xe).publicKey:void 0;return de&&T.addInstruction({instructions:[Yt(this.scope.ownerPubKey,de,g,s)]}),T.addInstruction({instructions:[El(e,this.scope.ownerPubKey,t,R.configId,R.platformId,w,x,K,R.vaultA,R.vaultB,o,s,n,Xe,po(e,R.platformId,s).publicKey,Eo(e,R.creator,s).publicKey,ue.amountA.amount.lt(d)?ue.amountA.amount:d,fe,b,de)]}),T.addCustomComputeBudget(l),T.addTipInstruction(m),T.versionBuild({txVersion:a,extInfo:{outAmount:fe}})}async sellTokenExactOut({programId:e=at,authProgramId:t,mintAProgram:n=Xe,mintA:o,mintB:s=Kn,poolInfo:i,configInfo:r,platformFeeRate:u,txVersion:a,computeBudgetConfig:l,txTipConfig:m,feePayer:p,inAmount:d,maxSellAmount:f,slippage:y,shareFeeRate:b=new se(0),shareFeeReceiver:g,associatedOnly:A=!0,checkCreateATAOwner:h=!1,skipCheckMintA:I=!1}){t=t!=null?t:fn(e).publicKey;let T=this.createTxBuilder(p);f!=null&&f.lte(new se(0))&&this.logAndCreateError("max sell amount should be gt 0");let{publicKey:w}=_o(e,o,s),S;if(!I){let te=await this.scope.connection.getAccountInfo(o);if(te&&te.owner.equals(Gn)){n=te.owner;let Ie=us(o,te,n);S=as(Ie)||void 0}}let x=null,K=null,B=s.equals(Kn),{account:C,instructionParams:O}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:n,mint:o,owner:this.scope.ownerPubKey,createInfo:void 0,skipCloseAccount:!0,notUseTokenAccount:!1,associatedOnly:A,checkCreateATAOwner:h});C&&(x=C),T.addInstruction(O||{}),x===void 0&&this.logAndCreateError("cannot found mintA token accounts","tokenAccounts",this.scope.account.tokenAccounts);let{account:M,instructionParams:L}=await this.scope.account.getOrCreateTokenAccount({mint:s,owner:this.scope.ownerPubKey,createInfo:B?{payer:this.scope.ownerPubKey,amount:0}:void 0,skipCloseAccount:!B,notUseTokenAccount:B,associatedOnly:B?!1:A,checkCreateATAOwner:h});M&&(K=M),T.addInstruction(L||{}),K===void 0&&this.logAndCreateError("cannot found mintB token accounts","tokenAccounts",this.scope.account.tokenAccounts);let R=i;if(!R){let te=await this.scope.connection.getAccountInfo(w,{commitment:"processed"});te||this.logAndCreateError("cannot found pool",w.toBase58()),R=rn.decode(te.data)}let _=r,X=await Le(this.scope.connection,[_?void 0:R.configId,R.platformId].filter(Boolean).map(te=>({pubkey:te})));if(!_){let te=X.find(Ie=>Ie.pubkey.equals(R.configId));(!te||!te.accountInfo)&&this.logAndCreateError("config not found: ",R.configId.toBase58()),_=qn.decode(te.accountInfo.data)}let j=X.find(te=>te.pubkey.equals(R.platformId));(!j||!j.accountInfo)&&this.logAndCreateError("platform info not found: ",R.configId.toBase58());let ae=Do.decode(j.accountInfo.data);u=u||ae.feeRate;let ue=Qt.sellExactOut({poolInfo:R,amountB:d,protocolFeeRate:_.tradeFeeRate,platformFeeRate:u,curveType:_.curveType,shareFeeRate:b,creatorFeeRate:ae.creatorFeeRate,transferFeeConfigA:S,slot:await this.scope.connection.getSlot()}),ie=new Vt(ue.amountA.amount.toString()),me=y?new Vt(Xn.add(y).toNumber()/Xn.toNumber()).clampedTo(0,Number.MAX_SAFE_INTEGER):new Vt(1),fe=(f!=null?f:y)?new se(ie.mul(me).toFixed(0)):ue.amountA.amount,de=g?H(g,s,Xe).publicKey:void 0;return de&&T.addInstruction({instructions:[Yt(this.scope.ownerPubKey,de,g,s)]}),T.addInstruction({instructions:[Dl(e,this.scope.ownerPubKey,t,R.configId,R.platformId,w,x,K,R.vaultA,R.vaultB,o,s,n,Xe,po(e,R.platformId,s).publicKey,Eo(e,R.creator,s).publicKey,d,fe,b,de)]}),T.addCustomComputeBudget(l),T.addTipInstruction(m),T.versionBuild({txVersion:a,extInfo:{maxSellAmount:fe}})}async createPlatformConfig({programId:e=at,platformAdmin:t,platformClaimFeeWallet:n,platformLockNftWallet:o,cpConfigId:s,migrateCpLockNftScale:i,transferFeeExtensionAuth:r,creatorFeeRate:u,feeRate:a,name:l,web:m,img:p,txVersion:d,computeBudgetConfig:f,txTipConfig:y,feePayer:b}){let g=this.createTxBuilder(b),{publicKey:A}=Ja(e,t);return g.addInstruction({instructions:[Wl(e,t,n,o,A,s,r,i,a,u,l,m,p)]}),g.addCustomComputeBudget(f),g.addTipInstruction(y),g.versionBuild({txVersion:d,extInfo:{platformId:A}})}async updatePlatformConfig({programId:e=at,platformAdmin:t,platformId:n,updateInfo:o,txVersion:s,computeBudgetConfig:i,txTipConfig:r,feePayer:u}){let a=this.createTxBuilder(u),l=n!=null?n:Ja(e,t).publicKey;return a.addInstruction({instructions:[ql(e,t,l,o)]}),a.addCustomComputeBudget(i),a.addTipInstruction(r),a.versionBuild({txVersion:s})}async claimPlatformFee({programId:e=at,authProgramId:t,platformId:n,poolId:o,platformClaimFeeWallet:s,mintB:i,vaultB:r,mintBProgram:u=Xe,txVersion:a,computeBudgetConfig:l,txTipConfig:m,feePayer:p}){var g;let d=this.createTxBuilder(p);t=t!=null?t:fn(e).publicKey;let f=i,y=r;if(!f){let A=await this.scope.connection.getAccountInfo(o,{commitment:"processed"});A||this.logAndCreateError("cannot found pool:",o.toBase58());let h=rn.decode(A.data),I=await this.scope.connection.getAccountInfo(h.configId,{commitment:"processed"});I||this.logAndCreateError("cannot found config:",h.configId.toBase58()),f=qn.decode(I.data).mintB,y=y!=null?y:h.vaultB}(!f||!y)&&this.logAndCreateError("cannot found mint info, mintB: ",f.toBase58(),", vaultB: ",(g=y==null?void 0:y.toBase58())!=null?g:"");let b=H(this.scope.ownerPubKey,f,Xe).publicKey;return d.addInstruction({instructions:[Yt(this.scope.ownerPubKey,b,this.scope.ownerPubKey,f)]}),d.addInstruction({instructions:[iu(e,s,t,o,n,y,b,f,u)]}),d.addCustomComputeBudget(l),d.addTipInstruction(m),d.versionBuild({txVersion:a})}async claimAllPlatformFee({programId:e=at,authProgramId:t,platformId:n,platformClaimFeeWallet:o,txVersion:s,computeBudgetConfig:i,txTipConfig:r,feePayer:u}){let a=this.createTxBuilder(u);return t=t!=null?t:fn(e).publicKey,(await this.scope.connection.getProgramAccounts(e,{filters:[{dataSize:rn.span},{memcmp:{offset:rn.offsetOf("platformId"),bytes:n.toString()}}]})).forEach(m=>{let p=rn.decode(m.account.data);if(p.platformFee.lte(new se(0)))return;let d=H(this.scope.ownerPubKey,p.mintB,Xe).publicKey;a.addInstruction({instructions:[Yt(this.scope.ownerPubKey,d,this.scope.ownerPubKey,p.mintB)]}),a.addInstruction({instructions:[iu(e,o,t,m.pubkey,n,p.vaultB,d,p.mintB,Xe)]})}),a.addTipInstruction(r),s===0?a.sizeCheckBuildV0({computeBudgetConfig:i}):a.sizeCheckBuild({computeBudgetConfig:i})}async createVesting({programId:e=at,poolId:t,beneficiary:n,shareAmount:o,txVersion:s,computeBudgetConfig:i,txTipConfig:r,feePayer:u}){let a=this.createTxBuilder(u),l=await this.getRpcPoolInfo({poolId:t});o.add(l.vestingSchedule.totalAllocatedShare).gt(l.vestingSchedule.totalLockedAmount)&&this.logAndCreateError("share amount exceed total locked amount");let m=Gi(e,t,n).publicKey;return a.addInstruction({instructions:[ou(e,this.scope.ownerPubKey,n,t,m,o)]}),a.addCustomComputeBudget(i),a.addTipInstruction(r),a.versionBuild({txVersion:s})}async createMultipleVesting({programId:e=at,poolId:t,beneficiaryList:n,txVersion:o,computeBudgetConfig:s,feePayer:i}){let r=this.createTxBuilder(i);n.length===0&&this.logAndCreateError("beneficiaryList is null");let u=await this.getRpcPoolInfo({poolId:t});return n.reduce((l,m)=>l.add(m.shareAmount),u.vestingSchedule.totalAllocatedShare).gt(u.vestingSchedule.totalLockedAmount)&&this.logAndCreateError("share amount exceed total locked amount"),n.forEach(l=>{let m=Gi(e,t,l.wallet).publicKey;r.addInstruction({instructions:[ou(e,this.scope.ownerPubKey,l.wallet,t,m,l.shareAmount)]})}),o===0?r.sizeCheckBuildV0({computeBudgetConfig:s}):r.sizeCheckBuild({computeBudgetConfig:s})}async claimVesting({programId:e=at,poolId:t,poolInfo:n,vestingRecord:o,txVersion:s,computeBudgetConfig:i,txTipConfig:r,feePayer:u}){let a=this.createTxBuilder(u),l=fn(e).publicKey,m=o||Gi(e,t,this.scope.ownerPubKey).publicKey,p=n;if(!p){let f=await this.scope.connection.getAccountInfo(t);f||this.logAndCreateError("pool not found"),p=rn.decode(f.data)}let d=H(this.scope.ownerPubKey,p.mintA,Xe).publicKey;return a.addInstruction({instructions:[Yt(this.scope.ownerPubKey,d,this.scope.ownerPubKey,p.mintA)]}),a.addInstruction({instructions:[nu(e,this.scope.ownerPubKey,l,t,m,d,p.vaultA,p.mintA,Xe)]}),a.addCustomComputeBudget(i),a.addTipInstruction(r),a.versionBuild({txVersion:s})}async claimMultiVesting({programId:e=at,poolIdList:t,poolsInfo:n={},vestingRecords:o={},txVersion:s,computeBudgetConfig:i,feePayer:r}){let u=this.createTxBuilder(r),a=v({},n),l=fn(e).publicKey,m=t.filter(p=>!a[p.toBase58()]);if(m.length){let p=await this.getRpcPoolsInfo({poolIdList:m});a=v(v({},a),p.poolInfoMap)}return t.forEach(p=>{let d=p.toBase58(),f=a[d];f||this.logAndCreateError(`pool info not found: ${d}`);let y=o[d]||Gi(e,p,this.scope.ownerPubKey).publicKey,b=H(this.scope.ownerPubKey,f.mintA,Xe).publicKey;u.addInstruction({instructions:[Yt(this.scope.ownerPubKey,b,this.scope.ownerPubKey,f.mintA)]}),u.addInstruction({instructions:[nu(e,this.scope.ownerPubKey,l,p,y,b,f.vaultA,f.mintA,Xe)]})}),s===0?u.sizeCheckBuildV0({computeBudgetConfig:i}):u.sizeCheckBuild({computeBudgetConfig:i})}async claimVaultPlatformFee({programId:e=at,platformId:t,mintB:n,mintBProgram:o=Xe,claimFeeWallet:s,txVersion:i,computeBudgetConfig:r,txTipConfig:u,feePayer:a}){let l=this.createTxBuilder(a),m=po(e,t,n).publicKey,p=eu(e).publicKey,d=this.scope.account.getAssociatedTokenAccount(n,o);return l.addInstruction({instructions:[Yt(this.scope.ownerPubKey,d,this.scope.ownerPubKey,n,o),ru(e,t,s!=null?s:this.scope.ownerPubKey,p,m,d,n,o)]}),l.addCustomComputeBudget(r),l.addTipInstruction(u),l.versionBuild({txVersion:i})}async claimMultipleVaultPlatformFee({programId:e=at,platformList:t,unwrapSol:n=!0,txVersion:o,computeBudgetConfig:s,feePayer:i,associatedOnly:r=!0,checkCreateATAOwner:u=!1}){let a=this.createTxBuilder(i),l={};return t.forEach(async m=>{var b,g;let p=eu(e).publicKey,d=po(e,m.id,m.mintB).publicKey,f=m.mintB.equals(Kn)&&n,y=l[m.mintB.toBase58()];if(!y){let{account:A,instructionParams:h}=await this.scope.account.getOrCreateTokenAccount({mint:m.mintB,owner:this.scope.ownerPubKey,createInfo:f?{payer:this.scope.ownerPubKey,amount:0}:void 0,skipCloseAccount:!f,notUseTokenAccount:f,associatedOnly:f?!1:r,checkCreateATAOwner:u});A&&(y=A),a.addInstruction(h||{}),y===void 0&&this.logAndCreateError(`cannot found platform ${m.id.toBase58()} mintB(${m.mintB.toBase58()}) token accounts`,"tokenAccounts",this.scope.account.tokenAccounts)}a.addInstruction({instructions:[ru(e,m.id,(b=m.claimFeeWallet)!=null?b:this.scope.ownerPubKey,d,p,y,m.mintB,(g=m.mintBProgram)!=null?g:Xe)]})}),o===0?a.sizeCheckBuildV0({computeBudgetConfig:s}):a.sizeCheckBuild({computeBudgetConfig:s})}async claimCreatorFee({programId:e=at,mintB:t,mintBProgram:n=Xe,txVersion:o,computeBudgetConfig:s,txTipConfig:i,feePayer:r}){let u=this.createTxBuilder(r),a=Eo(e,this.scope.ownerPubKey,t).publicKey,l=Ml(e).publicKey,m=this.scope.account.getAssociatedTokenAccount(t,n);return u.addInstruction({instructions:[Yt(this.scope.ownerPubKey,m,this.scope.ownerPubKey,t,n),Ul(e,this.scope.ownerPubKey,l,a,m,t,n)]}),u.addCustomComputeBudget(s),u.addTipInstruction(i),u.versionBuild({txVersion:o})}async getRpcPoolInfo({poolId:e}){return(await this.getRpcPoolsInfo({poolIdList:[e]})).poolInfoMap[e.toBase58()]}async getRpcPoolsInfo({poolIdList:e,config:t}){let n=await Le(this.scope.connection,e.map(u=>({pubkey:u})),t),o={},s=[];for(let u=0;u<e.length;u++){let a=n[u];if(a===null||!a.accountInfo)throw Error("fetch pool info error: "+e[u].toBase58());let l=rn.decode(a.accountInfo.data);o[e[u].toBase58()]=q(v({},l),{poolId:a.accountInfo.owner}),s.push(l.configId)}let i=await Le(this.scope.connection,s.map(u=>({pubkey:u})),t),r={};for(let u=0;u<s.length;u++){let a=i[u];if(a===null||!a.accountInfo)throw Error("fetch config info error: "+s[u].toBase58());let l=qn.decode(a.accountInfo.data);r[s[u].toBase58()]=q(v({},l),{configId:a.accountInfo.owner})}return{poolInfoMap:Object.keys(o).reduce((u,a)=>q(v({},u),{[a]:q(v({},o[a]),{configInfo:r[o[a].configId.toBase58()]})}),{})}}};import{PublicKey as df}from"@solana/web3.js";import{MintLayout as pf,TOKEN_2022_PROGRAM_ID as au,TOKEN_PROGRAM_ID as uu}from"@solana/spl-token";var Hi=class extends Fe{constructor(t){super(t);this._tokenList=[];this._tokenMap=new Map;this._blackTokenMap=new Set;this._mintGroup={official:new Set,jup:new Set,extra:new Set};this._whiteMap=new Set;this._extraTokenList=[]}async load(t){this.checkDisabled();let{forceUpdate:n=!1,type:o="strict"}=t||{},{mintList:s,blacklist:i,whiteList:r}=await this.scope.fetchV3TokenList(n),u=await this.scope.fetchJupTokenList(n);this._tokenList=[],this._tokenMap=new Map,this._blackTokenMap=new Set(i),this._mintGroup={official:new Set,jup:new Set,extra:new Set},this._whiteMap=new Set(r),this._tokenMap.set(an.address,an),this._mintGroup.official.add(an.address),s.forEach(a=>{var l;this._blackTokenMap.has(a.address)||(this._tokenMap.set(a.address,q(v({},a),{type:"raydium",priority:2,programId:(l=a.programId)!=null?l:a.tags.includes("token-2022")?au.toBase58():uu.toBase58()})),this._mintGroup.official.add(a.address))}),u.forEach(a=>{var l;this._blackTokenMap.has(a.address)||this._tokenMap.has(a.address)||(this._tokenMap.set(a.address,q(v({},a),{type:"jupiter",priority:1,programId:(l=a.programId)!=null?l:a.tags.includes("token-2022")?au.toBase58():uu.toBase58(),tags:a.freezeAuthority?[...a.tags||[],"hasFreeze"]:a.tags})),this._mintGroup.jup.add(a.address))}),this._extraTokenList.forEach(a=>{this._blackTokenMap.has(a.address)||this._tokenMap.has(a.address)||(this._tokenMap.set(a.address,q(v({},a),{type:"extra",priority:1,programId:a.programId||a.tags.includes("token-2022")?au.toBase58():uu.toBase58()})),this._mintGroup.extra.add(a.address))}),this._tokenList=Array.from(this._tokenMap).map(a=>a[1])}get tokenList(){return this._tokenList}get tokenMap(){return this._tokenMap}get blackTokenMap(){return this._blackTokenMap}get mintGroup(){return this._mintGroup}get whiteListMap(){return this._whiteMap}async getTokenInfo(t){if(!t)throw new Error("please input mint");let n=t.toString(),o=this._tokenMap.get(n);if(o)return o;if(n.toLocaleUpperCase()==="SOL")return an;let s=(await this.scope.api.getTokenInfo([n]))[0];if(s)return this._mintGroup.extra.add(n),this._tokenMap.set(n,q(v({},s),{priority:2})),s;let i=await this.scope.connection.getAccountInfo(new df(n));if(!i)throw new Error(`mint address not found: ${n}`);let r=pf.decode(i.data),u=n.toString().substring(0,6),a={chainId:101,address:n,programId:i.owner.toBase58(),logoURI:"",symbol:u,name:u,decimals:r.decimals,tags:[],extensions:{},priority:0,type:"unknown"};return this._mintGroup.extra.add(n),this._tokenMap.set(n,a),a}};var cs=class{constructor(e){this.rawBalances=new Map;let{connection:t,cluster:n,owner:o,api:s,defaultChainTime:i,defaultChainTimeOffset:r,apiCacheTime:u,blockhashCommitment:a="confirmed",loopMultiTxStatus:l}=e;this._connection=t,this.cluster=n||"mainnet",this._owner=o?new Ct(o):void 0,this._signAllTransactions=e.signAllTransactions,this.blockhashCommitment=a,this.loopMultiTxStatus=l,this.api=s,this._apiCacheTime=u||5*60*1e3,this.logger=ye("Raydium"),this.farm=new bi({scope:this,moduleName:"Raydium_Farm"}),this.account=new si({scope:this,moduleName:"Raydium_Account",tokenAccounts:e.tokenAccounts,tokenAccountRawInfos:e.tokenAccountRawInfos}),this.liquidity=new Ri({scope:this,moduleName:"Raydium_LiquidityV2"}),this.token=new Hi({scope:this,moduleName:"Raydium_tokenV2"}),this.tradeV2=new Wi({scope:this,moduleName:"Raydium_tradeV2"}),this.clmm=new Oi({scope:this,moduleName:"Raydium_clmm"}),this.cpmm=new Vi({scope:this,moduleName:"Raydium_cpmm"}),this.utils1216=new Gt({scope:this,moduleName:"Raydium_utils1216"}),this.marketV2=new Mo({scope:this,moduleName:"Raydium_marketV2"}),this.ido=new Vo({scope:this,moduleName:"Raydium_ido"}),this.launchpad=new ji({scope:this,moduleName:"Raydium_lauchpad"}),this.availability={};let m=new Date().getTime();this.apiData={},r&&(this._chainTime={fetched:m,value:{chainTime:i||Date.now()-r,offset:r}})}static async load(e){var l;let t=ff({cluster:"mainnet",owner:null,apiRequestInterval:3e5,apiRequestTimeout:1e4},e),{cluster:n,apiRequestTimeout:o,logCount:s,logRequests:i,urlConfigs:r}=t,u=new br({cluster:n,timeout:o,urlConfigs:r,logCount:s,logRequests:i}),a=new cs(q(v({},t),{api:u}));return await a.fetchAvailabilityStatus((l=e.disableFeatureCheck)!=null?l:!0),e.disableLoadToken||await a.token.load({type:e.jupTokenType}),a}get owner(){return this._owner}get ownerPubKey(){if(!this._owner)throw new Error(gr);return this._owner.publicKey}setOwner(e){return this._owner=e?new Ct(e):void 0,this.account.resetTokenAccounts(),this}get connection(){if(!this._connection)throw new Error(Uu);return this._connection}setConnection(e){return this._connection=e,this}get signAllTransactions(){return this._signAllTransactions}setSignAllTransactions(e){return this._signAllTransactions=e,this}checkOwner(){if(!this.owner)throw console.error(gr),new Error(gr)}isCacheInvalidate(e){return new Date().getTime()-e>this._apiCacheTime}async fetchChainTime(){try{let e=await this.api.getChainTimeOffset();this._chainTime={fetched:Date.now(),value:{chainTime:Date.now()+e.offset*1e3,offset:e.offset*1e3}}}catch{this._chainTime=void 0}}async fetchV3TokenList(e){if(this.apiData.tokenList&&!this.isCacheInvalidate(this.apiData.tokenList.fetched)&&!e)return this.apiData.tokenList.data;try{let t=await this.api.getTokenList(),n={fetched:Date.now(),data:t};return this.apiData.tokenList=n,n.data}catch(t){return console.error(t),{mintList:[],blacklist:[],whiteList:[]}}}async fetchJupTokenList(e){if(this.cluster==="devnet")return[];let t=this.apiData.jupTokenList;if(t&&!this.isCacheInvalidate(t.fetched)&&!e)return t.data;try{let n=await this.api.getJupTokenList();return this.apiData.jupTokenList={fetched:Date.now(),data:n.map(o=>q(v({},o),{mintAuthority:o.mint_authority||void 0,freezeAuthority:o.freeze_authority||void 0}))},this.apiData.jupTokenList.data}catch(n){return console.error(n),[]}}get chainTimeData(){var e;return(e=this._chainTime)==null?void 0:e.value}async chainTimeOffset(){var e;return this._chainTime&&Date.now()-this._chainTime.fetched<=1e3*60*5?this._chainTime.value.offset:(await this.fetchChainTime(),((e=this._chainTime)==null?void 0:e.value.offset)||0)}async currentBlockChainTime(){var e;return this._chainTime&&Date.now()-this._chainTime.fetched<=1e3*60*5?this._chainTime.value.chainTime:(await this.fetchChainTime(),((e=this._chainTime)==null?void 0:e.value.chainTime)||Date.now())}async fetchEpochInfo(){return this._epochInfo&&Date.now()-this._epochInfo.fetched<=1e3*30?this._epochInfo.value:(this._epochInfo={fetched:Date.now(),value:await this.connection.getEpochInfo()},this._epochInfo.value)}async fetchAvailabilityStatus(e){if(e)return{};try{let t=await this.api.fetchAvailabilityStatus(),n=t.all===!1;return this.availability={all:t.all,swap:n?!1:t.swap,createConcentratedPosition:n?!1:t.createConcentratedPosition,addConcentratedPosition:n?!1:t.addConcentratedPosition,addStandardPosition:n?!1:t.addStandardPosition,removeConcentratedPosition:n?!1:t.removeConcentratedPosition,removeStandardPosition:n?!1:t.removeStandardPosition,addFarm:n?!1:t.addFarm,removeFarm:n?!1:t.removeFarm},t}catch{return{}}}};var XR=c=>c;export{zd as AMM_CONFIG_SEED,nf as AUTH_SEED,Sc as BIT_PRECISION,of as CONFIG_SEED,uf as CREATOR_FEE_VAULT_AUTH_SEED,Oi as Clmm,qc as ClmmConfigLayout,Ke as ClmmInstrument,qr as ConstantProductCurve,Il as CpmmConfigInfoLayout,Ur as CpmmFee,Qr as CpmmPoolInfoLayout,Qt as Curve,Un as CurveBase,Xr as CurveCalculator,ck as DEV_FARM_LOCK_MINT,lk as DEV_FARM_LOCK_VAULT,fp as DataElement,wa as EXTENSION_TICKARRAY_BITMAP_SIZE,pc as FARM_LOCK_MINT,fc as FARM_LOCK_VAULT,Et as FARM_PROGRAM_TO_VERSION,bc as FARM_VERSION_TO_LEDGER_LAYOUT,yc as FARM_VERSION_TO_STATE_LAYOUT,Cr as FEE_RATE_DENOMINATOR,Jd as FETCH_TICKARRAY_COUNT,Xd as Fee,is as FixedPriceCurve,Mr as LIQUIDITY_FEES_DENOMINATOR,Ba as LIQUIDITY_FEES_NUMERATOR,up as LIQUIDITY_VERSION_TO_SERUM_VERSION,Rh as LIQUIDITY_VERSION_TO_STATE_LAYOUT,Up as LOCK_LIQUIDITY_SEED,Kc as LOG_B_2_X32,Cc as LOG_B_P_ERR_MARGIN_LOWER_X64,Rc as LOG_B_P_ERR_MARGIN_UPPER_X64,ns as LaunchConstantProductCurve,qn as LaunchpadConfig,rn as LaunchpadPool,yo as LaunchpadPoolInitParam,aC as LaunchpadVesting,ss as LinearPriceCurve,Ae as LiquidityMath,Xc as LockClPositionLayoutV2,qT as LockPositionLayout,_a as MARKET_STATE_LAYOUT_V2,Ua as MARKET_STATE_LAYOUT_V3,Kl as MARKET_VERSION_TO_STATE_LAYOUT,qt as MAX_SQRT_PRICE_X64,Kr as MAX_SQRT_PRICE_X64_SUB_ONE,Pt as MAX_TICK,Wt as MIN_SQRT_PRICE_X64,Sr as MIN_SQRT_PRICE_X64_ADD_ONE,ft as MIN_TICK,Hr as Market,Yi as MathLaunch,le as MathUtil,gi as MaxU64,xc as MaxUint128,Tn as NEGATIVE_ONE,Zd as OBSERVATION_SEED,Lt as ONE,jd as OPERATION_SEED,Uc as ObservationInfoLayout,np as ObservationLayout,Gc as OperationLayout,af as PLATFORM_FEE_VAULT_AUTH_SEED,sf as PLATFORM_SEED,_c as POOL_LOCK_ID_SEED,Qd as POOL_REWARD_VAULT_SEED,ya as POOL_SEED,Hd as POOL_TICK_ARRAY_BITMAP_SEED,ba as POOL_VAULT_SEED,rf as POOL_VESTING_SEED,Mc as POSITION_SEED,Do as PlatformConfig,eo as PoolInfoLayout,Oe as PoolUtils,Ro as PositionInfoLayout,ip as PositionRewardInfoLayout,wi as PositionUtils,WT as ProtocolPositionLayout,xr as Q128,et as Q64,cs as Raydium,op as RewardInfo,yl as RoundDirection,xl as SERUM_PROGRAMID_TO_VERSION,Sl as SERUM_VERSION_TO_PROGRAMID,an as SOL_INFO,jc as SPL_MINT_LAYOUT,$d as SUPPORT_MINT_SEED,re as SqrtPriceMath,No as StableLayout,Jn as SwapMath,$n as TICK_ARRAY_BITMAP_SIZE,Yd as TICK_ARRAY_SEED,tt as TICK_ARRAY_SIZE,hw as TICK_SPACINGS,it as TOKEN_WSOL,In as TickArrayBitmap,Wc as TickArrayBitmapExtensionLayout,hi as TickArrayBitmapExtensionUtils,Ti as TickArrayLayout,rp as TickLayout,to as TickMath,ke as TickQuery,$ as TickUtils,Ai as U64Resolution,Bw as U64_IGNORE_RANGE,mf as VestingSchedule,dc as Voter,Cd as VoterDepositEntry,Kd as VoterLockup,mc as VoterRegistrar,Sd as VoterVotingMintConfig,be as ZERO,Ca as addLiquidityLayout,Ft as anchorDataBuf,js as associatedLedgerAccountLayout,Vl as buyExactInInstruction,_l as buyExactOutInstruction,ca as calFarmRewardAmount,IC as checkPoolToAmm,Ul as claimCreatorFee,qi as claimLayout,iu as claimPlatformFee,ru as claimPlatformFeeFromVault,nu as claimVestedToken,Dc as clmmComputeInfoToApiInfo,wn as closeAccountInstruction,qa as collectCpFeeInstruction,Qp as cpmmLockPositionInstruction,di as createAssociatedLedgerAccountInstruction,Wl as createPlatformConfig,$c as createPoolFeeLayout,Oa as createPoolV4InstructionV2,Ch as createPoolV4Layout,ou as createVestingAccount,Mn as createWSolAccountInstructions,At as dwLayout,Js as farmAddRewardLayout,$P as farmLedgerLayoutV3_1,ui as farmLedgerLayoutV3_2,JP as farmLedgerLayoutV5_1,cc as farmLedgerLayoutV5_2,lc as farmLedgerLayoutV6_1,Ac as farmRewardInfoToConfig,Zs as farmRewardLayout,$s as farmRewardRestartLayout,xd as farmRewardTimeInfoLayout,ac as farmStateV3Layout,uc as farmStateV5Layout,ai as farmStateV6Layout,Sk as fetchMultipleFarmInfoAndUpdate,yI as fetchMultipleInfo,xa as fixedSwapInLayout,Sa as fixedSwapOutLayout,Ip as formatLayout,Qe as generatePubKey,gc as getAssociatedAuthority,Vr as getAssociatedConfigId,pt as getAssociatedLedgerAccount,li as getAssociatedLedgerPoolAccount,Kp as getAssociatedOpenOrders,Va as getAssociatedPoolKeys,vi as getCpLockPda,fx as getCpmmPdaAmmConfigId,Da as getCpmmPdaPoolId,gl as getCreatePoolKeys,la as getDepositEntryIndex,sl as getDxByDyBaseIn,rl as getDyByDxBaseIn,So as getFarmLedgerLayout,Ld as getFarmStateLayout,Fa as getLiquidityAssociatedAuthority,ro as getLiquidityAssociatedId,gT as getLiquidityFromAmounts,Ow as getPdaAmmConfigId,mo as getPdaCpiEvent,Ml as getPdaCreatorFeeVaultAuth,Eo as getPdaCreatorVault,Ye as getPdaExBitmapAccount,fn as getPdaLaunchpadAuth,jK as getPdaLaunchpadConfigId,_o as getPdaLaunchpadPoolId,$a as getPdaLaunchpadVaultId,Co as getPdaLockClPositionIdV2,Aa as getPdaLockPositionId,Wp as getPdaLpMint,hn as getPdaMetadataKey,Pa as getPdaMintExAccount,Vc as getPdaObservationAccount,Mi as getPdaObservationId,ki as getPdaOperationAccount,kt as getPdaPersonalPositionAddress,eu as getPdaPlatformFeeVaultAuth,Ja as getPdaPlatformId,po as getPdaPlatformVault,Fo as getPdaPoolAuthority,vc as getPdaPoolId,Fc as getPdaPoolRewardVaulId,ga as getPdaPoolVaultId,on as getPdaProtocolPositionAddress,ge as getPdaTickArrayAddress,bl as getPdaVault,Gi as getPdaVestId,oa as getRegistrarAddress,al as getStablePrice,ua as getTokenOwnerRecordAddress,sa as getVoterAddress,aa as getVoterWeightRecordAddress,ra as getVotingMintAuthority,ia as getVotingTokenMint,Dd as governanceCreateTokenOwnerRecord,Sw as i16ToBytes,Lr as i32ToBytes,Ka as initPoolLayout,Qs as initTokenAccountInstruction,vl as initialize,Op as initializeMarket,Fl as initializeWithToken2022,ta as isValidFarmVersion,Pi as isZero,Kk as judgeFarmType,pa as leadingZeros,Nc as leastSignificantBit,no as liquidityStateV4Layout,cp as liquidityStateV5Layout,vr as makeAMMSwapInstruction,tl as makeAddLiquidityInstruction,da as makeAddNewRewardInstruction,Jr as makeClaimInstruction,Za as makeClaimInstructionV4,hl as makeCpmmLockInstruction,Pl as makeCreateCpmmPoolInInstruction,Pc as makeCreateFarmInstruction,Er as makeCreateMarketInstruction,kc as makeCreatorWithdrawFarmRewardInstruction,kl as makeDepositCpmmInInstruction,Tc as makeDepositInstructionV3,hc as makeDepositInstructionV5,Ic as makeDepositInstructionV6,Gk as makeDepositTokenInstruction,zk as makeDepositWithdrawInstruction,qh as makeInitPoolInstructionV4,RK as makePurchaseInstruction,ma as makeRestartRewardInstruction,nl as makeSimulatePoolInfoInstruction,zr as makeSwapCpmmBaseInInstruction,Tl as makeSwapCpmmBaseOutInstruction,dp as makeSwapFixedInInstruction,pp as makeSwapFixedOutInstruction,Rl as makeSwapInstruction,sc as makeTransferInstruction,wl as makeWithdrawCpmmInInstruction,yi as makeWithdrawInstructionV3,wc as makeWithdrawInstructionV4,fi as makeWithdrawInstructionV5,pi as makeWithdrawInstructionV6,Xk as makeWithdrawTokenInstruction,Iw as mockCreatePoolInfo,Lc as mockV3CreatePoolInfo,yp as modelDataInfoLayout,Oc as mostSignificantBit,rc as parseTokenAccountResp,yh as parseTokenInfo,Fn as poolTypeV6,Ya as purchaseLayout,hd as realFarmStateV3Layout,Id as realFarmStateV5Layout,Bd as realFarmV6Layout,La as removeLiquidityInstruction,Ra as removeLiquidityLayout,MS as route1Instruction,vS as route2Instruction,Hp as routeInstruction,El as sellExactInInstruction,Dl as sellExactOut,Wh as simulatePoolInfoInstruction,gh as solToWSolToken,nn as splAccountLayout,FS as swapBaseInAutoAccount,VS as swapBaseOutAutoAccount,_r as toAmmComputePoolInfo,yt as toApiV3Token,Vn as toFeeConfig,Nr as toToken,Bi as toTokenAmount,bh as toTokenInfo,fa as trailingZeros,Rr as u16ToBytes,Kw as u32ToBytes,cf as u8ToBytes,XR as unionArr,Od as updateFarmPoolInfo,ql as updatePlatformConfig,na as validateFarmRewards,qd as voterStakeRegistryCreateDepositEntry,Wd as voterStakeRegistryCreateVoter,Vd as voterStakeRegistryDeposit,_d as voterStakeRegistryUpdateVoterWeightRecord,Ed as voterStakeRegistryWithdraw,Ah as wSolToSolToken,Hs as withdrawRewardLayout};
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
//# sourceMappingURL=index.mjs.map