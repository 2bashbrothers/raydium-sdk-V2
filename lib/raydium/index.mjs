var Wl=Object.defineProperty,ql=Object.defineProperties;var Ul=Object.getOwnPropertyDescriptors;var ji=Object.getOwnPropertySymbols;var pu=Object.prototype.hasOwnProperty,fu=Object.prototype.propertyIsEnumerable;var du=(c,e,t)=>e in c?Wl(c,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):c[e]=t,N=(c,e)=>{for(var t in e||(e={}))pu.call(e,t)&&du(c,t,e[t]);if(ji)for(var t of ji(e))fu.call(e,t)&&du(c,t,e[t]);return c},q=(c,e)=>ql(c,Ul(e));var qe=(c,e)=>{var t={};for(var n in c)pu.call(c,n)&&e.indexOf(n)<0&&(t[n]=c[n]);if(c!=null&&ji)for(var n of ji(c))e.indexOf(n)<0&&fu.call(c,n)&&(t[n]=c[n]);return t};import{merge as sf}from"lodash";import Fu from"axios";import{PublicKey as gu}from"@solana/web3.js";import{get as yu,set as Gl}from"lodash";var la=class{constructor(e){this.logLevel=e.logLevel!==void 0?e.logLevel:0,this.name=e.name}set level(e){this.logLevel=e}get time(){return Date.now().toString()}get moduleName(){return this.name}isLogLevel(e){return e<=this.logLevel}error(...e){return this.isLogLevel(0)?(console.error(this.time,this.name,"sdk logger error",...e),this):this}logWithError(...e){let t=e.map(n=>typeof n=="object"?JSON.stringify(n):n).join(", ");throw new Error(t)}warning(...e){return this.isLogLevel(1)?(console.warn(this.time,this.name,"sdk logger warning",...e),this):this}info(...e){return this.isLogLevel(2)?(console.info(this.time,this.name,"sdk logger info",...e),this):this}debug(...e){return this.isLogLevel(3)?(console.debug(this.time,this.name,"sdk logger debug",...e),this):this}},bu={},Xl={};function fe(c){let e=yu(bu,c);if(!e){let t=yu(Xl,c);e=new la({name:c,logLevel:t}),Gl(bu,c,e)}return e}import{MINT_SIZE as zl,TOKEN_PROGRAM_ID as Ql,getTransferFeeConfig as Yl,unpackMint as jl}from"@solana/spl-token";var ma=fe("Raydium_accountInfo_util");async function Yt(c,e,t){let{batchRequest:n,commitment:o="confirmed",chunkCount:r=100}=N({batchRequest:!1},t),i=da(e,r),a=new Array(i.length).fill([]);if(n){let u=i.map(d=>{let p=c._buildArgs([d.map(m=>m.toBase58())],o,"base64");return{methodName:"getMultipleAccounts",args:p}}),s=da(u,10);a=(await(await Promise.all(s.map(async d=>await c._rpcBatchRequest(d)))).flat()).map(d=>(d.error&&ma.logWithError(`failed to get info for multiple accounts, RPC_ERROR, ${d.error.message}`),d.result.value.map(p=>{if(p){let{data:m,executable:f,lamports:y,owner:b,rentEpoch:g}=p;return m.length!==2&&m[1]!=="base64"&&ma.logWithError("info must be base64 encoded, RPC_ERROR"),{data:Buffer.from(m[0],"base64"),executable:f,lamports:y,owner:new gu(b),rentEpoch:g}}return null})))}else try{a=await Promise.all(i.map(u=>c.getMultipleAccountsInfo(u,o)))}catch(u){u instanceof Error&&ma.logWithError(`failed to get info for multiple accounts, RPC_ERROR, ${u.message}`)}return a.flat()}async function Oe(c,e,t){let n=await Yt(c,e.map(o=>o.pubkey),t);return e.map((o,r)=>q(N({},o),{accountInfo:n[r]}))}async function po({connection:c,mints:e,config:t}){var r,i,a;if(e.length===0)return{};let n=await Oe(c,e.map(u=>({pubkey:mt(u)})),t),o={};for(let u of n){if(!u.accountInfo||u.accountInfo.data.length<zl){console.log("invalid mint account",u.pubkey.toBase58());continue}let s=jl(u.pubkey,u.accountInfo,(r=u.accountInfo)==null?void 0:r.owner);o[u.pubkey.toString()]=q(N({},s),{programId:((i=u.accountInfo)==null?void 0:i.owner)||Ql,feeConfig:(a=Yl(s))!=null?a:void 0})}return o[gu.default.toBase58()]=o[H.toBase58()],o}import un from"bn.js";import jy from"decimal.js";import om from"big.js";import $i from"bn.js";import Hl from"toformat";var Zl=Hl,Uo=Zl;import Zi from"big.js";import Jl from"bn.js";import em from"decimal.js-light";import Go from"bn.js";var Au=9007199254740991;function J(c){let e=fe("Raydium_parseBigNumberish");if(c instanceof Go)return c;if(typeof c=="string"){if(c.match(/^-?[0-9]+$/))return new Go(c);e.logWithError(`invalid BigNumberish string: ${c}`)}return typeof c=="number"?(c%1&&e.logWithError(`BigNumberish number underflow: ${c}`),(c>=Au||c<=-Au)&&e.logWithError(`BigNumberish number overflow: ${c}`),new Go(String(c))):typeof c=="bigint"?new Go(c.toString()):(e.error(`invalid BigNumberish value: ${c}`),new Go(0))}var Hi=fe("module/fraction"),pa=Uo(Zi),Xo=Uo(em),tm={[0]:Xo.ROUND_DOWN,[1]:Xo.ROUND_HALF_UP,[2]:Xo.ROUND_UP},nm={[0]:Zi.roundDown,[1]:Zi.roundHalfUp,[2]:Zi.roundUp},Te=class{constructor(e,t=new Jl(1)){this.numerator=J(e),this.denominator=J(t)}get quotient(){return this.numerator.div(this.denominator)}invert(){return new Te(this.denominator,this.numerator)}add(e){let t=e instanceof Te?e:new Te(J(e));return this.denominator.eq(t.denominator)?new Te(this.numerator.add(t.numerator),this.denominator):new Te(this.numerator.mul(t.denominator).add(t.numerator.mul(this.denominator)),this.denominator.mul(t.denominator))}sub(e){let t=e instanceof Te?e:new Te(J(e));return this.denominator.eq(t.denominator)?new Te(this.numerator.sub(t.numerator),this.denominator):new Te(this.numerator.mul(t.denominator).sub(t.numerator.mul(this.denominator)),this.denominator.mul(t.denominator))}mul(e){let t=e instanceof Te?e:new Te(J(e));return new Te(this.numerator.mul(t.numerator),this.denominator.mul(t.denominator))}div(e){let t=e instanceof Te?e:new Te(J(e));return new Te(this.numerator.mul(t.denominator),this.denominator.mul(t.numerator))}toSignificant(e,t={groupSeparator:""},n=1){Number.isInteger(e)||Hi.logWithError(`${e} is not an integer.`),e<=0&&Hi.logWithError(`${e} is not positive.`),Xo.set({precision:e+1,rounding:tm[n]});let o=new Xo(this.numerator.toString()).div(this.denominator.toString()).toSignificantDigits(e);return o.toFormat(o.decimalPlaces(),t)}toFixed(e,t={groupSeparator:""},n=1){return Number.isInteger(e)||Hi.logWithError(`${e} is not an integer.`),e<0&&Hi.logWithError(`${e} is negative.`),pa.DP=e,pa.RM=nm[n]||1,new pa(this.numerator.toString()).div(this.denominator.toString()).toFormat(e,t)}isZero(){return this.numerator.isZero()}};var im=fe("Raydium_amount"),Pu=Uo(om);function rm(c,e){let t="0",n="0";if(c.includes(".")){let o=c.split(".");o.length===2?([t,n]=o,n=n.padEnd(e,"0")):im.logWithError(`invalid number string, num: ${c}`)}else t=c;return[t,n.slice(0,e)||n]}var Se=class extends Te{constructor(t,n,o=!0,r){let i=new $i(0),a=fa.pow(new $i(t.decimals));if(o)i=J(n);else{let u=new $i(0),s=new $i(0);if(typeof n=="string"||typeof n=="number"||typeof n=="bigint"){let[l,d]=rm(n.toString(),t.decimals);u=J(l),s=J(d)}u=u.mul(a),i=u.add(s)}super(i,a);this.logger=fe(r||"TokenAmount"),this.token=t}get raw(){return this.numerator}isZero(){return this.raw.isZero()}gt(t){return this.token.equals(t.token)||this.logger.logWithError("gt token not equals"),this.raw.gt(t.raw)}lt(t){return this.token.equals(t.token)||this.logger.logWithError("lt token not equals"),this.raw.lt(t.raw)}add(t){return this.token.equals(t.token)||this.logger.logWithError("add token not equals"),new Se(this.token,this.raw.add(t.raw))}subtract(t){return this.token.equals(t.token)||this.logger.logWithError("sub token not equals"),new Se(this.token,this.raw.sub(t.raw))}toSignificant(t=this.token.decimals,n,o=0){return super.toSignificant(t,n,o)}toFixed(t=this.token.decimals,n,o=0){return t>this.token.decimals&&this.logger.logWithError("decimals overflow"),super.toFixed(t,n,o)}toExact(t={groupSeparator:""}){return Pu.DP=this.token.decimals,new Pu(this.numerator.toString()).div(this.denominator.toString()).toFormat(t)}};import{PublicKey as am}from"@solana/web3.js";import{TOKEN_PROGRAM_ID as ku}from"@solana/spl-token";var an={chainId:101,address:am.default.toBase58(),programId:ku.toBase58(),decimals:9,symbol:"SOL",name:"solana",logoURI:"https://img-v1.raydium.io/icon/So11111111111111111111111111111111111111112.png",tags:[],priority:2,type:"raydium",extensions:{coingeckoId:"solana"}},nt={chainId:101,address:"So11111111111111111111111111111111111111112",programId:ku.toBase58(),decimals:9,symbol:"WSOL",name:"Wrapped SOL",logoURI:"https://img-v1.raydium.io/icon/So11111111111111111111111111111111111111112.png",tags:[],priority:2,type:"raydium",extensions:{coingeckoId:"solana"}};import{PublicKey as Pa}from"@solana/web3.js";import{PublicKey as Ee,SystemProgram as wu,SYSVAR_RENT_PUBKEY as sm}from"@solana/web3.js";import{TOKEN_PROGRAM_ID as um}from"@solana/spl-token";function A({pubkey:c,isSigner:e=!1,isWritable:t=!0}){return{pubkey:c,isWritable:t,isSigner:e}}var ya=[A({pubkey:um,isWritable:!1}),A({pubkey:wu.programId,isWritable:!1}),A({pubkey:sm,isWritable:!1})];function ba({publicKey:c,transformSol:e}){let t=ga(c.toString());if(t instanceof Ee)return e&&t.equals(ot)?H:t;if(e&&t.toString()===ot.toBase58())return H;if(typeof t=="string"){if(t===Ee.default.toBase58())return Ee.default;try{return new Ee(t)}catch{throw new Error("invalid public key")}}throw new Error("invalid public key")}function ga(c){try{return new Ee(c)}catch{return c}}var Ji=new Ee("MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr"),sn=new Ee("MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr"),Ze=new Ee("SysvarRent111111111111111111111111111111111"),Aa=new Ee("SysvarC1ock11111111111111111111111111111111"),jt=new Ee("metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s"),er=new Ee("Sysvar1nstructions1111111111111111111111111"),tr=wu.programId,Jf=new Ee("4k3Dyjzvzp8eMZWUXbBCjEvwSkkk59S5iCNLY3QrkX6R"),ey=new Ee("Ea5SjE2Y6yvCeW5dYTn7PYMuW5ikXkvbGdcmSnXeaLjS"),ty=new Ee("SRMuApVNdxXokk5GT7XD5cUUgXMBCoAz2LHeuAoKWRt"),ny=new Ee("EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v"),oy=new Ee("Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB"),iy=new Ee("mSoLzYCxHdYgdzU16g5QSh3i5K3z3KZK7ytfqcJm7So"),ry=new Ee("7dHbWXmci3dT8UFYWYZweBLXgycu7Y3iL6trKn1Y7ARj"),ay=new Ee("USDH1SM1ojwWUga67PGrgFWUHibbjqMvuMaDkRJTgkX"),sy=new Ee("NRVwhjBQiUPYtfDT5zRBVJajzFQHaBUNtC7SNVvqRFa"),uy=new Ee("ANAxByE6G2WjFp7A4NqtWYXb3mgruyzZYg3spfxe6Lbo"),cy=new Ee("7vfCXTUXx5WJV5JADk17DUJ4ksgau7utNKj4b963voxs"),H=new Ee("So11111111111111111111111111111111111111112"),ot=Ee.default;function mt(c){return ba({publicKey:c,transformSol:!0})}var ka=class{constructor({mint:e,decimals:t,symbol:n,name:o,skipMint:r=!1,isToken2022:i=!1}){if(e===ot.toBase58()||e instanceof Pa&&ot.equals(e)){this.decimals=nt.decimals,this.symbol=nt.symbol,this.name=nt.name,this.mint=new Pa(nt.address),this.isToken2022=!1;return}this.decimals=t,this.symbol=n||e.toString().substring(0,6),this.name=o||e.toString().substring(0,6),this.mint=r?Pa.default:ba({publicKey:e}),this.isToken2022=i}equals(e){return this===e?!0:this.mint.equals(e.mint)}},De=ka;De.WSOL=new ka(q(N({},nt),{mint:nt.address}));var wa=class{constructor({decimals:e,symbol:t="UNKNOWN",name:n="UNKNOWN"}){this.decimals=e,this.symbol=t,this.name=n}equals(e){return this===e}},nr=wa;nr.SOL=new wa(an);import cm from"bn.js";var Tu=new Te(new cm(100)),it=class extends Te{toSignificant(e=5,t,n){return this.mul(Tu).toSignificant(e,t,n)}toFixed(e=2,t,n){return this.mul(Tu).toFixed(e,t,n)}};var lm=fe("Raydium_price"),ht=class extends Te{constructor(t){let{baseToken:n,quoteToken:o,numerator:r,denominator:i}=t;super(r,i);this.baseToken=n,this.quoteToken=o,this.scalar=new Te(Ta(n.decimals),Ta(o.decimals))}get raw(){return new Te(this.numerator,this.denominator)}get adjusted(){return super.mul(this.scalar)}invert(){return new ht({baseToken:this.quoteToken,quoteToken:this.baseToken,denominator:this.numerator,numerator:this.denominator})}mul(t){this.quoteToken!==t.baseToken&&lm.logWithError("mul token not equals");let n=super.mul(t);return new ht({baseToken:this.baseToken,quoteToken:t.quoteToken,denominator:n.denominator,numerator:n.numerator})}toSignificant(t=this.quoteToken.decimals,n,o){return this.adjusted.toSignificant(t,n,o)}toFixed(t=this.quoteToken.decimals,n,o){return this.adjusted.toFixed(t,n,o)}};import{PublicKey as mm}from"@solana/web3.js";import dm from"bn.js";function hu(c){return typeof c=="object"&&c!==null&&![De,Se,mm,Te,dm,ht,it].some(e=>typeof e=="object"&&c instanceof e)}function Me(c){return typeof c=="string"?ga(c):Array.isArray(c)?c.map(e=>Me(e)):hu(c)?Object.fromEntries(Object.entries(c).map(([e,t])=>[e,Me(t)])):c}var It=new un(0),Iu=new un(1),rb=new un(2),ab=new un(3),sb=new un(5),fa=new un(10),ub=new un(100),cb=new un(1e3),lb=new un(1e4);function Ta(c){return fa.pow(J(c))}function or(c,e){let t=c.divmod(e);return t.mod.isZero()?t.div:t.div.isNeg()?t.div.isubn(1):t.div.iaddn(1)}function ir(c,e,t){return c.mul(e).add(t).sub(new un(1)).div(t)}function ha(c,e,t){return c.mul(e).div(t)}var Bu=c=>typeof c=="number";function xu(c,e,t){let n=Bu(e)?e*((t==null?void 0:t.unit)==="s"?1e3:1):e;return new Date(c).getTime()<=n}function Su(c,e,t){let n=Bu(e)?e*((t==null?void 0:t.unit)==="s"?1e3:1):e;return new Date(c).getTime()>n}function da(c,e=1,t=[]){let n=[...c];if(e<=0)return t;for(;n.length;)t.push(n.splice(0,e));return t}var Ht=class{constructor(e){this._owner=e}get publicKey(){return Ht.isKeyPair(this._owner)?this._owner.publicKey:this._owner}get signer(){return Ht.isKeyPair(this._owner)?this._owner:void 0}get isKeyPair(){return Ht.isKeyPair(this._owner)}get isPublicKey(){return Ht.isPublicKey(this._owner)}static isKeyPair(e){return e.secretKey!==void 0}static isPublicKey(e){return!Ht.isKeyPair(e)}};import{PublicKey as Am}from"@solana/web3.js";import{TOKEN_PROGRAM_ID as Pm}from"@solana/spl-token";import{ComputeBudgetProgram as Ku,Keypair as Cu,PublicKey as Ru,Transaction as rr,TransactionMessage as pm,VersionedTransaction as Lu}from"@solana/web3.js";var U={CreateAccount:"CreateAccount",InitAccount:"InitAccount",CreateATA:"CreateATA",CloseAccount:"CloseAccount",TransferAmount:"TransferAmount",InitMint:"InitMint",MintTo:"MintTo",InitMarket:"InitMarket",Util1216OwnerClaim:"Util1216OwnerClaim",SetComputeUnitPrice:"SetComputeUnitPrice",SetComputeUnitLimit:"SetComputeUnitLimit",ClmmCreatePool:"ClmmCreatePool",ClmmOpenPosition:"ClmmOpenPosition",ClmmIncreasePosition:"ClmmIncreasePosition",ClmmDecreasePosition:"ClmmDecreasePosition",ClmmClosePosition:"ClmmClosePosition",ClmmSwapBaseIn:"ClmmSwapBaseIn",ClmmSwapBaseOut:"ClmmSwapBaseOut",ClmmInitReward:"ClmmInitReward",ClmmSetReward:"ClmmSetReward",ClmmCollectReward:"ClmmCollectReward",ClmmLockPosition:"ClmmLockPosition",ClmmHarvestLockPosition:"ClmmHarvestLockPosition",AmmV4Swap:"AmmV4Swap",AmmV4AddLiquidity:"AmmV4AddLiquidity",AmmV4RemoveLiquidity:"AmmV4RemoveLiquidity",AmmV4SimulatePoolInfo:"AmmV4SimulatePoolInfo",AmmV4SwapBaseIn:"AmmV4SwapBaseIn",AmmV4SwapBaseOut:"AmmV4SwapBaseOut",AmmV4CreatePool:"AmmV4CreatePool",AmmV4InitPool:"AmmV4InitPool",AmmV5AddLiquidity:"AmmV5AddLiquidity",AmmV5RemoveLiquidity:"AmmV5RemoveLiquidity",AmmV5SimulatePoolInfo:"AmmV5SimulatePoolInfo",AmmV5SwapBaseIn:"AmmV5SwapBaseIn",AmmV5SwapBaseOut:"AmmV5SwapBaseOut",RouteSwap:"RouteSwap",RouteSwap1:"RouteSwap1",RouteSwap2:"RouteSwap2",FarmV3Deposit:"FarmV3Deposit",FarmV3Withdraw:"FarmV3Withdraw",FarmV3CreateLedger:"FarmV3CreateLedger",FarmV4Withdraw:"FarmV4Withdraw",FarmV5Deposit:"FarmV5Deposit",FarmV5Withdraw:"FarmV5Withdraw",FarmV5CreateLedger:"FarmV5CreateLedger",FarmV6Deposit:"FarmV6Deposit",FarmV6Withdraw:"FarmV6Withdraw",FarmV6Create:"FarmV6Create",FarmV6Restart:"FarmV6Restart",FarmV6CreatorAddReward:"FarmV6CreatorAddReward",FarmV6CreatorWithdraw:"FarmV6CreatorWithdraw",CpmmCreatePool:"CpmmCreatePool",CpmmAddLiquidity:"CpmmAddLiquidity",CpmmWithdrawLiquidity:"CpmmWithdrawLiquidity",CpmmSwapBaseIn:"CpmmSwapBaseIn",CpmmSwapBaseOut:"CpmmSwapBaseOut",CpmmLockLp:"CpmmLockLp",CpmmCollectLockFee:"CpmmCollectLockFee",TransferTip:"TransferTip"};import{TOKEN_PROGRAM_ID as fm}from"@solana/spl-token";var yn=fe("Raydium_txUtil"),Ou=1644;function ar(c){let e=[],t=[];return c.microLamports&&(e.push(Ku.setComputeUnitPrice({microLamports:c.microLamports})),t.push(U.SetComputeUnitPrice)),c.units&&(e.push(Ku.setComputeUnitLimit({units:c.units})),t.push(U.SetComputeUnitLimit)),{instructions:e,instructionTypes:t}}async function fo(c,e){var n,o;let t=e!=null?e:"confirmed";return(o=await((n=c.getLatestBlockhash)==null?void 0:n.call(c,{commitment:t})))==null?void 0:o.blockhash}async function sr(c,e){return c.getSignatureStatuses([e]),new Promise((t,n)=>{let o=setTimeout(n,6e4);c.onSignature(e,r=>{if(clearTimeout(o),!r.err){t("");return}n(Object.assign(r.err,{txId:e}))},"confirmed")})}function ur(c,e){c.length<1&&yn.logWithError(`no instructions provided: ${c.toString()}`),e.length<1&&yn.logWithError(`no signers provided:, ${e.toString()}`);let t=new rr;t.recentBlockhash="11111111111111111111111111111111",t.feePayer=e[0],t.add(...c);try{return Buffer.from(t.serialize({verifySignatures:!1})).toString("base64").length<Ou}catch{return!1}}async function Nu(c,e,t,n=!0){let o=new Ru("RaydiumSimuLateTransaction11111111111111111"),r=[],i=new rr;i.feePayer=o;for(let s of e)ur([...i.instructions,s],[o])||(r.push(i),i=new rr,i.feePayer=o),i.add(s);i.instructions.length>0&&r.push(i);let a=[];try{if(a=await ym(c,r,n),a.find(s=>s.err!==null))throw Error("rpc simulateTransaction error")}catch(s){s instanceof Error&&yn.logWithError("failed to simulate for instructions","RPC_ERROR",{message:s.message})}let u=[];for(let s of a)if(yn.debug("simulate result:",s),s.logs){let l=s.logs.filter(d=>d&&d.includes(t));yn.debug("filteredLog:",u),l.length||yn.logWithError("simulate log not match keyword","keyword",t),u.push(...l)}return u}function Mu(c,e){let t=c.match(/{["\w:,]+}/g);return!t||t.length!==1?yn.logWithError(`simulate log fail to match json, keyword: ${e}`):t[0]}function bn(c,e){let n=new RegExp(`"${e}":(\\d+)`,"g").exec(c);return!n||n.length!==2?yn.logWithError(`simulate log fail to match key", key: ${e}`):n[1]}function ne(c,e){let[t,n]=Ru.findProgramAddressSync(c,e);return{publicKey:t,nonce:n}}async function ym(c,e,t){let n=[];if(t){let o=await c.getLatestBlockhash(),r=[];for(let s of e){s.recentBlockhash=o.blockhash,s.lastValidBlockHeight=o.lastValidBlockHeight;let d=s._compile().serialize(),m=s._serialize(d).toString("base64");r.push(m)}let i=r.map(s=>{let l=c._buildArgs([s],void 0,"base64");return{methodName:"simulateTransaction",args:l}}),a=[],u=20;for(let s=0;s<Math.ceil(i.length/u);s++)a.push(i.slice(s*u,(s+1)*u));n=await(await Promise.all(a.map(async s=>(await c._rpcBatchRequest(s)).map(l=>l.result.value)))).flat()}else try{n=await Promise.all(e.map(async o=>await(await c.simulateTransaction(o)).value))}catch(o){o instanceof Error&&yn.logWithError("failed to get info for multiple accounts","RPC_ERROR",{message:o.message})}return n}function zo({instructions:c,payer:e,signers:t}){return ur(c,[e,...t])}function Qo({instructions:c,payer:e,lookupTableAddressAccount:t,recentBlockhash:n=Cu.generate().publicKey.toString()}){let r=new pm({payerKey:e,recentBlockhash:n,instructions:c}).compileToV0Message(Object.values(t!=null?t:{}));try{return Buffer.from(new Lu(r).serialize()).toString("base64").length<Ou}catch{return!1}}var bm=c=>Buffer.isBuffer(c)?c:c instanceof Uint8Array?Buffer.from(c.buffer,c.byteOffset,c.byteLength):Buffer.from(c),gm=c=>{let e=c.serialize({requireAllSignatures:!1,verifySignatures:!1});c instanceof Lu&&(e=bm(e));try{return e instanceof Buffer?e.toString("base64"):Buffer.from(e).toString("base64")}catch{return e.toString("base64")}};function Un(c){let e=[];return c.forEach(t=>{t instanceof rr&&(t.recentBlockhash||(t.recentBlockhash=fm.toBase58()),t.feePayer||(t.feePayer=Cu.generate().publicKey)),e.push(gm(t))}),console.log("simulate tx string:",e),e}function j(c,e,t){return ne([c.toBuffer(),(t!=null?t:Pm).toBuffer(),e.toBuffer()],new Am("ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL"))}import{PublicKey as oe}from"@solana/web3.js";var Ia=new oe("EhhTKczWMGQt46ynNeRX1WfeagwwJd7ufHvCDjRxjo5Q"),Ba=new oe("CBuCnLe26faBpcBP2fktp4rp8abpcAnTWft6ZrP5Q4T"),xa=new oe("9KEPoZmtHUrBbhWN1v1KWLMkkvwY6WLtAVUCPRtRjP4z"),yo=new oe("FarmqiPv5eAj3j1GMdMCMUGXqPUvmquZtMy86QH6rzhG"),km=new oe("CLaimxFqjHzgTJtAGHU47NPhg6qrc5sCnpC4tBLyABQS"),Sa=new oe("srmqPvymJeFKQ4zGQed1GFppgkRHL9kaELCbyksJtPX"),cr=new oe("9xQeWvG816bUx9EPjHmaT23yvVM2ZWbrrpZb9PusVFin"),Yo=new oe("675kPX9MHTjS2zt1qfr1NYHuzeLXfQM9H24wFSUt1Mp8"),wm=new oe("5quBtoiQqxF9Jv6KYKctB59NT3gtJD2Y65kdnB1Uev3h"),lr=new oe("CDSr3ssLcRB6XYPJwAfFt18MZvEZp4LjHcvzBVZ45duo"),Sn=new oe("CAMMCzo5YL8w4VFF8KVHrK22GGUsp5VTaW7grrKgrWqK"),bo=new oe("LockrWmn6K5twhz3y9w1dQERbmgSaRkfnTeTKbpofwE"),jo=new oe("kN1kEznaF5Xbd8LYuqtEFcxzWSBk5Fv6ygX6SqEGJVy"),Kn=new oe("CDSr3ssLcRB6XYPJwAfFt18MZvEZp4LjHcvzBVZ45duo"),Tm=new oe("routeUGWgWzqBWFcrCfv8tritsqukccJPu3q5GPP3xS"),Ka=new oe("7YttLkHDoNj9wyDur5pM1ejNaAvT9X4eqaYcHQqtj2G5"),hm=new oe("6FJon3QE27qgPVggARueB22hLvoh22VzJpXv4rBEoSLF"),Im=new oe("CC12se5To1CdEuw7fDS27B7Geo5jJyL7t5UK2B44NgiH"),Bm=new oe("9HzJyW1qZsEiSfMUf6L2jo3CcTKAyBmSyKdwQeYisHrC"),xm=new oe("DropEU8AvevN3UrXWXTMuz3rqnMczQVNjq3kcSdW2SQi"),Ho=new oe("CPMMoo8L3F4NbTegBCKVNunggL7H1ZpdTHKxQB5qKP1C"),Ca=new oe("GpMZbSM2GgvTKHJirzeGfMFoaZ8UR2X7F4v8vHTvxFbL"),Sm=new oe("DNXgeM9EiiaAbaWvwjHj9fQQLAX5ZsfHyvmYUNRAdNC8"),Zo=new oe("LockrWmn6K5twhz3y9w1dQERbmgSaRkfnTeTKbpofwE"),$o=new oe("3f7GcQFG397GAaEnv51zR6tsTVihYRydnydDD1cXekxH"),rt=new oe("LanMV9sAd7wArD4vJFi2qDdfnVhFxYSUg6eADduJ3uj"),Km=new oe("WLHv2UAZm6z4KyaaELi5pjdbJh6RESMva1Rnn8pJVVh"),Lb=new oe("DRay6fNdQ5J82H7xV6uq2aV3mNrUZ1J4PgSKsWgptcm6"),Ob=new oe("5xqNaZXX5eUi4p5HU4oz9i5QnwRNT2y6oN7yyn4qENeq"),Cm=new oe("4Bu96XjU84XjPDSpveTVf6LYGCkfW5FK7SNkREWcEfV4"),Rm=new oe("6s1xP3hpbAfFoNtUNF8mfHsjr2Bd97JxFJRWLbL6aHuX"),Jo={IDO_PROGRAM_ID_V1:hm,IDO_PROGRAM_ID_V2:Im,IDO_PROGRAM_ID_V3:Bm,IDO_PROGRAM_ID_V4:xm},gt={AMM_V4:Yo,AMM_STABLE:wm,CLMM_PROGRAM_ID:Sn,CLMM_LOCK_PROGRAM_ID:bo,CLMM_LOCK_AUTH_ID:jo,FARM_PROGRAM_ID_V3:Ia,FARM_PROGRAM_ID_V4:Ba,FARM_PROGRAM_ID_V5:xa,FARM_PROGRAM_ID_V6:yo,OPEN_BOOK_PROGRAM:Sa,SERUM_PROGRAM_ID_V3:cr,UTIL1216:km,Router:Tm,CREATE_CPMM_POOL_PROGRAM:Ho,CREATE_CPMM_POOL_AUTH:Ca,CREATE_CPMM_POOL_FEE_ACC:Sm,LOCK_CPMM_PROGRAM:Zo,LOCK_CPMM_AUTH:$o,LAUNCHPAD_PROGRAM:rt,LAUNCHPAD_AUTH:Km,LAUNCHPAD_PLATFORM:Cm,LAUNCHPAD_CONFIG:Rm,FEE_DESTINATION_ID:Ka,MODEL_DATA_PUBKEY:Kn},gn={OPEN_BOOK_PROGRAM:new oe("EoTcMgcDRTJVZDMZWBoU6rhYHZfkNTVEAfz3uUJRcYGj"),SERUM_PROGRAM_ID_V3:new oe("Ray1111111111111111111111111111111111111111"),AMM_V4:new oe("DRaya7Kj3aMWQSy19kSjvmuwq9docCHofyP9kanQGaav"),AMM_STABLE:new oe("DRayDdXc1NZQ9C3hRWmoSf8zK4iapgMnjdNZWrfwsP8m"),CLMM_PROGRAM_ID:new oe("DRayAUgENGQBKVaX8owNhgzkEDyoHTGVEGHVJT1E9pfH"),CLMM_LOCK_PROGRAM_ID:new oe("DRay25Usp3YJAi7beckgpGUC7mGJ2cR1AVPxhYfwVCUX"),CLMM_LOCK_AUTH_ID:new oe("6Aoh8h2Lw2m5UGxYR8AdAL87jTWYeKoxM52mJRzfYwN"),CREATE_CPMM_POOL_PROGRAM:new oe("DRaycpLY18LhpbydsBWbVJtxpNv9oXPgjRSfpF2bWpYb"),CREATE_CPMM_POOL_AUTH:new oe("CXniRufdq5xL8t8jZAPxsPZDpuudwuJSPWnbcD5Y5Nxq"),CREATE_CPMM_POOL_FEE_ACC:new oe("3oE58BKVt8KuYkGxx8zBojugnymWmBiyafWgMrnb6eYy"),LOCK_CPMM_PROGRAM:new oe("DRay25Usp3YJAi7beckgpGUC7mGJ2cR1AVPxhYfwVCUX"),LOCK_CPMM_AUTH:new oe("7qWVV8UY2bRJfDLP4s37YzBPKUkVB46DStYJBpYbQzu3"),UTIL1216:oe.default,Router:new oe("DRaybByLpbUL57LJARs3j8BitTxVfzBg351EaMr5UTCd"),FARM_PROGRAM_ID_V3:new oe("DRayWyrLmEW5KEeqs8kdTMMaBabapqagaBC7KWpGtJeZ"),FARM_PROGRAM_ID_V4:new oe("Ray1111111111111111111111111111111111111111"),FARM_PROGRAM_ID_V5:new oe("DRayiCGSZgku1GTK6rXD6mVDdingXy6APAH1R6R5L2LC"),FARM_PROGRAM_ID_V6:new oe("DRayzbYakXs45ELHkzH6vC3fuhQqTAnv5A68gdFuvZyZ"),LAUNCHPAD_PROGRAM:new oe("DRay6fNdQ5J82H7xV6uq2aV3mNrUZ1J4PgSKsWgptcm6"),LAUNCHPAD_AUTH:new oe("5xqNaZXX5eUi4p5HU4oz9i5QnwRNT2y6oN7yyn4qENeq"),LAUNCHPAD_PLATFORM:new oe("2Jx4KTDrVSdWNazuGpcA8n3ZLTRGGBDxAWhuKe2Xcj2a"),LAUNCHPAD_CONFIG:new oe("7ZR4zD7PYfY2XxoG1Gxcy2EgEeGYrpxrwzPuwdUBssEt"),FEE_DESTINATION_ID:new oe("9y8ENuuZ3b19quffx9hQvRVygG5ky6snHfRvGpuSfeJy"),MODEL_DATA_PUBKEY:new oe("Ray1111111111111111111111111111111111111111")};import ve from"bn.js";var cn=1e4;function he(c,e,t,n){if(e===void 0)return{amount:c,fee:void 0,expirationTime:void 0};let o=q(N({},e),{olderTransferFee:{epoch:BigInt(e.olderTransferFee.epoch),maximumFee:BigInt(e.olderTransferFee.maximumFee),transferFeeBasisPoints:e.olderTransferFee.transferFeeBasisPoints},newerTransferFee:{epoch:BigInt(e.newerTransferFee.epoch),maximumFee:BigInt(e.newerTransferFee.maximumFee),transferFeeBasisPoints:e.newerTransferFee.transferFeeBasisPoints}}),r=t.epoch<o.newerTransferFee.epoch?o.olderTransferFee:o.newerTransferFee,i=new ve(r.maximumFee.toString()),a=t.epoch<o.newerTransferFee.epoch?(Number(o.newerTransferFee.epoch)*t.slotsInEpoch-t.absoluteSlot)*400/1e3:void 0;if(n)if(r.transferFeeBasisPoints===cn){let u=new ve(r.maximumFee.toString());return{amount:c.add(u),fee:u,expirationTime:a}}else{let u=Zt(c.mul(new ve(cn)),new ve(cn-r.transferFeeBasisPoints)),s=new ve(r.maximumFee.toString()),l=u.sub(c).gt(s)?c.add(s):u,d=Zt(l.mul(new ve(r.transferFeeBasisPoints)),new ve(cn)),p=d.gt(i)?i:d;return{amount:l,fee:p,expirationTime:a}}else{let u=Zt(c.mul(new ve(r.transferFeeBasisPoints)),new ve(cn)),s=u.gt(i)?i:u;return{amount:c,fee:s,expirationTime:a}}}function $t(c,e){return c===void 0?e:e===void 0?c:Math.min(c,e)}function Zt(c,e){let{div:t,mod:n}=c.divmod(e);return n.gt(new ve(0))?t.add(new ve(1)):t}function Gn(c,e){if(c.isZero())return new ve(0);let t=c.div(e);return t.isZero()?new ve(1):c.mod(e).gt(new ve(0))?t.add(new ve(1)):t}function Ra(c,e,t){if(e===void 0)return{amount:c,fee:void 0,expirationTime:void 0};let n=Math.floor(t/432e3),o=n<e.newerTransferFee.epoch?e.olderTransferFee:e.newerTransferFee,r=new ve(o.maximumFee.toString()),i=n<e.newerTransferFee.epoch?(Number(e.newerTransferFee.epoch)*432e3-t)*400/1e3:void 0,a=Zt(c.mul(new ve(o.transferFeeBasisPoints)),new ve(cn)),u=a.gt(r)?r:a;return{amount:c,fee:u,expirationTime:i}}function La(c,e,t){if(e===void 0)return{amount:c,fee:void 0,expirationTime:void 0};let n=Math.floor(t/432e3),o=n<e.newerTransferFee.epoch?e.olderTransferFee:e.newerTransferFee,r=new ve(o.maximumFee.toString()),i=n<e.newerTransferFee.epoch?(Number(e.newerTransferFee.epoch)*432e3-t)*400/1e3:void 0;if(o.transferFeeBasisPoints===cn){let a=new ve(o.maximumFee.toString());return{amount:c.add(a),fee:a,expirationTime:i}}else{let a=Zt(c.mul(new ve(cn)),new ve(cn-o.transferFeeBasisPoints)),u=new ve(o.maximumFee.toString()),s=a.sub(c).gt(u)?c.add(u):a,l=Zt(s.mul(new ve(o.transferFeeBasisPoints)),new ve(cn)),d=l.gt(r)?r:l;return{amount:s,fee:d,expirationTime:i}}}import{PublicKey as Oa,AddressLookupTableAccount as Ao}from"@solana/web3.js";async function Na({connection:c,address:e,cluster:t="mainnet"}){let n=await Yt(c,[...new Set(e.map(r=>r.toString()))].map(r=>new Oa(r))),o={};for(let r=0;r<e.length;r++){let i=n[r],a=e[r];if(!i)continue;let u=new Ao({key:a,state:Ao.deserialize(i.data)});o[a.toString()]=u,t==="devnet"?go[a.toString()]=u:mr[a.toString()]=u}return o}var mr={AcL1Vo8oy1ULiavEcjSUcwfBSForXMudcZvDZy5nzJkU:new Ao({key:new Oa("AcL1Vo8oy1ULiavEcjSUcwfBSForXMudcZvDZy5nzJkU"),state:Ao.deserialize(Buffer.from("AQAAAP//////////I1rcEwAAAAAvAQYwun9CU6c5Ikm2pAj+D9IEnCOR45nK+SFTGSdpd6J6AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAbd9uHXZaGT2cvhRs7reawctIXtX1s3kTqM9YV+/wCpBt324e51j94YQl285GzN2rYa/E2DuQ0n/r35KNihi/wFSlNQ+F3IgtYUpVZyeIopbd8eq6vQpgZ4iEky9O72oAVKU1qZKSEGTSTocWDaOHx8NbXdvJK7geQfqEBBBUSNBqfVFxksXFEhjMlMPUrxf1ja7gibof1E49vZigAAAAAGp9UXGMd0yShWY5hpHV62i164o5tLbVxzVVshAAAAAIyXJY9OJInxuz0QKRSODYMLWhOZ2v8QhASOe9jb6fhZC3BlsePRfEU4nVJ/awTDzVi4bHMaoP21SbbRvAP4KUbIScv+6Yw2LHF/6K0ZjUPibbSWXCirYPGuuVl7zT789IUPLW4CpHr4JNCatp3ELXDLKMv6JJ+37le50lbBJ2LvBkX2T9y7AHdNGviJAqQNtlDUDCnauQRWybsLji6nPM8Qkw5asQRvCdB3MbX6IEBwytOrpM32l4jQygKG9TKgR0vZScQ2AsM/IHeQ7RajUkyhuZdc8SGiqQz/7H34torNR/Wir3sl0ruUrVxJWEZfUg+QLNAxxODdBi53/OP7Ioil1cqeBM9dtZC3FLov4yyxWRM/wcGStyJX/QfTnLBAHqkqWotPKVlShCVQqpP9W5W1rOao65IMk5QuQ2kMIOxzDMKAy2vjGSxQODgBz0QwGA+eP4ZjIjrIAQaXENv31QfLlOdXSRCkaybRniDHF4C8YcwhcvsqrOVuTP4B2Na+9wLdtrB31uz2rtlFI5kahdsnp/d1SrASDInYCtTYtdoke4kX+hoKWcEWM4Tle8pTUkUVv4BxS6fje/EzKBE4Qu/YsA/yfEEFGcr8Z57VKDw8uQzpiru7g4lvjnfapW62W030syevD8k07SGoxUHiuT/ai7gAHWWhDsVmg/C63ajgpkH7Sn3GdutArDTfyqOkdqv4/IPC/EFFy7mGkfDd2C57N5a/4jC+BbmJy7wQaSEZr0CQU88lPtUxIVvzGjC95b8Ooss2TqmkrayGKofkPMGQn7Ux+9lfwBSNfxwH8NgbpqC/7LNlV4I7nCvsXf3p+ohQk9NrAJb2KAFpUqEIJ9ZBV7BYDzHF/ORKYlgtvPnXjudZQ6CEo5OzUDaNIomTCCsvhD16TxJjsbgne1kGnQPCFSoaxUbq2V1bPMFQ3VYP6wDZ9bKStCFKx9A3tNbwZFC5ZGAN83MFK7XoTy+OmmcFEr6rLOjfSuTfPvHJkSVxW6Qllwkl67XcBi5v00u2gQsbu+38sp+rd5pA/LvyWj4P94ZGZwc1tE2P88xekCLcAwZGb+UhFzL/7K26csOb57yM5bvF9xJrLEObOkAAAAAn+HWRkdcPKyFFMnVwEoD7vnD0jCKFIU1sImubYCxNTSVzsKpaQX+fzNxrLAI3L14JQnJx/D6Uk2LADIHGqnGELzjEbkBDAlaM77NkXMPfqXNLSveCkWI7UEgNs31WEWB6XHSYI/v5DklHOb4QTtDOR804PVbi3fjloZeLR2F8d4FuZmMMO7ck3Fnkn2zEMG5gOmqsygb6PjTitArVl52NhcSznTxVnguaIJxiZkAnurDmn3MWR0PC2GLghp2KJqHCc6QQ85odeIjFHKOlRlJyeSXVJmL8vb1UgOzsbJPVP8p6zM4M3C1Sd7uWIHP33G42AP2Zg8ucn/n6meQjjD266JgCWdxZD6PXs9CsnIeL7SSG0/6lGb9xfP0ZcWkCXB/3hjxHYVXjra/GPOeXGk0fLLKjCbk+mgs2w6d2oCwimBipTzuoZ30GiI8ij8VRzD5CzMWtu2m21eDBIfjGAEo4pQeNNonKcqzV/cleX8ySZLOHsz8PtBCrLqF+VkLm9hOzIT+6i/nIf6keR4GWKMOD4AvqfpjHoD4DuhBpz8P28+DxkGrDXXr/nr20x291VPvcTU/b+b+o2kC9G0kcXeTlLjU6a2TQXWlZ4gBUdBl1jgT7mObSTpLblNiXZsLkbmVXZwvFKXua5cUKlWed/w30skmEUraTuQqtqr5fHZPW9n57EmeTif6LjHL2YJFZkQU+TrJmFzqzmF4/b8OwrPQAprl8mX3q4LUIdAS/a+11B6DWD1Xk2++Sn94dLC4xjkO4Wtlw8c4XuzciVbepHOmnoWzVu/0y3KCrLCSfQxQ3br8DJCoVzhgtPsS2nZZjsBGIZgnU0QpMv+2MnRsnKwdp1VsrCX84j/qvaZn4WhKunippgTbN2EUs0tPTP55Qfgj+nKmjtWW5IYs72FrEwJKYoNfsmqaF4o5pf4v9zgPwVwY/5I4XJKUL2L25m9kAQcW/K+H1RTFEUoj8Z4ajpOmAB/dG0COmCphVMW2CCMvnxhcGiSgPnpDuWu6qiJ7NG7ye5kvHgefgqPLeicspNJ5EpL3XiRNLM2tmJLI1awAwOyd6iHv0dCkMYRKaa6rcaZeYwmKCkckm0kM2JNmnmmAaBQQ7mwmIM0IMxX4f5W6j9PqZWcJxF7r17T/lQBAmcjoupRiJifbnXCNUv9GhpRF19WcBdeKbivRJVlGop6I2RS6lGImJ9udcI1S/0aGlEXX1ZwF14puK9ElWUainojZFYVHLHD6dIP2ESjqBzg3ol1/wB7+/ylGwd9LS7wSZ2A630CJSVKwH47K9P4bB8PEQP8BwjMFa7xQHOqZFP1XqaQ==","base64"))})},go={},Ma=async c=>{let e="EFhMuDw1PKEuckuFRW9PavNfTH4LKP5uKHgyXDmWpFCq";if(go[e])return go;let t=new Oa(e),n=await c.getAccountInfo(t);return n&&(go[e]=new Ao({key:t,state:Ao.deserialize(n.data)})),go};import{PublicKey as Po,sendAndConfirmTransaction as va,SystemProgram as Lm,Transaction as ei,TransactionMessage as ti,VersionedTransaction as ni}from"@solana/web3.js";import Om from"axios";var dr=2e3,pr=class{constructor(e){this.instructions=[];this.endInstructions=[];this.lookupTableAddress=[];this.signers=[];this.instructionTypes=[];this.endInstructionTypes=[];this.connection=e.connection,this.feePayer=e.feePayer,this.signAllTransactions=e.signAllTransactions,this.owner=e.owner,this.cluster=e.cluster,this.blockhashCommitment=e.blockhashCommitment,this.loopMultiTxStatus=!!e.loopMultiTxStatus}get AllTxData(){return{instructions:this.instructions,endInstructions:this.endInstructions,signers:this.signers,instructionTypes:this.instructionTypes,endInstructionTypes:this.endInstructionTypes,lookupTableAddress:this.lookupTableAddress}}get allInstructions(){return[...this.instructions,...this.endInstructions]}async getComputeBudgetConfig(){var n;let e=(await Om.get(`https://solanacompass.com/api/fees?cacheFreshTime=${3e5}`)).data,{avg:t}=(n=e==null?void 0:e[15])!=null?n:{};if(!!t)return{units:6e5,microLamports:Math.min(Math.ceil(t*1e6/6e5),25e3)}}addCustomComputeBudget(e){if(e){let{instructions:t,instructionTypes:n}=ar(e);return this.instructions.unshift(...t),this.instructionTypes.unshift(...n),!0}return!1}addTipInstruction(e){var t;return e?(this.endInstructions.push(Lm.transfer({fromPubkey:(t=e.feePayer)!=null?t:this.feePayer,toPubkey:new Po(e.address),lamports:BigInt(e.amount.toString())})),this.endInstructionTypes.push(U.TransferTip),!0):!1}async calComputeBudget({config:e,defaultIns:t}){try{let n=e||await this.getComputeBudgetConfig();if(this.addCustomComputeBudget(n))return;t&&this.instructions.unshift(...t)}catch{t&&this.instructions.unshift(...t)}}addInstruction({instructions:e=[],endInstructions:t=[],signers:n=[],instructionTypes:o=[],endInstructionTypes:r=[],lookupTableAddress:i=[]}){return this.instructions.push(...e),this.endInstructions.push(...t),this.signers.push(...n),this.instructionTypes.push(...o),this.endInstructionTypes.push(...r),this.lookupTableAddress.push(...i.filter(a=>a!==Po.default.toString())),this}async versionBuild({txVersion:e,extInfo:t}){return e===0?await this.buildV0(N({},t||{})):this.build(t)}build(e){var n;let t=new ei;return this.allInstructions.length&&t.add(...this.allInstructions),t.feePayer=this.feePayer,((n=this.owner)==null?void 0:n.signer)&&!this.signers.some(o=>o.publicKey.equals(this.owner.publicKey))&&this.signers.push(this.owner.signer),{builder:this,transaction:t,signers:this.signers,instructionTypes:[...this.instructionTypes,...this.endInstructionTypes],execute:async o=>{var l;let{recentBlockHash:r,skipPreflight:i=!0,sendAndConfirm:a,notSendToRpc:u}=o||{},s=r!=null?r:await fo(this.connection,this.blockhashCommitment);if(t.recentBlockhash=s,this.signers.length&&t.sign(...this.signers),Un([t]),(l=this.owner)!=null&&l.isKeyPair)return{txId:a?await va(this.connection,t,this.signers.find(p=>p.publicKey.equals(this.owner.publicKey))?this.signers:[...this.signers,this.owner.signer],{skipPreflight:i}):await this.connection.sendRawTransaction(t.serialize(),{skipPreflight:i}),signedTx:t};if(this.signAllTransactions){let d=await this.signAllTransactions([t]);if(this.signers.length)for(let p of d)try{p.sign(...this.signers)}catch{}return{txId:u?"":await this.connection.sendRawTransaction(d[0].serialize(),{skipPreflight:i}),signedTx:d[0]}}throw new Error("please provide owner in keypair format or signAllTransactions function")},extInfo:e||{}}}buildMultiTx(e){var s;let{extraPreBuildData:t=[],extInfo:n}=e,{transaction:o}=this.build(n),r=t.filter(l=>l.transaction.instructions.length>0),i=[o,...r.map(l=>l.transaction)],a=[this.signers,...r.map(l=>l.signers)],u=[...this.instructionTypes,...r.map(l=>l.instructionTypes).flat()];return(s=this.owner)!=null&&s.signer&&a.forEach(l=>{l.some(d=>d.publicKey.equals(this.owner.publicKey))||this.signers.push(this.owner.signer)}),{builder:this,transactions:i,signers:a,instructionTypes:u,execute:async l=>{var g;let{sequentially:d,onTxUpdate:p,skipTxCount:m=0,recentBlockHash:f,skipPreflight:y=!0}=l||{},b=f!=null?f:await fo(this.connection,this.blockhashCommitment);if((g=this.owner)!=null&&g.isKeyPair){if(d){let P=[],h=0;for(let I of i){if(++h,h<=m)continue;let T=await va(this.connection,I,this.signers.find(w=>w.publicKey.equals(this.owner.publicKey))?this.signers:[...this.signers,this.owner.signer],{skipPreflight:y});P.push(T)}return{txIds:P,signedTxs:i}}return{txIds:await await Promise.all(i.map(async P=>(P.recentBlockhash=b,await this.connection.sendRawTransaction(P.serialize(),{skipPreflight:y})))),signedTxs:i}}if(this.signAllTransactions){let P=i.map((I,T)=>(I.recentBlockhash=b,a[T].length&&I.sign(...a[T]),I));Un(P);let h=await this.signAllTransactions(P);if(d){let I=0,T=[],w=async()=>{if(!h[I])return;let x=await this.connection.sendRawTransaction(h[I].serialize(),{skipPreflight:y});T.push({txId:x,status:"sent",signedTx:h[I]}),p==null||p([...T]),I++;let S=!1,K=null,B=null,C=M=>{K!==null&&clearInterval(K),B!==null&&this.connection.removeSignatureListener(B);let F=T.findIndex(R=>R.txId===x);if(F>-1){if(T[F].status==="error"||T[F].status==="success")return;T[F].status=M.err?"error":"success"}p==null||p([...T]),M.err||w()};this.loopMultiTxStatus&&(K=setInterval(async()=>{var M;if(S){clearInterval(K);return}try{let F=await this.connection.getTransaction(x,{commitment:"confirmed",maxSupportedTransactionVersion:0});F&&(S=!0,clearInterval(K),C({err:((M=F.meta)==null?void 0:M.err)||null}),console.log("tx status from getTransaction:",x))}catch(F){S=!0,clearInterval(K),console.error("getTransaction timeout:",F,x)}},dr)),B=this.connection.onSignature(x,M=>{if(S){this.connection.removeSignatureListener(B);return}S=!0,C(M)},"confirmed"),this.connection.getSignatureStatus(x)};return await w(),{txIds:T.map(x=>x.txId),signedTxs:h}}else{let I=[];for(let T=0;T<h.length;T+=1){let w=await this.connection.sendRawTransaction(h[T].serialize(),{skipPreflight:y});I.push(w)}return{txIds:I,signedTxs:h}}}throw new Error("please provide owner in keypair format or signAllTransactions function")},extInfo:n||{}}}async versionMultiBuild({extraPreBuildData:e,txVersion:t,extInfo:n}){return t===0?await this.buildV0MultiTx({extraPreBuildData:e,buildProps:n||{}}):this.buildMultiTx({extraPreBuildData:e,extInfo:n})}async buildV0(e){var y;let f=e||{},{lookupTableCache:t={},lookupTableAddress:n=[],forerunCreate:o,recentBlockhash:r}=f,i=qe(f,["lookupTableCache","lookupTableAddress","forerunCreate","recentBlockhash"]),a=N(N({},this.cluster==="devnet"?await Ma(this.connection):mr),t),u=Array.from(new Set([...n,...this.lookupTableAddress])),s=[];for(let b of u)a[b]===void 0&&s.push(new Po(b));let l=await Na({connection:this.connection,address:s});for(let[b,g]of Object.entries(l))a[b]=g;let d=o?Po.default.toBase58():r!=null?r:await fo(this.connection,this.blockhashCommitment),p=new ti({payerKey:this.feePayer,recentBlockhash:d,instructions:[...this.allInstructions]}).compileToV0Message(Object.values(a));((y=this.owner)==null?void 0:y.signer)&&!this.signers.some(b=>b.publicKey.equals(this.owner.publicKey))&&this.signers.push(this.owner.signer);let m=new ni(p);return m.sign(this.signers),{builder:this,transaction:m,signers:this.signers,instructionTypes:[...this.instructionTypes,...this.endInstructionTypes],execute:async b=>{var I;let{skipPreflight:g=!0,sendAndConfirm:P,notSendToRpc:h}=b||{};if(Un([m]),(I=this.owner)!=null&&I.isKeyPair){let T=await this.connection.sendTransaction(m,{skipPreflight:g});return P&&await sr(this.connection,T),{txId:T,signedTx:m}}if(this.signAllTransactions){let T=await this.signAllTransactions([m]);if(this.signers.length)for(let w of T)try{w.sign(this.signers)}catch{}return{txId:h?"":await this.connection.sendTransaction(T[0],{skipPreflight:g}),signedTx:T[0]}}throw new Error("please provide owner in keypair format or signAllTransactions function")},extInfo:i||{}}}async buildV0MultiTx(e){var s;let{extraPreBuildData:t=[],buildProps:n}=e,{transaction:o}=await this.buildV0(n),r=t.filter(l=>l.builder.instructions.length>0),i=[o,...r.map(l=>l.transaction)],a=[this.signers,...r.map(l=>l.signers)],u=[...this.instructionTypes,...r.map(l=>l.instructionTypes).flat()];return(s=this.owner)!=null&&s.signer&&a.forEach(l=>{l.some(d=>d.publicKey.equals(this.owner.publicKey))||this.signers.push(this.owner.signer)}),i.forEach(async(l,d)=>{l.sign(a[d])}),{builder:this,transactions:i,signers:a,instructionTypes:u,buildProps:n,execute:async l=>{var y;let{sequentially:d,onTxUpdate:p,recentBlockHash:m,skipPreflight:f=!0}=l||{};if(m&&i.forEach(b=>b.message.recentBlockhash=m),Un(i),(y=this.owner)!=null&&y.isKeyPair){if(d){let b=[];for(let g of i){let P=await this.connection.sendTransaction(g,{skipPreflight:f});await sr(this.connection,P),b.push(P)}return{txIds:b,signedTxs:i}}return{txIds:await Promise.all(i.map(async b=>await this.connection.sendTransaction(b,{skipPreflight:f}))),signedTxs:i}}if(this.signAllTransactions){let b=await this.signAllTransactions(i);if(d){let g=0,P=[],h=async()=>{if(!b[g])return;let I=await this.connection.sendTransaction(b[g],{skipPreflight:f});P.push({txId:I,status:"sent",signedTx:b[g]}),p==null||p([...P]),g++;let T=!1,w=null,x=null,S=K=>{w!==null&&clearInterval(w),x!==null&&this.connection.removeSignatureListener(x);let B=P.findIndex(C=>C.txId===I);if(B>-1){if(P[B].status==="error"||P[B].status==="success")return;P[B].status=K.err?"error":"success"}p==null||p([...P]),K.err||h()};this.loopMultiTxStatus&&(w=setInterval(async()=>{var K;if(T){clearInterval(w);return}try{let B=await this.connection.getTransaction(I,{commitment:"confirmed",maxSupportedTransactionVersion:0});B&&(T=!0,clearInterval(w),S({err:((K=B.meta)==null?void 0:K.err)||null}),console.log("tx status from getTransaction:",I))}catch(B){T=!0,clearInterval(w),console.error("getTransaction timeout:",B,I)}},dr)),x=this.connection.onSignature(I,K=>{if(T){this.connection.removeSignatureListener(x);return}T=!0,S(K)},"confirmed"),this.connection.getSignatureStatus(I)};return h(),{txIds:[],signedTxs:b}}else{let g=[];for(let P=0;P<b.length;P+=1){let h=await this.connection.sendTransaction(b[P],{skipPreflight:f});g.push(h)}return{txIds:g,signedTxs:b}}}throw new Error("please provide owner in keypair format or signAllTransactions function")},extInfo:n||{}}}async sizeCheckBuild(e){var p;let d=e||{},{splitIns:t=[],computeBudgetConfig:n}=d,o=qe(d,["splitIns","computeBudgetConfig"]),r=n?ar(n):{instructions:[],instructionTypes:[]},i=this.signers.reduce((m,f)=>q(N({},m),{[f.publicKey.toBase58()]:f}),{}),a=[],u=[],s=[],l=0;if(this.allInstructions.forEach(m=>{let f=[...s,m],y=n?[...r.instructions,...f]:f,g=[...new Set(f.map(P=>P.keys.filter(h=>h.isSigner).map(h=>h.pubkey.toString())).flat()).values()].map(P=>new Po(P));if(m!==t[l]&&s.length<12&&(zo({instructions:y,payer:this.feePayer,signers:g})||zo({instructions:f,payer:this.feePayer,signers:g})))s.push(m);else{if(s.length===0)throw Error("item ins too big");l+=m===t[l]?1:0,zo({instructions:n?[...r.instructions,...s]:[...s],payer:this.feePayer,signers:g})?a.push(new ei().add(...r.instructions,...s)):a.push(new ei().add(...s)),u.push(Array.from(new Set(s.map(P=>P.keys.filter(h=>h.isSigner).map(h=>h.pubkey.toString())).flat())).map(P=>i[P]).filter(P=>P!==void 0)),s=[m]}}),s.length>0){let f=[...new Set(s.map(y=>y.keys.filter(b=>b.isSigner).map(b=>b.pubkey.toString())).flat()).values()].map(y=>i[y]).filter(y=>y!==void 0);zo({instructions:n?[...r.instructions,...s]:[...s],payer:this.feePayer,signers:f.map(y=>y.publicKey)})?a.push(new ei().add(...r.instructions,...s)):a.push(new ei().add(...s)),u.push(f)}return a.forEach(m=>m.feePayer=this.feePayer),(p=this.owner)!=null&&p.signer&&u.forEach(m=>{m.some(f=>f.publicKey.equals(this.owner.publicKey))||m.push(this.owner.signer)}),{builder:this,transactions:a,signers:u,instructionTypes:this.instructionTypes,execute:async m=>{var I;let{sequentially:f,onTxUpdate:y,skipTxCount:b=0,recentBlockHash:g,skipPreflight:P=!0}=m||{},h=g!=null?g:await fo(this.connection,this.blockhashCommitment);if(a.forEach(async(T,w)=>{T.recentBlockhash=h,u[w].length&&T.sign(...u[w])}),Un(a),(I=this.owner)!=null&&I.isKeyPair){if(f){let T=0,w=[];for(let x of a){if(++T,T<=b){w.push("tx skipped");continue}let S=await va(this.connection,x,this.signers.find(K=>K.publicKey.equals(this.owner.publicKey))?this.signers:[...this.signers,this.owner.signer],{skipPreflight:P});w.push(S)}return{txIds:w,signedTxs:a}}return{txIds:await Promise.all(a.map(async T=>await this.connection.sendRawTransaction(T.serialize(),{skipPreflight:P}))),signedTxs:a}}if(this.signAllTransactions){let T=await this.signAllTransactions(a.slice(b,a.length)),w=[...a.slice(0,b),...T];if(f){let x=0,S=[],K=async()=>{if(!w[x])return;x<b&&(S.push({txId:"",status:"success",signedTx:w[x]}),y==null||y([...S]),x++,K());let B=await this.connection.sendRawTransaction(w[x].serialize(),{skipPreflight:P});S.push({txId:B,status:"sent",signedTx:w[x]}),y==null||y([...S]),x++;let C=!1,M=null,F=null,R=L=>{M!==null&&clearInterval(M),F!==null&&this.connection.removeSignatureListener(F);let W=S.findIndex(z=>z.txId===B);if(W>-1){if(S[W].status==="error"||S[W].status==="success")return;S[W].status=L.err?"error":"success"}y==null||y([...S]),L.err||K()};this.loopMultiTxStatus&&(M=setInterval(async()=>{var L;if(C){clearInterval(M);return}try{let W=await this.connection.getTransaction(B,{commitment:"confirmed",maxSupportedTransactionVersion:0});W&&(C=!0,clearInterval(M),R({err:((L=W.meta)==null?void 0:L.err)||null}),console.log("tx status from getTransaction:",B))}catch(W){C=!0,clearInterval(M),console.error("getTransaction timeout:",W,B)}},dr)),F=this.connection.onSignature(B,L=>{if(C){this.connection.removeSignatureListener(F);return}C=!0,R(L)},"confirmed"),this.connection.getSignatureStatus(B)};return await K(),{txIds:S.map(B=>B.txId),signedTxs:w}}else{let x=[];for(let S=0;S<w.length;S+=1){let K=await this.connection.sendRawTransaction(w[S].serialize(),{skipPreflight:P});x.push(K)}return{txIds:x,signedTxs:w}}}throw new Error("please provide owner in keypair format or signAllTransactions function")},extInfo:o||{}}}async sizeCheckBuildV0(e){var h;let P=e||{},{computeBudgetConfig:t,splitIns:n=[],lookupTableCache:o={},lookupTableAddress:r=[]}=P,i=qe(P,["computeBudgetConfig","splitIns","lookupTableCache","lookupTableAddress"]),a=N(N({},this.cluster==="devnet"?await Ma(this.connection):mr),o),u=Array.from(new Set([...this.lookupTableAddress,...r])),s=[];for(let I of u)a[I]===void 0&&s.push(new Po(I));let l=await Na({connection:this.connection,address:s});for(let[I,T]of Object.entries(l))a[I]=T;let d=t?ar(t):{instructions:[],instructionTypes:[]},p=await fo(this.connection,this.blockhashCommitment),m=this.signers.reduce((I,T)=>q(N({},I),{[T.publicKey.toBase58()]:T}),{}),f=[],y=[],b=[],g=0;if(this.allInstructions.forEach(I=>{let T=[...b,I],w=t?[...d.instructions,...T]:T;if(I!==n[g]&&b.length<12&&(Qo({instructions:w,payer:this.feePayer,lookupTableAddressAccount:a})||Qo({instructions:T,payer:this.feePayer,lookupTableAddressAccount:a})))b.push(I);else{if(b.length===0)throw Error("item ins too big");g+=I===n[g]?1:0;let x={};for(let S of[...new Set(u)])a[S]!==void 0&&(x[S]=a[S]);if(t&&Qo({instructions:[...d.instructions,...b],payer:this.feePayer,lookupTableAddressAccount:a,recentBlockhash:p})){let S=new ti({payerKey:this.feePayer,recentBlockhash:p,instructions:[...d.instructions,...b]}).compileToV0Message(Object.values(a));f.push(new ni(S))}else{let S=new ti({payerKey:this.feePayer,recentBlockhash:p,instructions:[...b]}).compileToV0Message(Object.values(a));f.push(new ni(S))}y.push(Array.from(new Set(b.map(S=>S.keys.filter(K=>K.isSigner).map(K=>K.pubkey.toString())).flat())).map(S=>m[S]).filter(S=>S!==void 0)),b=[I]}}),b.length>0){let T=[...new Set(b.map(w=>w.keys.filter(x=>x.isSigner).map(x=>x.pubkey.toString())).flat()).values()].map(w=>m[w]).filter(w=>w!==void 0);if(t&&Qo({instructions:[...d.instructions,...b],payer:this.feePayer,lookupTableAddressAccount:a,recentBlockhash:p})){let w=new ti({payerKey:this.feePayer,recentBlockhash:p,instructions:[...d.instructions,...b]}).compileToV0Message(Object.values(a));f.push(new ni(w))}else{let w=new ti({payerKey:this.feePayer,recentBlockhash:p,instructions:[...b]}).compileToV0Message(Object.values(a));f.push(new ni(w))}y.push(T)}return(h=this.owner)!=null&&h.signer&&y.forEach(I=>{I.some(T=>T.publicKey.equals(this.owner.publicKey))||I.push(this.owner.signer)}),f.forEach((I,T)=>{I.sign(y[T])}),{builder:this,transactions:f,buildProps:e,signers:y,instructionTypes:this.instructionTypes,execute:async I=>{var B;let{sequentially:T,onTxUpdate:w,skipTxCount:x=0,recentBlockHash:S,skipPreflight:K=!0}=I||{};if(f.map(async(C,M)=>{y[M].length&&C.sign(y[M]),S&&(C.message.recentBlockhash=S)}),Un(f),(B=this.owner)!=null&&B.isKeyPair){if(T){let C=0,M=[];for(let F of f){if(++C,C<=x){console.log("skip tx: ",C),M.push("tx skipped");continue}let R=await this.connection.sendTransaction(F,{skipPreflight:K});await sr(this.connection,R),M.push(R)}return{txIds:M,signedTxs:f}}return{txIds:await Promise.all(f.map(async C=>await this.connection.sendTransaction(C,{skipPreflight:K}))),signedTxs:f}}if(this.signAllTransactions){let C=await this.signAllTransactions(f.slice(x,f.length)),M=[...f.slice(0,x),...C];if(T){let F=0,R=[],L=async()=>{if(!M[F])return;if(F<x){R.push({txId:"",status:"success",signedTx:M[F]}),w==null||w([...R]),F++,L();return}let W=await this.connection.sendTransaction(M[F],{skipPreflight:K});R.push({txId:W,status:"sent",signedTx:M[F]}),w==null||w([...R]),F++;let z=!1,$=null,ae=null,ye=ce=>{$!==null&&clearInterval($),ae!==null&&this.connection.removeSignatureListener(ae);let de=R.findIndex(pe=>pe.txId===W);if(de>-1){if(R[de].status==="error"||R[de].status==="success")return;R[de].status=ce.err?"error":"success"}w==null||w([...R]),ce.err||L()};this.loopMultiTxStatus&&($=setInterval(async()=>{var ce;if(z){clearInterval($);return}try{let de=await this.connection.getTransaction(W,{commitment:"confirmed",maxSupportedTransactionVersion:0});de&&(z=!0,clearInterval($),ye({err:((ce=de.meta)==null?void 0:ce.err)||null}),console.log("tx status from getTransaction:",W))}catch(de){z=!0,clearInterval($),console.error("getTransaction timeout:",de,W)}},dr)),ae=this.connection.onSignature(W,ce=>{if(z){this.connection.removeSignatureListener(ae);return}z=!0,ye(ce)},"confirmed"),this.connection.getSignatureStatus(W)};return L(),{txIds:[],signedTxs:M}}else{let F=[];for(let R=0;R<M.length;R+=1){let L=await this.connection.sendTransaction(M[R],{skipPreflight:K});F.push(L)}return{txIds:F,signedTxs:M}}}throw new Error("please provide owner in keypair format or signAllTransactions function")},extInfo:i||{}}}};import Nm from"bn.js";var Jt=new Nm(1e6);var at={BASE_HOST:"https://api-v3.raydium.io",OWNER_BASE_HOST:"https://owner-v1.raydium.io",SERVICE_BASE_HOST:"https://service.raydium.io",MONITOR_BASE_HOST:"https://monitor.raydium.io",SERVICE_1_BASE_HOST:"https://service-v1.raydium.io",SEND_TRANSACTION:"/send-transaction",FARM_ARP:"/main/farm/info",FARM_ARP_LINE:"/main/farm-apr-tv",CLMM_CONFIG:"/main/clmm-config",CPMM_CONFIG:"/main/cpmm-config",VERSION:"/main/version",CHECK_AVAILABILITY:"/v3/main/AvailabilityCheckAPI",RPCS:"/main/rpcs",INFO:"/main/info",STAKE_POOLS:"/main/stake-pools",CHAIN_TIME:"/main/chain-time",TOKEN_LIST:"/mint/list",MINT_INFO_ID:"/mint/ids",JUP_TOKEN_LIST:"https://lite-api.jup.ag/tokens/v1/tagged/verified",POOL_LIST:"/pools/info/list",POOL_SEARCH_BY_ID:"/pools/info/ids",POOL_SEARCH_MINT:"/pools/info/mint",POOL_SEARCH_LP:"/pools/info/lps",POOL_KEY_BY_ID:"/pools/key/ids",POOL_LIQUIDITY_LINE:"/pools/line/liquidity",POOL_POSITION_LINE:"/pools/line/position",FARM_INFO:"/farms/info/ids",FARM_LP_INFO:"/farms/info/lp",FARM_KEYS:"/farms/key/ids",OWNER_CREATED_FARM:"/create-pool/{owner}",OWNER_IDO:"/main/ido/{owner}",OWNER_STAKE_FARMS:"/position/stake/{owner}",OWNER_LOCK_POSITION:"/position/clmm-lock/{owner}",IDO_KEYS:"/ido/key/ids",SWAP_HOST:"https://transaction-v1.raydium.io",SWAP_COMPUTE:"/compute/",SWAP_TX:"/transaction/",MINT_PRICE:"/mint/price",MIGRATE_CONFIG:"/main/migrate-lp",PRIORITY_FEE:"/main/auto-fee",CPMM_LOCK:"https://dynamic-ipfs.raydium.io/lock/cpmm/position"},kg=N({},at);var vu="ray_tab_hash",Fa="ray_req_hash",Mm=()=>{if(typeof window===void 0)return"";let c=sessionStorage.getItem(vu);return c||(c=`ray-${Date.now()}`,sessionStorage.setItem(vu,c)),c},fr=async n=>{var o=n,{logCount:c=1e3,removeLastLog:e}=o,t=qe(o,["logCount","removeLastLog"]);if(typeof window===void 0)return new Promise(i=>i());let r=JSON.parse(localStorage.getItem(Fa)||"[]").slice(0,c-1);e&&r.pop(),new Blob([JSON.stringify(t.data)]).size>1024&&(t.data=JSON.stringify(t.data).substring(0,200)+"..."),r.unshift(q(N({},t),{time:Date.now(),session:Mm()}));try{localStorage.setItem(Fa,JSON.stringify(r))}catch{if(e){let i=!1,a=JSON.stringify(t.data).substring(0,100);for(r[0].data=a+(a.length>100?"...":"");!i;){r.pop();let u=JSON.stringify(t.data).substring(0,100);r[0].data=u+(u.length>100?"...":"");try{localStorage.setItem(Fa,JSON.stringify(r)),i=!0}catch{i=!1}}return new Promise(u=>u())}return fr(q(N({},t),{logCount:c,removeLastLog:!0}))}};import{TOKEN_2022_PROGRAM_ID as vm,TOKEN_PROGRAM_ID as Fm}from"@solana/spl-token";var yr=fe("Raydium_Api"),Va=new Map;var br=class{constructor({cluster:e,timeout:t,logRequests:n,logCount:o,urlConfigs:r}){this.cluster=e,this.urlConfigs=r||{},this.logCount=o||1e3,this.api=Fu.create({baseURL:this.urlConfigs.BASE_HOST||at.BASE_HOST,timeout:t}),this.api.interceptors.request.use(i=>{let{method:a,baseURL:u,url:s}=i;return yr.debug(`${a==null?void 0:a.toUpperCase()} ${u}${s}`),i},i=>(yr.error("Request failed"),Promise.reject(i))),this.api.interceptors.response.use(i=>{let{config:a,data:u,status:s}=i,{method:l,baseURL:d,url:p}=a;return n&&fr({status:s,url:`${d}${p}`,params:a.params,data:u,logCount:this.logCount}),yr.debug(`${l==null?void 0:l.toUpperCase()} ${d}${p}  ${s}`),u},i=>{let{config:a,response:u={}}=i,{status:s}=u,{method:l,baseURL:d,url:p}=a;return n&&fr({status:s,url:`${d}${p}`,params:a.params,data:i.message,logCount:this.logCount}),yr.error(`${l.toUpperCase()} ${d}${p} ${s||i.message}`),Promise.reject(i)})}async getClmmConfigs(){return(await this.api.get(this.urlConfigs.CLMM_CONFIG||at.CLMM_CONFIG)).data}async getCpmmConfigs(){return(await this.api.get(this.urlConfigs.CPMM_CONFIG||at.CPMM_CONFIG)).data}async getClmmPoolLines(e){return(await this.api.get(`${this.urlConfigs.POOL_LIQUIDITY_LINE||at.POOL_LIQUIDITY_LINE}?pool_id=${e}`)).data}async getBlockSlotCountForSecond(e){if(!e)return 2;let n=(await Fu.post(e,{id:"getRecentPerformanceSamples",jsonrpc:"2.0",method:"getRecentPerformanceSamples",params:[4]})).result.map(o=>o.numSlots);return n.reduce((o,r)=>o+r,0)/n.length/60}async getChainTimeOffset(){return(await this.api.get(this.urlConfigs.CHAIN_TIME||at.CHAIN_TIME)).data}async getRpcs(){return this.api.get(this.urlConfigs.RPCS||at.RPCS)}async getTokenList(){return(await this.api.get(this.urlConfigs.TOKEN_LIST||at.TOKEN_LIST)).data}async getJupTokenList(){return(await this.api.get("",{baseURL:this.urlConfigs.JUP_TOKEN_LIST||at.JUP_TOKEN_LIST})).map(t=>q(N({},t),{chainId:101,programId:t.tags.includes("token-2022")?vm.toBase58():Fm.toBase58()}))}async getTokenInfo(e){return(await this.api.get((this.urlConfigs.MINT_INFO_ID||at.MINT_INFO_ID)+`?mints=${e.map(n=>n.toString()).join(",")}`)).data}async getPoolList(e={}){let{type:t="all",sort:n="liquidity",order:o="desc",page:r=0,pageSize:i=100}=e;return(await this.api.get((this.urlConfigs.POOL_LIST||at.POOL_LIST)+`?poolType=${t}&poolSortField=${n}&sortType=${o}&page=${r}&pageSize=${i}`)).data}async fetchPoolById(e){let{ids:t}=e;return(await this.api.get((this.urlConfigs.POOL_SEARCH_BY_ID||at.POOL_SEARCH_BY_ID)+`?ids=${t}`)).data}async fetchPoolKeysById(e){let{idList:t}=e,n=[],o=t.filter(i=>Va.has(i)?(n.push(Va.get(i)),!1):!0),r=[];return o.length&&(r=(await this.api.get((this.urlConfigs.POOL_KEY_BY_ID||at.POOL_KEY_BY_ID)+`?ids=${o.join(",")}`)).data.filter(Boolean),r.forEach(a=>{Va.set(a.id,a)})),n.concat(r)}async fetchPoolByMints(e){let{mint1:t,mint2:n,type:o="all",sort:r="default",order:i="desc",page:a=1}=e,[u,s]=[t&&mt(t).toBase58(),n&&n!=="undefined"?mt(n).toBase58():""],[l,d]=s&&u>s?[s,u]:[u,s];return(await this.api.get((this.urlConfigs.POOL_SEARCH_MINT||at.POOL_SEARCH_MINT)+`?mint1=${l}&mint2=${d}&poolType=${o}&poolSortField=${r}&sortType=${i}&pageSize=100&page=${a}`)).data}async fetchFarmInfoById(e){let{ids:t}=e;return(await this.api.get((this.urlConfigs.FARM_INFO||at.FARM_INFO)+`?ids=${t}`)).data}async fetchFarmKeysById(e){let{ids:t}=e;return(await this.api.get((this.urlConfigs.FARM_KEYS||at.FARM_KEYS)+`?ids=${t}`)).data}async fetchAvailabilityStatus(){return(await this.api.get(this.urlConfigs.CHECK_AVAILABILITY||at.CHECK_AVAILABILITY)).data}};var gr="please provide owner in load() initialization or you can set by calling raydium.setOwner(owner)",Vu="please provide connection in load() initialization or set it by raydium.setConnection(connection)";import{PublicKey as Ir,SystemProgram as pd}from"@solana/web3.js";import{AccountLayout as ho,createAssociatedTokenAccountIdempotentInstruction as Qa,TOKEN_PROGRAM_ID as On,TOKEN_2022_PROGRAM_ID as fd}from"@solana/spl-token";var _a=(...c)=>c.map(e=>{try{return typeof e=="object"?JSON.stringify(e):e}catch{return e}}).join(", "),Fe=class{constructor({scope:e,moduleName:t}){this.disabled=!1;this.scope=e,this.logger=fe(t)}createTxBuilder(e){return this.scope.checkOwner(),new pr({connection:this.scope.connection,feePayer:e||this.scope.ownerPubKey,cluster:this.scope.cluster,owner:this.scope.owner,blockhashCommitment:this.scope.blockhashCommitment,loopMultiTxStatus:this.scope.loopMultiTxStatus,api:this.scope.api,signAllTransactions:this.scope.signAllTransactions})}logDebug(...e){this.logger.debug(_a(e))}logInfo(...e){this.logger.info(_a(e))}logAndCreateError(...e){let t=_a(e);throw new Error(t)}checkDisabled(){(this.disabled||!this.scope)&&this.logAndCreateError("module not working")}};import{PublicKey as sd,SystemProgram as ud}from"@solana/web3.js";import cd from"bn.js";import{createCloseAccountInstruction as ld,createInitializeAccountInstruction as md,createTransferInstruction as dd,TOKEN_PROGRAM_ID as To}from"@solana/spl-token";import{Keypair as od,PublicKey as $u}from"@solana/web3.js";import id from"bn.js";import{TOKEN_PROGRAM_ID as rd}from"@solana/spl-token";function Vm(c){return c instanceof Uint8Array||c!=null&&typeof c=="object"&&c.constructor.name==="Uint8Array"}function Ea(c,...e){if(!Vm(c))throw new Error("Uint8Array expected");if(e.length>0&&!e.includes(c.length))throw new Error(`Uint8Array expected of length ${e}, not of length=${c.length}`)}function Da(c,e=!0){if(c.destroyed)throw new Error("Hash instance has been destroyed");if(e&&c.finished)throw new Error("Hash#digest() has already been called")}function _u(c,e){Ea(c);let t=e.outputLen;if(c.length<t)throw new Error(`digestInto() expects output buffer of length at least ${t}`)}var Pr=c=>new DataView(c.buffer,c.byteOffset,c.byteLength),en=(c,e)=>c<<32-e|c>>>e;var rA=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;function _m(c){if(typeof c!="string")throw new Error(`utf8ToBytes expected string, got ${typeof c}`);return new Uint8Array(new TextEncoder().encode(c))}function Wa(c){return typeof c=="string"&&(c=_m(c)),Ea(c),c}var Ar=class{clone(){return this._cloneInto()}},aA={}.toString;function Eu(c){let e=n=>c().update(Wa(n)).digest(),t=c();return e.outputLen=t.outputLen,e.blockLen=t.blockLen,e.create=()=>c(),e}function Em(c,e,t,n){if(typeof c.setBigUint64=="function")return c.setBigUint64(e,t,n);let o=BigInt(32),r=BigInt(4294967295),i=Number(t>>o&r),a=Number(t&r),u=n?4:0,s=n?0:4;c.setUint32(e+u,i,n),c.setUint32(e+s,a,n)}var Du=(c,e,t)=>c&e^~c&t,Wu=(c,e,t)=>c&e^c&t^e&t,kr=class extends Ar{constructor(e,t,n,o){super(),this.blockLen=e,this.outputLen=t,this.padOffset=n,this.isLE=o,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(e),this.view=Pr(this.buffer)}update(e){Da(this);let{view:t,buffer:n,blockLen:o}=this;e=Wa(e);let r=e.length;for(let i=0;i<r;){let a=Math.min(o-this.pos,r-i);if(a===o){let u=Pr(e);for(;o<=r-i;i+=o)this.process(u,i);continue}n.set(e.subarray(i,i+a),this.pos),this.pos+=a,i+=a,this.pos===o&&(this.process(t,0),this.pos=0)}return this.length+=e.length,this.roundClean(),this}digestInto(e){Da(this),_u(e,this),this.finished=!0;let{buffer:t,view:n,blockLen:o,isLE:r}=this,{pos:i}=this;t[i++]=128,this.buffer.subarray(i).fill(0),this.padOffset>o-i&&(this.process(n,0),i=0);for(let d=i;d<o;d++)t[d]=0;Em(n,o-8,BigInt(this.length*8),r),this.process(n,0);let a=Pr(e),u=this.outputLen;if(u%4)throw new Error("_sha2: outputLen should be aligned to 32bit");let s=u/4,l=this.get();if(s>l.length)throw new Error("_sha2: outputLen bigger than state");for(let d=0;d<s;d++)a.setUint32(4*d,l[d],r)}digest(){let{buffer:e,outputLen:t}=this;this.digestInto(e);let n=e.slice(0,t);return this.destroy(),n}_cloneInto(e){e||(e=new this.constructor),e.set(...this.get());let{blockLen:t,buffer:n,length:o,finished:r,destroyed:i,pos:a}=this;return e.length=o,e.pos=a,e.finished=r,e.destroyed=i,o%t&&e.buffer.set(n),e}};var Dm=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),Cn=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),Rn=new Uint32Array(64),qa=class extends kr{constructor(){super(64,32,8,!1),this.A=Cn[0]|0,this.B=Cn[1]|0,this.C=Cn[2]|0,this.D=Cn[3]|0,this.E=Cn[4]|0,this.F=Cn[5]|0,this.G=Cn[6]|0,this.H=Cn[7]|0}get(){let{A:e,B:t,C:n,D:o,E:r,F:i,G:a,H:u}=this;return[e,t,n,o,r,i,a,u]}set(e,t,n,o,r,i,a,u){this.A=e|0,this.B=t|0,this.C=n|0,this.D=o|0,this.E=r|0,this.F=i|0,this.G=a|0,this.H=u|0}process(e,t){for(let d=0;d<16;d++,t+=4)Rn[d]=e.getUint32(t,!1);for(let d=16;d<64;d++){let p=Rn[d-15],m=Rn[d-2],f=en(p,7)^en(p,18)^p>>>3,y=en(m,17)^en(m,19)^m>>>10;Rn[d]=y+Rn[d-7]+f+Rn[d-16]|0}let{A:n,B:o,C:r,D:i,E:a,F:u,G:s,H:l}=this;for(let d=0;d<64;d++){let p=en(a,6)^en(a,11)^en(a,25),m=l+p+Du(a,u,s)+Dm[d]+Rn[d]|0,y=(en(n,2)^en(n,13)^en(n,22))+Wu(n,o,r)|0;l=s,s=u,u=a,a=i+m|0,i=r,r=o,o=n,n=m+y|0}n=n+this.A|0,o=o+this.B|0,r=r+this.C|0,i=i+this.D|0,a=a+this.E|0,u=u+this.F|0,s=s+this.G|0,l=l+this.H|0,this.set(n,o,r,i,a,u,s,l)}roundClean(){Rn.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}};var qu=Eu(()=>new qa);import{PublicKey as Jm}from"@solana/web3.js";import Yu,{isBN as ju}from"bn.js";import{bits as Wm,BitStructure as yA,blob as qm,Blob as bA,cstr as gA,f32 as AA,f32be as PA,f64 as kA,f64be as wA,greedy as TA,Layout as Um,ns64 as hA,ns64be as IA,nu64 as Gm,nu64be as BA,offset as Xm,s16 as xA,s16be as SA,s24 as KA,s24be as CA,s32 as zm,s32be as RA,s40 as LA,s40be as OA,s48 as NA,s48be as MA,s8 as vA,seq as Qm,struct as FA,Structure as Ym,u16 as jm,u16be as VA,u24 as _A,u24be as EA,u32 as Hm,u32be as DA,u40 as WA,u40be as qA,u48 as UA,u48be as GA,u8 as Zm,UInt as $m,union as XA,Union as zA,unionLayoutDiscriminator as QA,utf8 as YA}from"@solana/buffer-layout";var wr=Um,Uu=Ym;var Ua=$m;var Gu=Zm,Rt=jm;var Tr=Hm;var Xu=Gm;var Ve=zm;var zu=Qm;var Ie=qm;var Ga=Wm,Qu=Xm;var zn=class extends wr{constructor(t,n,o){super(t,o);this.blob=Ie(t),this.signed=n}decode(t,n=0){let o=new Yu(this.blob.decode(t,n),10,"le");return this.signed?o.fromTwos(this.span*8).clone():o}encode(t,n,o=0){return typeof t=="number"&&(t=new Yu(t)),this.signed&&(t=t.toTwos(this.span*8)),this.blob.encode(t.toArrayLike(Buffer,"le",this.span),n,o)}},hr=class extends wr{constructor(t){super(8,t);this._lower=Ga(Tr(),!1),this._upper=Ga(Tr(),!1)}addBoolean(t){this._lower.fields.length<32?this._lower.addBoolean(t):this._upper.addBoolean(t)}decode(t,n=0){let o=this._lower.decode(t,n),r=this._upper.decode(t,n+this._lower.span);return N(N({},o),r)}encode(t,n,o=0){return this._lower.encode(t,n,o)+this._upper.encode(t,n,o+this._lower.span)}};function _(c){return new Ua(1,c)}function ct(c){return new Ua(4,c)}function k(c){return new zn(8,!1,c)}function te(c){return new zn(16,!1,c)}function Hu(c){return new zn(1,!0,c)}function wo(c){return new zn(8,!0,c)}function Zu(c){return new zn(16,!0,c)}var ko=class extends wr{constructor(t,n,o,r){super(t.span,r);this.layout=t,this.decoder=n,this.encoder=o}decode(t,n){return this.decoder(this.layout.decode(t,n))}encode(t,n,o){return this.layout.encode(this.encoder(t),n,o)}getSpan(t,n){return this.layout.getSpan(t,n)}};function O(c){return new ko(Ie(32),e=>new Jm(e),e=>e.toBuffer(),c)}function We(c){return new ko(Gu(),ed,td,c)}function ed(c){if(c===0)return!1;if(c===1)return!0;throw new Error("Invalid bool: "+c)}function td(c){return c?1:0}function nd(c){let e=Tr("length"),t=V([e,Ie(Qu(e,-e.span),"data")]);return new ko(t,({data:n})=>n,n=>({data:n}),c)}function Bt(c){return new ko(nd(),e=>e.toString("utf-8"),e=>Buffer.from(e,"utf-8"),c)}var Xa=class extends Uu{decode(e,t){return super.decode(e,t)}};function V(c,e,t){return new Xa(c,e,t)}function Y(c,e,t){let n,o=typeof e=="number"?e:ju(e)?e.toNumber():new Proxy(e,{get(r,i){if(!n){let a=Reflect.get(r,"count");n=ju(a)?a.toNumber():a,Reflect.set(r,"count",n)}return Reflect.get(r,i)},set(r,i,a){return i==="count"&&(n=a),Reflect.set(r,i,a)}});return zu(c,o,t)}var tn=V([O("mint"),O("owner"),k("amount"),ct("delegateOption"),O("delegate"),_("state"),ct("isNativeOption"),k("isNative"),k("delegatedAmount"),ct("closeAuthorityOption"),O("closeAuthority")]);var yP=fe("Raydium_Util");function Ju({owner:c,solAccountResp:e,tokenAccountResp:t}){let n=[],o=[];for(let{pubkey:r,account:i}of t.value){let a=tn.decode(i.data),{mint:u,amount:s}=a;n.push({publicKey:r,mint:u,amount:s,isAssociated:j(c,u,i.owner).publicKey.equals(r),isNative:!1,programId:i.owner}),o.push({pubkey:r,accountInfo:a,programId:i.owner})}return e&&n.push({mint:$u.default,amount:new id(String(e.lamports)),isNative:!0,programId:e.owner}),{tokenAccounts:n,tokenAccountRawInfos:o}}function ze({fromPublicKey:c,programId:e=rd,assignSeed:t}){let n=t?btoa(t).slice(0,32):od.generate().publicKey.toBase58().slice(0,32);return{publicKey:ad(c,n,e),seed:n}}function ad(c,e,t){let n=Buffer.concat([c.toBuffer(),Buffer.from(e),t.toBuffer()]),o=qu(n);return new $u(o)}function za(c){let{mint:e,tokenAccount:t,owner:n,programId:o=To}=c;return md(t,e,n,o)}function An(c){let{tokenAccount:e,payer:t,multiSigners:n=[],owner:o,programId:r=To}=c;return ld(e,t,o,n,r)}async function Ln(c){let{connection:e,amount:t,commitment:n,payer:o,owner:r,skipCloseAccount:i}=c,a=await e.getMinimumBalanceForRentExemption(tn.span,n),u=J(t).add(new cd(a)),s=ze({fromPublicKey:o,programId:To});return{addresses:{newAccount:s.publicKey},signers:[],instructions:[ud.createAccountWithSeed({fromPubkey:o,basePubkey:o,seed:s.seed,newAccountPubkey:s.publicKey,lamports:u.toNumber(),space:tn.span,programId:To}),za({mint:new sd(nt.address),tokenAccount:s.publicKey,owner:r,programId:To})],instructionTypes:[U.CreateAccount,U.InitAccount],endInstructionTypes:i?[]:[U.CloseAccount],endInstructions:i?[]:[An({tokenAccount:s.publicKey,payer:o,owner:r})]}}function ec({source:c,destination:e,owner:t,amount:n,multiSigners:o=[],tokenProgram:r=To}){return dd(c,e,t,BigInt(String(n)),o,r)}var oi=class extends Fe{constructor(t){super(t);this._tokenAccounts=[];this._tokenAccountRawInfos=[];this._accountListener=[];this._clientOwnedToken=!1;this._notSubscribeAccountChange=!1;this._accountFetchTime=0;let{tokenAccounts:n,tokenAccountRawInfos:o,notSubscribeAccountChange:r}=t;this._tokenAccounts=n||[],this._tokenAccountRawInfos=o||[],this._notSubscribeAccountChange=r!=null?r:!0,this._clientOwnedToken=!!(n||o)}get tokenAccounts(){return this._tokenAccounts}get tokenAccountRawInfos(){return this._tokenAccountRawInfos}set notSubscribeAccountChange(t){this._notSubscribeAccountChange=t}updateTokenAccount({tokenAccounts:t,tokenAccountRawInfos:n}){return t&&(this._tokenAccounts=t),n&&(this._tokenAccountRawInfos=n),this._accountChangeListenerId&&this.scope.connection.removeAccountChangeListener(this._accountChangeListenerId),this._accountChangeListenerId=void 0,this._clientOwnedToken=!0,this}addAccountChangeListener(t){return this._accountListener.push(t),this}removeAccountChangeListener(t){return this._accountListener=this._accountListener.filter(n=>n!==t),this}getAssociatedTokenAccount(t,n){return j(this.scope.ownerPubKey,t,n).publicKey}resetTokenAccounts(){this._clientOwnedToken||(this._tokenAccounts=[],this._tokenAccountRawInfos=[])}async fetchWalletTokenAccounts(t){if(this._clientOwnedToken||!(t!=null&&t.forceUpdate)&&this._tokenAccounts.length&&Date.now()-this._accountFetchTime<(this._notSubscribeAccountChange?1e3*5:1e3*60*3))return{tokenAccounts:this._tokenAccounts,tokenAccountRawInfos:this._tokenAccountRawInfos};this.scope.checkOwner();let o=N(N({},{}),t),[r,i,a]=await Promise.all([this.scope.connection.getAccountInfo(this.scope.ownerPubKey,o.commitment),this.scope.connection.getTokenAccountsByOwner(this.scope.ownerPubKey,{programId:On},o.commitment),this.scope.connection.getTokenAccountsByOwner(this.scope.ownerPubKey,{programId:fd},o.commitment)]),{tokenAccounts:u,tokenAccountRawInfos:s}=Ju({owner:this.scope.ownerPubKey,solAccountResp:r,tokenAccountResp:{context:i.context,value:[...i.value,...a.value]}});return this._tokenAccounts=u,this._tokenAccountRawInfos=s,this._accountFetchTime=Date.now(),this._notSubscribeAccountChange||(this._accountChangeListenerId&&this.scope.connection.removeAccountChangeListener(this._accountChangeListenerId),this._accountChangeListenerId=this.scope.connection.onAccountChange(this.scope.ownerPubKey,()=>{this.fetchWalletTokenAccounts({forceUpdate:!0}),this._accountListener.forEach(l=>l({tokenAccounts:this._tokenAccounts,tokenAccountRawInfos:this._tokenAccountRawInfos}))},{commitment:t==null?void 0:t.commitment})),{tokenAccounts:u,tokenAccountRawInfos:s}}clearAccountChangeCkb(){this._accountChangeListenerId!==void 0&&this.scope.connection.removeAccountChangeListener(this._accountChangeListenerId)}async getCreatedTokenAccount({mint:t,programId:n=On,associatedOnly:o=!0}){await this.fetchWalletTokenAccounts();let r=this._tokenAccounts.filter(({mint:a})=>a==null?void 0:a.equals(t)).sort((a,u)=>a.amount.lt(u.amount)?1:-1),i=this.getAssociatedTokenAccount(t,n);for(let a of r){let{publicKey:u}=a;if(u&&(!o||o&&i.equals(u)))return u}}async getOrCreateTokenAccount(t){var y,b,g,P;await this.fetchWalletTokenAccounts();let{mint:n,createInfo:o,associatedOnly:r,owner:i,notUseTokenAccount:a=!1,skipCloseAccount:u=!1,checkCreateATAOwner:s=!1,assignSeed:l}=t,d=new Ir(t.tokenProgram||On),p=this.getAssociatedTokenAccount(n,new Ir(d)),m=(a?[]:this.tokenAccountRawInfos).filter(h=>h.accountInfo.mint.equals(n)&&(!r||h.pubkey.equals(p))).sort((h,I)=>h.accountInfo.amount.lt(I.accountInfo.amount)?1:-1);if(o===void 0||m.length>0)return m.length>0?{account:m[0].pubkey}:{};let f={instructions:[],endInstructions:[],signers:[],instructionTypes:[],endInstructionTypes:[]};if(r){let h=Qa(i,p,i,n,d),I=this.tokenAccountRawInfos.find(T=>T.pubkey.equals(p));if(s){let T=await this.scope.connection.getAccountInfo(p);if(T===null)(y=f.instructions)==null||y.push(h),f.instructionTypes.push(U.CreateATA);else if(!(T.owner.equals(d)&&ho.decode(T.data).mint.equals(n)&&ho.decode(T.data).owner.equals(i)))throw Error(`create ata check error -> mint: ${n.toString()}, ata: ${p.toString()}`)}else I===void 0&&(f.instructions.push(h),f.instructionTypes.push(U.CreateATA));if(n.equals(H)&&o.amount){let T=await Ln({connection:this.scope.connection,owner:this.scope.ownerPubKey,payer:o.payer||this.scope.ownerPubKey,amount:(b=o.amount)!=null?b:0,skipCloseAccount:u});f.instructions.push(...T.instructions||[]),f.endInstructions.push(...T.endInstructions||[]),f.instructionTypes.push(...T.instructionTypes||[]),f.endInstructionTypes.push(...T.endInstructionTypes||[]),o.amount&&(f.instructions.push(ec({source:T.addresses.newAccount,destination:p,owner:this.scope.ownerPubKey,amount:o.amount,tokenProgram:On})),f.instructionTypes.push(U.TransferAmount))}return!u&&I===void 0&&(f.endInstructions.push(An({owner:i,payer:o.payer||i,tokenAccount:p,programId:d})),f.endInstructionTypes.push(U.CloseAccount)),{account:p,instructionParams:f}}else{let h=ze({fromPublicKey:i,programId:d,assignSeed:l}),I=await this.scope.connection.getMinimumBalanceForRentExemption(ho.span),T=pd.createAccountWithSeed({fromPubkey:i,basePubkey:i,seed:h.seed,newAccountPubkey:h.publicKey,lamports:I+Number((P=(g=o.amount)==null?void 0:g.toString())!=null?P:0),space:ho.span,programId:d});return f.instructions.push(T,za({mint:n,tokenAccount:h.publicKey,owner:this.scope.ownerPubKey,programId:d})),f.instructionTypes.push(U.CreateAccount),f.instructionTypes.push(U.InitAccount),u||(f.endInstructions.push(An({owner:i,payer:o.payer||i,tokenAccount:h.publicKey,programId:d})),f.endInstructionTypes.push(U.CloseAccount)),{account:h.publicKey,instructionParams:f}}}async checkOrCreateAta({mint:t,programId:n=On,autoUnwrapWSOLToSOL:o}){var u;await this.fetchWalletTokenAccounts();let r=(u=this.scope.account.tokenAccounts.find(({mint:s})=>(s==null?void 0:s.toBase58())===t.toBase58()))==null?void 0:u.publicKey,i=this.scope.ownerPubKey,a={};if(!r){let s=this.getAssociatedTokenAccount(t,n),l=await Qa(i,s,i,t,n);a.instructions=[l],a.instructionTypes=[U.CreateATA],r=s}return o&&H.toBase58()===t.toBase58()&&(a.endInstructions=[An({owner:i,payer:i,tokenAccount:r,programId:n})],a.endInstructionTypes=[U.CloseAccount]),{pubKey:r,newInstructions:a}}async handleTokenAccount(t){let{side:n,amount:o,mint:r,programId:i=On,tokenAccount:a,payer:u=this.scope.ownerPubKey,bypassAssociatedCheck:s,skipCloseAccount:l,checkCreateATAOwner:d}=t,p=this.getAssociatedTokenAccount(r,i);if(new Ir(H).equals(r)){let m=await Ln({connection:this.scope.connection,owner:this.scope.ownerPubKey,payer:u,amount:o,skipCloseAccount:l});return N({tokenAccount:m.addresses.newAccount},m)}else if(!a||n==="out"&&!p.equals(a)&&!s){let m=[],f=Qa(this.scope.ownerPubKey,p,this.scope.ownerPubKey,r,i);if(d){let y=await this.scope.connection.getAccountInfo(p);if(y===null)m.push(f);else if(!(y.owner.equals(On)&&ho.decode(y.data).mint.equals(r)&&ho.decode(y.data).owner.equals(this.scope.ownerPubKey)))throw Error(`create ata check error -> mint: ${r.toString()}, ata: ${p.toString()}`)}else m.push(f);return{tokenAccount:p,instructions:m,instructionTypes:[U.CreateATA]}}return{tokenAccount:a}}async processTokenAccount(t){let{mint:n,programId:o=On,amount:r,useSOLBalance:i,handleTokenAccount:a,feePayer:u}=t,s,l=this.createTxBuilder(u);if(n.equals(new Ir(H))&&i){let d=await this.handleTokenAccount({side:"in",amount:r||0,mint:n,bypassAssociatedCheck:!0,programId:o}),{tokenAccount:m}=d,f=qe(d,["tokenAccount"]);s=m,l.addInstruction(f)}else if(s=await this.getCreatedTokenAccount({mint:n,associatedOnly:!1,programId:o}),!s&&a){let p=await this.scope.account.handleTokenAccount({side:"in",amount:0,mint:n,bypassAssociatedCheck:!0,programId:o}),{tokenAccount:m}=p,f=qe(p,["tokenAccount"]);s=m,l.addInstruction(f)}return N({tokenAccount:s},l.AllTxData)}};import{PublicKey as Be,SystemProgram as Fd}from"@solana/web3.js";import{createAssociatedTokenAccountIdempotentInstruction as Pc}from"@solana/spl-token";import Vd from"decimal.js";import{PublicKey as Ja}from"@solana/web3.js";var Ya=V([_("instruction")]),ja=V([_("instruction")]),yd=V([k("rewardState"),k("rewardOpenTime"),k("rewardEndTime"),k("rewardLastUpdateTime"),k("totalReward"),k("totalRewardEmissioned"),k("rewardClaimed"),k("rewardPerSecond"),te("accRewardPerShare"),O("rewardVault"),O("rewardMint"),O("rewardSender"),k("rewardType"),Y(k(),15,"padding")]),bd=V([k("state"),k("nonce"),O("lpVault"),O("rewardVault"),O(),O(),k(),k(),k("totalReward"),te("perShareReward"),k("lastSlot"),k("perSlotReward")]),gd=V([k("state"),k("nonce"),O("lpVault"),O("rewardVaultA"),k("totalRewardA"),te("perShareRewardA"),k("perSlotRewardA"),_("option"),O("rewardVaultB"),Ie(7),k("totalRewardB"),te("perShareRewardB"),k("perSlotRewardB"),k("lastSlot"),O()]),Ad=V([k(),k("state"),k("nonce"),k("validRewardTokenNum"),te("rewardMultiplier"),k("rewardPeriodMax"),k("rewardPeriodMin"),k("rewardPeriodExtend"),O("lpMint"),O("lpVault"),Y(yd,5,"rewardInfos"),O("creator"),O(),Y(k(),32,"padding")]),tc=new Proxy(bd,{get(c,e,t){return e==="decode"?(...n)=>{let o=c.decode(...n);return q(N({},o),{version:3,rewardInfos:[{rewardVault:o.rewardVault,totalReward:o.totalReward,perSlotReward:o.perSlotReward,perShareReward:o.perShareReward}]})}:Reflect.get(c,e,t)}}),nc=new Proxy(gd,{get(c,e,t){return e==="decode"?(...n)=>{let o=c.decode(...n);return q(N({},o),{version:5,rewardInfos:[{rewardVault:o.rewardVaultA,totalReward:o.totalRewardA,perSlotReward:o.perSlotRewardA,perShareReward:o.perShareRewardA},{rewardVault:o.rewardVaultB,totalReward:o.totalRewardB,perSlotReward:o.perSlotRewardB,perShareReward:o.perShareRewardB}]})}:Reflect.get(c,e,t)}}),ii=new Proxy(Ad,{get(c,e,t){return e==="decode"?(...n)=>{let o=c.decode(...n);return q(N({},o),{version:6,rewardInfos:o.rewardInfos.map(r=>{var i;return q(N({},r),{rewardType:((i=Object.entries(Nn).find(a=>String(a[1])===r.rewardType.toString()))!=null?i:["Standard SPL"])[0]})})})}:Reflect.get(c,e,t)}}),Pd=V([k("isSet"),k("rewardPerSecond"),k("rewardOpenTime"),k("rewardEndTime"),k("rewardType")]),Ha=V([_("instruction"),k("nonce"),Y(Pd,5,"rewardTimeInfo")]),Za=V([_("instruction"),k("rewardReopenTime"),k("rewardEndTime"),k("rewardPerSecond")]),$a=V([_("instruction"),k("isSet"),k("rewardPerSecond"),k("rewardOpenTime"),k("rewardEndTime"),k("rewardType")]),QP=V([k("state"),O("id"),O("owner"),k("deposited"),Y(k(),1,"rewardDebts")]),ri=V([k("state"),O("id"),O("owner"),k("deposited"),Y(te(),1,"rewardDebts"),k(""),k("voteLockedBalance"),Y(k(),15)]),YP=V([k("state"),O("id"),O("owner"),k("deposited"),Y(k(),2,"rewardDebts")]),oc=V([k("state"),O("id"),O("owner"),k("deposited"),Y(te(),2,"rewardDebts"),Y(k(),17)]),ic=V([k(),k("state"),O("id"),O("owner"),k("deposited"),Y(te(),5,"rewardDebts"),Y(k(),16)]),At=V([_("instruction"),k("amount")]),kd=V([O("mint"),O("grantAuthority"),k("baselineVoteWeightScaledFactor"),k("maxExtraLockupVoteWeightScaledFactor"),k("lockupSaturationSecs"),Hu("digitShift"),Y(_(),7,"reserved1"),Y(k(),7,"reserved2")]),rc=V([Ie(8),O("governanceProgramId"),O("realm"),O("realmGoverningTokenMint"),O("realmAuthority"),Y(_(),32,"reserved1"),Y(kd,4,"votingMints"),wo("timeOffset"),_("bump"),Y(_(),7,"reserved2"),Y(k(),11,"reserved3")]),wd=V([wo("startTime"),wo("endTime"),_("kind"),Y(_(),15,"reserved")]),Td=V([Y(wd,1,"lockup"),k("amountDeposited_native"),k("amountInitiallyLockedNative"),We("isUsed"),We("allowClawback"),_("votingMintConfigIdx"),Y(_(),29,"reserved")]),ac=V([Ie(8),O("voterAuthority"),O("registrar"),Y(Td,32,"deposits"),_("voterBump"),_("voterWweightRecordBump"),Y(_(),94,"reserved")]);import{NATIVE_MINT as hd}from"@solana/spl-token";var ok=fe("Raydium_farm_config"),sc=new Ja("4k3Dyjzvzp8eMZWUXbBCjEvwSkkk59S5iCNLY3QrkX6R"),uc=new Ja("FrspKwj8i3pNmKwXreTveC4fu7KL5ZbGeXdZBe2XViu1"),ik=hd,rk=new Ja("3TRTX4dXUpp2eqxi3tvQDFYUV7SdDJjcPE3Y4mbtftaX"),cc={3:tc,5:nc,6:ii},lc={3:ri,5:oc,6:ic},es=c=>[3,4,5,6].indexOf(c)!==-1,ts=c=>{var i;let{version:e,rewardInfos:t,rewardTokenAccountsPublicKeys:n}=c,o=`rewardInfo:${JSON.stringify(t)}, rewardAccount:${JSON.stringify(n)}`,r={3:()=>{if(t.length!==1||n.length!==1)return`rewardInfos or rewardTokenAccounts lengths not equal 1: ${o}`},5:()=>{if(t.length!==n.length)return`rewardInfos and rewardTokenAccounts lengths not equal: ${o}`},6:()=>{if(!n.length||t.length!==n.length)return`no rewardTokenAccounts or rewardInfos and rewardTokenAccounts lengths not equal: ${o}`}};return(i=r[e])==null?void 0:i.call(r)},Nn={"Standard SPL":0,"Option tokens":1},_t={[Ia.toString()]:3,[Ba.toString()]:4,[xa.toString()]:5,[yo.toString()]:6,[gn.FARM_PROGRAM_ID_V3.toString()]:3,[gn.FARM_PROGRAM_ID_V4.toString()]:4,[gn.FARM_PROGRAM_ID_V5.toString()]:5,[gn.FARM_PROGRAM_ID_V6.toString()]:6};import{PublicKey as se,SystemProgram as Qn,SYSVAR_CLOCK_PUBKEY as Bo,SYSVAR_RENT_PUBKEY as xd,TransactionInstruction as $e}from"@solana/web3.js";import Br from"bn.js";import{ASSOCIATED_TOKEN_PROGRAM_ID as Sd,createAssociatedTokenAccountIdempotentInstruction as Kd,TOKEN_PROGRAM_ID as St}from"@solana/spl-token";function ns(c,e,t){return ne([e.toBuffer(),Buffer.from("registrar","utf8"),t.toBuffer()],c)}function os(c,e){return ne([e.toBuffer(),Buffer.from("voting_mint_seed","utf8")],c)}function is(c,e){return ne([e.toBuffer()],c)}function rs(c,e,t){return ne([e.toBuffer(),Buffer.from("voter","utf8"),t.toBuffer()],c)}function as(c,e,t){return ne([e.toBuffer(),Buffer.from("voter-weight-record","utf8"),t.toBuffer()],c)}function ss(c,e,t,n){return ne([Buffer.from("governance","utf8"),e.toBuffer(),t.toBuffer(),n.toBuffer()],c)}import xt from"bn.js";var ai=fe("Raydium.farm.util");function si({programId:c,poolId:e,mint:t,type:n}){let{publicKey:o}=ne([e.toBuffer(),t.toBuffer(),Buffer.from(n==="lpVault"?"lp_vault_associated_seed":n==="rewardVault"?"reward_vault_associated_seed":"","utf-8")],c);return o}function dt({programId:c,poolId:e,owner:t,version:n}){let{publicKey:o}=ne([e.toBuffer(),t.toBuffer(),Buffer.from(n===6?"farmer_info_associated_seed":"staker_info_v2_associated_seed","utf-8")],c);return o}var mc=({programId:c,poolId:e})=>ne([e.toBuffer()],c);function dc(c){return{isSet:new xt(1),rewardPerSecond:J(c.perSecond),rewardOpenTime:J(c.openTime),rewardEndTime:J(c.endTime),rewardType:J(Nn[c.rewardType])}}function us(c){return J(c.endTime).sub(J(c.openTime)).mul(J(c.perSecond))}function Io(c){let e=lc[c];return e||ai.logWithError("invalid version",c),e}function Id(c){let e=cc[c];return e||ai.logWithError("invalid version",c),e}function Bd(c,e,t,n){if(c.version===3||c.version===5){if(c.lastSlot.gte(new xt(t)))return c;let o=new xt(t).sub(c.lastSlot);c.lastSlot=new xt(t);for(let r of c.rewardInfos){if(e.amount.eq(new xt(0)))continue;let i=r.perSlotReward.mul(o);r.perShareReward=r.perShareReward.add(i.mul(new xt(10).pow(new xt(c.version===3?9:15))).div(e.amount)),r.totalReward=r.totalReward.add(i)}}else if(c.version===6)for(let o of c.rewardInfos){if(o.rewardState.eq(new xt(0)))continue;let r=xt.min(new xt(n),o.rewardEndTime);if(o.rewardOpenTime.gte(r))continue;let a=r.sub(o.rewardLastUpdateTime).mul(o.rewardPerSecond),u=o.totalReward.sub(o.totalRewardEmissioned);u.lt(a)?(a=u,o.rewardLastUpdateTime=o.rewardLastUpdateTime.add(u.div(o.rewardPerSecond))):o.rewardLastUpdateTime=r,!e.amount.eq(new xt(0))&&(o.accRewardPerShare=o.accRewardPerShare.add(a.mul(c.rewardMultiplier).div(e.amount)),o.totalRewardEmissioned=o.totalRewardEmissioned.add(a))}return c}async function Tk({connection:c,farmPools:e,owner:t,config:n,chainTime:o}){let r=!1,i=!1,a=new xt(10),u=[];for(let p of e){let m=Me(p);m.version===6?i=!0:r=!0,u.push({pubkey:m.id,version:m.version,key:"state",poolId:m.id},{pubkey:m.lpVault,version:m.version,key:"lpVault",poolId:m.id}),t&&u.push({pubkey:dt({programId:m.programId,poolId:m.id,owner:t,version:p.version}),version:m.version,key:"ledger",poolId:m.id})}let s={},l=await Oe(c,u,n);for(let{pubkey:p,version:m,key:f,poolId:y,accountInfo:b}of l){let g=y.toBase58();if(s[g]=N({},s[g]),f==="state"){let P=Id(m);(!b||!b.data||b.data.length!==P.span)&&ai.logWithError(`invalid farm state account info, pools.id, ${p}`),s[g].state=P.decode(b.data)}else if(f==="lpVault")(!b||!b.data||b.data.length!==tn.span)&&ai.logWithError(`invalid farm lp vault account info, pools.lpVault, ${p}`),s[g].lpVault=tn.decode(b.data);else if(f==="ledger"){let P=Io(m);b&&b.data&&(b.data.length!==P.span&&ai.logWithError(`invalid farm ledger account info, ledger, ${p}`),s[g].ledger=P.decode(b.data))}}let d=i||r?await c.getSlot():0;for(let p of Object.keys(s))s[p]!==void 0&&(s[p].state=Bd(s[p].state,s[p].lpVault,d,o));for(let[p,{state:m,ledger:f}]of Object.entries(s))if(f){let y=m.version===6?m.rewardMultiplier:m.rewardInfos.length===1?a.pow(new xt(9)):a.pow(new xt(15)),b=m.rewardInfos.map((g,P)=>{let h=f.rewardDebts[P];return f.deposited.mul(m.version===6?g.accRewardPerShare:g.perShareReward).div(y).sub(h)});s[p].wrapped=q(N({},s[p].wrapped),{pendingRewards:b})}return s}function hk(c,e=Date.now()){if(c.version===6){let t=c.state.rewardInfos;if(t.every(({rewardOpenTime:n})=>xu(e,n.toNumber(),{unit:"s"})))return"upcoming pool";if(t.every(({rewardEndTime:n})=>Su(e,n.toNumber(),{unit:"s"})))return"closed pool"}else{let t=c.state.rewardInfos.map(({perSlotReward:n})=>n);if(t.length===2){if(String(t[0])==="0"&&String(t[1])!=="0")return"normal fusion pool";if(String(t[0])!=="0"&&String(t[1])!=="0")return"dual fusion pool";if(String(t[0])==="0"&&String(t[1])==="0")return"closed pool"}else if(t.length===1&&String(t[0])==="0")return"closed pool"}}async function cs(c,e,t,n){let o=await c.getAccountInfo(e);if(o===null)throw Error("registrar info check error");let i=rc.decode(o.data).votingMints.findIndex(l=>l.mint.equals(n));if(i===-1)throw Error("find voter mint error");let a=await c.getAccountInfo(t);if(a===null)return{index:i,isInit:!1};let s=ac.decode(a.data).deposits.findIndex(l=>l.isUsed&&l.votingMintConfigIdx===i);return s===-1?{index:i,isInit:!1}:{index:s,isInit:!0}}var Cd=fe("Raydium_farm_instruction"),ui={voterStakeRegistryCreateVoter:Buffer.from([6,24,245,52,243,255,148,25]),voterStakeRegistryCreateDepositEntry:Buffer.from([185,131,167,186,159,125,19,67]),voterStakeRegistryDeposit:Buffer.from([242,35,198,137,82,225,242,182]),voterStakeRegistryWithdraw:Buffer.from([183,18,70,156,148,109,161,34]),voterStakeRegistryUpdateVoterWeightRecord:Buffer.from([45,185,3,36,109,190,115,169])};function ci(c){let{version:e,id:t,ledger:n,programId:o,owner:r}=c,i={3:9,5:10}[e];i||Cd.logWithError(`invalid farm pool version: ${e}`);let a=Buffer.alloc(Ya.span);Ya.encode({instruction:i},a);let u=[A({pubkey:t}),A({pubkey:n}),A({pubkey:r,isWritable:!1}),A({pubkey:Qn.programId,isWritable:!1}),A({pubkey:xd,isWritable:!1})];return{instruction:new $e({programId:o,keys:u,data:a}),instructionType:U.FarmV3CreateLedger}}function pc(c){var n;let e=Buffer.alloc(Ha.span);Ha.encode({instruction:0,nonce:new Br(c.nonce),rewardTimeInfo:c.rewardInfoConfig},e);let t=[...ya,A({pubkey:c.farmId}),A({pubkey:c.farmAuthority,isWritable:!1}),A({pubkey:c.lpVault}),A({pubkey:c.lpMint,isWritable:!1}),A({pubkey:c.lockVault}),A({pubkey:c.lockMint,isWritable:!1}),A({pubkey:(n=c.lockUserAccount)!=null?n:ot}),A({pubkey:c.owner,isWritable:!1,isSigner:!0})];for(let o of c.rewardInfo)t.push(A({pubkey:o.rewardMint,isWritable:!1}),A({pubkey:o.rewardVault}),A({pubkey:o.userRewardToken}));return{instruction:new $e({programId:c.programId,keys:t,data:e}),instructionType:U.FarmV6Create}}function fc(c){let e=Buffer.alloc(ja.span);ja.encode({instruction:5},e);let t=[A({pubkey:St,isWritable:!1}),A({pubkey:c.id}),A({pubkey:c.authority,isWritable:!1}),A({pubkey:c.lpVault,isWritable:!1}),A({pubkey:c.rewardVault}),A({pubkey:c.userRewardToken}),A({pubkey:c.owner,isWritable:!1,isSigner:!0})];return{instruction:new $e({programId:c.programId,keys:t,data:e}),instructionType:U.FarmV6CreatorWithdraw}}function Rd(c,e,t,n,o,r,i,a,u,s,l,d,p){let m=V([_("depositEntryIndex"),k("amount")]),f=[{pubkey:e,isSigner:!1,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!1},{pubkey:St,isSigner:!1,isWritable:!1},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!1},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!1},{pubkey:l,isSigner:!1,isWritable:!1},{pubkey:er,isSigner:!1,isWritable:!1}],y=Buffer.alloc(m.span);m.encode({depositEntryIndex:d,amount:p},y);let b=Buffer.from([...ui.voterStakeRegistryDeposit,...y]);return new $e({keys:f,programId:c,data:b})}function Ld(c,e,t,n){let o=V([]),r=[{pubkey:e,isSigner:!1,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:Qn.programId,isSigner:!1,isWritable:!1}],i=Buffer.alloc(o.span);o.encode({},i);let a=Buffer.from([...ui.voterStakeRegistryUpdateVoterWeightRecord,...i]);return new $e({keys:r,programId:c,data:a})}function Od(c,e,t,n,o,r,i,a,u,s,l,d,p,m,f){let y=V([_("depositEntryIndex"),k("amount")]),b=[{pubkey:e,isSigner:!1,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!0,isWritable:!1},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:St,isSigner:!1,isWritable:!1},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!1},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:d,isSigner:!1,isWritable:!1},{pubkey:p,isSigner:!1,isWritable:!1},{pubkey:er,isSigner:!1,isWritable:!1}],g=Buffer.alloc(y.span);y.encode({depositEntryIndex:m,amount:f},g);let P=Buffer.from([...ui.voterStakeRegistryWithdraw,...g]);return new $e({keys:b,programId:c,data:P})}function Nd(c,e,t,n,o,r){let i=V([_("ins")]),a=[{pubkey:e,isSigner:!1,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!0,isWritable:!0},{pubkey:Qn.programId,isSigner:!1,isWritable:!1}],u=Buffer.alloc(i.span);return i.encode({ins:23},u),new $e({keys:a,programId:c,data:u})}function Md(c,e,t,n,o,r,i,a){let u=V([_("voterBump"),_("voterWeightRecordBump")]),s=[{pubkey:e,isSigner:!1,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!0,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!0,isWritable:!0},{pubkey:Qn.programId,isSigner:!1,isWritable:!1},{pubkey:Ze,isSigner:!1,isWritable:!1},{pubkey:er,isSigner:!1,isWritable:!1}],l=Buffer.alloc(u.span);u.encode({voterBump:i,voterWeightRecordBump:a},l);let d=Buffer.from([...ui.voterStakeRegistryCreateVoter,...l]);return new $e({keys:s,programId:c,data:d})}function vd(c,e,t,n,o,r,i,a,u,s,l,d){let p=V([_("depositEntryIndex"),_("kind"),_("option"),k("startTs"),ct("periods"),We("allowClawback")]),m=[{pubkey:e,isSigner:!1,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!0,isWritable:!1},{pubkey:r,isSigner:!0,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!1},{pubkey:Qn.programId,isSigner:!1,isWritable:!1},{pubkey:St,isSigner:!1,isWritable:!1},{pubkey:Sd,isSigner:!1,isWritable:!1},{pubkey:Ze,isSigner:!1,isWritable:!1}],f=Buffer.alloc(p.span);p.encode({depositEntryIndex:a,kind:u,option:s===void 0?0:1,startTs:s,periods:l,allowClawback:d},f);let y=Buffer.from([...ui.voterStakeRegistryCreateDepositEntry,...f]);return new $e({keys:m,programId:c,data:y})}async function Ek({connection:c,programId:e,governanceProgramId:t,voteWeightAddinProgramId:n,realm:o,communityTokenMint:r,owner:i,poolId:a,tokenProgram:u}){let s=ns(n,o,r).publicKey,l=dt({programId:e,poolId:a,owner:i,version:3}),d=await c.getAccountInfo(l);if(d===null)throw Error("user is not staker");let p=ri.decode(d.data),m=p.deposited.sub(p.voteLockedBalance);if(console.log("amount",m.toString()),m.eq(new Br(0)))throw Error("user do not has new stake amount");let f=os(e,a).publicKey,y=is(e,a).publicKey,{publicKey:b,nonce:g}=rs(n,s,i),P=j(b,f,u).publicKey,{publicKey:h,nonce:I}=as(n,s,i),T=ss(t,o,r,i).publicKey,w=[],x=j(i,f,u).publicKey;if(await c.getAccountInfo(x)===null&&w.push(Kd(i,x,i,f)),await c.getAccountInfo(b)===null){let M=Nd(t,o,i,r,i,T);w.push(M,Md(n,s,b,h,i,i,g,I))}let{index:B,isInit:C}=await cs(c,s,b,f);return C||w.push(vd(n,s,b,P,i,i,f,B,0,void 0,0,!1)),w.push(Rd(n,s,b,P,x,i,l,a,f,y,e,B,m),Ld(n,s,b,h)),w}async function Dk({connection:c,programId:e,governanceProgramId:t,voteWeightAddinProgramId:n,realm:o,communityTokenMint:r,owner:i,poolId:a,tokenProgram:u}){let s=ns(n,o,r).publicKey,l=dt({programId:e,poolId:a,owner:i,version:3}),d=await c.getAccountInfo(l);if(d===null)throw Error("user is not staker");let p=ri.decode(d.data);if(p.voteLockedBalance.eq(new Br(0)))throw Error("user has vote locked balance = 0");let m=os(e,a).publicKey,f=is(e,a).publicKey,{publicKey:y}=rs(n,s,i),b=j(y,m,u).publicKey,{publicKey:g}=as(n,s,i),P=ss(t,o,r,i).publicKey,h=[],{index:I,isInit:T}=await cs(c,s,y,m);if(!T)throw Error("deposit entry index check error");return h.push(Od(n,s,y,i,P,g,b,j(i,m,u).publicKey,l,a,m,f,e,I,p.voteLockedBalance)),h}function ls({payer:c,rewardVault:e,userRewardTokenPub:t,farmKeys:n,rewardInfo:o}){let r=Buffer.alloc(Za.span);Za.encode({instruction:3,rewardReopenTime:J(o.openTime),rewardEndTime:J(o.endTime),rewardPerSecond:J(o.perSecond)},r);let i=[A({pubkey:St,isWritable:!1}),A({pubkey:n.id}),A({pubkey:n.lpVault,isWritable:!1}),A({pubkey:e}),A({pubkey:t}),A({pubkey:c,isWritable:!1,isSigner:!0})];return new $e({programId:n.programId,keys:i,data:r})}function ms({payer:c,userRewardTokenPub:e,farmKeys:t,rewardVault:n,rewardInfo:o}){let r=Buffer.alloc($a.span);$a.encode({instruction:4,isSet:new Br(1),rewardPerSecond:J(o.perSecond),rewardOpenTime:J(o.openTime),rewardEndTime:J(o.endTime),rewardType:J(Nn[o.rewardType])},r);let i=[...ya,A({pubkey:t.id}),A({pubkey:t.authority,isWritable:!1}),A({pubkey:o.mint,isWritable:!1}),A({pubkey:n}),A({pubkey:e}),A({pubkey:c,isWritable:!1,isSigner:!0})];return new $e({programId:t.programId,keys:i,data:r})}function Wk(c){let{farmInfo:e,farmKeys:t,version:n,lpAccount:o,rewardAccounts:r,owner:i,instruction:a,amount:u,deposit:s}=c,[l,d]=[new se(e.programId),new se(e.id)],p=dt({programId:l,poolId:d,owner:i,version:n}),m=Buffer.alloc(At.span);At.encode({instruction:a,amount:u},m);let f=n===6?[A({pubkey:St,isWritable:!1}),...s?[A({pubkey:Qn.programId,isWritable:!1})]:[],A({pubkey:d}),A({pubkey:new se(t.authority),isWritable:!1}),A({pubkey:new se(t.lpVault)}),A({pubkey:p}),A({pubkey:i,isWritable:!1,isSigner:!0}),A({pubkey:o})]:[A({pubkey:d}),A({pubkey:new se(t.authority),isWritable:!1}),A({pubkey:p}),A({pubkey:i,isWritable:!1,isSigner:!0}),A({pubkey:o}),A({pubkey:new se(t.lpVault)}),A({pubkey:r[0]}),A({pubkey:new se(t.rewardInfos[0].vault)}),A({pubkey:Bo,isWritable:!1}),A({pubkey:St,isWritable:!1})];if(n===5)for(let y=1;y<t.rewardInfos.length;y++)f.push(A({pubkey:r[y]})),f.push(A({pubkey:new se(t.rewardInfos[y].vault)}));if(n===6)for(let y=0;y<t.rewardInfos.length;y++)f.push(A({pubkey:new se(t.rewardInfos[y].vault)})),f.push(A({pubkey:r[y]}));return new $e({programId:l,keys:f,data:m})}function li(c){let{farmInfo:e,farmKeys:t,lpAccount:n,rewardAccounts:o,owner:r,amount:i}=c,[a,u]=[new se(e.programId),new se(e.id)],s=dt({programId:a,poolId:u,owner:r,version:6}),l=Buffer.alloc(At.span);At.encode({instruction:2,amount:J(i)},l);let d=[A({pubkey:St,isWritable:!1}),A({pubkey:u}),A({pubkey:new se(t.authority),isWritable:!1}),A({pubkey:new se(t.lpVault)}),A({pubkey:s}),A({pubkey:r,isWritable:!1,isSigner:!0}),A({pubkey:n})];for(let p=0;p<t.rewardInfos.length;p++)d.push(A({pubkey:new se(t.rewardInfos[p].vault)})),d.push(A({pubkey:o[p]}));return new $e({programId:a,keys:d,data:l})}function mi(c){let{farmInfo:e,farmKeys:t,lpAccount:n,rewardAccounts:o,owner:r,amount:i,userAuxiliaryLedgers:a}=c,[u,s]=[new se(e.programId),new se(e.id)],l=dt({programId:u,poolId:s,owner:r,version:5}),d=Buffer.alloc(At.span);At.encode({instruction:12,amount:J(i)},d);let p=[A({pubkey:s}),A({pubkey:new se(t.authority),isWritable:!1}),A({pubkey:l}),A({pubkey:r,isWritable:!1,isSigner:!0}),A({pubkey:n}),A({pubkey:new se(t.lpVault)}),A({pubkey:o[0]}),A({pubkey:new se(t.rewardInfos[0].vault)}),A({pubkey:Bo,isWritable:!1}),A({pubkey:St,isWritable:!1})];for(let m=1;m<t.rewardInfos.length;m++)p.push(A({pubkey:o[m]})),p.push(A({pubkey:new se(t.rewardInfos[m].vault)}));if(a)for(let m of a)p.push(A({pubkey:m}));return new $e({programId:u,keys:p,data:d})}function yc(c){let{farmInfo:e,farmKeys:t,lpAccount:n,rewardAccounts:o,owner:r,amount:i,userAuxiliaryLedgers:a}=c,[u,s]=[new se(e.programId),new se(e.id)],l=V([_("instruction"),k("amount")]),d=[A({pubkey:s}),A({pubkey:new se(t.authority),isWritable:!1}),A({pubkey:a[0]}),A({pubkey:r,isSigner:!0,isWritable:!1}),A({pubkey:n}),A({pubkey:new se(t.lpVault)}),A({pubkey:o[0]}),A({pubkey:new se(t.rewardInfos[0].vault)}),A({pubkey:Bo,isWritable:!1}),A({pubkey:St,isWritable:!1}),A({pubkey:o[1]}),A({pubkey:new se(t.rewardInfos[1].vault)})],p=Buffer.alloc(l.span);return l.encode({instruction:2,amount:i},p),new $e({keys:d,programId:u,data:p})}function di(c){let{farmInfo:e,farmKeys:t,lpAccount:n,rewardAccounts:o,owner:r,amount:i,userAuxiliaryLedgers:a}=c,[u,s]=[new se(e.programId),new se(e.id)],l=dt({programId:u,poolId:s,owner:r,version:3}),d=Buffer.alloc(At.span);At.encode({instruction:11,amount:J(i)},d);let p=[A({pubkey:s}),A({pubkey:new se(t.authority),isWritable:!1}),A({pubkey:l}),A({pubkey:r,isWritable:!1,isSigner:!0}),A({pubkey:n}),A({pubkey:new se(t.lpVault)}),A({pubkey:o[0]}),A({pubkey:new se(t.rewardInfos[0].vault)}),A({pubkey:Bo,isWritable:!1}),A({pubkey:St,isWritable:!1})];if(a)for(let m of a)p.push(A({pubkey:m}));return new $e({programId:u,keys:p,data:d})}function bc(c){let{farmInfo:e,farmKeys:t,lpAccount:n,rewardAccounts:o,owner:r,amount:i,userAuxiliaryLedgers:a}=c,[u,s]=[new se(e.programId),new se(e.id)],l=dt({programId:u,poolId:s,owner:r,version:3}),d=Buffer.alloc(At.span);At.encode({instruction:10,amount:J(i)},d);let p=[A({pubkey:s}),A({pubkey:new se(t.authority),isWritable:!1}),A({pubkey:l}),A({pubkey:r,isWritable:!1,isSigner:!0}),A({pubkey:n}),A({pubkey:new se(t.lpVault)}),A({pubkey:o[0]}),A({pubkey:new se(t.rewardInfos[0].vault)}),A({pubkey:Bo,isWritable:!1}),A({pubkey:St,isWritable:!1})];if(a)for(let m of a)p.push(A({pubkey:m}));return new $e({programId:u,keys:p,data:d})}function gc(c){let{farmInfo:e,farmKeys:t,lpAccount:n,rewardAccounts:o,owner:r,amount:i,userAuxiliaryLedgers:a}=c,[u,s]=[new se(e.programId),new se(e.id)],l=dt({programId:u,poolId:s,owner:r,version:5}),d=Buffer.alloc(At.span);At.encode({instruction:11,amount:J(i)},d);let p=[A({pubkey:s}),A({pubkey:new se(t.authority),isWritable:!1}),A({pubkey:l}),A({pubkey:r,isWritable:!1,isSigner:!0}),A({pubkey:n}),A({pubkey:new se(t.lpVault)}),A({pubkey:o[0]}),A({pubkey:new se(t.rewardInfos[0].vault)}),A({pubkey:Bo,isWritable:!1}),A({pubkey:St,isWritable:!1})];for(let m=1;m<t.rewardInfos.length;m++)p.push(A({pubkey:o[m]})),p.push(A({pubkey:new se(t.rewardInfos[m].vault)}));if(a)for(let m of a)p.push(A({pubkey:m}));return new $e({programId:u,keys:p,data:d})}function Ac(c){let{farmInfo:e,farmKeys:t,lpAccount:n,rewardAccounts:o,owner:r,amount:i}=c,[a,u]=[new se(e.programId),new se(e.id)],s=dt({programId:a,poolId:u,owner:r,version:6}),l=Buffer.alloc(At.span);At.encode({instruction:1,amount:J(i)},l);let d=[A({pubkey:St,isWritable:!1}),A({pubkey:Qn.programId,isWritable:!1}),A({pubkey:u}),A({pubkey:new se(t.authority),isWritable:!1}),A({pubkey:new se(t.lpVault)}),A({pubkey:s}),A({pubkey:r,isWritable:!1,isSigner:!0}),A({pubkey:n})];for(let p=0;p<t.rewardInfos.length;p++)d.push(A({pubkey:new se(t.rewardInfos[p].vault)})),d.push(A({pubkey:o[p]}));return new $e({programId:a,keys:d,data:l})}var pi=class extends Fe{async _getUserRewardInfo({payer:e,rewardInfo:t}){if(t.mint.equals(ot)){let n=await Ln({connection:this.scope.connection,owner:this.scope.ownerPubKey,payer:e,amount:us(q(N({},t),{openTime:t.openTime.toString(),endTime:t.endTime.toString()}))});return{rewardPubKey:n.addresses.newAccount,newInstruction:n}}return{rewardPubKey:await this.scope.account.getCreatedTokenAccount({mint:t.mint,associatedOnly:!1})}}async create({poolInfo:e,rewardInfos:t,payer:n,programId:o=yo,txVersion:r,feePayer:i,lockProgram:a}){var x,S;this.checkDisabled(),this.scope.checkOwner();let s={lpMint:new Be(e.lpMint.address),lockInfo:{lockMint:(x=a==null?void 0:a.mint)!=null?x:sc,lockVault:(S=a==null?void 0:a.vault)!=null?S:uc},version:6,rewardInfos:t,programId:o},l=this.createTxBuilder(i),d=n!=null?n:this.scope.ownerPubKey,p=ze({fromPublicKey:d,programId:s.programId}),m=await this.scope.connection.getMinimumBalanceForRentExemption(ii.span);l.addInstruction({instructions:[Fd.createAccountWithSeed({fromPubkey:d,basePubkey:d,seed:p.seed,newAccountPubkey:p.publicKey,lamports:m,space:ii.span,programId:s.programId})]});let{publicKey:f,nonce:y}=mc({programId:new Be(s.programId),poolId:p.publicKey}),b=si({programId:s.programId,poolId:p.publicKey,mint:s.lpMint,type:"lpVault"}),g=[],P=[];for(let K of s.rewardInfos){K.openTime>=K.endTime&&this.logAndCreateError("start time error","rewardInfo.rewardOpenTime",K.openTime.toString()),isNaN(Nn[K.rewardType])&&this.logAndCreateError("rewardType error",K.rewardType),Number(K.perSecond)<=0&&this.logAndCreateError("rewardPerSecond error",K.perSecond),g.push(dc(K));let{rewardPubKey:B,newInstruction:C}=await this._getUserRewardInfo({rewardInfo:K,payer:d});C&&l.addInstruction(C),B||this.logAndCreateError("cannot found target token accounts",this.scope.account.tokenAccounts);let M=K.mint.equals(ot)?new Be(nt.address):K.mint;P.push({rewardMint:M,rewardVault:si({programId:s.programId,poolId:p.publicKey,mint:M,type:"rewardVault"}),userRewardToken:B})}let{account:h,instructionParams:I}=await this.scope.account.getOrCreateTokenAccount({mint:new Be(s.lockInfo.lockMint),owner:this.scope.ownerPubKey,skipCloseAccount:!1,createInfo:{payer:this.scope.ownerPubKey,amount:0},associatedOnly:!1});I&&l.addInstruction(I),h||this.logAndCreateError("cannot found lock vault","tokenAccounts",this.scope.account.tokenAccounts);let{instruction:T,instructionType:w}=pc({farmId:p.publicKey,owner:this.scope.ownerPubKey,farmAuthority:f,lpVault:b,lpMint:s.lpMint,lockVault:s.lockInfo.lockVault,lockMint:s.lockInfo.lockMint,lockUserAccount:h,programId:s.programId,rewardInfo:P,rewardInfoConfig:g,nonce:y});return l.addInstruction({instructions:[T],instructionTypes:[w]}).versionBuild({txVersion:r,extInfo:{farmId:p.publicKey,farmAuthority:f,lpVault:b,lockUserAccount:h,nonce:y}})}async restartReward({farmInfo:e,payer:t,newRewardInfo:n,txVersion:o,feePayer:r}){var g;let i=_t[e.programId];i!==6&&this.logAndCreateError("invalid farm version ",i);let a=Me((await this.scope.api.fetchFarmKeysById({ids:e.id}))[0]),u={id:a.id,rewardInfos:e.rewardInfos,lpVault:a.lpVault,programId:a.programId};n.openTime>=n.endTime&&this.logAndCreateError("start time error","newRewardInfo",n);let s=t||this.scope.ownerPubKey,l=n.mint.equals(ot)?new Be(nt.address):n.mint,d=u.rewardInfos.findIndex(P=>new Be(P.mint.address).equals(l)),p=a.rewardInfos[d];p||this.logAndCreateError("configuration does not exist","rewardMint",l);let m=(g=p.vault)!=null?g:ot,f=this.createTxBuilder(r),{rewardPubKey:y,newInstruction:b}=await this._getUserRewardInfo({rewardInfo:n,payer:s});return b&&f.addInstruction(b),y||this.logAndCreateError("cannot found target token accounts",this.scope.account.tokenAccounts),f.addInstruction({instructions:[ls({payer:this.scope.ownerPubKey,rewardVault:m,userRewardTokenPub:y,farmKeys:u,rewardInfo:n})],instructionTypes:[U.FarmV6Restart]}).versionBuild({txVersion:o})}async restartRewards({farmInfo:e,payer:t,newRewardInfos:n,txVersion:o,feePayer:r}){var d;let i=_t[e.programId];i!==6&&this.logAndCreateError("invalid farm version ",i);let a=Me((await this.scope.api.fetchFarmKeysById({ids:e.id}))[0]),u={id:a.id,rewardInfos:e.rewardInfos,lpVault:a.lpVault,programId:a.programId};n.forEach(p=>{p.openTime>=p.endTime&&this.logAndCreateError("start time error","newRewardInfo",p)});let s=t||this.scope.ownerPubKey,l=this.createTxBuilder(r);for(let p of n){let m=p.mint.equals(ot)?new Be(nt.address):p.mint,f=u.rewardInfos.findIndex(I=>new Be(I.mint.address).equals(m)),y=a.rewardInfos[f];y||this.logAndCreateError("configuration does not exist","rewardMint",m);let b=(d=y.vault)!=null?d:ot,{rewardPubKey:g,newInstruction:P}=await this._getUserRewardInfo({rewardInfo:p,payer:s});P&&l.addInstruction(P),g||this.logAndCreateError("cannot found target token accounts",this.scope.account.tokenAccounts);let h=ls({payer:this.scope.ownerPubKey,rewardVault:b,userRewardTokenPub:g,farmKeys:u,rewardInfo:p});l.addInstruction({instructions:[h],instructionTypes:[U.FarmV6Restart]})}return l.versionBuild({txVersion:o})}async addNewRewardToken(e){let{txVersion:t,farmInfo:n,newRewardInfo:o,payer:r,feePayer:i}=e,a=_t[n.programId];a!==6&&this.logAndCreateError("invalid farm version ",a);let u=Me((await this.scope.api.fetchFarmKeysById({ids:n.id}))[0]),s=r!=null?r:this.scope.ownerPubKey,l=this.createTxBuilder(i),d=o.mint.equals(ot)?new Be(nt.address):o.mint,p=si({programId:new Be(n.programId),poolId:new Be(n.id),mint:d,type:"rewardVault"}),{rewardPubKey:m,newInstruction:f}=await this._getUserRewardInfo({rewardInfo:o,payer:s});return f&&l.addInstruction(f),m||this.logAndCreateError("annot found target token accounts",this.scope.account.tokenAccounts),o.mint=d,l.addInstruction({instructions:[ms({payer:this.scope.ownerPubKey,userRewardTokenPub:m,farmKeys:u,rewardVault:p,rewardInfo:o})],instructionTypes:[U.FarmV6CreatorAddReward]}).versionBuild({txVersion:t})}async addNewRewardsToken(e){let{txVersion:t,farmInfo:n,newRewardInfos:o,payer:r,feePayer:i}=e,a=_t[n.programId];a!==6&&this.logAndCreateError("invalid farm version ",a);let u=Me((await this.scope.api.fetchFarmKeysById({ids:n.id}))[0]),s=r!=null?r:this.scope.ownerPubKey,l=this.createTxBuilder(i);for(let d of o){let p=d.mint.equals(ot)?new Be(nt.address):d.mint,m=si({programId:new Be(n.programId),poolId:new Be(n.id),mint:p,type:"rewardVault"}),{rewardPubKey:f,newInstruction:y}=await this._getUserRewardInfo({rewardInfo:d,payer:s});y&&l.addInstruction(y),f||this.logAndCreateError("cannot found target token accounts",this.scope.account.tokenAccounts);let b=ms({payer:this.scope.ownerPubKey,userRewardTokenPub:f,farmKeys:u,rewardVault:m,rewardInfo:q(N({},d),{mint:p})});l.addInstruction({instructions:[b],instructionTypes:[U.FarmV6CreatorAddReward]})}return l.versionBuild({txVersion:t})}async deposit(e){let{txVersion:t,farmInfo:n,amount:o,feePayer:r,useSOLBalance:i,associatedOnly:a=!0,checkCreateATAOwner:u=!1,userAuxiliaryLedgers:s,computeBudgetConfig:l,txTipConfig:d}=e;this.scope.availability.addFarm===!1&&this.logAndCreateError("farm deposit feature disabled in your region");let{rewardInfos:p,programId:m}=n,f=_t[m];f===4&&this.logAndCreateError("V4 has suspended deposits:",n.programId),es(f)||this.logAndCreateError("invalid farm program:",n.programId);let[y,b]=[new Be(n.programId),new Be(n.id)],g=(await this.scope.api.fetchFarmKeysById({ids:n.id}))[0],P=dt({programId:y,poolId:b,owner:this.scope.ownerPubKey,version:f}),h=this.createTxBuilder(r);h.addCustomComputeBudget(l),h.addTipInstruction(d);let I={};for(let R of this.scope.account.tokenAccounts)if(a){let L=j(this.scope.ownerPubKey,R.mint,R.programId).publicKey;R.publicKey&&L.equals(R.publicKey)&&(I[R.mint.toString()]=R.publicKey)}else I[R.mint.toString()]=R.publicKey;let T=g.lpMint,w=I[T.address];w||this.logAndCreateError("you don't have any lp","lp zero",I);let x=[];for(let R of p){let L=i&&R.mint.address===H.toString(),W=I[R.mint.address];if(!W){let{account:z,instructionParams:$}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:R.mint.programId,mint:new Be(R.mint.address),notUseTokenAccount:L,createInfo:{payer:r||this.scope.ownerPubKey,amount:0},owner:this.scope.ownerPubKey,skipCloseAccount:!L,associatedOnly:L?!1:a,checkCreateATAOwner:u});W=z,$&&h.addInstruction($)}I[R.mint.address]=W,x.push(W)}let S,K=await this.scope.connection.getAccountInfo(P);if(K&&(S=Io(f).decode(K.data)),n.programId!==yo.toString()&&n.programId!==gn.FARM_PROGRAM_ID_V6.toString()&&!S){let{instruction:R,instructionType:L}=ci({id:b,programId:y,version:f,ledger:P,owner:this.scope.ownerPubKey});h.addInstruction({instructions:[R],instructionTypes:[L]})}let B=ts({version:f,rewardInfos:p,rewardTokenAccountsPublicKeys:x});B&&this.logAndCreateError(B);let C={amount:J(o),owner:this.scope.ownerPubKey,farmInfo:n,farmKeys:g,lpAccount:w,rewardAccounts:x,userAuxiliaryLedgers:s==null?void 0:s.map(R=>new Be(R))},M=f===6?Ac(C):f===5?gc(C):bc(C),F={3:U.FarmV3Deposit,5:U.FarmV5Deposit,6:U.FarmV6Deposit};return h.addInstruction({instructions:[M],instructionTypes:[F[f]]}).versionBuild({txVersion:t})}async withdraw(e){let{txVersion:t,farmInfo:n,amount:o,deposited:r,useSOLBalance:i,feePayer:a,associatedOnly:u=!0,checkCreateATAOwner:s=!1,userAuxiliaryLedgers:l,computeBudgetConfig:d,txTipConfig:p}=e,{rewardInfos:m}=n;this.scope.availability.removeFarm===!1&&this.logAndCreateError("farm withdraw feature disabled in your region");let f=_t[n.programId];es(f)||this.logAndCreateError("invalid farm program:",n.programId);let y=(await this.scope.api.fetchFarmKeysById({ids:n.id}))[0],b=this.createTxBuilder(a);b.addCustomComputeBudget(d),b.addTipInstruction(p);let g={};for(let B of this.scope.account.tokenAccounts)if(u){let C=j(this.scope.ownerPubKey,B.mint).publicKey;B.publicKey&&C.equals(B.publicKey)&&(g[B.mint.toString()]=B.publicKey)}else g[B.mint.toString()]=B.publicKey;if(f!==4){let B=dt({programId:new Be(n.programId),poolId:new Be(n.id),owner:this.scope.ownerPubKey,version:f}),C=await this.scope.connection.getAccountInfo(B);if(C)Io(f).decode(C.data).deposited.isZero()&&this.logAndCreateError("no deposited lp",{farmId:n.id});else if(f!==6){let{instruction:M,instructionType:F}=ci({id:new Be(y.id),programId:new Be(y.programId),version:f,ledger:B,owner:this.scope.ownerPubKey});b.addInstruction({instructions:[M],instructionTypes:[F]})}}r&&r.isZero()&&!(l||[]).length&&this.logAndCreateError("no deposited lp",{farmId:n.id});let P=y.lpMint.address,h=i&&P===H.toString(),I=g[P.toString()];if(!I){let{account:B,instructionParams:C}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:y.lpMint.programId,mint:new Be(P),notUseTokenAccount:h,createInfo:{payer:a||this.scope.ownerPubKey,amount:0},owner:this.scope.ownerPubKey,skipCloseAccount:!0,associatedOnly:h?!1:u,checkCreateATAOwner:s});I=B,C&&b.addInstruction(C)}g[P.toString()]=I;let T=[];for(let B of m){let C=i&&B.mint.address===H.toString(),M=g[B.mint.address];if(!M){let{account:F,instructionParams:R}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:B.mint.programId,mint:new Be(B.mint.address),notUseTokenAccount:C,createInfo:{payer:a||this.scope.ownerPubKey,amount:0},owner:this.scope.ownerPubKey,skipCloseAccount:!C,associatedOnly:C?!1:u,checkCreateATAOwner:s});M=F,R&&b.addInstruction(R)}g[B.mint.address]=M,T.push(M)}let w=ts({version:f,rewardInfos:m,rewardTokenAccountsPublicKeys:T});w&&this.logAndCreateError(w);let x={amount:J(o),owner:this.scope.ownerPubKey,farmInfo:n,farmKeys:y,lpAccount:I,rewardAccounts:T,userAuxiliaryLedgers:l==null?void 0:l.map(B=>new Be(B))},S=f===6?li(x):f===5?mi(x):f===4?yc(x):di(x),K={3:U.FarmV3Withdraw,4:U.FarmV4Withdraw,5:U.FarmV5Withdraw,6:U.FarmV6Withdraw};return b.addInstruction({instructions:[S],instructionTypes:[K[f]]}).versionBuild({txVersion:t})}async withdrawFarmReward({farmInfo:e,withdrawMint:t,txVersion:n,computeBudgetConfig:o,txTipConfig:r,feePayer:i}){var y;this.scope.checkOwner();let a=Me((await this.scope.api.fetchFarmKeysById({ids:e.id}))[0]),u=_t[e.programId];u!==6&&this.logAndCreateError("invalid farm version",u);let s=a.rewardInfos.find(b=>mt(b.mint.address).equals(mt(t)));s||this.logAndCreateError("withdraw mint error","rewardInfos",e);let l=(y=s==null?void 0:s.vault)!=null?y:ot,d=this.createTxBuilder(i),p;if(t.equals(ot)||t.equals(Be.default)){let b=await Ln({connection:this.scope.connection,owner:this.scope.ownerPubKey,payer:this.scope.ownerPubKey,amount:us(q(N({},s),{openTime:s.openTime,endTime:s.endTime,perSecond:new Vd(s.perSecond).mul(10**s.mint.decimals).toString()}))});p=b.addresses.newAccount,d.addInstruction(b)}else{let b=await this.scope.account.getCreatedTokenAccount({mint:t});b===null?(p=await this.scope.account.getAssociatedTokenAccount(t),d.addInstruction({instructions:[Pc(this.scope.ownerPubKey,p,this.scope.ownerPubKey,t)],instructionTypes:[U.CreateATA]})):p=b}let{instruction:m,instructionType:f}=fc({programId:a.programId,id:a.id,authority:a.authority,lpVault:a.lpVault,rewardVault:l,userRewardToken:p,owner:this.scope.ownerPubKey});return d.addCustomComputeBudget(o),d.addTipInstruction(r),d.addInstruction({instructions:[m],instructionTypes:[f]}).versionBuild({txVersion:n})}async harvestAllRewards(e){let{farmInfoList:t,useSOLBalance:n,feePayer:o,associatedOnly:r=!0,checkCreateATAOwner:i=!1,userAuxiliaryLedgers:a,txVersion:u,computeBudgetConfig:s}=e,l=this.createTxBuilder(o),d={};for(let f of this.scope.account.tokenAccounts)if(r){let y=j(this.scope.ownerPubKey,f.mint).publicKey;f.publicKey&&y.equals(f.publicKey)&&(d[f.mint.toString()]=f.publicKey)}else d[f.mint.toString()]=f.publicKey;let m=(await this.scope.api.fetchFarmKeysById({ids:Object.values(t).map(f=>f.id).join(",")})).reduce((f,y)=>q(N({},f),{[y.id]:y}),{});for(let f of Object.values(t)){let{programId:y,lpMint:b,rewardInfos:g,id:P}=f,h=_t[y],I=b.address,T=n&&I===H.toString(),w=d[I];if(!w){let{account:M,instructionParams:F}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:b.programId,mint:new Be(I),notUseTokenAccount:T,createInfo:{payer:o||this.scope.ownerPubKey,amount:0},owner:this.scope.ownerPubKey,skipCloseAccount:!0,associatedOnly:T?!1:r,checkCreateATAOwner:i});w=M,F&&l.addInstruction(F)}d[I.toString()]=w;let x=[];for(let M of g){let F=n&&M.mint.address===H.toString(),R=d[M.mint.address];if(!R)if(F){let{account:L,instructionParams:W}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:M.mint.programId,mint:new Be(M.mint.address),notUseTokenAccount:F,createInfo:{payer:o||this.scope.ownerPubKey,amount:0},owner:this.scope.ownerPubKey,skipCloseAccount:!F,associatedOnly:F?!1:r,checkCreateATAOwner:i});R=L,W&&l.addInstruction(W)}else{let L=new Be(M.mint.address);R=this.scope.account.getAssociatedTokenAccount(L),l.addInstruction({instructions:[Pc(this.scope.ownerPubKey,R,this.scope.ownerPubKey,L)]})}d[M.mint.address]=R,x.push(R)}let S=m[P],K={amount:It,owner:this.scope.ownerPubKey,farmInfo:f,farmKeys:S,lpAccount:w,rewardAccounts:x,userAuxiliaryLedgers:a==null?void 0:a.map(M=>new Be(M))},B=h===6?li(K):h===5?mi(K):di(K),C={3:U.FarmV3Withdraw,5:U.FarmV5Withdraw,6:U.FarmV6Withdraw};l.addInstruction({instructions:[B],instructionTypes:[C[h]]})}return u===1?l.sizeCheckBuild({computeBudgetConfig:s}):l.sizeCheckBuildV0({computeBudgetConfig:s})}};import{PublicKey as He}from"@solana/web3.js";import{AccountLayout as xp,NATIVE_MINT as Dr,TOKEN_PROGRAM_ID as vn}from"@solana/spl-token";import{Keypair as Or,PublicKey as G,SystemProgram as Tn,TransactionInstruction as lt}from"@solana/web3.js";import hs from"bn.js";import{ASSOCIATED_TOKEN_PROGRAM_ID as wi,TOKEN_2022_PROGRAM_ID as Ue,TOKEN_PROGRAM_ID as Ke}from"@solana/spl-token";import Yd from"bn.js";import Ko from"decimal.js";import Et from"bn.js";var be=new Et(0),Lt=new Et(1),Pn=new Et(-1),Je=new Et(1).shln(64),xr=new Et(1).shln(128),fi=Je.sub(Lt),yi=64,kc=xr.subn(1),pt=-443636,Pt=-pt,Dt=new Et("4295048016"),Wt=new Et("79226673521066979257578248091"),Sr=new Et("4295048017"),Kr=new Et("79226673521066979257578248090"),wc=16,Tc="59543866431248",hc="184467440737095516",Ic="15793534762490258745",Cr=new Et(10).pow(new Et(6)),_d=(n=>(n[n.rate_500=500]="rate_500",n[n.rate_3000=3e3]="rate_3000",n[n.rate_10000=1e4]="rate_10000",n))(_d||{}),Aw={[500]:10,[3e3]:60,[1e4]:200},Pw={version:6,liquidity:be,tickCurrent:0,feeGrowthGlobalX64A:be,feeGrowthGlobalX64B:be,protocolFeesTokenA:be,protocolFeesTokenB:be,swapInAmountTokenA:be,swapOutAmountTokenB:be,swapInAmountTokenB:be,swapOutAmountTokenA:be,tickArrayBitmap:[],rewardInfos:[],day:{volume:0,volumeFee:0,feeA:0,feeB:0,feeApr:0,rewardApr:{A:0,B:0,C:0},apr:0,priceMax:0,priceMin:0},week:{volume:0,volumeFee:0,feeA:0,feeB:0,feeApr:0,rewardApr:{A:0,B:0,C:0},apr:0,priceMax:0,priceMin:0},month:{volume:0,volumeFee:0,feeA:0,feeB:0,feeApr:0,rewardApr:{A:0,B:0,C:0},apr:0,priceMax:0,priceMin:0},tvl:0},Bc={tvl:0,volumeQuote:0,mintAmountA:0,mintAmountB:0,rewardDefaultInfos:[],farmUpcomingCount:0,farmOngoingCount:0,farmFinishedCount:0,day:{volume:0,volumeQuote:0,volumeFee:0,apr:0,feeApr:0,priceMin:0,priceMax:0,rewardApr:[0]},week:{volume:0,volumeQuote:0,volumeFee:0,apr:0,feeApr:0,priceMin:0,priceMax:0,rewardApr:[0]},month:{volume:0,volumeQuote:0,volumeFee:0,apr:0,feeApr:0,priceMin:0,priceMax:0,rewardApr:[0]},pooltype:[]},kw=new Et("18446744073700000000");import me from"bn.js";import mn from"decimal.js";function Rr(c){let e=new ArrayBuffer(2);return new DataView(e).setUint16(0,c,!1),new Uint8Array(e)}function Tw(c){let e=new ArrayBuffer(2);return new DataView(e).setInt16(0,c,!1),new Uint8Array(e)}function hw(c){let e=new ArrayBuffer(4);return new DataView(e).setUint32(0,c,!1),new Uint8Array(e)}function Lr(c){let e=new ArrayBuffer(4);return new DataView(e).setInt32(0,c,!1),new Uint8Array(e)}function ds(c,e){let t=0;for(let n=c-1;n>=0&&!e.testn(n);n--)t++;return t}function ps(c,e){let t=0;for(let n=0;n<c&&!e.testn(n);n++)t++;return t}function bi(c,e){for(let t=0;t<c;t++)if(e.testn(t))return!1;return!0}function xc(c,e){return bi(c,e)?null:ds(c,e)}function Sc(c,e){return bi(c,e)?null:ps(c,e)}var Ed=Buffer.from("amm_config","utf8"),fs=Buffer.from("pool","utf8"),ys=Buffer.from("pool_vault","utf8"),Dd=Buffer.from("pool_reward_vault","utf8"),Kc=Buffer.from("position","utf8"),Wd=Buffer.from("tick_array","utf8"),qd=Buffer.from("operation","utf8"),Ud=Buffer.from("pool_tick_array_bitmap_extension","utf8"),Gd=Buffer.from("observation","utf8");function Sw(c,e){return ne([Ed,Rr(e)],c)}function Cc(c,e,t,n){return ne([fs,e.toBuffer(),t.toBuffer(),n.toBuffer()],c)}function bs(c,e,t){return ne([ys,e.toBuffer(),t.toBuffer()],c)}function Rc(c,e,t){return ne([Dd,e.toBuffer(),t.toBuffer()],c)}function ge(c,e,t){return ne([Wd,e.toBuffer(),Lr(t)],c)}function nn(c,e,t,n){return ne([Kc,e.toBuffer(),Lr(t),Lr(n)],c)}function kt(c,e){return ne([Kc,e.toBuffer()],c)}function kn(c){return ne([Buffer.from("metadata","utf8"),jt.toBuffer(),c.toBuffer()],jt)}function gi(c){return ne([qd],c)}function Qe(c,e){return ne([Ud,e.toBuffer()],c)}function Lc(c,e){return ne([Gd,e.toBuffer()],c)}var Oc=Buffer.from("locked_position","utf8");function gs(c,e){return ne([Oc,e.toBuffer()],c)}function xo(c,e){return ne([Oc,e.toBuffer()],c)}var Xd=Buffer.from("support_mint","utf8");function As(c,e){return ne([Xd,e.toBuffer()],c)}import{PublicKey as Ot}from"@solana/web3.js";import{TOKEN_2022_PROGRAM_ID as Nc}from"@solana/spl-token";import _e from"bn.js";import Pe from"decimal.js";import ln from"bn.js";import Ps from"decimal.js";var Ai=class{static getfeeGrowthInside(e,t,n){let o=new ln(0),r=new ln(0);e.tickCurrent>=t.tick?(o=t.feeGrowthOutsideX64A,r=t.feeGrowthOutsideX64B):(o=e.feeGrowthGlobalX64A.sub(t.feeGrowthOutsideX64A),r=e.feeGrowthGlobalX64B.sub(t.feeGrowthOutsideX64B));let i=new ln(0),a=new ln(0);e.tickCurrent<n.tick?(i=n.feeGrowthOutsideX64A,a=n.feeGrowthOutsideX64B):(i=e.feeGrowthGlobalX64A.sub(n.feeGrowthOutsideX64A),a=e.feeGrowthGlobalX64B.sub(n.feeGrowthOutsideX64B));let u=ue.wrappingSubU128(ue.wrappingSubU128(e.feeGrowthGlobalX64A,o),i),s=ue.wrappingSubU128(ue.wrappingSubU128(e.feeGrowthGlobalX64B,r),a);return{feeGrowthInsideX64A:u,feeGrowthInsideBX64:s}}static GetPositionFees(e,t,n,o){let{feeGrowthInsideX64A:r,feeGrowthInsideBX64:i}=this.getfeeGrowthInside(e,n,o),a=ue.mulDivFloor(ue.wrappingSubU128(r,t.feeGrowthInsideLastX64A),t.liquidity,Je),u=t.tokenFeesOwedA.add(a),s=ue.mulDivFloor(ue.wrappingSubU128(i,t.feeGrowthInsideLastX64B),t.liquidity,Je),l=t.tokenFeesOwedB.add(s);return{tokenFeeAmountA:u,tokenFeeAmountB:l}}static GetPositionFeesV2(e,t,n,o){let{feeGrowthInsideX64A:r,feeGrowthInsideBX64:i}=this.getfeeGrowthInside(e,n,o),a=ue.mulDivFloor(ue.wrappingSubU128(r,t.feeGrowthInsideLastX64A),t.liquidity,Je),u=t.tokenFeesOwedA.add(a),s=ue.mulDivFloor(ue.wrappingSubU128(i,t.feeGrowthInsideLastX64B),t.liquidity,Je),l=t.tokenFeesOwedB.add(s);return{tokenFeeAmountA:u,tokenFeeAmountB:l}}static GetPositionRewardsV2(e,t,n,o){let r=[],i=this.getRewardGrowthInsideV2(e.tickCurrent,n,o,e.rewardInfos);for(let a=0;a<i.length;a++){let u=i[a],s=t.rewardInfos[a],l=ue.wrappingSubU128(u,s.growthInsideLastX64),d=ue.mulDivFloor(l,t.liquidity,Je),p=s.rewardAmountOwed.add(d);r.push(p)}return r}static GetPositionRewards(e,t,n,o){let r=[],i=this.getRewardGrowthInside(e.tickCurrent,n,o,e.rewardInfos);for(let a=0;a<i.length;a++){let u=i[a],s=t.rewardInfos[a],l=ue.wrappingSubU128(u,s.growthInsideLastX64),d=ue.mulDivFloor(l,t.liquidity,Je),p=s.rewardAmountOwed.add(d);r.push(p)}return r}static getRewardGrowthInside(e,t,n,o){let r=[];for(let i=0;i<o.length;i++){let a=new ln(0);t.liquidityGross.eqn(0)?a=o[i].rewardGrowthGlobalX64:e<t.tick?a=o[i].rewardGrowthGlobalX64.sub(t.rewardGrowthsOutsideX64[i]):a=t.rewardGrowthsOutsideX64[i];let u=new ln(0);n.liquidityGross.eqn(0)||(e<n.tick?u=n.rewardGrowthsOutsideX64[i]:u=o[i].rewardGrowthGlobalX64.sub(n.rewardGrowthsOutsideX64[i])),r.push(ue.wrappingSubU128(ue.wrappingSubU128(o[i].rewardGrowthGlobalX64,a),u))}return r}static getRewardGrowthInsideV2(e,t,n,o){let r=[];for(let i=0;i<o.length;i++){let a=new ln(0);t.liquidityGross.eqn(0)?a=o[i].rewardGrowthGlobalX64:e<t.tick?a=o[i].rewardGrowthGlobalX64.sub(t.rewardGrowthsOutsideX64[i]):a=t.rewardGrowthsOutsideX64[i];let u=new ln(0);n.liquidityGross.eqn(0)||(e<n.tick?u=n.rewardGrowthsOutsideX64[i]:u=o[i].rewardGrowthGlobalX64.sub(n.rewardGrowthsOutsideX64[i])),r.push(ue.wrappingSubU128(ue.wrappingSubU128(o[i].rewardGrowthGlobalX64,a),u))}return r}static getAmountsFromLiquidity({poolInfo:e,ownerPosition:t,liquidity:n,slippage:o,add:r,epochInfo:i}){var b,g,P,h;let a=ie.priceToSqrtPriceX64(new Ps(e.price),e.mintA.decimals,e.mintB.decimals),u=ie.getSqrtPriceX64FromTick(t.tickLower),s=ie.getSqrtPriceX64FromTick(t.tickUpper),l=r?1+o:1-o,d=Ae.getAmountsFromLiquidity(a,u,s,n,r),[p,m]=[he(d.amountA,(b=e.mintA.extensions)==null?void 0:b.feeConfig,i,!0),he(d.amountB,(g=e.mintB.extensions)==null?void 0:g.feeConfig,i,!0)],[f,y]=[he(new ln(new Ps(d.amountA.toString()).mul(l).toFixed(0)),(P=e.mintA.extensions)==null?void 0:P.feeConfig,i,!0),he(new ln(new Ps(d.amountB.toString()).mul(l).toFixed(0)),(h=e.mintB.extensions)==null?void 0:h.feeConfig,i,!0)];return{liquidity:n,amountA:p,amountB:m,amountSlippageA:f,amountSlippageB:y,expirationTime:$t(p.expirationTime,m.expirationTime)}}};var zd=15,ke=class{static async getTickArrays(e,t,n,o,r,i,a){let u=[],s=Z.getTickArrayStartIndexByTick(o,r),l=Z.getInitializedTickArrayInRange(i,a,r,s,Math.floor(zd/2));for(let m=0;m<l.length;m++){let{publicKey:f}=ge(t,n,l[m]);u.push(f)}let d=(await Yt(e,u)).map(m=>m!==null?Pi.decode(m.data):null),p={};for(let m=0;m<u.length;m++){let f=d[m];f!==null&&(p[f.startTickIndex]=q(N({},f),{address:u[m]}))}return p}static nextInitializedTick(e,t,n,o,r,i){let{initializedTick:a,tickArrayAddress:u,tickArrayStartTickIndex:s}=this.nextInitializedTickInOneArray(e,t,n,o,r,i);for(;a==null||a.liquidityGross.lten(0);){if(s=Z.getNextTickArrayStartIndex(s,r,i),this.checkIsValidStartIndex(s,r))throw new Error("No enough initialized tickArray");let l=n[s];if(l===void 0)continue;let{nextTick:d,tickArrayAddress:p,tickArrayStartTickIndex:m}=this.firstInitializedTickInOneArray(e,t,l,i);[a,u,s]=[d,p,m]}if(a==null)throw new Error("No invaild tickArray cache");return{nextTick:a,tickArrayAddress:u,tickArrayStartTickIndex:s}}static nextInitializedTickArray(e,t,n,o,r){let i=Math.floor(e/ke.tickCount(t)),a=n?Z.searchLowBitFromStart(o,r,i-1,1,t):Z.searchHightBitFromStart(o,r,i+1,1,t);return a.length>0?{isExist:!0,nextStartIndex:a[0]}:{isExist:!1,nextStartIndex:0}}static firstInitializedTickInOneArray(e,t,n,o){let r;if(o){let a=et-1;for(;a>=0;){let u=n.ticks[a];if(u.liquidityGross.gtn(0)){r=u;break}a=a-1}}else{let a=0;for(;a<et;){let u=n.ticks[a];if(u.liquidityGross.gtn(0)){r=u;break}a=a+1}}let{publicKey:i}=ge(e,t,n.startTickIndex);return{nextTick:r,tickArrayAddress:i,tickArrayStartTickIndex:n.startTickIndex}}static nextInitializedTickInOneArray(e,t,n,o,r,i){let a=Z.getTickArrayStartIndexByTick(o,r),u=Math.floor((o-a)/r),s=n[a];if(s==null)return{initializedTick:void 0,tickArrayAddress:void 0,tickArrayStartTickIndex:a};let l;if(i)for(;u>=0;){let p=s.ticks[u];if(p.liquidityGross.gtn(0)){l=p;break}u=u-1}else for(u=u+1;u<et;){let p=s.ticks[u];if(p.liquidityGross.gtn(0)){l=p;break}u=u+1}let{publicKey:d}=ge(e,t,a);return{initializedTick:l,tickArrayAddress:d,tickArrayStartTickIndex:s.startTickIndex}}static getArrayStartIndex(e,t){let n=this.tickCount(t);return Math.floor(e/n)*n}static checkIsValidStartIndex(e,t){if(Z.checkIsOutOfBoundary(e)){if(e>Pt)return!1;let n=Z.getTickArrayStartIndexByTick(pt,t);return e==n}return e%this.tickCount(t)==0}static tickCount(e){return et*e}};var ks=14,wn=class{static maxTickInTickarrayBitmap(e){return e*et*Yn}static getBitmapTickBoundary(e,t){let n=this.maxTickInTickarrayBitmap(t),o=Math.floor(Math.abs(e)/n);e<0&&Math.abs(e)%n!=0&&(o+=1);let r=n*o;return e<0?{minValue:-r,maxValue:-r+n}:{minValue:r,maxValue:r+n}}static nextInitializedTickArrayStartIndex(e,t,n,o){if(!ke.checkIsValidStartIndex(t,n))throw Error("nextInitializedTickArrayStartIndex check error");let r=this.maxTickInTickarrayBitmap(n),i=o?t-ke.tickCount(n):t+ke.tickCount(n);if(i<-r||i>=r)return{isInit:!1,tickIndex:t};let a=n*et,u=i/a+512;i<0&&i%a!=0&&u--;let s=Math.abs(u);if(o){let l=e.shln(1024-s-1),d=xc(1024,l);if(d!==null){let p=(s-d-512)*a;return{isInit:!0,tickIndex:p}}else return{isInit:!1,tickIndex:-r}}else{let l=e.shrn(s),d=Sc(1024,l);if(d!==null){let p=(s+d-512)*a;return{isInit:!0,tickIndex:p}}else return{isInit:!1,tickIndex:r-ke.tickCount(n)}}}},ki=class{static getBitmapOffset(e,t){if(!ke.checkIsValidStartIndex(e,t))throw new Error("No enough initialized tickArray");this.checkExtensionBoundary(e,t);let n=wn.maxTickInTickarrayBitmap(t),o=Math.floor(Math.abs(e)/n)-1;return e<0&&Math.abs(e)%n===0&&o--,o}static getBitmap(e,t,n){let o=this.getBitmapOffset(e,t);return e<0?{offset:o,tickarrayBitmap:n.negativeTickArrayBitmap[o]}:{offset:o,tickarrayBitmap:n.positiveTickArrayBitmap[o]}}static checkExtensionBoundary(e,t){let{positiveTickBoundary:n,negativeTickBoundary:o}=this.extensionTickBoundary(t);if(e>=o&&e<n)throw Error("checkExtensionBoundary -> InvalidTickArrayBoundary")}static extensionTickBoundary(e){let t=wn.maxTickInTickarrayBitmap(e),n=-t;if(Pt<=t)throw Error(`extensionTickBoundary check error: ${Pt}, ${t}`);if(n<=pt)throw Error(`extensionTickBoundary check error: ${n}, ${pt}`);return{positiveTickBoundary:t,negativeTickBoundary:n}}static checkTickArrayIsInit(e,t,n){let{tickarrayBitmap:o}=this.getBitmap(e,t,n),r=this.tickArrayOffsetInBitmap(e,t);return{isInitialized:Z.mergeTickArrayBitmap(o).testn(r),startIndex:e}}static nextInitializedTickArrayFromOneBitmap(e,t,n,o){let r=ke.tickCount(t),i=n?e-r:e+r,{tickarrayBitmap:a}=this.getBitmap(i,t,o);return this.nextInitializedTickArrayInBitmap(a,i,t,n)}static nextInitializedTickArrayInBitmap(e,t,n,o){let{minValue:r,maxValue:i}=wn.getBitmapTickBoundary(t,n),a=this.tickArrayOffsetInBitmap(t,n);if(o){let u=Z.mergeTickArrayBitmap(e).shln(Yn-1-a),s=bi(512,u)?null:ds(512,u);if(s!==null){let l=t-s*ke.tickCount(n);return{isInit:!0,tickIndex:l}}else return{isInit:!1,tickIndex:r}}else{let u=Z.mergeTickArrayBitmap(e).shrn(a),s=bi(512,u)?null:ps(512,u);if(s!==null){let l=t+s*ke.tickCount(n);return{isInit:!0,tickIndex:l}}else return{isInit:!1,tickIndex:i-ke.tickCount(n)}}}static tickArrayOffsetInBitmap(e,t){let n=Math.abs(e)%wn.maxTickInTickarrayBitmap(t),o=Math.floor(n/ke.tickCount(t));return e<0&&n!=0&&(o=Yn-o),o}};var Ne=class{static getOutputAmountAndRemainAccounts(e,t,n,o,r,i=!1){let a=n.toBase58()===e.mintA.address,u=[],{isExist:s,startIndex:l,nextAccountMeta:d}=this.getFirstInitializedTickArray(e,a);if(!s||l===void 0||!d)throw new Error("Invalid tick array");u.push(d);let{allTrade:p,amountCalculated:m,accounts:f,sqrtPriceX64:y,feeAmount:b}=jn.swapCompute(e.programId,e.id,t,e.tickArrayBitmap,e.exBitmapInfo,a,e.ammConfig.tradeFeeRate,e.liquidity,e.tickCurrent,e.tickSpacing,e.sqrtPriceX64,o,l,r,i);return u.push(...f),{allTrade:p,expectedAmountOut:m.mul(Pn),remainingAccounts:u,executionPrice:y,feeAmount:b}}static getInputAmountAndRemainAccounts(e,t,n,o,r){let i=n.toBase58()===e.mintB.address,a=[],{isExist:u,startIndex:s,nextAccountMeta:l}=this.getFirstInitializedTickArray(e,i);if(!u||s===void 0||!l)throw new Error("Invalid tick array");try{let y=this.preInitializedTickArrayStartIndex(e,i);if(y.isExist){let{publicKey:b}=ge(e.programId,e.id,y.nextStartIndex);a.push(b)}}catch{}a.push(l);let{amountCalculated:d,accounts:p,sqrtPriceX64:m,feeAmount:f}=jn.swapCompute(e.programId,e.id,t,e.tickArrayBitmap,e.exBitmapInfo,i,e.ammConfig.tradeFeeRate,e.liquidity,e.tickCurrent,e.tickSpacing,e.sqrtPriceX64,o.mul(Pn),s,r);return a.push(...p),{expectedAmountIn:d,remainingAccounts:a,executionPrice:m,feeAmount:f}}static getFirstInitializedTickArray(e,t){let{isInitialized:n,startIndex:o}=Ne.isOverflowDefaultTickarrayBitmap(e.tickSpacing,[e.tickCurrent])?ki.checkTickArrayIsInit(ke.getArrayStartIndex(e.tickCurrent,e.tickSpacing),e.tickSpacing,e.exBitmapInfo):Z.checkTickArrayIsInitialized(Z.mergeTickArrayBitmap(e.tickArrayBitmap),e.tickCurrent,e.tickSpacing);if(n){let{publicKey:a}=ge(e.programId,e.id,o);return{isExist:!0,startIndex:o,nextAccountMeta:a}}let{isExist:r,nextStartIndex:i}=this.nextInitializedTickArrayStartIndex(e,ke.getArrayStartIndex(e.tickCurrent,e.tickSpacing),t);if(r){let{publicKey:a}=ge(e.programId,e.id,i);return{isExist:!0,startIndex:i,nextAccountMeta:a}}return{isExist:!1,nextAccountMeta:void 0,startIndex:void 0}}static preInitializedTickArrayStartIndex(e,t){let n=Math.floor(e.tickCurrent/ke.tickCount(e.tickSpacing)),o=t?Z.searchHightBitFromStart(e.tickArrayBitmap,e.exBitmapInfo,n+1,1,e.tickSpacing):Z.searchLowBitFromStart(e.tickArrayBitmap,e.exBitmapInfo,n-1,1,e.tickSpacing);return o.length>0?{isExist:!0,nextStartIndex:o[0]}:{isExist:!1,nextStartIndex:0}}static nextInitializedTickArrayStartIndex(e,t,n){for(t=ke.getArrayStartIndex(e.tickCurrent,e.tickSpacing);;){let{isInit:o,tickIndex:r}=wn.nextInitializedTickArrayStartIndex(Z.mergeTickArrayBitmap(e.tickArrayBitmap),t,e.tickSpacing,n);if(o)return{isExist:!0,nextStartIndex:r};t=r;let{isInit:i,tickIndex:a}=ki.nextInitializedTickArrayFromOneBitmap(t,e.tickSpacing,n,e.exBitmapInfo);if(i)return{isExist:!0,nextStartIndex:a};if(t=a,t<pt||t>Pt)return{isExist:!1,nextStartIndex:0}}}static async updatePoolRewardInfos({connection:e,apiPoolInfo:t,chainTime:n,poolLiquidity:o,rewardInfos:r}){var a,u,s;let i=[];for(let l=0;l<r.length;l++){let d=r[l],p=(s=(a=t.rewardDefaultInfos[l])==null?void 0:a.mint.programId)!=null?s:(u=await e.getAccountInfo(d.tokenMint))==null?void 0:u.owner;if(p===void 0)throw Error("get new reward mint info error");let m=q(N({},d),{perSecond:ue.x64ToDecimal(d.emissionsPerSecondX64),remainingRewards:void 0,tokenProgramId:new Ot(p)});if(m.tokenMint.equals(Ot.default))continue;if(n<=m.openTime.toNumber()||o.eq(be)){i.push(m);continue}let f=new _e(Math.min(m.endTime.toNumber(),n)),y=f.sub(m.lastUpdateTime),b=ue.mulDivFloor(y,m.emissionsPerSecondX64,o),g=m.rewardGrowthGlobalX64.add(b),P=ue.mulDivFloor(y,m.emissionsPerSecondX64,Je),h=m.rewardTotalEmissioned.add(P);i.push(q(N({},m),{rewardGrowthGlobalX64:g,rewardTotalEmissioned:h,lastUpdateTime:f}))}return i}static isOverflowDefaultTickarrayBitmap(e,t){let{maxTickBoundary:n,minTickBoundary:o}=this.tickRange(e);for(let r of t){let i=Z.getTickArrayStartIndexByTick(r,e);if(i>=n||i<o)return!0}return!1}static tickRange(e){let t=wn.maxTickInTickarrayBitmap(e),n=-t;return t>Pt&&(t=ke.getArrayStartIndex(Pt,e)+ke.tickCount(e)),n<pt&&(n=ke.getArrayStartIndex(pt,e)),{maxTickBoundary:t,minTickBoundary:n}}static get_tick_array_offset(e,t){if(!ke.checkIsValidStartIndex(e,t))throw new Error("No enough initialized tickArray");return e/ke.tickCount(t)*Yn}static async fetchExBitmaps({connection:e,exBitmapAddress:t,batchRequest:n}){let o=await Oe(e,t.map(i=>({pubkey:i})),{batchRequest:n}),r={};for(let i of o)i.accountInfo!==null&&(r[i.pubkey.toString()]=vc.decode(i.accountInfo.data));return r}static async fetchMultiplePoolTickArrays({connection:e,poolKeys:t,batchRequest:n}){let o={},r=[];for(let u of t){let s=Z.getTickArrayStartIndexByTick(u.tickCurrent,u.tickSpacing),l=Z.getInitializedTickArrayInRange(u.tickArrayBitmap,u.exBitmapInfo,u.tickSpacing,s,7);for(let d of l){let{publicKey:p}=ge(u.programId,u.id,d);r.push({pubkey:p}),o[p.toString()]=u.id}}let i=await Oe(e,r,{batchRequest:n}),a={};for(let u of i){if(!u.accountInfo)continue;let s=o[u.pubkey.toString()];if(!s)continue;a[s.toString()]===void 0&&(a[s.toString()]={});let l=Pi.decode(u.accountInfo.data);a[s.toString()][l.startTickIndex]=q(N({},l),{address:u.pubkey})}return a}static async fetchPoolsAccountPosition({pools:e,connection:t,ownerInfo:n,batchRequest:o=!1,updateOwnerRewardAndFee:r=!0}){var a;let i=[];for(let u=0;u<e.length;u++){let s=e[u];s!==null&&(i.find(l=>l.equals(s.state.programId))||i.push(s.state.programId))}if(n){let u=n.tokenAccounts.map(p=>p.accountInfo.mint),s=[];for(let p of u)for(let m of i)s.push(kt(m,p).publicKey);let l=await Yt(t,s,{batchRequest:o}),d={};for(let p of l){if(p===null)continue;let m=So.decode(p.data),f=m.poolId.toString(),y=e.find(S=>S.state.id.toBase58()===f);if(y===void 0)continue;let b=y.state,g=Z._getTickPriceLegacy({poolInfo:b,tick:m.tickLower,baseIn:!0}),P=Z._getTickPriceLegacy({poolInfo:b,tick:m.tickUpper,baseIn:!0}),{amountA:h,amountB:I}=Ae.getAmountsFromLiquidity(b.sqrtPriceX64,g.tickSqrtPriceX64,P.tickSqrtPriceX64,m.liquidity,!1),T=1/(1-Math.sqrt(Math.sqrt(g.price.div(P.price).toNumber())));y.positionAccount=[...(a=y.positionAccount)!=null?a:[],{poolId:m.poolId,nftMint:m.nftMint,priceLower:g.price,priceUpper:P.price,amountA:h,amountB:I,tickLower:m.tickLower,tickUpper:m.tickUpper,liquidity:m.liquidity,feeGrowthInsideLastX64A:m.feeGrowthInsideLastX64A,feeGrowthInsideLastX64B:m.feeGrowthInsideLastX64B,tokenFeesOwedA:m.tokenFeesOwedA,tokenFeesOwedB:m.tokenFeesOwedB,rewardInfos:m.rewardInfos.map(S=>q(N({},S),{pendingReward:new _e(0)})),leverage:T,tokenFeeAmountA:new _e(0),tokenFeeAmountB:new _e(0)}];let w=await Z.getTickArrayAddressByTick(y.state.programId,m.poolId,m.tickLower,y.state.tickSpacing),x=await Z.getTickArrayAddressByTick(y.state.programId,m.poolId,m.tickUpper,y.state.tickSpacing);d[`${y.state.programId.toString()}-${m.poolId.toString()}-${m.tickLower}`]=w,d[`${y.state.programId.toString()}-${m.poolId.toString()}-${m.tickUpper}`]=x}if(r){let p=Object.values(d),m=await Yt(t,p,{batchRequest:o}),f={};for(let y=0;y<p.length;y++){let b=m[y];if(b===null)continue;let g=p[y].toString();f[g]=Pi.decode(b.data)}for(let{state:y,positionAccount:b}of e)if(!!b)for(let g of b){let P=`${y.programId.toString()}-${y.id.toString()}-${g.tickLower}`,h=`${y.programId.toString()}-${y.id.toString()}-${g.tickUpper}`,I=f[d[P].toString()],T=f[d[h].toString()],w=I.ticks[Z.getTickOffsetInArray(g.tickLower,y.tickSpacing)],x=T.ticks[Z.getTickOffsetInArray(g.tickUpper,y.tickSpacing)],{tokenFeeAmountA:S,tokenFeeAmountB:K}=await Ai.GetPositionFees(y,g,w,x),B=await Ai.GetPositionRewards(y,g,w,x);g.tokenFeeAmountA=S.gte(new _e(0))?S:new _e(0),g.tokenFeeAmountB=K.gte(new _e(0))?K:new _e(0);for(let C=0;C<B.length;C++)g.rewardInfos[C].pendingReward=B[C].gte(new _e(0))?B[C]:new _e(0)}}}return e}static computeAmountOut({poolInfo:e,tickArrayCache:t,baseMint:n,epochInfo:o,amountIn:r,slippage:i,priceLimit:a=new Pe(0),catchLiquidityInsufficient:u=!1}){var M;let s,l=n.toBase58()===e.mintA.address,[d,p]=l?[e.mintA.extensions.feeConfig,e.mintB.extensions.feeConfig]:[e.mintB.extensions.feeConfig,e.mintA.extensions.feeConfig];a.equals(new Pe(0))?s=l?Dt.add(new _e(1)):Wt.sub(new _e(1)):s=ie.priceToSqrtPriceX64(a,e.mintA.decimals,e.mintB.decimals);let m=he(r,d,o,!1),{allTrade:f,expectedAmountOut:y,remainingAccounts:b,executionPrice:g,feeAmount:P}=Ne.getOutputAmountAndRemainAccounts(e,t,n,m.amount.sub((M=m.fee)!=null?M:be),s,u),h=he(y,p,o,!1),I=ie.sqrtPriceX64ToPrice(g,e.mintA.decimals,e.mintB.decimals),T=l?I:new Pe(1).div(I),w=y.mul(new _e(Math.floor((1-i)*1e10))).div(new _e(1e10)),x=he(w,p,o,!1),S=l?e.currentPrice:new Pe(1).div(e.currentPrice),K=new Pe(T).sub(S).abs(),B=S,C=new it(new Pe(K).mul(10**15).toFixed(0),new Pe(B).mul(10**15).toFixed(0));return{allTrade:f,realAmountIn:m,amountOut:h,minAmountOut:x,expirationTime:$t(m.expirationTime,h.expirationTime),currentPrice:e.currentPrice,executionPrice:T,priceImpact:C,fee:P,remainingAccounts:b,executionPriceX64:g}}static computeAmountOutFormat({poolInfo:e,tickArrayCache:t,amountIn:n,tokenOut:o,slippage:r,epochInfo:i,catchLiquidityInsufficient:a=!1}){let u=o.address===e.mintB.address,[s,l]=u?[e.mintA,e.mintB]:[e.mintB,e.mintA],[d,p]=[new De(q(N({},s),{mint:s.address,isToken2022:s.programId===Nc.toBase58()})),new De(q(N({},l),{mint:l.address,isToken2022:l.programId===Nc.toBase58()}))],{allTrade:m,realAmountIn:f,amountOut:y,minAmountOut:b,expirationTime:g,currentPrice:P,executionPrice:h,priceImpact:I,fee:T,remainingAccounts:w,executionPriceX64:x}=Ne.computeAmountOut({poolInfo:e,tickArrayCache:t,baseMint:new Ot(s.address),amountIn:n,slippage:r,epochInfo:i,catchLiquidityInsufficient:a}),S=q(N({},f),{amount:new Se(d,f.amount),fee:f.fee===void 0?void 0:new Se(d,f.fee)}),K=q(N({},y),{amount:new Se(p,y.amount),fee:y.fee===void 0?void 0:new Se(p,y.fee)}),B=q(N({},b),{amount:new Se(p,b.amount),fee:b.fee===void 0?void 0:new Se(p,b.fee)}),C=new ht({baseToken:d,denominator:new _e(10).pow(new _e(20+d.decimals)),quoteToken:p,numerator:P.mul(new Pe(10**(20+p.decimals))).toFixed(0)}),M=new ht({baseToken:d,denominator:new _e(10).pow(new _e(20+d.decimals)),quoteToken:p,numerator:h.mul(new Pe(10**(20+p.decimals))).toFixed(0)}),F=new Se(d,T);return{allTrade:m,realAmountIn:S,amountOut:K,minAmountOut:B,expirationTime:g,currentPrice:C,executionPrice:M,priceImpact:I,fee:F,remainingAccounts:w,executionPriceX64:x}}static computeAmountIn({poolInfo:e,tickArrayCache:t,baseMint:n,epochInfo:o,amountOut:r,slippage:i,priceLimit:a=new Pe(0)}){var B;let u=n.toBase58()===e.mintA.address,s={[e.mintA.address]:e.mintA.extensions.feeConfig,[e.mintB.address]:e.mintB.extensions.feeConfig},l;a.equals(new Pe(0))?l=u?Wt.sub(new _e(1)):Dt.add(new _e(1)):l=ie.priceToSqrtPriceX64(a,e.mintA.decimals,e.mintB.decimals);let d=he(r,s[n.toString()],o,!0),{expectedAmountIn:p,remainingAccounts:m,executionPrice:f,feeAmount:y}=Ne.getInputAmountAndRemainAccounts(e,t,n,d.amount.sub((B=d.fee)!=null?B:be),l),b=u?e.mintB.address:e.mintA.address,g=he(p,s[b],o,!1),P=ie.sqrtPriceX64ToPrice(f,e.mintA.decimals,e.mintB.decimals),h=u?P:new Pe(1).div(P),I=p.mul(new _e(Math.floor((1+i)*1e10))).div(new _e(1e10)),T=he(I,s[b],o,!0),w=u?e.currentPrice:new Pe(1).div(e.currentPrice),x=new Pe(h).sub(w).abs(),S=w,K=new it(new Pe(x).mul(10**15).toFixed(0),new Pe(S).mul(10**15).toFixed(0));return{amountIn:g,maxAmountIn:T,realAmountOut:d,expirationTime:$t(g.expirationTime,d.expirationTime),currentPrice:e.currentPrice,executionPrice:h,priceImpact:K,fee:y,remainingAccounts:m}}static estimateAprsForPriceRangeMultiplier({poolInfo:e,aprType:t,positionTickLowerIndex:n,positionTickUpperIndex:o}){var f,y,b;let r=e[t],i=Z.getTickPrice({poolInfo:e,tick:n,baseIn:!0}).price.toNumber(),a=Z.getTickPrice({poolInfo:e,tick:o,baseIn:!0}).price.toNumber(),u=Math.max(i,r.priceMin),l=Math.min(a,r.priceMax)-u,d=a-i,p=r.priceMax-r.priceMin,m;return l<=0?m=0:d===l?m=p/l:p===l?m=l/d:m=l/p*(l/d),{feeApr:r.feeApr*m,rewardsApr:[((f=r.rewardApr[0])!=null?f:0)*m,((y=r.rewardApr[1])!=null?y:0)*m,((b=r.rewardApr[2])!=null?b:0)*m],apr:r.apr*m}}static estimateAprsForPriceRangeDelta({poolInfo:e,poolLiquidity:t,aprType:n,mintPrice:o,liquidity:r,positionTickLowerIndex:i,positionTickUpperIndex:a,chainTime:u}){let s=n==="day"?1:n==="week"?7:n==="month"?30:0,l=e[n],d=o[mt(e.mintA.address).toString()],p=o[mt(e.mintB.address).toString()],m=e.mintA.decimals,f=e.mintB.decimals;if(!l||!d||!p)return{feeApr:0,rewardsApr:[0,0,0],apr:0};let y=ie.priceToSqrtPriceX64(new Pe(e.price),e.mintA.decimals,e.mintB.decimals),b=ie.getSqrtPriceX64FromTick(i),g=ie.getSqrtPriceX64FromTick(a),{amountSlippageA:P,amountSlippageB:h}=Ae.getAmountsFromLiquidityWithSlippage(y,b,g,t,!1,!1,0),{amountSlippageA:I,amountSlippageB:T}=Ae.getAmountsFromLiquidityWithSlippage(y,b,g,r,!1,!1,0),w=new Pe(P.toString()).div(new Pe(10).pow(m)).mul(d.value).add(new Pe(h.toString()).div(new Pe(10).pow(f)).mul(p.value)),x=new Pe(I.toString()).div(new Pe(10).pow(m)).mul(d.value).add(new Pe(T.toString()).div(new Pe(10).pow(f)).mul(p.value)),S=new Pe(1).div(w.add(x)),B=new Pe(l.volumeFee).mul(365).div(s).mul(S).mul(100).toNumber(),C=3600*24*365,M=e.rewardDefaultInfos.map(F=>{var W,z;let R=F.mint.decimals,L=o[F.mint.address];return u<((W=F.startTime)!=null?W:0)||u>((z=F.endTime)!=null?z:0)||!F.perSecond||!L||R===void 0?0:new Pe(L.value).mul(new Pe(F.perSecond).mul(C)).div(new Pe(10).pow(R)).mul(S).mul(100).toNumber()});return{feeApr:B,rewardsApr:M,apr:B+M.reduce((F,R)=>F+R,0)}}static async getLiquidityAmountOutFromAmountIn({poolInfo:e,inputA:t,tickLower:n,tickUpper:o,amount:r,slippage:i,add:a,epochInfo:u,amountHasFee:s}){var g,P;let l=ie.priceToSqrtPriceX64(new Pe(e.price),e.mintA.decimals,e.mintB.decimals),d=ie.getSqrtPriceX64FromTick(n),p=ie.getSqrtPriceX64FromTick(o),m=he(r,(g=e[t?"mintA":"mintB"].extensions)==null?void 0:g.feeConfig,u,!s),f=new _e(new Pe(m.amount.sub((P=m.fee)!=null?P:be).toString()).toFixed(0)),y;if(l.lte(d))y=t?Ae.getLiquidityFromTokenAmountA(d,p,f,!a):new _e(0);else if(l.lte(p)){let h=Ae.getLiquidityFromTokenAmountA(l,p,f,!a),I=Ae.getLiquidityFromTokenAmountB(d,l,f);y=t?h:I}else y=t?new _e(0):Ae.getLiquidityFromTokenAmountB(d,p,f);let b=await Ne.getAmountsFromLiquidity({epochInfo:u,poolInfo:e,tickLower:n,tickUpper:o,liquidity:y,slippage:i,add:a});return{liquidity:y,amountA:t?m:b.amountA,amountB:t?b.amountB:m,amountSlippageA:t?m:b.amountSlippageA,amountSlippageB:t?b.amountSlippageB:m,expirationTime:b.expirationTime}}static async getAmountsFromLiquidity({epochInfo:e,poolInfo:t,tickLower:n,tickUpper:o,liquidity:r,slippage:i,add:a}){var b,g,P,h;let u=ie.getSqrtPriceX64FromTick(n),s=ie.getSqrtPriceX64FromTick(o),l=a?1+i:1-i,d=Ae.getAmountsFromLiquidity(ie.priceToSqrtPriceX64(new Pe(t.price),t.mintA.decimals,t.mintB.decimals),u,s,r,a),[p,m]=[he(d.amountA,(b=t.mintA.extensions)==null?void 0:b.feeConfig,e,!0),he(d.amountB,(g=t.mintB.extensions)==null?void 0:g.feeConfig,e,!0)],[f,y]=[he(d.amountA.muln(l),(P=t.mintA.extensions)==null?void 0:P.feeConfig,e,!0),he(d.amountB.muln(l),(h=t.mintB.extensions)==null?void 0:h.feeConfig,e,!0)];return{liquidity:r,amountA:p,amountB:m,amountSlippageA:f,amountSlippageB:y,expirationTime:$t(p.expirationTime,m.expirationTime)}}static async fetchComputeMultipleClmmInfo({connection:e,poolList:t,rpcDataMap:n={}}){let o=t.filter(u=>!n[u.id]).map(u=>new Ot(u.id));(await Yt(e,o)).forEach((u,s)=>{!u||(n[o[s].toBase58()]=Hn.decode(u.data))});let i=t.map(u=>Qe(new Ot(u.programId),new Ot(u.id)).publicKey),a=await Ne.fetchExBitmaps({connection:e,exBitmapAddress:i,batchRequest:!1});return t.reduce((u,s)=>q(N({},u),{[s.id]:q(N({},n[s.id]),{id:new Ot(s.id),version:6,programId:new Ot(s.programId),mintA:s.mintA,mintB:s.mintB,ammConfig:q(N({},s.config),{id:new Ot(s.config.id),fundOwner:""}),currentPrice:new Pe(s.price),exBitmapAccount:Qe(new Ot(s.programId),new Ot(s.id)).publicKey,exBitmapInfo:a[Qe(new Ot(s.programId),new Ot(s.id)).publicKey.toBase58()],startTime:n[s.id].startTime.toNumber(),rewardInfos:n[s.id].rewardInfos})}),{})}static async fetchComputeClmmInfo({connection:e,poolInfo:t,rpcData:n}){return(await this.fetchComputeMultipleClmmInfo({connection:e,rpcDataMap:n?{[t.id]:n}:void 0,poolList:[t]}))[t.id]}};function dT({poolInfo:c,tickLower:e,tickUpper:t,amountA:n,amountB:o,slippage:r,add:i,epochInfo:a,amountHasFee:u}){var h,I,T,w;let[s,l,d,p]=e<t?[e,t,n,o]:[t,e,o,n],m=ie.priceToSqrtPriceX64(new Pe(c.price),c.mintA.decimals,c.mintB.decimals),f=ie.getSqrtPriceX64FromTick(s),y=ie.getSqrtPriceX64FromTick(l),[b,g]=[he(d,(h=c.mintA.extensions)==null?void 0:h.feeConfig,a,!u),he(p,(I=c.mintB.extensions)==null?void 0:I.feeConfig,a,!u)],P=Ae.getLiquidityFromTokenAmounts(m,f,y,b.amount.sub((T=b.fee)!=null?T:be),g.amount.sub((w=g.fee)!=null?w:be));return Ae.getAmountsOutFromLiquidity({poolInfo:c,tickLower:e,tickUpper:t,liquidity:P,slippage:r,add:i,epochInfo:a,amountAddFee:!u})}var ws={volume:0,volumeQuote:0,volumeFee:0,apr:0,feeApr:0,priceMin:0,priceMax:0,rewardApr:[]};function Mc(c){return q(N({},c),{type:"Concentrated",programId:c.programId.toString(),id:c.id.toString(),rewardDefaultInfos:[],rewardDefaultPoolInfos:"Clmm",price:c.currentPrice.toNumber(),mintAmountA:0,mintAmountB:0,feeRate:c.ammConfig.tradeFeeRate,openTime:c.startTime.toString(),tvl:0,day:ws,week:ws,month:ws,pooltype:[],farmUpcomingCount:0,farmOngoingCount:0,farmFinishedCount:0,burnPercent:0,config:q(N({},c.ammConfig),{id:c.ammConfig.id.toString(),defaultRange:0,defaultRangePoint:[]})})}var ue=class{static mulDivRoundingUp(e,t,n){let o=e.mul(t),r=o.div(n);return o.mod(n).eq(be)||(r=r.add(Lt)),r}static mulDivFloor(e,t,n){if(n.eq(be))throw new Error("division by 0");return e.mul(t).div(n)}static mulDivCeil(e,t,n){if(n.eq(be))throw new Error("division by 0");return e.mul(t).add(n.sub(Lt)).div(n)}static x64ToDecimal(e,t){return new mn(e.toString()).div(mn.pow(2,64)).toDecimalPlaces(t)}static decimalToX64(e){return new me(e.mul(mn.pow(2,64)).floor().toFixed())}static wrappingSubU128(e,t){return e.add(xr).sub(t).mod(xr)}};function st(c,e){return Ts(c.mul(e),64,256)}function Qd(c,e,t){let n=c.toTwos(t).shln(e);return n.imaskn(t+1),n.fromTwos(t)}function Ts(c,e,t){let n=c.toTwos(t).shrn(e);return n.imaskn(t-e+1),n.fromTwos(t-e)}var ie=class{static sqrtPriceX64ToPrice(e,t,n){return ue.x64ToDecimal(e).pow(2).mul(mn.pow(10,t-n))}static priceToSqrtPriceX64(e,t,n){return ue.decimalToX64(e.mul(mn.pow(10,n-t)).sqrt())}static getNextSqrtPriceX64FromInput(e,t,n,o){if(!e.gt(be))throw new Error("sqrtPriceX64 must greater than 0");if(!t.gt(be))throw new Error("liquidity must greater than 0");return o?this.getNextSqrtPriceFromTokenAmountARoundingUp(e,t,n,!0):this.getNextSqrtPriceFromTokenAmountBRoundingDown(e,t,n,!0)}static getNextSqrtPriceX64FromOutput(e,t,n,o){if(!e.gt(be))throw new Error("sqrtPriceX64 must greater than 0");if(!t.gt(be))throw new Error("liquidity must greater than 0");return o?this.getNextSqrtPriceFromTokenAmountBRoundingDown(e,t,n,!1):this.getNextSqrtPriceFromTokenAmountARoundingUp(e,t,n,!1)}static getNextSqrtPriceFromTokenAmountARoundingUp(e,t,n,o){if(n.eq(be))return e;let r=t.shln(yi);if(o){let i=r,a=r.add(n.mul(e));return a.gte(i)?ue.mulDivCeil(i,e,a):ue.mulDivRoundingUp(i,Lt,i.div(e).add(n))}else{let i=n.mul(e);if(!r.gt(i))throw new Error("getNextSqrtPriceFromTokenAmountARoundingUp,liquidityLeftShift must gt amountMulSqrtPrice");let a=r.sub(i);return ue.mulDivCeil(r,e,a)}}static getNextSqrtPriceFromTokenAmountBRoundingDown(e,t,n,o){let r=n.shln(yi);if(o)return e.add(r.div(t));{let i=ue.mulDivRoundingUp(r,Lt,t);if(!e.gt(i))throw new Error("getNextSqrtPriceFromTokenAmountBRoundingDown sqrtPriceX64 must gt amountDivLiquidity");return e.sub(i)}}static getSqrtPriceX64FromTick(e){if(!Number.isInteger(e))throw new Error("tick must be integer");if(e<pt||e>Pt)throw new Error("tick must be in MIN_TICK and MAX_TICK");let t=e<0?e*-1:e,n=(t&1)!=0?new me("18445821805675395072"):new me("18446744073709551616");return(t&2)!=0&&(n=st(n,new me("18444899583751176192"))),(t&4)!=0&&(n=st(n,new me("18443055278223355904"))),(t&8)!=0&&(n=st(n,new me("18439367220385607680"))),(t&16)!=0&&(n=st(n,new me("18431993317065453568"))),(t&32)!=0&&(n=st(n,new me("18417254355718170624"))),(t&64)!=0&&(n=st(n,new me("18387811781193609216"))),(t&128)!=0&&(n=st(n,new me("18329067761203558400"))),(t&256)!=0&&(n=st(n,new me("18212142134806163456"))),(t&512)!=0&&(n=st(n,new me("17980523815641700352"))),(t&1024)!=0&&(n=st(n,new me("17526086738831433728"))),(t&2048)!=0&&(n=st(n,new me("16651378430235570176"))),(t&4096)!=0&&(n=st(n,new me("15030750278694412288"))),(t&8192)!=0&&(n=st(n,new me("12247334978884435968"))),(t&16384)!=0&&(n=st(n,new me("8131365268886854656"))),(t&32768)!=0&&(n=st(n,new me("3584323654725218816"))),(t&65536)!=0&&(n=st(n,new me("696457651848324352"))),(t&131072)!=0&&(n=st(n,new me("26294789957507116"))),(t&262144)!=0&&(n=st(n,new me("37481735321082"))),e>0&&(n=kc.div(n)),n}static getTickFromPrice(e,t,n){return ie.getTickFromSqrtPriceX64(ie.priceToSqrtPriceX64(e,t,n))}static getTickFromSqrtPriceX64(e){if(e.gt(Wt)||e.lt(Dt))throw new Error("Provided sqrtPrice is not within the supported sqrtPrice range.");let t=e.bitLength()-1,n=new me(t-64),o=Qd(n,32,128),r=new me("8000000000000000","hex"),i=0,a=new me(0),u=t>=64?e.shrn(t-63):e.shln(63-t);for(;r.gt(new me(0))&&i<wc;){u=u.mul(u);let f=u.shrn(127);u=u.shrn(63+f.toNumber()),a=a.add(r.mul(f)),r=r.shrn(1),i+=1}let s=a.shrn(32),d=o.add(s).mul(new me(Tc)),p=Ts(d.sub(new me(hc)),64,128).toNumber(),m=Ts(d.add(new me(Ic)),64,128).toNumber();return p==m?p:ie.getSqrtPriceX64FromTick(m).lte(e)?m:p}},Zn=class{static getTickWithPriceAndTickspacing(e,t,n,o){let i=ie.getTickFromSqrtPriceX64(ie.priceToSqrtPriceX64(e,n,o))/t;return i<0?i=Math.floor(i):i=Math.ceil(i),i*t}static roundPriceWithTickspacing(e,t,n,o){let r=Zn.getTickWithPriceAndTickspacing(e,t,n,o),i=ie.getSqrtPriceX64FromTick(r);return ie.sqrtPriceX64ToPrice(i,n,o)}},Ae=class{static addDelta(e,t){return e.add(t)}static getTokenAmountAFromLiquidity(e,t,n,o){if(e.gt(t)&&([e,t]=[t,e]),!e.gt(be))throw new Error("sqrtPriceX64A must greater than 0");let r=n.ushln(yi),i=t.sub(e);return o?ue.mulDivRoundingUp(ue.mulDivCeil(r,i,t),Lt,e):ue.mulDivFloor(r,i,t).div(e)}static getTokenAmountBFromLiquidity(e,t,n,o){if(e.gt(t)&&([e,t]=[t,e]),!e.gt(be))throw new Error("sqrtPriceX64A must greater than 0");return o?ue.mulDivCeil(n,t.sub(e),Je):ue.mulDivFloor(n,t.sub(e),Je)}static getLiquidityFromTokenAmountA(e,t,n,o){e.gt(t)&&([e,t]=[t,e]);let r=n.mul(e).mul(t),i=t.sub(e),a=r.div(i);return o?ue.mulDivRoundingUp(a,Lt,fi):a.shrn(yi)}static getLiquidityFromTokenAmountB(e,t,n){return e.gt(t)&&([e,t]=[t,e]),ue.mulDivFloor(n,fi,t.sub(e))}static getLiquidityFromTokenAmounts(e,t,n,o,r){if(t.gt(n)&&([t,n]=[n,t]),e.lte(t))return Ae.getLiquidityFromTokenAmountA(t,n,o,!1);if(e.lt(n)){let i=Ae.getLiquidityFromTokenAmountA(e,n,o,!1),a=Ae.getLiquidityFromTokenAmountB(t,e,r);return i.lt(a)?i:a}else return Ae.getLiquidityFromTokenAmountB(t,n,r)}static getAmountsFromLiquidity(e,t,n,o,r){if(t.gt(n)&&([t,n]=[n,t]),e.lte(t))return{amountA:Ae.getTokenAmountAFromLiquidity(t,n,o,r),amountB:new me(0)};if(e.lt(n)){let i=Ae.getTokenAmountAFromLiquidity(e,n,o,r),a=Ae.getTokenAmountBFromLiquidity(t,e,o,r);return{amountA:i,amountB:a}}else return{amountA:new me(0),amountB:Ae.getTokenAmountBFromLiquidity(t,n,o,r)}}static getAmountsFromLiquidityWithSlippage(e,t,n,o,r,i,a){let{amountA:u,amountB:s}=Ae.getAmountsFromLiquidity(e,t,n,o,i),l=r?1+a:1-a,d=new me(new mn(u.toString()).mul(l).toFixed(0)),p=new me(new mn(s.toString()).mul(l).toFixed(0));return{amountSlippageA:d,amountSlippageB:p}}static getAmountsOutFromLiquidity({poolInfo:e,tickLower:t,tickUpper:n,liquidity:o,slippage:r,add:i,epochInfo:a,amountAddFee:u}){var P,h,I,T;let s=ie.priceToSqrtPriceX64(new mn(e.price),e.mintA.decimals,e.mintB.decimals),l=ie.getSqrtPriceX64FromTick(t),d=ie.getSqrtPriceX64FromTick(n),p=i?1+r:1-r,m=Ae.getAmountsFromLiquidity(s,l,d,o,i),[f,y]=[he(m.amountA,(P=e.mintA.extensions)==null?void 0:P.feeConfig,a,u),he(m.amountB,(h=e.mintB.extensions)==null?void 0:h.feeConfig,a,u)],[b,g]=[he(new me(new mn(m.amountA.toString()).mul(p).toFixed(0)),(I=e.mintA.extensions)==null?void 0:I.feeConfig,a,u),he(new me(new mn(m.amountB.toString()).mul(p).toFixed(0)),(T=e.mintB.extensions)==null?void 0:T.feeConfig,a,u)];return{liquidity:o,amountA:f,amountB:y,amountSlippageA:b,amountSlippageB:g,expirationTime:$t(f.expirationTime,y.expirationTime)}}},jn=class{static swapCompute(e,t,n,o,r,i,a,u,s,l,d,p,m,f,y=!1){if(p.eq(be))throw new Error("amountSpecified must not be 0");if(f||(f=i?Dt.add(Lt):Wt.sub(Lt)),i){if(f.lt(Dt))throw new Error("sqrtPriceX64 must greater than MIN_SQRT_PRICE_X64");if(f.gte(d))throw new Error("sqrtPriceX64 must smaller than current")}else{if(f.gt(Wt))throw new Error("sqrtPriceX64 must smaller than MAX_SQRT_PRICE_X64");if(f.lte(d))throw new Error("sqrtPriceX64 must greater than current")}let b=p.gt(be),g={amountSpecifiedRemaining:p,amountCalculated:be,sqrtPriceX64:d,tick:s>m?Math.min(m+ke.tickCount(l)-1,s):m,accounts:[],liquidity:u,feeAmount:new me(0)},P=m,h=n[m],I=0,T=!i&&h.startTickIndex===g.tick;for(;!g.amountSpecifiedRemaining.eq(be)&&!g.sqrtPriceX64.eq(f);){I>10;let w={};w.sqrtPriceStartX64=g.sqrtPriceX64;let x=Z.nextInitTick(h,g.tick,l,i,T),S=x||null,K=null;if(!(S!=null&&S.liquidityGross.gtn(0))){let C=Ne.nextInitializedTickArrayStartIndex({tickCurrent:g.tick,tickSpacing:l,tickArrayBitmap:o,exBitmapInfo:r},P,i);if(!C.isExist){if(y)return{allTrade:!1,amountSpecifiedRemaining:g.amountSpecifiedRemaining,amountCalculated:g.amountCalculated,feeAmount:g.feeAmount,sqrtPriceX64:g.sqrtPriceX64,liquidity:g.liquidity,tickCurrent:g.tick,accounts:g.accounts};throw Error("swapCompute LiquidityInsufficient")}P=C.nextStartIndex;let{publicKey:M}=ge(e,t,P);K=M,h=n[P];try{S=Z.firstInitializedTick(h,i)}catch{throw Error("not found next tick info")}}w.tickNext=S.tick,w.initialized=S.liquidityGross.gtn(0),m!==P&&K&&(g.accounts.push(K),m=P),w.tickNext<pt?w.tickNext=pt:w.tickNext>Pt&&(w.tickNext=Pt),w.sqrtPriceNextX64=ie.getSqrtPriceX64FromTick(w.tickNext);let B;if(i&&w.sqrtPriceNextX64.lt(f)||!i&&w.sqrtPriceNextX64.gt(f)?B=f:B=w.sqrtPriceNextX64,[g.sqrtPriceX64,w.amountIn,w.amountOut,w.feeAmount]=jn.swapStepCompute(g.sqrtPriceX64,B,g.liquidity,g.amountSpecifiedRemaining,a,i),g.feeAmount=g.feeAmount.add(w.feeAmount),b?(g.amountSpecifiedRemaining=g.amountSpecifiedRemaining.sub(w.amountIn.add(w.feeAmount)),g.amountCalculated=g.amountCalculated.sub(w.amountOut)):(g.amountSpecifiedRemaining=g.amountSpecifiedRemaining.add(w.amountOut),g.amountCalculated=g.amountCalculated.add(w.amountIn.add(w.feeAmount))),g.sqrtPriceX64.eq(w.sqrtPriceNextX64)){if(w.initialized){let C=S.liquidityNet;i&&(C=C.mul(Pn)),g.liquidity=Ae.addDelta(g.liquidity,C)}T=w.tickNext!=g.tick&&!i&&h.startTickIndex===w.tickNext,g.tick=i?w.tickNext-1:w.tickNext}else if(g.sqrtPriceX64!=w.sqrtPriceStartX64){let C=ie.getTickFromSqrtPriceX64(g.sqrtPriceX64);T=C!=g.tick&&!i&&h.startTickIndex===C,g.tick=C}++I}try{let{nextStartIndex:w,isExist:x}=ke.nextInitializedTickArray(g.tick,l,i,o,r);x&&m!==w&&(g.accounts.push(ge(e,t,w).publicKey),m=w)}catch{}return{allTrade:!0,amountSpecifiedRemaining:be,amountCalculated:g.amountCalculated,feeAmount:g.feeAmount,sqrtPriceX64:g.sqrtPriceX64,liquidity:g.liquidity,tickCurrent:g.tick,accounts:g.accounts}}static swapStepCompute(e,t,n,o,r,i){let a={sqrtPriceX64Next:new me(0),amountIn:new me(0),amountOut:new me(0),feeAmount:new me(0)},u=o.gte(be);if(u){let l=ue.mulDivFloor(o,Cr.sub(new me(r.toString())),Cr);a.amountIn=i?Ae.getTokenAmountAFromLiquidity(t,e,n,!0):Ae.getTokenAmountBFromLiquidity(e,t,n,!0),l.gte(a.amountIn)?a.sqrtPriceX64Next=t:a.sqrtPriceX64Next=ie.getNextSqrtPriceX64FromInput(e,n,l,i)}else a.amountOut=i?Ae.getTokenAmountBFromLiquidity(t,e,n,!1):Ae.getTokenAmountAFromLiquidity(e,t,n,!1),o.mul(Pn).gte(a.amountOut)?a.sqrtPriceX64Next=t:a.sqrtPriceX64Next=ie.getNextSqrtPriceX64FromOutput(e,n,o.mul(Pn),i);let s=t.eq(a.sqrtPriceX64Next);return i?(s&&u||(a.amountIn=Ae.getTokenAmountAFromLiquidity(a.sqrtPriceX64Next,e,n,!0)),s&&!u||(a.amountOut=Ae.getTokenAmountBFromLiquidity(a.sqrtPriceX64Next,e,n,!1))):(a.amountIn=s&&u?a.amountIn:Ae.getTokenAmountBFromLiquidity(e,a.sqrtPriceX64Next,n,!0),a.amountOut=s&&!u?a.amountOut:Ae.getTokenAmountAFromLiquidity(e,a.sqrtPriceX64Next,n,!1)),!u&&a.amountOut.gt(o.mul(Pn))&&(a.amountOut=o.mul(Pn)),u&&!a.sqrtPriceX64Next.eq(t)?a.feeAmount=o.sub(a.amountIn):a.feeAmount=ue.mulDivCeil(a.amountIn,new me(r),Cr.sub(new me(r))),[a.sqrtPriceX64Next,a.amountIn,a.amountOut,a.feeAmount]}};var et=60,Yn=512,Z=class{static getTickArrayAddressByTick(e,t,n,o){let r=Z.getTickArrayStartIndexByTick(n,o),{publicKey:i}=ge(e,t,r);return i}static getTickOffsetInArray(e,t){if(e%t!=0)throw new Error("tickIndex % tickSpacing not equal 0");let n=Z.getTickArrayStartIndexByTick(e,t),o=Math.floor((e-n)/t);if(o<0||o>=et)throw new Error("tick offset in array overflow");return o}static getTickArrayBitIndex(e,t){let n=ke.tickCount(t),o=e/n;return e<0&&e%n!=0?o=Math.ceil(o)-1:o=Math.floor(o),o}static getTickArrayStartIndexByTick(e,t){return this.getTickArrayBitIndex(e,t)*ke.tickCount(t)}static getTickArrayOffsetInBitmapByTick(e,t){let n=t*et,o=Math.floor(e/n)+512;return Math.abs(o)}static checkTickArrayIsInitialized(e,t,n){let o=n*et,r=Math.floor(t/o)+512,i=Math.abs(r);return{isInitialized:e.testn(i),startIndex:(i-512)*o}}static getNextTickArrayStartIndex(e,t,n){return n?e-t*et:e+t*et}static mergeTickArrayBitmap(e){let t=new Yd(0);for(let n=0;n<e.length;n++)t=t.add(e[n].shln(64*n));return t}static getInitializedTickArrayInRange(e,t,n,o,r){let i=Math.floor(o/(n*et));return[...Z.searchLowBitFromStart(e,t,i-1,r,n),...Z.searchHightBitFromStart(e,t,i,r,n)]}static getAllInitializedTickArrayStartIndex(e,t,n){return Z.searchHightBitFromStart(e,t,-7680,Yn,n)}static getAllInitializedTickArrayInfo(e,t,n,o,r){let i=[],a=Z.getAllInitializedTickArrayStartIndex(n,o,r);for(let u of a){let{publicKey:s}=ge(e,t,u);i.push({tickArrayStartIndex:u,tickArrayAddress:s})}return i}static getAllInitializedTickInTickArray(e){return e.ticks.filter(t=>t.liquidityGross.gtn(0))}static searchLowBitFromStart(e,t,n,o,r){let i=[...[...t.negativeTickArrayBitmap].reverse(),e.slice(0,8),e.slice(8,16),...t.positiveTickArrayBitmap].map(s=>Z.mergeTickArrayBitmap(s)),a=[];for(;n>=-7680;){let s=Math.floor((n+7680)/512),l=(n+7680)%512;if(i[s].testn(l)&&a.push(n),n--,a.length===o)break}let u=ke.tickCount(r);return a.map(s=>s*u)}static searchHightBitFromStart(e,t,n,o,r){let i=[...[...t.negativeTickArrayBitmap].reverse(),e.slice(0,8),e.slice(8,16),...t.positiveTickArrayBitmap].map(s=>Z.mergeTickArrayBitmap(s)),a=[];for(;n<7680;){let s=Math.floor((n+7680)/512),l=(n+7680)%512;if(i[s].testn(l)&&a.push(n),n++,a.length===o)break}let u=ke.tickCount(r);return a.map(s=>s*u)}static checkIsOutOfBoundary(e){return e<pt||e>Pt}static nextInitTick(e,t,n,o,r){if(ke.getArrayStartIndex(t,n)!=e.startTickIndex)return null;let a=Math.floor((t-e.startTickIndex)/n);if(o)for(;a>=0;){if(e.ticks[a].liquidityGross.gtn(0))return e.ticks[a];a=a-1}else for(r||(a=a+1);a<et;){if(e.ticks[a].liquidityGross.gtn(0))return e.ticks[a];a=a+1}return null}static firstInitializedTick(e,t){if(t){let n=et-1;for(;n>=0;){if(e.ticks[n].liquidityGross.gtn(0))return e.ticks[n];n=n-1}}else{let n=0;for(;n<et;){if(e.ticks[n].liquidityGross.gtn(0))return e.ticks[n];n=n+1}}throw Error(`firstInitializedTick check error: ${e} - ${t}`)}static _getTickPriceLegacy({poolInfo:e,tick:t,baseIn:n}){let o=ie.getSqrtPriceX64FromTick(t),r=ie.sqrtPriceX64ToPrice(o,e.mintA.decimals,e.mintB.decimals);return n?{tick:t,price:r,tickSqrtPriceX64:o}:{tick:t,price:new Ko(1).div(r),tickSqrtPriceX64:o}}static _getPriceAndTickLegacy({poolInfo:e,price:t,baseIn:n}){let o=n?t:new Ko(1).div(t),r=Zn.getTickWithPriceAndTickspacing(o,e.ammConfig.tickSpacing,e.mintA.decimals,e.mintB.decimals),i=ie.getSqrtPriceX64FromTick(r),a=ie.sqrtPriceX64ToPrice(i,e.mintA.decimals,e.mintB.decimals);return n?{tick:r,price:a}:{tick:r,price:new Ko(1).div(a)}}static getTickPrice({poolInfo:e,tick:t,baseIn:n}){let o=ie.getSqrtPriceX64FromTick(t),r=ie.sqrtPriceX64ToPrice(o,e.mintA.decimals,e.mintB.decimals);return n?{tick:t,price:r,tickSqrtPriceX64:o}:{tick:t,price:new Ko(1).div(r),tickSqrtPriceX64:o}}static getPriceAndTick({poolInfo:e,price:t,baseIn:n}){let o=n?t:new Ko(1).div(t),r=Zn.getTickWithPriceAndTickspacing(o,e.config.tickSpacing,e.mintA.decimals,e.mintB.decimals),i=ie.getSqrtPriceX64FromTick(r),a=ie.sqrtPriceX64ToPrice(i,e.mintA.decimals,e.mintB.decimals);return n?{tick:r,price:a}:{tick:r,price:new Ko(1).div(a)}}};var Fc=V([Ie(8),_("bump"),Rt("index"),O(""),ct("protocolFeeRate"),ct("tradeFeeRate"),Rt("tickSpacing"),Y(k(),8,"")]),jd=V([ct("blockTimestamp"),wo("tickCumulative"),Y(k(),4)]),Vc=V([Ie(8),We("initialized"),k("recentEpoch"),Rt("observationIndex"),O("poolId"),Y(jd,100,"observations"),Y(k(),4)]),Hd=V([_("rewardState"),k("openTime"),k("endTime"),k("lastUpdateTime"),te("emissionsPerSecondX64"),k("rewardTotalEmissioned"),k("rewardClaimed"),O("tokenMint"),O("tokenVault"),O("creator"),te("rewardGrowthGlobalX64")]),Hn=V([Ie(8),_("bump"),O("ammConfig"),O("creator"),O("mintA"),O("mintB"),O("vaultA"),O("vaultB"),O("observationId"),_("mintDecimalsA"),_("mintDecimalsB"),Rt("tickSpacing"),te("liquidity"),te("sqrtPriceX64"),Ve("tickCurrent"),ct(),te("feeGrowthGlobalX64A"),te("feeGrowthGlobalX64B"),k("protocolFeesTokenA"),k("protocolFeesTokenB"),te("swapInAmountTokenA"),te("swapOutAmountTokenB"),te("swapInAmountTokenB"),te("swapOutAmountTokenA"),_("status"),Y(_(),7,""),Y(Hd,3,"rewardInfos"),Y(k(),16,"tickArrayBitmap"),k("totalFeesTokenA"),k("totalFeesClaimedTokenA"),k("totalFeesTokenB"),k("totalFeesClaimedTokenB"),k("fundFeesTokenA"),k("fundFeesTokenB"),k("startTime"),Y(k(),15*4-3,"padding")]),Zd=V([te("growthInsideLastX64"),k("rewardAmountOwed")]),So=V([Ie(8),_("bump"),O("nftMint"),O("poolId"),Ve("tickLower"),Ve("tickUpper"),te("liquidity"),te("feeGrowthInsideLastX64A"),te("feeGrowthInsideLastX64B"),k("tokenFeesOwedA"),k("tokenFeesOwedB"),Y(Zd,3,"rewardInfos"),Y(k(),8,"")]),FT=V([Ie(8),_("bump"),O("poolId"),Ve("tickLowerIndex"),Ve("tickUpperIndex"),te("liquidity"),te("feeGrowthInsideLastX64A"),te("feeGrowthInsideLastX64B"),k("tokenFeesOwedA"),k("tokenFeesOwedB"),Y(te(),3,"rewardGrowthInside"),Y(k(),8,"")]),$d=V([Ve("tick"),Zu("liquidityNet"),te("liquidityGross"),te("feeGrowthOutsideX64A"),te("feeGrowthOutsideX64B"),Y(te(),3,"rewardGrowthsOutsideX64"),Y(ct(),13,"")]),Pi=V([Ie(8),O("poolId"),Ve("startTickIndex"),Y($d,et,"ticks"),_("initializedTickCount"),Y(_(),115,"")]),_c=V([Ie(329),Y(O(),100,"whitelistMints")]),vc=V([Ie(8),O("poolId"),Y(Y(k(),8),ks,"positiveTickArrayBitmap"),Y(Y(k(),8),ks,"negativeTickArrayBitmap")]),VT=V([k(),_("bump"),O("owner"),O("poolId"),O("positionId"),O("nftAccount"),Y(k(),8)]),Ec=V([Ie(8),_("bump"),O("lockOwner"),O("poolId"),O("positionId"),O("nftAccount"),O("lockNftMint"),k("recentEpoch"),Y(k(),8)]);Vc.span;var Dc=fe("Raydium_Clmm"),Nt={createPool:[233,146,209,142,207,104,64,188],initReward:[95,135,192,196,242,129,230,68],setRewardEmissions:[112,52,167,75,32,201,211,137],openPosition:[77,184,74,214,112,86,241,199],openPositionWithTokenEx:[77,255,174,82,125,29,201,46],closePosition:[123,134,81,0,49,68,98,98],increaseLiquidity:[133,29,89,223,69,238,176,10],decreaseLiquidity:[58,127,188,62,79,82,196,96],swap:[43,4,237,11,26,201,30,98],collectReward:[18,237,166,197,34,16,213,144]},Wc=[188,37,179,131,82,150,84,73],qc=[16,72,250,198,14,162,212,19],Ce=class{static createPoolInstruction(e,t,n,o,r,i,a,u,s,l,d,p,m,f){let y=V([te("sqrtPriceX64"),k("zero")]),b=[{pubkey:n,isSigner:!0,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!1},{pubkey:s,isSigner:!1,isWritable:!1},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:p,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!1},{pubkey:d,isSigner:!1,isWritable:!1},{pubkey:Tn.programId,isSigner:!1,isWritable:!1},{pubkey:Ze,isSigner:!1,isWritable:!1},...(f==null?void 0:f.map(h=>({pubkey:h,isSigner:!1,isWritable:!1})))||[]],g=Buffer.alloc(y.span);y.encode({sqrtPriceX64:m,zero:be},g);let P=Buffer.from([...Nt.createPool,...g]);return new lt({keys:b,programId:e,data:P})}static async createPoolInstructions(e){let{programId:t,owner:n,mintA:o,mintB:r,ammConfigId:i,initialPriceX64:a,extendMintAccount:u}=e,[s,l]=[new G(o.address),new G(r.address)],{publicKey:d}=Cc(t,i,s,l),{publicKey:p}=Lc(t,d),{publicKey:m}=bs(t,d,s),{publicKey:f}=bs(t,d,l),y=Qe(t,d).publicKey,b=[this.createPoolInstruction(t,d,n,i,p,s,m,new G(o.programId||Ke),l,f,new G(r.programId||Ke),y,a,u)];return{signers:[],instructions:b,instructionTypes:[U.CreateAccount,U.ClmmCreatePool],address:{poolId:d,observationId:p,exBitmapAccount:y,mintAVault:m,mintBVault:f},lookupTableAddress:[]}}static openPositionFromLiquidityInstruction(e,t,n,o,r,i,a,u,s,l,d,p,m,f,y,b,g,P,h,I,T,w,x,S,K,B){let C=V([Ve("tickLowerIndex"),Ve("tickUpperIndex"),Ve("tickArrayLowerStartIndex"),Ve("tickArrayUpperStartIndex"),te("liquidity"),k("amountMaxA"),k("amountMaxB"),We("withMetadata"),_("optionBaseFlag"),We("baseFlag")]),M=[...B?[{pubkey:B,isSigner:!1,isWritable:!0}]:[]],F=[{pubkey:t,isSigner:!0,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!0,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:d,isSigner:!1,isWritable:!0},{pubkey:p,isSigner:!1,isWritable:!0},{pubkey:m,isSigner:!1,isWritable:!0},{pubkey:f,isSigner:!1,isWritable:!0},{pubkey:y,isSigner:!1,isWritable:!0},{pubkey:Ze,isSigner:!1,isWritable:!1},{pubkey:Tn.programId,isSigner:!1,isWritable:!1},{pubkey:Ke,isSigner:!1,isWritable:!1},{pubkey:wi,isSigner:!1,isWritable:!1},{pubkey:jt,isSigner:!1,isWritable:!1},{pubkey:Ue,isSigner:!1,isWritable:!1},{pubkey:b,isSigner:!1,isWritable:!1},{pubkey:g,isSigner:!1,isWritable:!1},...M],R=Buffer.alloc(C.span);C.encode({tickLowerIndex:P,tickUpperIndex:h,tickArrayLowerStartIndex:I,tickArrayUpperStartIndex:T,liquidity:w,amountMaxA:x,amountMaxB:S,withMetadata:K==="create",baseFlag:!1,optionBaseFlag:0},R);let L=Buffer.from([...Nt.openPosition,...R]);return new lt({keys:F,programId:e,data:L})}static openPositionFromLiquidityInstruction22(e,t,n,o,r,i,a,u,s,l,d,p,m,f,y,b,g,P,h,I,T,w,x,S,K){let B=V([Ve("tickLowerIndex"),Ve("tickUpperIndex"),Ve("tickArrayLowerStartIndex"),Ve("tickArrayUpperStartIndex"),te("liquidity"),k("amountMaxA"),k("amountMaxB"),We("withMetadata"),_("optionBaseFlag"),We("baseFlag")]),C=[...K?[{pubkey:K,isSigner:!1,isWritable:!0}]:[]],M=[{pubkey:t,isSigner:!0,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!0,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:d,isSigner:!1,isWritable:!0},{pubkey:p,isSigner:!1,isWritable:!0},{pubkey:m,isSigner:!1,isWritable:!0},{pubkey:f,isSigner:!1,isWritable:!0},{pubkey:Ze,isSigner:!1,isWritable:!1},{pubkey:Tn.programId,isSigner:!1,isWritable:!1},{pubkey:Ke,isSigner:!1,isWritable:!1},{pubkey:wi,isSigner:!1,isWritable:!1},{pubkey:Ue,isSigner:!1,isWritable:!1},{pubkey:y,isSigner:!1,isWritable:!1},{pubkey:b,isSigner:!1,isWritable:!1},...C],F=Buffer.alloc(B.span);B.encode({tickLowerIndex:g,tickUpperIndex:P,tickArrayLowerStartIndex:h,tickArrayUpperStartIndex:I,liquidity:T,amountMaxA:w,amountMaxB:x,withMetadata:S==="create",baseFlag:!1,optionBaseFlag:0},F);let R=Buffer.from([...Nt.openPositionWithTokenEx,...F]);return new lt({keys:M,programId:e,data:R})}static async openPositionInstructions({poolInfo:e,poolKeys:t,ownerInfo:n,tickLower:o,tickUpper:r,liquidity:i,amountMaxA:a,amountMaxB:u,withMetadata:s,getEphemeralSigners:l,nft2022:d}){let p=[],[m,f]=[new G(e.programId),new G(e.id)],y;if(l)y=new G((await l(1))[0]);else{let K=Or.generate();p.push(K),y=K.publicKey}let b=Z.getTickArrayStartIndexByTick(o,e.config.tickSpacing),g=Z.getTickArrayStartIndexByTick(r,e.config.tickSpacing),{publicKey:P}=ge(m,f,b),{publicKey:h}=ge(m,f,g),{publicKey:I}=d?j(n.wallet,y,Ue):j(n.wallet,y,Ke),{publicKey:T}=kn(y),{publicKey:w}=kt(m,y),{publicKey:x}=nn(m,f,o,r),S=d?this.openPositionFromLiquidityInstruction22(m,n.feePayer,f,n.wallet,y,I,x,P,h,w,n.tokenAccountA,n.tokenAccountB,new G(t.vault.A),new G(t.vault.B),new G(e.mintA.address),new G(e.mintB.address),o,r,b,g,i,a,u,s,Ne.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing,[b,g])?Qe(m,f).publicKey:void 0):this.openPositionFromLiquidityInstruction(m,n.feePayer,f,n.wallet,y,I,T,x,P,h,w,n.tokenAccountA,n.tokenAccountB,new G(t.vault.A),new G(t.vault.B),new G(e.mintA.address),new G(e.mintB.address),o,r,b,g,i,a,u,s,Ne.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing,[b,g])?Qe(m,f).publicKey:void 0);return{signers:p,instructions:[S],instructionTypes:[U.ClmmOpenPosition],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[],address:{nftMint:y,tickArrayLower:P,tickArrayUpper:h,positionNftAccount:I,metadataAccount:T,personalPosition:w,protocolPosition:x}}}static async openPositionFromBaseInstructions({poolInfo:e,poolKeys:t,ownerInfo:n,tickLower:o,tickUpper:r,base:i,baseAmount:a,otherAmountMax:u,withMetadata:s,getEphemeralSigners:l,nft2022:d}){let p=[],[m,f]=[new G(e.programId),new G(e.id)],y;if(l)y=new G((await l(1))[0]);else{let K=Or.generate();p.push(K),y=K.publicKey}let b=Z.getTickArrayStartIndexByTick(o,e.config.tickSpacing),g=Z.getTickArrayStartIndexByTick(r,e.config.tickSpacing),{publicKey:P}=ge(m,f,b),{publicKey:h}=ge(m,f,g),{publicKey:I}=d?j(n.wallet,y,Ue):j(n.wallet,y,Ke),{publicKey:T}=kn(y),{publicKey:w}=kt(m,y),{publicKey:x}=nn(m,f,o,r),S=d?this.openPositionFromBaseInstruction22(m,n.feePayer,f,n.wallet,y,I,x,P,h,w,n.tokenAccountA,n.tokenAccountB,new G(t.vault.A),new G(t.vault.B),new G(e.mintA.address),new G(e.mintB.address),o,r,b,g,s,i,a,u,Ne.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing,[b,g])?Qe(m,f).publicKey:void 0):this.openPositionFromBaseInstruction(m,n.feePayer,f,n.wallet,y,I,T,x,P,h,w,n.tokenAccountA,n.tokenAccountB,new G(t.vault.A),new G(t.vault.B),new G(e.mintA.address),new G(e.mintB.address),o,r,b,g,s,i,a,u,Ne.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing,[b,g])?Qe(m,f).publicKey:void 0);return{address:{nftMint:y,tickArrayLower:P,tickArrayUpper:h,positionNftAccount:I,metadataAccount:T,personalPosition:w,protocolPosition:x},instructions:[S],signers:p,instructionTypes:[U.ClmmOpenPosition],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[]}}static openPositionFromBaseInstruction(e,t,n,o,r,i,a,u,s,l,d,p,m,f,y,b,g,P,h,I,T,w,x,S,K,B){let C=V([Ve("tickLowerIndex"),Ve("tickUpperIndex"),Ve("tickArrayLowerStartIndex"),Ve("tickArrayUpperStartIndex"),te("liquidity"),k("amountMaxA"),k("amountMaxB"),We("withMetadata"),_("optionBaseFlag"),We("baseFlag")]),M=[...B?[{pubkey:B,isSigner:!1,isWritable:!0}]:[]],F=[{pubkey:t,isSigner:!0,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!0,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:d,isSigner:!1,isWritable:!0},{pubkey:p,isSigner:!1,isWritable:!0},{pubkey:m,isSigner:!1,isWritable:!0},{pubkey:f,isSigner:!1,isWritable:!0},{pubkey:y,isSigner:!1,isWritable:!0},{pubkey:Ze,isSigner:!1,isWritable:!1},{pubkey:Tn.programId,isSigner:!1,isWritable:!1},{pubkey:Ke,isSigner:!1,isWritable:!1},{pubkey:wi,isSigner:!1,isWritable:!1},{pubkey:jt,isSigner:!1,isWritable:!1},{pubkey:Ue,isSigner:!1,isWritable:!1},{pubkey:b,isSigner:!1,isWritable:!1},{pubkey:g,isSigner:!1,isWritable:!1},...M],R=Buffer.alloc(C.span);C.encode({tickLowerIndex:P,tickUpperIndex:h,tickArrayLowerStartIndex:I,tickArrayUpperStartIndex:T,liquidity:new hs(0),amountMaxA:x==="MintA"?S:K,amountMaxB:x==="MintA"?K:S,withMetadata:w==="create",baseFlag:x==="MintA",optionBaseFlag:1},R);let L=Buffer.from([...Nt.openPosition,...R]);return new lt({keys:F,programId:e,data:L})}static openPositionFromBaseInstruction22(e,t,n,o,r,i,a,u,s,l,d,p,m,f,y,b,g,P,h,I,T,w,x,S,K){let B=V([Ve("tickLowerIndex"),Ve("tickUpperIndex"),Ve("tickArrayLowerStartIndex"),Ve("tickArrayUpperStartIndex"),te("liquidity"),k("amountMaxA"),k("amountMaxB"),We("withMetadata"),_("optionBaseFlag"),We("baseFlag")]),C=[...K?[{pubkey:K,isSigner:!1,isWritable:!0}]:[]],M=[{pubkey:t,isSigner:!0,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!0,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:d,isSigner:!1,isWritable:!0},{pubkey:p,isSigner:!1,isWritable:!0},{pubkey:m,isSigner:!1,isWritable:!0},{pubkey:f,isSigner:!1,isWritable:!0},{pubkey:Ze,isSigner:!1,isWritable:!1},{pubkey:Tn.programId,isSigner:!1,isWritable:!1},{pubkey:Ke,isSigner:!1,isWritable:!1},{pubkey:wi,isSigner:!1,isWritable:!1},{pubkey:Ue,isSigner:!1,isWritable:!1},{pubkey:y,isSigner:!1,isWritable:!1},{pubkey:b,isSigner:!1,isWritable:!1},...C],F=Buffer.alloc(B.span);B.encode({tickLowerIndex:g,tickUpperIndex:P,tickArrayLowerStartIndex:h,tickArrayUpperStartIndex:I,liquidity:new hs(0),amountMaxA:w==="MintA"?x:S,amountMaxB:w==="MintA"?S:x,withMetadata:T==="create",baseFlag:w==="MintA",optionBaseFlag:1},F);let R=Buffer.from([...Nt.openPositionWithTokenEx,...F]);return new lt({keys:M,programId:e,data:R})}static async openPositionFromLiquidityInstructions({poolInfo:e,poolKeys:t,ownerInfo:n,tickLower:o,tickUpper:r,liquidity:i,amountMaxA:a,amountMaxB:u,withMetadata:s,getEphemeralSigners:l,nft2022:d}){let p,m=[];if(l)p=new G((await l(1))[0]);else{let K=Or.generate();m.push(K),p=K.publicKey}let[f,y]=[new G(e.programId),new G(e.id)],b=Z.getTickArrayStartIndexByTick(o,e.config.tickSpacing),g=Z.getTickArrayStartIndexByTick(r,e.config.tickSpacing),{publicKey:P}=ge(f,y,b),{publicKey:h}=ge(f,y,g),{publicKey:I}=d?j(n.wallet,p,Ue):j(n.wallet,p,Ke),{publicKey:T}=kn(p),{publicKey:w}=kt(f,p),{publicKey:x}=nn(f,y,o,r),S=d?this.openPositionFromLiquidityInstruction22(f,n.wallet,y,n.wallet,p,I,x,P,h,w,n.tokenAccountA,n.tokenAccountB,new G(t.vault.A),new G(t.vault.B),new G(t.mintA.address),new G(t.mintB.address),o,r,b,g,i,a,u,s,Ne.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing,[b,g])?Qe(f,y).publicKey:void 0):this.openPositionFromLiquidityInstruction(f,n.wallet,y,n.wallet,p,I,T,x,P,h,w,n.tokenAccountA,n.tokenAccountB,new G(t.vault.A),new G(t.vault.B),new G(t.mintA.address),new G(t.mintB.address),o,r,b,g,i,a,u,s,Ne.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing,[b,g])?Qe(f,y).publicKey:void 0);return{address:{nftMint:p,tickArrayLower:P,tickArrayUpper:h,positionNftAccount:I,metadataAccount:T,personalPosition:w,protocolPosition:x},instructions:[S],signers:m,instructionTypes:[U.ClmmOpenPosition],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[]}}static closePositionInstruction(e,t,n,o,r,i){let a=V([]),u=[{pubkey:t,isSigner:!0,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:Tn.programId,isSigner:!1,isWritable:!1},{pubkey:i?Ue:Ke,isSigner:!1,isWritable:!1}],s=Buffer.alloc(a.span);a.encode({},s);let l=Buffer.from([...Nt.closePosition,...s]);return new lt({keys:u,programId:e,data:l})}static closePositionInstructions({poolInfo:e,poolKeys:t,ownerInfo:n,ownerPosition:o,nft2022:r}){let i=new G(e.programId),a=r?j(n.wallet,o.nftMint,Ue).publicKey:j(n.wallet,o.nftMint,Ke).publicKey,{publicKey:u}=kt(i,o.nftMint),s=[];return s.push(this.closePositionInstruction(i,n.wallet,o.nftMint,a,u,r)),{address:{positionNftAccount:a,personalPosition:u},signers:[],instructions:s,instructionTypes:[U.ClmmClosePosition],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[]}}static increasePositionFromLiquidityInstruction(e,t,n,o,r,i,a,u,s,l,d,p,m,f,y,b,g,P){let h=V([te("liquidity"),k("amountMaxA"),k("amountMaxB"),_("optionBaseFlag"),We("baseFlag")]),I=[...P?[{pubkey:P,isSigner:!1,isWritable:!0}]:[]],T=[{pubkey:t,isSigner:!0,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:d,isSigner:!1,isWritable:!0},{pubkey:p,isSigner:!1,isWritable:!0},{pubkey:Ke,isSigner:!1,isWritable:!1},{pubkey:Ue,isSigner:!1,isWritable:!1},{pubkey:m,isSigner:!1,isWritable:!1},{pubkey:f,isSigner:!1,isWritable:!1},...I],w=Buffer.alloc(h.span);h.encode({liquidity:y,amountMaxA:b,amountMaxB:g,optionBaseFlag:0,baseFlag:!1},w);let x=Buffer.from([...Nt.increaseLiquidity,...w]);return new lt({keys:T,programId:e,data:x})}static increasePositionFromLiquidityInstructions({poolInfo:e,poolKeys:t,ownerPosition:n,ownerInfo:o,liquidity:r,amountMaxA:i,amountMaxB:a,nft2022:u}){let[s,l]=[new G(e.programId),new G(e.id)],d=Z.getTickArrayStartIndexByTick(n.tickLower,e.config.tickSpacing),p=Z.getTickArrayStartIndexByTick(n.tickUpper,e.config.tickSpacing),{publicKey:m}=ge(s,l,d),{publicKey:f}=ge(s,l,p),{publicKey:y}=u?j(o.wallet,n.nftMint,Ue):j(o.wallet,n.nftMint,Ke),{publicKey:b}=kt(s,n.nftMint),{publicKey:g}=nn(s,l,n.tickLower,n.tickUpper),P=this.increasePositionFromLiquidityInstruction(s,o.wallet,y,b,l,g,m,f,o.tokenAccountA,o.tokenAccountB,new G(t.vault.A),new G(t.vault.B),new G(e.mintA.address),new G(e.mintB.address),r,i,a,Ne.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing,[d,p])?Qe(s,l).publicKey:void 0);return{address:{tickArrayLower:m,tickArrayUpper:f,positionNftAccount:y,personalPosition:b,protocolPosition:g},signers:[],instructions:[P],instructionTypes:[U.ClmmIncreasePosition],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[]}}static increasePositionFromBaseInstructions({poolInfo:e,poolKeys:t,ownerPosition:n,ownerInfo:o,base:r,baseAmount:i,otherAmountMax:a,nft2022:u}){let[s,l]=[new G(e.programId),new G(e.id)],d=Z.getTickArrayStartIndexByTick(n.tickLower,e.config.tickSpacing),p=Z.getTickArrayStartIndexByTick(n.tickUpper,e.config.tickSpacing),{publicKey:m}=ge(s,l,d),{publicKey:f}=ge(s,l,p),{publicKey:y}=u?j(o.wallet,n.nftMint,Ue):j(o.wallet,n.nftMint,Ke),{publicKey:b}=kt(s,n.nftMint),{publicKey:g}=nn(s,l,n.tickLower,n.tickUpper);return{address:{tickArrayLower:m,tickArrayUpper:f,positionNftAccount:y,personalPosition:b,protocolPosition:g},instructions:[this.increasePositionFromBaseInstruction(s,o.wallet,y,b,l,g,m,f,o.tokenAccountA,o.tokenAccountB,new G(t.vault.A),new G(t.vault.B),new G(e.mintA.address),new G(e.mintB.address),r,i,a,Ne.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing,[d,p])?Qe(s,l).publicKey:void 0)],signers:[],instructionTypes:[U.ClmmIncreasePosition],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[]}}static increasePositionFromBaseInstruction(e,t,n,o,r,i,a,u,s,l,d,p,m,f,y,b,g,P){let h=V([te("liquidity"),k("amountMaxA"),k("amountMaxB"),_("optionBaseFlag"),We("baseFlag")]),I=[...P?[{pubkey:P,isSigner:!1,isWritable:!0}]:[]],T=[{pubkey:t,isSigner:!0,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:d,isSigner:!1,isWritable:!0},{pubkey:p,isSigner:!1,isWritable:!0},{pubkey:Ke,isSigner:!1,isWritable:!1},{pubkey:Ue,isSigner:!1,isWritable:!1},{pubkey:m,isSigner:!1,isWritable:!1},{pubkey:f,isSigner:!1,isWritable:!1},...I],w=Buffer.alloc(h.span);h.encode({liquidity:new hs(0),amountMaxA:y==="MintA"?b:g,amountMaxB:y==="MintA"?g:b,baseFlag:y==="MintA",optionBaseFlag:1},w);let x=Buffer.from([...Nt.increaseLiquidity,...w]);return new lt({keys:T,programId:e,data:x})}static decreaseLiquidityInstruction(e,t,n,o,r,i,a,u,s,l,d,p,m,f,y,b,g,P,h){let I=V([te("liquidity"),k("amountMinA"),k("amountMinB")]),T=[...h?[{pubkey:h,isSigner:!1,isWritable:!0}]:[],...y.map(K=>[{pubkey:K.poolRewardVault,isSigner:!1,isWritable:!0},{pubkey:K.ownerRewardVault,isSigner:!1,isWritable:!0},{pubkey:K.rewardMint,isSigner:!1,isWritable:!1}]).flat()],w=[{pubkey:t,isSigner:!0,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:d,isSigner:!1,isWritable:!0},{pubkey:p,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:Ke,isSigner:!1,isWritable:!1},{pubkey:Ue,isSigner:!1,isWritable:!1},{pubkey:Ji,isSigner:!1,isWritable:!1},{pubkey:m,isSigner:!1,isWritable:!1},{pubkey:f,isSigner:!1,isWritable:!1},...T],x=Buffer.alloc(I.span);I.encode({liquidity:b,amountMinA:g,amountMinB:P},x);let S=Buffer.from([...Nt.decreaseLiquidity,...x]);return new lt({keys:w,programId:e,data:S})}static decreaseLiquidityInstructions({poolInfo:e,poolKeys:t,ownerPosition:n,ownerInfo:o,liquidity:r,amountMinA:i,amountMinB:a,programId:u,nft2022:s}){let[l,d]=[new G(e.programId),new G(e.id)],p=Z.getTickArrayStartIndexByTick(n.tickLower,e.config.tickSpacing),m=Z.getTickArrayStartIndexByTick(n.tickUpper,e.config.tickSpacing),{publicKey:f}=ge(l,d,p),{publicKey:y}=ge(l,d,m),{publicKey:b}=s?j(o.wallet,n.nftMint,Ue):j(o.wallet,n.nftMint,u),{publicKey:g}=kt(l,n.nftMint),{publicKey:P}=nn(l,d,n.tickLower,n.tickUpper),h=[];for(let w=0;w<e.rewardDefaultInfos.length;w++)h.push({poolRewardVault:new G(t.rewardInfos[w].vault),ownerRewardVault:o.rewardAccounts[w],rewardMint:new G(e.rewardDefaultInfos[w].mint.address)});let I=[],T=this.decreaseLiquidityInstruction(l,o.wallet,b,g,d,P,f,y,o.tokenAccountA,o.tokenAccountB,new G(t.vault.A),new G(t.vault.B),new G(e.mintA.address),new G(e.mintB.address),h,r,i,a,Ne.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing,[p,m])?Qe(l,d).publicKey:void 0);return I.push(T),{address:{tickArrayLower:f,tickArrayUpper:y,positionNftAccount:b,personalPosition:g,protocolPosition:P},signers:[],instructions:I,instructionTypes:[U.ClmmDecreasePosition],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[]}}static swapInstruction(e,t,n,o,r,i,a,u,s,l,d,p,m,f,y,b,g){let P=V([k("amount"),k("otherAmountThreshold"),te("sqrtPriceLimitX64"),We("isBaseInput")]),h=[...g?[{pubkey:g,isSigner:!1,isWritable:!0}]:[],...d.map(x=>({pubkey:x,isSigner:!1,isWritable:!0}))],I=[{pubkey:t,isSigner:!0,isWritable:!1},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:p,isSigner:!1,isWritable:!0},{pubkey:Ke,isSigner:!1,isWritable:!1},{pubkey:Ue,isSigner:!1,isWritable:!1},{pubkey:Ji,isSigner:!1,isWritable:!1},{pubkey:s,isSigner:!1,isWritable:!1},{pubkey:l,isSigner:!1,isWritable:!1},...h],T=Buffer.alloc(P.span);P.encode({amount:m,otherAmountThreshold:f,sqrtPriceLimitX64:y,isBaseInput:b},T);let w=Buffer.from([...Nt.swap,...T]);return new lt({keys:I,programId:e,data:w})}static makeSwapBaseInInstructions({poolInfo:e,poolKeys:t,observationId:n,ownerInfo:o,inputMint:r,amountIn:i,amountOutMin:a,sqrtPriceLimitX64:u,remainingAccounts:s}){let[l,d]=[new G(e.programId),new G(e.id)],[p,m]=[new G(t.vault.A),new G(t.vault.B)],[f,y]=[new G(e.mintA.address),new G(e.mintB.address)],b=e.mintA.address===r.toString(),g=[this.swapInstruction(l,o.wallet,d,new G(e.config.id),b?o.tokenAccountA:o.tokenAccountB,b?o.tokenAccountB:o.tokenAccountA,b?p:m,b?m:p,b?f:y,b?y:f,s,n,i,a,u,!0,Qe(l,d).publicKey)];return{signers:[],instructions:g,instructionTypes:[U.ClmmSwapBaseIn],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[],address:{}}}static makeSwapBaseOutInstructions({poolInfo:e,poolKeys:t,observationId:n,ownerInfo:o,outputMint:r,amountOut:i,amountInMax:a,sqrtPriceLimitX64:u,remainingAccounts:s}){let[l,d]=[new G(e.programId),new G(e.id)],[p,m]=[new G(t.vault.A),new G(t.vault.B)],[f,y]=[new G(e.mintA.address),new G(e.mintB.address)],b=e.mintA.address===r.toBase58(),g=[this.swapInstruction(l,o.wallet,d,new G(e.config.id),b?o.tokenAccountB:o.tokenAccountA,b?o.tokenAccountA:o.tokenAccountB,b?m:p,b?p:m,b?y:f,b?f:y,s,n,i,a,u,!1,Qe(l,d).publicKey)];return{signers:[],instructions:g,instructionTypes:[U.ClmmSwapBaseOut],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[],address:{}}}static initRewardInstruction(e,t,n,o,r,i,a,u,s,l,d,p){let m=V([k("openTime"),k("endTime"),te("emissionsPerSecondX64")]),f=[{pubkey:t,isSigner:!0,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!1},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!1},{pubkey:Tn.programId,isSigner:!1,isWritable:!1},{pubkey:Ze,isSigner:!1,isWritable:!1}],y=Buffer.alloc(m.span);m.encode({openTime:J(l),endTime:J(d),emissionsPerSecondX64:p},y);let b=Buffer.from([...Nt.initReward,...y]);return new lt({keys:f,programId:e,data:b})}static initRewardInstructions({poolInfo:e,poolKeys:t,ownerInfo:n,rewardInfo:o}){let[r,i]=[new G(e.programId),new G(e.id)],a=Rc(r,i,o.mint).publicKey,u=gi(r).publicKey,s=[this.initRewardInstruction(r,n.wallet,i,u,new G(e.config.id),n.tokenAccount,o.programId,o.mint,a,o.openTime,o.endTime,o.emissionsPerSecondX64)];return{address:{poolRewardVault:a,operationId:u},signers:[],instructions:s,instructionTypes:[U.ClmmInitReward],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[]}}static setRewardInstruction(e,t,n,o,r,i,a,u,s,l,d,p){let m=V([_("rewardIndex"),te("emissionsPerSecondX64"),k("openTime"),k("endTime")]),f=[{pubkey:t,isSigner:!0,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:Ke,isSigner:!1,isWritable:!1},{pubkey:Ue,isSigner:!1,isWritable:!1},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0}],y=Buffer.alloc(m.span);m.encode({rewardIndex:s,emissionsPerSecondX64:p,openTime:J(l),endTime:J(d)},y);let b=Buffer.from([...Nt.setRewardEmissions,...y]);return new lt({keys:f,programId:e,data:b})}static setRewardInstructions({poolInfo:e,poolKeys:t,ownerInfo:n,rewardInfo:o}){let[r,i]=[new G(e.programId),new G(e.id)],a,u,s;for(let p=0;p<e.rewardDefaultInfos.length;p++)e.rewardDefaultInfos[p].mint.address===o.mint.toString()&&(a=p,u=new G(t.rewardInfos[p].vault),s=new G(t.rewardInfos[p].mint.address));(a===void 0||u===void 0)&&Dc.logWithError("reward mint check error","no reward mint",e.rewardDefaultInfos);let l=gi(r).publicKey,d=[this.setRewardInstruction(r,n.wallet,i,l,new G(e.config.id),n.tokenAccount,u,s,a,o.openTime,o.endTime,o.emissionsPerSecondX64)];return{address:{rewardVault:u,operationId:l},signers:[],instructions:d,instructionTypes:[U.ClmmSetReward],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[]}}static collectRewardInstruction(e,t,n,o,r,i,a){let u=V([_("rewardIndex")]),s=[{pubkey:t,isSigner:!0,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!1},{pubkey:Ke,isSigner:!1,isWritable:!1},{pubkey:Ue,isSigner:!1,isWritable:!1},{pubkey:Ji,isSigner:!1,isWritable:!1}],l=Buffer.alloc(u.span);u.encode({rewardIndex:a},l);let d=Buffer.from([...Nt.collectReward,...l]);return new lt({keys:s,programId:e,data:d})}static collectRewardInstructions({poolInfo:e,poolKeys:t,ownerInfo:n,rewardMint:o}){let[r,i]=[new G(e.programId),new G(e.id)],a,u;for(let l=0;l<e.rewardDefaultInfos.length;l++)e.rewardDefaultInfos[l].mint.address===o.toString()&&(a=l,u=new G(t.rewardInfos[l].vault));(a===void 0||u===void 0)&&Dc.logWithError("reward mint check error","no reward mint",e.rewardDefaultInfos);let s=[this.collectRewardInstruction(r,n.wallet,i,n.tokenAccount,u,o,a)];return{address:{rewardVault:u},signers:[],instructions:s,instructionTypes:[U.ClmmCollectReward],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[]}}static async makeLockPositions({programId:e,authProgramId:t,poolProgramId:n,payer:o,wallet:r,nftMint:i,nft2022:a,getEphemeralSigners:u}){let s=[],l;if(u)l=new G((await u(1))[0]);else{let g=Or.generate();s.push(g),l=g.publicKey}let d=a?j(r,i,Ue).publicKey:j(r,i,Ke).publicKey,{publicKey:p}=kt(n,i),m=xo(e,l).publicKey,f=j(r,l,Ke).publicKey,y=kn(l).publicKey,b=Ce.lockPositionInstructionV2({programId:e,auth:t,payer:o,positionOwner:r,lockOwner:r,positionNftAccount:d,positionId:p,lockPositionId:m,lockNftMint:l,lockNftAccount:f,metadataAccount:y,withMetadata:!0,nft2022:a,positionNftMint:i,authPositionNftAccount:j(t,i,a?Ue:Ke).publicKey,positionNftProgram:a?Ue:Ke});return{address:{positionId:p,lockPositionId:m,lockNftAccount:f,lockNftMint:l,positionNftAccount:d,metadataAccount:y},instructions:[b],signers:s,instructionTypes:[U.ClmmLockPosition],lookupTableAddress:[]}}static lockPositionInstructionV2({programId:e,auth:t,payer:n,positionOwner:o,lockOwner:r,positionNftAccount:i,positionId:a,positionNftMint:u,authPositionNftAccount:s,positionNftProgram:l,lockPositionId:d,lockNftMint:p,lockNftAccount:m,metadataAccount:f,withMetadata:y}){let b=[{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!0,isWritable:!0},{pubkey:o,isSigner:!0,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!1},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!1},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:d,isSigner:!1,isWritable:!0},{pubkey:p,isSigner:!0,isWritable:!0},{pubkey:m,isSigner:!1,isWritable:!0},{pubkey:f,isSigner:!1,isWritable:!0},{pubkey:jt,isSigner:!1,isWritable:!1},{pubkey:wi,isSigner:!1,isWritable:!1},{pubkey:Ze,isSigner:!1,isWritable:!1},{pubkey:Ke,isSigner:!1,isWritable:!1},{pubkey:l,isSigner:!1,isWritable:!1},{pubkey:Tn.programId,isSigner:!1,isWritable:!1}],g=V([We("withMetadata")]),P=Buffer.alloc(g.span);g.encode({withMetadata:y},P);let h=Buffer.from([...Wc,...P]);return new lt({keys:b,programId:e,data:h})}static lockPositionInstruction({programId:e,authProgramId:t,poolProgramId:n,owner:o,positionNft:r}){let{publicKey:i}=j(o,r,Ke),{publicKey:a}=kt(n,r),u=[{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!0,isWritable:!1},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!1},{pubkey:gs(e,a).publicKey,isSigner:!1,isWritable:!0},{pubkey:Ke,isSigner:!1,isWritable:!1},{pubkey:Tn.programId,isSigner:!1,isWritable:!1}];return new lt({keys:u,programId:e,data:Buffer.from(Wc)})}static harvestLockPositionInstruction(e){let[t,n]=[new G(e.poolKeys.programId),new G(e.poolKeys.id)],o=Z.getTickArrayStartIndexByTick(e.ownerPosition.tickLower,e.poolKeys.config.tickSpacing),r=Z.getTickArrayStartIndexByTick(e.ownerPosition.tickUpper,e.poolKeys.config.tickSpacing),{publicKey:i}=ge(t,n,o),{publicKey:a}=ge(t,n,r),{publicKey:u}=j(e.owner,e.ownerPosition.nftMint,Ke),{publicKey:s}=kt(t,e.ownerPosition.nftMint),{publicKey:l}=nn(t,n,e.ownerPosition.tickLower,e.ownerPosition.tickUpper),d=[];for(let f=0;f<e.poolKeys.rewardInfos.length;f++)d.push({poolRewardVault:new G(e.poolKeys.rewardInfos[f].vault),ownerRewardVault:e.ownerRewardAccounts[f],rewardMint:new G(e.poolKeys.rewardInfos[f].mint.address)});let p=[...d.map(f=>[{pubkey:f.poolRewardVault,isSigner:!1,isWritable:!0},{pubkey:f.ownerRewardVault,isSigner:!1,isWritable:!0},{pubkey:f.rewardMint,isSigner:!1,isWritable:!1}]).flat()],m=[{pubkey:e.authProgramId,isSigner:!1,isWritable:!1},{pubkey:gs(e.programId,s).publicKey,isSigner:!1,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:e.owner,isSigner:!0,isWritable:!1},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:new G(e.poolKeys.vault.A),isSigner:!1,isWritable:!0},{pubkey:new G(e.poolKeys.vault.B),isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:e.userVaultA,isSigner:!1,isWritable:!0},{pubkey:e.userVaultB,isSigner:!1,isWritable:!0},{pubkey:Ke,isSigner:!1,isWritable:!1},{pubkey:Ue,isSigner:!1,isWritable:!1},{pubkey:sn,isSigner:!1,isWritable:!1},{pubkey:new G(e.poolKeys.mintA.address),isSigner:!1,isWritable:!1},{pubkey:new G(e.poolKeys.mintB.address),isSigner:!1,isWritable:!1},...p];return new lt({keys:m,programId:e.programId,data:Buffer.from(qc)})}static harvestLockPositionInstructionV2({programId:e,auth:t,lockPositionId:n,clmmProgram:o,lockOwner:r,lockNftMint:i,lockNftAccount:a,positionNftAccount:u,positionId:s,poolId:l,protocolPosition:d,vaultA:p,vaultB:m,tickArrayLower:f,tickArrayUpper:y,userVaultA:b,userVaultB:g,mintA:P,mintB:h,rewardAccounts:I,exTickArrayBitmap:T}){let w=[...T?[{pubkey:T,isSigner:!1,isWritable:!0}]:[],...I.map(S=>[{pubkey:S.poolRewardVault,isSigner:!1,isWritable:!0},{pubkey:S.ownerRewardVault,isSigner:!1,isWritable:!0},{pubkey:S.rewardMint,isSigner:!1,isWritable:!1}]).flat()],x=[{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!0,isWritable:!1},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:d,isSigner:!1,isWritable:!0},{pubkey:p,isSigner:!1,isWritable:!0},{pubkey:m,isSigner:!1,isWritable:!0},{pubkey:f,isSigner:!1,isWritable:!0},{pubkey:y,isSigner:!1,isWritable:!0},{pubkey:b,isSigner:!1,isWritable:!0},{pubkey:g,isSigner:!1,isWritable:!0},{pubkey:Ke,isSigner:!1,isWritable:!1},{pubkey:Ue,isSigner:!1,isWritable:!1},{pubkey:sn,isSigner:!1,isWritable:!1},{pubkey:P,isSigner:!1,isWritable:!1},{pubkey:h,isSigner:!1,isWritable:!1},...w];return new lt({keys:x,programId:e,data:Buffer.from(qc)})}};var Uc=V([ct("mintAuthorityOption"),O("mintAuthority"),k("supply"),_("decimals"),_("isInitialized"),ct("freezeAuthorityOption"),O("freezeAuthority")]);import{PublicKey as Jd}from"@solana/web3.js";import{MintLayout as Gc,TOKEN_PROGRAM_ID as ep}from"@solana/spl-token";var lh=async({connection:c,mint:e})=>{let t=await c.getAccountInfo(new Jd(e));return!t||t.data.length!==Gc.span?void 0:Gc.decode(t.data)},mh=({mint:c,decimals:e,programId:t=ep,logoURI:n="",priority:o=3})=>{let r=c.toBase58().substring(0,6);return{address:c.toBase58(),decimals:e,symbol:r,logoURI:n,extensions:{},chainId:101,programId:t.toString(),name:r,tags:[],priority:o}},Nr=c=>new De({mint:c.address,decimals:c.decimals,symbol:c.symbol,name:c.name}),Ti=o=>{var r=o,{amount:c,isRaw:e,name:t}=r,n=qe(r,["amount","isRaw","name"]);return new Se(new De({mint:mt(n.address).toBase58(),decimals:n.decimals,symbol:n.symbol,name:t}),c,e,t)};function dh(c){return c.address===an.address?nt:c}function ph(c){return c.address===nt.address?an:c}var ft=o=>{var r=o,{address:c,programId:e,decimals:t}=r,n=qe(r,["address","programId","decimals"]);return N({chainId:101,address:mt(c).toBase58(),programId:e,logoURI:"",symbol:"",name:"",decimals:t,tags:[],extensions:n.extensions||{}},n)},Mn=c=>c?q(N({},c),{transferFeeConfigAuthority:c.transferFeeConfigAuthority.toBase58(),withdrawWithheldAuthority:c.withdrawWithheldAuthority.toBase58(),withheldAmount:c.withheldAmount.toString(),olderTransferFee:q(N({},c.olderTransferFee),{epoch:c.olderTransferFee.epoch.toString(),maximumFee:c.olderTransferFee.maximumFee.toString()}),newerTransferFee:q(N({},c.newerTransferFee),{epoch:c.newerTransferFee.epoch.toString(),maximumFee:c.newerTransferFee.maximumFee.toString()})}):void 0;import Xc from"bn.js";var Is=new Xc(25),Mr=new Xc(1e4),tp={4:3,5:3};import{PublicKey as Re,SystemProgram as Yc,SYSVAR_RENT_PUBKEY as op,TransactionInstruction as hn}from"@solana/web3.js";import{ASSOCIATED_TOKEN_PROGRAM_ID as ip,TOKEN_PROGRAM_ID as Co}from"@solana/spl-token";var Bs=V([_("instruction"),k("amountIn"),k("minAmountOut")]),xs=V([_("instruction"),k("maxAmountIn"),k("amountOut")]),Ih=V([_("instruction"),_("nonce")]),Ss=V([_("instruction"),_("nonce"),k("startTime")]),$n=V([k("status"),k("nonce"),k("maxOrder"),k("depth"),k("baseDecimal"),k("quoteDecimal"),k("state"),k("resetFlag"),k("minSize"),k("volMaxCutRatio"),k("amountWaveRatio"),k("baseLotSize"),k("quoteLotSize"),k("minPriceMultiplier"),k("maxPriceMultiplier"),k("systemDecimalValue"),k("minSeparateNumerator"),k("minSeparateDenominator"),k("tradeFeeNumerator"),k("tradeFeeDenominator"),k("pnlNumerator"),k("pnlDenominator"),k("swapFeeNumerator"),k("swapFeeDenominator"),k("baseNeedTakePnl"),k("quoteNeedTakePnl"),k("quoteTotalPnl"),k("baseTotalPnl"),k("poolOpenTime"),k("punishPcAmount"),k("punishCoinAmount"),k("orderbookToInitTime"),te("swapBaseInAmount"),te("swapQuoteOutAmount"),k("swapBase2QuoteFee"),te("swapQuoteInAmount"),te("swapBaseOutAmount"),k("swapQuote2BaseFee"),O("baseVault"),O("quoteVault"),O("baseMint"),O("quoteMint"),O("lpMint"),O("openOrders"),O("marketId"),O("marketProgramId"),O("targetOrders"),O("withdrawQueue"),O("lpVault"),O("owner"),k("lpReserve"),Y(k(),3,"padding")]),np=V([k("accountType"),k("status"),k("nonce"),k("maxOrder"),k("depth"),k("baseDecimal"),k("quoteDecimal"),k("state"),k("resetFlag"),k("minSize"),k("volMaxCutRatio"),k("amountWaveRatio"),k("baseLotSize"),k("quoteLotSize"),k("minPriceMultiplier"),k("maxPriceMultiplier"),k("systemDecimalsValue"),k("abortTradeFactor"),k("priceTickMultiplier"),k("priceTick"),k("minSeparateNumerator"),k("minSeparateDenominator"),k("tradeFeeNumerator"),k("tradeFeeDenominator"),k("pnlNumerator"),k("pnlDenominator"),k("swapFeeNumerator"),k("swapFeeDenominator"),k("baseNeedTakePnl"),k("quoteNeedTakePnl"),k("quoteTotalPnl"),k("baseTotalPnl"),k("poolOpenTime"),k("punishPcAmount"),k("punishCoinAmount"),k("orderbookToInitTime"),te("swapBaseInAmount"),te("swapQuoteOutAmount"),te("swapQuoteInAmount"),te("swapBaseOutAmount"),k("swapQuote2BaseFee"),k("swapBase2QuoteFee"),O("baseVault"),O("quoteVault"),O("baseMint"),O("quoteMint"),O("lpMint"),O("modelDataAccount"),O("openOrders"),O("marketId"),O("marketProgramId"),O("targetOrders"),O("owner"),Y(k(),64,"padding")]),Ks=V([_("instruction"),k("baseAmountIn"),k("quoteAmountIn"),k("fixedSide"),k("otherAmountMin")]),Cs=V([_("instruction"),k("lpAmount"),k("baseAmountMin"),k("quoteAmountMin")]),Bh={4:$n,5:np},zc=V([k("fee")]);var Qc=fe("Raydium_liquidity_instruction");function jc(c){let{poolInfo:e,poolKeys:t,userKeys:n,baseAmountIn:o,quoteAmountIn:r,fixedSide:i,otherAmountMin:a,modelDataPubKey:u=Kn}=c,s=Buffer.alloc(Ks.span);Ks.encode({instruction:3,baseAmountIn:J(o),quoteAmountIn:J(r),otherAmountMin:J(a),fixedSide:i==="base"?It:Iu},s);let l=[A({pubkey:Co,isWritable:!1}),A({pubkey:new Re(e.id)}),A({pubkey:new Re(t.authority),isWritable:!1}),A({pubkey:new Re(t.openOrders),isWritable:!1}),A({pubkey:new Re(t.targetOrders)}),A({pubkey:new Re(e.lpMint.address)}),A({pubkey:new Re(t.vault.A)}),A({pubkey:new Re(t.vault.B)})];return e.pooltype.includes("StablePool")&&l.push(A({pubkey:u})),l.push(A({pubkey:new Re(e.marketId),isWritable:!1}),A({pubkey:n.baseTokenAccount}),A({pubkey:n.quoteTokenAccount}),A({pubkey:n.lpTokenAccount}),A({pubkey:n.owner,isWritable:!1,isSigner:!0}),A({pubkey:new Re(t.marketEventQueue),isWritable:!1})),new hn({programId:new Re(e.programId),keys:l,data:s})}function Rs(c){let{poolInfo:e,poolKeys:t,userKeys:n,lpAmount:o,baseAmountMin:r,quoteAmountMin:i,modelDataPubKey:a=Kn}=c,u=Me(t),s=4;if(e.pooltype.includes("StablePool")&&(s=5),s===4||s===5){let l=Buffer.alloc(Cs.span);Cs.encode({instruction:4,lpAmount:J(o),baseAmountMin:J(r),quoteAmountMin:J(i)},l);let d=[A({pubkey:Co,isWritable:!1}),A({pubkey:u.id}),A({pubkey:u.authority,isWritable:!1}),A({pubkey:u.openOrders}),A({pubkey:u.targetOrders}),A({pubkey:u.mintLp.address}),A({pubkey:u.vault.A}),A({pubkey:u.vault.B})];return s===5?d.push(A({pubkey:a})):(d.push(A({pubkey:u.id})),d.push(A({pubkey:u.id}))),d.push(A({pubkey:u.marketProgramId,isWritable:!1}),A({pubkey:u.marketId}),A({pubkey:u.marketBaseVault}),A({pubkey:u.marketQuoteVault}),A({pubkey:u.marketAuthority,isWritable:!1}),A({pubkey:n.lpTokenAccount}),A({pubkey:n.baseTokenAccount}),A({pubkey:n.quoteTokenAccount}),A({pubkey:n.owner,isWritable:!1,isSigner:!0}),A({pubkey:u.marketEventQueue}),A({pubkey:u.marketBids}),A({pubkey:u.marketAsks})),new hn({programId:u.programId,keys:d,data:l})}return new hn({programId:u.programId,keys:[]})}function Ls({programId:c,ammId:e,ammAuthority:t,ammOpenOrders:n,lpMint:o,coinMint:r,pcMint:i,coinVault:a,pcVault:u,withdrawQueue:s,ammTargetOrders:l,poolTempLp:d,marketProgramId:p,marketId:m,userWallet:f,userCoinVault:y,userPcVault:b,userLpVault:g,nonce:P,openTime:h,coinAmount:I,pcAmount:T,ammConfigId:w,feeDestinationId:x}){let S=V([_("instruction"),_("nonce"),k("openTime"),k("pcAmount"),k("coinAmount")]),K=[{pubkey:Co,isSigner:!1,isWritable:!1},{pubkey:ip,isSigner:!1,isWritable:!1},{pubkey:Yc.programId,isSigner:!1,isWritable:!1},{pubkey:Ze,isSigner:!1,isWritable:!1},{pubkey:e,isSigner:!1,isWritable:!0},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!1},{pubkey:i,isSigner:!1,isWritable:!1},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:w,isSigner:!1,isWritable:!1},{pubkey:x,isSigner:!1,isWritable:!0},{pubkey:p,isSigner:!1,isWritable:!1},{pubkey:m,isSigner:!1,isWritable:!1},{pubkey:f,isSigner:!0,isWritable:!0},{pubkey:y,isSigner:!1,isWritable:!0},{pubkey:b,isSigner:!1,isWritable:!0},{pubkey:g,isSigner:!1,isWritable:!0}],B=Buffer.alloc(S.span);return S.encode({instruction:1,nonce:P,openTime:h,coinAmount:I,pcAmount:T},B),{instruction:new hn({keys:K,programId:c,data:B}),instructionType:U.AmmV4CreatePool}}function Fh(c){let e=V([_("instruction"),_("simulateType")]),t=Buffer.alloc(e.span);e.encode({instruction:12,simulateType:0},t);let n=[A({pubkey:new Re(c.id),isWritable:!1}),A({pubkey:new Re(c.authority),isWritable:!1}),A({pubkey:new Re(c.openOrders),isWritable:!1}),A({pubkey:new Re(c.vault.A),isWritable:!1}),A({pubkey:new Re(c.vault.B),isWritable:!1}),A({pubkey:new Re(c.mintLp.address),isWritable:!1}),A({pubkey:new Re(c.marketId),isWritable:!1}),A({pubkey:new Re(c.marketEventQueue),isWritable:!1})];return new hn({programId:new Re(c.programId),keys:n,data:t})}function rp({poolKeys:c,userKeys:e,amountIn:t,minAmountOut:n,modelDataPubKey:o=Kn},r){let i=Me(c),a=Buffer.alloc(Bs.span);Bs.encode({instruction:9,amountIn:J(t),minAmountOut:J(n)},a);let u=[A({pubkey:Co,isWritable:!1}),A({pubkey:i.id}),A({pubkey:i.authority,isWritable:!1}),A({pubkey:i.openOrders})];return r===4&&u.push(A({pubkey:i.targetOrders})),u.push(A({pubkey:i.vault.A}),A({pubkey:i.vault.B})),r===5&&u.push(A({pubkey:o})),u.push(A({pubkey:i.marketProgramId,isWritable:!1}),A({pubkey:i.marketId}),A({pubkey:i.marketBids}),A({pubkey:i.marketAsks}),A({pubkey:i.marketEventQueue}),A({pubkey:i.marketBaseVault}),A({pubkey:i.marketQuoteVault}),A({pubkey:i.marketAuthority,isWritable:!1}),A({pubkey:e.tokenAccountIn}),A({pubkey:e.tokenAccountOut}),A({pubkey:e.owner,isWritable:!1,isSigner:!0})),new hn({programId:i.programId,keys:u,data:a})}function ap({poolKeys:c,userKeys:e,maxAmountIn:t,amountOut:n,modelDataPubKey:o=Kn},r){let i=Me(c),a=Buffer.alloc(xs.span);xs.encode({instruction:11,maxAmountIn:J(t),amountOut:J(n)},a);let u=[A({pubkey:Co,isWritable:!1}),A({pubkey:i.id}),A({pubkey:i.authority,isWritable:!1}),A({pubkey:i.openOrders}),A({pubkey:i.targetOrders}),A({pubkey:i.vault.A}),A({pubkey:i.vault.B})];return r===5&&u.push(A({pubkey:o})),u.push(A({pubkey:i.marketProgramId,isWritable:!1}),A({pubkey:i.marketId}),A({pubkey:i.marketBids}),A({pubkey:i.marketAsks}),A({pubkey:i.marketEventQueue}),A({pubkey:i.marketBaseVault}),A({pubkey:i.marketQuoteVault}),A({pubkey:i.marketAuthority,isWritable:!1}),A({pubkey:e.tokenAccountIn}),A({pubkey:e.tokenAccountOut}),A({pubkey:e.owner,isWritable:!1,isSigner:!0})),new hn({programId:i.programId,keys:u,data:a})}function vr(c){let{poolKeys:e,version:t,userKeys:n,amountIn:o,amountOut:r,fixedSide:i}=c;if(t===4||t===5){let a={poolKeys:e,userKeys:n};if(i==="in")return rp(q(N({},a),{amountIn:o,minAmountOut:r}),t);if(i==="out")return ap(q(N({},a),{maxAmountIn:o,amountOut:r}),t);Qc.logWithError("invalid params","params",c)}throw Qc.logWithError("invalid version","poolKeys.version",t),new Error("invalid version")}function Vh({poolKeys:c,userKeys:e,startTime:t}){let n=Buffer.alloc(Ss.span);Ss.encode({instruction:0,nonce:5,startTime:J(t)},n);let o=Me(c),r=[A({pubkey:Co,isWritable:!1}),A({pubkey:Yc.programId,isWritable:!1}),A({pubkey:op,isWritable:!1}),A({pubkey:o.id}),A({pubkey:o.authority,isWritable:!1}),A({pubkey:o.openOrders}),A({pubkey:o.mintLp.address}),A({pubkey:o.mintA.address,isWritable:!1}),A({pubkey:o.mintB.address,isWritable:!1}),A({pubkey:o.vault.A,isWritable:!1}),A({pubkey:o.vault.B,isWritable:!1}),A({pubkey:o.id}),A({pubkey:o.targetOrders}),A({pubkey:e.lpTokenAccount}),A({pubkey:o.id,isWritable:!1}),A({pubkey:o.marketProgramId,isWritable:!1}),A({pubkey:o.marketId,isWritable:!1}),A({pubkey:e.payer,isSigner:!0})];return new hn({programId:o.programId,keys:r,data:n})}function Hc({poolKeys:c}){let e=V([_("instruction"),_("simulateType")]),t=Buffer.alloc(e.span);e.encode({instruction:12,simulateType:0},t);let n=[A({pubkey:new Re(c.id),isWritable:!1}),A({pubkey:new Re(c.authority),isWritable:!1}),A({pubkey:new Re(c.openOrders),isWritable:!1}),A({pubkey:new Re(c.vault.A),isWritable:!1}),A({pubkey:new Re(c.vault.B),isWritable:!1}),A({pubkey:new Re(c.mintLp.address),isWritable:!1}),A({pubkey:new Re(c.marketId),isWritable:!1}),A({pubkey:new Re(c.marketEventQueue),isWritable:!1})];return{instruction:new hn({programId:new Re(c.programId),keys:n,data:t})}}var eo=5e4,sp=V([k("x"),k("y"),k("price")]),up=V([k("accountType"),k("status"),k("multiplier"),k("validDataCount"),Y(sp,eo,"DataElement")]);function cp(c,e){return[0,eo-2]}function lp(c){return[0,eo-2]}function mp(c){return[0,eo-2]}function dp(c,e,t){let[n,o]=cp(e,t),r=n,i=o,a=0,u=e*c.multiplier/t;for(;r<=i;){if(a=Math.floor((i+r)/2),a===0||a>=eo-2)return[a,a,!1];let s=c.DataElement[a].x*c.multiplier/c.DataElement[a].y,l=c.DataElement[a-1].x*c.multiplier/c.DataElement[a-1].y,d=c.DataElement[a+1].x*c.multiplier/c.DataElement[a+1].y;if(u===s)return[a,a,!0];if(u===l)return[a-1,a-1,!0];if(u===d)return[a+1,a+1,!0];if(u<l)i=a-1;else{if(u>l&&u<s)return[a-1,a,!0];if(u>s&&u<d)return[a,a+1,!0];r=a+1}}return[a,a,!1]}function Os(c,e,t){let[n,o,r]=dp(c,e,t);if(!r)return 0;if(n===o){let i=c.DataElement[n].x;return e*c.multiplier/i}else{let i=c.DataElement[n].x,a=c.DataElement[n].y,u=c.DataElement[o].x,s=c.DataElement[o].y,l=t*(u*a-i*s),d=i*l,p=(u-i)*(e*a-i*t)*s,m=d+p;return e*c.multiplier*l/m}}function Jn(c,e,t){return e*c.multiplier/t}function Zc(c,e,t){return e*t/c.multiplier}function pp(c,e){let[t,n]=lp(e),o=t,r=n,i=0,a=e;for(;o<r;){if(i=Math.floor((r+o)/2),i<=0||i>eo-2)return[i,i,!1];let u=c.DataElement[i].x,s=c.DataElement[i-1].x,l=c.DataElement[i+1].x;if(a===u)return[i,i,!0];if(a===s)return[i-1,i-1,!0];if(a===l)return[i+1,i+1,!0];if(a<s)r=i-1;else{if(a>s&&a<u)return[i-1,i,!0];if(a>u&&a<l)return[i,i+1,!0];o=i+1}}return[i,i,!1]}function fp(c,e){let[t,n]=mp(e),o=t,r=n,i=0,a=e;for(;o<=r;){if(i=Math.floor((r+o)/2),i<=0||i>=eo-2)return[i,i,!1];let u=c.DataElement[i].y,s=c.DataElement[i-1].y,l=c.DataElement[i+1].y;if(a===u)return[i,i,!0];if(a===s)return[i-1,i-1,!0];if(a===l)return[i+1,i+1,!0];if(a<l)o=i+1;else{if(a<s&&a>u)return[i-1,i,!0];if(a<u&&a>l)return[i,i+1,!0];r=i-1}}return[i,i,!1]}function $c(c,e,t,n){let o=n?e+t:e-t,[r,i,a]=pp(c,o);if(!a)return[0,0,!1,a];if(r===i)return[c.DataElement[i].price,c.DataElement[i].y,!1,a];{let u=c.DataElement[r].x,s=c.DataElement[i].x,l=c.DataElement[r].price,d=c.DataElement[i].price,p=c.DataElement[r].y,m=c.DataElement[i].y;if(e>=u&&e<=s)return n?[d,m,!0,a]:[l,p,!0,a];{let f,y;return n?(f=l+(d-l)*(e-u)/(s-u),y=p-(o-u)*c.multiplier/d):(f=l+(d-l)*(e-u)/(s-u),y=m+(s-o)*c.multiplier/l),[f,y,!1,a]}}}function yp(c,e,t,n){let o=n?e-t:e+t,[r,i,a]=fp(c,o);if(!a)return[0,0,!1,a];if(r===i)return[c.DataElement[i].price,c.DataElement[i].x,!1,a];{let u=c.DataElement[r].x,s=c.DataElement[i].x,l=c.DataElement[r].price,d=c.DataElement[i].price,p=c.DataElement[r].y,m=c.DataElement[i].y;if(e>=m&&e<=p)return n?[d,s,!0,a]:[l,u,!0,a];{let f,y;return n?(f=l+(d-l)*(p-e)/(p-m),y=u+d*(p-o)/c.multiplier):(f=l+(d-l)*(p-e)/(p-m),y=s-l*(o-m)/c.multiplier),[f,y,!1,a]}}}function bp(c,e){let t=$c(c,e,0,!1);return t[3]?t[0]:0}function Jc(c,e,t,n){let o=Os(c,e,t),r=Jn(c,e,o),i=Jn(c,t,o),a=Jn(c,n,o),u=!0,[s,l,d,p]=$c(c,r,a,u);if(!p)return 0;if(d)return n*c.multiplier/s;{let m=i-l;return Zc(c,m,o)}}function el(c,e,t,n){let o=Os(c,e,t),r=Jn(c,e,o),i=Jn(c,t,o),a=Jn(c,n,o),u=!1,[s,l,d,p]=yp(c,i,a,u);if(!p)return 0;if(d)return n*s/c.multiplier;{let m=r-l;return Zc(c,m,o)}}function gp(c){let e=up.decode(c);return{accountType:e.accountType.toNumber(),status:e.status.toNumber(),multiplier:e.multiplier.toNumber(),validDataCount:e.validDataCount.toNumber(),DataElement:e.DataElement.map(t=>({x:t.x.toNumber(),y:t.y.toNumber(),price:t.price.toNumber()}))}}function tl(c,e,t,n){let o=bp(c,Jn(c,e,Os(c,e,t)))/c.multiplier;return n?o:1/o}var Ro=class{constructor({connection:e,modelDataPubKey:t=Kn}){this._layoutData={accountType:0,status:0,multiplier:0,validDataCount:0,DataElement:[]};this.connection=e,this.modelDataPubKey=t}get stableModelData(){return this._layoutData}async initStableModelLayout(){if(this._layoutData.validDataCount===0&&this.connection){let e=await this.connection.getAccountInfo(this.modelDataPubKey);e&&(this._layoutData=gp(e==null?void 0:e.data))}}};import{PublicKey as Ii}from"@solana/web3.js";import hi from"bn.js";import Fr from"decimal.js";import{TOKEN_PROGRAM_ID as kp}from"@solana/spl-token";import{PublicKey as Ap}from"@solana/web3.js";var Pp=fe("Raydium_liquidity_serum");function nl({programId:c,marketId:e}){let t=[e.toBuffer()],n=0,o;for(;n<100;){try{let r=t.concat(Buffer.from([n]),Buffer.alloc(7));o=Ap.createProgramAddressSync(r,c)}catch(r){if(r instanceof TypeError)throw r;n++;continue}return{publicKey:o,nonce:n}}throw Pp.logWithError("unable to find a viable program address nonce","params",{programId:c,marketId:e}),new Error("unable to find a viable program address nonce")}function Vr({programId:c}){let{publicKey:e}=ne([Buffer.from("amm_config_account_seed","utf-8")],c);return e}function to({name:c,programId:e,marketId:t}){let{publicKey:n}=ne([e.toBuffer(),t.toBuffer(),Buffer.from(c,"utf-8")],e);return n}function wp({programId:c,marketId:e}){let{publicKey:t}=ne([c.toBuffer(),e.toBuffer(),Buffer.from("open_order_associated_seed","utf-8")],c);return t}function vs({programId:c}){return ne([Buffer.from([97,109,109,32,97,117,116,104,111,114,105,116,121])],c)}function Fs({version:c,marketVersion:e,marketId:t,baseMint:n,quoteMint:o,baseDecimals:r,quoteDecimals:i,programId:a,marketProgramId:u}){let s=to({name:"amm_associated_seed",programId:a,marketId:t}),l=to({name:"lp_mint_associated_seed",programId:a,marketId:t}),{publicKey:d,nonce:p}=vs({programId:a}),m=to({name:"coin_vault_associated_seed",programId:a,marketId:t}),f=to({name:"pc_vault_associated_seed",programId:a,marketId:t}),y=to({name:"temp_lp_token_associated_seed",programId:a,marketId:t}),b=wp({programId:a,marketId:t}),g=to({name:"target_associated_seed",programId:a,marketId:t}),P=to({name:"withdraw_associated_seed",programId:a,marketId:t}),{publicKey:h}=nl({programId:u,marketId:t});return{id:s,baseMint:n,quoteMint:o,lpMint:l,baseDecimals:r,quoteDecimals:i,lpDecimals:r,version:c,programId:a,authority:d,nonce:p,baseVault:m,quoteVault:f,lpVault:y,openOrders:b,targetOrders:g,withdrawQueue:P,marketVersion:e,marketProgramId:u,marketId:t,marketAuthority:h,lookupTableAccount:Ii.default,configId:Vr({programId:a})}}var Ns;async function lI({connection:c,poolKeysList:e,config:t,modelDataPubKey:n}){return e.find(r=>r.modelDataAccount)&&(Ns||(Ns=new Ro({connection:c,modelDataPubKey:n}),await Ns.initStableModelLayout())),await Promise.all(e.map(async r=>{if(r.modelDataAccount){let i=Hc({poolKeys:r});return(await Nu(c,[i.instruction],"GetPoolData")).map(s=>{let l=Mu(s,"GetPoolData"),d=new hi(bn(l,"status")),p=Number(bn(l,"coin_decimals")),m=Number(bn(l,"pc_decimals")),f=Number(bn(l,"lp_decimals")),y=new hi(bn(l,"pool_coin_amount")),b=new hi(bn(l,"pool_pc_amount")),g=new hi(bn(l,"pool_lp_supply")),P="0";try{P=bn(l,"pool_open_time")}catch{}return{status:d,baseDecimals:p,quoteDecimals:m,lpDecimals:f,baseReserve:y,quoteReserve:b,lpSupply:g,startTime:new hi(P)}})[0]}else{let[i,a,u,s]=await c.getMultipleAccountsInfo([new Ii(r.id),new Ii(r.vault.A),new Ii(r.vault.B),new Ii(r.mintLp.address)]);if(i===null)throw Error("fetch pool error");if(a===null)throw Error("fetch vaultAccA error");if(u===null)throw Error("fetch vaultAccB error");if(s===null)throw Error("fetch mintAccLp error");let l=$n.decode(i.data),d=tn.decode(a.data),p=tn.decode(u.data),m=Uc.decode(s.data);return{status:l.status,baseDecimals:l.baseDecimal.toNumber(),quoteDecimals:l.quoteDecimal.toNumber(),lpDecimals:m.decimals,baseReserve:d.amount.sub(l.baseNeedTakePnl),quoteReserve:p.amount.sub(l.quoteNeedTakePnl),lpSupply:l.lpReserve,startTime:l.poolOpenTime}}}))}var Ms={volume:0,volumeQuote:0,volumeFee:0,apr:0,feeApr:0,priceMin:0,priceMax:0,rewardApr:[]},_r=c=>{let e={},t=kp.toBase58();return Object.keys(c).map(n=>{let o=c[n],[r,i]=[o.baseMint.toBase58(),o.quoteMint.toBase58()];e[n]={id:n,version:4,status:o.status.toNumber(),programId:o.programId.toBase58(),mintA:ft({address:r,programId:t,decimals:o.baseDecimal.toNumber()}),mintB:ft({address:i,programId:t,decimals:o.quoteDecimal.toNumber()}),rewardDefaultInfos:[],rewardDefaultPoolInfos:"Ecosystem",price:o.poolPrice.toNumber(),mintAmountA:new Fr(o.mintAAmount.toString()).div(10**o.baseDecimal.toNumber()).toNumber(),mintAmountB:new Fr(o.mintBAmount.toString()).div(10**o.quoteDecimal.toNumber()).toNumber(),baseReserve:o.baseReserve,quoteReserve:o.quoteReserve,feeRate:new Fr(o.tradeFeeNumerator.toString()).div(o.tradeFeeDenominator.toString()).toNumber(),openTime:o.poolOpenTime.toString(),tvl:0,day:Ms,week:Ms,month:Ms,pooltype:[],farmUpcomingCount:0,farmOngoingCount:0,farmFinishedCount:0,type:"Standard",marketId:o.marketId.toBase58(),configId:Vr({programId:o.programId}).toBase58(),lpPrice:0,lpAmount:new Fr(o.lpReserve.toString()).div(10**Math.min(o.baseDecimal.toNumber(),o.quoteDecimal.toNumber())).toNumber(),lpMint:ft({address:o.lpMint.toBase58(),programId:t,decimals:Math.min(o.baseDecimal.toNumber(),o.quoteDecimal.toNumber())}),burnPercent:0}}),e};import Ge from"bn.js";import Le from"decimal.js";import{PublicKey as Bi}from"@solana/web3.js";import xi from"bn.js";import{TOKEN_PROGRAM_ID as al}from"@solana/spl-token";import{SystemProgram as no,SYSVAR_RENT_PUBKEY as hp,Transaction as ol,TransactionInstruction as Ip}from"@solana/web3.js";import{createInitializeAccountInstruction as il,TOKEN_PROGRAM_ID as rl}from"@solana/spl-token";function Tp(c="accountFlags"){let e=new hr(c);return e.addBoolean("initialized"),e.addBoolean("market"),e.addBoolean("openOrders"),e.addBoolean("requestQueue"),e.addBoolean("eventQueue"),e.addBoolean("bids"),e.addBoolean("asks"),e}var Vs=V([Ie(5),Tp("accountFlags"),O("ownAddress"),k("vaultSignerNonce"),O("baseMint"),O("quoteMint"),O("baseVault"),k("baseDepositsTotal"),k("baseFeesAccrued"),O("quoteVault"),k("quoteDepositsTotal"),k("quoteFeesAccrued"),k("quoteDustThreshold"),O("requestQueue"),O("eventQueue"),O("bids"),O("asks"),k("baseLotSize"),k("quoteLotSize"),k("feeRateBps"),k("referrerRebatesAccrued"),Ie(7)]);function Bp({programId:c,marketInfo:e}){let t=V([_("version"),ct("instruction"),k("baseLotSize"),k("quoteLotSize"),Rt("feeRateBps"),k("vaultSignerNonce"),k("quoteDustThreshold")]),n=[{pubkey:e.id,isSigner:!1,isWritable:!0},{pubkey:e.requestQueue,isSigner:!1,isWritable:!0},{pubkey:e.eventQueue,isSigner:!1,isWritable:!0},{pubkey:e.bids,isSigner:!1,isWritable:!0},{pubkey:e.asks,isSigner:!1,isWritable:!0},{pubkey:e.baseVault,isSigner:!1,isWritable:!0},{pubkey:e.quoteVault,isSigner:!1,isWritable:!0},{pubkey:e.baseMint,isSigner:!1,isWritable:!1},{pubkey:e.quoteMint,isSigner:!1,isWritable:!1},{pubkey:e.authority?e.quoteMint:hp,isSigner:!1,isWritable:!1}].concat(e.authority?{pubkey:e.authority,isSigner:!1,isWritable:!1}:[]).concat(e.authority&&e.pruneAuthority?{pubkey:e.pruneAuthority,isSigner:!1,isWritable:!1}:[]),o=Buffer.alloc(t.span);return t.encode({version:0,instruction:0,baseLotSize:e.baseLotSize,quoteLotSize:e.quoteLotSize,feeRateBps:e.feeRateBps,vaultSignerNonce:e.vaultSignerNonce,quoteDustThreshold:e.quoteDustThreshold},o),new Ip({keys:n,programId:c,data:o})}async function Er({connection:c,wallet:e,marketInfo:t}){var i,a,u,s,l,d,p,m;let n=new ol,o=await c.getMinimumBalanceForRentExemption(165);n.add(no.createAccountWithSeed({fromPubkey:e,basePubkey:e,seed:t.baseVault.seed,newAccountPubkey:t.baseVault.publicKey,lamports:o,space:165,programId:rl}),no.createAccountWithSeed({fromPubkey:e,basePubkey:e,seed:t.quoteVault.seed,newAccountPubkey:t.quoteVault.publicKey,lamports:o,space:165,programId:rl}),il(t.baseVault.publicKey,t.baseMint,t.vaultOwner),il(t.quoteVault.publicKey,t.quoteMint,t.vaultOwner),no.createAccountWithSeed({fromPubkey:e,basePubkey:e,seed:t.id.seed,newAccountPubkey:t.id.publicKey,lamports:await c.getMinimumBalanceForRentExemption(Vs.span),space:Vs.span,programId:t.programId}));let r=new ol;return r.add(no.createAccountWithSeed({fromPubkey:e,basePubkey:e,seed:t.requestQueue.seed,newAccountPubkey:t.requestQueue.publicKey,lamports:t.lowestFeeMarket?6208320:await c.getMinimumBalanceForRentExemption((i=t.requestQueueSpace)!=null?i:5120+12),space:t.lowestFeeMarket?764:(a=t.requestQueueSpace)!=null?a:5120+12,programId:t.programId}),no.createAccountWithSeed({fromPubkey:e,basePubkey:e,seed:t.eventQueue.seed,newAccountPubkey:t.eventQueue.publicKey,lamports:t.lowestFeeMarket?79594560:await c.getMinimumBalanceForRentExemption((u=t.eventQueueSpace)!=null?u:262144+12),space:t.lowestFeeMarket?11308:(s=t.eventQueueSpace)!=null?s:262144+12,programId:t.programId}),no.createAccountWithSeed({fromPubkey:e,basePubkey:e,seed:t.bids.seed,newAccountPubkey:t.bids.publicKey,lamports:t.lowestFeeMarket?101977920:await c.getMinimumBalanceForRentExemption((l=t.orderbookQueueSpace)!=null?l:65536+12),space:t.lowestFeeMarket?14524:(d=t.orderbookQueueSpace)!=null?d:65536+12,programId:t.programId}),no.createAccountWithSeed({fromPubkey:e,basePubkey:e,seed:t.asks.seed,newAccountPubkey:t.asks.publicKey,lamports:t.lowestFeeMarket?101977920:await c.getMinimumBalanceForRentExemption((p=t.orderbookQueueSpace)!=null?p:65536+12),space:t.lowestFeeMarket?14524:(m=t.orderbookQueueSpace)!=null?m:65536+12,programId:t.programId}),Bp({programId:t.programId,marketInfo:{id:t.id.publicKey,requestQueue:t.requestQueue.publicKey,eventQueue:t.eventQueue.publicKey,bids:t.bids.publicKey,asks:t.asks.publicKey,baseVault:t.baseVault.publicKey,quoteVault:t.quoteVault.publicKey,baseMint:t.baseMint,quoteMint:t.quoteMint,baseLotSize:t.baseLotSize,quoteLotSize:t.quoteLotSize,feeRateBps:t.feeRateBps,vaultSignerNonce:t.vaultSignerNonce,quoteDustThreshold:t.quoteDustThreshold}})),[{transaction:n,signer:[],instructionTypes:[U.CreateAccount,U.CreateAccount,U.InitAccount,U.InitAccount]},{transaction:r,signer:[],instructionTypes:[U.CreateAccount,U.CreateAccount,U.CreateAccount,U.CreateAccount,U.CreateAccount,U.InitMarket]}]}var Lo=class extends Fe{async create({baseInfo:e,quoteInfo:t,lotSize:n,tickSize:o,dexProgramId:r,requestQueueSpace:i,eventQueueSpace:a,orderbookQueueSpace:u,lowestFeeMarket:s,assignSeed:l,txVersion:d,computeBudgetConfig:p,txTipConfig:m,feePayer:f}){let y=this.scope.ownerPubKey,b=l?`${e.mint.toBase58().slice(0,10)}-${t.mint.toBase58().slice(0,10)}-${l}`:void 0,g=ze({fromPublicKey:y,programId:r,assignSeed:b&&`${b}-market`}),P=ze({fromPublicKey:y,programId:r,assignSeed:b&&`${b}-request`}),h=ze({fromPublicKey:y,programId:r,assignSeed:b&&`${b}-event`}),I=ze({fromPublicKey:y,programId:r,assignSeed:b&&`${b}-bids`}),T=ze({fromPublicKey:y,programId:r,assignSeed:b&&`${b}-asks`}),w=ze({fromPublicKey:y,programId:al,assignSeed:b&&`${b}-baseVault`}),x=ze({fromPublicKey:y,programId:al,assignSeed:b&&`${b}-quoteVault`}),S=0,K=new xi(100);function B(){let z=new xi(0);for(;;)try{return{vaultOwner:Bi.createProgramAddressSync([g.publicKey.toBuffer(),z.toArrayLike(Buffer,"le",8)],r),vaultSignerNonce:z}}catch{if(z.iaddn(1),z.gt(new xi(25555)))throw Error("find vault owner error")}}let{vaultOwner:C,vaultSignerNonce:M}=B(),F=new xi(Math.round(10**e.decimals*n)),R=new xi(Math.round(n*10**t.decimals*o));if(F.eq(It))throw Error("lot size is too small");if(R.eq(It))throw Error("tick size or lot size is too small");let L=await Er({connection:this.scope.connection,wallet:this.scope.ownerPubKey,marketInfo:{programId:r,id:g,baseMint:e.mint,quoteMint:t.mint,baseVault:w,quoteVault:x,vaultOwner:C,requestQueue:P,eventQueue:h,bids:I,asks:T,feeRateBps:S,quoteDustThreshold:K,vaultSignerNonce:M,baseLotSize:F,quoteLotSize:R,requestQueueSpace:i,eventQueueSpace:a,orderbookQueueSpace:u,lowestFeeMarket:s}}),W=this.createTxBuilder(f);W.addInstruction({instructions:L[0].transaction.instructions,signers:L[0].signer});for await(let z of L.slice(1,L.length))W.addInstruction({instructions:z.transaction.instructions,signers:z.signer,instructionTypes:z.instructionTypes});return d===0?W.sizeCheckBuildV0({computeBudgetConfig:p,address:{marketId:g.publicKey,requestQueue:P.publicKey,eventQueue:h.publicKey,bids:I.publicKey,asks:T.publicKey,baseVault:w.publicKey,quoteVault:x.publicKey,baseMint:new Bi(e.mint),quoteMint:new Bi(t.mint)}}):W.sizeCheckBuild({computeBudgetConfig:p,address:{marketId:g.publicKey,requestQueue:P.publicKey,eventQueue:h.publicKey,bids:I.publicKey,asks:T.publicKey,baseVault:w.publicKey,quoteVault:x.publicKey,baseMint:new Bi(e.mint),quoteMint:new Bi(t.mint)}})}};var Si=class extends Fe{constructor(t){super(t);this.stableLayout=new Ro({connection:this.scope.connection,modelDataPubKey:this.scope.cluster==="mainnet"?void 0:gn.MODEL_DATA_PUBKEY})}async initLayout(){await this.stableLayout.initStableModelLayout()}async load(){this.checkDisabled()}computePairAmount({poolInfo:t,amount:n,slippage:o,baseIn:r}){let i=new Ge(new Le(n).mul(10**t[r?"mintA":"mintB"].decimals).toFixed(0)),a=Nr(t[r?"mintB":"mintA"]),[u,s]=[new Ge(new Le(t.mintAmountA).mul(10**t.mintA.decimals).toString()),new Ge(new Le(t.mintAmountB).mul(10**t.mintB.decimals).toString())],l=new Ge(new Le(t.lpAmount).mul(10**t.lpMint.decimals).toFixed(0,Le.ROUND_DOWN));this.logDebug("baseReserve:",u.toString(),"quoteReserve:",s.toString()),this.logDebug("tokenIn:",r?t.mintA.symbol:t.mintB.symbol,"amountIn:",i.toString(),"anotherToken:",r?t.mintB.symbol:t.mintA.symbol,"slippage:",`${o.toSignificant()}%`,"baseReserve",u.toString(),"quoteReserve",s.toString());let d=r?"base":"quote";this.logDebug("input side:",d);let p=It;i.isZero()||(p=d==="base"?or(i.mul(s),u):or(i.mul(u),s)),this.logDebug("amountRaw:",p.toString(),"lpAmount:",l.toString());let m=or(i.mul(l),d==="base"?u:s);this.logDebug("liquidity:",m.toString());let f=new it(new Ge(1)).add(o),y=new it(new Ge(1)).sub(o),b=f.mul(p).quotient,g=y.mul(p).quotient,P=new Se(a,p),h=new Se(a,b),I=new Se(a,g);return this.logDebug("anotherAmount:",P.toFixed(),"maxAnotherAmount:",h.toFixed()),{anotherAmount:P,maxAnotherAmount:h,minAnotherAmount:I,liquidity:m}}async getAmmPoolKeys(t){return(await this.scope.api.fetchPoolKeysById({idList:[t]}))[0]}async addLiquidity(t){let{poolInfo:n,poolKeys:o,amountInA:r,amountInB:i,otherAmountMin:a,fixedSide:u,config:s,txVersion:l,computeBudgetConfig:d,txTipConfig:p,feePayer:m}=t;this.scope.availability.addStandardPosition===!1&&this.logAndCreateError("add liquidity feature disabled in your region"),this.logDebug("amountInA:",r,"amountInB:",i),(r.isZero()||i.isZero())&&this.logAndCreateError("amounts must greater than zero","amountInA & amountInB",{amountInA:r.toFixed(),amountInB:i.toFixed()});let{account:f}=this.scope,{bypassAssociatedCheck:y,checkCreateATAOwner:b}=N({bypassAssociatedCheck:!1,checkCreateATAOwner:!1},s),[g,P]=[r.token,i.token],h=await f.getCreatedTokenAccount({mint:g.mint,associatedOnly:!1}),I=await f.getCreatedTokenAccount({mint:P.mint,associatedOnly:!1});!h&&!I&&this.logAndCreateError("cannot found target token accounts","tokenAccounts",f.tokenAccounts);let T=await f.getCreatedTokenAccount({mint:new He(n.lpMint.address)}),w=[g,P],x=[h,I],S=[r.raw,i.raw],K=r.token.mint.toBase58()===n.mintA.address?"base":"quote",B="base";["quote","base"].includes(K)||this.logAndCreateError("invalid fixedSide","fixedSide",u),K==="quote"?(w.reverse(),x.reverse(),S.reverse(),B=u==="a"?"quote":"base"):K==="base"&&(B=u==="a"?"base":"quote");let[C,M]=w,[F,R]=x,[L,W]=S,z=o!=null?o:await this.getAmmPoolKeys(n.id),$=this.createTxBuilder(m),ee=await f.handleTokenAccount({side:"in",amount:L,mint:C.mint,tokenAccount:F,bypassAssociatedCheck:y,checkCreateATAOwner:b}),{tokenAccount:ae}=ee,ye=qe(ee,["tokenAccount"]);$.addInstruction(ye);let xe=await f.handleTokenAccount({side:"in",amount:W,mint:M.mint,tokenAccount:R,bypassAssociatedCheck:y,checkCreateATAOwner:b}),{tokenAccount:ce}=xe,de=qe(xe,["tokenAccount"]);$.addInstruction(de);let we=await f.handleTokenAccount({side:"out",amount:0,mint:new He(n.lpMint.address),tokenAccount:T,bypassAssociatedCheck:y,checkCreateATAOwner:b}),{tokenAccount:pe}=we,le=qe(we,["tokenAccount"]);return $.addInstruction(le),$.addInstruction({instructions:[jc({poolInfo:n,poolKeys:z,userKeys:{baseTokenAccount:ae,quoteTokenAccount:ce,lpTokenAccount:pe,owner:this.scope.ownerPubKey},baseAmountIn:L,quoteAmountIn:W,otherAmountMin:a.raw,fixedSide:B})],instructionTypes:[n.pooltype.includes("StablePool")?U.AmmV5AddLiquidity:U.AmmV4AddLiquidity],lookupTableAddress:z.lookupTableAccount?[z.lookupTableAccount]:[]}),$.addCustomComputeBudget(d),$.addTipInstruction(p),l===0?await $.buildV0():$.build()}async removeLiquidity(t){this.scope.availability.removeStandardPosition===!1&&this.logAndCreateError("remove liquidity feature disabled in your region");let{poolInfo:n,poolKeys:o,lpAmount:r,baseAmountMin:i,quoteAmountMin:a,config:u,txVersion:s,computeBudgetConfig:l,txTipConfig:d,feePayer:p}=t,m=o!=null?o:await this.getAmmPoolKeys(n.id),[f,y,b]=[new He(n.mintA.address),new He(n.mintB.address),new He(n.lpMint.address)];this.logDebug("lpAmount:",r),this.logDebug("baseAmountMin:",i),this.logDebug("quoteAmountMin:",a),r.isZero()&&this.logAndCreateError("amount must greater than zero","lpAmount",r.toString());let{account:g}=this.scope,P=await g.getCreatedTokenAccount({mint:b,associatedOnly:!1});P||this.logAndCreateError("cannot found lpTokenAccount","tokenAccounts",g.tokenAccounts);let h=await g.getCreatedTokenAccount({mint:f}),I=await g.getCreatedTokenAccount({mint:y}),T=this.createTxBuilder(p),{bypassAssociatedCheck:w,checkCreateATAOwner:x}=N({bypassAssociatedCheck:!1,checkCreateATAOwner:!1},u),M=await g.handleTokenAccount({side:"out",amount:0,mint:f,tokenAccount:h,bypassAssociatedCheck:w,checkCreateATAOwner:x}),{tokenAccount:S}=M,K=qe(M,["tokenAccount"]);T.addInstruction(K);let F=await g.handleTokenAccount({side:"out",amount:0,mint:y,tokenAccount:I,bypassAssociatedCheck:w,checkCreateATAOwner:x}),{tokenAccount:B}=F,C=qe(F,["tokenAccount"]);return T.addInstruction(C),T.addInstruction({instructions:[Rs({poolInfo:n,poolKeys:m,userKeys:{lpTokenAccount:P,baseTokenAccount:S,quoteTokenAccount:B,owner:this.scope.ownerPubKey},lpAmount:r,baseAmountMin:i,quoteAmountMin:a})],lookupTableAddress:m.lookupTableAccount?[m.lookupTableAccount]:[],instructionTypes:[n.pooltype.includes("StablePool")?U.AmmV5RemoveLiquidity:U.AmmV4RemoveLiquidity]}),T.addCustomComputeBudget(l),T.addTipInstruction(d),s===0?await T.buildV0():T.build()}async removeAllLpAndCreateClmmPosition({poolInfo:t,clmmPoolInfo:n,removeLpAmount:o,createPositionInfo:r,farmInfo:i,userFarmLpAmount:a,base:u,computeBudgetConfig:s,payer:l,userAuxiliaryLedgers:d,tokenProgram:p=vn,checkCreateATAOwner:m=!0,getEphemeralSigners:f,txVersion:y,feePayer:b}){if((this.scope.availability.removeStandardPosition===!1||this.scope.availability.createConcentratedPosition===!1)&&this.logAndCreateError("remove liquidity or create position feature disabled in your region"),!(t.mintA.address===n.mintA.address||t.mintA.address===n.mintB.address)||!(t.mintB.address===n.mintA.address||t.mintB.address===n.mintB.address))throw Error("mint check error");let g=this.createTxBuilder(b),P={};for(let z of this.scope.account.tokenAccountRawInfos)(P[z.accountInfo.mint.toString()]===void 0||j(this.scope.ownerPubKey,z.accountInfo.mint,vn).publicKey.equals(z.pubkey))&&(P[z.accountInfo.mint.toString()]=z.pubkey);let h=P[t.lpMint.address];if(h===void 0)throw Error("find lp account error in trade accounts");let I=o.add(a!=null?a:new Ge(0)),T=t.mintA.address===De.WSOL.mint.toString(),w=t.mintB.address===De.WSOL.mint.toString(),{account:x,instructionParams:S}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:vn,mint:new He(t.mintA.address),owner:this.scope.ownerPubKey,createInfo:T?{payer:this.scope.ownerPubKey}:void 0,skipCloseAccount:!T,notUseTokenAccount:T,associatedOnly:!0,checkCreateATAOwner:m});if(g.addInstruction(S||{}),x===void 0)throw new Error("base token account not found");let{account:K,instructionParams:B}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:vn,mint:new He(t.mintB.address),owner:this.scope.ownerPubKey,createInfo:w?{payer:this.scope.ownerPubKey,amount:0}:void 0,skipCloseAccount:!w,notUseTokenAccount:w,associatedOnly:!0,checkCreateATAOwner:m});if(g.addInstruction(B||{}),K===void 0)throw new Error("quote token account not found");if(P[t.mintA.address]=x,P[t.mintB.address]=K,i!==void 0&&!(a!=null&&a.isZero())){let z=_t[i.programId],$=dt({programId:new He(i.programId),poolId:new He(i.id),owner:this.scope.ownerPubKey,version:z}),ae,ye=await this.scope.connection.getAccountInfo($);if(ye&&(ae=Io(z).decode(ye.data)),z!==6&&!ae){let{instruction:we,instructionType:bt}=ci({id:new He(i.id),programId:new He(i.programId),version:z,ledger:$,owner:this.scope.ownerPubKey});g.addInstruction({instructions:[we],instructionTypes:[bt]})}let ce=[];for(let we of i.rewardInfos){let bt=we.mint.address===De.WSOL.mint.toString();if(P[we.mint.address])ce.push(P[we.mint.address]);else{let{account:ut,instructionParams:fn}=await this.scope.account.getOrCreateTokenAccount({mint:new He(we.mint.address),tokenProgram:p,owner:this.scope.ownerPubKey,skipCloseAccount:!bt,createInfo:{payer:l||this.scope.ownerPubKey},associatedOnly:!0,checkCreateATAOwner:m});ut||this.logAndCreateError("farm reward account not found:",we.mint.address),fn&&g.addInstruction(fn),ce.push(ut)}}let de=(await this.scope.api.fetchFarmKeysById({ids:i.id}))[0],pe={userAuxiliaryLedgers:d,amount:a,owner:this.scope.ownerPubKey,farmInfo:i,farmKeys:de,lpAccount:h,rewardAccounts:ce},le=_t[i.programId],ee=le===6?li(pe):le===5?mi(pe):di(pe),xe={3:U.FarmV3Withdraw,5:U.FarmV5Withdraw,6:U.FarmV6Withdraw};g.addInstruction({instructions:[ee],instructionTypes:[xe[le]]})}let C=await this.getAmmPoolKeys(t.id),M=Rs({poolInfo:t,poolKeys:C,userKeys:{lpTokenAccount:h,baseTokenAccount:x,quoteTokenAccount:K,owner:this.scope.ownerPubKey},lpAmount:I,baseAmountMin:0,quoteAmountMin:0});g.addInstruction({instructions:[M],instructionTypes:[t.pooltype.includes("StablePool")?U.AmmV5RemoveLiquidity:U.AmmV4RemoveLiquidity],lookupTableAddress:C.lookupTableAccount?[C.lookupTableAccount]:[]});let[F,R]=t.mintA.address===n.mintA.address?[x,K]:[K,x],L=await this.scope.clmm.getClmmPoolKeys(n.id),W=await Ce.openPositionFromBaseInstructions(q(N({poolInfo:n,poolKeys:L,ownerInfo:{feePayer:this.scope.ownerPubKey,wallet:this.scope.ownerPubKey,tokenAccountA:F,tokenAccountB:R},withMetadata:"create"},r),{base:u,getEphemeralSigners:f}));return g.addInstruction({instructions:[...W.instructions],signers:W.signers,instructionTypes:[...W.instructionTypes],lookupTableAddress:L.lookupTableAccount?[L.lookupTableAccount]:[]}),y===0?g.sizeCheckBuildV0({computeBudgetConfig:s}):g.sizeCheckBuild({computeBudgetConfig:s})}async createPoolV4({programId:t,marketInfo:n,baseMintInfo:o,quoteMintInfo:r,baseAmount:i,quoteAmount:a,startTime:u,ownerInfo:s,associatedOnly:l=!1,checkCreateATAOwner:d=!1,tokenProgram:p,txVersion:m,feeDestinationId:f,computeBudgetConfig:y,txTipConfig:b,feePayer:g}){var R;let P=s.feePayer||((R=this.scope.owner)==null?void 0:R.publicKey),h=s.useSOLBalance&&o.mint.equals(Dr),I=s.useSOLBalance&&r.mint.equals(Dr),T=this.createTxBuilder(g),{account:w,instructionParams:x}=await this.scope.account.getOrCreateTokenAccount({mint:o.mint,owner:this.scope.ownerPubKey,createInfo:h?{payer:P,amount:i}:void 0,notUseTokenAccount:h,skipCloseAccount:!h,associatedOnly:h?!1:l,checkCreateATAOwner:d});T.addInstruction(x||{});let{account:S,instructionParams:K}=await this.scope.account.getOrCreateTokenAccount({mint:r.mint,owner:this.scope.ownerPubKey,createInfo:I?{payer:P,amount:a}:void 0,notUseTokenAccount:I,skipCloseAccount:!I,associatedOnly:I?!1:l,checkCreateATAOwner:d});if(T.addInstruction(K||{}),w===void 0||S===void 0)throw Error("you don't has some token account");let B=Fs({version:4,marketVersion:3,marketId:n.marketId,baseMint:o.mint,quoteMint:r.mint,baseDecimals:o.decimals,quoteDecimals:r.decimals,programId:t,marketProgramId:n.programId}),C={programId:t,ammId:B.id,ammAuthority:B.authority,ammOpenOrders:B.openOrders,lpMint:B.lpMint,coinMint:B.baseMint,pcMint:B.quoteMint,coinVault:B.baseVault,pcVault:B.quoteVault,withdrawQueue:B.withdrawQueue,ammTargetOrders:B.targetOrders,poolTempLp:B.lpVault,marketProgramId:B.marketProgramId,marketId:B.marketId,ammConfigId:B.configId,feeDestinationId:f},{instruction:M,instructionType:F}=Ls(q(N({},C),{userWallet:this.scope.ownerPubKey,userCoinVault:w,userPcVault:S,userLpVault:j(this.scope.ownerPubKey,B.lpMint,p).publicKey,nonce:B.nonce,openTime:u,coinAmount:i,pcAmount:a}));return T.addInstruction({instructions:[M],instructionTypes:[F]}),T.addCustomComputeBudget(y),T.addTipInstruction(b),T.versionBuild({txVersion:m,extInfo:{address:C}})}async createMarketAndPoolV4({programId:t=Yo,marketProgram:n=Sa,feeDestinationId:o=Ka,tokenProgram:r,baseMintInfo:i,quoteMintInfo:a,baseAmount:u,quoteAmount:s,startTime:l,ownerInfo:d,lowestFeeMarket:p,assignSeed:m,associatedOnly:f=!1,checkCreateATAOwner:y=!1,lotSize:b=1,tickSize:g=.01,txVersion:P,computeBudgetConfig:h,txTipConfig:I,feePayer:T}){var Do,Wo,qo;let w=this.scope.ownerPubKey,x=d.feePayer||((Do=this.scope.owner)==null?void 0:Do.publicKey),S=d.useSOLBalance&&i.mint.equals(Dr),K=d.useSOLBalance&&a.mint.equals(Dr),B=m?`${i.mint.toBase58().slice(0,7)}-${a.mint.toBase58().slice(0,7)}-${m}`:void 0,C=ze({fromPublicKey:w,programId:n,assignSeed:B&&`${B}-market`}),M=ze({fromPublicKey:w,programId:n,assignSeed:B&&`${B}-request`}),F=ze({fromPublicKey:w,programId:n,assignSeed:B&&`${B}-event`}),R=ze({fromPublicKey:w,programId:n,assignSeed:B&&`${B}-bids`}),L=ze({fromPublicKey:w,programId:n,assignSeed:B&&`${B}-asks`}),W=ze({fromPublicKey:w,programId:vn,assignSeed:B&&`${B}-baseVault`}),z=ze({fromPublicKey:w,programId:vn,assignSeed:B&&`${B}-quoteVault`}),$=0,ae=new Ge(100);function ye(){let Ct=new Ge(0);for(;;)try{return{vaultOwner:He.createProgramAddressSync([C.publicKey.toBuffer(),Ct.toArrayLike(Buffer,"le",8)],n),vaultSignerNonce:Ct}}catch{if(Ct.iaddn(1),Ct.gt(new Ge(25555)))throw Error("find vault owner error")}}let{vaultOwner:ce,vaultSignerNonce:de}=ye(),pe=new Ge(Math.round(10**i.decimals*b)),le=new Ge(Math.round(b*10**a.decimals*g));if(pe.eq(It))throw Error("lot size is too small");if(le.eq(It))throw Error("tick size or lot size is too small");let ee=await Er({connection:this.scope.connection,wallet:this.scope.ownerPubKey,marketInfo:{programId:n,vaultOwner:ce,baseMint:i.mint,quoteMint:a.mint,id:C,baseVault:W,quoteVault:z,requestQueue:M,eventQueue:F,bids:R,asks:L,feeRateBps:$,quoteDustThreshold:ae,vaultSignerNonce:de,baseLotSize:pe,quoteLotSize:le,lowestFeeMarket:p}}),xe=this.createTxBuilder(T);xe.addInstruction({instructions:ee[0].transaction.instructions,signers:ee[0].signer});for await(let Ct of ee.slice(1,ee.length))xe.addInstruction({instructions:Ct.transaction.instructions,signers:Ct.signer,instructionTypes:Ct.instructionTypes});let{account:we,instructionParams:bt}=await this.scope.account.getOrCreateTokenAccount({mint:i.mint,owner:this.scope.ownerPubKey,createInfo:S?{payer:x,amount:u}:void 0,notUseTokenAccount:S,skipCloseAccount:!S,associatedOnly:S?!1:f,checkCreateATAOwner:y,assignSeed:S&&B?`${B}-wsol`:void 0});xe.addInstruction(bt||{});let{account:ut,instructionParams:fn}=await this.scope.account.getOrCreateTokenAccount({mint:a.mint,owner:this.scope.ownerPubKey,createInfo:K?{payer:x,amount:s}:void 0,notUseTokenAccount:K,skipCloseAccount:!K,associatedOnly:K?!1:f,checkCreateATAOwner:y,assignSeed:K&&B?`${B}-wsol`:void 0});if(xe.addInstruction(fn||{}),we===void 0)throw Error("you don't has base token account");if(ut===void 0)throw Error("you don't has quote token account");let tt=Fs({version:4,marketVersion:3,marketId:C.publicKey,baseMint:i.mint,quoteMint:a.mint,baseDecimals:i.decimals,quoteDecimals:a.decimals,programId:t,marketProgramId:n}),qn={programId:t,ammId:tt.id,ammAuthority:tt.authority,ammOpenOrders:tt.openOrders,lpMint:tt.lpMint,coinMint:tt.baseMint,pcMint:tt.quoteMint,coinVault:tt.baseVault,pcVault:tt.quoteVault,withdrawQueue:tt.withdrawQueue,ammTargetOrders:tt.targetOrders,poolTempLp:tt.lpVault,marketProgramId:tt.marketProgramId,marketId:tt.marketId,ammConfigId:tt.configId,feeDestinationId:o},{instruction:Tt,instructionType:Eo}=Ls(q(N({},qn),{userWallet:this.scope.ownerPubKey,userCoinVault:we,userPcVault:ut,userLpVault:j(this.scope.ownerPubKey,tt.lpMint,r).publicKey,nonce:tt.nonce,openTime:l,coinAmount:u,pcAmount:s}));xe.addInstruction({instructions:[Tt],instructionTypes:[Eo]});let mo=S||K?[((Wo=bt==null?void 0:bt.instructions)==null?void 0:Wo[0])||((qo=fn==null?void 0:fn.instructions)==null?void 0:qo[0])].filter(Ct=>!!Ct):void 0;return P===0?xe.sizeCheckBuildV0({computeBudgetConfig:h,splitIns:mo,address:N({requestQueue:M.publicKey,eventQueue:F.publicKey,bids:R.publicKey,asks:L.publicKey,baseVault:W.publicKey,quoteVault:z.publicKey,baseMint:new He(i.mint),quoteMint:new He(a.mint)},qn)}):xe.sizeCheckBuild({computeBudgetConfig:h,splitIns:mo,address:N({requestQueue:M.publicKey,eventQueue:F.publicKey,bids:R.publicKey,asks:L.publicKey,baseVault:W.publicKey,quoteVault:z.publicKey,baseMint:new He(i.mint),quoteMint:new He(a.mint)},qn)})}async getCreatePoolFee({programId:t}){let n=Vr({programId:t}),o=await this.scope.connection.getAccountInfo(n,{dataSlice:{offset:536,length:8}});if(o===null)throw Error("get config account error");return zc.decode(o.data).fee}computeAmountOut({poolInfo:t,amountIn:n,mintIn:o,mintOut:r,slippage:i}){let[a,u]=[o.toString(),r.toString()];if(a!==t.mintA.address&&a!==t.mintB.address)throw new Error("toke not match");if(u!==t.mintA.address&&u!==t.mintB.address)throw new Error("toke not match");let{baseReserve:s,quoteReserve:l}=t,d=[s,l],p=[t.mintA.decimals,t.mintB.decimals],m=a==t.mintA.address?"base":"quote";m==="quote"&&(d.reverse(),p.reverse());let[f,y]=d,[b,g]=p,P=t.version===4,h;if(P)h=new Le(y.toString()).div(10**g).div(new Le(f.toString()).div(10**b));else{let F=tl(this.stableLayout.stableModelData,s.toNumber(),l.toNumber(),!1);m==="quote"?h=new Le(1e6).div(F*1e6):h=new Le(F*1e6).div(1e6)}let I=n,T=new Ge(0),w=new Ge(0);if(!I.isZero())if(P){w=Zt(I.mul(Is),Mr);let F=I.sub(w),R=f.add(F);T=y.mul(F).div(R)}else{w=I.mul(new Ge(2)).div(new Ge(1e4));let F=I.sub(w);m==="quote"?T=new Ge(Jc(this.stableLayout.stableModelData,l.toNumber(),s.toNumber(),F.toNumber())):T=new Ge(el(this.stableLayout.stableModelData,l.toNumber(),s.toNumber(),F.toNumber()))}let x=new Ge(new Le(T.toString()).mul(1-i).toFixed(0)),S=T,K=x,B=new Le(T.toString()).div(new Le(I.sub(w).toString()).toFixed(0));!I.isZero()&&!T.isZero()&&(B=new Le(T.toString()).div(10**g).div(new Le(I.sub(w).toString()).div(10**b)));let C=h.sub(B).div(h).mul(100);return{amountOut:S,minAmountOut:K,currentPrice:h,executionPrice:B,priceImpact:C,fee:w}}computeAmountIn({poolInfo:t,amountOut:n,mintIn:o,mintOut:r,slippage:i}){let{baseReserve:a,quoteReserve:u}=t;o.toString()!==t.mintA.address&&o.toString()!==t.mintB.address&&this.logAndCreateError("mintIn does not match pool"),r.toString()!==t.mintA.address&&r.toString()!==t.mintB.address&&this.logAndCreateError("mintOut does not match pool"),this.logDebug("baseReserve:",a.toString()),this.logDebug("quoteReserve:",u.toString());let s=o.toString()===t.mintA.address,[l,d]=s?[t.mintA,t.mintB]:[t.mintB,t.mintA];this.logDebug("currencyOut:",d.symbol||d.address),this.logDebug("amountOut:",new Le(n.toString()).div(10**d.decimals).toDecimalPlaces(d.decimals).toString(),l.symbol||l.address),this.logDebug("slippage:",`${i*100}%`);let p=[a,u],m=s?"quote":"base";m==="base"&&p.reverse(),this.logDebug("output side:",m);let[f,y]=p,b=new Le(y.toString()).div(10**t[s?"mintB":"mintA"].decimals).div(new Le(f.toString()).div(10**t[s?"mintA":"mintB"].decimals));this.logDebug("currentPrice:",`1 ${l.symbol||l.address} \u2248 ${b.toString()} ${d.symbol||d.address}`),this.logDebug("currentPrice invert:",`1 ${d.symbol||d.address} \u2248 ${new Le(1).div(b).toString()} ${l.symbol||l.address}`);let g=new Ge(0),P=n;if(!P.isZero()){P.gt(y)&&(P=y.sub(new Ge(1)));let K=y.sub(P);g=f.mul(P).div(K).mul(Mr).div(Mr.sub(Is))}let h=new Ge(new Le(g.toString()).mul(1+i).toFixed(0)),I=g,T=h;this.logDebug("amountIn:",new Le(I.toString()).div(10**l.decimals).toDecimalPlaces(l.decimals).toString()),this.logDebug("maxAmountIn:",new Le(T.toString()).div(10**l.decimals).toDecimalPlaces(l.decimals).toString());let w=null;!g.isZero()&&!P.isZero()&&(w=new Le(P.toString()).div(10**d.decimals).div(new Le(g.toString()).div(10**l.decimals)),this.logDebug("executionPrice:",`1 ${d.symbol||d.address} \u2248 ${w.toDecimalPlaces(Math.max(t.mintA.decimals,t.mintB.decimals)).toString()} ${l.symbol||l.address}`),this.logDebug("executionPrice invert:",`1 ${d.symbol||d.address} \u2248 ${new Le(1).div(w).toDecimalPlaces(Math.max(t.mintA.decimals,t.mintB.decimals)).toString()} ${l.symbol||l.address}`));let x=b.mul(I.toString()),S=x.sub(n.toString()).abs().div(x);return this.logDebug("priceImpact:",`${S.toString()}%`),{amountIn:I,maxAmountIn:T,currentPrice:b,executionPrice:w,priceImpact:S}}async swap({poolInfo:t,poolKeys:n,amountIn:o,amountOut:r,inputMint:i,fixedSide:a,txVersion:u,config:s,computeBudgetConfig:l,txTipConfig:d,feePayer:p}){let m=this.createTxBuilder(p),{associatedOnly:f=!0,inputUseSolBalance:y=!0,outputUseSolBalance:b=!0}=s||{},[g,P]=i===t.mintA.address?[t.mintA,t.mintB]:[t.mintB,t.mintA],h=y&&g.address===H.toBase58(),I=b&&P.address===H.toBase58(),{account:T,instructionParams:w}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:vn,mint:new He(g.address),owner:this.scope.ownerPubKey,createInfo:h?{payer:this.scope.ownerPubKey,amount:o}:void 0,skipCloseAccount:!h,notUseTokenAccount:h,associatedOnly:f});m.addInstruction(w||{}),T||this.logAndCreateError("input token account not found",{token:g.symbol||g.address,tokenAccountIn:T,inputTokenUseSolBalance:h,associatedOnly:f});let{account:x,instructionParams:S}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:vn,mint:new He(P.address),owner:this.scope.ownerPubKey,createInfo:{payer:this.scope.ownerPubKey,amount:0},skipCloseAccount:!I,notUseTokenAccount:I,associatedOnly:I?!1:f});m.addInstruction(S||{}),x===void 0&&this.logAndCreateError("output token account not found",{token:P.symbol||P.address,tokenAccountOut:x,outputTokenUseSolBalance:I,associatedOnly:f});let K=n||await this.getAmmPoolKeys(t.id),B=4;return t.pooltype.includes("StablePool")&&(B=5),m.addInstruction({instructions:[vr({version:B,poolKeys:K,userKeys:{tokenAccountIn:T,tokenAccountOut:x,owner:this.scope.ownerPubKey},amountIn:o,amountOut:r,fixedSide:a})],instructionTypes:[B===4?U.AmmV4SwapBaseIn:U.AmmV5SwapBaseIn]}),m.addCustomComputeBudget(l),m.addTipInstruction(d),m.versionBuild({txVersion:u})}async getRpcPoolInfo(t){return(await this.getRpcPoolInfos([t]))[t]}async getRpcPoolInfos(t,n){let o=await Oe(this.scope.connection,t.map(l=>({pubkey:new He(l)})),n),r={},i=[];for(let l=0;l<t.length;l++){let d=o[l];if(d===null||!d.accountInfo)throw Error("fetch pool info error: "+String(t[l]));let p=$n.decode(d.accountInfo.data);r[String(t[l])]=q(N({},p),{programId:d.accountInfo.owner}),i.push(p.baseVault,p.quoteVault)}let a={},u=await Oe(this.scope.connection,i.map(l=>({pubkey:new He(l)})),n);for(let l=0;l<i.length;l++){let d=u[l].accountInfo;if(d===null)throw Error("fetch vault info error: "+i[l]);a[String(i[l])]=new Ge(xp.decode(d.data).amount.toString())}let s={};for(let[l,d]of Object.entries(r)){let p=a[d.baseVault.toString()].sub(d.baseNeedTakePnl),m=a[d.quoteVault.toString()].sub(d.quoteNeedTakePnl);s[l]=q(N({},d),{baseReserve:p,mintAAmount:a[d.baseVault.toString()],mintBAmount:a[d.quoteVault.toString()],quoteReserve:m,poolPrice:new Le(m.toString()).div(new Le(10).pow(d.quoteDecimal.toString())).div(new Le(p.toString()).div(new Le(10).pow(d.baseDecimal.toString())))})}return s}async getPoolInfoFromRpc({poolId:t}){let n=await this.getRpcPoolInfo(t),o=_r({[t]:n}),r=o[t],i=await this.scope.tradeV2.computePoolToPoolKeys({pools:[o[t]],ammRpcData:{[t]:n}});return{poolRpcData:n,poolInfo:r,poolKeys:i[0]}}};import{PublicKey as Q}from"@solana/web3.js";import wt from"bn.js";import oo from"decimal.js";import{AccountLayout as sl,createAssociatedTokenAccountIdempotentInstruction as ul,TOKEN_2022_PROGRAM_ID as Fn,TOKEN_PROGRAM_ID as Ki}from"@solana/spl-token";var Ci=class extends Fe{constructor(e){super(e)}async getClmmPoolKeys(e){return(await this.scope.api.fetchPoolKeysById({idList:[e]}))[0]}async createPool(e){var x;let{programId:t,owner:n=((x=this.scope.owner)==null?void 0:x.publicKey)||Q.default,mint1:o,mint2:r,ammConfig:i,initialPrice:a,computeBudgetConfig:u,forerunCreate:s,getObserveState:l,txVersion:d,txTipConfig:p,feePayer:m}=e,f=this.createTxBuilder(m),[y,b,g]=new wt(new Q(o.address).toBuffer()).gt(new wt(new Q(r.address).toBuffer()))?[r,o,new oo(1).div(a)]:[o,r,a],P=ie.priceToSqrtPriceX64(g,y.decimals,b.decimals),h=[],I=[];y.programId===Fn.toBase58()&&I.push(As(t,new Q(y.address)).publicKey),b.programId===Fn.toBase58()&&I.push(As(t,new Q(b.address)).publicKey),(await this.scope.connection.getMultipleAccountsInfo(I)).forEach((S,K)=>{S&&h.push(I[K])});let w=await Ce.createPoolInstructions({connection:this.scope.connection,programId:t,owner:n,mintA:y,mintB:b,ammConfigId:i.id,initialPriceX64:P,forerunCreate:!l&&s,extendMintAccount:h});return f.addInstruction(w),f.addCustomComputeBudget(u),f.addTipInstruction(p),f.versionBuild({txVersion:d,extInfo:{address:q(N({},w.address),{observationId:w.address.observationId.toBase58(),exBitmapAccount:w.address.exBitmapAccount.toBase58(),programId:t.toString(),id:w.address.poolId.toString(),mintA:y,mintB:b,openTime:"0",vault:{A:w.address.mintAVault.toString(),B:w.address.mintBVault.toString()},rewardInfos:[],config:{id:i.id.toString(),index:i.index,protocolFeeRate:i.protocolFeeRate,tradeFeeRate:i.tradeFeeRate,tickSpacing:i.tickSpacing,fundFeeRate:i.fundFeeRate,description:i.description,defaultRange:0,defaultRangePoint:[]}}),mockPoolInfo:N({type:"Concentrated",rewardDefaultPoolInfos:"Clmm",id:w.address.poolId.toString(),mintA:y,mintB:b,feeRate:i.tradeFeeRate,openTime:"0",programId:t.toString(),price:g.toNumber(),config:{id:i.id.toString(),index:i.index,protocolFeeRate:i.protocolFeeRate,tradeFeeRate:i.tradeFeeRate,tickSpacing:i.tickSpacing,fundFeeRate:i.fundFeeRate,description:i.description,defaultRange:0,defaultRangePoint:[]},burnPercent:0},Bc),forerunCreate:s}})}async openPositionFromBase({poolInfo:e,poolKeys:t,ownerInfo:n,tickLower:o,tickUpper:r,base:i,baseAmount:a,otherAmountMax:u,nft2022:s,associatedOnly:l=!0,checkCreateATAOwner:d=!1,withMetadata:p="create",getEphemeralSigners:m,computeBudgetConfig:f,txTipConfig:y,txVersion:b,feePayer:g}){this.scope.availability.addConcentratedPosition===!1&&this.logAndCreateError("add position feature disabled in your region"),this.scope.checkOwner();let P=this.createTxBuilder(g),h=null,I=null,T=n.useSOLBalance&&e.mintA.address===H.toString(),w=n.useSOLBalance&&e.mintB.address===H.toString(),[x,S]=i==="MintA"?[a,u]:[u,a],{account:K,instructionParams:B}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:e.mintA.programId,mint:new Q(e.mintA.address),owner:this.scope.ownerPubKey,createInfo:T||x.isZero()?{payer:this.scope.ownerPubKey,amount:x}:void 0,skipCloseAccount:!T,notUseTokenAccount:T,associatedOnly:T?!1:l,checkCreateATAOwner:d});K&&(h=K),P.addInstruction(B||{});let{account:C,instructionParams:M}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:e.mintB.programId,mint:new Q(e.mintB.address),owner:this.scope.ownerPubKey,createInfo:w||S.isZero()?{payer:this.scope.ownerPubKey,amount:S}:void 0,skipCloseAccount:!w,notUseTokenAccount:w,associatedOnly:w?!1:l,checkCreateATAOwner:d});C&&(I=C),P.addInstruction(M||{}),(!h||!I)&&this.logAndCreateError("cannot found target token accounts","tokenAccounts",{ownerTokenAccountA:h==null?void 0:h.toBase58(),ownerTokenAccountB:I==null?void 0:I.toBase58()});let F=t||await this.getClmmPoolKeys(e.id),R=await Ce.openPositionFromBaseInstructions({poolInfo:e,poolKeys:F,ownerInfo:q(N({},n),{feePayer:this.scope.ownerPubKey,wallet:this.scope.ownerPubKey,tokenAccountA:h,tokenAccountB:I}),tickLower:o,tickUpper:r,base:i,baseAmount:a,otherAmountMax:u,withMetadata:p,getEphemeralSigners:m,nft2022:s});return P.addInstruction(R),P.addCustomComputeBudget(f),P.addTipInstruction(y),P.versionBuild({txVersion:b,extInfo:N({},R.address)})}async openPositionFromLiquidity({poolInfo:e,poolKeys:t,ownerInfo:n,amountMaxA:o,amountMaxB:r,tickLower:i,tickUpper:a,liquidity:u,associatedOnly:s=!0,checkCreateATAOwner:l=!1,withMetadata:d="create",txVersion:p,computeBudgetConfig:m,txTipConfig:f,getEphemeralSigners:y,nft2022:b,feePayer:g}){this.scope.availability.createConcentratedPosition===!1&&this.logAndCreateError("open position feature disabled in your region");let P=this.createTxBuilder(g),h=null,I=null,T=n.useSOLBalance&&e.mintA.address===H.toBase58(),w=n.useSOLBalance&&e.mintB.address===H.toBase58(),{account:x,instructionParams:S}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:e.mintA.programId,mint:new Q(e.mintA.address),owner:this.scope.ownerPubKey,createInfo:T||o.isZero()?{payer:this.scope.ownerPubKey,amount:o}:void 0,skipCloseAccount:!T,notUseTokenAccount:T,associatedOnly:T?!1:s,checkCreateATAOwner:l});x&&(h=x),P.addInstruction(S||{});let{account:K,instructionParams:B}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:e.mintB.programId,mint:new Q(e.mintB.address),owner:this.scope.ownerPubKey,createInfo:w||r.isZero()?{payer:this.scope.ownerPubKey,amount:r}:void 0,skipCloseAccount:!w,notUseTokenAccount:w,associatedOnly:w?!1:s,checkCreateATAOwner:l});K&&(I=K),P.addInstruction(B||{}),(h===void 0||I===void 0)&&this.logAndCreateError("cannot found target token accounts","tokenAccounts",this.scope.account.tokenAccounts);let C=t||await this.getClmmPoolKeys(e.id),M=await Ce.openPositionFromLiquidityInstructions({poolInfo:e,poolKeys:C,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccountA:h,tokenAccountB:I},tickLower:i,tickUpper:a,liquidity:u,amountMaxA:o,amountMaxB:r,withMetadata:d,getEphemeralSigners:y,nft2022:b});return P.addInstruction(M),P.addCustomComputeBudget(m),P.addTipInstruction(f),P.versionBuild({txVersion:p,extInfo:{address:M.address}})}async increasePositionFromLiquidity(e){var B;let{poolInfo:t,poolKeys:n,ownerPosition:o,amountMaxA:r,amountMaxB:i,liquidity:a,ownerInfo:u,associatedOnly:s=!0,checkCreateATAOwner:l=!1,computeBudgetConfig:d,txTipConfig:p,txVersion:m,feePayer:f}=e,y=this.createTxBuilder(f),b,g,P=u.useSOLBalance&&t.mintA.address===H.toString(),h=u.useSOLBalance&&t.mintB.address===H.toString(),{account:I,instructionParams:T}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:t.mintA.programId,mint:new Q(t.mintA.address),notUseTokenAccount:P,owner:this.scope.ownerPubKey,createInfo:P||r.isZero()?{payer:this.scope.ownerPubKey,amount:r}:void 0,skipCloseAccount:!P,associatedOnly:P?!1:s,checkCreateATAOwner:l});I&&(b=I),y.addInstruction(T||{});let{account:w,instructionParams:x}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:t.mintB.programId,mint:new Q(t.mintB.address),owner:this.scope.ownerPubKey,createInfo:h||i.isZero()?{payer:this.scope.ownerPubKey,amount:i}:void 0,notUseTokenAccount:h,skipCloseAccount:!h,associatedOnly:h?!1:s,checkCreateATAOwner:l});w&&(g=w),y.addInstruction(x||{}),!b&&!g&&this.logAndCreateError("cannot found target token accounts","tokenAccounts",this.scope.account.tokenAccounts);let S=n!=null?n:await this.getClmmPoolKeys(t.id),K=Ce.increasePositionFromLiquidityInstructions({poolInfo:t,poolKeys:S,ownerPosition:o,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccountA:b,tokenAccountB:g},liquidity:a,amountMaxA:r,amountMaxB:i,nft2022:(B=await this.scope.connection.getAccountInfo(o.nftMint))==null?void 0:B.owner.equals(Fn)});return y.addInstruction(K),y.addCustomComputeBudget(d),y.addTipInstruction(p),y.versionBuild({txVersion:m,extInfo:{address:K.address}})}async increasePositionFromBase(e){var K;let{poolInfo:t,ownerPosition:n,base:o,baseAmount:r,otherAmountMax:i,ownerInfo:a,associatedOnly:u=!0,checkCreateATAOwner:s=!1,computeBudgetConfig:l,txTipConfig:d,txVersion:p,feePayer:m}=e,f=this.createTxBuilder(m),y,b,g=a.useSOLBalance&&t.mintA.address===H.toString(),P=a.useSOLBalance&&t.mintB.address===H.toString(),{account:h,instructionParams:I}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:t.mintA.programId,mint:new Q(t.mintA.address),notUseTokenAccount:g,owner:this.scope.ownerPubKey,createInfo:g||(o==="MintA"?r:i).isZero()?{payer:this.scope.ownerPubKey,amount:o==="MintA"?r:i}:void 0,skipCloseAccount:!g,associatedOnly:g?!1:u,checkCreateATAOwner:s});h&&(y=h),f.addInstruction(I||{});let{account:T,instructionParams:w}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:t.mintB.programId,mint:new Q(t.mintB.address),owner:this.scope.ownerPubKey,createInfo:P||(o==="MintA"?i:r).isZero()?{payer:this.scope.ownerPubKey,amount:o==="MintA"?i:r}:void 0,notUseTokenAccount:P,skipCloseAccount:!P,associatedOnly:P?!1:u,checkCreateATAOwner:s});T&&(b=T),f.addInstruction(w||{}),!y&&!b&&this.logAndCreateError("cannot found target token accounts","tokenAccounts",this.scope.account.tokenAccounts);let x=await this.getClmmPoolKeys(t.id),S=Ce.increasePositionFromBaseInstructions({poolInfo:t,poolKeys:x,ownerPosition:n,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccountA:y,tokenAccountB:b},base:o,baseAmount:r,otherAmountMax:i,nft2022:(K=await this.scope.connection.getAccountInfo(n.nftMint))==null?void 0:K.owner.equals(Fn)});return f.addInstruction(S),f.addCustomComputeBudget(l),f.addTipInstruction(d),f.versionBuild({txVersion:p,extInfo:{address:S.address}})}async decreaseLiquidity(e){var F;let{poolInfo:t,poolKeys:n,ownerPosition:o,ownerInfo:r,amountMinA:i,amountMinB:a,liquidity:u,associatedOnly:s=!0,checkCreateATAOwner:l=!1,computeBudgetConfig:d,txTipConfig:p,txVersion:m,feePayer:f}=e;this.scope.availability.removeConcentratedPosition===!1&&this.logAndCreateError("remove position feature disabled in your region");let y=this.createTxBuilder(f),b=r.useSOLBalance&&t.mintA.address===H.toString(),g=r.useSOLBalance&&t.mintB.address===H.toString(),P,h,{account:I,instructionParams:T}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:t.mintA.programId,mint:new Q(t.mintA.address),notUseTokenAccount:b,owner:this.scope.ownerPubKey,createInfo:{payer:this.scope.ownerPubKey,amount:0},skipCloseAccount:!b,associatedOnly:b?!1:s,checkCreateATAOwner:l});P=I,T&&y.addInstruction(T);let{account:w,instructionParams:x}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:t.mintB.programId,mint:new Q(t.mintB.address),notUseTokenAccount:g,owner:this.scope.ownerPubKey,createInfo:{payer:this.scope.ownerPubKey,amount:0},skipCloseAccount:!g,associatedOnly:g?!1:s,checkCreateATAOwner:l});h=w,x&&y.addInstruction(x);let S=[];for(let R of t.rewardDefaultInfos){let L=r.useSOLBalance&&R.mint.address===H.toString(),W;if(R.mint.address===t.mintA.address)W=P;else if(R.mint.address===t.mintB.address)W=h;else{let{account:z,instructionParams:$}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:new Q(R.mint.programId),mint:new Q(R.mint.address),notUseTokenAccount:L,owner:this.scope.ownerPubKey,createInfo:{payer:this.scope.ownerPubKey,amount:0},skipCloseAccount:!L,associatedOnly:L?!1:s,checkCreateATAOwner:l});W=z,$&&y.addInstruction($)}S.push(W)}!P&&!h&&this.logAndCreateError("cannot found target token accounts","tokenAccounts",this.scope.account.tokenAccountRawInfos);let K=n!=null?n:await this.getClmmPoolKeys(t.id),B=(F=await this.scope.connection.getAccountInfo(o.nftMint))==null?void 0:F.owner.equals(Fn),C=await Ce.decreaseLiquidityInstructions({poolInfo:t,poolKeys:K,ownerPosition:o,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccountA:P,tokenAccountB:h,rewardAccounts:S},liquidity:u,amountMinA:i,amountMinB:a,nft2022:B});y.addInstruction({instructions:C.instructions,instructionTypes:[U.ClmmDecreasePosition]});let M=N({},C.address);if(r.closePosition){let R=await Ce.closePositionInstructions({poolInfo:t,poolKeys:K,ownerInfo:{wallet:this.scope.ownerPubKey},ownerPosition:o,nft2022:B});y.addInstruction({endInstructions:R.instructions,endInstructionTypes:R.instructionTypes}),M=N(N({},M),R.address)}return y.addCustomComputeBudget(d),y.addTipInstruction(p),y.versionBuild({txVersion:m,extInfo:{address:M}})}async lockPosition(e){var f;let{programId:t=bo,authProgramId:n=jo,poolProgramId:o=Sn,ownerPosition:r,payer:i,computeBudgetConfig:a,txTipConfig:u,txVersion:s,getEphemeralSigners:l,feePayer:d}=e,p=this.createTxBuilder(d),m=await Ce.makeLockPositions({programId:t,authProgramId:n,poolProgramId:o,wallet:this.scope.ownerPubKey,payer:i!=null?i:this.scope.ownerPubKey,nftMint:r.nftMint,getEphemeralSigners:l,nft2022:(f=await this.scope.connection.getAccountInfo(r.nftMint))==null?void 0:f.owner.equals(Fn)});return p.addInstruction(m),p.addCustomComputeBudget(a),p.addTipInstruction(u),p.versionBuild({txVersion:s,extInfo:m.address})}async harvestLockPosition(e){let{programId:t=bo,authProgramId:n=jo,clmmProgram:o=Sn,poolKeys:r,lockData:i,ownerInfo:a={useSOLBalance:!0},associatedOnly:u=!0,checkCreateATAOwner:s=!1,computeBudgetConfig:l,txTipConfig:d,txVersion:p,feePayer:m}=e,f=r||await this.getClmmPoolKeys(i.poolId.toString()),y=this.createTxBuilder(m),b=await this.scope.connection.getAccountInfo(i.positionId);b||this.logger.logWithError("position not found",i.positionId);let g=So.decode(b.data),P=a.useSOLBalance&&f.mintA.address===H.toString(),h=a.useSOLBalance&&f.mintB.address===H.toString(),I,T,{account:w,instructionParams:x}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:f.mintA.programId,mint:new Q(f.mintA.address),notUseTokenAccount:P,owner:this.scope.ownerPubKey,createInfo:{payer:this.scope.ownerPubKey,amount:0},skipCloseAccount:!P,associatedOnly:P?!1:u,checkCreateATAOwner:s});I=w,x&&y.addInstruction(x);let{account:S,instructionParams:K}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:f.mintB.programId,mint:new Q(f.mintB.address),notUseTokenAccount:h,owner:this.scope.ownerPubKey,createInfo:{payer:this.scope.ownerPubKey,amount:0},skipCloseAccount:!h,associatedOnly:h?!1:u,checkCreateATAOwner:s});T=S,K&&y.addInstruction(K);let B={},C=[];for(let ce of f.rewardInfos){let de=a.useSOLBalance&&ce.mint.address===H.toString(),pe=B[ce.mint.address];if(!pe){let{account:le,instructionParams:ee}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:new Q(ce.mint.programId),mint:new Q(ce.mint.address),notUseTokenAccount:de,owner:this.scope.ownerPubKey,skipCloseAccount:!de,createInfo:{payer:this.scope.ownerPubKey,amount:0},associatedOnly:de?!1:u});pe=le,ee&&y.addInstruction(ee)}B[ce.mint.address]=pe,C.push(pe)}let M=xo(t,i.lockNftMint).publicKey,F=j(this.scope.ownerPubKey,i.lockNftMint,Ki).publicKey,R=Z.getTickArrayStartIndexByTick(g.tickLower,f.config.tickSpacing),L=Z.getTickArrayStartIndexByTick(g.tickUpper,f.config.tickSpacing),{publicKey:W}=ge(new Q(f.programId),i.poolId,R),{publicKey:z}=ge(new Q(f.programId),i.poolId,L),{publicKey:$}=nn(new Q(f.programId),i.poolId,g.tickLower,g.tickUpper),ae=[];for(let ce=0;ce<f.rewardInfos.length;ce++)ae.push({poolRewardVault:new Q(f.rewardInfos[ce].vault),ownerRewardVault:C[ce],rewardMint:new Q(f.rewardInfos[ce].mint.address)});let ye=await Ce.harvestLockPositionInstructionV2({programId:t,auth:n,lockPositionId:M,clmmProgram:o,lockOwner:this.scope.ownerPubKey,lockNftMint:i.lockNftMint,lockNftAccount:F,positionNftAccount:i.nftAccount,positionId:i.positionId,poolId:i.poolId,protocolPosition:$,vaultA:new Q(f.vault.A),vaultB:new Q(f.vault.B),tickArrayLower:W,tickArrayUpper:z,userVaultA:I,userVaultB:T,mintA:new Q(f.mintA.address),mintB:new Q(f.mintB.address),rewardAccounts:ae,exTickArrayBitmap:Qe(o,i.poolId).publicKey});return y.addInstruction({instructions:[ye],instructionTypes:[U.ClmmHarvestLockPosition]}),y.addCustomComputeBudget(l),y.addTipInstruction(d),y.versionBuild({txVersion:p})}async closePosition({poolInfo:e,poolKeys:t,ownerPosition:n,txVersion:o,computeBudgetConfig:r,txTipConfig:i,feePayer:a}){var d;this.scope.availability.removeConcentratedPosition===!1&&this.logAndCreateError("remove position feature disabled in your region");let u=this.createTxBuilder(a),s=t!=null?t:await this.getClmmPoolKeys(e.id),l=Ce.closePositionInstructions({poolInfo:e,poolKeys:s,ownerInfo:{wallet:this.scope.ownerPubKey},ownerPosition:n,nft2022:(d=await this.scope.connection.getAccountInfo(n.nftMint))==null?void 0:d.owner.equals(Fn)});return u.addCustomComputeBudget(r),u.addTipInstruction(i),u.addInstruction(l).versionBuild({txVersion:o,extInfo:{address:l.address}})}async initReward({poolInfo:e,ownerInfo:t,rewardInfo:n,associatedOnly:o=!0,checkCreateATAOwner:r=!1,computeBudgetConfig:i,txVersion:a,feePayer:u}){n.endTime<=n.openTime&&this.logAndCreateError("reward time error","rewardInfo",n);let s=this.createTxBuilder(u),l=t.useSOLBalance&&n.mint.address.toString()===H.toString(),d=n.perSecond.mul(n.endTime-n.openTime),{account:p,instructionParams:m}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:new Q(n.mint.address),mint:new Q(n.mint.address),notUseTokenAccount:!!l,skipCloseAccount:!l,owner:this.scope.ownerPubKey,createInfo:l?{payer:t.feePayer||this.scope.ownerPubKey,amount:new wt(new oo(d.toFixed(0)).gte(d)?d.toFixed(0):d.add(1).toFixed(0))}:void 0,associatedOnly:l?!1:o,checkCreateATAOwner:r});m&&s.addInstruction(m),p||this.logAndCreateError("no money","ownerRewardAccount",this.scope.account.tokenAccountRawInfos);let f=await this.getClmmPoolKeys(e.id),y=Ce.initRewardInstructions({poolInfo:e,poolKeys:f,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccount:p},rewardInfo:{programId:new Q(n.mint.programId),mint:new Q(n.mint.address),openTime:n.openTime,endTime:n.endTime,emissionsPerSecondX64:ue.decimalToX64(n.perSecond)}});return s.addInstruction(y),s.addCustomComputeBudget(i),s.versionBuild({txVersion:a,extInfo:{address:y.address}})}async initRewards({poolInfo:e,poolKeys:t,ownerInfo:n,rewardInfos:o,associatedOnly:r=!0,checkCreateATAOwner:i=!1,computeBudgetConfig:a,txTipConfig:u,txVersion:s,feePayer:l}){for(let m of o)m.endTime<=m.openTime&&this.logAndCreateError("reward time error","rewardInfo",m);let d=this.createTxBuilder(l),p={};for(let m of o){let f=n.useSOLBalance&&m.mint.address===H.toString(),y=m.perSecond.mul(m.endTime-m.openTime),{account:b,instructionParams:g}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:new Q(m.mint.programId),mint:new Q(m.mint.address),notUseTokenAccount:!!f,skipCloseAccount:!f,owner:this.scope.ownerPubKey,createInfo:f?{payer:n.feePayer||this.scope.ownerPubKey,amount:new wt(new oo(y.toFixed(0)).gte(y)?y.toFixed(0):y.add(1).toFixed(0))}:void 0,associatedOnly:f?!1:r,checkCreateATAOwner:i});g&&d.addInstruction(g),b||this.logAndCreateError("no money","ownerRewardAccount",this.scope.account.tokenAccountRawInfos);let P=t!=null?t:await this.getClmmPoolKeys(e.id),h=Ce.initRewardInstructions({poolInfo:e,poolKeys:P,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccount:b},rewardInfo:{programId:new Q(m.mint.programId),mint:new Q(m.mint.address),openTime:m.openTime,endTime:m.endTime,emissionsPerSecondX64:ue.decimalToX64(m.perSecond)}});p=N(N({},p),h.address),d.addInstruction(h)}return d.addCustomComputeBudget(a),d.addTipInstruction(u),d.versionBuild({txVersion:s,extInfo:{address:p}})}async setReward({poolInfo:e,ownerInfo:t,rewardInfo:n,associatedOnly:o=!0,checkCreateATAOwner:r=!1,computeBudgetConfig:i,txTipConfig:a,txVersion:u,feePayer:s}){n.endTime<=n.openTime&&this.logAndCreateError("reward time error","rewardInfo",n);let l=this.createTxBuilder(s),d=t.useSOLBalance&&n.mint.equals(H),{account:p,instructionParams:m}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:n.programId,mint:n.mint,notUseTokenAccount:d,owner:this.scope.ownerPubKey,createInfo:d?{payer:t.feePayer||this.scope.ownerPubKey,amount:new wt(new oo(n.perSecond.mul(n.endTime-n.openTime).toFixed(0)).gte(n.perSecond.mul(n.endTime-n.openTime))?n.perSecond.mul(n.endTime-n.openTime).toFixed(0):n.perSecond.mul(n.endTime-n.openTime).add(1).toFixed(0))}:void 0,associatedOnly:d?!1:o,checkCreateATAOwner:r});m&&l.addInstruction(m),p||this.logAndCreateError("no money","ownerRewardAccount",this.scope.account.tokenAccountRawInfos);let f=await this.getClmmPoolKeys(e.id),y=Ce.setRewardInstructions({poolInfo:e,poolKeys:f,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccount:p},rewardInfo:{mint:n.mint,openTime:n.openTime,endTime:n.endTime,emissionsPerSecondX64:ue.decimalToX64(n.perSecond)}});return l.addInstruction(y),l.addCustomComputeBudget(i),l.addTipInstruction(a),l.versionBuild({txVersion:u,extInfo:{address:y.address}})}async setRewards({poolInfo:e,poolKeys:t,ownerInfo:n,rewardInfos:o,associatedOnly:r=!0,checkCreateATAOwner:i=!1,computeBudgetConfig:a,txTipConfig:u,txVersion:s,feePayer:l}){let d=this.createTxBuilder(l),p={};for(let m of o){m.endTime<=m.openTime&&this.logAndCreateError("reward time error","rewardInfo",m);let f=n.useSOLBalance&&m.mint.address===H.toString(),{account:y,instructionParams:b}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:new Q(m.mint.programId),mint:new Q(m.mint.address),notUseTokenAccount:f,owner:this.scope.ownerPubKey,createInfo:f?{payer:n.feePayer||this.scope.ownerPubKey,amount:new wt(new oo(m.perSecond.mul(m.endTime-m.openTime).toFixed(0)).gte(m.perSecond.mul(m.endTime-m.openTime))?m.perSecond.mul(m.endTime-m.openTime).toFixed(0):m.perSecond.mul(m.endTime-m.openTime).add(1).toFixed(0))}:void 0,associatedOnly:f?!1:r,checkCreateATAOwner:i});b&&d.addInstruction(b),y||this.logAndCreateError("no money","ownerRewardAccount",this.scope.account.tokenAccountRawInfos);let g=t!=null?t:await this.getClmmPoolKeys(e.id),P=Ce.setRewardInstructions({poolInfo:e,poolKeys:g,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccount:y},rewardInfo:{mint:new Q(m.mint.address),openTime:m.openTime,endTime:m.endTime,emissionsPerSecondX64:ue.decimalToX64(m.perSecond)}});d.addInstruction(P),p=N(N({},p),P.address)}return d.addCustomComputeBudget(a),d.addTipInstruction(u),d.versionBuild({txVersion:s,extInfo:{address:p}})}async collectReward({poolInfo:e,ownerInfo:t,rewardMint:n,associatedOnly:o=!0,checkCreateATAOwner:r=!1,computeBudgetConfig:i,txTipConfig:a,txVersion:u,feePayer:s}){let l=e.rewardDefaultInfos.find(g=>g.mint.address===n.toString());l||this.logAndCreateError("reward mint error","not found reward mint",n);let d=this.createTxBuilder(s),p=t.useSOLBalance&&n.equals(H),{account:m,instructionParams:f}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:new Q(l.mint.programId),mint:n,notUseTokenAccount:p,owner:this.scope.ownerPubKey,skipCloseAccount:!p,createInfo:{payer:t.feePayer||this.scope.ownerPubKey,amount:0},associatedOnly:p?!1:o,checkCreateATAOwner:r});f&&d.addInstruction(f),m||this.logAndCreateError("no money","ownerRewardAccount",this.scope.account.tokenAccountRawInfos);let y=await this.getClmmPoolKeys(e.id),b=Ce.collectRewardInstructions({poolInfo:e,poolKeys:y,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccount:m},rewardMint:n});return d.addInstruction(b),d.addCustomComputeBudget(i),d.addTipInstruction(a),d.versionBuild({txVersion:u,extInfo:{address:b.address}})}async collectRewards({poolInfo:e,ownerInfo:t,rewardMints:n,associatedOnly:o=!0,checkCreateATAOwner:r=!1,computeBudgetConfig:i,txTipConfig:a,feePayer:u}){let s=this.createTxBuilder(u),l={};for(let d of n){let p=e.rewardDefaultInfos.find(P=>P.mint.address===d.toString());if(!p){this.logAndCreateError("reward mint error","not found reward mint",d);continue}let m=t.useSOLBalance&&d.equals(H),{account:f,instructionParams:y}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:new Q(p.mint.programId),mint:d,notUseTokenAccount:m,owner:this.scope.ownerPubKey,skipCloseAccount:!m,createInfo:{payer:t.feePayer||this.scope.ownerPubKey,amount:0},associatedOnly:m?!1:o,checkCreateATAOwner:r});f||this.logAndCreateError("no money","ownerRewardAccount",this.scope.account.tokenAccountRawInfos),y&&s.addInstruction(y);let b=await this.getClmmPoolKeys(e.id),g=Ce.collectRewardInstructions({poolInfo:e,poolKeys:b,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccount:f},rewardMint:d});s.addInstruction(g),l=N(N({},l),g.address)}return s.addCustomComputeBudget(i),s.addTipInstruction(a),s.build({address:l})}async swap({poolInfo:e,poolKeys:t,inputMint:n,amountIn:o,amountOutMin:r,priceLimit:i,observationId:a,ownerInfo:u,remainingAccounts:s,associatedOnly:l=!0,checkCreateATAOwner:d=!1,txVersion:p,computeBudgetConfig:m,txTipConfig:f,feePayer:y}){let b=this.createTxBuilder(y),g=n.toString()===e.mintA.address,P=u.useSOLBalance&&e.mintA.address===H.toBase58(),h=u.useSOLBalance&&e.mintB.address===H.toBase58(),I;!i||i.equals(new oo(0))?I=g?Dt.add(new wt(1)):Wt.sub(new wt(1)):I=ie.priceToSqrtPriceX64(i,e.mintA.decimals,e.mintB.decimals);let T;if(!T){let{account:S,instructionParams:K}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:e.mintA.programId,mint:new Q(e.mintA.address),notUseTokenAccount:P,owner:this.scope.ownerPubKey,skipCloseAccount:!P,createInfo:P||!g?{payer:u.feePayer||this.scope.ownerPubKey,amount:g?o:0}:void 0,associatedOnly:P?!1:l,checkCreateATAOwner:d});T=S,K&&b.addInstruction(K)}let w;if(!w){let{account:S,instructionParams:K}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:e.mintB.programId,mint:new Q(e.mintB.address),notUseTokenAccount:h,owner:this.scope.ownerPubKey,skipCloseAccount:!h,createInfo:h||g?{payer:u.feePayer||this.scope.ownerPubKey,amount:g?0:o}:void 0,associatedOnly:h?!1:l,checkCreateATAOwner:d});w=S,K&&b.addInstruction(K)}(!T||!w)&&this.logAndCreateError("user do not have token account",{tokenA:e.mintA.symbol||e.mintA.address,tokenB:e.mintB.symbol||e.mintB.address,ownerTokenAccountA:T,ownerTokenAccountB:w,mintAUseSOLBalance:P,mintBUseSOLBalance:h,associatedOnly:l});let x=t!=null?t:await this.getClmmPoolKeys(e.id);return b.addInstruction(Ce.makeSwapBaseInInstructions({poolInfo:e,poolKeys:x,observationId:a,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccountA:T,tokenAccountB:w},inputMint:new Q(n),amountIn:o,amountOutMin:r,sqrtPriceLimitX64:I,remainingAccounts:s})),b.addCustomComputeBudget(m),b.addTipInstruction(f),b.versionBuild({txVersion:p})}async swapBaseOut({poolInfo:e,poolKeys:t,outputMint:n,amountOut:o,amountInMax:r,priceLimit:i,observationId:a,ownerInfo:u,remainingAccounts:s,associatedOnly:l=!0,checkCreateATAOwner:d=!1,txVersion:p,computeBudgetConfig:m,txTipConfig:f,feePayer:y}){let b=this.createTxBuilder(y),g=n.toString()===e.mintB.address,P=u.useSOLBalance&&e.mintA.address===H.toBase58(),h=u.useSOLBalance&&e.mintB.address===H.toBase58(),I;!i||i.equals(new oo(0))?I=n.toString()===e.mintB.address?Dt.add(new wt(1)):Wt.sub(new wt(1)):I=ie.priceToSqrtPriceX64(i,e.mintA.decimals,e.mintB.decimals);let T;if(!T){let{account:S,instructionParams:K}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:e.mintA.programId,mint:new Q(e.mintA.address),notUseTokenAccount:P,owner:this.scope.ownerPubKey,skipCloseAccount:!P,createInfo:P||!g?{payer:u.feePayer||this.scope.ownerPubKey,amount:g?r:0}:void 0,associatedOnly:P?!1:l,checkCreateATAOwner:d});T=S,K&&b.addInstruction(K)}let w;if(!w){let{account:S,instructionParams:K}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:e.mintB.programId,mint:new Q(e.mintB.address),notUseTokenAccount:h,owner:this.scope.ownerPubKey,skipCloseAccount:!h,createInfo:h||g?{payer:u.feePayer||this.scope.ownerPubKey,amount:g?0:r}:void 0,associatedOnly:h?!1:l,checkCreateATAOwner:d});w=S,K&&b.addInstruction(K)}(!T||!w)&&this.logAndCreateError("user do not have token account",{tokenA:e.mintA.symbol||e.mintA.address,tokenB:e.mintB.symbol||e.mintB.address,ownerTokenAccountA:T,ownerTokenAccountB:w,mintAUseSOLBalance:P,mintBUseSOLBalance:h,associatedOnly:l});let x=t!=null?t:await this.getClmmPoolKeys(e.id);return b.addInstruction(Ce.makeSwapBaseOutInstructions({poolInfo:e,poolKeys:x,observationId:a,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccountA:T,tokenAccountB:w},outputMint:new Q(n),amountOut:o,amountInMax:r,sqrtPriceLimitX64:I,remainingAccounts:s})),b.addCustomComputeBudget(m),b.addTipInstruction(f),b.versionBuild({txVersion:p})}async harvestAllRewards({allPoolInfo:e,allPositions:t,lockInfo:n,ownerInfo:o,associatedOnly:r=!0,checkCreateATAOwner:i=!1,programId:a,txVersion:u,computeBudgetConfig:s,feePayer:l,lockProgram:d=bo,lockAuth:p=jo,clmmProgram:m=Sn}){var h,I;let f={};for(let T of this.scope.account.tokenAccountRawInfos)r?j(this.scope.ownerPubKey,T.accountInfo.mint,a).publicKey.equals(T.pubkey)&&(f[T.accountInfo.mint.toString()]=T.pubkey):f[T.accountInfo.mint.toString()]=T.pubkey;let y=Object.values(t).flat().map(T=>T.nftMint),b=await Oe(this.scope.connection,y.map(T=>({pubkey:T}))),g={};b.forEach(T=>{var w,x;g[T.pubkey.toBase58()]=(x=(w=T==null?void 0:T.accountInfo)==null?void 0:w.owner)!=null?x:null});let P=this.createTxBuilder(l);for(let T of Object.values(e)){if(t[T.id]===void 0||!t[T.id].find(R=>!R.liquidity.isZero()||R.rewardInfos.find(L=>!L.rewardAmountOwed.isZero())))continue;let w=T,x=o.useSOLBalance&&w.mintA.address===H.toString(),S=o.useSOLBalance&&w.mintB.address===H.toString(),K=f[w.mintA.address];if(!K)if(x){let{account:R,instructionParams:L}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:w.mintA.programId,mint:new Q(w.mintA.address),notUseTokenAccount:x,owner:this.scope.ownerPubKey,skipCloseAccount:!x,createInfo:{payer:o.feePayer||this.scope.ownerPubKey,amount:0},associatedOnly:x?!1:r,checkCreateATAOwner:i});K=R,L&&P.addInstruction(L)}else{let R=new Q(w.mintA.address);K=this.scope.account.getAssociatedTokenAccount(R,new Q(w.mintA.programId)),P.addInstruction({instructions:[ul(this.scope.ownerPubKey,K,this.scope.ownerPubKey,R,new Q(w.mintA.programId))]})}let B=f[w.mintB.address];if(!B)if(S){let{account:R,instructionParams:L}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:w.mintB.programId,mint:new Q(w.mintB.address),notUseTokenAccount:S,owner:this.scope.ownerPubKey,skipCloseAccount:!S,createInfo:{payer:o.feePayer||this.scope.ownerPubKey,amount:0},associatedOnly:S?!1:r,checkCreateATAOwner:i});B=R,L&&P.addInstruction(L)}else{let R=new Q(w.mintB.address);B=this.scope.account.getAssociatedTokenAccount(R,new Q(w.mintB.programId)),P.addInstruction({instructions:[ul(this.scope.ownerPubKey,B,this.scope.ownerPubKey,R,new Q(w.mintB.programId))]})}f[w.mintA.address]=K,f[w.mintB.address]=B;let C=[];for(let R of w.rewardDefaultInfos){let L=o.useSOLBalance&&R.mint.address===H.toString(),W=f[R.mint.address];if(!W){let{account:z,instructionParams:$}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:new Q(R.mint.programId),mint:new Q(R.mint.address),notUseTokenAccount:L,owner:this.scope.ownerPubKey,skipCloseAccount:!L,createInfo:{payer:o.feePayer||this.scope.ownerPubKey,amount:0},associatedOnly:L?!1:r});W=z,$&&P.addInstruction($)}f[R.mint.address]=W,C.push(W)}let M=await this.getClmmPoolKeys(w.id),F=[];for(let R=0;R<M.rewardInfos.length;R++)F.push({poolRewardVault:new Q(M.rewardInfos[R].vault),ownerRewardVault:C[R],rewardMint:new Q(M.rewardInfos[R].mint.address)});for(let R of t[T.id]){let L=(h=n==null?void 0:n[T.id])==null?void 0:h[R.nftMint.toBase58()];if(L){let W=j(this.scope.ownerPubKey,L.lockNftMint,Ki).publicKey,z=Z.getTickArrayStartIndexByTick(R.tickLower,M.config.tickSpacing),$=Z.getTickArrayStartIndexByTick(R.tickUpper,M.config.tickSpacing),{publicKey:ae}=ge(new Q(M.programId),L.poolId,z),{publicKey:ye}=ge(new Q(M.programId),L.poolId,$),{publicKey:ce}=nn(new Q(M.programId),L.poolId,R.tickLower,R.tickUpper),de=xo(d,L.lockNftMint).publicKey,pe=Ce.harvestLockPositionInstructionV2({programId:d,auth:p,lockPositionId:de,clmmProgram:m,lockOwner:this.scope.ownerPubKey,lockNftMint:L.lockNftMint,lockNftAccount:W,positionNftAccount:L.nftAccount,positionId:L.positionId,poolId:L.poolId,protocolPosition:ce,vaultA:new Q(M.vault.A),vaultB:new Q(M.vault.B),tickArrayLower:ae,tickArrayUpper:ye,userVaultA:K,userVaultB:B,mintA:new Q(M.mintA.address),mintB:new Q(M.mintB.address),rewardAccounts:F,exTickArrayBitmap:Qe(m,L.poolId).publicKey});P.addInstruction({instructions:[pe],instructionTypes:[U.ClmmHarvestLockPosition],lookupTableAddress:M.lookupTableAccount?[M.lookupTableAccount]:[]})}else{let W=Ce.decreaseLiquidityInstructions({poolInfo:w,poolKeys:M,ownerPosition:R,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccountA:K,tokenAccountB:B,rewardAccounts:C},liquidity:new wt(0),amountMinA:new wt(0),amountMinB:new wt(0),nft2022:(I=g[R.nftMint.toBase58()])==null?void 0:I.equals(Fn)});P.addInstruction(W)}}}return u===0?P.sizeCheckBuildV0({computeBudgetConfig:s}):P.sizeCheckBuild({computeBudgetConfig:s})}async getWhiteListMint({programId:e}){let t=await this.scope.connection.getAccountInfo(gi(e).publicKey);return t?_c.decode(t.data).whitelistMints.filter(o=>!o.equals(Q.default)):[]}async getOwnerPositionInfo({programId:e=Sn}){await this.scope.account.fetchWalletTokenAccounts();let n=this.scope.account.tokenAccountRawInfos.filter(i=>i.accountInfo.amount.eq(new wt(1))).map(i=>kt(new Q(e),i.accountInfo.mint).publicKey),o=await this.scope.connection.getMultipleAccountsInfo(n),r=[];return o.forEach(i=>{if(!i)return;let a=So.decode(i.data);r.push(a)}),r}async getOwnerLockedPositionInfo({programId:e=bo}){await this.scope.account.fetchWalletTokenAccounts();let n=this.scope.account.tokenAccountRawInfos.filter(u=>u.accountInfo.amount.eq(new wt(1))).map(u=>xo(new Q(e),u.accountInfo.mint).publicKey),o=await this.scope.connection.getMultipleAccountsInfo(n),r=[];o.forEach(u=>{if(!u)return;let s=Ec.decode(u.data);r.push(s)});let i=await this.scope.connection.getMultipleAccountsInfo(r.map(u=>u.positionId)),a=[];return i.forEach(u=>{if(!u)return;let s=So.decode(u.data);a.push(s)}),r.map((u,s)=>({position:a[s],lockInfo:u}))}async getRpcClmmPoolInfo({poolId:e}){return(await this.getRpcClmmPoolInfos({poolIds:[e]}))[String(e)]}async getRpcClmmPoolInfos({poolIds:e,config:t}){let n=await Oe(this.scope.connection,e.map(r=>({pubkey:new Q(r)})),t),o={};for(let r=0;r<e.length;r++){let i=n[r];if(i===null||!i.accountInfo)throw Error("fetch pool info error: "+String(e[r]));let a=Hn.decode(i.accountInfo.data),u=ie.sqrtPriceX64ToPrice(a.sqrtPriceX64,a.mintDecimalsA,a.mintDecimalsB).toNumber();o[String(e[r])]=q(N({},a),{currentPrice:u,programId:i.accountInfo.owner})}return o}async getComputeClmmPoolInfos({clmmPoolsRpcInfo:e,mintInfos:t}){let n=new Set(Object.keys(e).map(u=>e[u].ammConfig.toBase58())),o=await Oe(this.scope.connection,Array.from(n).map(u=>({pubkey:new Q(u)}))),r={};o.forEach(u=>{!u.accountInfo||(r[u.pubkey.toBase58()]=Fc.decode(u.accountInfo.data))});let i=await Ne.fetchComputeMultipleClmmInfo({connection:this.scope.connection,rpcDataMap:e,poolList:Object.keys(e).map(u=>{var d,p,m,f;let[s,l]=[e[u].mintA.toBase58(),e[u].mintB.toBase58()];return{id:u,programId:e[u].programId.toBase58(),mintA:ft({address:s,decimals:e[u].mintDecimalsA,programId:t[s].programId.toBase58()||Ki.toBase58(),extensions:{feeConfig:(d=t[s])!=null&&d.feeConfig?Mn((p=t[s])==null?void 0:p.feeConfig):void 0}}),mintB:ft({address:l,decimals:e[u].mintDecimalsB,programId:t[l].programId.toBase58()||Ki.toBase58(),extensions:{feeConfig:(m=t[l])!=null&&m.feeConfig?Mn((f=t[l])==null?void 0:f.feeConfig):void 0}}),price:e[u].currentPrice,config:q(N({},r[e[u].ammConfig.toBase58()]),{id:e[u].ammConfig.toBase58(),fundFeeRate:0,description:"",defaultRange:0,defaultRangePoint:[]})}})}),a=await Ne.fetchMultiplePoolTickArrays({connection:this.scope.connection,poolKeys:Object.values(i)});return{computeClmmPoolInfo:i,computePoolTickData:a}}async getPoolInfoFromRpc(e){var l;let t=await this.getRpcClmmPoolInfo({poolId:e}),n=new Set([t.mintA.toBase58(),t.mintB.toBase58()]),o=await po({connection:this.scope.connection,mints:Array.from(n).map(d=>new Q(d))}),{computeClmmPoolInfo:r,computePoolTickData:i}=await this.scope.clmm.getComputeClmmPoolInfos({clmmPoolsRpcInfo:{[e]:t},mintInfos:o}),a=await Oe(this.scope.connection,[{pubkey:t.vaultA},{pubkey:t.vaultB}]),u=Mc(r[e]);if(!a[0].accountInfo||!a[1].accountInfo)throw new Error("pool vault data not found");u.mintAmountA=Number(sl.decode(a[0].accountInfo.data).amount.toString()),u.mintAmountB=Number(sl.decode((l=a[1].accountInfo)==null?void 0:l.data).amount.toString());let s=q(N({},r[e]),{exBitmapAccount:r[e].exBitmapAccount.toBase58(),observationId:r[e].observationId.toBase58(),id:e,programId:t.programId.toBase58(),openTime:t.startTime.toString(),vault:{A:t.vaultA.toBase58(),B:t.vaultB.toBase58()},config:u.config,rewardInfos:r[e].rewardInfos.filter(d=>!d.tokenVault.equals(Q.default)).map(d=>({mint:ft({address:d.tokenMint.toBase58(),programId:Ki.toBase58(),decimals:10}),vault:d.tokenVault.toBase58()}))});return{poolInfo:u,poolKeys:s,computePoolInfo:r[e],tickData:i}}};import{PublicKey as X}from"@solana/web3.js";import{AccountLayout as Wp,NATIVE_MINT as Yr,TOKEN_PROGRAM_ID as Mt,createAssociatedTokenAccountIdempotentInstruction as Pl}from"@solana/spl-token";import _s from"bn.js";import Gr from"decimal.js-light";import Ri from"bn.js";function Wr(c,e){if(e.isZero())throw Error("divisor is zero");return c.mod(e)}function Sp(c,e){if(e.isZero())throw Error("rhs is zero");let t=c.div(e);if(t.isZero())throw Error("quotient is zero");let n=Wr(c,e);return n.gt(Oo)&&(t=t.add(new Ri(1)),e=c.div(t),n=Wr(c,t),n.gt(Oo)&&(e=e.add(new Ri(1)))),[t,e]}var Oo=new Ri(0),qr=class{static swapWithoutFees(e,t,n){let o=t.mul(n),r=t.add(e),[i]=Sp(o,r),a=n.sub(i);if(a.isZero())throw Error("destinationAmountSwapped is zero");return{destinationAmountSwapped:a}}static lpTokensToTradingTokens(e,t,n,o,r){let i=e.mul(n).div(t),a=e.mul(o).div(t);if(r===0)return{tokenAmount0:i,tokenAmount1:a};if(r===1)return Wr(e.mul(n),t).gt(Oo)&&i.gt(Oo)&&(i=i.add(new Ri(1))),Wr(e.mul(o),t).gt(Oo)&&a.gt(Oo)&&(a=a.add(new Ri(1))),{tokenAmount0:i,tokenAmount1:a};throw Error("roundDirection value error")}};var Ur=class{static tradingFee(e,t){return ir(e,t,Jt)}static protocolFee(e,t){return ha(e,t,Jt)}static fundFee(e,t){return ha(e,t,Jt)}};var cl=(t=>(t[t.Floor=0]="Floor",t[t.Ceiling=1]="Ceiling",t))(cl||{}),Xr=class{static validate_supply(e,t){if(e.isZero())throw Error("tokenAmount0 is zero");if(t.isZero())throw Error("tokenAmount1 is zero")}static swap(e,t,n,o){let r=Ur.tradingFee(e,o),i=e.sub(r),{destinationAmountSwapped:a}=qr.swapWithoutFees(i,t,n);return{newSwapDestinationAmount:n.sub(a),sourceAmountSwapped:e,destinationAmountSwapped:a,tradeFee:r}}static swapBaseOut({poolMintA:e,poolMintB:t,tradeFeeRate:n,baseReserve:o,quoteReserve:r,outputMint:i,outputAmount:a}){let[u,s,l,d,p]=t.address===i.toString()?[o,r,e.decimals,t.decimals,e.address]:[r,o,t.decimals,e.decimals,t.address],m=new Gr(s.toString()).div(10**d).div(new Gr(u.toString()).div(10**l)),f=a.gte(s)?s.sub(new _s(1)):a,y=s.sub(f),b=Zt(u.mul(f),y),g=Zt(b.mul(new _s(1e6)),new _s(1e6).sub(n)),P=g.sub(b),h=new Gr(f.toString()).div(10**d).div(new Gr(g.toString()).div(10**l)),I=m.isZero()?0:h.sub(m).div(m).abs().toNumber();return{amountRealOut:f,amountIn:g,amountInWithoutFee:b,tradeFee:P,priceImpact:I}}};import Ye from"bn.js";import qt from"decimal.js";import{PublicKey as Ni,TransactionInstruction as io,Keypair as Vp,SystemProgram as _p}from"@solana/web3.js";import{ASSOCIATED_TOKEN_PROGRAM_ID as dl,TOKEN_2022_PROGRAM_ID as Ds,TOKEN_PROGRAM_ID as Vn}from"@solana/spl-token";var Kp=Buffer.from("vault_and_lp_mint_auth_seed","utf8"),Cp=Buffer.from("amm_config","utf8"),Rp=Buffer.from("pool","utf8"),Lp=Buffer.from("pool_lp_mint","utf8"),Op=Buffer.from("pool_vault","utf8"),Np=Buffer.from("observation","utf8");function No(c){return ne([Kp],c)}function cx(c,e){return ne([Cp,vp(e)],c)}function Es(c,e,t,n){return ne([Rp,e.toBuffer(),t.toBuffer(),n.toBuffer()],c)}function Mp(c,e){return ne([Lp,e.toBuffer()],c)}function ll(c,e,t){return ne([Op,e.toBuffer(),t.toBuffer()],c)}function Li(c,e){return ne([Np,e.toBuffer()],c)}function vp(c){let e=new ArrayBuffer(2);return new DataView(e).setUint16(0,c,!1),new Uint8Array(e)}function ml({poolId:c,programId:e,configId:t,mintA:n,mintB:o}){let r=No(e).publicKey,i=c||Es(e,t,n,o).publicKey,a=Mp(e,i).publicKey,u=ll(e,i,n).publicKey,s=ll(e,i,o).publicKey,l=Li(e,i).publicKey;return{poolId:i,configId:t,authority:r,lpMint:a,vaultA:u,vaultB:s,observationId:l}}var Fp=Buffer.from("locked_liquidity","utf8");function Oi(c,e){return ne([Fp,e.toBuffer()],c)}var Ep=fe("Raydium_cpmm"),ro={initialize:[175,175,109,31,13,152,155,237],deposit:[242,35,198,137,82,225,242,182],withdraw:[183,18,70,156,148,109,161,34],swapBaseInput:[143,190,90,218,196,30,51,222],swapBaseOutput:[55,217,98,86,163,74,180,173],lockCpLiquidity:[216,157,29,78,38,51,31,26],collectCpFee:[8,30,51,199,209,184,247,133]};function pl(c,e,t,n,o,r,i,a,u,s,l,d,p,m,f,y,b,g,P,h){let I=V([k("amountMaxA"),k("amountMaxB"),k("openTime")]),T=Es(c,t,r,i).publicKey,w=[{pubkey:e,isSigner:!0,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!o.equals(T),isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!1},{pubkey:i,isSigner:!1,isWritable:!1},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:d,isSigner:!1,isWritable:!0},{pubkey:p,isSigner:!1,isWritable:!0},{pubkey:m,isSigner:!1,isWritable:!0},{pubkey:b,isSigner:!1,isWritable:!0},{pubkey:Vn,isSigner:!1,isWritable:!1},{pubkey:f,isSigner:!1,isWritable:!1},{pubkey:y,isSigner:!1,isWritable:!1},{pubkey:dl,isSigner:!1,isWritable:!1},{pubkey:tr,isSigner:!1,isWritable:!1},{pubkey:Ze,isSigner:!1,isWritable:!1}],x=Buffer.alloc(I.span);return I.encode({amountMaxA:g,amountMaxB:P,openTime:h},x),new io({keys:w,programId:c,data:Buffer.from([...ro.initialize,...x])})}function fl(c,e,t,n,o,r,i,a,u,s,l,d,p,m,f){let y=V([k("lpAmount"),k("amountMaxA"),k("amountMaxB")]),b=[{pubkey:e,isSigner:!0,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:Vn,isSigner:!1,isWritable:!1},{pubkey:Ds,isSigner:!1,isWritable:!1},{pubkey:s,isSigner:!1,isWritable:!1},{pubkey:l,isSigner:!1,isWritable:!1},{pubkey:d,isSigner:!1,isWritable:!0}],g=Buffer.alloc(y.span);return Ep.debug("cpmm deposit data",{lpAmount:p.toString(),amountMaxA:m.toString(),amountMaxB:f.toString()}),y.encode({lpAmount:p,amountMaxA:m,amountMaxB:f},g),new io({keys:b,programId:c,data:Buffer.from([...ro.deposit,...g])})}function yl(c,e,t,n,o,r,i,a,u,s,l,d,p,m,f){let y=V([k("lpAmount"),k("amountMinA"),k("amountMinB")]),b=[{pubkey:e,isSigner:!0,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:Vn,isSigner:!1,isWritable:!1},{pubkey:Ds,isSigner:!1,isWritable:!1},{pubkey:s,isSigner:!1,isWritable:!1},{pubkey:l,isSigner:!1,isWritable:!1},{pubkey:d,isSigner:!1,isWritable:!0},{pubkey:sn,isSigner:!1,isWritable:!1}],g=Buffer.alloc(y.span);return y.encode({lpAmount:p,amountMinA:m,amountMinB:f},g),new io({keys:b,programId:c,data:Buffer.from([...ro.withdraw,...g])})}function zr(c,e,t,n,o,r,i,a,u,s,l,d,p,m,f,y){let b=V([k("amountIn"),k("amounOutMin")]),g=[{pubkey:e,isSigner:!0,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!1},{pubkey:l,isSigner:!1,isWritable:!1},{pubkey:d,isSigner:!1,isWritable:!1},{pubkey:p,isSigner:!1,isWritable:!1},{pubkey:m,isSigner:!1,isWritable:!0}],P=Buffer.alloc(b.span);return b.encode({amountIn:f,amounOutMin:y},P),new io({keys:g,programId:c,data:Buffer.from([...ro.swapBaseInput,...P])})}function bl(c,e,t,n,o,r,i,a,u,s,l,d,p,m,f,y){let b=V([k("amountInMax"),k("amountOut")]),g=[{pubkey:e,isSigner:!0,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!1},{pubkey:l,isSigner:!1,isWritable:!1},{pubkey:d,isSigner:!1,isWritable:!1},{pubkey:p,isSigner:!1,isWritable:!1},{pubkey:m,isSigner:!1,isWritable:!0}],P=Buffer.alloc(b.span);return b.encode({amountInMax:f,amountOut:y},P),new io({keys:g,programId:c,data:Buffer.from([...ro.swapBaseOutput,...P])})}async function gl(c){var b;let{ownerInfo:e,poolInfo:t,poolKeys:n,feeNftOwner:o,getEphemeralSigners:r}=c,i=[],[a,u]=[new Ni(t.id),new Ni(t.lpMint.address)],s;if(r)s=new Ni((await r(1))[0]);else{let g=Vp.generate();i.push(g),s=g.publicKey}let{publicKey:l}=j(o,s,Vn),{publicKey:d}=kn(s),{publicKey:p}=Oi(c.lockProgram,s),{publicKey:m}=j(e.wallet,u,Vn),{publicKey:f}=j(c.lockAuthProgram,u,Vn),y=Dp({programId:c.lockProgram,auth:c.lockAuthProgram,payer:e.feePayer,liquidityOwner:e.wallet,nftOwner:o,nftMint:s,nftAccount:l,poolId:a,lockPda:p,mintLp:u,userLpVault:m,lockLpVault:f,poolVaultA:new Ni(n.vault.A),poolVaultB:new Ni(n.vault.B),metadataAccount:d,lpAmount:c.lpAmount,withMetadata:(b=c.withMetadata)!=null?b:!0});return{address:{nftMint:s,nftAccount:l,metadataAccount:d,lockPda:p,userLpVault:m,lockLpVault:f},instructions:[y],signers:i,instructionTypes:[U.CpmmLockLp],lookupTableAddress:[]}}function Dp({programId:c,auth:e,payer:t,liquidityOwner:n,nftOwner:o,nftMint:r,nftAccount:i,poolId:a,lockPda:u,mintLp:s,userLpVault:l,lockLpVault:d,poolVaultA:p,poolVaultB:m,metadataAccount:f,lpAmount:y,withMetadata:b}){let g=[{pubkey:e,isSigner:!1,isWritable:!1},{pubkey:t,isSigner:!0,isWritable:!0},{pubkey:n,isSigner:!0,isWritable:!1},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!0,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!1},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!1},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:d,isSigner:!1,isWritable:!0},{pubkey:p,isSigner:!1,isWritable:!0},{pubkey:m,isSigner:!1,isWritable:!0},{pubkey:f,isSigner:!1,isWritable:!0},{pubkey:Ze,isSigner:!1,isWritable:!1},{pubkey:_p.programId,isSigner:!1,isWritable:!1},{pubkey:Vn,isSigner:!1,isWritable:!1},{pubkey:dl,isSigner:!1,isWritable:!1},{pubkey:jt,isSigner:!1,isWritable:!1}],P=V([k("lpAmount"),We("withMetadata")]),h=Buffer.alloc(P.span);P.encode({lpAmount:y,withMetadata:b},h);let I=Buffer.from([...ro.lockCpLiquidity,...h]);return new io({keys:g,programId:c,data:I})}function Ws({programId:c,nftOwner:e,auth:t,nftAccount:n,lockPda:o,poolId:r,mintLp:i,userVaultA:a,userVaultB:u,poolVaultA:s,poolVaultB:l,mintA:d,mintB:p,lockLpVault:m,lpFeeAmount:f,cpmmProgram:y,cpmmAuthProgram:b}){let g=[{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:e,isSigner:!0,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:y!=null?y:Ho,isSigner:!1,isWritable:!1},{pubkey:b!=null?b:Ca,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:d,isSigner:!1,isWritable:!1},{pubkey:p,isSigner:!1,isWritable:!1},{pubkey:m,isSigner:!1,isWritable:!0},{pubkey:Vn,isSigner:!1,isWritable:!1},{pubkey:Ds,isSigner:!1,isWritable:!1},{pubkey:sn,isSigner:!1,isWritable:!1}],P=V([k("lpFeeAmount")]),h=Buffer.alloc(P.span);P.encode({lpFeeAmount:f},h);let I=Buffer.from([...ro.collectCpFee,...h]);return new io({keys:g,programId:c,data:I})}var Al=V([Ie(8),_("bump"),We("disableCreatePool"),Rt("index"),k("tradeFeeRate"),k("protocolFeeRate"),k("fundFeeRate"),k("createPoolFee"),O("protocolOwner"),O("fundOwner"),Y(k(),16)]),Qr=V([Ie(8),O("configId"),O("poolCreator"),O("vaultA"),O("vaultB"),O("mintLp"),O("mintA"),O("mintB"),O("mintProgramA"),O("mintProgramB"),O("observationId"),_("bump"),_("status"),_("lpDecimals"),_("mintDecimalA"),_("mintDecimalB"),k("lpAmount"),k("protocolFeesMintA"),k("protocolFeesMintB"),k("fundFeesMintA"),k("fundFeesMintB"),k("openTime"),Y(k(),32)]);var Mi=class extends Fe{constructor(e){super(e)}async load(){this.checkDisabled()}async getCpmmPoolKeys(e){return(await this.scope.api.fetchPoolKeysById({idList:[e]}))[0]}async getRpcPoolInfo(e,t){return(await this.getRpcPoolInfos([e],t))[e]}async getRpcPoolInfos(e,t){let n=await Oe(this.scope.connection,e.map(d=>({pubkey:new X(d)}))),o={},r=new Set,i=[];for(let d=0;d<e.length;d++){let p=n[d];if(p.accountInfo===null)throw Error("fetch pool info error: "+String(e[d]));let m=Qr.decode(p.accountInfo.data);o[String(e[d])]=q(N({},m),{programId:p.accountInfo.owner}),r.add(String(m.configId)),i.push(m.vaultA,m.vaultB)}let a={};if(t){let d=[...r],p=await Oe(this.scope.connection,d.map(m=>({pubkey:new X(m)})));for(let m=0;m<d.length;m++){let f=p[m].accountInfo;if(f===null)throw Error("fetch pool config error: "+d[m]);a[d[m]]=Al.decode(f.data)}}let u={},s=await Oe(this.scope.connection,i.map(d=>({pubkey:new X(d)})));for(let d=0;d<i.length;d++){let p=s[d].accountInfo;if(p===null)throw Error("fetch vault info error: "+i[d]);u[String(i[d])]=new Ye(Wp.decode(p.data).amount.toString())}let l={};for(let[d,p]of Object.entries(o)){let m=u[p.vaultA.toString()].sub(p.protocolFeesMintA).sub(p.fundFeesMintA),f=u[p.vaultB.toString()].sub(p.protocolFeesMintB).sub(p.fundFeesMintB);l[d]=q(N({},p),{baseReserve:m,quoteReserve:f,vaultAAmount:u[p.vaultA.toString()],vaultBAmount:u[p.vaultB.toString()],configInfo:a[p.configId.toString()],poolPrice:new qt(f.toString()).div(new qt(10).pow(p.mintDecimalB)).div(new qt(m.toString()).div(new qt(10).pow(p.mintDecimalA)))})}return l}toComputePoolInfos({pools:e,mintInfos:t}){return Object.keys(e).reduce((n,o)=>{var u,s,l,d;let r=e[o],[i,a]=[r.mintA.toBase58(),r.mintB.toBase58()];return q(N({},n),{[o]:q(N({},r),{id:new X(o),configInfo:r.configInfo,version:7,authority:No(r.programId).publicKey,mintA:ft({address:i,decimals:r.mintDecimalA,programId:r.mintProgramA.toBase58(),extensions:{feeConfig:(u=t[i])!=null&&u.feeConfig?Mn((s=t[i])==null?void 0:s.feeConfig):void 0}}),mintB:ft({address:a,decimals:r.mintDecimalB,programId:r.mintProgramB.toBase58(),extensions:{feeConfig:(l=t[a])!=null&&l.feeConfig?Mn((d=t[a])==null?void 0:d.feeConfig):void 0}})})})},{})}async getPoolInfoFromRpc(e){let t=await this.getRpcPoolInfo(e,!0),n=await po({connection:this.scope.connection,mints:[t.mintA,t.mintB]}),o=ft({address:t.mintA.toBase58(),decimals:t.mintDecimalA,programId:t.mintProgramA.toBase58(),extensions:{feeConfig:n[t.mintA.toBase58()].feeConfig?Mn(n[t.mintA.toBase58()].feeConfig):void 0}}),r=ft({address:t.mintB.toBase58(),decimals:t.mintDecimalB,programId:t.mintProgramB.toBase58(),extensions:{feeConfig:n[t.mintB.toBase58()].feeConfig?Mn(n[t.mintB.toBase58()].feeConfig):void 0}}),i=ft({address:t.mintLp.toBase58(),decimals:t.lpDecimals,programId:Mt.toBase58()}),a={id:t.configId.toBase58(),index:t.configInfo.index,protocolFeeRate:t.configInfo.protocolFeeRate.toNumber(),tradeFeeRate:t.configInfo.tradeFeeRate.toNumber(),fundFeeRate:t.configInfo.fundFeeRate.toNumber(),createPoolFee:t.configInfo.createPoolFee.toString()},u={volume:0,volumeQuote:0,volumeFee:0,apr:0,feeApr:0,priceMin:0,priceMax:0,rewardApr:[]};return{poolInfo:{programId:t.programId.toBase58(),id:e,type:"Standard",lpMint:i,lpPrice:0,lpAmount:t.lpAmount.toNumber(),config:a,mintA:o,mintB:r,rewardDefaultInfos:[],rewardDefaultPoolInfos:"Ecosystem",price:t.poolPrice.toNumber(),mintAmountA:new qt(t.vaultAAmount.toString()).div(10**o.decimals).toNumber(),mintAmountB:new qt(t.vaultBAmount.toString()).div(10**r.decimals).toNumber(),feeRate:t.configInfo.tradeFeeRate.toNumber(),openTime:t.openTime.toString(),tvl:0,burnPercent:0,day:u,week:u,month:u,pooltype:[],farmUpcomingCount:0,farmOngoingCount:0,farmFinishedCount:0},poolKeys:{programId:t.programId.toBase58(),id:e,mintA:o,mintB:r,openTime:t.openTime.toString(),vault:{A:t.vaultA.toBase58(),B:t.vaultB.toBase58()},authority:No(t.programId).publicKey.toBase58(),mintLp:i,config:a,observationId:Li(t.programId,new X(e)).publicKey.toBase58()},rpcData:t}}async createPool(f){var y=f,{poolId:e,programId:t,poolFeeAccount:n,startTime:o,ownerInfo:r,associatedOnly:i=!1,checkCreateATAOwner:a=!1,txVersion:u,feeConfig:s,computeBudgetConfig:l,txTipConfig:d,feePayer:p}=y,m=qe(y,["poolId","programId","poolFeeAccount","startTime","ownerInfo","associatedOnly","checkCreateATAOwner","txVersion","feeConfig","computeBudgetConfig","txTipConfig","feePayer"]);var W,z,$;let b=r.feePayer||((W=this.scope.owner)==null?void 0:W.publicKey),g=new Ye(new X(m.mintA.address).toBuffer()).lte(new Ye(new X(m.mintB.address).toBuffer())),[P,h]=g?[m.mintA,m.mintB]:[m.mintB,m.mintA],[I,T]=g?[m.mintAAmount,m.mintBAmount]:[m.mintBAmount,m.mintAAmount],w=r.useSOLBalance&&P.address===Yr.toBase58(),x=r.useSOLBalance&&h.address===Yr.toBase58(),[S,K]=[new X(P.address),new X(h.address)],B=this.createTxBuilder(p),{account:C,instructionParams:M}=await this.scope.account.getOrCreateTokenAccount({mint:S,tokenProgram:P.programId,owner:this.scope.ownerPubKey,createInfo:w?{payer:b,amount:I}:void 0,notUseTokenAccount:w,skipCloseAccount:!w,associatedOnly:w?!1:i,checkCreateATAOwner:a});B.addInstruction(M||{});let{account:F,instructionParams:R}=await this.scope.account.getOrCreateTokenAccount({mint:new X(h.address),tokenProgram:h.programId,owner:this.scope.ownerPubKey,createInfo:x?{payer:b,amount:T}:void 0,notUseTokenAccount:x,skipCloseAccount:!x,associatedOnly:x?!1:i,checkCreateATAOwner:a});if(B.addInstruction(R||{}),C===void 0||F===void 0)throw Error("you don't has some token account");let L=ml({poolId:e,programId:t,configId:new X(s.id),mintA:S,mintB:K});return B.addInstruction({instructions:[pl(t,this.scope.ownerPubKey,new X(s.id),L.authority,L.poolId,S,K,L.lpMint,C,F,j(this.scope.ownerPubKey,L.lpMint).publicKey,L.vaultA,L.vaultB,n,new X((z=P.programId)!=null?z:Mt),new X(($=h.programId)!=null?$:Mt),L.observationId,I,T,o)],instructionTypes:[U.CpmmCreatePool]}),B.addCustomComputeBudget(l),B.addTipInstruction(d),B.versionBuild({txVersion:u,extInfo:{address:q(N({},L),{mintA:P,mintB:h,programId:t,poolFeeAccount:n,feeConfig:s})}})}async addLiquidity(e){let{poolInfo:t,poolKeys:n,inputAmount:o,baseIn:r,slippage:i,computeResult:a,computeBudgetConfig:u,txTipConfig:s,config:l,txVersion:d,feePayer:p}=e;this.scope.availability.addStandardPosition===!1&&this.logAndCreateError("add liquidity feature disabled in your region"),o.isZero()&&this.logAndCreateError("amounts must greater than zero","amountInA",{amountInA:o.toString()});let{account:m}=this.scope,{bypassAssociatedCheck:f,checkCreateATAOwner:y}=N({bypassAssociatedCheck:!1,checkCreateATAOwner:!1},l),b=a?void 0:await this.getRpcPoolInfo(t.id),{liquidity:g,inputAmountFee:P,anotherAmount:h}=a||this.computePairAmount({poolInfo:q(N({},t),{lpAmount:new qt(b.lpAmount.toString()).div(10**t.lpMint.decimals).toNumber()}),baseReserve:b.baseReserve,quoteReserve:b.quoteReserve,slippage:new it(0),baseIn:r,epochInfo:await this.scope.fetchEpochInfo(),amount:new qt(o.toString()).div(10**(r?t.mintA.decimals:t.mintB.decimals))}),I=h.amount,T=t.mintA.address===Yr.toString(),w=t.mintB.address===Yr.toString(),x=this.createTxBuilder(p),[S,K]=[new X(t.mintA.address),new X(t.mintB.address)],{account:B,instructionParams:C}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:t.mintA.programId,mint:new X(t.mintA.address),owner:this.scope.ownerPubKey,createInfo:T||(r?o:I).isZero()?{payer:this.scope.ownerPubKey,amount:r?o:I}:void 0,skipCloseAccount:!T,notUseTokenAccount:T,associatedOnly:!1,checkCreateATAOwner:y});x.addInstruction(C||{});let{account:M,instructionParams:F}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:t.mintB.programId,mint:new X(t.mintB.address),owner:this.scope.ownerPubKey,createInfo:w||(r?I:o).isZero()?{payer:this.scope.ownerPubKey,amount:r?I:o}:void 0,skipCloseAccount:!w,notUseTokenAccount:w,associatedOnly:!1,checkCreateATAOwner:y});x.addInstruction(F||{}),!B&&!M&&this.logAndCreateError("cannot found target token accounts","tokenAccounts",m.tokenAccounts);let R=await m.getCreatedTokenAccount({mint:new X(t.lpMint.address)}),ae=await m.handleTokenAccount({side:"out",amount:0,mint:new X(t.lpMint.address),tokenAccount:R,bypassAssociatedCheck:f,checkCreateATAOwner:y}),{tokenAccount:L}=ae,W=qe(ae,["tokenAccount"]);x.addInstruction(W);let z=n!=null?n:await this.getCpmmPoolKeys(t.id),$=new it(new Ye(1)).sub(i);return x.addInstruction({instructions:[fl(new X(t.programId),this.scope.ownerPubKey,new X(z.authority),new X(t.id),L,B,M,new X(z.vault.A),new X(z.vault.B),S,K,new X(t.lpMint.address),a?a==null?void 0:a.liquidity:$.mul(g).quotient,r?P.amount:I,r?I:P.amount)],instructionTypes:[U.CpmmAddLiquidity],lookupTableAddress:z.lookupTableAccount?[z.lookupTableAccount]:[]}),x.addCustomComputeBudget(u),x.addTipInstruction(s),x.versionBuild({txVersion:d})}async withdrawLiquidity(e){var W,z;let{poolInfo:t,poolKeys:n,lpAmount:o,slippage:r,computeBudgetConfig:i,txTipConfig:a,txVersion:u,feePayer:s,closeWsol:l=!0}=e;this.scope.availability.addStandardPosition===!1&&this.logAndCreateError("add liquidity feature disabled in your region");let d=new it(new Ye(1)).sub(r),p=await this.getRpcPoolInfo(t.id),[m,f]=[d.mul(o.mul(p.baseReserve).div(p.lpAmount)).quotient,d.mul(o.mul(p.quoteReserve).div(p.lpAmount)).quotient],y=await this.scope.fetchEpochInfo(),[b,g]=[he(m,t.mintA.extensions.feeConfig,y,!1),he(f,t.mintB.extensions.feeConfig,y,!1)],{account:P}=this.scope,h=this.createTxBuilder(s),[I,T]=[new X(t.mintA.address),new X(t.mintB.address)],w=I.equals(H),x=T.equals(H),S,K,{account:B,instructionParams:C}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:t.mintA.programId,mint:new X(t.mintA.address),notUseTokenAccount:w,owner:this.scope.ownerPubKey,createInfo:{payer:this.scope.ownerPubKey,amount:0},skipCloseAccount:!(w&&l),associatedOnly:!w,checkCreateATAOwner:!1});S=B,C&&h.addInstruction(C);let{account:M,instructionParams:F}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:t.mintB.programId,mint:new X(t.mintB.address),notUseTokenAccount:x,owner:this.scope.ownerPubKey,createInfo:{payer:this.scope.ownerPubKey,amount:0},skipCloseAccount:!(x&&l),associatedOnly:!x,checkCreateATAOwner:!1});K=M,F&&h.addInstruction(F),(!S||!K)&&this.logAndCreateError("cannot found target token accounts","tokenAccounts",P.tokenAccounts);let R=await P.getCreatedTokenAccount({mint:new X(t.lpMint.address)});R||this.logAndCreateError("cannot found lp token account","tokenAccounts",P.tokenAccounts);let L=n!=null?n:await this.getCpmmPoolKeys(t.id);return h.addInstruction({instructions:[yl(new X(t.programId),this.scope.ownerPubKey,new X(L.authority),new X(t.id),R,S,K,new X(L.vault.A),new X(L.vault.B),I,T,new X(t.lpMint.address),o,m.sub((W=b.fee)!=null?W:new Ye(0)),f.sub((z=g.fee)!=null?z:new Ye(0)))],instructionTypes:[U.CpmmWithdrawLiquidity],lookupTableAddress:L.lookupTableAccount?[L.lookupTableAccount]:[]}),h.addCustomComputeBudget(i),h.addTipInstruction(a),h.versionBuild({txVersion:u})}async swap(e){var C,M,F,R,L,W;let{poolInfo:t,poolKeys:n,baseIn:o,fixedOut:r,inputAmount:i,swapResult:a,slippage:u=0,config:s,computeBudgetConfig:l,txTipConfig:d,txVersion:p,feePayer:m}=e,{bypassAssociatedCheck:f,checkCreateATAOwner:y,associatedOnly:b}=N({bypassAssociatedCheck:!1,checkCreateATAOwner:!1,associatedOnly:!0},s),g=this.createTxBuilder(m),[P,h]=[new X(t.mintA.address),new X(t.mintB.address)];r?a.sourceAmountSwapped=a.sourceAmountSwapped.mul(new Ye((1+u)*1e4)).div(new Ye(1e4)):a.destinationAmountSwapped=a.destinationAmountSwapped.mul(new Ye((1-u)*1e4)).div(new Ye(1e4));let I=t.mintA.address===H.toBase58(),T=t.mintB.address===H.toBase58(),{account:w,instructionParams:x}=await this.scope.account.getOrCreateTokenAccount({mint:P,tokenProgram:new X((C=t.mintA.programId)!=null?C:Mt),owner:this.scope.ownerPubKey,createInfo:I||!o?{payer:this.scope.ownerPubKey,amount:o?a.sourceAmountSwapped:0}:void 0,notUseTokenAccount:I,skipCloseAccount:!I,associatedOnly:I?!1:b,checkCreateATAOwner:y});x&&g.addInstruction(x);let{account:S,instructionParams:K}=await this.scope.account.getOrCreateTokenAccount({mint:h,tokenProgram:new X((M=t.mintB.programId)!=null?M:Mt),owner:this.scope.ownerPubKey,createInfo:T||o?{payer:this.scope.ownerPubKey,amount:o?0:a.sourceAmountSwapped}:void 0,notUseTokenAccount:T,skipCloseAccount:!T,associatedOnly:T?!1:b,checkCreateATAOwner:y});K&&g.addInstruction(K),(!w||!S)&&this.logAndCreateError("user do not have token account",{mintA:t.mintA.symbol||t.mintA.address,mintB:t.mintB.symbol||t.mintB.address,mintATokenAcc:w,mintBTokenAcc:S,mintAUseSOLBalance:I,mintBUseSOLBalance:T,associatedOnly:b});let B=n!=null?n:await this.getCpmmPoolKeys(t.id);return g.addInstruction({instructions:[r?bl(new X(t.programId),this.scope.ownerPubKey,new X(B.authority),new X(B.config.id),new X(t.id),o?w:S,o?S:w,new X(B.vault[o?"A":"B"]),new X(B.vault[o?"B":"A"]),new X((L=t[o?"mintA":"mintB"].programId)!=null?L:Mt),new X((W=t[o?"mintB":"mintA"].programId)!=null?W:Mt),o?P:h,o?h:P,Li(new X(t.programId),new X(t.id)).publicKey,a.sourceAmountSwapped,a.destinationAmountSwapped):zr(new X(t.programId),this.scope.ownerPubKey,new X(B.authority),new X(B.config.id),new X(t.id),o?w:S,o?S:w,new X(B.vault[o?"A":"B"]),new X(B.vault[o?"B":"A"]),new X((F=t[o?"mintA":"mintB"].programId)!=null?F:Mt),new X((R=t[o?"mintB":"mintA"].programId)!=null?R:Mt),o?P:h,o?h:P,Li(new X(t.programId),new X(t.id)).publicKey,i,a.destinationAmountSwapped)],instructionTypes:[r?U.CpmmSwapBaseOut:U.ClmmSwapBaseIn]}),g.addCustomComputeBudget(l),g.addTipInstruction(d),g.versionBuild({txVersion:p})}async lockLp(e){var p,m,f,y,b;let{poolInfo:t,lpAmount:n,computeBudgetConfig:o,txTipConfig:r,txVersion:i,feePayer:a,feeNftOwner:u}=e;n.isZero()&&this.logAndCreateError("lpAmount must greater than zero",{lpAmount:n.toString()});let s=this.createTxBuilder(a),l=(p=e.poolKeys)!=null?p:await this.getCpmmPoolKeys(t.id),d=await gl({poolInfo:t,poolKeys:l,ownerInfo:{wallet:this.scope.ownerPubKey,feePayer:(m=e.feePayer)!=null?m:this.scope.ownerPubKey},feeNftOwner:u!=null?u:this.scope.ownerPubKey,lockProgram:(f=e.programId)!=null?f:Zo,lockAuthProgram:(y=e.authProgram)!=null?y:$o,lpAmount:n,withMetadata:(b=e.withMetadata)!=null?b:!0,getEphemeralSigners:e.getEphemeralSigners});return s.addInstruction(d),s.addCustomComputeBudget(o),s.addTipInstruction(r),s.versionBuild({txVersion:i,extInfo:d.address})}async harvestLockLp(e){var M;let{poolInfo:t,lpFeeAmount:n,nftMint:o,programId:r=Zo,authProgram:i=$o,cpmmProgram:a,computeBudgetConfig:u,txTipConfig:s,txVersion:l,closeWsol:d=!0}=e;n.isZero()&&this.logAndCreateError("lpFeeAmount must greater than zero",{lpAmount:n.toString()});let p=e.feePayer||this.scope.ownerPubKey,m=this.createTxBuilder(p),[f,y]=[new X(t.mintA.address),new X(t.mintB.address)],b=f.equals(H),g=y.equals(H),P,h,{account:I,instructionParams:T}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:t.mintA.programId,mint:new X(t.mintA.address),notUseTokenAccount:b,owner:this.scope.ownerPubKey,createInfo:{payer:this.scope.ownerPubKey,amount:0},skipCloseAccount:!(b&&d),associatedOnly:!b,checkCreateATAOwner:!1});P=I,T&&m.addInstruction(T);let{account:w,instructionParams:x}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:t.mintB.programId,mint:new X(t.mintB.address),notUseTokenAccount:g,owner:this.scope.ownerPubKey,createInfo:{payer:this.scope.ownerPubKey,amount:0},skipCloseAccount:!(g&&d),associatedOnly:!g,checkCreateATAOwner:!1});h=w,x&&m.addInstruction(x),(!P||!h)&&this.logAndCreateError("cannot found target token accounts",{tokenAccountA:P,tokenAccountB:h});let S=(M=e.poolKeys)!=null?M:await this.getCpmmPoolKeys(t.id),{publicKey:K}=j(p,o,Mt),{publicKey:B}=Oi(r,o),{publicKey:C}=j(i,new X(t.lpMint.address),Mt);return m.addInstruction({instructions:[Ws({programId:r,nftOwner:this.scope.ownerPubKey,auth:i,nftMint:o,nftAccount:K,lockPda:B,poolId:new X(t.id),mintLp:new X(S.mintLp.address),userVaultA:P,userVaultB:h,poolVaultA:new X(S.vault.A),poolVaultB:new X(S.vault.B),mintA:f,mintB:y,lockLpVault:C,lpFeeAmount:n,cpmmProgram:a==null?void 0:a.programId,cpmmAuthProgram:a==null?void 0:a.authProgram})],instructionTypes:[U.CpmmCollectLockFee]}),m.addCustomComputeBudget(u),m.addTipInstruction(s),m.versionBuild({txVersion:l})}async harvestMultiLockLp(e){let{lockInfo:t,programId:n=Zo,authProgram:o=$o,cpmmProgram:r,computeBudgetConfig:i,txVersion:a,closeWsol:u=!0}=e,s=e.feePayer||this.scope.ownerPubKey,l=this.createTxBuilder(s),d={};return t.forEach(async p=>{var B;let{poolInfo:m,lpFeeAmount:f,nftMint:y}=p;if(f.isZero())return;let[b,g]=[new X(m.mintA.address),new X(m.mintB.address)],P=b.equals(H),h=g.equals(H),I=d[m.mintA.address],T=d[m.mintB.address];if(!I)if(P){let{account:C,instructionParams:M}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:m.mintA.programId,mint:new X(m.mintA.address),notUseTokenAccount:!0,owner:this.scope.ownerPubKey,createInfo:{payer:this.scope.ownerPubKey,amount:0},skipCloseAccount:!u,associatedOnly:!1,checkCreateATAOwner:!1});I=C,M&&l.addInstruction(M),d[m.mintA.address]=C}else{let C=new X(m.mintA.address);I=this.scope.account.getAssociatedTokenAccount(C,new X(m.mintA.programId)),l.addInstruction({instructions:[Pl(this.scope.ownerPubKey,I,this.scope.ownerPubKey,C)]}),d[m.mintA.address]=I}if(!T)if(h){let{account:C,instructionParams:M}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:m.mintB.programId,mint:new X(m.mintB.address),notUseTokenAccount:!0,owner:this.scope.ownerPubKey,createInfo:{payer:this.scope.ownerPubKey,amount:0},skipCloseAccount:!u,associatedOnly:!1,checkCreateATAOwner:!1});T=C,M&&l.addInstruction(M),d[m.mintB.address]=C}else{let C=new X(m.mintB.address);T=this.scope.account.getAssociatedTokenAccount(C,new X(m.mintB.programId)),l.addInstruction({instructions:[Pl(this.scope.ownerPubKey,T,this.scope.ownerPubKey,C)]}),d[m.mintB.address]=T}(!I||!T)&&this.logAndCreateError("cannot found target token accounts",{tokenAccountA:I,tokenAccountB:T});let w=(B=p.poolKeys)!=null?B:await this.getCpmmPoolKeys(m.id),{publicKey:x}=j(s,y,Mt),{publicKey:S}=Oi(n,y),{publicKey:K}=j(o,new X(m.lpMint.address),Mt);l.addInstruction({instructions:[Ws({programId:n,nftOwner:this.scope.ownerPubKey,auth:o,nftMint:y,nftAccount:x,lockPda:S,poolId:new X(m.id),mintLp:new X(w.mintLp.address),userVaultA:I,userVaultB:T,poolVaultA:new X(w.vault.A),poolVaultB:new X(w.vault.B),mintA:b,mintB:g,lockLpVault:K,lpFeeAmount:f,cpmmProgram:r==null?void 0:r.programId,cpmmAuthProgram:r==null?void 0:r.authProgram})],instructionTypes:[U.CpmmCollectLockFee]})}),a===0?l.sizeCheckBuildV0({computeBudgetConfig:i}):l.sizeCheckBuild({computeBudgetConfig:i})}computeSwapAmount({pool:e,amountIn:t,outputMint:n,slippage:o}){let r=n.toString()===e.mintB.address,i=Xr.swap(t,r?e.baseReserve:e.quoteReserve,r?e.quoteReserve:e.baseReserve,e.configInfo.tradeFeeRate),a=new qt(i.destinationAmountSwapped.toString()).div(i.sourceAmountSwapped.toString()),u=i.destinationAmountSwapped.mul(new Ye((1-o)*1e4)).div(new Ye(1e4));return{allTrade:i.sourceAmountSwapped.eq(t),amountIn:t,amountOut:i.destinationAmountSwapped,minAmountOut:u,executionPrice:a,fee:i.tradeFee,priceImpact:e.poolPrice.sub(a).div(e.poolPrice)}}computePairAmount({poolInfo:e,baseReserve:t,quoteReserve:n,amount:o,slippage:r,epochInfo:i,baseIn:a}){var I,T,w,x,S,K,B,C,M;let u=1-Number(r.toSignificant())/100,s=new Ye(new qt(o).mul(10**e[a?"mintA":"mintB"].decimals).mul(u).toFixed(0)),l=he(s,e[a?"mintA":"mintB"].extensions.feeConfig,i,!1),d=s.sub((I=l.fee)!=null?I:new Ye(0)),p=new Ye(new qt(e.lpAmount).mul(10**e.lpMint.decimals).toFixed(0,qt.ROUND_DOWN));this.logDebug("baseReserve:",t.toString(),"quoteReserve:",n.toString()),this.logDebug("tokenIn:",a?e.mintA.symbol:e.mintB.symbol,"amountIn:",s.toString(),"amountInFee:",(w=(T=l.fee)==null?void 0:T.toString())!=null?w:0,"anotherToken:",a?e.mintB.symbol:e.mintA.symbol,"slippage:",`${r.toSignificant()}%`);let m=a?"base":"quote";this.logDebug("input side:",m);let f=d.mul(p).div(m==="base"?t:n),y={amount:It,fee:void 0,expirationTime:void 0};if(!d.isZero()){let F=qp(f,t,n,p);this.logDebug("lpAmountData:",{amountA:F.amountA.toString(),amountB:F.amountB.toString()}),y=he(F[a?"amountB":"amountA"],e[a?"mintB":"mintA"].extensions.feeConfig,i,!0)}let b=new it(new Ye(1)).add(r),g=new it(new Ye(1)).sub(r),P=he(b.mul(y.amount.sub((x=y.fee)!=null?x:new Ye(0))).quotient,e[a?"mintB":"mintA"].extensions.feeConfig,i,!0),h=he(g.mul(y.amount.sub((S=y.fee)!=null?S:new Ye(0))).quotient,e[a?"mintB":"mintA"].extensions.feeConfig,i,!0);return this.logDebug("anotherAmount:",y.amount.toString(),"anotherAmountFee:",(B=(K=y.fee)==null?void 0:K.toString())!=null?B:0,"maxAnotherAmount:",P.amount.toString(),"maxAnotherAmountFee:",(M=(C=P.fee)==null?void 0:C.toString())!=null?M:0),{inputAmountFee:l,anotherAmount:y,maxAnotherAmount:P,minAnotherAmount:h,liquidity:f}}};function qp(c,e,t,n){let o=c.mul(e).div(n);!o.isZero()&&!c.mul(e).mod(n).isZero()&&(o=o.add(new Ye(1)));let r=c.mul(t).div(n);return!r.isZero()&&!c.mul(t).mod(n).isZero()&&(r=r.add(new Ye(1))),{amountA:o,amountB:r}}import{PublicKey as ao}from"@solana/web3.js";import{createTransferInstruction as Bl,TOKEN_PROGRAM_ID as je,TOKEN_2022_PROGRAM_ID as Zr}from"@solana/spl-token";import $r from"bn.js";import Vi from"decimal.js";var kl={[cr.toBase58()]:3},wl={3:cr};var qs=V([Ie(5),Ie(8),O("ownAddress"),k("vaultSignerNonce"),O("baseMint"),O("quoteMint"),O("baseVault"),k("baseDepositsTotal"),k("baseFeesAccrued"),O("quoteVault"),k("quoteDepositsTotal"),k("quoteFeesAccrued"),k("quoteDustThreshold"),O("requestQueue"),O("eventQueue"),O("bids"),O("asks"),k("baseLotSize"),k("quoteLotSize"),k("feeRateBps"),k("referrerRebatesAccrued"),Ie(7)]),Tl={3:qs};import{PublicKey as hl}from"@solana/web3.js";var jr=fe("Serum"),Hr=class{static getProgramId(e){let t=wl[e];return t||jr.logWithError("invalid version","version",e),t}static getVersion(e){let t=e.toBase58(),n=kl[t];return n||jr.logWithError("invalid program id","programId",t),n}static getStateLayout(e){let t=Tl[e];return t||jr.logWithError(!!t,"invalid version","version",e),t}static getLayouts(e){return{state:this.getStateLayout(e)}}static getAssociatedAuthority({programId:e,marketId:t}){let n=[t.toBuffer()],o=0,r;for(;o<100;){try{let i=n.concat(Buffer.from([o]),Buffer.alloc(7));r=hl.createProgramAddressSync(i,e)}catch(i){if(i instanceof TypeError)throw i;o++;continue}return{publicKey:r,nonce:o}}return jr.logWithError("unable to find a viable program address nonce","params",{programId:e,marketId:t}),{publicKey:hl.default,nonce:o}}};import{PublicKey as v,SystemProgram as vi,TransactionInstruction as Fi}from"@solana/web3.js";import dn from"bn.js";import{ASSOCIATED_TOKEN_PROGRAM_ID as Us,TOKEN_2022_PROGRAM_ID as Gs,TOKEN_PROGRAM_ID as _n}from"@solana/spl-token";function CS(c,e,t,n,o,r,i,a,u,s,l,d){let p=V([_("instruction"),k("amountIn"),k("amountOut")]),m=[{pubkey:vi.programId,isSigner:!1,isWritable:!1},{pubkey:_n,isSigner:!1,isWritable:!1},{pubkey:new v(t.programId),isSigner:!1,isWritable:!1},{pubkey:new v(t.id),isSigner:!1,isWritable:!0},{pubkey:new v(n.id),isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!0,isWritable:!1}];if(e.type==="Concentrated"){let y=Me(t);m.push({pubkey:y.config.id,isSigner:!1,isWritable:!1},{pubkey:y.id,isSigner:!1,isWritable:!0},{pubkey:y.mintA.address.equals(u)?y.vault.A:y.vault.B,isSigner:!1,isWritable:!0},{pubkey:y.mintA.address.equals(u)?y.vault.B:y.vault.A,isSigner:!1,isWritable:!0},{pubkey:y.id,isSigner:!1,isWritable:!0},...d.map(b=>({pubkey:b,isSigner:!1,isWritable:!0})))}else if(e.pooltype.includes("StablePool")){let y=Me(t);m.push({pubkey:y.authority,isSigner:!1,isWritable:!1},{pubkey:y.marketProgramId,isSigner:!1,isWritable:!1},{pubkey:y.id,isSigner:!1,isWritable:!0},{pubkey:new v("CDSr3ssLcRB6XYPJwAfFt18MZvEZp4LjHcvzBVZ45duo"),isSigner:!1,isWritable:!1},{pubkey:y.openOrders,isSigner:!1,isWritable:!0},{pubkey:y.vault.A,isSigner:!1,isWritable:!0},{pubkey:y.vault.B,isSigner:!1,isWritable:!0},{pubkey:y.marketId,isSigner:!1,isWritable:!0},{pubkey:y.marketBids,isSigner:!1,isWritable:!0},{pubkey:y.marketAsks,isSigner:!1,isWritable:!0},{pubkey:y.marketEventQueue,isSigner:!1,isWritable:!0},{pubkey:y.id,isSigner:!1,isWritable:!0},{pubkey:y.id,isSigner:!1,isWritable:!0})}else{let y=Me(t);m.push({pubkey:y.authority,isSigner:!1,isWritable:!1},{pubkey:y.marketProgramId,isSigner:!1,isWritable:!1},{pubkey:y.marketAuthority,isSigner:!1,isWritable:!1},{pubkey:y.openOrders,isSigner:!1,isWritable:!0},{pubkey:y.vault.A,isSigner:!1,isWritable:!0},{pubkey:y.vault.B,isSigner:!1,isWritable:!0},{pubkey:y.marketId,isSigner:!1,isWritable:!0},{pubkey:y.marketBids,isSigner:!1,isWritable:!0},{pubkey:y.marketAsks,isSigner:!1,isWritable:!0},{pubkey:y.marketEventQueue,isSigner:!1,isWritable:!0},...y.marketProgramId.toString()==="srmqPvymJeFKQ4zGQed1GFppgkRHL9kaELCbyksJtPX"?[{pubkey:y.marketBaseVault,isSigner:!1,isWritable:!0},{pubkey:y.marketQuoteVault,isSigner:!1,isWritable:!0}]:[{pubkey:y.id,isSigner:!1,isWritable:!0},{pubkey:y.id,isSigner:!1,isWritable:!0}])}let f=Buffer.alloc(p.span);return p.encode({instruction:4,amountIn:s,amountOut:l},f),new Fi({keys:m,programId:c,data:f})}function RS(c,e,t,n,o,r,i,a,u,s){let l=V([_("instruction")]),d=[{pubkey:vi.programId,isSigner:!1,isWritable:!1},{pubkey:_n,isSigner:!1,isWritable:!1},{pubkey:new v(String(n.programId)),isSigner:!1,isWritable:!1},{pubkey:new v(String(n.id)),isSigner:!1,isWritable:!0},{pubkey:new v(String(t.id)),isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!0,isWritable:!1}];if(e.type==="Concentrated"){let m=Me(n);d.push({pubkey:m.config.id,isSigner:!1,isWritable:!1},{pubkey:m.id,isSigner:!1,isWritable:!0},{pubkey:m.mintA.address.equals(u)?m.vault.A:m.vault.B,isSigner:!1,isWritable:!0},{pubkey:m.mintA.address.equals(u)?m.vault.B:m.vault.A,isSigner:!1,isWritable:!0},{pubkey:m.id,isSigner:!1,isWritable:!0},...s.map(f=>({pubkey:f,isSigner:!1,isWritable:!0})))}else if(e.pooltype.includes("StablePool")){let m=Me(n);d.push({pubkey:m.authority,isSigner:!1,isWritable:!1},{pubkey:m.marketProgramId,isSigner:!1,isWritable:!1},{pubkey:m.id,isSigner:!1,isWritable:!0},{pubkey:new v("CDSr3ssLcRB6XYPJwAfFt18MZvEZp4LjHcvzBVZ45duo"),isSigner:!1,isWritable:!1},{pubkey:m.openOrders,isSigner:!1,isWritable:!0},{pubkey:m.vault.A,isSigner:!1,isWritable:!0},{pubkey:m.vault.B,isSigner:!1,isWritable:!0},{pubkey:m.marketId,isSigner:!1,isWritable:!0},{pubkey:m.marketBids,isSigner:!1,isWritable:!0},{pubkey:m.marketAsks,isSigner:!1,isWritable:!0},{pubkey:m.marketEventQueue,isSigner:!1,isWritable:!0},{pubkey:m.id,isSigner:!1,isWritable:!0},{pubkey:m.id,isSigner:!1,isWritable:!0})}else{let m=Me(n);d.push({pubkey:m.authority,isSigner:!1,isWritable:!1},{pubkey:m.marketProgramId,isSigner:!1,isWritable:!1},{pubkey:m.marketAuthority,isSigner:!1,isWritable:!1},{pubkey:m.openOrders,isSigner:!1,isWritable:!0},{pubkey:m.vault.A,isSigner:!1,isWritable:!0},{pubkey:m.vault.B,isSigner:!1,isWritable:!0},{pubkey:m.marketId,isSigner:!1,isWritable:!0},{pubkey:m.marketBids,isSigner:!1,isWritable:!0},{pubkey:m.marketAsks,isSigner:!1,isWritable:!0},{pubkey:m.marketEventQueue,isSigner:!1,isWritable:!0},...m.marketProgramId.toString()==="srmqPvymJeFKQ4zGQed1GFppgkRHL9kaELCbyksJtPX"?[{pubkey:m.marketBaseVault,isSigner:!1,isWritable:!0},{pubkey:m.marketQuoteVault,isSigner:!1,isWritable:!0}]:[{pubkey:m.id,isSigner:!1,isWritable:!0},{pubkey:m.id,isSigner:!1,isWritable:!0}])}let p=Buffer.alloc(l.span);return l.encode({instruction:5},p),new Fi({keys:d,programId:c,data:p})}function Up(c,e,t,n,o,r,i,a,u,s,l,d,p,m,f){var w;let y=[],b=[A({pubkey:_n,isWritable:!1}),A({pubkey:Gs,isWritable:!1}),A({pubkey:Us,isWritable:!1}),A({pubkey:vi.programId,isWritable:!1}),A({pubkey:e,isSigner:!0})];b.push(A({pubkey:t})),b.push(A({pubkey:o}));let g=[u,s],P=[l,d],h=[r,i,a];for(let x=0;x<g.length;x++){let S=g[x],K=h[x]===S.mintA.address;if(b.push(A({pubkey:new v(S.programId),isWritable:!1})),x===g.length-1?b.push(A({pubkey:o})):b.push(A({pubkey:n})),b.push(A({pubkey:new v(h[x])})),b.push(A({pubkey:new v(h[x+1])})),S.version===6){let B=P[x];b.push(A({pubkey:new v(B.config.id)})),b.push(A({pubkey:new v(B.id)})),b.push(A({pubkey:new v(K?B.vault.A:B.vault.B)})),b.push(A({pubkey:new v(K?B.vault.B:B.vault.A)})),b.push(A({pubkey:new v(S.observationId)})),b.push(A({pubkey:sn})),b.push(A({pubkey:Qe(new v(S.programId),new v(S.id)).publicKey})),y.push(Xs(S.sqrtPriceX64.toString(),K));for(let C of(w=f[x])!=null?w:[])b.push(A({pubkey:new v(C)}))}else if(S.version===5){let B=P[x];b.push(A({pubkey:new v(B.id)})),b.push(A({pubkey:new v(B.authority),isWritable:!1})),b.push(A({pubkey:new v(B.marketProgramId)})),b.push(A({pubkey:new v(B.marketAuthority)})),b.push(A({pubkey:lr,isWritable:!1})),b.push(A({pubkey:new v(B.openOrders)})),b.push(A({pubkey:new v(B.vault.A)})),b.push(A({pubkey:new v(B.vault.B)})),b.push(A({pubkey:new v(B.id)})),b.push(A({pubkey:new v(B.id)})),b.push(A({pubkey:new v(B.id)})),b.push(A({pubkey:new v(B.id)})),b.push(A({pubkey:new v(B.id)})),b.push(A({pubkey:new v(B.id)})),b.push(A({pubkey:new v(B.marketId)})),b.push(A({pubkey:new v(B.marketBids)})),b.push(A({pubkey:new v(B.marketAsks)})),b.push(A({pubkey:new v(B.marketEventQueue)})),b.push(A({pubkey:new v(B.marketBaseVault)})),b.push(A({pubkey:new v(B.marketQuoteVault)}))}else if(S.version===4){let B=P[x],C=S.status!==1;b.push(A({pubkey:new v(B.id)})),b.push(A({pubkey:new v(B.authority),isWritable:!1})),b.push(A({pubkey:new v(C?B.id:B.marketProgramId)})),b.push(A({pubkey:new v(C?B.id:B.marketAuthority)})),b.push(A({pubkey:new v(C?B.id:B.openOrders)})),b.push(A({pubkey:new v(B.vault.A)})),b.push(A({pubkey:new v(B.vault.B)})),b.push(A({pubkey:new v(C?B.id:B.marketId)})),b.push(A({pubkey:new v(C?B.id:B.marketBids)})),b.push(A({pubkey:new v(C?B.id:B.marketAsks)})),b.push(A({pubkey:new v(C?B.id:B.marketEventQueue)})),b.push(A({pubkey:new v(C?B.id:B.marketBaseVault)})),b.push(A({pubkey:new v(C?B.id:B.marketQuoteVault)}))}else if(S.version===7){let B=P[x];b.push(A({pubkey:new v(B.authority)})),b.push(A({pubkey:new v(B.config.id)})),b.push(A({pubkey:new v(B.id)})),b.push(A({pubkey:new v(K?B.vault.A:B.vault.B)})),b.push(A({pubkey:new v(K?B.vault.B:B.vault.A)})),b.push(A({pubkey:new v(S.observationId)}))}else throw Error("pool type error")}let I=V([_("insId"),k("amountIn"),k("amountOut"),Y(te(),y.length,"clmmPriceLimit")]),T=Buffer.alloc(I.span);return I.encode({insId:0,amountIn:p,amountOut:m,clmmPriceLimit:y},T),new Fi({keys:b,programId:c,data:T})}function Xs(c,e){if(c)if(e){let t=new dn(c).div(new dn(25));return t.gt(Sr)?t:Sr}else{let t=new dn(c).mul(new dn(25));return t.lt(Kr)?t:Kr}else return e?Sr:Kr}function Il({routeProgram:c,ownerInfo:e,inputMint:t,swapInfo:n}){var o,r,i,a,u,s,l;if(n.routeType==="amm")if(n.poolInfo[0].version===6){let d=n.poolKey[0],p=Me(d),m=t.equals(p.mintA.address)?Dt.add(Lt):Wt.sub(Lt);return Ce.makeSwapBaseInInstructions({poolInfo:d,poolKeys:d,observationId:n.poolInfo[0].observationId,ownerInfo:{wallet:e.wallet,tokenAccountA:p.mintA.address.equals(t)?e.sourceToken:e.destinationToken,tokenAccountB:p.mintA.address.equals(t)?e.destinationToken:e.sourceToken},inputMint:t,amountIn:n.amountIn.amount.raw,amountOutMin:n.minAmountOut.amount.raw.sub((r=(o=n.minAmountOut.fee)==null?void 0:o.raw)!=null?r:new dn(0)),sqrtPriceLimitX64:m,remainingAccounts:(i=n.remainingAccounts[0])!=null?i:[]})}else if(n.poolInfo[0].version===7){let d=n.poolInfo[0],p=t.toString()===n.poolInfo[0].mintA.address;return{signers:[],instructions:[zr(d.programId,e.wallet,d.authority,d.configId,d.id,e.sourceToken,e.destinationToken,p?d.vaultA:d.vaultB,p?d.vaultB:d.vaultA,p?d.mintProgramA:d.mintProgramB,p?d.mintProgramB:d.mintProgramA,new v(d[p?"mintA":"mintB"].address),new v(d[p?"mintB":"mintA"].address),d.observationId,n.amountIn.amount.raw,n.minAmountOut.amount.raw)],lookupTableAddress:[],instructionTypes:[p?U.CpmmSwapBaseIn:U.CpmmSwapBaseOut],address:{}}}else{let d=n.poolKey[0];return{signers:[],instructions:[vr({poolKeys:d,version:n.poolInfo[0].pooltype.includes("StablePool")?5:4,userKeys:{tokenAccountIn:e.sourceToken,tokenAccountOut:e.destinationToken,owner:e.wallet},amountIn:n.amountIn.amount.raw,amountOut:n.minAmountOut.amount.raw.sub((u=(a=n.minAmountOut.fee)==null?void 0:a.raw)!=null?u:new dn(0)),fixedSide:"in"})],lookupTableAddress:d.lookupTableAccount?[d.lookupTableAccount]:[],instructionTypes:[n.poolInfo[0].pooltype.includes("StablePool")?U.AmmV5SwapBaseIn:U.AmmV4SwapBaseIn],address:{}}}else if(n.routeType==="route"){let d=n.poolInfo[0],p=n.poolInfo[1],m=n.poolKey[0],f=n.poolKey[1];if(e.routeToken===void 0)throw Error("owner route token account check error");return{signers:[],instructions:[Up(c,e.wallet,e.sourceToken,e.routeToken,e.destinationToken,t.toString(),n.middleToken.mint.toString(),n.outputMint.toString(),d,p,m,f,n.amountIn.amount.raw,n.minAmountOut.amount.raw.sub((l=(s=n.minAmountOut.fee)==null?void 0:s.raw)!=null?l:new dn(0)),n.remainingAccounts)],instructionTypes:[U.RouteSwap],lookupTableAddress:[m.lookupTableAccount,f.lookupTableAccount].filter(y=>y!==void 0),address:{}}}else throw Error("route type error")}function LS({programId:c,wallet:e,amount:t,inputAccount:n,outputAccount:o,routeInfo:r,poolKeys:i}){var p;if(r.success===!1)throw Error("route info error");let a=[],u=[A({pubkey:_n,isWritable:!1}),A({pubkey:Gs,isWritable:!1}),A({pubkey:Us,isWritable:!1}),A({pubkey:vi.programId,isWritable:!1}),A({pubkey:e,isSigner:!0})],s={[r.data.inputMint]:n,[r.data.outputMint]:o};u.push(A({pubkey:s[r.data.inputMint]})),u.push(A({pubkey:s[r.data.outputMint]}));for(let m=0;m<i.length;m++){let f=r.data.routePlan[m],y=i[m],b=f.inputMint===y.mintA.address;if(u.push(A({pubkey:new v(y.programId),isWritable:!1})),m===i.length-1)u.push(A({pubkey:s[f.outputMint]}));else{let g=f.outputMint;if(s[g]===void 0){let P=j(e,new v(g),y.programId===gt.CLMM_PROGRAM_ID.toBase58()||y.programId===gt.CREATE_CPMM_POOL_PROGRAM.toBase58()?new v(b?y.mintB.programId:y.mintA.programId):_n).publicKey;s[g]=P}u.push(A({pubkey:s[g]}))}if(u.push(A({pubkey:new v(f.inputMint)})),u.push(A({pubkey:new v(f.outputMint)})),y.programId===gt.CLMM_PROGRAM_ID.toBase58()){let g=y;u.push(A({pubkey:new v(g.config.id)})),u.push(A({pubkey:new v(g.id)})),u.push(A({pubkey:new v(b?g.vault.A:g.vault.B)})),u.push(A({pubkey:new v(b?g.vault.B:g.vault.A)})),u.push(A({pubkey:new v(g.observationId)})),u.push(A({pubkey:sn,isWritable:!1})),u.push(A({pubkey:new v(g.exBitmapAccount)})),a.push(Xs(f.lastPoolPriceX64,b));for(let P of(p=f.remainingAccounts)!=null?p:[])u.push(A({pubkey:new v(P)}))}else if(y.programId===gt.AMM_STABLE.toBase58()){let g=y;u.push(A({pubkey:new v(g.id)})),u.push(A({pubkey:new v(g.authority),isWritable:!1})),u.push(A({pubkey:new v(g.marketProgramId),isWritable:!1})),u.push(A({pubkey:new v(g.marketAuthority),isWritable:!1})),u.push(A({pubkey:lr,isWritable:!1})),u.push(A({pubkey:new v(g.openOrders)})),u.push(A({pubkey:new v(g.vault.A)})),u.push(A({pubkey:new v(g.vault.B)})),u.push(A({pubkey:new v(g.marketId)})),u.push(A({pubkey:new v(g.marketBids)})),u.push(A({pubkey:new v(g.marketAsks)})),u.push(A({pubkey:new v(g.marketEventQueue)})),u.push(A({pubkey:new v(g.marketBaseVault)})),u.push(A({pubkey:new v(g.marketQuoteVault)}))}else if(y.programId===gt.AMM_V4.toBase58()){let g=y;u.push(A({pubkey:new v(g.id)})),u.push(A({pubkey:new v(g.authority),isWritable:!1})),u.push(A({pubkey:new v(g.id)})),u.push(A({pubkey:new v(g.id)})),u.push(A({pubkey:new v(g.id)})),u.push(A({pubkey:new v(g.vault.A)})),u.push(A({pubkey:new v(g.vault.B)})),u.push(A({pubkey:new v(g.id)})),u.push(A({pubkey:new v(g.id)})),u.push(A({pubkey:new v(g.id)})),u.push(A({pubkey:new v(g.id)})),u.push(A({pubkey:new v(g.id)})),u.push(A({pubkey:new v(g.id)}))}else if(y.programId===gt.CREATE_CPMM_POOL_PROGRAM.toBase58()){let g=y;u.push(A({pubkey:new v(g.authority)})),u.push(A({pubkey:new v(g.config.id)})),u.push(A({pubkey:new v(g.id)})),u.push(A({pubkey:new v(b?g.vault.A:g.vault.B)})),u.push(A({pubkey:new v(b?g.vault.B:g.vault.A)})),u.push(A({pubkey:new v(g.observationId)}))}else throw Error("pool type error")}let l=V([_("insId"),k("amountIn"),k("amountOut"),Y(te(),a.length,"clmmPriceLimit")]),d=Buffer.alloc(l.span);return l.encode({insId:0,amountIn:t,amountOut:new dn(r.data.otherAmountThreshold),clmmPriceLimit:a},d),new Fi({keys:u,programId:c,data:d})}function OS({programId:c,wallet:e,inputAccount:t,outputAccount:n,routeInfo:o,poolKeys:r}){var d;if(o.success===!1)throw Error("route info error");let i=[],a=[A({pubkey:_n,isWritable:!1}),A({pubkey:Gs,isWritable:!1}),A({pubkey:Us,isWritable:!1}),A({pubkey:vi.programId,isWritable:!1}),A({pubkey:e,isSigner:!0})],u={[o.data.inputMint]:t,[o.data.outputMint]:n};for(let p=r.length-1;p>=0;p--){let m=o.data.routePlan[p],f=r[p],y=m.inputMint===f.mintA.address;if(a.push(A({pubkey:new v(f.programId)})),p===0)a.push(A({pubkey:u[m.inputMint]}));else{let b=m.inputMint;if(u[b]===void 0){let g=j(e,new v(b),f.programId===gt.CLMM_PROGRAM_ID.toBase58()||f.programId===gt.CREATE_CPMM_POOL_PROGRAM.toBase58()?new v(y?f.mintA.programId:f.mintB.programId):_n).publicKey;u[b]=g}a.push(A({pubkey:u[b]}))}if(p===r.length-1)a.push(A({pubkey:u[m.outputMint]}));else{let b=m.outputMint;if(u[b]===void 0){let g=j(e,new v(b),f.programId===gt.CLMM_PROGRAM_ID.toBase58()||f.programId===gt.CREATE_CPMM_POOL_PROGRAM.toBase58()?new v(y?f.mintB.programId:f.mintA.programId):_n).publicKey;u[b]=g}a.push(A({pubkey:u[b]}))}if(a.push(A({pubkey:new v(m.inputMint)})),a.push(A({pubkey:new v(m.outputMint)})),f.programId===gt.CLMM_PROGRAM_ID.toBase58()){let b=f;a.push(A({pubkey:new v(b.config.id)})),a.push(A({pubkey:new v(b.id)})),a.push(A({pubkey:new v(y?b.vault.A:b.vault.B)})),a.push(A({pubkey:new v(y?b.vault.B:b.vault.A)})),a.push(A({pubkey:new v(b.observationId)})),a.push(A({pubkey:sn,isWritable:!1})),a.push(A({pubkey:new v(b.exBitmapAccount)})),i.push(Xs(m.lastPoolPriceX64,y));for(let g of(d=m.remainingAccounts)!=null?d:[])a.push(A({pubkey:new v(g)}))}else if(f.programId===gt.AMM_STABLE.toBase58()){let b=f;a.push(A({pubkey:new v(b.id)})),a.push(A({pubkey:new v(b.authority),isWritable:!1})),a.push(A({pubkey:new v(b.marketProgramId),isWritable:!1})),a.push(A({pubkey:new v(b.marketAuthority),isWritable:!1})),a.push(A({pubkey:lr,isWritable:!1})),a.push(A({pubkey:new v(b.openOrders)})),a.push(A({pubkey:new v(b.vault.A)})),a.push(A({pubkey:new v(b.vault.B)})),a.push(A({pubkey:new v(b.marketId)})),a.push(A({pubkey:new v(b.marketBids)})),a.push(A({pubkey:new v(b.marketAsks)})),a.push(A({pubkey:new v(b.marketEventQueue)})),a.push(A({pubkey:new v(b.marketBaseVault)})),a.push(A({pubkey:new v(b.marketQuoteVault)}))}else if(f.programId===gt.AMM_V4.toBase58()){let b=f;a.push(A({pubkey:new v(b.id)})),a.push(A({pubkey:new v(b.authority),isWritable:!1})),a.push(A({pubkey:new v(b.id)})),a.push(A({pubkey:new v(b.id)})),a.push(A({pubkey:new v(b.id)})),a.push(A({pubkey:new v(b.vault.A)})),a.push(A({pubkey:new v(b.vault.B)})),a.push(A({pubkey:new v(b.id)})),a.push(A({pubkey:new v(b.id)})),a.push(A({pubkey:new v(b.id)})),a.push(A({pubkey:new v(b.id)})),a.push(A({pubkey:new v(b.id)})),a.push(A({pubkey:new v(b.id)}))}else if(f.programId===gt.CREATE_CPMM_POOL_PROGRAM.toBase58()){let b=f;a.push(A({pubkey:new v(b.authority)})),a.push(A({pubkey:new v(b.config.id)})),a.push(A({pubkey:new v(b.id)})),a.push(A({pubkey:new v(y?b.vault.A:b.vault.B)})),a.push(A({pubkey:new v(y?b.vault.B:b.vault.A)})),a.push(A({pubkey:new v(b.observationId)}))}else throw Error("pool type error")}let s=V([_("insId"),k("amountIn"),k("amountOut"),Y(te(),i.length,"clmmPriceLimit")]),l=Buffer.alloc(s.span);return s.encode({insId:1,amountIn:new dn(o.data.otherAmountThreshold),amountOut:new dn(o.data.outputAmount),clmmPriceLimit:i},l),new Fi({keys:a,programId:c,data:l})}var In=new $r(0),_i=class extends Fe{constructor(e){super(e)}async getWSolAccounts(){this.scope.checkOwner(),await this.scope.account.fetchWalletTokenAccounts();let e=this.scope.account.tokenAccounts.filter(t=>t.mint.equals(H));return e.sort((t,n)=>t.isAssociated?1:n.isAssociated||t.amount.lt(n.amount)?-1:1),e}async unWrapWSol(e){let{amount:t,tokenProgram:n,txVersion:o=1,feePayer:r}=e,i=await this.getWSolAccounts(),a=this.createTxBuilder(r);a.addCustomComputeBudget(e.computeBudgetConfig);let u=J(t);for(let s=0;s<i.length;s++)u.gte(i[s].amount)?(a.addInstruction({instructions:[An({tokenAccount:i[s].publicKey,payer:this.scope.ownerPubKey,owner:this.scope.ownerPubKey,programId:n})]}),u.sub(i[s].amount)):a.addInstruction({instructions:[An({tokenAccount:i[s].publicKey,payer:this.scope.ownerPubKey,owner:this.scope.ownerPubKey,programId:n})]});return a.versionBuild({txVersion:o})}async wrapWSol(e,t,n,o){let r=this.createTxBuilder(o),i=await Ln({connection:this.scope.connection,owner:this.scope.ownerPubKey,payer:this.scope.ownerPubKey,amount:e,skipCloseAccount:!0});return r.addInstruction(i),r.versionBuild({txVersion:n!=null?n:1})}async swap({swapInfo:e,swapPoolKeys:t,ownerInfo:n,computeBudgetConfig:o,routeProgram:r,txVersion:i,feePayer:a}){let u=this.createTxBuilder(a),s=e.amountIn,l=e.amountOut,d=s.amount.token.mint.equals(H),p=l.amount.token.mint.equals(H),m=s.amount.token.mint,f=l.amount.token.mint,{account:y,instructionParams:b}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:s.amount.token.isToken2022?Zr:je,mint:m,notUseTokenAccount:d,owner:this.scope.ownerPubKey,skipCloseAccount:!d,createInfo:d?{payer:this.scope.ownerPubKey,amount:s.amount.raw}:void 0,associatedOnly:d?!1:n.associatedOnly,checkCreateATAOwner:n.checkCreateATAOwner});if(b&&u.addInstruction(b),y===void 0)throw Error("input account check error");let g;if(e.routeType==="route"&&!p)g=this.scope.account.getAssociatedTokenAccount(f,l.amount.token.isToken2022?Zr:je);else{let{account:T,instructionParams:w}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:l.amount.token.isToken2022?Zr:je,mint:f,notUseTokenAccount:p,owner:this.scope.ownerPubKey,skipCloseAccount:!0,createInfo:{payer:this.scope.ownerPubKey,amount:0},associatedOnly:p?!1:n.associatedOnly,checkCreateATAOwner:n.checkCreateATAOwner});g=T,w&&u.addInstruction(w)}p&&u.addInstruction({endInstructions:[An({owner:this.scope.ownerPubKey,payer:this.scope.ownerPubKey,tokenAccount:g,programId:je})],endInstructionTypes:[U.CloseAccount]});let P;if(e.routeType==="route"){let T=e.middleToken;P=this.scope.account.getAssociatedTokenAccount(T.mint,T.isToken2022?Zr:je)}let h=t||await this.computePoolToPoolKeys({pools:e.poolInfoList}),I=Il({routeProgram:r,inputMint:m,swapInfo:q(N({},e),{poolInfo:[...e.poolInfoList],poolKey:h,outputMint:f}),ownerInfo:{wallet:this.scope.ownerPubKey,sourceToken:y,routeToken:P,destinationToken:g}});if(e.feeConfig!==void 0){let T=this.createTxBuilder();T.addInstruction({instructions:[Bl(y,e.feeConfig.feeAccount,this.scope.ownerPubKey,e.feeConfig.feeAmount.toNumber())],instructionTypes:[U.TransferAmount]}),T.addInstruction(I);let{transactions:w}=i===0?await T.sizeCheckBuildV0():await T.sizeCheckBuild();w.length<2&&u.addInstruction({instructions:[Bl(y,e.feeConfig.feeAccount,this.scope.ownerPubKey,e.feeConfig.feeAmount.toNumber())],instructionTypes:[U.TransferAmount]})}return u.addInstruction(I),i===0?u.sizeCheckBuildV0({computeBudgetConfig:o,address:I.address}):u.sizeCheckBuild({computeBudgetConfig:o,address:I.address})}async fetchRoutePoolBasicInfo(e){let{amm:t=Yo,clmm:n=Sn,cpmm:o=Ho}=e||{},r=await this.scope.connection.getProgramAccounts(t,{dataSlice:{offset:$n.offsetOf("baseMint"),length:64}}),i=V([O("baseMint"),O("quoteMint")]),a=r.map(m=>({id:m.pubkey,version:4,mintA:i.decode(m.account.data).baseMint,mintB:i.decode(m.account.data).quoteMint})),u=V([O("mintA"),O("mintB")]),l=(await this.scope.connection.getProgramAccounts(n,{filters:[{dataSize:Hn.span}],dataSlice:{offset:Hn.offsetOf("mintA"),length:64}})).map(m=>{let f=u.decode(m.account.data);return{id:m.pubkey,version:6,mintA:f.mintA,mintB:f.mintB}}),p=(await this.scope.connection.getProgramAccounts(o,{dataSlice:{offset:Qr.offsetOf("mintA"),length:64}})).map(m=>{let f=u.decode(m.account.data);return{id:m.pubkey,version:7,mintA:f.mintA,mintB:f.mintB}});return{clmmPools:l,ammPools:a,cpmmPools:p}}getAllRoute({inputMint:e,outputMint:t,clmmPools:n,ammPools:o,cpmmPools:r}){e=e.toString()===ao.default.toString()?H:e,t=t.toString()===ao.default.toString()?H:t;let i={},a={},u={},s=[],l={};for(let p of n!=null?n:[]){if((p.mintA.equals(e)&&p.mintB.equals(t)||p.mintA.equals(t)&&p.mintB.equals(e))&&(s.push(p),a[p.id.toString()]=p),p.mintA.equals(e)){let m=p.mintB.toString();l[m]===void 0&&(l[m]={mintProgram:je,in:[],out:[],mDecimals:0}),l[m].in.push(p)}if(p.mintB.equals(e)){let m=p.mintA.toString();l[m]===void 0&&(l[m]={mintProgram:je,in:[],out:[],mDecimals:0}),l[m].in.push(p)}if(p.mintA.equals(t)){let m=p.mintB.toString();l[m]===void 0&&(l[m]={mintProgram:je,in:[],out:[],mDecimals:0}),l[m].out.push(p)}if(p.mintB.equals(t)){let m=p.mintA.toString();l[m]===void 0&&(l[m]={mintProgram:je,in:[],out:[],mDecimals:0}),l[m].out.push(p)}}let d=[];for(let p of o)(p.mintA.equals(e)&&p.mintB.equals(t)||p.mintA.equals(t)&&p.mintB.equals(e))&&(s.push(p),i[p.id.toBase58()]=p,d.push(p)),p.mintA.equals(e)&&(l[p.mintB.toBase58()]===void 0&&(l[p.mintB.toBase58()]={mintProgram:je,in:[],out:[],mDecimals:0}),l[p.mintB.toBase58()].in.push(p)),p.mintB.equals(e)&&(l[p.mintA.toBase58()]===void 0&&(l[p.mintA.toBase58()]={mintProgram:je,in:[],out:[],mDecimals:0}),l[p.mintA.toBase58()].in.push(p)),p.mintA.equals(t)&&(l[p.mintB.toBase58()]===void 0&&(l[p.mintB.toBase58()]={mintProgram:je,in:[],out:[],mDecimals:0}),l[p.mintB.toBase58()].out.push(p)),p.mintB.equals(t)&&(l[p.mintA.toBase58()]===void 0&&(l[p.mintA.toBase58()]={mintProgram:je,in:[],out:[],mDecimals:0}),l[p.mintA.toBase58()].out.push(p));for(let p of r)(p.mintA.equals(e)&&p.mintB.equals(t)||p.mintA.equals(t)&&p.mintB.equals(e))&&(s.push(p),u[p.id.toBase58()]=p),p.mintA.equals(e)&&(l[p.mintB.toBase58()]===void 0&&(l[p.mintB.toBase58()]={mintProgram:je,in:[],out:[],mDecimals:0}),l[p.mintB.toBase58()].in.push(p)),p.mintB.equals(e)&&(l[p.mintA.toBase58()]===void 0&&(l[p.mintA.toBase58()]={mintProgram:je,in:[],out:[],mDecimals:0}),l[p.mintA.toBase58()].in.push(p)),p.mintA.equals(t)&&(l[p.mintB.toBase58()]===void 0&&(l[p.mintB.toBase58()]={mintProgram:je,in:[],out:[],mDecimals:0}),l[p.mintB.toBase58()].out.push(p)),p.mintB.equals(t)&&(l[p.mintA.toBase58()]===void 0&&(l[p.mintA.toBase58()]={mintProgram:je,in:[],out:[],mDecimals:0}),l[p.mintA.toBase58()].out.push(p));for(let p of Object.keys(l)){if(l[p].in.length===1&&l[p].out.length===1&&l[p].in[0].id.equals(l[p].out[0].id)){delete l[p];continue}if(l[p].in.length===0||l[p].out.length===0){delete l[p];continue}let m=l[p];for(let f of m.in)for(let y of m.out)f.version===6&&a[f.id.toString()]===void 0?a[f.id.toString()]=f:f.version===7&&u[f.id.toString()]===void 0?u[f.id.toString()]=f:(f.version===4||f.version===5)&&i[f.id.toString()]===void 0&&(i[f.id.toString()]=f),y.version===6&&a[y.id.toString()]===void 0?a[y.id.toString()]=y:y.version===7&&u[y.id.toString()]===void 0?u[y.id.toString()]=y:(y.version===4||y.version===5)&&i[y.id.toString()]===void 0&&(i[y.id.toString()]=y)}return{directPath:s,addLiquidityPools:d,routePathDict:l,needSimulate:Object.values(i),needTickArray:Object.values(a),cpmmPoolList:Object.values(u)}}async fetchSwapRoutesData({routes:e,inputMint:t,outputMint:n}){let o=new Set([...e.needTickArray.map(y=>[y.mintA.toBase58(),y.mintB.toBase58()]).flat(),t.toString(),n.toString()]);console.log("fetching amm pools info, total: ",e.needSimulate.length);let r=await this.scope.liquidity.getRpcPoolInfos(e.needSimulate.map(y=>y.id)),i=_r(r),a={};Object.values(i).forEach(y=>{o.delete(y.mintA.address),a[y.mintA.address]={address:new ao(y.mintA.address),programId:je,mintAuthority:null,supply:BigInt(0),decimals:y.mintA.decimals,isInitialized:!0,freezeAuthority:null,tlvData:Buffer.from("0","hex"),feeConfig:void 0},o.delete(y.mintB.address),a[y.mintB.address]={address:new ao(y.mintB.address),programId:je,mintAuthority:null,supply:BigInt(0),decimals:y.mintB.decimals,isInitialized:!0,freezeAuthority:null,tlvData:Buffer.from("0","hex"),feeConfig:void 0}}),console.log("fetching cpmm pools info, total: ",e.cpmmPoolList.length);let u=await this.scope.cpmm.getRpcPoolInfos(e.cpmmPoolList.map(y=>y.id.toBase58()),!0);Object.values(u).forEach(y=>{let[b,g]=[y.mintA.toBase58(),y.mintB.toBase58()];y.mintProgramA.equals(je)?(o.delete(b),a[b]={address:y.mintA,programId:y.mintProgramA,mintAuthority:null,supply:BigInt(0),decimals:y.mintDecimalA,isInitialized:!0,freezeAuthority:null,tlvData:Buffer.from("0","hex"),feeConfig:void 0}):o.add(b),y.mintProgramB.equals(je)?(o.delete(g),a[g]={address:y.mintB,programId:y.mintProgramB,mintAuthority:null,supply:BigInt(0),decimals:y.mintDecimalB,isInitialized:!0,freezeAuthority:null,tlvData:Buffer.from("0","hex"),feeConfig:void 0}):o.add(g)}),console.log("fetching mints info, total: ",o.size);let s=await po({connection:this.scope.connection,mints:Array.from(o).map(y=>new ao(y))});a=N(N({},a),s);let l=this.scope.cpmm.toComputePoolInfos({pools:u,mintInfos:a});console.log("fetching clmm pools info, total:",e.needTickArray.length);let d=await this.scope.clmm.getRpcClmmPoolInfos({poolIds:e.needTickArray.map(y=>y.id)}),{computeClmmPoolInfo:p,computePoolTickData:m}=await this.scope.clmm.getComputeClmmPoolInfos({clmmPoolsRpcInfo:d,mintInfos:a}),f=Object.keys(e.routePathDict).reduce((y,b)=>q(N({},y),{[b]:q(N({},e.routePathDict[b]),{mintProgram:a[b].programId,mDecimals:a[b].decimals,in:e.routePathDict[b].in.map(g=>i[g.id.toBase58()]||p[g.id.toBase58()]||l[g.id.toBase58()]),out:e.routePathDict[b].out.map(g=>i[g.id.toBase58()]||p[g.id.toBase58()]||l[g.id.toBase58()])})}),{});return{mintInfos:a,ammPoolsRpcInfo:r,ammSimulateCache:i,clmmPoolsRpcInfo:d,computeClmmPoolInfo:p,computePoolTickData:m,computeCpmmData:l,routePathDict:f}}getAllRouteComputeAmountOut({inputTokenAmount:e,outputToken:t,directPath:n,routePathDict:o,simulateCache:r,tickCache:i,slippage:a,chainTime:u,epochInfo:s,feeConfig:l}){var g,P,h,I,T,w,x,S,K;let d=l===void 0?new $r(0):e.raw.mul(new $r(l.feeBps.toNumber())).div(new $r(1e4)),p=e.raw.sub(d),m=new Se(e.token,p),f=l===void 0?void 0:{feeAmount:d,feeAccount:l.feeAccount},y=q(N({},t),{address:mt(t.address).toString()}),b=[];for(let B of n)try{b.push(q(N({},this.computeAmountOut({itemPool:B,tickCache:i,simulateCache:r,chainTime:u,epochInfo:s,slippage:a,outputToken:y,amountIn:m})),{feeConfig:f}))}catch(C){this.logDebug("direct error",B.version,B.id.toString(),C.message)}this.logDebug("direct done");for(let[B,C]of Object.entries(o)){let M={chainId:101,address:B,programId:C.mintProgram.toBase58(),logoURI:"",symbol:"",name:"",decimals:C.mDecimals,tags:[],extensions:{}},F=C.in.map(L=>{try{return{pool:L,data:this.computeAmountOut({itemPool:L,tickCache:i,simulateCache:r,chainTime:u,epochInfo:s,slippage:a,outputToken:M,amountIn:m})}}catch(W){this.logDebug("route in error",L.version,L.id.toString(),W.message);return}}).sort((L,W)=>{var ae,ye,ce,de;let z=L===void 0?In:L.data.amountOut.amount.raw.sub((ye=(ae=L.data.amountOut.fee)==null?void 0:ae.raw)!=null?ye:In),$=W===void 0?In:W.data.amountOut.amount.raw.sub((de=(ce=W.data.amountOut.fee)==null?void 0:ce.raw)!=null?de:In);return z.lt($)?1:-1})[0];if(F===void 0)continue;let R=new Se(Nr(M),F.data.amountOut.amount.raw.sub((P=(g=F.data.amountOut.fee)==null?void 0:g.raw)!=null?P:In));for(let L of C.out)try{let W=this.computeAmountOut({itemPool:L,tickCache:i,simulateCache:r,chainTime:u,epochInfo:s,slippage:a,outputToken:y,amountIn:R});b.push(q(N({},W),{allTrade:!!(F.data.allTrade&&W.allTrade),amountIn:F.data.amountIn,amountOut:W.amountOut,minAmountOut:W.minAmountOut,currentPrice:void 0,executionPrice:new Vi(new ht({baseToken:F.data.amountIn.amount.token,denominator:F.data.amountIn.amount.raw,quoteToken:W.amountOut.amount.token,numerator:W.amountOut.amount.raw.sub((I=(h=W.amountOut.fee)==null?void 0:h.raw)!=null?I:In)}).toFixed()),priceImpact:new Vi(F.data.priceImpact.add(W.priceImpact).toFixed()),fee:[F.data.fee[0],W.fee[0]],routeType:"route",poolInfoList:[F.pool,L],remainingAccounts:[F.data.remainingAccounts[0],W.remainingAccounts[0]],minMiddleAmountFee:(T=W.amountOut.fee)!=null&&T.raw?new Se(F.data.amountOut.amount.token,((x=(w=F.data.amountOut.fee)==null?void 0:w.raw)!=null?x:In).add((K=(S=W.amountOut.fee)==null?void 0:S.raw)!=null?K:In)):void 0,middleToken:F.data.amountOut.amount.token,poolReady:F.data.poolReady&&W.poolReady,poolType:[F.data.poolType,W.poolType],feeConfig:f,expirationTime:$t(F.data.expirationTime,W.expirationTime)}))}catch(W){this.logDebug("route out error",L.version,L.id.toString(),W.message)}}return b.filter(B=>(B.allTrade||this.logDebug(`pool ${B.poolInfoList.map(C=>C.id.toString()).join(",")} filter out since not all trade`),B.allTrade)).sort((B,C)=>B.amountOut.amount.raw.sub(C.amountOut.amount.raw).gt(In)?-1:1)}computeAmountOut({itemPool:e,tickCache:t,simulateCache:n,chainTime:o,epochInfo:r,slippage:i,outputToken:a,amountIn:u}){if(e.version===6){let{allTrade:s,realAmountIn:l,amountOut:d,minAmountOut:p,expirationTime:m,currentPrice:f,executionPrice:y,priceImpact:b,fee:g,remainingAccounts:P,executionPriceX64:h}=Ne.computeAmountOutFormat({poolInfo:e,tickArrayCache:t[e.id.toString()],amountIn:u.raw,tokenOut:a,slippage:i,epochInfo:r,catchLiquidityInsufficient:!0});return{allTrade:s,amountIn:l,amountOut:d,minAmountOut:p,currentPrice:new Vi(f.toFixed()),executionPrice:new Vi(y.toFixed()),priceImpact:new Vi(b.toFixed()),fee:[g],remainingAccounts:[P],routeType:"amm",poolInfoList:[e],poolReady:e.startTime<o,poolType:"CLMM",slippage:i,clmmExPriceX64:[h],expirationTime:$t(l.expirationTime,m)}}else if(e.version===7){let{allTrade:s,executionPrice:l,amountOut:d,minAmountOut:p,priceImpact:m,fee:f}=this.scope.cpmm.computeSwapAmount({pool:e,outputMint:a.address,amountIn:u.raw,slippage:i});return{allTrade:s,amountIn:{amount:u,fee:void 0,expirationTime:void 0},amountOut:{amount:Ti(q(N({},a),{amount:d})),fee:void 0,expirationTime:void 0},minAmountOut:{amount:Ti(q(N({},a),{amount:p})),fee:void 0,expirationTime:void 0},currentPrice:e.poolPrice,executionPrice:l,priceImpact:m,fee:[new Se(u.token,f)],remainingAccounts:[],routeType:"amm",poolInfoList:[e],poolReady:e.openTime.toNumber()<o,poolType:"CPMM",slippage:i,clmmExPriceX64:[void 0],expirationTime:void 0}}else{if(![1,6,7].includes(n[e.id.toString()].status))throw Error("swap error");let{amountOut:s,minAmountOut:l,currentPrice:d,executionPrice:p,priceImpact:m,fee:f}=this.scope.liquidity.computeAmountOut({poolInfo:n[e.id.toString()],amountIn:u.raw,mintIn:u.token.mint,mintOut:a.address,slippage:i});return{amountIn:{amount:u,fee:void 0,expirationTime:void 0},amountOut:{amount:Ti(q(N({},a),{amount:s})),fee:void 0,expirationTime:void 0},minAmountOut:{amount:Ti(q(N({},a),{amount:l})),fee:void 0,expirationTime:void 0},currentPrice:d,executionPrice:p,priceImpact:m,fee:[new Se(u.token,f)],routeType:"amm",poolInfoList:[e],remainingAccounts:[],poolReady:Number(n[e.id].openTime)<o,poolType:e.version===5?"STABLE":void 0,expirationTime:void 0,allTrade:!0,slippage:i,clmmExPriceX64:[void 0]}}}async computePoolToPoolKeys({pools:e,clmmRpcData:t={},ammRpcData:n={}}){let o=new Set(e.filter(s=>s.version===6&&!t[s.id.toString()]).map(s=>s.id.toString()));if(o.size>0){let s=await this.scope.clmm.getRpcClmmPoolInfos({poolIds:Array.from(o)});Object.keys(s).forEach(l=>{t[l]=s[l]})}let r=new Set(e.filter(s=>s.version===4&&!n[s.id.toString()]).map(s=>s.id.toString()));if(r.size>0){let s=await this.scope.liquidity.getRpcPoolInfos(Array.from(r));Object.keys(s).forEach(l=>{n[l]=s[l]})}let i=new Set(e.filter(s=>s.version===4).map(s=>s.marketId)),a={};i.size>0&&(await Oe(this.scope.connection,Array.from(i).map(l=>({pubkey:new ao(l)})))).forEach(l=>{if(!l.accountInfo)return;let d=qs.decode(l.accountInfo.data);a[l.pubkey.toBase58()]={marketId:l.pubkey.toString(),marketProgramId:l.accountInfo.owner.toString(),marketAuthority:Hr.getAssociatedAuthority({programId:l.accountInfo.owner,marketId:l.pubkey}).publicKey.toString(),marketBaseVault:d.baseVault.toString(),marketQuoteVault:d.quoteVault.toString(),marketBids:d.bids.toString(),marketAsks:d.asks.toString(),marketEventQueue:d.eventQueue.toString()}});let u=[];return e.forEach(s=>{if(s.version===6){let l=t[s.id.toString()],d={programId:s.programId.toBase58(),id:s.id.toBase58(),mintA:s.mintA,mintB:s.mintB,openTime:String(s.startTime),vault:{A:l.vaultA.toBase58(),B:l.vaultB.toBase58()},config:q(N({},s.ammConfig),{id:s.ammConfig.id.toString(),defaultRange:0,defaultRangePoint:[]}),rewardInfos:[],observationId:s.observationId.toBase58(),exBitmapAccount:s.exBitmapAccount.toBase58()};u.push(d)}else if(s.version===4){let l=n[s.id.toString()],d=N({programId:s.programId,id:s.id,mintA:s.mintA,mintB:s.mintB,openTime:String(s.openTime),vault:{A:l.baseVault.toBase58(),B:l.quoteVault.toBase58()},authority:vs({programId:new ao(s.programId)}).publicKey.toString(),openOrders:l.openOrders.toBase58(),targetOrders:l.targetOrders.toBase58(),mintLp:s.lpMint},a[s.marketId]);u.push(d)}else s.version===7&&u.push({observationId:s.observationId.toBase58(),programId:s.programId.toBase58(),id:s.id.toBase58(),mintA:s.mintA,mintB:s.mintB,openTime:String(s.openTime),authority:No(s.programId).publicKey.toBase58(),vault:{A:s.vaultA.toBase58(),B:s.vaultB.toBase58()},mintLp:ft({address:s.mintLp.toBase58(),programId:je.toBase58(),decimals:s.lpDecimals}),config:q(N({id:s.configId.toBase58()},s.configInfo),{protocolFeeRate:s.configInfo.protocolFeeRate.toNumber(),tradeFeeRate:s.configInfo.tradeFeeRate.toNumber(),fundFeeRate:s.configInfo.fundFeeRate.toNumber(),createPoolFee:s.configInfo.createPoolFee.toString()})})}),u}};import{PublicKey as Gp,Transaction as zs,TransactionInstruction as Xp}from"@solana/web3.js";import{TOKEN_PROGRAM_ID as zp}from"@solana/spl-token";import xl from"bn.js";var yt=class extends Fe{static getPdaPoolId(e,t){return ne([yt.SEED_CONFIG.pool.id,t.toBuffer()],e)}static getPdaOwnerId(e,t,n,o){return ne([yt.SEED_CONFIG.owner.id,t.toBuffer(),n.toBuffer(),Buffer.from(new xl(o).toArray())],e)}static async getAllInfo({connection:e,programId:t,poolIds:n,wallet:o,chainTime:r}){if(n.length===0)return[];let i=n.map(l=>yt.getPdaPoolId(t,l).publicKey),a=[];for(let l=0;l<yt.VERSION_PROJECT.length;l++)a.push(...i.map(d=>yt.getPdaOwnerId(t,d,o,l).publicKey));let u=await Yt(e,[...i,...a]),s=[];for(let l=0;l<u.length;l++){let d=Math.floor(l/n.length),p=l%n.length,m=i[p],f=a[l],y=u[p],b=u[n.length+l];if(!(y&&b)||y.data.length!==yt.POOL_LAYOUT.span||b.data.length!==yt.OWNER_LAYOUT.span)continue;let g=yt.POOL_LAYOUT.decode(y.data),P=yt.OWNER_LAYOUT.decode(b.data),h=g.openTime.toNumber(),I=g.endTime.toNumber(),T=P.tokenInfo.map(S=>S.debtAmount.gt(new xl(0))).filter(S=>!S).length!==3,w=r>h&&r<I&&g.status===1,x=T&&w;s.push({programId:t,poolId:m,ammId:g.ammId,ownerAccountId:f,snapshotLpAmount:P.lpAmount,project:yt.VERSION_PROJECT[d],openTime:h,endTime:I,canClaim:x,canClaimErrorType:T?w?void 0:"outOfOperationalTime":"alreadyClaimIt",tokenInfo:g.tokenInfo.map((S,K)=>({mintAddress:S.mintAddress,mintVault:S.mintVault,mintDecimals:S.mintDecimals,perLpLoss:S.perLpLoss,debtAmount:P.tokenInfo[K].debtAmount.add(P.tokenInfo[K].claimedAmount)}))})}return s}async makeClaimTransaction({poolInfo:e,ownerInfo:t,feePayer:n}){t.wallet||this.scope.checkOwner();let o=this.createTxBuilder(n),r=t.wallet||this.scope.ownerPubKey,i=[];for(let s of e.tokenInfo){let{account:l,instructionParams:d}=await this.scope.account.getOrCreateTokenAccount({mint:s.mintAddress,owner:this.scope.ownerPubKey,notUseTokenAccount:s.mintAddress.equals(De.WSOL.mint),createInfo:{payer:r,amount:0},skipCloseAccount:!s.mintAddress.equals(De.WSOL.mint),associatedOnly:s.mintAddress.equals(De.WSOL.mint)?!1:t.associatedOnly});d&&o.addInstruction(d),i.push(l)}o.addInstruction({instructions:[yt.makeClaimInstruction({programId:e.programId,poolInfo:e,ownerInfo:{wallet:r,ownerPda:e.ownerAccountId,claimAddress:i}})]});let{transaction:a,signers:u}=o.build();return[{transaction:a,signer:u}]}async makeClaimAllTransaction({poolInfos:e,ownerInfo:t,feePayer:n}){let o=this.createTxBuilder(n),r=t.wallet||this.scope.ownerPubKey,i={};for(let l of e){let d=[];for(let p of l.tokenInfo){let{account:m,instructionParams:f}=await this.scope.account.getOrCreateTokenAccount({mint:p.mintAddress,owner:this.scope.ownerPubKey,notUseTokenAccount:p.mintAddress.equals(De.WSOL.mint),createInfo:{payer:r,amount:0},skipCloseAccount:!p.mintAddress.equals(De.WSOL.mint),associatedOnly:p.mintAddress.equals(De.WSOL.mint)?!1:t.associatedOnly});f&&o.addInstruction(f),m&&(i[p.mintAddress.toString()]=m,d.push(m))}o.addInstruction({instructions:[yt.makeClaimInstruction({programId:l.programId,poolInfo:l,ownerInfo:{wallet:r,ownerPda:l.ownerAccountId,claimAddress:d}})]})}let{transaction:a,signers:u}=o.build(),s=o.allInstructions;return ur(s,[r,...u.map(l=>l.publicKey)])?[{transaction:a,signer:u}]:[{transaction:new zs().add(...s.slice(0,o.AllTxData.instructions.length-1)),signer:u},{transaction:new zs().add(...s.slice(o.AllTxData.instructions.length-1)),signer:[]},{transaction:new zs().add(...o.AllTxData.endInstructions),signer:[]}]}static makeClaimInstruction({programId:e,poolInfo:t,ownerInfo:n}){let o=V([]),r=[{pubkey:n.wallet,isSigner:!0,isWritable:!0},{pubkey:t.poolId,isSigner:!1,isWritable:!0},{pubkey:n.ownerPda,isSigner:!1,isWritable:!0},...n.claimAddress.map(u=>({pubkey:u,isSigner:!1,isWritable:!0})),...t.tokenInfo.map(({mintVault:u})=>({pubkey:u,isSigner:!1,isWritable:!0})),{pubkey:zp,isSigner:!1,isWritable:!1}],i=Buffer.alloc(o.span);o.encode({},i);let a=Buffer.from([10,66,208,184,161,6,191,98,...i]);return new Xp({keys:r,programId:e,data:a})}},Ut=yt;Ut.CLAIMED_NUM=3,Ut.POOL_LAYOUT=V([Ie(8),_("bump"),_("status"),k("openTime"),k("endTime"),O("ammId"),Y(V([_("mintDecimals"),O("mintAddress"),O("mintVault"),k("perLpLoss"),k("totalClaimedAmount")]),yt.CLAIMED_NUM,"tokenInfo"),Y(k(),10,"padding")]),Ut.OWNER_LAYOUT=V([Ie(8),_("bump"),_("version"),O("poolId"),O("owner"),k("lpAmount"),Y(V([O("mintAddress"),k("debtAmount"),k("claimedAmount")]),yt.CLAIMED_NUM,"tokenInfo"),Y(k(),4,"padding")]),Ut.DEFAULT_POOL_ID=["58oQChx4yWmvKdwLLZzBi4ChoCc2fqCUWBkwMihLYQo2","6UmmUiYoBjSrhakAobJw8BvkmJtDVxaeBtbt7rxWo1mg","AVs9TA4nWDzfPJE9gGVNJMVhcQy3V9PGazuz33BfG2RA","DVa7Qmb5ct9RCpaU7UTpSaf3GVMYz17vNVU67XpdCRut","7XawhbbxtsRcQA8KTkHT9f9nc6d69UwqCDh6U5EEbEmX","6a1CsrpeZubDjEJE9s1CMVheB6HWM5d7m1cj2jkhyXhj","EoNrn8iUhwgJySD1pHu8Qxm5gSQqLK3za4m8xzD2RuEb","AceAyRTWt4PyB2pHqf2qhDgNZDtKVNaxgL8Ru3V4aN1P","6tmFJbMk5yVHFcFy7X2K8RwHjKLr6KVFLYXpgpBNeAxB"].map(e=>new Gp(e)),Ut.SEED_CONFIG={pool:{id:Buffer.from("pool_seed","utf8")},owner:{id:Buffer.from("user_claim_seed","utf8")}},Ut.VERSION_PROJECT=[void 0,"Francium","Tulip","Larix"];import{PublicKey as Di}from"@solana/web3.js";import Sl from"bn.js";import{SYSVAR_CLOCK_PUBKEY as Qp,TransactionInstruction as Ys}from"@solana/web3.js";import{TOKEN_PROGRAM_ID as js}from"@solana/spl-token";var Qs=V([_("instruction"),Xu("amount")]),Ei=V([_("instruction")]);function BK({programId:c,amount:e,instructionKeys:t}){let n=[{pubkey:tr,isSigner:!1,isWritable:!1},{pubkey:js,isSigner:!1,isWritable:!1},{pubkey:Ze,isSigner:!1,isWritable:!1},{pubkey:Aa,isSigner:!1,isWritable:!1},...Object.entries(t).map(([r,i])=>({pubkey:i,isSigner:r==="userOwner",isWritable:!["authority","userOwner","userIdoCheck","userStakeInfo"].includes(r)}))],o=Buffer.alloc(Qs.span);return Qs.encode({instruction:1,amount:Number(e)},o),new Ys({keys:n,programId:c,data:o})}function Jr({programId:c},e){let t=[{pubkey:js,isSigner:!1,isWritable:!1},{pubkey:Aa,isSigner:!1,isWritable:!1},...Object.entries(e).map(([o,r])=>({pubkey:r,isSigner:o==="userOwner",isWritable:!["authority","userOwner"].includes(o)}))],n=Buffer.alloc(Ei.span);return Ei.encode({instruction:2},n),new Ys({keys:t,programId:c,data:n})}function Hs(c){let{poolConfig:e,userKeys:t,side:n}=c,o=n==="base"?t.baseTokenAccount:t.quoteTokenAccount,r=n==="base"?e.baseVault:e.quoteVault,i=Buffer.alloc(Ei.span);Ei.encode({instruction:2},i);let a=[{pubkey:js,isWritable:!1,isSigner:!1},{pubkey:Qp,isWritable:!1,isSigner:!1},{pubkey:e.id,isWritable:!0,isSigner:!1},{pubkey:e.authority,isWritable:!1,isSigner:!1},{pubkey:r,isWritable:!0,isSigner:!1},{pubkey:o,isWritable:!0,isSigner:!1},{pubkey:t.ledgerAccount,isWritable:!0,isSigner:!1},{pubkey:t.owner,isWritable:!1,isSigner:!0}];return new Ys({programId:e.programId,keys:a,data:i})}var Yp={[Jo.IDO_PROGRAM_ID_V1.toString()]:1,[Jo.IDO_PROGRAM_ID_V2.toString()]:2,[Jo.IDO_PROGRAM_ID_V3.toString()]:3,[Jo.IDO_PROGRAM_ID_V4.toString()]:4},Mo=class extends Fe{async claim({ownerInfo:e,idoKeys:t,associatedOnly:n=!0,checkCreateATAOwner:o=!1,txVersion:r,feePayer:i}){let a=this.createTxBuilder(i),u=Yp[t.programId];u||this.logAndCreateError("invalid version",u);let s=Me(t),[l,d]=[!new Sl(e.coin).isZero(),!new Sl(e.pc).isZero()],p=s.projectInfo.mint.address.equals(H),{account:m,instructionParams:f}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:s.projectInfo.mint.programId,mint:s.projectInfo.mint.address,owner:this.scope.ownerPubKey,createInfo:{payer:this.scope.ownerPubKey,amount:0},skipCloseAccount:!p,notUseTokenAccount:p,associatedOnly:p?!1:n,checkCreateATAOwner:o});!m&&l&&this.logAndCreateError("target token accounts not found","mint",t.projectInfo.mint.address),l&&f&&a.addInstruction(f);let y=s.buyInfo.mint.address.equals(H),{account:b,instructionParams:g}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:s.buyInfo.mint.programId,mint:s.buyInfo.mint.address,owner:this.scope.ownerPubKey,createInfo:{payer:this.scope.ownerPubKey,amount:0},skipCloseAccount:!y,notUseTokenAccount:y,associatedOnly:y?!1:n,checkCreateATAOwner:o});if(!m&&d&&this.logAndCreateError("target token accounts not found","mint",t.projectInfo.mint.address),d&&g&&a.addInstruction(g),(!m||!b)&&this.logAndCreateError("target token accounts not found","mint",t.projectInfo.mint.address,t.buyInfo.mint.address),u===3)return a.addInstruction({instructions:[...l?[Jr({programId:s.programId},{idoId:s.id,authority:s.authority,poolTokenAccount:s.projectInfo.vault,userTokenAccount:m,userIdoInfo:new Di(e.userIdoInfo),userOwner:this.scope.ownerPubKey})]:[],...d?[Jr({programId:new Di(t.programId)},{idoId:s.id,authority:s.authority,poolTokenAccount:s.buyInfo.vault,userTokenAccount:b,userIdoInfo:new Di(e.userIdoInfo),userOwner:this.scope.ownerPubKey})]:[]]}).versionBuild({txVersion:r});if(u<3)return!l&&!d&&this.logAndCreateError("no claimable rewards"),a.addInstruction({instructions:[Jr({programId:s.programId},{idoId:s.id,authority:s.authority,poolQuoteTokenAccount:s.buyInfo.vault,poolBaseTokenAccount:s.projectInfo.vault,userQuoteTokenAccount:b,userBaseTokenAccount:m,userIdoInfo:new Di(e.userIdoInfo),userOwner:this.scope.ownerPubKey})]}).versionBuild({txVersion:r});let P={poolConfig:{id:s.id,programId:s.programId,authority:s.authority,baseVault:s.projectInfo.vault,quoteVault:s.buyInfo.vault,baseToken:t.projectInfo.mint,quoteToken:t.buyInfo.mint},userKeys:{baseTokenAccount:m,quoteTokenAccount:b,ledgerAccount:new Di(e.userIdoInfo),owner:this.scope.ownerPubKey}};return a.addInstruction({instructions:[...l?[Hs(q(N({},P),{side:"base"}))]:[],...d?[Hs(q(N({},P),{side:"quote"}))]:[]]}).versionBuild({txVersion:r})}};var jp=Buffer.from("vault_auth_seed","utf8"),Hp=Buffer.from("global_config","utf8"),Zp=Buffer.from("pool_vesting","utf8"),$p=Buffer.from("platform_config","utf8"),Jp=Buffer.from("platform_fee_vault_auth_seed","utf8"),ef=Buffer.from("creator_fee_vault_auth_seed","utf8");function pn(c){return ne([jp],c)}function GK(c,e,t,n){return ne([Hp,e.toBuffer(),tf(t),Rr(n)],c)}function vo(c,e,t){return ne([fs,e.toBuffer(),t.toBuffer()],c)}function Zs(c,e,t){return ne([ys,e.toBuffer(),t.toBuffer()],c)}function so(c){return ne([Buffer.from("__event_authority","utf8")],c)}function tf(c){let e=new ArrayBuffer(1);return new DataView(e).setUint8(0,c),new Uint8Array(e)}function $s(c,e){return ne([$p,e.toBuffer()],c)}function Wi(c,e,t){return ne([Zp,e.toBuffer(),t.toBuffer()],c)}function uo(c,e,t){return ne([e.toBuffer(),t.toBuffer()],c)}function Js(c){return ne([Jp],c)}function Fo(c,e,t){return ne([e.toBuffer(),t.toBuffer()],c)}function Kl(c){return ne([ef],c)}import{SystemProgram as Gt,TransactionInstruction as vt}from"@solana/web3.js";import{ASSOCIATED_TOKEN_PROGRAM_ID as ea,TOKEN_2022_PROGRAM_ID as nf,TOKEN_PROGRAM_ID as eu}from"@solana/spl-token";import qi from"bn.js";var Ft={initialize:Buffer.from([175,175,109,31,13,152,155,237]),buyExactIn:Buffer.from([250,234,13,123,213,156,19,236]),buyExactOut:Buffer.from([24,211,116,40,105,3,153,56]),sellExactIn:Buffer.from([149,39,222,155,211,124,152,26]),sellExactOut:Buffer.from([95,200,71,34,8,9,11,166]),createVestingAccount:Buffer.from([129,178,2,13,217,172,230,218]),claimVestedToken:Buffer.from([49,33,104,30,189,157,79,35]),createPlatformConfig:Buffer.from([176,90,196,175,253,113,220,20]),claimPlatformFee:Buffer.from([156,39,208,135,76,237,61,72]),updatePlaformConfig:Buffer.from([195,60,76,129,146,45,67,143]),initializeWithToken2022:Buffer.from([37,190,126,222,44,154,171,17]),claimPlatformFeeFromVault:Buffer.from([117,241,198,168,248,218,80,29]),claimCreatorFee:Buffer.from([26,97,138,203,132,171,141,252])};function Cl(c,e,t,n,o,r,i,a,u,s,l,d,p,m,f,y,b,g,P,h){let I=V([_("decimals"),Bt("name"),Bt("symbol"),Bt("uri")]),T=V([k("totalLockedAmount"),k("cliffPeriod"),k("unlockPeriod")]),w=V([_("index"),k("supply"),k("totalFundRaisingB"),_("migrateType")]),x=V([_("index"),k("supply"),k("totalSellA"),k("totalFundRaisingB"),_("migrateType")]),S=[{pubkey:e,isSigner:!0,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!1,isWritable:!1},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!0,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!1},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:d,isSigner:!1,isWritable:!0},{pubkey:eu,isSigner:!1,isWritable:!1},{pubkey:eu,isSigner:!1,isWritable:!1},{pubkey:jt,isSigner:!1,isWritable:!1},{pubkey:Gt.programId,isSigner:!1,isWritable:!1},{pubkey:Ze,isSigner:!1,isWritable:!1},{pubkey:so(c).publicKey,isSigner:!1,isWritable:!1},{pubkey:c,isSigner:!1,isWritable:!1}],K=Buffer.alloc(Buffer.from(m,"utf-8").length+Buffer.from(f,"utf-8").length+Buffer.from(y,"utf-8").length+4*3+1),B=Buffer.alloc(T.span),C=Buffer.alloc(b.type==="ConstantCurve"?x.span:w.span);return I.encode({decimals:p,name:m,symbol:f,uri:y},K),b.type==="ConstantCurve"?x.encode(q(N({index:0},b),{migrateType:b.migrateType==="amm"?0:1}),C):b.type==="FixedCurve"?w.encode(q(N({index:1},b),{migrateType:b.migrateType==="amm"?0:1}),C):b.type==="LinearCurve"&&w.encode(q(N({index:2},b),{migrateType:b.migrateType==="amm"?0:1}),C),T.encode({totalLockedAmount:g,cliffPeriod:P,unlockPeriod:h},B),new vt({keys:S,programId:c,data:Buffer.from([...Ft.initialize,...K,...C,...B])})}function Rl(c,e,t,n,o,r,i,a,u,s,l,d,p,m,f,y,b,g,P,h){let I=V([_("decimals"),Bt("name"),Bt("symbol"),Bt("uri")]),T=V([k("totalLockedAmount"),k("cliffPeriod"),k("unlockPeriod"),_("transferFeeExtensionParamsOption"),V([Rt("transferFeeBasePoints"),k("maxinumFee")]).replicate("transferFeeExtensionParams")]),w=V([_("index"),k("supply"),k("totalFundRaisingB"),_("migrateType")]),x=V([_("index"),k("supply"),k("totalSellA"),k("totalFundRaisingB"),_("migrateType")]),S=[{pubkey:e,isSigner:!0,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!1,isWritable:!1},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!0,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!1},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:nf,isSigner:!1,isWritable:!1},{pubkey:eu,isSigner:!1,isWritable:!1},{pubkey:Gt.programId,isSigner:!1,isWritable:!1},{pubkey:so(c).publicKey,isSigner:!1,isWritable:!1},{pubkey:c,isSigner:!1,isWritable:!1}],K=Buffer.alloc(Buffer.from(p,"utf-8").length+Buffer.from(m,"utf-8").length+Buffer.from(f,"utf-8").length+4*3+1),B=Buffer.alloc(T.span),C=Buffer.alloc(y.type==="ConstantCurve"?x.span:w.span);return I.encode({decimals:d,name:p,symbol:m,uri:f},K),y.type==="ConstantCurve"?x.encode(q(N({index:0},y),{migrateType:y.migrateType==="amm"?0:1}),C):y.type==="FixedCurve"?w.encode(q(N({index:1},y),{migrateType:y.migrateType==="amm"?0:1}),C):y.type==="LinearCurve"&&w.encode(q(N({index:2},y),{migrateType:y.migrateType==="amm"?0:1}),C),T.encode({totalLockedAmount:b,cliffPeriod:g,unlockPeriod:P,transferFeeExtensionParamsOption:h?1:0,transferFeeExtensionParams:h!=null?h:{transferFeeBasePoints:0,maxinumFee:new qi(0)}},B),new vt({keys:S,programId:c,data:Buffer.from([...Ft.initializeWithToken2022,...K,...C,...B])})}function Ll(c,e,t,n,o,r,i,a,u,s,l,d,p,m,f,y,b,g,P,h){let I=V([k("amountB"),k("minAmountA"),k("shareFeeRate")]),T=[{pubkey:e,isSigner:!0,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!1},{pubkey:d,isSigner:!1,isWritable:!1},{pubkey:p,isSigner:!1,isWritable:!1},{pubkey:m,isSigner:!1,isWritable:!1},{pubkey:so(c).publicKey,isSigner:!1,isWritable:!1},{pubkey:c,isSigner:!1,isWritable:!1}];h&&T.push({pubkey:h,isSigner:!1,isWritable:!0}),T.push({pubkey:Gt.programId,isSigner:!1,isWritable:!1}),T.push({pubkey:f,isSigner:!1,isWritable:!0}),T.push({pubkey:y,isSigner:!1,isWritable:!0});let w=Buffer.alloc(I.span);return I.encode({amountB:b,minAmountA:g,shareFeeRate:P!=null?P:new qi(0)},w),new vt({keys:T,programId:c,data:Buffer.from([...Ft.buyExactIn,...w])})}function Ol(c,e,t,n,o,r,i,a,u,s,l,d,p,m,f,y,b,g,P,h){let I=V([k("amountA"),k("maxAmountB"),k("shareFeeRate")]),T=[{pubkey:e,isSigner:!0,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!1},{pubkey:d,isSigner:!1,isWritable:!1},{pubkey:p,isSigner:!1,isWritable:!1},{pubkey:m,isSigner:!1,isWritable:!1},{pubkey:so(c).publicKey,isSigner:!1,isWritable:!1},{pubkey:c,isSigner:!1,isWritable:!1}];h&&T.push({pubkey:h,isSigner:!1,isWritable:!0}),T.push({pubkey:Gt.programId,isSigner:!1,isWritable:!1}),T.push({pubkey:f,isSigner:!1,isWritable:!0}),T.push({pubkey:y,isSigner:!1,isWritable:!0});let w=Buffer.alloc(I.span);return I.encode({amountA:b,maxAmountB:g,shareFeeRate:P!=null?P:new qi(0)},w),new vt({keys:T,programId:c,data:Buffer.from([...Ft.buyExactOut,...w])})}function Nl(c,e,t,n,o,r,i,a,u,s,l,d,p,m,f,y,b,g,P,h){let I=V([k("amountA"),k("minAmountB"),k("shareFeeRate")]),T=[{pubkey:e,isSigner:!0,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!1},{pubkey:d,isSigner:!1,isWritable:!1},{pubkey:p,isSigner:!1,isWritable:!1},{pubkey:m,isSigner:!1,isWritable:!1},{pubkey:so(c).publicKey,isSigner:!1,isWritable:!1},{pubkey:c,isSigner:!1,isWritable:!1}];h&&T.push({pubkey:h,isSigner:!1,isWritable:!0}),T.push({pubkey:Gt.programId,isSigner:!1,isWritable:!1}),T.push({pubkey:f,isSigner:!1,isWritable:!0}),T.push({pubkey:y,isSigner:!1,isWritable:!0});let w=Buffer.alloc(I.span);return I.encode({amountA:b,minAmountB:g,shareFeeRate:P!=null?P:new qi(0)},w),new vt({keys:T,programId:c,data:Buffer.from([...Ft.sellExactIn,...w])})}function Ml(c,e,t,n,o,r,i,a,u,s,l,d,p,m,f,y,b,g,P,h){let I=V([k("amountB"),k("maxAmountA"),k("shareFeeRate")]),T=[{pubkey:e,isSigner:!0,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!1},{pubkey:d,isSigner:!1,isWritable:!1},{pubkey:p,isSigner:!1,isWritable:!1},{pubkey:m,isSigner:!1,isWritable:!1},{pubkey:so(c).publicKey,isSigner:!1,isWritable:!1},{pubkey:c,isSigner:!1,isWritable:!1}];h&&T.push({pubkey:h,isSigner:!1,isWritable:!0}),T.push({pubkey:Gt.programId,isSigner:!1,isWritable:!1}),T.push({pubkey:f,isSigner:!1,isWritable:!0}),T.push({pubkey:y,isSigner:!1,isWritable:!0});let w=Buffer.alloc(I.span);return I.encode({amountB:b,maxAmountA:g,shareFeeRate:P!=null?P:new qi(0)},w),new vt({keys:T,programId:c,data:Buffer.from([...Ft.sellExactOut,...w])})}function tu(c,e,t,n,o,r,i,a,u){let s=V([]),l=[{pubkey:e,isSigner:!0,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!1},{pubkey:u,isSigner:!1,isWritable:!1},{pubkey:Gt.programId,isSigner:!1,isWritable:!1},{pubkey:ea,isSigner:!1,isWritable:!1}],d=Buffer.alloc(s.span);return s.encode({},d),new vt({keys:l,programId:c,data:Buffer.from([...Ft.claimVestedToken,...d])})}function nu(c,e,t,n,o,r){let i=V([k("shareAmount")]),a=[{pubkey:e,isSigner:!0,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:Gt.programId,isSigner:!1,isWritable:!1}],u=Buffer.alloc(i.span);return i.encode({shareAmount:r},u),new vt({keys:a,programId:c,data:Buffer.from([...Ft.createVestingAccount,...u])})}function ou(c,e,t,n,o,r,i,a,u){let s=[{pubkey:e,isSigner:!0,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:Gt.programId,isSigner:!1,isWritable:!0},{pubkey:ea,isSigner:!1,isWritable:!0}];return new vt({keys:s,programId:c,data:Ft.claimPlatformFee})}function vl(c,e,t,n,o,r,i,a,u,s,l,d,p){let m=V([k("platformScale"),k("creatorScale"),k("burnScale"),k("feeRate"),Bt("name"),Bt("web"),Bt("img"),k("creatorFeeRate")]),f=[{pubkey:e,isSigner:!0,isWritable:!0},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:Gt.programId,isSigner:!1,isWritable:!1},{pubkey:i,isSigner:!1,isWritable:!1}],y=Buffer.alloc(8*5+Buffer.from(l,"utf-8").length+Buffer.from(d,"utf-8").length+Buffer.from(p,"utf-8").length+4*3);return m.encode({platformScale:a.platformScale,creatorScale:a.creatorScale,burnScale:a.burnScale,feeRate:u,name:l,web:d,img:p,creatorFeeRate:s},y),new vt({keys:f,programId:c,data:Buffer.from([...Ft.createPlatformConfig,...y])})}function Fl(c,e,t,n){let o=[{pubkey:e,isSigner:!0,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!0}],r;if(n.type==="updateClaimFeeWallet"){let i=V([_("index"),O("value")]);r=Buffer.alloc(i.span),i.encode({index:0,value:n.value},r)}else if(n.type==="updateLockNftWallet"){let i=V([_("index"),O("value")]);r=Buffer.alloc(i.span),i.encode({index:1,value:n.value},r)}else if(n.type==="migrateCpLockNftScale"){let i=V([_("index"),k("platformScale"),k("creatorScale"),k("burnScale")]);r=Buffer.alloc(i.span),i.encode(N({index:2},n.value),r)}else if(n.type==="updateFeeRate"){let i=V([_("index"),k("value")]);r=Buffer.alloc(i.span),i.encode({index:3,value:n.value},r)}else if(n.type==="updateImg"||n.type==="updateName"||n.type==="updateWeb"){let i=V([_("index"),Bt("value")]);r=Buffer.alloc(Buffer.from(n.value,"utf-8").length+4+1*1),n.type==="updateName"?i.encode({index:4,value:n.value},r):n.type==="updateWeb"?i.encode({index:5,value:n.value},r):n.type==="updateImg"&&i.encode({index:6,value:n.value},r)}else if(n.type==="updateCpConfigId"){o.push({pubkey:n.value,isSigner:!1,isWritable:!1});let i=V([_("index")]);r=Buffer.alloc(i.span),i.encode({index:7},r)}else if(n.type==="updateAll"){o.push({pubkey:n.value.cpConfigId,isSigner:!1,isWritable:!1});let i=V([_("index"),O("platformClaimFeeWallet"),O("platformLockNftWallet"),k("platformScale"),k("creatorScale"),k("burnScale"),k("feeRate"),Bt("name"),Bt("web"),Bt("img"),O("transferFeeExtensionAuth"),k("creatorFeeRate")]);r=Buffer.alloc(1+32+32+8*4+4*3+Buffer.from(n.value.name,"utf-8").length+Buffer.from(n.value.web,"utf-8").length+Buffer.from(n.value.img,"utf-8").length),i.encode({index:8,platformClaimFeeWallet:n.value.platformClaimFeeWallet,platformLockNftWallet:n.value.platformLockNftWallet,platformScale:n.value.migrateCpLockNftScale.platformScale,creatorScale:n.value.migrateCpLockNftScale.creatorScale,burnScale:n.value.migrateCpLockNftScale.burnScale,feeRate:n.value.feeRate,name:n.value.name,web:n.value.web,img:n.value.img,transferFeeExtensionAuth:n.value.transferFeeExtensionAuth,creatorFeeRate:n.value.creatorFeeRate},r)}else throw Error("updateInfo params type error");return new vt({keys:o,programId:c,data:Buffer.from([...Ft.updatePlaformConfig,...r])})}function iu(c,e,t,n,o,r,i,a){let u=[{pubkey:t,isSigner:!0,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:e,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!1},{pubkey:a,isSigner:!1,isWritable:!1},{pubkey:Gt.programId,isSigner:!1,isWritable:!1},{pubkey:ea,isSigner:!1,isWritable:!1}];return new vt({keys:u,programId:c,data:Ft.claimPlatformFeeFromVault})}function Vl(c,e,t,n,o,r,i){let a=[{pubkey:e,isSigner:!0,isWritable:!0},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!1},{pubkey:i,isSigner:!1,isWritable:!1},{pubkey:Gt.programId,isSigner:!1,isWritable:!1},{pubkey:ea,isSigner:!1,isWritable:!1}];return new vt({keys:a,programId:c,data:Ft.claimCreatorFee})}import{NATIVE_MINT as Bn,TOKEN_2022_PROGRAM_ID as xn,TOKEN_PROGRAM_ID as Xe,createAssociatedTokenAccountIdempotentInstruction as Qt,getTransferFeeConfig as sa,unpackMint as ua}from"@solana/spl-token";import re from"bn.js";import{PublicKey as El}from"@solana/web3.js";var En=V([k(),k("epoch"),_("curveType"),Rt("index"),k("migrateFee"),k("tradeFeeRate"),k("maxShareFeeRate"),k("minSupplyA"),k("maxLockRate"),k("minSellRateA"),k("minMigrateRateA"),k("minFundRaisingB"),O("mintB"),O("protocolFeeOwner"),O("migrateFeeOwner"),O("migrateToAmmWallet"),O("migrateToCpmmWallet"),Y(k(),16)]),of=V([k("totalLockedAmount"),k("cliffPeriod"),k("unlockPeriod"),k("startTime"),k("totalAllocatedShare")]),on=V([k(),k("epoch"),_("bump"),_("status"),_("mintDecimalsA"),_("mintDecimalsB"),_("migrateType"),k("supply"),k("totalSellA"),k("virtualA"),k("virtualB"),k("realA"),k("realB"),k("totalFundRaisingB"),k("protocolFee"),k("platformFee"),k("migrateFee"),of.replicate("vestingSchedule"),O("configId"),O("platformId"),O("mintA"),O("mintB"),O("vaultA"),O("vaultB"),O("creator"),_("mintProgramFlag"),Y(_(),63)]),nC=V([k(),k("epoch"),O("poolId"),O("beneficiary"),k("claimedAmount"),k("tokenShareAmount"),Y(k(),8)]),Vo=V([k(),k("epoch"),O("platformClaimFeeWallet"),O("platformLockNftWallet"),k("platformScale"),k("creatorScale"),k("burnScale"),k("feeRate"),Y(_(),64,"name"),Y(_(),256,"web"),Y(_(),256,"img"),O("cpConfigId"),k("creatorFeeRate"),O("transferFeeExtensionAuth"),Y(_(),184)]);import Xt from"bn.js";import _l from"decimal.js";import ta from"bn.js";import Ui from"decimal.js";var Dn=class{static getPoolInitPriceByPool({poolInfo:e,decimalA:t,decimalB:n}){throw Error()}static getPoolInitPriceByInit({a:e,b:t,decimalA:n,decimalB:o}){throw Error()}static getPoolPrice({poolInfo:e,decimalA:t,decimalB:n}){throw Error()}static getPoolEndPrice({supply:e,totalSell:t,totalLockedAmount:n,totalFundRaising:o,migrateFee:r,decimalA:i,decimalB:a}){throw Error()}static getPoolEndPriceReal({poolInfo:e,decimalA:t,decimalB:n}){throw Error()}static getInitParam({supply:e,totalFundRaising:t,totalSell:n,totalLockedAmount:o,migrateFee:r}){throw Error()}static buyExactIn({poolInfo:e,amount:t}){throw Error()}static buyExactOut({poolInfo:e,amount:t}){throw Error()}static sellExactIn({poolInfo:e,amount:t}){throw Error()}static sellExactOut({poolInfo:e,amount:t}){throw Error()}};var na=class extends Dn{static getPoolInitPriceByPool({poolInfo:e,decimalA:t,decimalB:n}){return new Ui(e.virtualB.toString()).div(e.virtualA.toString()).mul(10**(t-n))}static getPoolInitPriceByInit({a:e,b:t,decimalA:n,decimalB:o}){return new Ui(t.toString()).div(e.toString()).mul(10**(n-o))}static getPoolPrice({poolInfo:e,decimalA:t,decimalB:n}){return new Ui(e.virtualB.add(e.realB).toString()).div(e.virtualA.sub(e.realA).toString()).mul(10**(t-n))}static getPoolEndPrice({supply:e,totalSell:t,totalLockedAmount:n,totalFundRaising:o,migrateFee:r,decimalA:i,decimalB:a}){return new Ui(o.sub(r).toString()).div(e.sub(t).sub(n).toString()).mul(10**(i-a))}static getPoolEndPriceReal({poolInfo:e,decimalA:t,decimalB:n}){let o=e.totalSellA.sub(e.realA),r=e.totalFundRaisingB.sub(e.realB);return new Ui(e.virtualB.add(e.realB.add(r)).toString()).div(e.virtualA.sub(e.realA.add(o)).toString()).mul(10**(t-n))}static getInitParam({supply:e,totalFundRaising:t,totalSell:n,totalLockedAmount:o,migrateFee:r}){if(e.lte(n))throw Error("supply need gt total sell");let i=e.sub(n).sub(o);if(i.lte(new ta(0)))throw Error("supplyMinusSellLocked <= 0");let a=t.sub(r);if(a.lte(new ta(0)))throw Error("tfMinusMf <= 0");let u=a.mul(n).mul(n).div(i),s=a.mul(n).div(i).sub(t),l=u.div(s),d=t.mul(t).div(s);if(l.lt(new ta(0))||d.lt(new ta(0)))throw Error("invalid input 0");return{a:l,b:d,c:n}}static buyExactIn({poolInfo:e,amount:t}){return this.getAmountOut({amountIn:t,inputReserve:e.virtualB.add(e.realB),outputReserve:e.virtualA.sub(e.realA)})}static buyExactOut({poolInfo:e,amount:t}){return this.getAmountIn({amountOut:t,inputReserve:e.virtualB.add(e.realB),outputReserve:e.virtualA.sub(e.realA)})}static sellExactIn({poolInfo:e,amount:t}){return this.getAmountOut({amountIn:t,inputReserve:e.virtualA.sub(e.realA),outputReserve:e.virtualB.add(e.realB)})}static sellExactOut({poolInfo:e,amount:t}){return this.getAmountIn({amountOut:t,inputReserve:e.virtualA.sub(e.realA),outputReserve:e.virtualB.add(e.realB)})}static getAmountOut({amountIn:e,inputReserve:t,outputReserve:n}){let o=e.mul(n),r=t.add(e);return o.div(r)}static getAmountIn({amountOut:e,inputReserve:t,outputReserve:n}){let o=t.mul(e),r=n.sub(e);return Gn(o,r)}};import oa from"bn.js";import Gi from"decimal.js";var ia=class extends Dn{static getPoolInitPriceByPool({poolInfo:e,decimalA:t,decimalB:n}){return new Gi(e.virtualB.toString()).div(e.virtualA.toString()).mul(10**(t-n))}static getPoolInitPriceByInit({a:e,b:t,decimalA:n,decimalB:o}){return new Gi(t.toString()).div(e.toString()).mul(10**(n-o))}static getPoolPrice({poolInfo:e,decimalA:t,decimalB:n}){return new Gi(e.virtualB.toString()).div(e.virtualA.toString()).mul(10**(t-n))}static getPoolEndPrice({supply:e,totalSell:t,totalLockedAmount:n,totalFundRaising:o,migrateFee:r,decimalA:i,decimalB:a}){return new Gi(o.sub(r).toString()).div(e.sub(t).sub(n).toString()).mul(10**(i-a))}static getPoolEndPriceReal({poolInfo:e,decimalA:t,decimalB:n}){let o=e.totalSellA.sub(e.realA),r=e.totalFundRaisingB.sub(e.realB);return new Gi(e.virtualB.add(e.realB).add(r).toString()).div(e.virtualA.sub(e.realA).add(o).toString()).mul(10**(t-n))}static getInitParam({supply:e,totalFundRaising:t,totalSell:n,totalLockedAmount:o,migrateFee:r}){let i=e.sub(o);if(i.lte(new oa(0)))throw Error("invalid input 1");let a=new oa(2).mul(t).sub(r),s=t.mul(i).div(a);if(s.lt(new oa(0))||t.lt(new oa(0)))throw Error("invalid input 0");return{a:s,b:t,c:s}}static buyExactIn({poolInfo:e,amount:t}){return this.getAmountOut({amountIn:t,initInput:e.virtualB,initOutput:e.virtualA})}static buyExactOut({poolInfo:e,amount:t}){return this.getAmountIn({amountOut:t,initInput:e.virtualB,initOutput:e.virtualA})}static sellExactIn({poolInfo:e,amount:t}){return this.getAmountOut({amountIn:t,initInput:e.virtualA,initOutput:e.virtualB})}static sellExactOut({poolInfo:e,amount:t}){return this.getAmountIn({amountOut:t,initInput:e.virtualA,initOutput:e.virtualB})}static getAmountOut({amountIn:e,initInput:t,initOutput:n}){return n.mul(e).div(t)}static getAmountIn({amountOut:e,initInput:t,initOutput:n}){let o=t.mul(e);return Gn(o,n)}};import Kt from"bn.js";import co from"decimal.js";import _o from"bn.js";import ra from"decimal.js";var Xi=class{static _multipler(e){return new ra(10).pow(e)}static getPrice({priceX64:e,decimalA:t,decimalB:n}){return new ra(e.toString()).div(this._Q64).mul(this._multipler(t)).div(this._multipler(n))}static getPriceX64({price:e,decimalA:t,decimalB:n}){let o=e.mul(this._multipler(n)).div(this._multipler(t));return new _o(o.mul(this._Q64).toFixed(0))}};Xi._Q64=new ra(new _o(1).shln(64).toString());function PC({supply:c,totalFundRaisingB:e,totalLockedAmount:t,totalSellA:n,migrateType:o,decimalsA:r}){let i=c.sub(n).sub(t),a=new _o(new ra(i.mul(e).toString()).sqrt().toFixed(0));if(o==="amm"){if(a.gt(new _o(10).pow(new _o(r))))return!0}else if(o==="cpmm"){if(a.gt(new _o(100)))return!0}else throw Error("migrate type error");return!1}var aa=class extends Dn{static getPoolInitPriceByPool({poolInfo:e,decimalA:t,decimalB:n}){return new co(0)}static getPoolInitPriceByInit({a:e,b:t,decimalA:n,decimalB:o}){return new co(0)}static getPoolPrice({poolInfo:e,decimalA:t,decimalB:n}){return new co(e.virtualA.mul(e.realA).toString()).div(Xi._Q64).mul(10**(t-n))}static getPoolEndPrice({supply:e,totalSell:t,totalLockedAmount:n,totalFundRaising:o,migrateFee:r,decimalA:i,decimalB:a}){return new co(o.sub(r).toString()).div(e.sub(t).sub(n).toString()).mul(10**(i-a))}static getPoolEndPriceReal({poolInfo:e,decimalA:t,decimalB:n}){let o=e.totalSellA.sub(e.realA),r=e.totalFundRaisingB.sub(e.realB);return new co(e.virtualB.add(e.realB).add(r).toString()).div(e.virtualA.sub(e.realA).add(o).toString()).mul(10**(t-n))}static getInitParam({supply:e,totalFundRaising:t,totalSell:n,totalLockedAmount:o,migrateFee:r}){let i=e.sub(o);if(i.lte(new Kt(0)))throw Error("supplyMinusLocked need gt 0");let a=t.mul(new Kt(3)).sub(r),s=t.mul(new Kt(2)).mul(i).div(a),l=s.mul(s),d=t.mul(new Kt(2)).mul(Je).div(l);if(!d.gt(new Kt(0)))throw Error("a need gt 0");if(!fi.gt(d))throw Error("a need lt u64 max");if(d.lt(new Kt(0))||s.lt(new Kt(0)))throw Error("invalid input 0");return{a:d,b:new Kt(0),c:s}}static buyExactIn({poolInfo:e,amount:t}){let n=e.realB.add(t),o=new Kt(2).mul(n).mul(Je).div(e.virtualA);return new Kt(new co(o.toString()).sqrt().toFixed(0)).sub(e.realA)}static buyExactOut({poolInfo:e,amount:t}){let n=e.realA.add(t),o=n.mul(n);return Gn(e.virtualA.mul(o),new Kt(2).mul(Je)).sub(e.realB)}static sellExactIn({poolInfo:e,amount:t}){let n=e.realA.sub(t),o=n.mul(n),r=Gn(e.virtualA.mul(o),new Kt(2).mul(Je));return e.realB.sub(r)}static sellExactOut({poolInfo:e,amount:t}){let n=e.realB.sub(t),o=new Kt(2).mul(n).mul(Je).div(e.virtualA),r=new Kt(new co(o.toString()).sqrt().toFixed(0));return e.realA.sub(r)}};var zt=class{static getPoolCurvePointByPoolInfo({curveType:e,pointCount:t,poolInfo:n}){return this.getPoolCurvePointByInit({curveType:e,pointCount:t,supply:n.supply,totalFundRaising:n.totalFundRaisingB,totalSell:n.totalSellA,totalLockedAmount:n.vestingSchedule.totalLockedAmount,migrateFee:n.migrateFee,decimalA:n.mintDecimalsA,decimalB:n.mintDecimalsB})}static getPoolCurvePointByInit({curveType:e,pointCount:t,supply:n,totalFundRaising:o,totalSell:r,totalLockedAmount:i,migrateFee:a,decimalA:u,decimalB:s}){if(t<3)throw Error("point count < 3");let l=this.getCurve(e),d=l.getInitParam({supply:n,totalFundRaising:o,totalSell:r,totalLockedAmount:i,migrateFee:a}),p=l.getPoolInitPriceByInit(q(N({},d),{decimalA:u,decimalB:s})),m=o.div(new Xt(t-1)),f=new Xt(0),y=[{price:p,totalSellSupply:0}],{a:b,b:g}=d,P=f,h=f;for(let I=1;I<t;I++){let T=I!==t-1?m:o.sub(h),w=this.buyExactIn({poolInfo:{virtualA:b,virtualB:g,realA:P,realB:h,totalFundRaisingB:o,totalSellA:r},amountB:T,protocolFeeRate:f,platformFeeRate:f,curveType:e,shareFeeRate:f,creatorFeeRate:f,transferFeeConfigA:void 0,slot:0});P=P.add(w.amountA.amount),h=h.add(w.amountB);let x=this.getPrice({poolInfo:{virtualA:b,virtualB:g,realA:P,realB:h},decimalA:u,decimalB:s,curveType:e});y.push({price:x,totalSellSupply:new _l(P.toString()).div(10**u).toNumber()})}return y}static getPoolInitPriceByPool({poolInfo:e,decimalA:t,decimalB:n,curveType:o}){return this.getCurve(o).getPoolInitPriceByPool({poolInfo:e,decimalA:t,decimalB:n})}static getPoolInitPriceByInit({a:e,b:t,decimalA:n,decimalB:o,curveType:r}){return this.getCurve(r).getPoolInitPriceByInit({a:e,b:t,decimalA:n,decimalB:o})}static getPrice({poolInfo:e,curveType:t,decimalA:n,decimalB:o}){return this.getCurve(t).getPoolPrice({poolInfo:e,decimalA:n,decimalB:o})}static getEndPrice({poolInfo:e,curveType:t,decimalA:n,decimalB:o}){return this.getCurve(t).getPoolPrice({poolInfo:e,decimalA:n,decimalB:o})}static getPoolEndPriceReal({poolInfo:e,curveType:t,decimalA:n,decimalB:o}){return this.getCurve(t).getPoolEndPriceReal({poolInfo:e,decimalA:n,decimalB:o})}static checkParam({supply:e,totalFundRaising:t,totalSell:n,totalLockedAmount:o,decimals:r,config:i,migrateType:a}){if(Number(r)!==6)throw Error("decimals = 6");if(e.mul(i.maxLockRate).div(Jt).lt(o))throw Error("total lock amount gte max lock amount");if(e.lt(i.minSupplyA.mul(new Xt(10**r))))throw Error("supply lt min supply");let s=e.mul(i.minSellRateA).div(Jt);if(n.lt(s))throw Error("invalid input");if(t.lt(i.minFundRaisingB))throw Error("total fund raising lt min fund raising");let l=e.sub(n).sub(o),d=e.mul(i.minMigrateRateA).div(Jt);if(l.lt(d))throw Error("migrate lt min migrate amoount");let p=e.sub(n).sub(o),m=new Xt(new _l(p.mul(t).toString()).sqrt().toFixed(0));if(a==="amm"){let f=new Xt(10).pow(new Xt(r));if(m.lte(f))throw Error("check migrate lp error")}else if(a==="cpmm"){let f=new Xt(100);if(m.lte(f))throw Error("check migrate lp error")}else throw Error("migrate type error")}static buyExactIn({poolInfo:e,amountB:t,protocolFeeRate:n,platformFeeRate:o,curveType:r,shareFeeRate:i,creatorFeeRate:a,transferFeeConfigA:u,slot:s}){let l=this.totalFeeRate({protocolFeeRate:n,platformFeeRate:o,shareFeeRate:i,creatorFeeRate:a}),d=this.calculateFee({amount:t,feeRate:l}),p=t.sub(d),m=this.getCurve(r),f=m.buyExactIn({poolInfo:e,amount:p}),y=e.totalSellA.sub(e.realA),b,g,P;if(f.gt(y)){b=y;let I=m.buyExactOut({poolInfo:e,amount:b});g=this.calculatePreFee({postFeeAmount:I,feeRate:l}),P=g.sub(I)}else b=f,g=t,P=d;let h=this.splitFee({totalFee:P,protocolFeeRate:n,platformFeeRate:o,shareFeeRate:i,creatorFeeRate:a});return{amountA:Ra(b,u,s),amountB:g,splitFee:h}}static buyExactOut({poolInfo:e,amountA:t,protocolFeeRate:n,platformFeeRate:o,curveType:r,shareFeeRate:i,creatorFeeRate:a,transferFeeConfigA:u,slot:s}){let l=e.totalSellA.sub(e.realA),d=La(t,u,s),p=d.fee?d.amount.add(d.fee):d.amount;t.gt(l)&&(p=l);let f=this.getCurve(r).buyExactOut({poolInfo:e,amount:p}),y=this.totalFeeRate({protocolFeeRate:n,platformFeeRate:o,shareFeeRate:i,creatorFeeRate:a}),b=this.calculatePreFee({postFeeAmount:f,feeRate:y}),g=b.sub(f),P=this.splitFee({totalFee:g,protocolFeeRate:n,platformFeeRate:o,shareFeeRate:i,creatorFeeRate:a});return{amountA:d,amountB:b,splitFee:P}}static sellExactIn({poolInfo:e,amountA:t,protocolFeeRate:n,platformFeeRate:o,curveType:r,shareFeeRate:i,creatorFeeRate:a,transferFeeConfigA:u,slot:s}){let l=this.getCurve(r),d=Ra(t,u,s),p=d.fee?d.amount.sub(d.fee):d.amount,m=l.sellExactIn({poolInfo:e,amount:p}),f=this.calculateFee({amount:m,feeRate:this.totalFeeRate({protocolFeeRate:n,platformFeeRate:o,shareFeeRate:i,creatorFeeRate:a})}),y=this.splitFee({totalFee:f,protocolFeeRate:n,platformFeeRate:o,shareFeeRate:i,creatorFeeRate:a});return{amountA:d,amountB:m.sub(f),splitFee:y}}static sellExactOut({poolInfo:e,amountB:t,protocolFeeRate:n,platformFeeRate:o,curveType:r,shareFeeRate:i,creatorFeeRate:a,transferFeeConfigA:u,slot:s}){let l=this.totalFeeRate({protocolFeeRate:n,platformFeeRate:o,shareFeeRate:i,creatorFeeRate:a}),d=this.calculatePreFee({postFeeAmount:t,feeRate:l});if(e.realB.lt(d))throw Error("Insufficient liquidity");let p=d.sub(t),f=zt.getCurve(r).sellExactOut({poolInfo:e,amount:d});if(f.gt(e.realA))throw Error();let y=this.splitFee({totalFee:p,protocolFeeRate:n,platformFeeRate:o,shareFeeRate:i,creatorFeeRate:a});return{amountA:La(f,u,s),amountB:t,splitFee:y}}static splitFee({totalFee:e,protocolFeeRate:t,platformFeeRate:n,shareFeeRate:o,creatorFeeRate:r}){let i=this.totalFeeRate({protocolFeeRate:t,platformFeeRate:n,shareFeeRate:o,creatorFeeRate:r}),a=i.isZero()?new Xt(0):e.mul(n).div(i),u=i.isZero()?new Xt(0):e.mul(o).div(i),s=i.isZero()?new Xt(0):e.mul(r).div(i),l=e.sub(a).sub(u).sub(s);return{platformFee:a,shareFee:u,protocolFee:l,creatorFee:s}}static calculateFee({amount:e,feeRate:t}){return ir(e,t,Jt)}static calculatePreFee({postFeeAmount:e,feeRate:t}){if(t.isZero())return e;let n=e.mul(Jt),o=Jt.sub(t);return n.add(o).sub(new Xt(1)).div(o)}static totalFeeRate({protocolFeeRate:e,platformFeeRate:t,shareFeeRate:n,creatorFeeRate:o}){if(e.add(t).add(n).add(o).gt(new Xt(1e6)))throw Error("total fee rate gt 1_000_000");return e.add(t).add(n).add(o)}static getCurve(e){switch(e){case 0:return na;case 1:return ia;case 2:return aa}throw Error("find curve error")}};import Vt from"decimal.js";var lo={initPriceX64:new re("515752397214619"),supply:new re(1e15),totalSellA:new re(7931e11),totalFundRaisingB:new re(85e9),totalLockedAmount:new re("0"),cliffPeriod:new re("0"),unlockPeriod:new re("0"),decimals:6,virtualA:new re("1073471847374405"),virtualB:new re("30050573465"),realA:new re(0),realB:new re(0),protocolFee:new re(0),platformId:new El("4Bu96XjU84XjPDSpveTVf6LYGCkfW5FK7SNkREWcEfV4"),vestingSchedule:{totalLockedAmount:new re(0),cliffPeriod:new re(0),unlockPeriod:new re(0),startTime:new re(0),totalAllocatedShare:new re(0)}},Wn=new re(1e4),zi=class extends Fe{constructor(e){super(e)}async createLaunchpad(M){var F=M,{programId:e=rt,authProgramId:t,platformId:n=lo.platformId,mintA:o,decimals:r=6,mintBDecimals:i=9,name:a,symbol:u,uri:s,migrateType:l,configId:d,snipers:p,configInfo:m,platformFeeRate:f,txVersion:y,computeBudgetConfig:b,txTipConfig:g,feePayer:P,buyAmount:h,minMintAAmount:I,slippage:T,associatedOnly:w=!0,checkCreateATAOwner:x=!1,extraSigners:S,token2022:K,transferFeeExtensionParams:B}=F,C=qe(F,["programId","authProgramId","platformId","mintA","decimals","mintBDecimals","name","symbol","uri","migrateType","configId","snipers","configInfo","platformFeeRate","txVersion","computeBudgetConfig","txTipConfig","feePayer","buyAmount","minMintAAmount","slippage","associatedOnly","checkCreateATAOwner","extraSigners","token2022","transferFeeExtensionParams"]);var Do,Wo,qo,Ct,Yi,su,uu,cu,lu,mu;let R=this.createTxBuilder(P);t=t!=null?t:pn(e).publicKey,console.log("snipers: ",p),K=!!B,K&&(l="cpmm");let L=m;if(!L&&d){let rn=await this.scope.connection.getAccountInfo(d);rn&&(L=En.decode(rn.data))}L||this.logAndCreateError("config not found");let W=L.mintB,z=L.curveType,{publicKey:$}=vo(e,o,W),{publicKey:ae}=Zs(e,$,o),{publicKey:ye}=Zs(e,$,W),{publicKey:ce}=kn(o);this.logDebug(`create token: ${o.toBase58()}, mintB: ${W.toBase58()}, decimals A:${r}/B:${i}, config:${d.toBase58()}`),u.length>10&&this.logAndCreateError("Symbol length should shorter than 11"),s||this.logAndCreateError("uri should not empty");let de=(Do=C==null?void 0:C.supply)!=null?Do:lo.supply,pe=(Wo=C==null?void 0:C.totalSellA)!=null?Wo:lo.totalSellA,le=(qo=C==null?void 0:C.totalFundRaisingB)!=null?qo:lo.totalFundRaisingB,ee=(Ct=C==null?void 0:C.totalLockedAmount)!=null?Ct:new re(0),xe=f;if(!f){let rn=await this.scope.connection.getAccountInfo(n);rn||this.logAndCreateError("platform id not found:",n.toString()),xe=Vo.decode(rn.data).feeRate}let bt=zt.getCurve(L.curveType).getInitParam({supply:de,totalFundRaising:le,totalSell:pe,totalLockedAmount:ee,migrateFee:L.migrateFee}),ut={epoch:new re(896),bump:254,status:0,mintDecimalsA:r,mintDecimalsB:i,supply:de,totalSellA:pe,mintA:new El(o),mintB:W,virtualA:bt.a,virtualB:bt.b,realA:lo.realA,realB:lo.realB,migrateFee:L.migrateFee,migrateType:l==="amm"?0:1,protocolFee:lo.protocolFee,platformFee:xe,platformId:n,configId:d,vaultA:ae,vaultB:ye,creator:this.scope.ownerPubKey,totalFundRaisingB:le,vestingSchedule:{totalLockedAmount:ee,cliffPeriod:new re(0),unlockPeriod:new re(0),startTime:new re(0),totalAllocatedShare:new re(0)},mintProgramFlag:K?1:0},fn=zt.getCurve(L.curveType),{c:tt}=fn.getInitParam({supply:ut.supply,totalFundRaising:ut.totalFundRaisingB,totalLockedAmount:ee,totalSell:L.curveType===0?ut.totalSellA:new re(0),migrateFee:L.migrateFee});try{zt.checkParam({supply:ut.supply,totalFundRaising:ut.totalFundRaisingB,totalSell:tt,totalLockedAmount:ee,decimals:ut.mintDecimalsA,config:L,migrateType:l}),this.logDebug("check init params success")}catch(rn){this.logAndCreateError(`check create mint params failed, ${rn.message}`)}R.addInstruction({instructions:[K?Rl(e,P!=null?P:this.scope.ownerPubKey,this.scope.ownerPubKey,d,n,t,$,o,W,ae,ye,r,a,u,s||"https://",{type:z===0?"ConstantCurve":z===1?"FixedCurve":z===2?"LinearCurve":"ConstantCurve",totalSellA:pe,migrateType:l,supply:de,totalFundRaisingB:le},ee,(Yi=C==null?void 0:C.cliffPeriod)!=null?Yi:new re(0),(su=C==null?void 0:C.unlockPeriod)!=null?su:new re(0),B):Cl(e,P!=null?P:this.scope.ownerPubKey,this.scope.ownerPubKey,d,n,t,$,o,W,ae,ye,ce,r,a,u,s||"https://",{type:z===0?"ConstantCurve":z===1?"FixedCurve":z===2?"LinearCurve":"ConstantCurve",totalSellA:pe,migrateType:l,supply:de,totalFundRaisingB:le},ee,(uu=C==null?void 0:C.cliffPeriod)!=null?uu:new re(0),(cu=C==null?void 0:C.unlockPeriod)!=null?cu:new re(0))]});let qn=K?await this.scope.connection.getEpochInfo():void 0,Tt=B?{epoch:BigInt((qn==null?void 0:qn.epoch)||0),maximumFee:BigInt((lu=B==null?void 0:B.maxinumFee.toString())!=null?lu:0),transferFeeBasisPoints:(mu=B==null?void 0:B.transferFeeBasePoints)!=null?mu:0}:void 0,Eo={amountA:{amount:new re(0),fee:void 0,expirationTime:void 0},amountB:new re(0),splitFee:{platformFee:new re(0),shareFee:new re(0),protocolFee:new re(0),creatorFee:new re(0)}},mo;if(S!=null&&S.length&&R.addInstruction({signers:S}),!C.createOnly){let{builder:rn,extInfo:Dl}=await this.buyToken({programId:e,authProgramId:t,mintAProgram:K?xn:void 0,mintA:o,mintB:W,poolInfo:ut,buyAmount:h,minMintAAmount:I,shareFeeRate:C.shareFeeRate,shareFeeReceiver:C.shareFeeReceiver,configInfo:L,platformFeeRate:xe,slippage:T,associatedOnly:w,checkCreateATAOwner:x,skipCheckMintA:!Tt,transferFeeConfigA:Tt?{transferFeeConfigAuthority:t,withdrawWithheldAuthority:t,withheldAmount:BigInt(0),olderTransferFee:Tt,newerTransferFee:Tt}:void 0}),{builder:uf,extInfo:cf}=await this.buyToken({programId:e,authProgramId:t,mintAProgram:K?xn:void 0,mintA:o,mintB:W,poolInfo:ut,buyAmount:h,minMintAAmount:I,shareFeeRate:C.shareFeeRate,shareFeeReceiver:C.shareFeeReceiver,configInfo:L,platformFeeRate:xe,slippage:T,associatedOnly:w,checkCreateATAOwner:x,skipCheckMintA:!Tt,transferFeeConfigA:Tt?{transferFeeConfigAuthority:t,withdrawWithheldAuthority:t,withheldAmount:BigInt(0),olderTransferFee:Tt,newerTransferFee:Tt}:void 0}),{builder:lf,extInfo:mf}=await this.buyToken({programId:e,authProgramId:t,mintAProgram:K?xn:void 0,mintA:o,mintB:W,poolInfo:ut,buyAmount:h,minMintAAmount:I,shareFeeRate:C.shareFeeRate,shareFeeReceiver:C.shareFeeReceiver,configInfo:L,platformFeeRate:xe,slippage:T,associatedOnly:w,checkCreateATAOwner:x,skipCheckMintA:!Tt,transferFeeConfigA:Tt?{transferFeeConfigAuthority:t,withdrawWithheldAuthority:t,withheldAmount:BigInt(0),olderTransferFee:Tt,newerTransferFee:Tt}:void 0});R.addInstruction(N({},rn.AllTxData)),Eo=N({},Dl),mo=(this.scope.cluster==="devnet"||y===1)&&C.shareFeeReceiver?[rn.allInstructions[0]]:void 0}return R.addTipInstruction(g),y===0?R.sizeCheckBuildV0({computeBudgetConfig:b,swapInfo:Eo,splitIns:mo,address:q(N({},ut),{poolId:$})}):R.sizeCheckBuild({computeBudgetConfig:b,swapInfo:Eo,splitIns:mo,address:q(N({},ut),{poolId:$})})}async buyToken({programId:e=rt,authProgramId:t,mintA:n,mintAProgram:o=Xe,mintB:r=Bn,poolInfo:i,configInfo:a,platformFeeRate:u,txVersion:s,computeBudgetConfig:l,txTipConfig:d,feePayer:p,buyAmount:m,minMintAAmount:f,slippage:y,shareFeeRate:b=new re(0),shareFeeReceiver:g,associatedOnly:P=!0,checkCreateATAOwner:h=!1,transferFeeConfigA:I,skipCheckMintA:T=!1}){var le,ee,xe;m.lte(new re(0))&&this.logAndCreateError("buy amount should gt 0:",m.toString());let w=this.createTxBuilder(p),{publicKey:x}=vo(e,n,r);t=t!=null?t:pn(e).publicKey;let S=I;if(!T)if(S)o=xn;else{let we=await this.scope.connection.getAccountInfo(n);if(we&&we.owner.equals(xn)){o=we.owner;let bt=ua(n,we,o);S=sa(bt)||void 0}}let K=this.scope.account.getAssociatedTokenAccount(n,o),B=null,C=r.equals(Bn);w.addInstruction({instructions:[Qt(this.scope.ownerPubKey,K,this.scope.ownerPubKey,n,o)]});let{account:M,instructionParams:F}=await this.scope.account.getOrCreateTokenAccount({mint:r,owner:this.scope.ownerPubKey,createInfo:C?{payer:this.scope.ownerPubKey,amount:m}:void 0,skipCloseAccount:!C,notUseTokenAccount:C,associatedOnly:C?!1:P,checkCreateATAOwner:h});M&&(B=M),w.addInstruction(F||{}),B===void 0&&this.logAndCreateError(`cannot found mintB(${r.toBase58()}) token accounts`,"tokenAccounts",this.scope.account.tokenAccounts);let R=i;if(!R){let we=await this.scope.connection.getAccountInfo(x,{commitment:"processed"});we||this.logAndCreateError("cannot found pool:",x.toBase58()),R=on.decode(we.data)}let L=a,W=await Oe(this.scope.connection,[L?void 0:R.configId,R.platformId].filter(Boolean).map(we=>({pubkey:we})));if(!L){let we=W.find(bt=>bt.pubkey.equals(R.configId));(!we||!we.accountInfo)&&this.logAndCreateError("config not found: ",R.configId.toBase58()),L=En.decode(we.accountInfo.data)}let z=W.find(we=>we.pubkey.equals(R.platformId));(!z||!z.accountInfo)&&this.logAndCreateError("platform info not found: ",R.configId.toBase58());let $=Vo.decode(z.accountInfo.data);u=u||$.feeRate;let ae=zt.buyExactIn({poolInfo:R,amountB:m,protocolFeeRate:L.tradeFeeRate,platformFeeRate:u,curveType:L.curveType,shareFeeRate:b,creatorFeeRate:$.creatorFeeRate,transferFeeConfigA:S,slot:await this.scope.connection.getSlot()}),ye=new Vt(ae.amountA.amount.toString()).sub((ee=(le=ae.amountA.fee)==null?void 0:le.toString())!=null?ee:0),ce=y?new Vt(Wn.sub(y).toNumber()/Wn.toNumber()).clampedTo(0,1):new Vt(1),de=f!=null?f:y?new re(ye.mul(ce).toFixed(0)):ae.amountA.amount.sub((xe=ae.amountA.fee)!=null?xe:new re(0));ae.amountB.lt(m)&&console.log(`maximum ${n.toBase58()} amount can buy is ${ae.amountA.toString()}, input ${r.toBase58()} amount: ${ae.amountB.toString()}`);let pe=g?j(g,r,Xe).publicKey:void 0;return pe&&w.addInstruction({instructions:[Qt(this.scope.ownerPubKey,pe,g,r)]}),w.addInstruction({instructions:[Ll(e,this.scope.ownerPubKey,t,R.configId,R.platformId,x,K,B,R.vaultA,R.vaultB,n,r,o,Xe,uo(e,R.platformId,r).publicKey,Fo(e,R.creator,r).publicKey,ae.amountB.lt(m)?ae.amountB:m,de,b,pe)]}),w.addCustomComputeBudget(l),w.addTipInstruction(d),w.versionBuild({txVersion:s,extInfo:q(N({},ae),{decimalOutAmount:ye,minDecimalOutAmount:new Vt(de.toString())})})}async buyTokenExactOut({programId:e=rt,authProgramId:t,mintA:n,mintAProgram:o=Xe,mintB:r=Bn,poolInfo:i,configInfo:a,transferFeeConfigA:u,platformFeeRate:s,txVersion:l,computeBudgetConfig:d,txTipConfig:p,feePayer:m,maxBuyAmount:f,outAmount:y,slippage:b,shareFeeRate:g=new re(0),shareFeeReceiver:P,associatedOnly:h=!0,checkCreateATAOwner:I=!1,skipCheckMintA:T=!1}){y.lte(new re(0))&&this.logAndCreateError("out amount should gt 0:",y.toString());let w=this.createTxBuilder(m),{publicKey:x}=vo(e,n,r);t=t!=null?t:pn(e).publicKey;let S=i;if(!S){let le=await this.scope.connection.getAccountInfo(x,{commitment:"processed"});le||this.logAndCreateError("cannot found pool:",x.toBase58()),S=on.decode(le.data)}let K=a,B=await Oe(this.scope.connection,[K?void 0:S.configId,S.platformId].filter(Boolean).map(le=>({pubkey:le})));if(!K){let le=B.find(ee=>ee.pubkey.equals(S.configId));(!le||!le.accountInfo)&&this.logAndCreateError("config not found: ",S.configId.toBase58()),K=En.decode(le.accountInfo.data)}let C=B.find(le=>le.pubkey.equals(S.platformId));(!C||!C.accountInfo)&&this.logAndCreateError("platform info not found: ",S.configId.toBase58());let M=Vo.decode(C.accountInfo.data);s=s||M.feeRate;let F=u;if(!T)if(F)o=xn;else{let le=await this.scope.connection.getAccountInfo(n);if(le&&le.owner.equals(xn)){o=le.owner;let ee=ua(n,le,o);F=sa(ee)||void 0}}let R=zt.buyExactOut({poolInfo:S,amountA:y,protocolFeeRate:K.tradeFeeRate,platformFeeRate:s,curveType:K.curveType,shareFeeRate:g,creatorFeeRate:M.creatorFeeRate,transferFeeConfigA:F,slot:await this.scope.connection.getSlot()}),L=new Vt(R.amountB.toString()),W=b?new Vt(Wn.add(b).toNumber()/Wn.toNumber()).clampedTo(0,Number.MIN_SAFE_INTEGER):new Vt(1),z=(f!=null?f:b)?new re(L.mul(W).toFixed(0)):R.amountB,$=this.scope.account.getAssociatedTokenAccount(n,o),ae=null,ye=r.equals(Bn);w.addInstruction({instructions:[Qt(this.scope.ownerPubKey,$,this.scope.ownerPubKey,n,o)]});let{account:ce,instructionParams:de}=await this.scope.account.getOrCreateTokenAccount({mint:r,owner:this.scope.ownerPubKey,createInfo:ye?{payer:this.scope.ownerPubKey,amount:R.amountB}:void 0,skipCloseAccount:!ye,notUseTokenAccount:ye,associatedOnly:ye?!1:h,checkCreateATAOwner:I});ce&&(ae=ce),w.addInstruction(de||{}),ae===void 0&&this.logAndCreateError(`cannot found mintB(${r.toBase58()}) token accounts`,"tokenAccounts",this.scope.account.tokenAccounts);let pe=P?j(P,r,Xe).publicKey:void 0;return pe&&w.addInstruction({instructions:[Qt(this.scope.ownerPubKey,pe,P,r)]}),w.addInstruction({instructions:[Ol(e,this.scope.ownerPubKey,t,S.configId,S.platformId,x,$,ae,S.vaultA,S.vaultB,n,r,o,Xe,uo(e,S.platformId,r).publicKey,Fo(e,S.creator,r).publicKey,y,z,g,pe)]}),w.addCustomComputeBudget(d),w.addTipInstruction(p),w.versionBuild({txVersion:l,extInfo:{maxSpentAmount:z,outAmount:y}})}async sellToken({programId:e=rt,authProgramId:t,mintAProgram:n=Xe,mintA:o,mintB:r=Bn,poolInfo:i,configInfo:a,platformFeeRate:u,txVersion:s,computeBudgetConfig:l,txTipConfig:d,feePayer:p,sellAmount:m,minAmountB:f,slippage:y,shareFeeRate:b=new re(0),shareFeeReceiver:g,associatedOnly:P=!0,checkCreateATAOwner:h=!1,skipCheckMintA:I=!1}){t=t!=null?t:pn(e).publicKey;let T=this.createTxBuilder(p);m.lte(new re(0))&&this.logAndCreateError("sell amount should be gt 0");let{publicKey:w}=vo(e,o,r),x;if(!I){let ee=await this.scope.connection.getAccountInfo(o);if(ee&&ee.owner.equals(xn)){n=ee.owner;let xe=ua(o,ee,n);x=sa(xe)||void 0}}let S=null,K=null,B=r.equals(Bn),{account:C,instructionParams:M}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:n,mint:o,owner:this.scope.ownerPubKey,createInfo:void 0,skipCloseAccount:!0,notUseTokenAccount:!1,associatedOnly:P,checkCreateATAOwner:h});C&&(S=C),T.addInstruction(M||{}),S===void 0&&this.logAndCreateError("cannot found mintA token accounts","tokenAccounts",this.scope.account.tokenAccounts);let{account:F,instructionParams:R}=await this.scope.account.getOrCreateTokenAccount({mint:r,owner:this.scope.ownerPubKey,createInfo:B?{payer:this.scope.ownerPubKey,amount:0}:void 0,skipCloseAccount:!B,notUseTokenAccount:B,associatedOnly:B?!1:P,checkCreateATAOwner:h});F&&(K=F),T.addInstruction(R||{}),K===void 0&&this.logAndCreateError("cannot found mintB token accounts","tokenAccounts",this.scope.account.tokenAccounts);let L=i;if(!L){let ee=await this.scope.connection.getAccountInfo(w,{commitment:"processed"});ee||this.logAndCreateError("cannot found pool",w.toBase58()),L=on.decode(ee.data)}let W=a,z=await Oe(this.scope.connection,[W?void 0:L.configId,L.platformId].filter(Boolean).map(ee=>({pubkey:ee})));if(!W){let ee=z.find(xe=>xe.pubkey.equals(L.configId));(!ee||!ee.accountInfo)&&this.logAndCreateError("config not found: ",L.configId.toBase58()),W=En.decode(ee.accountInfo.data)}let $=z.find(ee=>ee.pubkey.equals(L.platformId));(!$||!$.accountInfo)&&this.logAndCreateError("platform info not found: ",L.configId.toBase58());let ae=Vo.decode($.accountInfo.data);u=u||ae.feeRate;let ye=zt.sellExactIn({poolInfo:L,amountA:m,protocolFeeRate:W.tradeFeeRate,platformFeeRate:u,curveType:W.curveType,shareFeeRate:b,creatorFeeRate:ae.creatorFeeRate,transferFeeConfigA:x,slot:await this.scope.connection.getSlot()}),ce=new Vt(ye.amountB.toString()),de=y?new Vt(Wn.sub(y).toNumber()/Wn.toNumber()).clampedTo(0,1):new Vt(1),pe=f!=null?f:y?new re(ce.mul(de).toFixed(0)):ye.amountB;pe.lte(new re(0))&&this.logAndCreateError(`out ${r.toBase58()} amount should be gt 0`);let le=g?j(g,r,Xe).publicKey:void 0;return le&&T.addInstruction({instructions:[Qt(this.scope.ownerPubKey,le,g,r)]}),T.addInstruction({instructions:[Nl(e,this.scope.ownerPubKey,t,L.configId,L.platformId,w,S,K,L.vaultA,L.vaultB,o,r,n,Xe,uo(e,L.platformId,r).publicKey,Fo(e,L.creator,r).publicKey,ye.amountA.amount.lt(m)?ye.amountA.amount:m,pe,b,le)]}),T.addCustomComputeBudget(l),T.addTipInstruction(d),T.versionBuild({txVersion:s,extInfo:{outAmount:pe}})}async sellTokenExactOut({programId:e=rt,authProgramId:t,mintAProgram:n=Xe,mintA:o,mintB:r=Bn,poolInfo:i,configInfo:a,platformFeeRate:u,txVersion:s,computeBudgetConfig:l,txTipConfig:d,feePayer:p,inAmount:m,maxSellAmount:f,slippage:y,shareFeeRate:b=new re(0),shareFeeReceiver:g,associatedOnly:P=!0,checkCreateATAOwner:h=!1,skipCheckMintA:I=!1}){t=t!=null?t:pn(e).publicKey;let T=this.createTxBuilder(p);f!=null&&f.lte(new re(0))&&this.logAndCreateError("max sell amount should be gt 0");let{publicKey:w}=vo(e,o,r),x;if(!I){let ee=await this.scope.connection.getAccountInfo(o);if(ee&&ee.owner.equals(xn)){n=ee.owner;let xe=ua(o,ee,n);x=sa(xe)||void 0}}let S=null,K=null,B=r.equals(Bn),{account:C,instructionParams:M}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:n,mint:o,owner:this.scope.ownerPubKey,createInfo:void 0,skipCloseAccount:!0,notUseTokenAccount:!1,associatedOnly:P,checkCreateATAOwner:h});C&&(S=C),T.addInstruction(M||{}),S===void 0&&this.logAndCreateError("cannot found mintA token accounts","tokenAccounts",this.scope.account.tokenAccounts);let{account:F,instructionParams:R}=await this.scope.account.getOrCreateTokenAccount({mint:r,owner:this.scope.ownerPubKey,createInfo:B?{payer:this.scope.ownerPubKey,amount:0}:void 0,skipCloseAccount:!B,notUseTokenAccount:B,associatedOnly:B?!1:P,checkCreateATAOwner:h});F&&(K=F),T.addInstruction(R||{}),K===void 0&&this.logAndCreateError("cannot found mintB token accounts","tokenAccounts",this.scope.account.tokenAccounts);let L=i;if(!L){let ee=await this.scope.connection.getAccountInfo(w,{commitment:"processed"});ee||this.logAndCreateError("cannot found pool",w.toBase58()),L=on.decode(ee.data)}let W=a,z=await Oe(this.scope.connection,[W?void 0:L.configId,L.platformId].filter(Boolean).map(ee=>({pubkey:ee})));if(!W){let ee=z.find(xe=>xe.pubkey.equals(L.configId));(!ee||!ee.accountInfo)&&this.logAndCreateError("config not found: ",L.configId.toBase58()),W=En.decode(ee.accountInfo.data)}let $=z.find(ee=>ee.pubkey.equals(L.platformId));(!$||!$.accountInfo)&&this.logAndCreateError("platform info not found: ",L.configId.toBase58());let ae=Vo.decode($.accountInfo.data);u=u||ae.feeRate;let ye=zt.sellExactOut({poolInfo:L,amountB:m,protocolFeeRate:W.tradeFeeRate,platformFeeRate:u,curveType:W.curveType,shareFeeRate:b,creatorFeeRate:ae.creatorFeeRate,transferFeeConfigA:x,slot:await this.scope.connection.getSlot()}),ce=new Vt(ye.amountA.amount.toString()),de=y?new Vt(Wn.add(y).toNumber()/Wn.toNumber()).clampedTo(0,Number.MAX_SAFE_INTEGER):new Vt(1),pe=(f!=null?f:y)?new re(ce.mul(de).toFixed(0)):ye.amountA.amount,le=g?j(g,r,Xe).publicKey:void 0;return le&&T.addInstruction({instructions:[Qt(this.scope.ownerPubKey,le,g,r)]}),T.addInstruction({instructions:[Ml(e,this.scope.ownerPubKey,t,L.configId,L.platformId,w,S,K,L.vaultA,L.vaultB,o,r,n,Xe,uo(e,L.platformId,r).publicKey,Fo(e,L.creator,r).publicKey,m,pe,b,le)]}),T.addCustomComputeBudget(l),T.addTipInstruction(d),T.versionBuild({txVersion:s,extInfo:{maxSellAmount:pe}})}async createPlatformConfig({programId:e=rt,platformAdmin:t,platformClaimFeeWallet:n,platformLockNftWallet:o,cpConfigId:r,migrateCpLockNftScale:i,transferFeeExtensionAuth:a,creatorFeeRate:u,feeRate:s,name:l,web:d,img:p,txVersion:m,computeBudgetConfig:f,txTipConfig:y,feePayer:b}){let g=this.createTxBuilder(b),{publicKey:P}=$s(e,t);return g.addInstruction({instructions:[vl(e,t,n,o,P,r,a,i,s,u,l,d,p)]}),g.addCustomComputeBudget(f),g.addTipInstruction(y),g.versionBuild({txVersion:m,extInfo:{platformId:P}})}async updatePlatformConfig({programId:e=rt,platformAdmin:t,platformId:n,updateInfo:o,txVersion:r,computeBudgetConfig:i,txTipConfig:a,feePayer:u}){let s=this.createTxBuilder(u),l=n!=null?n:$s(e,t).publicKey;return s.addInstruction({instructions:[Fl(e,t,l,o)]}),s.addCustomComputeBudget(i),s.addTipInstruction(a),s.versionBuild({txVersion:r})}async claimPlatformFee({programId:e=rt,authProgramId:t,platformId:n,poolId:o,platformClaimFeeWallet:r,mintB:i,vaultB:a,mintBProgram:u=Xe,txVersion:s,computeBudgetConfig:l,txTipConfig:d,feePayer:p}){var g;let m=this.createTxBuilder(p);t=t!=null?t:pn(e).publicKey;let f=i,y=a;if(!f){let P=await this.scope.connection.getAccountInfo(o,{commitment:"processed"});P||this.logAndCreateError("cannot found pool:",o.toBase58());let h=on.decode(P.data),I=await this.scope.connection.getAccountInfo(h.configId,{commitment:"processed"});I||this.logAndCreateError("cannot found config:",h.configId.toBase58()),f=En.decode(I.data).mintB,y=y!=null?y:h.vaultB}(!f||!y)&&this.logAndCreateError("cannot found mint info, mintB: ",f.toBase58(),", vaultB: ",(g=y==null?void 0:y.toBase58())!=null?g:"");let b=j(this.scope.ownerPubKey,f,Xe).publicKey;return m.addInstruction({instructions:[Qt(this.scope.ownerPubKey,b,this.scope.ownerPubKey,f)]}),m.addInstruction({instructions:[ou(e,r,t,o,n,y,b,f,u)]}),m.addCustomComputeBudget(l),m.addTipInstruction(d),m.versionBuild({txVersion:s})}async claimAllPlatformFee({programId:e=rt,authProgramId:t,platformId:n,platformClaimFeeWallet:o,txVersion:r,computeBudgetConfig:i,txTipConfig:a,feePayer:u}){let s=this.createTxBuilder(u);return t=t!=null?t:pn(e).publicKey,(await this.scope.connection.getProgramAccounts(e,{filters:[{dataSize:on.span},{memcmp:{offset:on.offsetOf("platformId"),bytes:n.toString()}}]})).forEach(d=>{let p=on.decode(d.account.data);if(p.platformFee.lte(new re(0)))return;let m=j(this.scope.ownerPubKey,p.mintB,Xe).publicKey;s.addInstruction({instructions:[Qt(this.scope.ownerPubKey,m,this.scope.ownerPubKey,p.mintB)]}),s.addInstruction({instructions:[ou(e,o,t,d.pubkey,n,p.vaultB,m,p.mintB,Xe)]})}),s.addTipInstruction(a),r===0?s.sizeCheckBuildV0({computeBudgetConfig:i}):s.sizeCheckBuild({computeBudgetConfig:i})}async createVesting({programId:e=rt,poolId:t,beneficiary:n,shareAmount:o,txVersion:r,computeBudgetConfig:i,txTipConfig:a,feePayer:u}){let s=this.createTxBuilder(u),l=await this.getRpcPoolInfo({poolId:t});o.add(l.vestingSchedule.totalAllocatedShare).gt(l.vestingSchedule.totalLockedAmount)&&this.logAndCreateError("share amount exceed total locked amount");let d=Wi(e,t,n).publicKey;return s.addInstruction({instructions:[nu(e,this.scope.ownerPubKey,n,t,d,o)]}),s.addCustomComputeBudget(i),s.addTipInstruction(a),s.versionBuild({txVersion:r})}async createMultipleVesting({programId:e=rt,poolId:t,beneficiaryList:n,txVersion:o,computeBudgetConfig:r,feePayer:i}){let a=this.createTxBuilder(i);n.length===0&&this.logAndCreateError("beneficiaryList is null");let u=await this.getRpcPoolInfo({poolId:t});return n.reduce((l,d)=>l.add(d.shareAmount),u.vestingSchedule.totalAllocatedShare).gt(u.vestingSchedule.totalLockedAmount)&&this.logAndCreateError("share amount exceed total locked amount"),n.forEach(l=>{let d=Wi(e,t,l.wallet).publicKey;a.addInstruction({instructions:[nu(e,this.scope.ownerPubKey,l.wallet,t,d,l.shareAmount)]})}),o===0?a.sizeCheckBuildV0({computeBudgetConfig:r}):a.sizeCheckBuild({computeBudgetConfig:r})}async claimVesting({programId:e=rt,poolId:t,poolInfo:n,vestingRecord:o,txVersion:r,computeBudgetConfig:i,txTipConfig:a,feePayer:u}){let s=this.createTxBuilder(u),l=pn(e).publicKey,d=o||Wi(e,t,this.scope.ownerPubKey).publicKey,p=n;if(!p){let f=await this.scope.connection.getAccountInfo(t);f||this.logAndCreateError("pool not found"),p=on.decode(f.data)}let m=j(this.scope.ownerPubKey,p.mintA,Xe).publicKey;return s.addInstruction({instructions:[Qt(this.scope.ownerPubKey,m,this.scope.ownerPubKey,p.mintA)]}),s.addInstruction({instructions:[tu(e,this.scope.ownerPubKey,l,t,d,m,p.vaultA,p.mintA,Xe)]}),s.addCustomComputeBudget(i),s.addTipInstruction(a),s.versionBuild({txVersion:r})}async claimMultiVesting({programId:e=rt,poolIdList:t,poolsInfo:n={},vestingRecords:o={},txVersion:r,computeBudgetConfig:i,feePayer:a}){let u=this.createTxBuilder(a),s=N({},n),l=pn(e).publicKey,d=t.filter(p=>!s[p.toBase58()]);if(d.length){let p=await this.getRpcPoolsInfo({poolIdList:d});s=N(N({},s),p.poolInfoMap)}return t.forEach(p=>{let m=p.toBase58(),f=s[m];f||this.logAndCreateError(`pool info not found: ${m}`);let y=o[m]||Wi(e,p,this.scope.ownerPubKey).publicKey,b=j(this.scope.ownerPubKey,f.mintA,Xe).publicKey;u.addInstruction({instructions:[Qt(this.scope.ownerPubKey,b,this.scope.ownerPubKey,f.mintA)]}),u.addInstruction({instructions:[tu(e,this.scope.ownerPubKey,l,p,y,b,f.vaultA,f.mintA,Xe)]})}),r===0?u.sizeCheckBuildV0({computeBudgetConfig:i}):u.sizeCheckBuild({computeBudgetConfig:i})}async claimVaultPlatformFee({programId:e=rt,platformId:t,mintB:n,mintBProgram:o=Xe,claimFeeWallet:r,txVersion:i,computeBudgetConfig:a,txTipConfig:u,feePayer:s}){let l=this.createTxBuilder(s),d=uo(e,t,n).publicKey,p=Js(e).publicKey,m=this.scope.account.getAssociatedTokenAccount(n,o);return l.addInstruction({instructions:[Qt(this.scope.ownerPubKey,m,this.scope.ownerPubKey,n,o),iu(e,t,r!=null?r:this.scope.ownerPubKey,p,d,m,n,o)]}),l.addCustomComputeBudget(a),l.addTipInstruction(u),l.versionBuild({txVersion:i})}async claimMultipleVaultPlatformFee({programId:e=rt,platformList:t,unwrapSol:n=!0,txVersion:o,computeBudgetConfig:r,feePayer:i,associatedOnly:a=!0,checkCreateATAOwner:u=!1}){let s=this.createTxBuilder(i),l={};return t.forEach(async d=>{var b,g;let p=Js(e).publicKey,m=uo(e,d.id,d.mintB).publicKey,f=d.mintB.equals(Bn)&&n,y=l[d.mintB.toBase58()];if(!y){let{account:P,instructionParams:h}=await this.scope.account.getOrCreateTokenAccount({mint:d.mintB,owner:this.scope.ownerPubKey,createInfo:f?{payer:this.scope.ownerPubKey,amount:0}:void 0,skipCloseAccount:!f,notUseTokenAccount:f,associatedOnly:f?!1:a,checkCreateATAOwner:u});P&&(y=P),s.addInstruction(h||{}),y===void 0&&this.logAndCreateError(`cannot found platform ${d.id.toBase58()} mintB(${d.mintB.toBase58()}) token accounts`,"tokenAccounts",this.scope.account.tokenAccounts)}s.addInstruction({instructions:[iu(e,d.id,(b=d.claimFeeWallet)!=null?b:this.scope.ownerPubKey,m,p,y,d.mintB,(g=d.mintBProgram)!=null?g:Xe)]})}),o===0?s.sizeCheckBuildV0({computeBudgetConfig:r}):s.sizeCheckBuild({computeBudgetConfig:r})}async claimCreatorFee({programId:e=rt,mintB:t,mintBProgram:n=Xe,txVersion:o,computeBudgetConfig:r,txTipConfig:i,feePayer:a}){let u=this.createTxBuilder(a),s=Fo(e,this.scope.ownerPubKey,t).publicKey,l=Kl(e).publicKey,d=this.scope.account.getAssociatedTokenAccount(t,n);return u.addInstruction({instructions:[Qt(this.scope.ownerPubKey,d,this.scope.ownerPubKey,t,n),Vl(e,this.scope.ownerPubKey,l,s,d,t,n)]}),u.addCustomComputeBudget(r),u.addTipInstruction(i),u.versionBuild({txVersion:o})}async getRpcPoolInfo({poolId:e}){return(await this.getRpcPoolsInfo({poolIdList:[e]})).poolInfoMap[e.toBase58()]}async getRpcPoolsInfo({poolIdList:e,config:t}){let n=await Oe(this.scope.connection,e.map(u=>({pubkey:u})),t),o={},r=[];for(let u=0;u<e.length;u++){let s=n[u];if(s===null||!s.accountInfo)throw Error("fetch pool info error: "+e[u].toBase58());let l=on.decode(s.accountInfo.data);o[e[u].toBase58()]=q(N({},l),{poolId:s.accountInfo.owner}),r.push(l.configId)}let i=await Oe(this.scope.connection,r.map(u=>({pubkey:u})),t),a={};for(let u=0;u<r.length;u++){let s=i[u];if(s===null||!s.accountInfo)throw Error("fetch config info error: "+r[u].toBase58());let l=En.decode(s.accountInfo.data);a[r[u].toBase58()]=q(N({},l),{configId:s.accountInfo.owner})}return{poolInfoMap:Object.keys(o).reduce((u,s)=>q(N({},u),{[s]:q(N({},o[s]),{configInfo:a[o[s].configId.toBase58()]})}),{})}}};import{PublicKey as rf}from"@solana/web3.js";import{MintLayout as af,TOKEN_2022_PROGRAM_ID as ru,TOKEN_PROGRAM_ID as au}from"@solana/spl-token";var Qi=class extends Fe{constructor(t){super(t);this._tokenList=[];this._tokenMap=new Map;this._blackTokenMap=new Set;this._mintGroup={official:new Set,jup:new Set,extra:new Set};this._whiteMap=new Set;this._extraTokenList=[]}async load(t){this.checkDisabled();let{forceUpdate:n=!1,type:o="strict"}=t||{},{mintList:r,blacklist:i,whiteList:a}=await this.scope.fetchV3TokenList(n),u=await this.scope.fetchJupTokenList(n);this._tokenList=[],this._tokenMap=new Map,this._blackTokenMap=new Set(i),this._mintGroup={official:new Set,jup:new Set,extra:new Set},this._whiteMap=new Set(a),this._tokenMap.set(an.address,an),this._mintGroup.official.add(an.address),r.forEach(s=>{var l;this._blackTokenMap.has(s.address)||(this._tokenMap.set(s.address,q(N({},s),{type:"raydium",priority:2,programId:(l=s.programId)!=null?l:s.tags.includes("token-2022")?ru.toBase58():au.toBase58()})),this._mintGroup.official.add(s.address))}),u.forEach(s=>{var l;this._blackTokenMap.has(s.address)||this._tokenMap.has(s.address)||(this._tokenMap.set(s.address,q(N({},s),{type:"jupiter",priority:1,programId:(l=s.programId)!=null?l:s.tags.includes("token-2022")?ru.toBase58():au.toBase58(),tags:s.freezeAuthority?[...s.tags||[],"hasFreeze"]:s.tags})),this._mintGroup.jup.add(s.address))}),this._extraTokenList.forEach(s=>{this._blackTokenMap.has(s.address)||this._tokenMap.has(s.address)||(this._tokenMap.set(s.address,q(N({},s),{type:"extra",priority:1,programId:s.programId||s.tags.includes("token-2022")?ru.toBase58():au.toBase58()})),this._mintGroup.extra.add(s.address))}),this._tokenList=Array.from(this._tokenMap).map(s=>s[1])}get tokenList(){return this._tokenList}get tokenMap(){return this._tokenMap}get blackTokenMap(){return this._blackTokenMap}get mintGroup(){return this._mintGroup}get whiteListMap(){return this._whiteMap}async getTokenInfo(t){if(!t)throw new Error("please input mint");let n=t.toString(),o=this._tokenMap.get(n);if(o)return o;if(n.toLocaleUpperCase()==="SOL")return an;let r=(await this.scope.api.getTokenInfo([n]))[0];if(r)return this._mintGroup.extra.add(n),this._tokenMap.set(n,q(N({},r),{priority:2})),r;let i=await this.scope.connection.getAccountInfo(new rf(n));if(!i)throw new Error(`mint address not found: ${n}`);let a=af.decode(i.data),u=n.toString().substring(0,6),s={chainId:101,address:n,programId:i.owner.toBase58(),logoURI:"",symbol:u,name:u,decimals:a.decimals,tags:[],extensions:{},priority:0,type:"unknown"};return this._mintGroup.extra.add(n),this._tokenMap.set(n,s),s}};var ca=class{constructor(e){this.rawBalances=new Map;let{connection:t,cluster:n,owner:o,api:r,defaultChainTime:i,defaultChainTimeOffset:a,apiCacheTime:u,blockhashCommitment:s="confirmed",loopMultiTxStatus:l}=e;this._connection=t,this.cluster=n||"mainnet",this._owner=o?new Ht(o):void 0,this._signAllTransactions=e.signAllTransactions,this.blockhashCommitment=s,this.loopMultiTxStatus=l,this.api=r,this._apiCacheTime=u||5*60*1e3,this.logger=fe("Raydium"),this.farm=new pi({scope:this,moduleName:"Raydium_Farm"}),this.account=new oi({scope:this,moduleName:"Raydium_Account",tokenAccounts:e.tokenAccounts,tokenAccountRawInfos:e.tokenAccountRawInfos}),this.liquidity=new Si({scope:this,moduleName:"Raydium_LiquidityV2"}),this.token=new Qi({scope:this,moduleName:"Raydium_tokenV2"}),this.tradeV2=new _i({scope:this,moduleName:"Raydium_tradeV2"}),this.clmm=new Ci({scope:this,moduleName:"Raydium_clmm"}),this.cpmm=new Mi({scope:this,moduleName:"Raydium_cpmm"}),this.utils1216=new Ut({scope:this,moduleName:"Raydium_utils1216"}),this.marketV2=new Lo({scope:this,moduleName:"Raydium_marketV2"}),this.ido=new Mo({scope:this,moduleName:"Raydium_ido"}),this.launchpad=new zi({scope:this,moduleName:"Raydium_lauchpad"}),this.availability={};let d=new Date().getTime();this.apiData={},a&&(this._chainTime={fetched:d,value:{chainTime:i||Date.now()-a,offset:a}})}static async load(e){var l;let t=sf({cluster:"mainnet",owner:null,apiRequestInterval:3e5,apiRequestTimeout:1e4},e),{cluster:n,apiRequestTimeout:o,logCount:r,logRequests:i,urlConfigs:a}=t,u=new br({cluster:n,timeout:o,urlConfigs:a,logCount:r,logRequests:i}),s=new ca(q(N({},t),{api:u}));return await s.fetchAvailabilityStatus((l=e.disableFeatureCheck)!=null?l:!0),e.disableLoadToken||await s.token.load({type:e.jupTokenType}),s}get owner(){return this._owner}get ownerPubKey(){if(!this._owner)throw new Error(gr);return this._owner.publicKey}setOwner(e){return this._owner=e?new Ht(e):void 0,this.account.resetTokenAccounts(),this}get connection(){if(!this._connection)throw new Error(Vu);return this._connection}setConnection(e){return this._connection=e,this}get signAllTransactions(){return this._signAllTransactions}setSignAllTransactions(e){return this._signAllTransactions=e,this}checkOwner(){if(!this.owner)throw console.error(gr),new Error(gr)}isCacheInvalidate(e){return new Date().getTime()-e>this._apiCacheTime}async fetchChainTime(){try{let e=await this.api.getChainTimeOffset();this._chainTime={fetched:Date.now(),value:{chainTime:Date.now()+e.offset*1e3,offset:e.offset*1e3}}}catch{this._chainTime=void 0}}async fetchV3TokenList(e){if(this.apiData.tokenList&&!this.isCacheInvalidate(this.apiData.tokenList.fetched)&&!e)return this.apiData.tokenList.data;try{let t=await this.api.getTokenList(),n={fetched:Date.now(),data:t};return this.apiData.tokenList=n,n.data}catch(t){return console.error(t),{mintList:[],blacklist:[],whiteList:[]}}}async fetchJupTokenList(e){if(this.cluster==="devnet")return[];let t=this.apiData.jupTokenList;if(t&&!this.isCacheInvalidate(t.fetched)&&!e)return t.data;try{let n=await this.api.getJupTokenList();return this.apiData.jupTokenList={fetched:Date.now(),data:n.map(o=>q(N({},o),{mintAuthority:o.mint_authority||void 0,freezeAuthority:o.freeze_authority||void 0}))},this.apiData.jupTokenList.data}catch(n){return console.error(n),[]}}get chainTimeData(){var e;return(e=this._chainTime)==null?void 0:e.value}async chainTimeOffset(){var e;return this._chainTime&&Date.now()-this._chainTime.fetched<=1e3*60*5?this._chainTime.value.offset:(await this.fetchChainTime(),((e=this._chainTime)==null?void 0:e.value.offset)||0)}async currentBlockChainTime(){var e;return this._chainTime&&Date.now()-this._chainTime.fetched<=1e3*60*5?this._chainTime.value.chainTime:(await this.fetchChainTime(),((e=this._chainTime)==null?void 0:e.value.chainTime)||Date.now())}async fetchEpochInfo(){return this._epochInfo&&Date.now()-this._epochInfo.fetched<=1e3*30?this._epochInfo.value:(this._epochInfo={fetched:Date.now(),value:await this.connection.getEpochInfo()},this._epochInfo.value)}async fetchAvailabilityStatus(e){if(e)return{};try{let t=await this.api.fetchAvailabilityStatus(),n=t.all===!1;return this.availability={all:t.all,swap:n?!1:t.swap,createConcentratedPosition:n?!1:t.createConcentratedPosition,addConcentratedPosition:n?!1:t.addConcentratedPosition,addStandardPosition:n?!1:t.addStandardPosition,removeConcentratedPosition:n?!1:t.removeConcentratedPosition,removeStandardPosition:n?!1:t.removeStandardPosition,addFarm:n?!1:t.addFarm,removeFarm:n?!1:t.removeFarm},t}catch{return{}}}};var _R=c=>c;export{Ed as AMM_CONFIG_SEED,jp as AUTH_SEED,wc as BIT_PRECISION,Hp as CONFIG_SEED,ef as CREATOR_FEE_VAULT_AUTH_SEED,Ci as Clmm,Fc as ClmmConfigLayout,Ce as ClmmInstrument,qr as ConstantProductCurve,Al as CpmmConfigInfoLayout,Ur as CpmmFee,Qr as CpmmPoolInfoLayout,zt as Curve,Dn as CurveBase,Xr as CurveCalculator,ik as DEV_FARM_LOCK_MINT,rk as DEV_FARM_LOCK_VAULT,sp as DataElement,ks as EXTENSION_TICKARRAY_BITMAP_SIZE,sc as FARM_LOCK_MINT,uc as FARM_LOCK_VAULT,_t as FARM_PROGRAM_TO_VERSION,lc as FARM_VERSION_TO_LEDGER_LAYOUT,cc as FARM_VERSION_TO_STATE_LAYOUT,Cr as FEE_RATE_DENOMINATOR,zd as FETCH_TICKARRAY_COUNT,_d as Fee,ia as FixedPriceCurve,Mr as LIQUIDITY_FEES_DENOMINATOR,Is as LIQUIDITY_FEES_NUMERATOR,tp as LIQUIDITY_VERSION_TO_SERUM_VERSION,Bh as LIQUIDITY_VERSION_TO_STATE_LAYOUT,Fp as LOCK_LIQUIDITY_SEED,Tc as LOG_B_2_X32,hc as LOG_B_P_ERR_MARGIN_LOWER_X64,Ic as LOG_B_P_ERR_MARGIN_UPPER_X64,na as LaunchConstantProductCurve,En as LaunchpadConfig,on as LaunchpadPool,lo as LaunchpadPoolInitParam,nC as LaunchpadVesting,aa as LinearPriceCurve,Ae as LiquidityMath,Ec as LockClPositionLayoutV2,VT as LockPositionLayout,Vs as MARKET_STATE_LAYOUT_V2,qs as MARKET_STATE_LAYOUT_V3,Tl as MARKET_VERSION_TO_STATE_LAYOUT,Wt as MAX_SQRT_PRICE_X64,Kr as MAX_SQRT_PRICE_X64_SUB_ONE,Pt as MAX_TICK,Dt as MIN_SQRT_PRICE_X64,Sr as MIN_SQRT_PRICE_X64_ADD_ONE,pt as MIN_TICK,Hr as Market,Xi as MathLaunch,ue as MathUtil,fi as MaxU64,kc as MaxUint128,Pn as NEGATIVE_ONE,Gd as OBSERVATION_SEED,Lt as ONE,qd as OPERATION_SEED,Vc as ObservationInfoLayout,jd as ObservationLayout,_c as OperationLayout,Jp as PLATFORM_FEE_VAULT_AUTH_SEED,$p as PLATFORM_SEED,Oc as POOL_LOCK_ID_SEED,Dd as POOL_REWARD_VAULT_SEED,fs as POOL_SEED,Ud as POOL_TICK_ARRAY_BITMAP_SEED,ys as POOL_VAULT_SEED,Zp as POOL_VESTING_SEED,Kc as POSITION_SEED,Vo as PlatformConfig,Hn as PoolInfoLayout,Ne as PoolUtils,So as PositionInfoLayout,Zd as PositionRewardInfoLayout,Ai as PositionUtils,FT as ProtocolPositionLayout,xr as Q128,Je as Q64,ca as Raydium,Hd as RewardInfo,cl as RoundDirection,kl as SERUM_PROGRAMID_TO_VERSION,wl as SERUM_VERSION_TO_PROGRAMID,an as SOL_INFO,Uc as SPL_MINT_LAYOUT,Xd as SUPPORT_MINT_SEED,ie as SqrtPriceMath,Ro as StableLayout,jn as SwapMath,Yn as TICK_ARRAY_BITMAP_SIZE,Wd as TICK_ARRAY_SEED,et as TICK_ARRAY_SIZE,Aw as TICK_SPACINGS,nt as TOKEN_WSOL,wn as TickArrayBitmap,vc as TickArrayBitmapExtensionLayout,ki as TickArrayBitmapExtensionUtils,Pi as TickArrayLayout,$d as TickLayout,Zn as TickMath,ke as TickQuery,Z as TickUtils,yi as U64Resolution,kw as U64_IGNORE_RANGE,of as VestingSchedule,ac as Voter,Td as VoterDepositEntry,wd as VoterLockup,rc as VoterRegistrar,kd as VoterVotingMintConfig,be as ZERO,Ks as addLiquidityLayout,Ft as anchorDataBuf,Ya as associatedLedgerAccountLayout,Ll as buyExactInInstruction,Ol as buyExactOutInstruction,us as calFarmRewardAmount,PC as checkPoolToAmm,Vl as claimCreatorFee,Ei as claimLayout,ou as claimPlatformFee,iu as claimPlatformFeeFromVault,tu as claimVestedToken,Mc as clmmComputeInfoToApiInfo,An as closeAccountInstruction,Ws as collectCpFeeInstruction,Dp as cpmmLockPositionInstruction,ci as createAssociatedLedgerAccountInstruction,vl as createPlatformConfig,zc as createPoolFeeLayout,Ls as createPoolV4InstructionV2,Ih as createPoolV4Layout,nu as createVestingAccount,Ln as createWSolAccountInstructions,At as dwLayout,$a as farmAddRewardLayout,QP as farmLedgerLayoutV3_1,ri as farmLedgerLayoutV3_2,YP as farmLedgerLayoutV5_1,oc as farmLedgerLayoutV5_2,ic as farmLedgerLayoutV6_1,dc as farmRewardInfoToConfig,Ha as farmRewardLayout,Za as farmRewardRestartLayout,Pd as farmRewardTimeInfoLayout,tc as farmStateV3Layout,nc as farmStateV5Layout,ii as farmStateV6Layout,Tk as fetchMultipleFarmInfoAndUpdate,lI as fetchMultipleInfo,Bs as fixedSwapInLayout,xs as fixedSwapOutLayout,gp as formatLayout,ze as generatePubKey,mc as getAssociatedAuthority,Vr as getAssociatedConfigId,dt as getAssociatedLedgerAccount,si as getAssociatedLedgerPoolAccount,wp as getAssociatedOpenOrders,Fs as getAssociatedPoolKeys,Oi as getCpLockPda,cx as getCpmmPdaAmmConfigId,Es as getCpmmPdaPoolId,ml as getCreatePoolKeys,cs as getDepositEntryIndex,el as getDxByDyBaseIn,Jc as getDyByDxBaseIn,Io as getFarmLedgerLayout,Id as getFarmStateLayout,vs as getLiquidityAssociatedAuthority,to as getLiquidityAssociatedId,dT as getLiquidityFromAmounts,Sw as getPdaAmmConfigId,so as getPdaCpiEvent,Kl as getPdaCreatorFeeVaultAuth,Fo as getPdaCreatorVault,Qe as getPdaExBitmapAccount,pn as getPdaLaunchpadAuth,GK as getPdaLaunchpadConfigId,vo as getPdaLaunchpadPoolId,Zs as getPdaLaunchpadVaultId,xo as getPdaLockClPositionIdV2,gs as getPdaLockPositionId,Mp as getPdaLpMint,kn as getPdaMetadataKey,As as getPdaMintExAccount,Lc as getPdaObservationAccount,Li as getPdaObservationId,gi as getPdaOperationAccount,kt as getPdaPersonalPositionAddress,Js as getPdaPlatformFeeVaultAuth,$s as getPdaPlatformId,uo as getPdaPlatformVault,No as getPdaPoolAuthority,Cc as getPdaPoolId,Rc as getPdaPoolRewardVaulId,bs as getPdaPoolVaultId,nn as getPdaProtocolPositionAddress,ge as getPdaTickArrayAddress,ll as getPdaVault,Wi as getPdaVestId,ns as getRegistrarAddress,tl as getStablePrice,ss as getTokenOwnerRecordAddress,rs as getVoterAddress,as as getVoterWeightRecordAddress,is as getVotingMintAuthority,os as getVotingTokenMint,Nd as governanceCreateTokenOwnerRecord,Tw as i16ToBytes,Lr as i32ToBytes,Ss as initPoolLayout,za as initTokenAccountInstruction,Cl as initialize,Bp as initializeMarket,Rl as initializeWithToken2022,es as isValidFarmVersion,bi as isZero,hk as judgeFarmType,ds as leadingZeros,Sc as leastSignificantBit,$n as liquidityStateV4Layout,np as liquidityStateV5Layout,vr as makeAMMSwapInstruction,jc as makeAddLiquidityInstruction,ms as makeAddNewRewardInstruction,Jr as makeClaimInstruction,Hs as makeClaimInstructionV4,gl as makeCpmmLockInstruction,pl as makeCreateCpmmPoolInInstruction,pc as makeCreateFarmInstruction,Er as makeCreateMarketInstruction,fc as makeCreatorWithdrawFarmRewardInstruction,fl as makeDepositCpmmInInstruction,bc as makeDepositInstructionV3,gc as makeDepositInstructionV5,Ac as makeDepositInstructionV6,Ek as makeDepositTokenInstruction,Wk as makeDepositWithdrawInstruction,Vh as makeInitPoolInstructionV4,BK as makePurchaseInstruction,ls as makeRestartRewardInstruction,Hc as makeSimulatePoolInfoInstruction,zr as makeSwapCpmmBaseInInstruction,bl as makeSwapCpmmBaseOutInstruction,rp as makeSwapFixedInInstruction,ap as makeSwapFixedOutInstruction,Il as makeSwapInstruction,ec as makeTransferInstruction,yl as makeWithdrawCpmmInInstruction,di as makeWithdrawInstructionV3,yc as makeWithdrawInstructionV4,mi as makeWithdrawInstructionV5,li as makeWithdrawInstructionV6,Dk as makeWithdrawTokenInstruction,Pw as mockCreatePoolInfo,Bc as mockV3CreatePoolInfo,up as modelDataInfoLayout,xc as mostSignificantBit,Ju as parseTokenAccountResp,lh as parseTokenInfo,Nn as poolTypeV6,Qs as purchaseLayout,bd as realFarmStateV3Layout,gd as realFarmStateV5Layout,Ad as realFarmV6Layout,Rs as removeLiquidityInstruction,Cs as removeLiquidityLayout,CS as route1Instruction,RS as route2Instruction,Up as routeInstruction,Nl as sellExactInInstruction,Ml as sellExactOut,Fh as simulatePoolInfoInstruction,dh as solToWSolToken,tn as splAccountLayout,LS as swapBaseInAutoAccount,OS as swapBaseOutAutoAccount,_r as toAmmComputePoolInfo,ft as toApiV3Token,Mn as toFeeConfig,Nr as toToken,Ti as toTokenAmount,mh as toTokenInfo,ps as trailingZeros,Rr as u16ToBytes,hw as u32ToBytes,tf as u8ToBytes,_R as unionArr,Bd as updateFarmPoolInfo,Fl as updatePlatformConfig,ts as validateFarmRewards,vd as voterStakeRegistryCreateDepositEntry,Md as voterStakeRegistryCreateVoter,Rd as voterStakeRegistryDeposit,Ld as voterStakeRegistryUpdateVoterWeightRecord,Od as voterStakeRegistryWithdraw,ph as wSolToSolToken,ja as withdrawRewardLayout};
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
//# sourceMappingURL=index.mjs.map