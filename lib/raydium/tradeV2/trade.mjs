var Wr=Object.defineProperty,Fr=Object.defineProperties;var Vr=Object.getOwnPropertyDescriptors;var rn=Object.getOwnPropertySymbols;var Ti=Object.prototype.hasOwnProperty,hi=Object.prototype.propertyIsEnumerable;var wi=(m,e,t)=>e in m?Wr(m,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):m[e]=t,F=(m,e)=>{for(var t in e||(e={}))Ti.call(e,t)&&wi(m,t,e[t]);if(rn)for(var t of rn(e))hi.call(e,t)&&wi(m,t,e[t]);return m},X=(m,e)=>Fr(m,Vr(e));var ct=(m,e)=>{var t={};for(var n in m)Ti.call(m,n)&&e.indexOf(n)<0&&(t[n]=m[n]);if(m!=null&&rn)for(var n of rn(m))e.indexOf(n)<0&&hi.call(m,n)&&(t[n]=m[n]);return t};import{PublicKey as It}from"@solana/web3.js";import{createTransferInstruction as Er,TOKEN_PROGRAM_ID as ye,TOKEN_2022_PROGRAM_ID as Sn}from"@solana/spl-token";import Kn from"bn.js";import nn from"decimal.js";import{PublicKey as Ii}from"@solana/web3.js";import{get as xi,set as vr}from"lodash";var Ln=class{constructor(e){this.logLevel=e.logLevel!==void 0?e.logLevel:0,this.name=e.name}set level(e){this.logLevel=e}get time(){return Date.now().toString()}get moduleName(){return this.name}isLogLevel(e){return e<=this.logLevel}error(...e){return this.isLogLevel(0)?(console.error(this.time,this.name,"sdk logger error",...e),this):this}logWithError(...e){let t=e.map(n=>typeof n=="object"?JSON.stringify(n):n).join(", ");throw new Error(t)}warning(...e){return this.isLogLevel(1)?(console.warn(this.time,this.name,"sdk logger warning",...e),this):this}info(...e){return this.isLogLevel(2)?(console.info(this.time,this.name,"sdk logger info",...e),this):this}debug(...e){return this.isLogLevel(3)?(console.debug(this.time,this.name,"sdk logger debug",...e),this):this}},Bi={},Dr={};function re(m){let e=xi(Bi,m);if(!e){let t=xi(Dr,m);e=new Ln({name:m,logLevel:t}),vr(Bi,m,e)}return e}import{MINT_SIZE as qr,TOKEN_PROGRAM_ID as Gr,getTransferFeeConfig as Ur,unpackMint as Xr}from"@solana/spl-token";var Rn=re("Raydium_accountInfo_util");async function Ze(m,e,t){let{batchRequest:n,commitment:i="confirmed",chunkCount:s=100}=F({batchRequest:!1},t),o=Nn(e,s),r=new Array(o.length).fill([]);if(n){let u=o.map(p=>{let l=m._buildArgs([p.map(d=>d.toBase58())],i,"base64");return{methodName:"getMultipleAccounts",args:l}}),a=Nn(u,10);r=(await(await Promise.all(a.map(async p=>await m._rpcBatchRequest(p)))).flat()).map(p=>(p.error&&Rn.logWithError(`failed to get info for multiple accounts, RPC_ERROR, ${p.error.message}`),p.result.value.map(l=>{if(l){let{data:d,executable:y,lamports:b,owner:f,rentEpoch:g}=l;return d.length!==2&&d[1]!=="base64"&&Rn.logWithError("info must be base64 encoded, RPC_ERROR"),{data:Buffer.from(d[0],"base64"),executable:y,lamports:b,owner:new Ii(f),rentEpoch:g}}return null})))}else try{r=await Promise.all(o.map(u=>m.getMultipleAccountsInfo(u,i)))}catch(u){u instanceof Error&&Rn.logWithError(`failed to get info for multiple accounts, RPC_ERROR, ${u.message}`)}return r.flat()}async function bt(m,e,t){let n=await Ze(m,e.map(i=>i.pubkey),t);return e.map((i,s)=>X(F({},i),{accountInfo:n[s]}))}async function Mn({connection:m,mints:e,config:t}){var s,o,r;if(e.length===0)return{};let n=await bt(m,e.map(u=>({pubkey:Ge(u)})),t),i={};for(let u of n){if(!u.accountInfo||u.accountInfo.data.length<qr){console.log("invalid mint account",u.pubkey.toBase58());continue}let a=Xr(u.pubkey,u.accountInfo,(s=u.accountInfo)==null?void 0:s.owner);i[u.pubkey.toString()]=X(F({},a),{programId:((o=u.accountInfo)==null?void 0:o.owner)||Gr,feeConfig:(r=Ur(a))!=null?r:void 0})}return i[Ii.default.toBase58()]=i[Ve.toBase58()],i}import $e from"bn.js";import Pu from"decimal.js";import $r from"big.js";import an from"bn.js";import zr from"toformat";var Hr=zr,_t=Hr;import sn from"big.js";import Qr from"bn.js";import jr from"decimal.js-light";import Et from"bn.js";var Si=9007199254740991;function oe(m){let e=re("Raydium_parseBigNumberish");if(m instanceof Et)return m;if(typeof m=="string"){if(m.match(/^-?[0-9]+$/))return new Et(m);e.logWithError(`invalid BigNumberish string: ${m}`)}return typeof m=="number"?(m%1&&e.logWithError(`BigNumberish number underflow: ${m}`),(m>=Si||m<=-Si)&&e.logWithError(`BigNumberish number overflow: ${m}`),new Et(String(m))):typeof m=="bigint"?new Et(m.toString()):(e.error(`invalid BigNumberish value: ${m}`),new Et(0))}var on=re("module/fraction"),On=_t(sn),Wt=_t(jr),Zr={[0]:Wt.ROUND_DOWN,[1]:Wt.ROUND_HALF_UP,[2]:Wt.ROUND_UP},Jr={[0]:sn.roundDown,[1]:sn.roundHalfUp,[2]:sn.roundUp},te=class{constructor(e,t=new Qr(1)){this.numerator=oe(e),this.denominator=oe(t)}get quotient(){return this.numerator.div(this.denominator)}invert(){return new te(this.denominator,this.numerator)}add(e){let t=e instanceof te?e:new te(oe(e));return this.denominator.eq(t.denominator)?new te(this.numerator.add(t.numerator),this.denominator):new te(this.numerator.mul(t.denominator).add(t.numerator.mul(this.denominator)),this.denominator.mul(t.denominator))}sub(e){let t=e instanceof te?e:new te(oe(e));return this.denominator.eq(t.denominator)?new te(this.numerator.sub(t.numerator),this.denominator):new te(this.numerator.mul(t.denominator).sub(t.numerator.mul(this.denominator)),this.denominator.mul(t.denominator))}mul(e){let t=e instanceof te?e:new te(oe(e));return new te(this.numerator.mul(t.numerator),this.denominator.mul(t.denominator))}div(e){let t=e instanceof te?e:new te(oe(e));return new te(this.numerator.mul(t.denominator),this.denominator.mul(t.numerator))}toSignificant(e,t={groupSeparator:""},n=1){Number.isInteger(e)||on.logWithError(`${e} is not an integer.`),e<=0&&on.logWithError(`${e} is not positive.`),Wt.set({precision:e+1,rounding:Zr[n]});let i=new Wt(this.numerator.toString()).div(this.denominator.toString()).toSignificantDigits(e);return i.toFormat(i.decimalPlaces(),t)}toFixed(e,t={groupSeparator:""},n=1){return Number.isInteger(e)||on.logWithError(`${e} is not an integer.`),e<0&&on.logWithError(`${e} is negative.`),On.DP=e,On.RM=Jr[n]||1,new On(this.numerator.toString()).div(this.denominator.toString()).toFormat(e,t)}isZero(){return this.numerator.isZero()}};var eo=re("Raydium_amount"),Ki=_t($r);function to(m,e){let t="0",n="0";if(m.includes(".")){let i=m.split(".");i.length===2?([t,n]=i,n=n.padEnd(e,"0")):eo.logWithError(`invalid number string, num: ${m}`)}else t=m;return[t,n.slice(0,e)||n]}var se=class extends te{constructor(t,n,i=!0,s){let o=new an(0),r=_n.pow(new an(t.decimals));if(i)o=oe(n);else{let u=new an(0),a=new an(0);if(typeof n=="string"||typeof n=="number"||typeof n=="bigint"){let[c,p]=to(n.toString(),t.decimals);u=oe(c),a=oe(p)}u=u.mul(r),o=u.add(a)}super(o,r);this.logger=re(s||"TokenAmount"),this.token=t}get raw(){return this.numerator}isZero(){return this.raw.isZero()}gt(t){return this.token.equals(t.token)||this.logger.logWithError("gt token not equals"),this.raw.gt(t.raw)}lt(t){return this.token.equals(t.token)||this.logger.logWithError("lt token not equals"),this.raw.lt(t.raw)}add(t){return this.token.equals(t.token)||this.logger.logWithError("add token not equals"),new se(this.token,this.raw.add(t.raw))}subtract(t){return this.token.equals(t.token)||this.logger.logWithError("sub token not equals"),new se(this.token,this.raw.sub(t.raw))}toSignificant(t=this.token.decimals,n,i=0){return super.toSignificant(t,n,i)}toFixed(t=this.token.decimals,n,i=0){return t>this.token.decimals&&this.logger.logWithError("decimals overflow"),super.toFixed(t,n,i)}toExact(t={groupSeparator:""}){return Ki.DP=this.token.decimals,new Ki(this.numerator.toString()).div(this.denominator.toString()).toFormat(t)}};import{PublicKey as no}from"@solana/web3.js";import{TOKEN_PROGRAM_ID as Ci}from"@solana/spl-token";var En={chainId:101,address:no.default.toBase58(),programId:Ci.toBase58(),decimals:9,symbol:"SOL",name:"solana",logoURI:"https://img-v1.raydium.io/icon/So11111111111111111111111111111111111111112.png",tags:[],priority:2,type:"raydium",extensions:{coingeckoId:"solana"}},Ue={chainId:101,address:"So11111111111111111111111111111111111111112",programId:Ci.toBase58(),decimals:9,symbol:"WSOL",name:"Wrapped SOL",logoURI:"https://img-v1.raydium.io/icon/So11111111111111111111111111111111111111112.png",tags:[],priority:2,type:"raydium",extensions:{coingeckoId:"solana"}};import{PublicKey as Vn}from"@solana/web3.js";import{PublicKey as le,SystemProgram as Li,SYSVAR_RENT_PUBKEY as io}from"@solana/web3.js";import{TOKEN_PROGRAM_ID as ro}from"@solana/spl-token";function S({pubkey:m,isSigner:e=!1,isWritable:t=!0}){return{pubkey:m,isWritable:t,isSigner:e}}var xa=[S({pubkey:ro,isWritable:!1}),S({pubkey:Li.programId,isWritable:!1}),S({pubkey:io,isWritable:!1})];function Wn({publicKey:m,transformSol:e}){let t=Fn(m.toString());if(t instanceof le)return e&&t.equals(Ft)?Ve:t;if(e&&t.toString()===Ft.toBase58())return Ve;if(typeof t=="string"){if(t===le.default.toBase58())return le.default;try{return new le(t)}catch{throw new Error("invalid public key")}}throw new Error("invalid public key")}function Fn(m){try{return new le(m)}catch{return m}}var un=new le("MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr"),St=new le("MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr"),Xe=new le("SysvarRent111111111111111111111111111111111"),Ba=new le("SysvarC1ock11111111111111111111111111111111"),lt=new le("metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s"),Ia=new le("Sysvar1nstructions1111111111111111111111111"),oo=Li.programId,Sa=new le("4k3Dyjzvzp8eMZWUXbBCjEvwSkkk59S5iCNLY3QrkX6R"),Ka=new le("Ea5SjE2Y6yvCeW5dYTn7PYMuW5ikXkvbGdcmSnXeaLjS"),Ca=new le("SRMuApVNdxXokk5GT7XD5cUUgXMBCoAz2LHeuAoKWRt"),La=new le("EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v"),Ra=new le("Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB"),Na=new le("mSoLzYCxHdYgdzU16g5QSh3i5K3z3KZK7ytfqcJm7So"),Ma=new le("7dHbWXmci3dT8UFYWYZweBLXgycu7Y3iL6trKn1Y7ARj"),Oa=new le("USDH1SM1ojwWUga67PGrgFWUHibbjqMvuMaDkRJTgkX"),_a=new le("NRVwhjBQiUPYtfDT5zRBVJajzFQHaBUNtC7SNVvqRFa"),Ea=new le("ANAxByE6G2WjFp7A4NqtWYXb3mgruyzZYg3spfxe6Lbo"),Wa=new le("7vfCXTUXx5WJV5JADk17DUJ4ksgau7utNKj4b963voxs"),Ve=new le("So11111111111111111111111111111111111111112"),Ft=le.default;function Ge(m){return Wn({publicKey:m,transformSol:!0})}var vn=class{constructor({mint:e,decimals:t,symbol:n,name:i,skipMint:s=!1,isToken2022:o=!1}){if(e===Ft.toBase58()||e instanceof Vn&&Ft.equals(e)){this.decimals=Ue.decimals,this.symbol=Ue.symbol,this.name=Ue.name,this.mint=new Vn(Ue.address),this.isToken2022=!1;return}this.decimals=t,this.symbol=n||e.toString().substring(0,6),this.name=i||e.toString().substring(0,6),this.mint=s?Vn.default:Wn({publicKey:e}),this.isToken2022=o}equals(e){return this===e?!0:this.mint.equals(e.mint)}},Re=vn;Re.WSOL=new vn(X(F({},Ue),{mint:Ue.address}));var Dn=class{constructor({decimals:e,symbol:t="UNKNOWN",name:n="UNKNOWN"}){this.decimals=e,this.symbol=t,this.name=n}equals(e){return this===e}},cn=Dn;cn.SOL=new Dn(En);import so from"bn.js";var Ri=new te(new so(100)),Je=class extends te{toSignificant(e=5,t,n){return this.mul(Ri).toSignificant(e,t,n)}toFixed(e=2,t,n){return this.mul(Ri).toFixed(e,t,n)}};var ao=re("Raydium_price"),Ce=class extends te{constructor(t){let{baseToken:n,quoteToken:i,numerator:s,denominator:o}=t;super(s,o);this.baseToken=n,this.quoteToken=i,this.scalar=new te(qn(n.decimals),qn(i.decimals))}get raw(){return new te(this.numerator,this.denominator)}get adjusted(){return super.mul(this.scalar)}invert(){return new Ce({baseToken:this.quoteToken,quoteToken:this.baseToken,denominator:this.numerator,numerator:this.denominator})}mul(t){this.quoteToken!==t.baseToken&&ao.logWithError("mul token not equals");let n=super.mul(t);return new Ce({baseToken:this.baseToken,quoteToken:t.quoteToken,denominator:n.denominator,numerator:n.numerator})}toSignificant(t=this.quoteToken.decimals,n,i){return this.adjusted.toSignificant(t,n,i)}toFixed(t=this.quoteToken.decimals,n,i){return this.adjusted.toFixed(t,n,i)}};var Ni=new $e(0),uo=new $e(1),Su=new $e(2),Ku=new $e(3),Cu=new $e(5),_n=new $e(10),Lu=new $e(100),Ru=new $e(1e3),Nu=new $e(1e4);function qn(m){return _n.pow(oe(m))}function Nn(m,e=1,t=[]){let n=[...m];if(e<=0)return t;for(;n.length;)t.push(n.splice(0,e));return t}var ze=class{constructor(e){this._owner=e}get publicKey(){return ze.isKeyPair(this._owner)?this._owner.publicKey:this._owner}get signer(){return ze.isKeyPair(this._owner)?this._owner:void 0}get isKeyPair(){return ze.isKeyPair(this._owner)}get isPublicKey(){return ze.isPublicKey(this._owner)}static isKeyPair(e){return e.secretKey!==void 0}static isPublicKey(e){return!ze.isKeyPair(e)}};import{PublicKey as yo}from"@solana/web3.js";import{TOKEN_PROGRAM_ID as go}from"@solana/spl-token";import{ComputeBudgetProgram as Mi,Keypair as _i,PublicKey as co,Transaction as Ei,TransactionMessage as lo,VersionedTransaction as Wi}from"@solana/web3.js";var j={CreateAccount:"CreateAccount",InitAccount:"InitAccount",CreateATA:"CreateATA",CloseAccount:"CloseAccount",TransferAmount:"TransferAmount",InitMint:"InitMint",MintTo:"MintTo",InitMarket:"InitMarket",Util1216OwnerClaim:"Util1216OwnerClaim",SetComputeUnitPrice:"SetComputeUnitPrice",SetComputeUnitLimit:"SetComputeUnitLimit",ClmmCreatePool:"ClmmCreatePool",ClmmOpenPosition:"ClmmOpenPosition",ClmmIncreasePosition:"ClmmIncreasePosition",ClmmDecreasePosition:"ClmmDecreasePosition",ClmmClosePosition:"ClmmClosePosition",ClmmSwapBaseIn:"ClmmSwapBaseIn",ClmmSwapBaseOut:"ClmmSwapBaseOut",ClmmInitReward:"ClmmInitReward",ClmmSetReward:"ClmmSetReward",ClmmCollectReward:"ClmmCollectReward",ClmmLockPosition:"ClmmLockPosition",ClmmHarvestLockPosition:"ClmmHarvestLockPosition",AmmV4Swap:"AmmV4Swap",AmmV4AddLiquidity:"AmmV4AddLiquidity",AmmV4RemoveLiquidity:"AmmV4RemoveLiquidity",AmmV4SimulatePoolInfo:"AmmV4SimulatePoolInfo",AmmV4SwapBaseIn:"AmmV4SwapBaseIn",AmmV4SwapBaseOut:"AmmV4SwapBaseOut",AmmV4CreatePool:"AmmV4CreatePool",AmmV4InitPool:"AmmV4InitPool",AmmV5AddLiquidity:"AmmV5AddLiquidity",AmmV5RemoveLiquidity:"AmmV5RemoveLiquidity",AmmV5SimulatePoolInfo:"AmmV5SimulatePoolInfo",AmmV5SwapBaseIn:"AmmV5SwapBaseIn",AmmV5SwapBaseOut:"AmmV5SwapBaseOut",RouteSwap:"RouteSwap",RouteSwap1:"RouteSwap1",RouteSwap2:"RouteSwap2",FarmV3Deposit:"FarmV3Deposit",FarmV3Withdraw:"FarmV3Withdraw",FarmV3CreateLedger:"FarmV3CreateLedger",FarmV4Withdraw:"FarmV4Withdraw",FarmV5Deposit:"FarmV5Deposit",FarmV5Withdraw:"FarmV5Withdraw",FarmV5CreateLedger:"FarmV5CreateLedger",FarmV6Deposit:"FarmV6Deposit",FarmV6Withdraw:"FarmV6Withdraw",FarmV6Create:"FarmV6Create",FarmV6Restart:"FarmV6Restart",FarmV6CreatorAddReward:"FarmV6CreatorAddReward",FarmV6CreatorWithdraw:"FarmV6CreatorWithdraw",CpmmCreatePool:"CpmmCreatePool",CpmmAddLiquidity:"CpmmAddLiquidity",CpmmWithdrawLiquidity:"CpmmWithdrawLiquidity",CpmmSwapBaseIn:"CpmmSwapBaseIn",CpmmSwapBaseOut:"CpmmSwapBaseOut",CpmmLockLp:"CpmmLockLp",CpmmCollectLockFee:"CpmmCollectLockFee",TransferTip:"TransferTip"};import{TOKEN_PROGRAM_ID as mo}from"@solana/spl-token";var Oi=re("Raydium_txUtil"),Fi=1644;function Vt(m){let e=[],t=[];return m.microLamports&&(e.push(Mi.setComputeUnitPrice({microLamports:m.microLamports})),t.push(j.SetComputeUnitPrice)),m.units&&(e.push(Mi.setComputeUnitLimit({units:m.units})),t.push(j.SetComputeUnitLimit)),{instructions:e,instructionTypes:t}}async function yt(m,e){var n,i;let t=e!=null?e:"confirmed";return(i=await((n=m.getLatestBlockhash)==null?void 0:n.call(m,{commitment:t})))==null?void 0:i.blockhash}async function vt(m,e){return m.getSignatureStatuses([e]),new Promise((t,n)=>{let i=setTimeout(n,6e4);m.onSignature(e,s=>{if(clearTimeout(i),!s.err){t("");return}n(Object.assign(s.err,{txId:e}))},"confirmed")})}function po(m,e){m.length<1&&Oi.logWithError(`no instructions provided: ${m.toString()}`),e.length<1&&Oi.logWithError(`no signers provided:, ${e.toString()}`);let t=new Ei;t.recentBlockhash="11111111111111111111111111111111",t.feePayer=e[0],t.add(...m);try{return Buffer.from(t.serialize({verifySignatures:!1})).toString("base64").length<Fi}catch{return!1}}function Pe(m,e){let[t,n]=co.findProgramAddressSync(m,e);return{publicKey:t,nonce:n}}function Dt({instructions:m,payer:e,signers:t}){return po(m,[e,...t])}function et({instructions:m,payer:e,lookupTableAddressAccount:t,recentBlockhash:n=_i.generate().publicKey.toString()}){let s=new lo({payerKey:e,recentBlockhash:n,instructions:m}).compileToV0Message(Object.values(t!=null?t:{}));try{return Buffer.from(new Wi(s).serialize()).toString("base64").length<Fi}catch{return!1}}var fo=m=>Buffer.isBuffer(m)?m:m instanceof Uint8Array?Buffer.from(m.buffer,m.byteOffset,m.byteLength):Buffer.from(m),bo=m=>{let e=m.serialize({requireAllSignatures:!1,verifySignatures:!1});m instanceof Wi&&(e=fo(e));try{return e instanceof Buffer?e.toString("base64"):Buffer.from(e).toString("base64")}catch{return e.toString("base64")}};function mt(m){let e=[];return m.forEach(t=>{t instanceof Ei&&(t.recentBlockhash||(t.recentBlockhash=mo.toBase58()),t.feePayer||(t.feePayer=_i.generate().publicKey)),e.push(bo(t))}),console.log("simulate tx string:",e),e}function ae(m,e,t){return Pe([m.toBuffer(),(t!=null?t:go).toBuffer(),e.toBuffer()],new yo("ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL"))}import{PublicKey as v}from"@solana/web3.js";var $u=new v("EhhTKczWMGQt46ynNeRX1WfeagwwJd7ufHvCDjRxjo5Q"),ec=new v("CBuCnLe26faBpcBP2fktp4rp8abpcAnTWft6ZrP5Q4T"),tc=new v("9KEPoZmtHUrBbhWN1v1KWLMkkvwY6WLtAVUCPRtRjP4z"),nc=new v("FarmqiPv5eAj3j1GMdMCMUGXqPUvmquZtMy86QH6rzhG"),ic=new v("CLaimxFqjHzgTJtAGHU47NPhg6qrc5sCnpC4tBLyABQS"),rc=new v("srmqPvymJeFKQ4zGQed1GFppgkRHL9kaELCbyksJtPX"),Gn=new v("9xQeWvG816bUx9EPjHmaT23yvVM2ZWbrrpZb9PusVFin"),Vi=new v("675kPX9MHTjS2zt1qfr1NYHuzeLXfQM9H24wFSUt1Mp8"),oc=new v("5quBtoiQqxF9Jv6KYKctB59NT3gtJD2Y65kdnB1Uev3h"),vi=new v("CDSr3ssLcRB6XYPJwAfFt18MZvEZp4LjHcvzBVZ45duo"),Un=new v("CAMMCzo5YL8w4VFF8KVHrK22GGUsp5VTaW7grrKgrWqK"),Po=new v("LockrWmn6K5twhz3y9w1dQERbmgSaRkfnTeTKbpofwE"),ko=new v("kN1kEznaF5Xbd8LYuqtEFcxzWSBk5Fv6ygX6SqEGJVy"),ln=new v("CDSr3ssLcRB6XYPJwAfFt18MZvEZp4LjHcvzBVZ45duo"),sc=new v("routeUGWgWzqBWFcrCfv8tritsqukccJPu3q5GPP3xS"),ac=new v("7YttLkHDoNj9wyDur5pM1ejNaAvT9X4eqaYcHQqtj2G5"),uc=new v("6FJon3QE27qgPVggARueB22hLvoh22VzJpXv4rBEoSLF"),cc=new v("CC12se5To1CdEuw7fDS27B7Geo5jJyL7t5UK2B44NgiH"),lc=new v("9HzJyW1qZsEiSfMUf6L2jo3CcTKAyBmSyKdwQeYisHrC"),mc=new v("DropEU8AvevN3UrXWXTMuz3rqnMczQVNjq3kcSdW2SQi"),Xn=new v("CPMMoo8L3F4NbTegBCKVNunggL7H1ZpdTHKxQB5qKP1C"),Ao=new v("GpMZbSM2GgvTKHJirzeGfMFoaZ8UR2X7F4v8vHTvxFbL"),pc=new v("DNXgeM9EiiaAbaWvwjHj9fQQLAX5ZsfHyvmYUNRAdNC8"),dc=new v("LockrWmn6K5twhz3y9w1dQERbmgSaRkfnTeTKbpofwE"),fc=new v("3f7GcQFG397GAaEnv51zR6tsTVihYRydnydDD1cXekxH"),bc=new v("LanMV9sAd7wArD4vJFi2qDdfnVhFxYSUg6eADduJ3uj"),yc=new v("WLHv2UAZm6z4KyaaELi5pjdbJh6RESMva1Rnn8pJVVh"),gc=new v("DRay6fNdQ5J82H7xV6uq2aV3mNrUZ1J4PgSKsWgptcm6"),Pc=new v("5xqNaZXX5eUi4p5HU4oz9i5QnwRNT2y6oN7yyn4qENeq"),kc=new v("4Bu96XjU84XjPDSpveTVf6LYGCkfW5FK7SNkREWcEfV4"),Ac=new v("6s1xP3hpbAfFoNtUNF8mfHsjr2Bd97JxFJRWLbL6aHuX");var wc={OPEN_BOOK_PROGRAM:new v("EoTcMgcDRTJVZDMZWBoU6rhYHZfkNTVEAfz3uUJRcYGj"),SERUM_PROGRAM_ID_V3:new v("Ray1111111111111111111111111111111111111111"),AMM_V4:new v("DRaya7Kj3aMWQSy19kSjvmuwq9docCHofyP9kanQGaav"),AMM_STABLE:new v("DRayDdXc1NZQ9C3hRWmoSf8zK4iapgMnjdNZWrfwsP8m"),CLMM_PROGRAM_ID:new v("DRayAUgENGQBKVaX8owNhgzkEDyoHTGVEGHVJT1E9pfH"),CLMM_LOCK_PROGRAM_ID:new v("DRay25Usp3YJAi7beckgpGUC7mGJ2cR1AVPxhYfwVCUX"),CLMM_LOCK_AUTH_ID:new v("6Aoh8h2Lw2m5UGxYR8AdAL87jTWYeKoxM52mJRzfYwN"),CREATE_CPMM_POOL_PROGRAM:new v("DRaycpLY18LhpbydsBWbVJtxpNv9oXPgjRSfpF2bWpYb"),CREATE_CPMM_POOL_AUTH:new v("CXniRufdq5xL8t8jZAPxsPZDpuudwuJSPWnbcD5Y5Nxq"),CREATE_CPMM_POOL_FEE_ACC:new v("3oE58BKVt8KuYkGxx8zBojugnymWmBiyafWgMrnb6eYy"),LOCK_CPMM_PROGRAM:new v("DRay25Usp3YJAi7beckgpGUC7mGJ2cR1AVPxhYfwVCUX"),LOCK_CPMM_AUTH:new v("7qWVV8UY2bRJfDLP4s37YzBPKUkVB46DStYJBpYbQzu3"),UTIL1216:v.default,Router:new v("DRaybByLpbUL57LJARs3j8BitTxVfzBg351EaMr5UTCd"),FARM_PROGRAM_ID_V3:new v("DRayWyrLmEW5KEeqs8kdTMMaBabapqagaBC7KWpGtJeZ"),FARM_PROGRAM_ID_V4:new v("Ray1111111111111111111111111111111111111111"),FARM_PROGRAM_ID_V5:new v("DRayiCGSZgku1GTK6rXD6mVDdingXy6APAH1R6R5L2LC"),FARM_PROGRAM_ID_V6:new v("DRayzbYakXs45ELHkzH6vC3fuhQqTAnv5A68gdFuvZyZ"),LAUNCHPAD_PROGRAM:new v("DRay6fNdQ5J82H7xV6uq2aV3mNrUZ1J4PgSKsWgptcm6"),LAUNCHPAD_AUTH:new v("5xqNaZXX5eUi4p5HU4oz9i5QnwRNT2y6oN7yyn4qENeq"),LAUNCHPAD_PLATFORM:new v("2Jx4KTDrVSdWNazuGpcA8n3ZLTRGGBDxAWhuKe2Xcj2a"),LAUNCHPAD_CONFIG:new v("7ZR4zD7PYfY2XxoG1Gxcy2EgEeGYrpxrwzPuwdUBssEt"),FEE_DESTINATION_ID:new v("9y8ENuuZ3b19quffx9hQvRVygG5ky6snHfRvGpuSfeJy"),MODEL_DATA_PUBKEY:new v("Ray1111111111111111111111111111111111111111")};import ve from"bn.js";var qt=1e4;function be(m,e,t,n){if(e===void 0)return{amount:m,fee:void 0,expirationTime:void 0};let i=X(F({},e),{olderTransferFee:{epoch:BigInt(e.olderTransferFee.epoch),maximumFee:BigInt(e.olderTransferFee.maximumFee),transferFeeBasisPoints:e.olderTransferFee.transferFeeBasisPoints},newerTransferFee:{epoch:BigInt(e.newerTransferFee.epoch),maximumFee:BigInt(e.newerTransferFee.maximumFee),transferFeeBasisPoints:e.newerTransferFee.transferFeeBasisPoints}}),s=t.epoch<i.newerTransferFee.epoch?i.olderTransferFee:i.newerTransferFee,o=new ve(s.maximumFee.toString()),r=t.epoch<i.newerTransferFee.epoch?(Number(i.newerTransferFee.epoch)*t.slotsInEpoch-t.absoluteSlot)*400/1e3:void 0;if(n)if(s.transferFeeBasisPoints===qt){let u=new ve(s.maximumFee.toString());return{amount:m.add(u),fee:u,expirationTime:r}}else{let u=zn(m.mul(new ve(qt)),new ve(qt-s.transferFeeBasisPoints)),a=new ve(s.maximumFee.toString()),c=u.sub(m).gt(a)?m.add(a):u,p=zn(c.mul(new ve(s.transferFeeBasisPoints)),new ve(qt)),l=p.gt(o)?o:p;return{amount:c,fee:l,expirationTime:r}}else{let u=zn(m.mul(new ve(s.transferFeeBasisPoints)),new ve(qt)),a=u.gt(o)?o:u;return{amount:m,fee:a,expirationTime:r}}}function De(m,e){return m===void 0?e:e===void 0?m:Math.min(m,e)}function zn(m,e){let{div:t,mod:n}=m.divmod(e);return n.gt(new ve(0))?t.add(new ve(1)):t}import{PublicKey as Hn,AddressLookupTableAccount as Ct}from"@solana/web3.js";async function mn({connection:m,address:e,cluster:t="mainnet"}){let n=await Ze(m,[...new Set(e.map(s=>s.toString()))].map(s=>new Hn(s))),i={};for(let s=0;s<e.length;s++){let o=n[s],r=e[s];if(!o)continue;let u=new Ct({key:r,state:Ct.deserialize(o.data)});i[r.toString()]=u,t==="devnet"?Kt[r.toString()]=u:pt[r.toString()]=u}return i}var pt={},Yn=async m=>{let e="AcL1Vo8oy1ULiavEcjSUcwfBSForXMudcZvDZy5nzJkU";if(pt[e])return pt;let t=new Hn(e),n=await m.getAccountInfo(t);return n&&(pt[e]=new Ct({key:t,state:Ct.deserialize(n.data)})),pt},Kt={},pn=async m=>{let e="EFhMuDw1PKEuckuFRW9PavNfTH4LKP5uKHgyXDmWpFCq";if(Kt[e])return Kt;let t=new Hn(e),n=await m.getAccountInfo(t);return n&&(Kt[e]=new Ct({key:t,state:Ct.deserialize(n.data)})),Kt};import{PublicKey as gt,sendAndConfirmTransaction as Qn,SystemProgram as wo,Transaction as Gt,TransactionMessage as tt,VersionedTransaction as nt}from"@solana/web3.js";import To from"axios";var Ut=2e3,Xt=class{constructor(e){this.instructions=[];this.endInstructions=[];this.lookupTableAddress=[];this.signers=[];this.instructionTypes=[];this.endInstructionTypes=[];this.connection=e.connection,this.feePayer=e.feePayer,this.signAllTransactions=e.signAllTransactions,this.owner=e.owner,this.cluster=e.cluster,this.blockhashCommitment=e.blockhashCommitment,this.loopMultiTxStatus=!!e.loopMultiTxStatus}get AllTxData(){return{instructions:this.instructions,endInstructions:this.endInstructions,signers:this.signers,instructionTypes:this.instructionTypes,endInstructionTypes:this.endInstructionTypes,lookupTableAddress:this.lookupTableAddress}}get allInstructions(){return[...this.instructions,...this.endInstructions]}async getComputeBudgetConfig(){var n;let e=(await To.get(`https://solanacompass.com/api/fees?cacheFreshTime=${3e5}`)).data,{avg:t}=(n=e==null?void 0:e[15])!=null?n:{};if(!!t)return{units:6e5,microLamports:Math.min(Math.ceil(t*1e6/6e5),25e3)}}addCustomComputeBudget(e){if(e){let{instructions:t,instructionTypes:n}=Vt(e);return this.instructions.unshift(...t),this.instructionTypes.unshift(...n),!0}return!1}addTipInstruction(e){var t;return e?(this.endInstructions.push(wo.transfer({fromPubkey:(t=e.feePayer)!=null?t:this.feePayer,toPubkey:new gt(e.address),lamports:BigInt(e.amount.toString())})),this.endInstructionTypes.push(j.TransferTip),!0):!1}async calComputeBudget({config:e,defaultIns:t}){try{let n=e||await this.getComputeBudgetConfig();if(this.addCustomComputeBudget(n))return;t&&this.instructions.unshift(...t)}catch{t&&this.instructions.unshift(...t)}}addInstruction({instructions:e=[],endInstructions:t=[],signers:n=[],instructionTypes:i=[],endInstructionTypes:s=[],lookupTableAddress:o=[]}){return this.instructions.push(...e),this.endInstructions.push(...t),this.signers.push(...n),this.instructionTypes.push(...i),this.endInstructionTypes.push(...s),this.lookupTableAddress.push(...o.filter(r=>r!==gt.default.toString())),this}async versionBuild({txVersion:e,extInfo:t}){return e===0?await this.buildV0(F({},t||{})):this.build(t)}build(e){var n;let t=new Gt;return this.allInstructions.length&&t.add(...this.allInstructions),t.feePayer=this.feePayer,((n=this.owner)==null?void 0:n.signer)&&!this.signers.some(i=>i.publicKey.equals(this.owner.publicKey))&&this.signers.push(this.owner.signer),{builder:this,transaction:t,signers:this.signers,instructionTypes:[...this.instructionTypes,...this.endInstructionTypes],execute:async i=>{var c;let{recentBlockHash:s,skipPreflight:o=!0,sendAndConfirm:r,notSendToRpc:u}=i||{},a=s!=null?s:await yt(this.connection,this.blockhashCommitment);if(t.recentBlockhash=a,this.signers.length&&t.sign(...this.signers),mt([t]),(c=this.owner)!=null&&c.isKeyPair)return{txId:r?await Qn(this.connection,t,this.signers.find(l=>l.publicKey.equals(this.owner.publicKey))?this.signers:[...this.signers,this.owner.signer],{skipPreflight:o}):await this.connection.sendRawTransaction(t.serialize(),{skipPreflight:o}),signedTx:t};if(this.signAllTransactions){let p=await this.signAllTransactions([t]);if(this.signers.length)for(let l of p)try{l.sign(...this.signers)}catch{}return{txId:u?"":await this.connection.sendRawTransaction(p[0].serialize(),{skipPreflight:o}),signedTx:p[0]}}throw new Error("please provide owner in keypair format or signAllTransactions function")},extInfo:e||{}}}buildMultiTx(e){var a;let{extraPreBuildData:t=[],extInfo:n}=e,{transaction:i}=this.build(n),s=t.filter(c=>c.transaction.instructions.length>0),o=[i,...s.map(c=>c.transaction)],r=[this.signers,...s.map(c=>c.signers)],u=[...this.instructionTypes,...s.map(c=>c.instructionTypes).flat()];return(a=this.owner)!=null&&a.signer&&r.forEach(c=>{c.some(p=>p.publicKey.equals(this.owner.publicKey))||this.signers.push(this.owner.signer)}),{builder:this,transactions:o,signers:r,instructionTypes:u,execute:async c=>{var g;let{sequentially:p,onTxUpdate:l,skipTxCount:d=0,recentBlockHash:y,skipPreflight:b=!0}=c||{},f=y!=null?y:await yt(this.connection,this.blockhashCommitment);if((g=this.owner)!=null&&g.isKeyPair){if(p){let w=[],B=0;for(let T of o){if(++B,B<=d)continue;let A=await Qn(this.connection,T,this.signers.find(k=>k.publicKey.equals(this.owner.publicKey))?this.signers:[...this.signers,this.owner.signer],{skipPreflight:b});w.push(A)}return{txIds:w,signedTxs:o}}return{txIds:await await Promise.all(o.map(async w=>(w.recentBlockhash=f,await this.connection.sendRawTransaction(w.serialize(),{skipPreflight:b})))),signedTxs:o}}if(this.signAllTransactions){let w=o.map((T,A)=>(T.recentBlockhash=f,r[A].length&&T.sign(...r[A]),T));mt(w);let B=await this.signAllTransactions(w);if(p){let T=0,A=[],k=async()=>{if(!B[T])return;let I=await this.connection.sendRawTransaction(B[T].serialize(),{skipPreflight:b});A.push({txId:I,status:"sent",signedTx:B[T]}),l==null||l([...A]),T++;let x=!1,R=null,h=null,L=_=>{R!==null&&clearInterval(R),h!==null&&this.connection.removeSignatureListener(h);let O=A.findIndex(V=>V.txId===I);if(O>-1){if(A[O].status==="error"||A[O].status==="success")return;A[O].status=_.err?"error":"success"}l==null||l([...A]),_.err||k()};this.loopMultiTxStatus&&(R=setInterval(async()=>{var _;if(x){clearInterval(R);return}try{let O=await this.connection.getTransaction(I,{commitment:"confirmed",maxSupportedTransactionVersion:0});O&&(x=!0,clearInterval(R),L({err:((_=O.meta)==null?void 0:_.err)||null}),console.log("tx status from getTransaction:",I))}catch(O){x=!0,clearInterval(R),console.error("getTransaction timeout:",O,I)}},Ut)),h=this.connection.onSignature(I,_=>{if(x){this.connection.removeSignatureListener(h);return}x=!0,L(_)},"confirmed"),this.connection.getSignatureStatus(I)};return await k(),{txIds:A.map(I=>I.txId),signedTxs:B}}else{let T=[];for(let A=0;A<B.length;A+=1){let k=await this.connection.sendRawTransaction(B[A].serialize(),{skipPreflight:b});T.push(k)}return{txIds:T,signedTxs:B}}}throw new Error("please provide owner in keypair format or signAllTransactions function")},extInfo:n||{}}}async versionMultiBuild({extraPreBuildData:e,txVersion:t,extInfo:n}){return t===0?await this.buildV0MultiTx({extraPreBuildData:e,buildProps:n||{}}):this.buildMultiTx({extraPreBuildData:e,extInfo:n})}async buildV0(e){var b;let y=e||{},{lookupTableCache:t={},lookupTableAddress:n=[],forerunCreate:i,recentBlockhash:s}=y,o=ct(y,["lookupTableCache","lookupTableAddress","forerunCreate","recentBlockhash"]),r=F(F({},this.cluster==="devnet"?await pn(this.connection):await Yn(this.connection)),t),u=Array.from(new Set([...n,...this.lookupTableAddress])),a=[];for(let f of u)r[f]===void 0&&a.push(new gt(f));let c=await mn({connection:this.connection,address:a});for(let[f,g]of Object.entries(c))r[f]=g;let p=i?gt.default.toBase58():s!=null?s:await yt(this.connection,this.blockhashCommitment),l=new tt({payerKey:this.feePayer,recentBlockhash:p,instructions:[...this.allInstructions]}).compileToV0Message(Object.values(r));((b=this.owner)==null?void 0:b.signer)&&!this.signers.some(f=>f.publicKey.equals(this.owner.publicKey))&&this.signers.push(this.owner.signer);let d=new nt(l);return d.sign(this.signers),{builder:this,transaction:d,signers:this.signers,instructionTypes:[...this.instructionTypes,...this.endInstructionTypes],execute:async f=>{var T;let{skipPreflight:g=!0,sendAndConfirm:w,notSendToRpc:B}=f||{};if(mt([d]),(T=this.owner)!=null&&T.isKeyPair){let A=await this.connection.sendTransaction(d,{skipPreflight:g});return w&&await vt(this.connection,A),{txId:A,signedTx:d}}if(this.signAllTransactions){let A=await this.signAllTransactions([d]);if(this.signers.length)for(let k of A)try{k.sign(this.signers)}catch{}return{txId:B?"":await this.connection.sendTransaction(A[0],{skipPreflight:g}),signedTx:A[0]}}throw new Error("please provide owner in keypair format or signAllTransactions function")},extInfo:o||{}}}async buildV0MultiTx(e){var a;let{extraPreBuildData:t=[],buildProps:n}=e,{transaction:i}=await this.buildV0(n),s=t.filter(c=>c.builder.instructions.length>0),o=[i,...s.map(c=>c.transaction)],r=[this.signers,...s.map(c=>c.signers)],u=[...this.instructionTypes,...s.map(c=>c.instructionTypes).flat()];return(a=this.owner)!=null&&a.signer&&r.forEach(c=>{c.some(p=>p.publicKey.equals(this.owner.publicKey))||this.signers.push(this.owner.signer)}),o.forEach(async(c,p)=>{c.sign(r[p])}),{builder:this,transactions:o,signers:r,instructionTypes:u,buildProps:n,execute:async c=>{var b;let{sequentially:p,onTxUpdate:l,recentBlockHash:d,skipPreflight:y=!0}=c||{};if(d&&o.forEach(f=>f.message.recentBlockhash=d),mt(o),(b=this.owner)!=null&&b.isKeyPair){if(p){let f=[];for(let g of o){let w=await this.connection.sendTransaction(g,{skipPreflight:y});await vt(this.connection,w),f.push(w)}return{txIds:f,signedTxs:o}}return{txIds:await Promise.all(o.map(async f=>await this.connection.sendTransaction(f,{skipPreflight:y}))),signedTxs:o}}if(this.signAllTransactions){let f=await this.signAllTransactions(o);if(p){let g=0,w=[],B=async()=>{if(!f[g])return;let T=await this.connection.sendTransaction(f[g],{skipPreflight:y});w.push({txId:T,status:"sent",signedTx:f[g]}),l==null||l([...w]),g++;let A=!1,k=null,I=null,x=R=>{k!==null&&clearInterval(k),I!==null&&this.connection.removeSignatureListener(I);let h=w.findIndex(L=>L.txId===T);if(h>-1){if(w[h].status==="error"||w[h].status==="success")return;w[h].status=R.err?"error":"success"}l==null||l([...w]),R.err||B()};this.loopMultiTxStatus&&(k=setInterval(async()=>{var R;if(A){clearInterval(k);return}try{let h=await this.connection.getTransaction(T,{commitment:"confirmed",maxSupportedTransactionVersion:0});h&&(A=!0,clearInterval(k),x({err:((R=h.meta)==null?void 0:R.err)||null}),console.log("tx status from getTransaction:",T))}catch(h){A=!0,clearInterval(k),console.error("getTransaction timeout:",h,T)}},Ut)),I=this.connection.onSignature(T,R=>{if(A){this.connection.removeSignatureListener(I);return}A=!0,x(R)},"confirmed"),this.connection.getSignatureStatus(T)};return B(),{txIds:[],signedTxs:f}}else{let g=[];for(let w=0;w<f.length;w+=1){let B=await this.connection.sendTransaction(f[w],{skipPreflight:y});g.push(B)}return{txIds:g,signedTxs:f}}}throw new Error("please provide owner in keypair format or signAllTransactions function")},extInfo:n||{}}}async sizeCheckBuild(e){var l;let p=e||{},{splitIns:t=[],computeBudgetConfig:n}=p,i=ct(p,["splitIns","computeBudgetConfig"]),s=n?Vt(n):{instructions:[],instructionTypes:[]},o=this.signers.reduce((d,y)=>X(F({},d),{[y.publicKey.toBase58()]:y}),{}),r=[],u=[],a=[],c=0;if(this.allInstructions.forEach(d=>{let y=[...a,d],b=n?[...s.instructions,...y]:y,g=[...new Set(y.map(w=>w.keys.filter(B=>B.isSigner).map(B=>B.pubkey.toString())).flat()).values()].map(w=>new gt(w));if(d!==t[c]&&a.length<12&&(Dt({instructions:b,payer:this.feePayer,signers:g})||Dt({instructions:y,payer:this.feePayer,signers:g})))a.push(d);else{if(a.length===0)throw Error("item ins too big");c+=d===t[c]?1:0,Dt({instructions:n?[...s.instructions,...a]:[...a],payer:this.feePayer,signers:g})?r.push(new Gt().add(...s.instructions,...a)):r.push(new Gt().add(...a)),u.push(Array.from(new Set(a.map(w=>w.keys.filter(B=>B.isSigner).map(B=>B.pubkey.toString())).flat())).map(w=>o[w]).filter(w=>w!==void 0)),a=[d]}}),a.length>0){let y=[...new Set(a.map(b=>b.keys.filter(f=>f.isSigner).map(f=>f.pubkey.toString())).flat()).values()].map(b=>o[b]).filter(b=>b!==void 0);Dt({instructions:n?[...s.instructions,...a]:[...a],payer:this.feePayer,signers:y.map(b=>b.publicKey)})?r.push(new Gt().add(...s.instructions,...a)):r.push(new Gt().add(...a)),u.push(y)}return r.forEach(d=>d.feePayer=this.feePayer),(l=this.owner)!=null&&l.signer&&u.forEach(d=>{d.some(y=>y.publicKey.equals(this.owner.publicKey))||d.push(this.owner.signer)}),{builder:this,transactions:r,signers:u,instructionTypes:this.instructionTypes,execute:async d=>{var T;let{sequentially:y,onTxUpdate:b,skipTxCount:f=0,recentBlockHash:g,skipPreflight:w=!0}=d||{},B=g!=null?g:await yt(this.connection,this.blockhashCommitment);if(r.forEach(async(A,k)=>{A.recentBlockhash=B,u[k].length&&A.sign(...u[k])}),mt(r),(T=this.owner)!=null&&T.isKeyPair){if(y){let A=0,k=[];for(let I of r){if(++A,A<=f){k.push("tx skipped");continue}let x=await Qn(this.connection,I,this.signers.find(R=>R.publicKey.equals(this.owner.publicKey))?this.signers:[...this.signers,this.owner.signer],{skipPreflight:w});k.push(x)}return{txIds:k,signedTxs:r}}return{txIds:await Promise.all(r.map(async A=>await this.connection.sendRawTransaction(A.serialize(),{skipPreflight:w}))),signedTxs:r}}if(this.signAllTransactions){let A=await this.signAllTransactions(r.slice(f,r.length)),k=[...r.slice(0,f),...A];if(y){let I=0,x=[],R=async()=>{if(!k[I])return;I<f&&(x.push({txId:"",status:"success",signedTx:k[I]}),b==null||b([...x]),I++,R());let h=await this.connection.sendRawTransaction(k[I].serialize(),{skipPreflight:w});x.push({txId:h,status:"sent",signedTx:k[I]}),b==null||b([...x]),I++;let L=!1,_=null,O=null,V=Q=>{_!==null&&clearInterval(_),O!==null&&this.connection.removeSignatureListener(O);let D=x.findIndex(Te=>Te.txId===h);if(D>-1){if(x[D].status==="error"||x[D].status==="success")return;x[D].status=Q.err?"error":"success"}b==null||b([...x]),Q.err||R()};this.loopMultiTxStatus&&(_=setInterval(async()=>{var Q;if(L){clearInterval(_);return}try{let D=await this.connection.getTransaction(h,{commitment:"confirmed",maxSupportedTransactionVersion:0});D&&(L=!0,clearInterval(_),V({err:((Q=D.meta)==null?void 0:Q.err)||null}),console.log("tx status from getTransaction:",h))}catch(D){L=!0,clearInterval(_),console.error("getTransaction timeout:",D,h)}},Ut)),O=this.connection.onSignature(h,Q=>{if(L){this.connection.removeSignatureListener(O);return}L=!0,V(Q)},"confirmed"),this.connection.getSignatureStatus(h)};return await R(),{txIds:x.map(h=>h.txId),signedTxs:k}}else{let I=[];for(let x=0;x<k.length;x+=1){let R=await this.connection.sendRawTransaction(k[x].serialize(),{skipPreflight:w});I.push(R)}return{txIds:I,signedTxs:k}}}throw new Error("please provide owner in keypair format or signAllTransactions function")},extInfo:i||{}}}async sizeCheckBuildV0(e){var B;let w=e||{},{computeBudgetConfig:t,splitIns:n=[],lookupTableCache:i={},lookupTableAddress:s=[]}=w,o=ct(w,["computeBudgetConfig","splitIns","lookupTableCache","lookupTableAddress"]),r=F(F({},this.cluster==="devnet"?await pn(this.connection):pt),i),u=Array.from(new Set([...this.lookupTableAddress,...s])),a=[];for(let T of u)r[T]===void 0&&a.push(new gt(T));let c=await mn({connection:this.connection,address:a});for(let[T,A]of Object.entries(c))r[T]=A;let p=t?Vt(t):{instructions:[],instructionTypes:[]},l=await yt(this.connection,this.blockhashCommitment),d=this.signers.reduce((T,A)=>X(F({},T),{[A.publicKey.toBase58()]:A}),{}),y=[],b=[],f=[],g=0;if(this.allInstructions.forEach(T=>{let A=[...f,T],k=t?[...p.instructions,...A]:A;if(T!==n[g]&&f.length<12&&(et({instructions:k,payer:this.feePayer,lookupTableAddressAccount:r})||et({instructions:A,payer:this.feePayer,lookupTableAddressAccount:r})))f.push(T);else{if(f.length===0)throw Error("item ins too big");g+=T===n[g]?1:0;let I={};for(let x of[...new Set(u)])r[x]!==void 0&&(I[x]=r[x]);if(t&&et({instructions:[...p.instructions,...f],payer:this.feePayer,lookupTableAddressAccount:r,recentBlockhash:l})){let x=new tt({payerKey:this.feePayer,recentBlockhash:l,instructions:[...p.instructions,...f]}).compileToV0Message(Object.values(r));y.push(new nt(x))}else{let x=new tt({payerKey:this.feePayer,recentBlockhash:l,instructions:[...f]}).compileToV0Message(Object.values(r));y.push(new nt(x))}b.push(Array.from(new Set(f.map(x=>x.keys.filter(R=>R.isSigner).map(R=>R.pubkey.toString())).flat())).map(x=>d[x]).filter(x=>x!==void 0)),f=[T]}}),f.length>0){let A=[...new Set(f.map(k=>k.keys.filter(I=>I.isSigner).map(I=>I.pubkey.toString())).flat()).values()].map(k=>d[k]).filter(k=>k!==void 0);if(t&&et({instructions:[...p.instructions,...f],payer:this.feePayer,lookupTableAddressAccount:r,recentBlockhash:l})){let k=new tt({payerKey:this.feePayer,recentBlockhash:l,instructions:[...p.instructions,...f]}).compileToV0Message(Object.values(r));y.push(new nt(k))}else{let k=new tt({payerKey:this.feePayer,recentBlockhash:l,instructions:[...f]}).compileToV0Message(Object.values(r));y.push(new nt(k))}b.push(A)}return(B=this.owner)!=null&&B.signer&&b.forEach(T=>{T.some(A=>A.publicKey.equals(this.owner.publicKey))||T.push(this.owner.signer)}),y.forEach((T,A)=>{T.sign(b[A])}),{builder:this,transactions:y,buildProps:e,signers:b,blockHash:l,instructionTypes:this.instructionTypes,execute:async T=>{var h;let{sequentially:A,onTxUpdate:k,skipTxCount:I=0,recentBlockHash:x,skipPreflight:R=!0}=T||{};if(y.map(async(L,_)=>{b[_].length&&L.sign(b[_]),x&&(L.message.recentBlockhash=x)}),mt(y),(h=this.owner)!=null&&h.isKeyPair){if(A){let L=0,_=[];for(let O of y){if(++L,L<=I){console.log("skip tx: ",L),_.push("tx skipped");continue}let V=await this.connection.sendTransaction(O,{skipPreflight:R});await vt(this.connection,V),_.push(V)}return{txIds:_,signedTxs:y}}return{txIds:await Promise.all(y.map(async L=>await this.connection.sendTransaction(L,{skipPreflight:R}))),signedTxs:y}}if(this.signAllTransactions){let L=await this.signAllTransactions(y.slice(I,y.length)),_=[...y.slice(0,I),...L];if(A){let O=0,V=[],Q=async()=>{if(!_[O])return;if(O<I){V.push({txId:"",status:"success",signedTx:_[O]}),k==null||k([...V]),O++,Q();return}let D=await this.connection.sendTransaction(_[O],{skipPreflight:R});V.push({txId:D,status:"sent",signedTx:_[O]}),k==null||k([...V]),O++;let Te=!1,Se=null,We=null,ut=he=>{Se!==null&&clearInterval(Se),We!==null&&this.connection.removeSignatureListener(We);let fe=V.findIndex(Cn=>Cn.txId===D);if(fe>-1){if(V[fe].status==="error"||V[fe].status==="success")return;V[fe].status=he.err?"error":"success"}k==null||k([...V]),he.err||Q()};this.loopMultiTxStatus&&(Se=setInterval(async()=>{var he;if(Te){clearInterval(Se);return}try{let fe=await this.connection.getTransaction(D,{commitment:"confirmed",maxSupportedTransactionVersion:0});fe&&(Te=!0,clearInterval(Se),ut({err:((he=fe.meta)==null?void 0:he.err)||null}),console.log("tx status from getTransaction:",D))}catch(fe){Te=!0,clearInterval(Se),console.error("getTransaction timeout:",fe,D)}},Ut)),We=this.connection.onSignature(D,he=>{if(Te){this.connection.removeSignatureListener(We);return}Te=!0,ut(he)},"confirmed"),this.connection.getSignatureStatus(D)};return Q(),{txIds:[],signedTxs:_}}else{let O=[];for(let V=0;V<_.length;V+=1){let Q=await this.connection.sendTransaction(_[V],{skipPreflight:R});O.push(Q)}return{txIds:O,signedTxs:_}}}throw new Error("please provide owner in keypair format or signAllTransactions function")},extInfo:o||{}}}async buildSniperTransaction(e){var B;let w=e||{},{computeBudgetConfig:t,splitIns:n=[],lookupTableCache:i={},lookupTableAddress:s=[]}=w,o=ct(w,["computeBudgetConfig","splitIns","lookupTableCache","lookupTableAddress"]),r=F(F({},this.cluster==="devnet"?await pn(this.connection):await Yn(this.connection)),i),u=Array.from(new Set([...this.lookupTableAddress,...s])),a=[];for(let T of u)r[T]===void 0&&a.push(new gt(T));let c=await mn({connection:this.connection,address:a});for(let[T,A]of Object.entries(c))r[T]=A;let p=t?Vt(t):{instructions:[],instructionTypes:[]},l=await yt(this.connection,this.blockhashCommitment),d=this.signers.reduce((T,A)=>X(F({},T),{[A.publicKey.toBase58()]:A}),{}),y=[],b=[],f=[],g=0;if(this.allInstructions.forEach(T=>{let A=[...f,T],k=t?[...p.instructions,...A]:A;if(T!==n[g]&&f.length<12&&(et({instructions:k,payer:this.feePayer,lookupTableAddressAccount:r})||et({instructions:A,payer:this.feePayer,lookupTableAddressAccount:r})))f.push(T);else{if(f.length===0)throw Error("item ins too big");g+=T===n[g]?1:0;let I={};for(let x of[...new Set(u)])r[x]!==void 0&&(I[x]=r[x]);if(t&&et({instructions:[...p.instructions,...f],payer:this.feePayer,lookupTableAddressAccount:r,recentBlockhash:l})){let x=new tt({payerKey:this.feePayer,recentBlockhash:l,instructions:[...p.instructions,...f]}).compileToV0Message(Object.values(r));y.push(new nt(x))}else{let x=new tt({payerKey:this.feePayer,recentBlockhash:l,instructions:[...f]}).compileToV0Message(Object.values(r));y.push(new nt(x))}b.push(Array.from(new Set(f.map(x=>x.keys.filter(R=>R.isSigner).map(R=>R.pubkey.toString())).flat())).map(x=>d[x]).filter(x=>x!==void 0)),f=[T]}}),f.length>0){let A=[...new Set(f.map(k=>k.keys.filter(I=>I.isSigner).map(I=>I.pubkey.toString())).flat()).values()].map(k=>d[k]).filter(k=>k!==void 0);if(t&&et({instructions:[...p.instructions,...f],payer:this.feePayer,lookupTableAddressAccount:r,recentBlockhash:l})){let k=new tt({payerKey:this.feePayer,recentBlockhash:l,instructions:[...p.instructions,...f]}).compileToV0Message(Object.values(r));y.push(new nt(k))}else{let k=new tt({payerKey:this.feePayer,recentBlockhash:l,instructions:[...f]}).compileToV0Message(Object.values(r));y.push(new nt(k))}b.push(A)}return(B=this.owner)!=null&&B.signer&&b.forEach(T=>{T.some(A=>A.publicKey.equals(this.owner.publicKey))||T.push(this.owner.signer)}),y.forEach((T,A)=>{T.sign(b[A])}),{builder:this,transactions:y,buildProps:e,signers:b,instructionTypes:this.instructionTypes,execute:async T=>{var h;let{sequentially:A,onTxUpdate:k,skipTxCount:I=0,recentBlockHash:x,skipPreflight:R=!0}=T||{};if(y.map(async(L,_)=>{b[_].length&&L.sign(b[_]),x&&(L.message.recentBlockhash=x)}),mt(y),(h=this.owner)!=null&&h.isKeyPair){if(A){let L=0,_=[];for(let O of y){if(++L,L<=I){console.log("skip tx: ",L),_.push("tx skipped");continue}let V=await this.connection.sendTransaction(O,{skipPreflight:R});await vt(this.connection,V),_.push(V)}return{txIds:_,signedTxs:y}}return{txIds:await Promise.all(y.map(async L=>await this.connection.sendTransaction(L,{skipPreflight:R}))),signedTxs:y}}if(this.signAllTransactions){let L=await this.signAllTransactions(y.slice(I,y.length)),_=[...y.slice(0,I),...L];if(A){let O=0,V=[],Q=async()=>{if(!_[O])return;if(O<I){V.push({txId:"",status:"success",signedTx:_[O]}),k==null||k([...V]),O++,Q();return}let D=await this.connection.sendTransaction(_[O],{skipPreflight:R});V.push({txId:D,status:"sent",signedTx:_[O]}),k==null||k([...V]),O++;let Te=!1,Se=null,We=null,ut=he=>{Se!==null&&clearInterval(Se),We!==null&&this.connection.removeSignatureListener(We);let fe=V.findIndex(Cn=>Cn.txId===D);if(fe>-1){if(V[fe].status==="error"||V[fe].status==="success")return;V[fe].status=he.err?"error":"success"}k==null||k([...V]),he.err||Q()};this.loopMultiTxStatus&&(Se=setInterval(async()=>{var he;if(Te){clearInterval(Se);return}try{let fe=await this.connection.getTransaction(D,{commitment:"confirmed",maxSupportedTransactionVersion:0});fe&&(Te=!0,clearInterval(Se),ut({err:((he=fe.meta)==null?void 0:he.err)||null}),console.log("tx status from getTransaction:",D))}catch(fe){Te=!0,clearInterval(Se),console.error("getTransaction timeout:",fe,D)}},Ut)),We=this.connection.onSignature(D,he=>{if(Te){this.connection.removeSignatureListener(We);return}Te=!0,ut(he)},"confirmed"),this.connection.getSignatureStatus(D)};return Q(),{txIds:[],signedTxs:_}}else{let O=[];for(let V=0;V<_.length;V+=1){let Q=await this.connection.sendTransaction(_[V],{skipPreflight:R});O.push(Q)}return{txIds:O,signedTxs:_}}}throw new Error("please provide owner in keypair format or signAllTransactions function")},extInfo:o||{}}}};import{PublicKey as ho}from"@solana/web3.js";import xo from"bn.js";function Bo(m){return typeof m=="object"&&m!==null&&![Re,se,ho,te,xo,Ce,Je].some(e=>typeof e=="object"&&m instanceof e)}function Pt(m){return typeof m=="string"?Fn(m):Array.isArray(m)?m.map(e=>Pt(e)):Bo(m)?Object.fromEntries(Object.entries(m).map(([e,t])=>[e,Pt(t)])):m}import Io from"bn.js";var So=new Io(1e6);import{PublicKey as Eo}from"@solana/web3.js";import Xi,{isBN as zi}from"bn.js";import{bits as bl,BitStructure as yl,blob as Ko,Blob as gl,cstr as Pl,f32 as kl,f32be as Al,f64 as wl,f64be as Tl,greedy as hl,Layout as Co,ns64 as xl,ns64be as Bl,nu64 as Il,nu64be as Sl,offset as Kl,s16 as Cl,s16be as Ll,s24 as Rl,s24be as Nl,s32 as Lo,s32be as Ml,s40 as Ol,s40be as _l,s48 as El,s48be as Wl,s8 as Fl,seq as Ro,struct as Vl,Structure as No,u16 as Mo,u16be as vl,u24 as Dl,u24be as ql,u32 as Gl,u32be as Ul,u40 as Xl,u40be as zl,u48 as Hl,u48be as Yl,u8 as Oo,UInt as _o,union as Ql,Union as jl,unionLayoutDiscriminator as Zl,utf8 as Jl}from"@solana/buffer-layout";var jn=Co,qi=No;var Zn=_o;var Gi=Oo,kt=Mo;var ue=Lo;var Ui=Ro;var ge=Ko;var Lt=class extends jn{constructor(t,n,i){super(t,i);this.blob=ge(t),this.signed=n}decode(t,n=0){let i=new Xi(this.blob.decode(t,n),10,"le");return this.signed?i.fromTwos(this.span*8).clone():i}encode(t,n,i=0){return typeof t=="number"&&(t=new Xi(t)),this.signed&&(t=t.toTwos(this.span*8)),this.blob.encode(t.toArrayLike(Buffer,"le",this.span),n,i)}};function G(m){return new Zn(1,m)}function Ne(m){return new Zn(4,m)}function P(m){return new Lt(8,!1,m)}function U(m){return new Lt(16,!1,m)}function Hi(m){return new Lt(8,!0,m)}function Yi(m){return new Lt(16,!0,m)}var dn=class extends jn{constructor(t,n,i,s){super(t.span,s);this.layout=t,this.decoder=n,this.encoder=i}decode(t,n){return this.decoder(this.layout.decode(t,n))}encode(t,n,i){return this.layout.encode(this.encoder(t),n,i)}getSpan(t,n){return this.layout.getSpan(t,n)}};function C(m){return new dn(ge(32),e=>new Eo(e),e=>e.toBuffer(),m)}function Ae(m){return new dn(Gi(),Wo,Fo,m)}function Wo(m){if(m===0)return!1;if(m===1)return!0;throw new Error("Invalid bool: "+m)}function Fo(m){return m?1:0}var Jn=class extends qi{decode(e,t){return super.decode(e,t)}};function E(m,e,t){return new Jn(m,e,t)}function Z(m,e,t){let n,i=typeof e=="number"?e:zi(e)?e.toNumber():new Proxy(e,{get(s,o){if(!n){let r=Reflect.get(s,"count");n=zi(r)?r.toNumber():r,Reflect.set(s,"count",n)}return Reflect.get(s,o)},set(s,o,r){return o==="count"&&(n=r),Reflect.set(s,o,r)}});return Ui(m,i,t)}import{PublicKey as fd}from"@solana/web3.js";import yd from"bn.js";import Pd from"decimal.js";import{AccountLayout as wd,createAssociatedTokenAccountIdempotentInstruction as Td,TOKEN_2022_PROGRAM_ID as hd,TOKEN_PROGRAM_ID as xd}from"@solana/spl-token";import{PublicKey as dm}from"@solana/web3.js";import{MintLayout as bm,TOKEN_PROGRAM_ID as gm}from"@solana/spl-token";var Qi=m=>new Re({mint:m.address,decimals:m.decimals,symbol:m.symbol,name:m.name}),zt=i=>{var s=i,{amount:m,isRaw:e,name:t}=s,n=ct(s,["amount","isRaw","name"]);return new se(new Re({mint:Ge(n.address).toBase58(),decimals:n.decimals,symbol:n.symbol,name:t}),m,e,t)};var At=i=>{var s=i,{address:m,programId:e,decimals:t}=s,n=ct(s,["address","programId","decimals"]);return F({chainId:101,address:Ge(m).toBase58(),programId:e,logoURI:"",symbol:"",name:"",decimals:t,tags:[],extensions:n.extensions||{}},n)};var $n=(...m)=>m.map(e=>{try{return typeof e=="object"?JSON.stringify(e):e}catch{return e}}).join(", "),Rt=class{constructor({scope:e,moduleName:t}){this.disabled=!1;this.scope=e,this.logger=re(t)}createTxBuilder(e){return this.scope.checkOwner(),new Xt({connection:this.scope.connection,feePayer:e||this.scope.ownerPubKey,cluster:this.scope.cluster,owner:this.scope.owner,blockhashCommitment:this.scope.blockhashCommitment,loopMultiTxStatus:this.scope.loopMultiTxStatus,api:this.scope.api,signAllTransactions:this.scope.signAllTransactions})}createSniperTxBuilder(e,t){let n=new ze(e);return new Xt({connection:this.scope.connection,feePayer:t,cluster:this.scope.cluster,owner:n,blockhashCommitment:this.scope.blockhashCommitment,loopMultiTxStatus:this.scope.loopMultiTxStatus,api:this.scope.api,signAllTransactions:this.scope.signAllTransactions})}logDebug(...e){this.logger.debug($n(e))}logInfo(...e){this.logger.info($n(e))}logAndCreateError(...e){let t=$n(e);throw new Error(t)}checkDisabled(){(this.disabled||!this.scope)&&this.logAndCreateError("module not working")}};import{Keypair as An,PublicKey as K,SystemProgram as st,TransactionInstruction as Be}from"@solana/web3.js";import li from"bn.js";import{ASSOCIATED_TOKEN_PROGRAM_ID as Jt,TOKEN_2022_PROGRAM_ID as de,TOKEN_PROGRAM_ID as ie}from"@solana/spl-token";import Yo from"bn.js";import Ot from"decimal.js";import Fe from"bn.js";var me=new Fe(0),Me=new Fe(1),it=new Fe(-1),Oe=new Fe(1).shln(64),fn=new Fe(1).shln(128),ei=Oe.sub(Me),Ht=64,ji=fn.subn(1),Ie=-443636,Ke=-Ie,He=new Fe("4295048016"),Ye=new Fe("79226673521066979257578248091"),bn=new Fe("4295048017"),yn=new Fe("79226673521066979257578248090"),Zi=16,Ji="59543866431248",$i="184467440737095516",er="15793534762490258745",gn=new Fe(10).pow(new Fe(6));var Cm=new Fe("18446744073700000000");import Y from"bn.js";import je from"decimal.js";function Pn(m){let e=new ArrayBuffer(4);return new DataView(e).setInt32(0,m,!1),new Uint8Array(e)}function ti(m,e){let t=0;for(let n=m-1;n>=0&&!e.testn(n);n--)t++;return t}function ni(m,e){let t=0;for(let n=0;n<m&&!e.testn(n);n++)t++;return t}function Yt(m,e){for(let t=0;t<m;t++)if(e.testn(t))return!1;return!0}function tr(m,e){return Yt(m,e)?null:ti(m,e)}function nr(m,e){return Yt(m,e)?null:ni(m,e)}var _m=Buffer.from("amm_config","utf8"),Vo=Buffer.from("pool","utf8"),vo=Buffer.from("pool_vault","utf8"),Do=Buffer.from("pool_reward_vault","utf8"),ir=Buffer.from("position","utf8"),qo=Buffer.from("tick_array","utf8"),Go=Buffer.from("operation","utf8"),Uo=Buffer.from("pool_tick_array_bitmap_extension","utf8"),Xo=Buffer.from("observation","utf8");function rr(m,e,t,n){return Pe([Vo,e.toBuffer(),t.toBuffer(),n.toBuffer()],m)}function ii(m,e,t){return Pe([vo,e.toBuffer(),t.toBuffer()],m)}function or(m,e,t){return Pe([Do,e.toBuffer(),t.toBuffer()],m)}function ne(m,e,t){return Pe([qo,e.toBuffer(),Pn(t)],m)}function rt(m,e,t,n){return Pe([ir,e.toBuffer(),Pn(t),Pn(n)],m)}function Le(m,e){return Pe([ir,e.toBuffer()],m)}function Nt(m){return Pe([Buffer.from("metadata","utf8"),lt.toBuffer(),m.toBuffer()],lt)}function kn(m){return Pe([Go],m)}function ke(m,e){return Pe([Uo,e.toBuffer()],m)}function sr(m,e){return Pe([Xo,e.toBuffer()],m)}var ar=Buffer.from("locked_position","utf8");function ri(m,e){return Pe([ar,e.toBuffer()],m)}function oi(m,e){return Pe([ar,e.toBuffer()],m)}var Em=Buffer.from("support_mint","utf8");import{PublicKey as _e}from"@solana/web3.js";import{TOKEN_2022_PROGRAM_ID as ur}from"@solana/spl-token";import ce from"bn.js";import $ from"decimal.js";import Qe from"bn.js";import si from"decimal.js";var Qt=class{static getfeeGrowthInside(e,t,n){let i=new Qe(0),s=new Qe(0);e.tickCurrent>=t.tick?(i=t.feeGrowthOutsideX64A,s=t.feeGrowthOutsideX64B):(i=e.feeGrowthGlobalX64A.sub(t.feeGrowthOutsideX64A),s=e.feeGrowthGlobalX64B.sub(t.feeGrowthOutsideX64B));let o=new Qe(0),r=new Qe(0);e.tickCurrent<n.tick?(o=n.feeGrowthOutsideX64A,r=n.feeGrowthOutsideX64B):(o=e.feeGrowthGlobalX64A.sub(n.feeGrowthOutsideX64A),r=e.feeGrowthGlobalX64B.sub(n.feeGrowthOutsideX64B));let u=H.wrappingSubU128(H.wrappingSubU128(e.feeGrowthGlobalX64A,i),o),a=H.wrappingSubU128(H.wrappingSubU128(e.feeGrowthGlobalX64B,s),r);return{feeGrowthInsideX64A:u,feeGrowthInsideBX64:a}}static GetPositionFees(e,t,n,i){let{feeGrowthInsideX64A:s,feeGrowthInsideBX64:o}=this.getfeeGrowthInside(e,n,i),r=H.mulDivFloor(H.wrappingSubU128(s,t.feeGrowthInsideLastX64A),t.liquidity,Oe),u=t.tokenFeesOwedA.add(r),a=H.mulDivFloor(H.wrappingSubU128(o,t.feeGrowthInsideLastX64B),t.liquidity,Oe),c=t.tokenFeesOwedB.add(a);return{tokenFeeAmountA:u,tokenFeeAmountB:c}}static GetPositionFeesV2(e,t,n,i){let{feeGrowthInsideX64A:s,feeGrowthInsideBX64:o}=this.getfeeGrowthInside(e,n,i),r=H.mulDivFloor(H.wrappingSubU128(s,t.feeGrowthInsideLastX64A),t.liquidity,Oe),u=t.tokenFeesOwedA.add(r),a=H.mulDivFloor(H.wrappingSubU128(o,t.feeGrowthInsideLastX64B),t.liquidity,Oe),c=t.tokenFeesOwedB.add(a);return{tokenFeeAmountA:u,tokenFeeAmountB:c}}static GetPositionRewardsV2(e,t,n,i){let s=[],o=this.getRewardGrowthInsideV2(e.tickCurrent,n,i,e.rewardInfos);for(let r=0;r<o.length;r++){let u=o[r],a=t.rewardInfos[r],c=H.wrappingSubU128(u,a.growthInsideLastX64),p=H.mulDivFloor(c,t.liquidity,Oe),l=a.rewardAmountOwed.add(p);s.push(l)}return s}static GetPositionRewards(e,t,n,i){let s=[],o=this.getRewardGrowthInside(e.tickCurrent,n,i,e.rewardInfos);for(let r=0;r<o.length;r++){let u=o[r],a=t.rewardInfos[r],c=H.wrappingSubU128(u,a.growthInsideLastX64),p=H.mulDivFloor(c,t.liquidity,Oe),l=a.rewardAmountOwed.add(p);s.push(l)}return s}static getRewardGrowthInside(e,t,n,i){let s=[];for(let o=0;o<i.length;o++){let r=new Qe(0);t.liquidityGross.eqn(0)?r=i[o].rewardGrowthGlobalX64:e<t.tick?r=i[o].rewardGrowthGlobalX64.sub(t.rewardGrowthsOutsideX64[o]):r=t.rewardGrowthsOutsideX64[o];let u=new Qe(0);n.liquidityGross.eqn(0)||(e<n.tick?u=n.rewardGrowthsOutsideX64[o]:u=i[o].rewardGrowthGlobalX64.sub(n.rewardGrowthsOutsideX64[o])),s.push(H.wrappingSubU128(H.wrappingSubU128(i[o].rewardGrowthGlobalX64,r),u))}return s}static getRewardGrowthInsideV2(e,t,n,i){let s=[];for(let o=0;o<i.length;o++){let r=new Qe(0);t.liquidityGross.eqn(0)?r=i[o].rewardGrowthGlobalX64:e<t.tick?r=i[o].rewardGrowthGlobalX64.sub(t.rewardGrowthsOutsideX64[o]):r=t.rewardGrowthsOutsideX64[o];let u=new Qe(0);n.liquidityGross.eqn(0)||(e<n.tick?u=n.rewardGrowthsOutsideX64[o]:u=i[o].rewardGrowthGlobalX64.sub(n.rewardGrowthsOutsideX64[o])),s.push(H.wrappingSubU128(H.wrappingSubU128(i[o].rewardGrowthGlobalX64,r),u))}return s}static getAmountsFromLiquidity({poolInfo:e,ownerPosition:t,liquidity:n,slippage:i,add:s,epochInfo:o}){var f,g,w,B;let r=z.priceToSqrtPriceX64(new si(e.price),e.mintA.decimals,e.mintB.decimals),u=z.getSqrtPriceX64FromTick(t.tickLower),a=z.getSqrtPriceX64FromTick(t.tickUpper),c=s?1+i:1-i,p=ee.getAmountsFromLiquidity(r,u,a,n,s),[l,d]=[be(p.amountA,(f=e.mintA.extensions)==null?void 0:f.feeConfig,o,!0),be(p.amountB,(g=e.mintB.extensions)==null?void 0:g.feeConfig,o,!0)],[y,b]=[be(new Qe(new si(p.amountA.toString()).mul(c).toFixed(0)),(w=e.mintA.extensions)==null?void 0:w.feeConfig,o,!0),be(new Qe(new si(p.amountB.toString()).mul(c).toFixed(0)),(B=e.mintB.extensions)==null?void 0:B.feeConfig,o,!0)];return{liquidity:n,amountA:l,amountB:d,amountSlippageA:y,amountSlippageB:b,expirationTime:De(l.expirationTime,d.expirationTime)}}};var zo=15,J=class{static async getTickArrays(e,t,n,i,s,o,r){let u=[],a=W.getTickArrayStartIndexByTick(i,s),c=W.getInitializedTickArrayInRange(o,r,s,a,Math.floor(zo/2));for(let d=0;d<c.length;d++){let{publicKey:y}=ne(t,n,c[d]);u.push(y)}let p=(await Ze(e,u)).map(d=>d!==null?jt.decode(d.data):null),l={};for(let d=0;d<u.length;d++){let y=p[d];y!==null&&(l[y.startTickIndex]=X(F({},y),{address:u[d]}))}return l}static nextInitializedTick(e,t,n,i,s,o){let{initializedTick:r,tickArrayAddress:u,tickArrayStartTickIndex:a}=this.nextInitializedTickInOneArray(e,t,n,i,s,o);for(;r==null||r.liquidityGross.lten(0);){if(a=W.getNextTickArrayStartIndex(a,s,o),this.checkIsValidStartIndex(a,s))throw new Error("No enough initialized tickArray");let c=n[a];if(c===void 0)continue;let{nextTick:p,tickArrayAddress:l,tickArrayStartTickIndex:d}=this.firstInitializedTickInOneArray(e,t,c,o);[r,u,a]=[p,l,d]}if(r==null)throw new Error("No invaild tickArray cache");return{nextTick:r,tickArrayAddress:u,tickArrayStartTickIndex:a}}static nextInitializedTickArray(e,t,n,i,s){let o=Math.floor(e/J.tickCount(t)),r=n?W.searchLowBitFromStart(i,s,o-1,1,t):W.searchHightBitFromStart(i,s,o+1,1,t);return r.length>0?{isExist:!0,nextStartIndex:r[0]}:{isExist:!1,nextStartIndex:0}}static firstInitializedTickInOneArray(e,t,n,i){let s;if(i){let r=we-1;for(;r>=0;){let u=n.ticks[r];if(u.liquidityGross.gtn(0)){s=u;break}r=r-1}}else{let r=0;for(;r<we;){let u=n.ticks[r];if(u.liquidityGross.gtn(0)){s=u;break}r=r+1}}let{publicKey:o}=ne(e,t,n.startTickIndex);return{nextTick:s,tickArrayAddress:o,tickArrayStartTickIndex:n.startTickIndex}}static nextInitializedTickInOneArray(e,t,n,i,s,o){let r=W.getTickArrayStartIndexByTick(i,s),u=Math.floor((i-r)/s),a=n[r];if(a==null)return{initializedTick:void 0,tickArrayAddress:void 0,tickArrayStartTickIndex:r};let c;if(o)for(;u>=0;){let l=a.ticks[u];if(l.liquidityGross.gtn(0)){c=l;break}u=u-1}else for(u=u+1;u<we;){let l=a.ticks[u];if(l.liquidityGross.gtn(0)){c=l;break}u=u+1}let{publicKey:p}=ne(e,t,r);return{initializedTick:c,tickArrayAddress:p,tickArrayStartTickIndex:a.startTickIndex}}static getArrayStartIndex(e,t){let n=this.tickCount(t);return Math.floor(e/n)*n}static checkIsValidStartIndex(e,t){if(W.checkIsOutOfBoundary(e)){if(e>Ke)return!1;let n=W.getTickArrayStartIndexByTick(Ie,t);return e==n}return e%this.tickCount(t)==0}static tickCount(e){return we*e}};var ai=14,ot=class{static maxTickInTickarrayBitmap(e){return e*we*wt}static getBitmapTickBoundary(e,t){let n=this.maxTickInTickarrayBitmap(t),i=Math.floor(Math.abs(e)/n);e<0&&Math.abs(e)%n!=0&&(i+=1);let s=n*i;return e<0?{minValue:-s,maxValue:-s+n}:{minValue:s,maxValue:s+n}}static nextInitializedTickArrayStartIndex(e,t,n,i){if(!J.checkIsValidStartIndex(t,n))throw Error("nextInitializedTickArrayStartIndex check error");let s=this.maxTickInTickarrayBitmap(n),o=i?t-J.tickCount(n):t+J.tickCount(n);if(o<-s||o>=s)return{isInit:!1,tickIndex:t};let r=n*we,u=o/r+512;o<0&&o%r!=0&&u--;let a=Math.abs(u);if(i){let c=e.shln(1024-a-1),p=tr(1024,c);if(p!==null){let l=(a-p-512)*r;return{isInit:!0,tickIndex:l}}else return{isInit:!1,tickIndex:-s}}else{let c=e.shrn(a),p=nr(1024,c);if(p!==null){let l=(a+p-512)*r;return{isInit:!0,tickIndex:l}}else return{isInit:!1,tickIndex:s-J.tickCount(n)}}}},Zt=class{static getBitmapOffset(e,t){if(!J.checkIsValidStartIndex(e,t))throw new Error("No enough initialized tickArray");this.checkExtensionBoundary(e,t);let n=ot.maxTickInTickarrayBitmap(t),i=Math.floor(Math.abs(e)/n)-1;return e<0&&Math.abs(e)%n===0&&i--,i}static getBitmap(e,t,n){let i=this.getBitmapOffset(e,t);return e<0?{offset:i,tickarrayBitmap:n.negativeTickArrayBitmap[i]}:{offset:i,tickarrayBitmap:n.positiveTickArrayBitmap[i]}}static checkExtensionBoundary(e,t){let{positiveTickBoundary:n,negativeTickBoundary:i}=this.extensionTickBoundary(t);if(e>=i&&e<n)throw Error("checkExtensionBoundary -> InvalidTickArrayBoundary")}static extensionTickBoundary(e){let t=ot.maxTickInTickarrayBitmap(e),n=-t;if(Ke<=t)throw Error(`extensionTickBoundary check error: ${Ke}, ${t}`);if(n<=Ie)throw Error(`extensionTickBoundary check error: ${n}, ${Ie}`);return{positiveTickBoundary:t,negativeTickBoundary:n}}static checkTickArrayIsInit(e,t,n){let{tickarrayBitmap:i}=this.getBitmap(e,t,n),s=this.tickArrayOffsetInBitmap(e,t);return{isInitialized:W.mergeTickArrayBitmap(i).testn(s),startIndex:e}}static nextInitializedTickArrayFromOneBitmap(e,t,n,i){let s=J.tickCount(t),o=n?e-s:e+s,{tickarrayBitmap:r}=this.getBitmap(o,t,i);return this.nextInitializedTickArrayInBitmap(r,o,t,n)}static nextInitializedTickArrayInBitmap(e,t,n,i){let{minValue:s,maxValue:o}=ot.getBitmapTickBoundary(t,n),r=this.tickArrayOffsetInBitmap(t,n);if(i){let u=W.mergeTickArrayBitmap(e).shln(wt-1-r),a=Yt(512,u)?null:ti(512,u);if(a!==null){let c=t-a*J.tickCount(n);return{isInit:!0,tickIndex:c}}else return{isInit:!1,tickIndex:s}}else{let u=W.mergeTickArrayBitmap(e).shrn(r),a=Yt(512,u)?null:ni(512,u);if(a!==null){let c=t+a*J.tickCount(n);return{isInit:!0,tickIndex:c}}else return{isInit:!1,tickIndex:o-J.tickCount(n)}}}static tickArrayOffsetInBitmap(e,t){let n=Math.abs(e)%ot.maxTickInTickarrayBitmap(t),i=Math.floor(n/J.tickCount(t));return e<0&&n!=0&&(i=wt-i),i}};var pe=class{static getOutputAmountAndRemainAccounts(e,t,n,i,s,o=!1){let r=n.toBase58()===e.mintA.address,u=[],{isExist:a,startIndex:c,nextAccountMeta:p}=this.getFirstInitializedTickArray(e,r);if(!a||c===void 0||!p)throw new Error("Invalid tick array");u.push(p);let{allTrade:l,amountCalculated:d,accounts:y,sqrtPriceX64:b,feeAmount:f}=Tt.swapCompute(e.programId,e.id,t,e.tickArrayBitmap,e.exBitmapInfo,r,e.ammConfig.tradeFeeRate,e.liquidity,e.tickCurrent,e.tickSpacing,e.sqrtPriceX64,i,c,s,o);return u.push(...y),{allTrade:l,expectedAmountOut:d.mul(it),remainingAccounts:u,executionPrice:b,feeAmount:f}}static getInputAmountAndRemainAccounts(e,t,n,i,s){let o=n.toBase58()===e.mintB.address,r=[],{isExist:u,startIndex:a,nextAccountMeta:c}=this.getFirstInitializedTickArray(e,o);if(!u||a===void 0||!c)throw new Error("Invalid tick array");try{let b=this.preInitializedTickArrayStartIndex(e,o);if(b.isExist){let{publicKey:f}=ne(e.programId,e.id,b.nextStartIndex);r.push(f)}}catch{}r.push(c);let{amountCalculated:p,accounts:l,sqrtPriceX64:d,feeAmount:y}=Tt.swapCompute(e.programId,e.id,t,e.tickArrayBitmap,e.exBitmapInfo,o,e.ammConfig.tradeFeeRate,e.liquidity,e.tickCurrent,e.tickSpacing,e.sqrtPriceX64,i.mul(it),a,s);return r.push(...l),{expectedAmountIn:p,remainingAccounts:r,executionPrice:d,feeAmount:y}}static getFirstInitializedTickArray(e,t){let{isInitialized:n,startIndex:i}=pe.isOverflowDefaultTickarrayBitmap(e.tickSpacing,[e.tickCurrent])?Zt.checkTickArrayIsInit(J.getArrayStartIndex(e.tickCurrent,e.tickSpacing),e.tickSpacing,e.exBitmapInfo):W.checkTickArrayIsInitialized(W.mergeTickArrayBitmap(e.tickArrayBitmap),e.tickCurrent,e.tickSpacing);if(n){let{publicKey:r}=ne(e.programId,e.id,i);return{isExist:!0,startIndex:i,nextAccountMeta:r}}let{isExist:s,nextStartIndex:o}=this.nextInitializedTickArrayStartIndex(e,J.getArrayStartIndex(e.tickCurrent,e.tickSpacing),t);if(s){let{publicKey:r}=ne(e.programId,e.id,o);return{isExist:!0,startIndex:o,nextAccountMeta:r}}return{isExist:!1,nextAccountMeta:void 0,startIndex:void 0}}static preInitializedTickArrayStartIndex(e,t){let n=Math.floor(e.tickCurrent/J.tickCount(e.tickSpacing)),i=t?W.searchHightBitFromStart(e.tickArrayBitmap,e.exBitmapInfo,n+1,1,e.tickSpacing):W.searchLowBitFromStart(e.tickArrayBitmap,e.exBitmapInfo,n-1,1,e.tickSpacing);return i.length>0?{isExist:!0,nextStartIndex:i[0]}:{isExist:!1,nextStartIndex:0}}static nextInitializedTickArrayStartIndex(e,t,n){for(t=J.getArrayStartIndex(e.tickCurrent,e.tickSpacing);;){let{isInit:i,tickIndex:s}=ot.nextInitializedTickArrayStartIndex(W.mergeTickArrayBitmap(e.tickArrayBitmap),t,e.tickSpacing,n);if(i)return{isExist:!0,nextStartIndex:s};t=s;let{isInit:o,tickIndex:r}=Zt.nextInitializedTickArrayFromOneBitmap(t,e.tickSpacing,n,e.exBitmapInfo);if(o)return{isExist:!0,nextStartIndex:r};if(t=r,t<Ie||t>Ke)return{isExist:!1,nextStartIndex:0}}}static async updatePoolRewardInfos({connection:e,apiPoolInfo:t,chainTime:n,poolLiquidity:i,rewardInfos:s}){var r,u,a;let o=[];for(let c=0;c<s.length;c++){let p=s[c],l=(a=(r=t.rewardDefaultInfos[c])==null?void 0:r.mint.programId)!=null?a:(u=await e.getAccountInfo(p.tokenMint))==null?void 0:u.owner;if(l===void 0)throw Error("get new reward mint info error");let d=X(F({},p),{perSecond:H.x64ToDecimal(p.emissionsPerSecondX64),remainingRewards:void 0,tokenProgramId:new _e(l)});if(d.tokenMint.equals(_e.default))continue;if(n<=d.openTime.toNumber()||i.eq(me)){o.push(d);continue}let y=new ce(Math.min(d.endTime.toNumber(),n)),b=y.sub(d.lastUpdateTime),f=H.mulDivFloor(b,d.emissionsPerSecondX64,i),g=d.rewardGrowthGlobalX64.add(f),w=H.mulDivFloor(b,d.emissionsPerSecondX64,Oe),B=d.rewardTotalEmissioned.add(w);o.push(X(F({},d),{rewardGrowthGlobalX64:g,rewardTotalEmissioned:B,lastUpdateTime:y}))}return o}static isOverflowDefaultTickarrayBitmap(e,t){let{maxTickBoundary:n,minTickBoundary:i}=this.tickRange(e);for(let s of t){let o=W.getTickArrayStartIndexByTick(s,e);if(o>=n||o<i)return!0}return!1}static tickRange(e){let t=ot.maxTickInTickarrayBitmap(e),n=-t;return t>Ke&&(t=J.getArrayStartIndex(Ke,e)+J.tickCount(e)),n<Ie&&(n=J.getArrayStartIndex(Ie,e)),{maxTickBoundary:t,minTickBoundary:n}}static get_tick_array_offset(e,t){if(!J.checkIsValidStartIndex(e,t))throw new Error("No enough initialized tickArray");return e/J.tickCount(t)*wt}static async fetchExBitmaps({connection:e,exBitmapAddress:t,batchRequest:n}){let i=await bt(e,t.map(o=>({pubkey:o})),{batchRequest:n}),s={};for(let o of i)o.accountInfo!==null&&(s[o.pubkey.toString()]=cr.decode(o.accountInfo.data));return s}static async fetchMultiplePoolTickArrays({connection:e,poolKeys:t,batchRequest:n}){let i={},s=[];for(let u of t){let a=W.getTickArrayStartIndexByTick(u.tickCurrent,u.tickSpacing),c=W.getInitializedTickArrayInRange(u.tickArrayBitmap,u.exBitmapInfo,u.tickSpacing,a,7);for(let p of c){let{publicKey:l}=ne(u.programId,u.id,p);s.push({pubkey:l}),i[l.toString()]=u.id}}let o=await bt(e,s,{batchRequest:n}),r={};for(let u of o){if(!u.accountInfo)continue;let a=i[u.pubkey.toString()];if(!a)continue;r[a.toString()]===void 0&&(r[a.toString()]={});let c=jt.decode(u.accountInfo.data);r[a.toString()][c.startTickIndex]=X(F({},c),{address:u.pubkey})}return r}static async fetchPoolsAccountPosition({pools:e,connection:t,ownerInfo:n,batchRequest:i=!1,updateOwnerRewardAndFee:s=!0}){var r;let o=[];for(let u=0;u<e.length;u++){let a=e[u];a!==null&&(o.find(c=>c.equals(a.state.programId))||o.push(a.state.programId))}if(n){let u=n.tokenAccounts.map(l=>l.accountInfo.mint),a=[];for(let l of u)for(let d of o)a.push(Le(d,l).publicKey);let c=await Ze(t,a,{batchRequest:i}),p={};for(let l of c){if(l===null)continue;let d=ui.decode(l.data),y=d.poolId.toString(),b=e.find(x=>x.state.id.toBase58()===y);if(b===void 0)continue;let f=b.state,g=W._getTickPriceLegacy({poolInfo:f,tick:d.tickLower,baseIn:!0}),w=W._getTickPriceLegacy({poolInfo:f,tick:d.tickUpper,baseIn:!0}),{amountA:B,amountB:T}=ee.getAmountsFromLiquidity(f.sqrtPriceX64,g.tickSqrtPriceX64,w.tickSqrtPriceX64,d.liquidity,!1),A=1/(1-Math.sqrt(Math.sqrt(g.price.div(w.price).toNumber())));b.positionAccount=[...(r=b.positionAccount)!=null?r:[],{poolId:d.poolId,nftMint:d.nftMint,priceLower:g.price,priceUpper:w.price,amountA:B,amountB:T,tickLower:d.tickLower,tickUpper:d.tickUpper,liquidity:d.liquidity,feeGrowthInsideLastX64A:d.feeGrowthInsideLastX64A,feeGrowthInsideLastX64B:d.feeGrowthInsideLastX64B,tokenFeesOwedA:d.tokenFeesOwedA,tokenFeesOwedB:d.tokenFeesOwedB,rewardInfos:d.rewardInfos.map(x=>X(F({},x),{pendingReward:new ce(0)})),leverage:A,tokenFeeAmountA:new ce(0),tokenFeeAmountB:new ce(0)}];let k=await W.getTickArrayAddressByTick(b.state.programId,d.poolId,d.tickLower,b.state.tickSpacing),I=await W.getTickArrayAddressByTick(b.state.programId,d.poolId,d.tickUpper,b.state.tickSpacing);p[`${b.state.programId.toString()}-${d.poolId.toString()}-${d.tickLower}`]=k,p[`${b.state.programId.toString()}-${d.poolId.toString()}-${d.tickUpper}`]=I}if(s){let l=Object.values(p),d=await Ze(t,l,{batchRequest:i}),y={};for(let b=0;b<l.length;b++){let f=d[b];if(f===null)continue;let g=l[b].toString();y[g]=jt.decode(f.data)}for(let{state:b,positionAccount:f}of e)if(!!f)for(let g of f){let w=`${b.programId.toString()}-${b.id.toString()}-${g.tickLower}`,B=`${b.programId.toString()}-${b.id.toString()}-${g.tickUpper}`,T=y[p[w].toString()],A=y[p[B].toString()],k=T.ticks[W.getTickOffsetInArray(g.tickLower,b.tickSpacing)],I=A.ticks[W.getTickOffsetInArray(g.tickUpper,b.tickSpacing)],{tokenFeeAmountA:x,tokenFeeAmountB:R}=await Qt.GetPositionFees(b,g,k,I),h=await Qt.GetPositionRewards(b,g,k,I);g.tokenFeeAmountA=x.gte(new ce(0))?x:new ce(0),g.tokenFeeAmountB=R.gte(new ce(0))?R:new ce(0);for(let L=0;L<h.length;L++)g.rewardInfos[L].pendingReward=h[L].gte(new ce(0))?h[L]:new ce(0)}}}return e}static computeAmountOut({poolInfo:e,tickArrayCache:t,baseMint:n,epochInfo:i,amountIn:s,slippage:o,priceLimit:r=new $(0),catchLiquidityInsufficient:u=!1}){var _;let a,c=n.toBase58()===e.mintA.address,[p,l]=c?[e.mintA.extensions.feeConfig,e.mintB.extensions.feeConfig]:[e.mintB.extensions.feeConfig,e.mintA.extensions.feeConfig];r.equals(new $(0))?a=c?He.add(new ce(1)):Ye.sub(new ce(1)):a=z.priceToSqrtPriceX64(r,e.mintA.decimals,e.mintB.decimals);let d=be(s,p,i,!1),{allTrade:y,expectedAmountOut:b,remainingAccounts:f,executionPrice:g,feeAmount:w}=pe.getOutputAmountAndRemainAccounts(e,t,n,d.amount.sub((_=d.fee)!=null?_:me),a,u),B=be(b,l,i,!1),T=z.sqrtPriceX64ToPrice(g,e.mintA.decimals,e.mintB.decimals),A=c?T:new $(1).div(T),k=b.mul(new ce(Math.floor((1-o)*1e10))).div(new ce(1e10)),I=be(k,l,i,!1),x=c?e.currentPrice:new $(1).div(e.currentPrice),R=new $(A).sub(x).abs(),h=x,L=new Je(new $(R).mul(10**15).toFixed(0),new $(h).mul(10**15).toFixed(0));return{allTrade:y,realAmountIn:d,amountOut:B,minAmountOut:I,expirationTime:De(d.expirationTime,B.expirationTime),currentPrice:e.currentPrice,executionPrice:A,priceImpact:L,fee:w,remainingAccounts:f,executionPriceX64:g}}static computeAmountOutFormat({poolInfo:e,tickArrayCache:t,amountIn:n,tokenOut:i,slippage:s,epochInfo:o,catchLiquidityInsufficient:r=!1}){let u=i.address===e.mintB.address,[a,c]=u?[e.mintA,e.mintB]:[e.mintB,e.mintA],[p,l]=[new Re(X(F({},a),{mint:a.address,isToken2022:a.programId===ur.toBase58()})),new Re(X(F({},c),{mint:c.address,isToken2022:c.programId===ur.toBase58()}))],{allTrade:d,realAmountIn:y,amountOut:b,minAmountOut:f,expirationTime:g,currentPrice:w,executionPrice:B,priceImpact:T,fee:A,remainingAccounts:k,executionPriceX64:I}=pe.computeAmountOut({poolInfo:e,tickArrayCache:t,baseMint:new _e(a.address),amountIn:n,slippage:s,epochInfo:o,catchLiquidityInsufficient:r}),x=X(F({},y),{amount:new se(p,y.amount),fee:y.fee===void 0?void 0:new se(p,y.fee)}),R=X(F({},b),{amount:new se(l,b.amount),fee:b.fee===void 0?void 0:new se(l,b.fee)}),h=X(F({},f),{amount:new se(l,f.amount),fee:f.fee===void 0?void 0:new se(l,f.fee)}),L=new Ce({baseToken:p,denominator:new ce(10).pow(new ce(20+p.decimals)),quoteToken:l,numerator:w.mul(new $(10**(20+l.decimals))).toFixed(0)}),_=new Ce({baseToken:p,denominator:new ce(10).pow(new ce(20+p.decimals)),quoteToken:l,numerator:B.mul(new $(10**(20+l.decimals))).toFixed(0)}),O=new se(p,A);return{allTrade:d,realAmountIn:x,amountOut:R,minAmountOut:h,expirationTime:g,currentPrice:L,executionPrice:_,priceImpact:T,fee:O,remainingAccounts:k,executionPriceX64:I}}static computeAmountIn({poolInfo:e,tickArrayCache:t,baseMint:n,epochInfo:i,amountOut:s,slippage:o,priceLimit:r=new $(0)}){var h;let u=n.toBase58()===e.mintA.address,a={[e.mintA.address]:e.mintA.extensions.feeConfig,[e.mintB.address]:e.mintB.extensions.feeConfig},c;r.equals(new $(0))?c=u?Ye.sub(new ce(1)):He.add(new ce(1)):c=z.priceToSqrtPriceX64(r,e.mintA.decimals,e.mintB.decimals);let p=be(s,a[n.toString()],i,!0),{expectedAmountIn:l,remainingAccounts:d,executionPrice:y,feeAmount:b}=pe.getInputAmountAndRemainAccounts(e,t,n,p.amount.sub((h=p.fee)!=null?h:me),c),f=u?e.mintB.address:e.mintA.address,g=be(l,a[f],i,!1),w=z.sqrtPriceX64ToPrice(y,e.mintA.decimals,e.mintB.decimals),B=u?w:new $(1).div(w),T=l.mul(new ce(Math.floor((1+o)*1e10))).div(new ce(1e10)),A=be(T,a[f],i,!0),k=u?e.currentPrice:new $(1).div(e.currentPrice),I=new $(B).sub(k).abs(),x=k,R=new Je(new $(I).mul(10**15).toFixed(0),new $(x).mul(10**15).toFixed(0));return{amountIn:g,maxAmountIn:A,realAmountOut:p,expirationTime:De(g.expirationTime,p.expirationTime),currentPrice:e.currentPrice,executionPrice:B,priceImpact:R,fee:b,remainingAccounts:d}}static estimateAprsForPriceRangeMultiplier({poolInfo:e,aprType:t,positionTickLowerIndex:n,positionTickUpperIndex:i}){var y,b,f;let s=e[t],o=W.getTickPrice({poolInfo:e,tick:n,baseIn:!0}).price.toNumber(),r=W.getTickPrice({poolInfo:e,tick:i,baseIn:!0}).price.toNumber(),u=Math.max(o,s.priceMin),c=Math.min(r,s.priceMax)-u,p=r-o,l=s.priceMax-s.priceMin,d;return c<=0?d=0:p===c?d=l/c:l===c?d=c/p:d=c/l*(c/p),{feeApr:s.feeApr*d,rewardsApr:[((y=s.rewardApr[0])!=null?y:0)*d,((b=s.rewardApr[1])!=null?b:0)*d,((f=s.rewardApr[2])!=null?f:0)*d],apr:s.apr*d}}static estimateAprsForPriceRangeDelta({poolInfo:e,poolLiquidity:t,aprType:n,mintPrice:i,liquidity:s,positionTickLowerIndex:o,positionTickUpperIndex:r,chainTime:u}){let a=n==="day"?1:n==="week"?7:n==="month"?30:0,c=e[n],p=i[Ge(e.mintA.address).toString()],l=i[Ge(e.mintB.address).toString()],d=e.mintA.decimals,y=e.mintB.decimals;if(!c||!p||!l)return{feeApr:0,rewardsApr:[0,0,0],apr:0};let b=z.priceToSqrtPriceX64(new $(e.price),e.mintA.decimals,e.mintB.decimals),f=z.getSqrtPriceX64FromTick(o),g=z.getSqrtPriceX64FromTick(r),{amountSlippageA:w,amountSlippageB:B}=ee.getAmountsFromLiquidityWithSlippage(b,f,g,t,!1,!1,0),{amountSlippageA:T,amountSlippageB:A}=ee.getAmountsFromLiquidityWithSlippage(b,f,g,s,!1,!1,0),k=new $(w.toString()).div(new $(10).pow(d)).mul(p.value).add(new $(B.toString()).div(new $(10).pow(y)).mul(l.value)),I=new $(T.toString()).div(new $(10).pow(d)).mul(p.value).add(new $(A.toString()).div(new $(10).pow(y)).mul(l.value)),x=new $(1).div(k.add(I)),h=new $(c.volumeFee).mul(365).div(a).mul(x).mul(100).toNumber(),L=3600*24*365,_=e.rewardDefaultInfos.map(O=>{var D,Te;let V=O.mint.decimals,Q=i[O.mint.address];return u<((D=O.startTime)!=null?D:0)||u>((Te=O.endTime)!=null?Te:0)||!O.perSecond||!Q||V===void 0?0:new $(Q.value).mul(new $(O.perSecond).mul(L)).div(new $(10).pow(V)).mul(x).mul(100).toNumber()});return{feeApr:h,rewardsApr:_,apr:h+_.reduce((O,V)=>O+V,0)}}static async getLiquidityAmountOutFromAmountIn({poolInfo:e,inputA:t,tickLower:n,tickUpper:i,amount:s,slippage:o,add:r,epochInfo:u,amountHasFee:a}){var g,w;let c=z.priceToSqrtPriceX64(new $(e.price),e.mintA.decimals,e.mintB.decimals),p=z.getSqrtPriceX64FromTick(n),l=z.getSqrtPriceX64FromTick(i),d=be(s,(g=e[t?"mintA":"mintB"].extensions)==null?void 0:g.feeConfig,u,!a),y=new ce(new $(d.amount.sub((w=d.fee)!=null?w:me).toString()).toFixed(0)),b;if(c.lte(p))b=t?ee.getLiquidityFromTokenAmountA(p,l,y,!r):new ce(0);else if(c.lte(l)){let B=ee.getLiquidityFromTokenAmountA(c,l,y,!r),T=ee.getLiquidityFromTokenAmountB(p,c,y);b=t?B:T}else b=t?new ce(0):ee.getLiquidityFromTokenAmountB(p,l,y);let f=await pe.getAmountsFromLiquidity({epochInfo:u,poolInfo:e,tickLower:n,tickUpper:i,liquidity:b,slippage:o,add:r});return{liquidity:b,amountA:t?d:f.amountA,amountB:t?f.amountB:d,amountSlippageA:t?d:f.amountSlippageA,amountSlippageB:t?f.amountSlippageB:d,expirationTime:f.expirationTime}}static async getAmountsFromLiquidity({epochInfo:e,poolInfo:t,tickLower:n,tickUpper:i,liquidity:s,slippage:o,add:r}){var f,g,w,B;let u=z.getSqrtPriceX64FromTick(n),a=z.getSqrtPriceX64FromTick(i),c=r?1+o:1-o,p=ee.getAmountsFromLiquidity(z.priceToSqrtPriceX64(new $(t.price),t.mintA.decimals,t.mintB.decimals),u,a,s,r),[l,d]=[be(p.amountA,(f=t.mintA.extensions)==null?void 0:f.feeConfig,e,!0),be(p.amountB,(g=t.mintB.extensions)==null?void 0:g.feeConfig,e,!0)],[y,b]=[be(p.amountA.muln(c),(w=t.mintA.extensions)==null?void 0:w.feeConfig,e,!0),be(p.amountB.muln(c),(B=t.mintB.extensions)==null?void 0:B.feeConfig,e,!0)];return{liquidity:s,amountA:l,amountB:d,amountSlippageA:y,amountSlippageB:b,expirationTime:De(l.expirationTime,d.expirationTime)}}static async fetchComputeMultipleClmmInfo({connection:e,poolList:t,rpcDataMap:n={}}){let i=t.filter(u=>!n[u.id]).map(u=>new _e(u.id));(await Ze(e,i)).forEach((u,a)=>{!u||(n[i[a].toBase58()]=Mt.decode(u.data))});let o=t.map(u=>ke(new _e(u.programId),new _e(u.id)).publicKey),r=await pe.fetchExBitmaps({connection:e,exBitmapAddress:o,batchRequest:!1});return t.reduce((u,a)=>X(F({},u),{[a.id]:X(F({},n[a.id]),{id:new _e(a.id),version:6,programId:new _e(a.programId),mintA:a.mintA,mintB:a.mintB,ammConfig:X(F({},a.config),{id:new _e(a.config.id),fundOwner:""}),currentPrice:new $(a.price),exBitmapAccount:ke(new _e(a.programId),new _e(a.id)).publicKey,exBitmapInfo:r[ke(new _e(a.programId),new _e(a.id)).publicKey.toBase58()],startTime:n[a.id].startTime.toNumber(),rewardInfos:n[a.id].rewardInfos})}),{})}static async fetchComputeClmmInfo({connection:e,poolInfo:t,rpcData:n}){return(await this.fetchComputeMultipleClmmInfo({connection:e,rpcDataMap:n?{[t.id]:n}:void 0,poolList:[t]}))[t.id]}};var H=class{static mulDivRoundingUp(e,t,n){let i=e.mul(t),s=i.div(n);return i.mod(n).eq(me)||(s=s.add(Me)),s}static mulDivFloor(e,t,n){if(n.eq(me))throw new Error("division by 0");return e.mul(t).div(n)}static mulDivCeil(e,t,n){if(n.eq(me))throw new Error("division by 0");return e.mul(t).add(n.sub(Me)).div(n)}static x64ToDecimal(e,t){return new je(e.toString()).div(je.pow(2,64)).toDecimalPlaces(t)}static decimalToX64(e){return new Y(e.mul(je.pow(2,64)).floor().toFixed())}static wrappingSubU128(e,t){return e.add(fn).sub(t).mod(fn)}};function xe(m,e){return ci(m.mul(e),64,256)}function Ho(m,e,t){let n=m.toTwos(t).shln(e);return n.imaskn(t+1),n.fromTwos(t)}function ci(m,e,t){let n=m.toTwos(t).shrn(e);return n.imaskn(t-e+1),n.fromTwos(t-e)}var z=class{static sqrtPriceX64ToPrice(e,t,n){return H.x64ToDecimal(e).pow(2).mul(je.pow(10,t-n))}static priceToSqrtPriceX64(e,t,n){return H.decimalToX64(e.mul(je.pow(10,n-t)).sqrt())}static getNextSqrtPriceX64FromInput(e,t,n,i){if(!e.gt(me))throw new Error("sqrtPriceX64 must greater than 0");if(!t.gt(me))throw new Error("liquidity must greater than 0");return i?this.getNextSqrtPriceFromTokenAmountARoundingUp(e,t,n,!0):this.getNextSqrtPriceFromTokenAmountBRoundingDown(e,t,n,!0)}static getNextSqrtPriceX64FromOutput(e,t,n,i){if(!e.gt(me))throw new Error("sqrtPriceX64 must greater than 0");if(!t.gt(me))throw new Error("liquidity must greater than 0");return i?this.getNextSqrtPriceFromTokenAmountBRoundingDown(e,t,n,!1):this.getNextSqrtPriceFromTokenAmountARoundingUp(e,t,n,!1)}static getNextSqrtPriceFromTokenAmountARoundingUp(e,t,n,i){if(n.eq(me))return e;let s=t.shln(Ht);if(i){let o=s,r=s.add(n.mul(e));return r.gte(o)?H.mulDivCeil(o,e,r):H.mulDivRoundingUp(o,Me,o.div(e).add(n))}else{let o=n.mul(e);if(!s.gt(o))throw new Error("getNextSqrtPriceFromTokenAmountARoundingUp,liquidityLeftShift must gt amountMulSqrtPrice");let r=s.sub(o);return H.mulDivCeil(s,e,r)}}static getNextSqrtPriceFromTokenAmountBRoundingDown(e,t,n,i){let s=n.shln(Ht);if(i)return e.add(s.div(t));{let o=H.mulDivRoundingUp(s,Me,t);if(!e.gt(o))throw new Error("getNextSqrtPriceFromTokenAmountBRoundingDown sqrtPriceX64 must gt amountDivLiquidity");return e.sub(o)}}static getSqrtPriceX64FromTick(e){if(!Number.isInteger(e))throw new Error("tick must be integer");if(e<Ie||e>Ke)throw new Error("tick must be in MIN_TICK and MAX_TICK");let t=e<0?e*-1:e,n=(t&1)!=0?new Y("18445821805675395072"):new Y("18446744073709551616");return(t&2)!=0&&(n=xe(n,new Y("18444899583751176192"))),(t&4)!=0&&(n=xe(n,new Y("18443055278223355904"))),(t&8)!=0&&(n=xe(n,new Y("18439367220385607680"))),(t&16)!=0&&(n=xe(n,new Y("18431993317065453568"))),(t&32)!=0&&(n=xe(n,new Y("18417254355718170624"))),(t&64)!=0&&(n=xe(n,new Y("18387811781193609216"))),(t&128)!=0&&(n=xe(n,new Y("18329067761203558400"))),(t&256)!=0&&(n=xe(n,new Y("18212142134806163456"))),(t&512)!=0&&(n=xe(n,new Y("17980523815641700352"))),(t&1024)!=0&&(n=xe(n,new Y("17526086738831433728"))),(t&2048)!=0&&(n=xe(n,new Y("16651378430235570176"))),(t&4096)!=0&&(n=xe(n,new Y("15030750278694412288"))),(t&8192)!=0&&(n=xe(n,new Y("12247334978884435968"))),(t&16384)!=0&&(n=xe(n,new Y("8131365268886854656"))),(t&32768)!=0&&(n=xe(n,new Y("3584323654725218816"))),(t&65536)!=0&&(n=xe(n,new Y("696457651848324352"))),(t&131072)!=0&&(n=xe(n,new Y("26294789957507116"))),(t&262144)!=0&&(n=xe(n,new Y("37481735321082"))),e>0&&(n=ji.div(n)),n}static getTickFromPrice(e,t,n){return z.getTickFromSqrtPriceX64(z.priceToSqrtPriceX64(e,t,n))}static getTickFromSqrtPriceX64(e){if(e.gt(Ye)||e.lt(He))throw new Error("Provided sqrtPrice is not within the supported sqrtPrice range.");let t=e.bitLength()-1,n=new Y(t-64),i=Ho(n,32,128),s=new Y("8000000000000000","hex"),o=0,r=new Y(0),u=t>=64?e.shrn(t-63):e.shln(63-t);for(;s.gt(new Y(0))&&o<Zi;){u=u.mul(u);let y=u.shrn(127);u=u.shrn(63+y.toNumber()),r=r.add(s.mul(y)),s=s.shrn(1),o+=1}let a=r.shrn(32),p=i.add(a).mul(new Y(Ji)),l=ci(p.sub(new Y($i)),64,128).toNumber(),d=ci(p.add(new Y(er)),64,128).toNumber();return l==d?l:z.getSqrtPriceX64FromTick(d).lte(e)?d:l}},ht=class{static getTickWithPriceAndTickspacing(e,t,n,i){let o=z.getTickFromSqrtPriceX64(z.priceToSqrtPriceX64(e,n,i))/t;return o<0?o=Math.floor(o):o=Math.ceil(o),o*t}static roundPriceWithTickspacing(e,t,n,i){let s=ht.getTickWithPriceAndTickspacing(e,t,n,i),o=z.getSqrtPriceX64FromTick(s);return z.sqrtPriceX64ToPrice(o,n,i)}},ee=class{static addDelta(e,t){return e.add(t)}static getTokenAmountAFromLiquidity(e,t,n,i){if(e.gt(t)&&([e,t]=[t,e]),!e.gt(me))throw new Error("sqrtPriceX64A must greater than 0");let s=n.ushln(Ht),o=t.sub(e);return i?H.mulDivRoundingUp(H.mulDivCeil(s,o,t),Me,e):H.mulDivFloor(s,o,t).div(e)}static getTokenAmountBFromLiquidity(e,t,n,i){if(e.gt(t)&&([e,t]=[t,e]),!e.gt(me))throw new Error("sqrtPriceX64A must greater than 0");return i?H.mulDivCeil(n,t.sub(e),Oe):H.mulDivFloor(n,t.sub(e),Oe)}static getLiquidityFromTokenAmountA(e,t,n,i){e.gt(t)&&([e,t]=[t,e]);let s=n.mul(e).mul(t),o=t.sub(e),r=s.div(o);return i?H.mulDivRoundingUp(r,Me,ei):r.shrn(Ht)}static getLiquidityFromTokenAmountB(e,t,n){return e.gt(t)&&([e,t]=[t,e]),H.mulDivFloor(n,ei,t.sub(e))}static getLiquidityFromTokenAmounts(e,t,n,i,s){if(t.gt(n)&&([t,n]=[n,t]),e.lte(t))return ee.getLiquidityFromTokenAmountA(t,n,i,!1);if(e.lt(n)){let o=ee.getLiquidityFromTokenAmountA(e,n,i,!1),r=ee.getLiquidityFromTokenAmountB(t,e,s);return o.lt(r)?o:r}else return ee.getLiquidityFromTokenAmountB(t,n,s)}static getAmountsFromLiquidity(e,t,n,i,s){if(t.gt(n)&&([t,n]=[n,t]),e.lte(t))return{amountA:ee.getTokenAmountAFromLiquidity(t,n,i,s),amountB:new Y(0)};if(e.lt(n)){let o=ee.getTokenAmountAFromLiquidity(e,n,i,s),r=ee.getTokenAmountBFromLiquidity(t,e,i,s);return{amountA:o,amountB:r}}else return{amountA:new Y(0),amountB:ee.getTokenAmountBFromLiquidity(t,n,i,s)}}static getAmountsFromLiquidityWithSlippage(e,t,n,i,s,o,r){let{amountA:u,amountB:a}=ee.getAmountsFromLiquidity(e,t,n,i,o),c=s?1+r:1-r,p=new Y(new je(u.toString()).mul(c).toFixed(0)),l=new Y(new je(a.toString()).mul(c).toFixed(0));return{amountSlippageA:p,amountSlippageB:l}}static getAmountsOutFromLiquidity({poolInfo:e,tickLower:t,tickUpper:n,liquidity:i,slippage:s,add:o,epochInfo:r,amountAddFee:u}){var w,B,T,A;let a=z.priceToSqrtPriceX64(new je(e.price),e.mintA.decimals,e.mintB.decimals),c=z.getSqrtPriceX64FromTick(t),p=z.getSqrtPriceX64FromTick(n),l=o?1+s:1-s,d=ee.getAmountsFromLiquidity(a,c,p,i,o),[y,b]=[be(d.amountA,(w=e.mintA.extensions)==null?void 0:w.feeConfig,r,u),be(d.amountB,(B=e.mintB.extensions)==null?void 0:B.feeConfig,r,u)],[f,g]=[be(new Y(new je(d.amountA.toString()).mul(l).toFixed(0)),(T=e.mintA.extensions)==null?void 0:T.feeConfig,r,u),be(new Y(new je(d.amountB.toString()).mul(l).toFixed(0)),(A=e.mintB.extensions)==null?void 0:A.feeConfig,r,u)];return{liquidity:i,amountA:y,amountB:b,amountSlippageA:f,amountSlippageB:g,expirationTime:De(y.expirationTime,b.expirationTime)}}},Tt=class{static swapCompute(e,t,n,i,s,o,r,u,a,c,p,l,d,y,b=!1){if(l.eq(me))throw new Error("amountSpecified must not be 0");if(y||(y=o?He.add(Me):Ye.sub(Me)),o){if(y.lt(He))throw new Error("sqrtPriceX64 must greater than MIN_SQRT_PRICE_X64");if(y.gte(p))throw new Error("sqrtPriceX64 must smaller than current")}else{if(y.gt(Ye))throw new Error("sqrtPriceX64 must smaller than MAX_SQRT_PRICE_X64");if(y.lte(p))throw new Error("sqrtPriceX64 must greater than current")}let f=l.gt(me),g={amountSpecifiedRemaining:l,amountCalculated:me,sqrtPriceX64:p,tick:a>d?Math.min(d+J.tickCount(c)-1,a):d,accounts:[],liquidity:u,feeAmount:new Y(0)},w=d,B=n[d],T=0,A=!o&&B.startTickIndex===g.tick;for(;!g.amountSpecifiedRemaining.eq(me)&&!g.sqrtPriceX64.eq(y);){T>10;let k={};k.sqrtPriceStartX64=g.sqrtPriceX64;let I=W.nextInitTick(B,g.tick,c,o,A),x=I||null,R=null;if(!(x!=null&&x.liquidityGross.gtn(0))){let L=pe.nextInitializedTickArrayStartIndex({tickCurrent:g.tick,tickSpacing:c,tickArrayBitmap:i,exBitmapInfo:s},w,o);if(!L.isExist){if(b)return{allTrade:!1,amountSpecifiedRemaining:g.amountSpecifiedRemaining,amountCalculated:g.amountCalculated,feeAmount:g.feeAmount,sqrtPriceX64:g.sqrtPriceX64,liquidity:g.liquidity,tickCurrent:g.tick,accounts:g.accounts};throw Error("swapCompute LiquidityInsufficient")}w=L.nextStartIndex;let{publicKey:_}=ne(e,t,w);R=_,B=n[w];try{x=W.firstInitializedTick(B,o)}catch{throw Error("not found next tick info")}}k.tickNext=x.tick,k.initialized=x.liquidityGross.gtn(0),d!==w&&R&&(g.accounts.push(R),d=w),k.tickNext<Ie?k.tickNext=Ie:k.tickNext>Ke&&(k.tickNext=Ke),k.sqrtPriceNextX64=z.getSqrtPriceX64FromTick(k.tickNext);let h;if(o&&k.sqrtPriceNextX64.lt(y)||!o&&k.sqrtPriceNextX64.gt(y)?h=y:h=k.sqrtPriceNextX64,[g.sqrtPriceX64,k.amountIn,k.amountOut,k.feeAmount]=Tt.swapStepCompute(g.sqrtPriceX64,h,g.liquidity,g.amountSpecifiedRemaining,r,o),g.feeAmount=g.feeAmount.add(k.feeAmount),f?(g.amountSpecifiedRemaining=g.amountSpecifiedRemaining.sub(k.amountIn.add(k.feeAmount)),g.amountCalculated=g.amountCalculated.sub(k.amountOut)):(g.amountSpecifiedRemaining=g.amountSpecifiedRemaining.add(k.amountOut),g.amountCalculated=g.amountCalculated.add(k.amountIn.add(k.feeAmount))),g.sqrtPriceX64.eq(k.sqrtPriceNextX64)){if(k.initialized){let L=x.liquidityNet;o&&(L=L.mul(it)),g.liquidity=ee.addDelta(g.liquidity,L)}A=k.tickNext!=g.tick&&!o&&B.startTickIndex===k.tickNext,g.tick=o?k.tickNext-1:k.tickNext}else if(g.sqrtPriceX64!=k.sqrtPriceStartX64){let L=z.getTickFromSqrtPriceX64(g.sqrtPriceX64);A=L!=g.tick&&!o&&B.startTickIndex===L,g.tick=L}++T}try{let{nextStartIndex:k,isExist:I}=J.nextInitializedTickArray(g.tick,c,o,i,s);I&&d!==k&&(g.accounts.push(ne(e,t,k).publicKey),d=k)}catch{}return{allTrade:!0,amountSpecifiedRemaining:me,amountCalculated:g.amountCalculated,feeAmount:g.feeAmount,sqrtPriceX64:g.sqrtPriceX64,liquidity:g.liquidity,tickCurrent:g.tick,accounts:g.accounts}}static swapStepCompute(e,t,n,i,s,o){let r={sqrtPriceX64Next:new Y(0),amountIn:new Y(0),amountOut:new Y(0),feeAmount:new Y(0)},u=i.gte(me);if(u){let c=H.mulDivFloor(i,gn.sub(new Y(s.toString())),gn);r.amountIn=o?ee.getTokenAmountAFromLiquidity(t,e,n,!0):ee.getTokenAmountBFromLiquidity(e,t,n,!0),c.gte(r.amountIn)?r.sqrtPriceX64Next=t:r.sqrtPriceX64Next=z.getNextSqrtPriceX64FromInput(e,n,c,o)}else r.amountOut=o?ee.getTokenAmountBFromLiquidity(t,e,n,!1):ee.getTokenAmountAFromLiquidity(e,t,n,!1),i.mul(it).gte(r.amountOut)?r.sqrtPriceX64Next=t:r.sqrtPriceX64Next=z.getNextSqrtPriceX64FromOutput(e,n,i.mul(it),o);let a=t.eq(r.sqrtPriceX64Next);return o?(a&&u||(r.amountIn=ee.getTokenAmountAFromLiquidity(r.sqrtPriceX64Next,e,n,!0)),a&&!u||(r.amountOut=ee.getTokenAmountBFromLiquidity(r.sqrtPriceX64Next,e,n,!1))):(r.amountIn=a&&u?r.amountIn:ee.getTokenAmountBFromLiquidity(e,r.sqrtPriceX64Next,n,!0),r.amountOut=a&&!u?r.amountOut:ee.getTokenAmountAFromLiquidity(e,r.sqrtPriceX64Next,n,!1)),!u&&r.amountOut.gt(i.mul(it))&&(r.amountOut=i.mul(it)),u&&!r.sqrtPriceX64Next.eq(t)?r.feeAmount=i.sub(r.amountIn):r.feeAmount=H.mulDivCeil(r.amountIn,new Y(s),gn.sub(new Y(s))),[r.sqrtPriceX64Next,r.amountIn,r.amountOut,r.feeAmount]}};var we=60,wt=512,W=class{static getTickArrayAddressByTick(e,t,n,i){let s=W.getTickArrayStartIndexByTick(n,i),{publicKey:o}=ne(e,t,s);return o}static getTickOffsetInArray(e,t){if(e%t!=0)throw new Error("tickIndex % tickSpacing not equal 0");let n=W.getTickArrayStartIndexByTick(e,t),i=Math.floor((e-n)/t);if(i<0||i>=we)throw new Error("tick offset in array overflow");return i}static getTickArrayBitIndex(e,t){let n=J.tickCount(t),i=e/n;return e<0&&e%n!=0?i=Math.ceil(i)-1:i=Math.floor(i),i}static getTickArrayStartIndexByTick(e,t){return this.getTickArrayBitIndex(e,t)*J.tickCount(t)}static getTickArrayOffsetInBitmapByTick(e,t){let n=t*we,i=Math.floor(e/n)+512;return Math.abs(i)}static checkTickArrayIsInitialized(e,t,n){let i=n*we,s=Math.floor(t/i)+512,o=Math.abs(s);return{isInitialized:e.testn(o),startIndex:(o-512)*i}}static getNextTickArrayStartIndex(e,t,n){return n?e-t*we:e+t*we}static mergeTickArrayBitmap(e){let t=new Yo(0);for(let n=0;n<e.length;n++)t=t.add(e[n].shln(64*n));return t}static getInitializedTickArrayInRange(e,t,n,i,s){let o=Math.floor(i/(n*we));return[...W.searchLowBitFromStart(e,t,o-1,s,n),...W.searchHightBitFromStart(e,t,o,s,n)]}static getAllInitializedTickArrayStartIndex(e,t,n){return W.searchHightBitFromStart(e,t,-7680,wt,n)}static getAllInitializedTickArrayInfo(e,t,n,i,s){let o=[],r=W.getAllInitializedTickArrayStartIndex(n,i,s);for(let u of r){let{publicKey:a}=ne(e,t,u);o.push({tickArrayStartIndex:u,tickArrayAddress:a})}return o}static getAllInitializedTickInTickArray(e){return e.ticks.filter(t=>t.liquidityGross.gtn(0))}static searchLowBitFromStart(e,t,n,i,s){let o=[...[...t.negativeTickArrayBitmap].reverse(),e.slice(0,8),e.slice(8,16),...t.positiveTickArrayBitmap].map(a=>W.mergeTickArrayBitmap(a)),r=[];for(;n>=-7680;){let a=Math.floor((n+7680)/512),c=(n+7680)%512;if(o[a].testn(c)&&r.push(n),n--,r.length===i)break}let u=J.tickCount(s);return r.map(a=>a*u)}static searchHightBitFromStart(e,t,n,i,s){let o=[...[...t.negativeTickArrayBitmap].reverse(),e.slice(0,8),e.slice(8,16),...t.positiveTickArrayBitmap].map(a=>W.mergeTickArrayBitmap(a)),r=[];for(;n<7680;){let a=Math.floor((n+7680)/512),c=(n+7680)%512;if(o[a].testn(c)&&r.push(n),n++,r.length===i)break}let u=J.tickCount(s);return r.map(a=>a*u)}static checkIsOutOfBoundary(e){return e<Ie||e>Ke}static nextInitTick(e,t,n,i,s){if(J.getArrayStartIndex(t,n)!=e.startTickIndex)return null;let r=Math.floor((t-e.startTickIndex)/n);if(i)for(;r>=0;){if(e.ticks[r].liquidityGross.gtn(0))return e.ticks[r];r=r-1}else for(s||(r=r+1);r<we;){if(e.ticks[r].liquidityGross.gtn(0))return e.ticks[r];r=r+1}return null}static firstInitializedTick(e,t){if(t){let n=we-1;for(;n>=0;){if(e.ticks[n].liquidityGross.gtn(0))return e.ticks[n];n=n-1}}else{let n=0;for(;n<we;){if(e.ticks[n].liquidityGross.gtn(0))return e.ticks[n];n=n+1}}throw Error(`firstInitializedTick check error: ${e} - ${t}`)}static _getTickPriceLegacy({poolInfo:e,tick:t,baseIn:n}){let i=z.getSqrtPriceX64FromTick(t),s=z.sqrtPriceX64ToPrice(i,e.mintA.decimals,e.mintB.decimals);return n?{tick:t,price:s,tickSqrtPriceX64:i}:{tick:t,price:new Ot(1).div(s),tickSqrtPriceX64:i}}static _getPriceAndTickLegacy({poolInfo:e,price:t,baseIn:n}){let i=n?t:new Ot(1).div(t),s=ht.getTickWithPriceAndTickspacing(i,e.ammConfig.tickSpacing,e.mintA.decimals,e.mintB.decimals),o=z.getSqrtPriceX64FromTick(s),r=z.sqrtPriceX64ToPrice(o,e.mintA.decimals,e.mintB.decimals);return n?{tick:s,price:r}:{tick:s,price:new Ot(1).div(r)}}static getTickPrice({poolInfo:e,tick:t,baseIn:n}){let i=z.getSqrtPriceX64FromTick(t),s=z.sqrtPriceX64ToPrice(i,e.mintA.decimals,e.mintB.decimals);return n?{tick:t,price:s,tickSqrtPriceX64:i}:{tick:t,price:new Ot(1).div(s),tickSqrtPriceX64:i}}static getPriceAndTick({poolInfo:e,price:t,baseIn:n}){let i=n?t:new Ot(1).div(t),s=ht.getTickWithPriceAndTickspacing(i,e.config.tickSpacing,e.mintA.decimals,e.mintB.decimals),o=z.getSqrtPriceX64FromTick(s),r=z.sqrtPriceX64ToPrice(o,e.mintA.decimals,e.mintB.decimals);return n?{tick:s,price:r}:{tick:s,price:new Ot(1).div(r)}}};var Qo=E([ge(8),G("bump"),kt("index"),C(""),Ne("protocolFeeRate"),Ne("tradeFeeRate"),kt("tickSpacing"),Z(P(),8,"")]),jo=E([Ne("blockTimestamp"),Hi("tickCumulative"),Z(P(),4)]),lr=E([ge(8),Ae("initialized"),P("recentEpoch"),kt("observationIndex"),C("poolId"),Z(jo,100,"observations"),Z(P(),4)]),Zo=E([G("rewardState"),P("openTime"),P("endTime"),P("lastUpdateTime"),U("emissionsPerSecondX64"),P("rewardTotalEmissioned"),P("rewardClaimed"),C("tokenMint"),C("tokenVault"),C("creator"),U("rewardGrowthGlobalX64")]),Mt=E([ge(8),G("bump"),C("ammConfig"),C("creator"),C("mintA"),C("mintB"),C("vaultA"),C("vaultB"),C("observationId"),G("mintDecimalsA"),G("mintDecimalsB"),kt("tickSpacing"),U("liquidity"),U("sqrtPriceX64"),ue("tickCurrent"),Ne(),U("feeGrowthGlobalX64A"),U("feeGrowthGlobalX64B"),P("protocolFeesTokenA"),P("protocolFeesTokenB"),U("swapInAmountTokenA"),U("swapOutAmountTokenB"),U("swapInAmountTokenB"),U("swapOutAmountTokenA"),G("status"),Z(G(),7,""),Z(Zo,3,"rewardInfos"),Z(P(),16,"tickArrayBitmap"),P("totalFeesTokenA"),P("totalFeesClaimedTokenA"),P("totalFeesTokenB"),P("totalFeesClaimedTokenB"),P("fundFeesTokenA"),P("fundFeesTokenB"),P("startTime"),Z(P(),15*4-3,"padding")]),Jo=E([U("growthInsideLastX64"),P("rewardAmountOwed")]),ui=E([ge(8),G("bump"),C("nftMint"),C("poolId"),ue("tickLower"),ue("tickUpper"),U("liquidity"),U("feeGrowthInsideLastX64A"),U("feeGrowthInsideLastX64B"),P("tokenFeesOwedA"),P("tokenFeesOwedB"),Z(Jo,3,"rewardInfos"),Z(P(),8,"")]),Xp=E([ge(8),G("bump"),C("poolId"),ue("tickLowerIndex"),ue("tickUpperIndex"),U("liquidity"),U("feeGrowthInsideLastX64A"),U("feeGrowthInsideLastX64B"),P("tokenFeesOwedA"),P("tokenFeesOwedB"),Z(U(),3,"rewardGrowthInside"),Z(P(),8,"")]),$o=E([ue("tick"),Yi("liquidityNet"),U("liquidityGross"),U("feeGrowthOutsideX64A"),U("feeGrowthOutsideX64B"),Z(U(),3,"rewardGrowthsOutsideX64"),Z(Ne(),13,"")]),jt=E([ge(8),C("poolId"),ue("startTickIndex"),Z($o,we,"ticks"),G("initializedTickCount"),Z(G(),115,"")]),es=E([ge(329),Z(C(),100,"whitelistMints")]),cr=E([ge(8),C("poolId"),Z(Z(P(),8),ai,"positiveTickArrayBitmap"),Z(Z(P(),8),ai,"negativeTickArrayBitmap")]),zp=E([P(),G("bump"),C("owner"),C("poolId"),C("positionId"),C("nftAccount"),Z(P(),8)]),ts=E([ge(8),G("bump"),C("lockOwner"),C("poolId"),C("positionId"),C("nftAccount"),C("lockNftMint"),P("recentEpoch"),Z(P(),8)]);lr.span;var mr=re("Raydium_Clmm"),Ee={createPool:[233,146,209,142,207,104,64,188],initReward:[95,135,192,196,242,129,230,68],setRewardEmissions:[112,52,167,75,32,201,211,137],openPosition:[77,184,74,214,112,86,241,199],openPositionWithTokenEx:[77,255,174,82,125,29,201,46],closePosition:[123,134,81,0,49,68,98,98],increaseLiquidity:[133,29,89,223,69,238,176,10],decreaseLiquidity:[58,127,188,62,79,82,196,96],swap:[43,4,237,11,26,201,30,98],collectReward:[18,237,166,197,34,16,213,144]},pr=[188,37,179,131,82,150,84,73],dr=[16,72,250,198,14,162,212,19],xt=class{static createPoolInstruction(e,t,n,i,s,o,r,u,a,c,p,l,d,y){let b=E([U("sqrtPriceX64"),P("zero")]),f=[{pubkey:n,isSigner:!0,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:a,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!1},{pubkey:p,isSigner:!1,isWritable:!1},{pubkey:st.programId,isSigner:!1,isWritable:!1},{pubkey:Xe,isSigner:!1,isWritable:!1},...(y==null?void 0:y.map(B=>({pubkey:B,isSigner:!1,isWritable:!1})))||[]],g=Buffer.alloc(b.span);b.encode({sqrtPriceX64:d,zero:me},g);let w=Buffer.from([...Ee.createPool,...g]);return new Be({keys:f,programId:e,data:w})}static async createPoolInstructions(e){let{programId:t,owner:n,mintA:i,mintB:s,ammConfigId:o,initialPriceX64:r,extendMintAccount:u}=e,[a,c]=[new K(i.address),new K(s.address)],{publicKey:p}=rr(t,o,a,c),{publicKey:l}=sr(t,p),{publicKey:d}=ii(t,p,a),{publicKey:y}=ii(t,p,c),b=ke(t,p).publicKey,f=[this.createPoolInstruction(t,p,n,o,l,a,d,new K(i.programId||ie),c,y,new K(s.programId||ie),b,r,u)];return{signers:[],instructions:f,instructionTypes:[j.CreateAccount,j.ClmmCreatePool],address:{poolId:p,observationId:l,exBitmapAccount:b,mintAVault:d,mintBVault:y},lookupTableAddress:[]}}static openPositionFromLiquidityInstruction(e,t,n,i,s,o,r,u,a,c,p,l,d,y,b,f,g,w,B,T,A,k,I,x,R,h){let L=E([ue("tickLowerIndex"),ue("tickUpperIndex"),ue("tickArrayLowerStartIndex"),ue("tickArrayUpperStartIndex"),U("liquidity"),P("amountMaxA"),P("amountMaxB"),Ae("withMetadata"),G("optionBaseFlag"),Ae("baseFlag")]),_=[...h?[{pubkey:h,isSigner:!1,isWritable:!0}]:[]],O=[{pubkey:t,isSigner:!0,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!1},{pubkey:s,isSigner:!0,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:p,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:d,isSigner:!1,isWritable:!0},{pubkey:y,isSigner:!1,isWritable:!0},{pubkey:b,isSigner:!1,isWritable:!0},{pubkey:Xe,isSigner:!1,isWritable:!1},{pubkey:st.programId,isSigner:!1,isWritable:!1},{pubkey:ie,isSigner:!1,isWritable:!1},{pubkey:Jt,isSigner:!1,isWritable:!1},{pubkey:lt,isSigner:!1,isWritable:!1},{pubkey:de,isSigner:!1,isWritable:!1},{pubkey:f,isSigner:!1,isWritable:!1},{pubkey:g,isSigner:!1,isWritable:!1},..._],V=Buffer.alloc(L.span);L.encode({tickLowerIndex:w,tickUpperIndex:B,tickArrayLowerStartIndex:T,tickArrayUpperStartIndex:A,liquidity:k,amountMaxA:I,amountMaxB:x,withMetadata:R==="create",baseFlag:!1,optionBaseFlag:0},V);let Q=Buffer.from([...Ee.openPosition,...V]);return new Be({keys:O,programId:e,data:Q})}static openPositionFromLiquidityInstruction22(e,t,n,i,s,o,r,u,a,c,p,l,d,y,b,f,g,w,B,T,A,k,I,x,R){let h=E([ue("tickLowerIndex"),ue("tickUpperIndex"),ue("tickArrayLowerStartIndex"),ue("tickArrayUpperStartIndex"),U("liquidity"),P("amountMaxA"),P("amountMaxB"),Ae("withMetadata"),G("optionBaseFlag"),Ae("baseFlag")]),L=[...R?[{pubkey:R,isSigner:!1,isWritable:!0}]:[]],_=[{pubkey:t,isSigner:!0,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!1},{pubkey:s,isSigner:!0,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:p,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:d,isSigner:!1,isWritable:!0},{pubkey:y,isSigner:!1,isWritable:!0},{pubkey:Xe,isSigner:!1,isWritable:!1},{pubkey:st.programId,isSigner:!1,isWritable:!1},{pubkey:ie,isSigner:!1,isWritable:!1},{pubkey:Jt,isSigner:!1,isWritable:!1},{pubkey:de,isSigner:!1,isWritable:!1},{pubkey:b,isSigner:!1,isWritable:!1},{pubkey:f,isSigner:!1,isWritable:!1},...L],O=Buffer.alloc(h.span);h.encode({tickLowerIndex:g,tickUpperIndex:w,tickArrayLowerStartIndex:B,tickArrayUpperStartIndex:T,liquidity:A,amountMaxA:k,amountMaxB:I,withMetadata:x==="create",baseFlag:!1,optionBaseFlag:0},O);let V=Buffer.from([...Ee.openPositionWithTokenEx,...O]);return new Be({keys:_,programId:e,data:V})}static async openPositionInstructions({poolInfo:e,poolKeys:t,ownerInfo:n,tickLower:i,tickUpper:s,liquidity:o,amountMaxA:r,amountMaxB:u,withMetadata:a,getEphemeralSigners:c,nft2022:p}){let l=[],[d,y]=[new K(e.programId),new K(e.id)],b;if(c)b=new K((await c(1))[0]);else{let R=An.generate();l.push(R),b=R.publicKey}let f=W.getTickArrayStartIndexByTick(i,e.config.tickSpacing),g=W.getTickArrayStartIndexByTick(s,e.config.tickSpacing),{publicKey:w}=ne(d,y,f),{publicKey:B}=ne(d,y,g),{publicKey:T}=p?ae(n.wallet,b,de):ae(n.wallet,b,ie),{publicKey:A}=Nt(b),{publicKey:k}=Le(d,b),{publicKey:I}=rt(d,y,i,s),x=p?this.openPositionFromLiquidityInstruction22(d,n.feePayer,y,n.wallet,b,T,I,w,B,k,n.tokenAccountA,n.tokenAccountB,new K(t.vault.A),new K(t.vault.B),new K(e.mintA.address),new K(e.mintB.address),i,s,f,g,o,r,u,a,pe.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing,[f,g])?ke(d,y).publicKey:void 0):this.openPositionFromLiquidityInstruction(d,n.feePayer,y,n.wallet,b,T,A,I,w,B,k,n.tokenAccountA,n.tokenAccountB,new K(t.vault.A),new K(t.vault.B),new K(e.mintA.address),new K(e.mintB.address),i,s,f,g,o,r,u,a,pe.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing,[f,g])?ke(d,y).publicKey:void 0);return{signers:l,instructions:[x],instructionTypes:[j.ClmmOpenPosition],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[],address:{nftMint:b,tickArrayLower:w,tickArrayUpper:B,positionNftAccount:T,metadataAccount:A,personalPosition:k,protocolPosition:I}}}static async openPositionFromBaseInstructions({poolInfo:e,poolKeys:t,ownerInfo:n,tickLower:i,tickUpper:s,base:o,baseAmount:r,otherAmountMax:u,withMetadata:a,getEphemeralSigners:c,nft2022:p}){let l=[],[d,y]=[new K(e.programId),new K(e.id)],b;if(c)b=new K((await c(1))[0]);else{let R=An.generate();l.push(R),b=R.publicKey}let f=W.getTickArrayStartIndexByTick(i,e.config.tickSpacing),g=W.getTickArrayStartIndexByTick(s,e.config.tickSpacing),{publicKey:w}=ne(d,y,f),{publicKey:B}=ne(d,y,g),{publicKey:T}=p?ae(n.wallet,b,de):ae(n.wallet,b,ie),{publicKey:A}=Nt(b),{publicKey:k}=Le(d,b),{publicKey:I}=rt(d,y,i,s),x=p?this.openPositionFromBaseInstruction22(d,n.feePayer,y,n.wallet,b,T,I,w,B,k,n.tokenAccountA,n.tokenAccountB,new K(t.vault.A),new K(t.vault.B),new K(e.mintA.address),new K(e.mintB.address),i,s,f,g,a,o,r,u,pe.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing,[f,g])?ke(d,y).publicKey:void 0):this.openPositionFromBaseInstruction(d,n.feePayer,y,n.wallet,b,T,A,I,w,B,k,n.tokenAccountA,n.tokenAccountB,new K(t.vault.A),new K(t.vault.B),new K(e.mintA.address),new K(e.mintB.address),i,s,f,g,a,o,r,u,pe.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing,[f,g])?ke(d,y).publicKey:void 0);return{address:{nftMint:b,tickArrayLower:w,tickArrayUpper:B,positionNftAccount:T,metadataAccount:A,personalPosition:k,protocolPosition:I},instructions:[x],signers:l,instructionTypes:[j.ClmmOpenPosition],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[]}}static openPositionFromBaseInstruction(e,t,n,i,s,o,r,u,a,c,p,l,d,y,b,f,g,w,B,T,A,k,I,x,R,h){let L=E([ue("tickLowerIndex"),ue("tickUpperIndex"),ue("tickArrayLowerStartIndex"),ue("tickArrayUpperStartIndex"),U("liquidity"),P("amountMaxA"),P("amountMaxB"),Ae("withMetadata"),G("optionBaseFlag"),Ae("baseFlag")]),_=[...h?[{pubkey:h,isSigner:!1,isWritable:!0}]:[]],O=[{pubkey:t,isSigner:!0,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!1},{pubkey:s,isSigner:!0,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:p,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:d,isSigner:!1,isWritable:!0},{pubkey:y,isSigner:!1,isWritable:!0},{pubkey:b,isSigner:!1,isWritable:!0},{pubkey:Xe,isSigner:!1,isWritable:!1},{pubkey:st.programId,isSigner:!1,isWritable:!1},{pubkey:ie,isSigner:!1,isWritable:!1},{pubkey:Jt,isSigner:!1,isWritable:!1},{pubkey:lt,isSigner:!1,isWritable:!1},{pubkey:de,isSigner:!1,isWritable:!1},{pubkey:f,isSigner:!1,isWritable:!1},{pubkey:g,isSigner:!1,isWritable:!1},..._],V=Buffer.alloc(L.span);L.encode({tickLowerIndex:w,tickUpperIndex:B,tickArrayLowerStartIndex:T,tickArrayUpperStartIndex:A,liquidity:new li(0),amountMaxA:I==="MintA"?x:R,amountMaxB:I==="MintA"?R:x,withMetadata:k==="create",baseFlag:I==="MintA",optionBaseFlag:1},V);let Q=Buffer.from([...Ee.openPosition,...V]);return new Be({keys:O,programId:e,data:Q})}static openPositionFromBaseInstruction22(e,t,n,i,s,o,r,u,a,c,p,l,d,y,b,f,g,w,B,T,A,k,I,x,R){let h=E([ue("tickLowerIndex"),ue("tickUpperIndex"),ue("tickArrayLowerStartIndex"),ue("tickArrayUpperStartIndex"),U("liquidity"),P("amountMaxA"),P("amountMaxB"),Ae("withMetadata"),G("optionBaseFlag"),Ae("baseFlag")]),L=[...R?[{pubkey:R,isSigner:!1,isWritable:!0}]:[]],_=[{pubkey:t,isSigner:!0,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!1},{pubkey:s,isSigner:!0,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:p,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:d,isSigner:!1,isWritable:!0},{pubkey:y,isSigner:!1,isWritable:!0},{pubkey:Xe,isSigner:!1,isWritable:!1},{pubkey:st.programId,isSigner:!1,isWritable:!1},{pubkey:ie,isSigner:!1,isWritable:!1},{pubkey:Jt,isSigner:!1,isWritable:!1},{pubkey:de,isSigner:!1,isWritable:!1},{pubkey:b,isSigner:!1,isWritable:!1},{pubkey:f,isSigner:!1,isWritable:!1},...L],O=Buffer.alloc(h.span);h.encode({tickLowerIndex:g,tickUpperIndex:w,tickArrayLowerStartIndex:B,tickArrayUpperStartIndex:T,liquidity:new li(0),amountMaxA:k==="MintA"?I:x,amountMaxB:k==="MintA"?x:I,withMetadata:A==="create",baseFlag:k==="MintA",optionBaseFlag:1},O);let V=Buffer.from([...Ee.openPositionWithTokenEx,...O]);return new Be({keys:_,programId:e,data:V})}static async openPositionFromLiquidityInstructions({poolInfo:e,poolKeys:t,ownerInfo:n,tickLower:i,tickUpper:s,liquidity:o,amountMaxA:r,amountMaxB:u,withMetadata:a,getEphemeralSigners:c,nft2022:p}){let l,d=[];if(c)l=new K((await c(1))[0]);else{let R=An.generate();d.push(R),l=R.publicKey}let[y,b]=[new K(e.programId),new K(e.id)],f=W.getTickArrayStartIndexByTick(i,e.config.tickSpacing),g=W.getTickArrayStartIndexByTick(s,e.config.tickSpacing),{publicKey:w}=ne(y,b,f),{publicKey:B}=ne(y,b,g),{publicKey:T}=p?ae(n.wallet,l,de):ae(n.wallet,l,ie),{publicKey:A}=Nt(l),{publicKey:k}=Le(y,l),{publicKey:I}=rt(y,b,i,s),x=p?this.openPositionFromLiquidityInstruction22(y,n.wallet,b,n.wallet,l,T,I,w,B,k,n.tokenAccountA,n.tokenAccountB,new K(t.vault.A),new K(t.vault.B),new K(t.mintA.address),new K(t.mintB.address),i,s,f,g,o,r,u,a,pe.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing,[f,g])?ke(y,b).publicKey:void 0):this.openPositionFromLiquidityInstruction(y,n.wallet,b,n.wallet,l,T,A,I,w,B,k,n.tokenAccountA,n.tokenAccountB,new K(t.vault.A),new K(t.vault.B),new K(t.mintA.address),new K(t.mintB.address),i,s,f,g,o,r,u,a,pe.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing,[f,g])?ke(y,b).publicKey:void 0);return{address:{nftMint:l,tickArrayLower:w,tickArrayUpper:B,positionNftAccount:T,metadataAccount:A,personalPosition:k,protocolPosition:I},instructions:[x],signers:d,instructionTypes:[j.ClmmOpenPosition],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[]}}static closePositionInstruction(e,t,n,i,s,o){let r=E([]),u=[{pubkey:t,isSigner:!0,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:st.programId,isSigner:!1,isWritable:!1},{pubkey:o?de:ie,isSigner:!1,isWritable:!1}],a=Buffer.alloc(r.span);r.encode({},a);let c=Buffer.from([...Ee.closePosition,...a]);return new Be({keys:u,programId:e,data:c})}static closePositionInstructions({poolInfo:e,poolKeys:t,ownerInfo:n,ownerPosition:i,nft2022:s}){let o=new K(e.programId),r=s?ae(n.wallet,i.nftMint,de).publicKey:ae(n.wallet,i.nftMint,ie).publicKey,{publicKey:u}=Le(o,i.nftMint),a=[];return a.push(this.closePositionInstruction(o,n.wallet,i.nftMint,r,u,s)),{address:{positionNftAccount:r,personalPosition:u},signers:[],instructions:a,instructionTypes:[j.ClmmClosePosition],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[]}}static increasePositionFromLiquidityInstruction(e,t,n,i,s,o,r,u,a,c,p,l,d,y,b,f,g,w){let B=E([U("liquidity"),P("amountMaxA"),P("amountMaxB"),G("optionBaseFlag"),Ae("baseFlag")]),T=[...w?[{pubkey:w,isSigner:!1,isWritable:!0}]:[]],A=[{pubkey:t,isSigner:!0,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:p,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:ie,isSigner:!1,isWritable:!1},{pubkey:de,isSigner:!1,isWritable:!1},{pubkey:d,isSigner:!1,isWritable:!1},{pubkey:y,isSigner:!1,isWritable:!1},...T],k=Buffer.alloc(B.span);B.encode({liquidity:b,amountMaxA:f,amountMaxB:g,optionBaseFlag:0,baseFlag:!1},k);let I=Buffer.from([...Ee.increaseLiquidity,...k]);return new Be({keys:A,programId:e,data:I})}static increasePositionFromLiquidityInstructions({poolInfo:e,poolKeys:t,ownerPosition:n,ownerInfo:i,liquidity:s,amountMaxA:o,amountMaxB:r,nft2022:u}){let[a,c]=[new K(e.programId),new K(e.id)],p=W.getTickArrayStartIndexByTick(n.tickLower,e.config.tickSpacing),l=W.getTickArrayStartIndexByTick(n.tickUpper,e.config.tickSpacing),{publicKey:d}=ne(a,c,p),{publicKey:y}=ne(a,c,l),{publicKey:b}=u?ae(i.wallet,n.nftMint,de):ae(i.wallet,n.nftMint,ie),{publicKey:f}=Le(a,n.nftMint),{publicKey:g}=rt(a,c,n.tickLower,n.tickUpper),w=this.increasePositionFromLiquidityInstruction(a,i.wallet,b,f,c,g,d,y,i.tokenAccountA,i.tokenAccountB,new K(t.vault.A),new K(t.vault.B),new K(e.mintA.address),new K(e.mintB.address),s,o,r,pe.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing,[p,l])?ke(a,c).publicKey:void 0);return{address:{tickArrayLower:d,tickArrayUpper:y,positionNftAccount:b,personalPosition:f,protocolPosition:g},signers:[],instructions:[w],instructionTypes:[j.ClmmIncreasePosition],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[]}}static increasePositionFromBaseInstructions({poolInfo:e,poolKeys:t,ownerPosition:n,ownerInfo:i,base:s,baseAmount:o,otherAmountMax:r,nft2022:u}){let[a,c]=[new K(e.programId),new K(e.id)],p=W.getTickArrayStartIndexByTick(n.tickLower,e.config.tickSpacing),l=W.getTickArrayStartIndexByTick(n.tickUpper,e.config.tickSpacing),{publicKey:d}=ne(a,c,p),{publicKey:y}=ne(a,c,l),{publicKey:b}=u?ae(i.wallet,n.nftMint,de):ae(i.wallet,n.nftMint,ie),{publicKey:f}=Le(a,n.nftMint),{publicKey:g}=rt(a,c,n.tickLower,n.tickUpper);return{address:{tickArrayLower:d,tickArrayUpper:y,positionNftAccount:b,personalPosition:f,protocolPosition:g},instructions:[this.increasePositionFromBaseInstruction(a,i.wallet,b,f,c,g,d,y,i.tokenAccountA,i.tokenAccountB,new K(t.vault.A),new K(t.vault.B),new K(e.mintA.address),new K(e.mintB.address),s,o,r,pe.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing,[p,l])?ke(a,c).publicKey:void 0)],signers:[],instructionTypes:[j.ClmmIncreasePosition],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[]}}static increasePositionFromBaseInstruction(e,t,n,i,s,o,r,u,a,c,p,l,d,y,b,f,g,w){let B=E([U("liquidity"),P("amountMaxA"),P("amountMaxB"),G("optionBaseFlag"),Ae("baseFlag")]),T=[...w?[{pubkey:w,isSigner:!1,isWritable:!0}]:[]],A=[{pubkey:t,isSigner:!0,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:p,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:ie,isSigner:!1,isWritable:!1},{pubkey:de,isSigner:!1,isWritable:!1},{pubkey:d,isSigner:!1,isWritable:!1},{pubkey:y,isSigner:!1,isWritable:!1},...T],k=Buffer.alloc(B.span);B.encode({liquidity:new li(0),amountMaxA:b==="MintA"?f:g,amountMaxB:b==="MintA"?g:f,baseFlag:b==="MintA",optionBaseFlag:1},k);let I=Buffer.from([...Ee.increaseLiquidity,...k]);return new Be({keys:A,programId:e,data:I})}static decreaseLiquidityInstruction(e,t,n,i,s,o,r,u,a,c,p,l,d,y,b,f,g,w,B){let T=E([U("liquidity"),P("amountMinA"),P("amountMinB")]),A=[...B?[{pubkey:B,isSigner:!1,isWritable:!0}]:[],...b.map(R=>[{pubkey:R.poolRewardVault,isSigner:!1,isWritable:!0},{pubkey:R.ownerRewardVault,isSigner:!1,isWritable:!0},{pubkey:R.rewardMint,isSigner:!1,isWritable:!1}]).flat()],k=[{pubkey:t,isSigner:!0,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:p,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:ie,isSigner:!1,isWritable:!1},{pubkey:de,isSigner:!1,isWritable:!1},{pubkey:un,isSigner:!1,isWritable:!1},{pubkey:d,isSigner:!1,isWritable:!1},{pubkey:y,isSigner:!1,isWritable:!1},...A],I=Buffer.alloc(T.span);T.encode({liquidity:f,amountMinA:g,amountMinB:w},I);let x=Buffer.from([...Ee.decreaseLiquidity,...I]);return new Be({keys:k,programId:e,data:x})}static decreaseLiquidityInstructions({poolInfo:e,poolKeys:t,ownerPosition:n,ownerInfo:i,liquidity:s,amountMinA:o,amountMinB:r,programId:u,nft2022:a}){let[c,p]=[new K(e.programId),new K(e.id)],l=W.getTickArrayStartIndexByTick(n.tickLower,e.config.tickSpacing),d=W.getTickArrayStartIndexByTick(n.tickUpper,e.config.tickSpacing),{publicKey:y}=ne(c,p,l),{publicKey:b}=ne(c,p,d),{publicKey:f}=a?ae(i.wallet,n.nftMint,de):ae(i.wallet,n.nftMint,u),{publicKey:g}=Le(c,n.nftMint),{publicKey:w}=rt(c,p,n.tickLower,n.tickUpper),B=[];for(let k=0;k<e.rewardDefaultInfos.length;k++)B.push({poolRewardVault:new K(t.rewardInfos[k].vault),ownerRewardVault:i.rewardAccounts[k],rewardMint:new K(e.rewardDefaultInfos[k].mint.address)});let T=[],A=this.decreaseLiquidityInstruction(c,i.wallet,f,g,p,w,y,b,i.tokenAccountA,i.tokenAccountB,new K(t.vault.A),new K(t.vault.B),new K(e.mintA.address),new K(e.mintB.address),B,s,o,r,pe.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing,[l,d])?ke(c,p).publicKey:void 0);return T.push(A),{address:{tickArrayLower:y,tickArrayUpper:b,positionNftAccount:f,personalPosition:g,protocolPosition:w},signers:[],instructions:T,instructionTypes:[j.ClmmDecreasePosition],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[]}}static swapInstruction(e,t,n,i,s,o,r,u,a,c,p,l,d,y,b,f,g){let w=E([P("amount"),P("otherAmountThreshold"),U("sqrtPriceLimitX64"),Ae("isBaseInput")]),B=[...g?[{pubkey:g,isSigner:!1,isWritable:!0}]:[],...p.map(I=>({pubkey:I,isSigner:!1,isWritable:!0}))],T=[{pubkey:t,isSigner:!0,isWritable:!1},{pubkey:i,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:ie,isSigner:!1,isWritable:!1},{pubkey:de,isSigner:!1,isWritable:!1},{pubkey:un,isSigner:!1,isWritable:!1},{pubkey:a,isSigner:!1,isWritable:!1},{pubkey:c,isSigner:!1,isWritable:!1},...B],A=Buffer.alloc(w.span);w.encode({amount:d,otherAmountThreshold:y,sqrtPriceLimitX64:b,isBaseInput:f},A);let k=Buffer.from([...Ee.swap,...A]);return new Be({keys:T,programId:e,data:k})}static makeSwapBaseInInstructions({poolInfo:e,poolKeys:t,observationId:n,ownerInfo:i,inputMint:s,amountIn:o,amountOutMin:r,sqrtPriceLimitX64:u,remainingAccounts:a}){let[c,p]=[new K(e.programId),new K(e.id)],[l,d]=[new K(t.vault.A),new K(t.vault.B)],[y,b]=[new K(e.mintA.address),new K(e.mintB.address)],f=e.mintA.address===s.toString(),g=[this.swapInstruction(c,i.wallet,p,new K(e.config.id),f?i.tokenAccountA:i.tokenAccountB,f?i.tokenAccountB:i.tokenAccountA,f?l:d,f?d:l,f?y:b,f?b:y,a,n,o,r,u,!0,ke(c,p).publicKey)];return{signers:[],instructions:g,instructionTypes:[j.ClmmSwapBaseIn],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[],address:{}}}static makeSwapBaseOutInstructions({poolInfo:e,poolKeys:t,observationId:n,ownerInfo:i,outputMint:s,amountOut:o,amountInMax:r,sqrtPriceLimitX64:u,remainingAccounts:a}){let[c,p]=[new K(e.programId),new K(e.id)],[l,d]=[new K(t.vault.A),new K(t.vault.B)],[y,b]=[new K(e.mintA.address),new K(e.mintB.address)],f=e.mintA.address===s.toBase58(),g=[this.swapInstruction(c,i.wallet,p,new K(e.config.id),f?i.tokenAccountB:i.tokenAccountA,f?i.tokenAccountA:i.tokenAccountB,f?d:l,f?l:d,f?b:y,f?y:b,a,n,o,r,u,!1,ke(c,p).publicKey)];return{signers:[],instructions:g,instructionTypes:[j.ClmmSwapBaseOut],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[],address:{}}}static initRewardInstruction(e,t,n,i,s,o,r,u,a,c,p,l){let d=E([P("openTime"),P("endTime"),U("emissionsPerSecondX64")]),y=[{pubkey:t,isSigner:!0,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!1},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!1},{pubkey:st.programId,isSigner:!1,isWritable:!1},{pubkey:Xe,isSigner:!1,isWritable:!1}],b=Buffer.alloc(d.span);d.encode({openTime:oe(c),endTime:oe(p),emissionsPerSecondX64:l},b);let f=Buffer.from([...Ee.initReward,...b]);return new Be({keys:y,programId:e,data:f})}static initRewardInstructions({poolInfo:e,poolKeys:t,ownerInfo:n,rewardInfo:i}){let[s,o]=[new K(e.programId),new K(e.id)],r=or(s,o,i.mint).publicKey,u=kn(s).publicKey,a=[this.initRewardInstruction(s,n.wallet,o,u,new K(e.config.id),n.tokenAccount,i.programId,i.mint,r,i.openTime,i.endTime,i.emissionsPerSecondX64)];return{address:{poolRewardVault:r,operationId:u},signers:[],instructions:a,instructionTypes:[j.ClmmInitReward],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[]}}static setRewardInstruction(e,t,n,i,s,o,r,u,a,c,p,l){let d=E([G("rewardIndex"),U("emissionsPerSecondX64"),P("openTime"),P("endTime")]),y=[{pubkey:t,isSigner:!0,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:ie,isSigner:!1,isWritable:!1},{pubkey:de,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0}],b=Buffer.alloc(d.span);d.encode({rewardIndex:a,emissionsPerSecondX64:l,openTime:oe(c),endTime:oe(p)},b);let f=Buffer.from([...Ee.setRewardEmissions,...b]);return new Be({keys:y,programId:e,data:f})}static setRewardInstructions({poolInfo:e,poolKeys:t,ownerInfo:n,rewardInfo:i}){let[s,o]=[new K(e.programId),new K(e.id)],r,u,a;for(let l=0;l<e.rewardDefaultInfos.length;l++)e.rewardDefaultInfos[l].mint.address===i.mint.toString()&&(r=l,u=new K(t.rewardInfos[l].vault),a=new K(t.rewardInfos[l].mint.address));(r===void 0||u===void 0)&&mr.logWithError("reward mint check error","no reward mint",e.rewardDefaultInfos);let c=kn(s).publicKey,p=[this.setRewardInstruction(s,n.wallet,o,c,new K(e.config.id),n.tokenAccount,u,a,r,i.openTime,i.endTime,i.emissionsPerSecondX64)];return{address:{rewardVault:u,operationId:c},signers:[],instructions:p,instructionTypes:[j.ClmmSetReward],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[]}}static collectRewardInstruction(e,t,n,i,s,o,r){let u=E([G("rewardIndex")]),a=[{pubkey:t,isSigner:!0,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:ie,isSigner:!1,isWritable:!1},{pubkey:de,isSigner:!1,isWritable:!1},{pubkey:un,isSigner:!1,isWritable:!1}],c=Buffer.alloc(u.span);u.encode({rewardIndex:r},c);let p=Buffer.from([...Ee.collectReward,...c]);return new Be({keys:a,programId:e,data:p})}static collectRewardInstructions({poolInfo:e,poolKeys:t,ownerInfo:n,rewardMint:i}){let[s,o]=[new K(e.programId),new K(e.id)],r,u;for(let c=0;c<e.rewardDefaultInfos.length;c++)e.rewardDefaultInfos[c].mint.address===i.toString()&&(r=c,u=new K(t.rewardInfos[c].vault));(r===void 0||u===void 0)&&mr.logWithError("reward mint check error","no reward mint",e.rewardDefaultInfos);let a=[this.collectRewardInstruction(s,n.wallet,o,n.tokenAccount,u,i,r)];return{address:{rewardVault:u},signers:[],instructions:a,instructionTypes:[j.ClmmCollectReward],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[]}}static async makeLockPositions({programId:e,authProgramId:t,poolProgramId:n,payer:i,wallet:s,nftMint:o,nft2022:r,getEphemeralSigners:u}){let a=[],c;if(u)c=new K((await u(1))[0]);else{let g=An.generate();a.push(g),c=g.publicKey}let p=r?ae(s,o,de).publicKey:ae(s,o,ie).publicKey,{publicKey:l}=Le(n,o),d=oi(e,c).publicKey,y=ae(s,c,ie).publicKey,b=Nt(c).publicKey,f=xt.lockPositionInstructionV2({programId:e,auth:t,payer:i,positionOwner:s,lockOwner:s,positionNftAccount:p,positionId:l,lockPositionId:d,lockNftMint:c,lockNftAccount:y,metadataAccount:b,withMetadata:!0,nft2022:r,positionNftMint:o,authPositionNftAccount:ae(t,o,r?de:ie).publicKey,positionNftProgram:r?de:ie});return{address:{positionId:l,lockPositionId:d,lockNftAccount:y,lockNftMint:c,positionNftAccount:p,metadataAccount:b},instructions:[f],signers:a,instructionTypes:[j.ClmmLockPosition],lookupTableAddress:[]}}static lockPositionInstructionV2({programId:e,auth:t,payer:n,positionOwner:i,lockOwner:s,positionNftAccount:o,positionId:r,positionNftMint:u,authPositionNftAccount:a,positionNftProgram:c,lockPositionId:p,lockNftMint:l,lockNftAccount:d,metadataAccount:y,withMetadata:b}){let f=[{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!0,isWritable:!0},{pubkey:i,isSigner:!0,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!1},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:p,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!0,isWritable:!0},{pubkey:d,isSigner:!1,isWritable:!0},{pubkey:y,isSigner:!1,isWritable:!0},{pubkey:lt,isSigner:!1,isWritable:!1},{pubkey:Jt,isSigner:!1,isWritable:!1},{pubkey:Xe,isSigner:!1,isWritable:!1},{pubkey:ie,isSigner:!1,isWritable:!1},{pubkey:c,isSigner:!1,isWritable:!1},{pubkey:st.programId,isSigner:!1,isWritable:!1}],g=E([Ae("withMetadata")]),w=Buffer.alloc(g.span);g.encode({withMetadata:b},w);let B=Buffer.from([...pr,...w]);return new Be({keys:f,programId:e,data:B})}static lockPositionInstruction({programId:e,authProgramId:t,poolProgramId:n,owner:i,positionNft:s}){let{publicKey:o}=ae(i,s,ie),{publicKey:r}=Le(n,s),u=[{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:i,isSigner:!0,isWritable:!1},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!1},{pubkey:ri(e,r).publicKey,isSigner:!1,isWritable:!0},{pubkey:ie,isSigner:!1,isWritable:!1},{pubkey:st.programId,isSigner:!1,isWritable:!1}];return new Be({keys:u,programId:e,data:Buffer.from(pr)})}static harvestLockPositionInstruction(e){let[t,n]=[new K(e.poolKeys.programId),new K(e.poolKeys.id)],i=W.getTickArrayStartIndexByTick(e.ownerPosition.tickLower,e.poolKeys.config.tickSpacing),s=W.getTickArrayStartIndexByTick(e.ownerPosition.tickUpper,e.poolKeys.config.tickSpacing),{publicKey:o}=ne(t,n,i),{publicKey:r}=ne(t,n,s),{publicKey:u}=ae(e.owner,e.ownerPosition.nftMint,ie),{publicKey:a}=Le(t,e.ownerPosition.nftMint),{publicKey:c}=rt(t,n,e.ownerPosition.tickLower,e.ownerPosition.tickUpper),p=[];for(let y=0;y<e.poolKeys.rewardInfos.length;y++)p.push({poolRewardVault:new K(e.poolKeys.rewardInfos[y].vault),ownerRewardVault:e.ownerRewardAccounts[y],rewardMint:new K(e.poolKeys.rewardInfos[y].mint.address)});let l=[...p.map(y=>[{pubkey:y.poolRewardVault,isSigner:!1,isWritable:!0},{pubkey:y.ownerRewardVault,isSigner:!1,isWritable:!0},{pubkey:y.rewardMint,isSigner:!1,isWritable:!1}]).flat()],d=[{pubkey:e.authProgramId,isSigner:!1,isWritable:!1},{pubkey:ri(e.programId,a).publicKey,isSigner:!1,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:e.owner,isSigner:!0,isWritable:!1},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:new K(e.poolKeys.vault.A),isSigner:!1,isWritable:!0},{pubkey:new K(e.poolKeys.vault.B),isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:e.userVaultA,isSigner:!1,isWritable:!0},{pubkey:e.userVaultB,isSigner:!1,isWritable:!0},{pubkey:ie,isSigner:!1,isWritable:!1},{pubkey:de,isSigner:!1,isWritable:!1},{pubkey:St,isSigner:!1,isWritable:!1},{pubkey:new K(e.poolKeys.mintA.address),isSigner:!1,isWritable:!1},{pubkey:new K(e.poolKeys.mintB.address),isSigner:!1,isWritable:!1},...l];return new Be({keys:d,programId:e.programId,data:Buffer.from(dr)})}static harvestLockPositionInstructionV2({programId:e,auth:t,lockPositionId:n,clmmProgram:i,lockOwner:s,lockNftMint:o,lockNftAccount:r,positionNftAccount:u,positionId:a,poolId:c,protocolPosition:p,vaultA:l,vaultB:d,tickArrayLower:y,tickArrayUpper:b,userVaultA:f,userVaultB:g,mintA:w,mintB:B,rewardAccounts:T,exTickArrayBitmap:A}){let k=[...A?[{pubkey:A,isSigner:!1,isWritable:!0}]:[],...T.map(x=>[{pubkey:x.poolRewardVault,isSigner:!1,isWritable:!0},{pubkey:x.ownerRewardVault,isSigner:!1,isWritable:!0},{pubkey:x.rewardMint,isSigner:!1,isWritable:!1}]).flat()],I=[{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:s,isSigner:!0,isWritable:!1},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:i,isSigner:!1,isWritable:!1},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:p,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:d,isSigner:!1,isWritable:!0},{pubkey:y,isSigner:!1,isWritable:!0},{pubkey:b,isSigner:!1,isWritable:!0},{pubkey:f,isSigner:!1,isWritable:!0},{pubkey:g,isSigner:!1,isWritable:!0},{pubkey:ie,isSigner:!1,isWritable:!1},{pubkey:de,isSigner:!1,isWritable:!1},{pubkey:St,isSigner:!1,isWritable:!1},{pubkey:w,isSigner:!1,isWritable:!1},{pubkey:B,isSigner:!1,isWritable:!1},...k];return new Be({keys:I,programId:e,data:Buffer.from(dr)})}};var uf=E([ge(8),G("bump"),Ae("disableCreatePool"),kt("index"),P("tradeFeeRate"),P("protocolFeeRate"),P("fundFeeRate"),P("createPoolFee"),C("protocolOwner"),C("fundOwner"),P("creatorFeeRate"),Z(P(),15)]),fr=E([ge(8),C("configId"),C("poolCreator"),C("vaultA"),C("vaultB"),C("mintLp"),C("mintA"),C("mintB"),C("mintProgramA"),C("mintProgramB"),C("observationId"),G("bump"),G("status"),G("lpDecimals"),G("mintDecimalA"),G("mintDecimalB"),P("lpAmount"),P("protocolFeesMintA"),P("protocolFeesMintB"),P("fundFeesMintA"),P("fundFeesMintB"),P("openTime"),P("epoch"),G("feeOn"),Ae("enableCreatorFee"),Z(G(),6),P("creatorFeesMintA"),P("creatorFeesMintB"),Z(P(),28)]),cf=E([ge(8),C("configId"),Z(P(),30)]);import{PublicKey as Bf,TransactionInstruction as is,Keypair as Sf,SystemProgram as Kf}from"@solana/web3.js";import{ASSOCIATED_TOKEN_PROGRAM_ID as Lf,TOKEN_2022_PROGRAM_ID as Rf,TOKEN_PROGRAM_ID as Nf}from"@solana/spl-token";var ns=Buffer.from("vault_and_lp_mint_auth_seed","utf8"),df=Buffer.from("amm_config","utf8"),ff=Buffer.from("pool","utf8"),bf=Buffer.from("pool_lp_mint","utf8"),yf=Buffer.from("pool_vault","utf8"),gf=Buffer.from("observation","utf8"),Pf=Buffer.from("permission","utf8");function br(m){return Pe([ns],m)}var kf=Buffer.from("locked_liquidity","utf8");var Ff=re("Raydium_cpmm"),rs={initialize:[175,175,109,31,13,152,155,237],deposit:[242,35,198,137,82,225,242,182],withdraw:[183,18,70,156,148,109,161,34],swapBaseInput:[143,190,90,218,196,30,51,222],swapBaseOutput:[55,217,98,86,163,74,180,173],lockCpLiquidity:[216,157,29,78,38,51,31,26],collectCpFee:[8,30,51,199,209,184,247,133],createPermissionPda:Buffer.from([135,136,2,216,137,169,181,202]),closePermissionPda:Buffer.from([156,84,32,118,69,135,70,123]),initializeWithPermission:Buffer.from([63,55,254,65,49,178,89,121]),collectCreatorFee:Buffer.from([20,22,86,123,198,28,219,132])};function yr(m,e,t,n,i,s,o,r,u,a,c,p,l,d,y,b){let f=E([P("amountIn"),P("amounOutMin")]),g=[{pubkey:e,isSigner:!0,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!1},{pubkey:c,isSigner:!1,isWritable:!1},{pubkey:p,isSigner:!1,isWritable:!1},{pubkey:l,isSigner:!1,isWritable:!1},{pubkey:d,isSigner:!1,isWritable:!0}],w=Buffer.alloc(f.span);return f.encode({amountIn:y,amounOutMin:b},w),new is({keys:g,programId:m,data:Buffer.from([...rs.swapBaseInput,...w])})}import nb from"bn.js";import os from"bn.js";var Gf=new os(0);import Qf from"bn.js";import gr from"bn.js";var yb=new gr(25),gb=new gr(1e4);var mi=E([G("instruction"),P("amountIn"),P("minAmountOut")]),pi=E([G("instruction"),P("maxAmountIn"),P("amountOut")]),wb=E([G("instruction"),G("nonce")]),ss=E([G("instruction"),G("nonce"),P("startTime")]),di=E([P("status"),P("nonce"),P("maxOrder"),P("depth"),P("baseDecimal"),P("quoteDecimal"),P("state"),P("resetFlag"),P("minSize"),P("volMaxCutRatio"),P("amountWaveRatio"),P("baseLotSize"),P("quoteLotSize"),P("minPriceMultiplier"),P("maxPriceMultiplier"),P("systemDecimalValue"),P("minSeparateNumerator"),P("minSeparateDenominator"),P("tradeFeeNumerator"),P("tradeFeeDenominator"),P("pnlNumerator"),P("pnlDenominator"),P("swapFeeNumerator"),P("swapFeeDenominator"),P("baseNeedTakePnl"),P("quoteNeedTakePnl"),P("quoteTotalPnl"),P("baseTotalPnl"),P("poolOpenTime"),P("punishPcAmount"),P("punishCoinAmount"),P("orderbookToInitTime"),U("swapBaseInAmount"),U("swapQuoteOutAmount"),P("swapBase2QuoteFee"),U("swapQuoteInAmount"),U("swapBaseOutAmount"),P("swapQuote2BaseFee"),C("baseVault"),C("quoteVault"),C("baseMint"),C("quoteMint"),C("lpMint"),C("openOrders"),C("marketId"),C("marketProgramId"),C("targetOrders"),C("withdrawQueue"),C("lpVault"),C("owner"),P("lpReserve"),Z(P(),3,"padding")]),Tb=E([P("accountType"),P("status"),P("nonce"),P("maxOrder"),P("depth"),P("baseDecimal"),P("quoteDecimal"),P("state"),P("resetFlag"),P("minSize"),P("volMaxCutRatio"),P("amountWaveRatio"),P("baseLotSize"),P("quoteLotSize"),P("minPriceMultiplier"),P("maxPriceMultiplier"),P("systemDecimalsValue"),P("abortTradeFactor"),P("priceTickMultiplier"),P("priceTick"),P("minSeparateNumerator"),P("minSeparateDenominator"),P("tradeFeeNumerator"),P("tradeFeeDenominator"),P("pnlNumerator"),P("pnlDenominator"),P("swapFeeNumerator"),P("swapFeeDenominator"),P("baseNeedTakePnl"),P("quoteNeedTakePnl"),P("quoteTotalPnl"),P("baseTotalPnl"),P("poolOpenTime"),P("punishPcAmount"),P("punishCoinAmount"),P("orderbookToInitTime"),U("swapBaseInAmount"),U("swapQuoteOutAmount"),U("swapQuoteInAmount"),U("swapBaseOutAmount"),P("swapQuote2BaseFee"),P("swapBase2QuoteFee"),C("baseVault"),C("quoteVault"),C("baseMint"),C("quoteMint"),C("lpMint"),C("modelDataAccount"),C("openOrders"),C("marketId"),C("marketProgramId"),C("targetOrders"),C("owner"),Z(P(),64,"padding")]),as=E([G("instruction"),P("baseAmountIn"),P("quoteAmountIn"),P("fixedSide"),P("otherAmountMin")]),us=E([G("instruction"),P("lpAmount"),P("baseAmountMin"),P("quoteAmountMin")]);var hb=E([P("fee")]);import{PublicKey as ng}from"@solana/web3.js";import rg from"bn.js";import xn from"decimal.js";import{TOKEN_PROGRAM_ID as Ks}from"@solana/spl-token";import{PublicKey as Ib,SystemProgram as Sb,SYSVAR_RENT_PUBKEY as Kb,TransactionInstruction as kr}from"@solana/web3.js";import{ASSOCIATED_TOKEN_PROGRAM_ID as Lb,TOKEN_PROGRAM_ID as Ar}from"@solana/spl-token";var Pr=re("Raydium_liquidity_instruction");function cs({poolKeys:m,userKeys:e,amountIn:t,minAmountOut:n,modelDataPubKey:i=ln},s){let o=Pt(m),r=Buffer.alloc(mi.span);mi.encode({instruction:9,amountIn:oe(t),minAmountOut:oe(n)},r);let u=[S({pubkey:Ar,isWritable:!1}),S({pubkey:o.id}),S({pubkey:o.authority,isWritable:!1}),S({pubkey:o.openOrders})];return s===4&&u.push(S({pubkey:o.targetOrders})),u.push(S({pubkey:o.vault.A}),S({pubkey:o.vault.B})),s===5&&u.push(S({pubkey:i})),u.push(S({pubkey:o.marketProgramId,isWritable:!1}),S({pubkey:o.marketId}),S({pubkey:o.marketBids}),S({pubkey:o.marketAsks}),S({pubkey:o.marketEventQueue}),S({pubkey:o.marketBaseVault}),S({pubkey:o.marketQuoteVault}),S({pubkey:o.marketAuthority,isWritable:!1}),S({pubkey:e.tokenAccountIn}),S({pubkey:e.tokenAccountOut}),S({pubkey:e.owner,isWritable:!1,isSigner:!0})),new kr({programId:o.programId,keys:u,data:r})}function ls({poolKeys:m,userKeys:e,maxAmountIn:t,amountOut:n,modelDataPubKey:i=ln},s){let o=Pt(m),r=Buffer.alloc(pi.span);pi.encode({instruction:11,maxAmountIn:oe(t),amountOut:oe(n)},r);let u=[S({pubkey:Ar,isWritable:!1}),S({pubkey:o.id}),S({pubkey:o.authority,isWritable:!1}),S({pubkey:o.openOrders}),S({pubkey:o.targetOrders}),S({pubkey:o.vault.A}),S({pubkey:o.vault.B})];return s===5&&u.push(S({pubkey:i})),u.push(S({pubkey:o.marketProgramId,isWritable:!1}),S({pubkey:o.marketId}),S({pubkey:o.marketBids}),S({pubkey:o.marketAsks}),S({pubkey:o.marketEventQueue}),S({pubkey:o.marketBaseVault}),S({pubkey:o.marketQuoteVault}),S({pubkey:o.marketAuthority,isWritable:!1}),S({pubkey:e.tokenAccountIn}),S({pubkey:e.tokenAccountOut}),S({pubkey:e.owner,isWritable:!1,isSigner:!0})),new kr({programId:o.programId,keys:u,data:r})}function wr(m){let{poolKeys:e,version:t,userKeys:n,amountIn:i,amountOut:s,fixedSide:o}=m;if(t===4||t===5){let r={poolKeys:e,userKeys:n};if(o==="in")return cs(X(F({},r),{amountIn:i,minAmountOut:s}),t);if(o==="out")return ls(X(F({},r),{maxAmountIn:i,amountOut:s}),t);Pr.logWithError("invalid params","params",m)}throw Pr.logWithError("invalid version","poolKeys.version",t),new Error("invalid version")}import{PublicKey as Db}from"@solana/web3.js";var Ub=re("Raydium_liquidity_serum");var ms=5e4,ps=E([P("x"),P("y"),P("price")]),Yb=E([P("accountType"),P("status"),P("multiplier"),P("validDataCount"),Z(ps,ms,"DataElement")]);var $t=E([C("mint"),C("owner"),P("amount"),Ne("delegateOption"),C("delegate"),G("state"),Ne("isNativeOption"),P("isNative"),P("delegatedAmount"),Ne("closeAuthorityOption"),C("closeAuthority")]);import{Keypair as gs,PublicKey as Ps}from"@solana/web3.js";import fy from"bn.js";import{TOKEN_PROGRAM_ID as ks}from"@solana/spl-token";function ds(m){return m instanceof Uint8Array||m!=null&&typeof m=="object"&&m.constructor.name==="Uint8Array"}function fi(m,...e){if(!ds(m))throw new Error("Uint8Array expected");if(e.length>0&&!e.includes(m.length))throw new Error(`Uint8Array expected of length ${e}, not of length=${m.length}`)}function bi(m,e=!0){if(m.destroyed)throw new Error("Hash instance has been destroyed");if(e&&m.finished)throw new Error("Hash#digest() has already been called")}function Tr(m,e){fi(m);let t=e.outputLen;if(m.length<t)throw new Error(`digestInto() expects output buffer of length at least ${t}`)}var Tn=m=>new DataView(m.buffer,m.byteOffset,m.byteLength),qe=(m,e)=>m<<32-e|m>>>e;var ey=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;function fs(m){if(typeof m!="string")throw new Error(`utf8ToBytes expected string, got ${typeof m}`);return new Uint8Array(new TextEncoder().encode(m))}function yi(m){return typeof m=="string"&&(m=fs(m)),fi(m),m}var wn=class{clone(){return this._cloneInto()}},ty={}.toString;function hr(m){let e=n=>m().update(yi(n)).digest(),t=m();return e.outputLen=t.outputLen,e.blockLen=t.blockLen,e.create=()=>m(),e}function bs(m,e,t,n){if(typeof m.setBigUint64=="function")return m.setBigUint64(e,t,n);let i=BigInt(32),s=BigInt(4294967295),o=Number(t>>i&s),r=Number(t&s),u=n?4:0,a=n?0:4;m.setUint32(e+u,o,n),m.setUint32(e+a,r,n)}var xr=(m,e,t)=>m&e^~m&t,Br=(m,e,t)=>m&e^m&t^e&t,hn=class extends wn{constructor(e,t,n,i){super(),this.blockLen=e,this.outputLen=t,this.padOffset=n,this.isLE=i,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(e),this.view=Tn(this.buffer)}update(e){bi(this);let{view:t,buffer:n,blockLen:i}=this;e=yi(e);let s=e.length;for(let o=0;o<s;){let r=Math.min(i-this.pos,s-o);if(r===i){let u=Tn(e);for(;i<=s-o;o+=i)this.process(u,o);continue}n.set(e.subarray(o,o+r),this.pos),this.pos+=r,o+=r,this.pos===i&&(this.process(t,0),this.pos=0)}return this.length+=e.length,this.roundClean(),this}digestInto(e){bi(this),Tr(e,this),this.finished=!0;let{buffer:t,view:n,blockLen:i,isLE:s}=this,{pos:o}=this;t[o++]=128,this.buffer.subarray(o).fill(0),this.padOffset>i-o&&(this.process(n,0),o=0);for(let p=o;p<i;p++)t[p]=0;bs(n,i-8,BigInt(this.length*8),s),this.process(n,0);let r=Tn(e),u=this.outputLen;if(u%4)throw new Error("_sha2: outputLen should be aligned to 32bit");let a=u/4,c=this.get();if(a>c.length)throw new Error("_sha2: outputLen bigger than state");for(let p=0;p<a;p++)r.setUint32(4*p,c[p],s)}digest(){let{buffer:e,outputLen:t}=this;this.digestInto(e);let n=e.slice(0,t);return this.destroy(),n}_cloneInto(e){e||(e=new this.constructor),e.set(...this.get());let{blockLen:t,buffer:n,length:i,finished:s,destroyed:o,pos:r}=this;return e.length=i,e.pos=r,e.finished=s,e.destroyed=o,i%t&&e.buffer.set(n),e}};var ys=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),dt=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),ft=new Uint32Array(64),gi=class extends hn{constructor(){super(64,32,8,!1),this.A=dt[0]|0,this.B=dt[1]|0,this.C=dt[2]|0,this.D=dt[3]|0,this.E=dt[4]|0,this.F=dt[5]|0,this.G=dt[6]|0,this.H=dt[7]|0}get(){let{A:e,B:t,C:n,D:i,E:s,F:o,G:r,H:u}=this;return[e,t,n,i,s,o,r,u]}set(e,t,n,i,s,o,r,u){this.A=e|0,this.B=t|0,this.C=n|0,this.D=i|0,this.E=s|0,this.F=o|0,this.G=r|0,this.H=u|0}process(e,t){for(let p=0;p<16;p++,t+=4)ft[p]=e.getUint32(t,!1);for(let p=16;p<64;p++){let l=ft[p-15],d=ft[p-2],y=qe(l,7)^qe(l,18)^l>>>3,b=qe(d,17)^qe(d,19)^d>>>10;ft[p]=b+ft[p-7]+y+ft[p-16]|0}let{A:n,B:i,C:s,D:o,E:r,F:u,G:a,H:c}=this;for(let p=0;p<64;p++){let l=qe(r,6)^qe(r,11)^qe(r,25),d=c+l+xr(r,u,a)+ys[p]+ft[p]|0,b=(qe(n,2)^qe(n,13)^qe(n,22))+Br(n,i,s)|0;c=a,a=u,u=r,r=o+d|0,o=s,s=i,i=n,n=d+b|0}n=n+this.A|0,i=i+this.B|0,s=s+this.C|0,o=o+this.D|0,r=r+this.E|0,u=u+this.F|0,a=a+this.G|0,c=c+this.H|0,this.set(n,i,s,o,r,u,a,c)}roundClean(){ft.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}};var Ir=hr(()=>new gi);var ky=re("Raydium_Util");function Sr({fromPublicKey:m,programId:e=ks,assignSeed:t}){let n=t?btoa(t).slice(0,32):gs.generate().publicKey.toBase58().slice(0,32);return{publicKey:As(m,n,e),seed:n}}function As(m,e,t){let n=Buffer.concat([m.toBuffer(),Buffer.from(e),t.toBuffer()]),i=Ir(n);return new Ps(i)}import{PublicKey as ws,SystemProgram as Ts}from"@solana/web3.js";import hs from"bn.js";import{createCloseAccountInstruction as xs,createInitializeAccountInstruction as Bs,createTransferInstruction as Ly,TOKEN_PROGRAM_ID as en}from"@solana/spl-token";function Is(m){let{mint:e,tokenAccount:t,owner:n,programId:i=en}=m;return Bs(t,e,n,i)}function tn(m){let{tokenAccount:e,payer:t,multiSigners:n=[],owner:i,programId:s=en}=m;return xs(e,t,i,n,s)}async function Kr(m){let{connection:e,amount:t,commitment:n,payer:i,owner:s,skipCloseAccount:o}=m,r=await e.getMinimumBalanceForRentExemption($t.span,n),u=oe(t).add(new hs(r)),a=Sr({fromPublicKey:i,programId:en});return{addresses:{newAccount:a.publicKey},signers:[],instructions:[Ts.createAccountWithSeed({fromPubkey:i,basePubkey:i,seed:a.seed,newAccountPubkey:a.publicKey,lamports:u.toNumber(),space:$t.span,programId:en}),Is({mint:new ws(Ue.address),tokenAccount:a.publicKey,owner:s,programId:en})],instructionTypes:[j.CreateAccount,j.InitAccount],endInstructionTypes:o?[]:[j.CloseAccount],endInstructions:o?[]:[tn({tokenAccount:a.publicKey,payer:i,owner:s})]}}var Ss=E([Ne("mintAuthorityOption"),C("mintAuthority"),P("supply"),G("decimals"),G("isInitialized"),Ne("freezeAuthorityOption"),C("freezeAuthority")]);function Cs({programId:m}){let{publicKey:e}=Pe([Buffer.from("amm_config_account_seed","utf-8")],m);return e}function Cr({programId:m}){return Pe([Buffer.from([97,109,109,32,97,117,116,104,111,114,105,116,121])],m)}var Pi={volume:0,volumeQuote:0,volumeFee:0,apr:0,feeApr:0,priceMin:0,priceMax:0,rewardApr:[]},Lr=m=>{let e={},t=Ks.toBase58();return Object.keys(m).map(n=>{let i=m[n],[s,o]=[i.baseMint.toBase58(),i.quoteMint.toBase58()];e[n]={id:n,version:4,status:i.status.toNumber(),programId:i.programId.toBase58(),mintA:At({address:s,programId:t,decimals:i.baseDecimal.toNumber()}),mintB:At({address:o,programId:t,decimals:i.quoteDecimal.toNumber()}),rewardDefaultInfos:[],rewardDefaultPoolInfos:"Ecosystem",price:i.poolPrice.toNumber(),mintAmountA:new xn(i.mintAAmount.toString()).div(10**i.baseDecimal.toNumber()).toNumber(),mintAmountB:new xn(i.mintBAmount.toString()).div(10**i.quoteDecimal.toNumber()).toNumber(),baseReserve:i.baseReserve,quoteReserve:i.quoteReserve,feeRate:new xn(i.tradeFeeNumerator.toString()).div(i.tradeFeeDenominator.toString()).toNumber(),openTime:i.poolOpenTime.toString(),tvl:0,day:Pi,week:Pi,month:Pi,pooltype:[],farmUpcomingCount:0,farmOngoingCount:0,farmFinishedCount:0,type:"Standard",marketId:i.marketId.toBase58(),configId:Cs({programId:i.programId}).toBase58(),lpPrice:0,lpAmount:new xn(i.lpReserve.toString()).div(10**Math.min(i.baseDecimal.toNumber(),i.quoteDecimal.toNumber())).toNumber(),lpMint:At({address:i.lpMint.toBase58(),programId:t,decimals:Math.min(i.baseDecimal.toNumber(),i.quoteDecimal.toNumber())}),burnPercent:0}}),e};var Rr={[Gn.toBase58()]:3},Nr={3:Gn};var ki=E([ge(5),ge(8),C("ownAddress"),P("vaultSignerNonce"),C("baseMint"),C("quoteMint"),C("baseVault"),P("baseDepositsTotal"),P("baseFeesAccrued"),C("quoteVault"),P("quoteDepositsTotal"),P("quoteFeesAccrued"),P("quoteDustThreshold"),C("requestQueue"),C("eventQueue"),C("bids"),C("asks"),P("baseLotSize"),P("quoteLotSize"),P("feeRateBps"),P("referrerRebatesAccrued"),ge(7)]),Mr={3:ki};import{PublicKey as Or}from"@solana/web3.js";var Bn=re("Serum"),In=class{static getProgramId(e){let t=Nr[e];return t||Bn.logWithError("invalid version","version",e),t}static getVersion(e){let t=e.toBase58(),n=Rr[t];return n||Bn.logWithError("invalid program id","programId",t),n}static getStateLayout(e){let t=Mr[e];return t||Bn.logWithError(!!t,"invalid version","version",e),t}static getLayouts(e){return{state:this.getStateLayout(e)}}static getAssociatedAuthority({programId:e,marketId:t}){let n=[t.toBuffer()],i=0,s;for(;i<100;){try{let o=n.concat(Buffer.from([i]),Buffer.alloc(7));s=Or.createProgramAddressSync(o,e)}catch(o){if(o instanceof TypeError)throw o;i++;continue}return{publicKey:s,nonce:i}}return Bn.logWithError("unable to find a viable program address nonce","params",{programId:e,marketId:t}),{publicKey:Or.default,nonce:i}}};import{PublicKey as q,SystemProgram as Ls,TransactionInstruction as Rs}from"@solana/web3.js";import Bt from"bn.js";import{ASSOCIATED_TOKEN_PROGRAM_ID as Ns,TOKEN_2022_PROGRAM_ID as Ms,TOKEN_PROGRAM_ID as Os}from"@solana/spl-token";function _s(m,e,t,n,i,s,o,r,u,a,c,p,l,d,y){var k;let b=[],f=[S({pubkey:Os,isWritable:!1}),S({pubkey:Ms,isWritable:!1}),S({pubkey:Ns,isWritable:!1}),S({pubkey:Ls.programId,isWritable:!1}),S({pubkey:e,isSigner:!0})];f.push(S({pubkey:t})),f.push(S({pubkey:i}));let g=[u,a],w=[c,p],B=[s,o,r];for(let I=0;I<g.length;I++){let x=g[I],R=B[I]===x.mintA.address;if(f.push(S({pubkey:new q(x.programId),isWritable:!1})),I===g.length-1?f.push(S({pubkey:i})):f.push(S({pubkey:n})),f.push(S({pubkey:new q(B[I])})),f.push(S({pubkey:new q(B[I+1])})),x.version===6){let h=w[I];f.push(S({pubkey:new q(h.config.id)})),f.push(S({pubkey:new q(h.id)})),f.push(S({pubkey:new q(R?h.vault.A:h.vault.B)})),f.push(S({pubkey:new q(R?h.vault.B:h.vault.A)})),f.push(S({pubkey:new q(x.observationId)})),f.push(S({pubkey:St})),f.push(S({pubkey:ke(new q(x.programId),new q(x.id)).publicKey})),b.push(Es(x.sqrtPriceX64.toString(),R));for(let L of(k=y[I])!=null?k:[])f.push(S({pubkey:new q(L)}))}else if(x.version===5){let h=w[I];f.push(S({pubkey:new q(h.id)})),f.push(S({pubkey:new q(h.authority),isWritable:!1})),f.push(S({pubkey:new q(h.marketProgramId)})),f.push(S({pubkey:new q(h.marketAuthority)})),f.push(S({pubkey:vi,isWritable:!1})),f.push(S({pubkey:new q(h.openOrders)})),f.push(S({pubkey:new q(h.vault.A)})),f.push(S({pubkey:new q(h.vault.B)})),f.push(S({pubkey:new q(h.id)})),f.push(S({pubkey:new q(h.id)})),f.push(S({pubkey:new q(h.id)})),f.push(S({pubkey:new q(h.id)})),f.push(S({pubkey:new q(h.id)})),f.push(S({pubkey:new q(h.id)})),f.push(S({pubkey:new q(h.marketId)})),f.push(S({pubkey:new q(h.marketBids)})),f.push(S({pubkey:new q(h.marketAsks)})),f.push(S({pubkey:new q(h.marketEventQueue)})),f.push(S({pubkey:new q(h.marketBaseVault)})),f.push(S({pubkey:new q(h.marketQuoteVault)}))}else if(x.version===4){let h=w[I],L=x.status!==1;f.push(S({pubkey:new q(h.id)})),f.push(S({pubkey:new q(h.authority),isWritable:!1})),f.push(S({pubkey:new q(L?h.id:h.marketProgramId)})),f.push(S({pubkey:new q(L?h.id:h.marketAuthority)})),f.push(S({pubkey:new q(L?h.id:h.openOrders)})),f.push(S({pubkey:new q(h.vault.A)})),f.push(S({pubkey:new q(h.vault.B)})),f.push(S({pubkey:new q(L?h.id:h.marketId)})),f.push(S({pubkey:new q(L?h.id:h.marketBids)})),f.push(S({pubkey:new q(L?h.id:h.marketAsks)})),f.push(S({pubkey:new q(L?h.id:h.marketEventQueue)})),f.push(S({pubkey:new q(L?h.id:h.marketBaseVault)})),f.push(S({pubkey:new q(L?h.id:h.marketQuoteVault)}))}else if(x.version===7){let h=w[I];f.push(S({pubkey:new q(h.authority)})),f.push(S({pubkey:new q(h.config.id)})),f.push(S({pubkey:new q(h.id)})),f.push(S({pubkey:new q(R?h.vault.A:h.vault.B)})),f.push(S({pubkey:new q(R?h.vault.B:h.vault.A)})),f.push(S({pubkey:new q(x.observationId)}))}else throw Error("pool type error")}let T=E([G("insId"),P("amountIn"),P("amountOut"),Z(U(),b.length,"clmmPriceLimit")]),A=Buffer.alloc(T.span);return T.encode({insId:0,amountIn:l,amountOut:d,clmmPriceLimit:b},A),new Rs({keys:f,programId:m,data:A})}function Es(m,e){if(m)if(e){let t=new Bt(m).div(new Bt(25));return t.gt(bn)?t:bn}else{let t=new Bt(m).mul(new Bt(25));return t.lt(yn)?t:yn}else return e?bn:yn}function _r({routeProgram:m,ownerInfo:e,inputMint:t,swapInfo:n}){var i,s,o,r,u,a,c;if(n.routeType==="amm")if(n.poolInfo[0].version===6){let p=n.poolKey[0],l=Pt(p),d=t.equals(l.mintA.address)?He.add(Me):Ye.sub(Me);return xt.makeSwapBaseInInstructions({poolInfo:p,poolKeys:p,observationId:n.poolInfo[0].observationId,ownerInfo:{wallet:e.wallet,tokenAccountA:l.mintA.address.equals(t)?e.sourceToken:e.destinationToken,tokenAccountB:l.mintA.address.equals(t)?e.destinationToken:e.sourceToken},inputMint:t,amountIn:n.amountIn.amount.raw,amountOutMin:n.minAmountOut.amount.raw.sub((s=(i=n.minAmountOut.fee)==null?void 0:i.raw)!=null?s:new Bt(0)),sqrtPriceLimitX64:d,remainingAccounts:(o=n.remainingAccounts[0])!=null?o:[]})}else if(n.poolInfo[0].version===7){let p=n.poolInfo[0],l=t.toString()===n.poolInfo[0].mintA.address;return{signers:[],instructions:[yr(p.programId,e.wallet,p.authority,p.configId,p.id,e.sourceToken,e.destinationToken,l?p.vaultA:p.vaultB,l?p.vaultB:p.vaultA,l?p.mintProgramA:p.mintProgramB,l?p.mintProgramB:p.mintProgramA,new q(p[l?"mintA":"mintB"].address),new q(p[l?"mintB":"mintA"].address),p.observationId,n.amountIn.amount.raw,n.minAmountOut.amount.raw)],lookupTableAddress:[],instructionTypes:[l?j.CpmmSwapBaseIn:j.CpmmSwapBaseOut],address:{}}}else{let p=n.poolKey[0];return{signers:[],instructions:[wr({poolKeys:p,version:n.poolInfo[0].pooltype.includes("StablePool")?5:4,userKeys:{tokenAccountIn:e.sourceToken,tokenAccountOut:e.destinationToken,owner:e.wallet},amountIn:n.amountIn.amount.raw,amountOut:n.minAmountOut.amount.raw.sub((u=(r=n.minAmountOut.fee)==null?void 0:r.raw)!=null?u:new Bt(0)),fixedSide:"in"})],lookupTableAddress:p.lookupTableAccount?[p.lookupTableAccount]:[],instructionTypes:[n.poolInfo[0].pooltype.includes("StablePool")?j.AmmV5SwapBaseIn:j.AmmV4SwapBaseIn],address:{}}}else if(n.routeType==="route"){let p=n.poolInfo[0],l=n.poolInfo[1],d=n.poolKey[0],y=n.poolKey[1];if(e.routeToken===void 0)throw Error("owner route token account check error");return{signers:[],instructions:[_s(m,e.wallet,e.sourceToken,e.routeToken,e.destinationToken,t.toString(),n.middleToken.mint.toString(),n.outputMint.toString(),p,l,d,y,n.amountIn.amount.raw,n.minAmountOut.amount.raw.sub((c=(a=n.minAmountOut.fee)==null?void 0:a.raw)!=null?c:new Bt(0)),n.remainingAccounts)],instructionTypes:[j.RouteSwap],lookupTableAddress:[d.lookupTableAccount,y.lookupTableAccount].filter(b=>b!==void 0),address:{}}}else throw Error("route type error")}var at=new Kn(0),Ai=class extends Rt{constructor(e){super(e)}async getWSolAccounts(){this.scope.checkOwner(),await this.scope.account.fetchWalletTokenAccounts();let e=this.scope.account.tokenAccounts.filter(t=>t.mint.equals(Ve));return e.sort((t,n)=>t.isAssociated?1:n.isAssociated||t.amount.lt(n.amount)?-1:1),e}async unWrapWSol(e){let{amount:t,tokenProgram:n,txVersion:i=1,feePayer:s}=e,o=await this.getWSolAccounts(),r=this.createTxBuilder(s);r.addCustomComputeBudget(e.computeBudgetConfig);let u=oe(t);for(let a=0;a<o.length;a++)u.gte(o[a].amount)?(r.addInstruction({instructions:[tn({tokenAccount:o[a].publicKey,payer:this.scope.ownerPubKey,owner:this.scope.ownerPubKey,programId:n})]}),u.sub(o[a].amount)):r.addInstruction({instructions:[tn({tokenAccount:o[a].publicKey,payer:this.scope.ownerPubKey,owner:this.scope.ownerPubKey,programId:n})]});return r.versionBuild({txVersion:i})}async wrapWSol(e,t,n,i){let s=this.createTxBuilder(i),o=await Kr({connection:this.scope.connection,owner:this.scope.ownerPubKey,payer:this.scope.ownerPubKey,amount:e,skipCloseAccount:!0});return s.addInstruction(o),s.versionBuild({txVersion:n!=null?n:1})}async swap({swapInfo:e,swapPoolKeys:t,ownerInfo:n,computeBudgetConfig:i,routeProgram:s,txVersion:o,feePayer:r}){let u=this.createTxBuilder(r),a=e.amountIn,c=e.amountOut,p=a.amount.token.mint.equals(Ve),l=c.amount.token.mint.equals(Ve),d=a.amount.token.mint,y=c.amount.token.mint,{account:b,instructionParams:f}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:a.amount.token.isToken2022?Sn:ye,mint:d,notUseTokenAccount:p,owner:this.scope.ownerPubKey,skipCloseAccount:!p,createInfo:p?{payer:this.scope.ownerPubKey,amount:a.amount.raw}:void 0,associatedOnly:p?!1:n.associatedOnly,checkCreateATAOwner:n.checkCreateATAOwner});if(f&&u.addInstruction(f),b===void 0)throw Error("input account check error");let g;if(e.routeType==="route"&&!l)g=this.scope.account.getAssociatedTokenAccount(y,c.amount.token.isToken2022?Sn:ye);else{let{account:A,instructionParams:k}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:c.amount.token.isToken2022?Sn:ye,mint:y,notUseTokenAccount:l,owner:this.scope.ownerPubKey,skipCloseAccount:!0,createInfo:{payer:this.scope.ownerPubKey,amount:0},associatedOnly:l?!1:n.associatedOnly,checkCreateATAOwner:n.checkCreateATAOwner});g=A,k&&u.addInstruction(k)}l&&u.addInstruction({endInstructions:[tn({owner:this.scope.ownerPubKey,payer:this.scope.ownerPubKey,tokenAccount:g,programId:ye})],endInstructionTypes:[j.CloseAccount]});let w;if(e.routeType==="route"){let A=e.middleToken;w=this.scope.account.getAssociatedTokenAccount(A.mint,A.isToken2022?Sn:ye)}let B=t||await this.computePoolToPoolKeys({pools:e.poolInfoList}),T=_r({routeProgram:s,inputMint:d,swapInfo:X(F({},e),{poolInfo:[...e.poolInfoList],poolKey:B,outputMint:y}),ownerInfo:{wallet:this.scope.ownerPubKey,sourceToken:b,routeToken:w,destinationToken:g}});if(e.feeConfig!==void 0){let A=this.createTxBuilder();A.addInstruction({instructions:[Er(b,e.feeConfig.feeAccount,this.scope.ownerPubKey,e.feeConfig.feeAmount.toNumber())],instructionTypes:[j.TransferAmount]}),A.addInstruction(T);let{transactions:k}=o===0?await A.sizeCheckBuildV0():await A.sizeCheckBuild();k.length<2&&u.addInstruction({instructions:[Er(b,e.feeConfig.feeAccount,this.scope.ownerPubKey,e.feeConfig.feeAmount.toNumber())],instructionTypes:[j.TransferAmount]})}return u.addInstruction(T),o===0?u.sizeCheckBuildV0({computeBudgetConfig:i,address:T.address}):u.sizeCheckBuild({computeBudgetConfig:i,address:T.address})}async fetchRoutePoolBasicInfo(e){let{amm:t=Vi,clmm:n=Un,cpmm:i=Xn}=e||{},s=await this.scope.connection.getProgramAccounts(t,{dataSlice:{offset:di.offsetOf("baseMint"),length:64}}),o=E([C("baseMint"),C("quoteMint")]),r=s.map(d=>({id:d.pubkey,version:4,mintA:o.decode(d.account.data).baseMint,mintB:o.decode(d.account.data).quoteMint})),u=E([C("mintA"),C("mintB")]),c=(await this.scope.connection.getProgramAccounts(n,{filters:[{dataSize:Mt.span}],dataSlice:{offset:Mt.offsetOf("mintA"),length:64}})).map(d=>{let y=u.decode(d.account.data);return{id:d.pubkey,version:6,mintA:y.mintA,mintB:y.mintB}}),l=(await this.scope.connection.getProgramAccounts(i,{dataSlice:{offset:fr.offsetOf("mintA"),length:64}})).map(d=>{let y=u.decode(d.account.data);return{id:d.pubkey,version:7,mintA:y.mintA,mintB:y.mintB}});return{clmmPools:c,ammPools:r,cpmmPools:l}}getAllRoute({inputMint:e,outputMint:t,clmmPools:n,ammPools:i,cpmmPools:s}){e=e.toString()===It.default.toString()?Ve:e,t=t.toString()===It.default.toString()?Ve:t;let o={},r={},u={},a=[],c={};for(let l of n!=null?n:[]){if((l.mintA.equals(e)&&l.mintB.equals(t)||l.mintA.equals(t)&&l.mintB.equals(e))&&(a.push(l),r[l.id.toString()]=l),l.mintA.equals(e)){let d=l.mintB.toString();c[d]===void 0&&(c[d]={mintProgram:ye,in:[],out:[],mDecimals:0}),c[d].in.push(l)}if(l.mintB.equals(e)){let d=l.mintA.toString();c[d]===void 0&&(c[d]={mintProgram:ye,in:[],out:[],mDecimals:0}),c[d].in.push(l)}if(l.mintA.equals(t)){let d=l.mintB.toString();c[d]===void 0&&(c[d]={mintProgram:ye,in:[],out:[],mDecimals:0}),c[d].out.push(l)}if(l.mintB.equals(t)){let d=l.mintA.toString();c[d]===void 0&&(c[d]={mintProgram:ye,in:[],out:[],mDecimals:0}),c[d].out.push(l)}}let p=[];for(let l of i)(l.mintA.equals(e)&&l.mintB.equals(t)||l.mintA.equals(t)&&l.mintB.equals(e))&&(a.push(l),o[l.id.toBase58()]=l,p.push(l)),l.mintA.equals(e)&&(c[l.mintB.toBase58()]===void 0&&(c[l.mintB.toBase58()]={mintProgram:ye,in:[],out:[],mDecimals:0}),c[l.mintB.toBase58()].in.push(l)),l.mintB.equals(e)&&(c[l.mintA.toBase58()]===void 0&&(c[l.mintA.toBase58()]={mintProgram:ye,in:[],out:[],mDecimals:0}),c[l.mintA.toBase58()].in.push(l)),l.mintA.equals(t)&&(c[l.mintB.toBase58()]===void 0&&(c[l.mintB.toBase58()]={mintProgram:ye,in:[],out:[],mDecimals:0}),c[l.mintB.toBase58()].out.push(l)),l.mintB.equals(t)&&(c[l.mintA.toBase58()]===void 0&&(c[l.mintA.toBase58()]={mintProgram:ye,in:[],out:[],mDecimals:0}),c[l.mintA.toBase58()].out.push(l));for(let l of s)(l.mintA.equals(e)&&l.mintB.equals(t)||l.mintA.equals(t)&&l.mintB.equals(e))&&(a.push(l),u[l.id.toBase58()]=l),l.mintA.equals(e)&&(c[l.mintB.toBase58()]===void 0&&(c[l.mintB.toBase58()]={mintProgram:ye,in:[],out:[],mDecimals:0}),c[l.mintB.toBase58()].in.push(l)),l.mintB.equals(e)&&(c[l.mintA.toBase58()]===void 0&&(c[l.mintA.toBase58()]={mintProgram:ye,in:[],out:[],mDecimals:0}),c[l.mintA.toBase58()].in.push(l)),l.mintA.equals(t)&&(c[l.mintB.toBase58()]===void 0&&(c[l.mintB.toBase58()]={mintProgram:ye,in:[],out:[],mDecimals:0}),c[l.mintB.toBase58()].out.push(l)),l.mintB.equals(t)&&(c[l.mintA.toBase58()]===void 0&&(c[l.mintA.toBase58()]={mintProgram:ye,in:[],out:[],mDecimals:0}),c[l.mintA.toBase58()].out.push(l));for(let l of Object.keys(c)){if(c[l].in.length===1&&c[l].out.length===1&&c[l].in[0].id.equals(c[l].out[0].id)){delete c[l];continue}if(c[l].in.length===0||c[l].out.length===0){delete c[l];continue}let d=c[l];for(let y of d.in)for(let b of d.out)y.version===6&&r[y.id.toString()]===void 0?r[y.id.toString()]=y:y.version===7&&u[y.id.toString()]===void 0?u[y.id.toString()]=y:(y.version===4||y.version===5)&&o[y.id.toString()]===void 0&&(o[y.id.toString()]=y),b.version===6&&r[b.id.toString()]===void 0?r[b.id.toString()]=b:b.version===7&&u[b.id.toString()]===void 0?u[b.id.toString()]=b:(b.version===4||b.version===5)&&o[b.id.toString()]===void 0&&(o[b.id.toString()]=b)}return{directPath:a,addLiquidityPools:p,routePathDict:c,needSimulate:Object.values(o),needTickArray:Object.values(r),cpmmPoolList:Object.values(u)}}async fetchSwapRoutesData({routes:e,inputMint:t,outputMint:n}){let i=new Set([...e.needTickArray.map(b=>[b.mintA.toBase58(),b.mintB.toBase58()]).flat(),t.toString(),n.toString()]);console.log("fetching amm pools info, total: ",e.needSimulate.length);let s=await this.scope.liquidity.getRpcPoolInfos(e.needSimulate.map(b=>b.id)),o=Lr(s),r={};Object.values(o).forEach(b=>{i.delete(b.mintA.address),r[b.mintA.address]={address:new It(b.mintA.address),programId:ye,mintAuthority:null,supply:BigInt(0),decimals:b.mintA.decimals,isInitialized:!0,freezeAuthority:null,tlvData:Buffer.from("0","hex"),feeConfig:void 0},i.delete(b.mintB.address),r[b.mintB.address]={address:new It(b.mintB.address),programId:ye,mintAuthority:null,supply:BigInt(0),decimals:b.mintB.decimals,isInitialized:!0,freezeAuthority:null,tlvData:Buffer.from("0","hex"),feeConfig:void 0}}),console.log("fetching cpmm pools info, total: ",e.cpmmPoolList.length);let u=await this.scope.cpmm.getRpcPoolInfos(e.cpmmPoolList.map(b=>b.id.toBase58()),!0);Object.values(u).forEach(b=>{let[f,g]=[b.mintA.toBase58(),b.mintB.toBase58()];b.mintProgramA.equals(ye)?(i.delete(f),r[f]={address:b.mintA,programId:b.mintProgramA,mintAuthority:null,supply:BigInt(0),decimals:b.mintDecimalA,isInitialized:!0,freezeAuthority:null,tlvData:Buffer.from("0","hex"),feeConfig:void 0}):i.add(f),b.mintProgramB.equals(ye)?(i.delete(g),r[g]={address:b.mintB,programId:b.mintProgramB,mintAuthority:null,supply:BigInt(0),decimals:b.mintDecimalB,isInitialized:!0,freezeAuthority:null,tlvData:Buffer.from("0","hex"),feeConfig:void 0}):i.add(g)}),console.log("fetching mints info, total: ",i.size);let a=await Mn({connection:this.scope.connection,mints:Array.from(i).map(b=>new It(b))});r=F(F({},r),a);let c=this.scope.cpmm.toComputePoolInfos({pools:u,mintInfos:r});console.log("fetching clmm pools info, total:",e.needTickArray.length);let p=await this.scope.clmm.getRpcClmmPoolInfos({poolIds:e.needTickArray.map(b=>b.id)}),{computeClmmPoolInfo:l,computePoolTickData:d}=await this.scope.clmm.getComputeClmmPoolInfos({clmmPoolsRpcInfo:p,mintInfos:r}),y=Object.keys(e.routePathDict).reduce((b,f)=>X(F({},b),{[f]:X(F({},e.routePathDict[f]),{mintProgram:r[f].programId,mDecimals:r[f].decimals,in:e.routePathDict[f].in.map(g=>o[g.id.toBase58()]||l[g.id.toBase58()]||c[g.id.toBase58()]),out:e.routePathDict[f].out.map(g=>o[g.id.toBase58()]||l[g.id.toBase58()]||c[g.id.toBase58()])})}),{});return{mintInfos:r,ammPoolsRpcInfo:s,ammSimulateCache:o,clmmPoolsRpcInfo:p,computeClmmPoolInfo:l,computePoolTickData:d,computeCpmmData:c,routePathDict:y}}getAllRouteComputeAmountOut({inputTokenAmount:e,outputToken:t,directPath:n,routePathDict:i,simulateCache:s,tickCache:o,slippage:r,chainTime:u,epochInfo:a,feeConfig:c}){var g,w,B,T,A,k,I,x,R;let p=c===void 0?new Kn(0):e.raw.mul(new Kn(c.feeBps.toNumber())).div(new Kn(1e4)),l=e.raw.sub(p),d=new se(e.token,l),y=c===void 0?void 0:{feeAmount:p,feeAccount:c.feeAccount},b=X(F({},t),{address:Ge(t.address).toString()}),f=[];for(let h of n)try{f.push(X(F({},this.computeAmountOut({itemPool:h,tickCache:o,simulateCache:s,chainTime:u,epochInfo:a,slippage:r,outputToken:b,amountIn:d})),{feeConfig:y}))}catch(L){this.logDebug("direct error",h.version,h.id.toString(),L.message)}this.logDebug("direct done");for(let[h,L]of Object.entries(i)){let _={chainId:101,address:h,programId:L.mintProgram.toBase58(),logoURI:"",symbol:"",name:"",decimals:L.mDecimals,tags:[],extensions:{}},O=L.in.map(Q=>{try{return{pool:Q,data:this.computeAmountOut({itemPool:Q,tickCache:o,simulateCache:s,chainTime:u,epochInfo:a,slippage:r,outputToken:_,amountIn:d})}}catch(D){this.logDebug("route in error",Q.version,Q.id.toString(),D.message);return}}).sort((Q,D)=>{var We,ut,he,fe;let Te=Q===void 0?at:Q.data.amountOut.amount.raw.sub((ut=(We=Q.data.amountOut.fee)==null?void 0:We.raw)!=null?ut:at),Se=D===void 0?at:D.data.amountOut.amount.raw.sub((fe=(he=D.data.amountOut.fee)==null?void 0:he.raw)!=null?fe:at);return Te.lt(Se)?1:-1})[0];if(O===void 0)continue;let V=new se(Qi(_),O.data.amountOut.amount.raw.sub((w=(g=O.data.amountOut.fee)==null?void 0:g.raw)!=null?w:at));for(let Q of L.out)try{let D=this.computeAmountOut({itemPool:Q,tickCache:o,simulateCache:s,chainTime:u,epochInfo:a,slippage:r,outputToken:b,amountIn:V});f.push(X(F({},D),{allTrade:!!(O.data.allTrade&&D.allTrade),amountIn:O.data.amountIn,amountOut:D.amountOut,minAmountOut:D.minAmountOut,currentPrice:void 0,executionPrice:new nn(new Ce({baseToken:O.data.amountIn.amount.token,denominator:O.data.amountIn.amount.raw,quoteToken:D.amountOut.amount.token,numerator:D.amountOut.amount.raw.sub((T=(B=D.amountOut.fee)==null?void 0:B.raw)!=null?T:at)}).toFixed()),priceImpact:new nn(O.data.priceImpact.add(D.priceImpact).toFixed()),fee:[O.data.fee[0],D.fee[0]],routeType:"route",poolInfoList:[O.pool,Q],remainingAccounts:[O.data.remainingAccounts[0],D.remainingAccounts[0]],minMiddleAmountFee:(A=D.amountOut.fee)!=null&&A.raw?new se(O.data.amountOut.amount.token,((I=(k=O.data.amountOut.fee)==null?void 0:k.raw)!=null?I:at).add((R=(x=D.amountOut.fee)==null?void 0:x.raw)!=null?R:at)):void 0,middleToken:O.data.amountOut.amount.token,poolReady:O.data.poolReady&&D.poolReady,poolType:[O.data.poolType,D.poolType],feeConfig:y,expirationTime:De(O.data.expirationTime,D.expirationTime)}))}catch(D){this.logDebug("route out error",Q.version,Q.id.toString(),D.message)}}return f.filter(h=>(h.allTrade||this.logDebug(`pool ${h.poolInfoList.map(L=>L.id.toString()).join(",")} filter out since not all trade`),h.allTrade)).sort((h,L)=>h.amountOut.amount.raw.sub(L.amountOut.amount.raw).gt(at)?-1:1)}computeAmountOut({itemPool:e,tickCache:t,simulateCache:n,chainTime:i,epochInfo:s,slippage:o,outputToken:r,amountIn:u}){if(e.version===6){let{allTrade:a,realAmountIn:c,amountOut:p,minAmountOut:l,expirationTime:d,currentPrice:y,executionPrice:b,priceImpact:f,fee:g,remainingAccounts:w,executionPriceX64:B}=pe.computeAmountOutFormat({poolInfo:e,tickArrayCache:t[e.id.toString()],amountIn:u.raw,tokenOut:r,slippage:o,epochInfo:s,catchLiquidityInsufficient:!0});return{allTrade:a,amountIn:c,amountOut:p,minAmountOut:l,currentPrice:new nn(y.toFixed()),executionPrice:new nn(b.toFixed()),priceImpact:new nn(f.toFixed()),fee:[g],remainingAccounts:[w],routeType:"amm",poolInfoList:[e],poolReady:e.startTime<i,poolType:"CLMM",slippage:o,clmmExPriceX64:[B],expirationTime:De(c.expirationTime,d)}}else if(e.version===7){let{allTrade:a,executionPrice:c,amountOut:p,minAmountOut:l,priceImpact:d,fee:y}=this.scope.cpmm.computeSwapAmount({pool:e,outputMint:r.address,amountIn:u.raw,slippage:o});return{allTrade:a,amountIn:{amount:u,fee:void 0,expirationTime:void 0},amountOut:{amount:zt(X(F({},r),{amount:p})),fee:void 0,expirationTime:void 0},minAmountOut:{amount:zt(X(F({},r),{amount:l})),fee:void 0,expirationTime:void 0},currentPrice:e.poolPrice,executionPrice:c,priceImpact:d,fee:[new se(u.token,y)],remainingAccounts:[],routeType:"amm",poolInfoList:[e],poolReady:e.openTime.toNumber()<i,poolType:"CPMM",slippage:o,clmmExPriceX64:[void 0],expirationTime:void 0}}else{if(![1,6,7].includes(n[e.id.toString()].status))throw Error("swap error");let{amountOut:a,minAmountOut:c,currentPrice:p,executionPrice:l,priceImpact:d,fee:y}=this.scope.liquidity.computeAmountOut({poolInfo:n[e.id.toString()],amountIn:u.raw,mintIn:u.token.mint,mintOut:r.address,slippage:o});return{amountIn:{amount:u,fee:void 0,expirationTime:void 0},amountOut:{amount:zt(X(F({},r),{amount:a})),fee:void 0,expirationTime:void 0},minAmountOut:{amount:zt(X(F({},r),{amount:c})),fee:void 0,expirationTime:void 0},currentPrice:p,executionPrice:l,priceImpact:d,fee:[new se(u.token,y)],routeType:"amm",poolInfoList:[e],remainingAccounts:[],poolReady:Number(n[e.id].openTime)<i,poolType:e.version===5?"STABLE":void 0,expirationTime:void 0,allTrade:!0,slippage:o,clmmExPriceX64:[void 0]}}}async computePoolToPoolKeys({pools:e,clmmRpcData:t={},ammRpcData:n={}}){let i=new Set(e.filter(a=>a.version===6&&!t[a.id.toString()]).map(a=>a.id.toString()));if(i.size>0){let a=await this.scope.clmm.getRpcClmmPoolInfos({poolIds:Array.from(i)});Object.keys(a).forEach(c=>{t[c]=a[c]})}let s=new Set(e.filter(a=>a.version===4&&!n[a.id.toString()]).map(a=>a.id.toString()));if(s.size>0){let a=await this.scope.liquidity.getRpcPoolInfos(Array.from(s));Object.keys(a).forEach(c=>{n[c]=a[c]})}let o=new Set(e.filter(a=>a.version===4).map(a=>a.marketId)),r={};o.size>0&&(await bt(this.scope.connection,Array.from(o).map(c=>({pubkey:new It(c)})))).forEach(c=>{if(!c.accountInfo)return;let p=ki.decode(c.accountInfo.data);r[c.pubkey.toBase58()]={marketId:c.pubkey.toString(),marketProgramId:c.accountInfo.owner.toString(),marketAuthority:In.getAssociatedAuthority({programId:c.accountInfo.owner,marketId:c.pubkey}).publicKey.toString(),marketBaseVault:p.baseVault.toString(),marketQuoteVault:p.quoteVault.toString(),marketBids:p.bids.toString(),marketAsks:p.asks.toString(),marketEventQueue:p.eventQueue.toString()}});let u=[];return e.forEach(a=>{if(a.version===6){let c=t[a.id.toString()],p={programId:a.programId.toBase58(),id:a.id.toBase58(),mintA:a.mintA,mintB:a.mintB,openTime:String(a.startTime),vault:{A:c.vaultA.toBase58(),B:c.vaultB.toBase58()},config:X(F({},a.ammConfig),{id:a.ammConfig.id.toString(),defaultRange:0,defaultRangePoint:[]}),rewardInfos:[],observationId:a.observationId.toBase58(),exBitmapAccount:a.exBitmapAccount.toBase58()};u.push(p)}else if(a.version===4){let c=n[a.id.toString()],p=F({programId:a.programId,id:a.id,mintA:a.mintA,mintB:a.mintB,openTime:String(a.openTime),vault:{A:c.baseVault.toBase58(),B:c.quoteVault.toBase58()},authority:Cr({programId:new It(a.programId)}).publicKey.toString(),openOrders:c.openOrders.toBase58(),targetOrders:c.targetOrders.toBase58(),mintLp:a.lpMint},r[a.marketId]);u.push(p)}else a.version===7&&u.push({observationId:a.observationId.toBase58(),programId:a.programId.toBase58(),id:a.id.toBase58(),mintA:a.mintA,mintB:a.mintB,openTime:String(a.openTime),authority:br(a.programId).publicKey.toBase58(),vault:{A:a.vaultA.toBase58(),B:a.vaultB.toBase58()},mintLp:At({address:a.mintLp.toBase58(),programId:ye.toBase58(),decimals:a.lpDecimals}),config:X(F({id:a.configId.toBase58()},a.configInfo),{protocolFeeRate:a.configInfo.protocolFeeRate.toNumber(),tradeFeeRate:a.configInfo.tradeFeeRate.toNumber(),fundFeeRate:a.configInfo.fundFeeRate.toNumber(),createPoolFee:a.configInfo.createPoolFee.toString()})})}),u}};export{Ai as default};
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
//# sourceMappingURL=trade.mjs.map