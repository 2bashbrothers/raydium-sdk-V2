var No=Object.defineProperty,Mo=Object.defineProperties;var _o=Object.getOwnPropertyDescriptors;var yn=Object.getOwnPropertySymbols;var $r=Object.prototype.hasOwnProperty,ei=Object.prototype.propertyIsEnumerable;var Jr=(a,e,t)=>e in a?No(a,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):a[e]=t,F=(a,e)=>{for(var t in e||(e={}))$r.call(e,t)&&Jr(a,t,e[t]);if(yn)for(var t of yn(e))ei.call(e,t)&&Jr(a,t,e[t]);return a},j=(a,e)=>Mo(a,_o(e));var Oe=(a,e)=>{var t={};for(var n in a)$r.call(a,n)&&e.indexOf(n)<0&&(t[n]=a[n]);if(a!=null&&yn)for(var n of yn(a))e.indexOf(n)<0&&ei.call(a,n)&&(t[n]=a[n]);return t};import{PublicKey as we}from"@solana/web3.js";import{AccountLayout as Ga,NATIVE_MINT as Xn,TOKEN_PROGRAM_ID as yt}from"@solana/spl-token";import{PublicKey as ps}from"@solana/web3.js";import it from"bn.js";import Pc from"decimal.js";import Uo from"big.js";import kn from"bn.js";import{get as ti,set as Vo}from"lodash";var zn=class{constructor(e){this.logLevel=e.logLevel!==void 0?e.logLevel:0,this.name=e.name}set level(e){this.logLevel=e}get time(){return Date.now().toString()}get moduleName(){return this.name}isLogLevel(e){return e<=this.logLevel}error(...e){return this.isLogLevel(0)?(console.error(this.time,this.name,"sdk logger error",...e),this):this}logWithError(...e){let t=e.map(n=>typeof n=="object"?JSON.stringify(n):n).join(", ");throw new Error(t)}warning(...e){return this.isLogLevel(1)?(console.warn(this.time,this.name,"sdk logger warning",...e),this):this}info(...e){return this.isLogLevel(2)?(console.info(this.time,this.name,"sdk logger info",...e),this):this}debug(...e){return this.isLogLevel(3)?(console.debug(this.time,this.name,"sdk logger debug",...e),this):this}},ni={},vo={};function ie(a){let e=ti(ni,a);if(!e){let t=ti(vo,a);e=new zn({name:a,logLevel:t}),Vo(ni,a,e)}return e}import Wo from"toformat";var Eo=Wo,Yt=Eo;import wn from"big.js";import Oo from"bn.js";import Do from"decimal.js-light";import Zt from"bn.js";var ri=9007199254740991;function H(a){let e=ie("Raydium_parseBigNumberish");if(a instanceof Zt)return a;if(typeof a=="string"){if(a.match(/^-?[0-9]+$/))return new Zt(a);e.logWithError(`invalid BigNumberish string: ${a}`)}return typeof a=="number"?(a%1&&e.logWithError(`BigNumberish number underflow: ${a}`),(a>=ri||a<=-ri)&&e.logWithError(`BigNumberish number overflow: ${a}`),new Zt(String(a))):typeof a=="bigint"?new Zt(a.toString()):(e.error(`invalid BigNumberish value: ${a}`),new Zt(0))}var gn=ie("module/fraction"),jn=Yt(wn),Jt=Yt(Do),qo={[0]:Jt.ROUND_DOWN,[1]:Jt.ROUND_HALF_UP,[2]:Jt.ROUND_UP},Go={[0]:wn.roundDown,[1]:wn.roundHalfUp,[2]:wn.roundUp},te=class{constructor(e,t=new Oo(1)){this.numerator=H(e),this.denominator=H(t)}get quotient(){return this.numerator.div(this.denominator)}invert(){return new te(this.denominator,this.numerator)}add(e){let t=e instanceof te?e:new te(H(e));return this.denominator.eq(t.denominator)?new te(this.numerator.add(t.numerator),this.denominator):new te(this.numerator.mul(t.denominator).add(t.numerator.mul(this.denominator)),this.denominator.mul(t.denominator))}sub(e){let t=e instanceof te?e:new te(H(e));return this.denominator.eq(t.denominator)?new te(this.numerator.sub(t.numerator),this.denominator):new te(this.numerator.mul(t.denominator).sub(t.numerator.mul(this.denominator)),this.denominator.mul(t.denominator))}mul(e){let t=e instanceof te?e:new te(H(e));return new te(this.numerator.mul(t.numerator),this.denominator.mul(t.denominator))}div(e){let t=e instanceof te?e:new te(H(e));return new te(this.numerator.mul(t.denominator),this.denominator.mul(t.numerator))}toSignificant(e,t={groupSeparator:""},n=1){Number.isInteger(e)||gn.logWithError(`${e} is not an integer.`),e<=0&&gn.logWithError(`${e} is not positive.`),Jt.set({precision:e+1,rounding:qo[n]});let r=new Jt(this.numerator.toString()).div(this.denominator.toString()).toSignificantDigits(e);return r.toFormat(r.decimalPlaces(),t)}toFixed(e,t={groupSeparator:""},n=1){return Number.isInteger(e)||gn.logWithError(`${e} is not an integer.`),e<0&&gn.logWithError(`${e} is negative.`),jn.DP=e,jn.RM=Go[n]||1,new jn(this.numerator.toString()).div(this.denominator.toString()).toFormat(e,t)}isZero(){return this.numerator.isZero()}};var Xo=ie("Raydium_amount"),ii=Yt(Uo);function Qo(a,e){let t="0",n="0";if(a.includes(".")){let r=a.split(".");r.length===2?([t,n]=r,n=n.padEnd(e,"0")):Xo.logWithError(`invalid number string, num: ${a}`)}else t=a;return[t,n.slice(0,e)||n]}var be=class extends te{constructor(t,n,r=!0,s){let i=new kn(0),o=Hn.pow(new kn(t.decimals));if(r)i=H(n);else{let u=new kn(0),l=new kn(0);if(typeof n=="string"||typeof n=="number"||typeof n=="bigint"){let[c,m]=Qo(n.toString(),t.decimals);u=H(c),l=H(m)}u=u.mul(o),i=u.add(l)}super(i,o);this.logger=ie(s||"TokenAmount"),this.token=t}get raw(){return this.numerator}isZero(){return this.raw.isZero()}gt(t){return this.token.equals(t.token)||this.logger.logWithError("gt token not equals"),this.raw.gt(t.raw)}lt(t){return this.token.equals(t.token)||this.logger.logWithError("lt token not equals"),this.raw.lt(t.raw)}add(t){return this.token.equals(t.token)||this.logger.logWithError("add token not equals"),new be(this.token,this.raw.add(t.raw))}subtract(t){return this.token.equals(t.token)||this.logger.logWithError("sub token not equals"),new be(this.token,this.raw.sub(t.raw))}toSignificant(t=this.token.decimals,n,r=0){return super.toSignificant(t,n,r)}toFixed(t=this.token.decimals,n,r=0){return t>this.token.decimals&&this.logger.logWithError("decimals overflow"),super.toFixed(t,n,r)}toExact(t={groupSeparator:""}){return ii.DP=this.token.decimals,new ii(this.numerator.toString()).div(this.denominator.toString()).toFormat(t)}};import{PublicKey as zo}from"@solana/web3.js";import{TOKEN_PROGRAM_ID as oi}from"@solana/spl-token";var Yn={chainId:101,address:zo.default.toBase58(),programId:oi.toBase58(),decimals:9,symbol:"SOL",name:"solana",logoURI:"https://img-v1.raydium.io/icon/So11111111111111111111111111111111111111112.png",tags:[],priority:2,type:"raydium",extensions:{coingeckoId:"solana"}},rt={chainId:101,address:"So11111111111111111111111111111111111111112",programId:oi.toBase58(),decimals:9,symbol:"WSOL",name:"Wrapped SOL",logoURI:"https://img-v1.raydium.io/icon/So11111111111111111111111111111111111111112.png",tags:[],priority:2,type:"raydium",extensions:{coingeckoId:"solana"}};import{PublicKey as er}from"@solana/web3.js";import{PublicKey as le,SystemProgram as si,SYSVAR_RENT_PUBKEY as jo}from"@solana/web3.js";import{TOKEN_PROGRAM_ID as Ho}from"@solana/spl-token";function B({pubkey:a,isSigner:e=!1,isWritable:t=!0}){return{pubkey:a,isWritable:t,isSigner:e}}var Yo=[B({pubkey:Ho,isWritable:!1}),B({pubkey:si.programId,isWritable:!1}),B({pubkey:jo,isWritable:!1})];function Zn({publicKey:a,transformSol:e}){let t=Jn(a.toString());if(t instanceof le)return e&&t.equals(Wt)?vt:t;if(e&&t.toString()===Wt.toBase58())return vt;if(typeof t=="string"){if(t===le.default.toBase58())return le.default;try{return new le(t)}catch{throw new Error("invalid public key")}}throw new Error("invalid public key")}function Jn(a){try{return new le(a)}catch{return a}}var An=new le("MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr"),$n=new le("MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr"),Xe=new le("SysvarRent111111111111111111111111111111111"),hu=new le("SysvarC1ock11111111111111111111111111111111"),wt=new le("metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s"),Zo=new le("Sysvar1nstructions1111111111111111111111111"),xu=si.programId,Su=new le("4k3Dyjzvzp8eMZWUXbBCjEvwSkkk59S5iCNLY3QrkX6R"),Bu=new le("Ea5SjE2Y6yvCeW5dYTn7PYMuW5ikXkvbGdcmSnXeaLjS"),Iu=new le("SRMuApVNdxXokk5GT7XD5cUUgXMBCoAz2LHeuAoKWRt"),Ku=new le("EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v"),Lu=new le("Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB"),Ru=new le("mSoLzYCxHdYgdzU16g5QSh3i5K3z3KZK7ytfqcJm7So"),Cu=new le("7dHbWXmci3dT8UFYWYZweBLXgycu7Y3iL6trKn1Y7ARj"),Nu=new le("USDH1SM1ojwWUga67PGrgFWUHibbjqMvuMaDkRJTgkX"),Mu=new le("NRVwhjBQiUPYtfDT5zRBVJajzFQHaBUNtC7SNVvqRFa"),_u=new le("ANAxByE6G2WjFp7A4NqtWYXb3mgruyzZYg3spfxe6Lbo"),Vu=new le("7vfCXTUXx5WJV5JADk17DUJ4ksgau7utNKj4b963voxs"),vt=new le("So11111111111111111111111111111111111111112"),Wt=le.default;function Et(a){return Zn({publicKey:a,transformSol:!0})}var tr=class{constructor({mint:e,decimals:t,symbol:n,name:r,skipMint:s=!1,isToken2022:i=!1}){if(e===Wt.toBase58()||e instanceof er&&Wt.equals(e)){this.decimals=rt.decimals,this.symbol=rt.symbol,this.name=rt.name,this.mint=new er(rt.address),this.isToken2022=!1;return}this.decimals=t,this.symbol=n||e.toString().substring(0,6),this.name=r||e.toString().substring(0,6),this.mint=s?er.default:Zn({publicKey:e}),this.isToken2022=i}equals(e){return this===e?!0:this.mint.equals(e.mint)}},Ie=tr;Ie.WSOL=new tr(j(F({},rt),{mint:rt.address}));var nr=class{constructor({decimals:e,symbol:t="UNKNOWN",name:n="UNKNOWN"}){this.decimals=e,this.symbol=t,this.name=n}equals(e){return this===e}},Pn=nr;Pn.SOL=new nr(Yn);import Jo from"bn.js";var ai=new te(new Jo(100)),De=class extends te{toSignificant(e=5,t,n){return this.mul(ai).toSignificant(e,t,n)}toFixed(e=2,t,n){return this.mul(ai).toFixed(e,t,n)}};var $o=ie("Raydium_price"),qe=class extends te{constructor(t){let{baseToken:n,quoteToken:r,numerator:s,denominator:i}=t;super(s,i);this.baseToken=n,this.quoteToken=r,this.scalar=new te(rr(n.decimals),rr(r.decimals))}get raw(){return new te(this.numerator,this.denominator)}get adjusted(){return super.mul(this.scalar)}invert(){return new qe({baseToken:this.quoteToken,quoteToken:this.baseToken,denominator:this.numerator,numerator:this.denominator})}mul(t){this.quoteToken!==t.baseToken&&$o.logWithError("mul token not equals");let n=super.mul(t);return new qe({baseToken:this.baseToken,quoteToken:t.quoteToken,denominator:n.denominator,numerator:n.numerator})}toSignificant(t=this.quoteToken.decimals,n,r){return this.adjusted.toSignificant(t,n,r)}toFixed(t=this.quoteToken.decimals,n,r){return this.adjusted.toFixed(t,n,r)}};import{PublicKey as es}from"@solana/web3.js";import ts from"bn.js";function ui(a){return typeof a=="object"&&a!==null&&![Ie,be,es,te,ts,qe,De].some(e=>typeof e=="object"&&a instanceof e)}function kt(a){return typeof a=="string"?Jn(a):Array.isArray(a)?a.map(e=>kt(e)):ui(a)?Object.fromEntries(Object.entries(a).map(([e,t])=>[e,kt(t)])):a}var mt=new it(0),ci=new it(1),Cc=new it(2),Nc=new it(3),Mc=new it(5),Hn=new it(10),_c=new it(100),Vc=new it(1e3),vc=new it(1e4);function rr(a){return Hn.pow(H(a))}function Tn(a,e){let t=a.divmod(e);return t.mod.isZero()?t.div:t.div.isNeg()?t.div.isubn(1):t.div.iaddn(1)}function ir(a,e=1,t=[]){let n=[...a];if(e<=0)return t;for(;n.length;)t.push(n.splice(0,e));return t}import{PublicKey as us}from"@solana/web3.js";import{TOKEN_PROGRAM_ID as cs}from"@solana/spl-token";import{ComputeBudgetProgram as li,Keypair as di,PublicKey as ns,Transaction as pi,TransactionMessage as rs,VersionedTransaction as fi}from"@solana/web3.js";var U={CreateAccount:"CreateAccount",InitAccount:"InitAccount",CreateATA:"CreateATA",CloseAccount:"CloseAccount",TransferAmount:"TransferAmount",InitMint:"InitMint",MintTo:"MintTo",InitMarket:"InitMarket",Util1216OwnerClaim:"Util1216OwnerClaim",SetComputeUnitPrice:"SetComputeUnitPrice",SetComputeUnitLimit:"SetComputeUnitLimit",ClmmCreatePool:"ClmmCreatePool",ClmmOpenPosition:"ClmmOpenPosition",ClmmIncreasePosition:"ClmmIncreasePosition",ClmmDecreasePosition:"ClmmDecreasePosition",ClmmClosePosition:"ClmmClosePosition",ClmmSwapBaseIn:"ClmmSwapBaseIn",ClmmSwapBaseOut:"ClmmSwapBaseOut",ClmmInitReward:"ClmmInitReward",ClmmSetReward:"ClmmSetReward",ClmmCollectReward:"ClmmCollectReward",ClmmLockPosition:"ClmmLockPosition",ClmmHarvestLockPosition:"ClmmHarvestLockPosition",AmmV4Swap:"AmmV4Swap",AmmV4AddLiquidity:"AmmV4AddLiquidity",AmmV4RemoveLiquidity:"AmmV4RemoveLiquidity",AmmV4SimulatePoolInfo:"AmmV4SimulatePoolInfo",AmmV4SwapBaseIn:"AmmV4SwapBaseIn",AmmV4SwapBaseOut:"AmmV4SwapBaseOut",AmmV4CreatePool:"AmmV4CreatePool",AmmV4InitPool:"AmmV4InitPool",AmmV5AddLiquidity:"AmmV5AddLiquidity",AmmV5RemoveLiquidity:"AmmV5RemoveLiquidity",AmmV5SimulatePoolInfo:"AmmV5SimulatePoolInfo",AmmV5SwapBaseIn:"AmmV5SwapBaseIn",AmmV5SwapBaseOut:"AmmV5SwapBaseOut",RouteSwap:"RouteSwap",RouteSwap1:"RouteSwap1",RouteSwap2:"RouteSwap2",FarmV3Deposit:"FarmV3Deposit",FarmV3Withdraw:"FarmV3Withdraw",FarmV3CreateLedger:"FarmV3CreateLedger",FarmV4Withdraw:"FarmV4Withdraw",FarmV5Deposit:"FarmV5Deposit",FarmV5Withdraw:"FarmV5Withdraw",FarmV5CreateLedger:"FarmV5CreateLedger",FarmV6Deposit:"FarmV6Deposit",FarmV6Withdraw:"FarmV6Withdraw",FarmV6Create:"FarmV6Create",FarmV6Restart:"FarmV6Restart",FarmV6CreatorAddReward:"FarmV6CreatorAddReward",FarmV6CreatorWithdraw:"FarmV6CreatorWithdraw",CpmmCreatePool:"CpmmCreatePool",CpmmAddLiquidity:"CpmmAddLiquidity",CpmmWithdrawLiquidity:"CpmmWithdrawLiquidity",CpmmSwapBaseIn:"CpmmSwapBaseIn",CpmmSwapBaseOut:"CpmmSwapBaseOut",CpmmLockLp:"CpmmLockLp",CpmmCollectLockFee:"CpmmCollectLockFee",TransferTip:"TransferTip"};import{TOKEN_PROGRAM_ID as is}from"@solana/spl-token";var mi=ie("Raydium_txUtil"),bi=1644;function hn(a){let e=[],t=[];return a.microLamports&&(e.push(li.setComputeUnitPrice({microLamports:a.microLamports})),t.push(U.SetComputeUnitPrice)),a.units&&(e.push(li.setComputeUnitLimit({units:a.units})),t.push(U.SetComputeUnitLimit)),{instructions:e,instructionTypes:t}}async function Ft(a,e){var n,r;let t=e!=null?e:"confirmed";return(r=await((n=a.getLatestBlockhash)==null?void 0:n.call(a,{commitment:t})))==null?void 0:r.blockhash}async function xn(a,e){return a.getSignatureStatuses([e]),new Promise((t,n)=>{let r=setTimeout(n,6e4);a.onSignature(e,s=>{if(clearTimeout(r),!s.err){t("");return}n(Object.assign(s.err,{txId:e}))},"confirmed")})}function os(a,e){a.length<1&&mi.logWithError(`no instructions provided: ${a.toString()}`),e.length<1&&mi.logWithError(`no signers provided:, ${e.toString()}`);let t=new pi;t.recentBlockhash="11111111111111111111111111111111",t.feePayer=e[0],t.add(...a);try{return Buffer.from(t.serialize({verifySignatures:!1})).toString("base64").length<bi}catch{return!1}}function de(a,e){let[t,n]=ns.findProgramAddressSync(a,e);return{publicKey:t,nonce:n}}function $t({instructions:a,payer:e,signers:t}){return os(a,[e,...t])}function en({instructions:a,payer:e,lookupTableAddressAccount:t,recentBlockhash:n=di.generate().publicKey.toString()}){let s=new rs({payerKey:e,recentBlockhash:n,instructions:a}).compileToV0Message(Object.values(t!=null?t:{}));try{return Buffer.from(new fi(s).serialize()).toString("base64").length<bi}catch{return!1}}var ss=a=>Buffer.isBuffer(a)?a:a instanceof Uint8Array?Buffer.from(a.buffer,a.byteOffset,a.byteLength):Buffer.from(a),as=a=>{let e=a.serialize({requireAllSignatures:!1,verifySignatures:!1});a instanceof fi&&(e=ss(e));try{return e instanceof Buffer?e.toString("base64"):Buffer.from(e).toString("base64")}catch{return e.toString("base64")}};function At(a){let e=[];return a.forEach(t=>{t instanceof pi&&(t.recentBlockhash||(t.recentBlockhash=is.toBase58()),t.feePayer||(t.feePayer=di.generate().publicKey)),e.push(as(t))}),console.log("simulate tx string:",e),e}function ae(a,e,t){return de([a.toBuffer(),(t!=null?t:cs).toBuffer(),e.toBuffer()],new us("ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL"))}import{PublicKey as O}from"@solana/web3.js";var yi=new O("EhhTKczWMGQt46ynNeRX1WfeagwwJd7ufHvCDjRxjo5Q"),gi=new O("CBuCnLe26faBpcBP2fktp4rp8abpcAnTWft6ZrP5Q4T"),wi=new O("9KEPoZmtHUrBbhWN1v1KWLMkkvwY6WLtAVUCPRtRjP4z"),ki=new O("FarmqiPv5eAj3j1GMdMCMUGXqPUvmquZtMy86QH6rzhG"),rl=new O("CLaimxFqjHzgTJtAGHU47NPhg6qrc5sCnpC4tBLyABQS"),Ai=new O("srmqPvymJeFKQ4zGQed1GFppgkRHL9kaELCbyksJtPX"),il=new O("9xQeWvG816bUx9EPjHmaT23yvVM2ZWbrrpZb9PusVFin"),Pi=new O("675kPX9MHTjS2zt1qfr1NYHuzeLXfQM9H24wFSUt1Mp8"),ol=new O("5quBtoiQqxF9Jv6KYKctB59NT3gtJD2Y65kdnB1Uev3h"),sl=new O("CDSr3ssLcRB6XYPJwAfFt18MZvEZp4LjHcvzBVZ45duo"),al=new O("CAMMCzo5YL8w4VFF8KVHrK22GGUsp5VTaW7grrKgrWqK"),ul=new O("LockrWmn6K5twhz3y9w1dQERbmgSaRkfnTeTKbpofwE"),cl=new O("kN1kEznaF5Xbd8LYuqtEFcxzWSBk5Fv6ygX6SqEGJVy"),Pt=new O("CDSr3ssLcRB6XYPJwAfFt18MZvEZp4LjHcvzBVZ45duo"),ll=new O("routeUGWgWzqBWFcrCfv8tritsqukccJPu3q5GPP3xS"),Ti=new O("7YttLkHDoNj9wyDur5pM1ejNaAvT9X4eqaYcHQqtj2G5"),ml=new O("6FJon3QE27qgPVggARueB22hLvoh22VzJpXv4rBEoSLF"),dl=new O("CC12se5To1CdEuw7fDS27B7Geo5jJyL7t5UK2B44NgiH"),pl=new O("9HzJyW1qZsEiSfMUf6L2jo3CcTKAyBmSyKdwQeYisHrC"),fl=new O("DropEU8AvevN3UrXWXTMuz3rqnMczQVNjq3kcSdW2SQi"),bl=new O("CPMMoo8L3F4NbTegBCKVNunggL7H1ZpdTHKxQB5qKP1C"),yl=new O("GpMZbSM2GgvTKHJirzeGfMFoaZ8UR2X7F4v8vHTvxFbL"),gl=new O("DNXgeM9EiiaAbaWvwjHj9fQQLAX5ZsfHyvmYUNRAdNC8"),wl=new O("LockrWmn6K5twhz3y9w1dQERbmgSaRkfnTeTKbpofwE"),kl=new O("3f7GcQFG397GAaEnv51zR6tsTVihYRydnydDD1cXekxH"),Al=new O("LanMV9sAd7wArD4vJFi2qDdfnVhFxYSUg6eADduJ3uj"),Pl=new O("WLHv2UAZm6z4KyaaELi5pjdbJh6RESMva1Rnn8pJVVh"),Tl=new O("DRay6fNdQ5J82H7xV6uq2aV3mNrUZ1J4PgSKsWgptcm6"),hl=new O("5xqNaZXX5eUi4p5HU4oz9i5QnwRNT2y6oN7yyn4qENeq"),xl=new O("4Bu96XjU84XjPDSpveTVf6LYGCkfW5FK7SNkREWcEfV4"),Sl=new O("6s1xP3hpbAfFoNtUNF8mfHsjr2Bd97JxFJRWLbL6aHuX");var Tt={OPEN_BOOK_PROGRAM:new O("EoTcMgcDRTJVZDMZWBoU6rhYHZfkNTVEAfz3uUJRcYGj"),SERUM_PROGRAM_ID_V3:new O("Ray1111111111111111111111111111111111111111"),AMM_V4:new O("DRaya7Kj3aMWQSy19kSjvmuwq9docCHofyP9kanQGaav"),AMM_STABLE:new O("DRayDdXc1NZQ9C3hRWmoSf8zK4iapgMnjdNZWrfwsP8m"),CLMM_PROGRAM_ID:new O("DRayAUgENGQBKVaX8owNhgzkEDyoHTGVEGHVJT1E9pfH"),CLMM_LOCK_PROGRAM_ID:new O("DRay25Usp3YJAi7beckgpGUC7mGJ2cR1AVPxhYfwVCUX"),CLMM_LOCK_AUTH_ID:new O("6Aoh8h2Lw2m5UGxYR8AdAL87jTWYeKoxM52mJRzfYwN"),CREATE_CPMM_POOL_PROGRAM:new O("DRaycpLY18LhpbydsBWbVJtxpNv9oXPgjRSfpF2bWpYb"),CREATE_CPMM_POOL_AUTH:new O("CXniRufdq5xL8t8jZAPxsPZDpuudwuJSPWnbcD5Y5Nxq"),CREATE_CPMM_POOL_FEE_ACC:new O("3oE58BKVt8KuYkGxx8zBojugnymWmBiyafWgMrnb6eYy"),LOCK_CPMM_PROGRAM:new O("DRay25Usp3YJAi7beckgpGUC7mGJ2cR1AVPxhYfwVCUX"),LOCK_CPMM_AUTH:new O("7qWVV8UY2bRJfDLP4s37YzBPKUkVB46DStYJBpYbQzu3"),UTIL1216:O.default,Router:new O("DRaybByLpbUL57LJARs3j8BitTxVfzBg351EaMr5UTCd"),FARM_PROGRAM_ID_V3:new O("DRayWyrLmEW5KEeqs8kdTMMaBabapqagaBC7KWpGtJeZ"),FARM_PROGRAM_ID_V4:new O("Ray1111111111111111111111111111111111111111"),FARM_PROGRAM_ID_V5:new O("DRayiCGSZgku1GTK6rXD6mVDdingXy6APAH1R6R5L2LC"),FARM_PROGRAM_ID_V6:new O("DRayzbYakXs45ELHkzH6vC3fuhQqTAnv5A68gdFuvZyZ"),LAUNCHPAD_PROGRAM:new O("DRay6fNdQ5J82H7xV6uq2aV3mNrUZ1J4PgSKsWgptcm6"),LAUNCHPAD_AUTH:new O("5xqNaZXX5eUi4p5HU4oz9i5QnwRNT2y6oN7yyn4qENeq"),LAUNCHPAD_PLATFORM:new O("2Jx4KTDrVSdWNazuGpcA8n3ZLTRGGBDxAWhuKe2Xcj2a"),LAUNCHPAD_CONFIG:new O("7ZR4zD7PYfY2XxoG1Gxcy2EgEeGYrpxrwzPuwdUBssEt"),FEE_DESTINATION_ID:new O("9y8ENuuZ3b19quffx9hQvRVygG5ky6snHfRvGpuSfeJy"),MODEL_DATA_PUBKEY:new O("Ray1111111111111111111111111111111111111111")};import Qe from"bn.js";var tn=1e4;function ye(a,e,t,n){if(e===void 0)return{amount:a,fee:void 0,expirationTime:void 0};let r=j(F({},e),{olderTransferFee:{epoch:BigInt(e.olderTransferFee.epoch),maximumFee:BigInt(e.olderTransferFee.maximumFee),transferFeeBasisPoints:e.olderTransferFee.transferFeeBasisPoints},newerTransferFee:{epoch:BigInt(e.newerTransferFee.epoch),maximumFee:BigInt(e.newerTransferFee.maximumFee),transferFeeBasisPoints:e.newerTransferFee.transferFeeBasisPoints}}),s=t.epoch<r.newerTransferFee.epoch?r.olderTransferFee:r.newerTransferFee,i=new Qe(s.maximumFee.toString()),o=t.epoch<r.newerTransferFee.epoch?(Number(r.newerTransferFee.epoch)*t.slotsInEpoch-t.absoluteSlot)*400/1e3:void 0;if(n)if(s.transferFeeBasisPoints===tn){let u=new Qe(s.maximumFee.toString());return{amount:a.add(u),fee:u,expirationTime:o}}else{let u=nn(a.mul(new Qe(tn)),new Qe(tn-s.transferFeeBasisPoints)),l=new Qe(s.maximumFee.toString()),c=u.sub(a).gt(l)?a.add(l):u,m=nn(c.mul(new Qe(s.transferFeeBasisPoints)),new Qe(tn)),p=m.gt(i)?i:m;return{amount:c,fee:p,expirationTime:o}}else{let u=nn(a.mul(new Qe(s.transferFeeBasisPoints)),new Qe(tn)),l=u.gt(i)?i:u;return{amount:a,fee:l,expirationTime:o}}}function dt(a,e){return a===void 0?e:e===void 0?a:Math.min(a,e)}function nn(a,e){let{div:t,mod:n}=a.divmod(e);return n.gt(new Qe(0))?t.add(new Qe(1)):t}import{PublicKey as or,AddressLookupTableAccount as Dt}from"@solana/web3.js";async function sr({connection:a,address:e,cluster:t="mainnet"}){let n=await ot(a,[...new Set(e.map(s=>s.toString()))].map(s=>new or(s))),r={};for(let s=0;s<e.length;s++){let i=n[s],o=e[s];if(!i)continue;let u=new Dt({key:o,state:Dt.deserialize(i.data)});r[o.toString()]=u,t==="devnet"?Ot[o.toString()]=u:Sn[o.toString()]=u}return r}var Sn={AcL1Vo8oy1ULiavEcjSUcwfBSForXMudcZvDZy5nzJkU:new Dt({key:new or("AcL1Vo8oy1ULiavEcjSUcwfBSForXMudcZvDZy5nzJkU"),state:Dt.deserialize(Buffer.from("AQAAAP//////////I1rcEwAAAAAvAQYwun9CU6c5Ikm2pAj+D9IEnCOR45nK+SFTGSdpd6J6AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAbd9uHXZaGT2cvhRs7reawctIXtX1s3kTqM9YV+/wCpBt324e51j94YQl285GzN2rYa/E2DuQ0n/r35KNihi/wFSlNQ+F3IgtYUpVZyeIopbd8eq6vQpgZ4iEky9O72oAVKU1qZKSEGTSTocWDaOHx8NbXdvJK7geQfqEBBBUSNBqfVFxksXFEhjMlMPUrxf1ja7gibof1E49vZigAAAAAGp9UXGMd0yShWY5hpHV62i164o5tLbVxzVVshAAAAAIyXJY9OJInxuz0QKRSODYMLWhOZ2v8QhASOe9jb6fhZC3BlsePRfEU4nVJ/awTDzVi4bHMaoP21SbbRvAP4KUbIScv+6Yw2LHF/6K0ZjUPibbSWXCirYPGuuVl7zT789IUPLW4CpHr4JNCatp3ELXDLKMv6JJ+37le50lbBJ2LvBkX2T9y7AHdNGviJAqQNtlDUDCnauQRWybsLji6nPM8Qkw5asQRvCdB3MbX6IEBwytOrpM32l4jQygKG9TKgR0vZScQ2AsM/IHeQ7RajUkyhuZdc8SGiqQz/7H34torNR/Wir3sl0ruUrVxJWEZfUg+QLNAxxODdBi53/OP7Ioil1cqeBM9dtZC3FLov4yyxWRM/wcGStyJX/QfTnLBAHqkqWotPKVlShCVQqpP9W5W1rOao65IMk5QuQ2kMIOxzDMKAy2vjGSxQODgBz0QwGA+eP4ZjIjrIAQaXENv31QfLlOdXSRCkaybRniDHF4C8YcwhcvsqrOVuTP4B2Na+9wLdtrB31uz2rtlFI5kahdsnp/d1SrASDInYCtTYtdoke4kX+hoKWcEWM4Tle8pTUkUVv4BxS6fje/EzKBE4Qu/YsA/yfEEFGcr8Z57VKDw8uQzpiru7g4lvjnfapW62W030syevD8k07SGoxUHiuT/ai7gAHWWhDsVmg/C63ajgpkH7Sn3GdutArDTfyqOkdqv4/IPC/EFFy7mGkfDd2C57N5a/4jC+BbmJy7wQaSEZr0CQU88lPtUxIVvzGjC95b8Ooss2TqmkrayGKofkPMGQn7Ux+9lfwBSNfxwH8NgbpqC/7LNlV4I7nCvsXf3p+ohQk9NrAJb2KAFpUqEIJ9ZBV7BYDzHF/ORKYlgtvPnXjudZQ6CEo5OzUDaNIomTCCsvhD16TxJjsbgne1kGnQPCFSoaxUbq2V1bPMFQ3VYP6wDZ9bKStCFKx9A3tNbwZFC5ZGAN83MFK7XoTy+OmmcFEr6rLOjfSuTfPvHJkSVxW6Qllwkl67XcBi5v00u2gQsbu+38sp+rd5pA/LvyWj4P94ZGZwc1tE2P88xekCLcAwZGb+UhFzL/7K26csOb57yM5bvF9xJrLEObOkAAAAAn+HWRkdcPKyFFMnVwEoD7vnD0jCKFIU1sImubYCxNTSVzsKpaQX+fzNxrLAI3L14JQnJx/D6Uk2LADIHGqnGELzjEbkBDAlaM77NkXMPfqXNLSveCkWI7UEgNs31WEWB6XHSYI/v5DklHOb4QTtDOR804PVbi3fjloZeLR2F8d4FuZmMMO7ck3Fnkn2zEMG5gOmqsygb6PjTitArVl52NhcSznTxVnguaIJxiZkAnurDmn3MWR0PC2GLghp2KJqHCc6QQ85odeIjFHKOlRlJyeSXVJmL8vb1UgOzsbJPVP8p6zM4M3C1Sd7uWIHP33G42AP2Zg8ucn/n6meQjjD266JgCWdxZD6PXs9CsnIeL7SSG0/6lGb9xfP0ZcWkCXB/3hjxHYVXjra/GPOeXGk0fLLKjCbk+mgs2w6d2oCwimBipTzuoZ30GiI8ij8VRzD5CzMWtu2m21eDBIfjGAEo4pQeNNonKcqzV/cleX8ySZLOHsz8PtBCrLqF+VkLm9hOzIT+6i/nIf6keR4GWKMOD4AvqfpjHoD4DuhBpz8P28+DxkGrDXXr/nr20x291VPvcTU/b+b+o2kC9G0kcXeTlLjU6a2TQXWlZ4gBUdBl1jgT7mObSTpLblNiXZsLkbmVXZwvFKXua5cUKlWed/w30skmEUraTuQqtqr5fHZPW9n57EmeTif6LjHL2YJFZkQU+TrJmFzqzmF4/b8OwrPQAprl8mX3q4LUIdAS/a+11B6DWD1Xk2++Sn94dLC4xjkO4Wtlw8c4XuzciVbepHOmnoWzVu/0y3KCrLCSfQxQ3br8DJCoVzhgtPsS2nZZjsBGIZgnU0QpMv+2MnRsnKwdp1VsrCX84j/qvaZn4WhKunippgTbN2EUs0tPTP55Qfgj+nKmjtWW5IYs72FrEwJKYoNfsmqaF4o5pf4v9zgPwVwY/5I4XJKUL2L25m9kAQcW/K+H1RTFEUoj8Z4ajpOmAB/dG0COmCphVMW2CCMvnxhcGiSgPnpDuWu6qiJ7NG7ye5kvHgefgqPLeicspNJ5EpL3XiRNLM2tmJLI1awAwOyd6iHv0dCkMYRKaa6rcaZeYwmKCkckm0kM2JNmnmmAaBQQ7mwmIM0IMxX4f5W6j9PqZWcJxF7r17T/lQBAmcjoupRiJifbnXCNUv9GhpRF19WcBdeKbivRJVlGop6I2RS6lGImJ9udcI1S/0aGlEXX1ZwF14puK9ElWUainojZFYVHLHD6dIP2ESjqBzg3ol1/wB7+/ylGwd9LS7wSZ2A630CJSVKwH47K9P4bB8PEQP8BwjMFa7xQHOqZFP1XqaQ==","base64"))})},Ot={},ar=async a=>{let e="EFhMuDw1PKEuckuFRW9PavNfTH4LKP5uKHgyXDmWpFCq";if(Ot[e])return Ot;let t=new or(e),n=await a.getAccountInfo(t);return n&&(Ot[e]=new Dt({key:t,state:Dt.deserialize(n.data)})),Ot};import{PublicKey as qt,sendAndConfirmTransaction as ur,SystemProgram as ls,Transaction as rn,TransactionMessage as on,VersionedTransaction as sn}from"@solana/web3.js";import ms from"axios";var Bn=2e3,In=class{constructor(e){this.instructions=[];this.endInstructions=[];this.lookupTableAddress=[];this.signers=[];this.instructionTypes=[];this.endInstructionTypes=[];this.connection=e.connection,this.feePayer=e.feePayer,this.signAllTransactions=e.signAllTransactions,this.owner=e.owner,this.cluster=e.cluster,this.blockhashCommitment=e.blockhashCommitment,this.loopMultiTxStatus=!!e.loopMultiTxStatus}get AllTxData(){return{instructions:this.instructions,endInstructions:this.endInstructions,signers:this.signers,instructionTypes:this.instructionTypes,endInstructionTypes:this.endInstructionTypes,lookupTableAddress:this.lookupTableAddress}}get allInstructions(){return[...this.instructions,...this.endInstructions]}async getComputeBudgetConfig(){var n;let e=(await ms.get(`https://solanacompass.com/api/fees?cacheFreshTime=${3e5}`)).data,{avg:t}=(n=e==null?void 0:e[15])!=null?n:{};if(!!t)return{units:6e5,microLamports:Math.min(Math.ceil(t*1e6/6e5),25e3)}}addCustomComputeBudget(e){if(e){let{instructions:t,instructionTypes:n}=hn(e);return this.instructions.unshift(...t),this.instructionTypes.unshift(...n),!0}return!1}addTipInstruction(e){var t;return e?(this.endInstructions.push(ls.transfer({fromPubkey:(t=e.feePayer)!=null?t:this.feePayer,toPubkey:new qt(e.address),lamports:BigInt(e.amount.toString())})),this.endInstructionTypes.push(U.TransferTip),!0):!1}async calComputeBudget({config:e,defaultIns:t}){try{let n=e||await this.getComputeBudgetConfig();if(this.addCustomComputeBudget(n))return;t&&this.instructions.unshift(...t)}catch{t&&this.instructions.unshift(...t)}}addInstruction({instructions:e=[],endInstructions:t=[],signers:n=[],instructionTypes:r=[],endInstructionTypes:s=[],lookupTableAddress:i=[]}){return this.instructions.push(...e),this.endInstructions.push(...t),this.signers.push(...n),this.instructionTypes.push(...r),this.endInstructionTypes.push(...s),this.lookupTableAddress.push(...i.filter(o=>o!==qt.default.toString())),this}async versionBuild({txVersion:e,extInfo:t}){return e===0?await this.buildV0(F({},t||{})):this.build(t)}build(e){var n;let t=new rn;return this.allInstructions.length&&t.add(...this.allInstructions),t.feePayer=this.feePayer,((n=this.owner)==null?void 0:n.signer)&&!this.signers.some(r=>r.publicKey.equals(this.owner.publicKey))&&this.signers.push(this.owner.signer),{builder:this,transaction:t,signers:this.signers,instructionTypes:[...this.instructionTypes,...this.endInstructionTypes],execute:async r=>{var c;let{recentBlockHash:s,skipPreflight:i=!0,sendAndConfirm:o,notSendToRpc:u}=r||{},l=s!=null?s:await Ft(this.connection,this.blockhashCommitment);if(t.recentBlockhash=l,this.signers.length&&t.sign(...this.signers),At([t]),(c=this.owner)!=null&&c.isKeyPair)return{txId:o?await ur(this.connection,t,this.signers.find(p=>p.publicKey.equals(this.owner.publicKey))?this.signers:[...this.signers,this.owner.signer],{skipPreflight:i}):await this.connection.sendRawTransaction(t.serialize(),{skipPreflight:i}),signedTx:t};if(this.signAllTransactions){let m=await this.signAllTransactions([t]);if(this.signers.length)for(let p of m)try{p.sign(...this.signers)}catch{}return{txId:u?"":await this.connection.sendRawTransaction(m[0].serialize(),{skipPreflight:i}),signedTx:m[0]}}throw new Error("please provide owner in keypair format or signAllTransactions function")},extInfo:e||{}}}buildMultiTx(e){var l;let{extraPreBuildData:t=[],extInfo:n}=e,{transaction:r}=this.build(n),s=t.filter(c=>c.transaction.instructions.length>0),i=[r,...s.map(c=>c.transaction)],o=[this.signers,...s.map(c=>c.signers)],u=[...this.instructionTypes,...s.map(c=>c.instructionTypes).flat()];return(l=this.owner)!=null&&l.signer&&o.forEach(c=>{c.some(m=>m.publicKey.equals(this.owner.publicKey))||this.signers.push(this.owner.signer)}),{builder:this,transactions:i,signers:o,instructionTypes:u,execute:async c=>{var g;let{sequentially:m,onTxUpdate:p,skipTxCount:d=0,recentBlockHash:b,skipPreflight:y=!0}=c||{},w=b!=null?b:await Ft(this.connection,this.blockhashCommitment);if((g=this.owner)!=null&&g.isKeyPair){if(m){let A=[],T=0;for(let h of i){if(++T,T<=d)continue;let P=await ur(this.connection,h,this.signers.find(k=>k.publicKey.equals(this.owner.publicKey))?this.signers:[...this.signers,this.owner.signer],{skipPreflight:y});A.push(P)}return{txIds:A,signedTxs:i}}return{txIds:await await Promise.all(i.map(async A=>(A.recentBlockhash=w,await this.connection.sendRawTransaction(A.serialize(),{skipPreflight:y})))),signedTxs:i}}if(this.signAllTransactions){let A=i.map((h,P)=>(h.recentBlockhash=w,o[P].length&&h.sign(...o[P]),h));At(A);let T=await this.signAllTransactions(A);if(m){let h=0,P=[],k=async()=>{if(!T[h])return;let S=await this.connection.sendRawTransaction(T[h].serialize(),{skipPreflight:y});P.push({txId:S,status:"sent",signedTx:T[h]}),p==null||p([...P]),h++;let I=!1,L=null,x=null,_=v=>{L!==null&&clearInterval(L),x!==null&&this.connection.removeSignatureListener(x);let V=P.findIndex(G=>G.txId===S);if(V>-1){if(P[V].status==="error"||P[V].status==="success")return;P[V].status=v.err?"error":"success"}p==null||p([...P]),v.err||k()};this.loopMultiTxStatus&&(L=setInterval(async()=>{var v;if(I){clearInterval(L);return}try{let V=await this.connection.getTransaction(S,{commitment:"confirmed",maxSupportedTransactionVersion:0});V&&(I=!0,clearInterval(L),_({err:((v=V.meta)==null?void 0:v.err)||null}),console.log("tx status from getTransaction:",S))}catch(V){I=!0,clearInterval(L),console.error("getTransaction timeout:",V,S)}},Bn)),x=this.connection.onSignature(S,v=>{if(I){this.connection.removeSignatureListener(x);return}I=!0,_(v)},"confirmed"),this.connection.getSignatureStatus(S)};return await k(),{txIds:P.map(S=>S.txId),signedTxs:T}}else{let h=[];for(let P=0;P<T.length;P+=1){let k=await this.connection.sendRawTransaction(T[P].serialize(),{skipPreflight:y});h.push(k)}return{txIds:h,signedTxs:T}}}throw new Error("please provide owner in keypair format or signAllTransactions function")},extInfo:n||{}}}async versionMultiBuild({extraPreBuildData:e,txVersion:t,extInfo:n}){return t===0?await this.buildV0MultiTx({extraPreBuildData:e,buildProps:n||{}}):this.buildMultiTx({extraPreBuildData:e,extInfo:n})}async buildV0(e){var y;let b=e||{},{lookupTableCache:t={},lookupTableAddress:n=[],forerunCreate:r,recentBlockhash:s}=b,i=Oe(b,["lookupTableCache","lookupTableAddress","forerunCreate","recentBlockhash"]),o=F(F({},this.cluster==="devnet"?await ar(this.connection):Sn),t),u=Array.from(new Set([...n,...this.lookupTableAddress])),l=[];for(let w of u)o[w]===void 0&&l.push(new qt(w));let c=await sr({connection:this.connection,address:l});for(let[w,g]of Object.entries(c))o[w]=g;let m=r?qt.default.toBase58():s!=null?s:await Ft(this.connection,this.blockhashCommitment),p=new on({payerKey:this.feePayer,recentBlockhash:m,instructions:[...this.allInstructions]}).compileToV0Message(Object.values(o));((y=this.owner)==null?void 0:y.signer)&&!this.signers.some(w=>w.publicKey.equals(this.owner.publicKey))&&this.signers.push(this.owner.signer);let d=new sn(p);return d.sign(this.signers),{builder:this,transaction:d,signers:this.signers,instructionTypes:[...this.instructionTypes,...this.endInstructionTypes],execute:async w=>{var h;let{skipPreflight:g=!0,sendAndConfirm:A,notSendToRpc:T}=w||{};if(At([d]),(h=this.owner)!=null&&h.isKeyPair){let P=await this.connection.sendTransaction(d,{skipPreflight:g});return A&&await xn(this.connection,P),{txId:P,signedTx:d}}if(this.signAllTransactions){let P=await this.signAllTransactions([d]);if(this.signers.length)for(let k of P)try{k.sign(this.signers)}catch{}return{txId:T?"":await this.connection.sendTransaction(P[0],{skipPreflight:g}),signedTx:P[0]}}throw new Error("please provide owner in keypair format or signAllTransactions function")},extInfo:i||{}}}async buildV0MultiTx(e){var l;let{extraPreBuildData:t=[],buildProps:n}=e,{transaction:r}=await this.buildV0(n),s=t.filter(c=>c.builder.instructions.length>0),i=[r,...s.map(c=>c.transaction)],o=[this.signers,...s.map(c=>c.signers)],u=[...this.instructionTypes,...s.map(c=>c.instructionTypes).flat()];return(l=this.owner)!=null&&l.signer&&o.forEach(c=>{c.some(m=>m.publicKey.equals(this.owner.publicKey))||this.signers.push(this.owner.signer)}),i.forEach(async(c,m)=>{c.sign(o[m])}),{builder:this,transactions:i,signers:o,instructionTypes:u,buildProps:n,execute:async c=>{var y;let{sequentially:m,onTxUpdate:p,recentBlockHash:d,skipPreflight:b=!0}=c||{};if(d&&i.forEach(w=>w.message.recentBlockhash=d),At(i),(y=this.owner)!=null&&y.isKeyPair){if(m){let w=[];for(let g of i){let A=await this.connection.sendTransaction(g,{skipPreflight:b});await xn(this.connection,A),w.push(A)}return{txIds:w,signedTxs:i}}return{txIds:await Promise.all(i.map(async w=>await this.connection.sendTransaction(w,{skipPreflight:b}))),signedTxs:i}}if(this.signAllTransactions){let w=await this.signAllTransactions(i);if(m){let g=0,A=[],T=async()=>{if(!w[g])return;let h=await this.connection.sendTransaction(w[g],{skipPreflight:b});A.push({txId:h,status:"sent",signedTx:w[g]}),p==null||p([...A]),g++;let P=!1,k=null,S=null,I=L=>{k!==null&&clearInterval(k),S!==null&&this.connection.removeSignatureListener(S);let x=A.findIndex(_=>_.txId===h);if(x>-1){if(A[x].status==="error"||A[x].status==="success")return;A[x].status=L.err?"error":"success"}p==null||p([...A]),L.err||T()};this.loopMultiTxStatus&&(k=setInterval(async()=>{var L;if(P){clearInterval(k);return}try{let x=await this.connection.getTransaction(h,{commitment:"confirmed",maxSupportedTransactionVersion:0});x&&(P=!0,clearInterval(k),I({err:((L=x.meta)==null?void 0:L.err)||null}),console.log("tx status from getTransaction:",h))}catch(x){P=!0,clearInterval(k),console.error("getTransaction timeout:",x,h)}},Bn)),S=this.connection.onSignature(h,L=>{if(P){this.connection.removeSignatureListener(S);return}P=!0,I(L)},"confirmed"),this.connection.getSignatureStatus(h)};return T(),{txIds:[],signedTxs:w}}else{let g=[];for(let A=0;A<w.length;A+=1){let T=await this.connection.sendTransaction(w[A],{skipPreflight:b});g.push(T)}return{txIds:g,signedTxs:w}}}throw new Error("please provide owner in keypair format or signAllTransactions function")},extInfo:n||{}}}async sizeCheckBuild(e){var p;let m=e||{},{splitIns:t=[],computeBudgetConfig:n}=m,r=Oe(m,["splitIns","computeBudgetConfig"]),s=n?hn(n):{instructions:[],instructionTypes:[]},i=this.signers.reduce((d,b)=>j(F({},d),{[b.publicKey.toBase58()]:b}),{}),o=[],u=[],l=[],c=0;if(this.allInstructions.forEach(d=>{let b=[...l,d],y=n?[...s.instructions,...b]:b,g=[...new Set(b.map(A=>A.keys.filter(T=>T.isSigner).map(T=>T.pubkey.toString())).flat()).values()].map(A=>new qt(A));if(d!==t[c]&&l.length<12&&($t({instructions:y,payer:this.feePayer,signers:g})||$t({instructions:b,payer:this.feePayer,signers:g})))l.push(d);else{if(l.length===0)throw Error("item ins too big");c+=d===t[c]?1:0,$t({instructions:n?[...s.instructions,...l]:[...l],payer:this.feePayer,signers:g})?o.push(new rn().add(...s.instructions,...l)):o.push(new rn().add(...l)),u.push(Array.from(new Set(l.map(A=>A.keys.filter(T=>T.isSigner).map(T=>T.pubkey.toString())).flat())).map(A=>i[A]).filter(A=>A!==void 0)),l=[d]}}),l.length>0){let b=[...new Set(l.map(y=>y.keys.filter(w=>w.isSigner).map(w=>w.pubkey.toString())).flat()).values()].map(y=>i[y]).filter(y=>y!==void 0);$t({instructions:n?[...s.instructions,...l]:[...l],payer:this.feePayer,signers:b.map(y=>y.publicKey)})?o.push(new rn().add(...s.instructions,...l)):o.push(new rn().add(...l)),u.push(b)}return o.forEach(d=>d.feePayer=this.feePayer),(p=this.owner)!=null&&p.signer&&u.forEach(d=>{d.some(b=>b.publicKey.equals(this.owner.publicKey))||d.push(this.owner.signer)}),{builder:this,transactions:o,signers:u,instructionTypes:this.instructionTypes,execute:async d=>{var h;let{sequentially:b,onTxUpdate:y,skipTxCount:w=0,recentBlockHash:g,skipPreflight:A=!0}=d||{},T=g!=null?g:await Ft(this.connection,this.blockhashCommitment);if(o.forEach(async(P,k)=>{P.recentBlockhash=T,u[k].length&&P.sign(...u[k])}),At(o),(h=this.owner)!=null&&h.isKeyPair){if(b){let P=0,k=[];for(let S of o){if(++P,P<=w){k.push("tx skipped");continue}let I=await ur(this.connection,S,this.signers.find(L=>L.publicKey.equals(this.owner.publicKey))?this.signers:[...this.signers,this.owner.signer],{skipPreflight:A});k.push(I)}return{txIds:k,signedTxs:o}}return{txIds:await Promise.all(o.map(async P=>await this.connection.sendRawTransaction(P.serialize(),{skipPreflight:A}))),signedTxs:o}}if(this.signAllTransactions){let P=await this.signAllTransactions(o.slice(w,o.length)),k=[...o.slice(0,w),...P];if(b){let S=0,I=[],L=async()=>{if(!k[S])return;S<w&&(I.push({txId:"",status:"success",signedTx:k[S]}),y==null||y([...I]),S++,L());let x=await this.connection.sendRawTransaction(k[S].serialize(),{skipPreflight:A});I.push({txId:x,status:"sent",signedTx:k[S]}),y==null||y([...I]),S++;let _=!1,v=null,V=null,G=$=>{v!==null&&clearInterval(v),V!==null&&this.connection.removeSignatureListener(V);let ee=I.findIndex(re=>re.txId===x);if(ee>-1){if(I[ee].status==="error"||I[ee].status==="success")return;I[ee].status=$.err?"error":"success"}y==null||y([...I]),$.err||L()};this.loopMultiTxStatus&&(v=setInterval(async()=>{var $;if(_){clearInterval(v);return}try{let ee=await this.connection.getTransaction(x,{commitment:"confirmed",maxSupportedTransactionVersion:0});ee&&(_=!0,clearInterval(v),G({err:(($=ee.meta)==null?void 0:$.err)||null}),console.log("tx status from getTransaction:",x))}catch(ee){_=!0,clearInterval(v),console.error("getTransaction timeout:",ee,x)}},Bn)),V=this.connection.onSignature(x,$=>{if(_){this.connection.removeSignatureListener(V);return}_=!0,G($)},"confirmed"),this.connection.getSignatureStatus(x)};return await L(),{txIds:I.map(x=>x.txId),signedTxs:k}}else{let S=[];for(let I=0;I<k.length;I+=1){let L=await this.connection.sendRawTransaction(k[I].serialize(),{skipPreflight:A});S.push(L)}return{txIds:S,signedTxs:k}}}throw new Error("please provide owner in keypair format or signAllTransactions function")},extInfo:r||{}}}async sizeCheckBuildV0(e){var T;let A=e||{},{computeBudgetConfig:t,splitIns:n=[],lookupTableCache:r={},lookupTableAddress:s=[]}=A,i=Oe(A,["computeBudgetConfig","splitIns","lookupTableCache","lookupTableAddress"]),o=F(F({},this.cluster==="devnet"?await ar(this.connection):Sn),r),u=Array.from(new Set([...this.lookupTableAddress,...s])),l=[];for(let h of u)o[h]===void 0&&l.push(new qt(h));let c=await sr({connection:this.connection,address:l});for(let[h,P]of Object.entries(c))o[h]=P;let m=t?hn(t):{instructions:[],instructionTypes:[]},p=await Ft(this.connection,this.blockhashCommitment),d=this.signers.reduce((h,P)=>j(F({},h),{[P.publicKey.toBase58()]:P}),{}),b=[],y=[],w=[],g=0;if(this.allInstructions.forEach(h=>{let P=[...w,h],k=t?[...m.instructions,...P]:P;if(h!==n[g]&&w.length<12&&(en({instructions:k,payer:this.feePayer,lookupTableAddressAccount:o})||en({instructions:P,payer:this.feePayer,lookupTableAddressAccount:o})))w.push(h);else{if(w.length===0)throw Error("item ins too big");g+=h===n[g]?1:0;let S={};for(let I of[...new Set(u)])o[I]!==void 0&&(S[I]=o[I]);if(t&&en({instructions:[...m.instructions,...w],payer:this.feePayer,lookupTableAddressAccount:o,recentBlockhash:p})){let I=new on({payerKey:this.feePayer,recentBlockhash:p,instructions:[...m.instructions,...w]}).compileToV0Message(Object.values(o));b.push(new sn(I))}else{let I=new on({payerKey:this.feePayer,recentBlockhash:p,instructions:[...w]}).compileToV0Message(Object.values(o));b.push(new sn(I))}y.push(Array.from(new Set(w.map(I=>I.keys.filter(L=>L.isSigner).map(L=>L.pubkey.toString())).flat())).map(I=>d[I]).filter(I=>I!==void 0)),w=[h]}}),w.length>0){let P=[...new Set(w.map(k=>k.keys.filter(S=>S.isSigner).map(S=>S.pubkey.toString())).flat()).values()].map(k=>d[k]).filter(k=>k!==void 0);if(t&&en({instructions:[...m.instructions,...w],payer:this.feePayer,lookupTableAddressAccount:o,recentBlockhash:p})){let k=new on({payerKey:this.feePayer,recentBlockhash:p,instructions:[...m.instructions,...w]}).compileToV0Message(Object.values(o));b.push(new sn(k))}else{let k=new on({payerKey:this.feePayer,recentBlockhash:p,instructions:[...w]}).compileToV0Message(Object.values(o));b.push(new sn(k))}y.push(P)}return(T=this.owner)!=null&&T.signer&&y.forEach(h=>{h.some(P=>P.publicKey.equals(this.owner.publicKey))||h.push(this.owner.signer)}),b.forEach((h,P)=>{h.sign(y[P])}),{builder:this,transactions:b,buildProps:e,signers:y,instructionTypes:this.instructionTypes,execute:async h=>{var x;let{sequentially:P,onTxUpdate:k,skipTxCount:S=0,recentBlockHash:I,skipPreflight:L=!0}=h||{};if(b.map(async(_,v)=>{y[v].length&&_.sign(y[v]),I&&(_.message.recentBlockhash=I)}),At(b),(x=this.owner)!=null&&x.isKeyPair){if(P){let _=0,v=[];for(let V of b){if(++_,_<=S){console.log("skip tx: ",_),v.push("tx skipped");continue}let G=await this.connection.sendTransaction(V,{skipPreflight:L});await xn(this.connection,G),v.push(G)}return{txIds:v,signedTxs:b}}return{txIds:await Promise.all(b.map(async _=>await this.connection.sendTransaction(_,{skipPreflight:L}))),signedTxs:b}}if(this.signAllTransactions){let _=await this.signAllTransactions(b.slice(S,b.length)),v=[...b.slice(0,S),..._];if(P){let V=0,G=[],$=async()=>{if(!v[V])return;if(V<S){G.push({txId:"",status:"success",signedTx:v[V]}),k==null||k([...G]),V++,$();return}let ee=await this.connection.sendTransaction(v[V],{skipPreflight:L});G.push({txId:ee,status:"sent",signedTx:v[V]}),k==null||k([...G]),V++;let re=!1,ke=null,Ue=null,tt=Ce=>{ke!==null&&clearInterval(ke),Ue!==null&&this.connection.removeSignatureListener(Ue);let Ne=G.findIndex(je=>je.txId===ee);if(Ne>-1){if(G[Ne].status==="error"||G[Ne].status==="success")return;G[Ne].status=Ce.err?"error":"success"}k==null||k([...G]),Ce.err||$()};this.loopMultiTxStatus&&(ke=setInterval(async()=>{var Ce;if(re){clearInterval(ke);return}try{let Ne=await this.connection.getTransaction(ee,{commitment:"confirmed",maxSupportedTransactionVersion:0});Ne&&(re=!0,clearInterval(ke),tt({err:((Ce=Ne.meta)==null?void 0:Ce.err)||null}),console.log("tx status from getTransaction:",ee))}catch(Ne){re=!0,clearInterval(ke),console.error("getTransaction timeout:",Ne,ee)}},Bn)),Ue=this.connection.onSignature(ee,Ce=>{if(re){this.connection.removeSignatureListener(Ue);return}re=!0,tt(Ce)},"confirmed"),this.connection.getSignatureStatus(ee)};return $(),{txIds:[],signedTxs:v}}else{let V=[];for(let G=0;G<v.length;G+=1){let $=await this.connection.sendTransaction(v[G],{skipPreflight:L});V.push($)}return{txIds:V,signedTxs:v}}}throw new Error("please provide owner in keypair format or signAllTransactions function")},extInfo:i||{}}}};import ds from"bn.js";var Ql=new ds(1e6);import{MINT_SIZE as Am,TOKEN_PROGRAM_ID as Pm,getTransferFeeConfig as Tm,unpackMint as hm}from"@solana/spl-token";var cr=ie("Raydium_accountInfo_util");async function ot(a,e,t){let{batchRequest:n,commitment:r="confirmed",chunkCount:s=100}=F({batchRequest:!1},t),i=ir(e,s),o=new Array(i.length).fill([]);if(n){let u=i.map(m=>{let p=a._buildArgs([m.map(d=>d.toBase58())],r,"base64");return{methodName:"getMultipleAccounts",args:p}}),l=ir(u,10);o=(await(await Promise.all(l.map(async m=>await a._rpcBatchRequest(m)))).flat()).map(m=>(m.error&&cr.logWithError(`failed to get info for multiple accounts, RPC_ERROR, ${m.error.message}`),m.result.value.map(p=>{if(p){let{data:d,executable:b,lamports:y,owner:w,rentEpoch:g}=p;return d.length!==2&&d[1]!=="base64"&&cr.logWithError("info must be base64 encoded, RPC_ERROR"),{data:Buffer.from(d[0],"base64"),executable:b,lamports:y,owner:new ps(w),rentEpoch:g}}return null})))}else try{o=await Promise.all(i.map(u=>a.getMultipleAccountsInfo(u,r)))}catch(u){u instanceof Error&&cr.logWithError(`failed to get info for multiple accounts, RPC_ERROR, ${u.message}`)}return o.flat()}async function ht(a,e,t){let n=await ot(a,e.map(r=>r.pubkey),t);return e.map((r,s)=>j(F({},r),{accountInfo:n[s]}))}import{PublicKey as xs}from"@solana/web3.js";import Ii,{isBN as Ki}from"bn.js";import{bits as fs,BitStructure as Bm,blob as bs,Blob as Im,cstr as Km,f32 as Lm,f32be as Rm,f64 as Cm,f64be as Nm,greedy as Mm,Layout as ys,ns64 as _m,ns64be as Vm,nu64 as vm,nu64be as Wm,offset as Em,s16 as Fm,s16be as Om,s24 as Dm,s24be as qm,s32 as gs,s32be as Gm,s40 as Um,s40be as Xm,s48 as Qm,s48be as zm,s8 as jm,seq as ws,struct as Hm,Structure as ks,u16 as As,u16be as Ym,u24 as Zm,u24be as Jm,u32 as Ps,u32be as $m,u40 as ed,u40be as td,u48 as nd,u48be as rd,u8 as Ts,UInt as hs,union as id,Union as od,unionLayoutDiscriminator as sd,utf8 as ad}from"@solana/buffer-layout";var Kn=ys,xi=ks;var lr=hs;var Si=Ts,xt=As;var mr=Ps;var ue=gs;var Bi=ws;var Ae=bs;var dr=fs;var St=class extends Kn{constructor(t,n,r){super(t,r);this.blob=Ae(t),this.signed=n}decode(t,n=0){let r=new Ii(this.blob.decode(t,n),10,"le");return this.signed?r.fromTwos(this.span*8).clone():r}encode(t,n,r=0){return typeof t=="number"&&(t=new Ii(t)),this.signed&&(t=t.toTwos(this.span*8)),this.blob.encode(t.toArrayLike(Buffer,"le",this.span),n,r)}},Ln=class extends Kn{constructor(t){super(8,t);this._lower=dr(mr(),!1),this._upper=dr(mr(),!1)}addBoolean(t){this._lower.fields.length<32?this._lower.addBoolean(t):this._upper.addBoolean(t)}decode(t,n=0){let r=this._lower.decode(t,n),s=this._upper.decode(t,n+this._lower.span);return F(F({},r),s)}encode(t,n,r=0){return this._lower.encode(t,n,r)+this._upper.encode(t,n,r+this._lower.span)}};function W(a){return new lr(1,a)}function Ke(a){return new lr(4,a)}function f(a){return new St(8,!1,a)}function D(a){return new St(16,!1,a)}function Li(a){return new St(1,!0,a)}function Gt(a){return new St(8,!0,a)}function Ri(a){return new St(16,!0,a)}var Rn=class extends Kn{constructor(t,n,r,s){super(t.span,s);this.layout=t,this.decoder=n,this.encoder=r}decode(t,n){return this.decoder(this.layout.decode(t,n))}encode(t,n,r){return this.layout.encode(this.encoder(t),n,r)}getSpan(t,n){return this.layout.getSpan(t,n)}};function K(a){return new Rn(Ae(32),e=>new xs(e),e=>e.toBuffer(),a)}function Pe(a){return new Rn(Si(),Ss,Bs,a)}function Ss(a){if(a===0)return!1;if(a===1)return!0;throw new Error("Invalid bool: "+a)}function Bs(a){return a?1:0}var pr=class extends xi{decode(e,t){return super.decode(e,t)}};function C(a,e,t){return new pr(a,e,t)}function q(a,e,t){let n,r=typeof e=="number"?e:Ki(e)?e.toNumber():new Proxy(e,{get(s,i){if(!n){let o=Reflect.get(s,"count");n=Ki(o)?o.toNumber():o,Reflect.set(s,"count",n)}return Reflect.get(s,i)},set(s,i,o){return i==="count"&&(n=o),Reflect.set(s,i,o)}});return Bi(a,r,t)}import{PublicKey as fr}from"@solana/web3.js";import{NATIVE_MINT as Sd}from"@solana/spl-token";var Bd=ie("Raydium_farm_config"),Id=new fr("4k3Dyjzvzp8eMZWUXbBCjEvwSkkk59S5iCNLY3QrkX6R"),Kd=new fr("FrspKwj8i3pNmKwXreTveC4fu7KL5ZbGeXdZBe2XViu1");var Ld=new fr("3TRTX4dXUpp2eqxi3tvQDFYUV7SdDJjcPE3Y4mbtftaX");var Ci={3:yr,5:Ni,6:Mi};var Cn={"Standard SPL":0,"Option tokens":1},br={[yi.toString()]:3,[gi.toString()]:4,[wi.toString()]:5,[ki.toString()]:6,[Tt.FARM_PROGRAM_ID_V3.toString()]:3,[Tt.FARM_PROGRAM_ID_V4.toString()]:4,[Tt.FARM_PROGRAM_ID_V5.toString()]:5,[Tt.FARM_PROGRAM_ID_V6.toString()]:6};var gr=C([W("instruction")]),Rs=C([W("instruction")]),Cs=C([f("rewardState"),f("rewardOpenTime"),f("rewardEndTime"),f("rewardLastUpdateTime"),f("totalReward"),f("totalRewardEmissioned"),f("rewardClaimed"),f("rewardPerSecond"),D("accRewardPerShare"),K("rewardVault"),K("rewardMint"),K("rewardSender"),f("rewardType"),q(f(),15,"padding")]),Ns=C([f("state"),f("nonce"),K("lpVault"),K("rewardVault"),K(),K(),f(),f(),f("totalReward"),D("perShareReward"),f("lastSlot"),f("perSlotReward")]),Ms=C([f("state"),f("nonce"),K("lpVault"),K("rewardVaultA"),f("totalRewardA"),D("perShareRewardA"),f("perSlotRewardA"),W("option"),K("rewardVaultB"),Ae(7),f("totalRewardB"),D("perShareRewardB"),f("perSlotRewardB"),f("lastSlot"),K()]),_s=C([f(),f("state"),f("nonce"),f("validRewardTokenNum"),D("rewardMultiplier"),f("rewardPeriodMax"),f("rewardPeriodMin"),f("rewardPeriodExtend"),K("lpMint"),K("lpVault"),q(Cs,5,"rewardInfos"),K("creator"),K(),q(f(),32,"padding")]),Is=new Proxy(Ns,{get(a,e,t){return e==="decode"?(...n)=>{let r=a.decode(...n);return j(F({},r),{version:3,rewardInfos:[{rewardVault:r.rewardVault,totalReward:r.totalReward,perSlotReward:r.perSlotReward,perShareReward:r.perShareReward}]})}:Reflect.get(a,e,t)}}),Ks=new Proxy(Ms,{get(a,e,t){return e==="decode"?(...n)=>{let r=a.decode(...n);return j(F({},r),{version:5,rewardInfos:[{rewardVault:r.rewardVaultA,totalReward:r.totalRewardA,perSlotReward:r.perSlotRewardA,perShareReward:r.perShareRewardA},{rewardVault:r.rewardVaultB,totalReward:r.totalRewardB,perSlotReward:r.perSlotRewardB,perShareReward:r.perShareRewardB}]})}:Reflect.get(a,e,t)}}),Ls=new Proxy(_s,{get(a,e,t){return e==="decode"?(...n)=>{let r=a.decode(...n);return j(F({},r),{version:6,rewardInfos:r.rewardInfos.map(s=>{var i;return j(F({},s),{rewardType:((i=Object.entries(Cn).find(o=>String(o[1])===s.rewardType.toString()))!=null?i:["Standard SPL"])[0]})})})}:Reflect.get(a,e,t)}}),Vs=C([f("isSet"),f("rewardPerSecond"),f("rewardOpenTime"),f("rewardEndTime"),f("rewardType")]),vs=C([W("instruction"),f("nonce"),q(Vs,5,"rewardTimeInfo")]),Ws=C([W("instruction"),f("rewardReopenTime"),f("rewardEndTime"),f("rewardPerSecond")]),Es=C([W("instruction"),f("isSet"),f("rewardPerSecond"),f("rewardOpenTime"),f("rewardEndTime"),f("rewardType")]),vd=C([f("state"),K("id"),K("owner"),f("deposited"),q(f(),1,"rewardDebts")]),yr=C([f("state"),K("id"),K("owner"),f("deposited"),q(D(),1,"rewardDebts"),f(""),f("voteLockedBalance"),q(f(),15)]),Wd=C([f("state"),K("id"),K("owner"),f("deposited"),q(f(),2,"rewardDebts")]),Ni=C([f("state"),K("id"),K("owner"),f("deposited"),q(D(),2,"rewardDebts"),q(f(),17)]),Mi=C([f(),f("state"),K("id"),K("owner"),f("deposited"),q(D(),5,"rewardDebts"),q(f(),16)]),Bt=C([W("instruction"),f("amount")]),Fs=C([K("mint"),K("grantAuthority"),f("baselineVoteWeightScaledFactor"),f("maxExtraLockupVoteWeightScaledFactor"),f("lockupSaturationSecs"),Li("digitShift"),q(W(),7,"reserved1"),q(f(),7,"reserved2")]),Os=C([Ae(8),K("governanceProgramId"),K("realm"),K("realmGoverningTokenMint"),K("realmAuthority"),q(W(),32,"reserved1"),q(Fs,4,"votingMints"),Gt("timeOffset"),W("bump"),q(W(),7,"reserved2"),q(f(),11,"reserved3")]),Ds=C([Gt("startTime"),Gt("endTime"),W("kind"),q(W(),15,"reserved")]),qs=C([q(Ds,1,"lockup"),f("amountDeposited_native"),f("amountInitiallyLockedNative"),Pe("isUsed"),Pe("allowClawback"),W("votingMintConfigIdx"),q(W(),29,"reserved")]),Gs=C([Ae(8),K("voterAuthority"),K("registrar"),q(qs,32,"deposits"),W("voterBump"),W("voterWweightRecordBump"),q(W(),94,"reserved")]);import Xd from"bn.js";var Nn=C([K("mint"),K("owner"),f("amount"),Ke("delegateOption"),K("delegate"),W("state"),Ke("isNativeOption"),f("isNative"),f("delegatedAmount"),Ke("closeAuthorityOption"),K("closeAuthority")]);var Us=ie("Raydium.farm.util");function Ut({programId:a,poolId:e,owner:t,version:n}){let{publicKey:r}=de([e.toBuffer(),t.toBuffer(),Buffer.from(n===6?"farmer_info_associated_seed":"staker_info_v2_associated_seed","utf-8")],a);return r}function _i(a){let e=Ci[a];return e||Us.logWithError("invalid version",a),e}import{PublicKey as Le,SystemProgram as Xs,SYSVAR_CLOCK_PUBKEY as Vi,SYSVAR_RENT_PUBKEY as Qs,TransactionInstruction as Mn}from"@solana/web3.js";import gp from"bn.js";import{ASSOCIATED_TOKEN_PROGRAM_ID as kp,createAssociatedTokenAccountIdempotentInstruction as Ap,TOKEN_PROGRAM_ID as wr}from"@solana/spl-token";var zs=ie("Raydium_farm_instruction"),Cp={voterStakeRegistryCreateVoter:Buffer.from([6,24,245,52,243,255,148,25]),voterStakeRegistryCreateDepositEntry:Buffer.from([185,131,167,186,159,125,19,67]),voterStakeRegistryDeposit:Buffer.from([242,35,198,137,82,225,242,182]),voterStakeRegistryWithdraw:Buffer.from([183,18,70,156,148,109,161,34]),voterStakeRegistryUpdateVoterWeightRecord:Buffer.from([45,185,3,36,109,190,115,169])};function vi(a){let{version:e,id:t,ledger:n,programId:r,owner:s}=a,i={3:9,5:10}[e];i||zs.logWithError(`invalid farm pool version: ${e}`);let o=Buffer.alloc(gr.span);gr.encode({instruction:i},o);let u=[B({pubkey:t}),B({pubkey:n}),B({pubkey:s,isWritable:!1}),B({pubkey:Xs.programId,isWritable:!1}),B({pubkey:Qs,isWritable:!1})];return{instruction:new Mn({programId:r,keys:u,data:o}),instructionType:U.FarmV3CreateLedger}}function Wi(a){let{farmInfo:e,farmKeys:t,lpAccount:n,rewardAccounts:r,owner:s,amount:i}=a,[o,u]=[new Le(e.programId),new Le(e.id)],l=Ut({programId:o,poolId:u,owner:s,version:6}),c=Buffer.alloc(Bt.span);Bt.encode({instruction:2,amount:H(i)},c);let m=[B({pubkey:wr,isWritable:!1}),B({pubkey:u}),B({pubkey:new Le(t.authority),isWritable:!1}),B({pubkey:new Le(t.lpVault)}),B({pubkey:l}),B({pubkey:s,isWritable:!1,isSigner:!0}),B({pubkey:n})];for(let p=0;p<t.rewardInfos.length;p++)m.push(B({pubkey:new Le(t.rewardInfos[p].vault)})),m.push(B({pubkey:r[p]}));return new Mn({programId:o,keys:m,data:c})}function Ei(a){let{farmInfo:e,farmKeys:t,lpAccount:n,rewardAccounts:r,owner:s,amount:i,userAuxiliaryLedgers:o}=a,[u,l]=[new Le(e.programId),new Le(e.id)],c=Ut({programId:u,poolId:l,owner:s,version:5}),m=Buffer.alloc(Bt.span);Bt.encode({instruction:12,amount:H(i)},m);let p=[B({pubkey:l}),B({pubkey:new Le(t.authority),isWritable:!1}),B({pubkey:c}),B({pubkey:s,isWritable:!1,isSigner:!0}),B({pubkey:n}),B({pubkey:new Le(t.lpVault)}),B({pubkey:r[0]}),B({pubkey:new Le(t.rewardInfos[0].vault)}),B({pubkey:Vi,isWritable:!1}),B({pubkey:wr,isWritable:!1})];for(let d=1;d<t.rewardInfos.length;d++)p.push(B({pubkey:r[d]})),p.push(B({pubkey:new Le(t.rewardInfos[d].vault)}));if(o)for(let d of o)p.push(B({pubkey:d}));return new Mn({programId:u,keys:p,data:m})}function Fi(a){let{farmInfo:e,farmKeys:t,lpAccount:n,rewardAccounts:r,owner:s,amount:i,userAuxiliaryLedgers:o}=a,[u,l]=[new Le(e.programId),new Le(e.id)],c=Ut({programId:u,poolId:l,owner:s,version:3}),m=Buffer.alloc(Bt.span);Bt.encode({instruction:11,amount:H(i)},m);let p=[B({pubkey:l}),B({pubkey:new Le(t.authority),isWritable:!1}),B({pubkey:c}),B({pubkey:s,isWritable:!1,isSigner:!0}),B({pubkey:n}),B({pubkey:new Le(t.lpVault)}),B({pubkey:r[0]}),B({pubkey:new Le(t.rewardInfos[0].vault)}),B({pubkey:Vi,isWritable:!1}),B({pubkey:wr,isWritable:!1})];if(o)for(let d of o)p.push(B({pubkey:d}));return new Mn({programId:u,keys:p,data:m})}import{Keypair as Wn,PublicKey as R,SystemProgram as ut,TransactionInstruction as Se}from"@solana/web3.js";import Kr from"bn.js";import{ASSOCIATED_TOKEN_PROGRAM_ID as pn,TOKEN_2022_PROGRAM_ID as pe,TOKEN_PROGRAM_ID as oe}from"@solana/spl-token";import ra from"bn.js";import Xt from"decimal.js";import Ge from"bn.js";var me=new Ge(0),Ye=new Ge(1),st=new Ge(-1),Ve=new Ge(1).shln(64),_n=new Ge(1).shln(128),kr=Ve.sub(Ye),an=64,Oi=_n.subn(1),Re=-443636,Me=-Re,It=new Ge("4295048016"),Kt=new Ge("79226673521066979257578248091"),Dp=new Ge("4295048017"),qp=new Ge("79226673521066979257578248090"),Di=16,qi="59543866431248",Gi="184467440737095516",Ui="15793534762490258745",Vn=new Ge(10).pow(new Ge(6));var Gp=new Ge("18446744073700000000");import z from"bn.js";import Je from"decimal.js";function vn(a){let e=new ArrayBuffer(4);return new DataView(e).setInt32(0,a,!1),new Uint8Array(e)}function Ar(a,e){let t=0;for(let n=a-1;n>=0&&!e.testn(n);n--)t++;return t}function Pr(a,e){let t=0;for(let n=0;n<a&&!e.testn(n);n++)t++;return t}function un(a,e){for(let t=0;t<a;t++)if(e.testn(t))return!1;return!0}function Xi(a,e){return un(a,e)?null:Ar(a,e)}function Qi(a,e){return un(a,e)?null:Pr(a,e)}var Hp=Buffer.from("amm_config","utf8"),js=Buffer.from("pool","utf8"),Hs=Buffer.from("pool_vault","utf8"),Ys=Buffer.from("pool_reward_vault","utf8"),zi=Buffer.from("position","utf8"),Zs=Buffer.from("tick_array","utf8"),Js=Buffer.from("operation","utf8"),$s=Buffer.from("pool_tick_array_bitmap_extension","utf8"),ea=Buffer.from("observation","utf8");function ji(a,e,t,n){return de([js,e.toBuffer(),t.toBuffer(),n.toBuffer()],a)}function Tr(a,e,t){return de([Hs,e.toBuffer(),t.toBuffer()],a)}function Hi(a,e,t){return de([Ys,e.toBuffer(),t.toBuffer()],a)}function ne(a,e,t){return de([Zs,e.toBuffer(),vn(t)],a)}function pt(a,e,t,n){return de([zi,e.toBuffer(),vn(t),vn(n)],a)}function ve(a,e){return de([zi,e.toBuffer()],a)}function cn(a){return de([Buffer.from("metadata","utf8"),wt.toBuffer(),a.toBuffer()],wt)}function hr(a){return de([Js],a)}function xe(a,e){return de([$s,e.toBuffer()],a)}function Yi(a,e){return de([ea,e.toBuffer()],a)}var Zi=Buffer.from("locked_position","utf8");function xr(a,e){return de([Zi,e.toBuffer()],a)}function Ji(a,e){return de([Zi,e.toBuffer()],a)}var Yp=Buffer.from("support_mint","utf8");import{PublicKey as We}from"@solana/web3.js";import{TOKEN_2022_PROGRAM_ID as $i}from"@solana/spl-token";import ce from"bn.js";import Z from"decimal.js";import Ze from"bn.js";import Sr from"decimal.js";var ln=class{static getfeeGrowthInside(e,t,n){let r=new Ze(0),s=new Ze(0);e.tickCurrent>=t.tick?(r=t.feeGrowthOutsideX64A,s=t.feeGrowthOutsideX64B):(r=e.feeGrowthGlobalX64A.sub(t.feeGrowthOutsideX64A),s=e.feeGrowthGlobalX64B.sub(t.feeGrowthOutsideX64B));let i=new Ze(0),o=new Ze(0);e.tickCurrent<n.tick?(i=n.feeGrowthOutsideX64A,o=n.feeGrowthOutsideX64B):(i=e.feeGrowthGlobalX64A.sub(n.feeGrowthOutsideX64A),o=e.feeGrowthGlobalX64B.sub(n.feeGrowthOutsideX64B));let u=Q.wrappingSubU128(Q.wrappingSubU128(e.feeGrowthGlobalX64A,r),i),l=Q.wrappingSubU128(Q.wrappingSubU128(e.feeGrowthGlobalX64B,s),o);return{feeGrowthInsideX64A:u,feeGrowthInsideBX64:l}}static GetPositionFees(e,t,n,r){let{feeGrowthInsideX64A:s,feeGrowthInsideBX64:i}=this.getfeeGrowthInside(e,n,r),o=Q.mulDivFloor(Q.wrappingSubU128(s,t.feeGrowthInsideLastX64A),t.liquidity,Ve),u=t.tokenFeesOwedA.add(o),l=Q.mulDivFloor(Q.wrappingSubU128(i,t.feeGrowthInsideLastX64B),t.liquidity,Ve),c=t.tokenFeesOwedB.add(l);return{tokenFeeAmountA:u,tokenFeeAmountB:c}}static GetPositionFeesV2(e,t,n,r){let{feeGrowthInsideX64A:s,feeGrowthInsideBX64:i}=this.getfeeGrowthInside(e,n,r),o=Q.mulDivFloor(Q.wrappingSubU128(s,t.feeGrowthInsideLastX64A),t.liquidity,Ve),u=t.tokenFeesOwedA.add(o),l=Q.mulDivFloor(Q.wrappingSubU128(i,t.feeGrowthInsideLastX64B),t.liquidity,Ve),c=t.tokenFeesOwedB.add(l);return{tokenFeeAmountA:u,tokenFeeAmountB:c}}static GetPositionRewardsV2(e,t,n,r){let s=[],i=this.getRewardGrowthInsideV2(e.tickCurrent,n,r,e.rewardInfos);for(let o=0;o<i.length;o++){let u=i[o],l=t.rewardInfos[o],c=Q.wrappingSubU128(u,l.growthInsideLastX64),m=Q.mulDivFloor(c,t.liquidity,Ve),p=l.rewardAmountOwed.add(m);s.push(p)}return s}static GetPositionRewards(e,t,n,r){let s=[],i=this.getRewardGrowthInside(e.tickCurrent,n,r,e.rewardInfos);for(let o=0;o<i.length;o++){let u=i[o],l=t.rewardInfos[o],c=Q.wrappingSubU128(u,l.growthInsideLastX64),m=Q.mulDivFloor(c,t.liquidity,Ve),p=l.rewardAmountOwed.add(m);s.push(p)}return s}static getRewardGrowthInside(e,t,n,r){let s=[];for(let i=0;i<r.length;i++){let o=new Ze(0);t.liquidityGross.eqn(0)?o=r[i].rewardGrowthGlobalX64:e<t.tick?o=r[i].rewardGrowthGlobalX64.sub(t.rewardGrowthsOutsideX64[i]):o=t.rewardGrowthsOutsideX64[i];let u=new Ze(0);n.liquidityGross.eqn(0)||(e<n.tick?u=n.rewardGrowthsOutsideX64[i]:u=r[i].rewardGrowthGlobalX64.sub(n.rewardGrowthsOutsideX64[i])),s.push(Q.wrappingSubU128(Q.wrappingSubU128(r[i].rewardGrowthGlobalX64,o),u))}return s}static getRewardGrowthInsideV2(e,t,n,r){let s=[];for(let i=0;i<r.length;i++){let o=new Ze(0);t.liquidityGross.eqn(0)?o=r[i].rewardGrowthGlobalX64:e<t.tick?o=r[i].rewardGrowthGlobalX64.sub(t.rewardGrowthsOutsideX64[i]):o=t.rewardGrowthsOutsideX64[i];let u=new Ze(0);n.liquidityGross.eqn(0)||(e<n.tick?u=n.rewardGrowthsOutsideX64[i]:u=r[i].rewardGrowthGlobalX64.sub(n.rewardGrowthsOutsideX64[i])),s.push(Q.wrappingSubU128(Q.wrappingSubU128(r[i].rewardGrowthGlobalX64,o),u))}return s}static getAmountsFromLiquidity({poolInfo:e,ownerPosition:t,liquidity:n,slippage:r,add:s,epochInfo:i}){var w,g,A,T;let o=X.priceToSqrtPriceX64(new Sr(e.price),e.mintA.decimals,e.mintB.decimals),u=X.getSqrtPriceX64FromTick(t.tickLower),l=X.getSqrtPriceX64FromTick(t.tickUpper),c=s?1+r:1-r,m=J.getAmountsFromLiquidity(o,u,l,n,s),[p,d]=[ye(m.amountA,(w=e.mintA.extensions)==null?void 0:w.feeConfig,i,!0),ye(m.amountB,(g=e.mintB.extensions)==null?void 0:g.feeConfig,i,!0)],[b,y]=[ye(new Ze(new Sr(m.amountA.toString()).mul(c).toFixed(0)),(A=e.mintA.extensions)==null?void 0:A.feeConfig,i,!0),ye(new Ze(new Sr(m.amountB.toString()).mul(c).toFixed(0)),(T=e.mintB.extensions)==null?void 0:T.feeConfig,i,!0)];return{liquidity:n,amountA:p,amountB:d,amountSlippageA:b,amountSlippageB:y,expirationTime:dt(p.expirationTime,d.expirationTime)}}};var ta=15,Y=class{static async getTickArrays(e,t,n,r,s,i,o){let u=[],l=E.getTickArrayStartIndexByTick(r,s),c=E.getInitializedTickArrayInRange(i,o,s,l,Math.floor(ta/2));for(let d=0;d<c.length;d++){let{publicKey:b}=ne(t,n,c[d]);u.push(b)}let m=(await ot(e,u)).map(d=>d!==null?mn.decode(d.data):null),p={};for(let d=0;d<u.length;d++){let b=m[d];b!==null&&(p[b.startTickIndex]=j(F({},b),{address:u[d]}))}return p}static nextInitializedTick(e,t,n,r,s,i){let{initializedTick:o,tickArrayAddress:u,tickArrayStartTickIndex:l}=this.nextInitializedTickInOneArray(e,t,n,r,s,i);for(;o==null||o.liquidityGross.lten(0);){if(l=E.getNextTickArrayStartIndex(l,s,i),this.checkIsValidStartIndex(l,s))throw new Error("No enough initialized tickArray");let c=n[l];if(c===void 0)continue;let{nextTick:m,tickArrayAddress:p,tickArrayStartTickIndex:d}=this.firstInitializedTickInOneArray(e,t,c,i);[o,u,l]=[m,p,d]}if(o==null)throw new Error("No invaild tickArray cache");return{nextTick:o,tickArrayAddress:u,tickArrayStartTickIndex:l}}static nextInitializedTickArray(e,t,n,r,s){let i=Math.floor(e/Y.tickCount(t)),o=n?E.searchLowBitFromStart(r,s,i-1,1,t):E.searchHightBitFromStart(r,s,i+1,1,t);return o.length>0?{isExist:!0,nextStartIndex:o[0]}:{isExist:!1,nextStartIndex:0}}static firstInitializedTickInOneArray(e,t,n,r){let s;if(r){let o=Te-1;for(;o>=0;){let u=n.ticks[o];if(u.liquidityGross.gtn(0)){s=u;break}o=o-1}}else{let o=0;for(;o<Te;){let u=n.ticks[o];if(u.liquidityGross.gtn(0)){s=u;break}o=o+1}}let{publicKey:i}=ne(e,t,n.startTickIndex);return{nextTick:s,tickArrayAddress:i,tickArrayStartTickIndex:n.startTickIndex}}static nextInitializedTickInOneArray(e,t,n,r,s,i){let o=E.getTickArrayStartIndexByTick(r,s),u=Math.floor((r-o)/s),l=n[o];if(l==null)return{initializedTick:void 0,tickArrayAddress:void 0,tickArrayStartTickIndex:o};let c;if(i)for(;u>=0;){let p=l.ticks[u];if(p.liquidityGross.gtn(0)){c=p;break}u=u-1}else for(u=u+1;u<Te;){let p=l.ticks[u];if(p.liquidityGross.gtn(0)){c=p;break}u=u+1}let{publicKey:m}=ne(e,t,o);return{initializedTick:c,tickArrayAddress:m,tickArrayStartTickIndex:l.startTickIndex}}static getArrayStartIndex(e,t){let n=this.tickCount(t);return Math.floor(e/n)*n}static checkIsValidStartIndex(e,t){if(E.checkIsOutOfBoundary(e)){if(e>Me)return!1;let n=E.getTickArrayStartIndexByTick(Re,t);return e==n}return e%this.tickCount(t)==0}static tickCount(e){return Te*e}};var Br=14,at=class{static maxTickInTickarrayBitmap(e){return e*Te*Lt}static getBitmapTickBoundary(e,t){let n=this.maxTickInTickarrayBitmap(t),r=Math.floor(Math.abs(e)/n);e<0&&Math.abs(e)%n!=0&&(r+=1);let s=n*r;return e<0?{minValue:-s,maxValue:-s+n}:{minValue:s,maxValue:s+n}}static nextInitializedTickArrayStartIndex(e,t,n,r){if(!Y.checkIsValidStartIndex(t,n))throw Error("nextInitializedTickArrayStartIndex check error");let s=this.maxTickInTickarrayBitmap(n),i=r?t-Y.tickCount(n):t+Y.tickCount(n);if(i<-s||i>=s)return{isInit:!1,tickIndex:t};let o=n*Te,u=i/o+512;i<0&&i%o!=0&&u--;let l=Math.abs(u);if(r){let c=e.shln(1024-l-1),m=Xi(1024,c);if(m!==null){let p=(l-m-512)*o;return{isInit:!0,tickIndex:p}}else return{isInit:!1,tickIndex:-s}}else{let c=e.shrn(l),m=Qi(1024,c);if(m!==null){let p=(l+m-512)*o;return{isInit:!0,tickIndex:p}}else return{isInit:!1,tickIndex:s-Y.tickCount(n)}}}},dn=class{static getBitmapOffset(e,t){if(!Y.checkIsValidStartIndex(e,t))throw new Error("No enough initialized tickArray");this.checkExtensionBoundary(e,t);let n=at.maxTickInTickarrayBitmap(t),r=Math.floor(Math.abs(e)/n)-1;return e<0&&Math.abs(e)%n===0&&r--,r}static getBitmap(e,t,n){let r=this.getBitmapOffset(e,t);return e<0?{offset:r,tickarrayBitmap:n.negativeTickArrayBitmap[r]}:{offset:r,tickarrayBitmap:n.positiveTickArrayBitmap[r]}}static checkExtensionBoundary(e,t){let{positiveTickBoundary:n,negativeTickBoundary:r}=this.extensionTickBoundary(t);if(e>=r&&e<n)throw Error("checkExtensionBoundary -> InvalidTickArrayBoundary")}static extensionTickBoundary(e){let t=at.maxTickInTickarrayBitmap(e),n=-t;if(Me<=t)throw Error(`extensionTickBoundary check error: ${Me}, ${t}`);if(n<=Re)throw Error(`extensionTickBoundary check error: ${n}, ${Re}`);return{positiveTickBoundary:t,negativeTickBoundary:n}}static checkTickArrayIsInit(e,t,n){let{tickarrayBitmap:r}=this.getBitmap(e,t,n),s=this.tickArrayOffsetInBitmap(e,t);return{isInitialized:E.mergeTickArrayBitmap(r).testn(s),startIndex:e}}static nextInitializedTickArrayFromOneBitmap(e,t,n,r){let s=Y.tickCount(t),i=n?e-s:e+s,{tickarrayBitmap:o}=this.getBitmap(i,t,r);return this.nextInitializedTickArrayInBitmap(o,i,t,n)}static nextInitializedTickArrayInBitmap(e,t,n,r){let{minValue:s,maxValue:i}=at.getBitmapTickBoundary(t,n),o=this.tickArrayOffsetInBitmap(t,n);if(r){let u=E.mergeTickArrayBitmap(e).shln(Lt-1-o),l=un(512,u)?null:Ar(512,u);if(l!==null){let c=t-l*Y.tickCount(n);return{isInit:!0,tickIndex:c}}else return{isInit:!1,tickIndex:s}}else{let u=E.mergeTickArrayBitmap(e).shrn(o),l=un(512,u)?null:Pr(512,u);if(l!==null){let c=t+l*Y.tickCount(n);return{isInit:!0,tickIndex:c}}else return{isInit:!1,tickIndex:i-Y.tickCount(n)}}}static tickArrayOffsetInBitmap(e,t){let n=Math.abs(e)%at.maxTickInTickarrayBitmap(t),r=Math.floor(n/Y.tickCount(t));return e<0&&n!=0&&(r=Lt-r),r}};var ge=class{static getOutputAmountAndRemainAccounts(e,t,n,r,s,i=!1){let o=n.toBase58()===e.mintA.address,u=[],{isExist:l,startIndex:c,nextAccountMeta:m}=this.getFirstInitializedTickArray(e,o);if(!l||c===void 0||!m)throw new Error("Invalid tick array");u.push(m);let{allTrade:p,amountCalculated:d,accounts:b,sqrtPriceX64:y,feeAmount:w}=Rt.swapCompute(e.programId,e.id,t,e.tickArrayBitmap,e.exBitmapInfo,o,e.ammConfig.tradeFeeRate,e.liquidity,e.tickCurrent,e.tickSpacing,e.sqrtPriceX64,r,c,s,i);return u.push(...b),{allTrade:p,expectedAmountOut:d.mul(st),remainingAccounts:u,executionPrice:y,feeAmount:w}}static getInputAmountAndRemainAccounts(e,t,n,r,s){let i=n.toBase58()===e.mintB.address,o=[],{isExist:u,startIndex:l,nextAccountMeta:c}=this.getFirstInitializedTickArray(e,i);if(!u||l===void 0||!c)throw new Error("Invalid tick array");try{let y=this.preInitializedTickArrayStartIndex(e,i);if(y.isExist){let{publicKey:w}=ne(e.programId,e.id,y.nextStartIndex);o.push(w)}}catch{}o.push(c);let{amountCalculated:m,accounts:p,sqrtPriceX64:d,feeAmount:b}=Rt.swapCompute(e.programId,e.id,t,e.tickArrayBitmap,e.exBitmapInfo,i,e.ammConfig.tradeFeeRate,e.liquidity,e.tickCurrent,e.tickSpacing,e.sqrtPriceX64,r.mul(st),l,s);return o.push(...p),{expectedAmountIn:m,remainingAccounts:o,executionPrice:d,feeAmount:b}}static getFirstInitializedTickArray(e,t){let{isInitialized:n,startIndex:r}=ge.isOverflowDefaultTickarrayBitmap(e.tickSpacing,[e.tickCurrent])?dn.checkTickArrayIsInit(Y.getArrayStartIndex(e.tickCurrent,e.tickSpacing),e.tickSpacing,e.exBitmapInfo):E.checkTickArrayIsInitialized(E.mergeTickArrayBitmap(e.tickArrayBitmap),e.tickCurrent,e.tickSpacing);if(n){let{publicKey:o}=ne(e.programId,e.id,r);return{isExist:!0,startIndex:r,nextAccountMeta:o}}let{isExist:s,nextStartIndex:i}=this.nextInitializedTickArrayStartIndex(e,Y.getArrayStartIndex(e.tickCurrent,e.tickSpacing),t);if(s){let{publicKey:o}=ne(e.programId,e.id,i);return{isExist:!0,startIndex:i,nextAccountMeta:o}}return{isExist:!1,nextAccountMeta:void 0,startIndex:void 0}}static preInitializedTickArrayStartIndex(e,t){let n=Math.floor(e.tickCurrent/Y.tickCount(e.tickSpacing)),r=t?E.searchHightBitFromStart(e.tickArrayBitmap,e.exBitmapInfo,n+1,1,e.tickSpacing):E.searchLowBitFromStart(e.tickArrayBitmap,e.exBitmapInfo,n-1,1,e.tickSpacing);return r.length>0?{isExist:!0,nextStartIndex:r[0]}:{isExist:!1,nextStartIndex:0}}static nextInitializedTickArrayStartIndex(e,t,n){for(t=Y.getArrayStartIndex(e.tickCurrent,e.tickSpacing);;){let{isInit:r,tickIndex:s}=at.nextInitializedTickArrayStartIndex(E.mergeTickArrayBitmap(e.tickArrayBitmap),t,e.tickSpacing,n);if(r)return{isExist:!0,nextStartIndex:s};t=s;let{isInit:i,tickIndex:o}=dn.nextInitializedTickArrayFromOneBitmap(t,e.tickSpacing,n,e.exBitmapInfo);if(i)return{isExist:!0,nextStartIndex:o};if(t=o,t<Re||t>Me)return{isExist:!1,nextStartIndex:0}}}static async updatePoolRewardInfos({connection:e,apiPoolInfo:t,chainTime:n,poolLiquidity:r,rewardInfos:s}){var o,u,l;let i=[];for(let c=0;c<s.length;c++){let m=s[c],p=(l=(o=t.rewardDefaultInfos[c])==null?void 0:o.mint.programId)!=null?l:(u=await e.getAccountInfo(m.tokenMint))==null?void 0:u.owner;if(p===void 0)throw Error("get new reward mint info error");let d=j(F({},m),{perSecond:Q.x64ToDecimal(m.emissionsPerSecondX64),remainingRewards:void 0,tokenProgramId:new We(p)});if(d.tokenMint.equals(We.default))continue;if(n<=d.openTime.toNumber()||r.eq(me)){i.push(d);continue}let b=new ce(Math.min(d.endTime.toNumber(),n)),y=b.sub(d.lastUpdateTime),w=Q.mulDivFloor(y,d.emissionsPerSecondX64,r),g=d.rewardGrowthGlobalX64.add(w),A=Q.mulDivFloor(y,d.emissionsPerSecondX64,Ve),T=d.rewardTotalEmissioned.add(A);i.push(j(F({},d),{rewardGrowthGlobalX64:g,rewardTotalEmissioned:T,lastUpdateTime:b}))}return i}static isOverflowDefaultTickarrayBitmap(e,t){let{maxTickBoundary:n,minTickBoundary:r}=this.tickRange(e);for(let s of t){let i=E.getTickArrayStartIndexByTick(s,e);if(i>=n||i<r)return!0}return!1}static tickRange(e){let t=at.maxTickInTickarrayBitmap(e),n=-t;return t>Me&&(t=Y.getArrayStartIndex(Me,e)+Y.tickCount(e)),n<Re&&(n=Y.getArrayStartIndex(Re,e)),{maxTickBoundary:t,minTickBoundary:n}}static get_tick_array_offset(e,t){if(!Y.checkIsValidStartIndex(e,t))throw new Error("No enough initialized tickArray");return e/Y.tickCount(t)*Lt}static async fetchExBitmaps({connection:e,exBitmapAddress:t,batchRequest:n}){let r=await ht(e,t.map(i=>({pubkey:i})),{batchRequest:n}),s={};for(let i of r)i.accountInfo!==null&&(s[i.pubkey.toString()]=no.decode(i.accountInfo.data));return s}static async fetchMultiplePoolTickArrays({connection:e,poolKeys:t,batchRequest:n}){let r={},s=[];for(let u of t){let l=E.getTickArrayStartIndexByTick(u.tickCurrent,u.tickSpacing),c=E.getInitializedTickArrayInRange(u.tickArrayBitmap,u.exBitmapInfo,u.tickSpacing,l,7);for(let m of c){let{publicKey:p}=ne(u.programId,u.id,m);s.push({pubkey:p}),r[p.toString()]=u.id}}let i=await ht(e,s,{batchRequest:n}),o={};for(let u of i){if(!u.accountInfo)continue;let l=r[u.pubkey.toString()];if(!l)continue;o[l.toString()]===void 0&&(o[l.toString()]={});let c=mn.decode(u.accountInfo.data);o[l.toString()][c.startTickIndex]=j(F({},c),{address:u.pubkey})}return o}static async fetchPoolsAccountPosition({pools:e,connection:t,ownerInfo:n,batchRequest:r=!1,updateOwnerRewardAndFee:s=!0}){var o;let i=[];for(let u=0;u<e.length;u++){let l=e[u];l!==null&&(i.find(c=>c.equals(l.state.programId))||i.push(l.state.programId))}if(n){let u=n.tokenAccounts.map(p=>p.accountInfo.mint),l=[];for(let p of u)for(let d of i)l.push(ve(d,p).publicKey);let c=await ot(t,l,{batchRequest:r}),m={};for(let p of c){if(p===null)continue;let d=to.decode(p.data),b=d.poolId.toString(),y=e.find(I=>I.state.id.toBase58()===b);if(y===void 0)continue;let w=y.state,g=E._getTickPriceLegacy({poolInfo:w,tick:d.tickLower,baseIn:!0}),A=E._getTickPriceLegacy({poolInfo:w,tick:d.tickUpper,baseIn:!0}),{amountA:T,amountB:h}=J.getAmountsFromLiquidity(w.sqrtPriceX64,g.tickSqrtPriceX64,A.tickSqrtPriceX64,d.liquidity,!1),P=1/(1-Math.sqrt(Math.sqrt(g.price.div(A.price).toNumber())));y.positionAccount=[...(o=y.positionAccount)!=null?o:[],{poolId:d.poolId,nftMint:d.nftMint,priceLower:g.price,priceUpper:A.price,amountA:T,amountB:h,tickLower:d.tickLower,tickUpper:d.tickUpper,liquidity:d.liquidity,feeGrowthInsideLastX64A:d.feeGrowthInsideLastX64A,feeGrowthInsideLastX64B:d.feeGrowthInsideLastX64B,tokenFeesOwedA:d.tokenFeesOwedA,tokenFeesOwedB:d.tokenFeesOwedB,rewardInfos:d.rewardInfos.map(I=>j(F({},I),{pendingReward:new ce(0)})),leverage:P,tokenFeeAmountA:new ce(0),tokenFeeAmountB:new ce(0)}];let k=await E.getTickArrayAddressByTick(y.state.programId,d.poolId,d.tickLower,y.state.tickSpacing),S=await E.getTickArrayAddressByTick(y.state.programId,d.poolId,d.tickUpper,y.state.tickSpacing);m[`${y.state.programId.toString()}-${d.poolId.toString()}-${d.tickLower}`]=k,m[`${y.state.programId.toString()}-${d.poolId.toString()}-${d.tickUpper}`]=S}if(s){let p=Object.values(m),d=await ot(t,p,{batchRequest:r}),b={};for(let y=0;y<p.length;y++){let w=d[y];if(w===null)continue;let g=p[y].toString();b[g]=mn.decode(w.data)}for(let{state:y,positionAccount:w}of e)if(!!w)for(let g of w){let A=`${y.programId.toString()}-${y.id.toString()}-${g.tickLower}`,T=`${y.programId.toString()}-${y.id.toString()}-${g.tickUpper}`,h=b[m[A].toString()],P=b[m[T].toString()],k=h.ticks[E.getTickOffsetInArray(g.tickLower,y.tickSpacing)],S=P.ticks[E.getTickOffsetInArray(g.tickUpper,y.tickSpacing)],{tokenFeeAmountA:I,tokenFeeAmountB:L}=await ln.GetPositionFees(y,g,k,S),x=await ln.GetPositionRewards(y,g,k,S);g.tokenFeeAmountA=I.gte(new ce(0))?I:new ce(0),g.tokenFeeAmountB=L.gte(new ce(0))?L:new ce(0);for(let _=0;_<x.length;_++)g.rewardInfos[_].pendingReward=x[_].gte(new ce(0))?x[_]:new ce(0)}}}return e}static computeAmountOut({poolInfo:e,tickArrayCache:t,baseMint:n,epochInfo:r,amountIn:s,slippage:i,priceLimit:o=new Z(0),catchLiquidityInsufficient:u=!1}){var v;let l,c=n.toBase58()===e.mintA.address,[m,p]=c?[e.mintA.extensions.feeConfig,e.mintB.extensions.feeConfig]:[e.mintB.extensions.feeConfig,e.mintA.extensions.feeConfig];o.equals(new Z(0))?l=c?It.add(new ce(1)):Kt.sub(new ce(1)):l=X.priceToSqrtPriceX64(o,e.mintA.decimals,e.mintB.decimals);let d=ye(s,m,r,!1),{allTrade:b,expectedAmountOut:y,remainingAccounts:w,executionPrice:g,feeAmount:A}=ge.getOutputAmountAndRemainAccounts(e,t,n,d.amount.sub((v=d.fee)!=null?v:me),l,u),T=ye(y,p,r,!1),h=X.sqrtPriceX64ToPrice(g,e.mintA.decimals,e.mintB.decimals),P=c?h:new Z(1).div(h),k=y.mul(new ce(Math.floor((1-i)*1e10))).div(new ce(1e10)),S=ye(k,p,r,!1),I=c?e.currentPrice:new Z(1).div(e.currentPrice),L=new Z(P).sub(I).abs(),x=I,_=new De(new Z(L).mul(10**15).toFixed(0),new Z(x).mul(10**15).toFixed(0));return{allTrade:b,realAmountIn:d,amountOut:T,minAmountOut:S,expirationTime:dt(d.expirationTime,T.expirationTime),currentPrice:e.currentPrice,executionPrice:P,priceImpact:_,fee:A,remainingAccounts:w,executionPriceX64:g}}static computeAmountOutFormat({poolInfo:e,tickArrayCache:t,amountIn:n,tokenOut:r,slippage:s,epochInfo:i,catchLiquidityInsufficient:o=!1}){let u=r.address===e.mintB.address,[l,c]=u?[e.mintA,e.mintB]:[e.mintB,e.mintA],[m,p]=[new Ie(j(F({},l),{mint:l.address,isToken2022:l.programId===$i.toBase58()})),new Ie(j(F({},c),{mint:c.address,isToken2022:c.programId===$i.toBase58()}))],{allTrade:d,realAmountIn:b,amountOut:y,minAmountOut:w,expirationTime:g,currentPrice:A,executionPrice:T,priceImpact:h,fee:P,remainingAccounts:k,executionPriceX64:S}=ge.computeAmountOut({poolInfo:e,tickArrayCache:t,baseMint:new We(l.address),amountIn:n,slippage:s,epochInfo:i,catchLiquidityInsufficient:o}),I=j(F({},b),{amount:new be(m,b.amount),fee:b.fee===void 0?void 0:new be(m,b.fee)}),L=j(F({},y),{amount:new be(p,y.amount),fee:y.fee===void 0?void 0:new be(p,y.fee)}),x=j(F({},w),{amount:new be(p,w.amount),fee:w.fee===void 0?void 0:new be(p,w.fee)}),_=new qe({baseToken:m,denominator:new ce(10).pow(new ce(20+m.decimals)),quoteToken:p,numerator:A.mul(new Z(10**(20+p.decimals))).toFixed(0)}),v=new qe({baseToken:m,denominator:new ce(10).pow(new ce(20+m.decimals)),quoteToken:p,numerator:T.mul(new Z(10**(20+p.decimals))).toFixed(0)}),V=new be(m,P);return{allTrade:d,realAmountIn:I,amountOut:L,minAmountOut:x,expirationTime:g,currentPrice:_,executionPrice:v,priceImpact:h,fee:V,remainingAccounts:k,executionPriceX64:S}}static computeAmountIn({poolInfo:e,tickArrayCache:t,baseMint:n,epochInfo:r,amountOut:s,slippage:i,priceLimit:o=new Z(0)}){var x;let u=n.toBase58()===e.mintA.address,l={[e.mintA.address]:e.mintA.extensions.feeConfig,[e.mintB.address]:e.mintB.extensions.feeConfig},c;o.equals(new Z(0))?c=u?Kt.sub(new ce(1)):It.add(new ce(1)):c=X.priceToSqrtPriceX64(o,e.mintA.decimals,e.mintB.decimals);let m=ye(s,l[n.toString()],r,!0),{expectedAmountIn:p,remainingAccounts:d,executionPrice:b,feeAmount:y}=ge.getInputAmountAndRemainAccounts(e,t,n,m.amount.sub((x=m.fee)!=null?x:me),c),w=u?e.mintB.address:e.mintA.address,g=ye(p,l[w],r,!1),A=X.sqrtPriceX64ToPrice(b,e.mintA.decimals,e.mintB.decimals),T=u?A:new Z(1).div(A),h=p.mul(new ce(Math.floor((1+i)*1e10))).div(new ce(1e10)),P=ye(h,l[w],r,!0),k=u?e.currentPrice:new Z(1).div(e.currentPrice),S=new Z(T).sub(k).abs(),I=k,L=new De(new Z(S).mul(10**15).toFixed(0),new Z(I).mul(10**15).toFixed(0));return{amountIn:g,maxAmountIn:P,realAmountOut:m,expirationTime:dt(g.expirationTime,m.expirationTime),currentPrice:e.currentPrice,executionPrice:T,priceImpact:L,fee:y,remainingAccounts:d}}static estimateAprsForPriceRangeMultiplier({poolInfo:e,aprType:t,positionTickLowerIndex:n,positionTickUpperIndex:r}){var b,y,w;let s=e[t],i=E.getTickPrice({poolInfo:e,tick:n,baseIn:!0}).price.toNumber(),o=E.getTickPrice({poolInfo:e,tick:r,baseIn:!0}).price.toNumber(),u=Math.max(i,s.priceMin),c=Math.min(o,s.priceMax)-u,m=o-i,p=s.priceMax-s.priceMin,d;return c<=0?d=0:m===c?d=p/c:p===c?d=c/m:d=c/p*(c/m),{feeApr:s.feeApr*d,rewardsApr:[((b=s.rewardApr[0])!=null?b:0)*d,((y=s.rewardApr[1])!=null?y:0)*d,((w=s.rewardApr[2])!=null?w:0)*d],apr:s.apr*d}}static estimateAprsForPriceRangeDelta({poolInfo:e,poolLiquidity:t,aprType:n,mintPrice:r,liquidity:s,positionTickLowerIndex:i,positionTickUpperIndex:o,chainTime:u}){let l=n==="day"?1:n==="week"?7:n==="month"?30:0,c=e[n],m=r[Et(e.mintA.address).toString()],p=r[Et(e.mintB.address).toString()],d=e.mintA.decimals,b=e.mintB.decimals;if(!c||!m||!p)return{feeApr:0,rewardsApr:[0,0,0],apr:0};let y=X.priceToSqrtPriceX64(new Z(e.price),e.mintA.decimals,e.mintB.decimals),w=X.getSqrtPriceX64FromTick(i),g=X.getSqrtPriceX64FromTick(o),{amountSlippageA:A,amountSlippageB:T}=J.getAmountsFromLiquidityWithSlippage(y,w,g,t,!1,!1,0),{amountSlippageA:h,amountSlippageB:P}=J.getAmountsFromLiquidityWithSlippage(y,w,g,s,!1,!1,0),k=new Z(A.toString()).div(new Z(10).pow(d)).mul(m.value).add(new Z(T.toString()).div(new Z(10).pow(b)).mul(p.value)),S=new Z(h.toString()).div(new Z(10).pow(d)).mul(m.value).add(new Z(P.toString()).div(new Z(10).pow(b)).mul(p.value)),I=new Z(1).div(k.add(S)),x=new Z(c.volumeFee).mul(365).div(l).mul(I).mul(100).toNumber(),_=3600*24*365,v=e.rewardDefaultInfos.map(V=>{var ee,re;let G=V.mint.decimals,$=r[V.mint.address];return u<((ee=V.startTime)!=null?ee:0)||u>((re=V.endTime)!=null?re:0)||!V.perSecond||!$||G===void 0?0:new Z($.value).mul(new Z(V.perSecond).mul(_)).div(new Z(10).pow(G)).mul(I).mul(100).toNumber()});return{feeApr:x,rewardsApr:v,apr:x+v.reduce((V,G)=>V+G,0)}}static async getLiquidityAmountOutFromAmountIn({poolInfo:e,inputA:t,tickLower:n,tickUpper:r,amount:s,slippage:i,add:o,epochInfo:u,amountHasFee:l}){var g,A;let c=X.priceToSqrtPriceX64(new Z(e.price),e.mintA.decimals,e.mintB.decimals),m=X.getSqrtPriceX64FromTick(n),p=X.getSqrtPriceX64FromTick(r),d=ye(s,(g=e[t?"mintA":"mintB"].extensions)==null?void 0:g.feeConfig,u,!l),b=new ce(new Z(d.amount.sub((A=d.fee)!=null?A:me).toString()).toFixed(0)),y;if(c.lte(m))y=t?J.getLiquidityFromTokenAmountA(m,p,b,!o):new ce(0);else if(c.lte(p)){let T=J.getLiquidityFromTokenAmountA(c,p,b,!o),h=J.getLiquidityFromTokenAmountB(m,c,b);y=t?T:h}else y=t?new ce(0):J.getLiquidityFromTokenAmountB(m,p,b);let w=await ge.getAmountsFromLiquidity({epochInfo:u,poolInfo:e,tickLower:n,tickUpper:r,liquidity:y,slippage:i,add:o});return{liquidity:y,amountA:t?d:w.amountA,amountB:t?w.amountB:d,amountSlippageA:t?d:w.amountSlippageA,amountSlippageB:t?w.amountSlippageB:d,expirationTime:w.expirationTime}}static async getAmountsFromLiquidity({epochInfo:e,poolInfo:t,tickLower:n,tickUpper:r,liquidity:s,slippage:i,add:o}){var w,g,A,T;let u=X.getSqrtPriceX64FromTick(n),l=X.getSqrtPriceX64FromTick(r),c=o?1+i:1-i,m=J.getAmountsFromLiquidity(X.priceToSqrtPriceX64(new Z(t.price),t.mintA.decimals,t.mintB.decimals),u,l,s,o),[p,d]=[ye(m.amountA,(w=t.mintA.extensions)==null?void 0:w.feeConfig,e,!0),ye(m.amountB,(g=t.mintB.extensions)==null?void 0:g.feeConfig,e,!0)],[b,y]=[ye(m.amountA.muln(c),(A=t.mintA.extensions)==null?void 0:A.feeConfig,e,!0),ye(m.amountB.muln(c),(T=t.mintB.extensions)==null?void 0:T.feeConfig,e,!0)];return{liquidity:s,amountA:p,amountB:d,amountSlippageA:b,amountSlippageB:y,expirationTime:dt(p.expirationTime,d.expirationTime)}}static async fetchComputeMultipleClmmInfo({connection:e,poolList:t,rpcDataMap:n={}}){let r=t.filter(u=>!n[u.id]).map(u=>new We(u.id));(await ot(e,r)).forEach((u,l)=>{!u||(n[r[l].toBase58()]=eo.decode(u.data))});let i=t.map(u=>xe(new We(u.programId),new We(u.id)).publicKey),o=await ge.fetchExBitmaps({connection:e,exBitmapAddress:i,batchRequest:!1});return t.reduce((u,l)=>j(F({},u),{[l.id]:j(F({},n[l.id]),{id:new We(l.id),version:6,programId:new We(l.programId),mintA:l.mintA,mintB:l.mintB,ammConfig:j(F({},l.config),{id:new We(l.config.id),fundOwner:""}),currentPrice:new Z(l.price),exBitmapAccount:xe(new We(l.programId),new We(l.id)).publicKey,exBitmapInfo:o[xe(new We(l.programId),new We(l.id)).publicKey.toBase58()],startTime:n[l.id].startTime.toNumber(),rewardInfos:n[l.id].rewardInfos})}),{})}static async fetchComputeClmmInfo({connection:e,poolInfo:t,rpcData:n}){return(await this.fetchComputeMultipleClmmInfo({connection:e,rpcDataMap:n?{[t.id]:n}:void 0,poolList:[t]}))[t.id]}};var Q=class{static mulDivRoundingUp(e,t,n){let r=e.mul(t),s=r.div(n);return r.mod(n).eq(me)||(s=s.add(Ye)),s}static mulDivFloor(e,t,n){if(n.eq(me))throw new Error("division by 0");return e.mul(t).div(n)}static mulDivCeil(e,t,n){if(n.eq(me))throw new Error("division by 0");return e.mul(t).add(n.sub(Ye)).div(n)}static x64ToDecimal(e,t){return new Je(e.toString()).div(Je.pow(2,64)).toDecimalPlaces(t)}static decimalToX64(e){return new z(e.mul(Je.pow(2,64)).floor().toFixed())}static wrappingSubU128(e,t){return e.add(_n).sub(t).mod(_n)}};function he(a,e){return Ir(a.mul(e),64,256)}function na(a,e,t){let n=a.toTwos(t).shln(e);return n.imaskn(t+1),n.fromTwos(t)}function Ir(a,e,t){let n=a.toTwos(t).shrn(e);return n.imaskn(t-e+1),n.fromTwos(t-e)}var X=class{static sqrtPriceX64ToPrice(e,t,n){return Q.x64ToDecimal(e).pow(2).mul(Je.pow(10,t-n))}static priceToSqrtPriceX64(e,t,n){return Q.decimalToX64(e.mul(Je.pow(10,n-t)).sqrt())}static getNextSqrtPriceX64FromInput(e,t,n,r){if(!e.gt(me))throw new Error("sqrtPriceX64 must greater than 0");if(!t.gt(me))throw new Error("liquidity must greater than 0");return r?this.getNextSqrtPriceFromTokenAmountARoundingUp(e,t,n,!0):this.getNextSqrtPriceFromTokenAmountBRoundingDown(e,t,n,!0)}static getNextSqrtPriceX64FromOutput(e,t,n,r){if(!e.gt(me))throw new Error("sqrtPriceX64 must greater than 0");if(!t.gt(me))throw new Error("liquidity must greater than 0");return r?this.getNextSqrtPriceFromTokenAmountBRoundingDown(e,t,n,!1):this.getNextSqrtPriceFromTokenAmountARoundingUp(e,t,n,!1)}static getNextSqrtPriceFromTokenAmountARoundingUp(e,t,n,r){if(n.eq(me))return e;let s=t.shln(an);if(r){let i=s,o=s.add(n.mul(e));return o.gte(i)?Q.mulDivCeil(i,e,o):Q.mulDivRoundingUp(i,Ye,i.div(e).add(n))}else{let i=n.mul(e);if(!s.gt(i))throw new Error("getNextSqrtPriceFromTokenAmountARoundingUp,liquidityLeftShift must gt amountMulSqrtPrice");let o=s.sub(i);return Q.mulDivCeil(s,e,o)}}static getNextSqrtPriceFromTokenAmountBRoundingDown(e,t,n,r){let s=n.shln(an);if(r)return e.add(s.div(t));{let i=Q.mulDivRoundingUp(s,Ye,t);if(!e.gt(i))throw new Error("getNextSqrtPriceFromTokenAmountBRoundingDown sqrtPriceX64 must gt amountDivLiquidity");return e.sub(i)}}static getSqrtPriceX64FromTick(e){if(!Number.isInteger(e))throw new Error("tick must be integer");if(e<Re||e>Me)throw new Error("tick must be in MIN_TICK and MAX_TICK");let t=e<0?e*-1:e,n=(t&1)!=0?new z("18445821805675395072"):new z("18446744073709551616");return(t&2)!=0&&(n=he(n,new z("18444899583751176192"))),(t&4)!=0&&(n=he(n,new z("18443055278223355904"))),(t&8)!=0&&(n=he(n,new z("18439367220385607680"))),(t&16)!=0&&(n=he(n,new z("18431993317065453568"))),(t&32)!=0&&(n=he(n,new z("18417254355718170624"))),(t&64)!=0&&(n=he(n,new z("18387811781193609216"))),(t&128)!=0&&(n=he(n,new z("18329067761203558400"))),(t&256)!=0&&(n=he(n,new z("18212142134806163456"))),(t&512)!=0&&(n=he(n,new z("17980523815641700352"))),(t&1024)!=0&&(n=he(n,new z("17526086738831433728"))),(t&2048)!=0&&(n=he(n,new z("16651378430235570176"))),(t&4096)!=0&&(n=he(n,new z("15030750278694412288"))),(t&8192)!=0&&(n=he(n,new z("12247334978884435968"))),(t&16384)!=0&&(n=he(n,new z("8131365268886854656"))),(t&32768)!=0&&(n=he(n,new z("3584323654725218816"))),(t&65536)!=0&&(n=he(n,new z("696457651848324352"))),(t&131072)!=0&&(n=he(n,new z("26294789957507116"))),(t&262144)!=0&&(n=he(n,new z("37481735321082"))),e>0&&(n=Oi.div(n)),n}static getTickFromPrice(e,t,n){return X.getTickFromSqrtPriceX64(X.priceToSqrtPriceX64(e,t,n))}static getTickFromSqrtPriceX64(e){if(e.gt(Kt)||e.lt(It))throw new Error("Provided sqrtPrice is not within the supported sqrtPrice range.");let t=e.bitLength()-1,n=new z(t-64),r=na(n,32,128),s=new z("8000000000000000","hex"),i=0,o=new z(0),u=t>=64?e.shrn(t-63):e.shln(63-t);for(;s.gt(new z(0))&&i<Di;){u=u.mul(u);let b=u.shrn(127);u=u.shrn(63+b.toNumber()),o=o.add(s.mul(b)),s=s.shrn(1),i+=1}let l=o.shrn(32),m=r.add(l).mul(new z(qi)),p=Ir(m.sub(new z(Gi)),64,128).toNumber(),d=Ir(m.add(new z(Ui)),64,128).toNumber();return p==d?p:X.getSqrtPriceX64FromTick(d).lte(e)?d:p}},Ct=class{static getTickWithPriceAndTickspacing(e,t,n,r){let i=X.getTickFromSqrtPriceX64(X.priceToSqrtPriceX64(e,n,r))/t;return i<0?i=Math.floor(i):i=Math.ceil(i),i*t}static roundPriceWithTickspacing(e,t,n,r){let s=Ct.getTickWithPriceAndTickspacing(e,t,n,r),i=X.getSqrtPriceX64FromTick(s);return X.sqrtPriceX64ToPrice(i,n,r)}},J=class{static addDelta(e,t){return e.add(t)}static getTokenAmountAFromLiquidity(e,t,n,r){if(e.gt(t)&&([e,t]=[t,e]),!e.gt(me))throw new Error("sqrtPriceX64A must greater than 0");let s=n.ushln(an),i=t.sub(e);return r?Q.mulDivRoundingUp(Q.mulDivCeil(s,i,t),Ye,e):Q.mulDivFloor(s,i,t).div(e)}static getTokenAmountBFromLiquidity(e,t,n,r){if(e.gt(t)&&([e,t]=[t,e]),!e.gt(me))throw new Error("sqrtPriceX64A must greater than 0");return r?Q.mulDivCeil(n,t.sub(e),Ve):Q.mulDivFloor(n,t.sub(e),Ve)}static getLiquidityFromTokenAmountA(e,t,n,r){e.gt(t)&&([e,t]=[t,e]);let s=n.mul(e).mul(t),i=t.sub(e),o=s.div(i);return r?Q.mulDivRoundingUp(o,Ye,kr):o.shrn(an)}static getLiquidityFromTokenAmountB(e,t,n){return e.gt(t)&&([e,t]=[t,e]),Q.mulDivFloor(n,kr,t.sub(e))}static getLiquidityFromTokenAmounts(e,t,n,r,s){if(t.gt(n)&&([t,n]=[n,t]),e.lte(t))return J.getLiquidityFromTokenAmountA(t,n,r,!1);if(e.lt(n)){let i=J.getLiquidityFromTokenAmountA(e,n,r,!1),o=J.getLiquidityFromTokenAmountB(t,e,s);return i.lt(o)?i:o}else return J.getLiquidityFromTokenAmountB(t,n,s)}static getAmountsFromLiquidity(e,t,n,r,s){if(t.gt(n)&&([t,n]=[n,t]),e.lte(t))return{amountA:J.getTokenAmountAFromLiquidity(t,n,r,s),amountB:new z(0)};if(e.lt(n)){let i=J.getTokenAmountAFromLiquidity(e,n,r,s),o=J.getTokenAmountBFromLiquidity(t,e,r,s);return{amountA:i,amountB:o}}else return{amountA:new z(0),amountB:J.getTokenAmountBFromLiquidity(t,n,r,s)}}static getAmountsFromLiquidityWithSlippage(e,t,n,r,s,i,o){let{amountA:u,amountB:l}=J.getAmountsFromLiquidity(e,t,n,r,i),c=s?1+o:1-o,m=new z(new Je(u.toString()).mul(c).toFixed(0)),p=new z(new Je(l.toString()).mul(c).toFixed(0));return{amountSlippageA:m,amountSlippageB:p}}static getAmountsOutFromLiquidity({poolInfo:e,tickLower:t,tickUpper:n,liquidity:r,slippage:s,add:i,epochInfo:o,amountAddFee:u}){var A,T,h,P;let l=X.priceToSqrtPriceX64(new Je(e.price),e.mintA.decimals,e.mintB.decimals),c=X.getSqrtPriceX64FromTick(t),m=X.getSqrtPriceX64FromTick(n),p=i?1+s:1-s,d=J.getAmountsFromLiquidity(l,c,m,r,i),[b,y]=[ye(d.amountA,(A=e.mintA.extensions)==null?void 0:A.feeConfig,o,u),ye(d.amountB,(T=e.mintB.extensions)==null?void 0:T.feeConfig,o,u)],[w,g]=[ye(new z(new Je(d.amountA.toString()).mul(p).toFixed(0)),(h=e.mintA.extensions)==null?void 0:h.feeConfig,o,u),ye(new z(new Je(d.amountB.toString()).mul(p).toFixed(0)),(P=e.mintB.extensions)==null?void 0:P.feeConfig,o,u)];return{liquidity:r,amountA:b,amountB:y,amountSlippageA:w,amountSlippageB:g,expirationTime:dt(b.expirationTime,y.expirationTime)}}},Rt=class{static swapCompute(e,t,n,r,s,i,o,u,l,c,m,p,d,b,y=!1){if(p.eq(me))throw new Error("amountSpecified must not be 0");if(b||(b=i?It.add(Ye):Kt.sub(Ye)),i){if(b.lt(It))throw new Error("sqrtPriceX64 must greater than MIN_SQRT_PRICE_X64");if(b.gte(m))throw new Error("sqrtPriceX64 must smaller than current")}else{if(b.gt(Kt))throw new Error("sqrtPriceX64 must smaller than MAX_SQRT_PRICE_X64");if(b.lte(m))throw new Error("sqrtPriceX64 must greater than current")}let w=p.gt(me),g={amountSpecifiedRemaining:p,amountCalculated:me,sqrtPriceX64:m,tick:l>d?Math.min(d+Y.tickCount(c)-1,l):d,accounts:[],liquidity:u,feeAmount:new z(0)},A=d,T=n[d],h=0,P=!i&&T.startTickIndex===g.tick;for(;!g.amountSpecifiedRemaining.eq(me)&&!g.sqrtPriceX64.eq(b);){h>10;let k={};k.sqrtPriceStartX64=g.sqrtPriceX64;let S=E.nextInitTick(T,g.tick,c,i,P),I=S||null,L=null;if(!(I!=null&&I.liquidityGross.gtn(0))){let _=ge.nextInitializedTickArrayStartIndex({tickCurrent:g.tick,tickSpacing:c,tickArrayBitmap:r,exBitmapInfo:s},A,i);if(!_.isExist){if(y)return{allTrade:!1,amountSpecifiedRemaining:g.amountSpecifiedRemaining,amountCalculated:g.amountCalculated,feeAmount:g.feeAmount,sqrtPriceX64:g.sqrtPriceX64,liquidity:g.liquidity,tickCurrent:g.tick,accounts:g.accounts};throw Error("swapCompute LiquidityInsufficient")}A=_.nextStartIndex;let{publicKey:v}=ne(e,t,A);L=v,T=n[A];try{I=E.firstInitializedTick(T,i)}catch{throw Error("not found next tick info")}}k.tickNext=I.tick,k.initialized=I.liquidityGross.gtn(0),d!==A&&L&&(g.accounts.push(L),d=A),k.tickNext<Re?k.tickNext=Re:k.tickNext>Me&&(k.tickNext=Me),k.sqrtPriceNextX64=X.getSqrtPriceX64FromTick(k.tickNext);let x;if(i&&k.sqrtPriceNextX64.lt(b)||!i&&k.sqrtPriceNextX64.gt(b)?x=b:x=k.sqrtPriceNextX64,[g.sqrtPriceX64,k.amountIn,k.amountOut,k.feeAmount]=Rt.swapStepCompute(g.sqrtPriceX64,x,g.liquidity,g.amountSpecifiedRemaining,o,i),g.feeAmount=g.feeAmount.add(k.feeAmount),w?(g.amountSpecifiedRemaining=g.amountSpecifiedRemaining.sub(k.amountIn.add(k.feeAmount)),g.amountCalculated=g.amountCalculated.sub(k.amountOut)):(g.amountSpecifiedRemaining=g.amountSpecifiedRemaining.add(k.amountOut),g.amountCalculated=g.amountCalculated.add(k.amountIn.add(k.feeAmount))),g.sqrtPriceX64.eq(k.sqrtPriceNextX64)){if(k.initialized){let _=I.liquidityNet;i&&(_=_.mul(st)),g.liquidity=J.addDelta(g.liquidity,_)}P=k.tickNext!=g.tick&&!i&&T.startTickIndex===k.tickNext,g.tick=i?k.tickNext-1:k.tickNext}else if(g.sqrtPriceX64!=k.sqrtPriceStartX64){let _=X.getTickFromSqrtPriceX64(g.sqrtPriceX64);P=_!=g.tick&&!i&&T.startTickIndex===_,g.tick=_}++h}try{let{nextStartIndex:k,isExist:S}=Y.nextInitializedTickArray(g.tick,c,i,r,s);S&&d!==k&&(g.accounts.push(ne(e,t,k).publicKey),d=k)}catch{}return{allTrade:!0,amountSpecifiedRemaining:me,amountCalculated:g.amountCalculated,feeAmount:g.feeAmount,sqrtPriceX64:g.sqrtPriceX64,liquidity:g.liquidity,tickCurrent:g.tick,accounts:g.accounts}}static swapStepCompute(e,t,n,r,s,i){let o={sqrtPriceX64Next:new z(0),amountIn:new z(0),amountOut:new z(0),feeAmount:new z(0)},u=r.gte(me);if(u){let c=Q.mulDivFloor(r,Vn.sub(new z(s.toString())),Vn);o.amountIn=i?J.getTokenAmountAFromLiquidity(t,e,n,!0):J.getTokenAmountBFromLiquidity(e,t,n,!0),c.gte(o.amountIn)?o.sqrtPriceX64Next=t:o.sqrtPriceX64Next=X.getNextSqrtPriceX64FromInput(e,n,c,i)}else o.amountOut=i?J.getTokenAmountBFromLiquidity(t,e,n,!1):J.getTokenAmountAFromLiquidity(e,t,n,!1),r.mul(st).gte(o.amountOut)?o.sqrtPriceX64Next=t:o.sqrtPriceX64Next=X.getNextSqrtPriceX64FromOutput(e,n,r.mul(st),i);let l=t.eq(o.sqrtPriceX64Next);return i?(l&&u||(o.amountIn=J.getTokenAmountAFromLiquidity(o.sqrtPriceX64Next,e,n,!0)),l&&!u||(o.amountOut=J.getTokenAmountBFromLiquidity(o.sqrtPriceX64Next,e,n,!1))):(o.amountIn=l&&u?o.amountIn:J.getTokenAmountBFromLiquidity(e,o.sqrtPriceX64Next,n,!0),o.amountOut=l&&!u?o.amountOut:J.getTokenAmountAFromLiquidity(e,o.sqrtPriceX64Next,n,!1)),!u&&o.amountOut.gt(r.mul(st))&&(o.amountOut=r.mul(st)),u&&!o.sqrtPriceX64Next.eq(t)?o.feeAmount=r.sub(o.amountIn):o.feeAmount=Q.mulDivCeil(o.amountIn,new z(s),Vn.sub(new z(s))),[o.sqrtPriceX64Next,o.amountIn,o.amountOut,o.feeAmount]}};var Te=60,Lt=512,E=class{static getTickArrayAddressByTick(e,t,n,r){let s=E.getTickArrayStartIndexByTick(n,r),{publicKey:i}=ne(e,t,s);return i}static getTickOffsetInArray(e,t){if(e%t!=0)throw new Error("tickIndex % tickSpacing not equal 0");let n=E.getTickArrayStartIndexByTick(e,t),r=Math.floor((e-n)/t);if(r<0||r>=Te)throw new Error("tick offset in array overflow");return r}static getTickArrayBitIndex(e,t){let n=Y.tickCount(t),r=e/n;return e<0&&e%n!=0?r=Math.ceil(r)-1:r=Math.floor(r),r}static getTickArrayStartIndexByTick(e,t){return this.getTickArrayBitIndex(e,t)*Y.tickCount(t)}static getTickArrayOffsetInBitmapByTick(e,t){let n=t*Te,r=Math.floor(e/n)+512;return Math.abs(r)}static checkTickArrayIsInitialized(e,t,n){let r=n*Te,s=Math.floor(t/r)+512,i=Math.abs(s);return{isInitialized:e.testn(i),startIndex:(i-512)*r}}static getNextTickArrayStartIndex(e,t,n){return n?e-t*Te:e+t*Te}static mergeTickArrayBitmap(e){let t=new ra(0);for(let n=0;n<e.length;n++)t=t.add(e[n].shln(64*n));return t}static getInitializedTickArrayInRange(e,t,n,r,s){let i=Math.floor(r/(n*Te));return[...E.searchLowBitFromStart(e,t,i-1,s,n),...E.searchHightBitFromStart(e,t,i,s,n)]}static getAllInitializedTickArrayStartIndex(e,t,n){return E.searchHightBitFromStart(e,t,-7680,Lt,n)}static getAllInitializedTickArrayInfo(e,t,n,r,s){let i=[],o=E.getAllInitializedTickArrayStartIndex(n,r,s);for(let u of o){let{publicKey:l}=ne(e,t,u);i.push({tickArrayStartIndex:u,tickArrayAddress:l})}return i}static getAllInitializedTickInTickArray(e){return e.ticks.filter(t=>t.liquidityGross.gtn(0))}static searchLowBitFromStart(e,t,n,r,s){let i=[...[...t.negativeTickArrayBitmap].reverse(),e.slice(0,8),e.slice(8,16),...t.positiveTickArrayBitmap].map(l=>E.mergeTickArrayBitmap(l)),o=[];for(;n>=-7680;){let l=Math.floor((n+7680)/512),c=(n+7680)%512;if(i[l].testn(c)&&o.push(n),n--,o.length===r)break}let u=Y.tickCount(s);return o.map(l=>l*u)}static searchHightBitFromStart(e,t,n,r,s){let i=[...[...t.negativeTickArrayBitmap].reverse(),e.slice(0,8),e.slice(8,16),...t.positiveTickArrayBitmap].map(l=>E.mergeTickArrayBitmap(l)),o=[];for(;n<7680;){let l=Math.floor((n+7680)/512),c=(n+7680)%512;if(i[l].testn(c)&&o.push(n),n++,o.length===r)break}let u=Y.tickCount(s);return o.map(l=>l*u)}static checkIsOutOfBoundary(e){return e<Re||e>Me}static nextInitTick(e,t,n,r,s){if(Y.getArrayStartIndex(t,n)!=e.startTickIndex)return null;let o=Math.floor((t-e.startTickIndex)/n);if(r)for(;o>=0;){if(e.ticks[o].liquidityGross.gtn(0))return e.ticks[o];o=o-1}else for(s||(o=o+1);o<Te;){if(e.ticks[o].liquidityGross.gtn(0))return e.ticks[o];o=o+1}return null}static firstInitializedTick(e,t){if(t){let n=Te-1;for(;n>=0;){if(e.ticks[n].liquidityGross.gtn(0))return e.ticks[n];n=n-1}}else{let n=0;for(;n<Te;){if(e.ticks[n].liquidityGross.gtn(0))return e.ticks[n];n=n+1}}throw Error(`firstInitializedTick check error: ${e} - ${t}`)}static _getTickPriceLegacy({poolInfo:e,tick:t,baseIn:n}){let r=X.getSqrtPriceX64FromTick(t),s=X.sqrtPriceX64ToPrice(r,e.mintA.decimals,e.mintB.decimals);return n?{tick:t,price:s,tickSqrtPriceX64:r}:{tick:t,price:new Xt(1).div(s),tickSqrtPriceX64:r}}static _getPriceAndTickLegacy({poolInfo:e,price:t,baseIn:n}){let r=n?t:new Xt(1).div(t),s=Ct.getTickWithPriceAndTickspacing(r,e.ammConfig.tickSpacing,e.mintA.decimals,e.mintB.decimals),i=X.getSqrtPriceX64FromTick(s),o=X.sqrtPriceX64ToPrice(i,e.mintA.decimals,e.mintB.decimals);return n?{tick:s,price:o}:{tick:s,price:new Xt(1).div(o)}}static getTickPrice({poolInfo:e,tick:t,baseIn:n}){let r=X.getSqrtPriceX64FromTick(t),s=X.sqrtPriceX64ToPrice(r,e.mintA.decimals,e.mintB.decimals);return n?{tick:t,price:s,tickSqrtPriceX64:r}:{tick:t,price:new Xt(1).div(s),tickSqrtPriceX64:r}}static getPriceAndTick({poolInfo:e,price:t,baseIn:n}){let r=n?t:new Xt(1).div(t),s=Ct.getTickWithPriceAndTickspacing(r,e.config.tickSpacing,e.mintA.decimals,e.mintB.decimals),i=X.getSqrtPriceX64FromTick(s),o=X.sqrtPriceX64ToPrice(i,e.mintA.decimals,e.mintB.decimals);return n?{tick:s,price:o}:{tick:s,price:new Xt(1).div(o)}}};var ob=C([Ae(8),W("bump"),xt("index"),K(""),Ke("protocolFeeRate"),Ke("tradeFeeRate"),xt("tickSpacing"),q(f(),8,"")]),ia=C([Ke("blockTimestamp"),Gt("tickCumulative"),q(f(),4)]),ro=C([Ae(8),Pe("initialized"),f("recentEpoch"),xt("observationIndex"),K("poolId"),q(ia,100,"observations"),q(f(),4)]),oa=C([W("rewardState"),f("openTime"),f("endTime"),f("lastUpdateTime"),D("emissionsPerSecondX64"),f("rewardTotalEmissioned"),f("rewardClaimed"),K("tokenMint"),K("tokenVault"),K("creator"),D("rewardGrowthGlobalX64")]),eo=C([Ae(8),W("bump"),K("ammConfig"),K("creator"),K("mintA"),K("mintB"),K("vaultA"),K("vaultB"),K("observationId"),W("mintDecimalsA"),W("mintDecimalsB"),xt("tickSpacing"),D("liquidity"),D("sqrtPriceX64"),ue("tickCurrent"),Ke(),D("feeGrowthGlobalX64A"),D("feeGrowthGlobalX64B"),f("protocolFeesTokenA"),f("protocolFeesTokenB"),D("swapInAmountTokenA"),D("swapOutAmountTokenB"),D("swapInAmountTokenB"),D("swapOutAmountTokenA"),W("status"),q(W(),7,""),q(oa,3,"rewardInfos"),q(f(),16,"tickArrayBitmap"),f("totalFeesTokenA"),f("totalFeesClaimedTokenA"),f("totalFeesTokenB"),f("totalFeesClaimedTokenB"),f("fundFeesTokenA"),f("fundFeesTokenB"),f("startTime"),q(f(),15*4-3,"padding")]),sa=C([D("growthInsideLastX64"),f("rewardAmountOwed")]),to=C([Ae(8),W("bump"),K("nftMint"),K("poolId"),ue("tickLower"),ue("tickUpper"),D("liquidity"),D("feeGrowthInsideLastX64A"),D("feeGrowthInsideLastX64B"),f("tokenFeesOwedA"),f("tokenFeesOwedB"),q(sa,3,"rewardInfos"),q(f(),8,"")]),sb=C([Ae(8),W("bump"),K("poolId"),ue("tickLowerIndex"),ue("tickUpperIndex"),D("liquidity"),D("feeGrowthInsideLastX64A"),D("feeGrowthInsideLastX64B"),f("tokenFeesOwedA"),f("tokenFeesOwedB"),q(D(),3,"rewardGrowthInside"),q(f(),8,"")]),aa=C([ue("tick"),Ri("liquidityNet"),D("liquidityGross"),D("feeGrowthOutsideX64A"),D("feeGrowthOutsideX64B"),q(D(),3,"rewardGrowthsOutsideX64"),q(Ke(),13,"")]),mn=C([Ae(8),K("poolId"),ue("startTickIndex"),q(aa,Te,"ticks"),W("initializedTickCount"),q(W(),115,"")]),ab=C([Ae(329),q(K(),100,"whitelistMints")]),no=C([Ae(8),K("poolId"),q(q(f(),8),Br,"positiveTickArrayBitmap"),q(q(f(),8),Br,"negativeTickArrayBitmap")]),ub=C([f(),W("bump"),K("owner"),K("poolId"),K("positionId"),K("nftAccount"),q(f(),8)]),cb=C([Ae(8),W("bump"),K("lockOwner"),K("poolId"),K("positionId"),K("nftAccount"),K("lockNftMint"),f("recentEpoch"),q(f(),8)]);ro.span;var io=ie("Raydium_Clmm"),Ee={createPool:[233,146,209,142,207,104,64,188],initReward:[95,135,192,196,242,129,230,68],setRewardEmissions:[112,52,167,75,32,201,211,137],openPosition:[77,184,74,214,112,86,241,199],openPositionWithTokenEx:[77,255,174,82,125,29,201,46],closePosition:[123,134,81,0,49,68,98,98],increaseLiquidity:[133,29,89,223,69,238,176,10],decreaseLiquidity:[58,127,188,62,79,82,196,96],swap:[43,4,237,11,26,201,30,98],collectReward:[18,237,166,197,34,16,213,144]},oo=[188,37,179,131,82,150,84,73],so=[16,72,250,198,14,162,212,19],Qt=class{static createPoolInstruction(e,t,n,r,s,i,o,u,l,c,m,p,d,b){let y=C([D("sqrtPriceX64"),f("zero")]),w=[{pubkey:n,isSigner:!0,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!1},{pubkey:l,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:p,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!1},{pubkey:m,isSigner:!1,isWritable:!1},{pubkey:ut.programId,isSigner:!1,isWritable:!1},{pubkey:Xe,isSigner:!1,isWritable:!1},...(b==null?void 0:b.map(T=>({pubkey:T,isSigner:!1,isWritable:!1})))||[]],g=Buffer.alloc(y.span);y.encode({sqrtPriceX64:d,zero:me},g);let A=Buffer.from([...Ee.createPool,...g]);return new Se({keys:w,programId:e,data:A})}static async createPoolInstructions(e){let{programId:t,owner:n,mintA:r,mintB:s,ammConfigId:i,initialPriceX64:o,extendMintAccount:u}=e,[l,c]=[new R(r.address),new R(s.address)],{publicKey:m}=ji(t,i,l,c),{publicKey:p}=Yi(t,m),{publicKey:d}=Tr(t,m,l),{publicKey:b}=Tr(t,m,c),y=xe(t,m).publicKey,w=[this.createPoolInstruction(t,m,n,i,p,l,d,new R(r.programId||oe),c,b,new R(s.programId||oe),y,o,u)];return{signers:[],instructions:w,instructionTypes:[U.CreateAccount,U.ClmmCreatePool],address:{poolId:m,observationId:p,exBitmapAccount:y,mintAVault:d,mintBVault:b},lookupTableAddress:[]}}static openPositionFromLiquidityInstruction(e,t,n,r,s,i,o,u,l,c,m,p,d,b,y,w,g,A,T,h,P,k,S,I,L,x){let _=C([ue("tickLowerIndex"),ue("tickUpperIndex"),ue("tickArrayLowerStartIndex"),ue("tickArrayUpperStartIndex"),D("liquidity"),f("amountMaxA"),f("amountMaxB"),Pe("withMetadata"),W("optionBaseFlag"),Pe("baseFlag")]),v=[...x?[{pubkey:x,isSigner:!1,isWritable:!0}]:[]],V=[{pubkey:t,isSigner:!0,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!1},{pubkey:s,isSigner:!0,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:m,isSigner:!1,isWritable:!0},{pubkey:p,isSigner:!1,isWritable:!0},{pubkey:d,isSigner:!1,isWritable:!0},{pubkey:b,isSigner:!1,isWritable:!0},{pubkey:y,isSigner:!1,isWritable:!0},{pubkey:Xe,isSigner:!1,isWritable:!1},{pubkey:ut.programId,isSigner:!1,isWritable:!1},{pubkey:oe,isSigner:!1,isWritable:!1},{pubkey:pn,isSigner:!1,isWritable:!1},{pubkey:wt,isSigner:!1,isWritable:!1},{pubkey:pe,isSigner:!1,isWritable:!1},{pubkey:w,isSigner:!1,isWritable:!1},{pubkey:g,isSigner:!1,isWritable:!1},...v],G=Buffer.alloc(_.span);_.encode({tickLowerIndex:A,tickUpperIndex:T,tickArrayLowerStartIndex:h,tickArrayUpperStartIndex:P,liquidity:k,amountMaxA:S,amountMaxB:I,withMetadata:L==="create",baseFlag:!1,optionBaseFlag:0},G);let $=Buffer.from([...Ee.openPosition,...G]);return new Se({keys:V,programId:e,data:$})}static openPositionFromLiquidityInstruction22(e,t,n,r,s,i,o,u,l,c,m,p,d,b,y,w,g,A,T,h,P,k,S,I,L){let x=C([ue("tickLowerIndex"),ue("tickUpperIndex"),ue("tickArrayLowerStartIndex"),ue("tickArrayUpperStartIndex"),D("liquidity"),f("amountMaxA"),f("amountMaxB"),Pe("withMetadata"),W("optionBaseFlag"),Pe("baseFlag")]),_=[...L?[{pubkey:L,isSigner:!1,isWritable:!0}]:[]],v=[{pubkey:t,isSigner:!0,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!1},{pubkey:s,isSigner:!0,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:m,isSigner:!1,isWritable:!0},{pubkey:p,isSigner:!1,isWritable:!0},{pubkey:d,isSigner:!1,isWritable:!0},{pubkey:b,isSigner:!1,isWritable:!0},{pubkey:Xe,isSigner:!1,isWritable:!1},{pubkey:ut.programId,isSigner:!1,isWritable:!1},{pubkey:oe,isSigner:!1,isWritable:!1},{pubkey:pn,isSigner:!1,isWritable:!1},{pubkey:pe,isSigner:!1,isWritable:!1},{pubkey:y,isSigner:!1,isWritable:!1},{pubkey:w,isSigner:!1,isWritable:!1},..._],V=Buffer.alloc(x.span);x.encode({tickLowerIndex:g,tickUpperIndex:A,tickArrayLowerStartIndex:T,tickArrayUpperStartIndex:h,liquidity:P,amountMaxA:k,amountMaxB:S,withMetadata:I==="create",baseFlag:!1,optionBaseFlag:0},V);let G=Buffer.from([...Ee.openPositionWithTokenEx,...V]);return new Se({keys:v,programId:e,data:G})}static async openPositionInstructions({poolInfo:e,poolKeys:t,ownerInfo:n,tickLower:r,tickUpper:s,liquidity:i,amountMaxA:o,amountMaxB:u,withMetadata:l,getEphemeralSigners:c,nft2022:m}){let p=[],[d,b]=[new R(e.programId),new R(e.id)],y;if(c)y=new R((await c(1))[0]);else{let L=Wn.generate();p.push(L),y=L.publicKey}let w=E.getTickArrayStartIndexByTick(r,e.config.tickSpacing),g=E.getTickArrayStartIndexByTick(s,e.config.tickSpacing),{publicKey:A}=ne(d,b,w),{publicKey:T}=ne(d,b,g),{publicKey:h}=m?ae(n.wallet,y,pe):ae(n.wallet,y,oe),{publicKey:P}=cn(y),{publicKey:k}=ve(d,y),{publicKey:S}=pt(d,b,r,s),I=m?this.openPositionFromLiquidityInstruction22(d,n.feePayer,b,n.wallet,y,h,S,A,T,k,n.tokenAccountA,n.tokenAccountB,new R(t.vault.A),new R(t.vault.B),new R(e.mintA.address),new R(e.mintB.address),r,s,w,g,i,o,u,l,ge.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing,[w,g])?xe(d,b).publicKey:void 0):this.openPositionFromLiquidityInstruction(d,n.feePayer,b,n.wallet,y,h,P,S,A,T,k,n.tokenAccountA,n.tokenAccountB,new R(t.vault.A),new R(t.vault.B),new R(e.mintA.address),new R(e.mintB.address),r,s,w,g,i,o,u,l,ge.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing,[w,g])?xe(d,b).publicKey:void 0);return{signers:p,instructions:[I],instructionTypes:[U.ClmmOpenPosition],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[],address:{nftMint:y,tickArrayLower:A,tickArrayUpper:T,positionNftAccount:h,metadataAccount:P,personalPosition:k,protocolPosition:S}}}static async openPositionFromBaseInstructions({poolInfo:e,poolKeys:t,ownerInfo:n,tickLower:r,tickUpper:s,base:i,baseAmount:o,otherAmountMax:u,withMetadata:l,getEphemeralSigners:c,nft2022:m}){let p=[],[d,b]=[new R(e.programId),new R(e.id)],y;if(c)y=new R((await c(1))[0]);else{let L=Wn.generate();p.push(L),y=L.publicKey}let w=E.getTickArrayStartIndexByTick(r,e.config.tickSpacing),g=E.getTickArrayStartIndexByTick(s,e.config.tickSpacing),{publicKey:A}=ne(d,b,w),{publicKey:T}=ne(d,b,g),{publicKey:h}=m?ae(n.wallet,y,pe):ae(n.wallet,y,oe),{publicKey:P}=cn(y),{publicKey:k}=ve(d,y),{publicKey:S}=pt(d,b,r,s),I=m?this.openPositionFromBaseInstruction22(d,n.feePayer,b,n.wallet,y,h,S,A,T,k,n.tokenAccountA,n.tokenAccountB,new R(t.vault.A),new R(t.vault.B),new R(e.mintA.address),new R(e.mintB.address),r,s,w,g,l,i,o,u,ge.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing,[w,g])?xe(d,b).publicKey:void 0):this.openPositionFromBaseInstruction(d,n.feePayer,b,n.wallet,y,h,P,S,A,T,k,n.tokenAccountA,n.tokenAccountB,new R(t.vault.A),new R(t.vault.B),new R(e.mintA.address),new R(e.mintB.address),r,s,w,g,l,i,o,u,ge.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing,[w,g])?xe(d,b).publicKey:void 0);return{address:{nftMint:y,tickArrayLower:A,tickArrayUpper:T,positionNftAccount:h,metadataAccount:P,personalPosition:k,protocolPosition:S},instructions:[I],signers:p,instructionTypes:[U.ClmmOpenPosition],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[]}}static openPositionFromBaseInstruction(e,t,n,r,s,i,o,u,l,c,m,p,d,b,y,w,g,A,T,h,P,k,S,I,L,x){let _=C([ue("tickLowerIndex"),ue("tickUpperIndex"),ue("tickArrayLowerStartIndex"),ue("tickArrayUpperStartIndex"),D("liquidity"),f("amountMaxA"),f("amountMaxB"),Pe("withMetadata"),W("optionBaseFlag"),Pe("baseFlag")]),v=[...x?[{pubkey:x,isSigner:!1,isWritable:!0}]:[]],V=[{pubkey:t,isSigner:!0,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!1},{pubkey:s,isSigner:!0,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:m,isSigner:!1,isWritable:!0},{pubkey:p,isSigner:!1,isWritable:!0},{pubkey:d,isSigner:!1,isWritable:!0},{pubkey:b,isSigner:!1,isWritable:!0},{pubkey:y,isSigner:!1,isWritable:!0},{pubkey:Xe,isSigner:!1,isWritable:!1},{pubkey:ut.programId,isSigner:!1,isWritable:!1},{pubkey:oe,isSigner:!1,isWritable:!1},{pubkey:pn,isSigner:!1,isWritable:!1},{pubkey:wt,isSigner:!1,isWritable:!1},{pubkey:pe,isSigner:!1,isWritable:!1},{pubkey:w,isSigner:!1,isWritable:!1},{pubkey:g,isSigner:!1,isWritable:!1},...v],G=Buffer.alloc(_.span);_.encode({tickLowerIndex:A,tickUpperIndex:T,tickArrayLowerStartIndex:h,tickArrayUpperStartIndex:P,liquidity:new Kr(0),amountMaxA:S==="MintA"?I:L,amountMaxB:S==="MintA"?L:I,withMetadata:k==="create",baseFlag:S==="MintA",optionBaseFlag:1},G);let $=Buffer.from([...Ee.openPosition,...G]);return new Se({keys:V,programId:e,data:$})}static openPositionFromBaseInstruction22(e,t,n,r,s,i,o,u,l,c,m,p,d,b,y,w,g,A,T,h,P,k,S,I,L){let x=C([ue("tickLowerIndex"),ue("tickUpperIndex"),ue("tickArrayLowerStartIndex"),ue("tickArrayUpperStartIndex"),D("liquidity"),f("amountMaxA"),f("amountMaxB"),Pe("withMetadata"),W("optionBaseFlag"),Pe("baseFlag")]),_=[...L?[{pubkey:L,isSigner:!1,isWritable:!0}]:[]],v=[{pubkey:t,isSigner:!0,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!1},{pubkey:s,isSigner:!0,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:m,isSigner:!1,isWritable:!0},{pubkey:p,isSigner:!1,isWritable:!0},{pubkey:d,isSigner:!1,isWritable:!0},{pubkey:b,isSigner:!1,isWritable:!0},{pubkey:Xe,isSigner:!1,isWritable:!1},{pubkey:ut.programId,isSigner:!1,isWritable:!1},{pubkey:oe,isSigner:!1,isWritable:!1},{pubkey:pn,isSigner:!1,isWritable:!1},{pubkey:pe,isSigner:!1,isWritable:!1},{pubkey:y,isSigner:!1,isWritable:!1},{pubkey:w,isSigner:!1,isWritable:!1},..._],V=Buffer.alloc(x.span);x.encode({tickLowerIndex:g,tickUpperIndex:A,tickArrayLowerStartIndex:T,tickArrayUpperStartIndex:h,liquidity:new Kr(0),amountMaxA:k==="MintA"?S:I,amountMaxB:k==="MintA"?I:S,withMetadata:P==="create",baseFlag:k==="MintA",optionBaseFlag:1},V);let G=Buffer.from([...Ee.openPositionWithTokenEx,...V]);return new Se({keys:v,programId:e,data:G})}static async openPositionFromLiquidityInstructions({poolInfo:e,poolKeys:t,ownerInfo:n,tickLower:r,tickUpper:s,liquidity:i,amountMaxA:o,amountMaxB:u,withMetadata:l,getEphemeralSigners:c,nft2022:m}){let p,d=[];if(c)p=new R((await c(1))[0]);else{let L=Wn.generate();d.push(L),p=L.publicKey}let[b,y]=[new R(e.programId),new R(e.id)],w=E.getTickArrayStartIndexByTick(r,e.config.tickSpacing),g=E.getTickArrayStartIndexByTick(s,e.config.tickSpacing),{publicKey:A}=ne(b,y,w),{publicKey:T}=ne(b,y,g),{publicKey:h}=m?ae(n.wallet,p,pe):ae(n.wallet,p,oe),{publicKey:P}=cn(p),{publicKey:k}=ve(b,p),{publicKey:S}=pt(b,y,r,s),I=m?this.openPositionFromLiquidityInstruction22(b,n.wallet,y,n.wallet,p,h,S,A,T,k,n.tokenAccountA,n.tokenAccountB,new R(t.vault.A),new R(t.vault.B),new R(t.mintA.address),new R(t.mintB.address),r,s,w,g,i,o,u,l,ge.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing,[w,g])?xe(b,y).publicKey:void 0):this.openPositionFromLiquidityInstruction(b,n.wallet,y,n.wallet,p,h,P,S,A,T,k,n.tokenAccountA,n.tokenAccountB,new R(t.vault.A),new R(t.vault.B),new R(t.mintA.address),new R(t.mintB.address),r,s,w,g,i,o,u,l,ge.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing,[w,g])?xe(b,y).publicKey:void 0);return{address:{nftMint:p,tickArrayLower:A,tickArrayUpper:T,positionNftAccount:h,metadataAccount:P,personalPosition:k,protocolPosition:S},instructions:[I],signers:d,instructionTypes:[U.ClmmOpenPosition],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[]}}static closePositionInstruction(e,t,n,r,s,i){let o=C([]),u=[{pubkey:t,isSigner:!0,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:ut.programId,isSigner:!1,isWritable:!1},{pubkey:i?pe:oe,isSigner:!1,isWritable:!1}],l=Buffer.alloc(o.span);o.encode({},l);let c=Buffer.from([...Ee.closePosition,...l]);return new Se({keys:u,programId:e,data:c})}static closePositionInstructions({poolInfo:e,poolKeys:t,ownerInfo:n,ownerPosition:r,nft2022:s}){let i=new R(e.programId),o=s?ae(n.wallet,r.nftMint,pe).publicKey:ae(n.wallet,r.nftMint,oe).publicKey,{publicKey:u}=ve(i,r.nftMint),l=[];return l.push(this.closePositionInstruction(i,n.wallet,r.nftMint,o,u,s)),{address:{positionNftAccount:o,personalPosition:u},signers:[],instructions:l,instructionTypes:[U.ClmmClosePosition],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[]}}static increasePositionFromLiquidityInstruction(e,t,n,r,s,i,o,u,l,c,m,p,d,b,y,w,g,A){let T=C([D("liquidity"),f("amountMaxA"),f("amountMaxB"),W("optionBaseFlag"),Pe("baseFlag")]),h=[...A?[{pubkey:A,isSigner:!1,isWritable:!0}]:[]],P=[{pubkey:t,isSigner:!0,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:m,isSigner:!1,isWritable:!0},{pubkey:p,isSigner:!1,isWritable:!0},{pubkey:oe,isSigner:!1,isWritable:!1},{pubkey:pe,isSigner:!1,isWritable:!1},{pubkey:d,isSigner:!1,isWritable:!1},{pubkey:b,isSigner:!1,isWritable:!1},...h],k=Buffer.alloc(T.span);T.encode({liquidity:y,amountMaxA:w,amountMaxB:g,optionBaseFlag:0,baseFlag:!1},k);let S=Buffer.from([...Ee.increaseLiquidity,...k]);return new Se({keys:P,programId:e,data:S})}static increasePositionFromLiquidityInstructions({poolInfo:e,poolKeys:t,ownerPosition:n,ownerInfo:r,liquidity:s,amountMaxA:i,amountMaxB:o,nft2022:u}){let[l,c]=[new R(e.programId),new R(e.id)],m=E.getTickArrayStartIndexByTick(n.tickLower,e.config.tickSpacing),p=E.getTickArrayStartIndexByTick(n.tickUpper,e.config.tickSpacing),{publicKey:d}=ne(l,c,m),{publicKey:b}=ne(l,c,p),{publicKey:y}=u?ae(r.wallet,n.nftMint,pe):ae(r.wallet,n.nftMint,oe),{publicKey:w}=ve(l,n.nftMint),{publicKey:g}=pt(l,c,n.tickLower,n.tickUpper),A=this.increasePositionFromLiquidityInstruction(l,r.wallet,y,w,c,g,d,b,r.tokenAccountA,r.tokenAccountB,new R(t.vault.A),new R(t.vault.B),new R(e.mintA.address),new R(e.mintB.address),s,i,o,ge.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing,[m,p])?xe(l,c).publicKey:void 0);return{address:{tickArrayLower:d,tickArrayUpper:b,positionNftAccount:y,personalPosition:w,protocolPosition:g},signers:[],instructions:[A],instructionTypes:[U.ClmmIncreasePosition],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[]}}static increasePositionFromBaseInstructions({poolInfo:e,poolKeys:t,ownerPosition:n,ownerInfo:r,base:s,baseAmount:i,otherAmountMax:o,nft2022:u}){let[l,c]=[new R(e.programId),new R(e.id)],m=E.getTickArrayStartIndexByTick(n.tickLower,e.config.tickSpacing),p=E.getTickArrayStartIndexByTick(n.tickUpper,e.config.tickSpacing),{publicKey:d}=ne(l,c,m),{publicKey:b}=ne(l,c,p),{publicKey:y}=u?ae(r.wallet,n.nftMint,pe):ae(r.wallet,n.nftMint,oe),{publicKey:w}=ve(l,n.nftMint),{publicKey:g}=pt(l,c,n.tickLower,n.tickUpper);return{address:{tickArrayLower:d,tickArrayUpper:b,positionNftAccount:y,personalPosition:w,protocolPosition:g},instructions:[this.increasePositionFromBaseInstruction(l,r.wallet,y,w,c,g,d,b,r.tokenAccountA,r.tokenAccountB,new R(t.vault.A),new R(t.vault.B),new R(e.mintA.address),new R(e.mintB.address),s,i,o,ge.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing,[m,p])?xe(l,c).publicKey:void 0)],signers:[],instructionTypes:[U.ClmmIncreasePosition],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[]}}static increasePositionFromBaseInstruction(e,t,n,r,s,i,o,u,l,c,m,p,d,b,y,w,g,A){let T=C([D("liquidity"),f("amountMaxA"),f("amountMaxB"),W("optionBaseFlag"),Pe("baseFlag")]),h=[...A?[{pubkey:A,isSigner:!1,isWritable:!0}]:[]],P=[{pubkey:t,isSigner:!0,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:m,isSigner:!1,isWritable:!0},{pubkey:p,isSigner:!1,isWritable:!0},{pubkey:oe,isSigner:!1,isWritable:!1},{pubkey:pe,isSigner:!1,isWritable:!1},{pubkey:d,isSigner:!1,isWritable:!1},{pubkey:b,isSigner:!1,isWritable:!1},...h],k=Buffer.alloc(T.span);T.encode({liquidity:new Kr(0),amountMaxA:y==="MintA"?w:g,amountMaxB:y==="MintA"?g:w,baseFlag:y==="MintA",optionBaseFlag:1},k);let S=Buffer.from([...Ee.increaseLiquidity,...k]);return new Se({keys:P,programId:e,data:S})}static decreaseLiquidityInstruction(e,t,n,r,s,i,o,u,l,c,m,p,d,b,y,w,g,A,T){let h=C([D("liquidity"),f("amountMinA"),f("amountMinB")]),P=[...T?[{pubkey:T,isSigner:!1,isWritable:!0}]:[],...y.map(L=>[{pubkey:L.poolRewardVault,isSigner:!1,isWritable:!0},{pubkey:L.ownerRewardVault,isSigner:!1,isWritable:!0},{pubkey:L.rewardMint,isSigner:!1,isWritable:!1}]).flat()],k=[{pubkey:t,isSigner:!0,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:m,isSigner:!1,isWritable:!0},{pubkey:p,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:oe,isSigner:!1,isWritable:!1},{pubkey:pe,isSigner:!1,isWritable:!1},{pubkey:An,isSigner:!1,isWritable:!1},{pubkey:d,isSigner:!1,isWritable:!1},{pubkey:b,isSigner:!1,isWritable:!1},...P],S=Buffer.alloc(h.span);h.encode({liquidity:w,amountMinA:g,amountMinB:A},S);let I=Buffer.from([...Ee.decreaseLiquidity,...S]);return new Se({keys:k,programId:e,data:I})}static decreaseLiquidityInstructions({poolInfo:e,poolKeys:t,ownerPosition:n,ownerInfo:r,liquidity:s,amountMinA:i,amountMinB:o,programId:u,nft2022:l}){let[c,m]=[new R(e.programId),new R(e.id)],p=E.getTickArrayStartIndexByTick(n.tickLower,e.config.tickSpacing),d=E.getTickArrayStartIndexByTick(n.tickUpper,e.config.tickSpacing),{publicKey:b}=ne(c,m,p),{publicKey:y}=ne(c,m,d),{publicKey:w}=l?ae(r.wallet,n.nftMint,pe):ae(r.wallet,n.nftMint,u),{publicKey:g}=ve(c,n.nftMint),{publicKey:A}=pt(c,m,n.tickLower,n.tickUpper),T=[];for(let k=0;k<e.rewardDefaultInfos.length;k++)T.push({poolRewardVault:new R(t.rewardInfos[k].vault),ownerRewardVault:r.rewardAccounts[k],rewardMint:new R(e.rewardDefaultInfos[k].mint.address)});let h=[],P=this.decreaseLiquidityInstruction(c,r.wallet,w,g,m,A,b,y,r.tokenAccountA,r.tokenAccountB,new R(t.vault.A),new R(t.vault.B),new R(e.mintA.address),new R(e.mintB.address),T,s,i,o,ge.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing,[p,d])?xe(c,m).publicKey:void 0);return h.push(P),{address:{tickArrayLower:b,tickArrayUpper:y,positionNftAccount:w,personalPosition:g,protocolPosition:A},signers:[],instructions:h,instructionTypes:[U.ClmmDecreasePosition],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[]}}static swapInstruction(e,t,n,r,s,i,o,u,l,c,m,p,d,b,y,w,g){let A=C([f("amount"),f("otherAmountThreshold"),D("sqrtPriceLimitX64"),Pe("isBaseInput")]),T=[...g?[{pubkey:g,isSigner:!1,isWritable:!0}]:[],...m.map(S=>({pubkey:S,isSigner:!1,isWritable:!0}))],h=[{pubkey:t,isSigner:!0,isWritable:!1},{pubkey:r,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:p,isSigner:!1,isWritable:!0},{pubkey:oe,isSigner:!1,isWritable:!1},{pubkey:pe,isSigner:!1,isWritable:!1},{pubkey:An,isSigner:!1,isWritable:!1},{pubkey:l,isSigner:!1,isWritable:!1},{pubkey:c,isSigner:!1,isWritable:!1},...T],P=Buffer.alloc(A.span);A.encode({amount:d,otherAmountThreshold:b,sqrtPriceLimitX64:y,isBaseInput:w},P);let k=Buffer.from([...Ee.swap,...P]);return new Se({keys:h,programId:e,data:k})}static makeSwapBaseInInstructions({poolInfo:e,poolKeys:t,observationId:n,ownerInfo:r,inputMint:s,amountIn:i,amountOutMin:o,sqrtPriceLimitX64:u,remainingAccounts:l}){let[c,m]=[new R(e.programId),new R(e.id)],[p,d]=[new R(t.vault.A),new R(t.vault.B)],[b,y]=[new R(e.mintA.address),new R(e.mintB.address)],w=e.mintA.address===s.toString(),g=[this.swapInstruction(c,r.wallet,m,new R(e.config.id),w?r.tokenAccountA:r.tokenAccountB,w?r.tokenAccountB:r.tokenAccountA,w?p:d,w?d:p,w?b:y,w?y:b,l,n,i,o,u,!0,xe(c,m).publicKey)];return{signers:[],instructions:g,instructionTypes:[U.ClmmSwapBaseIn],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[],address:{}}}static makeSwapBaseOutInstructions({poolInfo:e,poolKeys:t,observationId:n,ownerInfo:r,outputMint:s,amountOut:i,amountInMax:o,sqrtPriceLimitX64:u,remainingAccounts:l}){let[c,m]=[new R(e.programId),new R(e.id)],[p,d]=[new R(t.vault.A),new R(t.vault.B)],[b,y]=[new R(e.mintA.address),new R(e.mintB.address)],w=e.mintA.address===s.toBase58(),g=[this.swapInstruction(c,r.wallet,m,new R(e.config.id),w?r.tokenAccountB:r.tokenAccountA,w?r.tokenAccountA:r.tokenAccountB,w?d:p,w?p:d,w?y:b,w?b:y,l,n,i,o,u,!1,xe(c,m).publicKey)];return{signers:[],instructions:g,instructionTypes:[U.ClmmSwapBaseOut],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[],address:{}}}static initRewardInstruction(e,t,n,r,s,i,o,u,l,c,m,p){let d=C([f("openTime"),f("endTime"),D("emissionsPerSecondX64")]),b=[{pubkey:t,isSigner:!0,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!1},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:ut.programId,isSigner:!1,isWritable:!1},{pubkey:Xe,isSigner:!1,isWritable:!1}],y=Buffer.alloc(d.span);d.encode({openTime:H(c),endTime:H(m),emissionsPerSecondX64:p},y);let w=Buffer.from([...Ee.initReward,...y]);return new Se({keys:b,programId:e,data:w})}static initRewardInstructions({poolInfo:e,poolKeys:t,ownerInfo:n,rewardInfo:r}){let[s,i]=[new R(e.programId),new R(e.id)],o=Hi(s,i,r.mint).publicKey,u=hr(s).publicKey,l=[this.initRewardInstruction(s,n.wallet,i,u,new R(e.config.id),n.tokenAccount,r.programId,r.mint,o,r.openTime,r.endTime,r.emissionsPerSecondX64)];return{address:{poolRewardVault:o,operationId:u},signers:[],instructions:l,instructionTypes:[U.ClmmInitReward],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[]}}static setRewardInstruction(e,t,n,r,s,i,o,u,l,c,m,p){let d=C([W("rewardIndex"),D("emissionsPerSecondX64"),f("openTime"),f("endTime")]),b=[{pubkey:t,isSigner:!0,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:oe,isSigner:!1,isWritable:!1},{pubkey:pe,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0}],y=Buffer.alloc(d.span);d.encode({rewardIndex:l,emissionsPerSecondX64:p,openTime:H(c),endTime:H(m)},y);let w=Buffer.from([...Ee.setRewardEmissions,...y]);return new Se({keys:b,programId:e,data:w})}static setRewardInstructions({poolInfo:e,poolKeys:t,ownerInfo:n,rewardInfo:r}){let[s,i]=[new R(e.programId),new R(e.id)],o,u,l;for(let p=0;p<e.rewardDefaultInfos.length;p++)e.rewardDefaultInfos[p].mint.address===r.mint.toString()&&(o=p,u=new R(t.rewardInfos[p].vault),l=new R(t.rewardInfos[p].mint.address));(o===void 0||u===void 0)&&io.logWithError("reward mint check error","no reward mint",e.rewardDefaultInfos);let c=hr(s).publicKey,m=[this.setRewardInstruction(s,n.wallet,i,c,new R(e.config.id),n.tokenAccount,u,l,o,r.openTime,r.endTime,r.emissionsPerSecondX64)];return{address:{rewardVault:u,operationId:c},signers:[],instructions:m,instructionTypes:[U.ClmmSetReward],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[]}}static collectRewardInstruction(e,t,n,r,s,i,o){let u=C([W("rewardIndex")]),l=[{pubkey:t,isSigner:!0,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!1},{pubkey:oe,isSigner:!1,isWritable:!1},{pubkey:pe,isSigner:!1,isWritable:!1},{pubkey:An,isSigner:!1,isWritable:!1}],c=Buffer.alloc(u.span);u.encode({rewardIndex:o},c);let m=Buffer.from([...Ee.collectReward,...c]);return new Se({keys:l,programId:e,data:m})}static collectRewardInstructions({poolInfo:e,poolKeys:t,ownerInfo:n,rewardMint:r}){let[s,i]=[new R(e.programId),new R(e.id)],o,u;for(let c=0;c<e.rewardDefaultInfos.length;c++)e.rewardDefaultInfos[c].mint.address===r.toString()&&(o=c,u=new R(t.rewardInfos[c].vault));(o===void 0||u===void 0)&&io.logWithError("reward mint check error","no reward mint",e.rewardDefaultInfos);let l=[this.collectRewardInstruction(s,n.wallet,i,n.tokenAccount,u,r,o)];return{address:{rewardVault:u},signers:[],instructions:l,instructionTypes:[U.ClmmCollectReward],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[]}}static async makeLockPositions({programId:e,authProgramId:t,poolProgramId:n,payer:r,wallet:s,nftMint:i,nft2022:o,getEphemeralSigners:u}){let l=[],c;if(u)c=new R((await u(1))[0]);else{let g=Wn.generate();l.push(g),c=g.publicKey}let m=o?ae(s,i,pe).publicKey:ae(s,i,oe).publicKey,{publicKey:p}=ve(n,i),d=Ji(e,c).publicKey,b=ae(s,c,oe).publicKey,y=cn(c).publicKey,w=Qt.lockPositionInstructionV2({programId:e,auth:t,payer:r,positionOwner:s,lockOwner:s,positionNftAccount:m,positionId:p,lockPositionId:d,lockNftMint:c,lockNftAccount:b,metadataAccount:y,withMetadata:!0,nft2022:o,positionNftMint:i,authPositionNftAccount:ae(t,i,o?pe:oe).publicKey,positionNftProgram:o?pe:oe});return{address:{positionId:p,lockPositionId:d,lockNftAccount:b,lockNftMint:c,positionNftAccount:m,metadataAccount:y},instructions:[w],signers:l,instructionTypes:[U.ClmmLockPosition],lookupTableAddress:[]}}static lockPositionInstructionV2({programId:e,auth:t,payer:n,positionOwner:r,lockOwner:s,positionNftAccount:i,positionId:o,positionNftMint:u,authPositionNftAccount:l,positionNftProgram:c,lockPositionId:m,lockNftMint:p,lockNftAccount:d,metadataAccount:b,withMetadata:y}){let w=[{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!0,isWritable:!0},{pubkey:r,isSigner:!0,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!1},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:m,isSigner:!1,isWritable:!0},{pubkey:p,isSigner:!0,isWritable:!0},{pubkey:d,isSigner:!1,isWritable:!0},{pubkey:b,isSigner:!1,isWritable:!0},{pubkey:wt,isSigner:!1,isWritable:!1},{pubkey:pn,isSigner:!1,isWritable:!1},{pubkey:Xe,isSigner:!1,isWritable:!1},{pubkey:oe,isSigner:!1,isWritable:!1},{pubkey:c,isSigner:!1,isWritable:!1},{pubkey:ut.programId,isSigner:!1,isWritable:!1}],g=C([Pe("withMetadata")]),A=Buffer.alloc(g.span);g.encode({withMetadata:y},A);let T=Buffer.from([...oo,...A]);return new Se({keys:w,programId:e,data:T})}static lockPositionInstruction({programId:e,authProgramId:t,poolProgramId:n,owner:r,positionNft:s}){let{publicKey:i}=ae(r,s,oe),{publicKey:o}=ve(n,s),u=[{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!0,isWritable:!1},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:xr(e,o).publicKey,isSigner:!1,isWritable:!0},{pubkey:oe,isSigner:!1,isWritable:!1},{pubkey:ut.programId,isSigner:!1,isWritable:!1}];return new Se({keys:u,programId:e,data:Buffer.from(oo)})}static harvestLockPositionInstruction(e){let[t,n]=[new R(e.poolKeys.programId),new R(e.poolKeys.id)],r=E.getTickArrayStartIndexByTick(e.ownerPosition.tickLower,e.poolKeys.config.tickSpacing),s=E.getTickArrayStartIndexByTick(e.ownerPosition.tickUpper,e.poolKeys.config.tickSpacing),{publicKey:i}=ne(t,n,r),{publicKey:o}=ne(t,n,s),{publicKey:u}=ae(e.owner,e.ownerPosition.nftMint,oe),{publicKey:l}=ve(t,e.ownerPosition.nftMint),{publicKey:c}=pt(t,n,e.ownerPosition.tickLower,e.ownerPosition.tickUpper),m=[];for(let b=0;b<e.poolKeys.rewardInfos.length;b++)m.push({poolRewardVault:new R(e.poolKeys.rewardInfos[b].vault),ownerRewardVault:e.ownerRewardAccounts[b],rewardMint:new R(e.poolKeys.rewardInfos[b].mint.address)});let p=[...m.map(b=>[{pubkey:b.poolRewardVault,isSigner:!1,isWritable:!0},{pubkey:b.ownerRewardVault,isSigner:!1,isWritable:!0},{pubkey:b.rewardMint,isSigner:!1,isWritable:!1}]).flat()],d=[{pubkey:e.authProgramId,isSigner:!1,isWritable:!1},{pubkey:xr(e.programId,l).publicKey,isSigner:!1,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:e.owner,isSigner:!0,isWritable:!1},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:new R(e.poolKeys.vault.A),isSigner:!1,isWritable:!0},{pubkey:new R(e.poolKeys.vault.B),isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:e.userVaultA,isSigner:!1,isWritable:!0},{pubkey:e.userVaultB,isSigner:!1,isWritable:!0},{pubkey:oe,isSigner:!1,isWritable:!1},{pubkey:pe,isSigner:!1,isWritable:!1},{pubkey:$n,isSigner:!1,isWritable:!1},{pubkey:new R(e.poolKeys.mintA.address),isSigner:!1,isWritable:!1},{pubkey:new R(e.poolKeys.mintB.address),isSigner:!1,isWritable:!1},...p];return new Se({keys:d,programId:e.programId,data:Buffer.from(so)})}static harvestLockPositionInstructionV2({programId:e,auth:t,lockPositionId:n,clmmProgram:r,lockOwner:s,lockNftMint:i,lockNftAccount:o,positionNftAccount:u,positionId:l,poolId:c,protocolPosition:m,vaultA:p,vaultB:d,tickArrayLower:b,tickArrayUpper:y,userVaultA:w,userVaultB:g,mintA:A,mintB:T,rewardAccounts:h,exTickArrayBitmap:P}){let k=[...P?[{pubkey:P,isSigner:!1,isWritable:!0}]:[],...h.map(I=>[{pubkey:I.poolRewardVault,isSigner:!1,isWritable:!0},{pubkey:I.ownerRewardVault,isSigner:!1,isWritable:!0},{pubkey:I.rewardMint,isSigner:!1,isWritable:!1}]).flat()],S=[{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:s,isSigner:!0,isWritable:!1},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!1,isWritable:!1},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:m,isSigner:!1,isWritable:!0},{pubkey:p,isSigner:!1,isWritable:!0},{pubkey:d,isSigner:!1,isWritable:!0},{pubkey:b,isSigner:!1,isWritable:!0},{pubkey:y,isSigner:!1,isWritable:!0},{pubkey:w,isSigner:!1,isWritable:!0},{pubkey:g,isSigner:!1,isWritable:!0},{pubkey:oe,isSigner:!1,isWritable:!1},{pubkey:pe,isSigner:!1,isWritable:!1},{pubkey:$n,isSigner:!1,isWritable:!1},{pubkey:A,isSigner:!1,isWritable:!1},{pubkey:T,isSigner:!1,isWritable:!1},...k];return new Se({keys:S,programId:e,data:Buffer.from(so)})}};var Lr=(...a)=>a.map(e=>{try{return typeof e=="object"?JSON.stringify(e):e}catch{return e}}).join(", "),zt=class{constructor({scope:e,moduleName:t}){this.disabled=!1;this.scope=e,this.logger=ie(t)}createTxBuilder(e){return this.scope.checkOwner(),new In({connection:this.scope.connection,feePayer:e||this.scope.ownerPubKey,cluster:this.scope.cluster,owner:this.scope.owner,blockhashCommitment:this.scope.blockhashCommitment,loopMultiTxStatus:this.scope.loopMultiTxStatus,api:this.scope.api,signAllTransactions:this.scope.signAllTransactions})}logDebug(...e){this.logger.debug(Lr(e))}logInfo(...e){this.logger.info(Lr(e))}logAndCreateError(...e){let t=Lr(e);throw new Error(t)}checkDisabled(){(this.disabled||!this.scope)&&this.logAndCreateError("module not working")}};var ua=C([Ke("mintAuthorityOption"),K("mintAuthority"),f("supply"),W("decimals"),W("isInitialized"),Ke("freezeAuthorityOption"),K("freezeAuthority")]);import{PublicKey as _b}from"@solana/web3.js";import{MintLayout as vb,TOKEN_PROGRAM_ID as Eb}from"@solana/spl-token";var ao=a=>new Ie({mint:a.address,decimals:a.decimals,symbol:a.symbol,name:a.name});var En=r=>{var s=r,{address:a,programId:e,decimals:t}=s,n=Oe(s,["address","programId","decimals"]);return F({chainId:101,address:Et(a).toBase58(),programId:e,logoURI:"",symbol:"",name:"",decimals:t,tags:[],extensions:n.extensions||{}},n)};import uo from"bn.js";var Rr=new uo(25),Fn=new uo(1e4);import{PublicKey as $e,SystemProgram as la,SYSVAR_RENT_PUBKEY as ry,TransactionInstruction as jt}from"@solana/web3.js";import{ASSOCIATED_TOKEN_PROGRAM_ID as ma,TOKEN_PROGRAM_ID as fn}from"@solana/spl-token";var Cr=C([W("instruction"),f("amountIn"),f("minAmountOut")]),Nr=C([W("instruction"),f("maxAmountIn"),f("amountOut")]),$b=C([W("instruction"),W("nonce")]),ca=C([W("instruction"),W("nonce"),f("startTime")]),Mr=C([f("status"),f("nonce"),f("maxOrder"),f("depth"),f("baseDecimal"),f("quoteDecimal"),f("state"),f("resetFlag"),f("minSize"),f("volMaxCutRatio"),f("amountWaveRatio"),f("baseLotSize"),f("quoteLotSize"),f("minPriceMultiplier"),f("maxPriceMultiplier"),f("systemDecimalValue"),f("minSeparateNumerator"),f("minSeparateDenominator"),f("tradeFeeNumerator"),f("tradeFeeDenominator"),f("pnlNumerator"),f("pnlDenominator"),f("swapFeeNumerator"),f("swapFeeDenominator"),f("baseNeedTakePnl"),f("quoteNeedTakePnl"),f("quoteTotalPnl"),f("baseTotalPnl"),f("poolOpenTime"),f("punishPcAmount"),f("punishCoinAmount"),f("orderbookToInitTime"),D("swapBaseInAmount"),D("swapQuoteOutAmount"),f("swapBase2QuoteFee"),D("swapQuoteInAmount"),D("swapBaseOutAmount"),f("swapQuote2BaseFee"),K("baseVault"),K("quoteVault"),K("baseMint"),K("quoteMint"),K("lpMint"),K("openOrders"),K("marketId"),K("marketProgramId"),K("targetOrders"),K("withdrawQueue"),K("lpVault"),K("owner"),f("lpReserve"),q(f(),3,"padding")]),ey=C([f("accountType"),f("status"),f("nonce"),f("maxOrder"),f("depth"),f("baseDecimal"),f("quoteDecimal"),f("state"),f("resetFlag"),f("minSize"),f("volMaxCutRatio"),f("amountWaveRatio"),f("baseLotSize"),f("quoteLotSize"),f("minPriceMultiplier"),f("maxPriceMultiplier"),f("systemDecimalsValue"),f("abortTradeFactor"),f("priceTickMultiplier"),f("priceTick"),f("minSeparateNumerator"),f("minSeparateDenominator"),f("tradeFeeNumerator"),f("tradeFeeDenominator"),f("pnlNumerator"),f("pnlDenominator"),f("swapFeeNumerator"),f("swapFeeDenominator"),f("baseNeedTakePnl"),f("quoteNeedTakePnl"),f("quoteTotalPnl"),f("baseTotalPnl"),f("poolOpenTime"),f("punishPcAmount"),f("punishCoinAmount"),f("orderbookToInitTime"),D("swapBaseInAmount"),D("swapQuoteOutAmount"),D("swapQuoteInAmount"),D("swapBaseOutAmount"),f("swapQuote2BaseFee"),f("swapBase2QuoteFee"),K("baseVault"),K("quoteVault"),K("baseMint"),K("quoteMint"),K("lpMint"),K("modelDataAccount"),K("openOrders"),K("marketId"),K("marketProgramId"),K("targetOrders"),K("owner"),q(f(),64,"padding")]),_r=C([W("instruction"),f("baseAmountIn"),f("quoteAmountIn"),f("fixedSide"),f("otherAmountMin")]),Vr=C([W("instruction"),f("lpAmount"),f("baseAmountMin"),f("quoteAmountMin")]);var co=C([f("fee")]);var lo=ie("Raydium_liquidity_instruction");function mo(a){let{poolInfo:e,poolKeys:t,userKeys:n,baseAmountIn:r,quoteAmountIn:s,fixedSide:i,otherAmountMin:o,modelDataPubKey:u=Pt}=a,l=Buffer.alloc(_r.span);_r.encode({instruction:3,baseAmountIn:H(r),quoteAmountIn:H(s),otherAmountMin:H(o),fixedSide:i==="base"?mt:ci},l);let c=[B({pubkey:fn,isWritable:!1}),B({pubkey:new $e(e.id)}),B({pubkey:new $e(t.authority),isWritable:!1}),B({pubkey:new $e(t.openOrders),isWritable:!1}),B({pubkey:new $e(t.targetOrders)}),B({pubkey:new $e(e.lpMint.address)}),B({pubkey:new $e(t.vault.A)}),B({pubkey:new $e(t.vault.B)})];return e.pooltype.includes("StablePool")&&c.push(B({pubkey:u})),c.push(B({pubkey:new $e(e.marketId),isWritable:!1}),B({pubkey:n.baseTokenAccount}),B({pubkey:n.quoteTokenAccount}),B({pubkey:n.lpTokenAccount}),B({pubkey:n.owner,isWritable:!1,isSigner:!0}),B({pubkey:new $e(t.marketEventQueue),isWritable:!1})),new jt({programId:new $e(e.programId),keys:c,data:l})}function vr(a){let{poolInfo:e,poolKeys:t,userKeys:n,lpAmount:r,baseAmountMin:s,quoteAmountMin:i,modelDataPubKey:o=Pt}=a,u=kt(t),l=4;if(e.pooltype.includes("StablePool")&&(l=5),l===4||l===5){let c=Buffer.alloc(Vr.span);Vr.encode({instruction:4,lpAmount:H(r),baseAmountMin:H(s),quoteAmountMin:H(i)},c);let m=[B({pubkey:fn,isWritable:!1}),B({pubkey:u.id}),B({pubkey:u.authority,isWritable:!1}),B({pubkey:u.openOrders}),B({pubkey:u.targetOrders}),B({pubkey:u.mintLp.address}),B({pubkey:u.vault.A}),B({pubkey:u.vault.B})];return l===5?m.push(B({pubkey:o})):(m.push(B({pubkey:u.id})),m.push(B({pubkey:u.id}))),m.push(B({pubkey:u.marketProgramId,isWritable:!1}),B({pubkey:u.marketId}),B({pubkey:u.marketBaseVault}),B({pubkey:u.marketQuoteVault}),B({pubkey:u.marketAuthority,isWritable:!1}),B({pubkey:n.lpTokenAccount}),B({pubkey:n.baseTokenAccount}),B({pubkey:n.quoteTokenAccount}),B({pubkey:n.owner,isWritable:!1,isSigner:!0}),B({pubkey:u.marketEventQueue}),B({pubkey:u.marketBids}),B({pubkey:u.marketAsks})),new jt({programId:u.programId,keys:m,data:c})}return new jt({programId:u.programId,keys:[]})}function Wr({programId:a,ammId:e,ammAuthority:t,ammOpenOrders:n,lpMint:r,coinMint:s,pcMint:i,coinVault:o,pcVault:u,withdrawQueue:l,ammTargetOrders:c,poolTempLp:m,marketProgramId:p,marketId:d,userWallet:b,userCoinVault:y,userPcVault:w,userLpVault:g,nonce:A,openTime:T,coinAmount:h,pcAmount:P,ammConfigId:k,feeDestinationId:S}){let I=C([W("instruction"),W("nonce"),f("openTime"),f("pcAmount"),f("coinAmount")]),L=[{pubkey:fn,isSigner:!1,isWritable:!1},{pubkey:ma,isSigner:!1,isWritable:!1},{pubkey:la.programId,isSigner:!1,isWritable:!1},{pubkey:Xe,isSigner:!1,isWritable:!1},{pubkey:e,isSigner:!1,isWritable:!0},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!1},{pubkey:i,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:k,isSigner:!1,isWritable:!1},{pubkey:S,isSigner:!1,isWritable:!0},{pubkey:p,isSigner:!1,isWritable:!1},{pubkey:d,isSigner:!1,isWritable:!1},{pubkey:b,isSigner:!0,isWritable:!0},{pubkey:y,isSigner:!1,isWritable:!0},{pubkey:w,isSigner:!1,isWritable:!0},{pubkey:g,isSigner:!1,isWritable:!0}],x=Buffer.alloc(I.span);return I.encode({instruction:1,nonce:A,openTime:T,coinAmount:h,pcAmount:P},x),{instruction:new jt({keys:L,programId:a,data:x}),instructionType:U.AmmV4CreatePool}}function da({poolKeys:a,userKeys:e,amountIn:t,minAmountOut:n,modelDataPubKey:r=Pt},s){let i=kt(a),o=Buffer.alloc(Cr.span);Cr.encode({instruction:9,amountIn:H(t),minAmountOut:H(n)},o);let u=[B({pubkey:fn,isWritable:!1}),B({pubkey:i.id}),B({pubkey:i.authority,isWritable:!1}),B({pubkey:i.openOrders})];return s===4&&u.push(B({pubkey:i.targetOrders})),u.push(B({pubkey:i.vault.A}),B({pubkey:i.vault.B})),s===5&&u.push(B({pubkey:r})),u.push(B({pubkey:i.marketProgramId,isWritable:!1}),B({pubkey:i.marketId}),B({pubkey:i.marketBids}),B({pubkey:i.marketAsks}),B({pubkey:i.marketEventQueue}),B({pubkey:i.marketBaseVault}),B({pubkey:i.marketQuoteVault}),B({pubkey:i.marketAuthority,isWritable:!1}),B({pubkey:e.tokenAccountIn}),B({pubkey:e.tokenAccountOut}),B({pubkey:e.owner,isWritable:!1,isSigner:!0})),new jt({programId:i.programId,keys:u,data:o})}function pa({poolKeys:a,userKeys:e,maxAmountIn:t,amountOut:n,modelDataPubKey:r=Pt},s){let i=kt(a),o=Buffer.alloc(Nr.span);Nr.encode({instruction:11,maxAmountIn:H(t),amountOut:H(n)},o);let u=[B({pubkey:fn,isWritable:!1}),B({pubkey:i.id}),B({pubkey:i.authority,isWritable:!1}),B({pubkey:i.openOrders}),B({pubkey:i.targetOrders}),B({pubkey:i.vault.A}),B({pubkey:i.vault.B})];return s===5&&u.push(B({pubkey:r})),u.push(B({pubkey:i.marketProgramId,isWritable:!1}),B({pubkey:i.marketId}),B({pubkey:i.marketBids}),B({pubkey:i.marketAsks}),B({pubkey:i.marketEventQueue}),B({pubkey:i.marketBaseVault}),B({pubkey:i.marketQuoteVault}),B({pubkey:i.marketAuthority,isWritable:!1}),B({pubkey:e.tokenAccountIn}),B({pubkey:e.tokenAccountOut}),B({pubkey:e.owner,isWritable:!1,isSigner:!0})),new jt({programId:i.programId,keys:u,data:o})}function po(a){let{poolKeys:e,version:t,userKeys:n,amountIn:r,amountOut:s,fixedSide:i}=a;if(t===4||t===5){let o={poolKeys:e,userKeys:n};if(i==="in")return da(j(F({},o),{amountIn:r,minAmountOut:s}),t);if(i==="out")return pa(j(F({},o),{maxAmountIn:r,amountOut:s}),t);lo.logWithError("invalid params","params",a)}throw lo.logWithError("invalid version","poolKeys.version",t),new Error("invalid version")}var Mt=5e4,fa=C([f("x"),f("y"),f("price")]),ba=C([f("accountType"),f("status"),f("multiplier"),f("validDataCount"),q(fa,Mt,"DataElement")]);function ya(a,e){return[0,Mt-2]}function ga(a){return[0,Mt-2]}function wa(a){return[0,Mt-2]}function ka(a,e,t){let[n,r]=ya(e,t),s=n,i=r,o=0,u=e*a.multiplier/t;for(;s<=i;){if(o=Math.floor((i+s)/2),o===0||o>=Mt-2)return[o,o,!1];let l=a.DataElement[o].x*a.multiplier/a.DataElement[o].y,c=a.DataElement[o-1].x*a.multiplier/a.DataElement[o-1].y,m=a.DataElement[o+1].x*a.multiplier/a.DataElement[o+1].y;if(u===l)return[o,o,!0];if(u===c)return[o-1,o-1,!0];if(u===m)return[o+1,o+1,!0];if(u<c)i=o-1;else{if(u>c&&u<l)return[o-1,o,!0];if(u>l&&u<m)return[o,o+1,!0];s=o+1}}return[o,o,!1]}function Er(a,e,t){let[n,r,s]=ka(a,e,t);if(!s)return 0;if(n===r){let i=a.DataElement[n].x;return e*a.multiplier/i}else{let i=a.DataElement[n].x,o=a.DataElement[n].y,u=a.DataElement[r].x,l=a.DataElement[r].y,c=t*(u*o-i*l),m=i*c,p=(u-i)*(e*o-i*t)*l,d=m+p;return e*a.multiplier*c/d}}function Nt(a,e,t){return e*a.multiplier/t}function fo(a,e,t){return e*t/a.multiplier}function Aa(a,e){let[t,n]=ga(e),r=t,s=n,i=0,o=e;for(;r<s;){if(i=Math.floor((s+r)/2),i<=0||i>Mt-2)return[i,i,!1];let u=a.DataElement[i].x,l=a.DataElement[i-1].x,c=a.DataElement[i+1].x;if(o===u)return[i,i,!0];if(o===l)return[i-1,i-1,!0];if(o===c)return[i+1,i+1,!0];if(o<l)s=i-1;else{if(o>l&&o<u)return[i-1,i,!0];if(o>u&&o<c)return[i,i+1,!0];r=i+1}}return[i,i,!1]}function Pa(a,e){let[t,n]=wa(e),r=t,s=n,i=0,o=e;for(;r<=s;){if(i=Math.floor((s+r)/2),i<=0||i>=Mt-2)return[i,i,!1];let u=a.DataElement[i].y,l=a.DataElement[i-1].y,c=a.DataElement[i+1].y;if(o===u)return[i,i,!0];if(o===l)return[i-1,i-1,!0];if(o===c)return[i+1,i+1,!0];if(o<c)r=i+1;else{if(o<l&&o>u)return[i-1,i,!0];if(o<u&&o>c)return[i,i+1,!0];s=i-1}}return[i,i,!1]}function bo(a,e,t,n){let r=n?e+t:e-t,[s,i,o]=Aa(a,r);if(!o)return[0,0,!1,o];if(s===i)return[a.DataElement[i].price,a.DataElement[i].y,!1,o];{let u=a.DataElement[s].x,l=a.DataElement[i].x,c=a.DataElement[s].price,m=a.DataElement[i].price,p=a.DataElement[s].y,d=a.DataElement[i].y;if(e>=u&&e<=l)return n?[m,d,!0,o]:[c,p,!0,o];{let b,y;return n?(b=c+(m-c)*(e-u)/(l-u),y=p-(r-u)*a.multiplier/m):(b=c+(m-c)*(e-u)/(l-u),y=d+(l-r)*a.multiplier/c),[b,y,!1,o]}}}function Ta(a,e,t,n){let r=n?e-t:e+t,[s,i,o]=Pa(a,r);if(!o)return[0,0,!1,o];if(s===i)return[a.DataElement[i].price,a.DataElement[i].x,!1,o];{let u=a.DataElement[s].x,l=a.DataElement[i].x,c=a.DataElement[s].price,m=a.DataElement[i].price,p=a.DataElement[s].y,d=a.DataElement[i].y;if(e>=d&&e<=p)return n?[m,l,!0,o]:[c,u,!0,o];{let b,y;return n?(b=c+(m-c)*(p-e)/(p-d),y=u+m*(p-r)/a.multiplier):(b=c+(m-c)*(p-e)/(p-d),y=l-c*(r-d)/a.multiplier),[b,y,!1,o]}}}function ha(a,e){let t=bo(a,e,0,!1);return t[3]?t[0]:0}function yo(a,e,t,n){let r=Er(a,e,t),s=Nt(a,e,r),i=Nt(a,t,r),o=Nt(a,n,r),u=!0,[l,c,m,p]=bo(a,s,o,u);if(!p)return 0;if(m)return n*a.multiplier/l;{let d=i-c;return fo(a,d,r)}}function go(a,e,t,n){let r=Er(a,e,t),s=Nt(a,e,r),i=Nt(a,t,r),o=Nt(a,n,r),u=!1,[l,c,m,p]=Ta(a,i,o,u);if(!p)return 0;if(m)return n*l/a.multiplier;{let d=s-c;return fo(a,d,r)}}function xa(a){let e=ba.decode(a);return{accountType:e.accountType.toNumber(),status:e.status.toNumber(),multiplier:e.multiplier.toNumber(),validDataCount:e.validDataCount.toNumber(),DataElement:e.DataElement.map(t=>({x:t.x.toNumber(),y:t.y.toNumber(),price:t.price.toNumber()}))}}function wo(a,e,t,n){let r=ha(a,Nt(a,e,Er(a,e,t)))/a.multiplier;return n?r:1/r}var bn=class{constructor({connection:e,modelDataPubKey:t=Pt}){this._layoutData={accountType:0,status:0,multiplier:0,validDataCount:0,DataElement:[]};this.connection=e,this.modelDataPubKey=t}get stableModelData(){return this._layoutData}async initStableModelLayout(){if(this._layoutData.validDataCount===0&&this.connection){let e=await this.connection.getAccountInfo(this.modelDataPubKey);e&&(this._layoutData=xa(e==null?void 0:e.data))}}};import{PublicKey as Va}from"@solana/web3.js";import hg from"bn.js";import Gn from"decimal.js";import{TOKEN_PROGRAM_ID as va}from"@solana/spl-token";import{PublicKey as Sa}from"@solana/web3.js";var Ba=ie("Raydium_liquidity_serum");function ko({programId:a,marketId:e}){let t=[e.toBuffer()],n=0,r;for(;n<100;){try{let s=t.concat(Buffer.from([n]),Buffer.alloc(7));r=Sa.createProgramAddressSync(s,a)}catch(s){if(s instanceof TypeError)throw s;n++;continue}return{publicKey:r,nonce:n}}throw Ba.logWithError("unable to find a viable program address nonce","params",{programId:a,marketId:e}),new Error("unable to find a viable program address nonce")}import{Keypair as Ca,PublicKey as Na}from"@solana/web3.js";import Wy from"bn.js";import{TOKEN_PROGRAM_ID as Ma}from"@solana/spl-token";function Ia(a){return a instanceof Uint8Array||a!=null&&typeof a=="object"&&a.constructor.name==="Uint8Array"}function Fr(a,...e){if(!Ia(a))throw new Error("Uint8Array expected");if(e.length>0&&!e.includes(a.length))throw new Error(`Uint8Array expected of length ${e}, not of length=${a.length}`)}function Or(a,e=!0){if(a.destroyed)throw new Error("Hash instance has been destroyed");if(e&&a.finished)throw new Error("Hash#digest() has already been called")}function Ao(a,e){Fr(a);let t=e.outputLen;if(a.length<t)throw new Error(`digestInto() expects output buffer of length at least ${t}`)}var Dn=a=>new DataView(a.buffer,a.byteOffset,a.byteLength),ze=(a,e)=>a<<32-e|a>>>e;var hy=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;function Ka(a){if(typeof a!="string")throw new Error(`utf8ToBytes expected string, got ${typeof a}`);return new Uint8Array(new TextEncoder().encode(a))}function Dr(a){return typeof a=="string"&&(a=Ka(a)),Fr(a),a}var On=class{clone(){return this._cloneInto()}},xy={}.toString;function Po(a){let e=n=>a().update(Dr(n)).digest(),t=a();return e.outputLen=t.outputLen,e.blockLen=t.blockLen,e.create=()=>a(),e}function La(a,e,t,n){if(typeof a.setBigUint64=="function")return a.setBigUint64(e,t,n);let r=BigInt(32),s=BigInt(4294967295),i=Number(t>>r&s),o=Number(t&s),u=n?4:0,l=n?0:4;a.setUint32(e+u,i,n),a.setUint32(e+l,o,n)}var To=(a,e,t)=>a&e^~a&t,ho=(a,e,t)=>a&e^a&t^e&t,qn=class extends On{constructor(e,t,n,r){super(),this.blockLen=e,this.outputLen=t,this.padOffset=n,this.isLE=r,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(e),this.view=Dn(this.buffer)}update(e){Or(this);let{view:t,buffer:n,blockLen:r}=this;e=Dr(e);let s=e.length;for(let i=0;i<s;){let o=Math.min(r-this.pos,s-i);if(o===r){let u=Dn(e);for(;r<=s-i;i+=r)this.process(u,i);continue}n.set(e.subarray(i,i+o),this.pos),this.pos+=o,i+=o,this.pos===r&&(this.process(t,0),this.pos=0)}return this.length+=e.length,this.roundClean(),this}digestInto(e){Or(this),Ao(e,this),this.finished=!0;let{buffer:t,view:n,blockLen:r,isLE:s}=this,{pos:i}=this;t[i++]=128,this.buffer.subarray(i).fill(0),this.padOffset>r-i&&(this.process(n,0),i=0);for(let m=i;m<r;m++)t[m]=0;La(n,r-8,BigInt(this.length*8),s),this.process(n,0);let o=Dn(e),u=this.outputLen;if(u%4)throw new Error("_sha2: outputLen should be aligned to 32bit");let l=u/4,c=this.get();if(l>c.length)throw new Error("_sha2: outputLen bigger than state");for(let m=0;m<l;m++)o.setUint32(4*m,c[m],s)}digest(){let{buffer:e,outputLen:t}=this;this.digestInto(e);let n=e.slice(0,t);return this.destroy(),n}_cloneInto(e){e||(e=new this.constructor),e.set(...this.get());let{blockLen:t,buffer:n,length:r,finished:s,destroyed:i,pos:o}=this;return e.length=r,e.pos=o,e.finished=s,e.destroyed=i,r%t&&e.buffer.set(n),e}};var Ra=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),ft=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),bt=new Uint32Array(64),qr=class extends qn{constructor(){super(64,32,8,!1),this.A=ft[0]|0,this.B=ft[1]|0,this.C=ft[2]|0,this.D=ft[3]|0,this.E=ft[4]|0,this.F=ft[5]|0,this.G=ft[6]|0,this.H=ft[7]|0}get(){let{A:e,B:t,C:n,D:r,E:s,F:i,G:o,H:u}=this;return[e,t,n,r,s,i,o,u]}set(e,t,n,r,s,i,o,u){this.A=e|0,this.B=t|0,this.C=n|0,this.D=r|0,this.E=s|0,this.F=i|0,this.G=o|0,this.H=u|0}process(e,t){for(let m=0;m<16;m++,t+=4)bt[m]=e.getUint32(t,!1);for(let m=16;m<64;m++){let p=bt[m-15],d=bt[m-2],b=ze(p,7)^ze(p,18)^p>>>3,y=ze(d,17)^ze(d,19)^d>>>10;bt[m]=y+bt[m-7]+b+bt[m-16]|0}let{A:n,B:r,C:s,D:i,E:o,F:u,G:l,H:c}=this;for(let m=0;m<64;m++){let p=ze(o,6)^ze(o,11)^ze(o,25),d=c+p+To(o,u,l)+Ra[m]+bt[m]|0,y=(ze(n,2)^ze(n,13)^ze(n,22))+ho(n,r,s)|0;c=l,l=u,u=o,o=i+d|0,i=s,s=r,r=n,n=d+y|0}n=n+this.A|0,r=r+this.B|0,s=s+this.C|0,i=i+this.D|0,o=o+this.E|0,u=u+this.F|0,l=l+this.G|0,c=c+this.H|0,this.set(n,r,s,i,o,u,l,c)}roundClean(){bt.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}};var xo=Po(()=>new qr);var qy=ie("Raydium_Util");function et({fromPublicKey:a,programId:e=Ma,assignSeed:t}){let n=t?btoa(t).slice(0,32):Ca.generate().publicKey.toBase58().slice(0,32);return{publicKey:_a(a,n,e),seed:n}}function _a(a,e,t){let n=Buffer.concat([a.toBuffer(),Buffer.from(e),t.toBuffer()]),r=xo(n);return new Na(r)}import{PublicKey as zy,SystemProgram as Hy}from"@solana/web3.js";import Jy from"bn.js";import{createCloseAccountInstruction as ng,createInitializeAccountInstruction as rg,createTransferInstruction as ig,TOKEN_PROGRAM_ID as og}from"@solana/spl-token";function Un({programId:a}){let{publicKey:e}=de([Buffer.from("amm_config_account_seed","utf-8")],a);return e}function _t({name:a,programId:e,marketId:t}){let{publicKey:n}=de([e.toBuffer(),t.toBuffer(),Buffer.from(a,"utf-8")],e);return n}function Wa({programId:a,marketId:e}){let{publicKey:t}=de([a.toBuffer(),e.toBuffer(),Buffer.from("open_order_associated_seed","utf-8")],a);return t}function Ea({programId:a}){return de([Buffer.from([97,109,109,32,97,117,116,104,111,114,105,116,121])],a)}function Ur({version:a,marketVersion:e,marketId:t,baseMint:n,quoteMint:r,baseDecimals:s,quoteDecimals:i,programId:o,marketProgramId:u}){let l=_t({name:"amm_associated_seed",programId:o,marketId:t}),c=_t({name:"lp_mint_associated_seed",programId:o,marketId:t}),{publicKey:m,nonce:p}=Ea({programId:o}),d=_t({name:"coin_vault_associated_seed",programId:o,marketId:t}),b=_t({name:"pc_vault_associated_seed",programId:o,marketId:t}),y=_t({name:"temp_lp_token_associated_seed",programId:o,marketId:t}),w=Wa({programId:o,marketId:t}),g=_t({name:"target_associated_seed",programId:o,marketId:t}),A=_t({name:"withdraw_associated_seed",programId:o,marketId:t}),{publicKey:T}=ko({programId:u,marketId:t});return{id:l,baseMint:n,quoteMint:r,lpMint:c,baseDecimals:s,quoteDecimals:i,lpDecimals:s,version:a,programId:o,authority:m,nonce:p,baseVault:d,quoteVault:b,lpVault:y,openOrders:w,targetOrders:g,withdrawQueue:A,marketVersion:e,marketProgramId:u,marketId:t,marketAuthority:T,lookupTableAccount:Va.default,configId:Un({programId:o})}}var Gr={volume:0,volumeQuote:0,volumeFee:0,apr:0,feeApr:0,priceMin:0,priceMax:0,rewardApr:[]},So=a=>{let e={},t=va.toBase58();return Object.keys(a).map(n=>{let r=a[n],[s,i]=[r.baseMint.toBase58(),r.quoteMint.toBase58()];e[n]={id:n,version:4,status:r.status.toNumber(),programId:r.programId.toBase58(),mintA:En({address:s,programId:t,decimals:r.baseDecimal.toNumber()}),mintB:En({address:i,programId:t,decimals:r.quoteDecimal.toNumber()}),rewardDefaultInfos:[],rewardDefaultPoolInfos:"Ecosystem",price:r.poolPrice.toNumber(),mintAmountA:new Gn(r.mintAAmount.toString()).div(10**r.baseDecimal.toNumber()).toNumber(),mintAmountB:new Gn(r.mintBAmount.toString()).div(10**r.quoteDecimal.toNumber()).toNumber(),baseReserve:r.baseReserve,quoteReserve:r.quoteReserve,feeRate:new Gn(r.tradeFeeNumerator.toString()).div(r.tradeFeeDenominator.toString()).toNumber(),openTime:r.poolOpenTime.toString(),tvl:0,day:Gr,week:Gr,month:Gr,pooltype:[],farmUpcomingCount:0,farmOngoingCount:0,farmFinishedCount:0,type:"Standard",marketId:r.marketId.toBase58(),configId:Un({programId:r.programId}).toBase58(),lpPrice:0,lpAmount:new Gn(r.lpReserve.toString()).div(10**Math.min(r.baseDecimal.toNumber(),r.quoteDecimal.toNumber())).toNumber(),lpMint:En({address:r.lpMint.toBase58(),programId:t,decimals:Math.min(r.baseDecimal.toNumber(),r.quoteDecimal.toNumber())}),burnPercent:0}}),e};import fe from"bn.js";import se from"decimal.js";import{PublicKey as zg}from"@solana/web3.js";import Hg from"bn.js";import{TOKEN_PROGRAM_ID as Zg}from"@solana/spl-token";import{SystemProgram as Vt,SYSVAR_RENT_PUBKEY as Oa,Transaction as Bo,TransactionInstruction as Da}from"@solana/web3.js";import{createInitializeAccountInstruction as Io,TOKEN_PROGRAM_ID as Ko}from"@solana/spl-token";function Fa(a="accountFlags"){let e=new Ln(a);return e.addBoolean("initialized"),e.addBoolean("market"),e.addBoolean("openOrders"),e.addBoolean("requestQueue"),e.addBoolean("eventQueue"),e.addBoolean("bids"),e.addBoolean("asks"),e}var Xr=C([Ae(5),Fa("accountFlags"),K("ownAddress"),f("vaultSignerNonce"),K("baseMint"),K("quoteMint"),K("baseVault"),f("baseDepositsTotal"),f("baseFeesAccrued"),K("quoteVault"),f("quoteDepositsTotal"),f("quoteFeesAccrued"),f("quoteDustThreshold"),K("requestQueue"),K("eventQueue"),K("bids"),K("asks"),f("baseLotSize"),f("quoteLotSize"),f("feeRateBps"),f("referrerRebatesAccrued"),Ae(7)]);function qa({programId:a,marketInfo:e}){let t=C([W("version"),Ke("instruction"),f("baseLotSize"),f("quoteLotSize"),xt("feeRateBps"),f("vaultSignerNonce"),f("quoteDustThreshold")]),n=[{pubkey:e.id,isSigner:!1,isWritable:!0},{pubkey:e.requestQueue,isSigner:!1,isWritable:!0},{pubkey:e.eventQueue,isSigner:!1,isWritable:!0},{pubkey:e.bids,isSigner:!1,isWritable:!0},{pubkey:e.asks,isSigner:!1,isWritable:!0},{pubkey:e.baseVault,isSigner:!1,isWritable:!0},{pubkey:e.quoteVault,isSigner:!1,isWritable:!0},{pubkey:e.baseMint,isSigner:!1,isWritable:!1},{pubkey:e.quoteMint,isSigner:!1,isWritable:!1},{pubkey:e.authority?e.quoteMint:Oa,isSigner:!1,isWritable:!1}].concat(e.authority?{pubkey:e.authority,isSigner:!1,isWritable:!1}:[]).concat(e.authority&&e.pruneAuthority?{pubkey:e.pruneAuthority,isSigner:!1,isWritable:!1}:[]),r=Buffer.alloc(t.span);return t.encode({version:0,instruction:0,baseLotSize:e.baseLotSize,quoteLotSize:e.quoteLotSize,feeRateBps:e.feeRateBps,vaultSignerNonce:e.vaultSignerNonce,quoteDustThreshold:e.quoteDustThreshold},r),new Da({keys:n,programId:a,data:r})}async function Qr({connection:a,wallet:e,marketInfo:t}){var i,o,u,l,c,m,p,d;let n=new Bo,r=await a.getMinimumBalanceForRentExemption(165);n.add(Vt.createAccountWithSeed({fromPubkey:e,basePubkey:e,seed:t.baseVault.seed,newAccountPubkey:t.baseVault.publicKey,lamports:r,space:165,programId:Ko}),Vt.createAccountWithSeed({fromPubkey:e,basePubkey:e,seed:t.quoteVault.seed,newAccountPubkey:t.quoteVault.publicKey,lamports:r,space:165,programId:Ko}),Io(t.baseVault.publicKey,t.baseMint,t.vaultOwner),Io(t.quoteVault.publicKey,t.quoteMint,t.vaultOwner),Vt.createAccountWithSeed({fromPubkey:e,basePubkey:e,seed:t.id.seed,newAccountPubkey:t.id.publicKey,lamports:await a.getMinimumBalanceForRentExemption(Xr.span),space:Xr.span,programId:t.programId}));let s=new Bo;return s.add(Vt.createAccountWithSeed({fromPubkey:e,basePubkey:e,seed:t.requestQueue.seed,newAccountPubkey:t.requestQueue.publicKey,lamports:t.lowestFeeMarket?6208320:await a.getMinimumBalanceForRentExemption((i=t.requestQueueSpace)!=null?i:5120+12),space:t.lowestFeeMarket?764:(o=t.requestQueueSpace)!=null?o:5120+12,programId:t.programId}),Vt.createAccountWithSeed({fromPubkey:e,basePubkey:e,seed:t.eventQueue.seed,newAccountPubkey:t.eventQueue.publicKey,lamports:t.lowestFeeMarket?79594560:await a.getMinimumBalanceForRentExemption((u=t.eventQueueSpace)!=null?u:262144+12),space:t.lowestFeeMarket?11308:(l=t.eventQueueSpace)!=null?l:262144+12,programId:t.programId}),Vt.createAccountWithSeed({fromPubkey:e,basePubkey:e,seed:t.bids.seed,newAccountPubkey:t.bids.publicKey,lamports:t.lowestFeeMarket?101977920:await a.getMinimumBalanceForRentExemption((c=t.orderbookQueueSpace)!=null?c:65536+12),space:t.lowestFeeMarket?14524:(m=t.orderbookQueueSpace)!=null?m:65536+12,programId:t.programId}),Vt.createAccountWithSeed({fromPubkey:e,basePubkey:e,seed:t.asks.seed,newAccountPubkey:t.asks.publicKey,lamports:t.lowestFeeMarket?101977920:await a.getMinimumBalanceForRentExemption((p=t.orderbookQueueSpace)!=null?p:65536+12),space:t.lowestFeeMarket?14524:(d=t.orderbookQueueSpace)!=null?d:65536+12,programId:t.programId}),qa({programId:t.programId,marketInfo:{id:t.id.publicKey,requestQueue:t.requestQueue.publicKey,eventQueue:t.eventQueue.publicKey,bids:t.bids.publicKey,asks:t.asks.publicKey,baseVault:t.baseVault.publicKey,quoteVault:t.quoteVault.publicKey,baseMint:t.baseMint,quoteMint:t.quoteMint,baseLotSize:t.baseLotSize,quoteLotSize:t.quoteLotSize,feeRateBps:t.feeRateBps,vaultSignerNonce:t.vaultSignerNonce,quoteDustThreshold:t.quoteDustThreshold}})),[{transaction:n,signer:[],instructionTypes:[U.CreateAccount,U.CreateAccount,U.InitAccount,U.InitAccount]},{transaction:s,signer:[],instructionTypes:[U.CreateAccount,U.CreateAccount,U.CreateAccount,U.CreateAccount,U.CreateAccount,U.InitMarket]}]}var zr=class extends zt{constructor(t){super(t);this.stableLayout=new bn({connection:this.scope.connection,modelDataPubKey:this.scope.cluster==="mainnet"?void 0:Tt.MODEL_DATA_PUBKEY})}async initLayout(){await this.stableLayout.initStableModelLayout()}async load(){this.checkDisabled()}computePairAmount({poolInfo:t,amount:n,slippage:r,baseIn:s}){let i=new fe(new se(n).mul(10**t[s?"mintA":"mintB"].decimals).toFixed(0)),o=ao(t[s?"mintB":"mintA"]),[u,l]=[new fe(new se(t.mintAmountA).mul(10**t.mintA.decimals).toString()),new fe(new se(t.mintAmountB).mul(10**t.mintB.decimals).toString())],c=new fe(new se(t.lpAmount).mul(10**t.lpMint.decimals).toFixed(0,se.ROUND_DOWN));this.logDebug("baseReserve:",u.toString(),"quoteReserve:",l.toString()),this.logDebug("tokenIn:",s?t.mintA.symbol:t.mintB.symbol,"amountIn:",i.toString(),"anotherToken:",s?t.mintB.symbol:t.mintA.symbol,"slippage:",`${r.toSignificant()}%`,"baseReserve",u.toString(),"quoteReserve",l.toString());let m=s?"base":"quote";this.logDebug("input side:",m);let p=mt;i.isZero()||(p=m==="base"?Tn(i.mul(l),u):Tn(i.mul(u),l)),this.logDebug("amountRaw:",p.toString(),"lpAmount:",c.toString());let d=Tn(i.mul(c),m==="base"?u:l);this.logDebug("liquidity:",d.toString());let b=new De(new fe(1)).add(r),y=new De(new fe(1)).sub(r),w=b.mul(p).quotient,g=y.mul(p).quotient,A=new be(o,p),T=new be(o,w),h=new be(o,g);return this.logDebug("anotherAmount:",A.toFixed(),"maxAnotherAmount:",T.toFixed()),{anotherAmount:A,maxAnotherAmount:T,minAnotherAmount:h,liquidity:d}}async getAmmPoolKeys(t){return(await this.scope.api.fetchPoolKeysById({idList:[t]}))[0]}async addLiquidity(t){let{poolInfo:n,poolKeys:r,amountInA:s,amountInB:i,otherAmountMin:o,fixedSide:u,config:l,txVersion:c,computeBudgetConfig:m,txTipConfig:p,feePayer:d}=t;this.scope.availability.addStandardPosition===!1&&this.logAndCreateError("add liquidity feature disabled in your region"),this.logDebug("amountInA:",s,"amountInB:",i),(s.isZero()||i.isZero())&&this.logAndCreateError("amounts must greater than zero","amountInA & amountInB",{amountInA:s.toFixed(),amountInB:i.toFixed()});let{account:b}=this.scope,{bypassAssociatedCheck:y,checkCreateATAOwner:w}=F({bypassAssociatedCheck:!1,checkCreateATAOwner:!1},l),[g,A]=[s.token,i.token],T=await b.getCreatedTokenAccount({mint:g.mint,associatedOnly:!1}),h=await b.getCreatedTokenAccount({mint:A.mint,associatedOnly:!1});!T&&!h&&this.logAndCreateError("cannot found target token accounts","tokenAccounts",b.tokenAccounts);let P=await b.getCreatedTokenAccount({mint:new we(n.lpMint.address)}),k=[g,A],S=[T,h],I=[s.raw,i.raw],L=s.token.mint.toBase58()===n.mintA.address?"base":"quote",x="base";["quote","base"].includes(L)||this.logAndCreateError("invalid fixedSide","fixedSide",u),L==="quote"?(k.reverse(),S.reverse(),I.reverse(),x=u==="a"?"quote":"base"):L==="base"&&(x=u==="a"?"base":"quote");let[_,v]=k,[V,G]=S,[$,ee]=I,re=r!=null?r:await this.getAmmPoolKeys(n.id),ke=this.createTxBuilder(d),nt=await b.handleTokenAccount({side:"in",amount:$,mint:_.mint,tokenAccount:V,bypassAssociatedCheck:y,checkCreateATAOwner:w}),{tokenAccount:Ue}=nt,tt=Oe(nt,["tokenAccount"]);ke.addInstruction(tt);let Fe=await b.handleTokenAccount({side:"in",amount:ee,mint:v.mint,tokenAccount:G,bypassAssociatedCheck:y,checkCreateATAOwner:w}),{tokenAccount:Ce}=Fe,Ne=Oe(Fe,["tokenAccount"]);ke.addInstruction(Ne);let _e=await b.handleTokenAccount({side:"out",amount:0,mint:new we(n.lpMint.address),tokenAccount:P,bypassAssociatedCheck:y,checkCreateATAOwner:w}),{tokenAccount:je}=_e,ct=Oe(_e,["tokenAccount"]);return ke.addInstruction(ct),ke.addInstruction({instructions:[mo({poolInfo:n,poolKeys:re,userKeys:{baseTokenAccount:Ue,quoteTokenAccount:Ce,lpTokenAccount:je,owner:this.scope.ownerPubKey},baseAmountIn:$,quoteAmountIn:ee,otherAmountMin:o.raw,fixedSide:x})],instructionTypes:[n.pooltype.includes("StablePool")?U.AmmV5AddLiquidity:U.AmmV4AddLiquidity],lookupTableAddress:re.lookupTableAccount?[re.lookupTableAccount]:[]}),ke.addCustomComputeBudget(m),ke.addTipInstruction(p),c===0?await ke.buildV0():ke.build()}async removeLiquidity(t){this.scope.availability.removeStandardPosition===!1&&this.logAndCreateError("remove liquidity feature disabled in your region");let{poolInfo:n,poolKeys:r,lpAmount:s,baseAmountMin:i,quoteAmountMin:o,config:u,txVersion:l,computeBudgetConfig:c,txTipConfig:m,feePayer:p}=t,d=r!=null?r:await this.getAmmPoolKeys(n.id),[b,y,w]=[new we(n.mintA.address),new we(n.mintB.address),new we(n.lpMint.address)];this.logDebug("lpAmount:",s),this.logDebug("baseAmountMin:",i),this.logDebug("quoteAmountMin:",o),s.isZero()&&this.logAndCreateError("amount must greater than zero","lpAmount",s.toString());let{account:g}=this.scope,A=await g.getCreatedTokenAccount({mint:w,associatedOnly:!1});A||this.logAndCreateError("cannot found lpTokenAccount","tokenAccounts",g.tokenAccounts);let T=await g.getCreatedTokenAccount({mint:b}),h=await g.getCreatedTokenAccount({mint:y}),P=this.createTxBuilder(p),{bypassAssociatedCheck:k,checkCreateATAOwner:S}=F({bypassAssociatedCheck:!1,checkCreateATAOwner:!1},u),v=await g.handleTokenAccount({side:"out",amount:0,mint:b,tokenAccount:T,bypassAssociatedCheck:k,checkCreateATAOwner:S}),{tokenAccount:I}=v,L=Oe(v,["tokenAccount"]);P.addInstruction(L);let V=await g.handleTokenAccount({side:"out",amount:0,mint:y,tokenAccount:h,bypassAssociatedCheck:k,checkCreateATAOwner:S}),{tokenAccount:x}=V,_=Oe(V,["tokenAccount"]);return P.addInstruction(_),P.addInstruction({instructions:[vr({poolInfo:n,poolKeys:d,userKeys:{lpTokenAccount:A,baseTokenAccount:I,quoteTokenAccount:x,owner:this.scope.ownerPubKey},lpAmount:s,baseAmountMin:i,quoteAmountMin:o})],lookupTableAddress:d.lookupTableAccount?[d.lookupTableAccount]:[],instructionTypes:[n.pooltype.includes("StablePool")?U.AmmV5RemoveLiquidity:U.AmmV4RemoveLiquidity]}),P.addCustomComputeBudget(c),P.addTipInstruction(m),l===0?await P.buildV0():P.build()}async removeAllLpAndCreateClmmPosition({poolInfo:t,clmmPoolInfo:n,removeLpAmount:r,createPositionInfo:s,farmInfo:i,userFarmLpAmount:o,base:u,computeBudgetConfig:l,payer:c,userAuxiliaryLedgers:m,tokenProgram:p=yt,checkCreateATAOwner:d=!0,getEphemeralSigners:b,txVersion:y,feePayer:w}){if((this.scope.availability.removeStandardPosition===!1||this.scope.availability.createConcentratedPosition===!1)&&this.logAndCreateError("remove liquidity or create position feature disabled in your region"),!(t.mintA.address===n.mintA.address||t.mintA.address===n.mintB.address)||!(t.mintB.address===n.mintA.address||t.mintB.address===n.mintB.address))throw Error("mint check error");let g=this.createTxBuilder(w),A={};for(let re of this.scope.account.tokenAccountRawInfos)(A[re.accountInfo.mint.toString()]===void 0||ae(this.scope.ownerPubKey,re.accountInfo.mint,yt).publicKey.equals(re.pubkey))&&(A[re.accountInfo.mint.toString()]=re.pubkey);let T=A[t.lpMint.address];if(T===void 0)throw Error("find lp account error in trade accounts");let h=r.add(o!=null?o:new fe(0)),P=t.mintA.address===Ie.WSOL.mint.toString(),k=t.mintB.address===Ie.WSOL.mint.toString(),{account:S,instructionParams:I}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:yt,mint:new we(t.mintA.address),owner:this.scope.ownerPubKey,createInfo:P?{payer:this.scope.ownerPubKey}:void 0,skipCloseAccount:!P,notUseTokenAccount:P,associatedOnly:!0,checkCreateATAOwner:d});if(g.addInstruction(I||{}),S===void 0)throw new Error("base token account not found");let{account:L,instructionParams:x}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:yt,mint:new we(t.mintB.address),owner:this.scope.ownerPubKey,createInfo:k?{payer:this.scope.ownerPubKey,amount:0}:void 0,skipCloseAccount:!k,notUseTokenAccount:k,associatedOnly:!0,checkCreateATAOwner:d});if(g.addInstruction(x||{}),L===void 0)throw new Error("quote token account not found");if(A[t.mintA.address]=S,A[t.mintB.address]=L,i!==void 0&&!(o!=null&&o.isZero())){let re=br[i.programId],ke=Ut({programId:new we(i.programId),poolId:new we(i.id),owner:this.scope.ownerPubKey,version:re}),Ue,tt=await this.scope.connection.getAccountInfo(ke);if(tt&&(Ue=_i(re).decode(tt.data)),re!==6&&!Ue){let{instruction:_e,instructionType:lt}=vi({id:new we(i.id),programId:new we(i.programId),version:re,ledger:ke,owner:this.scope.ownerPubKey});g.addInstruction({instructions:[_e],instructionTypes:[lt]})}let Ce=[];for(let _e of i.rewardInfos){let lt=_e.mint.address===Ie.WSOL.mint.toString();if(A[_e.mint.address])Ce.push(A[_e.mint.address]);else{let{account:Ht,instructionParams:gt}=await this.scope.account.getOrCreateTokenAccount({mint:new we(_e.mint.address),tokenProgram:p,owner:this.scope.ownerPubKey,skipCloseAccount:!lt,createInfo:{payer:c||this.scope.ownerPubKey},associatedOnly:!0,checkCreateATAOwner:d});Ht||this.logAndCreateError("farm reward account not found:",_e.mint.address),gt&&g.addInstruction(gt),Ce.push(Ht)}}let Ne=(await this.scope.api.fetchFarmKeysById({ids:i.id}))[0],je={userAuxiliaryLedgers:m,amount:o,owner:this.scope.ownerPubKey,farmInfo:i,farmKeys:Ne,lpAccount:T,rewardAccounts:Ce},ct=br[i.programId],nt=ct===6?Wi(je):ct===5?Ei(je):Fi(je),Fe={3:U.FarmV3Withdraw,5:U.FarmV5Withdraw,6:U.FarmV6Withdraw};g.addInstruction({instructions:[nt],instructionTypes:[Fe[ct]]})}let _=await this.getAmmPoolKeys(t.id),v=vr({poolInfo:t,poolKeys:_,userKeys:{lpTokenAccount:T,baseTokenAccount:S,quoteTokenAccount:L,owner:this.scope.ownerPubKey},lpAmount:h,baseAmountMin:0,quoteAmountMin:0});g.addInstruction({instructions:[v],instructionTypes:[t.pooltype.includes("StablePool")?U.AmmV5RemoveLiquidity:U.AmmV4RemoveLiquidity],lookupTableAddress:_.lookupTableAccount?[_.lookupTableAccount]:[]});let[V,G]=t.mintA.address===n.mintA.address?[S,L]:[L,S],$=await this.scope.clmm.getClmmPoolKeys(n.id),ee=await Qt.openPositionFromBaseInstructions(j(F({poolInfo:n,poolKeys:$,ownerInfo:{feePayer:this.scope.ownerPubKey,wallet:this.scope.ownerPubKey,tokenAccountA:V,tokenAccountB:G},withMetadata:"create"},s),{base:u,getEphemeralSigners:b}));return g.addInstruction({instructions:[...ee.instructions],signers:ee.signers,instructionTypes:[...ee.instructionTypes],lookupTableAddress:$.lookupTableAccount?[$.lookupTableAccount]:[]}),y===0?g.sizeCheckBuildV0({computeBudgetConfig:l}):g.sizeCheckBuild({computeBudgetConfig:l})}async createPoolV4({programId:t,marketInfo:n,baseMintInfo:r,quoteMintInfo:s,baseAmount:i,quoteAmount:o,startTime:u,ownerInfo:l,associatedOnly:c=!1,checkCreateATAOwner:m=!1,tokenProgram:p,txVersion:d,feeDestinationId:b,computeBudgetConfig:y,txTipConfig:w,feePayer:g}){var G;let A=l.feePayer||((G=this.scope.owner)==null?void 0:G.publicKey),T=l.useSOLBalance&&r.mint.equals(Xn),h=l.useSOLBalance&&s.mint.equals(Xn),P=this.createTxBuilder(g),{account:k,instructionParams:S}=await this.scope.account.getOrCreateTokenAccount({mint:r.mint,owner:this.scope.ownerPubKey,createInfo:T?{payer:A,amount:i}:void 0,notUseTokenAccount:T,skipCloseAccount:!T,associatedOnly:T?!1:c,checkCreateATAOwner:m});P.addInstruction(S||{});let{account:I,instructionParams:L}=await this.scope.account.getOrCreateTokenAccount({mint:s.mint,owner:this.scope.ownerPubKey,createInfo:h?{payer:A,amount:o}:void 0,notUseTokenAccount:h,skipCloseAccount:!h,associatedOnly:h?!1:c,checkCreateATAOwner:m});if(P.addInstruction(L||{}),k===void 0||I===void 0)throw Error("you don't has some token account");let x=Ur({version:4,marketVersion:3,marketId:n.marketId,baseMint:r.mint,quoteMint:s.mint,baseDecimals:r.decimals,quoteDecimals:s.decimals,programId:t,marketProgramId:n.programId}),_={programId:t,ammId:x.id,ammAuthority:x.authority,ammOpenOrders:x.openOrders,lpMint:x.lpMint,coinMint:x.baseMint,pcMint:x.quoteMint,coinVault:x.baseVault,pcVault:x.quoteVault,withdrawQueue:x.withdrawQueue,ammTargetOrders:x.targetOrders,poolTempLp:x.lpVault,marketProgramId:x.marketProgramId,marketId:x.marketId,ammConfigId:x.configId,feeDestinationId:b},{instruction:v,instructionType:V}=Wr(j(F({},_),{userWallet:this.scope.ownerPubKey,userCoinVault:k,userPcVault:I,userLpVault:ae(this.scope.ownerPubKey,x.lpMint,p).publicKey,nonce:x.nonce,openTime:u,coinAmount:i,pcAmount:o}));return P.addInstruction({instructions:[v],instructionTypes:[V]}),P.addCustomComputeBudget(y),P.addTipInstruction(w),P.versionBuild({txVersion:d,extInfo:{address:_}})}async createMarketAndPoolV4({programId:t=Pi,marketProgram:n=Ai,feeDestinationId:r=Ti,tokenProgram:s,baseMintInfo:i,quoteMintInfo:o,baseAmount:u,quoteAmount:l,startTime:c,ownerInfo:m,lowestFeeMarket:p,assignSeed:d,associatedOnly:b=!1,checkCreateATAOwner:y=!1,lotSize:w=1,tickSize:g=.01,txVersion:A,computeBudgetConfig:T,txTipConfig:h,feePayer:P}){var Hr,Yr,Zr;let k=this.scope.ownerPubKey,S=m.feePayer||((Hr=this.scope.owner)==null?void 0:Hr.publicKey),I=m.useSOLBalance&&i.mint.equals(Xn),L=m.useSOLBalance&&o.mint.equals(Xn),x=d?`${i.mint.toBase58().slice(0,7)}-${o.mint.toBase58().slice(0,7)}-${d}`:void 0,_=et({fromPublicKey:k,programId:n,assignSeed:x&&`${x}-market`}),v=et({fromPublicKey:k,programId:n,assignSeed:x&&`${x}-request`}),V=et({fromPublicKey:k,programId:n,assignSeed:x&&`${x}-event`}),G=et({fromPublicKey:k,programId:n,assignSeed:x&&`${x}-bids`}),$=et({fromPublicKey:k,programId:n,assignSeed:x&&`${x}-asks`}),ee=et({fromPublicKey:k,programId:yt,assignSeed:x&&`${x}-baseVault`}),re=et({fromPublicKey:k,programId:yt,assignSeed:x&&`${x}-quoteVault`}),ke=0,Ue=new fe(100);function tt(){let He=new fe(0);for(;;)try{return{vaultOwner:we.createProgramAddressSync([_.publicKey.toBuffer(),He.toArrayLike(Buffer,"le",8)],n),vaultSignerNonce:He}}catch{if(He.iaddn(1),He.gt(new fe(25555)))throw Error("find vault owner error")}}let{vaultOwner:Ce,vaultSignerNonce:Ne}=tt(),je=new fe(Math.round(10**i.decimals*w)),ct=new fe(Math.round(w*10**o.decimals*g));if(je.eq(mt))throw Error("lot size is too small");if(ct.eq(mt))throw Error("tick size or lot size is too small");let nt=await Qr({connection:this.scope.connection,wallet:this.scope.ownerPubKey,marketInfo:{programId:n,vaultOwner:Ce,baseMint:i.mint,quoteMint:o.mint,id:_,baseVault:ee,quoteVault:re,requestQueue:v,eventQueue:V,bids:G,asks:$,feeRateBps:ke,quoteDustThreshold:Ue,vaultSignerNonce:Ne,baseLotSize:je,quoteLotSize:ct,lowestFeeMarket:p}}),Fe=this.createTxBuilder(P);Fe.addInstruction({instructions:nt[0].transaction.instructions,signers:nt[0].signer});for await(let He of nt.slice(1,nt.length))Fe.addInstruction({instructions:He.transaction.instructions,signers:He.signer,instructionTypes:He.instructionTypes});let{account:_e,instructionParams:lt}=await this.scope.account.getOrCreateTokenAccount({mint:i.mint,owner:this.scope.ownerPubKey,createInfo:I?{payer:S,amount:u}:void 0,notUseTokenAccount:I,skipCloseAccount:!I,associatedOnly:I?!1:b,checkCreateATAOwner:y,assignSeed:I&&x?`${x}-wsol`:void 0});Fe.addInstruction(lt||{});let{account:Ht,instructionParams:gt}=await this.scope.account.getOrCreateTokenAccount({mint:o.mint,owner:this.scope.ownerPubKey,createInfo:L?{payer:S,amount:l}:void 0,notUseTokenAccount:L,skipCloseAccount:!L,associatedOnly:L?!1:b,checkCreateATAOwner:y,assignSeed:L&&x?`${x}-wsol`:void 0});if(Fe.addInstruction(gt||{}),_e===void 0)throw Error("you don't has base token account");if(Ht===void 0)throw Error("you don't has quote token account");let Be=Ur({version:4,marketVersion:3,marketId:_.publicKey,baseMint:i.mint,quoteMint:o.mint,baseDecimals:i.decimals,quoteDecimals:o.decimals,programId:t,marketProgramId:n}),Qn={programId:t,ammId:Be.id,ammAuthority:Be.authority,ammOpenOrders:Be.openOrders,lpMint:Be.lpMint,coinMint:Be.baseMint,pcMint:Be.quoteMint,coinVault:Be.baseVault,pcVault:Be.quoteVault,withdrawQueue:Be.withdrawQueue,ammTargetOrders:Be.targetOrders,poolTempLp:Be.lpVault,marketProgramId:Be.marketProgramId,marketId:Be.marketId,ammConfigId:Be.configId,feeDestinationId:r},{instruction:Lo,instructionType:Ro}=Wr(j(F({},Qn),{userWallet:this.scope.ownerPubKey,userCoinVault:_e,userPcVault:Ht,userLpVault:ae(this.scope.ownerPubKey,Be.lpMint,s).publicKey,nonce:Be.nonce,openTime:c,coinAmount:u,pcAmount:l}));Fe.addInstruction({instructions:[Lo],instructionTypes:[Ro]});let jr=I||L?[((Yr=lt==null?void 0:lt.instructions)==null?void 0:Yr[0])||((Zr=gt==null?void 0:gt.instructions)==null?void 0:Zr[0])].filter(He=>!!He):void 0;return A===0?Fe.sizeCheckBuildV0({computeBudgetConfig:T,splitIns:jr,address:F({requestQueue:v.publicKey,eventQueue:V.publicKey,bids:G.publicKey,asks:$.publicKey,baseVault:ee.publicKey,quoteVault:re.publicKey,baseMint:new we(i.mint),quoteMint:new we(o.mint)},Qn)}):Fe.sizeCheckBuild({computeBudgetConfig:T,splitIns:jr,address:F({requestQueue:v.publicKey,eventQueue:V.publicKey,bids:G.publicKey,asks:$.publicKey,baseVault:ee.publicKey,quoteVault:re.publicKey,baseMint:new we(i.mint),quoteMint:new we(o.mint)},Qn)})}async getCreatePoolFee({programId:t}){let n=Un({programId:t}),r=await this.scope.connection.getAccountInfo(n,{dataSlice:{offset:536,length:8}});if(r===null)throw Error("get config account error");return co.decode(r.data).fee}computeAmountOut({poolInfo:t,amountIn:n,mintIn:r,mintOut:s,slippage:i}){let[o,u]=[r.toString(),s.toString()];if(o!==t.mintA.address&&o!==t.mintB.address)throw new Error("toke not match");if(u!==t.mintA.address&&u!==t.mintB.address)throw new Error("toke not match");let{baseReserve:l,quoteReserve:c}=t,m=[l,c],p=[t.mintA.decimals,t.mintB.decimals],d=o==t.mintA.address?"base":"quote";d==="quote"&&(m.reverse(),p.reverse());let[b,y]=m,[w,g]=p,A=t.version===4,T;if(A)T=new se(y.toString()).div(10**g).div(new se(b.toString()).div(10**w));else{let V=wo(this.stableLayout.stableModelData,l.toNumber(),c.toNumber(),!1);d==="quote"?T=new se(1e6).div(V*1e6):T=new se(V*1e6).div(1e6)}let h=n,P=new fe(0),k=new fe(0);if(!h.isZero())if(A){k=nn(h.mul(Rr),Fn);let V=h.sub(k),G=b.add(V);P=y.mul(V).div(G)}else{k=h.mul(new fe(2)).div(new fe(1e4));let V=h.sub(k);d==="quote"?P=new fe(yo(this.stableLayout.stableModelData,c.toNumber(),l.toNumber(),V.toNumber())):P=new fe(go(this.stableLayout.stableModelData,c.toNumber(),l.toNumber(),V.toNumber()))}let S=new fe(new se(P.toString()).mul(1-i).toFixed(0)),I=P,L=S,x=new se(P.toString()).div(new se(h.sub(k).toString()).toFixed(0));!h.isZero()&&!P.isZero()&&(x=new se(P.toString()).div(10**g).div(new se(h.sub(k).toString()).div(10**w)));let _=T.sub(x).div(T).mul(100);return{amountOut:I,minAmountOut:L,currentPrice:T,executionPrice:x,priceImpact:_,fee:k}}computeAmountIn({poolInfo:t,amountOut:n,mintIn:r,mintOut:s,slippage:i}){let{baseReserve:o,quoteReserve:u}=t;r.toString()!==t.mintA.address&&r.toString()!==t.mintB.address&&this.logAndCreateError("mintIn does not match pool"),s.toString()!==t.mintA.address&&s.toString()!==t.mintB.address&&this.logAndCreateError("mintOut does not match pool"),this.logDebug("baseReserve:",o.toString()),this.logDebug("quoteReserve:",u.toString());let l=r.toString()===t.mintA.address,[c,m]=l?[t.mintA,t.mintB]:[t.mintB,t.mintA];this.logDebug("currencyOut:",m.symbol||m.address),this.logDebug("amountOut:",new se(n.toString()).div(10**m.decimals).toDecimalPlaces(m.decimals).toString(),c.symbol||c.address),this.logDebug("slippage:",`${i*100}%`);let p=[o,u],d=l?"quote":"base";d==="base"&&p.reverse(),this.logDebug("output side:",d);let[b,y]=p,w=new se(y.toString()).div(10**t[l?"mintB":"mintA"].decimals).div(new se(b.toString()).div(10**t[l?"mintA":"mintB"].decimals));this.logDebug("currentPrice:",`1 ${c.symbol||c.address} \u2248 ${w.toString()} ${m.symbol||m.address}`),this.logDebug("currentPrice invert:",`1 ${m.symbol||m.address} \u2248 ${new se(1).div(w).toString()} ${c.symbol||c.address}`);let g=new fe(0),A=n;if(!A.isZero()){A.gt(y)&&(A=y.sub(new fe(1)));let L=y.sub(A);g=b.mul(A).div(L).mul(Fn).div(Fn.sub(Rr))}let T=new fe(new se(g.toString()).mul(1+i).toFixed(0)),h=g,P=T;this.logDebug("amountIn:",new se(h.toString()).div(10**c.decimals).toDecimalPlaces(c.decimals).toString()),this.logDebug("maxAmountIn:",new se(P.toString()).div(10**c.decimals).toDecimalPlaces(c.decimals).toString());let k=null;!g.isZero()&&!A.isZero()&&(k=new se(A.toString()).div(10**m.decimals).div(new se(g.toString()).div(10**c.decimals)),this.logDebug("executionPrice:",`1 ${m.symbol||m.address} \u2248 ${k.toDecimalPlaces(Math.max(t.mintA.decimals,t.mintB.decimals)).toString()} ${c.symbol||c.address}`),this.logDebug("executionPrice invert:",`1 ${m.symbol||m.address} \u2248 ${new se(1).div(k).toDecimalPlaces(Math.max(t.mintA.decimals,t.mintB.decimals)).toString()} ${c.symbol||c.address}`));let S=w.mul(h.toString()),I=S.sub(n.toString()).abs().div(S);return this.logDebug("priceImpact:",`${I.toString()}%`),{amountIn:h,maxAmountIn:P,currentPrice:w,executionPrice:k,priceImpact:I}}async swap({poolInfo:t,poolKeys:n,amountIn:r,amountOut:s,inputMint:i,fixedSide:o,txVersion:u,config:l,computeBudgetConfig:c,txTipConfig:m,feePayer:p}){let d=this.createTxBuilder(p),{associatedOnly:b=!0,inputUseSolBalance:y=!0,outputUseSolBalance:w=!0}=l||{},[g,A]=i===t.mintA.address?[t.mintA,t.mintB]:[t.mintB,t.mintA],T=y&&g.address===vt.toBase58(),h=w&&A.address===vt.toBase58(),{account:P,instructionParams:k}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:yt,mint:new we(g.address),owner:this.scope.ownerPubKey,createInfo:T?{payer:this.scope.ownerPubKey,amount:r}:void 0,skipCloseAccount:!T,notUseTokenAccount:T,associatedOnly:b});d.addInstruction(k||{}),P||this.logAndCreateError("input token account not found",{token:g.symbol||g.address,tokenAccountIn:P,inputTokenUseSolBalance:T,associatedOnly:b});let{account:S,instructionParams:I}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:yt,mint:new we(A.address),owner:this.scope.ownerPubKey,createInfo:{payer:this.scope.ownerPubKey,amount:0},skipCloseAccount:!h,notUseTokenAccount:h,associatedOnly:h?!1:b});d.addInstruction(I||{}),S===void 0&&this.logAndCreateError("output token account not found",{token:A.symbol||A.address,tokenAccountOut:S,outputTokenUseSolBalance:h,associatedOnly:b});let L=n||await this.getAmmPoolKeys(t.id),x=4;return t.pooltype.includes("StablePool")&&(x=5),d.addInstruction({instructions:[po({version:x,poolKeys:L,userKeys:{tokenAccountIn:P,tokenAccountOut:S,owner:this.scope.ownerPubKey},amountIn:r,amountOut:s,fixedSide:o})],instructionTypes:[x===4?U.AmmV4SwapBaseIn:U.AmmV5SwapBaseIn]}),d.addCustomComputeBudget(c),d.addTipInstruction(m),d.versionBuild({txVersion:u})}async getRpcPoolInfo(t){return(await this.getRpcPoolInfos([t]))[t]}async getRpcPoolInfos(t,n){let r=await ht(this.scope.connection,t.map(c=>({pubkey:new we(c)})),n),s={},i=[];for(let c=0;c<t.length;c++){let m=r[c];if(m===null||!m.accountInfo)throw Error("fetch pool info error: "+String(t[c]));let p=Mr.decode(m.accountInfo.data);s[String(t[c])]=j(F({},p),{programId:m.accountInfo.owner}),i.push(p.baseVault,p.quoteVault)}let o={},u=await ht(this.scope.connection,i.map(c=>({pubkey:new we(c)})),n);for(let c=0;c<i.length;c++){let m=u[c].accountInfo;if(m===null)throw Error("fetch vault info error: "+i[c]);o[String(i[c])]=new fe(Ga.decode(m.data).amount.toString())}let l={};for(let[c,m]of Object.entries(s)){let p=o[m.baseVault.toString()].sub(m.baseNeedTakePnl),d=o[m.quoteVault.toString()].sub(m.quoteNeedTakePnl);l[c]=j(F({},m),{baseReserve:p,mintAAmount:o[m.baseVault.toString()],mintBAmount:o[m.quoteVault.toString()],quoteReserve:d,poolPrice:new se(d.toString()).div(new se(10).pow(m.quoteDecimal.toString())).div(new se(p.toString()).div(new se(10).pow(m.baseDecimal.toString())))})}return l}async getPoolInfoFromRpc({poolId:t}){let n=await this.getRpcPoolInfo(t),r=So({[t]:n}),s=r[t],i=await this.scope.tradeV2.computePoolToPoolKeys({pools:[r[t]],ammRpcData:{[t]:n}});return{poolRpcData:n,poolInfo:s,poolKeys:i[0]}}};export{zr as default};
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
//# sourceMappingURL=liquidity.mjs.map