var Mo=Object.defineProperty,_o=Object.defineProperties;var Vo=Object.getOwnPropertyDescriptors;var hn=Object.getOwnPropertySymbols;var ti=Object.prototype.hasOwnProperty,ni=Object.prototype.propertyIsEnumerable;var ei=(a,e,t)=>e in a?Mo(a,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):a[e]=t,F=(a,e)=>{for(var t in e||(e={}))ti.call(e,t)&&ei(a,t,e[t]);if(hn)for(var t of hn(e))ni.call(e,t)&&ei(a,t,e[t]);return a},z=(a,e)=>_o(a,Vo(e));var ve=(a,e)=>{var t={};for(var n in a)ti.call(a,n)&&e.indexOf(n)<0&&(t[n]=a[n]);if(a!=null&&hn)for(var n of hn(a))e.indexOf(n)<0&&ni.call(a,n)&&(t[n]=a[n]);return t};import{PublicKey as Ae}from"@solana/web3.js";import{AccountLayout as Xa,NATIVE_MINT as Hn,TOKEN_PROGRAM_ID as ht}from"@solana/spl-token";import{PublicKey as bs}from"@solana/web3.js";import ot from"bn.js";import wc from"decimal.js";import Xo from"big.js";import Sn from"bn.js";import{get as ri,set as vo}from"lodash";var jn=class{constructor(e){this.logLevel=e.logLevel!==void 0?e.logLevel:0,this.name=e.name}set level(e){this.logLevel=e}get time(){return Date.now().toString()}get moduleName(){return this.name}isLogLevel(e){return e<=this.logLevel}error(...e){return this.isLogLevel(0)?(console.error(this.time,this.name,"sdk logger error",...e),this):this}logWithError(...e){let t=e.map(n=>typeof n=="object"?JSON.stringify(n):n).join(", ");throw new Error(t)}warning(...e){return this.isLogLevel(1)?(console.warn(this.time,this.name,"sdk logger warning",...e),this):this}info(...e){return this.isLogLevel(2)?(console.info(this.time,this.name,"sdk logger info",...e),this):this}debug(...e){return this.isLogLevel(3)?(console.debug(this.time,this.name,"sdk logger debug",...e),this):this}},ii={},Eo={};function ie(a){let e=ri(ii,a);if(!e){let t=ri(Eo,a);e=new jn({name:a,logLevel:t}),vo(ii,a,e)}return e}import Wo from"toformat";var Oo=Wo,tn=Oo;import xn from"big.js";import Do from"bn.js";import qo from"decimal.js-light";import nn from"bn.js";var oi=9007199254740991;function $(a){let e=ie("Raydium_parseBigNumberish");if(a instanceof nn)return a;if(typeof a=="string"){if(a.match(/^-?[0-9]+$/))return new nn(a);e.logWithError(`invalid BigNumberish string: ${a}`)}return typeof a=="number"?(a%1&&e.logWithError(`BigNumberish number underflow: ${a}`),(a>=oi||a<=-oi)&&e.logWithError(`BigNumberish number overflow: ${a}`),new nn(String(a))):typeof a=="bigint"?new nn(a.toString()):(e.error(`invalid BigNumberish value: ${a}`),new nn(0))}var Tn=ie("module/fraction"),Zn=tn(xn),rn=tn(qo),Go={[0]:rn.ROUND_DOWN,[1]:rn.ROUND_HALF_UP,[2]:rn.ROUND_UP},Uo={[0]:xn.roundDown,[1]:xn.roundHalfUp,[2]:xn.roundUp},ne=class{constructor(e,t=new Do(1)){this.numerator=$(e),this.denominator=$(t)}get quotient(){return this.numerator.div(this.denominator)}invert(){return new ne(this.denominator,this.numerator)}add(e){let t=e instanceof ne?e:new ne($(e));return this.denominator.eq(t.denominator)?new ne(this.numerator.add(t.numerator),this.denominator):new ne(this.numerator.mul(t.denominator).add(t.numerator.mul(this.denominator)),this.denominator.mul(t.denominator))}sub(e){let t=e instanceof ne?e:new ne($(e));return this.denominator.eq(t.denominator)?new ne(this.numerator.sub(t.numerator),this.denominator):new ne(this.numerator.mul(t.denominator).sub(t.numerator.mul(this.denominator)),this.denominator.mul(t.denominator))}mul(e){let t=e instanceof ne?e:new ne($(e));return new ne(this.numerator.mul(t.numerator),this.denominator.mul(t.denominator))}div(e){let t=e instanceof ne?e:new ne($(e));return new ne(this.numerator.mul(t.denominator),this.denominator.mul(t.numerator))}toSignificant(e,t={groupSeparator:""},n=1){Number.isInteger(e)||Tn.logWithError(`${e} is not an integer.`),e<=0&&Tn.logWithError(`${e} is not positive.`),rn.set({precision:e+1,rounding:Go[n]});let r=new rn(this.numerator.toString()).div(this.denominator.toString()).toSignificantDigits(e);return r.toFormat(r.decimalPlaces(),t)}toFixed(e,t={groupSeparator:""},n=1){return Number.isInteger(e)||Tn.logWithError(`${e} is not an integer.`),e<0&&Tn.logWithError(`${e} is negative.`),Zn.DP=e,Zn.RM=Uo[n]||1,new Zn(this.numerator.toString()).div(this.denominator.toString()).toFormat(e,t)}isZero(){return this.numerator.isZero()}};var zo=ie("Raydium_amount"),si=tn(Xo);function Qo(a,e){let t="0",n="0";if(a.includes(".")){let r=a.split(".");r.length===2?([t,n]=r,n=n.padEnd(e,"0")):zo.logWithError(`invalid number string, num: ${a}`)}else t=a;return[t,n.slice(0,e)||n]}var we=class extends ne{constructor(t,n,r=!0,s){let i=new Sn(0),o=$n.pow(new Sn(t.decimals));if(r)i=$(n);else{let u=new Sn(0),l=new Sn(0);if(typeof n=="string"||typeof n=="number"||typeof n=="bigint"){let[c,m]=Qo(n.toString(),t.decimals);u=$(c),l=$(m)}u=u.mul(o),i=u.add(l)}super(i,o);this.logger=ie(s||"TokenAmount"),this.token=t}get raw(){return this.numerator}isZero(){return this.raw.isZero()}gt(t){return this.token.equals(t.token)||this.logger.logWithError("gt token not equals"),this.raw.gt(t.raw)}lt(t){return this.token.equals(t.token)||this.logger.logWithError("lt token not equals"),this.raw.lt(t.raw)}add(t){return this.token.equals(t.token)||this.logger.logWithError("add token not equals"),new we(this.token,this.raw.add(t.raw))}subtract(t){return this.token.equals(t.token)||this.logger.logWithError("sub token not equals"),new we(this.token,this.raw.sub(t.raw))}toSignificant(t=this.token.decimals,n,r=0){return super.toSignificant(t,n,r)}toFixed(t=this.token.decimals,n,r=0){return t>this.token.decimals&&this.logger.logWithError("decimals overflow"),super.toFixed(t,n,r)}toExact(t={groupSeparator:""}){return si.DP=this.token.decimals,new si(this.numerator.toString()).div(this.denominator.toString()).toFormat(t)}};import{PublicKey as Ho}from"@solana/web3.js";import{TOKEN_PROGRAM_ID as ai}from"@solana/spl-token";var Jn={chainId:101,address:Ho.default.toBase58(),programId:ai.toBase58(),decimals:9,symbol:"SOL",name:"solana",logoURI:"https://img-v1.raydium.io/icon/So11111111111111111111111111111111111111112.png",tags:[],priority:2,type:"raydium",extensions:{coingeckoId:"solana"}},it={chainId:101,address:"So11111111111111111111111111111111111111112",programId:ai.toBase58(),decimals:9,symbol:"WSOL",name:"Wrapped SOL",logoURI:"https://img-v1.raydium.io/icon/So11111111111111111111111111111111111111112.png",tags:[],priority:2,type:"raydium",extensions:{coingeckoId:"solana"}};import{PublicKey as rr}from"@solana/web3.js";import{PublicKey as de,SystemProgram as ui,SYSVAR_RENT_PUBKEY as Yo}from"@solana/web3.js";import{TOKEN_PROGRAM_ID as jo}from"@solana/spl-token";function I({pubkey:a,isSigner:e=!1,isWritable:t=!0}){return{pubkey:a,isWritable:t,isSigner:e}}var Zo=[I({pubkey:jo,isWritable:!1}),I({pubkey:ui.programId,isWritable:!1}),I({pubkey:Yo,isWritable:!1})];function er({publicKey:a,transformSol:e}){let t=tr(a.toString());if(t instanceof de)return e&&t.equals(Ut)?Gt:t;if(e&&t.toString()===Ut.toBase58())return Gt;if(typeof t=="string"){if(t===de.default.toBase58())return de.default;try{return new de(t)}catch{throw new Error("invalid public key")}}throw new Error("invalid public key")}function tr(a){try{return new de(a)}catch{return a}}var Bn=new de("MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr"),nr=new de("MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr"),Qe=new de("SysvarRent111111111111111111111111111111111"),Su=new de("SysvarC1ock11111111111111111111111111111111"),xt=new de("metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s"),$o=new de("Sysvar1nstructions1111111111111111111111111"),Bu=ui.programId,Iu=new de("4k3Dyjzvzp8eMZWUXbBCjEvwSkkk59S5iCNLY3QrkX6R"),Ku=new de("Ea5SjE2Y6yvCeW5dYTn7PYMuW5ikXkvbGdcmSnXeaLjS"),Lu=new de("SRMuApVNdxXokk5GT7XD5cUUgXMBCoAz2LHeuAoKWRt"),Ru=new de("EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v"),Cu=new de("Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB"),Nu=new de("mSoLzYCxHdYgdzU16g5QSh3i5K3z3KZK7ytfqcJm7So"),Mu=new de("7dHbWXmci3dT8UFYWYZweBLXgycu7Y3iL6trKn1Y7ARj"),_u=new de("USDH1SM1ojwWUga67PGrgFWUHibbjqMvuMaDkRJTgkX"),Vu=new de("NRVwhjBQiUPYtfDT5zRBVJajzFQHaBUNtC7SNVvqRFa"),vu=new de("ANAxByE6G2WjFp7A4NqtWYXb3mgruyzZYg3spfxe6Lbo"),Eu=new de("7vfCXTUXx5WJV5JADk17DUJ4ksgau7utNKj4b963voxs"),Gt=new de("So11111111111111111111111111111111111111112"),Ut=de.default;function Xt(a){return er({publicKey:a,transformSol:!0})}var ir=class{constructor({mint:e,decimals:t,symbol:n,name:r,skipMint:s=!1,isToken2022:i=!1}){if(e===Ut.toBase58()||e instanceof rr&&Ut.equals(e)){this.decimals=it.decimals,this.symbol=it.symbol,this.name=it.name,this.mint=new rr(it.address),this.isToken2022=!1;return}this.decimals=t,this.symbol=n||e.toString().substring(0,6),this.name=r||e.toString().substring(0,6),this.mint=s?rr.default:er({publicKey:e}),this.isToken2022=i}equals(e){return this===e?!0:this.mint.equals(e.mint)}},Re=ir;Re.WSOL=new ir(z(F({},it),{mint:it.address}));var or=class{constructor({decimals:e,symbol:t="UNKNOWN",name:n="UNKNOWN"}){this.decimals=e,this.symbol=t,this.name=n}equals(e){return this===e}},In=or;In.SOL=new or(Jn);import Jo from"bn.js";var ci=new ne(new Jo(100)),Ue=class extends ne{toSignificant(e=5,t,n){return this.mul(ci).toSignificant(e,t,n)}toFixed(e=2,t,n){return this.mul(ci).toFixed(e,t,n)}};var es=ie("Raydium_price"),Xe=class extends ne{constructor(t){let{baseToken:n,quoteToken:r,numerator:s,denominator:i}=t;super(s,i);this.baseToken=n,this.quoteToken=r,this.scalar=new ne(sr(n.decimals),sr(r.decimals))}get raw(){return new ne(this.numerator,this.denominator)}get adjusted(){return super.mul(this.scalar)}invert(){return new Xe({baseToken:this.quoteToken,quoteToken:this.baseToken,denominator:this.numerator,numerator:this.denominator})}mul(t){this.quoteToken!==t.baseToken&&es.logWithError("mul token not equals");let n=super.mul(t);return new Xe({baseToken:this.baseToken,quoteToken:t.quoteToken,denominator:n.denominator,numerator:n.numerator})}toSignificant(t=this.quoteToken.decimals,n,r){return this.adjusted.toSignificant(t,n,r)}toFixed(t=this.quoteToken.decimals,n,r){return this.adjusted.toFixed(t,n,r)}};var bt=new ot(0),li=new ot(1),Ic=new ot(2),Kc=new ot(3),Lc=new ot(5),$n=new ot(10),Rc=new ot(100),Cc=new ot(1e3),Nc=new ot(1e4);function sr(a){return $n.pow($(a))}function Kn(a,e){let t=a.divmod(e);return t.mod.isZero()?t.div:t.div.isNeg()?t.div.isubn(1):t.div.iaddn(1)}function ar(a,e=1,t=[]){let n=[...a];if(e<=0)return t;for(;n.length;)t.push(n.splice(0,e));return t}var Ze=class{constructor(e){this._owner=e}get publicKey(){return Ze.isKeyPair(this._owner)?this._owner.publicKey:this._owner}get signer(){return Ze.isKeyPair(this._owner)?this._owner:void 0}get isKeyPair(){return Ze.isKeyPair(this._owner)}get isPublicKey(){return Ze.isPublicKey(this._owner)}static isKeyPair(e){return e.secretKey!==void 0}static isPublicKey(e){return!Ze.isKeyPair(e)}};import{PublicKey as as}from"@solana/web3.js";import{TOKEN_PROGRAM_ID as us}from"@solana/spl-token";import{ComputeBudgetProgram as mi,Keypair as pi,PublicKey as ts,Transaction as fi,TransactionMessage as ns,VersionedTransaction as bi}from"@solana/web3.js";var U={CreateAccount:"CreateAccount",InitAccount:"InitAccount",CreateATA:"CreateATA",CloseAccount:"CloseAccount",TransferAmount:"TransferAmount",InitMint:"InitMint",MintTo:"MintTo",InitMarket:"InitMarket",Util1216OwnerClaim:"Util1216OwnerClaim",SetComputeUnitPrice:"SetComputeUnitPrice",SetComputeUnitLimit:"SetComputeUnitLimit",ClmmCreatePool:"ClmmCreatePool",ClmmOpenPosition:"ClmmOpenPosition",ClmmIncreasePosition:"ClmmIncreasePosition",ClmmDecreasePosition:"ClmmDecreasePosition",ClmmClosePosition:"ClmmClosePosition",ClmmSwapBaseIn:"ClmmSwapBaseIn",ClmmSwapBaseOut:"ClmmSwapBaseOut",ClmmInitReward:"ClmmInitReward",ClmmSetReward:"ClmmSetReward",ClmmCollectReward:"ClmmCollectReward",ClmmLockPosition:"ClmmLockPosition",ClmmHarvestLockPosition:"ClmmHarvestLockPosition",AmmV4Swap:"AmmV4Swap",AmmV4AddLiquidity:"AmmV4AddLiquidity",AmmV4RemoveLiquidity:"AmmV4RemoveLiquidity",AmmV4SimulatePoolInfo:"AmmV4SimulatePoolInfo",AmmV4SwapBaseIn:"AmmV4SwapBaseIn",AmmV4SwapBaseOut:"AmmV4SwapBaseOut",AmmV4CreatePool:"AmmV4CreatePool",AmmV4InitPool:"AmmV4InitPool",AmmV5AddLiquidity:"AmmV5AddLiquidity",AmmV5RemoveLiquidity:"AmmV5RemoveLiquidity",AmmV5SimulatePoolInfo:"AmmV5SimulatePoolInfo",AmmV5SwapBaseIn:"AmmV5SwapBaseIn",AmmV5SwapBaseOut:"AmmV5SwapBaseOut",RouteSwap:"RouteSwap",RouteSwap1:"RouteSwap1",RouteSwap2:"RouteSwap2",FarmV3Deposit:"FarmV3Deposit",FarmV3Withdraw:"FarmV3Withdraw",FarmV3CreateLedger:"FarmV3CreateLedger",FarmV4Withdraw:"FarmV4Withdraw",FarmV5Deposit:"FarmV5Deposit",FarmV5Withdraw:"FarmV5Withdraw",FarmV5CreateLedger:"FarmV5CreateLedger",FarmV6Deposit:"FarmV6Deposit",FarmV6Withdraw:"FarmV6Withdraw",FarmV6Create:"FarmV6Create",FarmV6Restart:"FarmV6Restart",FarmV6CreatorAddReward:"FarmV6CreatorAddReward",FarmV6CreatorWithdraw:"FarmV6CreatorWithdraw",CpmmCreatePool:"CpmmCreatePool",CpmmAddLiquidity:"CpmmAddLiquidity",CpmmWithdrawLiquidity:"CpmmWithdrawLiquidity",CpmmSwapBaseIn:"CpmmSwapBaseIn",CpmmSwapBaseOut:"CpmmSwapBaseOut",CpmmLockLp:"CpmmLockLp",CpmmCollectLockFee:"CpmmCollectLockFee",TransferTip:"TransferTip"};import{TOKEN_PROGRAM_ID as rs}from"@solana/spl-token";var di=ie("Raydium_txUtil"),yi=1644;function on(a){let e=[],t=[];return a.microLamports&&(e.push(mi.setComputeUnitPrice({microLamports:a.microLamports})),t.push(U.SetComputeUnitPrice)),a.units&&(e.push(mi.setComputeUnitLimit({units:a.units})),t.push(U.SetComputeUnitLimit)),{instructions:e,instructionTypes:t}}async function St(a,e){var n,r;let t=e!=null?e:"confirmed";return(r=await((n=a.getLatestBlockhash)==null?void 0:n.call(a,{commitment:t})))==null?void 0:r.blockhash}async function sn(a,e){return a.getSignatureStatuses([e]),new Promise((t,n)=>{let r=setTimeout(n,6e4);a.onSignature(e,s=>{if(clearTimeout(r),!s.err){t("");return}n(Object.assign(s.err,{txId:e}))},"confirmed")})}function is(a,e){a.length<1&&di.logWithError(`no instructions provided: ${a.toString()}`),e.length<1&&di.logWithError(`no signers provided:, ${e.toString()}`);let t=new fi;t.recentBlockhash="11111111111111111111111111111111",t.feePayer=e[0],t.add(...a);try{return Buffer.from(t.serialize({verifySignatures:!1})).toString("base64").length<yi}catch{return!1}}function be(a,e){let[t,n]=ts.findProgramAddressSync(a,e);return{publicKey:t,nonce:n}}function an({instructions:a,payer:e,signers:t}){return is(a,[e,...t])}function st({instructions:a,payer:e,lookupTableAddressAccount:t,recentBlockhash:n=pi.generate().publicKey.toString()}){let s=new ns({payerKey:e,recentBlockhash:n,instructions:a}).compileToV0Message(Object.values(t!=null?t:{}));try{return Buffer.from(new bi(s).serialize()).toString("base64").length<yi}catch{return!1}}var os=a=>Buffer.isBuffer(a)?a:a instanceof Uint8Array?Buffer.from(a.buffer,a.byteOffset,a.byteLength):Buffer.from(a),ss=a=>{let e=a.serialize({requireAllSignatures:!1,verifySignatures:!1});a instanceof bi&&(e=os(e));try{return e instanceof Buffer?e.toString("base64"):Buffer.from(e).toString("base64")}catch{return e.toString("base64")}};function yt(a){let e=[];return a.forEach(t=>{t instanceof fi&&(t.recentBlockhash||(t.recentBlockhash=rs.toBase58()),t.feePayer||(t.feePayer=pi.generate().publicKey)),e.push(ss(t))}),console.log("simulate tx string:",e),e}function ue(a,e,t){return be([a.toBuffer(),(t!=null?t:us).toBuffer(),e.toBuffer()],new as("ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL"))}import{PublicKey as D}from"@solana/web3.js";var gi=new D("EhhTKczWMGQt46ynNeRX1WfeagwwJd7ufHvCDjRxjo5Q"),wi=new D("CBuCnLe26faBpcBP2fktp4rp8abpcAnTWft6ZrP5Q4T"),ki=new D("9KEPoZmtHUrBbhWN1v1KWLMkkvwY6WLtAVUCPRtRjP4z"),Pi=new D("FarmqiPv5eAj3j1GMdMCMUGXqPUvmquZtMy86QH6rzhG"),Jc=new D("CLaimxFqjHzgTJtAGHU47NPhg6qrc5sCnpC4tBLyABQS"),Ai=new D("srmqPvymJeFKQ4zGQed1GFppgkRHL9kaELCbyksJtPX"),el=new D("9xQeWvG816bUx9EPjHmaT23yvVM2ZWbrrpZb9PusVFin"),hi=new D("675kPX9MHTjS2zt1qfr1NYHuzeLXfQM9H24wFSUt1Mp8"),tl=new D("5quBtoiQqxF9Jv6KYKctB59NT3gtJD2Y65kdnB1Uev3h"),nl=new D("CDSr3ssLcRB6XYPJwAfFt18MZvEZp4LjHcvzBVZ45duo"),rl=new D("CAMMCzo5YL8w4VFF8KVHrK22GGUsp5VTaW7grrKgrWqK"),il=new D("LockrWmn6K5twhz3y9w1dQERbmgSaRkfnTeTKbpofwE"),ol=new D("kN1kEznaF5Xbd8LYuqtEFcxzWSBk5Fv6ygX6SqEGJVy"),Bt=new D("CDSr3ssLcRB6XYPJwAfFt18MZvEZp4LjHcvzBVZ45duo"),sl=new D("routeUGWgWzqBWFcrCfv8tritsqukccJPu3q5GPP3xS"),Ti=new D("7YttLkHDoNj9wyDur5pM1ejNaAvT9X4eqaYcHQqtj2G5"),al=new D("6FJon3QE27qgPVggARueB22hLvoh22VzJpXv4rBEoSLF"),ul=new D("CC12se5To1CdEuw7fDS27B7Geo5jJyL7t5UK2B44NgiH"),cl=new D("9HzJyW1qZsEiSfMUf6L2jo3CcTKAyBmSyKdwQeYisHrC"),ll=new D("DropEU8AvevN3UrXWXTMuz3rqnMczQVNjq3kcSdW2SQi"),ml=new D("CPMMoo8L3F4NbTegBCKVNunggL7H1ZpdTHKxQB5qKP1C"),dl=new D("GpMZbSM2GgvTKHJirzeGfMFoaZ8UR2X7F4v8vHTvxFbL"),pl=new D("DNXgeM9EiiaAbaWvwjHj9fQQLAX5ZsfHyvmYUNRAdNC8"),fl=new D("LockrWmn6K5twhz3y9w1dQERbmgSaRkfnTeTKbpofwE"),bl=new D("3f7GcQFG397GAaEnv51zR6tsTVihYRydnydDD1cXekxH"),yl=new D("LanMV9sAd7wArD4vJFi2qDdfnVhFxYSUg6eADduJ3uj"),gl=new D("WLHv2UAZm6z4KyaaELi5pjdbJh6RESMva1Rnn8pJVVh"),wl=new D("DRay6fNdQ5J82H7xV6uq2aV3mNrUZ1J4PgSKsWgptcm6"),kl=new D("5xqNaZXX5eUi4p5HU4oz9i5QnwRNT2y6oN7yyn4qENeq"),Pl=new D("4Bu96XjU84XjPDSpveTVf6LYGCkfW5FK7SNkREWcEfV4"),Al=new D("6s1xP3hpbAfFoNtUNF8mfHsjr2Bd97JxFJRWLbL6aHuX");var It={OPEN_BOOK_PROGRAM:new D("EoTcMgcDRTJVZDMZWBoU6rhYHZfkNTVEAfz3uUJRcYGj"),SERUM_PROGRAM_ID_V3:new D("Ray1111111111111111111111111111111111111111"),AMM_V4:new D("DRaya7Kj3aMWQSy19kSjvmuwq9docCHofyP9kanQGaav"),AMM_STABLE:new D("DRayDdXc1NZQ9C3hRWmoSf8zK4iapgMnjdNZWrfwsP8m"),CLMM_PROGRAM_ID:new D("DRayAUgENGQBKVaX8owNhgzkEDyoHTGVEGHVJT1E9pfH"),CLMM_LOCK_PROGRAM_ID:new D("DRay25Usp3YJAi7beckgpGUC7mGJ2cR1AVPxhYfwVCUX"),CLMM_LOCK_AUTH_ID:new D("6Aoh8h2Lw2m5UGxYR8AdAL87jTWYeKoxM52mJRzfYwN"),CREATE_CPMM_POOL_PROGRAM:new D("DRaycpLY18LhpbydsBWbVJtxpNv9oXPgjRSfpF2bWpYb"),CREATE_CPMM_POOL_AUTH:new D("CXniRufdq5xL8t8jZAPxsPZDpuudwuJSPWnbcD5Y5Nxq"),CREATE_CPMM_POOL_FEE_ACC:new D("3oE58BKVt8KuYkGxx8zBojugnymWmBiyafWgMrnb6eYy"),LOCK_CPMM_PROGRAM:new D("DRay25Usp3YJAi7beckgpGUC7mGJ2cR1AVPxhYfwVCUX"),LOCK_CPMM_AUTH:new D("7qWVV8UY2bRJfDLP4s37YzBPKUkVB46DStYJBpYbQzu3"),UTIL1216:D.default,Router:new D("DRaybByLpbUL57LJARs3j8BitTxVfzBg351EaMr5UTCd"),FARM_PROGRAM_ID_V3:new D("DRayWyrLmEW5KEeqs8kdTMMaBabapqagaBC7KWpGtJeZ"),FARM_PROGRAM_ID_V4:new D("Ray1111111111111111111111111111111111111111"),FARM_PROGRAM_ID_V5:new D("DRayiCGSZgku1GTK6rXD6mVDdingXy6APAH1R6R5L2LC"),FARM_PROGRAM_ID_V6:new D("DRayzbYakXs45ELHkzH6vC3fuhQqTAnv5A68gdFuvZyZ"),LAUNCHPAD_PROGRAM:new D("DRay6fNdQ5J82H7xV6uq2aV3mNrUZ1J4PgSKsWgptcm6"),LAUNCHPAD_AUTH:new D("5xqNaZXX5eUi4p5HU4oz9i5QnwRNT2y6oN7yyn4qENeq"),LAUNCHPAD_PLATFORM:new D("2Jx4KTDrVSdWNazuGpcA8n3ZLTRGGBDxAWhuKe2Xcj2a"),LAUNCHPAD_CONFIG:new D("7ZR4zD7PYfY2XxoG1Gxcy2EgEeGYrpxrwzPuwdUBssEt"),FEE_DESTINATION_ID:new D("9y8ENuuZ3b19quffx9hQvRVygG5ky6snHfRvGpuSfeJy"),MODEL_DATA_PUBKEY:new D("Ray1111111111111111111111111111111111111111")};import He from"bn.js";var un=1e4;function ke(a,e,t,n){if(e===void 0)return{amount:a,fee:void 0,expirationTime:void 0};let r=z(F({},e),{olderTransferFee:{epoch:BigInt(e.olderTransferFee.epoch),maximumFee:BigInt(e.olderTransferFee.maximumFee),transferFeeBasisPoints:e.olderTransferFee.transferFeeBasisPoints},newerTransferFee:{epoch:BigInt(e.newerTransferFee.epoch),maximumFee:BigInt(e.newerTransferFee.maximumFee),transferFeeBasisPoints:e.newerTransferFee.transferFeeBasisPoints}}),s=t.epoch<r.newerTransferFee.epoch?r.olderTransferFee:r.newerTransferFee,i=new He(s.maximumFee.toString()),o=t.epoch<r.newerTransferFee.epoch?(Number(r.newerTransferFee.epoch)*t.slotsInEpoch-t.absoluteSlot)*400/1e3:void 0;if(n)if(s.transferFeeBasisPoints===un){let u=new He(s.maximumFee.toString());return{amount:a.add(u),fee:u,expirationTime:o}}else{let u=cn(a.mul(new He(un)),new He(un-s.transferFeeBasisPoints)),l=new He(s.maximumFee.toString()),c=u.sub(a).gt(l)?a.add(l):u,m=cn(c.mul(new He(s.transferFeeBasisPoints)),new He(un)),p=m.gt(i)?i:m;return{amount:c,fee:p,expirationTime:o}}else{let u=cn(a.mul(new He(s.transferFeeBasisPoints)),new He(un)),l=u.gt(i)?i:u;return{amount:a,fee:l,expirationTime:o}}}function gt(a,e){return a===void 0?e:e===void 0?a:Math.min(a,e)}function cn(a,e){let{div:t,mod:n}=a.divmod(e);return n.gt(new He(0))?t.add(new He(1)):t}import{PublicKey as ur,AddressLookupTableAccount as Qt}from"@solana/web3.js";async function Ln({connection:a,address:e,cluster:t="mainnet"}){let n=await at(a,[...new Set(e.map(s=>s.toString()))].map(s=>new ur(s))),r={};for(let s=0;s<e.length;s++){let i=n[s],o=e[s];if(!i)continue;let u=new Qt({key:o,state:Qt.deserialize(i.data)});r[o.toString()]=u,t==="devnet"?zt[o.toString()]=u:wt[o.toString()]=u}return r}var wt={},cr=async a=>{let e="AcL1Vo8oy1ULiavEcjSUcwfBSForXMudcZvDZy5nzJkU";if(wt[e])return wt;let t=new ur(e),n=await a.getAccountInfo(t);return n&&(wt[e]=new Qt({key:t,state:Qt.deserialize(n.data)})),wt},zt={},Rn=async a=>{let e="EFhMuDw1PKEuckuFRW9PavNfTH4LKP5uKHgyXDmWpFCq";if(zt[e])return zt;let t=new ur(e),n=await a.getAccountInfo(t);return n&&(zt[e]=new Qt({key:t,state:Qt.deserialize(n.data)})),zt};import{PublicKey as Kt,sendAndConfirmTransaction as lr,SystemProgram as cs,Transaction as ln,TransactionMessage as ut,VersionedTransaction as ct}from"@solana/web3.js";import ls from"axios";var mn=2e3,dn=class{constructor(e){this.instructions=[];this.endInstructions=[];this.lookupTableAddress=[];this.signers=[];this.instructionTypes=[];this.endInstructionTypes=[];this.connection=e.connection,this.feePayer=e.feePayer,this.signAllTransactions=e.signAllTransactions,this.owner=e.owner,this.cluster=e.cluster,this.blockhashCommitment=e.blockhashCommitment,this.loopMultiTxStatus=!!e.loopMultiTxStatus}get AllTxData(){return{instructions:this.instructions,endInstructions:this.endInstructions,signers:this.signers,instructionTypes:this.instructionTypes,endInstructionTypes:this.endInstructionTypes,lookupTableAddress:this.lookupTableAddress}}get allInstructions(){return[...this.instructions,...this.endInstructions]}async getComputeBudgetConfig(){var n;let e=(await ls.get(`https://solanacompass.com/api/fees?cacheFreshTime=${3e5}`)).data,{avg:t}=(n=e==null?void 0:e[15])!=null?n:{};if(!!t)return{units:6e5,microLamports:Math.min(Math.ceil(t*1e6/6e5),25e3)}}addCustomComputeBudget(e){if(e){let{instructions:t,instructionTypes:n}=on(e);return this.instructions.unshift(...t),this.instructionTypes.unshift(...n),!0}return!1}addTipInstruction(e){var t;return e?(this.endInstructions.push(cs.transfer({fromPubkey:(t=e.feePayer)!=null?t:this.feePayer,toPubkey:new Kt(e.address),lamports:BigInt(e.amount.toString())})),this.endInstructionTypes.push(U.TransferTip),!0):!1}async calComputeBudget({config:e,defaultIns:t}){try{let n=e||await this.getComputeBudgetConfig();if(this.addCustomComputeBudget(n))return;t&&this.instructions.unshift(...t)}catch{t&&this.instructions.unshift(...t)}}addInstruction({instructions:e=[],endInstructions:t=[],signers:n=[],instructionTypes:r=[],endInstructionTypes:s=[],lookupTableAddress:i=[]}){return this.instructions.push(...e),this.endInstructions.push(...t),this.signers.push(...n),this.instructionTypes.push(...r),this.endInstructionTypes.push(...s),this.lookupTableAddress.push(...i.filter(o=>o!==Kt.default.toString())),this}async versionBuild({txVersion:e,extInfo:t}){return e===0?await this.buildV0(F({},t||{})):this.build(t)}build(e){var n;let t=new ln;return this.allInstructions.length&&t.add(...this.allInstructions),t.feePayer=this.feePayer,((n=this.owner)==null?void 0:n.signer)&&!this.signers.some(r=>r.publicKey.equals(this.owner.publicKey))&&this.signers.push(this.owner.signer),{builder:this,transaction:t,signers:this.signers,instructionTypes:[...this.instructionTypes,...this.endInstructionTypes],execute:async r=>{var c;let{recentBlockHash:s,skipPreflight:i=!0,sendAndConfirm:o,notSendToRpc:u}=r||{},l=s!=null?s:await St(this.connection,this.blockhashCommitment);if(t.recentBlockhash=l,this.signers.length&&t.sign(...this.signers),yt([t]),(c=this.owner)!=null&&c.isKeyPair)return{txId:o?await lr(this.connection,t,this.signers.find(p=>p.publicKey.equals(this.owner.publicKey))?this.signers:[...this.signers,this.owner.signer],{skipPreflight:i}):await this.connection.sendRawTransaction(t.serialize(),{skipPreflight:i}),signedTx:t};if(this.signAllTransactions){let m=await this.signAllTransactions([t]);if(this.signers.length)for(let p of m)try{p.sign(...this.signers)}catch{}return{txId:u?"":await this.connection.sendRawTransaction(m[0].serialize(),{skipPreflight:i}),signedTx:m[0]}}throw new Error("please provide owner in keypair format or signAllTransactions function")},extInfo:e||{}}}buildMultiTx(e){var l;let{extraPreBuildData:t=[],extInfo:n}=e,{transaction:r}=this.build(n),s=t.filter(c=>c.transaction.instructions.length>0),i=[r,...s.map(c=>c.transaction)],o=[this.signers,...s.map(c=>c.signers)],u=[...this.instructionTypes,...s.map(c=>c.instructionTypes).flat()];return(l=this.owner)!=null&&l.signer&&o.forEach(c=>{c.some(m=>m.publicKey.equals(this.owner.publicKey))||this.signers.push(this.owner.signer)}),{builder:this,transactions:i,signers:o,instructionTypes:u,execute:async c=>{var g;let{sequentially:m,onTxUpdate:p,skipTxCount:d=0,recentBlockHash:f,skipPreflight:y=!0}=c||{},w=f!=null?f:await St(this.connection,this.blockhashCommitment);if((g=this.owner)!=null&&g.isKeyPair){if(m){let A=[],T=0;for(let h of i){if(++T,T<=d)continue;let P=await lr(this.connection,h,this.signers.find(k=>k.publicKey.equals(this.owner.publicKey))?this.signers:[...this.signers,this.owner.signer],{skipPreflight:y});A.push(P)}return{txIds:A,signedTxs:i}}return{txIds:await await Promise.all(i.map(async A=>(A.recentBlockhash=w,await this.connection.sendRawTransaction(A.serialize(),{skipPreflight:y})))),signedTxs:i}}if(this.signAllTransactions){let A=i.map((h,P)=>(h.recentBlockhash=w,o[P].length&&h.sign(...o[P]),h));yt(A);let T=await this.signAllTransactions(A);if(m){let h=0,P=[],k=async()=>{if(!T[h])return;let S=await this.connection.sendRawTransaction(T[h].serialize(),{skipPreflight:y});P.push({txId:S,status:"sent",signedTx:T[h]}),p==null||p([...P]),h++;let x=!1,K=null,B=null,N=M=>{K!==null&&clearInterval(K),B!==null&&this.connection.removeSignatureListener(B);let C=P.findIndex(E=>E.txId===S);if(C>-1){if(P[C].status==="error"||P[C].status==="success")return;P[C].status=M.err?"error":"success"}p==null||p([...P]),M.err||k()};this.loopMultiTxStatus&&(K=setInterval(async()=>{var M;if(x){clearInterval(K);return}try{let C=await this.connection.getTransaction(S,{commitment:"confirmed",maxSupportedTransactionVersion:0});C&&(x=!0,clearInterval(K),N({err:((M=C.meta)==null?void 0:M.err)||null}),console.log("tx status from getTransaction:",S))}catch(C){x=!0,clearInterval(K),console.error("getTransaction timeout:",C,S)}},mn)),B=this.connection.onSignature(S,M=>{if(x){this.connection.removeSignatureListener(B);return}x=!0,N(M)},"confirmed"),this.connection.getSignatureStatus(S)};return await k(),{txIds:P.map(S=>S.txId),signedTxs:T}}else{let h=[];for(let P=0;P<T.length;P+=1){let k=await this.connection.sendRawTransaction(T[P].serialize(),{skipPreflight:y});h.push(k)}return{txIds:h,signedTxs:T}}}throw new Error("please provide owner in keypair format or signAllTransactions function")},extInfo:n||{}}}async versionMultiBuild({extraPreBuildData:e,txVersion:t,extInfo:n}){return t===0?await this.buildV0MultiTx({extraPreBuildData:e,buildProps:n||{}}):this.buildMultiTx({extraPreBuildData:e,extInfo:n})}async buildV0(e){var y;let f=e||{},{lookupTableCache:t={},lookupTableAddress:n=[],forerunCreate:r,recentBlockhash:s}=f,i=ve(f,["lookupTableCache","lookupTableAddress","forerunCreate","recentBlockhash"]),o=F(F({},this.cluster==="devnet"?await Rn(this.connection):await cr(this.connection)),t),u=Array.from(new Set([...n,...this.lookupTableAddress])),l=[];for(let w of u)o[w]===void 0&&l.push(new Kt(w));let c=await Ln({connection:this.connection,address:l});for(let[w,g]of Object.entries(c))o[w]=g;let m=r?Kt.default.toBase58():s!=null?s:await St(this.connection,this.blockhashCommitment),p=new ut({payerKey:this.feePayer,recentBlockhash:m,instructions:[...this.allInstructions]}).compileToV0Message(Object.values(o));((y=this.owner)==null?void 0:y.signer)&&!this.signers.some(w=>w.publicKey.equals(this.owner.publicKey))&&this.signers.push(this.owner.signer);let d=new ct(p);return d.sign(this.signers),{builder:this,transaction:d,signers:this.signers,instructionTypes:[...this.instructionTypes,...this.endInstructionTypes],execute:async w=>{var h;let{skipPreflight:g=!0,sendAndConfirm:A,notSendToRpc:T}=w||{};if(yt([d]),(h=this.owner)!=null&&h.isKeyPair){let P=await this.connection.sendTransaction(d,{skipPreflight:g});return A&&await sn(this.connection,P),{txId:P,signedTx:d}}if(this.signAllTransactions){let P=await this.signAllTransactions([d]);if(this.signers.length)for(let k of P)try{k.sign(this.signers)}catch{}return{txId:T?"":await this.connection.sendTransaction(P[0],{skipPreflight:g}),signedTx:P[0]}}throw new Error("please provide owner in keypair format or signAllTransactions function")},extInfo:i||{}}}async buildV0MultiTx(e){var l;let{extraPreBuildData:t=[],buildProps:n}=e,{transaction:r}=await this.buildV0(n),s=t.filter(c=>c.builder.instructions.length>0),i=[r,...s.map(c=>c.transaction)],o=[this.signers,...s.map(c=>c.signers)],u=[...this.instructionTypes,...s.map(c=>c.instructionTypes).flat()];return(l=this.owner)!=null&&l.signer&&o.forEach(c=>{c.some(m=>m.publicKey.equals(this.owner.publicKey))||this.signers.push(this.owner.signer)}),i.forEach(async(c,m)=>{c.sign(o[m])}),{builder:this,transactions:i,signers:o,instructionTypes:u,buildProps:n,execute:async c=>{var y;let{sequentially:m,onTxUpdate:p,recentBlockHash:d,skipPreflight:f=!0}=c||{};if(d&&i.forEach(w=>w.message.recentBlockhash=d),yt(i),(y=this.owner)!=null&&y.isKeyPair){if(m){let w=[];for(let g of i){let A=await this.connection.sendTransaction(g,{skipPreflight:f});await sn(this.connection,A),w.push(A)}return{txIds:w,signedTxs:i}}return{txIds:await Promise.all(i.map(async w=>await this.connection.sendTransaction(w,{skipPreflight:f}))),signedTxs:i}}if(this.signAllTransactions){let w=await this.signAllTransactions(i);if(m){let g=0,A=[],T=async()=>{if(!w[g])return;let h=await this.connection.sendTransaction(w[g],{skipPreflight:f});A.push({txId:h,status:"sent",signedTx:w[g]}),p==null||p([...A]),g++;let P=!1,k=null,S=null,x=K=>{k!==null&&clearInterval(k),S!==null&&this.connection.removeSignatureListener(S);let B=A.findIndex(N=>N.txId===h);if(B>-1){if(A[B].status==="error"||A[B].status==="success")return;A[B].status=K.err?"error":"success"}p==null||p([...A]),K.err||T()};this.loopMultiTxStatus&&(k=setInterval(async()=>{var K;if(P){clearInterval(k);return}try{let B=await this.connection.getTransaction(h,{commitment:"confirmed",maxSupportedTransactionVersion:0});B&&(P=!0,clearInterval(k),x({err:((K=B.meta)==null?void 0:K.err)||null}),console.log("tx status from getTransaction:",h))}catch(B){P=!0,clearInterval(k),console.error("getTransaction timeout:",B,h)}},mn)),S=this.connection.onSignature(h,K=>{if(P){this.connection.removeSignatureListener(S);return}P=!0,x(K)},"confirmed"),this.connection.getSignatureStatus(h)};return T(),{txIds:[],signedTxs:w}}else{let g=[];for(let A=0;A<w.length;A+=1){let T=await this.connection.sendTransaction(w[A],{skipPreflight:f});g.push(T)}return{txIds:g,signedTxs:w}}}throw new Error("please provide owner in keypair format or signAllTransactions function")},extInfo:n||{}}}async sizeCheckBuild(e){var p;let m=e||{},{splitIns:t=[],computeBudgetConfig:n}=m,r=ve(m,["splitIns","computeBudgetConfig"]),s=n?on(n):{instructions:[],instructionTypes:[]},i=this.signers.reduce((d,f)=>z(F({},d),{[f.publicKey.toBase58()]:f}),{}),o=[],u=[],l=[],c=0;if(this.allInstructions.forEach(d=>{let f=[...l,d],y=n?[...s.instructions,...f]:f,g=[...new Set(f.map(A=>A.keys.filter(T=>T.isSigner).map(T=>T.pubkey.toString())).flat()).values()].map(A=>new Kt(A));if(d!==t[c]&&l.length<12&&(an({instructions:y,payer:this.feePayer,signers:g})||an({instructions:f,payer:this.feePayer,signers:g})))l.push(d);else{if(l.length===0)throw Error("item ins too big");c+=d===t[c]?1:0,an({instructions:n?[...s.instructions,...l]:[...l],payer:this.feePayer,signers:g})?o.push(new ln().add(...s.instructions,...l)):o.push(new ln().add(...l)),u.push(Array.from(new Set(l.map(A=>A.keys.filter(T=>T.isSigner).map(T=>T.pubkey.toString())).flat())).map(A=>i[A]).filter(A=>A!==void 0)),l=[d]}}),l.length>0){let f=[...new Set(l.map(y=>y.keys.filter(w=>w.isSigner).map(w=>w.pubkey.toString())).flat()).values()].map(y=>i[y]).filter(y=>y!==void 0);an({instructions:n?[...s.instructions,...l]:[...l],payer:this.feePayer,signers:f.map(y=>y.publicKey)})?o.push(new ln().add(...s.instructions,...l)):o.push(new ln().add(...l)),u.push(f)}return o.forEach(d=>d.feePayer=this.feePayer),(p=this.owner)!=null&&p.signer&&u.forEach(d=>{d.some(f=>f.publicKey.equals(this.owner.publicKey))||d.push(this.owner.signer)}),{builder:this,transactions:o,signers:u,instructionTypes:this.instructionTypes,execute:async d=>{var h;let{sequentially:f,onTxUpdate:y,skipTxCount:w=0,recentBlockHash:g,skipPreflight:A=!0}=d||{},T=g!=null?g:await St(this.connection,this.blockhashCommitment);if(o.forEach(async(P,k)=>{P.recentBlockhash=T,u[k].length&&P.sign(...u[k])}),yt(o),(h=this.owner)!=null&&h.isKeyPair){if(f){let P=0,k=[];for(let S of o){if(++P,P<=w){k.push("tx skipped");continue}let x=await lr(this.connection,S,this.signers.find(K=>K.publicKey.equals(this.owner.publicKey))?this.signers:[...this.signers,this.owner.signer],{skipPreflight:A});k.push(x)}return{txIds:k,signedTxs:o}}return{txIds:await Promise.all(o.map(async P=>await this.connection.sendRawTransaction(P.serialize(),{skipPreflight:A}))),signedTxs:o}}if(this.signAllTransactions){let P=await this.signAllTransactions(o.slice(w,o.length)),k=[...o.slice(0,w),...P];if(f){let S=0,x=[],K=async()=>{if(!k[S])return;S<w&&(x.push({txId:"",status:"success",signedTx:k[S]}),y==null||y([...x]),S++,K());let B=await this.connection.sendRawTransaction(k[S].serialize(),{skipPreflight:A});x.push({txId:B,status:"sent",signedTx:k[S]}),y==null||y([...x]),S++;let N=!1,M=null,C=null,E=j=>{M!==null&&clearInterval(M),C!==null&&this.connection.removeSignatureListener(C);let Y=x.findIndex(Z=>Z.txId===B);if(Y>-1){if(x[Y].status==="error"||x[Y].status==="success")return;x[Y].status=j.err?"error":"success"}y==null||y([...x]),j.err||K()};this.loopMultiTxStatus&&(M=setInterval(async()=>{var j;if(N){clearInterval(M);return}try{let Y=await this.connection.getTransaction(B,{commitment:"confirmed",maxSupportedTransactionVersion:0});Y&&(N=!0,clearInterval(M),E({err:((j=Y.meta)==null?void 0:j.err)||null}),console.log("tx status from getTransaction:",B))}catch(Y){N=!0,clearInterval(M),console.error("getTransaction timeout:",Y,B)}},mn)),C=this.connection.onSignature(B,j=>{if(N){this.connection.removeSignatureListener(C);return}N=!0,E(j)},"confirmed"),this.connection.getSignatureStatus(B)};return await K(),{txIds:x.map(B=>B.txId),signedTxs:k}}else{let S=[];for(let x=0;x<k.length;x+=1){let K=await this.connection.sendRawTransaction(k[x].serialize(),{skipPreflight:A});S.push(K)}return{txIds:S,signedTxs:k}}}throw new Error("please provide owner in keypair format or signAllTransactions function")},extInfo:r||{}}}async sizeCheckBuildV0(e){var T;let A=e||{},{computeBudgetConfig:t,splitIns:n=[],lookupTableCache:r={},lookupTableAddress:s=[]}=A,i=ve(A,["computeBudgetConfig","splitIns","lookupTableCache","lookupTableAddress"]),o=F(F({},this.cluster==="devnet"?await Rn(this.connection):wt),r),u=Array.from(new Set([...this.lookupTableAddress,...s])),l=[];for(let h of u)o[h]===void 0&&l.push(new Kt(h));let c=await Ln({connection:this.connection,address:l});for(let[h,P]of Object.entries(c))o[h]=P;let m=t?on(t):{instructions:[],instructionTypes:[]},p=await St(this.connection,this.blockhashCommitment),d=this.signers.reduce((h,P)=>z(F({},h),{[P.publicKey.toBase58()]:P}),{}),f=[],y=[],w=[],g=0;if(this.allInstructions.forEach(h=>{let P=[...w,h],k=t?[...m.instructions,...P]:P;if(h!==n[g]&&w.length<12&&(st({instructions:k,payer:this.feePayer,lookupTableAddressAccount:o})||st({instructions:P,payer:this.feePayer,lookupTableAddressAccount:o})))w.push(h);else{if(w.length===0)throw Error("item ins too big");g+=h===n[g]?1:0;let S={};for(let x of[...new Set(u)])o[x]!==void 0&&(S[x]=o[x]);if(t&&st({instructions:[...m.instructions,...w],payer:this.feePayer,lookupTableAddressAccount:o,recentBlockhash:p})){let x=new ut({payerKey:this.feePayer,recentBlockhash:p,instructions:[...m.instructions,...w]}).compileToV0Message(Object.values(o));f.push(new ct(x))}else{let x=new ut({payerKey:this.feePayer,recentBlockhash:p,instructions:[...w]}).compileToV0Message(Object.values(o));f.push(new ct(x))}y.push(Array.from(new Set(w.map(x=>x.keys.filter(K=>K.isSigner).map(K=>K.pubkey.toString())).flat())).map(x=>d[x]).filter(x=>x!==void 0)),w=[h]}}),w.length>0){let P=[...new Set(w.map(k=>k.keys.filter(S=>S.isSigner).map(S=>S.pubkey.toString())).flat()).values()].map(k=>d[k]).filter(k=>k!==void 0);if(t&&st({instructions:[...m.instructions,...w],payer:this.feePayer,lookupTableAddressAccount:o,recentBlockhash:p})){let k=new ut({payerKey:this.feePayer,recentBlockhash:p,instructions:[...m.instructions,...w]}).compileToV0Message(Object.values(o));f.push(new ct(k))}else{let k=new ut({payerKey:this.feePayer,recentBlockhash:p,instructions:[...w]}).compileToV0Message(Object.values(o));f.push(new ct(k))}y.push(P)}return(T=this.owner)!=null&&T.signer&&y.forEach(h=>{h.some(P=>P.publicKey.equals(this.owner.publicKey))||h.push(this.owner.signer)}),f.forEach((h,P)=>{h.sign(y[P])}),{builder:this,transactions:f,buildProps:e,signers:y,blockHash:p,instructionTypes:this.instructionTypes,execute:async h=>{var B;let{sequentially:P,onTxUpdate:k,skipTxCount:S=0,recentBlockHash:x,skipPreflight:K=!0}=h||{};if(f.map(async(N,M)=>{y[M].length&&N.sign(y[M]),x&&(N.message.recentBlockhash=x)}),yt(f),(B=this.owner)!=null&&B.isKeyPair){if(P){let N=0,M=[];for(let C of f){if(++N,N<=S){console.log("skip tx: ",N),M.push("tx skipped");continue}let E=await this.connection.sendTransaction(C,{skipPreflight:K});await sn(this.connection,E),M.push(E)}return{txIds:M,signedTxs:f}}return{txIds:await Promise.all(f.map(async N=>await this.connection.sendTransaction(N,{skipPreflight:K}))),signedTxs:f}}if(this.signAllTransactions){let N=await this.signAllTransactions(f.slice(S,f.length)),M=[...f.slice(0,S),...N];if(P){let C=0,E=[],j=async()=>{if(!M[C])return;if(C<S){E.push({txId:"",status:"success",signedTx:M[C]}),k==null||k([...E]),C++,j();return}let Y=await this.connection.sendTransaction(M[C],{skipPreflight:K});E.push({txId:Y,status:"sent",signedTx:M[C]}),k==null||k([...E]),C++;let Z=!1,ae=null,Ke=null,De=fe=>{ae!==null&&clearInterval(ae),Ke!==null&&this.connection.removeSignatureListener(Ke);let ce=E.findIndex(qe=>qe.txId===Y);if(ce>-1){if(E[ce].status==="error"||E[ce].status==="success")return;E[ce].status=fe.err?"error":"success"}k==null||k([...E]),fe.err||j()};this.loopMultiTxStatus&&(ae=setInterval(async()=>{var fe;if(Z){clearInterval(ae);return}try{let ce=await this.connection.getTransaction(Y,{commitment:"confirmed",maxSupportedTransactionVersion:0});ce&&(Z=!0,clearInterval(ae),De({err:((fe=ce.meta)==null?void 0:fe.err)||null}),console.log("tx status from getTransaction:",Y))}catch(ce){Z=!0,clearInterval(ae),console.error("getTransaction timeout:",ce,Y)}},mn)),Ke=this.connection.onSignature(Y,fe=>{if(Z){this.connection.removeSignatureListener(Ke);return}Z=!0,De(fe)},"confirmed"),this.connection.getSignatureStatus(Y)};return j(),{txIds:[],signedTxs:M}}else{let C=[];for(let E=0;E<M.length;E+=1){let j=await this.connection.sendTransaction(M[E],{skipPreflight:K});C.push(j)}return{txIds:C,signedTxs:M}}}throw new Error("please provide owner in keypair format or signAllTransactions function")},extInfo:i||{}}}async buildSniperTransaction(e){var T;let A=e||{},{computeBudgetConfig:t,splitIns:n=[],lookupTableCache:r={},lookupTableAddress:s=[]}=A,i=ve(A,["computeBudgetConfig","splitIns","lookupTableCache","lookupTableAddress"]),o=F(F({},this.cluster==="devnet"?await Rn(this.connection):await cr(this.connection)),r),u=Array.from(new Set([...this.lookupTableAddress,...s])),l=[];for(let h of u)o[h]===void 0&&l.push(new Kt(h));let c=await Ln({connection:this.connection,address:l});for(let[h,P]of Object.entries(c))o[h]=P;let m=t?on(t):{instructions:[],instructionTypes:[]},p=await St(this.connection,this.blockhashCommitment),d=this.signers.reduce((h,P)=>z(F({},h),{[P.publicKey.toBase58()]:P}),{}),f=[],y=[],w=[],g=0;if(this.allInstructions.forEach(h=>{let P=[...w,h],k=t?[...m.instructions,...P]:P;if(h!==n[g]&&w.length<12&&(st({instructions:k,payer:this.feePayer,lookupTableAddressAccount:o})||st({instructions:P,payer:this.feePayer,lookupTableAddressAccount:o})))w.push(h);else{if(w.length===0)throw Error("item ins too big");g+=h===n[g]?1:0;let S={};for(let x of[...new Set(u)])o[x]!==void 0&&(S[x]=o[x]);if(t&&st({instructions:[...m.instructions,...w],payer:this.feePayer,lookupTableAddressAccount:o,recentBlockhash:p})){let x=new ut({payerKey:this.feePayer,recentBlockhash:p,instructions:[...m.instructions,...w]}).compileToV0Message(Object.values(o));f.push(new ct(x))}else{let x=new ut({payerKey:this.feePayer,recentBlockhash:p,instructions:[...w]}).compileToV0Message(Object.values(o));f.push(new ct(x))}y.push(Array.from(new Set(w.map(x=>x.keys.filter(K=>K.isSigner).map(K=>K.pubkey.toString())).flat())).map(x=>d[x]).filter(x=>x!==void 0)),w=[h]}}),w.length>0){let P=[...new Set(w.map(k=>k.keys.filter(S=>S.isSigner).map(S=>S.pubkey.toString())).flat()).values()].map(k=>d[k]).filter(k=>k!==void 0);if(t&&st({instructions:[...m.instructions,...w],payer:this.feePayer,lookupTableAddressAccount:o,recentBlockhash:p})){let k=new ut({payerKey:this.feePayer,recentBlockhash:p,instructions:[...m.instructions,...w]}).compileToV0Message(Object.values(o));f.push(new ct(k))}else{let k=new ut({payerKey:this.feePayer,recentBlockhash:p,instructions:[...w]}).compileToV0Message(Object.values(o));f.push(new ct(k))}y.push(P)}return(T=this.owner)!=null&&T.signer&&y.forEach(h=>{h.some(P=>P.publicKey.equals(this.owner.publicKey))||h.push(this.owner.signer)}),f.forEach((h,P)=>{h.sign(y[P])}),{builder:this,transactions:f,buildProps:e,signers:y,instructionTypes:this.instructionTypes,execute:async h=>{var B;let{sequentially:P,onTxUpdate:k,skipTxCount:S=0,recentBlockHash:x,skipPreflight:K=!0}=h||{};if(f.map(async(N,M)=>{y[M].length&&N.sign(y[M]),x&&(N.message.recentBlockhash=x)}),yt(f),(B=this.owner)!=null&&B.isKeyPair){if(P){let N=0,M=[];for(let C of f){if(++N,N<=S){console.log("skip tx: ",N),M.push("tx skipped");continue}let E=await this.connection.sendTransaction(C,{skipPreflight:K});await sn(this.connection,E),M.push(E)}return{txIds:M,signedTxs:f}}return{txIds:await Promise.all(f.map(async N=>await this.connection.sendTransaction(N,{skipPreflight:K}))),signedTxs:f}}if(this.signAllTransactions){let N=await this.signAllTransactions(f.slice(S,f.length)),M=[...f.slice(0,S),...N];if(P){let C=0,E=[],j=async()=>{if(!M[C])return;if(C<S){E.push({txId:"",status:"success",signedTx:M[C]}),k==null||k([...E]),C++,j();return}let Y=await this.connection.sendTransaction(M[C],{skipPreflight:K});E.push({txId:Y,status:"sent",signedTx:M[C]}),k==null||k([...E]),C++;let Z=!1,ae=null,Ke=null,De=fe=>{ae!==null&&clearInterval(ae),Ke!==null&&this.connection.removeSignatureListener(Ke);let ce=E.findIndex(qe=>qe.txId===Y);if(ce>-1){if(E[ce].status==="error"||E[ce].status==="success")return;E[ce].status=fe.err?"error":"success"}k==null||k([...E]),fe.err||j()};this.loopMultiTxStatus&&(ae=setInterval(async()=>{var fe;if(Z){clearInterval(ae);return}try{let ce=await this.connection.getTransaction(Y,{commitment:"confirmed",maxSupportedTransactionVersion:0});ce&&(Z=!0,clearInterval(ae),De({err:((fe=ce.meta)==null?void 0:fe.err)||null}),console.log("tx status from getTransaction:",Y))}catch(ce){Z=!0,clearInterval(ae),console.error("getTransaction timeout:",ce,Y)}},mn)),Ke=this.connection.onSignature(Y,fe=>{if(Z){this.connection.removeSignatureListener(Ke);return}Z=!0,De(fe)},"confirmed"),this.connection.getSignatureStatus(Y)};return j(),{txIds:[],signedTxs:M}}else{let C=[];for(let E=0;E<M.length;E+=1){let j=await this.connection.sendTransaction(M[E],{skipPreflight:K});C.push(j)}return{txIds:C,signedTxs:M}}}throw new Error("please provide owner in keypair format or signAllTransactions function")},extInfo:i||{}}}};import{PublicKey as ms}from"@solana/web3.js";import ds from"bn.js";function ps(a){return typeof a=="object"&&a!==null&&![Re,we,ms,ne,ds,Xe,Ue].some(e=>typeof e=="object"&&a instanceof e)}function Lt(a){return typeof a=="string"?tr(a):Array.isArray(a)?a.map(e=>Lt(e)):ps(a)?Object.fromEntries(Object.entries(a).map(([e,t])=>[e,Lt(t)])):a}import fs from"bn.js";var Hl=new fs(1e6);import{MINT_SIZE as hm,TOKEN_PROGRAM_ID as Tm,getTransferFeeConfig as xm,unpackMint as Sm}from"@solana/spl-token";var mr=ie("Raydium_accountInfo_util");async function at(a,e,t){let{batchRequest:n,commitment:r="confirmed",chunkCount:s=100}=F({batchRequest:!1},t),i=ar(e,s),o=new Array(i.length).fill([]);if(n){let u=i.map(m=>{let p=a._buildArgs([m.map(d=>d.toBase58())],r,"base64");return{methodName:"getMultipleAccounts",args:p}}),l=ar(u,10);o=(await(await Promise.all(l.map(async m=>await a._rpcBatchRequest(m)))).flat()).map(m=>(m.error&&mr.logWithError(`failed to get info for multiple accounts, RPC_ERROR, ${m.error.message}`),m.result.value.map(p=>{if(p){let{data:d,executable:f,lamports:y,owner:w,rentEpoch:g}=p;return d.length!==2&&d[1]!=="base64"&&mr.logWithError("info must be base64 encoded, RPC_ERROR"),{data:Buffer.from(d[0],"base64"),executable:f,lamports:y,owner:new bs(w),rentEpoch:g}}return null})))}else try{o=await Promise.all(i.map(u=>a.getMultipleAccountsInfo(u,r)))}catch(u){u instanceof Error&&mr.logWithError(`failed to get info for multiple accounts, RPC_ERROR, ${u.message}`)}return o.flat()}async function Rt(a,e,t){let n=await at(a,e.map(r=>r.pubkey),t);return e.map((r,s)=>z(F({},r),{accountInfo:n[s]}))}import{PublicKey as Bs}from"@solana/web3.js";import Ki,{isBN as Li}from"bn.js";import{bits as ys,BitStructure as Km,blob as gs,Blob as Lm,cstr as Rm,f32 as Cm,f32be as Nm,f64 as Mm,f64be as _m,greedy as Vm,Layout as ws,ns64 as vm,ns64be as Em,nu64 as Wm,nu64be as Om,offset as Fm,s16 as Dm,s16be as qm,s24 as Gm,s24be as Um,s32 as ks,s32be as Xm,s40 as zm,s40be as Qm,s48 as Hm,s48be as Ym,s8 as jm,seq as Ps,struct as Zm,Structure as As,u16 as hs,u16be as $m,u24 as Jm,u24be as ed,u32 as Ts,u32be as td,u40 as nd,u40be as rd,u48 as id,u48be as od,u8 as xs,UInt as Ss,union as sd,Union as ad,unionLayoutDiscriminator as ud,utf8 as cd}from"@solana/buffer-layout";var Cn=ws,Si=As;var dr=Ss;var Bi=xs,Ct=hs;var pr=Ts;var le=ks;var Ii=Ps;var he=gs;var fr=ys;var Nt=class extends Cn{constructor(t,n,r){super(t,r);this.blob=he(t),this.signed=n}decode(t,n=0){let r=new Ki(this.blob.decode(t,n),10,"le");return this.signed?r.fromTwos(this.span*8).clone():r}encode(t,n,r=0){return typeof t=="number"&&(t=new Ki(t)),this.signed&&(t=t.toTwos(this.span*8)),this.blob.encode(t.toArrayLike(Buffer,"le",this.span),n,r)}},Nn=class extends Cn{constructor(t){super(8,t);this._lower=fr(pr(),!1),this._upper=fr(pr(),!1)}addBoolean(t){this._lower.fields.length<32?this._lower.addBoolean(t):this._upper.addBoolean(t)}decode(t,n=0){let r=this._lower.decode(t,n),s=this._upper.decode(t,n+this._lower.span);return F(F({},r),s)}encode(t,n,r=0){return this._lower.encode(t,n,r)+this._upper.encode(t,n,r+this._lower.span)}};function W(a){return new dr(1,a)}function Ce(a){return new dr(4,a)}function b(a){return new Nt(8,!1,a)}function q(a){return new Nt(16,!1,a)}function Ri(a){return new Nt(1,!0,a)}function Ht(a){return new Nt(8,!0,a)}function Ci(a){return new Nt(16,!0,a)}var Mn=class extends Cn{constructor(t,n,r,s){super(t.span,s);this.layout=t,this.decoder=n,this.encoder=r}decode(t,n){return this.decoder(this.layout.decode(t,n))}encode(t,n,r){return this.layout.encode(this.encoder(t),n,r)}getSpan(t,n){return this.layout.getSpan(t,n)}};function L(a){return new Mn(he(32),e=>new Bs(e),e=>e.toBuffer(),a)}function Te(a){return new Mn(Bi(),Is,Ks,a)}function Is(a){if(a===0)return!1;if(a===1)return!0;throw new Error("Invalid bool: "+a)}function Ks(a){return a?1:0}var br=class extends Si{decode(e,t){return super.decode(e,t)}};function _(a,e,t){return new br(a,e,t)}function G(a,e,t){let n,r=typeof e=="number"?e:Li(e)?e.toNumber():new Proxy(e,{get(s,i){if(!n){let o=Reflect.get(s,"count");n=Li(o)?o.toNumber():o,Reflect.set(s,"count",n)}return Reflect.get(s,i)},set(s,i,o){return i==="count"&&(n=o),Reflect.set(s,i,o)}});return Ii(a,r,t)}import{PublicKey as yr}from"@solana/web3.js";import{NATIVE_MINT as Id}from"@solana/spl-token";var Kd=ie("Raydium_farm_config"),Ld=new yr("4k3Dyjzvzp8eMZWUXbBCjEvwSkkk59S5iCNLY3QrkX6R"),Rd=new yr("FrspKwj8i3pNmKwXreTveC4fu7KL5ZbGeXdZBe2XViu1");var Cd=new yr("3TRTX4dXUpp2eqxi3tvQDFYUV7SdDJjcPE3Y4mbtftaX");var Ni={3:wr,5:Mi,6:_i};var _n={"Standard SPL":0,"Option tokens":1},gr={[gi.toString()]:3,[wi.toString()]:4,[ki.toString()]:5,[Pi.toString()]:6,[It.FARM_PROGRAM_ID_V3.toString()]:3,[It.FARM_PROGRAM_ID_V4.toString()]:4,[It.FARM_PROGRAM_ID_V5.toString()]:5,[It.FARM_PROGRAM_ID_V6.toString()]:6};var kr=_([W("instruction")]),Ns=_([W("instruction")]),Ms=_([b("rewardState"),b("rewardOpenTime"),b("rewardEndTime"),b("rewardLastUpdateTime"),b("totalReward"),b("totalRewardEmissioned"),b("rewardClaimed"),b("rewardPerSecond"),q("accRewardPerShare"),L("rewardVault"),L("rewardMint"),L("rewardSender"),b("rewardType"),G(b(),15,"padding")]),_s=_([b("state"),b("nonce"),L("lpVault"),L("rewardVault"),L(),L(),b(),b(),b("totalReward"),q("perShareReward"),b("lastSlot"),b("perSlotReward")]),Vs=_([b("state"),b("nonce"),L("lpVault"),L("rewardVaultA"),b("totalRewardA"),q("perShareRewardA"),b("perSlotRewardA"),W("option"),L("rewardVaultB"),he(7),b("totalRewardB"),q("perShareRewardB"),b("perSlotRewardB"),b("lastSlot"),L()]),vs=_([b(),b("state"),b("nonce"),b("validRewardTokenNum"),q("rewardMultiplier"),b("rewardPeriodMax"),b("rewardPeriodMin"),b("rewardPeriodExtend"),L("lpMint"),L("lpVault"),G(Ms,5,"rewardInfos"),L("creator"),L(),G(b(),32,"padding")]),Ls=new Proxy(_s,{get(a,e,t){return e==="decode"?(...n)=>{let r=a.decode(...n);return z(F({},r),{version:3,rewardInfos:[{rewardVault:r.rewardVault,totalReward:r.totalReward,perSlotReward:r.perSlotReward,perShareReward:r.perShareReward}]})}:Reflect.get(a,e,t)}}),Rs=new Proxy(Vs,{get(a,e,t){return e==="decode"?(...n)=>{let r=a.decode(...n);return z(F({},r),{version:5,rewardInfos:[{rewardVault:r.rewardVaultA,totalReward:r.totalRewardA,perSlotReward:r.perSlotRewardA,perShareReward:r.perShareRewardA},{rewardVault:r.rewardVaultB,totalReward:r.totalRewardB,perSlotReward:r.perSlotRewardB,perShareReward:r.perShareRewardB}]})}:Reflect.get(a,e,t)}}),Cs=new Proxy(vs,{get(a,e,t){return e==="decode"?(...n)=>{let r=a.decode(...n);return z(F({},r),{version:6,rewardInfos:r.rewardInfos.map(s=>{var i;return z(F({},s),{rewardType:((i=Object.entries(_n).find(o=>String(o[1])===s.rewardType.toString()))!=null?i:["Standard SPL"])[0]})})})}:Reflect.get(a,e,t)}}),Es=_([b("isSet"),b("rewardPerSecond"),b("rewardOpenTime"),b("rewardEndTime"),b("rewardType")]),Ws=_([W("instruction"),b("nonce"),G(Es,5,"rewardTimeInfo")]),Os=_([W("instruction"),b("rewardReopenTime"),b("rewardEndTime"),b("rewardPerSecond")]),Fs=_([W("instruction"),b("isSet"),b("rewardPerSecond"),b("rewardOpenTime"),b("rewardEndTime"),b("rewardType")]),Wd=_([b("state"),L("id"),L("owner"),b("deposited"),G(b(),1,"rewardDebts")]),wr=_([b("state"),L("id"),L("owner"),b("deposited"),G(q(),1,"rewardDebts"),b(""),b("voteLockedBalance"),G(b(),15)]),Od=_([b("state"),L("id"),L("owner"),b("deposited"),G(b(),2,"rewardDebts")]),Mi=_([b("state"),L("id"),L("owner"),b("deposited"),G(q(),2,"rewardDebts"),G(b(),17)]),_i=_([b(),b("state"),L("id"),L("owner"),b("deposited"),G(q(),5,"rewardDebts"),G(b(),16)]),Mt=_([W("instruction"),b("amount")]),Ds=_([L("mint"),L("grantAuthority"),b("baselineVoteWeightScaledFactor"),b("maxExtraLockupVoteWeightScaledFactor"),b("lockupSaturationSecs"),Ri("digitShift"),G(W(),7,"reserved1"),G(b(),7,"reserved2")]),qs=_([he(8),L("governanceProgramId"),L("realm"),L("realmGoverningTokenMint"),L("realmAuthority"),G(W(),32,"reserved1"),G(Ds,4,"votingMints"),Ht("timeOffset"),W("bump"),G(W(),7,"reserved2"),G(b(),11,"reserved3")]),Gs=_([Ht("startTime"),Ht("endTime"),W("kind"),G(W(),15,"reserved")]),Us=_([G(Gs,1,"lockup"),b("amountDeposited_native"),b("amountInitiallyLockedNative"),Te("isUsed"),Te("allowClawback"),W("votingMintConfigIdx"),G(W(),29,"reserved")]),Xs=_([he(8),L("voterAuthority"),L("registrar"),G(Us,32,"deposits"),W("voterBump"),W("voterWweightRecordBump"),G(W(),94,"reserved")]);import Qd from"bn.js";var Vn=_([L("mint"),L("owner"),b("amount"),Ce("delegateOption"),L("delegate"),W("state"),Ce("isNativeOption"),b("isNative"),b("delegatedAmount"),Ce("closeAuthorityOption"),L("closeAuthority")]);var zs=ie("Raydium.farm.util");function Yt({programId:a,poolId:e,owner:t,version:n}){let{publicKey:r}=be([e.toBuffer(),t.toBuffer(),Buffer.from(n===6?"farmer_info_associated_seed":"staker_info_v2_associated_seed","utf-8")],a);return r}function Vi(a){let e=Ni[a];return e||zs.logWithError("invalid version",a),e}import{PublicKey as Ne,SystemProgram as Qs,SYSVAR_CLOCK_PUBKEY as vi,SYSVAR_RENT_PUBKEY as Hs,TransactionInstruction as vn}from"@solana/web3.js";import kp from"bn.js";import{ASSOCIATED_TOKEN_PROGRAM_ID as Ap,createAssociatedTokenAccountIdempotentInstruction as hp,TOKEN_PROGRAM_ID as Pr}from"@solana/spl-token";var Ys=ie("Raydium_farm_instruction"),Mp={voterStakeRegistryCreateVoter:Buffer.from([6,24,245,52,243,255,148,25]),voterStakeRegistryCreateDepositEntry:Buffer.from([185,131,167,186,159,125,19,67]),voterStakeRegistryDeposit:Buffer.from([242,35,198,137,82,225,242,182]),voterStakeRegistryWithdraw:Buffer.from([183,18,70,156,148,109,161,34]),voterStakeRegistryUpdateVoterWeightRecord:Buffer.from([45,185,3,36,109,190,115,169])};function Ei(a){let{version:e,id:t,ledger:n,programId:r,owner:s}=a,i={3:9,5:10}[e];i||Ys.logWithError(`invalid farm pool version: ${e}`);let o=Buffer.alloc(kr.span);kr.encode({instruction:i},o);let u=[I({pubkey:t}),I({pubkey:n}),I({pubkey:s,isWritable:!1}),I({pubkey:Qs.programId,isWritable:!1}),I({pubkey:Hs,isWritable:!1})];return{instruction:new vn({programId:r,keys:u,data:o}),instructionType:U.FarmV3CreateLedger}}function Wi(a){let{farmInfo:e,farmKeys:t,lpAccount:n,rewardAccounts:r,owner:s,amount:i}=a,[o,u]=[new Ne(e.programId),new Ne(e.id)],l=Yt({programId:o,poolId:u,owner:s,version:6}),c=Buffer.alloc(Mt.span);Mt.encode({instruction:2,amount:$(i)},c);let m=[I({pubkey:Pr,isWritable:!1}),I({pubkey:u}),I({pubkey:new Ne(t.authority),isWritable:!1}),I({pubkey:new Ne(t.lpVault)}),I({pubkey:l}),I({pubkey:s,isWritable:!1,isSigner:!0}),I({pubkey:n})];for(let p=0;p<t.rewardInfos.length;p++)m.push(I({pubkey:new Ne(t.rewardInfos[p].vault)})),m.push(I({pubkey:r[p]}));return new vn({programId:o,keys:m,data:c})}function Oi(a){let{farmInfo:e,farmKeys:t,lpAccount:n,rewardAccounts:r,owner:s,amount:i,userAuxiliaryLedgers:o}=a,[u,l]=[new Ne(e.programId),new Ne(e.id)],c=Yt({programId:u,poolId:l,owner:s,version:5}),m=Buffer.alloc(Mt.span);Mt.encode({instruction:12,amount:$(i)},m);let p=[I({pubkey:l}),I({pubkey:new Ne(t.authority),isWritable:!1}),I({pubkey:c}),I({pubkey:s,isWritable:!1,isSigner:!0}),I({pubkey:n}),I({pubkey:new Ne(t.lpVault)}),I({pubkey:r[0]}),I({pubkey:new Ne(t.rewardInfos[0].vault)}),I({pubkey:vi,isWritable:!1}),I({pubkey:Pr,isWritable:!1})];for(let d=1;d<t.rewardInfos.length;d++)p.push(I({pubkey:r[d]})),p.push(I({pubkey:new Ne(t.rewardInfos[d].vault)}));if(o)for(let d of o)p.push(I({pubkey:d}));return new vn({programId:u,keys:p,data:m})}function Fi(a){let{farmInfo:e,farmKeys:t,lpAccount:n,rewardAccounts:r,owner:s,amount:i,userAuxiliaryLedgers:o}=a,[u,l]=[new Ne(e.programId),new Ne(e.id)],c=Yt({programId:u,poolId:l,owner:s,version:3}),m=Buffer.alloc(Mt.span);Mt.encode({instruction:11,amount:$(i)},m);let p=[I({pubkey:l}),I({pubkey:new Ne(t.authority),isWritable:!1}),I({pubkey:c}),I({pubkey:s,isWritable:!1,isSigner:!0}),I({pubkey:n}),I({pubkey:new Ne(t.lpVault)}),I({pubkey:r[0]}),I({pubkey:new Ne(t.rewardInfos[0].vault)}),I({pubkey:vi,isWritable:!1}),I({pubkey:Pr,isWritable:!1})];if(o)for(let d of o)p.push(I({pubkey:d}));return new vn({programId:u,keys:p,data:m})}import{Keypair as Fn,PublicKey as R,SystemProgram as dt,TransactionInstruction as Ie}from"@solana/web3.js";import Rr from"bn.js";import{ASSOCIATED_TOKEN_PROGRAM_ID as kn,TOKEN_2022_PROGRAM_ID as ye,TOKEN_PROGRAM_ID as oe}from"@solana/spl-token";import oa from"bn.js";import jt from"decimal.js";import ze from"bn.js";var pe=new ze(0),$e=new ze(1),lt=new ze(-1),Ee=new ze(1).shln(64),En=new ze(1).shln(128),Ar=Ee.sub($e),pn=64,Di=En.subn(1),Me=-443636,_e=-Me,_t=new ze("4295048016"),Vt=new ze("79226673521066979257578248091"),Gp=new ze("4295048017"),Up=new ze("79226673521066979257578248090"),qi=16,Gi="59543866431248",Ui="184467440737095516",Xi="15793534762490258745",Wn=new ze(10).pow(new ze(6));var Xp=new ze("18446744073700000000");import H from"bn.js";import et from"decimal.js";function On(a){let e=new ArrayBuffer(4);return new DataView(e).setInt32(0,a,!1),new Uint8Array(e)}function hr(a,e){let t=0;for(let n=a-1;n>=0&&!e.testn(n);n--)t++;return t}function Tr(a,e){let t=0;for(let n=0;n<a&&!e.testn(n);n++)t++;return t}function fn(a,e){for(let t=0;t<a;t++)if(e.testn(t))return!1;return!0}function zi(a,e){return fn(a,e)?null:hr(a,e)}function Qi(a,e){return fn(a,e)?null:Tr(a,e)}var Zp=Buffer.from("amm_config","utf8"),js=Buffer.from("pool","utf8"),Zs=Buffer.from("pool_vault","utf8"),$s=Buffer.from("pool_reward_vault","utf8"),Hi=Buffer.from("position","utf8"),Js=Buffer.from("tick_array","utf8"),ea=Buffer.from("operation","utf8"),ta=Buffer.from("pool_tick_array_bitmap_extension","utf8"),na=Buffer.from("observation","utf8");function Yi(a,e,t,n){return be([js,e.toBuffer(),t.toBuffer(),n.toBuffer()],a)}function xr(a,e,t){return be([Zs,e.toBuffer(),t.toBuffer()],a)}function ji(a,e,t){return be([$s,e.toBuffer(),t.toBuffer()],a)}function re(a,e,t){return be([Js,e.toBuffer(),On(t)],a)}function kt(a,e,t,n){return be([Hi,e.toBuffer(),On(t),On(n)],a)}function We(a,e){return be([Hi,e.toBuffer()],a)}function bn(a){return be([Buffer.from("metadata","utf8"),xt.toBuffer(),a.toBuffer()],xt)}function Sr(a){return be([ea],a)}function Be(a,e){return be([ta,e.toBuffer()],a)}function Zi(a,e){return be([na,e.toBuffer()],a)}var $i=Buffer.from("locked_position","utf8");function Br(a,e){return be([$i,e.toBuffer()],a)}function Ji(a,e){return be([$i,e.toBuffer()],a)}var $p=Buffer.from("support_mint","utf8");import{PublicKey as Oe}from"@solana/web3.js";import{TOKEN_2022_PROGRAM_ID as eo}from"@solana/spl-token";import me from"bn.js";import ee from"decimal.js";import Je from"bn.js";import Ir from"decimal.js";var yn=class{static getfeeGrowthInside(e,t,n){let r=new Je(0),s=new Je(0);e.tickCurrent>=t.tick?(r=t.feeGrowthOutsideX64A,s=t.feeGrowthOutsideX64B):(r=e.feeGrowthGlobalX64A.sub(t.feeGrowthOutsideX64A),s=e.feeGrowthGlobalX64B.sub(t.feeGrowthOutsideX64B));let i=new Je(0),o=new Je(0);e.tickCurrent<n.tick?(i=n.feeGrowthOutsideX64A,o=n.feeGrowthOutsideX64B):(i=e.feeGrowthGlobalX64A.sub(n.feeGrowthOutsideX64A),o=e.feeGrowthGlobalX64B.sub(n.feeGrowthOutsideX64B));let u=Q.wrappingSubU128(Q.wrappingSubU128(e.feeGrowthGlobalX64A,r),i),l=Q.wrappingSubU128(Q.wrappingSubU128(e.feeGrowthGlobalX64B,s),o);return{feeGrowthInsideX64A:u,feeGrowthInsideBX64:l}}static GetPositionFees(e,t,n,r){let{feeGrowthInsideX64A:s,feeGrowthInsideBX64:i}=this.getfeeGrowthInside(e,n,r),o=Q.mulDivFloor(Q.wrappingSubU128(s,t.feeGrowthInsideLastX64A),t.liquidity,Ee),u=t.tokenFeesOwedA.add(o),l=Q.mulDivFloor(Q.wrappingSubU128(i,t.feeGrowthInsideLastX64B),t.liquidity,Ee),c=t.tokenFeesOwedB.add(l);return{tokenFeeAmountA:u,tokenFeeAmountB:c}}static GetPositionFeesV2(e,t,n,r){let{feeGrowthInsideX64A:s,feeGrowthInsideBX64:i}=this.getfeeGrowthInside(e,n,r),o=Q.mulDivFloor(Q.wrappingSubU128(s,t.feeGrowthInsideLastX64A),t.liquidity,Ee),u=t.tokenFeesOwedA.add(o),l=Q.mulDivFloor(Q.wrappingSubU128(i,t.feeGrowthInsideLastX64B),t.liquidity,Ee),c=t.tokenFeesOwedB.add(l);return{tokenFeeAmountA:u,tokenFeeAmountB:c}}static GetPositionRewardsV2(e,t,n,r){let s=[],i=this.getRewardGrowthInsideV2(e.tickCurrent,n,r,e.rewardInfos);for(let o=0;o<i.length;o++){let u=i[o],l=t.rewardInfos[o],c=Q.wrappingSubU128(u,l.growthInsideLastX64),m=Q.mulDivFloor(c,t.liquidity,Ee),p=l.rewardAmountOwed.add(m);s.push(p)}return s}static GetPositionRewards(e,t,n,r){let s=[],i=this.getRewardGrowthInside(e.tickCurrent,n,r,e.rewardInfos);for(let o=0;o<i.length;o++){let u=i[o],l=t.rewardInfos[o],c=Q.wrappingSubU128(u,l.growthInsideLastX64),m=Q.mulDivFloor(c,t.liquidity,Ee),p=l.rewardAmountOwed.add(m);s.push(p)}return s}static getRewardGrowthInside(e,t,n,r){let s=[];for(let i=0;i<r.length;i++){let o=new Je(0);t.liquidityGross.eqn(0)?o=r[i].rewardGrowthGlobalX64:e<t.tick?o=r[i].rewardGrowthGlobalX64.sub(t.rewardGrowthsOutsideX64[i]):o=t.rewardGrowthsOutsideX64[i];let u=new Je(0);n.liquidityGross.eqn(0)||(e<n.tick?u=n.rewardGrowthsOutsideX64[i]:u=r[i].rewardGrowthGlobalX64.sub(n.rewardGrowthsOutsideX64[i])),s.push(Q.wrappingSubU128(Q.wrappingSubU128(r[i].rewardGrowthGlobalX64,o),u))}return s}static getRewardGrowthInsideV2(e,t,n,r){let s=[];for(let i=0;i<r.length;i++){let o=new Je(0);t.liquidityGross.eqn(0)?o=r[i].rewardGrowthGlobalX64:e<t.tick?o=r[i].rewardGrowthGlobalX64.sub(t.rewardGrowthsOutsideX64[i]):o=t.rewardGrowthsOutsideX64[i];let u=new Je(0);n.liquidityGross.eqn(0)||(e<n.tick?u=n.rewardGrowthsOutsideX64[i]:u=r[i].rewardGrowthGlobalX64.sub(n.rewardGrowthsOutsideX64[i])),s.push(Q.wrappingSubU128(Q.wrappingSubU128(r[i].rewardGrowthGlobalX64,o),u))}return s}static getAmountsFromLiquidity({poolInfo:e,ownerPosition:t,liquidity:n,slippage:r,add:s,epochInfo:i}){var w,g,A,T;let o=X.priceToSqrtPriceX64(new Ir(e.price),e.mintA.decimals,e.mintB.decimals),u=X.getSqrtPriceX64FromTick(t.tickLower),l=X.getSqrtPriceX64FromTick(t.tickUpper),c=s?1+r:1-r,m=te.getAmountsFromLiquidity(o,u,l,n,s),[p,d]=[ke(m.amountA,(w=e.mintA.extensions)==null?void 0:w.feeConfig,i,!0),ke(m.amountB,(g=e.mintB.extensions)==null?void 0:g.feeConfig,i,!0)],[f,y]=[ke(new Je(new Ir(m.amountA.toString()).mul(c).toFixed(0)),(A=e.mintA.extensions)==null?void 0:A.feeConfig,i,!0),ke(new Je(new Ir(m.amountB.toString()).mul(c).toFixed(0)),(T=e.mintB.extensions)==null?void 0:T.feeConfig,i,!0)];return{liquidity:n,amountA:p,amountB:d,amountSlippageA:f,amountSlippageB:y,expirationTime:gt(p.expirationTime,d.expirationTime)}}};var ra=15,J=class{static async getTickArrays(e,t,n,r,s,i,o){let u=[],l=O.getTickArrayStartIndexByTick(r,s),c=O.getInitializedTickArrayInRange(i,o,s,l,Math.floor(ra/2));for(let d=0;d<c.length;d++){let{publicKey:f}=re(t,n,c[d]);u.push(f)}let m=(await at(e,u)).map(d=>d!==null?gn.decode(d.data):null),p={};for(let d=0;d<u.length;d++){let f=m[d];f!==null&&(p[f.startTickIndex]=z(F({},f),{address:u[d]}))}return p}static nextInitializedTick(e,t,n,r,s,i){let{initializedTick:o,tickArrayAddress:u,tickArrayStartTickIndex:l}=this.nextInitializedTickInOneArray(e,t,n,r,s,i);for(;o==null||o.liquidityGross.lten(0);){if(l=O.getNextTickArrayStartIndex(l,s,i),this.checkIsValidStartIndex(l,s))throw new Error("No enough initialized tickArray");let c=n[l];if(c===void 0)continue;let{nextTick:m,tickArrayAddress:p,tickArrayStartTickIndex:d}=this.firstInitializedTickInOneArray(e,t,c,i);[o,u,l]=[m,p,d]}if(o==null)throw new Error("No invaild tickArray cache");return{nextTick:o,tickArrayAddress:u,tickArrayStartTickIndex:l}}static nextInitializedTickArray(e,t,n,r,s){let i=Math.floor(e/J.tickCount(t)),o=n?O.searchLowBitFromStart(r,s,i-1,1,t):O.searchHightBitFromStart(r,s,i+1,1,t);return o.length>0?{isExist:!0,nextStartIndex:o[0]}:{isExist:!1,nextStartIndex:0}}static firstInitializedTickInOneArray(e,t,n,r){let s;if(r){let o=xe-1;for(;o>=0;){let u=n.ticks[o];if(u.liquidityGross.gtn(0)){s=u;break}o=o-1}}else{let o=0;for(;o<xe;){let u=n.ticks[o];if(u.liquidityGross.gtn(0)){s=u;break}o=o+1}}let{publicKey:i}=re(e,t,n.startTickIndex);return{nextTick:s,tickArrayAddress:i,tickArrayStartTickIndex:n.startTickIndex}}static nextInitializedTickInOneArray(e,t,n,r,s,i){let o=O.getTickArrayStartIndexByTick(r,s),u=Math.floor((r-o)/s),l=n[o];if(l==null)return{initializedTick:void 0,tickArrayAddress:void 0,tickArrayStartTickIndex:o};let c;if(i)for(;u>=0;){let p=l.ticks[u];if(p.liquidityGross.gtn(0)){c=p;break}u=u-1}else for(u=u+1;u<xe;){let p=l.ticks[u];if(p.liquidityGross.gtn(0)){c=p;break}u=u+1}let{publicKey:m}=re(e,t,o);return{initializedTick:c,tickArrayAddress:m,tickArrayStartTickIndex:l.startTickIndex}}static getArrayStartIndex(e,t){let n=this.tickCount(t);return Math.floor(e/n)*n}static checkIsValidStartIndex(e,t){if(O.checkIsOutOfBoundary(e)){if(e>_e)return!1;let n=O.getTickArrayStartIndexByTick(Me,t);return e==n}return e%this.tickCount(t)==0}static tickCount(e){return xe*e}};var Kr=14,mt=class{static maxTickInTickarrayBitmap(e){return e*xe*vt}static getBitmapTickBoundary(e,t){let n=this.maxTickInTickarrayBitmap(t),r=Math.floor(Math.abs(e)/n);e<0&&Math.abs(e)%n!=0&&(r+=1);let s=n*r;return e<0?{minValue:-s,maxValue:-s+n}:{minValue:s,maxValue:s+n}}static nextInitializedTickArrayStartIndex(e,t,n,r){if(!J.checkIsValidStartIndex(t,n))throw Error("nextInitializedTickArrayStartIndex check error");let s=this.maxTickInTickarrayBitmap(n),i=r?t-J.tickCount(n):t+J.tickCount(n);if(i<-s||i>=s)return{isInit:!1,tickIndex:t};let o=n*xe,u=i/o+512;i<0&&i%o!=0&&u--;let l=Math.abs(u);if(r){let c=e.shln(1024-l-1),m=zi(1024,c);if(m!==null){let p=(l-m-512)*o;return{isInit:!0,tickIndex:p}}else return{isInit:!1,tickIndex:-s}}else{let c=e.shrn(l),m=Qi(1024,c);if(m!==null){let p=(l+m-512)*o;return{isInit:!0,tickIndex:p}}else return{isInit:!1,tickIndex:s-J.tickCount(n)}}}},wn=class{static getBitmapOffset(e,t){if(!J.checkIsValidStartIndex(e,t))throw new Error("No enough initialized tickArray");this.checkExtensionBoundary(e,t);let n=mt.maxTickInTickarrayBitmap(t),r=Math.floor(Math.abs(e)/n)-1;return e<0&&Math.abs(e)%n===0&&r--,r}static getBitmap(e,t,n){let r=this.getBitmapOffset(e,t);return e<0?{offset:r,tickarrayBitmap:n.negativeTickArrayBitmap[r]}:{offset:r,tickarrayBitmap:n.positiveTickArrayBitmap[r]}}static checkExtensionBoundary(e,t){let{positiveTickBoundary:n,negativeTickBoundary:r}=this.extensionTickBoundary(t);if(e>=r&&e<n)throw Error("checkExtensionBoundary -> InvalidTickArrayBoundary")}static extensionTickBoundary(e){let t=mt.maxTickInTickarrayBitmap(e),n=-t;if(_e<=t)throw Error(`extensionTickBoundary check error: ${_e}, ${t}`);if(n<=Me)throw Error(`extensionTickBoundary check error: ${n}, ${Me}`);return{positiveTickBoundary:t,negativeTickBoundary:n}}static checkTickArrayIsInit(e,t,n){let{tickarrayBitmap:r}=this.getBitmap(e,t,n),s=this.tickArrayOffsetInBitmap(e,t);return{isInitialized:O.mergeTickArrayBitmap(r).testn(s),startIndex:e}}static nextInitializedTickArrayFromOneBitmap(e,t,n,r){let s=J.tickCount(t),i=n?e-s:e+s,{tickarrayBitmap:o}=this.getBitmap(i,t,r);return this.nextInitializedTickArrayInBitmap(o,i,t,n)}static nextInitializedTickArrayInBitmap(e,t,n,r){let{minValue:s,maxValue:i}=mt.getBitmapTickBoundary(t,n),o=this.tickArrayOffsetInBitmap(t,n);if(r){let u=O.mergeTickArrayBitmap(e).shln(vt-1-o),l=fn(512,u)?null:hr(512,u);if(l!==null){let c=t-l*J.tickCount(n);return{isInit:!0,tickIndex:c}}else return{isInit:!1,tickIndex:s}}else{let u=O.mergeTickArrayBitmap(e).shrn(o),l=fn(512,u)?null:Tr(512,u);if(l!==null){let c=t+l*J.tickCount(n);return{isInit:!0,tickIndex:c}}else return{isInit:!1,tickIndex:i-J.tickCount(n)}}}static tickArrayOffsetInBitmap(e,t){let n=Math.abs(e)%mt.maxTickInTickarrayBitmap(t),r=Math.floor(n/J.tickCount(t));return e<0&&n!=0&&(r=vt-r),r}};var Pe=class{static getOutputAmountAndRemainAccounts(e,t,n,r,s,i=!1){let o=n.toBase58()===e.mintA.address,u=[],{isExist:l,startIndex:c,nextAccountMeta:m}=this.getFirstInitializedTickArray(e,o);if(!l||c===void 0||!m)throw new Error("Invalid tick array");u.push(m);let{allTrade:p,amountCalculated:d,accounts:f,sqrtPriceX64:y,feeAmount:w}=Et.swapCompute(e.programId,e.id,t,e.tickArrayBitmap,e.exBitmapInfo,o,e.ammConfig.tradeFeeRate,e.liquidity,e.tickCurrent,e.tickSpacing,e.sqrtPriceX64,r,c,s,i);return u.push(...f),{allTrade:p,expectedAmountOut:d.mul(lt),remainingAccounts:u,executionPrice:y,feeAmount:w}}static getInputAmountAndRemainAccounts(e,t,n,r,s){let i=n.toBase58()===e.mintB.address,o=[],{isExist:u,startIndex:l,nextAccountMeta:c}=this.getFirstInitializedTickArray(e,i);if(!u||l===void 0||!c)throw new Error("Invalid tick array");try{let y=this.preInitializedTickArrayStartIndex(e,i);if(y.isExist){let{publicKey:w}=re(e.programId,e.id,y.nextStartIndex);o.push(w)}}catch{}o.push(c);let{amountCalculated:m,accounts:p,sqrtPriceX64:d,feeAmount:f}=Et.swapCompute(e.programId,e.id,t,e.tickArrayBitmap,e.exBitmapInfo,i,e.ammConfig.tradeFeeRate,e.liquidity,e.tickCurrent,e.tickSpacing,e.sqrtPriceX64,r.mul(lt),l,s);return o.push(...p),{expectedAmountIn:m,remainingAccounts:o,executionPrice:d,feeAmount:f}}static getFirstInitializedTickArray(e,t){let{isInitialized:n,startIndex:r}=Pe.isOverflowDefaultTickarrayBitmap(e.tickSpacing,[e.tickCurrent])?wn.checkTickArrayIsInit(J.getArrayStartIndex(e.tickCurrent,e.tickSpacing),e.tickSpacing,e.exBitmapInfo):O.checkTickArrayIsInitialized(O.mergeTickArrayBitmap(e.tickArrayBitmap),e.tickCurrent,e.tickSpacing);if(n){let{publicKey:o}=re(e.programId,e.id,r);return{isExist:!0,startIndex:r,nextAccountMeta:o}}let{isExist:s,nextStartIndex:i}=this.nextInitializedTickArrayStartIndex(e,J.getArrayStartIndex(e.tickCurrent,e.tickSpacing),t);if(s){let{publicKey:o}=re(e.programId,e.id,i);return{isExist:!0,startIndex:i,nextAccountMeta:o}}return{isExist:!1,nextAccountMeta:void 0,startIndex:void 0}}static preInitializedTickArrayStartIndex(e,t){let n=Math.floor(e.tickCurrent/J.tickCount(e.tickSpacing)),r=t?O.searchHightBitFromStart(e.tickArrayBitmap,e.exBitmapInfo,n+1,1,e.tickSpacing):O.searchLowBitFromStart(e.tickArrayBitmap,e.exBitmapInfo,n-1,1,e.tickSpacing);return r.length>0?{isExist:!0,nextStartIndex:r[0]}:{isExist:!1,nextStartIndex:0}}static nextInitializedTickArrayStartIndex(e,t,n){for(t=J.getArrayStartIndex(e.tickCurrent,e.tickSpacing);;){let{isInit:r,tickIndex:s}=mt.nextInitializedTickArrayStartIndex(O.mergeTickArrayBitmap(e.tickArrayBitmap),t,e.tickSpacing,n);if(r)return{isExist:!0,nextStartIndex:s};t=s;let{isInit:i,tickIndex:o}=wn.nextInitializedTickArrayFromOneBitmap(t,e.tickSpacing,n,e.exBitmapInfo);if(i)return{isExist:!0,nextStartIndex:o};if(t=o,t<Me||t>_e)return{isExist:!1,nextStartIndex:0}}}static async updatePoolRewardInfos({connection:e,apiPoolInfo:t,chainTime:n,poolLiquidity:r,rewardInfos:s}){var o,u,l;let i=[];for(let c=0;c<s.length;c++){let m=s[c],p=(l=(o=t.rewardDefaultInfos[c])==null?void 0:o.mint.programId)!=null?l:(u=await e.getAccountInfo(m.tokenMint))==null?void 0:u.owner;if(p===void 0)throw Error("get new reward mint info error");let d=z(F({},m),{perSecond:Q.x64ToDecimal(m.emissionsPerSecondX64),remainingRewards:void 0,tokenProgramId:new Oe(p)});if(d.tokenMint.equals(Oe.default))continue;if(n<=d.openTime.toNumber()||r.eq(pe)){i.push(d);continue}let f=new me(Math.min(d.endTime.toNumber(),n)),y=f.sub(d.lastUpdateTime),w=Q.mulDivFloor(y,d.emissionsPerSecondX64,r),g=d.rewardGrowthGlobalX64.add(w),A=Q.mulDivFloor(y,d.emissionsPerSecondX64,Ee),T=d.rewardTotalEmissioned.add(A);i.push(z(F({},d),{rewardGrowthGlobalX64:g,rewardTotalEmissioned:T,lastUpdateTime:f}))}return i}static isOverflowDefaultTickarrayBitmap(e,t){let{maxTickBoundary:n,minTickBoundary:r}=this.tickRange(e);for(let s of t){let i=O.getTickArrayStartIndexByTick(s,e);if(i>=n||i<r)return!0}return!1}static tickRange(e){let t=mt.maxTickInTickarrayBitmap(e),n=-t;return t>_e&&(t=J.getArrayStartIndex(_e,e)+J.tickCount(e)),n<Me&&(n=J.getArrayStartIndex(Me,e)),{maxTickBoundary:t,minTickBoundary:n}}static get_tick_array_offset(e,t){if(!J.checkIsValidStartIndex(e,t))throw new Error("No enough initialized tickArray");return e/J.tickCount(t)*vt}static async fetchExBitmaps({connection:e,exBitmapAddress:t,batchRequest:n}){let r=await Rt(e,t.map(i=>({pubkey:i})),{batchRequest:n}),s={};for(let i of r)i.accountInfo!==null&&(s[i.pubkey.toString()]=ro.decode(i.accountInfo.data));return s}static async fetchMultiplePoolTickArrays({connection:e,poolKeys:t,batchRequest:n}){let r={},s=[];for(let u of t){let l=O.getTickArrayStartIndexByTick(u.tickCurrent,u.tickSpacing),c=O.getInitializedTickArrayInRange(u.tickArrayBitmap,u.exBitmapInfo,u.tickSpacing,l,7);for(let m of c){let{publicKey:p}=re(u.programId,u.id,m);s.push({pubkey:p}),r[p.toString()]=u.id}}let i=await Rt(e,s,{batchRequest:n}),o={};for(let u of i){if(!u.accountInfo)continue;let l=r[u.pubkey.toString()];if(!l)continue;o[l.toString()]===void 0&&(o[l.toString()]={});let c=gn.decode(u.accountInfo.data);o[l.toString()][c.startTickIndex]=z(F({},c),{address:u.pubkey})}return o}static async fetchPoolsAccountPosition({pools:e,connection:t,ownerInfo:n,batchRequest:r=!1,updateOwnerRewardAndFee:s=!0}){var o;let i=[];for(let u=0;u<e.length;u++){let l=e[u];l!==null&&(i.find(c=>c.equals(l.state.programId))||i.push(l.state.programId))}if(n){let u=n.tokenAccounts.map(p=>p.accountInfo.mint),l=[];for(let p of u)for(let d of i)l.push(We(d,p).publicKey);let c=await at(t,l,{batchRequest:r}),m={};for(let p of c){if(p===null)continue;let d=no.decode(p.data),f=d.poolId.toString(),y=e.find(x=>x.state.id.toBase58()===f);if(y===void 0)continue;let w=y.state,g=O._getTickPriceLegacy({poolInfo:w,tick:d.tickLower,baseIn:!0}),A=O._getTickPriceLegacy({poolInfo:w,tick:d.tickUpper,baseIn:!0}),{amountA:T,amountB:h}=te.getAmountsFromLiquidity(w.sqrtPriceX64,g.tickSqrtPriceX64,A.tickSqrtPriceX64,d.liquidity,!1),P=1/(1-Math.sqrt(Math.sqrt(g.price.div(A.price).toNumber())));y.positionAccount=[...(o=y.positionAccount)!=null?o:[],{poolId:d.poolId,nftMint:d.nftMint,priceLower:g.price,priceUpper:A.price,amountA:T,amountB:h,tickLower:d.tickLower,tickUpper:d.tickUpper,liquidity:d.liquidity,feeGrowthInsideLastX64A:d.feeGrowthInsideLastX64A,feeGrowthInsideLastX64B:d.feeGrowthInsideLastX64B,tokenFeesOwedA:d.tokenFeesOwedA,tokenFeesOwedB:d.tokenFeesOwedB,rewardInfos:d.rewardInfos.map(x=>z(F({},x),{pendingReward:new me(0)})),leverage:P,tokenFeeAmountA:new me(0),tokenFeeAmountB:new me(0)}];let k=await O.getTickArrayAddressByTick(y.state.programId,d.poolId,d.tickLower,y.state.tickSpacing),S=await O.getTickArrayAddressByTick(y.state.programId,d.poolId,d.tickUpper,y.state.tickSpacing);m[`${y.state.programId.toString()}-${d.poolId.toString()}-${d.tickLower}`]=k,m[`${y.state.programId.toString()}-${d.poolId.toString()}-${d.tickUpper}`]=S}if(s){let p=Object.values(m),d=await at(t,p,{batchRequest:r}),f={};for(let y=0;y<p.length;y++){let w=d[y];if(w===null)continue;let g=p[y].toString();f[g]=gn.decode(w.data)}for(let{state:y,positionAccount:w}of e)if(!!w)for(let g of w){let A=`${y.programId.toString()}-${y.id.toString()}-${g.tickLower}`,T=`${y.programId.toString()}-${y.id.toString()}-${g.tickUpper}`,h=f[m[A].toString()],P=f[m[T].toString()],k=h.ticks[O.getTickOffsetInArray(g.tickLower,y.tickSpacing)],S=P.ticks[O.getTickOffsetInArray(g.tickUpper,y.tickSpacing)],{tokenFeeAmountA:x,tokenFeeAmountB:K}=await yn.GetPositionFees(y,g,k,S),B=await yn.GetPositionRewards(y,g,k,S);g.tokenFeeAmountA=x.gte(new me(0))?x:new me(0),g.tokenFeeAmountB=K.gte(new me(0))?K:new me(0);for(let N=0;N<B.length;N++)g.rewardInfos[N].pendingReward=B[N].gte(new me(0))?B[N]:new me(0)}}}return e}static computeAmountOut({poolInfo:e,tickArrayCache:t,baseMint:n,epochInfo:r,amountIn:s,slippage:i,priceLimit:o=new ee(0),catchLiquidityInsufficient:u=!1}){var M;let l,c=n.toBase58()===e.mintA.address,[m,p]=c?[e.mintA.extensions.feeConfig,e.mintB.extensions.feeConfig]:[e.mintB.extensions.feeConfig,e.mintA.extensions.feeConfig];o.equals(new ee(0))?l=c?_t.add(new me(1)):Vt.sub(new me(1)):l=X.priceToSqrtPriceX64(o,e.mintA.decimals,e.mintB.decimals);let d=ke(s,m,r,!1),{allTrade:f,expectedAmountOut:y,remainingAccounts:w,executionPrice:g,feeAmount:A}=Pe.getOutputAmountAndRemainAccounts(e,t,n,d.amount.sub((M=d.fee)!=null?M:pe),l,u),T=ke(y,p,r,!1),h=X.sqrtPriceX64ToPrice(g,e.mintA.decimals,e.mintB.decimals),P=c?h:new ee(1).div(h),k=y.mul(new me(Math.floor((1-i)*1e10))).div(new me(1e10)),S=ke(k,p,r,!1),x=c?e.currentPrice:new ee(1).div(e.currentPrice),K=new ee(P).sub(x).abs(),B=x,N=new Ue(new ee(K).mul(10**15).toFixed(0),new ee(B).mul(10**15).toFixed(0));return{allTrade:f,realAmountIn:d,amountOut:T,minAmountOut:S,expirationTime:gt(d.expirationTime,T.expirationTime),currentPrice:e.currentPrice,executionPrice:P,priceImpact:N,fee:A,remainingAccounts:w,executionPriceX64:g}}static computeAmountOutFormat({poolInfo:e,tickArrayCache:t,amountIn:n,tokenOut:r,slippage:s,epochInfo:i,catchLiquidityInsufficient:o=!1}){let u=r.address===e.mintB.address,[l,c]=u?[e.mintA,e.mintB]:[e.mintB,e.mintA],[m,p]=[new Re(z(F({},l),{mint:l.address,isToken2022:l.programId===eo.toBase58()})),new Re(z(F({},c),{mint:c.address,isToken2022:c.programId===eo.toBase58()}))],{allTrade:d,realAmountIn:f,amountOut:y,minAmountOut:w,expirationTime:g,currentPrice:A,executionPrice:T,priceImpact:h,fee:P,remainingAccounts:k,executionPriceX64:S}=Pe.computeAmountOut({poolInfo:e,tickArrayCache:t,baseMint:new Oe(l.address),amountIn:n,slippage:s,epochInfo:i,catchLiquidityInsufficient:o}),x=z(F({},f),{amount:new we(m,f.amount),fee:f.fee===void 0?void 0:new we(m,f.fee)}),K=z(F({},y),{amount:new we(p,y.amount),fee:y.fee===void 0?void 0:new we(p,y.fee)}),B=z(F({},w),{amount:new we(p,w.amount),fee:w.fee===void 0?void 0:new we(p,w.fee)}),N=new Xe({baseToken:m,denominator:new me(10).pow(new me(20+m.decimals)),quoteToken:p,numerator:A.mul(new ee(10**(20+p.decimals))).toFixed(0)}),M=new Xe({baseToken:m,denominator:new me(10).pow(new me(20+m.decimals)),quoteToken:p,numerator:T.mul(new ee(10**(20+p.decimals))).toFixed(0)}),C=new we(m,P);return{allTrade:d,realAmountIn:x,amountOut:K,minAmountOut:B,expirationTime:g,currentPrice:N,executionPrice:M,priceImpact:h,fee:C,remainingAccounts:k,executionPriceX64:S}}static computeAmountIn({poolInfo:e,tickArrayCache:t,baseMint:n,epochInfo:r,amountOut:s,slippage:i,priceLimit:o=new ee(0)}){var B;let u=n.toBase58()===e.mintA.address,l={[e.mintA.address]:e.mintA.extensions.feeConfig,[e.mintB.address]:e.mintB.extensions.feeConfig},c;o.equals(new ee(0))?c=u?Vt.sub(new me(1)):_t.add(new me(1)):c=X.priceToSqrtPriceX64(o,e.mintA.decimals,e.mintB.decimals);let m=ke(s,l[n.toString()],r,!0),{expectedAmountIn:p,remainingAccounts:d,executionPrice:f,feeAmount:y}=Pe.getInputAmountAndRemainAccounts(e,t,n,m.amount.sub((B=m.fee)!=null?B:pe),c),w=u?e.mintB.address:e.mintA.address,g=ke(p,l[w],r,!1),A=X.sqrtPriceX64ToPrice(f,e.mintA.decimals,e.mintB.decimals),T=u?A:new ee(1).div(A),h=p.mul(new me(Math.floor((1+i)*1e10))).div(new me(1e10)),P=ke(h,l[w],r,!0),k=u?e.currentPrice:new ee(1).div(e.currentPrice),S=new ee(T).sub(k).abs(),x=k,K=new Ue(new ee(S).mul(10**15).toFixed(0),new ee(x).mul(10**15).toFixed(0));return{amountIn:g,maxAmountIn:P,realAmountOut:m,expirationTime:gt(g.expirationTime,m.expirationTime),currentPrice:e.currentPrice,executionPrice:T,priceImpact:K,fee:y,remainingAccounts:d}}static estimateAprsForPriceRangeMultiplier({poolInfo:e,aprType:t,positionTickLowerIndex:n,positionTickUpperIndex:r}){var f,y,w;let s=e[t],i=O.getTickPrice({poolInfo:e,tick:n,baseIn:!0}).price.toNumber(),o=O.getTickPrice({poolInfo:e,tick:r,baseIn:!0}).price.toNumber(),u=Math.max(i,s.priceMin),c=Math.min(o,s.priceMax)-u,m=o-i,p=s.priceMax-s.priceMin,d;return c<=0?d=0:m===c?d=p/c:p===c?d=c/m:d=c/p*(c/m),{feeApr:s.feeApr*d,rewardsApr:[((f=s.rewardApr[0])!=null?f:0)*d,((y=s.rewardApr[1])!=null?y:0)*d,((w=s.rewardApr[2])!=null?w:0)*d],apr:s.apr*d}}static estimateAprsForPriceRangeDelta({poolInfo:e,poolLiquidity:t,aprType:n,mintPrice:r,liquidity:s,positionTickLowerIndex:i,positionTickUpperIndex:o,chainTime:u}){let l=n==="day"?1:n==="week"?7:n==="month"?30:0,c=e[n],m=r[Xt(e.mintA.address).toString()],p=r[Xt(e.mintB.address).toString()],d=e.mintA.decimals,f=e.mintB.decimals;if(!c||!m||!p)return{feeApr:0,rewardsApr:[0,0,0],apr:0};let y=X.priceToSqrtPriceX64(new ee(e.price),e.mintA.decimals,e.mintB.decimals),w=X.getSqrtPriceX64FromTick(i),g=X.getSqrtPriceX64FromTick(o),{amountSlippageA:A,amountSlippageB:T}=te.getAmountsFromLiquidityWithSlippage(y,w,g,t,!1,!1,0),{amountSlippageA:h,amountSlippageB:P}=te.getAmountsFromLiquidityWithSlippage(y,w,g,s,!1,!1,0),k=new ee(A.toString()).div(new ee(10).pow(d)).mul(m.value).add(new ee(T.toString()).div(new ee(10).pow(f)).mul(p.value)),S=new ee(h.toString()).div(new ee(10).pow(d)).mul(m.value).add(new ee(P.toString()).div(new ee(10).pow(f)).mul(p.value)),x=new ee(1).div(k.add(S)),B=new ee(c.volumeFee).mul(365).div(l).mul(x).mul(100).toNumber(),N=3600*24*365,M=e.rewardDefaultInfos.map(C=>{var Y,Z;let E=C.mint.decimals,j=r[C.mint.address];return u<((Y=C.startTime)!=null?Y:0)||u>((Z=C.endTime)!=null?Z:0)||!C.perSecond||!j||E===void 0?0:new ee(j.value).mul(new ee(C.perSecond).mul(N)).div(new ee(10).pow(E)).mul(x).mul(100).toNumber()});return{feeApr:B,rewardsApr:M,apr:B+M.reduce((C,E)=>C+E,0)}}static async getLiquidityAmountOutFromAmountIn({poolInfo:e,inputA:t,tickLower:n,tickUpper:r,amount:s,slippage:i,add:o,epochInfo:u,amountHasFee:l}){var g,A;let c=X.priceToSqrtPriceX64(new ee(e.price),e.mintA.decimals,e.mintB.decimals),m=X.getSqrtPriceX64FromTick(n),p=X.getSqrtPriceX64FromTick(r),d=ke(s,(g=e[t?"mintA":"mintB"].extensions)==null?void 0:g.feeConfig,u,!l),f=new me(new ee(d.amount.sub((A=d.fee)!=null?A:pe).toString()).toFixed(0)),y;if(c.lte(m))y=t?te.getLiquidityFromTokenAmountA(m,p,f,!o):new me(0);else if(c.lte(p)){let T=te.getLiquidityFromTokenAmountA(c,p,f,!o),h=te.getLiquidityFromTokenAmountB(m,c,f);y=t?T:h}else y=t?new me(0):te.getLiquidityFromTokenAmountB(m,p,f);let w=await Pe.getAmountsFromLiquidity({epochInfo:u,poolInfo:e,tickLower:n,tickUpper:r,liquidity:y,slippage:i,add:o});return{liquidity:y,amountA:t?d:w.amountA,amountB:t?w.amountB:d,amountSlippageA:t?d:w.amountSlippageA,amountSlippageB:t?w.amountSlippageB:d,expirationTime:w.expirationTime}}static async getAmountsFromLiquidity({epochInfo:e,poolInfo:t,tickLower:n,tickUpper:r,liquidity:s,slippage:i,add:o}){var w,g,A,T;let u=X.getSqrtPriceX64FromTick(n),l=X.getSqrtPriceX64FromTick(r),c=o?1+i:1-i,m=te.getAmountsFromLiquidity(X.priceToSqrtPriceX64(new ee(t.price),t.mintA.decimals,t.mintB.decimals),u,l,s,o),[p,d]=[ke(m.amountA,(w=t.mintA.extensions)==null?void 0:w.feeConfig,e,!0),ke(m.amountB,(g=t.mintB.extensions)==null?void 0:g.feeConfig,e,!0)],[f,y]=[ke(m.amountA.muln(c),(A=t.mintA.extensions)==null?void 0:A.feeConfig,e,!0),ke(m.amountB.muln(c),(T=t.mintB.extensions)==null?void 0:T.feeConfig,e,!0)];return{liquidity:s,amountA:p,amountB:d,amountSlippageA:f,amountSlippageB:y,expirationTime:gt(p.expirationTime,d.expirationTime)}}static async fetchComputeMultipleClmmInfo({connection:e,poolList:t,rpcDataMap:n={}}){let r=t.filter(u=>!n[u.id]).map(u=>new Oe(u.id));(await at(e,r)).forEach((u,l)=>{!u||(n[r[l].toBase58()]=to.decode(u.data))});let i=t.map(u=>Be(new Oe(u.programId),new Oe(u.id)).publicKey),o=await Pe.fetchExBitmaps({connection:e,exBitmapAddress:i,batchRequest:!1});return t.reduce((u,l)=>z(F({},u),{[l.id]:z(F({},n[l.id]),{id:new Oe(l.id),version:6,programId:new Oe(l.programId),mintA:l.mintA,mintB:l.mintB,ammConfig:z(F({},l.config),{id:new Oe(l.config.id),fundOwner:""}),currentPrice:new ee(l.price),exBitmapAccount:Be(new Oe(l.programId),new Oe(l.id)).publicKey,exBitmapInfo:o[Be(new Oe(l.programId),new Oe(l.id)).publicKey.toBase58()],startTime:n[l.id].startTime.toNumber(),rewardInfos:n[l.id].rewardInfos})}),{})}static async fetchComputeClmmInfo({connection:e,poolInfo:t,rpcData:n}){return(await this.fetchComputeMultipleClmmInfo({connection:e,rpcDataMap:n?{[t.id]:n}:void 0,poolList:[t]}))[t.id]}};var Q=class{static mulDivRoundingUp(e,t,n){let r=e.mul(t),s=r.div(n);return r.mod(n).eq(pe)||(s=s.add($e)),s}static mulDivFloor(e,t,n){if(n.eq(pe))throw new Error("division by 0");return e.mul(t).div(n)}static mulDivCeil(e,t,n){if(n.eq(pe))throw new Error("division by 0");return e.mul(t).add(n.sub($e)).div(n)}static x64ToDecimal(e,t){return new et(e.toString()).div(et.pow(2,64)).toDecimalPlaces(t)}static decimalToX64(e){return new H(e.mul(et.pow(2,64)).floor().toFixed())}static wrappingSubU128(e,t){return e.add(En).sub(t).mod(En)}};function Se(a,e){return Lr(a.mul(e),64,256)}function ia(a,e,t){let n=a.toTwos(t).shln(e);return n.imaskn(t+1),n.fromTwos(t)}function Lr(a,e,t){let n=a.toTwos(t).shrn(e);return n.imaskn(t-e+1),n.fromTwos(t-e)}var X=class{static sqrtPriceX64ToPrice(e,t,n){return Q.x64ToDecimal(e).pow(2).mul(et.pow(10,t-n))}static priceToSqrtPriceX64(e,t,n){return Q.decimalToX64(e.mul(et.pow(10,n-t)).sqrt())}static getNextSqrtPriceX64FromInput(e,t,n,r){if(!e.gt(pe))throw new Error("sqrtPriceX64 must greater than 0");if(!t.gt(pe))throw new Error("liquidity must greater than 0");return r?this.getNextSqrtPriceFromTokenAmountARoundingUp(e,t,n,!0):this.getNextSqrtPriceFromTokenAmountBRoundingDown(e,t,n,!0)}static getNextSqrtPriceX64FromOutput(e,t,n,r){if(!e.gt(pe))throw new Error("sqrtPriceX64 must greater than 0");if(!t.gt(pe))throw new Error("liquidity must greater than 0");return r?this.getNextSqrtPriceFromTokenAmountBRoundingDown(e,t,n,!1):this.getNextSqrtPriceFromTokenAmountARoundingUp(e,t,n,!1)}static getNextSqrtPriceFromTokenAmountARoundingUp(e,t,n,r){if(n.eq(pe))return e;let s=t.shln(pn);if(r){let i=s,o=s.add(n.mul(e));return o.gte(i)?Q.mulDivCeil(i,e,o):Q.mulDivRoundingUp(i,$e,i.div(e).add(n))}else{let i=n.mul(e);if(!s.gt(i))throw new Error("getNextSqrtPriceFromTokenAmountARoundingUp,liquidityLeftShift must gt amountMulSqrtPrice");let o=s.sub(i);return Q.mulDivCeil(s,e,o)}}static getNextSqrtPriceFromTokenAmountBRoundingDown(e,t,n,r){let s=n.shln(pn);if(r)return e.add(s.div(t));{let i=Q.mulDivRoundingUp(s,$e,t);if(!e.gt(i))throw new Error("getNextSqrtPriceFromTokenAmountBRoundingDown sqrtPriceX64 must gt amountDivLiquidity");return e.sub(i)}}static getSqrtPriceX64FromTick(e){if(!Number.isInteger(e))throw new Error("tick must be integer");if(e<Me||e>_e)throw new Error("tick must be in MIN_TICK and MAX_TICK");let t=e<0?e*-1:e,n=(t&1)!=0?new H("18445821805675395072"):new H("18446744073709551616");return(t&2)!=0&&(n=Se(n,new H("18444899583751176192"))),(t&4)!=0&&(n=Se(n,new H("18443055278223355904"))),(t&8)!=0&&(n=Se(n,new H("18439367220385607680"))),(t&16)!=0&&(n=Se(n,new H("18431993317065453568"))),(t&32)!=0&&(n=Se(n,new H("18417254355718170624"))),(t&64)!=0&&(n=Se(n,new H("18387811781193609216"))),(t&128)!=0&&(n=Se(n,new H("18329067761203558400"))),(t&256)!=0&&(n=Se(n,new H("18212142134806163456"))),(t&512)!=0&&(n=Se(n,new H("17980523815641700352"))),(t&1024)!=0&&(n=Se(n,new H("17526086738831433728"))),(t&2048)!=0&&(n=Se(n,new H("16651378430235570176"))),(t&4096)!=0&&(n=Se(n,new H("15030750278694412288"))),(t&8192)!=0&&(n=Se(n,new H("12247334978884435968"))),(t&16384)!=0&&(n=Se(n,new H("8131365268886854656"))),(t&32768)!=0&&(n=Se(n,new H("3584323654725218816"))),(t&65536)!=0&&(n=Se(n,new H("696457651848324352"))),(t&131072)!=0&&(n=Se(n,new H("26294789957507116"))),(t&262144)!=0&&(n=Se(n,new H("37481735321082"))),e>0&&(n=Di.div(n)),n}static getTickFromPrice(e,t,n){return X.getTickFromSqrtPriceX64(X.priceToSqrtPriceX64(e,t,n))}static getTickFromSqrtPriceX64(e){if(e.gt(Vt)||e.lt(_t))throw new Error("Provided sqrtPrice is not within the supported sqrtPrice range.");let t=e.bitLength()-1,n=new H(t-64),r=ia(n,32,128),s=new H("8000000000000000","hex"),i=0,o=new H(0),u=t>=64?e.shrn(t-63):e.shln(63-t);for(;s.gt(new H(0))&&i<qi;){u=u.mul(u);let f=u.shrn(127);u=u.shrn(63+f.toNumber()),o=o.add(s.mul(f)),s=s.shrn(1),i+=1}let l=o.shrn(32),m=r.add(l).mul(new H(Gi)),p=Lr(m.sub(new H(Ui)),64,128).toNumber(),d=Lr(m.add(new H(Xi)),64,128).toNumber();return p==d?p:X.getSqrtPriceX64FromTick(d).lte(e)?d:p}},Wt=class{static getTickWithPriceAndTickspacing(e,t,n,r){let i=X.getTickFromSqrtPriceX64(X.priceToSqrtPriceX64(e,n,r))/t;return i<0?i=Math.floor(i):i=Math.ceil(i),i*t}static roundPriceWithTickspacing(e,t,n,r){let s=Wt.getTickWithPriceAndTickspacing(e,t,n,r),i=X.getSqrtPriceX64FromTick(s);return X.sqrtPriceX64ToPrice(i,n,r)}},te=class{static addDelta(e,t){return e.add(t)}static getTokenAmountAFromLiquidity(e,t,n,r){if(e.gt(t)&&([e,t]=[t,e]),!e.gt(pe))throw new Error("sqrtPriceX64A must greater than 0");let s=n.ushln(pn),i=t.sub(e);return r?Q.mulDivRoundingUp(Q.mulDivCeil(s,i,t),$e,e):Q.mulDivFloor(s,i,t).div(e)}static getTokenAmountBFromLiquidity(e,t,n,r){if(e.gt(t)&&([e,t]=[t,e]),!e.gt(pe))throw new Error("sqrtPriceX64A must greater than 0");return r?Q.mulDivCeil(n,t.sub(e),Ee):Q.mulDivFloor(n,t.sub(e),Ee)}static getLiquidityFromTokenAmountA(e,t,n,r){e.gt(t)&&([e,t]=[t,e]);let s=n.mul(e).mul(t),i=t.sub(e),o=s.div(i);return r?Q.mulDivRoundingUp(o,$e,Ar):o.shrn(pn)}static getLiquidityFromTokenAmountB(e,t,n){return e.gt(t)&&([e,t]=[t,e]),Q.mulDivFloor(n,Ar,t.sub(e))}static getLiquidityFromTokenAmounts(e,t,n,r,s){if(t.gt(n)&&([t,n]=[n,t]),e.lte(t))return te.getLiquidityFromTokenAmountA(t,n,r,!1);if(e.lt(n)){let i=te.getLiquidityFromTokenAmountA(e,n,r,!1),o=te.getLiquidityFromTokenAmountB(t,e,s);return i.lt(o)?i:o}else return te.getLiquidityFromTokenAmountB(t,n,s)}static getAmountsFromLiquidity(e,t,n,r,s){if(t.gt(n)&&([t,n]=[n,t]),e.lte(t))return{amountA:te.getTokenAmountAFromLiquidity(t,n,r,s),amountB:new H(0)};if(e.lt(n)){let i=te.getTokenAmountAFromLiquidity(e,n,r,s),o=te.getTokenAmountBFromLiquidity(t,e,r,s);return{amountA:i,amountB:o}}else return{amountA:new H(0),amountB:te.getTokenAmountBFromLiquidity(t,n,r,s)}}static getAmountsFromLiquidityWithSlippage(e,t,n,r,s,i,o){let{amountA:u,amountB:l}=te.getAmountsFromLiquidity(e,t,n,r,i),c=s?1+o:1-o,m=new H(new et(u.toString()).mul(c).toFixed(0)),p=new H(new et(l.toString()).mul(c).toFixed(0));return{amountSlippageA:m,amountSlippageB:p}}static getAmountsOutFromLiquidity({poolInfo:e,tickLower:t,tickUpper:n,liquidity:r,slippage:s,add:i,epochInfo:o,amountAddFee:u}){var A,T,h,P;let l=X.priceToSqrtPriceX64(new et(e.price),e.mintA.decimals,e.mintB.decimals),c=X.getSqrtPriceX64FromTick(t),m=X.getSqrtPriceX64FromTick(n),p=i?1+s:1-s,d=te.getAmountsFromLiquidity(l,c,m,r,i),[f,y]=[ke(d.amountA,(A=e.mintA.extensions)==null?void 0:A.feeConfig,o,u),ke(d.amountB,(T=e.mintB.extensions)==null?void 0:T.feeConfig,o,u)],[w,g]=[ke(new H(new et(d.amountA.toString()).mul(p).toFixed(0)),(h=e.mintA.extensions)==null?void 0:h.feeConfig,o,u),ke(new H(new et(d.amountB.toString()).mul(p).toFixed(0)),(P=e.mintB.extensions)==null?void 0:P.feeConfig,o,u)];return{liquidity:r,amountA:f,amountB:y,amountSlippageA:w,amountSlippageB:g,expirationTime:gt(f.expirationTime,y.expirationTime)}}},Et=class{static swapCompute(e,t,n,r,s,i,o,u,l,c,m,p,d,f,y=!1){if(p.eq(pe))throw new Error("amountSpecified must not be 0");if(f||(f=i?_t.add($e):Vt.sub($e)),i){if(f.lt(_t))throw new Error("sqrtPriceX64 must greater than MIN_SQRT_PRICE_X64");if(f.gte(m))throw new Error("sqrtPriceX64 must smaller than current")}else{if(f.gt(Vt))throw new Error("sqrtPriceX64 must smaller than MAX_SQRT_PRICE_X64");if(f.lte(m))throw new Error("sqrtPriceX64 must greater than current")}let w=p.gt(pe),g={amountSpecifiedRemaining:p,amountCalculated:pe,sqrtPriceX64:m,tick:l>d?Math.min(d+J.tickCount(c)-1,l):d,accounts:[],liquidity:u,feeAmount:new H(0)},A=d,T=n[d],h=0,P=!i&&T.startTickIndex===g.tick;for(;!g.amountSpecifiedRemaining.eq(pe)&&!g.sqrtPriceX64.eq(f);){h>10;let k={};k.sqrtPriceStartX64=g.sqrtPriceX64;let S=O.nextInitTick(T,g.tick,c,i,P),x=S||null,K=null;if(!(x!=null&&x.liquidityGross.gtn(0))){let N=Pe.nextInitializedTickArrayStartIndex({tickCurrent:g.tick,tickSpacing:c,tickArrayBitmap:r,exBitmapInfo:s},A,i);if(!N.isExist){if(y)return{allTrade:!1,amountSpecifiedRemaining:g.amountSpecifiedRemaining,amountCalculated:g.amountCalculated,feeAmount:g.feeAmount,sqrtPriceX64:g.sqrtPriceX64,liquidity:g.liquidity,tickCurrent:g.tick,accounts:g.accounts};throw Error("swapCompute LiquidityInsufficient")}A=N.nextStartIndex;let{publicKey:M}=re(e,t,A);K=M,T=n[A];try{x=O.firstInitializedTick(T,i)}catch{throw Error("not found next tick info")}}k.tickNext=x.tick,k.initialized=x.liquidityGross.gtn(0),d!==A&&K&&(g.accounts.push(K),d=A),k.tickNext<Me?k.tickNext=Me:k.tickNext>_e&&(k.tickNext=_e),k.sqrtPriceNextX64=X.getSqrtPriceX64FromTick(k.tickNext);let B;if(i&&k.sqrtPriceNextX64.lt(f)||!i&&k.sqrtPriceNextX64.gt(f)?B=f:B=k.sqrtPriceNextX64,[g.sqrtPriceX64,k.amountIn,k.amountOut,k.feeAmount]=Et.swapStepCompute(g.sqrtPriceX64,B,g.liquidity,g.amountSpecifiedRemaining,o,i),g.feeAmount=g.feeAmount.add(k.feeAmount),w?(g.amountSpecifiedRemaining=g.amountSpecifiedRemaining.sub(k.amountIn.add(k.feeAmount)),g.amountCalculated=g.amountCalculated.sub(k.amountOut)):(g.amountSpecifiedRemaining=g.amountSpecifiedRemaining.add(k.amountOut),g.amountCalculated=g.amountCalculated.add(k.amountIn.add(k.feeAmount))),g.sqrtPriceX64.eq(k.sqrtPriceNextX64)){if(k.initialized){let N=x.liquidityNet;i&&(N=N.mul(lt)),g.liquidity=te.addDelta(g.liquidity,N)}P=k.tickNext!=g.tick&&!i&&T.startTickIndex===k.tickNext,g.tick=i?k.tickNext-1:k.tickNext}else if(g.sqrtPriceX64!=k.sqrtPriceStartX64){let N=X.getTickFromSqrtPriceX64(g.sqrtPriceX64);P=N!=g.tick&&!i&&T.startTickIndex===N,g.tick=N}++h}try{let{nextStartIndex:k,isExist:S}=J.nextInitializedTickArray(g.tick,c,i,r,s);S&&d!==k&&(g.accounts.push(re(e,t,k).publicKey),d=k)}catch{}return{allTrade:!0,amountSpecifiedRemaining:pe,amountCalculated:g.amountCalculated,feeAmount:g.feeAmount,sqrtPriceX64:g.sqrtPriceX64,liquidity:g.liquidity,tickCurrent:g.tick,accounts:g.accounts}}static swapStepCompute(e,t,n,r,s,i){let o={sqrtPriceX64Next:new H(0),amountIn:new H(0),amountOut:new H(0),feeAmount:new H(0)},u=r.gte(pe);if(u){let c=Q.mulDivFloor(r,Wn.sub(new H(s.toString())),Wn);o.amountIn=i?te.getTokenAmountAFromLiquidity(t,e,n,!0):te.getTokenAmountBFromLiquidity(e,t,n,!0),c.gte(o.amountIn)?o.sqrtPriceX64Next=t:o.sqrtPriceX64Next=X.getNextSqrtPriceX64FromInput(e,n,c,i)}else o.amountOut=i?te.getTokenAmountBFromLiquidity(t,e,n,!1):te.getTokenAmountAFromLiquidity(e,t,n,!1),r.mul(lt).gte(o.amountOut)?o.sqrtPriceX64Next=t:o.sqrtPriceX64Next=X.getNextSqrtPriceX64FromOutput(e,n,r.mul(lt),i);let l=t.eq(o.sqrtPriceX64Next);return i?(l&&u||(o.amountIn=te.getTokenAmountAFromLiquidity(o.sqrtPriceX64Next,e,n,!0)),l&&!u||(o.amountOut=te.getTokenAmountBFromLiquidity(o.sqrtPriceX64Next,e,n,!1))):(o.amountIn=l&&u?o.amountIn:te.getTokenAmountBFromLiquidity(e,o.sqrtPriceX64Next,n,!0),o.amountOut=l&&!u?o.amountOut:te.getTokenAmountAFromLiquidity(e,o.sqrtPriceX64Next,n,!1)),!u&&o.amountOut.gt(r.mul(lt))&&(o.amountOut=r.mul(lt)),u&&!o.sqrtPriceX64Next.eq(t)?o.feeAmount=r.sub(o.amountIn):o.feeAmount=Q.mulDivCeil(o.amountIn,new H(s),Wn.sub(new H(s))),[o.sqrtPriceX64Next,o.amountIn,o.amountOut,o.feeAmount]}};var xe=60,vt=512,O=class{static getTickArrayAddressByTick(e,t,n,r){let s=O.getTickArrayStartIndexByTick(n,r),{publicKey:i}=re(e,t,s);return i}static getTickOffsetInArray(e,t){if(e%t!=0)throw new Error("tickIndex % tickSpacing not equal 0");let n=O.getTickArrayStartIndexByTick(e,t),r=Math.floor((e-n)/t);if(r<0||r>=xe)throw new Error("tick offset in array overflow");return r}static getTickArrayBitIndex(e,t){let n=J.tickCount(t),r=e/n;return e<0&&e%n!=0?r=Math.ceil(r)-1:r=Math.floor(r),r}static getTickArrayStartIndexByTick(e,t){return this.getTickArrayBitIndex(e,t)*J.tickCount(t)}static getTickArrayOffsetInBitmapByTick(e,t){let n=t*xe,r=Math.floor(e/n)+512;return Math.abs(r)}static checkTickArrayIsInitialized(e,t,n){let r=n*xe,s=Math.floor(t/r)+512,i=Math.abs(s);return{isInitialized:e.testn(i),startIndex:(i-512)*r}}static getNextTickArrayStartIndex(e,t,n){return n?e-t*xe:e+t*xe}static mergeTickArrayBitmap(e){let t=new oa(0);for(let n=0;n<e.length;n++)t=t.add(e[n].shln(64*n));return t}static getInitializedTickArrayInRange(e,t,n,r,s){let i=Math.floor(r/(n*xe));return[...O.searchLowBitFromStart(e,t,i-1,s,n),...O.searchHightBitFromStart(e,t,i,s,n)]}static getAllInitializedTickArrayStartIndex(e,t,n){return O.searchHightBitFromStart(e,t,-7680,vt,n)}static getAllInitializedTickArrayInfo(e,t,n,r,s){let i=[],o=O.getAllInitializedTickArrayStartIndex(n,r,s);for(let u of o){let{publicKey:l}=re(e,t,u);i.push({tickArrayStartIndex:u,tickArrayAddress:l})}return i}static getAllInitializedTickInTickArray(e){return e.ticks.filter(t=>t.liquidityGross.gtn(0))}static searchLowBitFromStart(e,t,n,r,s){let i=[...[...t.negativeTickArrayBitmap].reverse(),e.slice(0,8),e.slice(8,16),...t.positiveTickArrayBitmap].map(l=>O.mergeTickArrayBitmap(l)),o=[];for(;n>=-7680;){let l=Math.floor((n+7680)/512),c=(n+7680)%512;if(i[l].testn(c)&&o.push(n),n--,o.length===r)break}let u=J.tickCount(s);return o.map(l=>l*u)}static searchHightBitFromStart(e,t,n,r,s){let i=[...[...t.negativeTickArrayBitmap].reverse(),e.slice(0,8),e.slice(8,16),...t.positiveTickArrayBitmap].map(l=>O.mergeTickArrayBitmap(l)),o=[];for(;n<7680;){let l=Math.floor((n+7680)/512),c=(n+7680)%512;if(i[l].testn(c)&&o.push(n),n++,o.length===r)break}let u=J.tickCount(s);return o.map(l=>l*u)}static checkIsOutOfBoundary(e){return e<Me||e>_e}static nextInitTick(e,t,n,r,s){if(J.getArrayStartIndex(t,n)!=e.startTickIndex)return null;let o=Math.floor((t-e.startTickIndex)/n);if(r)for(;o>=0;){if(e.ticks[o].liquidityGross.gtn(0))return e.ticks[o];o=o-1}else for(s||(o=o+1);o<xe;){if(e.ticks[o].liquidityGross.gtn(0))return e.ticks[o];o=o+1}return null}static firstInitializedTick(e,t){if(t){let n=xe-1;for(;n>=0;){if(e.ticks[n].liquidityGross.gtn(0))return e.ticks[n];n=n-1}}else{let n=0;for(;n<xe;){if(e.ticks[n].liquidityGross.gtn(0))return e.ticks[n];n=n+1}}throw Error(`firstInitializedTick check error: ${e} - ${t}`)}static _getTickPriceLegacy({poolInfo:e,tick:t,baseIn:n}){let r=X.getSqrtPriceX64FromTick(t),s=X.sqrtPriceX64ToPrice(r,e.mintA.decimals,e.mintB.decimals);return n?{tick:t,price:s,tickSqrtPriceX64:r}:{tick:t,price:new jt(1).div(s),tickSqrtPriceX64:r}}static _getPriceAndTickLegacy({poolInfo:e,price:t,baseIn:n}){let r=n?t:new jt(1).div(t),s=Wt.getTickWithPriceAndTickspacing(r,e.ammConfig.tickSpacing,e.mintA.decimals,e.mintB.decimals),i=X.getSqrtPriceX64FromTick(s),o=X.sqrtPriceX64ToPrice(i,e.mintA.decimals,e.mintB.decimals);return n?{tick:s,price:o}:{tick:s,price:new jt(1).div(o)}}static getTickPrice({poolInfo:e,tick:t,baseIn:n}){let r=X.getSqrtPriceX64FromTick(t),s=X.sqrtPriceX64ToPrice(r,e.mintA.decimals,e.mintB.decimals);return n?{tick:t,price:s,tickSqrtPriceX64:r}:{tick:t,price:new jt(1).div(s),tickSqrtPriceX64:r}}static getPriceAndTick({poolInfo:e,price:t,baseIn:n}){let r=n?t:new jt(1).div(t),s=Wt.getTickWithPriceAndTickspacing(r,e.config.tickSpacing,e.mintA.decimals,e.mintB.decimals),i=X.getSqrtPriceX64FromTick(s),o=X.sqrtPriceX64ToPrice(i,e.mintA.decimals,e.mintB.decimals);return n?{tick:s,price:o}:{tick:s,price:new jt(1).div(o)}}};var ub=_([he(8),W("bump"),Ct("index"),L(""),Ce("protocolFeeRate"),Ce("tradeFeeRate"),Ct("tickSpacing"),G(b(),8,"")]),sa=_([Ce("blockTimestamp"),Ht("tickCumulative"),G(b(),4)]),io=_([he(8),Te("initialized"),b("recentEpoch"),Ct("observationIndex"),L("poolId"),G(sa,100,"observations"),G(b(),4)]),aa=_([W("rewardState"),b("openTime"),b("endTime"),b("lastUpdateTime"),q("emissionsPerSecondX64"),b("rewardTotalEmissioned"),b("rewardClaimed"),L("tokenMint"),L("tokenVault"),L("creator"),q("rewardGrowthGlobalX64")]),to=_([he(8),W("bump"),L("ammConfig"),L("creator"),L("mintA"),L("mintB"),L("vaultA"),L("vaultB"),L("observationId"),W("mintDecimalsA"),W("mintDecimalsB"),Ct("tickSpacing"),q("liquidity"),q("sqrtPriceX64"),le("tickCurrent"),Ce(),q("feeGrowthGlobalX64A"),q("feeGrowthGlobalX64B"),b("protocolFeesTokenA"),b("protocolFeesTokenB"),q("swapInAmountTokenA"),q("swapOutAmountTokenB"),q("swapInAmountTokenB"),q("swapOutAmountTokenA"),W("status"),G(W(),7,""),G(aa,3,"rewardInfos"),G(b(),16,"tickArrayBitmap"),b("totalFeesTokenA"),b("totalFeesClaimedTokenA"),b("totalFeesTokenB"),b("totalFeesClaimedTokenB"),b("fundFeesTokenA"),b("fundFeesTokenB"),b("startTime"),G(b(),15*4-3,"padding")]),ua=_([q("growthInsideLastX64"),b("rewardAmountOwed")]),no=_([he(8),W("bump"),L("nftMint"),L("poolId"),le("tickLower"),le("tickUpper"),q("liquidity"),q("feeGrowthInsideLastX64A"),q("feeGrowthInsideLastX64B"),b("tokenFeesOwedA"),b("tokenFeesOwedB"),G(ua,3,"rewardInfos"),G(b(),8,"")]),cb=_([he(8),W("bump"),L("poolId"),le("tickLowerIndex"),le("tickUpperIndex"),q("liquidity"),q("feeGrowthInsideLastX64A"),q("feeGrowthInsideLastX64B"),b("tokenFeesOwedA"),b("tokenFeesOwedB"),G(q(),3,"rewardGrowthInside"),G(b(),8,"")]),ca=_([le("tick"),Ci("liquidityNet"),q("liquidityGross"),q("feeGrowthOutsideX64A"),q("feeGrowthOutsideX64B"),G(q(),3,"rewardGrowthsOutsideX64"),G(Ce(),13,"")]),gn=_([he(8),L("poolId"),le("startTickIndex"),G(ca,xe,"ticks"),W("initializedTickCount"),G(W(),115,"")]),lb=_([he(329),G(L(),100,"whitelistMints")]),ro=_([he(8),L("poolId"),G(G(b(),8),Kr,"positiveTickArrayBitmap"),G(G(b(),8),Kr,"negativeTickArrayBitmap")]),mb=_([b(),W("bump"),L("owner"),L("poolId"),L("positionId"),L("nftAccount"),G(b(),8)]),db=_([he(8),W("bump"),L("lockOwner"),L("poolId"),L("positionId"),L("nftAccount"),L("lockNftMint"),b("recentEpoch"),G(b(),8)]);io.span;var oo=ie("Raydium_Clmm"),Fe={createPool:[233,146,209,142,207,104,64,188],initReward:[95,135,192,196,242,129,230,68],setRewardEmissions:[112,52,167,75,32,201,211,137],openPosition:[77,184,74,214,112,86,241,199],openPositionWithTokenEx:[77,255,174,82,125,29,201,46],closePosition:[123,134,81,0,49,68,98,98],increaseLiquidity:[133,29,89,223,69,238,176,10],decreaseLiquidity:[58,127,188,62,79,82,196,96],swap:[43,4,237,11,26,201,30,98],collectReward:[18,237,166,197,34,16,213,144]},so=[188,37,179,131,82,150,84,73],ao=[16,72,250,198,14,162,212,19],Zt=class{static createPoolInstruction(e,t,n,r,s,i,o,u,l,c,m,p,d,f){let y=_([q("sqrtPriceX64"),b("zero")]),w=[{pubkey:n,isSigner:!0,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!1},{pubkey:l,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:p,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!1},{pubkey:m,isSigner:!1,isWritable:!1},{pubkey:dt.programId,isSigner:!1,isWritable:!1},{pubkey:Qe,isSigner:!1,isWritable:!1},...(f==null?void 0:f.map(T=>({pubkey:T,isSigner:!1,isWritable:!1})))||[]],g=Buffer.alloc(y.span);y.encode({sqrtPriceX64:d,zero:pe},g);let A=Buffer.from([...Fe.createPool,...g]);return new Ie({keys:w,programId:e,data:A})}static async createPoolInstructions(e){let{programId:t,owner:n,mintA:r,mintB:s,ammConfigId:i,initialPriceX64:o,extendMintAccount:u}=e,[l,c]=[new R(r.address),new R(s.address)],{publicKey:m}=Yi(t,i,l,c),{publicKey:p}=Zi(t,m),{publicKey:d}=xr(t,m,l),{publicKey:f}=xr(t,m,c),y=Be(t,m).publicKey,w=[this.createPoolInstruction(t,m,n,i,p,l,d,new R(r.programId||oe),c,f,new R(s.programId||oe),y,o,u)];return{signers:[],instructions:w,instructionTypes:[U.CreateAccount,U.ClmmCreatePool],address:{poolId:m,observationId:p,exBitmapAccount:y,mintAVault:d,mintBVault:f},lookupTableAddress:[]}}static openPositionFromLiquidityInstruction(e,t,n,r,s,i,o,u,l,c,m,p,d,f,y,w,g,A,T,h,P,k,S,x,K,B){let N=_([le("tickLowerIndex"),le("tickUpperIndex"),le("tickArrayLowerStartIndex"),le("tickArrayUpperStartIndex"),q("liquidity"),b("amountMaxA"),b("amountMaxB"),Te("withMetadata"),W("optionBaseFlag"),Te("baseFlag")]),M=[...B?[{pubkey:B,isSigner:!1,isWritable:!0}]:[]],C=[{pubkey:t,isSigner:!0,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!1},{pubkey:s,isSigner:!0,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:m,isSigner:!1,isWritable:!0},{pubkey:p,isSigner:!1,isWritable:!0},{pubkey:d,isSigner:!1,isWritable:!0},{pubkey:f,isSigner:!1,isWritable:!0},{pubkey:y,isSigner:!1,isWritable:!0},{pubkey:Qe,isSigner:!1,isWritable:!1},{pubkey:dt.programId,isSigner:!1,isWritable:!1},{pubkey:oe,isSigner:!1,isWritable:!1},{pubkey:kn,isSigner:!1,isWritable:!1},{pubkey:xt,isSigner:!1,isWritable:!1},{pubkey:ye,isSigner:!1,isWritable:!1},{pubkey:w,isSigner:!1,isWritable:!1},{pubkey:g,isSigner:!1,isWritable:!1},...M],E=Buffer.alloc(N.span);N.encode({tickLowerIndex:A,tickUpperIndex:T,tickArrayLowerStartIndex:h,tickArrayUpperStartIndex:P,liquidity:k,amountMaxA:S,amountMaxB:x,withMetadata:K==="create",baseFlag:!1,optionBaseFlag:0},E);let j=Buffer.from([...Fe.openPosition,...E]);return new Ie({keys:C,programId:e,data:j})}static openPositionFromLiquidityInstruction22(e,t,n,r,s,i,o,u,l,c,m,p,d,f,y,w,g,A,T,h,P,k,S,x,K){let B=_([le("tickLowerIndex"),le("tickUpperIndex"),le("tickArrayLowerStartIndex"),le("tickArrayUpperStartIndex"),q("liquidity"),b("amountMaxA"),b("amountMaxB"),Te("withMetadata"),W("optionBaseFlag"),Te("baseFlag")]),N=[...K?[{pubkey:K,isSigner:!1,isWritable:!0}]:[]],M=[{pubkey:t,isSigner:!0,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!1},{pubkey:s,isSigner:!0,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:m,isSigner:!1,isWritable:!0},{pubkey:p,isSigner:!1,isWritable:!0},{pubkey:d,isSigner:!1,isWritable:!0},{pubkey:f,isSigner:!1,isWritable:!0},{pubkey:Qe,isSigner:!1,isWritable:!1},{pubkey:dt.programId,isSigner:!1,isWritable:!1},{pubkey:oe,isSigner:!1,isWritable:!1},{pubkey:kn,isSigner:!1,isWritable:!1},{pubkey:ye,isSigner:!1,isWritable:!1},{pubkey:y,isSigner:!1,isWritable:!1},{pubkey:w,isSigner:!1,isWritable:!1},...N],C=Buffer.alloc(B.span);B.encode({tickLowerIndex:g,tickUpperIndex:A,tickArrayLowerStartIndex:T,tickArrayUpperStartIndex:h,liquidity:P,amountMaxA:k,amountMaxB:S,withMetadata:x==="create",baseFlag:!1,optionBaseFlag:0},C);let E=Buffer.from([...Fe.openPositionWithTokenEx,...C]);return new Ie({keys:M,programId:e,data:E})}static async openPositionInstructions({poolInfo:e,poolKeys:t,ownerInfo:n,tickLower:r,tickUpper:s,liquidity:i,amountMaxA:o,amountMaxB:u,withMetadata:l,getEphemeralSigners:c,nft2022:m}){let p=[],[d,f]=[new R(e.programId),new R(e.id)],y;if(c)y=new R((await c(1))[0]);else{let K=Fn.generate();p.push(K),y=K.publicKey}let w=O.getTickArrayStartIndexByTick(r,e.config.tickSpacing),g=O.getTickArrayStartIndexByTick(s,e.config.tickSpacing),{publicKey:A}=re(d,f,w),{publicKey:T}=re(d,f,g),{publicKey:h}=m?ue(n.wallet,y,ye):ue(n.wallet,y,oe),{publicKey:P}=bn(y),{publicKey:k}=We(d,y),{publicKey:S}=kt(d,f,r,s),x=m?this.openPositionFromLiquidityInstruction22(d,n.feePayer,f,n.wallet,y,h,S,A,T,k,n.tokenAccountA,n.tokenAccountB,new R(t.vault.A),new R(t.vault.B),new R(e.mintA.address),new R(e.mintB.address),r,s,w,g,i,o,u,l,Pe.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing,[w,g])?Be(d,f).publicKey:void 0):this.openPositionFromLiquidityInstruction(d,n.feePayer,f,n.wallet,y,h,P,S,A,T,k,n.tokenAccountA,n.tokenAccountB,new R(t.vault.A),new R(t.vault.B),new R(e.mintA.address),new R(e.mintB.address),r,s,w,g,i,o,u,l,Pe.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing,[w,g])?Be(d,f).publicKey:void 0);return{signers:p,instructions:[x],instructionTypes:[U.ClmmOpenPosition],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[],address:{nftMint:y,tickArrayLower:A,tickArrayUpper:T,positionNftAccount:h,metadataAccount:P,personalPosition:k,protocolPosition:S}}}static async openPositionFromBaseInstructions({poolInfo:e,poolKeys:t,ownerInfo:n,tickLower:r,tickUpper:s,base:i,baseAmount:o,otherAmountMax:u,withMetadata:l,getEphemeralSigners:c,nft2022:m}){let p=[],[d,f]=[new R(e.programId),new R(e.id)],y;if(c)y=new R((await c(1))[0]);else{let K=Fn.generate();p.push(K),y=K.publicKey}let w=O.getTickArrayStartIndexByTick(r,e.config.tickSpacing),g=O.getTickArrayStartIndexByTick(s,e.config.tickSpacing),{publicKey:A}=re(d,f,w),{publicKey:T}=re(d,f,g),{publicKey:h}=m?ue(n.wallet,y,ye):ue(n.wallet,y,oe),{publicKey:P}=bn(y),{publicKey:k}=We(d,y),{publicKey:S}=kt(d,f,r,s),x=m?this.openPositionFromBaseInstruction22(d,n.feePayer,f,n.wallet,y,h,S,A,T,k,n.tokenAccountA,n.tokenAccountB,new R(t.vault.A),new R(t.vault.B),new R(e.mintA.address),new R(e.mintB.address),r,s,w,g,l,i,o,u,Pe.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing,[w,g])?Be(d,f).publicKey:void 0):this.openPositionFromBaseInstruction(d,n.feePayer,f,n.wallet,y,h,P,S,A,T,k,n.tokenAccountA,n.tokenAccountB,new R(t.vault.A),new R(t.vault.B),new R(e.mintA.address),new R(e.mintB.address),r,s,w,g,l,i,o,u,Pe.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing,[w,g])?Be(d,f).publicKey:void 0);return{address:{nftMint:y,tickArrayLower:A,tickArrayUpper:T,positionNftAccount:h,metadataAccount:P,personalPosition:k,protocolPosition:S},instructions:[x],signers:p,instructionTypes:[U.ClmmOpenPosition],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[]}}static openPositionFromBaseInstruction(e,t,n,r,s,i,o,u,l,c,m,p,d,f,y,w,g,A,T,h,P,k,S,x,K,B){let N=_([le("tickLowerIndex"),le("tickUpperIndex"),le("tickArrayLowerStartIndex"),le("tickArrayUpperStartIndex"),q("liquidity"),b("amountMaxA"),b("amountMaxB"),Te("withMetadata"),W("optionBaseFlag"),Te("baseFlag")]),M=[...B?[{pubkey:B,isSigner:!1,isWritable:!0}]:[]],C=[{pubkey:t,isSigner:!0,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!1},{pubkey:s,isSigner:!0,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:m,isSigner:!1,isWritable:!0},{pubkey:p,isSigner:!1,isWritable:!0},{pubkey:d,isSigner:!1,isWritable:!0},{pubkey:f,isSigner:!1,isWritable:!0},{pubkey:y,isSigner:!1,isWritable:!0},{pubkey:Qe,isSigner:!1,isWritable:!1},{pubkey:dt.programId,isSigner:!1,isWritable:!1},{pubkey:oe,isSigner:!1,isWritable:!1},{pubkey:kn,isSigner:!1,isWritable:!1},{pubkey:xt,isSigner:!1,isWritable:!1},{pubkey:ye,isSigner:!1,isWritable:!1},{pubkey:w,isSigner:!1,isWritable:!1},{pubkey:g,isSigner:!1,isWritable:!1},...M],E=Buffer.alloc(N.span);N.encode({tickLowerIndex:A,tickUpperIndex:T,tickArrayLowerStartIndex:h,tickArrayUpperStartIndex:P,liquidity:new Rr(0),amountMaxA:S==="MintA"?x:K,amountMaxB:S==="MintA"?K:x,withMetadata:k==="create",baseFlag:S==="MintA",optionBaseFlag:1},E);let j=Buffer.from([...Fe.openPosition,...E]);return new Ie({keys:C,programId:e,data:j})}static openPositionFromBaseInstruction22(e,t,n,r,s,i,o,u,l,c,m,p,d,f,y,w,g,A,T,h,P,k,S,x,K){let B=_([le("tickLowerIndex"),le("tickUpperIndex"),le("tickArrayLowerStartIndex"),le("tickArrayUpperStartIndex"),q("liquidity"),b("amountMaxA"),b("amountMaxB"),Te("withMetadata"),W("optionBaseFlag"),Te("baseFlag")]),N=[...K?[{pubkey:K,isSigner:!1,isWritable:!0}]:[]],M=[{pubkey:t,isSigner:!0,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!1},{pubkey:s,isSigner:!0,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:m,isSigner:!1,isWritable:!0},{pubkey:p,isSigner:!1,isWritable:!0},{pubkey:d,isSigner:!1,isWritable:!0},{pubkey:f,isSigner:!1,isWritable:!0},{pubkey:Qe,isSigner:!1,isWritable:!1},{pubkey:dt.programId,isSigner:!1,isWritable:!1},{pubkey:oe,isSigner:!1,isWritable:!1},{pubkey:kn,isSigner:!1,isWritable:!1},{pubkey:ye,isSigner:!1,isWritable:!1},{pubkey:y,isSigner:!1,isWritable:!1},{pubkey:w,isSigner:!1,isWritable:!1},...N],C=Buffer.alloc(B.span);B.encode({tickLowerIndex:g,tickUpperIndex:A,tickArrayLowerStartIndex:T,tickArrayUpperStartIndex:h,liquidity:new Rr(0),amountMaxA:k==="MintA"?S:x,amountMaxB:k==="MintA"?x:S,withMetadata:P==="create",baseFlag:k==="MintA",optionBaseFlag:1},C);let E=Buffer.from([...Fe.openPositionWithTokenEx,...C]);return new Ie({keys:M,programId:e,data:E})}static async openPositionFromLiquidityInstructions({poolInfo:e,poolKeys:t,ownerInfo:n,tickLower:r,tickUpper:s,liquidity:i,amountMaxA:o,amountMaxB:u,withMetadata:l,getEphemeralSigners:c,nft2022:m}){let p,d=[];if(c)p=new R((await c(1))[0]);else{let K=Fn.generate();d.push(K),p=K.publicKey}let[f,y]=[new R(e.programId),new R(e.id)],w=O.getTickArrayStartIndexByTick(r,e.config.tickSpacing),g=O.getTickArrayStartIndexByTick(s,e.config.tickSpacing),{publicKey:A}=re(f,y,w),{publicKey:T}=re(f,y,g),{publicKey:h}=m?ue(n.wallet,p,ye):ue(n.wallet,p,oe),{publicKey:P}=bn(p),{publicKey:k}=We(f,p),{publicKey:S}=kt(f,y,r,s),x=m?this.openPositionFromLiquidityInstruction22(f,n.wallet,y,n.wallet,p,h,S,A,T,k,n.tokenAccountA,n.tokenAccountB,new R(t.vault.A),new R(t.vault.B),new R(t.mintA.address),new R(t.mintB.address),r,s,w,g,i,o,u,l,Pe.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing,[w,g])?Be(f,y).publicKey:void 0):this.openPositionFromLiquidityInstruction(f,n.wallet,y,n.wallet,p,h,P,S,A,T,k,n.tokenAccountA,n.tokenAccountB,new R(t.vault.A),new R(t.vault.B),new R(t.mintA.address),new R(t.mintB.address),r,s,w,g,i,o,u,l,Pe.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing,[w,g])?Be(f,y).publicKey:void 0);return{address:{nftMint:p,tickArrayLower:A,tickArrayUpper:T,positionNftAccount:h,metadataAccount:P,personalPosition:k,protocolPosition:S},instructions:[x],signers:d,instructionTypes:[U.ClmmOpenPosition],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[]}}static closePositionInstruction(e,t,n,r,s,i){let o=_([]),u=[{pubkey:t,isSigner:!0,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:dt.programId,isSigner:!1,isWritable:!1},{pubkey:i?ye:oe,isSigner:!1,isWritable:!1}],l=Buffer.alloc(o.span);o.encode({},l);let c=Buffer.from([...Fe.closePosition,...l]);return new Ie({keys:u,programId:e,data:c})}static closePositionInstructions({poolInfo:e,poolKeys:t,ownerInfo:n,ownerPosition:r,nft2022:s}){let i=new R(e.programId),o=s?ue(n.wallet,r.nftMint,ye).publicKey:ue(n.wallet,r.nftMint,oe).publicKey,{publicKey:u}=We(i,r.nftMint),l=[];return l.push(this.closePositionInstruction(i,n.wallet,r.nftMint,o,u,s)),{address:{positionNftAccount:o,personalPosition:u},signers:[],instructions:l,instructionTypes:[U.ClmmClosePosition],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[]}}static increasePositionFromLiquidityInstruction(e,t,n,r,s,i,o,u,l,c,m,p,d,f,y,w,g,A){let T=_([q("liquidity"),b("amountMaxA"),b("amountMaxB"),W("optionBaseFlag"),Te("baseFlag")]),h=[...A?[{pubkey:A,isSigner:!1,isWritable:!0}]:[]],P=[{pubkey:t,isSigner:!0,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:m,isSigner:!1,isWritable:!0},{pubkey:p,isSigner:!1,isWritable:!0},{pubkey:oe,isSigner:!1,isWritable:!1},{pubkey:ye,isSigner:!1,isWritable:!1},{pubkey:d,isSigner:!1,isWritable:!1},{pubkey:f,isSigner:!1,isWritable:!1},...h],k=Buffer.alloc(T.span);T.encode({liquidity:y,amountMaxA:w,amountMaxB:g,optionBaseFlag:0,baseFlag:!1},k);let S=Buffer.from([...Fe.increaseLiquidity,...k]);return new Ie({keys:P,programId:e,data:S})}static increasePositionFromLiquidityInstructions({poolInfo:e,poolKeys:t,ownerPosition:n,ownerInfo:r,liquidity:s,amountMaxA:i,amountMaxB:o,nft2022:u}){let[l,c]=[new R(e.programId),new R(e.id)],m=O.getTickArrayStartIndexByTick(n.tickLower,e.config.tickSpacing),p=O.getTickArrayStartIndexByTick(n.tickUpper,e.config.tickSpacing),{publicKey:d}=re(l,c,m),{publicKey:f}=re(l,c,p),{publicKey:y}=u?ue(r.wallet,n.nftMint,ye):ue(r.wallet,n.nftMint,oe),{publicKey:w}=We(l,n.nftMint),{publicKey:g}=kt(l,c,n.tickLower,n.tickUpper),A=this.increasePositionFromLiquidityInstruction(l,r.wallet,y,w,c,g,d,f,r.tokenAccountA,r.tokenAccountB,new R(t.vault.A),new R(t.vault.B),new R(e.mintA.address),new R(e.mintB.address),s,i,o,Pe.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing,[m,p])?Be(l,c).publicKey:void 0);return{address:{tickArrayLower:d,tickArrayUpper:f,positionNftAccount:y,personalPosition:w,protocolPosition:g},signers:[],instructions:[A],instructionTypes:[U.ClmmIncreasePosition],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[]}}static increasePositionFromBaseInstructions({poolInfo:e,poolKeys:t,ownerPosition:n,ownerInfo:r,base:s,baseAmount:i,otherAmountMax:o,nft2022:u}){let[l,c]=[new R(e.programId),new R(e.id)],m=O.getTickArrayStartIndexByTick(n.tickLower,e.config.tickSpacing),p=O.getTickArrayStartIndexByTick(n.tickUpper,e.config.tickSpacing),{publicKey:d}=re(l,c,m),{publicKey:f}=re(l,c,p),{publicKey:y}=u?ue(r.wallet,n.nftMint,ye):ue(r.wallet,n.nftMint,oe),{publicKey:w}=We(l,n.nftMint),{publicKey:g}=kt(l,c,n.tickLower,n.tickUpper);return{address:{tickArrayLower:d,tickArrayUpper:f,positionNftAccount:y,personalPosition:w,protocolPosition:g},instructions:[this.increasePositionFromBaseInstruction(l,r.wallet,y,w,c,g,d,f,r.tokenAccountA,r.tokenAccountB,new R(t.vault.A),new R(t.vault.B),new R(e.mintA.address),new R(e.mintB.address),s,i,o,Pe.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing,[m,p])?Be(l,c).publicKey:void 0)],signers:[],instructionTypes:[U.ClmmIncreasePosition],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[]}}static increasePositionFromBaseInstruction(e,t,n,r,s,i,o,u,l,c,m,p,d,f,y,w,g,A){let T=_([q("liquidity"),b("amountMaxA"),b("amountMaxB"),W("optionBaseFlag"),Te("baseFlag")]),h=[...A?[{pubkey:A,isSigner:!1,isWritable:!0}]:[]],P=[{pubkey:t,isSigner:!0,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:m,isSigner:!1,isWritable:!0},{pubkey:p,isSigner:!1,isWritable:!0},{pubkey:oe,isSigner:!1,isWritable:!1},{pubkey:ye,isSigner:!1,isWritable:!1},{pubkey:d,isSigner:!1,isWritable:!1},{pubkey:f,isSigner:!1,isWritable:!1},...h],k=Buffer.alloc(T.span);T.encode({liquidity:new Rr(0),amountMaxA:y==="MintA"?w:g,amountMaxB:y==="MintA"?g:w,baseFlag:y==="MintA",optionBaseFlag:1},k);let S=Buffer.from([...Fe.increaseLiquidity,...k]);return new Ie({keys:P,programId:e,data:S})}static decreaseLiquidityInstruction(e,t,n,r,s,i,o,u,l,c,m,p,d,f,y,w,g,A,T){let h=_([q("liquidity"),b("amountMinA"),b("amountMinB")]),P=[...T?[{pubkey:T,isSigner:!1,isWritable:!0}]:[],...y.map(K=>[{pubkey:K.poolRewardVault,isSigner:!1,isWritable:!0},{pubkey:K.ownerRewardVault,isSigner:!1,isWritable:!0},{pubkey:K.rewardMint,isSigner:!1,isWritable:!1}]).flat()],k=[{pubkey:t,isSigner:!0,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:m,isSigner:!1,isWritable:!0},{pubkey:p,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:oe,isSigner:!1,isWritable:!1},{pubkey:ye,isSigner:!1,isWritable:!1},{pubkey:Bn,isSigner:!1,isWritable:!1},{pubkey:d,isSigner:!1,isWritable:!1},{pubkey:f,isSigner:!1,isWritable:!1},...P],S=Buffer.alloc(h.span);h.encode({liquidity:w,amountMinA:g,amountMinB:A},S);let x=Buffer.from([...Fe.decreaseLiquidity,...S]);return new Ie({keys:k,programId:e,data:x})}static decreaseLiquidityInstructions({poolInfo:e,poolKeys:t,ownerPosition:n,ownerInfo:r,liquidity:s,amountMinA:i,amountMinB:o,programId:u,nft2022:l}){let[c,m]=[new R(e.programId),new R(e.id)],p=O.getTickArrayStartIndexByTick(n.tickLower,e.config.tickSpacing),d=O.getTickArrayStartIndexByTick(n.tickUpper,e.config.tickSpacing),{publicKey:f}=re(c,m,p),{publicKey:y}=re(c,m,d),{publicKey:w}=l?ue(r.wallet,n.nftMint,ye):ue(r.wallet,n.nftMint,u),{publicKey:g}=We(c,n.nftMint),{publicKey:A}=kt(c,m,n.tickLower,n.tickUpper),T=[];for(let k=0;k<e.rewardDefaultInfos.length;k++)T.push({poolRewardVault:new R(t.rewardInfos[k].vault),ownerRewardVault:r.rewardAccounts[k],rewardMint:new R(e.rewardDefaultInfos[k].mint.address)});let h=[],P=this.decreaseLiquidityInstruction(c,r.wallet,w,g,m,A,f,y,r.tokenAccountA,r.tokenAccountB,new R(t.vault.A),new R(t.vault.B),new R(e.mintA.address),new R(e.mintB.address),T,s,i,o,Pe.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing,[p,d])?Be(c,m).publicKey:void 0);return h.push(P),{address:{tickArrayLower:f,tickArrayUpper:y,positionNftAccount:w,personalPosition:g,protocolPosition:A},signers:[],instructions:h,instructionTypes:[U.ClmmDecreasePosition],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[]}}static swapInstruction(e,t,n,r,s,i,o,u,l,c,m,p,d,f,y,w,g){let A=_([b("amount"),b("otherAmountThreshold"),q("sqrtPriceLimitX64"),Te("isBaseInput")]),T=[...g?[{pubkey:g,isSigner:!1,isWritable:!0}]:[],...m.map(S=>({pubkey:S,isSigner:!1,isWritable:!0}))],h=[{pubkey:t,isSigner:!0,isWritable:!1},{pubkey:r,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:p,isSigner:!1,isWritable:!0},{pubkey:oe,isSigner:!1,isWritable:!1},{pubkey:ye,isSigner:!1,isWritable:!1},{pubkey:Bn,isSigner:!1,isWritable:!1},{pubkey:l,isSigner:!1,isWritable:!1},{pubkey:c,isSigner:!1,isWritable:!1},...T],P=Buffer.alloc(A.span);A.encode({amount:d,otherAmountThreshold:f,sqrtPriceLimitX64:y,isBaseInput:w},P);let k=Buffer.from([...Fe.swap,...P]);return new Ie({keys:h,programId:e,data:k})}static makeSwapBaseInInstructions({poolInfo:e,poolKeys:t,observationId:n,ownerInfo:r,inputMint:s,amountIn:i,amountOutMin:o,sqrtPriceLimitX64:u,remainingAccounts:l}){let[c,m]=[new R(e.programId),new R(e.id)],[p,d]=[new R(t.vault.A),new R(t.vault.B)],[f,y]=[new R(e.mintA.address),new R(e.mintB.address)],w=e.mintA.address===s.toString(),g=[this.swapInstruction(c,r.wallet,m,new R(e.config.id),w?r.tokenAccountA:r.tokenAccountB,w?r.tokenAccountB:r.tokenAccountA,w?p:d,w?d:p,w?f:y,w?y:f,l,n,i,o,u,!0,Be(c,m).publicKey)];return{signers:[],instructions:g,instructionTypes:[U.ClmmSwapBaseIn],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[],address:{}}}static makeSwapBaseOutInstructions({poolInfo:e,poolKeys:t,observationId:n,ownerInfo:r,outputMint:s,amountOut:i,amountInMax:o,sqrtPriceLimitX64:u,remainingAccounts:l}){let[c,m]=[new R(e.programId),new R(e.id)],[p,d]=[new R(t.vault.A),new R(t.vault.B)],[f,y]=[new R(e.mintA.address),new R(e.mintB.address)],w=e.mintA.address===s.toBase58(),g=[this.swapInstruction(c,r.wallet,m,new R(e.config.id),w?r.tokenAccountB:r.tokenAccountA,w?r.tokenAccountA:r.tokenAccountB,w?d:p,w?p:d,w?y:f,w?f:y,l,n,i,o,u,!1,Be(c,m).publicKey)];return{signers:[],instructions:g,instructionTypes:[U.ClmmSwapBaseOut],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[],address:{}}}static initRewardInstruction(e,t,n,r,s,i,o,u,l,c,m,p){let d=_([b("openTime"),b("endTime"),q("emissionsPerSecondX64")]),f=[{pubkey:t,isSigner:!0,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!1},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:dt.programId,isSigner:!1,isWritable:!1},{pubkey:Qe,isSigner:!1,isWritable:!1}],y=Buffer.alloc(d.span);d.encode({openTime:$(c),endTime:$(m),emissionsPerSecondX64:p},y);let w=Buffer.from([...Fe.initReward,...y]);return new Ie({keys:f,programId:e,data:w})}static initRewardInstructions({poolInfo:e,poolKeys:t,ownerInfo:n,rewardInfo:r}){let[s,i]=[new R(e.programId),new R(e.id)],o=ji(s,i,r.mint).publicKey,u=Sr(s).publicKey,l=[this.initRewardInstruction(s,n.wallet,i,u,new R(e.config.id),n.tokenAccount,r.programId,r.mint,o,r.openTime,r.endTime,r.emissionsPerSecondX64)];return{address:{poolRewardVault:o,operationId:u},signers:[],instructions:l,instructionTypes:[U.ClmmInitReward],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[]}}static setRewardInstruction(e,t,n,r,s,i,o,u,l,c,m,p){let d=_([W("rewardIndex"),q("emissionsPerSecondX64"),b("openTime"),b("endTime")]),f=[{pubkey:t,isSigner:!0,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:oe,isSigner:!1,isWritable:!1},{pubkey:ye,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0}],y=Buffer.alloc(d.span);d.encode({rewardIndex:l,emissionsPerSecondX64:p,openTime:$(c),endTime:$(m)},y);let w=Buffer.from([...Fe.setRewardEmissions,...y]);return new Ie({keys:f,programId:e,data:w})}static setRewardInstructions({poolInfo:e,poolKeys:t,ownerInfo:n,rewardInfo:r}){let[s,i]=[new R(e.programId),new R(e.id)],o,u,l;for(let p=0;p<e.rewardDefaultInfos.length;p++)e.rewardDefaultInfos[p].mint.address===r.mint.toString()&&(o=p,u=new R(t.rewardInfos[p].vault),l=new R(t.rewardInfos[p].mint.address));(o===void 0||u===void 0)&&oo.logWithError("reward mint check error","no reward mint",e.rewardDefaultInfos);let c=Sr(s).publicKey,m=[this.setRewardInstruction(s,n.wallet,i,c,new R(e.config.id),n.tokenAccount,u,l,o,r.openTime,r.endTime,r.emissionsPerSecondX64)];return{address:{rewardVault:u,operationId:c},signers:[],instructions:m,instructionTypes:[U.ClmmSetReward],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[]}}static collectRewardInstruction(e,t,n,r,s,i,o){let u=_([W("rewardIndex")]),l=[{pubkey:t,isSigner:!0,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!1},{pubkey:oe,isSigner:!1,isWritable:!1},{pubkey:ye,isSigner:!1,isWritable:!1},{pubkey:Bn,isSigner:!1,isWritable:!1}],c=Buffer.alloc(u.span);u.encode({rewardIndex:o},c);let m=Buffer.from([...Fe.collectReward,...c]);return new Ie({keys:l,programId:e,data:m})}static collectRewardInstructions({poolInfo:e,poolKeys:t,ownerInfo:n,rewardMint:r}){let[s,i]=[new R(e.programId),new R(e.id)],o,u;for(let c=0;c<e.rewardDefaultInfos.length;c++)e.rewardDefaultInfos[c].mint.address===r.toString()&&(o=c,u=new R(t.rewardInfos[c].vault));(o===void 0||u===void 0)&&oo.logWithError("reward mint check error","no reward mint",e.rewardDefaultInfos);let l=[this.collectRewardInstruction(s,n.wallet,i,n.tokenAccount,u,r,o)];return{address:{rewardVault:u},signers:[],instructions:l,instructionTypes:[U.ClmmCollectReward],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[]}}static async makeLockPositions({programId:e,authProgramId:t,poolProgramId:n,payer:r,wallet:s,nftMint:i,nft2022:o,getEphemeralSigners:u}){let l=[],c;if(u)c=new R((await u(1))[0]);else{let g=Fn.generate();l.push(g),c=g.publicKey}let m=o?ue(s,i,ye).publicKey:ue(s,i,oe).publicKey,{publicKey:p}=We(n,i),d=Ji(e,c).publicKey,f=ue(s,c,oe).publicKey,y=bn(c).publicKey,w=Zt.lockPositionInstructionV2({programId:e,auth:t,payer:r,positionOwner:s,lockOwner:s,positionNftAccount:m,positionId:p,lockPositionId:d,lockNftMint:c,lockNftAccount:f,metadataAccount:y,withMetadata:!0,nft2022:o,positionNftMint:i,authPositionNftAccount:ue(t,i,o?ye:oe).publicKey,positionNftProgram:o?ye:oe});return{address:{positionId:p,lockPositionId:d,lockNftAccount:f,lockNftMint:c,positionNftAccount:m,metadataAccount:y},instructions:[w],signers:l,instructionTypes:[U.ClmmLockPosition],lookupTableAddress:[]}}static lockPositionInstructionV2({programId:e,auth:t,payer:n,positionOwner:r,lockOwner:s,positionNftAccount:i,positionId:o,positionNftMint:u,authPositionNftAccount:l,positionNftProgram:c,lockPositionId:m,lockNftMint:p,lockNftAccount:d,metadataAccount:f,withMetadata:y}){let w=[{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!0,isWritable:!0},{pubkey:r,isSigner:!0,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!1},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:m,isSigner:!1,isWritable:!0},{pubkey:p,isSigner:!0,isWritable:!0},{pubkey:d,isSigner:!1,isWritable:!0},{pubkey:f,isSigner:!1,isWritable:!0},{pubkey:xt,isSigner:!1,isWritable:!1},{pubkey:kn,isSigner:!1,isWritable:!1},{pubkey:Qe,isSigner:!1,isWritable:!1},{pubkey:oe,isSigner:!1,isWritable:!1},{pubkey:c,isSigner:!1,isWritable:!1},{pubkey:dt.programId,isSigner:!1,isWritable:!1}],g=_([Te("withMetadata")]),A=Buffer.alloc(g.span);g.encode({withMetadata:y},A);let T=Buffer.from([...so,...A]);return new Ie({keys:w,programId:e,data:T})}static lockPositionInstruction({programId:e,authProgramId:t,poolProgramId:n,owner:r,positionNft:s}){let{publicKey:i}=ue(r,s,oe),{publicKey:o}=We(n,s),u=[{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!0,isWritable:!1},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:Br(e,o).publicKey,isSigner:!1,isWritable:!0},{pubkey:oe,isSigner:!1,isWritable:!1},{pubkey:dt.programId,isSigner:!1,isWritable:!1}];return new Ie({keys:u,programId:e,data:Buffer.from(so)})}static harvestLockPositionInstruction(e){let[t,n]=[new R(e.poolKeys.programId),new R(e.poolKeys.id)],r=O.getTickArrayStartIndexByTick(e.ownerPosition.tickLower,e.poolKeys.config.tickSpacing),s=O.getTickArrayStartIndexByTick(e.ownerPosition.tickUpper,e.poolKeys.config.tickSpacing),{publicKey:i}=re(t,n,r),{publicKey:o}=re(t,n,s),{publicKey:u}=ue(e.owner,e.ownerPosition.nftMint,oe),{publicKey:l}=We(t,e.ownerPosition.nftMint),{publicKey:c}=kt(t,n,e.ownerPosition.tickLower,e.ownerPosition.tickUpper),m=[];for(let f=0;f<e.poolKeys.rewardInfos.length;f++)m.push({poolRewardVault:new R(e.poolKeys.rewardInfos[f].vault),ownerRewardVault:e.ownerRewardAccounts[f],rewardMint:new R(e.poolKeys.rewardInfos[f].mint.address)});let p=[...m.map(f=>[{pubkey:f.poolRewardVault,isSigner:!1,isWritable:!0},{pubkey:f.ownerRewardVault,isSigner:!1,isWritable:!0},{pubkey:f.rewardMint,isSigner:!1,isWritable:!1}]).flat()],d=[{pubkey:e.authProgramId,isSigner:!1,isWritable:!1},{pubkey:Br(e.programId,l).publicKey,isSigner:!1,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:e.owner,isSigner:!0,isWritable:!1},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:new R(e.poolKeys.vault.A),isSigner:!1,isWritable:!0},{pubkey:new R(e.poolKeys.vault.B),isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:e.userVaultA,isSigner:!1,isWritable:!0},{pubkey:e.userVaultB,isSigner:!1,isWritable:!0},{pubkey:oe,isSigner:!1,isWritable:!1},{pubkey:ye,isSigner:!1,isWritable:!1},{pubkey:nr,isSigner:!1,isWritable:!1},{pubkey:new R(e.poolKeys.mintA.address),isSigner:!1,isWritable:!1},{pubkey:new R(e.poolKeys.mintB.address),isSigner:!1,isWritable:!1},...p];return new Ie({keys:d,programId:e.programId,data:Buffer.from(ao)})}static harvestLockPositionInstructionV2({programId:e,auth:t,lockPositionId:n,clmmProgram:r,lockOwner:s,lockNftMint:i,lockNftAccount:o,positionNftAccount:u,positionId:l,poolId:c,protocolPosition:m,vaultA:p,vaultB:d,tickArrayLower:f,tickArrayUpper:y,userVaultA:w,userVaultB:g,mintA:A,mintB:T,rewardAccounts:h,exTickArrayBitmap:P}){let k=[...P?[{pubkey:P,isSigner:!1,isWritable:!0}]:[],...h.map(x=>[{pubkey:x.poolRewardVault,isSigner:!1,isWritable:!0},{pubkey:x.ownerRewardVault,isSigner:!1,isWritable:!0},{pubkey:x.rewardMint,isSigner:!1,isWritable:!1}]).flat()],S=[{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:s,isSigner:!0,isWritable:!1},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!1,isWritable:!1},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:m,isSigner:!1,isWritable:!0},{pubkey:p,isSigner:!1,isWritable:!0},{pubkey:d,isSigner:!1,isWritable:!0},{pubkey:f,isSigner:!1,isWritable:!0},{pubkey:y,isSigner:!1,isWritable:!0},{pubkey:w,isSigner:!1,isWritable:!0},{pubkey:g,isSigner:!1,isWritable:!0},{pubkey:oe,isSigner:!1,isWritable:!1},{pubkey:ye,isSigner:!1,isWritable:!1},{pubkey:nr,isSigner:!1,isWritable:!1},{pubkey:A,isSigner:!1,isWritable:!1},{pubkey:T,isSigner:!1,isWritable:!1},...k];return new Ie({keys:S,programId:e,data:Buffer.from(ao)})}};var Cr=(...a)=>a.map(e=>{try{return typeof e=="object"?JSON.stringify(e):e}catch{return e}}).join(", "),$t=class{constructor({scope:e,moduleName:t}){this.disabled=!1;this.scope=e,this.logger=ie(t)}createTxBuilder(e){return this.scope.checkOwner(),new dn({connection:this.scope.connection,feePayer:e||this.scope.ownerPubKey,cluster:this.scope.cluster,owner:this.scope.owner,blockhashCommitment:this.scope.blockhashCommitment,loopMultiTxStatus:this.scope.loopMultiTxStatus,api:this.scope.api,signAllTransactions:this.scope.signAllTransactions})}createSniperTxBuilder(e,t){let n=new Ze(e);return new dn({connection:this.scope.connection,feePayer:t,cluster:this.scope.cluster,owner:n,blockhashCommitment:this.scope.blockhashCommitment,loopMultiTxStatus:this.scope.loopMultiTxStatus,api:this.scope.api,signAllTransactions:this.scope.signAllTransactions})}logDebug(...e){this.logger.debug(Cr(e))}logInfo(...e){this.logger.info(Cr(e))}logAndCreateError(...e){let t=Cr(e);throw new Error(t)}checkDisabled(){(this.disabled||!this.scope)&&this.logAndCreateError("module not working")}};var la=_([Ce("mintAuthorityOption"),L("mintAuthority"),b("supply"),W("decimals"),W("isInitialized"),Ce("freezeAuthorityOption"),L("freezeAuthority")]);import{PublicKey as Wb}from"@solana/web3.js";import{MintLayout as Fb,TOKEN_PROGRAM_ID as qb}from"@solana/spl-token";var uo=a=>new Re({mint:a.address,decimals:a.decimals,symbol:a.symbol,name:a.name});var Dn=r=>{var s=r,{address:a,programId:e,decimals:t}=s,n=ve(s,["address","programId","decimals"]);return F({chainId:101,address:Xt(a).toBase58(),programId:e,logoURI:"",symbol:"",name:"",decimals:t,tags:[],extensions:n.extensions||{}},n)};import co from"bn.js";var Nr=new co(25),qn=new co(1e4);import{PublicKey as tt,SystemProgram as da,SYSVAR_RENT_PUBKEY as ay,TransactionInstruction as Jt}from"@solana/web3.js";import{ASSOCIATED_TOKEN_PROGRAM_ID as pa,TOKEN_PROGRAM_ID as Pn}from"@solana/spl-token";var Mr=_([W("instruction"),b("amountIn"),b("minAmountOut")]),_r=_([W("instruction"),b("maxAmountIn"),b("amountOut")]),ry=_([W("instruction"),W("nonce")]),ma=_([W("instruction"),W("nonce"),b("startTime")]),Vr=_([b("status"),b("nonce"),b("maxOrder"),b("depth"),b("baseDecimal"),b("quoteDecimal"),b("state"),b("resetFlag"),b("minSize"),b("volMaxCutRatio"),b("amountWaveRatio"),b("baseLotSize"),b("quoteLotSize"),b("minPriceMultiplier"),b("maxPriceMultiplier"),b("systemDecimalValue"),b("minSeparateNumerator"),b("minSeparateDenominator"),b("tradeFeeNumerator"),b("tradeFeeDenominator"),b("pnlNumerator"),b("pnlDenominator"),b("swapFeeNumerator"),b("swapFeeDenominator"),b("baseNeedTakePnl"),b("quoteNeedTakePnl"),b("quoteTotalPnl"),b("baseTotalPnl"),b("poolOpenTime"),b("punishPcAmount"),b("punishCoinAmount"),b("orderbookToInitTime"),q("swapBaseInAmount"),q("swapQuoteOutAmount"),b("swapBase2QuoteFee"),q("swapQuoteInAmount"),q("swapBaseOutAmount"),b("swapQuote2BaseFee"),L("baseVault"),L("quoteVault"),L("baseMint"),L("quoteMint"),L("lpMint"),L("openOrders"),L("marketId"),L("marketProgramId"),L("targetOrders"),L("withdrawQueue"),L("lpVault"),L("owner"),b("lpReserve"),G(b(),3,"padding")]),iy=_([b("accountType"),b("status"),b("nonce"),b("maxOrder"),b("depth"),b("baseDecimal"),b("quoteDecimal"),b("state"),b("resetFlag"),b("minSize"),b("volMaxCutRatio"),b("amountWaveRatio"),b("baseLotSize"),b("quoteLotSize"),b("minPriceMultiplier"),b("maxPriceMultiplier"),b("systemDecimalsValue"),b("abortTradeFactor"),b("priceTickMultiplier"),b("priceTick"),b("minSeparateNumerator"),b("minSeparateDenominator"),b("tradeFeeNumerator"),b("tradeFeeDenominator"),b("pnlNumerator"),b("pnlDenominator"),b("swapFeeNumerator"),b("swapFeeDenominator"),b("baseNeedTakePnl"),b("quoteNeedTakePnl"),b("quoteTotalPnl"),b("baseTotalPnl"),b("poolOpenTime"),b("punishPcAmount"),b("punishCoinAmount"),b("orderbookToInitTime"),q("swapBaseInAmount"),q("swapQuoteOutAmount"),q("swapQuoteInAmount"),q("swapBaseOutAmount"),b("swapQuote2BaseFee"),b("swapBase2QuoteFee"),L("baseVault"),L("quoteVault"),L("baseMint"),L("quoteMint"),L("lpMint"),L("modelDataAccount"),L("openOrders"),L("marketId"),L("marketProgramId"),L("targetOrders"),L("owner"),G(b(),64,"padding")]),vr=_([W("instruction"),b("baseAmountIn"),b("quoteAmountIn"),b("fixedSide"),b("otherAmountMin")]),Er=_([W("instruction"),b("lpAmount"),b("baseAmountMin"),b("quoteAmountMin")]);var lo=_([b("fee")]);var mo=ie("Raydium_liquidity_instruction");function po(a){let{poolInfo:e,poolKeys:t,userKeys:n,baseAmountIn:r,quoteAmountIn:s,fixedSide:i,otherAmountMin:o,modelDataPubKey:u=Bt}=a,l=Buffer.alloc(vr.span);vr.encode({instruction:3,baseAmountIn:$(r),quoteAmountIn:$(s),otherAmountMin:$(o),fixedSide:i==="base"?bt:li},l);let c=[I({pubkey:Pn,isWritable:!1}),I({pubkey:new tt(e.id)}),I({pubkey:new tt(t.authority),isWritable:!1}),I({pubkey:new tt(t.openOrders),isWritable:!1}),I({pubkey:new tt(t.targetOrders)}),I({pubkey:new tt(e.lpMint.address)}),I({pubkey:new tt(t.vault.A)}),I({pubkey:new tt(t.vault.B)})];return e.pooltype.includes("StablePool")&&c.push(I({pubkey:u})),c.push(I({pubkey:new tt(e.marketId),isWritable:!1}),I({pubkey:n.baseTokenAccount}),I({pubkey:n.quoteTokenAccount}),I({pubkey:n.lpTokenAccount}),I({pubkey:n.owner,isWritable:!1,isSigner:!0}),I({pubkey:new tt(t.marketEventQueue),isWritable:!1})),new Jt({programId:new tt(e.programId),keys:c,data:l})}function Wr(a){let{poolInfo:e,poolKeys:t,userKeys:n,lpAmount:r,baseAmountMin:s,quoteAmountMin:i,modelDataPubKey:o=Bt}=a,u=Lt(t),l=4;if(e.pooltype.includes("StablePool")&&(l=5),l===4||l===5){let c=Buffer.alloc(Er.span);Er.encode({instruction:4,lpAmount:$(r),baseAmountMin:$(s),quoteAmountMin:$(i)},c);let m=[I({pubkey:Pn,isWritable:!1}),I({pubkey:u.id}),I({pubkey:u.authority,isWritable:!1}),I({pubkey:u.openOrders}),I({pubkey:u.targetOrders}),I({pubkey:u.mintLp.address}),I({pubkey:u.vault.A}),I({pubkey:u.vault.B})];return l===5?m.push(I({pubkey:o})):(m.push(I({pubkey:u.id})),m.push(I({pubkey:u.id}))),m.push(I({pubkey:u.marketProgramId,isWritable:!1}),I({pubkey:u.marketId}),I({pubkey:u.marketBaseVault}),I({pubkey:u.marketQuoteVault}),I({pubkey:u.marketAuthority,isWritable:!1}),I({pubkey:n.lpTokenAccount}),I({pubkey:n.baseTokenAccount}),I({pubkey:n.quoteTokenAccount}),I({pubkey:n.owner,isWritable:!1,isSigner:!0}),I({pubkey:u.marketEventQueue}),I({pubkey:u.marketBids}),I({pubkey:u.marketAsks})),new Jt({programId:u.programId,keys:m,data:c})}return new Jt({programId:u.programId,keys:[]})}function Or({programId:a,ammId:e,ammAuthority:t,ammOpenOrders:n,lpMint:r,coinMint:s,pcMint:i,coinVault:o,pcVault:u,withdrawQueue:l,ammTargetOrders:c,poolTempLp:m,marketProgramId:p,marketId:d,userWallet:f,userCoinVault:y,userPcVault:w,userLpVault:g,nonce:A,openTime:T,coinAmount:h,pcAmount:P,ammConfigId:k,feeDestinationId:S}){let x=_([W("instruction"),W("nonce"),b("openTime"),b("pcAmount"),b("coinAmount")]),K=[{pubkey:Pn,isSigner:!1,isWritable:!1},{pubkey:pa,isSigner:!1,isWritable:!1},{pubkey:da.programId,isSigner:!1,isWritable:!1},{pubkey:Qe,isSigner:!1,isWritable:!1},{pubkey:e,isSigner:!1,isWritable:!0},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!1},{pubkey:i,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:k,isSigner:!1,isWritable:!1},{pubkey:S,isSigner:!1,isWritable:!0},{pubkey:p,isSigner:!1,isWritable:!1},{pubkey:d,isSigner:!1,isWritable:!1},{pubkey:f,isSigner:!0,isWritable:!0},{pubkey:y,isSigner:!1,isWritable:!0},{pubkey:w,isSigner:!1,isWritable:!0},{pubkey:g,isSigner:!1,isWritable:!0}],B=Buffer.alloc(x.span);return x.encode({instruction:1,nonce:A,openTime:T,coinAmount:h,pcAmount:P},B),{instruction:new Jt({keys:K,programId:a,data:B}),instructionType:U.AmmV4CreatePool}}function fa({poolKeys:a,userKeys:e,amountIn:t,minAmountOut:n,modelDataPubKey:r=Bt},s){let i=Lt(a),o=Buffer.alloc(Mr.span);Mr.encode({instruction:9,amountIn:$(t),minAmountOut:$(n)},o);let u=[I({pubkey:Pn,isWritable:!1}),I({pubkey:i.id}),I({pubkey:i.authority,isWritable:!1}),I({pubkey:i.openOrders})];return s===4&&u.push(I({pubkey:i.targetOrders})),u.push(I({pubkey:i.vault.A}),I({pubkey:i.vault.B})),s===5&&u.push(I({pubkey:r})),u.push(I({pubkey:i.marketProgramId,isWritable:!1}),I({pubkey:i.marketId}),I({pubkey:i.marketBids}),I({pubkey:i.marketAsks}),I({pubkey:i.marketEventQueue}),I({pubkey:i.marketBaseVault}),I({pubkey:i.marketQuoteVault}),I({pubkey:i.marketAuthority,isWritable:!1}),I({pubkey:e.tokenAccountIn}),I({pubkey:e.tokenAccountOut}),I({pubkey:e.owner,isWritable:!1,isSigner:!0})),new Jt({programId:i.programId,keys:u,data:o})}function ba({poolKeys:a,userKeys:e,maxAmountIn:t,amountOut:n,modelDataPubKey:r=Bt},s){let i=Lt(a),o=Buffer.alloc(_r.span);_r.encode({instruction:11,maxAmountIn:$(t),amountOut:$(n)},o);let u=[I({pubkey:Pn,isWritable:!1}),I({pubkey:i.id}),I({pubkey:i.authority,isWritable:!1}),I({pubkey:i.openOrders}),I({pubkey:i.targetOrders}),I({pubkey:i.vault.A}),I({pubkey:i.vault.B})];return s===5&&u.push(I({pubkey:r})),u.push(I({pubkey:i.marketProgramId,isWritable:!1}),I({pubkey:i.marketId}),I({pubkey:i.marketBids}),I({pubkey:i.marketAsks}),I({pubkey:i.marketEventQueue}),I({pubkey:i.marketBaseVault}),I({pubkey:i.marketQuoteVault}),I({pubkey:i.marketAuthority,isWritable:!1}),I({pubkey:e.tokenAccountIn}),I({pubkey:e.tokenAccountOut}),I({pubkey:e.owner,isWritable:!1,isSigner:!0})),new Jt({programId:i.programId,keys:u,data:o})}function fo(a){let{poolKeys:e,version:t,userKeys:n,amountIn:r,amountOut:s,fixedSide:i}=a;if(t===4||t===5){let o={poolKeys:e,userKeys:n};if(i==="in")return fa(z(F({},o),{amountIn:r,minAmountOut:s}),t);if(i==="out")return ba(z(F({},o),{maxAmountIn:r,amountOut:s}),t);mo.logWithError("invalid params","params",a)}throw mo.logWithError("invalid version","poolKeys.version",t),new Error("invalid version")}var Ft=5e4,ya=_([b("x"),b("y"),b("price")]),ga=_([b("accountType"),b("status"),b("multiplier"),b("validDataCount"),G(ya,Ft,"DataElement")]);function wa(a,e){return[0,Ft-2]}function ka(a){return[0,Ft-2]}function Pa(a){return[0,Ft-2]}function Aa(a,e,t){let[n,r]=wa(e,t),s=n,i=r,o=0,u=e*a.multiplier/t;for(;s<=i;){if(o=Math.floor((i+s)/2),o===0||o>=Ft-2)return[o,o,!1];let l=a.DataElement[o].x*a.multiplier/a.DataElement[o].y,c=a.DataElement[o-1].x*a.multiplier/a.DataElement[o-1].y,m=a.DataElement[o+1].x*a.multiplier/a.DataElement[o+1].y;if(u===l)return[o,o,!0];if(u===c)return[o-1,o-1,!0];if(u===m)return[o+1,o+1,!0];if(u<c)i=o-1;else{if(u>c&&u<l)return[o-1,o,!0];if(u>l&&u<m)return[o,o+1,!0];s=o+1}}return[o,o,!1]}function Fr(a,e,t){let[n,r,s]=Aa(a,e,t);if(!s)return 0;if(n===r){let i=a.DataElement[n].x;return e*a.multiplier/i}else{let i=a.DataElement[n].x,o=a.DataElement[n].y,u=a.DataElement[r].x,l=a.DataElement[r].y,c=t*(u*o-i*l),m=i*c,p=(u-i)*(e*o-i*t)*l,d=m+p;return e*a.multiplier*c/d}}function Ot(a,e,t){return e*a.multiplier/t}function bo(a,e,t){return e*t/a.multiplier}function ha(a,e){let[t,n]=ka(e),r=t,s=n,i=0,o=e;for(;r<s;){if(i=Math.floor((s+r)/2),i<=0||i>Ft-2)return[i,i,!1];let u=a.DataElement[i].x,l=a.DataElement[i-1].x,c=a.DataElement[i+1].x;if(o===u)return[i,i,!0];if(o===l)return[i-1,i-1,!0];if(o===c)return[i+1,i+1,!0];if(o<l)s=i-1;else{if(o>l&&o<u)return[i-1,i,!0];if(o>u&&o<c)return[i,i+1,!0];r=i+1}}return[i,i,!1]}function Ta(a,e){let[t,n]=Pa(e),r=t,s=n,i=0,o=e;for(;r<=s;){if(i=Math.floor((s+r)/2),i<=0||i>=Ft-2)return[i,i,!1];let u=a.DataElement[i].y,l=a.DataElement[i-1].y,c=a.DataElement[i+1].y;if(o===u)return[i,i,!0];if(o===l)return[i-1,i-1,!0];if(o===c)return[i+1,i+1,!0];if(o<c)r=i+1;else{if(o<l&&o>u)return[i-1,i,!0];if(o<u&&o>c)return[i,i+1,!0];s=i-1}}return[i,i,!1]}function yo(a,e,t,n){let r=n?e+t:e-t,[s,i,o]=ha(a,r);if(!o)return[0,0,!1,o];if(s===i)return[a.DataElement[i].price,a.DataElement[i].y,!1,o];{let u=a.DataElement[s].x,l=a.DataElement[i].x,c=a.DataElement[s].price,m=a.DataElement[i].price,p=a.DataElement[s].y,d=a.DataElement[i].y;if(e>=u&&e<=l)return n?[m,d,!0,o]:[c,p,!0,o];{let f,y;return n?(f=c+(m-c)*(e-u)/(l-u),y=p-(r-u)*a.multiplier/m):(f=c+(m-c)*(e-u)/(l-u),y=d+(l-r)*a.multiplier/c),[f,y,!1,o]}}}function xa(a,e,t,n){let r=n?e-t:e+t,[s,i,o]=Ta(a,r);if(!o)return[0,0,!1,o];if(s===i)return[a.DataElement[i].price,a.DataElement[i].x,!1,o];{let u=a.DataElement[s].x,l=a.DataElement[i].x,c=a.DataElement[s].price,m=a.DataElement[i].price,p=a.DataElement[s].y,d=a.DataElement[i].y;if(e>=d&&e<=p)return n?[m,l,!0,o]:[c,u,!0,o];{let f,y;return n?(f=c+(m-c)*(p-e)/(p-d),y=u+m*(p-r)/a.multiplier):(f=c+(m-c)*(p-e)/(p-d),y=l-c*(r-d)/a.multiplier),[f,y,!1,o]}}}function Sa(a,e){let t=yo(a,e,0,!1);return t[3]?t[0]:0}function go(a,e,t,n){let r=Fr(a,e,t),s=Ot(a,e,r),i=Ot(a,t,r),o=Ot(a,n,r),u=!0,[l,c,m,p]=yo(a,s,o,u);if(!p)return 0;if(m)return n*a.multiplier/l;{let d=i-c;return bo(a,d,r)}}function wo(a,e,t,n){let r=Fr(a,e,t),s=Ot(a,e,r),i=Ot(a,t,r),o=Ot(a,n,r),u=!1,[l,c,m,p]=xa(a,i,o,u);if(!p)return 0;if(m)return n*l/a.multiplier;{let d=s-c;return bo(a,d,r)}}function Ba(a){let e=ga.decode(a);return{accountType:e.accountType.toNumber(),status:e.status.toNumber(),multiplier:e.multiplier.toNumber(),validDataCount:e.validDataCount.toNumber(),DataElement:e.DataElement.map(t=>({x:t.x.toNumber(),y:t.y.toNumber(),price:t.price.toNumber()}))}}function ko(a,e,t,n){let r=Sa(a,Ot(a,e,Fr(a,e,t)))/a.multiplier;return n?r:1/r}var An=class{constructor({connection:e,modelDataPubKey:t=Bt}){this._layoutData={accountType:0,status:0,multiplier:0,validDataCount:0,DataElement:[]};this.connection=e,this.modelDataPubKey=t}get stableModelData(){return this._layoutData}async initStableModelLayout(){if(this._layoutData.validDataCount===0&&this.connection){let e=await this.connection.getAccountInfo(this.modelDataPubKey);e&&(this._layoutData=Ba(e==null?void 0:e.data))}}};import{PublicKey as Ea}from"@solana/web3.js";import Ig from"bn.js";import zn from"decimal.js";import{TOKEN_PROGRAM_ID as Wa}from"@solana/spl-token";import{PublicKey as Ia}from"@solana/web3.js";var Ka=ie("Raydium_liquidity_serum");function Po({programId:a,marketId:e}){let t=[e.toBuffer()],n=0,r;for(;n<100;){try{let s=t.concat(Buffer.from([n]),Buffer.alloc(7));r=Ia.createProgramAddressSync(s,a)}catch(s){if(s instanceof TypeError)throw s;n++;continue}return{publicKey:r,nonce:n}}throw Ka.logWithError("unable to find a viable program address nonce","params",{programId:a,marketId:e}),new Error("unable to find a viable program address nonce")}import{Keypair as Ma,PublicKey as _a}from"@solana/web3.js";import Dy from"bn.js";import{TOKEN_PROGRAM_ID as Va}from"@solana/spl-token";function La(a){return a instanceof Uint8Array||a!=null&&typeof a=="object"&&a.constructor.name==="Uint8Array"}function Dr(a,...e){if(!La(a))throw new Error("Uint8Array expected");if(e.length>0&&!e.includes(a.length))throw new Error(`Uint8Array expected of length ${e}, not of length=${a.length}`)}function qr(a,e=!0){if(a.destroyed)throw new Error("Hash instance has been destroyed");if(e&&a.finished)throw new Error("Hash#digest() has already been called")}function Ao(a,e){Dr(a);let t=e.outputLen;if(a.length<t)throw new Error(`digestInto() expects output buffer of length at least ${t}`)}var Un=a=>new DataView(a.buffer,a.byteOffset,a.byteLength),Ye=(a,e)=>a<<32-e|a>>>e;var Iy=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;function Ra(a){if(typeof a!="string")throw new Error(`utf8ToBytes expected string, got ${typeof a}`);return new Uint8Array(new TextEncoder().encode(a))}function Gr(a){return typeof a=="string"&&(a=Ra(a)),Dr(a),a}var Gn=class{clone(){return this._cloneInto()}},Ky={}.toString;function ho(a){let e=n=>a().update(Gr(n)).digest(),t=a();return e.outputLen=t.outputLen,e.blockLen=t.blockLen,e.create=()=>a(),e}function Ca(a,e,t,n){if(typeof a.setBigUint64=="function")return a.setBigUint64(e,t,n);let r=BigInt(32),s=BigInt(4294967295),i=Number(t>>r&s),o=Number(t&s),u=n?4:0,l=n?0:4;a.setUint32(e+u,i,n),a.setUint32(e+l,o,n)}var To=(a,e,t)=>a&e^~a&t,xo=(a,e,t)=>a&e^a&t^e&t,Xn=class extends Gn{constructor(e,t,n,r){super(),this.blockLen=e,this.outputLen=t,this.padOffset=n,this.isLE=r,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(e),this.view=Un(this.buffer)}update(e){qr(this);let{view:t,buffer:n,blockLen:r}=this;e=Gr(e);let s=e.length;for(let i=0;i<s;){let o=Math.min(r-this.pos,s-i);if(o===r){let u=Un(e);for(;r<=s-i;i+=r)this.process(u,i);continue}n.set(e.subarray(i,i+o),this.pos),this.pos+=o,i+=o,this.pos===r&&(this.process(t,0),this.pos=0)}return this.length+=e.length,this.roundClean(),this}digestInto(e){qr(this),Ao(e,this),this.finished=!0;let{buffer:t,view:n,blockLen:r,isLE:s}=this,{pos:i}=this;t[i++]=128,this.buffer.subarray(i).fill(0),this.padOffset>r-i&&(this.process(n,0),i=0);for(let m=i;m<r;m++)t[m]=0;Ca(n,r-8,BigInt(this.length*8),s),this.process(n,0);let o=Un(e),u=this.outputLen;if(u%4)throw new Error("_sha2: outputLen should be aligned to 32bit");let l=u/4,c=this.get();if(l>c.length)throw new Error("_sha2: outputLen bigger than state");for(let m=0;m<l;m++)o.setUint32(4*m,c[m],s)}digest(){let{buffer:e,outputLen:t}=this;this.digestInto(e);let n=e.slice(0,t);return this.destroy(),n}_cloneInto(e){e||(e=new this.constructor),e.set(...this.get());let{blockLen:t,buffer:n,length:r,finished:s,destroyed:i,pos:o}=this;return e.length=r,e.pos=o,e.finished=s,e.destroyed=i,r%t&&e.buffer.set(n),e}};var Na=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),Pt=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),At=new Uint32Array(64),Ur=class extends Xn{constructor(){super(64,32,8,!1),this.A=Pt[0]|0,this.B=Pt[1]|0,this.C=Pt[2]|0,this.D=Pt[3]|0,this.E=Pt[4]|0,this.F=Pt[5]|0,this.G=Pt[6]|0,this.H=Pt[7]|0}get(){let{A:e,B:t,C:n,D:r,E:s,F:i,G:o,H:u}=this;return[e,t,n,r,s,i,o,u]}set(e,t,n,r,s,i,o,u){this.A=e|0,this.B=t|0,this.C=n|0,this.D=r|0,this.E=s|0,this.F=i|0,this.G=o|0,this.H=u|0}process(e,t){for(let m=0;m<16;m++,t+=4)At[m]=e.getUint32(t,!1);for(let m=16;m<64;m++){let p=At[m-15],d=At[m-2],f=Ye(p,7)^Ye(p,18)^p>>>3,y=Ye(d,17)^Ye(d,19)^d>>>10;At[m]=y+At[m-7]+f+At[m-16]|0}let{A:n,B:r,C:s,D:i,E:o,F:u,G:l,H:c}=this;for(let m=0;m<64;m++){let p=Ye(o,6)^Ye(o,11)^Ye(o,25),d=c+p+To(o,u,l)+Na[m]+At[m]|0,y=(Ye(n,2)^Ye(n,13)^Ye(n,22))+xo(n,r,s)|0;c=l,l=u,u=o,o=i+d|0,i=s,s=r,r=n,n=d+y|0}n=n+this.A|0,r=r+this.B|0,s=s+this.C|0,i=i+this.D|0,o=o+this.E|0,u=u+this.F|0,l=l+this.G|0,c=c+this.H|0,this.set(n,r,s,i,o,u,l,c)}roundClean(){At.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}};var So=ho(()=>new Ur);var zy=ie("Raydium_Util");function nt({fromPublicKey:a,programId:e=Va,assignSeed:t}){let n=t?btoa(t).slice(0,32):Ma.generate().publicKey.toBase58().slice(0,32);return{publicKey:va(a,n,e),seed:n}}function va(a,e,t){let n=Buffer.concat([a.toBuffer(),Buffer.from(e),t.toBuffer()]),r=So(n);return new _a(r)}import{PublicKey as Zy,SystemProgram as Jy}from"@solana/web3.js";import ng from"bn.js";import{createCloseAccountInstruction as sg,createInitializeAccountInstruction as ag,createTransferInstruction as ug,TOKEN_PROGRAM_ID as cg}from"@solana/spl-token";function Qn({programId:a}){let{publicKey:e}=be([Buffer.from("amm_config_account_seed","utf-8")],a);return e}function Dt({name:a,programId:e,marketId:t}){let{publicKey:n}=be([e.toBuffer(),t.toBuffer(),Buffer.from(a,"utf-8")],e);return n}function Oa({programId:a,marketId:e}){let{publicKey:t}=be([a.toBuffer(),e.toBuffer(),Buffer.from("open_order_associated_seed","utf-8")],a);return t}function Fa({programId:a}){return be([Buffer.from([97,109,109,32,97,117,116,104,111,114,105,116,121])],a)}function zr({version:a,marketVersion:e,marketId:t,baseMint:n,quoteMint:r,baseDecimals:s,quoteDecimals:i,programId:o,marketProgramId:u}){let l=Dt({name:"amm_associated_seed",programId:o,marketId:t}),c=Dt({name:"lp_mint_associated_seed",programId:o,marketId:t}),{publicKey:m,nonce:p}=Fa({programId:o}),d=Dt({name:"coin_vault_associated_seed",programId:o,marketId:t}),f=Dt({name:"pc_vault_associated_seed",programId:o,marketId:t}),y=Dt({name:"temp_lp_token_associated_seed",programId:o,marketId:t}),w=Oa({programId:o,marketId:t}),g=Dt({name:"target_associated_seed",programId:o,marketId:t}),A=Dt({name:"withdraw_associated_seed",programId:o,marketId:t}),{publicKey:T}=Po({programId:u,marketId:t});return{id:l,baseMint:n,quoteMint:r,lpMint:c,baseDecimals:s,quoteDecimals:i,lpDecimals:s,version:a,programId:o,authority:m,nonce:p,baseVault:d,quoteVault:f,lpVault:y,openOrders:w,targetOrders:g,withdrawQueue:A,marketVersion:e,marketProgramId:u,marketId:t,marketAuthority:T,lookupTableAccount:Ea.default,configId:Qn({programId:o})}}var Xr={volume:0,volumeQuote:0,volumeFee:0,apr:0,feeApr:0,priceMin:0,priceMax:0,rewardApr:[]},Bo=a=>{let e={},t=Wa.toBase58();return Object.keys(a).map(n=>{let r=a[n],[s,i]=[r.baseMint.toBase58(),r.quoteMint.toBase58()];e[n]={id:n,version:4,status:r.status.toNumber(),programId:r.programId.toBase58(),mintA:Dn({address:s,programId:t,decimals:r.baseDecimal.toNumber()}),mintB:Dn({address:i,programId:t,decimals:r.quoteDecimal.toNumber()}),rewardDefaultInfos:[],rewardDefaultPoolInfos:"Ecosystem",price:r.poolPrice.toNumber(),mintAmountA:new zn(r.mintAAmount.toString()).div(10**r.baseDecimal.toNumber()).toNumber(),mintAmountB:new zn(r.mintBAmount.toString()).div(10**r.quoteDecimal.toNumber()).toNumber(),baseReserve:r.baseReserve,quoteReserve:r.quoteReserve,feeRate:new zn(r.tradeFeeNumerator.toString()).div(r.tradeFeeDenominator.toString()).toNumber(),openTime:r.poolOpenTime.toString(),tvl:0,day:Xr,week:Xr,month:Xr,pooltype:[],farmUpcomingCount:0,farmOngoingCount:0,farmFinishedCount:0,type:"Standard",marketId:r.marketId.toBase58(),configId:Qn({programId:r.programId}).toBase58(),lpPrice:0,lpAmount:new zn(r.lpReserve.toString()).div(10**Math.min(r.baseDecimal.toNumber(),r.quoteDecimal.toNumber())).toNumber(),lpMint:Dn({address:r.lpMint.toBase58(),programId:t,decimals:Math.min(r.baseDecimal.toNumber(),r.quoteDecimal.toNumber())}),burnPercent:0}}),e};import ge from"bn.js";import se from"decimal.js";import{PublicKey as Zg}from"@solana/web3.js";import Jg from"bn.js";import{TOKEN_PROGRAM_ID as tw}from"@solana/spl-token";import{SystemProgram as qt,SYSVAR_RENT_PUBKEY as qa,Transaction as Io,TransactionInstruction as Ga}from"@solana/web3.js";import{createInitializeAccountInstruction as Ko,TOKEN_PROGRAM_ID as Lo}from"@solana/spl-token";function Da(a="accountFlags"){let e=new Nn(a);return e.addBoolean("initialized"),e.addBoolean("market"),e.addBoolean("openOrders"),e.addBoolean("requestQueue"),e.addBoolean("eventQueue"),e.addBoolean("bids"),e.addBoolean("asks"),e}var Qr=_([he(5),Da("accountFlags"),L("ownAddress"),b("vaultSignerNonce"),L("baseMint"),L("quoteMint"),L("baseVault"),b("baseDepositsTotal"),b("baseFeesAccrued"),L("quoteVault"),b("quoteDepositsTotal"),b("quoteFeesAccrued"),b("quoteDustThreshold"),L("requestQueue"),L("eventQueue"),L("bids"),L("asks"),b("baseLotSize"),b("quoteLotSize"),b("feeRateBps"),b("referrerRebatesAccrued"),he(7)]);function Ua({programId:a,marketInfo:e}){let t=_([W("version"),Ce("instruction"),b("baseLotSize"),b("quoteLotSize"),Ct("feeRateBps"),b("vaultSignerNonce"),b("quoteDustThreshold")]),n=[{pubkey:e.id,isSigner:!1,isWritable:!0},{pubkey:e.requestQueue,isSigner:!1,isWritable:!0},{pubkey:e.eventQueue,isSigner:!1,isWritable:!0},{pubkey:e.bids,isSigner:!1,isWritable:!0},{pubkey:e.asks,isSigner:!1,isWritable:!0},{pubkey:e.baseVault,isSigner:!1,isWritable:!0},{pubkey:e.quoteVault,isSigner:!1,isWritable:!0},{pubkey:e.baseMint,isSigner:!1,isWritable:!1},{pubkey:e.quoteMint,isSigner:!1,isWritable:!1},{pubkey:e.authority?e.quoteMint:qa,isSigner:!1,isWritable:!1}].concat(e.authority?{pubkey:e.authority,isSigner:!1,isWritable:!1}:[]).concat(e.authority&&e.pruneAuthority?{pubkey:e.pruneAuthority,isSigner:!1,isWritable:!1}:[]),r=Buffer.alloc(t.span);return t.encode({version:0,instruction:0,baseLotSize:e.baseLotSize,quoteLotSize:e.quoteLotSize,feeRateBps:e.feeRateBps,vaultSignerNonce:e.vaultSignerNonce,quoteDustThreshold:e.quoteDustThreshold},r),new Ga({keys:n,programId:a,data:r})}async function Hr({connection:a,wallet:e,marketInfo:t}){var i,o,u,l,c,m,p,d;let n=new Io,r=await a.getMinimumBalanceForRentExemption(165);n.add(qt.createAccountWithSeed({fromPubkey:e,basePubkey:e,seed:t.baseVault.seed,newAccountPubkey:t.baseVault.publicKey,lamports:r,space:165,programId:Lo}),qt.createAccountWithSeed({fromPubkey:e,basePubkey:e,seed:t.quoteVault.seed,newAccountPubkey:t.quoteVault.publicKey,lamports:r,space:165,programId:Lo}),Ko(t.baseVault.publicKey,t.baseMint,t.vaultOwner),Ko(t.quoteVault.publicKey,t.quoteMint,t.vaultOwner),qt.createAccountWithSeed({fromPubkey:e,basePubkey:e,seed:t.id.seed,newAccountPubkey:t.id.publicKey,lamports:await a.getMinimumBalanceForRentExemption(Qr.span),space:Qr.span,programId:t.programId}));let s=new Io;return s.add(qt.createAccountWithSeed({fromPubkey:e,basePubkey:e,seed:t.requestQueue.seed,newAccountPubkey:t.requestQueue.publicKey,lamports:t.lowestFeeMarket?6208320:await a.getMinimumBalanceForRentExemption((i=t.requestQueueSpace)!=null?i:5120+12),space:t.lowestFeeMarket?764:(o=t.requestQueueSpace)!=null?o:5120+12,programId:t.programId}),qt.createAccountWithSeed({fromPubkey:e,basePubkey:e,seed:t.eventQueue.seed,newAccountPubkey:t.eventQueue.publicKey,lamports:t.lowestFeeMarket?79594560:await a.getMinimumBalanceForRentExemption((u=t.eventQueueSpace)!=null?u:262144+12),space:t.lowestFeeMarket?11308:(l=t.eventQueueSpace)!=null?l:262144+12,programId:t.programId}),qt.createAccountWithSeed({fromPubkey:e,basePubkey:e,seed:t.bids.seed,newAccountPubkey:t.bids.publicKey,lamports:t.lowestFeeMarket?101977920:await a.getMinimumBalanceForRentExemption((c=t.orderbookQueueSpace)!=null?c:65536+12),space:t.lowestFeeMarket?14524:(m=t.orderbookQueueSpace)!=null?m:65536+12,programId:t.programId}),qt.createAccountWithSeed({fromPubkey:e,basePubkey:e,seed:t.asks.seed,newAccountPubkey:t.asks.publicKey,lamports:t.lowestFeeMarket?101977920:await a.getMinimumBalanceForRentExemption((p=t.orderbookQueueSpace)!=null?p:65536+12),space:t.lowestFeeMarket?14524:(d=t.orderbookQueueSpace)!=null?d:65536+12,programId:t.programId}),Ua({programId:t.programId,marketInfo:{id:t.id.publicKey,requestQueue:t.requestQueue.publicKey,eventQueue:t.eventQueue.publicKey,bids:t.bids.publicKey,asks:t.asks.publicKey,baseVault:t.baseVault.publicKey,quoteVault:t.quoteVault.publicKey,baseMint:t.baseMint,quoteMint:t.quoteMint,baseLotSize:t.baseLotSize,quoteLotSize:t.quoteLotSize,feeRateBps:t.feeRateBps,vaultSignerNonce:t.vaultSignerNonce,quoteDustThreshold:t.quoteDustThreshold}})),[{transaction:n,signer:[],instructionTypes:[U.CreateAccount,U.CreateAccount,U.InitAccount,U.InitAccount]},{transaction:s,signer:[],instructionTypes:[U.CreateAccount,U.CreateAccount,U.CreateAccount,U.CreateAccount,U.CreateAccount,U.InitMarket]}]}var Yr=class extends $t{constructor(t){super(t);this.stableLayout=new An({connection:this.scope.connection,modelDataPubKey:this.scope.cluster==="mainnet"?void 0:It.MODEL_DATA_PUBKEY})}async initLayout(){await this.stableLayout.initStableModelLayout()}async load(){this.checkDisabled()}computePairAmount({poolInfo:t,amount:n,slippage:r,baseIn:s}){let i=new ge(new se(n).mul(10**t[s?"mintA":"mintB"].decimals).toFixed(0)),o=uo(t[s?"mintB":"mintA"]),[u,l]=[new ge(new se(t.mintAmountA).mul(10**t.mintA.decimals).toString()),new ge(new se(t.mintAmountB).mul(10**t.mintB.decimals).toString())],c=new ge(new se(t.lpAmount).mul(10**t.lpMint.decimals).toFixed(0,se.ROUND_DOWN));this.logDebug("baseReserve:",u.toString(),"quoteReserve:",l.toString()),this.logDebug("tokenIn:",s?t.mintA.symbol:t.mintB.symbol,"amountIn:",i.toString(),"anotherToken:",s?t.mintB.symbol:t.mintA.symbol,"slippage:",`${r.toSignificant()}%`,"baseReserve",u.toString(),"quoteReserve",l.toString());let m=s?"base":"quote";this.logDebug("input side:",m);let p=bt;i.isZero()||(p=m==="base"?Kn(i.mul(l),u):Kn(i.mul(u),l)),this.logDebug("amountRaw:",p.toString(),"lpAmount:",c.toString());let d=Kn(i.mul(c),m==="base"?u:l);this.logDebug("liquidity:",d.toString());let f=new Ue(new ge(1)).add(r),y=new Ue(new ge(1)).sub(r),w=f.mul(p).quotient,g=y.mul(p).quotient,A=new we(o,p),T=new we(o,w),h=new we(o,g);return this.logDebug("anotherAmount:",A.toFixed(),"maxAnotherAmount:",T.toFixed()),{anotherAmount:A,maxAnotherAmount:T,minAnotherAmount:h,liquidity:d}}async getAmmPoolKeys(t){return(await this.scope.api.fetchPoolKeysById({idList:[t]}))[0]}async addLiquidity(t){let{poolInfo:n,poolKeys:r,amountInA:s,amountInB:i,otherAmountMin:o,fixedSide:u,config:l,txVersion:c,computeBudgetConfig:m,txTipConfig:p,feePayer:d}=t;this.scope.availability.addStandardPosition===!1&&this.logAndCreateError("add liquidity feature disabled in your region"),this.logDebug("amountInA:",s,"amountInB:",i),(s.isZero()||i.isZero())&&this.logAndCreateError("amounts must greater than zero","amountInA & amountInB",{amountInA:s.toFixed(),amountInB:i.toFixed()});let{account:f}=this.scope,{bypassAssociatedCheck:y,checkCreateATAOwner:w}=F({bypassAssociatedCheck:!1,checkCreateATAOwner:!1},l),[g,A]=[s.token,i.token],T=await f.getCreatedTokenAccount({mint:g.mint,associatedOnly:!1}),h=await f.getCreatedTokenAccount({mint:A.mint,associatedOnly:!1});!T&&!h&&this.logAndCreateError("cannot found target token accounts","tokenAccounts",f.tokenAccounts);let P=await f.getCreatedTokenAccount({mint:new Ae(n.lpMint.address)}),k=[g,A],S=[T,h],x=[s.raw,i.raw],K=s.token.mint.toBase58()===n.mintA.address?"base":"quote",B="base";["quote","base"].includes(K)||this.logAndCreateError("invalid fixedSide","fixedSide",u),K==="quote"?(k.reverse(),S.reverse(),x.reverse(),B=u==="a"?"quote":"base"):K==="base"&&(B=u==="a"?"base":"quote");let[N,M]=k,[C,E]=S,[j,Y]=x,Z=r!=null?r:await this.getAmmPoolKeys(n.id),ae=this.createTxBuilder(d),rt=await f.handleTokenAccount({side:"in",amount:j,mint:N.mint,tokenAccount:C,bypassAssociatedCheck:y,checkCreateATAOwner:w}),{tokenAccount:Ke}=rt,De=ve(rt,["tokenAccount"]);ae.addInstruction(De);let Ge=await f.handleTokenAccount({side:"in",amount:Y,mint:M.mint,tokenAccount:E,bypassAssociatedCheck:y,checkCreateATAOwner:w}),{tokenAccount:fe}=Ge,ce=ve(Ge,["tokenAccount"]);ae.addInstruction(ce);let Ve=await f.handleTokenAccount({side:"out",amount:0,mint:new Ae(n.lpMint.address),tokenAccount:P,bypassAssociatedCheck:y,checkCreateATAOwner:w}),{tokenAccount:qe}=Ve,pt=ve(Ve,["tokenAccount"]);return ae.addInstruction(pt),ae.addInstruction({instructions:[po({poolInfo:n,poolKeys:Z,userKeys:{baseTokenAccount:Ke,quoteTokenAccount:fe,lpTokenAccount:qe,owner:this.scope.ownerPubKey},baseAmountIn:j,quoteAmountIn:Y,otherAmountMin:o.raw,fixedSide:B})],instructionTypes:[n.pooltype.includes("StablePool")?U.AmmV5AddLiquidity:U.AmmV4AddLiquidity],lookupTableAddress:Z.lookupTableAccount?[Z.lookupTableAccount]:[]}),ae.addCustomComputeBudget(m),ae.addTipInstruction(p),c===0?await ae.buildV0():ae.build()}async removeLiquidity(t){this.scope.availability.removeStandardPosition===!1&&this.logAndCreateError("remove liquidity feature disabled in your region");let{poolInfo:n,poolKeys:r,lpAmount:s,baseAmountMin:i,quoteAmountMin:o,config:u,txVersion:l,computeBudgetConfig:c,txTipConfig:m,feePayer:p}=t,d=r!=null?r:await this.getAmmPoolKeys(n.id),[f,y,w]=[new Ae(n.mintA.address),new Ae(n.mintB.address),new Ae(n.lpMint.address)];this.logDebug("lpAmount:",s),this.logDebug("baseAmountMin:",i),this.logDebug("quoteAmountMin:",o),s.isZero()&&this.logAndCreateError("amount must greater than zero","lpAmount",s.toString());let{account:g}=this.scope,A=await g.getCreatedTokenAccount({mint:w,associatedOnly:!1});A||this.logAndCreateError("cannot found lpTokenAccount","tokenAccounts",g.tokenAccounts);let T=await g.getCreatedTokenAccount({mint:f}),h=await g.getCreatedTokenAccount({mint:y}),P=this.createTxBuilder(p),{bypassAssociatedCheck:k,checkCreateATAOwner:S}=F({bypassAssociatedCheck:!1,checkCreateATAOwner:!1},u),M=await g.handleTokenAccount({side:"out",amount:0,mint:f,tokenAccount:T,bypassAssociatedCheck:k,checkCreateATAOwner:S}),{tokenAccount:x}=M,K=ve(M,["tokenAccount"]);P.addInstruction(K);let C=await g.handleTokenAccount({side:"out",amount:0,mint:y,tokenAccount:h,bypassAssociatedCheck:k,checkCreateATAOwner:S}),{tokenAccount:B}=C,N=ve(C,["tokenAccount"]);return P.addInstruction(N),P.addInstruction({instructions:[Wr({poolInfo:n,poolKeys:d,userKeys:{lpTokenAccount:A,baseTokenAccount:x,quoteTokenAccount:B,owner:this.scope.ownerPubKey},lpAmount:s,baseAmountMin:i,quoteAmountMin:o})],lookupTableAddress:d.lookupTableAccount?[d.lookupTableAccount]:[],instructionTypes:[n.pooltype.includes("StablePool")?U.AmmV5RemoveLiquidity:U.AmmV4RemoveLiquidity]}),P.addCustomComputeBudget(c),P.addTipInstruction(m),l===0?await P.buildV0():P.build()}async removeAllLpAndCreateClmmPosition({poolInfo:t,clmmPoolInfo:n,removeLpAmount:r,createPositionInfo:s,farmInfo:i,userFarmLpAmount:o,base:u,computeBudgetConfig:l,payer:c,userAuxiliaryLedgers:m,tokenProgram:p=ht,checkCreateATAOwner:d=!0,getEphemeralSigners:f,txVersion:y,feePayer:w}){if((this.scope.availability.removeStandardPosition===!1||this.scope.availability.createConcentratedPosition===!1)&&this.logAndCreateError("remove liquidity or create position feature disabled in your region"),!(t.mintA.address===n.mintA.address||t.mintA.address===n.mintB.address)||!(t.mintB.address===n.mintA.address||t.mintB.address===n.mintB.address))throw Error("mint check error");let g=this.createTxBuilder(w),A={};for(let Z of this.scope.account.tokenAccountRawInfos)(A[Z.accountInfo.mint.toString()]===void 0||ue(this.scope.ownerPubKey,Z.accountInfo.mint,ht).publicKey.equals(Z.pubkey))&&(A[Z.accountInfo.mint.toString()]=Z.pubkey);let T=A[t.lpMint.address];if(T===void 0)throw Error("find lp account error in trade accounts");let h=r.add(o!=null?o:new ge(0)),P=t.mintA.address===Re.WSOL.mint.toString(),k=t.mintB.address===Re.WSOL.mint.toString(),{account:S,instructionParams:x}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:ht,mint:new Ae(t.mintA.address),owner:this.scope.ownerPubKey,createInfo:P?{payer:this.scope.ownerPubKey}:void 0,skipCloseAccount:!P,notUseTokenAccount:P,associatedOnly:!0,checkCreateATAOwner:d});if(g.addInstruction(x||{}),S===void 0)throw new Error("base token account not found");let{account:K,instructionParams:B}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:ht,mint:new Ae(t.mintB.address),owner:this.scope.ownerPubKey,createInfo:k?{payer:this.scope.ownerPubKey,amount:0}:void 0,skipCloseAccount:!k,notUseTokenAccount:k,associatedOnly:!0,checkCreateATAOwner:d});if(g.addInstruction(B||{}),K===void 0)throw new Error("quote token account not found");if(A[t.mintA.address]=S,A[t.mintB.address]=K,i!==void 0&&!(o!=null&&o.isZero())){let Z=gr[i.programId],ae=Yt({programId:new Ae(i.programId),poolId:new Ae(i.id),owner:this.scope.ownerPubKey,version:Z}),Ke,De=await this.scope.connection.getAccountInfo(ae);if(De&&(Ke=Vi(Z).decode(De.data)),Z!==6&&!Ke){let{instruction:Ve,instructionType:ft}=Ei({id:new Ae(i.id),programId:new Ae(i.programId),version:Z,ledger:ae,owner:this.scope.ownerPubKey});g.addInstruction({instructions:[Ve],instructionTypes:[ft]})}let fe=[];for(let Ve of i.rewardInfos){let ft=Ve.mint.address===Re.WSOL.mint.toString();if(A[Ve.mint.address])fe.push(A[Ve.mint.address]);else{let{account:en,instructionParams:Tt}=await this.scope.account.getOrCreateTokenAccount({mint:new Ae(Ve.mint.address),tokenProgram:p,owner:this.scope.ownerPubKey,skipCloseAccount:!ft,createInfo:{payer:c||this.scope.ownerPubKey},associatedOnly:!0,checkCreateATAOwner:d});en||this.logAndCreateError("farm reward account not found:",Ve.mint.address),Tt&&g.addInstruction(Tt),fe.push(en)}}let ce=(await this.scope.api.fetchFarmKeysById({ids:i.id}))[0],qe={userAuxiliaryLedgers:m,amount:o,owner:this.scope.ownerPubKey,farmInfo:i,farmKeys:ce,lpAccount:T,rewardAccounts:fe},pt=gr[i.programId],rt=pt===6?Wi(qe):pt===5?Oi(qe):Fi(qe),Ge={3:U.FarmV3Withdraw,5:U.FarmV5Withdraw,6:U.FarmV6Withdraw};g.addInstruction({instructions:[rt],instructionTypes:[Ge[pt]]})}let N=await this.getAmmPoolKeys(t.id),M=Wr({poolInfo:t,poolKeys:N,userKeys:{lpTokenAccount:T,baseTokenAccount:S,quoteTokenAccount:K,owner:this.scope.ownerPubKey},lpAmount:h,baseAmountMin:0,quoteAmountMin:0});g.addInstruction({instructions:[M],instructionTypes:[t.pooltype.includes("StablePool")?U.AmmV5RemoveLiquidity:U.AmmV4RemoveLiquidity],lookupTableAddress:N.lookupTableAccount?[N.lookupTableAccount]:[]});let[C,E]=t.mintA.address===n.mintA.address?[S,K]:[K,S],j=await this.scope.clmm.getClmmPoolKeys(n.id),Y=await Zt.openPositionFromBaseInstructions(z(F({poolInfo:n,poolKeys:j,ownerInfo:{feePayer:this.scope.ownerPubKey,wallet:this.scope.ownerPubKey,tokenAccountA:C,tokenAccountB:E},withMetadata:"create"},s),{base:u,getEphemeralSigners:f}));return g.addInstruction({instructions:[...Y.instructions],signers:Y.signers,instructionTypes:[...Y.instructionTypes],lookupTableAddress:j.lookupTableAccount?[j.lookupTableAccount]:[]}),y===0?g.sizeCheckBuildV0({computeBudgetConfig:l}):g.sizeCheckBuild({computeBudgetConfig:l})}async createPoolV4({programId:t,marketInfo:n,baseMintInfo:r,quoteMintInfo:s,baseAmount:i,quoteAmount:o,startTime:u,ownerInfo:l,associatedOnly:c=!1,checkCreateATAOwner:m=!1,tokenProgram:p,txVersion:d,feeDestinationId:f,computeBudgetConfig:y,txTipConfig:w,feePayer:g}){var E;let A=l.feePayer||((E=this.scope.owner)==null?void 0:E.publicKey),T=l.useSOLBalance&&r.mint.equals(Hn),h=l.useSOLBalance&&s.mint.equals(Hn),P=this.createTxBuilder(g),{account:k,instructionParams:S}=await this.scope.account.getOrCreateTokenAccount({mint:r.mint,owner:this.scope.ownerPubKey,createInfo:T?{payer:A,amount:i}:void 0,notUseTokenAccount:T,skipCloseAccount:!T,associatedOnly:T?!1:c,checkCreateATAOwner:m});P.addInstruction(S||{});let{account:x,instructionParams:K}=await this.scope.account.getOrCreateTokenAccount({mint:s.mint,owner:this.scope.ownerPubKey,createInfo:h?{payer:A,amount:o}:void 0,notUseTokenAccount:h,skipCloseAccount:!h,associatedOnly:h?!1:c,checkCreateATAOwner:m});if(P.addInstruction(K||{}),k===void 0||x===void 0)throw Error("you don't has some token account");let B=zr({version:4,marketVersion:3,marketId:n.marketId,baseMint:r.mint,quoteMint:s.mint,baseDecimals:r.decimals,quoteDecimals:s.decimals,programId:t,marketProgramId:n.programId}),N={programId:t,ammId:B.id,ammAuthority:B.authority,ammOpenOrders:B.openOrders,lpMint:B.lpMint,coinMint:B.baseMint,pcMint:B.quoteMint,coinVault:B.baseVault,pcVault:B.quoteVault,withdrawQueue:B.withdrawQueue,ammTargetOrders:B.targetOrders,poolTempLp:B.lpVault,marketProgramId:B.marketProgramId,marketId:B.marketId,ammConfigId:B.configId,feeDestinationId:f},{instruction:M,instructionType:C}=Or(z(F({},N),{userWallet:this.scope.ownerPubKey,userCoinVault:k,userPcVault:x,userLpVault:ue(this.scope.ownerPubKey,B.lpMint,p).publicKey,nonce:B.nonce,openTime:u,coinAmount:i,pcAmount:o}));return P.addInstruction({instructions:[M],instructionTypes:[C]}),P.addCustomComputeBudget(y),P.addTipInstruction(w),P.versionBuild({txVersion:d,extInfo:{address:N}})}async createMarketAndPoolV4({programId:t=hi,marketProgram:n=Ai,feeDestinationId:r=Ti,tokenProgram:s,baseMintInfo:i,quoteMintInfo:o,baseAmount:u,quoteAmount:l,startTime:c,ownerInfo:m,lowestFeeMarket:p,assignSeed:d,associatedOnly:f=!1,checkCreateATAOwner:y=!1,lotSize:w=1,tickSize:g=.01,txVersion:A,computeBudgetConfig:T,txTipConfig:h,feePayer:P}){var Zr,$r,Jr;let k=this.scope.ownerPubKey,S=m.feePayer||((Zr=this.scope.owner)==null?void 0:Zr.publicKey),x=m.useSOLBalance&&i.mint.equals(Hn),K=m.useSOLBalance&&o.mint.equals(Hn),B=d?`${i.mint.toBase58().slice(0,7)}-${o.mint.toBase58().slice(0,7)}-${d}`:void 0,N=nt({fromPublicKey:k,programId:n,assignSeed:B&&`${B}-market`}),M=nt({fromPublicKey:k,programId:n,assignSeed:B&&`${B}-request`}),C=nt({fromPublicKey:k,programId:n,assignSeed:B&&`${B}-event`}),E=nt({fromPublicKey:k,programId:n,assignSeed:B&&`${B}-bids`}),j=nt({fromPublicKey:k,programId:n,assignSeed:B&&`${B}-asks`}),Y=nt({fromPublicKey:k,programId:ht,assignSeed:B&&`${B}-baseVault`}),Z=nt({fromPublicKey:k,programId:ht,assignSeed:B&&`${B}-quoteVault`}),ae=0,Ke=new ge(100);function De(){let je=new ge(0);for(;;)try{return{vaultOwner:Ae.createProgramAddressSync([N.publicKey.toBuffer(),je.toArrayLike(Buffer,"le",8)],n),vaultSignerNonce:je}}catch{if(je.iaddn(1),je.gt(new ge(25555)))throw Error("find vault owner error")}}let{vaultOwner:fe,vaultSignerNonce:ce}=De(),qe=new ge(Math.round(10**i.decimals*w)),pt=new ge(Math.round(w*10**o.decimals*g));if(qe.eq(bt))throw Error("lot size is too small");if(pt.eq(bt))throw Error("tick size or lot size is too small");let rt=await Hr({connection:this.scope.connection,wallet:this.scope.ownerPubKey,marketInfo:{programId:n,vaultOwner:fe,baseMint:i.mint,quoteMint:o.mint,id:N,baseVault:Y,quoteVault:Z,requestQueue:M,eventQueue:C,bids:E,asks:j,feeRateBps:ae,quoteDustThreshold:Ke,vaultSignerNonce:ce,baseLotSize:qe,quoteLotSize:pt,lowestFeeMarket:p}}),Ge=this.createTxBuilder(P);Ge.addInstruction({instructions:rt[0].transaction.instructions,signers:rt[0].signer});for await(let je of rt.slice(1,rt.length))Ge.addInstruction({instructions:je.transaction.instructions,signers:je.signer,instructionTypes:je.instructionTypes});let{account:Ve,instructionParams:ft}=await this.scope.account.getOrCreateTokenAccount({mint:i.mint,owner:this.scope.ownerPubKey,createInfo:x?{payer:S,amount:u}:void 0,notUseTokenAccount:x,skipCloseAccount:!x,associatedOnly:x?!1:f,checkCreateATAOwner:y,assignSeed:x&&B?`${B}-wsol`:void 0});Ge.addInstruction(ft||{});let{account:en,instructionParams:Tt}=await this.scope.account.getOrCreateTokenAccount({mint:o.mint,owner:this.scope.ownerPubKey,createInfo:K?{payer:S,amount:l}:void 0,notUseTokenAccount:K,skipCloseAccount:!K,associatedOnly:K?!1:f,checkCreateATAOwner:y,assignSeed:K&&B?`${B}-wsol`:void 0});if(Ge.addInstruction(Tt||{}),Ve===void 0)throw Error("you don't has base token account");if(en===void 0)throw Error("you don't has quote token account");let Le=zr({version:4,marketVersion:3,marketId:N.publicKey,baseMint:i.mint,quoteMint:o.mint,baseDecimals:i.decimals,quoteDecimals:o.decimals,programId:t,marketProgramId:n}),Yn={programId:t,ammId:Le.id,ammAuthority:Le.authority,ammOpenOrders:Le.openOrders,lpMint:Le.lpMint,coinMint:Le.baseMint,pcMint:Le.quoteMint,coinVault:Le.baseVault,pcVault:Le.quoteVault,withdrawQueue:Le.withdrawQueue,ammTargetOrders:Le.targetOrders,poolTempLp:Le.lpVault,marketProgramId:Le.marketProgramId,marketId:Le.marketId,ammConfigId:Le.configId,feeDestinationId:r},{instruction:Ro,instructionType:Co}=Or(z(F({},Yn),{userWallet:this.scope.ownerPubKey,userCoinVault:Ve,userPcVault:en,userLpVault:ue(this.scope.ownerPubKey,Le.lpMint,s).publicKey,nonce:Le.nonce,openTime:c,coinAmount:u,pcAmount:l}));Ge.addInstruction({instructions:[Ro],instructionTypes:[Co]});let jr=x||K?[(($r=ft==null?void 0:ft.instructions)==null?void 0:$r[0])||((Jr=Tt==null?void 0:Tt.instructions)==null?void 0:Jr[0])].filter(je=>!!je):void 0;return A===0?Ge.sizeCheckBuildV0({computeBudgetConfig:T,splitIns:jr,address:F({requestQueue:M.publicKey,eventQueue:C.publicKey,bids:E.publicKey,asks:j.publicKey,baseVault:Y.publicKey,quoteVault:Z.publicKey,baseMint:new Ae(i.mint),quoteMint:new Ae(o.mint)},Yn)}):Ge.sizeCheckBuild({computeBudgetConfig:T,splitIns:jr,address:F({requestQueue:M.publicKey,eventQueue:C.publicKey,bids:E.publicKey,asks:j.publicKey,baseVault:Y.publicKey,quoteVault:Z.publicKey,baseMint:new Ae(i.mint),quoteMint:new Ae(o.mint)},Yn)})}async getCreatePoolFee({programId:t}){let n=Qn({programId:t}),r=await this.scope.connection.getAccountInfo(n,{dataSlice:{offset:536,length:8}});if(r===null)throw Error("get config account error");return lo.decode(r.data).fee}computeAmountOut({poolInfo:t,amountIn:n,mintIn:r,mintOut:s,slippage:i}){let[o,u]=[r.toString(),s.toString()];if(o!==t.mintA.address&&o!==t.mintB.address)throw new Error("toke not match");if(u!==t.mintA.address&&u!==t.mintB.address)throw new Error("toke not match");let{baseReserve:l,quoteReserve:c}=t,m=[l,c],p=[t.mintA.decimals,t.mintB.decimals],d=o==t.mintA.address?"base":"quote";d==="quote"&&(m.reverse(),p.reverse());let[f,y]=m,[w,g]=p,A=t.version===4,T;if(A)T=new se(y.toString()).div(10**g).div(new se(f.toString()).div(10**w));else{let C=ko(this.stableLayout.stableModelData,l.toNumber(),c.toNumber(),!1);d==="quote"?T=new se(1e6).div(C*1e6):T=new se(C*1e6).div(1e6)}let h=n,P=new ge(0),k=new ge(0);if(!h.isZero())if(A){k=cn(h.mul(Nr),qn);let C=h.sub(k),E=f.add(C);P=y.mul(C).div(E)}else{k=h.mul(new ge(2)).div(new ge(1e4));let C=h.sub(k);d==="quote"?P=new ge(go(this.stableLayout.stableModelData,c.toNumber(),l.toNumber(),C.toNumber())):P=new ge(wo(this.stableLayout.stableModelData,c.toNumber(),l.toNumber(),C.toNumber()))}let S=new ge(new se(P.toString()).mul(1-i).toFixed(0)),x=P,K=S,B=new se(P.toString()).div(new se(h.sub(k).toString()).toFixed(0));!h.isZero()&&!P.isZero()&&(B=new se(P.toString()).div(10**g).div(new se(h.sub(k).toString()).div(10**w)));let N=T.sub(B).div(T).mul(100);return{amountOut:x,minAmountOut:K,currentPrice:T,executionPrice:B,priceImpact:N,fee:k}}computeAmountIn({poolInfo:t,amountOut:n,mintIn:r,mintOut:s,slippage:i}){let{baseReserve:o,quoteReserve:u}=t;r.toString()!==t.mintA.address&&r.toString()!==t.mintB.address&&this.logAndCreateError("mintIn does not match pool"),s.toString()!==t.mintA.address&&s.toString()!==t.mintB.address&&this.logAndCreateError("mintOut does not match pool"),this.logDebug("baseReserve:",o.toString()),this.logDebug("quoteReserve:",u.toString());let l=r.toString()===t.mintA.address,[c,m]=l?[t.mintA,t.mintB]:[t.mintB,t.mintA];this.logDebug("currencyOut:",m.symbol||m.address),this.logDebug("amountOut:",new se(n.toString()).div(10**m.decimals).toDecimalPlaces(m.decimals).toString(),c.symbol||c.address),this.logDebug("slippage:",`${i*100}%`);let p=[o,u],d=l?"quote":"base";d==="base"&&p.reverse(),this.logDebug("output side:",d);let[f,y]=p,w=new se(y.toString()).div(10**t[l?"mintB":"mintA"].decimals).div(new se(f.toString()).div(10**t[l?"mintA":"mintB"].decimals));this.logDebug("currentPrice:",`1 ${c.symbol||c.address} \u2248 ${w.toString()} ${m.symbol||m.address}`),this.logDebug("currentPrice invert:",`1 ${m.symbol||m.address} \u2248 ${new se(1).div(w).toString()} ${c.symbol||c.address}`);let g=new ge(0),A=n;if(!A.isZero()){A.gt(y)&&(A=y.sub(new ge(1)));let K=y.sub(A);g=f.mul(A).div(K).mul(qn).div(qn.sub(Nr))}let T=new ge(new se(g.toString()).mul(1+i).toFixed(0)),h=g,P=T;this.logDebug("amountIn:",new se(h.toString()).div(10**c.decimals).toDecimalPlaces(c.decimals).toString()),this.logDebug("maxAmountIn:",new se(P.toString()).div(10**c.decimals).toDecimalPlaces(c.decimals).toString());let k=null;!g.isZero()&&!A.isZero()&&(k=new se(A.toString()).div(10**m.decimals).div(new se(g.toString()).div(10**c.decimals)),this.logDebug("executionPrice:",`1 ${m.symbol||m.address} \u2248 ${k.toDecimalPlaces(Math.max(t.mintA.decimals,t.mintB.decimals)).toString()} ${c.symbol||c.address}`),this.logDebug("executionPrice invert:",`1 ${m.symbol||m.address} \u2248 ${new se(1).div(k).toDecimalPlaces(Math.max(t.mintA.decimals,t.mintB.decimals)).toString()} ${c.symbol||c.address}`));let S=w.mul(h.toString()),x=S.sub(n.toString()).abs().div(S);return this.logDebug("priceImpact:",`${x.toString()}%`),{amountIn:h,maxAmountIn:P,currentPrice:w,executionPrice:k,priceImpact:x}}async swap({poolInfo:t,poolKeys:n,amountIn:r,amountOut:s,inputMint:i,fixedSide:o,txVersion:u,config:l,computeBudgetConfig:c,txTipConfig:m,feePayer:p}){let d=this.createTxBuilder(p),{associatedOnly:f=!0,inputUseSolBalance:y=!0,outputUseSolBalance:w=!0}=l||{},[g,A]=i===t.mintA.address?[t.mintA,t.mintB]:[t.mintB,t.mintA],T=y&&g.address===Gt.toBase58(),h=w&&A.address===Gt.toBase58(),{account:P,instructionParams:k}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:ht,mint:new Ae(g.address),owner:this.scope.ownerPubKey,createInfo:T?{payer:this.scope.ownerPubKey,amount:r}:void 0,skipCloseAccount:!T,notUseTokenAccount:T,associatedOnly:f});d.addInstruction(k||{}),P||this.logAndCreateError("input token account not found",{token:g.symbol||g.address,tokenAccountIn:P,inputTokenUseSolBalance:T,associatedOnly:f});let{account:S,instructionParams:x}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:ht,mint:new Ae(A.address),owner:this.scope.ownerPubKey,createInfo:{payer:this.scope.ownerPubKey,amount:0},skipCloseAccount:!h,notUseTokenAccount:h,associatedOnly:h?!1:f});d.addInstruction(x||{}),S===void 0&&this.logAndCreateError("output token account not found",{token:A.symbol||A.address,tokenAccountOut:S,outputTokenUseSolBalance:h,associatedOnly:f});let K=n||await this.getAmmPoolKeys(t.id),B=4;return t.pooltype.includes("StablePool")&&(B=5),d.addInstruction({instructions:[fo({version:B,poolKeys:K,userKeys:{tokenAccountIn:P,tokenAccountOut:S,owner:this.scope.ownerPubKey},amountIn:r,amountOut:s,fixedSide:o})],instructionTypes:[B===4?U.AmmV4SwapBaseIn:U.AmmV5SwapBaseIn]}),d.addCustomComputeBudget(c),d.addTipInstruction(m),d.versionBuild({txVersion:u})}async getRpcPoolInfo(t){return(await this.getRpcPoolInfos([t]))[t]}async getRpcPoolInfos(t,n){let r=await Rt(this.scope.connection,t.map(c=>({pubkey:new Ae(c)})),n),s={},i=[];for(let c=0;c<t.length;c++){let m=r[c];if(m===null||!m.accountInfo)throw Error("fetch pool info error: "+String(t[c]));let p=Vr.decode(m.accountInfo.data);s[String(t[c])]=z(F({},p),{programId:m.accountInfo.owner}),i.push(p.baseVault,p.quoteVault)}let o={},u=await Rt(this.scope.connection,i.map(c=>({pubkey:new Ae(c)})),n);for(let c=0;c<i.length;c++){let m=u[c].accountInfo;if(m===null)throw Error("fetch vault info error: "+i[c]);o[String(i[c])]=new ge(Xa.decode(m.data).amount.toString())}let l={};for(let[c,m]of Object.entries(s)){let p=o[m.baseVault.toString()].sub(m.baseNeedTakePnl),d=o[m.quoteVault.toString()].sub(m.quoteNeedTakePnl);l[c]=z(F({},m),{baseReserve:p,mintAAmount:o[m.baseVault.toString()],mintBAmount:o[m.quoteVault.toString()],quoteReserve:d,poolPrice:new se(d.toString()).div(new se(10).pow(m.quoteDecimal.toString())).div(new se(p.toString()).div(new se(10).pow(m.baseDecimal.toString())))})}return l}async getPoolInfoFromRpc({poolId:t}){let n=await this.getRpcPoolInfo(t),r=Bo({[t]:n}),s=r[t],i=await this.scope.tradeV2.computePoolToPoolKeys({pools:[r[t]],ammRpcData:{[t]:n}});return{poolRpcData:n,poolInfo:s,poolKeys:i[0]}}};export{Yr as default};
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
//# sourceMappingURL=liquidity.mjs.map