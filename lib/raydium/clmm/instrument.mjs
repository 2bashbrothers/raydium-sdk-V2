var Dn=Object.defineProperty,On=Object.defineProperties;var vn=Object.getOwnPropertyDescriptors;var Qt=Object.getOwnPropertySymbols;var Vn=Object.prototype.hasOwnProperty,qn=Object.prototype.propertyIsEnumerable;var $t=(p,e,t)=>e in p?Dn(p,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):p[e]=t,z=(p,e)=>{for(var t in e||(e={}))Vn.call(e,t)&&$t(p,t,e[t]);if(Qt)for(var t of Qt(e))qn.call(e,t)&&$t(p,t,e[t]);return p},Q=(p,e)=>On(p,vn(e));import{Keypair as Pt,PublicKey as k,SystemProgram as _e,TransactionInstruction as me}from"@solana/web3.js";import Yt from"bn.js";import{PublicKey as Xn}from"@solana/web3.js";import{get as en,set as Gn}from"lodash";var ht=class{constructor(e){this.logLevel=e.logLevel!==void 0?e.logLevel:0,this.name=e.name}set level(e){this.logLevel=e}get time(){return Date.now().toString()}get moduleName(){return this.name}isLogLevel(e){return e<=this.logLevel}error(...e){return this.isLogLevel(0)?(console.error(this.time,this.name,"sdk logger error",...e),this):this}logWithError(...e){let t=e.map(n=>typeof n=="object"?JSON.stringify(n):n).join(", ");throw new Error(t)}warning(...e){return this.isLogLevel(1)?(console.warn(this.time,this.name,"sdk logger warning",...e),this):this}info(...e){return this.isLogLevel(2)?(console.info(this.time,this.name,"sdk logger info",...e),this):this}debug(...e){return this.isLogLevel(3)?(console.debug(this.time,this.name,"sdk logger debug",...e),this):this}},tn={},Un={};function fe(p){let e=en(tn,p);if(!e){let t=en(Un,p);e=new ht({name:p,logLevel:t}),Gn(tn,p,e)}return e}import{MINT_SIZE as Hi,TOKEN_PROGRAM_ID as ji,getTransferFeeConfig as Yi,unpackMint as Zi}from"@solana/spl-token";var At=fe("Raydium_accountInfo_util");async function Fe(p,e,t){let{batchRequest:n,commitment:i="confirmed",chunkCount:o=100}=z({batchRequest:!1},t),s=xt(e,o),r=new Array(s.length).fill([]);if(n){let a=s.map(d=>{let m=p._buildArgs([d.map(l=>l.toBase58())],i,"base64");return{methodName:"getMultipleAccounts",args:m}}),u=xt(a,10);r=(await(await Promise.all(u.map(async d=>await p._rpcBatchRequest(d)))).flat()).map(d=>(d.error&&At.logWithError(`failed to get info for multiple accounts, RPC_ERROR, ${d.error.message}`),d.result.value.map(m=>{if(m){let{data:l,executable:b,lamports:y,owner:g,rentEpoch:f}=m;return l.length!==2&&l[1]!=="base64"&&At.logWithError("info must be base64 encoded, RPC_ERROR"),{data:Buffer.from(l[0],"base64"),executable:b,lamports:y,owner:new Xn(g),rentEpoch:f}}return null})))}else try{r=await Promise.all(s.map(a=>p.getMultipleAccountsInfo(a,i)))}catch(a){a instanceof Error&&At.logWithError(`failed to get info for multiple accounts, RPC_ERROR, ${a.message}`)}return r.flat()}async function Bt(p,e,t){let n=await Fe(p,e.map(i=>i.pubkey),t);return e.map((i,o)=>Q(z({},i),{accountInfo:n[o]}))}import Le from"bn.js";import xo from"decimal.js";import $n from"big.js";import pt from"bn.js";import zn from"toformat";var Hn=zn,Je=Hn;import dt from"big.js";import Yn from"bn.js";import Zn from"decimal.js-light";import Qe from"bn.js";var nn=9007199254740991;function se(p){let e=fe("Raydium_parseBigNumberish");if(p instanceof Qe)return p;if(typeof p=="string"){if(p.match(/^-?[0-9]+$/))return new Qe(p);e.logWithError(`invalid BigNumberish string: ${p}`)}return typeof p=="number"?(p%1&&e.logWithError(`BigNumberish number underflow: ${p}`),(p>=nn||p<=-nn)&&e.logWithError(`BigNumberish number overflow: ${p}`),new Qe(String(p))):typeof p=="bigint"?new Qe(p.toString()):(e.error(`invalid BigNumberish value: ${p}`),new Qe(0))}var mt=fe("module/fraction"),It=Je(dt),$e=Je(Zn),Jn={[0]:$e.ROUND_DOWN,[1]:$e.ROUND_HALF_UP,[2]:$e.ROUND_UP},Qn={[0]:dt.roundDown,[1]:dt.roundHalfUp,[2]:dt.roundUp},v=class{constructor(e,t=new Yn(1)){this.numerator=se(e),this.denominator=se(t)}get quotient(){return this.numerator.div(this.denominator)}invert(){return new v(this.denominator,this.numerator)}add(e){let t=e instanceof v?e:new v(se(e));return this.denominator.eq(t.denominator)?new v(this.numerator.add(t.numerator),this.denominator):new v(this.numerator.mul(t.denominator).add(t.numerator.mul(this.denominator)),this.denominator.mul(t.denominator))}sub(e){let t=e instanceof v?e:new v(se(e));return this.denominator.eq(t.denominator)?new v(this.numerator.sub(t.numerator),this.denominator):new v(this.numerator.mul(t.denominator).sub(t.numerator.mul(this.denominator)),this.denominator.mul(t.denominator))}mul(e){let t=e instanceof v?e:new v(se(e));return new v(this.numerator.mul(t.numerator),this.denominator.mul(t.denominator))}div(e){let t=e instanceof v?e:new v(se(e));return new v(this.numerator.mul(t.denominator),this.denominator.mul(t.numerator))}toSignificant(e,t={groupSeparator:""},n=1){Number.isInteger(e)||mt.logWithError(`${e} is not an integer.`),e<=0&&mt.logWithError(`${e} is not positive.`),$e.set({precision:e+1,rounding:Jn[n]});let i=new $e(this.numerator.toString()).div(this.denominator.toString()).toSignificantDigits(e);return i.toFormat(i.decimalPlaces(),t)}toFixed(e,t={groupSeparator:""},n=1){return Number.isInteger(e)||mt.logWithError(`${e} is not an integer.`),e<0&&mt.logWithError(`${e} is negative.`),It.DP=e,It.RM=Qn[n]||1,new It(this.numerator.toString()).div(this.denominator.toString()).toFormat(e,t)}isZero(){return this.numerator.isZero()}};var ei=fe("Raydium_amount"),rn=Je($n);function ti(p,e){let t="0",n="0";if(p.includes(".")){let i=p.split(".");i.length===2?([t,n]=i,n=n.padEnd(e,"0")):ei.logWithError(`invalid number string, num: ${p}`)}else t=p;return[t,n.slice(0,e)||n]}var de=class extends v{constructor(t,n,i=!0,o){let s=new pt(0),r=Kt.pow(new pt(t.decimals));if(i)s=se(n);else{let a=new pt(0),u=new pt(0);if(typeof n=="string"||typeof n=="number"||typeof n=="bigint"){let[c,d]=ti(n.toString(),t.decimals);a=se(c),u=se(d)}a=a.mul(r),s=a.add(u)}super(s,r);this.logger=fe(o||"TokenAmount"),this.token=t}get raw(){return this.numerator}isZero(){return this.raw.isZero()}gt(t){return this.token.equals(t.token)||this.logger.logWithError("gt token not equals"),this.raw.gt(t.raw)}lt(t){return this.token.equals(t.token)||this.logger.logWithError("lt token not equals"),this.raw.lt(t.raw)}add(t){return this.token.equals(t.token)||this.logger.logWithError("add token not equals"),new de(this.token,this.raw.add(t.raw))}subtract(t){return this.token.equals(t.token)||this.logger.logWithError("sub token not equals"),new de(this.token,this.raw.sub(t.raw))}toSignificant(t=this.token.decimals,n,i=0){return super.toSignificant(t,n,i)}toFixed(t=this.token.decimals,n,i=0){return t>this.token.decimals&&this.logger.logWithError("decimals overflow"),super.toFixed(t,n,i)}toExact(t={groupSeparator:""}){return rn.DP=this.token.decimals,new rn(this.numerator.toString()).div(this.denominator.toString()).toFormat(t)}};import{PublicKey as ni}from"@solana/web3.js";import{TOKEN_PROGRAM_ID as on}from"@solana/spl-token";var sn={chainId:101,address:ni.default.toBase58(),programId:on.toBase58(),decimals:9,symbol:"SOL",name:"solana",logoURI:"https://img-v1.raydium.io/icon/So11111111111111111111111111111111111111112.png",tags:[],priority:2,type:"raydium",extensions:{coingeckoId:"solana"}},ve={chainId:101,address:"So11111111111111111111111111111111111111112",programId:on.toBase58(),decimals:9,symbol:"WSOL",name:"Wrapped SOL",logoURI:"https://img-v1.raydium.io/icon/So11111111111111111111111111111111111111112.png",tags:[],priority:2,type:"raydium",extensions:{coingeckoId:"solana"}};import{PublicKey as Rt}from"@solana/web3.js";import{PublicKey as Y,SystemProgram as an,SYSVAR_RENT_PUBKEY as ii}from"@solana/web3.js";import{TOKEN_PROGRAM_ID as ri}from"@solana/spl-token";function Nt({pubkey:p,isSigner:e=!1,isWritable:t=!0}){return{pubkey:p,isWritable:t,isSigner:e}}var Kr=[Nt({pubkey:ri,isWritable:!1}),Nt({pubkey:an.programId,isWritable:!1}),Nt({pubkey:ii,isWritable:!1})];function Ct({publicKey:p,transformSol:e}){let t=un(p.toString());if(t instanceof Y)return e&&t.equals(et)?St:t;if(e&&t.toString()===et.toBase58())return St;if(typeof t=="string"){if(t===Y.default.toBase58())return Y.default;try{return new Y(t)}catch{throw new Error("invalid public key")}}throw new Error("invalid public key")}function un(p){try{return new Y(p)}catch{return p}}var ft=new Y("MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr"),Lt=new Y("MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr"),Ee=new Y("SysvarRent111111111111111111111111111111111"),Nr=new Y("SysvarC1ock11111111111111111111111111111111"),Ve=new Y("metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s"),Cr=new Y("Sysvar1nstructions1111111111111111111111111"),Lr=an.programId,Rr=new Y("4k3Dyjzvzp8eMZWUXbBCjEvwSkkk59S5iCNLY3QrkX6R"),Mr=new Y("Ea5SjE2Y6yvCeW5dYTn7PYMuW5ikXkvbGdcmSnXeaLjS"),_r=new Y("SRMuApVNdxXokk5GT7XD5cUUgXMBCoAz2LHeuAoKWRt"),Fr=new Y("EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v"),Er=new Y("Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB"),Wr=new Y("mSoLzYCxHdYgdzU16g5QSh3i5K3z3KZK7ytfqcJm7So"),Dr=new Y("7dHbWXmci3dT8UFYWYZweBLXgycu7Y3iL6trKn1Y7ARj"),Or=new Y("USDH1SM1ojwWUga67PGrgFWUHibbjqMvuMaDkRJTgkX"),vr=new Y("NRVwhjBQiUPYtfDT5zRBVJajzFQHaBUNtC7SNVvqRFa"),Vr=new Y("ANAxByE6G2WjFp7A4NqtWYXb3mgruyzZYg3spfxe6Lbo"),qr=new Y("7vfCXTUXx5WJV5JADk17DUJ4ksgau7utNKj4b963voxs"),St=new Y("So11111111111111111111111111111111111111112"),et=Y.default;function lt(p){return Ct({publicKey:p,transformSol:!0})}var Mt=class{constructor({mint:e,decimals:t,symbol:n,name:i,skipMint:o=!1,isToken2022:s=!1}){if(e===et.toBase58()||e instanceof Rt&&et.equals(e)){this.decimals=ve.decimals,this.symbol=ve.symbol,this.name=ve.name,this.mint=new Rt(ve.address),this.isToken2022=!1;return}this.decimals=t,this.symbol=n||e.toString().substring(0,6),this.name=i||e.toString().substring(0,6),this.mint=o?Rt.default:Ct({publicKey:e}),this.isToken2022=s}equals(e){return this===e?!0:this.mint.equals(e.mint)}},Ce=Mt;Ce.WSOL=new Mt(Q(z({},ve),{mint:ve.address}));var _t=class{constructor({decimals:e,symbol:t="UNKNOWN",name:n="UNKNOWN"}){this.decimals=e,this.symbol=t,this.name=n}equals(e){return this===e}},bt=_t;bt.SOL=new _t(sn);import oi from"bn.js";var cn=new v(new oi(100)),We=class extends v{toSignificant(e=5,t,n){return this.mul(cn).toSignificant(e,t,n)}toFixed(e=2,t,n){return this.mul(cn).toFixed(e,t,n)}};var si=fe("Raydium_price"),Be=class extends v{constructor(t){let{baseToken:n,quoteToken:i,numerator:o,denominator:s}=t;super(o,s);this.baseToken=n,this.quoteToken=i,this.scalar=new v(Ft(n.decimals),Ft(i.decimals))}get raw(){return new v(this.numerator,this.denominator)}get adjusted(){return super.mul(this.scalar)}invert(){return new Be({baseToken:this.quoteToken,quoteToken:this.baseToken,denominator:this.numerator,numerator:this.denominator})}mul(t){this.quoteToken!==t.baseToken&&si.logWithError("mul token not equals");let n=super.mul(t);return new Be({baseToken:this.baseToken,quoteToken:t.quoteToken,denominator:n.denominator,numerator:n.numerator})}toSignificant(t=this.quoteToken.decimals,n,i){return this.adjusted.toSignificant(t,n,i)}toFixed(t=this.quoteToken.decimals,n,i){return this.adjusted.toFixed(t,n,i)}};var ai=new Le(0),Mo=new Le(1),_o=new Le(2),Fo=new Le(3),Eo=new Le(5),Kt=new Le(10),Wo=new Le(100),Do=new Le(1e3),Oo=new Le(1e4);function Ft(p){return Kt.pow(se(p))}function xt(p,e=1,t=[]){let n=[...p];if(e<=0)return t;for(;n.length;)t.push(n.splice(0,e));return t}import{PublicKey as ci}from"@solana/web3.js";import{TOKEN_PROGRAM_ID as li}from"@solana/spl-token";import{ComputeBudgetProgram as Ho,Keypair as Zo,PublicKey as ui,Transaction as Qo,TransactionMessage as es,VersionedTransaction as ts}from"@solana/web3.js";var ae={CreateAccount:"CreateAccount",InitAccount:"InitAccount",CreateATA:"CreateATA",CloseAccount:"CloseAccount",TransferAmount:"TransferAmount",InitMint:"InitMint",MintTo:"MintTo",InitMarket:"InitMarket",Util1216OwnerClaim:"Util1216OwnerClaim",SetComputeUnitPrice:"SetComputeUnitPrice",SetComputeUnitLimit:"SetComputeUnitLimit",ClmmCreatePool:"ClmmCreatePool",ClmmOpenPosition:"ClmmOpenPosition",ClmmIncreasePosition:"ClmmIncreasePosition",ClmmDecreasePosition:"ClmmDecreasePosition",ClmmClosePosition:"ClmmClosePosition",ClmmSwapBaseIn:"ClmmSwapBaseIn",ClmmSwapBaseOut:"ClmmSwapBaseOut",ClmmInitReward:"ClmmInitReward",ClmmSetReward:"ClmmSetReward",ClmmCollectReward:"ClmmCollectReward",ClmmLockPosition:"ClmmLockPosition",ClmmHarvestLockPosition:"ClmmHarvestLockPosition",AmmV4Swap:"AmmV4Swap",AmmV4AddLiquidity:"AmmV4AddLiquidity",AmmV4RemoveLiquidity:"AmmV4RemoveLiquidity",AmmV4SimulatePoolInfo:"AmmV4SimulatePoolInfo",AmmV4SwapBaseIn:"AmmV4SwapBaseIn",AmmV4SwapBaseOut:"AmmV4SwapBaseOut",AmmV4CreatePool:"AmmV4CreatePool",AmmV4InitPool:"AmmV4InitPool",AmmV5AddLiquidity:"AmmV5AddLiquidity",AmmV5RemoveLiquidity:"AmmV5RemoveLiquidity",AmmV5SimulatePoolInfo:"AmmV5SimulatePoolInfo",AmmV5SwapBaseIn:"AmmV5SwapBaseIn",AmmV5SwapBaseOut:"AmmV5SwapBaseOut",RouteSwap:"RouteSwap",RouteSwap1:"RouteSwap1",RouteSwap2:"RouteSwap2",FarmV3Deposit:"FarmV3Deposit",FarmV3Withdraw:"FarmV3Withdraw",FarmV3CreateLedger:"FarmV3CreateLedger",FarmV4Withdraw:"FarmV4Withdraw",FarmV5Deposit:"FarmV5Deposit",FarmV5Withdraw:"FarmV5Withdraw",FarmV5CreateLedger:"FarmV5CreateLedger",FarmV6Deposit:"FarmV6Deposit",FarmV6Withdraw:"FarmV6Withdraw",FarmV6Create:"FarmV6Create",FarmV6Restart:"FarmV6Restart",FarmV6CreatorAddReward:"FarmV6CreatorAddReward",FarmV6CreatorWithdraw:"FarmV6CreatorWithdraw",CpmmCreatePool:"CpmmCreatePool",CpmmAddLiquidity:"CpmmAddLiquidity",CpmmWithdrawLiquidity:"CpmmWithdrawLiquidity",CpmmSwapBaseIn:"CpmmSwapBaseIn",CpmmSwapBaseOut:"CpmmSwapBaseOut",CpmmLockLp:"CpmmLockLp",CpmmCollectLockFee:"CpmmCollectLockFee",TransferTip:"TransferTip"};import{TOKEN_PROGRAM_ID as os}from"@solana/spl-token";var ss=fe("Raydium_txUtil");function be(p,e){let[t,n]=ui.findProgramAddressSync(p,e);return{publicKey:t,nonce:n}}function ie(p,e,t){return be([p.toBuffer(),(t!=null?t:li).toBuffer(),e.toBuffer()],new ci("ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL"))}import{PublicKey as x}from"@solana/web3.js";var ps=new x("EhhTKczWMGQt46ynNeRX1WfeagwwJd7ufHvCDjRxjo5Q"),fs=new x("CBuCnLe26faBpcBP2fktp4rp8abpcAnTWft6ZrP5Q4T"),bs=new x("9KEPoZmtHUrBbhWN1v1KWLMkkvwY6WLtAVUCPRtRjP4z"),ys=new x("FarmqiPv5eAj3j1GMdMCMUGXqPUvmquZtMy86QH6rzhG"),gs=new x("CLaimxFqjHzgTJtAGHU47NPhg6qrc5sCnpC4tBLyABQS"),ks=new x("srmqPvymJeFKQ4zGQed1GFppgkRHL9kaELCbyksJtPX"),ws=new x("9xQeWvG816bUx9EPjHmaT23yvVM2ZWbrrpZb9PusVFin"),Ps=new x("675kPX9MHTjS2zt1qfr1NYHuzeLXfQM9H24wFSUt1Mp8"),Ts=new x("5quBtoiQqxF9Jv6KYKctB59NT3gtJD2Y65kdnB1Uev3h"),hs=new x("CDSr3ssLcRB6XYPJwAfFt18MZvEZp4LjHcvzBVZ45duo"),As=new x("CAMMCzo5YL8w4VFF8KVHrK22GGUsp5VTaW7grrKgrWqK"),xs=new x("LockrWmn6K5twhz3y9w1dQERbmgSaRkfnTeTKbpofwE"),Bs=new x("kN1kEznaF5Xbd8LYuqtEFcxzWSBk5Fv6ygX6SqEGJVy"),Ss=new x("CDSr3ssLcRB6XYPJwAfFt18MZvEZp4LjHcvzBVZ45duo"),Is=new x("routeUGWgWzqBWFcrCfv8tritsqukccJPu3q5GPP3xS"),Ks=new x("7YttLkHDoNj9wyDur5pM1ejNaAvT9X4eqaYcHQqtj2G5"),Ns=new x("6FJon3QE27qgPVggARueB22hLvoh22VzJpXv4rBEoSLF"),Cs=new x("CC12se5To1CdEuw7fDS27B7Geo5jJyL7t5UK2B44NgiH"),Ls=new x("9HzJyW1qZsEiSfMUf6L2jo3CcTKAyBmSyKdwQeYisHrC"),Rs=new x("DropEU8AvevN3UrXWXTMuz3rqnMczQVNjq3kcSdW2SQi"),Ms=new x("CPMMoo8L3F4NbTegBCKVNunggL7H1ZpdTHKxQB5qKP1C"),_s=new x("GpMZbSM2GgvTKHJirzeGfMFoaZ8UR2X7F4v8vHTvxFbL"),Fs=new x("DNXgeM9EiiaAbaWvwjHj9fQQLAX5ZsfHyvmYUNRAdNC8"),Es=new x("LockrWmn6K5twhz3y9w1dQERbmgSaRkfnTeTKbpofwE"),Ws=new x("3f7GcQFG397GAaEnv51zR6tsTVihYRydnydDD1cXekxH"),Ds=new x("LanMV9sAd7wArD4vJFi2qDdfnVhFxYSUg6eADduJ3uj"),Os=new x("WLHv2UAZm6z4KyaaELi5pjdbJh6RESMva1Rnn8pJVVh"),vs=new x("DRay6fNdQ5J82H7xV6uq2aV3mNrUZ1J4PgSKsWgptcm6"),Vs=new x("5xqNaZXX5eUi4p5HU4oz9i5QnwRNT2y6oN7yyn4qENeq"),qs=new x("4Bu96XjU84XjPDSpveTVf6LYGCkfW5FK7SNkREWcEfV4"),Gs=new x("6s1xP3hpbAfFoNtUNF8mfHsjr2Bd97JxFJRWLbL6aHuX");var Us={OPEN_BOOK_PROGRAM:new x("EoTcMgcDRTJVZDMZWBoU6rhYHZfkNTVEAfz3uUJRcYGj"),SERUM_PROGRAM_ID_V3:new x("Ray1111111111111111111111111111111111111111"),AMM_V4:new x("DRaya7Kj3aMWQSy19kSjvmuwq9docCHofyP9kanQGaav"),AMM_STABLE:new x("DRayDdXc1NZQ9C3hRWmoSf8zK4iapgMnjdNZWrfwsP8m"),CLMM_PROGRAM_ID:new x("DRayAUgENGQBKVaX8owNhgzkEDyoHTGVEGHVJT1E9pfH"),CLMM_LOCK_PROGRAM_ID:new x("DRay25Usp3YJAi7beckgpGUC7mGJ2cR1AVPxhYfwVCUX"),CLMM_LOCK_AUTH_ID:new x("6Aoh8h2Lw2m5UGxYR8AdAL87jTWYeKoxM52mJRzfYwN"),CREATE_CPMM_POOL_PROGRAM:new x("DRaycpLY18LhpbydsBWbVJtxpNv9oXPgjRSfpF2bWpYb"),CREATE_CPMM_POOL_AUTH:new x("CXniRufdq5xL8t8jZAPxsPZDpuudwuJSPWnbcD5Y5Nxq"),CREATE_CPMM_POOL_FEE_ACC:new x("3oE58BKVt8KuYkGxx8zBojugnymWmBiyafWgMrnb6eYy"),LOCK_CPMM_PROGRAM:new x("DRay25Usp3YJAi7beckgpGUC7mGJ2cR1AVPxhYfwVCUX"),LOCK_CPMM_AUTH:new x("7qWVV8UY2bRJfDLP4s37YzBPKUkVB46DStYJBpYbQzu3"),UTIL1216:x.default,Router:new x("DRaybByLpbUL57LJARs3j8BitTxVfzBg351EaMr5UTCd"),FARM_PROGRAM_ID_V3:new x("DRayWyrLmEW5KEeqs8kdTMMaBabapqagaBC7KWpGtJeZ"),FARM_PROGRAM_ID_V4:new x("Ray1111111111111111111111111111111111111111"),FARM_PROGRAM_ID_V5:new x("DRayiCGSZgku1GTK6rXD6mVDdingXy6APAH1R6R5L2LC"),FARM_PROGRAM_ID_V6:new x("DRayzbYakXs45ELHkzH6vC3fuhQqTAnv5A68gdFuvZyZ"),LAUNCHPAD_PROGRAM:new x("DRay6fNdQ5J82H7xV6uq2aV3mNrUZ1J4PgSKsWgptcm6"),LAUNCHPAD_AUTH:new x("5xqNaZXX5eUi4p5HU4oz9i5QnwRNT2y6oN7yyn4qENeq"),LAUNCHPAD_PLATFORM:new x("2Jx4KTDrVSdWNazuGpcA8n3ZLTRGGBDxAWhuKe2Xcj2a"),LAUNCHPAD_CONFIG:new x("7ZR4zD7PYfY2XxoG1Gxcy2EgEeGYrpxrwzPuwdUBssEt"),FEE_DESTINATION_ID:new x("9y8ENuuZ3b19quffx9hQvRVygG5ky6snHfRvGpuSfeJy"),MODEL_DATA_PUBKEY:new x("Ray1111111111111111111111111111111111111111")};import Se from"bn.js";var tt=1e4;function te(p,e,t,n){if(e===void 0)return{amount:p,fee:void 0,expirationTime:void 0};let i=Q(z({},e),{olderTransferFee:{epoch:BigInt(e.olderTransferFee.epoch),maximumFee:BigInt(e.olderTransferFee.maximumFee),transferFeeBasisPoints:e.olderTransferFee.transferFeeBasisPoints},newerTransferFee:{epoch:BigInt(e.newerTransferFee.epoch),maximumFee:BigInt(e.newerTransferFee.maximumFee),transferFeeBasisPoints:e.newerTransferFee.transferFeeBasisPoints}}),o=t.epoch<i.newerTransferFee.epoch?i.olderTransferFee:i.newerTransferFee,s=new Se(o.maximumFee.toString()),r=t.epoch<i.newerTransferFee.epoch?(Number(i.newerTransferFee.epoch)*t.slotsInEpoch-t.absoluteSlot)*400/1e3:void 0;if(n)if(o.transferFeeBasisPoints===tt){let a=new Se(o.maximumFee.toString());return{amount:p.add(a),fee:a,expirationTime:r}}else{let a=Et(p.mul(new Se(tt)),new Se(tt-o.transferFeeBasisPoints)),u=new Se(o.maximumFee.toString()),c=a.sub(p).gt(u)?p.add(u):a,d=Et(c.mul(new Se(o.transferFeeBasisPoints)),new Se(tt)),m=d.gt(s)?s:d;return{amount:c,fee:m,expirationTime:r}}else{let a=Et(p.mul(new Se(o.transferFeeBasisPoints)),new Se(tt)),u=a.gt(s)?s:a;return{amount:p,fee:u,expirationTime:r}}}function De(p,e){return p===void 0?e:e===void 0?p:Math.min(p,e)}function Et(p,e){let{div:t,mod:n}=p.divmod(e);return n.gt(new Se(0))?t.add(new Se(1)):t}import{PublicKey as Zs,AddressLookupTableAccount as Js}from"@solana/web3.js";import{PublicKey as ba,sendAndConfirmTransaction as ya,SystemProgram as wa,Transaction as Pa,TransactionMessage as ha,VersionedTransaction as Aa}from"@solana/web3.js";import Ba from"axios";import{PublicKey as Ma}from"@solana/web3.js";import Fa from"bn.js";import mi from"bn.js";var va=new mi(1e6);import{ASSOCIATED_TOKEN_PROGRAM_ID as ct,TOKEN_2022_PROGRAM_ID as ee,TOKEN_PROGRAM_ID as U}from"@solana/spl-token";import{PublicKey as Pi}from"@solana/web3.js";import pn,{isBN as fn}from"bn.js";import{bits as uu,BitStructure as cu,blob as di,Blob as lu,cstr as mu,f32 as du,f32be as pu,f64 as fu,f64be as bu,greedy as yu,Layout as pi,ns64 as gu,ns64be as ku,nu64 as wu,nu64be as Pu,offset as Tu,s16 as hu,s16be as Au,s24 as xu,s24be as Bu,s32 as fi,s32be as Su,s40 as Iu,s40be as Ku,s48 as Nu,s48be as Cu,s8 as Lu,seq as bi,struct as Ru,Structure as yi,u16 as gi,u16be as Mu,u24 as _u,u24be as Fu,u32 as Eu,u32be as Wu,u40 as Du,u40be as Ou,u48 as vu,u48be as Vu,u8 as ki,UInt as wi,union as qu,Union as Gu,unionLayoutDiscriminator as Uu,utf8 as Xu}from"@solana/buffer-layout";var Wt=pi,ln=yi;var Dt=wi;var mn=ki,nt=gi;var H=fi;var dn=bi;var we=di;var je=class extends Wt{constructor(t,n,i){super(t,i);this.blob=we(t),this.signed=n}decode(t,n=0){let i=new pn(this.blob.decode(t,n),10,"le");return this.signed?i.fromTwos(this.span*8).clone():i}encode(t,n,i=0){return typeof t=="number"&&(t=new pn(t)),this.signed&&(t=t.toTwos(this.span*8)),this.blob.encode(t.toArrayLike(Buffer,"le",this.span),n,i)}};function $(p){return new Dt(1,p)}function Ye(p){return new Dt(4,p)}function A(p){return new je(8,!1,p)}function F(p){return new je(16,!1,p)}function bn(p){return new je(8,!0,p)}function yn(p){return new je(16,!0,p)}var yt=class extends Wt{constructor(t,n,i,o){super(t.span,o);this.layout=t,this.decoder=n,this.encoder=i}decode(t,n){return this.decoder(this.layout.decode(t,n))}encode(t,n,i){return this.layout.encode(this.encoder(t),n,i)}getSpan(t,n){return this.layout.getSpan(t,n)}};function X(p){return new yt(we(32),e=>new Pi(e),e=>e.toBuffer(),p)}function ye(p){return new yt(mn(),Ti,hi,p)}function Ti(p){if(p===0)return!1;if(p===1)return!0;throw new Error("Invalid bool: "+p)}function hi(p){return p?1:0}var Ot=class extends ln{decode(e,t){return super.decode(e,t)}};function V(p,e,t){return new Ot(p,e,t)}function Z(p,e,t){let n,i=typeof e=="number"?e:fn(e)?e.toNumber():new Proxy(e,{get(o,s){if(!n){let r=Reflect.get(o,"count");n=fn(r)?r.toNumber():r,Reflect.set(o,"count",n)}return Reflect.get(o,s)},set(o,s,r){return s==="count"&&(n=r),Reflect.set(o,s,r)}});return dn(p,i,t)}import Ri from"bn.js";import Ze from"decimal.js";import xe from"bn.js";var J=new xe(0),Ie=new xe(1),Re=new xe(-1),Pe=new xe(1).shln(64),gt=new xe(1).shln(128),vt=Pe.sub(Ie),it=64,gn=gt.subn(1),pe=-443636,ge=-pe,qe=new xe("4295048016"),Ge=new xe("79226673521066979257578248091"),oc=new xe("4295048017"),sc=new xe("79226673521066979257578248090"),kn=16,wn="59543866431248",Pn="184467440737095516",Tn="15793534762490258745",kt=new xe(10).pow(new xe(6));var ac=new xe("18446744073700000000");import L from"bn.js";import Ne from"decimal.js";function wt(p){let e=new ArrayBuffer(4);return new DataView(e).setInt32(0,p,!1),new Uint8Array(e)}function Vt(p,e){let t=0;for(let n=p-1;n>=0&&!e.testn(n);n--)t++;return t}function qt(p,e){let t=0;for(let n=0;n<p&&!e.testn(n);n++)t++;return t}function rt(p,e){for(let t=0;t<p;t++)if(e.testn(t))return!1;return!0}function hn(p,e){return rt(p,e)?null:Vt(p,e)}function An(p,e){return rt(p,e)?null:qt(p,e)}var pc=Buffer.from("amm_config","utf8"),Ai=Buffer.from("pool","utf8"),xi=Buffer.from("pool_vault","utf8"),Bi=Buffer.from("pool_reward_vault","utf8"),xn=Buffer.from("position","utf8"),Si=Buffer.from("tick_array","utf8"),Ii=Buffer.from("operation","utf8"),Ki=Buffer.from("pool_tick_array_bitmap_extension","utf8"),Ni=Buffer.from("observation","utf8");function Bn(p,e,t,n){return be([Ai,e.toBuffer(),t.toBuffer(),n.toBuffer()],p)}function Gt(p,e,t){return be([xi,e.toBuffer(),t.toBuffer()],p)}function Sn(p,e,t){return be([Bi,e.toBuffer(),t.toBuffer()],p)}function q(p,e,t){return be([Si,e.toBuffer(),wt(t)],p)}function Oe(p,e,t,n){return be([xn,e.toBuffer(),wt(t),wt(n)],p)}function Te(p,e){return be([xn,e.toBuffer()],p)}function ot(p){return be([Buffer.from("metadata","utf8"),Ve.toBuffer(),p.toBuffer()],Ve)}function Ut(p){return be([Ii],p)}function le(p,e){return be([Ki,e.toBuffer()],p)}function In(p,e){return be([Ni,e.toBuffer()],p)}var Kn=Buffer.from("locked_position","utf8");function Xt(p,e){return be([Kn,e.toBuffer()],p)}function Nn(p,e){return be([Kn,e.toBuffer()],p)}var fc=Buffer.from("support_mint","utf8");import{PublicKey as he}from"@solana/web3.js";import{TOKEN_2022_PROGRAM_ID as Cn}from"@solana/spl-token";import j from"bn.js";import W from"decimal.js";import Ke from"bn.js";import zt from"decimal.js";var st=class{static getfeeGrowthInside(e,t,n){let i=new Ke(0),o=new Ke(0);e.tickCurrent>=t.tick?(i=t.feeGrowthOutsideX64A,o=t.feeGrowthOutsideX64B):(i=e.feeGrowthGlobalX64A.sub(t.feeGrowthOutsideX64A),o=e.feeGrowthGlobalX64B.sub(t.feeGrowthOutsideX64B));let s=new Ke(0),r=new Ke(0);e.tickCurrent<n.tick?(s=n.feeGrowthOutsideX64A,r=n.feeGrowthOutsideX64B):(s=e.feeGrowthGlobalX64A.sub(n.feeGrowthOutsideX64A),r=e.feeGrowthGlobalX64B.sub(n.feeGrowthOutsideX64B));let a=C.wrappingSubU128(C.wrappingSubU128(e.feeGrowthGlobalX64A,i),s),u=C.wrappingSubU128(C.wrappingSubU128(e.feeGrowthGlobalX64B,o),r);return{feeGrowthInsideX64A:a,feeGrowthInsideBX64:u}}static GetPositionFees(e,t,n,i){let{feeGrowthInsideX64A:o,feeGrowthInsideBX64:s}=this.getfeeGrowthInside(e,n,i),r=C.mulDivFloor(C.wrappingSubU128(o,t.feeGrowthInsideLastX64A),t.liquidity,Pe),a=t.tokenFeesOwedA.add(r),u=C.mulDivFloor(C.wrappingSubU128(s,t.feeGrowthInsideLastX64B),t.liquidity,Pe),c=t.tokenFeesOwedB.add(u);return{tokenFeeAmountA:a,tokenFeeAmountB:c}}static GetPositionFeesV2(e,t,n,i){let{feeGrowthInsideX64A:o,feeGrowthInsideBX64:s}=this.getfeeGrowthInside(e,n,i),r=C.mulDivFloor(C.wrappingSubU128(o,t.feeGrowthInsideLastX64A),t.liquidity,Pe),a=t.tokenFeesOwedA.add(r),u=C.mulDivFloor(C.wrappingSubU128(s,t.feeGrowthInsideLastX64B),t.liquidity,Pe),c=t.tokenFeesOwedB.add(u);return{tokenFeeAmountA:a,tokenFeeAmountB:c}}static GetPositionRewardsV2(e,t,n,i){let o=[],s=this.getRewardGrowthInsideV2(e.tickCurrent,n,i,e.rewardInfos);for(let r=0;r<s.length;r++){let a=s[r],u=t.rewardInfos[r],c=C.wrappingSubU128(a,u.growthInsideLastX64),d=C.mulDivFloor(c,t.liquidity,Pe),m=u.rewardAmountOwed.add(d);o.push(m)}return o}static GetPositionRewards(e,t,n,i){let o=[],s=this.getRewardGrowthInside(e.tickCurrent,n,i,e.rewardInfos);for(let r=0;r<s.length;r++){let a=s[r],u=t.rewardInfos[r],c=C.wrappingSubU128(a,u.growthInsideLastX64),d=C.mulDivFloor(c,t.liquidity,Pe),m=u.rewardAmountOwed.add(d);o.push(m)}return o}static getRewardGrowthInside(e,t,n,i){let o=[];for(let s=0;s<i.length;s++){let r=new Ke(0);t.liquidityGross.eqn(0)?r=i[s].rewardGrowthGlobalX64:e<t.tick?r=i[s].rewardGrowthGlobalX64.sub(t.rewardGrowthsOutsideX64[s]):r=t.rewardGrowthsOutsideX64[s];let a=new Ke(0);n.liquidityGross.eqn(0)||(e<n.tick?a=n.rewardGrowthsOutsideX64[s]:a=i[s].rewardGrowthGlobalX64.sub(n.rewardGrowthsOutsideX64[s])),o.push(C.wrappingSubU128(C.wrappingSubU128(i[s].rewardGrowthGlobalX64,r),a))}return o}static getRewardGrowthInsideV2(e,t,n,i){let o=[];for(let s=0;s<i.length;s++){let r=new Ke(0);t.liquidityGross.eqn(0)?r=i[s].rewardGrowthGlobalX64:e<t.tick?r=i[s].rewardGrowthGlobalX64.sub(t.rewardGrowthsOutsideX64[s]):r=t.rewardGrowthsOutsideX64[s];let a=new Ke(0);n.liquidityGross.eqn(0)||(e<n.tick?a=n.rewardGrowthsOutsideX64[s]:a=i[s].rewardGrowthGlobalX64.sub(n.rewardGrowthsOutsideX64[s])),o.push(C.wrappingSubU128(C.wrappingSubU128(i[s].rewardGrowthGlobalX64,r),a))}return o}static getAmountsFromLiquidity({poolInfo:e,ownerPosition:t,liquidity:n,slippage:i,add:o,epochInfo:s}){var g,f,P,T;let r=N.priceToSqrtPriceX64(new zt(e.price),e.mintA.decimals,e.mintB.decimals),a=N.getSqrtPriceX64FromTick(t.tickLower),u=N.getSqrtPriceX64FromTick(t.tickUpper),c=o?1+i:1-i,d=D.getAmountsFromLiquidity(r,a,u,n,o),[m,l]=[te(d.amountA,(g=e.mintA.extensions)==null?void 0:g.feeConfig,s,!0),te(d.amountB,(f=e.mintB.extensions)==null?void 0:f.feeConfig,s,!0)],[b,y]=[te(new Ke(new zt(d.amountA.toString()).mul(c).toFixed(0)),(P=e.mintA.extensions)==null?void 0:P.feeConfig,s,!0),te(new Ke(new zt(d.amountB.toString()).mul(c).toFixed(0)),(T=e.mintB.extensions)==null?void 0:T.feeConfig,s,!0)];return{liquidity:n,amountA:m,amountB:l,amountSlippageA:b,amountSlippageB:y,expirationTime:De(m.expirationTime,l.expirationTime)}}};var Ci=15,E=class{static async getTickArrays(e,t,n,i,o,s,r){let a=[],u=h.getTickArrayStartIndexByTick(i,o),c=h.getInitializedTickArrayInRange(s,r,o,u,Math.floor(Ci/2));for(let l=0;l<c.length;l++){let{publicKey:b}=q(t,n,c[l]);a.push(b)}let d=(await Fe(e,a)).map(l=>l!==null?at.decode(l.data):null),m={};for(let l=0;l<a.length;l++){let b=d[l];b!==null&&(m[b.startTickIndex]=Q(z({},b),{address:a[l]}))}return m}static nextInitializedTick(e,t,n,i,o,s){let{initializedTick:r,tickArrayAddress:a,tickArrayStartTickIndex:u}=this.nextInitializedTickInOneArray(e,t,n,i,o,s);for(;r==null||r.liquidityGross.lten(0);){if(u=h.getNextTickArrayStartIndex(u,o,s),this.checkIsValidStartIndex(u,o))throw new Error("No enough initialized tickArray");let c=n[u];if(c===void 0)continue;let{nextTick:d,tickArrayAddress:m,tickArrayStartTickIndex:l}=this.firstInitializedTickInOneArray(e,t,c,s);[r,a,u]=[d,m,l]}if(r==null)throw new Error("No invaild tickArray cache");return{nextTick:r,tickArrayAddress:a,tickArrayStartTickIndex:u}}static nextInitializedTickArray(e,t,n,i,o){let s=Math.floor(e/E.tickCount(t)),r=n?h.searchLowBitFromStart(i,o,s-1,1,t):h.searchHightBitFromStart(i,o,s+1,1,t);return r.length>0?{isExist:!0,nextStartIndex:r[0]}:{isExist:!1,nextStartIndex:0}}static firstInitializedTickInOneArray(e,t,n,i){let o;if(i){let r=oe-1;for(;r>=0;){let a=n.ticks[r];if(a.liquidityGross.gtn(0)){o=a;break}r=r-1}}else{let r=0;for(;r<oe;){let a=n.ticks[r];if(a.liquidityGross.gtn(0)){o=a;break}r=r+1}}let{publicKey:s}=q(e,t,n.startTickIndex);return{nextTick:o,tickArrayAddress:s,tickArrayStartTickIndex:n.startTickIndex}}static nextInitializedTickInOneArray(e,t,n,i,o,s){let r=h.getTickArrayStartIndexByTick(i,o),a=Math.floor((i-r)/o),u=n[r];if(u==null)return{initializedTick:void 0,tickArrayAddress:void 0,tickArrayStartTickIndex:r};let c;if(s)for(;a>=0;){let m=u.ticks[a];if(m.liquidityGross.gtn(0)){c=m;break}a=a-1}else for(a=a+1;a<oe;){let m=u.ticks[a];if(m.liquidityGross.gtn(0)){c=m;break}a=a+1}let{publicKey:d}=q(e,t,r);return{initializedTick:c,tickArrayAddress:d,tickArrayStartTickIndex:u.startTickIndex}}static getArrayStartIndex(e,t){let n=this.tickCount(t);return Math.floor(e/n)*n}static checkIsValidStartIndex(e,t){if(h.checkIsOutOfBoundary(e)){if(e>ge)return!1;let n=h.getTickArrayStartIndexByTick(pe,t);return e==n}return e%this.tickCount(t)==0}static tickCount(e){return oe*e}};var Ht=14,Me=class{static maxTickInTickarrayBitmap(e){return e*oe*Ue}static getBitmapTickBoundary(e,t){let n=this.maxTickInTickarrayBitmap(t),i=Math.floor(Math.abs(e)/n);e<0&&Math.abs(e)%n!=0&&(i+=1);let o=n*i;return e<0?{minValue:-o,maxValue:-o+n}:{minValue:o,maxValue:o+n}}static nextInitializedTickArrayStartIndex(e,t,n,i){if(!E.checkIsValidStartIndex(t,n))throw Error("nextInitializedTickArrayStartIndex check error");let o=this.maxTickInTickarrayBitmap(n),s=i?t-E.tickCount(n):t+E.tickCount(n);if(s<-o||s>=o)return{isInit:!1,tickIndex:t};let r=n*oe,a=s/r+512;s<0&&s%r!=0&&a--;let u=Math.abs(a);if(i){let c=e.shln(1024-u-1),d=hn(1024,c);if(d!==null){let m=(u-d-512)*r;return{isInit:!0,tickIndex:m}}else return{isInit:!1,tickIndex:-o}}else{let c=e.shrn(u),d=An(1024,c);if(d!==null){let m=(u+d-512)*r;return{isInit:!0,tickIndex:m}}else return{isInit:!1,tickIndex:o-E.tickCount(n)}}}},ut=class{static getBitmapOffset(e,t){if(!E.checkIsValidStartIndex(e,t))throw new Error("No enough initialized tickArray");this.checkExtensionBoundary(e,t);let n=Me.maxTickInTickarrayBitmap(t),i=Math.floor(Math.abs(e)/n)-1;return e<0&&Math.abs(e)%n===0&&i--,i}static getBitmap(e,t,n){let i=this.getBitmapOffset(e,t);return e<0?{offset:i,tickarrayBitmap:n.negativeTickArrayBitmap[i]}:{offset:i,tickarrayBitmap:n.positiveTickArrayBitmap[i]}}static checkExtensionBoundary(e,t){let{positiveTickBoundary:n,negativeTickBoundary:i}=this.extensionTickBoundary(t);if(e>=i&&e<n)throw Error("checkExtensionBoundary -> InvalidTickArrayBoundary")}static extensionTickBoundary(e){let t=Me.maxTickInTickarrayBitmap(e),n=-t;if(ge<=t)throw Error(`extensionTickBoundary check error: ${ge}, ${t}`);if(n<=pe)throw Error(`extensionTickBoundary check error: ${n}, ${pe}`);return{positiveTickBoundary:t,negativeTickBoundary:n}}static checkTickArrayIsInit(e,t,n){let{tickarrayBitmap:i}=this.getBitmap(e,t,n),o=this.tickArrayOffsetInBitmap(e,t);return{isInitialized:h.mergeTickArrayBitmap(i).testn(o),startIndex:e}}static nextInitializedTickArrayFromOneBitmap(e,t,n,i){let o=E.tickCount(t),s=n?e-o:e+o,{tickarrayBitmap:r}=this.getBitmap(s,t,i);return this.nextInitializedTickArrayInBitmap(r,s,t,n)}static nextInitializedTickArrayInBitmap(e,t,n,i){let{minValue:o,maxValue:s}=Me.getBitmapTickBoundary(t,n),r=this.tickArrayOffsetInBitmap(t,n);if(i){let a=h.mergeTickArrayBitmap(e).shln(Ue-1-r),u=rt(512,a)?null:Vt(512,a);if(u!==null){let c=t-u*E.tickCount(n);return{isInit:!0,tickIndex:c}}else return{isInit:!1,tickIndex:o}}else{let a=h.mergeTickArrayBitmap(e).shrn(r),u=rt(512,a)?null:qt(512,a);if(u!==null){let c=t+u*E.tickCount(n);return{isInit:!0,tickIndex:c}}else return{isInit:!1,tickIndex:s-E.tickCount(n)}}}static tickArrayOffsetInBitmap(e,t){let n=Math.abs(e)%Me.maxTickInTickarrayBitmap(t),i=Math.floor(n/E.tickCount(t));return e<0&&n!=0&&(i=Ue-i),i}};var re=class{static getOutputAmountAndRemainAccounts(e,t,n,i,o,s=!1){let r=n.toBase58()===e.mintA.address,a=[],{isExist:u,startIndex:c,nextAccountMeta:d}=this.getFirstInitializedTickArray(e,r);if(!u||c===void 0||!d)throw new Error("Invalid tick array");a.push(d);let{allTrade:m,amountCalculated:l,accounts:b,sqrtPriceX64:y,feeAmount:g}=Xe.swapCompute(e.programId,e.id,t,e.tickArrayBitmap,e.exBitmapInfo,r,e.ammConfig.tradeFeeRate,e.liquidity,e.tickCurrent,e.tickSpacing,e.sqrtPriceX64,i,c,o,s);return a.push(...b),{allTrade:m,expectedAmountOut:l.mul(Re),remainingAccounts:a,executionPrice:y,feeAmount:g}}static getInputAmountAndRemainAccounts(e,t,n,i,o){let s=n.toBase58()===e.mintB.address,r=[],{isExist:a,startIndex:u,nextAccountMeta:c}=this.getFirstInitializedTickArray(e,s);if(!a||u===void 0||!c)throw new Error("Invalid tick array");try{let y=this.preInitializedTickArrayStartIndex(e,s);if(y.isExist){let{publicKey:g}=q(e.programId,e.id,y.nextStartIndex);r.push(g)}}catch{}r.push(c);let{amountCalculated:d,accounts:m,sqrtPriceX64:l,feeAmount:b}=Xe.swapCompute(e.programId,e.id,t,e.tickArrayBitmap,e.exBitmapInfo,s,e.ammConfig.tradeFeeRate,e.liquidity,e.tickCurrent,e.tickSpacing,e.sqrtPriceX64,i.mul(Re),u,o);return r.push(...m),{expectedAmountIn:d,remainingAccounts:r,executionPrice:l,feeAmount:b}}static getFirstInitializedTickArray(e,t){let{isInitialized:n,startIndex:i}=re.isOverflowDefaultTickarrayBitmap(e.tickSpacing,[e.tickCurrent])?ut.checkTickArrayIsInit(E.getArrayStartIndex(e.tickCurrent,e.tickSpacing),e.tickSpacing,e.exBitmapInfo):h.checkTickArrayIsInitialized(h.mergeTickArrayBitmap(e.tickArrayBitmap),e.tickCurrent,e.tickSpacing);if(n){let{publicKey:r}=q(e.programId,e.id,i);return{isExist:!0,startIndex:i,nextAccountMeta:r}}let{isExist:o,nextStartIndex:s}=this.nextInitializedTickArrayStartIndex(e,E.getArrayStartIndex(e.tickCurrent,e.tickSpacing),t);if(o){let{publicKey:r}=q(e.programId,e.id,s);return{isExist:!0,startIndex:s,nextAccountMeta:r}}return{isExist:!1,nextAccountMeta:void 0,startIndex:void 0}}static preInitializedTickArrayStartIndex(e,t){let n=Math.floor(e.tickCurrent/E.tickCount(e.tickSpacing)),i=t?h.searchHightBitFromStart(e.tickArrayBitmap,e.exBitmapInfo,n+1,1,e.tickSpacing):h.searchLowBitFromStart(e.tickArrayBitmap,e.exBitmapInfo,n-1,1,e.tickSpacing);return i.length>0?{isExist:!0,nextStartIndex:i[0]}:{isExist:!1,nextStartIndex:0}}static nextInitializedTickArrayStartIndex(e,t,n){for(t=E.getArrayStartIndex(e.tickCurrent,e.tickSpacing);;){let{isInit:i,tickIndex:o}=Me.nextInitializedTickArrayStartIndex(h.mergeTickArrayBitmap(e.tickArrayBitmap),t,e.tickSpacing,n);if(i)return{isExist:!0,nextStartIndex:o};t=o;let{isInit:s,tickIndex:r}=ut.nextInitializedTickArrayFromOneBitmap(t,e.tickSpacing,n,e.exBitmapInfo);if(s)return{isExist:!0,nextStartIndex:r};if(t=r,t<pe||t>ge)return{isExist:!1,nextStartIndex:0}}}static async updatePoolRewardInfos({connection:e,apiPoolInfo:t,chainTime:n,poolLiquidity:i,rewardInfos:o}){var r,a,u;let s=[];for(let c=0;c<o.length;c++){let d=o[c],m=(u=(r=t.rewardDefaultInfos[c])==null?void 0:r.mint.programId)!=null?u:(a=await e.getAccountInfo(d.tokenMint))==null?void 0:a.owner;if(m===void 0)throw Error("get new reward mint info error");let l=Q(z({},d),{perSecond:C.x64ToDecimal(d.emissionsPerSecondX64),remainingRewards:void 0,tokenProgramId:new he(m)});if(l.tokenMint.equals(he.default))continue;if(n<=l.openTime.toNumber()||i.eq(J)){s.push(l);continue}let b=new j(Math.min(l.endTime.toNumber(),n)),y=b.sub(l.lastUpdateTime),g=C.mulDivFloor(y,l.emissionsPerSecondX64,i),f=l.rewardGrowthGlobalX64.add(g),P=C.mulDivFloor(y,l.emissionsPerSecondX64,Pe),T=l.rewardTotalEmissioned.add(P);s.push(Q(z({},l),{rewardGrowthGlobalX64:f,rewardTotalEmissioned:T,lastUpdateTime:b}))}return s}static isOverflowDefaultTickarrayBitmap(e,t){let{maxTickBoundary:n,minTickBoundary:i}=this.tickRange(e);for(let o of t){let s=h.getTickArrayStartIndexByTick(o,e);if(s>=n||s<i)return!0}return!1}static tickRange(e){let t=Me.maxTickInTickarrayBitmap(e),n=-t;return t>ge&&(t=E.getArrayStartIndex(ge,e)+E.tickCount(e)),n<pe&&(n=E.getArrayStartIndex(pe,e)),{maxTickBoundary:t,minTickBoundary:n}}static get_tick_array_offset(e,t){if(!E.checkIsValidStartIndex(e,t))throw new Error("No enough initialized tickArray");return e/E.tickCount(t)*Ue}static async fetchExBitmaps({connection:e,exBitmapAddress:t,batchRequest:n}){let i=await Bt(e,t.map(s=>({pubkey:s})),{batchRequest:n}),o={};for(let s of i)s.accountInfo!==null&&(o[s.pubkey.toString()]=Mn.decode(s.accountInfo.data));return o}static async fetchMultiplePoolTickArrays({connection:e,poolKeys:t,batchRequest:n}){let i={},o=[];for(let a of t){let u=h.getTickArrayStartIndexByTick(a.tickCurrent,a.tickSpacing),c=h.getInitializedTickArrayInRange(a.tickArrayBitmap,a.exBitmapInfo,a.tickSpacing,u,7);for(let d of c){let{publicKey:m}=q(a.programId,a.id,d);o.push({pubkey:m}),i[m.toString()]=a.id}}let s=await Bt(e,o,{batchRequest:n}),r={};for(let a of s){if(!a.accountInfo)continue;let u=i[a.pubkey.toString()];if(!u)continue;r[u.toString()]===void 0&&(r[u.toString()]={});let c=at.decode(a.accountInfo.data);r[u.toString()][c.startTickIndex]=Q(z({},c),{address:a.pubkey})}return r}static async fetchPoolsAccountPosition({pools:e,connection:t,ownerInfo:n,batchRequest:i=!1,updateOwnerRewardAndFee:o=!0}){var r;let s=[];for(let a=0;a<e.length;a++){let u=e[a];u!==null&&(s.find(c=>c.equals(u.state.programId))||s.push(u.state.programId))}if(n){let a=n.tokenAccounts.map(m=>m.accountInfo.mint),u=[];for(let m of a)for(let l of s)u.push(Te(l,m).publicKey);let c=await Fe(t,u,{batchRequest:i}),d={};for(let m of c){if(m===null)continue;let l=Rn.decode(m.data),b=l.poolId.toString(),y=e.find(K=>K.state.id.toBase58()===b);if(y===void 0)continue;let g=y.state,f=h._getTickPriceLegacy({poolInfo:g,tick:l.tickLower,baseIn:!0}),P=h._getTickPriceLegacy({poolInfo:g,tick:l.tickUpper,baseIn:!0}),{amountA:T,amountB:B}=D.getAmountsFromLiquidity(g.sqrtPriceX64,f.tickSqrtPriceX64,P.tickSqrtPriceX64,l.liquidity,!1),I=1/(1-Math.sqrt(Math.sqrt(f.price.div(P.price).toNumber())));y.positionAccount=[...(r=y.positionAccount)!=null?r:[],{poolId:l.poolId,nftMint:l.nftMint,priceLower:f.price,priceUpper:P.price,amountA:T,amountB:B,tickLower:l.tickLower,tickUpper:l.tickUpper,liquidity:l.liquidity,feeGrowthInsideLastX64A:l.feeGrowthInsideLastX64A,feeGrowthInsideLastX64B:l.feeGrowthInsideLastX64B,tokenFeesOwedA:l.tokenFeesOwedA,tokenFeesOwedB:l.tokenFeesOwedB,rewardInfos:l.rewardInfos.map(K=>Q(z({},K),{pendingReward:new j(0)})),leverage:I,tokenFeeAmountA:new j(0),tokenFeeAmountB:new j(0)}];let w=await h.getTickArrayAddressByTick(y.state.programId,l.poolId,l.tickLower,y.state.tickSpacing),S=await h.getTickArrayAddressByTick(y.state.programId,l.poolId,l.tickUpper,y.state.tickSpacing);d[`${y.state.programId.toString()}-${l.poolId.toString()}-${l.tickLower}`]=w,d[`${y.state.programId.toString()}-${l.poolId.toString()}-${l.tickUpper}`]=S}if(o){let m=Object.values(d),l=await Fe(t,m,{batchRequest:i}),b={};for(let y=0;y<m.length;y++){let g=l[y];if(g===null)continue;let f=m[y].toString();b[f]=at.decode(g.data)}for(let{state:y,positionAccount:g}of e)if(!!g)for(let f of g){let P=`${y.programId.toString()}-${y.id.toString()}-${f.tickLower}`,T=`${y.programId.toString()}-${y.id.toString()}-${f.tickUpper}`,B=b[d[P].toString()],I=b[d[T].toString()],w=B.ticks[h.getTickOffsetInArray(f.tickLower,y.tickSpacing)],S=I.ticks[h.getTickOffsetInArray(f.tickUpper,y.tickSpacing)],{tokenFeeAmountA:K,tokenFeeAmountB:_}=await st.GetPositionFees(y,f,w,S),G=await st.GetPositionRewards(y,f,w,S);f.tokenFeeAmountA=K.gte(new j(0))?K:new j(0),f.tokenFeeAmountB=_.gte(new j(0))?_:new j(0);for(let O=0;O<G.length;O++)f.rewardInfos[O].pendingReward=G[O].gte(new j(0))?G[O]:new j(0)}}}return e}static computeAmountOut({poolInfo:e,tickArrayCache:t,baseMint:n,epochInfo:i,amountIn:o,slippage:s,priceLimit:r=new W(0),catchLiquidityInsufficient:a=!1}){var ce;let u,c=n.toBase58()===e.mintA.address,[d,m]=c?[e.mintA.extensions.feeConfig,e.mintB.extensions.feeConfig]:[e.mintB.extensions.feeConfig,e.mintA.extensions.feeConfig];r.equals(new W(0))?u=c?qe.add(new j(1)):Ge.sub(new j(1)):u=N.priceToSqrtPriceX64(r,e.mintA.decimals,e.mintB.decimals);let l=te(o,d,i,!1),{allTrade:b,expectedAmountOut:y,remainingAccounts:g,executionPrice:f,feeAmount:P}=re.getOutputAmountAndRemainAccounts(e,t,n,l.amount.sub((ce=l.fee)!=null?ce:J),u,a),T=te(y,m,i,!1),B=N.sqrtPriceX64ToPrice(f,e.mintA.decimals,e.mintB.decimals),I=c?B:new W(1).div(B),w=y.mul(new j(Math.floor((1-s)*1e10))).div(new j(1e10)),S=te(w,m,i,!1),K=c?e.currentPrice:new W(1).div(e.currentPrice),_=new W(I).sub(K).abs(),G=K,O=new We(new W(_).mul(10**15).toFixed(0),new W(G).mul(10**15).toFixed(0));return{allTrade:b,realAmountIn:l,amountOut:T,minAmountOut:S,expirationTime:De(l.expirationTime,T.expirationTime),currentPrice:e.currentPrice,executionPrice:I,priceImpact:O,fee:P,remainingAccounts:g,executionPriceX64:f}}static computeAmountOutFormat({poolInfo:e,tickArrayCache:t,amountIn:n,tokenOut:i,slippage:o,epochInfo:s,catchLiquidityInsufficient:r=!1}){let a=i.address===e.mintB.address,[u,c]=a?[e.mintA,e.mintB]:[e.mintB,e.mintA],[d,m]=[new Ce(Q(z({},u),{mint:u.address,isToken2022:u.programId===Cn.toBase58()})),new Ce(Q(z({},c),{mint:c.address,isToken2022:c.programId===Cn.toBase58()}))],{allTrade:l,realAmountIn:b,amountOut:y,minAmountOut:g,expirationTime:f,currentPrice:P,executionPrice:T,priceImpact:B,fee:I,remainingAccounts:w,executionPriceX64:S}=re.computeAmountOut({poolInfo:e,tickArrayCache:t,baseMint:new he(u.address),amountIn:n,slippage:o,epochInfo:s,catchLiquidityInsufficient:r}),K=Q(z({},b),{amount:new de(d,b.amount),fee:b.fee===void 0?void 0:new de(d,b.fee)}),_=Q(z({},y),{amount:new de(m,y.amount),fee:y.fee===void 0?void 0:new de(m,y.fee)}),G=Q(z({},g),{amount:new de(m,g.amount),fee:g.fee===void 0?void 0:new de(m,g.fee)}),O=new Be({baseToken:d,denominator:new j(10).pow(new j(20+d.decimals)),quoteToken:m,numerator:P.mul(new W(10**(20+m.decimals))).toFixed(0)}),ce=new Be({baseToken:d,denominator:new j(10).pow(new j(20+d.decimals)),quoteToken:m,numerator:T.mul(new W(10**(20+m.decimals))).toFixed(0)}),ne=new de(d,I);return{allTrade:l,realAmountIn:K,amountOut:_,minAmountOut:G,expirationTime:f,currentPrice:O,executionPrice:ce,priceImpact:B,fee:ne,remainingAccounts:w,executionPriceX64:S}}static computeAmountIn({poolInfo:e,tickArrayCache:t,baseMint:n,epochInfo:i,amountOut:o,slippage:s,priceLimit:r=new W(0)}){var G;let a=n.toBase58()===e.mintA.address,u={[e.mintA.address]:e.mintA.extensions.feeConfig,[e.mintB.address]:e.mintB.extensions.feeConfig},c;r.equals(new W(0))?c=a?Ge.sub(new j(1)):qe.add(new j(1)):c=N.priceToSqrtPriceX64(r,e.mintA.decimals,e.mintB.decimals);let d=te(o,u[n.toString()],i,!0),{expectedAmountIn:m,remainingAccounts:l,executionPrice:b,feeAmount:y}=re.getInputAmountAndRemainAccounts(e,t,n,d.amount.sub((G=d.fee)!=null?G:J),c),g=a?e.mintB.address:e.mintA.address,f=te(m,u[g],i,!1),P=N.sqrtPriceX64ToPrice(b,e.mintA.decimals,e.mintB.decimals),T=a?P:new W(1).div(P),B=m.mul(new j(Math.floor((1+s)*1e10))).div(new j(1e10)),I=te(B,u[g],i,!0),w=a?e.currentPrice:new W(1).div(e.currentPrice),S=new W(T).sub(w).abs(),K=w,_=new We(new W(S).mul(10**15).toFixed(0),new W(K).mul(10**15).toFixed(0));return{amountIn:f,maxAmountIn:I,realAmountOut:d,expirationTime:De(f.expirationTime,d.expirationTime),currentPrice:e.currentPrice,executionPrice:T,priceImpact:_,fee:y,remainingAccounts:l}}static estimateAprsForPriceRangeMultiplier({poolInfo:e,aprType:t,positionTickLowerIndex:n,positionTickUpperIndex:i}){var b,y,g;let o=e[t],s=h.getTickPrice({poolInfo:e,tick:n,baseIn:!0}).price.toNumber(),r=h.getTickPrice({poolInfo:e,tick:i,baseIn:!0}).price.toNumber(),a=Math.max(s,o.priceMin),c=Math.min(r,o.priceMax)-a,d=r-s,m=o.priceMax-o.priceMin,l;return c<=0?l=0:d===c?l=m/c:m===c?l=c/d:l=c/m*(c/d),{feeApr:o.feeApr*l,rewardsApr:[((b=o.rewardApr[0])!=null?b:0)*l,((y=o.rewardApr[1])!=null?y:0)*l,((g=o.rewardApr[2])!=null?g:0)*l],apr:o.apr*l}}static estimateAprsForPriceRangeDelta({poolInfo:e,poolLiquidity:t,aprType:n,mintPrice:i,liquidity:o,positionTickLowerIndex:s,positionTickUpperIndex:r,chainTime:a}){let u=n==="day"?1:n==="week"?7:n==="month"?30:0,c=e[n],d=i[lt(e.mintA.address).toString()],m=i[lt(e.mintB.address).toString()],l=e.mintA.decimals,b=e.mintB.decimals;if(!c||!d||!m)return{feeApr:0,rewardsApr:[0,0,0],apr:0};let y=N.priceToSqrtPriceX64(new W(e.price),e.mintA.decimals,e.mintB.decimals),g=N.getSqrtPriceX64FromTick(s),f=N.getSqrtPriceX64FromTick(r),{amountSlippageA:P,amountSlippageB:T}=D.getAmountsFromLiquidityWithSlippage(y,g,f,t,!1,!1,0),{amountSlippageA:B,amountSlippageB:I}=D.getAmountsFromLiquidityWithSlippage(y,g,f,o,!1,!1,0),w=new W(P.toString()).div(new W(10).pow(l)).mul(d.value).add(new W(T.toString()).div(new W(10).pow(b)).mul(m.value)),S=new W(B.toString()).div(new W(10).pow(l)).mul(d.value).add(new W(I.toString()).div(new W(10).pow(b)).mul(m.value)),K=new W(1).div(w.add(S)),G=new W(c.volumeFee).mul(365).div(u).mul(K).mul(100).toNumber(),O=3600*24*365,ce=e.rewardDefaultInfos.map(ne=>{var Zt,Jt;let ke=ne.mint.decimals,He=i[ne.mint.address];return a<((Zt=ne.startTime)!=null?Zt:0)||a>((Jt=ne.endTime)!=null?Jt:0)||!ne.perSecond||!He||ke===void 0?0:new W(He.value).mul(new W(ne.perSecond).mul(O)).div(new W(10).pow(ke)).mul(K).mul(100).toNumber()});return{feeApr:G,rewardsApr:ce,apr:G+ce.reduce((ne,ke)=>ne+ke,0)}}static async getLiquidityAmountOutFromAmountIn({poolInfo:e,inputA:t,tickLower:n,tickUpper:i,amount:o,slippage:s,add:r,epochInfo:a,amountHasFee:u}){var f,P;let c=N.priceToSqrtPriceX64(new W(e.price),e.mintA.decimals,e.mintB.decimals),d=N.getSqrtPriceX64FromTick(n),m=N.getSqrtPriceX64FromTick(i),l=te(o,(f=e[t?"mintA":"mintB"].extensions)==null?void 0:f.feeConfig,a,!u),b=new j(new W(l.amount.sub((P=l.fee)!=null?P:J).toString()).toFixed(0)),y;if(c.lte(d))y=t?D.getLiquidityFromTokenAmountA(d,m,b,!r):new j(0);else if(c.lte(m)){let T=D.getLiquidityFromTokenAmountA(c,m,b,!r),B=D.getLiquidityFromTokenAmountB(d,c,b);y=t?T:B}else y=t?new j(0):D.getLiquidityFromTokenAmountB(d,m,b);let g=await re.getAmountsFromLiquidity({epochInfo:a,poolInfo:e,tickLower:n,tickUpper:i,liquidity:y,slippage:s,add:r});return{liquidity:y,amountA:t?l:g.amountA,amountB:t?g.amountB:l,amountSlippageA:t?l:g.amountSlippageA,amountSlippageB:t?g.amountSlippageB:l,expirationTime:g.expirationTime}}static async getAmountsFromLiquidity({epochInfo:e,poolInfo:t,tickLower:n,tickUpper:i,liquidity:o,slippage:s,add:r}){var g,f,P,T;let a=N.getSqrtPriceX64FromTick(n),u=N.getSqrtPriceX64FromTick(i),c=r?1+s:1-s,d=D.getAmountsFromLiquidity(N.priceToSqrtPriceX64(new W(t.price),t.mintA.decimals,t.mintB.decimals),a,u,o,r),[m,l]=[te(d.amountA,(g=t.mintA.extensions)==null?void 0:g.feeConfig,e,!0),te(d.amountB,(f=t.mintB.extensions)==null?void 0:f.feeConfig,e,!0)],[b,y]=[te(d.amountA.muln(c),(P=t.mintA.extensions)==null?void 0:P.feeConfig,e,!0),te(d.amountB.muln(c),(T=t.mintB.extensions)==null?void 0:T.feeConfig,e,!0)];return{liquidity:o,amountA:m,amountB:l,amountSlippageA:b,amountSlippageB:y,expirationTime:De(m.expirationTime,l.expirationTime)}}static async fetchComputeMultipleClmmInfo({connection:e,poolList:t,rpcDataMap:n={}}){let i=t.filter(a=>!n[a.id]).map(a=>new he(a.id));(await Fe(e,i)).forEach((a,u)=>{!a||(n[i[u].toBase58()]=Ln.decode(a.data))});let s=t.map(a=>le(new he(a.programId),new he(a.id)).publicKey),r=await re.fetchExBitmaps({connection:e,exBitmapAddress:s,batchRequest:!1});return t.reduce((a,u)=>Q(z({},a),{[u.id]:Q(z({},n[u.id]),{id:new he(u.id),version:6,programId:new he(u.programId),mintA:u.mintA,mintB:u.mintB,ammConfig:Q(z({},u.config),{id:new he(u.config.id),fundOwner:""}),currentPrice:new W(u.price),exBitmapAccount:le(new he(u.programId),new he(u.id)).publicKey,exBitmapInfo:r[le(new he(u.programId),new he(u.id)).publicKey.toBase58()],startTime:n[u.id].startTime.toNumber(),rewardInfos:n[u.id].rewardInfos})}),{})}static async fetchComputeClmmInfo({connection:e,poolInfo:t,rpcData:n}){return(await this.fetchComputeMultipleClmmInfo({connection:e,rpcDataMap:n?{[t.id]:n}:void 0,poolList:[t]}))[t.id]}};var C=class{static mulDivRoundingUp(e,t,n){let i=e.mul(t),o=i.div(n);return i.mod(n).eq(J)||(o=o.add(Ie)),o}static mulDivFloor(e,t,n){if(n.eq(J))throw new Error("division by 0");return e.mul(t).div(n)}static mulDivCeil(e,t,n){if(n.eq(J))throw new Error("division by 0");return e.mul(t).add(n.sub(Ie)).div(n)}static x64ToDecimal(e,t){return new Ne(e.toString()).div(Ne.pow(2,64)).toDecimalPlaces(t)}static decimalToX64(e){return new L(e.mul(Ne.pow(2,64)).floor().toFixed())}static wrappingSubU128(e,t){return e.add(gt).sub(t).mod(gt)}};function ue(p,e){return jt(p.mul(e),64,256)}function Li(p,e,t){let n=p.toTwos(t).shln(e);return n.imaskn(t+1),n.fromTwos(t)}function jt(p,e,t){let n=p.toTwos(t).shrn(e);return n.imaskn(t-e+1),n.fromTwos(t-e)}var N=class{static sqrtPriceX64ToPrice(e,t,n){return C.x64ToDecimal(e).pow(2).mul(Ne.pow(10,t-n))}static priceToSqrtPriceX64(e,t,n){return C.decimalToX64(e.mul(Ne.pow(10,n-t)).sqrt())}static getNextSqrtPriceX64FromInput(e,t,n,i){if(!e.gt(J))throw new Error("sqrtPriceX64 must greater than 0");if(!t.gt(J))throw new Error("liquidity must greater than 0");return i?this.getNextSqrtPriceFromTokenAmountARoundingUp(e,t,n,!0):this.getNextSqrtPriceFromTokenAmountBRoundingDown(e,t,n,!0)}static getNextSqrtPriceX64FromOutput(e,t,n,i){if(!e.gt(J))throw new Error("sqrtPriceX64 must greater than 0");if(!t.gt(J))throw new Error("liquidity must greater than 0");return i?this.getNextSqrtPriceFromTokenAmountBRoundingDown(e,t,n,!1):this.getNextSqrtPriceFromTokenAmountARoundingUp(e,t,n,!1)}static getNextSqrtPriceFromTokenAmountARoundingUp(e,t,n,i){if(n.eq(J))return e;let o=t.shln(it);if(i){let s=o,r=o.add(n.mul(e));return r.gte(s)?C.mulDivCeil(s,e,r):C.mulDivRoundingUp(s,Ie,s.div(e).add(n))}else{let s=n.mul(e);if(!o.gt(s))throw new Error("getNextSqrtPriceFromTokenAmountARoundingUp,liquidityLeftShift must gt amountMulSqrtPrice");let r=o.sub(s);return C.mulDivCeil(o,e,r)}}static getNextSqrtPriceFromTokenAmountBRoundingDown(e,t,n,i){let o=n.shln(it);if(i)return e.add(o.div(t));{let s=C.mulDivRoundingUp(o,Ie,t);if(!e.gt(s))throw new Error("getNextSqrtPriceFromTokenAmountBRoundingDown sqrtPriceX64 must gt amountDivLiquidity");return e.sub(s)}}static getSqrtPriceX64FromTick(e){if(!Number.isInteger(e))throw new Error("tick must be integer");if(e<pe||e>ge)throw new Error("tick must be in MIN_TICK and MAX_TICK");let t=e<0?e*-1:e,n=(t&1)!=0?new L("18445821805675395072"):new L("18446744073709551616");return(t&2)!=0&&(n=ue(n,new L("18444899583751176192"))),(t&4)!=0&&(n=ue(n,new L("18443055278223355904"))),(t&8)!=0&&(n=ue(n,new L("18439367220385607680"))),(t&16)!=0&&(n=ue(n,new L("18431993317065453568"))),(t&32)!=0&&(n=ue(n,new L("18417254355718170624"))),(t&64)!=0&&(n=ue(n,new L("18387811781193609216"))),(t&128)!=0&&(n=ue(n,new L("18329067761203558400"))),(t&256)!=0&&(n=ue(n,new L("18212142134806163456"))),(t&512)!=0&&(n=ue(n,new L("17980523815641700352"))),(t&1024)!=0&&(n=ue(n,new L("17526086738831433728"))),(t&2048)!=0&&(n=ue(n,new L("16651378430235570176"))),(t&4096)!=0&&(n=ue(n,new L("15030750278694412288"))),(t&8192)!=0&&(n=ue(n,new L("12247334978884435968"))),(t&16384)!=0&&(n=ue(n,new L("8131365268886854656"))),(t&32768)!=0&&(n=ue(n,new L("3584323654725218816"))),(t&65536)!=0&&(n=ue(n,new L("696457651848324352"))),(t&131072)!=0&&(n=ue(n,new L("26294789957507116"))),(t&262144)!=0&&(n=ue(n,new L("37481735321082"))),e>0&&(n=gn.div(n)),n}static getTickFromPrice(e,t,n){return N.getTickFromSqrtPriceX64(N.priceToSqrtPriceX64(e,t,n))}static getTickFromSqrtPriceX64(e){if(e.gt(Ge)||e.lt(qe))throw new Error("Provided sqrtPrice is not within the supported sqrtPrice range.");let t=e.bitLength()-1,n=new L(t-64),i=Li(n,32,128),o=new L("8000000000000000","hex"),s=0,r=new L(0),a=t>=64?e.shrn(t-63):e.shln(63-t);for(;o.gt(new L(0))&&s<kn;){a=a.mul(a);let b=a.shrn(127);a=a.shrn(63+b.toNumber()),r=r.add(o.mul(b)),o=o.shrn(1),s+=1}let u=r.shrn(32),d=i.add(u).mul(new L(wn)),m=jt(d.sub(new L(Pn)),64,128).toNumber(),l=jt(d.add(new L(Tn)),64,128).toNumber();return m==l?m:N.getSqrtPriceX64FromTick(l).lte(e)?l:m}},ze=class{static getTickWithPriceAndTickspacing(e,t,n,i){let s=N.getTickFromSqrtPriceX64(N.priceToSqrtPriceX64(e,n,i))/t;return s<0?s=Math.floor(s):s=Math.ceil(s),s*t}static roundPriceWithTickspacing(e,t,n,i){let o=ze.getTickWithPriceAndTickspacing(e,t,n,i),s=N.getSqrtPriceX64FromTick(o);return N.sqrtPriceX64ToPrice(s,n,i)}},D=class{static addDelta(e,t){return e.add(t)}static getTokenAmountAFromLiquidity(e,t,n,i){if(e.gt(t)&&([e,t]=[t,e]),!e.gt(J))throw new Error("sqrtPriceX64A must greater than 0");let o=n.ushln(it),s=t.sub(e);return i?C.mulDivRoundingUp(C.mulDivCeil(o,s,t),Ie,e):C.mulDivFloor(o,s,t).div(e)}static getTokenAmountBFromLiquidity(e,t,n,i){if(e.gt(t)&&([e,t]=[t,e]),!e.gt(J))throw new Error("sqrtPriceX64A must greater than 0");return i?C.mulDivCeil(n,t.sub(e),Pe):C.mulDivFloor(n,t.sub(e),Pe)}static getLiquidityFromTokenAmountA(e,t,n,i){e.gt(t)&&([e,t]=[t,e]);let o=n.mul(e).mul(t),s=t.sub(e),r=o.div(s);return i?C.mulDivRoundingUp(r,Ie,vt):r.shrn(it)}static getLiquidityFromTokenAmountB(e,t,n){return e.gt(t)&&([e,t]=[t,e]),C.mulDivFloor(n,vt,t.sub(e))}static getLiquidityFromTokenAmounts(e,t,n,i,o){if(t.gt(n)&&([t,n]=[n,t]),e.lte(t))return D.getLiquidityFromTokenAmountA(t,n,i,!1);if(e.lt(n)){let s=D.getLiquidityFromTokenAmountA(e,n,i,!1),r=D.getLiquidityFromTokenAmountB(t,e,o);return s.lt(r)?s:r}else return D.getLiquidityFromTokenAmountB(t,n,o)}static getAmountsFromLiquidity(e,t,n,i,o){if(t.gt(n)&&([t,n]=[n,t]),e.lte(t))return{amountA:D.getTokenAmountAFromLiquidity(t,n,i,o),amountB:new L(0)};if(e.lt(n)){let s=D.getTokenAmountAFromLiquidity(e,n,i,o),r=D.getTokenAmountBFromLiquidity(t,e,i,o);return{amountA:s,amountB:r}}else return{amountA:new L(0),amountB:D.getTokenAmountBFromLiquidity(t,n,i,o)}}static getAmountsFromLiquidityWithSlippage(e,t,n,i,o,s,r){let{amountA:a,amountB:u}=D.getAmountsFromLiquidity(e,t,n,i,s),c=o?1+r:1-r,d=new L(new Ne(a.toString()).mul(c).toFixed(0)),m=new L(new Ne(u.toString()).mul(c).toFixed(0));return{amountSlippageA:d,amountSlippageB:m}}static getAmountsOutFromLiquidity({poolInfo:e,tickLower:t,tickUpper:n,liquidity:i,slippage:o,add:s,epochInfo:r,amountAddFee:a}){var P,T,B,I;let u=N.priceToSqrtPriceX64(new Ne(e.price),e.mintA.decimals,e.mintB.decimals),c=N.getSqrtPriceX64FromTick(t),d=N.getSqrtPriceX64FromTick(n),m=s?1+o:1-o,l=D.getAmountsFromLiquidity(u,c,d,i,s),[b,y]=[te(l.amountA,(P=e.mintA.extensions)==null?void 0:P.feeConfig,r,a),te(l.amountB,(T=e.mintB.extensions)==null?void 0:T.feeConfig,r,a)],[g,f]=[te(new L(new Ne(l.amountA.toString()).mul(m).toFixed(0)),(B=e.mintA.extensions)==null?void 0:B.feeConfig,r,a),te(new L(new Ne(l.amountB.toString()).mul(m).toFixed(0)),(I=e.mintB.extensions)==null?void 0:I.feeConfig,r,a)];return{liquidity:i,amountA:b,amountB:y,amountSlippageA:g,amountSlippageB:f,expirationTime:De(b.expirationTime,y.expirationTime)}}},Xe=class{static swapCompute(e,t,n,i,o,s,r,a,u,c,d,m,l,b,y=!1){if(m.eq(J))throw new Error("amountSpecified must not be 0");if(b||(b=s?qe.add(Ie):Ge.sub(Ie)),s){if(b.lt(qe))throw new Error("sqrtPriceX64 must greater than MIN_SQRT_PRICE_X64");if(b.gte(d))throw new Error("sqrtPriceX64 must smaller than current")}else{if(b.gt(Ge))throw new Error("sqrtPriceX64 must smaller than MAX_SQRT_PRICE_X64");if(b.lte(d))throw new Error("sqrtPriceX64 must greater than current")}let g=m.gt(J),f={amountSpecifiedRemaining:m,amountCalculated:J,sqrtPriceX64:d,tick:u>l?Math.min(l+E.tickCount(c)-1,u):l,accounts:[],liquidity:a,feeAmount:new L(0)},P=l,T=n[l],B=0,I=!s&&T.startTickIndex===f.tick;for(;!f.amountSpecifiedRemaining.eq(J)&&!f.sqrtPriceX64.eq(b);){B>10;let w={};w.sqrtPriceStartX64=f.sqrtPriceX64;let S=h.nextInitTick(T,f.tick,c,s,I),K=S||null,_=null;if(!(K!=null&&K.liquidityGross.gtn(0))){let O=re.nextInitializedTickArrayStartIndex({tickCurrent:f.tick,tickSpacing:c,tickArrayBitmap:i,exBitmapInfo:o},P,s);if(!O.isExist){if(y)return{allTrade:!1,amountSpecifiedRemaining:f.amountSpecifiedRemaining,amountCalculated:f.amountCalculated,feeAmount:f.feeAmount,sqrtPriceX64:f.sqrtPriceX64,liquidity:f.liquidity,tickCurrent:f.tick,accounts:f.accounts};throw Error("swapCompute LiquidityInsufficient")}P=O.nextStartIndex;let{publicKey:ce}=q(e,t,P);_=ce,T=n[P];try{K=h.firstInitializedTick(T,s)}catch{throw Error("not found next tick info")}}w.tickNext=K.tick,w.initialized=K.liquidityGross.gtn(0),l!==P&&_&&(f.accounts.push(_),l=P),w.tickNext<pe?w.tickNext=pe:w.tickNext>ge&&(w.tickNext=ge),w.sqrtPriceNextX64=N.getSqrtPriceX64FromTick(w.tickNext);let G;if(s&&w.sqrtPriceNextX64.lt(b)||!s&&w.sqrtPriceNextX64.gt(b)?G=b:G=w.sqrtPriceNextX64,[f.sqrtPriceX64,w.amountIn,w.amountOut,w.feeAmount]=Xe.swapStepCompute(f.sqrtPriceX64,G,f.liquidity,f.amountSpecifiedRemaining,r,s),f.feeAmount=f.feeAmount.add(w.feeAmount),g?(f.amountSpecifiedRemaining=f.amountSpecifiedRemaining.sub(w.amountIn.add(w.feeAmount)),f.amountCalculated=f.amountCalculated.sub(w.amountOut)):(f.amountSpecifiedRemaining=f.amountSpecifiedRemaining.add(w.amountOut),f.amountCalculated=f.amountCalculated.add(w.amountIn.add(w.feeAmount))),f.sqrtPriceX64.eq(w.sqrtPriceNextX64)){if(w.initialized){let O=K.liquidityNet;s&&(O=O.mul(Re)),f.liquidity=D.addDelta(f.liquidity,O)}I=w.tickNext!=f.tick&&!s&&T.startTickIndex===w.tickNext,f.tick=s?w.tickNext-1:w.tickNext}else if(f.sqrtPriceX64!=w.sqrtPriceStartX64){let O=N.getTickFromSqrtPriceX64(f.sqrtPriceX64);I=O!=f.tick&&!s&&T.startTickIndex===O,f.tick=O}++B}try{let{nextStartIndex:w,isExist:S}=E.nextInitializedTickArray(f.tick,c,s,i,o);S&&l!==w&&(f.accounts.push(q(e,t,w).publicKey),l=w)}catch{}return{allTrade:!0,amountSpecifiedRemaining:J,amountCalculated:f.amountCalculated,feeAmount:f.feeAmount,sqrtPriceX64:f.sqrtPriceX64,liquidity:f.liquidity,tickCurrent:f.tick,accounts:f.accounts}}static swapStepCompute(e,t,n,i,o,s){let r={sqrtPriceX64Next:new L(0),amountIn:new L(0),amountOut:new L(0),feeAmount:new L(0)},a=i.gte(J);if(a){let c=C.mulDivFloor(i,kt.sub(new L(o.toString())),kt);r.amountIn=s?D.getTokenAmountAFromLiquidity(t,e,n,!0):D.getTokenAmountBFromLiquidity(e,t,n,!0),c.gte(r.amountIn)?r.sqrtPriceX64Next=t:r.sqrtPriceX64Next=N.getNextSqrtPriceX64FromInput(e,n,c,s)}else r.amountOut=s?D.getTokenAmountBFromLiquidity(t,e,n,!1):D.getTokenAmountAFromLiquidity(e,t,n,!1),i.mul(Re).gte(r.amountOut)?r.sqrtPriceX64Next=t:r.sqrtPriceX64Next=N.getNextSqrtPriceX64FromOutput(e,n,i.mul(Re),s);let u=t.eq(r.sqrtPriceX64Next);return s?(u&&a||(r.amountIn=D.getTokenAmountAFromLiquidity(r.sqrtPriceX64Next,e,n,!0)),u&&!a||(r.amountOut=D.getTokenAmountBFromLiquidity(r.sqrtPriceX64Next,e,n,!1))):(r.amountIn=u&&a?r.amountIn:D.getTokenAmountBFromLiquidity(e,r.sqrtPriceX64Next,n,!0),r.amountOut=u&&!a?r.amountOut:D.getTokenAmountAFromLiquidity(e,r.sqrtPriceX64Next,n,!1)),!a&&r.amountOut.gt(i.mul(Re))&&(r.amountOut=i.mul(Re)),a&&!r.sqrtPriceX64Next.eq(t)?r.feeAmount=i.sub(r.amountIn):r.feeAmount=C.mulDivCeil(r.amountIn,new L(o),kt.sub(new L(o))),[r.sqrtPriceX64Next,r.amountIn,r.amountOut,r.feeAmount]}};var oe=60,Ue=512,h=class{static getTickArrayAddressByTick(e,t,n,i){let o=h.getTickArrayStartIndexByTick(n,i),{publicKey:s}=q(e,t,o);return s}static getTickOffsetInArray(e,t){if(e%t!=0)throw new Error("tickIndex % tickSpacing not equal 0");let n=h.getTickArrayStartIndexByTick(e,t),i=Math.floor((e-n)/t);if(i<0||i>=oe)throw new Error("tick offset in array overflow");return i}static getTickArrayBitIndex(e,t){let n=E.tickCount(t),i=e/n;return e<0&&e%n!=0?i=Math.ceil(i)-1:i=Math.floor(i),i}static getTickArrayStartIndexByTick(e,t){return this.getTickArrayBitIndex(e,t)*E.tickCount(t)}static getTickArrayOffsetInBitmapByTick(e,t){let n=t*oe,i=Math.floor(e/n)+512;return Math.abs(i)}static checkTickArrayIsInitialized(e,t,n){let i=n*oe,o=Math.floor(t/i)+512,s=Math.abs(o);return{isInitialized:e.testn(s),startIndex:(s-512)*i}}static getNextTickArrayStartIndex(e,t,n){return n?e-t*oe:e+t*oe}static mergeTickArrayBitmap(e){let t=new Ri(0);for(let n=0;n<e.length;n++)t=t.add(e[n].shln(64*n));return t}static getInitializedTickArrayInRange(e,t,n,i,o){let s=Math.floor(i/(n*oe));return[...h.searchLowBitFromStart(e,t,s-1,o,n),...h.searchHightBitFromStart(e,t,s,o,n)]}static getAllInitializedTickArrayStartIndex(e,t,n){return h.searchHightBitFromStart(e,t,-7680,Ue,n)}static getAllInitializedTickArrayInfo(e,t,n,i,o){let s=[],r=h.getAllInitializedTickArrayStartIndex(n,i,o);for(let a of r){let{publicKey:u}=q(e,t,a);s.push({tickArrayStartIndex:a,tickArrayAddress:u})}return s}static getAllInitializedTickInTickArray(e){return e.ticks.filter(t=>t.liquidityGross.gtn(0))}static searchLowBitFromStart(e,t,n,i,o){let s=[...[...t.negativeTickArrayBitmap].reverse(),e.slice(0,8),e.slice(8,16),...t.positiveTickArrayBitmap].map(u=>h.mergeTickArrayBitmap(u)),r=[];for(;n>=-7680;){let u=Math.floor((n+7680)/512),c=(n+7680)%512;if(s[u].testn(c)&&r.push(n),n--,r.length===i)break}let a=E.tickCount(o);return r.map(u=>u*a)}static searchHightBitFromStart(e,t,n,i,o){let s=[...[...t.negativeTickArrayBitmap].reverse(),e.slice(0,8),e.slice(8,16),...t.positiveTickArrayBitmap].map(u=>h.mergeTickArrayBitmap(u)),r=[];for(;n<7680;){let u=Math.floor((n+7680)/512),c=(n+7680)%512;if(s[u].testn(c)&&r.push(n),n++,r.length===i)break}let a=E.tickCount(o);return r.map(u=>u*a)}static checkIsOutOfBoundary(e){return e<pe||e>ge}static nextInitTick(e,t,n,i,o){if(E.getArrayStartIndex(t,n)!=e.startTickIndex)return null;let r=Math.floor((t-e.startTickIndex)/n);if(i)for(;r>=0;){if(e.ticks[r].liquidityGross.gtn(0))return e.ticks[r];r=r-1}else for(o||(r=r+1);r<oe;){if(e.ticks[r].liquidityGross.gtn(0))return e.ticks[r];r=r+1}return null}static firstInitializedTick(e,t){if(t){let n=oe-1;for(;n>=0;){if(e.ticks[n].liquidityGross.gtn(0))return e.ticks[n];n=n-1}}else{let n=0;for(;n<oe;){if(e.ticks[n].liquidityGross.gtn(0))return e.ticks[n];n=n+1}}throw Error(`firstInitializedTick check error: ${e} - ${t}`)}static _getTickPriceLegacy({poolInfo:e,tick:t,baseIn:n}){let i=N.getSqrtPriceX64FromTick(t),o=N.sqrtPriceX64ToPrice(i,e.mintA.decimals,e.mintB.decimals);return n?{tick:t,price:o,tickSqrtPriceX64:i}:{tick:t,price:new Ze(1).div(o),tickSqrtPriceX64:i}}static _getPriceAndTickLegacy({poolInfo:e,price:t,baseIn:n}){let i=n?t:new Ze(1).div(t),o=ze.getTickWithPriceAndTickspacing(i,e.ammConfig.tickSpacing,e.mintA.decimals,e.mintB.decimals),s=N.getSqrtPriceX64FromTick(o),r=N.sqrtPriceX64ToPrice(s,e.mintA.decimals,e.mintB.decimals);return n?{tick:o,price:r}:{tick:o,price:new Ze(1).div(r)}}static getTickPrice({poolInfo:e,tick:t,baseIn:n}){let i=N.getSqrtPriceX64FromTick(t),o=N.sqrtPriceX64ToPrice(i,e.mintA.decimals,e.mintB.decimals);return n?{tick:t,price:o,tickSqrtPriceX64:i}:{tick:t,price:new Ze(1).div(o),tickSqrtPriceX64:i}}static getPriceAndTick({poolInfo:e,price:t,baseIn:n}){let i=n?t:new Ze(1).div(t),o=ze.getTickWithPriceAndTickspacing(i,e.config.tickSpacing,e.mintA.decimals,e.mintB.decimals),s=N.getSqrtPriceX64FromTick(o),r=N.sqrtPriceX64ToPrice(s,e.mintA.decimals,e.mintB.decimals);return n?{tick:o,price:r}:{tick:o,price:new Ze(1).div(r)}}};var Al=V([we(8),$("bump"),nt("index"),X(""),Ye("protocolFeeRate"),Ye("tradeFeeRate"),nt("tickSpacing"),Z(A(),8,"")]),Mi=V([Ye("blockTimestamp"),bn("tickCumulative"),Z(A(),4)]),_n=V([we(8),ye("initialized"),A("recentEpoch"),nt("observationIndex"),X("poolId"),Z(Mi,100,"observations"),Z(A(),4)]),_i=V([$("rewardState"),A("openTime"),A("endTime"),A("lastUpdateTime"),F("emissionsPerSecondX64"),A("rewardTotalEmissioned"),A("rewardClaimed"),X("tokenMint"),X("tokenVault"),X("creator"),F("rewardGrowthGlobalX64")]),Ln=V([we(8),$("bump"),X("ammConfig"),X("creator"),X("mintA"),X("mintB"),X("vaultA"),X("vaultB"),X("observationId"),$("mintDecimalsA"),$("mintDecimalsB"),nt("tickSpacing"),F("liquidity"),F("sqrtPriceX64"),H("tickCurrent"),Ye(),F("feeGrowthGlobalX64A"),F("feeGrowthGlobalX64B"),A("protocolFeesTokenA"),A("protocolFeesTokenB"),F("swapInAmountTokenA"),F("swapOutAmountTokenB"),F("swapInAmountTokenB"),F("swapOutAmountTokenA"),$("status"),Z($(),7,""),Z(_i,3,"rewardInfos"),Z(A(),16,"tickArrayBitmap"),A("totalFeesTokenA"),A("totalFeesClaimedTokenA"),A("totalFeesTokenB"),A("totalFeesClaimedTokenB"),A("fundFeesTokenA"),A("fundFeesTokenB"),A("startTime"),Z(A(),15*4-3,"padding")]),Fi=V([F("growthInsideLastX64"),A("rewardAmountOwed")]),Rn=V([we(8),$("bump"),X("nftMint"),X("poolId"),H("tickLower"),H("tickUpper"),F("liquidity"),F("feeGrowthInsideLastX64A"),F("feeGrowthInsideLastX64B"),A("tokenFeesOwedA"),A("tokenFeesOwedB"),Z(Fi,3,"rewardInfos"),Z(A(),8,"")]),xl=V([we(8),$("bump"),X("poolId"),H("tickLowerIndex"),H("tickUpperIndex"),F("liquidity"),F("feeGrowthInsideLastX64A"),F("feeGrowthInsideLastX64B"),A("tokenFeesOwedA"),A("tokenFeesOwedB"),Z(F(),3,"rewardGrowthInside"),Z(A(),8,"")]),Ei=V([H("tick"),yn("liquidityNet"),F("liquidityGross"),F("feeGrowthOutsideX64A"),F("feeGrowthOutsideX64B"),Z(F(),3,"rewardGrowthsOutsideX64"),Z(Ye(),13,"")]),at=V([we(8),X("poolId"),H("startTickIndex"),Z(Ei,oe,"ticks"),$("initializedTickCount"),Z($(),115,"")]),Bl=V([we(329),Z(X(),100,"whitelistMints")]),Mn=V([we(8),X("poolId"),Z(Z(A(),8),Ht,"positiveTickArrayBitmap"),Z(Z(A(),8),Ht,"negativeTickArrayBitmap")]),Sl=V([A(),$("bump"),X("owner"),X("poolId"),X("positionId"),X("nftAccount"),Z(A(),8)]),Il=V([we(8),$("bump"),X("lockOwner"),X("poolId"),X("positionId"),X("nftAccount"),X("lockNftMint"),A("recentEpoch"),Z(A(),8)]);_n.span;var Fn=fe("Raydium_Clmm"),Ae={createPool:[233,146,209,142,207,104,64,188],initReward:[95,135,192,196,242,129,230,68],setRewardEmissions:[112,52,167,75,32,201,211,137],openPosition:[77,184,74,214,112,86,241,199],openPositionWithTokenEx:[77,255,174,82,125,29,201,46],closePosition:[123,134,81,0,49,68,98,98],increaseLiquidity:[133,29,89,223,69,238,176,10],decreaseLiquidity:[58,127,188,62,79,82,196,96],swap:[43,4,237,11,26,201,30,98],collectReward:[18,237,166,197,34,16,213,144]},En=[188,37,179,131,82,150,84,73],Wn=[16,72,250,198,14,162,212,19],Tt=class{static createPoolInstruction(e,t,n,i,o,s,r,a,u,c,d,m,l,b){let y=V([F("sqrtPriceX64"),A("zero")]),g=[{pubkey:n,isSigner:!0,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!1},{pubkey:u,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:m,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!1},{pubkey:d,isSigner:!1,isWritable:!1},{pubkey:_e.programId,isSigner:!1,isWritable:!1},{pubkey:Ee,isSigner:!1,isWritable:!1},...(b==null?void 0:b.map(T=>({pubkey:T,isSigner:!1,isWritable:!1})))||[]],f=Buffer.alloc(y.span);y.encode({sqrtPriceX64:l,zero:J},f);let P=Buffer.from([...Ae.createPool,...f]);return new me({keys:g,programId:e,data:P})}static async createPoolInstructions(e){let{programId:t,owner:n,mintA:i,mintB:o,ammConfigId:s,initialPriceX64:r,extendMintAccount:a}=e,[u,c]=[new k(i.address),new k(o.address)],{publicKey:d}=Bn(t,s,u,c),{publicKey:m}=In(t,d),{publicKey:l}=Gt(t,d,u),{publicKey:b}=Gt(t,d,c),y=le(t,d).publicKey,g=[this.createPoolInstruction(t,d,n,s,m,u,l,new k(i.programId||U),c,b,new k(o.programId||U),y,r,a)];return{signers:[],instructions:g,instructionTypes:[ae.CreateAccount,ae.ClmmCreatePool],address:{poolId:d,observationId:m,exBitmapAccount:y,mintAVault:l,mintBVault:b},lookupTableAddress:[]}}static openPositionFromLiquidityInstruction(e,t,n,i,o,s,r,a,u,c,d,m,l,b,y,g,f,P,T,B,I,w,S,K,_,G){let O=V([H("tickLowerIndex"),H("tickUpperIndex"),H("tickArrayLowerStartIndex"),H("tickArrayUpperStartIndex"),F("liquidity"),A("amountMaxA"),A("amountMaxB"),ye("withMetadata"),$("optionBaseFlag"),ye("baseFlag")]),ce=[...G?[{pubkey:G,isSigner:!1,isWritable:!0}]:[]],ne=[{pubkey:t,isSigner:!0,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!0,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:d,isSigner:!1,isWritable:!0},{pubkey:m,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:b,isSigner:!1,isWritable:!0},{pubkey:y,isSigner:!1,isWritable:!0},{pubkey:Ee,isSigner:!1,isWritable:!1},{pubkey:_e.programId,isSigner:!1,isWritable:!1},{pubkey:U,isSigner:!1,isWritable:!1},{pubkey:ct,isSigner:!1,isWritable:!1},{pubkey:Ve,isSigner:!1,isWritable:!1},{pubkey:ee,isSigner:!1,isWritable:!1},{pubkey:g,isSigner:!1,isWritable:!1},{pubkey:f,isSigner:!1,isWritable:!1},...ce],ke=Buffer.alloc(O.span);O.encode({tickLowerIndex:P,tickUpperIndex:T,tickArrayLowerStartIndex:B,tickArrayUpperStartIndex:I,liquidity:w,amountMaxA:S,amountMaxB:K,withMetadata:_==="create",baseFlag:!1,optionBaseFlag:0},ke);let He=Buffer.from([...Ae.openPosition,...ke]);return new me({keys:ne,programId:e,data:He})}static openPositionFromLiquidityInstruction22(e,t,n,i,o,s,r,a,u,c,d,m,l,b,y,g,f,P,T,B,I,w,S,K,_){let G=V([H("tickLowerIndex"),H("tickUpperIndex"),H("tickArrayLowerStartIndex"),H("tickArrayUpperStartIndex"),F("liquidity"),A("amountMaxA"),A("amountMaxB"),ye("withMetadata"),$("optionBaseFlag"),ye("baseFlag")]),O=[..._?[{pubkey:_,isSigner:!1,isWritable:!0}]:[]],ce=[{pubkey:t,isSigner:!0,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!0,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:d,isSigner:!1,isWritable:!0},{pubkey:m,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:b,isSigner:!1,isWritable:!0},{pubkey:Ee,isSigner:!1,isWritable:!1},{pubkey:_e.programId,isSigner:!1,isWritable:!1},{pubkey:U,isSigner:!1,isWritable:!1},{pubkey:ct,isSigner:!1,isWritable:!1},{pubkey:ee,isSigner:!1,isWritable:!1},{pubkey:y,isSigner:!1,isWritable:!1},{pubkey:g,isSigner:!1,isWritable:!1},...O],ne=Buffer.alloc(G.span);G.encode({tickLowerIndex:f,tickUpperIndex:P,tickArrayLowerStartIndex:T,tickArrayUpperStartIndex:B,liquidity:I,amountMaxA:w,amountMaxB:S,withMetadata:K==="create",baseFlag:!1,optionBaseFlag:0},ne);let ke=Buffer.from([...Ae.openPositionWithTokenEx,...ne]);return new me({keys:ce,programId:e,data:ke})}static async openPositionInstructions({poolInfo:e,poolKeys:t,ownerInfo:n,tickLower:i,tickUpper:o,liquidity:s,amountMaxA:r,amountMaxB:a,withMetadata:u,getEphemeralSigners:c,nft2022:d}){let m=[],[l,b]=[new k(e.programId),new k(e.id)],y;if(c)y=new k((await c(1))[0]);else{let _=Pt.generate();m.push(_),y=_.publicKey}let g=h.getTickArrayStartIndexByTick(i,e.config.tickSpacing),f=h.getTickArrayStartIndexByTick(o,e.config.tickSpacing),{publicKey:P}=q(l,b,g),{publicKey:T}=q(l,b,f),{publicKey:B}=d?ie(n.wallet,y,ee):ie(n.wallet,y,U),{publicKey:I}=ot(y),{publicKey:w}=Te(l,y),{publicKey:S}=Oe(l,b,i,o),K=d?this.openPositionFromLiquidityInstruction22(l,n.feePayer,b,n.wallet,y,B,S,P,T,w,n.tokenAccountA,n.tokenAccountB,new k(t.vault.A),new k(t.vault.B),new k(e.mintA.address),new k(e.mintB.address),i,o,g,f,s,r,a,u,re.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing,[g,f])?le(l,b).publicKey:void 0):this.openPositionFromLiquidityInstruction(l,n.feePayer,b,n.wallet,y,B,I,S,P,T,w,n.tokenAccountA,n.tokenAccountB,new k(t.vault.A),new k(t.vault.B),new k(e.mintA.address),new k(e.mintB.address),i,o,g,f,s,r,a,u,re.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing,[g,f])?le(l,b).publicKey:void 0);return{signers:m,instructions:[K],instructionTypes:[ae.ClmmOpenPosition],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[],address:{nftMint:y,tickArrayLower:P,tickArrayUpper:T,positionNftAccount:B,metadataAccount:I,personalPosition:w,protocolPosition:S}}}static async openPositionFromBaseInstructions({poolInfo:e,poolKeys:t,ownerInfo:n,tickLower:i,tickUpper:o,base:s,baseAmount:r,otherAmountMax:a,withMetadata:u,getEphemeralSigners:c,nft2022:d}){let m=[],[l,b]=[new k(e.programId),new k(e.id)],y;if(c)y=new k((await c(1))[0]);else{let _=Pt.generate();m.push(_),y=_.publicKey}let g=h.getTickArrayStartIndexByTick(i,e.config.tickSpacing),f=h.getTickArrayStartIndexByTick(o,e.config.tickSpacing),{publicKey:P}=q(l,b,g),{publicKey:T}=q(l,b,f),{publicKey:B}=d?ie(n.wallet,y,ee):ie(n.wallet,y,U),{publicKey:I}=ot(y),{publicKey:w}=Te(l,y),{publicKey:S}=Oe(l,b,i,o),K=d?this.openPositionFromBaseInstruction22(l,n.feePayer,b,n.wallet,y,B,S,P,T,w,n.tokenAccountA,n.tokenAccountB,new k(t.vault.A),new k(t.vault.B),new k(e.mintA.address),new k(e.mintB.address),i,o,g,f,u,s,r,a,re.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing,[g,f])?le(l,b).publicKey:void 0):this.openPositionFromBaseInstruction(l,n.feePayer,b,n.wallet,y,B,I,S,P,T,w,n.tokenAccountA,n.tokenAccountB,new k(t.vault.A),new k(t.vault.B),new k(e.mintA.address),new k(e.mintB.address),i,o,g,f,u,s,r,a,re.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing,[g,f])?le(l,b).publicKey:void 0);return{address:{nftMint:y,tickArrayLower:P,tickArrayUpper:T,positionNftAccount:B,metadataAccount:I,personalPosition:w,protocolPosition:S},instructions:[K],signers:m,instructionTypes:[ae.ClmmOpenPosition],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[]}}static openPositionFromBaseInstruction(e,t,n,i,o,s,r,a,u,c,d,m,l,b,y,g,f,P,T,B,I,w,S,K,_,G){let O=V([H("tickLowerIndex"),H("tickUpperIndex"),H("tickArrayLowerStartIndex"),H("tickArrayUpperStartIndex"),F("liquidity"),A("amountMaxA"),A("amountMaxB"),ye("withMetadata"),$("optionBaseFlag"),ye("baseFlag")]),ce=[...G?[{pubkey:G,isSigner:!1,isWritable:!0}]:[]],ne=[{pubkey:t,isSigner:!0,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!0,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:d,isSigner:!1,isWritable:!0},{pubkey:m,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:b,isSigner:!1,isWritable:!0},{pubkey:y,isSigner:!1,isWritable:!0},{pubkey:Ee,isSigner:!1,isWritable:!1},{pubkey:_e.programId,isSigner:!1,isWritable:!1},{pubkey:U,isSigner:!1,isWritable:!1},{pubkey:ct,isSigner:!1,isWritable:!1},{pubkey:Ve,isSigner:!1,isWritable:!1},{pubkey:ee,isSigner:!1,isWritable:!1},{pubkey:g,isSigner:!1,isWritable:!1},{pubkey:f,isSigner:!1,isWritable:!1},...ce],ke=Buffer.alloc(O.span);O.encode({tickLowerIndex:P,tickUpperIndex:T,tickArrayLowerStartIndex:B,tickArrayUpperStartIndex:I,liquidity:new Yt(0),amountMaxA:S==="MintA"?K:_,amountMaxB:S==="MintA"?_:K,withMetadata:w==="create",baseFlag:S==="MintA",optionBaseFlag:1},ke);let He=Buffer.from([...Ae.openPosition,...ke]);return new me({keys:ne,programId:e,data:He})}static openPositionFromBaseInstruction22(e,t,n,i,o,s,r,a,u,c,d,m,l,b,y,g,f,P,T,B,I,w,S,K,_){let G=V([H("tickLowerIndex"),H("tickUpperIndex"),H("tickArrayLowerStartIndex"),H("tickArrayUpperStartIndex"),F("liquidity"),A("amountMaxA"),A("amountMaxB"),ye("withMetadata"),$("optionBaseFlag"),ye("baseFlag")]),O=[..._?[{pubkey:_,isSigner:!1,isWritable:!0}]:[]],ce=[{pubkey:t,isSigner:!0,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!0,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:d,isSigner:!1,isWritable:!0},{pubkey:m,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:b,isSigner:!1,isWritable:!0},{pubkey:Ee,isSigner:!1,isWritable:!1},{pubkey:_e.programId,isSigner:!1,isWritable:!1},{pubkey:U,isSigner:!1,isWritable:!1},{pubkey:ct,isSigner:!1,isWritable:!1},{pubkey:ee,isSigner:!1,isWritable:!1},{pubkey:y,isSigner:!1,isWritable:!1},{pubkey:g,isSigner:!1,isWritable:!1},...O],ne=Buffer.alloc(G.span);G.encode({tickLowerIndex:f,tickUpperIndex:P,tickArrayLowerStartIndex:T,tickArrayUpperStartIndex:B,liquidity:new Yt(0),amountMaxA:w==="MintA"?S:K,amountMaxB:w==="MintA"?K:S,withMetadata:I==="create",baseFlag:w==="MintA",optionBaseFlag:1},ne);let ke=Buffer.from([...Ae.openPositionWithTokenEx,...ne]);return new me({keys:ce,programId:e,data:ke})}static async openPositionFromLiquidityInstructions({poolInfo:e,poolKeys:t,ownerInfo:n,tickLower:i,tickUpper:o,liquidity:s,amountMaxA:r,amountMaxB:a,withMetadata:u,getEphemeralSigners:c,nft2022:d}){let m,l=[];if(c)m=new k((await c(1))[0]);else{let _=Pt.generate();l.push(_),m=_.publicKey}let[b,y]=[new k(e.programId),new k(e.id)],g=h.getTickArrayStartIndexByTick(i,e.config.tickSpacing),f=h.getTickArrayStartIndexByTick(o,e.config.tickSpacing),{publicKey:P}=q(b,y,g),{publicKey:T}=q(b,y,f),{publicKey:B}=d?ie(n.wallet,m,ee):ie(n.wallet,m,U),{publicKey:I}=ot(m),{publicKey:w}=Te(b,m),{publicKey:S}=Oe(b,y,i,o),K=d?this.openPositionFromLiquidityInstruction22(b,n.wallet,y,n.wallet,m,B,S,P,T,w,n.tokenAccountA,n.tokenAccountB,new k(t.vault.A),new k(t.vault.B),new k(t.mintA.address),new k(t.mintB.address),i,o,g,f,s,r,a,u,re.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing,[g,f])?le(b,y).publicKey:void 0):this.openPositionFromLiquidityInstruction(b,n.wallet,y,n.wallet,m,B,I,S,P,T,w,n.tokenAccountA,n.tokenAccountB,new k(t.vault.A),new k(t.vault.B),new k(t.mintA.address),new k(t.mintB.address),i,o,g,f,s,r,a,u,re.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing,[g,f])?le(b,y).publicKey:void 0);return{address:{nftMint:m,tickArrayLower:P,tickArrayUpper:T,positionNftAccount:B,metadataAccount:I,personalPosition:w,protocolPosition:S},instructions:[K],signers:l,instructionTypes:[ae.ClmmOpenPosition],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[]}}static closePositionInstruction(e,t,n,i,o,s){let r=V([]),a=[{pubkey:t,isSigner:!0,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:_e.programId,isSigner:!1,isWritable:!1},{pubkey:s?ee:U,isSigner:!1,isWritable:!1}],u=Buffer.alloc(r.span);r.encode({},u);let c=Buffer.from([...Ae.closePosition,...u]);return new me({keys:a,programId:e,data:c})}static closePositionInstructions({poolInfo:e,poolKeys:t,ownerInfo:n,ownerPosition:i,nft2022:o}){let s=new k(e.programId),r=o?ie(n.wallet,i.nftMint,ee).publicKey:ie(n.wallet,i.nftMint,U).publicKey,{publicKey:a}=Te(s,i.nftMint),u=[];return u.push(this.closePositionInstruction(s,n.wallet,i.nftMint,r,a,o)),{address:{positionNftAccount:r,personalPosition:a},signers:[],instructions:u,instructionTypes:[ae.ClmmClosePosition],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[]}}static increasePositionFromLiquidityInstruction(e,t,n,i,o,s,r,a,u,c,d,m,l,b,y,g,f,P){let T=V([F("liquidity"),A("amountMaxA"),A("amountMaxB"),$("optionBaseFlag"),ye("baseFlag")]),B=[...P?[{pubkey:P,isSigner:!1,isWritable:!0}]:[]],I=[{pubkey:t,isSigner:!0,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:d,isSigner:!1,isWritable:!0},{pubkey:m,isSigner:!1,isWritable:!0},{pubkey:U,isSigner:!1,isWritable:!1},{pubkey:ee,isSigner:!1,isWritable:!1},{pubkey:l,isSigner:!1,isWritable:!1},{pubkey:b,isSigner:!1,isWritable:!1},...B],w=Buffer.alloc(T.span);T.encode({liquidity:y,amountMaxA:g,amountMaxB:f,optionBaseFlag:0,baseFlag:!1},w);let S=Buffer.from([...Ae.increaseLiquidity,...w]);return new me({keys:I,programId:e,data:S})}static increasePositionFromLiquidityInstructions({poolInfo:e,poolKeys:t,ownerPosition:n,ownerInfo:i,liquidity:o,amountMaxA:s,amountMaxB:r,nft2022:a}){let[u,c]=[new k(e.programId),new k(e.id)],d=h.getTickArrayStartIndexByTick(n.tickLower,e.config.tickSpacing),m=h.getTickArrayStartIndexByTick(n.tickUpper,e.config.tickSpacing),{publicKey:l}=q(u,c,d),{publicKey:b}=q(u,c,m),{publicKey:y}=a?ie(i.wallet,n.nftMint,ee):ie(i.wallet,n.nftMint,U),{publicKey:g}=Te(u,n.nftMint),{publicKey:f}=Oe(u,c,n.tickLower,n.tickUpper),P=this.increasePositionFromLiquidityInstruction(u,i.wallet,y,g,c,f,l,b,i.tokenAccountA,i.tokenAccountB,new k(t.vault.A),new k(t.vault.B),new k(e.mintA.address),new k(e.mintB.address),o,s,r,re.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing,[d,m])?le(u,c).publicKey:void 0);return{address:{tickArrayLower:l,tickArrayUpper:b,positionNftAccount:y,personalPosition:g,protocolPosition:f},signers:[],instructions:[P],instructionTypes:[ae.ClmmIncreasePosition],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[]}}static increasePositionFromBaseInstructions({poolInfo:e,poolKeys:t,ownerPosition:n,ownerInfo:i,base:o,baseAmount:s,otherAmountMax:r,nft2022:a}){let[u,c]=[new k(e.programId),new k(e.id)],d=h.getTickArrayStartIndexByTick(n.tickLower,e.config.tickSpacing),m=h.getTickArrayStartIndexByTick(n.tickUpper,e.config.tickSpacing),{publicKey:l}=q(u,c,d),{publicKey:b}=q(u,c,m),{publicKey:y}=a?ie(i.wallet,n.nftMint,ee):ie(i.wallet,n.nftMint,U),{publicKey:g}=Te(u,n.nftMint),{publicKey:f}=Oe(u,c,n.tickLower,n.tickUpper);return{address:{tickArrayLower:l,tickArrayUpper:b,positionNftAccount:y,personalPosition:g,protocolPosition:f},instructions:[this.increasePositionFromBaseInstruction(u,i.wallet,y,g,c,f,l,b,i.tokenAccountA,i.tokenAccountB,new k(t.vault.A),new k(t.vault.B),new k(e.mintA.address),new k(e.mintB.address),o,s,r,re.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing,[d,m])?le(u,c).publicKey:void 0)],signers:[],instructionTypes:[ae.ClmmIncreasePosition],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[]}}static increasePositionFromBaseInstruction(e,t,n,i,o,s,r,a,u,c,d,m,l,b,y,g,f,P){let T=V([F("liquidity"),A("amountMaxA"),A("amountMaxB"),$("optionBaseFlag"),ye("baseFlag")]),B=[...P?[{pubkey:P,isSigner:!1,isWritable:!0}]:[]],I=[{pubkey:t,isSigner:!0,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:d,isSigner:!1,isWritable:!0},{pubkey:m,isSigner:!1,isWritable:!0},{pubkey:U,isSigner:!1,isWritable:!1},{pubkey:ee,isSigner:!1,isWritable:!1},{pubkey:l,isSigner:!1,isWritable:!1},{pubkey:b,isSigner:!1,isWritable:!1},...B],w=Buffer.alloc(T.span);T.encode({liquidity:new Yt(0),amountMaxA:y==="MintA"?g:f,amountMaxB:y==="MintA"?f:g,baseFlag:y==="MintA",optionBaseFlag:1},w);let S=Buffer.from([...Ae.increaseLiquidity,...w]);return new me({keys:I,programId:e,data:S})}static decreaseLiquidityInstruction(e,t,n,i,o,s,r,a,u,c,d,m,l,b,y,g,f,P,T){let B=V([F("liquidity"),A("amountMinA"),A("amountMinB")]),I=[...T?[{pubkey:T,isSigner:!1,isWritable:!0}]:[],...y.map(_=>[{pubkey:_.poolRewardVault,isSigner:!1,isWritable:!0},{pubkey:_.ownerRewardVault,isSigner:!1,isWritable:!0},{pubkey:_.rewardMint,isSigner:!1,isWritable:!1}]).flat()],w=[{pubkey:t,isSigner:!0,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:d,isSigner:!1,isWritable:!0},{pubkey:m,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:U,isSigner:!1,isWritable:!1},{pubkey:ee,isSigner:!1,isWritable:!1},{pubkey:ft,isSigner:!1,isWritable:!1},{pubkey:l,isSigner:!1,isWritable:!1},{pubkey:b,isSigner:!1,isWritable:!1},...I],S=Buffer.alloc(B.span);B.encode({liquidity:g,amountMinA:f,amountMinB:P},S);let K=Buffer.from([...Ae.decreaseLiquidity,...S]);return new me({keys:w,programId:e,data:K})}static decreaseLiquidityInstructions({poolInfo:e,poolKeys:t,ownerPosition:n,ownerInfo:i,liquidity:o,amountMinA:s,amountMinB:r,programId:a,nft2022:u}){let[c,d]=[new k(e.programId),new k(e.id)],m=h.getTickArrayStartIndexByTick(n.tickLower,e.config.tickSpacing),l=h.getTickArrayStartIndexByTick(n.tickUpper,e.config.tickSpacing),{publicKey:b}=q(c,d,m),{publicKey:y}=q(c,d,l),{publicKey:g}=u?ie(i.wallet,n.nftMint,ee):ie(i.wallet,n.nftMint,a),{publicKey:f}=Te(c,n.nftMint),{publicKey:P}=Oe(c,d,n.tickLower,n.tickUpper),T=[];for(let w=0;w<e.rewardDefaultInfos.length;w++)T.push({poolRewardVault:new k(t.rewardInfos[w].vault),ownerRewardVault:i.rewardAccounts[w],rewardMint:new k(e.rewardDefaultInfos[w].mint.address)});let B=[],I=this.decreaseLiquidityInstruction(c,i.wallet,g,f,d,P,b,y,i.tokenAccountA,i.tokenAccountB,new k(t.vault.A),new k(t.vault.B),new k(e.mintA.address),new k(e.mintB.address),T,o,s,r,re.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing,[m,l])?le(c,d).publicKey:void 0);return B.push(I),{address:{tickArrayLower:b,tickArrayUpper:y,positionNftAccount:g,personalPosition:f,protocolPosition:P},signers:[],instructions:B,instructionTypes:[ae.ClmmDecreasePosition],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[]}}static swapInstruction(e,t,n,i,o,s,r,a,u,c,d,m,l,b,y,g,f){let P=V([A("amount"),A("otherAmountThreshold"),F("sqrtPriceLimitX64"),ye("isBaseInput")]),T=[...f?[{pubkey:f,isSigner:!1,isWritable:!0}]:[],...d.map(S=>({pubkey:S,isSigner:!1,isWritable:!0}))],B=[{pubkey:t,isSigner:!0,isWritable:!1},{pubkey:i,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:m,isSigner:!1,isWritable:!0},{pubkey:U,isSigner:!1,isWritable:!1},{pubkey:ee,isSigner:!1,isWritable:!1},{pubkey:ft,isSigner:!1,isWritable:!1},{pubkey:u,isSigner:!1,isWritable:!1},{pubkey:c,isSigner:!1,isWritable:!1},...T],I=Buffer.alloc(P.span);P.encode({amount:l,otherAmountThreshold:b,sqrtPriceLimitX64:y,isBaseInput:g},I);let w=Buffer.from([...Ae.swap,...I]);return new me({keys:B,programId:e,data:w})}static makeSwapBaseInInstructions({poolInfo:e,poolKeys:t,observationId:n,ownerInfo:i,inputMint:o,amountIn:s,amountOutMin:r,sqrtPriceLimitX64:a,remainingAccounts:u}){let[c,d]=[new k(e.programId),new k(e.id)],[m,l]=[new k(t.vault.A),new k(t.vault.B)],[b,y]=[new k(e.mintA.address),new k(e.mintB.address)],g=e.mintA.address===o.toString(),f=[this.swapInstruction(c,i.wallet,d,new k(e.config.id),g?i.tokenAccountA:i.tokenAccountB,g?i.tokenAccountB:i.tokenAccountA,g?m:l,g?l:m,g?b:y,g?y:b,u,n,s,r,a,!0,le(c,d).publicKey)];return{signers:[],instructions:f,instructionTypes:[ae.ClmmSwapBaseIn],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[],address:{}}}static makeSwapBaseOutInstructions({poolInfo:e,poolKeys:t,observationId:n,ownerInfo:i,outputMint:o,amountOut:s,amountInMax:r,sqrtPriceLimitX64:a,remainingAccounts:u}){let[c,d]=[new k(e.programId),new k(e.id)],[m,l]=[new k(t.vault.A),new k(t.vault.B)],[b,y]=[new k(e.mintA.address),new k(e.mintB.address)],g=e.mintA.address===o.toBase58(),f=[this.swapInstruction(c,i.wallet,d,new k(e.config.id),g?i.tokenAccountB:i.tokenAccountA,g?i.tokenAccountA:i.tokenAccountB,g?l:m,g?m:l,g?y:b,g?b:y,u,n,s,r,a,!1,le(c,d).publicKey)];return{signers:[],instructions:f,instructionTypes:[ae.ClmmSwapBaseOut],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[],address:{}}}static initRewardInstruction(e,t,n,i,o,s,r,a,u,c,d,m){let l=V([A("openTime"),A("endTime"),F("emissionsPerSecondX64")]),b=[{pubkey:t,isSigner:!0,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!1},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!1},{pubkey:_e.programId,isSigner:!1,isWritable:!1},{pubkey:Ee,isSigner:!1,isWritable:!1}],y=Buffer.alloc(l.span);l.encode({openTime:se(c),endTime:se(d),emissionsPerSecondX64:m},y);let g=Buffer.from([...Ae.initReward,...y]);return new me({keys:b,programId:e,data:g})}static initRewardInstructions({poolInfo:e,poolKeys:t,ownerInfo:n,rewardInfo:i}){let[o,s]=[new k(e.programId),new k(e.id)],r=Sn(o,s,i.mint).publicKey,a=Ut(o).publicKey,u=[this.initRewardInstruction(o,n.wallet,s,a,new k(e.config.id),n.tokenAccount,i.programId,i.mint,r,i.openTime,i.endTime,i.emissionsPerSecondX64)];return{address:{poolRewardVault:r,operationId:a},signers:[],instructions:u,instructionTypes:[ae.ClmmInitReward],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[]}}static setRewardInstruction(e,t,n,i,o,s,r,a,u,c,d,m){let l=V([$("rewardIndex"),F("emissionsPerSecondX64"),A("openTime"),A("endTime")]),b=[{pubkey:t,isSigner:!0,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:U,isSigner:!1,isWritable:!1},{pubkey:ee,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0}],y=Buffer.alloc(l.span);l.encode({rewardIndex:u,emissionsPerSecondX64:m,openTime:se(c),endTime:se(d)},y);let g=Buffer.from([...Ae.setRewardEmissions,...y]);return new me({keys:b,programId:e,data:g})}static setRewardInstructions({poolInfo:e,poolKeys:t,ownerInfo:n,rewardInfo:i}){let[o,s]=[new k(e.programId),new k(e.id)],r,a,u;for(let m=0;m<e.rewardDefaultInfos.length;m++)e.rewardDefaultInfos[m].mint.address===i.mint.toString()&&(r=m,a=new k(t.rewardInfos[m].vault),u=new k(t.rewardInfos[m].mint.address));(r===void 0||a===void 0)&&Fn.logWithError("reward mint check error","no reward mint",e.rewardDefaultInfos);let c=Ut(o).publicKey,d=[this.setRewardInstruction(o,n.wallet,s,c,new k(e.config.id),n.tokenAccount,a,u,r,i.openTime,i.endTime,i.emissionsPerSecondX64)];return{address:{rewardVault:a,operationId:c},signers:[],instructions:d,instructionTypes:[ae.ClmmSetReward],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[]}}static collectRewardInstruction(e,t,n,i,o,s,r){let a=V([$("rewardIndex")]),u=[{pubkey:t,isSigner:!0,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!1},{pubkey:U,isSigner:!1,isWritable:!1},{pubkey:ee,isSigner:!1,isWritable:!1},{pubkey:ft,isSigner:!1,isWritable:!1}],c=Buffer.alloc(a.span);a.encode({rewardIndex:r},c);let d=Buffer.from([...Ae.collectReward,...c]);return new me({keys:u,programId:e,data:d})}static collectRewardInstructions({poolInfo:e,poolKeys:t,ownerInfo:n,rewardMint:i}){let[o,s]=[new k(e.programId),new k(e.id)],r,a;for(let c=0;c<e.rewardDefaultInfos.length;c++)e.rewardDefaultInfos[c].mint.address===i.toString()&&(r=c,a=new k(t.rewardInfos[c].vault));(r===void 0||a===void 0)&&Fn.logWithError("reward mint check error","no reward mint",e.rewardDefaultInfos);let u=[this.collectRewardInstruction(o,n.wallet,s,n.tokenAccount,a,i,r)];return{address:{rewardVault:a},signers:[],instructions:u,instructionTypes:[ae.ClmmCollectReward],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[]}}static async makeLockPositions({programId:e,authProgramId:t,poolProgramId:n,payer:i,wallet:o,nftMint:s,nft2022:r,getEphemeralSigners:a}){let u=[],c;if(a)c=new k((await a(1))[0]);else{let f=Pt.generate();u.push(f),c=f.publicKey}let d=r?ie(o,s,ee).publicKey:ie(o,s,U).publicKey,{publicKey:m}=Te(n,s),l=Nn(e,c).publicKey,b=ie(o,c,U).publicKey,y=ot(c).publicKey,g=Tt.lockPositionInstructionV2({programId:e,auth:t,payer:i,positionOwner:o,lockOwner:o,positionNftAccount:d,positionId:m,lockPositionId:l,lockNftMint:c,lockNftAccount:b,metadataAccount:y,withMetadata:!0,nft2022:r,positionNftMint:s,authPositionNftAccount:ie(t,s,r?ee:U).publicKey,positionNftProgram:r?ee:U});return{address:{positionId:m,lockPositionId:l,lockNftAccount:b,lockNftMint:c,positionNftAccount:d,metadataAccount:y},instructions:[g],signers:u,instructionTypes:[ae.ClmmLockPosition],lookupTableAddress:[]}}static lockPositionInstructionV2({programId:e,auth:t,payer:n,positionOwner:i,lockOwner:o,positionNftAccount:s,positionId:r,positionNftMint:a,authPositionNftAccount:u,positionNftProgram:c,lockPositionId:d,lockNftMint:m,lockNftAccount:l,metadataAccount:b,withMetadata:y}){let g=[{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!0,isWritable:!0},{pubkey:i,isSigner:!0,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!1},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:d,isSigner:!1,isWritable:!0},{pubkey:m,isSigner:!0,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:b,isSigner:!1,isWritable:!0},{pubkey:Ve,isSigner:!1,isWritable:!1},{pubkey:ct,isSigner:!1,isWritable:!1},{pubkey:Ee,isSigner:!1,isWritable:!1},{pubkey:U,isSigner:!1,isWritable:!1},{pubkey:c,isSigner:!1,isWritable:!1},{pubkey:_e.programId,isSigner:!1,isWritable:!1}],f=V([ye("withMetadata")]),P=Buffer.alloc(f.span);f.encode({withMetadata:y},P);let T=Buffer.from([...En,...P]);return new me({keys:g,programId:e,data:T})}static lockPositionInstruction({programId:e,authProgramId:t,poolProgramId:n,owner:i,positionNft:o}){let{publicKey:s}=ie(i,o,U),{publicKey:r}=Te(n,o),a=[{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:i,isSigner:!0,isWritable:!1},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!1},{pubkey:Xt(e,r).publicKey,isSigner:!1,isWritable:!0},{pubkey:U,isSigner:!1,isWritable:!1},{pubkey:_e.programId,isSigner:!1,isWritable:!1}];return new me({keys:a,programId:e,data:Buffer.from(En)})}static harvestLockPositionInstruction(e){let[t,n]=[new k(e.poolKeys.programId),new k(e.poolKeys.id)],i=h.getTickArrayStartIndexByTick(e.ownerPosition.tickLower,e.poolKeys.config.tickSpacing),o=h.getTickArrayStartIndexByTick(e.ownerPosition.tickUpper,e.poolKeys.config.tickSpacing),{publicKey:s}=q(t,n,i),{publicKey:r}=q(t,n,o),{publicKey:a}=ie(e.owner,e.ownerPosition.nftMint,U),{publicKey:u}=Te(t,e.ownerPosition.nftMint),{publicKey:c}=Oe(t,n,e.ownerPosition.tickLower,e.ownerPosition.tickUpper),d=[];for(let b=0;b<e.poolKeys.rewardInfos.length;b++)d.push({poolRewardVault:new k(e.poolKeys.rewardInfos[b].vault),ownerRewardVault:e.ownerRewardAccounts[b],rewardMint:new k(e.poolKeys.rewardInfos[b].mint.address)});let m=[...d.map(b=>[{pubkey:b.poolRewardVault,isSigner:!1,isWritable:!0},{pubkey:b.ownerRewardVault,isSigner:!1,isWritable:!0},{pubkey:b.rewardMint,isSigner:!1,isWritable:!1}]).flat()],l=[{pubkey:e.authProgramId,isSigner:!1,isWritable:!1},{pubkey:Xt(e.programId,u).publicKey,isSigner:!1,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:e.owner,isSigner:!0,isWritable:!1},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:new k(e.poolKeys.vault.A),isSigner:!1,isWritable:!0},{pubkey:new k(e.poolKeys.vault.B),isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:e.userVaultA,isSigner:!1,isWritable:!0},{pubkey:e.userVaultB,isSigner:!1,isWritable:!0},{pubkey:U,isSigner:!1,isWritable:!1},{pubkey:ee,isSigner:!1,isWritable:!1},{pubkey:Lt,isSigner:!1,isWritable:!1},{pubkey:new k(e.poolKeys.mintA.address),isSigner:!1,isWritable:!1},{pubkey:new k(e.poolKeys.mintB.address),isSigner:!1,isWritable:!1},...m];return new me({keys:l,programId:e.programId,data:Buffer.from(Wn)})}static harvestLockPositionInstructionV2({programId:e,auth:t,lockPositionId:n,clmmProgram:i,lockOwner:o,lockNftMint:s,lockNftAccount:r,positionNftAccount:a,positionId:u,poolId:c,protocolPosition:d,vaultA:m,vaultB:l,tickArrayLower:b,tickArrayUpper:y,userVaultA:g,userVaultB:f,mintA:P,mintB:T,rewardAccounts:B,exTickArrayBitmap:I}){let w=[...I?[{pubkey:I,isSigner:!1,isWritable:!0}]:[],...B.map(K=>[{pubkey:K.poolRewardVault,isSigner:!1,isWritable:!0},{pubkey:K.ownerRewardVault,isSigner:!1,isWritable:!0},{pubkey:K.rewardMint,isSigner:!1,isWritable:!1}]).flat()],S=[{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!0,isWritable:!1},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:i,isSigner:!1,isWritable:!1},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:d,isSigner:!1,isWritable:!0},{pubkey:m,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:b,isSigner:!1,isWritable:!0},{pubkey:y,isSigner:!1,isWritable:!0},{pubkey:g,isSigner:!1,isWritable:!0},{pubkey:f,isSigner:!1,isWritable:!0},{pubkey:U,isSigner:!1,isWritable:!1},{pubkey:ee,isSigner:!1,isWritable:!1},{pubkey:Lt,isSigner:!1,isWritable:!1},{pubkey:P,isSigner:!1,isWritable:!1},{pubkey:T,isSigner:!1,isWritable:!1},...w];return new me({keys:S,programId:e,data:Buffer.from(Wn)})}};export{Tt as ClmmInstrument};
//# sourceMappingURL=instrument.mjs.map