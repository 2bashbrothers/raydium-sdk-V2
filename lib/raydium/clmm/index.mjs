var Hi=Object.defineProperty,zi=Object.defineProperties;var ji=Object.getOwnPropertyDescriptors;var Yt=Object.getOwnPropertySymbols;var jn=Object.prototype.hasOwnProperty,Zn=Object.prototype.propertyIsEnumerable;var zn=(y,e,t)=>e in y?Hi(y,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):y[e]=t,O=(y,e)=>{for(var t in e||(e={}))jn.call(e,t)&&zn(y,t,e[t]);if(Yt)for(var t of Yt(e))Zn.call(e,t)&&zn(y,t,e[t]);return y},U=(y,e)=>zi(y,ji(e));var ut=(y,e)=>{var t={};for(var n in y)jn.call(y,n)&&e.indexOf(n)<0&&(t[n]=y[n]);if(y!=null&&Yt)for(var n of Yt(y))e.indexOf(n)<0&&Zn.call(y,n)&&(t[n]=y[n]);return t};import{PublicKey as R}from"@solana/web3.js";import Ke from"bn.js";import gt from"decimal.js";import{PublicKey as Jn}from"@solana/web3.js";import{get as Yn,set as Zi}from"lodash";var pn=class{constructor(e){this.logLevel=e.logLevel!==void 0?e.logLevel:0,this.name=e.name}set level(e){this.logLevel=e}get time(){return Date.now().toString()}get moduleName(){return this.name}isLogLevel(e){return e<=this.logLevel}error(...e){return this.isLogLevel(0)?(console.error(this.time,this.name,"sdk logger error",...e),this):this}logWithError(...e){let t=e.map(n=>typeof n=="object"?JSON.stringify(n):n).join(", ");throw new Error(t)}warning(...e){return this.isLogLevel(1)?(console.warn(this.time,this.name,"sdk logger warning",...e),this):this}info(...e){return this.isLogLevel(2)?(console.info(this.time,this.name,"sdk logger info",...e),this):this}debug(...e){return this.isLogLevel(3)?(console.debug(this.time,this.name,"sdk logger debug",...e),this):this}},Qn={},Yi={};function Te(y){let e=Yn(Qn,y);if(!e){let t=Yn(Yi,y);e=new pn({name:y,logLevel:t}),Zi(Qn,y,e)}return e}import{MINT_SIZE as Qi,TOKEN_PROGRAM_ID as Ji,getTransferFeeConfig as $i,unpackMint as er}from"@solana/spl-token";var fn=Te("Raydium_accountInfo_util");async function je(y,e,t){let{batchRequest:n,commitment:i="confirmed",chunkCount:s=100}=O({batchRequest:!1},t),o=yn(e,s),r=new Array(o.length).fill([]);if(n){let a=o.map(d=>{let f=y._buildArgs([d.map(u=>u.toBase58())],i,"base64");return{methodName:"getMultipleAccounts",args:f}}),c=yn(a,10);r=(await(await Promise.all(c.map(async d=>await y._rpcBatchRequest(d)))).flat()).map(d=>(d.error&&fn.logWithError(`failed to get info for multiple accounts, RPC_ERROR, ${d.error.message}`),d.result.value.map(f=>{if(f){let{data:u,executable:m,lamports:p,owner:b,rentEpoch:g}=f;return u.length!==2&&u[1]!=="base64"&&fn.logWithError("info must be base64 encoded, RPC_ERROR"),{data:Buffer.from(u[0],"base64"),executable:m,lamports:p,owner:new Jn(b),rentEpoch:g}}return null})))}else try{r=await Promise.all(o.map(a=>y.getMultipleAccountsInfo(a,i)))}catch(a){a instanceof Error&&fn.logWithError(`failed to get info for multiple accounts, RPC_ERROR, ${a.message}`)}return r.flat()}async function Ze(y,e,t){let n=await je(y,e.map(i=>i.pubkey),t);return e.map((i,s)=>U(O({},i),{accountInfo:n[s]}))}async function $n({connection:y,mints:e,config:t}){var s,o,r;if(e.length===0)return{};let n=await Ze(y,e.map(a=>({pubkey:lt(a)})),t),i={};for(let a of n){if(!a.accountInfo||a.accountInfo.data.length<Qi){console.log("invalid mint account",a.pubkey.toBase58());continue}let c=er(a.pubkey,a.accountInfo,(s=a.accountInfo)==null?void 0:s.owner);i[a.pubkey.toString()]=U(O({},c),{programId:((o=a.accountInfo)==null?void 0:o.owner)||Ji,feeConfig:(r=$i(c))!=null?r:void 0})}return i[Jn.default.toBase58()]=i[Q.toBase58()],i}import Ye from"bn.js";import js from"decimal.js";import cr from"big.js";import $t from"bn.js";import tr from"toformat";var nr=tr,Bt=nr;import Jt from"big.js";import rr from"bn.js";import or from"decimal.js-light";import It from"bn.js";var ei=9007199254740991;function we(y){let e=Te("Raydium_parseBigNumberish");if(y instanceof It)return y;if(typeof y=="string"){if(y.match(/^-?[0-9]+$/))return new It(y);e.logWithError(`invalid BigNumberish string: ${y}`)}return typeof y=="number"?(y%1&&e.logWithError(`BigNumberish number underflow: ${y}`),(y>=ei||y<=-ei)&&e.logWithError(`BigNumberish number overflow: ${y}`),new It(String(y))):typeof y=="bigint"?new It(y.toString()):(e.error(`invalid BigNumberish value: ${y}`),new It(0))}var Qt=Te("module/fraction"),bn=Bt(Jt),St=Bt(or),sr={[0]:St.ROUND_DOWN,[1]:St.ROUND_HALF_UP,[2]:St.ROUND_UP},ar={[0]:Jt.roundDown,[1]:Jt.roundHalfUp,[2]:Jt.roundUp},J=class{constructor(e,t=new rr(1)){this.numerator=we(e),this.denominator=we(t)}get quotient(){return this.numerator.div(this.denominator)}invert(){return new J(this.denominator,this.numerator)}add(e){let t=e instanceof J?e:new J(we(e));return this.denominator.eq(t.denominator)?new J(this.numerator.add(t.numerator),this.denominator):new J(this.numerator.mul(t.denominator).add(t.numerator.mul(this.denominator)),this.denominator.mul(t.denominator))}sub(e){let t=e instanceof J?e:new J(we(e));return this.denominator.eq(t.denominator)?new J(this.numerator.sub(t.numerator),this.denominator):new J(this.numerator.mul(t.denominator).sub(t.numerator.mul(this.denominator)),this.denominator.mul(t.denominator))}mul(e){let t=e instanceof J?e:new J(we(e));return new J(this.numerator.mul(t.numerator),this.denominator.mul(t.denominator))}div(e){let t=e instanceof J?e:new J(we(e));return new J(this.numerator.mul(t.denominator),this.denominator.mul(t.numerator))}toSignificant(e,t={groupSeparator:""},n=1){Number.isInteger(e)||Qt.logWithError(`${e} is not an integer.`),e<=0&&Qt.logWithError(`${e} is not positive.`),St.set({precision:e+1,rounding:sr[n]});let i=new St(this.numerator.toString()).div(this.denominator.toString()).toSignificantDigits(e);return i.toFormat(i.decimalPlaces(),t)}toFixed(e,t={groupSeparator:""},n=1){return Number.isInteger(e)||Qt.logWithError(`${e} is not an integer.`),e<0&&Qt.logWithError(`${e} is negative.`),bn.DP=e,bn.RM=ar[n]||1,new bn(this.numerator.toString()).div(this.denominator.toString()).toFormat(e,t)}isZero(){return this.numerator.isZero()}};var ur=Te("Raydium_amount"),ti=Bt(cr);function lr(y,e){let t="0",n="0";if(y.includes(".")){let i=y.split(".");i.length===2?([t,n]=i,n=n.padEnd(e,"0")):ur.logWithError(`invalid number string, num: ${y}`)}else t=y;return[t,n.slice(0,e)||n]}var ke=class extends J{constructor(t,n,i=!0,s){let o=new $t(0),r=gn.pow(new $t(t.decimals));if(i)o=we(n);else{let a=new $t(0),c=new $t(0);if(typeof n=="string"||typeof n=="number"||typeof n=="bigint"){let[l,d]=lr(n.toString(),t.decimals);a=we(l),c=we(d)}a=a.mul(r),o=a.add(c)}super(o,r);this.logger=Te(s||"TokenAmount"),this.token=t}get raw(){return this.numerator}isZero(){return this.raw.isZero()}gt(t){return this.token.equals(t.token)||this.logger.logWithError("gt token not equals"),this.raw.gt(t.raw)}lt(t){return this.token.equals(t.token)||this.logger.logWithError("lt token not equals"),this.raw.lt(t.raw)}add(t){return this.token.equals(t.token)||this.logger.logWithError("add token not equals"),new ke(this.token,this.raw.add(t.raw))}subtract(t){return this.token.equals(t.token)||this.logger.logWithError("sub token not equals"),new ke(this.token,this.raw.sub(t.raw))}toSignificant(t=this.token.decimals,n,i=0){return super.toSignificant(t,n,i)}toFixed(t=this.token.decimals,n,i=0){return t>this.token.decimals&&this.logger.logWithError("decimals overflow"),super.toFixed(t,n,i)}toExact(t={groupSeparator:""}){return ti.DP=this.token.decimals,new ti(this.numerator.toString()).div(this.denominator.toString()).toFormat(t)}};import{PublicKey as mr}from"@solana/web3.js";import{TOKEN_PROGRAM_ID as ni}from"@solana/spl-token";var Pn={chainId:101,address:mr.default.toBase58(),programId:ni.toBase58(),decimals:9,symbol:"SOL",name:"solana",logoURI:"https://img-v1.raydium.io/icon/So11111111111111111111111111111111111111112.png",tags:[],priority:2,type:"raydium",extensions:{coingeckoId:"solana"}},it={chainId:101,address:"So11111111111111111111111111111111111111112",programId:ni.toBase58(),decimals:9,symbol:"WSOL",name:"Wrapped SOL",logoURI:"https://img-v1.raydium.io/icon/So11111111111111111111111111111111111111112.png",tags:[],priority:2,type:"raydium",extensions:{coingeckoId:"solana"}};import{PublicKey as kn}from"@solana/web3.js";import{PublicKey as le,SystemProgram as ii,SYSVAR_RENT_PUBKEY as dr}from"@solana/web3.js";import{TOKEN_PROGRAM_ID as pr}from"@solana/spl-token";function wn({pubkey:y,isSigner:e=!1,isWritable:t=!0}){return{pubkey:y,isWritable:t,isSigner:e}}var Xo=[wn({pubkey:pr,isWritable:!1}),wn({pubkey:ii.programId,isWritable:!1}),wn({pubkey:dr,isWritable:!1})];function An({publicKey:y,transformSol:e}){let t=ri(y.toString());if(t instanceof le)return e&&t.equals(Ct)?Q:t;if(e&&t.toString()===Ct.toBase58())return Q;if(typeof t=="string"){if(t===le.default.toBase58())return le.default;try{return new le(t)}catch{throw new Error("invalid public key")}}throw new Error("invalid public key")}function ri(y){try{return new le(y)}catch{return y}}var en=new le("MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr"),Tn=new le("MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr"),rt=new le("SysvarRent111111111111111111111111111111111"),Ho=new le("SysvarC1ock11111111111111111111111111111111"),mt=new le("metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s"),zo=new le("Sysvar1nstructions1111111111111111111111111"),jo=ii.programId,Zo=new le("4k3Dyjzvzp8eMZWUXbBCjEvwSkkk59S5iCNLY3QrkX6R"),Yo=new le("Ea5SjE2Y6yvCeW5dYTn7PYMuW5ikXkvbGdcmSnXeaLjS"),Qo=new le("SRMuApVNdxXokk5GT7XD5cUUgXMBCoAz2LHeuAoKWRt"),Jo=new le("EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v"),$o=new le("Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB"),es=new le("mSoLzYCxHdYgdzU16g5QSh3i5K3z3KZK7ytfqcJm7So"),ts=new le("7dHbWXmci3dT8UFYWYZweBLXgycu7Y3iL6trKn1Y7ARj"),ns=new le("USDH1SM1ojwWUga67PGrgFWUHibbjqMvuMaDkRJTgkX"),is=new le("NRVwhjBQiUPYtfDT5zRBVJajzFQHaBUNtC7SNVvqRFa"),rs=new le("ANAxByE6G2WjFp7A4NqtWYXb3mgruyzZYg3spfxe6Lbo"),os=new le("7vfCXTUXx5WJV5JADk17DUJ4ksgau7utNKj4b963voxs"),Q=new le("So11111111111111111111111111111111111111112"),Ct=le.default;function lt(y){return An({publicKey:y,transformSol:!0})}var hn=class{constructor({mint:e,decimals:t,symbol:n,name:i,skipMint:s=!1,isToken2022:o=!1}){if(e===Ct.toBase58()||e instanceof kn&&Ct.equals(e)){this.decimals=it.decimals,this.symbol=it.symbol,this.name=it.name,this.mint=new kn(it.address),this.isToken2022=!1;return}this.decimals=t,this.symbol=n||e.toString().substring(0,6),this.name=i||e.toString().substring(0,6),this.mint=s?kn.default:An({publicKey:e}),this.isToken2022=o}equals(e){return this===e?!0:this.mint.equals(e.mint)}},_e=hn;_e.WSOL=new hn(U(O({},it),{mint:it.address}));var xn=class{constructor({decimals:e,symbol:t="UNKNOWN",name:n="UNKNOWN"}){this.decimals=e,this.symbol=t,this.name=n}equals(e){return this===e}},tn=xn;tn.SOL=new xn(Pn);import fr from"bn.js";var oi=new J(new fr(100)),ot=class extends J{toSignificant(e=5,t,n){return this.mul(oi).toSignificant(e,t,n)}toFixed(e=2,t,n){return this.mul(oi).toFixed(e,t,n)}};var yr=Te("Raydium_price"),Ee=class extends J{constructor(t){let{baseToken:n,quoteToken:i,numerator:s,denominator:o}=t;super(s,o);this.baseToken=n,this.quoteToken=i,this.scalar=new J(Bn(n.decimals),Bn(i.decimals))}get raw(){return new J(this.numerator,this.denominator)}get adjusted(){return super.mul(this.scalar)}invert(){return new Ee({baseToken:this.quoteToken,quoteToken:this.baseToken,denominator:this.numerator,numerator:this.denominator})}mul(t){this.quoteToken!==t.baseToken&&yr.logWithError("mul token not equals");let n=super.mul(t);return new Ee({baseToken:this.baseToken,quoteToken:t.quoteToken,denominator:n.denominator,numerator:n.numerator})}toSignificant(t=this.quoteToken.decimals,n,i){return this.adjusted.toSignificant(t,n,i)}toFixed(t=this.quoteToken.decimals,n,i){return this.adjusted.toFixed(t,n,i)}};import{PublicKey as Ds}from"@solana/web3.js";import vs from"bn.js";var br=new Ye(0),ra=new Ye(1),oa=new Ye(2),sa=new Ye(3),aa=new Ye(5),gn=new Ye(10),ca=new Ye(100),ua=new Ye(1e3),la=new Ye(1e4);function Bn(y){return gn.pow(we(y))}function yn(y,e=1,t=[]){let n=[...y];if(e<=0)return t;for(;n.length;)t.push(n.splice(0,e));return t}var We=class{constructor(e){this._owner=e}get publicKey(){return We.isKeyPair(this._owner)?this._owner.publicKey:this._owner}get signer(){return We.isKeyPair(this._owner)?this._owner:void 0}get isKeyPair(){return We.isKeyPair(this._owner)}get isPublicKey(){return We.isPublicKey(this._owner)}static isKeyPair(e){return e.secretKey!==void 0}static isPublicKey(e){return!We.isKeyPair(e)}};import{PublicKey as hr}from"@solana/web3.js";import{TOKEN_PROGRAM_ID as xr}from"@solana/spl-token";import{ComputeBudgetProgram as si,Keypair as ci,PublicKey as gr,Transaction as ui,TransactionMessage as Pr,VersionedTransaction as li}from"@solana/web3.js";var re={CreateAccount:"CreateAccount",InitAccount:"InitAccount",CreateATA:"CreateATA",CloseAccount:"CloseAccount",TransferAmount:"TransferAmount",InitMint:"InitMint",MintTo:"MintTo",InitMarket:"InitMarket",Util1216OwnerClaim:"Util1216OwnerClaim",SetComputeUnitPrice:"SetComputeUnitPrice",SetComputeUnitLimit:"SetComputeUnitLimit",ClmmCreatePool:"ClmmCreatePool",ClmmOpenPosition:"ClmmOpenPosition",ClmmIncreasePosition:"ClmmIncreasePosition",ClmmDecreasePosition:"ClmmDecreasePosition",ClmmClosePosition:"ClmmClosePosition",ClmmSwapBaseIn:"ClmmSwapBaseIn",ClmmSwapBaseOut:"ClmmSwapBaseOut",ClmmInitReward:"ClmmInitReward",ClmmSetReward:"ClmmSetReward",ClmmCollectReward:"ClmmCollectReward",ClmmLockPosition:"ClmmLockPosition",ClmmHarvestLockPosition:"ClmmHarvestLockPosition",AmmV4Swap:"AmmV4Swap",AmmV4AddLiquidity:"AmmV4AddLiquidity",AmmV4RemoveLiquidity:"AmmV4RemoveLiquidity",AmmV4SimulatePoolInfo:"AmmV4SimulatePoolInfo",AmmV4SwapBaseIn:"AmmV4SwapBaseIn",AmmV4SwapBaseOut:"AmmV4SwapBaseOut",AmmV4CreatePool:"AmmV4CreatePool",AmmV4InitPool:"AmmV4InitPool",AmmV5AddLiquidity:"AmmV5AddLiquidity",AmmV5RemoveLiquidity:"AmmV5RemoveLiquidity",AmmV5SimulatePoolInfo:"AmmV5SimulatePoolInfo",AmmV5SwapBaseIn:"AmmV5SwapBaseIn",AmmV5SwapBaseOut:"AmmV5SwapBaseOut",RouteSwap:"RouteSwap",RouteSwap1:"RouteSwap1",RouteSwap2:"RouteSwap2",FarmV3Deposit:"FarmV3Deposit",FarmV3Withdraw:"FarmV3Withdraw",FarmV3CreateLedger:"FarmV3CreateLedger",FarmV4Withdraw:"FarmV4Withdraw",FarmV5Deposit:"FarmV5Deposit",FarmV5Withdraw:"FarmV5Withdraw",FarmV5CreateLedger:"FarmV5CreateLedger",FarmV6Deposit:"FarmV6Deposit",FarmV6Withdraw:"FarmV6Withdraw",FarmV6Create:"FarmV6Create",FarmV6Restart:"FarmV6Restart",FarmV6CreatorAddReward:"FarmV6CreatorAddReward",FarmV6CreatorWithdraw:"FarmV6CreatorWithdraw",CpmmCreatePool:"CpmmCreatePool",CpmmAddLiquidity:"CpmmAddLiquidity",CpmmWithdrawLiquidity:"CpmmWithdrawLiquidity",CpmmSwapBaseIn:"CpmmSwapBaseIn",CpmmSwapBaseOut:"CpmmSwapBaseOut",CpmmLockLp:"CpmmLockLp",CpmmCollectLockFee:"CpmmCollectLockFee",TransferTip:"TransferTip"};import{TOKEN_PROGRAM_ID as wr}from"@solana/spl-token";var ai=Te("Raydium_txUtil"),mi=1644;function Kt(y){let e=[],t=[];return y.microLamports&&(e.push(si.setComputeUnitPrice({microLamports:y.microLamports})),t.push(re.SetComputeUnitPrice)),y.units&&(e.push(si.setComputeUnitLimit({units:y.units})),t.push(re.SetComputeUnitLimit)),{instructions:e,instructionTypes:t}}async function dt(y,e){var n,i;let t=e!=null?e:"confirmed";return(i=await((n=y.getLatestBlockhash)==null?void 0:n.call(y,{commitment:t})))==null?void 0:i.blockhash}async function Lt(y,e){return y.getSignatureStatuses([e]),new Promise((t,n)=>{let i=setTimeout(n,6e4);y.onSignature(e,s=>{if(clearTimeout(i),!s.err){t("");return}n(Object.assign(s.err,{txId:e}))},"confirmed")})}function Ar(y,e){y.length<1&&ai.logWithError(`no instructions provided: ${y.toString()}`),e.length<1&&ai.logWithError(`no signers provided:, ${e.toString()}`);let t=new ui;t.recentBlockhash="11111111111111111111111111111111",t.feePayer=e[0],t.add(...y);try{return Buffer.from(t.serialize({verifySignatures:!1})).toString("base64").length<mi}catch{return!1}}function he(y,e){let[t,n]=gr.findProgramAddressSync(y,e);return{publicKey:t,nonce:n}}function Rt({instructions:y,payer:e,signers:t}){return Ar(y,[e,...t])}function Qe({instructions:y,payer:e,lookupTableAddressAccount:t,recentBlockhash:n=ci.generate().publicKey.toString()}){let s=new Pr({payerKey:e,recentBlockhash:n,instructions:y}).compileToV0Message(Object.values(t!=null?t:{}));try{return Buffer.from(new li(s).serialize()).toString("base64").length<mi}catch{return!1}}var Tr=y=>Buffer.isBuffer(y)?y:y instanceof Uint8Array?Buffer.from(y.buffer,y.byteOffset,y.byteLength):Buffer.from(y),kr=y=>{let e=y.serialize({requireAllSignatures:!1,verifySignatures:!1});y instanceof li&&(e=Tr(e));try{return e instanceof Buffer?e.toString("base64"):Buffer.from(e).toString("base64")}catch{return e.toString("base64")}};function st(y){let e=[];return y.forEach(t=>{t instanceof ui&&(t.recentBlockhash||(t.recentBlockhash=wr.toBase58()),t.feePayer||(t.feePayer=ci.generate().publicKey)),e.push(kr(t))}),console.log("simulate tx string:",e),e}function oe(y,e,t){return he([y.toBuffer(),(t!=null?t:xr).toBuffer(),e.toBuffer()],new hr("ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL"))}import{PublicKey as D}from"@solana/web3.js";var Ra=new D("EhhTKczWMGQt46ynNeRX1WfeagwwJd7ufHvCDjRxjo5Q"),Na=new D("CBuCnLe26faBpcBP2fktp4rp8abpcAnTWft6ZrP5Q4T"),Ma=new D("9KEPoZmtHUrBbhWN1v1KWLMkkvwY6WLtAVUCPRtRjP4z"),Oa=new D("FarmqiPv5eAj3j1GMdMCMUGXqPUvmquZtMy86QH6rzhG"),Fa=new D("CLaimxFqjHzgTJtAGHU47NPhg6qrc5sCnpC4tBLyABQS"),Ea=new D("srmqPvymJeFKQ4zGQed1GFppgkRHL9kaELCbyksJtPX"),Da=new D("9xQeWvG816bUx9EPjHmaT23yvVM2ZWbrrpZb9PusVFin"),Va=new D("675kPX9MHTjS2zt1qfr1NYHuzeLXfQM9H24wFSUt1Mp8"),va=new D("5quBtoiQqxF9Jv6KYKctB59NT3gtJD2Y65kdnB1Uev3h"),_a=new D("CDSr3ssLcRB6XYPJwAfFt18MZvEZp4LjHcvzBVZ45duo"),Nt=new D("CAMMCzo5YL8w4VFF8KVHrK22GGUsp5VTaW7grrKgrWqK"),Mt=new D("LockrWmn6K5twhz3y9w1dQERbmgSaRkfnTeTKbpofwE"),nn=new D("kN1kEznaF5Xbd8LYuqtEFcxzWSBk5Fv6ygX6SqEGJVy"),Wa=new D("CDSr3ssLcRB6XYPJwAfFt18MZvEZp4LjHcvzBVZ45duo"),qa=new D("routeUGWgWzqBWFcrCfv8tritsqukccJPu3q5GPP3xS"),Ga=new D("7YttLkHDoNj9wyDur5pM1ejNaAvT9X4eqaYcHQqtj2G5"),Ua=new D("6FJon3QE27qgPVggARueB22hLvoh22VzJpXv4rBEoSLF"),Xa=new D("CC12se5To1CdEuw7fDS27B7Geo5jJyL7t5UK2B44NgiH"),Ha=new D("9HzJyW1qZsEiSfMUf6L2jo3CcTKAyBmSyKdwQeYisHrC"),za=new D("DropEU8AvevN3UrXWXTMuz3rqnMczQVNjq3kcSdW2SQi"),ja=new D("CPMMoo8L3F4NbTegBCKVNunggL7H1ZpdTHKxQB5qKP1C"),Za=new D("GpMZbSM2GgvTKHJirzeGfMFoaZ8UR2X7F4v8vHTvxFbL"),Ya=new D("DNXgeM9EiiaAbaWvwjHj9fQQLAX5ZsfHyvmYUNRAdNC8"),Qa=new D("LockrWmn6K5twhz3y9w1dQERbmgSaRkfnTeTKbpofwE"),Ja=new D("3f7GcQFG397GAaEnv51zR6tsTVihYRydnydDD1cXekxH"),$a=new D("LanMV9sAd7wArD4vJFi2qDdfnVhFxYSUg6eADduJ3uj"),ec=new D("WLHv2UAZm6z4KyaaELi5pjdbJh6RESMva1Rnn8pJVVh"),tc=new D("DRay6fNdQ5J82H7xV6uq2aV3mNrUZ1J4PgSKsWgptcm6"),nc=new D("5xqNaZXX5eUi4p5HU4oz9i5QnwRNT2y6oN7yyn4qENeq"),ic=new D("4Bu96XjU84XjPDSpveTVf6LYGCkfW5FK7SNkREWcEfV4"),rc=new D("6s1xP3hpbAfFoNtUNF8mfHsjr2Bd97JxFJRWLbL6aHuX");var oc={OPEN_BOOK_PROGRAM:new D("EoTcMgcDRTJVZDMZWBoU6rhYHZfkNTVEAfz3uUJRcYGj"),SERUM_PROGRAM_ID_V3:new D("Ray1111111111111111111111111111111111111111"),AMM_V4:new D("DRaya7Kj3aMWQSy19kSjvmuwq9docCHofyP9kanQGaav"),AMM_STABLE:new D("DRayDdXc1NZQ9C3hRWmoSf8zK4iapgMnjdNZWrfwsP8m"),CLMM_PROGRAM_ID:new D("DRayAUgENGQBKVaX8owNhgzkEDyoHTGVEGHVJT1E9pfH"),CLMM_LOCK_PROGRAM_ID:new D("DRay25Usp3YJAi7beckgpGUC7mGJ2cR1AVPxhYfwVCUX"),CLMM_LOCK_AUTH_ID:new D("6Aoh8h2Lw2m5UGxYR8AdAL87jTWYeKoxM52mJRzfYwN"),CREATE_CPMM_POOL_PROGRAM:new D("DRaycpLY18LhpbydsBWbVJtxpNv9oXPgjRSfpF2bWpYb"),CREATE_CPMM_POOL_AUTH:new D("CXniRufdq5xL8t8jZAPxsPZDpuudwuJSPWnbcD5Y5Nxq"),CREATE_CPMM_POOL_FEE_ACC:new D("3oE58BKVt8KuYkGxx8zBojugnymWmBiyafWgMrnb6eYy"),LOCK_CPMM_PROGRAM:new D("DRay25Usp3YJAi7beckgpGUC7mGJ2cR1AVPxhYfwVCUX"),LOCK_CPMM_AUTH:new D("7qWVV8UY2bRJfDLP4s37YzBPKUkVB46DStYJBpYbQzu3"),UTIL1216:D.default,Router:new D("DRaybByLpbUL57LJARs3j8BitTxVfzBg351EaMr5UTCd"),FARM_PROGRAM_ID_V3:new D("DRayWyrLmEW5KEeqs8kdTMMaBabapqagaBC7KWpGtJeZ"),FARM_PROGRAM_ID_V4:new D("Ray1111111111111111111111111111111111111111"),FARM_PROGRAM_ID_V5:new D("DRayiCGSZgku1GTK6rXD6mVDdingXy6APAH1R6R5L2LC"),FARM_PROGRAM_ID_V6:new D("DRayzbYakXs45ELHkzH6vC3fuhQqTAnv5A68gdFuvZyZ"),LAUNCHPAD_PROGRAM:new D("DRay6fNdQ5J82H7xV6uq2aV3mNrUZ1J4PgSKsWgptcm6"),LAUNCHPAD_AUTH:new D("5xqNaZXX5eUi4p5HU4oz9i5QnwRNT2y6oN7yyn4qENeq"),LAUNCHPAD_PLATFORM:new D("2Jx4KTDrVSdWNazuGpcA8n3ZLTRGGBDxAWhuKe2Xcj2a"),LAUNCHPAD_CONFIG:new D("7ZR4zD7PYfY2XxoG1Gxcy2EgEeGYrpxrwzPuwdUBssEt"),FEE_DESTINATION_ID:new D("9y8ENuuZ3b19quffx9hQvRVygG5ky6snHfRvGpuSfeJy"),MODEL_DATA_PUBKEY:new D("Ray1111111111111111111111111111111111111111")};import De from"bn.js";var Ot=1e4;function me(y,e,t,n){if(e===void 0)return{amount:y,fee:void 0,expirationTime:void 0};let i=U(O({},e),{olderTransferFee:{epoch:BigInt(e.olderTransferFee.epoch),maximumFee:BigInt(e.olderTransferFee.maximumFee),transferFeeBasisPoints:e.olderTransferFee.transferFeeBasisPoints},newerTransferFee:{epoch:BigInt(e.newerTransferFee.epoch),maximumFee:BigInt(e.newerTransferFee.maximumFee),transferFeeBasisPoints:e.newerTransferFee.transferFeeBasisPoints}}),s=t.epoch<i.newerTransferFee.epoch?i.olderTransferFee:i.newerTransferFee,o=new De(s.maximumFee.toString()),r=t.epoch<i.newerTransferFee.epoch?(Number(i.newerTransferFee.epoch)*t.slotsInEpoch-t.absoluteSlot)*400/1e3:void 0;if(n)if(s.transferFeeBasisPoints===Ot){let a=new De(s.maximumFee.toString());return{amount:y.add(a),fee:a,expirationTime:r}}else{let a=In(y.mul(new De(Ot)),new De(Ot-s.transferFeeBasisPoints)),c=new De(s.maximumFee.toString()),l=a.sub(y).gt(c)?y.add(c):a,d=In(l.mul(new De(s.transferFeeBasisPoints)),new De(Ot)),f=d.gt(o)?o:d;return{amount:l,fee:f,expirationTime:r}}else{let a=In(y.mul(new De(s.transferFeeBasisPoints)),new De(Ot)),c=a.gt(o)?o:a;return{amount:y,fee:c,expirationTime:r}}}function at(y,e){return y===void 0?e:e===void 0?y:Math.min(y,e)}function In(y,e){let{div:t,mod:n}=y.divmod(e);return n.gt(new De(0))?t.add(new De(1)):t}import{PublicKey as Sn,AddressLookupTableAccount as wt}from"@solana/web3.js";async function rn({connection:y,address:e,cluster:t="mainnet"}){let n=await je(y,[...new Set(e.map(s=>s.toString()))].map(s=>new Sn(s))),i={};for(let s=0;s<e.length;s++){let o=n[s],r=e[s];if(!o)continue;let a=new wt({key:r,state:wt.deserialize(o.data)});i[r.toString()]=a,t==="devnet"?Pt[r.toString()]=a:Ft[r.toString()]=a}return i}var Ft={AcL1Vo8oy1ULiavEcjSUcwfBSForXMudcZvDZy5nzJkU:new wt({key:new Sn("AcL1Vo8oy1ULiavEcjSUcwfBSForXMudcZvDZy5nzJkU"),state:wt.deserialize(Buffer.from("AQAAAP//////////I1rcEwAAAAAvAQYwun9CU6c5Ikm2pAj+D9IEnCOR45nK+SFTGSdpd6J6AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAbd9uHXZaGT2cvhRs7reawctIXtX1s3kTqM9YV+/wCpBt324e51j94YQl285GzN2rYa/E2DuQ0n/r35KNihi/wFSlNQ+F3IgtYUpVZyeIopbd8eq6vQpgZ4iEky9O72oAVKU1qZKSEGTSTocWDaOHx8NbXdvJK7geQfqEBBBUSNBqfVFxksXFEhjMlMPUrxf1ja7gibof1E49vZigAAAAAGp9UXGMd0yShWY5hpHV62i164o5tLbVxzVVshAAAAAIyXJY9OJInxuz0QKRSODYMLWhOZ2v8QhASOe9jb6fhZC3BlsePRfEU4nVJ/awTDzVi4bHMaoP21SbbRvAP4KUbIScv+6Yw2LHF/6K0ZjUPibbSWXCirYPGuuVl7zT789IUPLW4CpHr4JNCatp3ELXDLKMv6JJ+37le50lbBJ2LvBkX2T9y7AHdNGviJAqQNtlDUDCnauQRWybsLji6nPM8Qkw5asQRvCdB3MbX6IEBwytOrpM32l4jQygKG9TKgR0vZScQ2AsM/IHeQ7RajUkyhuZdc8SGiqQz/7H34torNR/Wir3sl0ruUrVxJWEZfUg+QLNAxxODdBi53/OP7Ioil1cqeBM9dtZC3FLov4yyxWRM/wcGStyJX/QfTnLBAHqkqWotPKVlShCVQqpP9W5W1rOao65IMk5QuQ2kMIOxzDMKAy2vjGSxQODgBz0QwGA+eP4ZjIjrIAQaXENv31QfLlOdXSRCkaybRniDHF4C8YcwhcvsqrOVuTP4B2Na+9wLdtrB31uz2rtlFI5kahdsnp/d1SrASDInYCtTYtdoke4kX+hoKWcEWM4Tle8pTUkUVv4BxS6fje/EzKBE4Qu/YsA/yfEEFGcr8Z57VKDw8uQzpiru7g4lvjnfapW62W030syevD8k07SGoxUHiuT/ai7gAHWWhDsVmg/C63ajgpkH7Sn3GdutArDTfyqOkdqv4/IPC/EFFy7mGkfDd2C57N5a/4jC+BbmJy7wQaSEZr0CQU88lPtUxIVvzGjC95b8Ooss2TqmkrayGKofkPMGQn7Ux+9lfwBSNfxwH8NgbpqC/7LNlV4I7nCvsXf3p+ohQk9NrAJb2KAFpUqEIJ9ZBV7BYDzHF/ORKYlgtvPnXjudZQ6CEo5OzUDaNIomTCCsvhD16TxJjsbgne1kGnQPCFSoaxUbq2V1bPMFQ3VYP6wDZ9bKStCFKx9A3tNbwZFC5ZGAN83MFK7XoTy+OmmcFEr6rLOjfSuTfPvHJkSVxW6Qllwkl67XcBi5v00u2gQsbu+38sp+rd5pA/LvyWj4P94ZGZwc1tE2P88xekCLcAwZGb+UhFzL/7K26csOb57yM5bvF9xJrLEObOkAAAAAn+HWRkdcPKyFFMnVwEoD7vnD0jCKFIU1sImubYCxNTSVzsKpaQX+fzNxrLAI3L14JQnJx/D6Uk2LADIHGqnGELzjEbkBDAlaM77NkXMPfqXNLSveCkWI7UEgNs31WEWB6XHSYI/v5DklHOb4QTtDOR804PVbi3fjloZeLR2F8d4FuZmMMO7ck3Fnkn2zEMG5gOmqsygb6PjTitArVl52NhcSznTxVnguaIJxiZkAnurDmn3MWR0PC2GLghp2KJqHCc6QQ85odeIjFHKOlRlJyeSXVJmL8vb1UgOzsbJPVP8p6zM4M3C1Sd7uWIHP33G42AP2Zg8ucn/n6meQjjD266JgCWdxZD6PXs9CsnIeL7SSG0/6lGb9xfP0ZcWkCXB/3hjxHYVXjra/GPOeXGk0fLLKjCbk+mgs2w6d2oCwimBipTzuoZ30GiI8ij8VRzD5CzMWtu2m21eDBIfjGAEo4pQeNNonKcqzV/cleX8ySZLOHsz8PtBCrLqF+VkLm9hOzIT+6i/nIf6keR4GWKMOD4AvqfpjHoD4DuhBpz8P28+DxkGrDXXr/nr20x291VPvcTU/b+b+o2kC9G0kcXeTlLjU6a2TQXWlZ4gBUdBl1jgT7mObSTpLblNiXZsLkbmVXZwvFKXua5cUKlWed/w30skmEUraTuQqtqr5fHZPW9n57EmeTif6LjHL2YJFZkQU+TrJmFzqzmF4/b8OwrPQAprl8mX3q4LUIdAS/a+11B6DWD1Xk2++Sn94dLC4xjkO4Wtlw8c4XuzciVbepHOmnoWzVu/0y3KCrLCSfQxQ3br8DJCoVzhgtPsS2nZZjsBGIZgnU0QpMv+2MnRsnKwdp1VsrCX84j/qvaZn4WhKunippgTbN2EUs0tPTP55Qfgj+nKmjtWW5IYs72FrEwJKYoNfsmqaF4o5pf4v9zgPwVwY/5I4XJKUL2L25m9kAQcW/K+H1RTFEUoj8Z4ajpOmAB/dG0COmCphVMW2CCMvnxhcGiSgPnpDuWu6qiJ7NG7ye5kvHgefgqPLeicspNJ5EpL3XiRNLM2tmJLI1awAwOyd6iHv0dCkMYRKaa6rcaZeYwmKCkckm0kM2JNmnmmAaBQQ7mwmIM0IMxX4f5W6j9PqZWcJxF7r17T/lQBAmcjoupRiJifbnXCNUv9GhpRF19WcBdeKbivRJVlGop6I2RS6lGImJ9udcI1S/0aGlEXX1ZwF14puK9ElWUainojZFYVHLHD6dIP2ESjqBzg3ol1/wB7+/ylGwd9LS7wSZ2A630CJSVKwH47K9P4bB8PEQP8BwjMFa7xQHOqZFP1XqaQ==","base64"))})},Pt={},on=async y=>{let e="EFhMuDw1PKEuckuFRW9PavNfTH4LKP5uKHgyXDmWpFCq";if(Pt[e])return Pt;let t=new Sn(e),n=await y.getAccountInfo(t);return n&&(Pt[e]=new wt({key:t,state:wt.deserialize(n.data)})),Pt};import{PublicKey as pt,sendAndConfirmTransaction as Cn,SystemProgram as Ir,Transaction as Et,TransactionMessage as Je,VersionedTransaction as $e}from"@solana/web3.js";import Sr from"axios";var Dt=2e3,Vt=class{constructor(e){this.instructions=[];this.endInstructions=[];this.lookupTableAddress=[];this.signers=[];this.instructionTypes=[];this.endInstructionTypes=[];this.connection=e.connection,this.feePayer=e.feePayer,this.signAllTransactions=e.signAllTransactions,this.owner=e.owner,this.cluster=e.cluster,this.blockhashCommitment=e.blockhashCommitment,this.loopMultiTxStatus=!!e.loopMultiTxStatus}get AllTxData(){return{instructions:this.instructions,endInstructions:this.endInstructions,signers:this.signers,instructionTypes:this.instructionTypes,endInstructionTypes:this.endInstructionTypes,lookupTableAddress:this.lookupTableAddress}}get allInstructions(){return[...this.instructions,...this.endInstructions]}async getComputeBudgetConfig(){var n;let e=(await Sr.get(`https://solanacompass.com/api/fees?cacheFreshTime=${3e5}`)).data,{avg:t}=(n=e==null?void 0:e[15])!=null?n:{};if(!!t)return{units:6e5,microLamports:Math.min(Math.ceil(t*1e6/6e5),25e3)}}addCustomComputeBudget(e){if(e){let{instructions:t,instructionTypes:n}=Kt(e);return this.instructions.unshift(...t),this.instructionTypes.unshift(...n),!0}return!1}addTipInstruction(e){var t;return e?(this.endInstructions.push(Ir.transfer({fromPubkey:(t=e.feePayer)!=null?t:this.feePayer,toPubkey:new pt(e.address),lamports:BigInt(e.amount.toString())})),this.endInstructionTypes.push(re.TransferTip),!0):!1}async calComputeBudget({config:e,defaultIns:t}){try{let n=e||await this.getComputeBudgetConfig();if(this.addCustomComputeBudget(n))return;t&&this.instructions.unshift(...t)}catch{t&&this.instructions.unshift(...t)}}addInstruction({instructions:e=[],endInstructions:t=[],signers:n=[],instructionTypes:i=[],endInstructionTypes:s=[],lookupTableAddress:o=[]}){return this.instructions.push(...e),this.endInstructions.push(...t),this.signers.push(...n),this.instructionTypes.push(...i),this.endInstructionTypes.push(...s),this.lookupTableAddress.push(...o.filter(r=>r!==pt.default.toString())),this}async versionBuild({txVersion:e,extInfo:t}){return e===0?await this.buildV0(O({},t||{})):this.build(t)}build(e){var n;let t=new Et;return this.allInstructions.length&&t.add(...this.allInstructions),t.feePayer=this.feePayer,((n=this.owner)==null?void 0:n.signer)&&!this.signers.some(i=>i.publicKey.equals(this.owner.publicKey))&&this.signers.push(this.owner.signer),{builder:this,transaction:t,signers:this.signers,instructionTypes:[...this.instructionTypes,...this.endInstructionTypes],execute:async i=>{var l;let{recentBlockHash:s,skipPreflight:o=!0,sendAndConfirm:r,notSendToRpc:a}=i||{},c=s!=null?s:await dt(this.connection,this.blockhashCommitment);if(t.recentBlockhash=c,this.signers.length&&t.sign(...this.signers),st([t]),(l=this.owner)!=null&&l.isKeyPair)return{txId:r?await Cn(this.connection,t,this.signers.find(f=>f.publicKey.equals(this.owner.publicKey))?this.signers:[...this.signers,this.owner.signer],{skipPreflight:o}):await this.connection.sendRawTransaction(t.serialize(),{skipPreflight:o}),signedTx:t};if(this.signAllTransactions){let d=await this.signAllTransactions([t]);if(this.signers.length)for(let f of d)try{f.sign(...this.signers)}catch{}return{txId:a?"":await this.connection.sendRawTransaction(d[0].serialize(),{skipPreflight:o}),signedTx:d[0]}}throw new Error("please provide owner in keypair format or signAllTransactions function")},extInfo:e||{}}}buildMultiTx(e){var c;let{extraPreBuildData:t=[],extInfo:n}=e,{transaction:i}=this.build(n),s=t.filter(l=>l.transaction.instructions.length>0),o=[i,...s.map(l=>l.transaction)],r=[this.signers,...s.map(l=>l.signers)],a=[...this.instructionTypes,...s.map(l=>l.instructionTypes).flat()];return(c=this.owner)!=null&&c.signer&&r.forEach(l=>{l.some(d=>d.publicKey.equals(this.owner.publicKey))||this.signers.push(this.owner.signer)}),{builder:this,transactions:o,signers:r,instructionTypes:a,execute:async l=>{var g;let{sequentially:d,onTxUpdate:f,skipTxCount:u=0,recentBlockHash:m,skipPreflight:p=!0}=l||{},b=m!=null?m:await dt(this.connection,this.blockhashCommitment);if((g=this.owner)!=null&&g.isKeyPair){if(d){let w=[],k=0;for(let T of o){if(++k,k<=u)continue;let A=await Cn(this.connection,T,this.signers.find(P=>P.publicKey.equals(this.owner.publicKey))?this.signers:[...this.signers,this.owner.signer],{skipPreflight:p});w.push(A)}return{txIds:w,signedTxs:o}}return{txIds:await await Promise.all(o.map(async w=>(w.recentBlockhash=b,await this.connection.sendRawTransaction(w.serialize(),{skipPreflight:p})))),signedTxs:o}}if(this.signAllTransactions){let w=o.map((T,A)=>(T.recentBlockhash=b,r[A].length&&T.sign(...r[A]),T));st(w);let k=await this.signAllTransactions(w);if(d){let T=0,A=[],P=async()=>{if(!k[T])return;let x=await this.connection.sendRawTransaction(k[T].serialize(),{skipPreflight:p});A.push({txId:x,status:"sent",signedTx:k[T]}),f==null||f([...A]),T++;let h=!1,B=null,K=null,L=C=>{B!==null&&clearInterval(B),K!==null&&this.connection.removeSignatureListener(K);let N=A.findIndex(I=>I.txId===x);if(N>-1){if(A[N].status==="error"||A[N].status==="success")return;A[N].status=C.err?"error":"success"}f==null||f([...A]),C.err||P()};this.loopMultiTxStatus&&(B=setInterval(async()=>{var C;if(h){clearInterval(B);return}try{let N=await this.connection.getTransaction(x,{commitment:"confirmed",maxSupportedTransactionVersion:0});N&&(h=!0,clearInterval(B),L({err:((C=N.meta)==null?void 0:C.err)||null}),console.log("tx status from getTransaction:",x))}catch(N){h=!0,clearInterval(B),console.error("getTransaction timeout:",N,x)}},Dt)),K=this.connection.onSignature(x,C=>{if(h){this.connection.removeSignatureListener(K);return}h=!0,L(C)},"confirmed"),this.connection.getSignatureStatus(x)};return await P(),{txIds:A.map(x=>x.txId),signedTxs:k}}else{let T=[];for(let A=0;A<k.length;A+=1){let P=await this.connection.sendRawTransaction(k[A].serialize(),{skipPreflight:p});T.push(P)}return{txIds:T,signedTxs:k}}}throw new Error("please provide owner in keypair format or signAllTransactions function")},extInfo:n||{}}}async versionMultiBuild({extraPreBuildData:e,txVersion:t,extInfo:n}){return t===0?await this.buildV0MultiTx({extraPreBuildData:e,buildProps:n||{}}):this.buildMultiTx({extraPreBuildData:e,extInfo:n})}async buildV0(e){var p;let m=e||{},{lookupTableCache:t={},lookupTableAddress:n=[],forerunCreate:i,recentBlockhash:s}=m,o=ut(m,["lookupTableCache","lookupTableAddress","forerunCreate","recentBlockhash"]),r=O(O({},this.cluster==="devnet"?await on(this.connection):Ft),t),a=Array.from(new Set([...n,...this.lookupTableAddress])),c=[];for(let b of a)r[b]===void 0&&c.push(new pt(b));let l=await rn({connection:this.connection,address:c});for(let[b,g]of Object.entries(l))r[b]=g;let d=i?pt.default.toBase58():s!=null?s:await dt(this.connection,this.blockhashCommitment),f=new Je({payerKey:this.feePayer,recentBlockhash:d,instructions:[...this.allInstructions]}).compileToV0Message(Object.values(r));((p=this.owner)==null?void 0:p.signer)&&!this.signers.some(b=>b.publicKey.equals(this.owner.publicKey))&&this.signers.push(this.owner.signer);let u=new $e(f);return u.sign(this.signers),{builder:this,transaction:u,signers:this.signers,instructionTypes:[...this.instructionTypes,...this.endInstructionTypes],execute:async b=>{var T;let{skipPreflight:g=!0,sendAndConfirm:w,notSendToRpc:k}=b||{};if(st([u]),(T=this.owner)!=null&&T.isKeyPair){let A=await this.connection.sendTransaction(u,{skipPreflight:g});return w&&await Lt(this.connection,A),{txId:A,signedTx:u}}if(this.signAllTransactions){let A=await this.signAllTransactions([u]);if(this.signers.length)for(let P of A)try{P.sign(this.signers)}catch{}return{txId:k?"":await this.connection.sendTransaction(A[0],{skipPreflight:g}),signedTx:A[0]}}throw new Error("please provide owner in keypair format or signAllTransactions function")},extInfo:o||{}}}async buildV0MultiTx(e){var c;let{extraPreBuildData:t=[],buildProps:n}=e,{transaction:i}=await this.buildV0(n),s=t.filter(l=>l.builder.instructions.length>0),o=[i,...s.map(l=>l.transaction)],r=[this.signers,...s.map(l=>l.signers)],a=[...this.instructionTypes,...s.map(l=>l.instructionTypes).flat()];return(c=this.owner)!=null&&c.signer&&r.forEach(l=>{l.some(d=>d.publicKey.equals(this.owner.publicKey))||this.signers.push(this.owner.signer)}),o.forEach(async(l,d)=>{l.sign(r[d])}),{builder:this,transactions:o,signers:r,instructionTypes:a,buildProps:n,execute:async l=>{var p;let{sequentially:d,onTxUpdate:f,recentBlockHash:u,skipPreflight:m=!0}=l||{};if(u&&o.forEach(b=>b.message.recentBlockhash=u),st(o),(p=this.owner)!=null&&p.isKeyPair){if(d){let b=[];for(let g of o){let w=await this.connection.sendTransaction(g,{skipPreflight:m});await Lt(this.connection,w),b.push(w)}return{txIds:b,signedTxs:o}}return{txIds:await Promise.all(o.map(async b=>await this.connection.sendTransaction(b,{skipPreflight:m}))),signedTxs:o}}if(this.signAllTransactions){let b=await this.signAllTransactions(o);if(d){let g=0,w=[],k=async()=>{if(!b[g])return;let T=await this.connection.sendTransaction(b[g],{skipPreflight:m});w.push({txId:T,status:"sent",signedTx:b[g]}),f==null||f([...w]),g++;let A=!1,P=null,x=null,h=B=>{P!==null&&clearInterval(P),x!==null&&this.connection.removeSignatureListener(x);let K=w.findIndex(L=>L.txId===T);if(K>-1){if(w[K].status==="error"||w[K].status==="success")return;w[K].status=B.err?"error":"success"}f==null||f([...w]),B.err||k()};this.loopMultiTxStatus&&(P=setInterval(async()=>{var B;if(A){clearInterval(P);return}try{let K=await this.connection.getTransaction(T,{commitment:"confirmed",maxSupportedTransactionVersion:0});K&&(A=!0,clearInterval(P),h({err:((B=K.meta)==null?void 0:B.err)||null}),console.log("tx status from getTransaction:",T))}catch(K){A=!0,clearInterval(P),console.error("getTransaction timeout:",K,T)}},Dt)),x=this.connection.onSignature(T,B=>{if(A){this.connection.removeSignatureListener(x);return}A=!0,h(B)},"confirmed"),this.connection.getSignatureStatus(T)};return k(),{txIds:[],signedTxs:b}}else{let g=[];for(let w=0;w<b.length;w+=1){let k=await this.connection.sendTransaction(b[w],{skipPreflight:m});g.push(k)}return{txIds:g,signedTxs:b}}}throw new Error("please provide owner in keypair format or signAllTransactions function")},extInfo:n||{}}}async sizeCheckBuild(e){var f;let d=e||{},{splitIns:t=[],computeBudgetConfig:n}=d,i=ut(d,["splitIns","computeBudgetConfig"]),s=n?Kt(n):{instructions:[],instructionTypes:[]},o=this.signers.reduce((u,m)=>U(O({},u),{[m.publicKey.toBase58()]:m}),{}),r=[],a=[],c=[],l=0;if(this.allInstructions.forEach(u=>{let m=[...c,u],p=n?[...s.instructions,...m]:m,g=[...new Set(m.map(w=>w.keys.filter(k=>k.isSigner).map(k=>k.pubkey.toString())).flat()).values()].map(w=>new pt(w));if(u!==t[l]&&c.length<12&&(Rt({instructions:p,payer:this.feePayer,signers:g})||Rt({instructions:m,payer:this.feePayer,signers:g})))c.push(u);else{if(c.length===0)throw Error("item ins too big");l+=u===t[l]?1:0,Rt({instructions:n?[...s.instructions,...c]:[...c],payer:this.feePayer,signers:g})?r.push(new Et().add(...s.instructions,...c)):r.push(new Et().add(...c)),a.push(Array.from(new Set(c.map(w=>w.keys.filter(k=>k.isSigner).map(k=>k.pubkey.toString())).flat())).map(w=>o[w]).filter(w=>w!==void 0)),c=[u]}}),c.length>0){let m=[...new Set(c.map(p=>p.keys.filter(b=>b.isSigner).map(b=>b.pubkey.toString())).flat()).values()].map(p=>o[p]).filter(p=>p!==void 0);Rt({instructions:n?[...s.instructions,...c]:[...c],payer:this.feePayer,signers:m.map(p=>p.publicKey)})?r.push(new Et().add(...s.instructions,...c)):r.push(new Et().add(...c)),a.push(m)}return r.forEach(u=>u.feePayer=this.feePayer),(f=this.owner)!=null&&f.signer&&a.forEach(u=>{u.some(m=>m.publicKey.equals(this.owner.publicKey))||u.push(this.owner.signer)}),{builder:this,transactions:r,signers:a,instructionTypes:this.instructionTypes,execute:async u=>{var T;let{sequentially:m,onTxUpdate:p,skipTxCount:b=0,recentBlockHash:g,skipPreflight:w=!0}=u||{},k=g!=null?g:await dt(this.connection,this.blockhashCommitment);if(r.forEach(async(A,P)=>{A.recentBlockhash=k,a[P].length&&A.sign(...a[P])}),st(r),(T=this.owner)!=null&&T.isKeyPair){if(m){let A=0,P=[];for(let x of r){if(++A,A<=b){P.push("tx skipped");continue}let h=await Cn(this.connection,x,this.signers.find(B=>B.publicKey.equals(this.owner.publicKey))?this.signers:[...this.signers,this.owner.signer],{skipPreflight:w});P.push(h)}return{txIds:P,signedTxs:r}}return{txIds:await Promise.all(r.map(async A=>await this.connection.sendRawTransaction(A.serialize(),{skipPreflight:w}))),signedTxs:r}}if(this.signAllTransactions){let A=await this.signAllTransactions(r.slice(b,r.length)),P=[...r.slice(0,b),...A];if(m){let x=0,h=[],B=async()=>{if(!P[x])return;x<b&&(h.push({txId:"",status:"success",signedTx:P[x]}),p==null||p([...h]),x++,B());let K=await this.connection.sendRawTransaction(P[x].serialize(),{skipPreflight:w});h.push({txId:K,status:"sent",signedTx:P[x]}),p==null||p([...h]),x++;let L=!1,C=null,N=null,I=F=>{C!==null&&clearInterval(C),N!==null&&this.connection.removeSignatureListener(N);let q=h.findIndex(ue=>ue.txId===K);if(q>-1){if(h[q].status==="error"||h[q].status==="success")return;h[q].status=F.err?"error":"success"}p==null||p([...h]),F.err||B()};this.loopMultiTxStatus&&(C=setInterval(async()=>{var F;if(L){clearInterval(C);return}try{let q=await this.connection.getTransaction(K,{commitment:"confirmed",maxSupportedTransactionVersion:0});q&&(L=!0,clearInterval(C),I({err:((F=q.meta)==null?void 0:F.err)||null}),console.log("tx status from getTransaction:",K))}catch(q){L=!0,clearInterval(C),console.error("getTransaction timeout:",q,K)}},Dt)),N=this.connection.onSignature(K,F=>{if(L){this.connection.removeSignatureListener(N);return}L=!0,I(F)},"confirmed"),this.connection.getSignatureStatus(K)};return await B(),{txIds:h.map(K=>K.txId),signedTxs:P}}else{let x=[];for(let h=0;h<P.length;h+=1){let B=await this.connection.sendRawTransaction(P[h].serialize(),{skipPreflight:w});x.push(B)}return{txIds:x,signedTxs:P}}}throw new Error("please provide owner in keypair format or signAllTransactions function")},extInfo:i||{}}}async sizeCheckBuildV0(e){var k;let w=e||{},{computeBudgetConfig:t,splitIns:n=[],lookupTableCache:i={},lookupTableAddress:s=[]}=w,o=ut(w,["computeBudgetConfig","splitIns","lookupTableCache","lookupTableAddress"]),r=O(O({},this.cluster==="devnet"?await on(this.connection):Ft),i),a=Array.from(new Set([...this.lookupTableAddress,...s])),c=[];for(let T of a)r[T]===void 0&&c.push(new pt(T));let l=await rn({connection:this.connection,address:c});for(let[T,A]of Object.entries(l))r[T]=A;let d=t?Kt(t):{instructions:[],instructionTypes:[]},f=await dt(this.connection,this.blockhashCommitment),u=this.signers.reduce((T,A)=>U(O({},T),{[A.publicKey.toBase58()]:A}),{}),m=[],p=[],b=[],g=0;if(this.allInstructions.forEach(T=>{let A=[...b,T],P=t?[...d.instructions,...A]:A;if(T!==n[g]&&b.length<12&&(Qe({instructions:P,payer:this.feePayer,lookupTableAddressAccount:r})||Qe({instructions:A,payer:this.feePayer,lookupTableAddressAccount:r})))b.push(T);else{if(b.length===0)throw Error("item ins too big");g+=T===n[g]?1:0;let x={};for(let h of[...new Set(a)])r[h]!==void 0&&(x[h]=r[h]);if(t&&Qe({instructions:[...d.instructions,...b],payer:this.feePayer,lookupTableAddressAccount:r,recentBlockhash:f})){let h=new Je({payerKey:this.feePayer,recentBlockhash:f,instructions:[...d.instructions,...b]}).compileToV0Message(Object.values(r));m.push(new $e(h))}else{let h=new Je({payerKey:this.feePayer,recentBlockhash:f,instructions:[...b]}).compileToV0Message(Object.values(r));m.push(new $e(h))}p.push(Array.from(new Set(b.map(h=>h.keys.filter(B=>B.isSigner).map(B=>B.pubkey.toString())).flat())).map(h=>u[h]).filter(h=>h!==void 0)),b=[T]}}),b.length>0){let A=[...new Set(b.map(P=>P.keys.filter(x=>x.isSigner).map(x=>x.pubkey.toString())).flat()).values()].map(P=>u[P]).filter(P=>P!==void 0);if(t&&Qe({instructions:[...d.instructions,...b],payer:this.feePayer,lookupTableAddressAccount:r,recentBlockhash:f})){let P=new Je({payerKey:this.feePayer,recentBlockhash:f,instructions:[...d.instructions,...b]}).compileToV0Message(Object.values(r));m.push(new $e(P))}else{let P=new Je({payerKey:this.feePayer,recentBlockhash:f,instructions:[...b]}).compileToV0Message(Object.values(r));m.push(new $e(P))}p.push(A)}return(k=this.owner)!=null&&k.signer&&p.forEach(T=>{T.some(A=>A.publicKey.equals(this.owner.publicKey))||T.push(this.owner.signer)}),m.forEach((T,A)=>{T.sign(p[A])}),{builder:this,transactions:m,buildProps:e,signers:p,instructionTypes:this.instructionTypes,execute:async T=>{var K;let{sequentially:A,onTxUpdate:P,skipTxCount:x=0,recentBlockHash:h,skipPreflight:B=!0}=T||{};if(m.map(async(L,C)=>{p[C].length&&L.sign(p[C]),h&&(L.message.recentBlockhash=h)}),st(m),(K=this.owner)!=null&&K.isKeyPair){if(A){let L=0,C=[];for(let N of m){if(++L,L<=x){console.log("skip tx: ",L),C.push("tx skipped");continue}let I=await this.connection.sendTransaction(N,{skipPreflight:B});await Lt(this.connection,I),C.push(I)}return{txIds:C,signedTxs:m}}return{txIds:await Promise.all(m.map(async L=>await this.connection.sendTransaction(L,{skipPreflight:B}))),signedTxs:m}}if(this.signAllTransactions){let L=await this.signAllTransactions(m.slice(x,m.length)),C=[...m.slice(0,x),...L];if(A){let N=0,I=[],F=async()=>{if(!C[N])return;if(N<x){I.push({txId:"",status:"success",signedTx:C[N]}),P==null||P([...I]),N++,F();return}let q=await this.connection.sendTransaction(C[N],{skipPreflight:B});I.push({txId:q,status:"sent",signedTx:C[N]}),P==null||P([...I]),N++;let ue=!1,fe=null,Le=null,ze=ee=>{fe!==null&&clearInterval(fe),Le!==null&&this.connection.removeSignatureListener(Le);let ie=I.findIndex(ve=>ve.txId===q);if(ie>-1){if(I[ie].status==="error"||I[ie].status==="success")return;I[ie].status=ee.err?"error":"success"}P==null||P([...I]),ee.err||F()};this.loopMultiTxStatus&&(fe=setInterval(async()=>{var ee;if(ue){clearInterval(fe);return}try{let ie=await this.connection.getTransaction(q,{commitment:"confirmed",maxSupportedTransactionVersion:0});ie&&(ue=!0,clearInterval(fe),ze({err:((ee=ie.meta)==null?void 0:ee.err)||null}),console.log("tx status from getTransaction:",q))}catch(ie){ue=!0,clearInterval(fe),console.error("getTransaction timeout:",ie,q)}},Dt)),Le=this.connection.onSignature(q,ee=>{if(ue){this.connection.removeSignatureListener(Le);return}ue=!0,ze(ee)},"confirmed"),this.connection.getSignatureStatus(q)};return F(),{txIds:[],signedTxs:C}}else{let N=[];for(let I=0;I<C.length;I+=1){let F=await this.connection.sendTransaction(C[I],{skipPreflight:B});N.push(F)}return{txIds:N,signedTxs:C}}}throw new Error("please provide owner in keypair format or signAllTransactions function")},extInfo:o||{}}}async buildSniperTransaction(e){var k;let w=e||{},{computeBudgetConfig:t,splitIns:n=[],lookupTableCache:i={},lookupTableAddress:s=[]}=w,o=ut(w,["computeBudgetConfig","splitIns","lookupTableCache","lookupTableAddress"]),r=O(O({},this.cluster==="devnet"?await on(this.connection):Ft),i),a=Array.from(new Set([...this.lookupTableAddress,...s])),c=[];for(let T of a)r[T]===void 0&&c.push(new pt(T));let l=await rn({connection:this.connection,address:c});for(let[T,A]of Object.entries(l))r[T]=A;let d=t?Kt(t):{instructions:[],instructionTypes:[]},f=await dt(this.connection,this.blockhashCommitment),u=this.signers.reduce((T,A)=>U(O({},T),{[A.publicKey.toBase58()]:A}),{}),m=[],p=[],b=[],g=0;if(this.allInstructions.forEach(T=>{let A=[...b,T],P=t?[...d.instructions,...A]:A;if(T!==n[g]&&b.length<12&&(Qe({instructions:P,payer:this.feePayer,lookupTableAddressAccount:r})||Qe({instructions:A,payer:this.feePayer,lookupTableAddressAccount:r})))b.push(T);else{if(b.length===0)throw Error("item ins too big");g+=T===n[g]?1:0;let x={};for(let h of[...new Set(a)])r[h]!==void 0&&(x[h]=r[h]);if(t&&Qe({instructions:[...d.instructions,...b],payer:this.feePayer,lookupTableAddressAccount:r,recentBlockhash:f})){let h=new Je({payerKey:this.feePayer,recentBlockhash:f,instructions:[...d.instructions,...b]}).compileToV0Message(Object.values(r));m.push(new $e(h))}else{let h=new Je({payerKey:this.feePayer,recentBlockhash:f,instructions:[...b]}).compileToV0Message(Object.values(r));m.push(new $e(h))}p.push(Array.from(new Set(b.map(h=>h.keys.filter(B=>B.isSigner).map(B=>B.pubkey.toString())).flat())).map(h=>u[h]).filter(h=>h!==void 0)),b=[T]}}),b.length>0){let A=[...new Set(b.map(P=>P.keys.filter(x=>x.isSigner).map(x=>x.pubkey.toString())).flat()).values()].map(P=>u[P]).filter(P=>P!==void 0);if(t&&Qe({instructions:[...d.instructions,...b],payer:this.feePayer,lookupTableAddressAccount:r,recentBlockhash:f})){let P=new Je({payerKey:this.feePayer,recentBlockhash:f,instructions:[...d.instructions,...b]}).compileToV0Message(Object.values(r));m.push(new $e(P))}else{let P=new Je({payerKey:this.feePayer,recentBlockhash:f,instructions:[...b]}).compileToV0Message(Object.values(r));m.push(new $e(P))}p.push(A)}return(k=this.owner)!=null&&k.signer&&p.forEach(T=>{T.some(A=>A.publicKey.equals(this.owner.publicKey))||T.push(this.owner.signer)}),m.forEach((T,A)=>{T.sign(p[A])}),{builder:this,transactions:m,buildProps:e,signers:p,instructionTypes:this.instructionTypes,execute:async T=>{var K;let{sequentially:A,onTxUpdate:P,skipTxCount:x=0,recentBlockHash:h,skipPreflight:B=!0}=T||{};if(m.map(async(L,C)=>{p[C].length&&L.sign(p[C]),h&&(L.message.recentBlockhash=h)}),st(m),(K=this.owner)!=null&&K.isKeyPair){if(A){let L=0,C=[];for(let N of m){if(++L,L<=x){console.log("skip tx: ",L),C.push("tx skipped");continue}let I=await this.connection.sendTransaction(N,{skipPreflight:B});await Lt(this.connection,I),C.push(I)}return{txIds:C,signedTxs:m}}return{txIds:await Promise.all(m.map(async L=>await this.connection.sendTransaction(L,{skipPreflight:B}))),signedTxs:m}}if(this.signAllTransactions){let L=await this.signAllTransactions(m.slice(x,m.length)),C=[...m.slice(0,x),...L];if(A){let N=0,I=[],F=async()=>{if(!C[N])return;if(N<x){I.push({txId:"",status:"success",signedTx:C[N]}),P==null||P([...I]),N++,F();return}let q=await this.connection.sendTransaction(C[N],{skipPreflight:B});I.push({txId:q,status:"sent",signedTx:C[N]}),P==null||P([...I]),N++;let ue=!1,fe=null,Le=null,ze=ee=>{fe!==null&&clearInterval(fe),Le!==null&&this.connection.removeSignatureListener(Le);let ie=I.findIndex(ve=>ve.txId===q);if(ie>-1){if(I[ie].status==="error"||I[ie].status==="success")return;I[ie].status=ee.err?"error":"success"}P==null||P([...I]),ee.err||F()};this.loopMultiTxStatus&&(fe=setInterval(async()=>{var ee;if(ue){clearInterval(fe);return}try{let ie=await this.connection.getTransaction(q,{commitment:"confirmed",maxSupportedTransactionVersion:0});ie&&(ue=!0,clearInterval(fe),ze({err:((ee=ie.meta)==null?void 0:ee.err)||null}),console.log("tx status from getTransaction:",q))}catch(ie){ue=!0,clearInterval(fe),console.error("getTransaction timeout:",ie,q)}},Dt)),Le=this.connection.onSignature(q,ee=>{if(ue){this.connection.removeSignatureListener(Le);return}ue=!0,ze(ee)},"confirmed"),this.connection.getSignatureStatus(q)};return F(),{txIds:[],signedTxs:C}}else{let N=[];for(let I=0;I<C.length;I+=1){let F=await this.connection.sendTransaction(C[I],{skipPreflight:B});N.push(F)}return{txIds:N,signedTxs:C}}}throw new Error("please provide owner in keypair format or signAllTransactions function")},extInfo:o||{}}}};import Cr from"bn.js";var Ic=new Cr(1e6);import{AccountLayout as Gi,createAssociatedTokenAccountIdempotentInstruction as Ui,TOKEN_2022_PROGRAM_ID as ct,TOKEN_PROGRAM_ID as Zt}from"@solana/spl-token";import{PublicKey as Zc}from"@solana/web3.js";import{MintLayout as Qc,TOKEN_PROGRAM_ID as $c}from"@solana/spl-token";var sn=i=>{var s=i,{address:y,programId:e,decimals:t}=s,n=ut(s,["address","programId","decimals"]);return O({chainId:101,address:lt(y).toBase58(),programId:e,logoURI:"",symbol:"",name:"",decimals:t,tags:[],extensions:n.extensions||{}},n)},Kn=y=>y?U(O({},y),{transferFeeConfigAuthority:y.transferFeeConfigAuthority.toBase58(),withdrawWithheldAuthority:y.withdrawWithheldAuthority.toBase58(),withheldAmount:y.withheldAmount.toString(),olderTransferFee:U(O({},y.olderTransferFee),{epoch:y.olderTransferFee.epoch.toString(),maximumFee:y.olderTransferFee.maximumFee.toString()}),newerTransferFee:U(O({},y.newerTransferFee),{epoch:y.newerTransferFee.epoch.toString(),maximumFee:y.newerTransferFee.maximumFee.toString()})}):void 0;var Ln=(...y)=>y.map(e=>{try{return typeof e=="object"?JSON.stringify(e):e}catch{return e}}).join(", "),vt=class{constructor({scope:e,moduleName:t}){this.disabled=!1;this.scope=e,this.logger=Te(t)}createTxBuilder(e){return this.scope.checkOwner(),new Vt({connection:this.scope.connection,feePayer:e||this.scope.ownerPubKey,cluster:this.scope.cluster,owner:this.scope.owner,blockhashCommitment:this.scope.blockhashCommitment,loopMultiTxStatus:this.scope.loopMultiTxStatus,api:this.scope.api,signAllTransactions:this.scope.signAllTransactions})}createSniperTxBuilder(e,t){let n=new We(e);return new Vt({connection:this.scope.connection,feePayer:t,cluster:this.scope.cluster,owner:n,blockhashCommitment:this.scope.blockhashCommitment,loopMultiTxStatus:this.scope.loopMultiTxStatus,api:this.scope.api,signAllTransactions:this.scope.signAllTransactions})}logDebug(...e){this.logger.debug(Ln(e))}logInfo(...e){this.logger.info(Ln(e))}logAndCreateError(...e){let t=Ln(e);throw new Error(t)}checkDisabled(){(this.disabled||!this.scope)&&this.logAndCreateError("module not working")}};import{Keypair as dn,PublicKey as S,SystemProgram as nt,TransactionInstruction as xe}from"@solana/web3.js";import Un from"bn.js";import{ASSOCIATED_TOKEN_PROGRAM_ID as jt,TOKEN_2022_PROGRAM_ID as be,TOKEN_PROGRAM_ID as te}from"@solana/spl-token";import{PublicKey as Dr}from"@solana/web3.js";import yi,{isBN as bi}from"bn.js";import{bits as mu,BitStructure as du,blob as Kr,Blob as pu,cstr as fu,f32 as yu,f32be as bu,f64 as gu,f64be as Pu,greedy as wu,Layout as Lr,ns64 as Au,ns64be as Tu,nu64 as ku,nu64be as hu,offset as xu,s16 as Bu,s16be as Iu,s24 as Su,s24be as Cu,s32 as Rr,s32be as Ku,s40 as Lu,s40be as Ru,s48 as Nu,s48be as Mu,s8 as Ou,seq as Nr,struct as Fu,Structure as Mr,u16 as Or,u16be as Eu,u24 as Du,u24be as Vu,u32 as vu,u32be as _u,u40 as Wu,u40be as qu,u48 as Gu,u48be as Uu,u8 as Fr,UInt as Er,union as Xu,Union as Hu,unionLayoutDiscriminator as zu,utf8 as ju}from"@solana/buffer-layout";var Rn=Lr,di=Mr;var Nn=Er;var pi=Fr,_t=Or;var se=Rr;var fi=Nr;var Re=Kr;var At=class extends Rn{constructor(t,n,i){super(t,i);this.blob=Re(t),this.signed=n}decode(t,n=0){let i=new yi(this.blob.decode(t,n),10,"le");return this.signed?i.fromTwos(this.span*8).clone():i}encode(t,n,i=0){return typeof t=="number"&&(t=new yi(t)),this.signed&&(t=t.toTwos(this.span*8)),this.blob.encode(t.toArrayLike(Buffer,"le",this.span),n,i)}};function ye(y){return new Nn(1,y)}function Tt(y){return new Nn(4,y)}function E(y){return new At(8,!1,y)}function X(y){return new At(16,!1,y)}function gi(y){return new At(8,!0,y)}function Pi(y){return new At(16,!0,y)}var an=class extends Rn{constructor(t,n,i,s){super(t.span,s);this.layout=t,this.decoder=n,this.encoder=i}decode(t,n){return this.decoder(this.layout.decode(t,n))}encode(t,n,i){return this.layout.encode(this.encoder(t),n,i)}getSpan(t,n){return this.layout.getSpan(t,n)}};function ne(y){return new an(Re(32),e=>new Dr(e),e=>e.toBuffer(),y)}function Ie(y){return new an(pi(),Vr,vr,y)}function Vr(y){if(y===0)return!1;if(y===1)return!0;throw new Error("Invalid bool: "+y)}function vr(y){return y?1:0}var Mn=class extends di{decode(e,t){return super.decode(e,t)}};function $(y,e,t){return new Mn(y,e,t)}function de(y,e,t){let n,i=typeof e=="number"?e:bi(e)?e.toNumber():new Proxy(e,{get(s,o){if(!n){let r=Reflect.get(s,"count");n=bi(r)?r.toNumber():r,Reflect.set(s,"count",n)}return Reflect.get(s,o)},set(s,o,r){return o==="count"&&(n=r),Reflect.set(s,o,r)}});return fi(y,i,t)}import Jr from"bn.js";import xt from"decimal.js";import Fe from"bn.js";var H=new Fe(0),qe=new Fe(1),et=new Fe(-1),Ne=new Fe(1).shln(64),cn=new Fe(1).shln(128),On=Ne.sub(qe),Wt=64,wi=cn.subn(1),Be=-443636,Se=-Be,Ge=new Fe("4295048016"),Ue=new Fe("79226673521066979257578248091"),cl=new Fe("4295048017"),ul=new Fe("79226673521066979257578248090"),Ai=16,Ti="59543866431248",ki="184467440737095516",hi="15793534762490258745",un=new Fe(10).pow(new Fe(6)),_r=(n=>(n[n.rate_500=500]="rate_500",n[n.rate_3000=3e3]="rate_3000",n[n.rate_10000=1e4]="rate_10000",n))(_r||{}),ll={[500]:10,[3e3]:60,[1e4]:200},ml={version:6,liquidity:H,tickCurrent:0,feeGrowthGlobalX64A:H,feeGrowthGlobalX64B:H,protocolFeesTokenA:H,protocolFeesTokenB:H,swapInAmountTokenA:H,swapOutAmountTokenB:H,swapInAmountTokenB:H,swapOutAmountTokenA:H,tickArrayBitmap:[],rewardInfos:[],day:{volume:0,volumeFee:0,feeA:0,feeB:0,feeApr:0,rewardApr:{A:0,B:0,C:0},apr:0,priceMax:0,priceMin:0},week:{volume:0,volumeFee:0,feeA:0,feeB:0,feeApr:0,rewardApr:{A:0,B:0,C:0},apr:0,priceMax:0,priceMin:0},month:{volume:0,volumeFee:0,feeA:0,feeB:0,feeApr:0,rewardApr:{A:0,B:0,C:0},apr:0,priceMax:0,priceMin:0},tvl:0},xi={tvl:0,volumeQuote:0,mintAmountA:0,mintAmountB:0,rewardDefaultInfos:[],farmUpcomingCount:0,farmOngoingCount:0,farmFinishedCount:0,day:{volume:0,volumeQuote:0,volumeFee:0,apr:0,feeApr:0,priceMin:0,priceMax:0,rewardApr:[0]},week:{volume:0,volumeQuote:0,volumeFee:0,apr:0,feeApr:0,priceMin:0,priceMax:0,rewardApr:[0]},month:{volume:0,volumeQuote:0,volumeFee:0,apr:0,feeApr:0,priceMin:0,priceMax:0,rewardApr:[0]},pooltype:[]},dl=new Fe("18446744073700000000");import G from"bn.js";import He from"decimal.js";function Bi(y){let e=new ArrayBuffer(2);return new DataView(e).setUint16(0,y,!1),new Uint8Array(e)}function fl(y){let e=new ArrayBuffer(2);return new DataView(e).setInt16(0,y,!1),new Uint8Array(e)}function yl(y){let e=new ArrayBuffer(4);return new DataView(e).setUint32(0,y,!1),new Uint8Array(e)}function ln(y){let e=new ArrayBuffer(4);return new DataView(e).setInt32(0,y,!1),new Uint8Array(e)}function Fn(y,e){let t=0;for(let n=y-1;n>=0&&!e.testn(n);n--)t++;return t}function En(y,e){let t=0;for(let n=0;n<y&&!e.testn(n);n++)t++;return t}function qt(y,e){for(let t=0;t<y;t++)if(e.testn(t))return!1;return!0}function Ii(y,e){return qt(y,e)?null:Fn(y,e)}function Si(y,e){return qt(y,e)?null:En(y,e)}var Wr=Buffer.from("amm_config","utf8"),qr=Buffer.from("pool","utf8"),Gr=Buffer.from("pool_vault","utf8"),Ur=Buffer.from("pool_reward_vault","utf8"),Ci=Buffer.from("position","utf8"),Xr=Buffer.from("tick_array","utf8"),Hr=Buffer.from("operation","utf8"),zr=Buffer.from("pool_tick_array_bitmap_extension","utf8"),jr=Buffer.from("observation","utf8");function wl(y,e){return he([Wr,Bi(e)],y)}function Ki(y,e,t,n){return he([qr,e.toBuffer(),t.toBuffer(),n.toBuffer()],y)}function Dn(y,e,t){return he([Gr,e.toBuffer(),t.toBuffer()],y)}function Li(y,e,t){return he([Ur,e.toBuffer(),t.toBuffer()],y)}function z(y,e,t){return he([Xr,e.toBuffer(),ln(t)],y)}function Ve(y,e,t,n){return he([Ci,e.toBuffer(),ln(t),ln(n)],y)}function Ce(y,e){return he([Ci,e.toBuffer()],y)}function Gt(y){return he([Buffer.from("metadata","utf8"),mt.toBuffer(),y.toBuffer()],mt)}function Ut(y){return he([Hr],y)}function ge(y,e){return he([zr,e.toBuffer()],y)}function Ri(y,e){return he([jr,e.toBuffer()],y)}var Ni=Buffer.from("locked_position","utf8");function Vn(y,e){return he([Ni,e.toBuffer()],y)}function kt(y,e){return he([Ni,e.toBuffer()],y)}var Zr=Buffer.from("support_mint","utf8");function vn(y,e){return he([Zr,e.toBuffer()],y)}import{PublicKey as Me}from"@solana/web3.js";import{TOKEN_2022_PROGRAM_ID as Mi}from"@solana/spl-token";import ae from"bn.js";import Z from"decimal.js";import Xe from"bn.js";import _n from"decimal.js";var Xt=class{static getfeeGrowthInside(e,t,n){let i=new Xe(0),s=new Xe(0);e.tickCurrent>=t.tick?(i=t.feeGrowthOutsideX64A,s=t.feeGrowthOutsideX64B):(i=e.feeGrowthGlobalX64A.sub(t.feeGrowthOutsideX64A),s=e.feeGrowthGlobalX64B.sub(t.feeGrowthOutsideX64B));let o=new Xe(0),r=new Xe(0);e.tickCurrent<n.tick?(o=n.feeGrowthOutsideX64A,r=n.feeGrowthOutsideX64B):(o=e.feeGrowthGlobalX64A.sub(n.feeGrowthOutsideX64A),r=e.feeGrowthGlobalX64B.sub(n.feeGrowthOutsideX64B));let a=v.wrappingSubU128(v.wrappingSubU128(e.feeGrowthGlobalX64A,i),o),c=v.wrappingSubU128(v.wrappingSubU128(e.feeGrowthGlobalX64B,s),r);return{feeGrowthInsideX64A:a,feeGrowthInsideBX64:c}}static GetPositionFees(e,t,n,i){let{feeGrowthInsideX64A:s,feeGrowthInsideBX64:o}=this.getfeeGrowthInside(e,n,i),r=v.mulDivFloor(v.wrappingSubU128(s,t.feeGrowthInsideLastX64A),t.liquidity,Ne),a=t.tokenFeesOwedA.add(r),c=v.mulDivFloor(v.wrappingSubU128(o,t.feeGrowthInsideLastX64B),t.liquidity,Ne),l=t.tokenFeesOwedB.add(c);return{tokenFeeAmountA:a,tokenFeeAmountB:l}}static GetPositionFeesV2(e,t,n,i){let{feeGrowthInsideX64A:s,feeGrowthInsideBX64:o}=this.getfeeGrowthInside(e,n,i),r=v.mulDivFloor(v.wrappingSubU128(s,t.feeGrowthInsideLastX64A),t.liquidity,Ne),a=t.tokenFeesOwedA.add(r),c=v.mulDivFloor(v.wrappingSubU128(o,t.feeGrowthInsideLastX64B),t.liquidity,Ne),l=t.tokenFeesOwedB.add(c);return{tokenFeeAmountA:a,tokenFeeAmountB:l}}static GetPositionRewardsV2(e,t,n,i){let s=[],o=this.getRewardGrowthInsideV2(e.tickCurrent,n,i,e.rewardInfos);for(let r=0;r<o.length;r++){let a=o[r],c=t.rewardInfos[r],l=v.wrappingSubU128(a,c.growthInsideLastX64),d=v.mulDivFloor(l,t.liquidity,Ne),f=c.rewardAmountOwed.add(d);s.push(f)}return s}static GetPositionRewards(e,t,n,i){let s=[],o=this.getRewardGrowthInside(e.tickCurrent,n,i,e.rewardInfos);for(let r=0;r<o.length;r++){let a=o[r],c=t.rewardInfos[r],l=v.wrappingSubU128(a,c.growthInsideLastX64),d=v.mulDivFloor(l,t.liquidity,Ne),f=c.rewardAmountOwed.add(d);s.push(f)}return s}static getRewardGrowthInside(e,t,n,i){let s=[];for(let o=0;o<i.length;o++){let r=new Xe(0);t.liquidityGross.eqn(0)?r=i[o].rewardGrowthGlobalX64:e<t.tick?r=i[o].rewardGrowthGlobalX64.sub(t.rewardGrowthsOutsideX64[o]):r=t.rewardGrowthsOutsideX64[o];let a=new Xe(0);n.liquidityGross.eqn(0)||(e<n.tick?a=n.rewardGrowthsOutsideX64[o]:a=i[o].rewardGrowthGlobalX64.sub(n.rewardGrowthsOutsideX64[o])),s.push(v.wrappingSubU128(v.wrappingSubU128(i[o].rewardGrowthGlobalX64,r),a))}return s}static getRewardGrowthInsideV2(e,t,n,i){let s=[];for(let o=0;o<i.length;o++){let r=new Xe(0);t.liquidityGross.eqn(0)?r=i[o].rewardGrowthGlobalX64:e<t.tick?r=i[o].rewardGrowthGlobalX64.sub(t.rewardGrowthsOutsideX64[o]):r=t.rewardGrowthsOutsideX64[o];let a=new Xe(0);n.liquidityGross.eqn(0)||(e<n.tick?a=n.rewardGrowthsOutsideX64[o]:a=i[o].rewardGrowthGlobalX64.sub(n.rewardGrowthsOutsideX64[o])),s.push(v.wrappingSubU128(v.wrappingSubU128(i[o].rewardGrowthGlobalX64,r),a))}return s}static getAmountsFromLiquidity({poolInfo:e,ownerPosition:t,liquidity:n,slippage:i,add:s,epochInfo:o}){var b,g,w,k;let r=V.priceToSqrtPriceX64(new _n(e.price),e.mintA.decimals,e.mintB.decimals),a=V.getSqrtPriceX64FromTick(t.tickLower),c=V.getSqrtPriceX64FromTick(t.tickUpper),l=s?1+i:1-i,d=j.getAmountsFromLiquidity(r,a,c,n,s),[f,u]=[me(d.amountA,(b=e.mintA.extensions)==null?void 0:b.feeConfig,o,!0),me(d.amountB,(g=e.mintB.extensions)==null?void 0:g.feeConfig,o,!0)],[m,p]=[me(new Xe(new _n(d.amountA.toString()).mul(l).toFixed(0)),(w=e.mintA.extensions)==null?void 0:w.feeConfig,o,!0),me(new Xe(new _n(d.amountB.toString()).mul(l).toFixed(0)),(k=e.mintB.extensions)==null?void 0:k.feeConfig,o,!0)];return{liquidity:n,amountA:f,amountB:u,amountSlippageA:m,amountSlippageB:p,expirationTime:at(f.expirationTime,u.expirationTime)}}};var Yr=15,Y=class{static async getTickArrays(e,t,n,i,s,o,r){let a=[],c=M.getTickArrayStartIndexByTick(i,s),l=M.getInitializedTickArrayInRange(o,r,s,c,Math.floor(Yr/2));for(let u=0;u<l.length;u++){let{publicKey:m}=z(t,n,l[u]);a.push(m)}let d=(await je(e,a)).map(u=>u!==null?Ht.decode(u.data):null),f={};for(let u=0;u<a.length;u++){let m=d[u];m!==null&&(f[m.startTickIndex]=U(O({},m),{address:a[u]}))}return f}static nextInitializedTick(e,t,n,i,s,o){let{initializedTick:r,tickArrayAddress:a,tickArrayStartTickIndex:c}=this.nextInitializedTickInOneArray(e,t,n,i,s,o);for(;r==null||r.liquidityGross.lten(0);){if(c=M.getNextTickArrayStartIndex(c,s,o),this.checkIsValidStartIndex(c,s))throw new Error("No enough initialized tickArray");let l=n[c];if(l===void 0)continue;let{nextTick:d,tickArrayAddress:f,tickArrayStartTickIndex:u}=this.firstInitializedTickInOneArray(e,t,l,o);[r,a,c]=[d,f,u]}if(r==null)throw new Error("No invaild tickArray cache");return{nextTick:r,tickArrayAddress:a,tickArrayStartTickIndex:c}}static nextInitializedTickArray(e,t,n,i,s){let o=Math.floor(e/Y.tickCount(t)),r=n?M.searchLowBitFromStart(i,s,o-1,1,t):M.searchHightBitFromStart(i,s,o+1,1,t);return r.length>0?{isExist:!0,nextStartIndex:r[0]}:{isExist:!1,nextStartIndex:0}}static firstInitializedTickInOneArray(e,t,n,i){let s;if(i){let r=Pe-1;for(;r>=0;){let a=n.ticks[r];if(a.liquidityGross.gtn(0)){s=a;break}r=r-1}}else{let r=0;for(;r<Pe;){let a=n.ticks[r];if(a.liquidityGross.gtn(0)){s=a;break}r=r+1}}let{publicKey:o}=z(e,t,n.startTickIndex);return{nextTick:s,tickArrayAddress:o,tickArrayStartTickIndex:n.startTickIndex}}static nextInitializedTickInOneArray(e,t,n,i,s,o){let r=M.getTickArrayStartIndexByTick(i,s),a=Math.floor((i-r)/s),c=n[r];if(c==null)return{initializedTick:void 0,tickArrayAddress:void 0,tickArrayStartTickIndex:r};let l;if(o)for(;a>=0;){let f=c.ticks[a];if(f.liquidityGross.gtn(0)){l=f;break}a=a-1}else for(a=a+1;a<Pe;){let f=c.ticks[a];if(f.liquidityGross.gtn(0)){l=f;break}a=a+1}let{publicKey:d}=z(e,t,r);return{initializedTick:l,tickArrayAddress:d,tickArrayStartTickIndex:c.startTickIndex}}static getArrayStartIndex(e,t){let n=this.tickCount(t);return Math.floor(e/n)*n}static checkIsValidStartIndex(e,t){if(M.checkIsOutOfBoundary(e)){if(e>Se)return!1;let n=M.getTickArrayStartIndexByTick(Be,t);return e==n}return e%this.tickCount(t)==0}static tickCount(e){return Pe*e}};var Wn=14,tt=class{static maxTickInTickarrayBitmap(e){return e*Pe*ft}static getBitmapTickBoundary(e,t){let n=this.maxTickInTickarrayBitmap(t),i=Math.floor(Math.abs(e)/n);e<0&&Math.abs(e)%n!=0&&(i+=1);let s=n*i;return e<0?{minValue:-s,maxValue:-s+n}:{minValue:s,maxValue:s+n}}static nextInitializedTickArrayStartIndex(e,t,n,i){if(!Y.checkIsValidStartIndex(t,n))throw Error("nextInitializedTickArrayStartIndex check error");let s=this.maxTickInTickarrayBitmap(n),o=i?t-Y.tickCount(n):t+Y.tickCount(n);if(o<-s||o>=s)return{isInit:!1,tickIndex:t};let r=n*Pe,a=o/r+512;o<0&&o%r!=0&&a--;let c=Math.abs(a);if(i){let l=e.shln(1024-c-1),d=Ii(1024,l);if(d!==null){let f=(c-d-512)*r;return{isInit:!0,tickIndex:f}}else return{isInit:!1,tickIndex:-s}}else{let l=e.shrn(c),d=Si(1024,l);if(d!==null){let f=(c+d-512)*r;return{isInit:!0,tickIndex:f}}else return{isInit:!1,tickIndex:s-Y.tickCount(n)}}}},zt=class{static getBitmapOffset(e,t){if(!Y.checkIsValidStartIndex(e,t))throw new Error("No enough initialized tickArray");this.checkExtensionBoundary(e,t);let n=tt.maxTickInTickarrayBitmap(t),i=Math.floor(Math.abs(e)/n)-1;return e<0&&Math.abs(e)%n===0&&i--,i}static getBitmap(e,t,n){let i=this.getBitmapOffset(e,t);return e<0?{offset:i,tickarrayBitmap:n.negativeTickArrayBitmap[i]}:{offset:i,tickarrayBitmap:n.positiveTickArrayBitmap[i]}}static checkExtensionBoundary(e,t){let{positiveTickBoundary:n,negativeTickBoundary:i}=this.extensionTickBoundary(t);if(e>=i&&e<n)throw Error("checkExtensionBoundary -> InvalidTickArrayBoundary")}static extensionTickBoundary(e){let t=tt.maxTickInTickarrayBitmap(e),n=-t;if(Se<=t)throw Error(`extensionTickBoundary check error: ${Se}, ${t}`);if(n<=Be)throw Error(`extensionTickBoundary check error: ${n}, ${Be}`);return{positiveTickBoundary:t,negativeTickBoundary:n}}static checkTickArrayIsInit(e,t,n){let{tickarrayBitmap:i}=this.getBitmap(e,t,n),s=this.tickArrayOffsetInBitmap(e,t);return{isInitialized:M.mergeTickArrayBitmap(i).testn(s),startIndex:e}}static nextInitializedTickArrayFromOneBitmap(e,t,n,i){let s=Y.tickCount(t),o=n?e-s:e+s,{tickarrayBitmap:r}=this.getBitmap(o,t,i);return this.nextInitializedTickArrayInBitmap(r,o,t,n)}static nextInitializedTickArrayInBitmap(e,t,n,i){let{minValue:s,maxValue:o}=tt.getBitmapTickBoundary(t,n),r=this.tickArrayOffsetInBitmap(t,n);if(i){let a=M.mergeTickArrayBitmap(e).shln(ft-1-r),c=qt(512,a)?null:Fn(512,a);if(c!==null){let l=t-c*Y.tickCount(n);return{isInit:!0,tickIndex:l}}else return{isInit:!1,tickIndex:s}}else{let a=M.mergeTickArrayBitmap(e).shrn(r),c=qt(512,a)?null:En(512,a);if(c!==null){let l=t+c*Y.tickCount(n);return{isInit:!0,tickIndex:l}}else return{isInit:!1,tickIndex:o-Y.tickCount(n)}}}static tickArrayOffsetInBitmap(e,t){let n=Math.abs(e)%tt.maxTickInTickarrayBitmap(t),i=Math.floor(n/Y.tickCount(t));return e<0&&n!=0&&(i=ft-i),i}};var pe=class{static getOutputAmountAndRemainAccounts(e,t,n,i,s,o=!1){let r=n.toBase58()===e.mintA.address,a=[],{isExist:c,startIndex:l,nextAccountMeta:d}=this.getFirstInitializedTickArray(e,r);if(!c||l===void 0||!d)throw new Error("Invalid tick array");a.push(d);let{allTrade:f,amountCalculated:u,accounts:m,sqrtPriceX64:p,feeAmount:b}=yt.swapCompute(e.programId,e.id,t,e.tickArrayBitmap,e.exBitmapInfo,r,e.ammConfig.tradeFeeRate,e.liquidity,e.tickCurrent,e.tickSpacing,e.sqrtPriceX64,i,l,s,o);return a.push(...m),{allTrade:f,expectedAmountOut:u.mul(et),remainingAccounts:a,executionPrice:p,feeAmount:b}}static getInputAmountAndRemainAccounts(e,t,n,i,s){let o=n.toBase58()===e.mintB.address,r=[],{isExist:a,startIndex:c,nextAccountMeta:l}=this.getFirstInitializedTickArray(e,o);if(!a||c===void 0||!l)throw new Error("Invalid tick array");try{let p=this.preInitializedTickArrayStartIndex(e,o);if(p.isExist){let{publicKey:b}=z(e.programId,e.id,p.nextStartIndex);r.push(b)}}catch{}r.push(l);let{amountCalculated:d,accounts:f,sqrtPriceX64:u,feeAmount:m}=yt.swapCompute(e.programId,e.id,t,e.tickArrayBitmap,e.exBitmapInfo,o,e.ammConfig.tradeFeeRate,e.liquidity,e.tickCurrent,e.tickSpacing,e.sqrtPriceX64,i.mul(et),c,s);return r.push(...f),{expectedAmountIn:d,remainingAccounts:r,executionPrice:u,feeAmount:m}}static getFirstInitializedTickArray(e,t){let{isInitialized:n,startIndex:i}=pe.isOverflowDefaultTickarrayBitmap(e.tickSpacing,[e.tickCurrent])?zt.checkTickArrayIsInit(Y.getArrayStartIndex(e.tickCurrent,e.tickSpacing),e.tickSpacing,e.exBitmapInfo):M.checkTickArrayIsInitialized(M.mergeTickArrayBitmap(e.tickArrayBitmap),e.tickCurrent,e.tickSpacing);if(n){let{publicKey:r}=z(e.programId,e.id,i);return{isExist:!0,startIndex:i,nextAccountMeta:r}}let{isExist:s,nextStartIndex:o}=this.nextInitializedTickArrayStartIndex(e,Y.getArrayStartIndex(e.tickCurrent,e.tickSpacing),t);if(s){let{publicKey:r}=z(e.programId,e.id,o);return{isExist:!0,startIndex:o,nextAccountMeta:r}}return{isExist:!1,nextAccountMeta:void 0,startIndex:void 0}}static preInitializedTickArrayStartIndex(e,t){let n=Math.floor(e.tickCurrent/Y.tickCount(e.tickSpacing)),i=t?M.searchHightBitFromStart(e.tickArrayBitmap,e.exBitmapInfo,n+1,1,e.tickSpacing):M.searchLowBitFromStart(e.tickArrayBitmap,e.exBitmapInfo,n-1,1,e.tickSpacing);return i.length>0?{isExist:!0,nextStartIndex:i[0]}:{isExist:!1,nextStartIndex:0}}static nextInitializedTickArrayStartIndex(e,t,n){for(t=Y.getArrayStartIndex(e.tickCurrent,e.tickSpacing);;){let{isInit:i,tickIndex:s}=tt.nextInitializedTickArrayStartIndex(M.mergeTickArrayBitmap(e.tickArrayBitmap),t,e.tickSpacing,n);if(i)return{isExist:!0,nextStartIndex:s};t=s;let{isInit:o,tickIndex:r}=zt.nextInitializedTickArrayFromOneBitmap(t,e.tickSpacing,n,e.exBitmapInfo);if(o)return{isExist:!0,nextStartIndex:r};if(t=r,t<Be||t>Se)return{isExist:!1,nextStartIndex:0}}}static async updatePoolRewardInfos({connection:e,apiPoolInfo:t,chainTime:n,poolLiquidity:i,rewardInfos:s}){var r,a,c;let o=[];for(let l=0;l<s.length;l++){let d=s[l],f=(c=(r=t.rewardDefaultInfos[l])==null?void 0:r.mint.programId)!=null?c:(a=await e.getAccountInfo(d.tokenMint))==null?void 0:a.owner;if(f===void 0)throw Error("get new reward mint info error");let u=U(O({},d),{perSecond:v.x64ToDecimal(d.emissionsPerSecondX64),remainingRewards:void 0,tokenProgramId:new Me(f)});if(u.tokenMint.equals(Me.default))continue;if(n<=u.openTime.toNumber()||i.eq(H)){o.push(u);continue}let m=new ae(Math.min(u.endTime.toNumber(),n)),p=m.sub(u.lastUpdateTime),b=v.mulDivFloor(p,u.emissionsPerSecondX64,i),g=u.rewardGrowthGlobalX64.add(b),w=v.mulDivFloor(p,u.emissionsPerSecondX64,Ne),k=u.rewardTotalEmissioned.add(w);o.push(U(O({},u),{rewardGrowthGlobalX64:g,rewardTotalEmissioned:k,lastUpdateTime:m}))}return o}static isOverflowDefaultTickarrayBitmap(e,t){let{maxTickBoundary:n,minTickBoundary:i}=this.tickRange(e);for(let s of t){let o=M.getTickArrayStartIndexByTick(s,e);if(o>=n||o<i)return!0}return!1}static tickRange(e){let t=tt.maxTickInTickarrayBitmap(e),n=-t;return t>Se&&(t=Y.getArrayStartIndex(Se,e)+Y.tickCount(e)),n<Be&&(n=Y.getArrayStartIndex(Be,e)),{maxTickBoundary:t,minTickBoundary:n}}static get_tick_array_offset(e,t){if(!Y.checkIsValidStartIndex(e,t))throw new Error("No enough initialized tickArray");return e/Y.tickCount(t)*ft}static async fetchExBitmaps({connection:e,exBitmapAddress:t,batchRequest:n}){let i=await Ze(e,t.map(o=>({pubkey:o})),{batchRequest:n}),s={};for(let o of i)o.accountInfo!==null&&(s[o.pubkey.toString()]=Fi.decode(o.accountInfo.data));return s}static async fetchMultiplePoolTickArrays({connection:e,poolKeys:t,batchRequest:n}){let i={},s=[];for(let a of t){let c=M.getTickArrayStartIndexByTick(a.tickCurrent,a.tickSpacing),l=M.getInitializedTickArrayInRange(a.tickArrayBitmap,a.exBitmapInfo,a.tickSpacing,c,7);for(let d of l){let{publicKey:f}=z(a.programId,a.id,d);s.push({pubkey:f}),i[f.toString()]=a.id}}let o=await Ze(e,s,{batchRequest:n}),r={};for(let a of o){if(!a.accountInfo)continue;let c=i[a.pubkey.toString()];if(!c)continue;r[c.toString()]===void 0&&(r[c.toString()]={});let l=Ht.decode(a.accountInfo.data);r[c.toString()][l.startTickIndex]=U(O({},l),{address:a.pubkey})}return r}static async fetchPoolsAccountPosition({pools:e,connection:t,ownerInfo:n,batchRequest:i=!1,updateOwnerRewardAndFee:s=!0}){var r;let o=[];for(let a=0;a<e.length;a++){let c=e[a];c!==null&&(o.find(l=>l.equals(c.state.programId))||o.push(c.state.programId))}if(n){let a=n.tokenAccounts.map(f=>f.accountInfo.mint),c=[];for(let f of a)for(let u of o)c.push(Ce(u,f).publicKey);let l=await je(t,c,{batchRequest:i}),d={};for(let f of l){if(f===null)continue;let u=ht.decode(f.data),m=u.poolId.toString(),p=e.find(h=>h.state.id.toBase58()===m);if(p===void 0)continue;let b=p.state,g=M._getTickPriceLegacy({poolInfo:b,tick:u.tickLower,baseIn:!0}),w=M._getTickPriceLegacy({poolInfo:b,tick:u.tickUpper,baseIn:!0}),{amountA:k,amountB:T}=j.getAmountsFromLiquidity(b.sqrtPriceX64,g.tickSqrtPriceX64,w.tickSqrtPriceX64,u.liquidity,!1),A=1/(1-Math.sqrt(Math.sqrt(g.price.div(w.price).toNumber())));p.positionAccount=[...(r=p.positionAccount)!=null?r:[],{poolId:u.poolId,nftMint:u.nftMint,priceLower:g.price,priceUpper:w.price,amountA:k,amountB:T,tickLower:u.tickLower,tickUpper:u.tickUpper,liquidity:u.liquidity,feeGrowthInsideLastX64A:u.feeGrowthInsideLastX64A,feeGrowthInsideLastX64B:u.feeGrowthInsideLastX64B,tokenFeesOwedA:u.tokenFeesOwedA,tokenFeesOwedB:u.tokenFeesOwedB,rewardInfos:u.rewardInfos.map(h=>U(O({},h),{pendingReward:new ae(0)})),leverage:A,tokenFeeAmountA:new ae(0),tokenFeeAmountB:new ae(0)}];let P=await M.getTickArrayAddressByTick(p.state.programId,u.poolId,u.tickLower,p.state.tickSpacing),x=await M.getTickArrayAddressByTick(p.state.programId,u.poolId,u.tickUpper,p.state.tickSpacing);d[`${p.state.programId.toString()}-${u.poolId.toString()}-${u.tickLower}`]=P,d[`${p.state.programId.toString()}-${u.poolId.toString()}-${u.tickUpper}`]=x}if(s){let f=Object.values(d),u=await je(t,f,{batchRequest:i}),m={};for(let p=0;p<f.length;p++){let b=u[p];if(b===null)continue;let g=f[p].toString();m[g]=Ht.decode(b.data)}for(let{state:p,positionAccount:b}of e)if(!!b)for(let g of b){let w=`${p.programId.toString()}-${p.id.toString()}-${g.tickLower}`,k=`${p.programId.toString()}-${p.id.toString()}-${g.tickUpper}`,T=m[d[w].toString()],A=m[d[k].toString()],P=T.ticks[M.getTickOffsetInArray(g.tickLower,p.tickSpacing)],x=A.ticks[M.getTickOffsetInArray(g.tickUpper,p.tickSpacing)],{tokenFeeAmountA:h,tokenFeeAmountB:B}=await Xt.GetPositionFees(p,g,P,x),K=await Xt.GetPositionRewards(p,g,P,x);g.tokenFeeAmountA=h.gte(new ae(0))?h:new ae(0),g.tokenFeeAmountB=B.gte(new ae(0))?B:new ae(0);for(let L=0;L<K.length;L++)g.rewardInfos[L].pendingReward=K[L].gte(new ae(0))?K[L]:new ae(0)}}}return e}static computeAmountOut({poolInfo:e,tickArrayCache:t,baseMint:n,epochInfo:i,amountIn:s,slippage:o,priceLimit:r=new Z(0),catchLiquidityInsufficient:a=!1}){var C;let c,l=n.toBase58()===e.mintA.address,[d,f]=l?[e.mintA.extensions.feeConfig,e.mintB.extensions.feeConfig]:[e.mintB.extensions.feeConfig,e.mintA.extensions.feeConfig];r.equals(new Z(0))?c=l?Ge.add(new ae(1)):Ue.sub(new ae(1)):c=V.priceToSqrtPriceX64(r,e.mintA.decimals,e.mintB.decimals);let u=me(s,d,i,!1),{allTrade:m,expectedAmountOut:p,remainingAccounts:b,executionPrice:g,feeAmount:w}=pe.getOutputAmountAndRemainAccounts(e,t,n,u.amount.sub((C=u.fee)!=null?C:H),c,a),k=me(p,f,i,!1),T=V.sqrtPriceX64ToPrice(g,e.mintA.decimals,e.mintB.decimals),A=l?T:new Z(1).div(T),P=p.mul(new ae(Math.floor((1-o)*1e10))).div(new ae(1e10)),x=me(P,f,i,!1),h=l?e.currentPrice:new Z(1).div(e.currentPrice),B=new Z(A).sub(h).abs(),K=h,L=new ot(new Z(B).mul(10**15).toFixed(0),new Z(K).mul(10**15).toFixed(0));return{allTrade:m,realAmountIn:u,amountOut:k,minAmountOut:x,expirationTime:at(u.expirationTime,k.expirationTime),currentPrice:e.currentPrice,executionPrice:A,priceImpact:L,fee:w,remainingAccounts:b,executionPriceX64:g}}static computeAmountOutFormat({poolInfo:e,tickArrayCache:t,amountIn:n,tokenOut:i,slippage:s,epochInfo:o,catchLiquidityInsufficient:r=!1}){let a=i.address===e.mintB.address,[c,l]=a?[e.mintA,e.mintB]:[e.mintB,e.mintA],[d,f]=[new _e(U(O({},c),{mint:c.address,isToken2022:c.programId===Mi.toBase58()})),new _e(U(O({},l),{mint:l.address,isToken2022:l.programId===Mi.toBase58()}))],{allTrade:u,realAmountIn:m,amountOut:p,minAmountOut:b,expirationTime:g,currentPrice:w,executionPrice:k,priceImpact:T,fee:A,remainingAccounts:P,executionPriceX64:x}=pe.computeAmountOut({poolInfo:e,tickArrayCache:t,baseMint:new Me(c.address),amountIn:n,slippage:s,epochInfo:o,catchLiquidityInsufficient:r}),h=U(O({},m),{amount:new ke(d,m.amount),fee:m.fee===void 0?void 0:new ke(d,m.fee)}),B=U(O({},p),{amount:new ke(f,p.amount),fee:p.fee===void 0?void 0:new ke(f,p.fee)}),K=U(O({},b),{amount:new ke(f,b.amount),fee:b.fee===void 0?void 0:new ke(f,b.fee)}),L=new Ee({baseToken:d,denominator:new ae(10).pow(new ae(20+d.decimals)),quoteToken:f,numerator:w.mul(new Z(10**(20+f.decimals))).toFixed(0)}),C=new Ee({baseToken:d,denominator:new ae(10).pow(new ae(20+d.decimals)),quoteToken:f,numerator:k.mul(new Z(10**(20+f.decimals))).toFixed(0)}),N=new ke(d,A);return{allTrade:u,realAmountIn:h,amountOut:B,minAmountOut:K,expirationTime:g,currentPrice:L,executionPrice:C,priceImpact:T,fee:N,remainingAccounts:P,executionPriceX64:x}}static computeAmountIn({poolInfo:e,tickArrayCache:t,baseMint:n,epochInfo:i,amountOut:s,slippage:o,priceLimit:r=new Z(0)}){var K;let a=n.toBase58()===e.mintA.address,c={[e.mintA.address]:e.mintA.extensions.feeConfig,[e.mintB.address]:e.mintB.extensions.feeConfig},l;r.equals(new Z(0))?l=a?Ue.sub(new ae(1)):Ge.add(new ae(1)):l=V.priceToSqrtPriceX64(r,e.mintA.decimals,e.mintB.decimals);let d=me(s,c[n.toString()],i,!0),{expectedAmountIn:f,remainingAccounts:u,executionPrice:m,feeAmount:p}=pe.getInputAmountAndRemainAccounts(e,t,n,d.amount.sub((K=d.fee)!=null?K:H),l),b=a?e.mintB.address:e.mintA.address,g=me(f,c[b],i,!1),w=V.sqrtPriceX64ToPrice(m,e.mintA.decimals,e.mintB.decimals),k=a?w:new Z(1).div(w),T=f.mul(new ae(Math.floor((1+o)*1e10))).div(new ae(1e10)),A=me(T,c[b],i,!0),P=a?e.currentPrice:new Z(1).div(e.currentPrice),x=new Z(k).sub(P).abs(),h=P,B=new ot(new Z(x).mul(10**15).toFixed(0),new Z(h).mul(10**15).toFixed(0));return{amountIn:g,maxAmountIn:A,realAmountOut:d,expirationTime:at(g.expirationTime,d.expirationTime),currentPrice:e.currentPrice,executionPrice:k,priceImpact:B,fee:p,remainingAccounts:u}}static estimateAprsForPriceRangeMultiplier({poolInfo:e,aprType:t,positionTickLowerIndex:n,positionTickUpperIndex:i}){var m,p,b;let s=e[t],o=M.getTickPrice({poolInfo:e,tick:n,baseIn:!0}).price.toNumber(),r=M.getTickPrice({poolInfo:e,tick:i,baseIn:!0}).price.toNumber(),a=Math.max(o,s.priceMin),l=Math.min(r,s.priceMax)-a,d=r-o,f=s.priceMax-s.priceMin,u;return l<=0?u=0:d===l?u=f/l:f===l?u=l/d:u=l/f*(l/d),{feeApr:s.feeApr*u,rewardsApr:[((m=s.rewardApr[0])!=null?m:0)*u,((p=s.rewardApr[1])!=null?p:0)*u,((b=s.rewardApr[2])!=null?b:0)*u],apr:s.apr*u}}static estimateAprsForPriceRangeDelta({poolInfo:e,poolLiquidity:t,aprType:n,mintPrice:i,liquidity:s,positionTickLowerIndex:o,positionTickUpperIndex:r,chainTime:a}){let c=n==="day"?1:n==="week"?7:n==="month"?30:0,l=e[n],d=i[lt(e.mintA.address).toString()],f=i[lt(e.mintB.address).toString()],u=e.mintA.decimals,m=e.mintB.decimals;if(!l||!d||!f)return{feeApr:0,rewardsApr:[0,0,0],apr:0};let p=V.priceToSqrtPriceX64(new Z(e.price),e.mintA.decimals,e.mintB.decimals),b=V.getSqrtPriceX64FromTick(o),g=V.getSqrtPriceX64FromTick(r),{amountSlippageA:w,amountSlippageB:k}=j.getAmountsFromLiquidityWithSlippage(p,b,g,t,!1,!1,0),{amountSlippageA:T,amountSlippageB:A}=j.getAmountsFromLiquidityWithSlippage(p,b,g,s,!1,!1,0),P=new Z(w.toString()).div(new Z(10).pow(u)).mul(d.value).add(new Z(k.toString()).div(new Z(10).pow(m)).mul(f.value)),x=new Z(T.toString()).div(new Z(10).pow(u)).mul(d.value).add(new Z(A.toString()).div(new Z(10).pow(m)).mul(f.value)),h=new Z(1).div(P.add(x)),K=new Z(l.volumeFee).mul(365).div(c).mul(h).mul(100).toNumber(),L=3600*24*365,C=e.rewardDefaultInfos.map(N=>{var q,ue;let I=N.mint.decimals,F=i[N.mint.address];return a<((q=N.startTime)!=null?q:0)||a>((ue=N.endTime)!=null?ue:0)||!N.perSecond||!F||I===void 0?0:new Z(F.value).mul(new Z(N.perSecond).mul(L)).div(new Z(10).pow(I)).mul(h).mul(100).toNumber()});return{feeApr:K,rewardsApr:C,apr:K+C.reduce((N,I)=>N+I,0)}}static async getLiquidityAmountOutFromAmountIn({poolInfo:e,inputA:t,tickLower:n,tickUpper:i,amount:s,slippage:o,add:r,epochInfo:a,amountHasFee:c}){var g,w;let l=V.priceToSqrtPriceX64(new Z(e.price),e.mintA.decimals,e.mintB.decimals),d=V.getSqrtPriceX64FromTick(n),f=V.getSqrtPriceX64FromTick(i),u=me(s,(g=e[t?"mintA":"mintB"].extensions)==null?void 0:g.feeConfig,a,!c),m=new ae(new Z(u.amount.sub((w=u.fee)!=null?w:H).toString()).toFixed(0)),p;if(l.lte(d))p=t?j.getLiquidityFromTokenAmountA(d,f,m,!r):new ae(0);else if(l.lte(f)){let k=j.getLiquidityFromTokenAmountA(l,f,m,!r),T=j.getLiquidityFromTokenAmountB(d,l,m);p=t?k:T}else p=t?new ae(0):j.getLiquidityFromTokenAmountB(d,f,m);let b=await pe.getAmountsFromLiquidity({epochInfo:a,poolInfo:e,tickLower:n,tickUpper:i,liquidity:p,slippage:o,add:r});return{liquidity:p,amountA:t?u:b.amountA,amountB:t?b.amountB:u,amountSlippageA:t?u:b.amountSlippageA,amountSlippageB:t?b.amountSlippageB:u,expirationTime:b.expirationTime}}static async getAmountsFromLiquidity({epochInfo:e,poolInfo:t,tickLower:n,tickUpper:i,liquidity:s,slippage:o,add:r}){var b,g,w,k;let a=V.getSqrtPriceX64FromTick(n),c=V.getSqrtPriceX64FromTick(i),l=r?1+o:1-o,d=j.getAmountsFromLiquidity(V.priceToSqrtPriceX64(new Z(t.price),t.mintA.decimals,t.mintB.decimals),a,c,s,r),[f,u]=[me(d.amountA,(b=t.mintA.extensions)==null?void 0:b.feeConfig,e,!0),me(d.amountB,(g=t.mintB.extensions)==null?void 0:g.feeConfig,e,!0)],[m,p]=[me(d.amountA.muln(l),(w=t.mintA.extensions)==null?void 0:w.feeConfig,e,!0),me(d.amountB.muln(l),(k=t.mintB.extensions)==null?void 0:k.feeConfig,e,!0)];return{liquidity:s,amountA:f,amountB:u,amountSlippageA:m,amountSlippageB:p,expirationTime:at(f.expirationTime,u.expirationTime)}}static async fetchComputeMultipleClmmInfo({connection:e,poolList:t,rpcDataMap:n={}}){let i=t.filter(a=>!n[a.id]).map(a=>new Me(a.id));(await je(e,i)).forEach((a,c)=>{!a||(n[i[c].toBase58()]=mn.decode(a.data))});let o=t.map(a=>ge(new Me(a.programId),new Me(a.id)).publicKey),r=await pe.fetchExBitmaps({connection:e,exBitmapAddress:o,batchRequest:!1});return t.reduce((a,c)=>U(O({},a),{[c.id]:U(O({},n[c.id]),{id:new Me(c.id),version:6,programId:new Me(c.programId),mintA:c.mintA,mintB:c.mintB,ammConfig:U(O({},c.config),{id:new Me(c.config.id),fundOwner:""}),currentPrice:new Z(c.price),exBitmapAccount:ge(new Me(c.programId),new Me(c.id)).publicKey,exBitmapInfo:r[ge(new Me(c.programId),new Me(c.id)).publicKey.toBase58()],startTime:n[c.id].startTime.toNumber(),rewardInfos:n[c.id].rewardInfos})}),{})}static async fetchComputeClmmInfo({connection:e,poolInfo:t,rpcData:n}){return(await this.fetchComputeMultipleClmmInfo({connection:e,rpcDataMap:n?{[t.id]:n}:void 0,poolList:[t]}))[t.id]}};function rm({poolInfo:y,tickLower:e,tickUpper:t,amountA:n,amountB:i,slippage:s,add:o,epochInfo:r,amountHasFee:a}){var k,T,A,P;let[c,l,d,f]=e<t?[e,t,n,i]:[t,e,i,n],u=V.priceToSqrtPriceX64(new Z(y.price),y.mintA.decimals,y.mintB.decimals),m=V.getSqrtPriceX64FromTick(c),p=V.getSqrtPriceX64FromTick(l),[b,g]=[me(d,(k=y.mintA.extensions)==null?void 0:k.feeConfig,r,!a),me(f,(T=y.mintB.extensions)==null?void 0:T.feeConfig,r,!a)],w=j.getLiquidityFromTokenAmounts(u,m,p,b.amount.sub((A=b.fee)!=null?A:H),g.amount.sub((P=g.fee)!=null?P:H));return j.getAmountsOutFromLiquidity({poolInfo:y,tickLower:e,tickUpper:t,liquidity:w,slippage:s,add:o,epochInfo:r,amountAddFee:!a})}var qn={volume:0,volumeQuote:0,volumeFee:0,apr:0,feeApr:0,priceMin:0,priceMax:0,rewardApr:[]};function Oi(y){return U(O({},y),{type:"Concentrated",programId:y.programId.toString(),id:y.id.toString(),rewardDefaultInfos:[],rewardDefaultPoolInfos:"Clmm",price:y.currentPrice.toNumber(),mintAmountA:0,mintAmountB:0,feeRate:y.ammConfig.tradeFeeRate,openTime:y.startTime.toString(),tvl:0,day:qn,week:qn,month:qn,pooltype:[],farmUpcomingCount:0,farmOngoingCount:0,farmFinishedCount:0,burnPercent:0,config:U(O({},y.ammConfig),{id:y.ammConfig.id.toString(),defaultRange:0,defaultRangePoint:[]})})}var v=class{static mulDivRoundingUp(e,t,n){let i=e.mul(t),s=i.div(n);return i.mod(n).eq(H)||(s=s.add(qe)),s}static mulDivFloor(e,t,n){if(n.eq(H))throw new Error("division by 0");return e.mul(t).div(n)}static mulDivCeil(e,t,n){if(n.eq(H))throw new Error("division by 0");return e.mul(t).add(n.sub(qe)).div(n)}static x64ToDecimal(e,t){return new He(e.toString()).div(He.pow(2,64)).toDecimalPlaces(t)}static decimalToX64(e){return new G(e.mul(He.pow(2,64)).floor().toFixed())}static wrappingSubU128(e,t){return e.add(cn).sub(t).mod(cn)}};function Ae(y,e){return Gn(y.mul(e),64,256)}function Qr(y,e,t){let n=y.toTwos(t).shln(e);return n.imaskn(t+1),n.fromTwos(t)}function Gn(y,e,t){let n=y.toTwos(t).shrn(e);return n.imaskn(t-e+1),n.fromTwos(t-e)}var V=class{static sqrtPriceX64ToPrice(e,t,n){return v.x64ToDecimal(e).pow(2).mul(He.pow(10,t-n))}static priceToSqrtPriceX64(e,t,n){return v.decimalToX64(e.mul(He.pow(10,n-t)).sqrt())}static getNextSqrtPriceX64FromInput(e,t,n,i){if(!e.gt(H))throw new Error("sqrtPriceX64 must greater than 0");if(!t.gt(H))throw new Error("liquidity must greater than 0");return i?this.getNextSqrtPriceFromTokenAmountARoundingUp(e,t,n,!0):this.getNextSqrtPriceFromTokenAmountBRoundingDown(e,t,n,!0)}static getNextSqrtPriceX64FromOutput(e,t,n,i){if(!e.gt(H))throw new Error("sqrtPriceX64 must greater than 0");if(!t.gt(H))throw new Error("liquidity must greater than 0");return i?this.getNextSqrtPriceFromTokenAmountBRoundingDown(e,t,n,!1):this.getNextSqrtPriceFromTokenAmountARoundingUp(e,t,n,!1)}static getNextSqrtPriceFromTokenAmountARoundingUp(e,t,n,i){if(n.eq(H))return e;let s=t.shln(Wt);if(i){let o=s,r=s.add(n.mul(e));return r.gte(o)?v.mulDivCeil(o,e,r):v.mulDivRoundingUp(o,qe,o.div(e).add(n))}else{let o=n.mul(e);if(!s.gt(o))throw new Error("getNextSqrtPriceFromTokenAmountARoundingUp,liquidityLeftShift must gt amountMulSqrtPrice");let r=s.sub(o);return v.mulDivCeil(s,e,r)}}static getNextSqrtPriceFromTokenAmountBRoundingDown(e,t,n,i){let s=n.shln(Wt);if(i)return e.add(s.div(t));{let o=v.mulDivRoundingUp(s,qe,t);if(!e.gt(o))throw new Error("getNextSqrtPriceFromTokenAmountBRoundingDown sqrtPriceX64 must gt amountDivLiquidity");return e.sub(o)}}static getSqrtPriceX64FromTick(e){if(!Number.isInteger(e))throw new Error("tick must be integer");if(e<Be||e>Se)throw new Error("tick must be in MIN_TICK and MAX_TICK");let t=e<0?e*-1:e,n=(t&1)!=0?new G("18445821805675395072"):new G("18446744073709551616");return(t&2)!=0&&(n=Ae(n,new G("18444899583751176192"))),(t&4)!=0&&(n=Ae(n,new G("18443055278223355904"))),(t&8)!=0&&(n=Ae(n,new G("18439367220385607680"))),(t&16)!=0&&(n=Ae(n,new G("18431993317065453568"))),(t&32)!=0&&(n=Ae(n,new G("18417254355718170624"))),(t&64)!=0&&(n=Ae(n,new G("18387811781193609216"))),(t&128)!=0&&(n=Ae(n,new G("18329067761203558400"))),(t&256)!=0&&(n=Ae(n,new G("18212142134806163456"))),(t&512)!=0&&(n=Ae(n,new G("17980523815641700352"))),(t&1024)!=0&&(n=Ae(n,new G("17526086738831433728"))),(t&2048)!=0&&(n=Ae(n,new G("16651378430235570176"))),(t&4096)!=0&&(n=Ae(n,new G("15030750278694412288"))),(t&8192)!=0&&(n=Ae(n,new G("12247334978884435968"))),(t&16384)!=0&&(n=Ae(n,new G("8131365268886854656"))),(t&32768)!=0&&(n=Ae(n,new G("3584323654725218816"))),(t&65536)!=0&&(n=Ae(n,new G("696457651848324352"))),(t&131072)!=0&&(n=Ae(n,new G("26294789957507116"))),(t&262144)!=0&&(n=Ae(n,new G("37481735321082"))),e>0&&(n=wi.div(n)),n}static getTickFromPrice(e,t,n){return V.getTickFromSqrtPriceX64(V.priceToSqrtPriceX64(e,t,n))}static getTickFromSqrtPriceX64(e){if(e.gt(Ue)||e.lt(Ge))throw new Error("Provided sqrtPrice is not within the supported sqrtPrice range.");let t=e.bitLength()-1,n=new G(t-64),i=Qr(n,32,128),s=new G("8000000000000000","hex"),o=0,r=new G(0),a=t>=64?e.shrn(t-63):e.shln(63-t);for(;s.gt(new G(0))&&o<Ai;){a=a.mul(a);let m=a.shrn(127);a=a.shrn(63+m.toNumber()),r=r.add(s.mul(m)),s=s.shrn(1),o+=1}let c=r.shrn(32),d=i.add(c).mul(new G(Ti)),f=Gn(d.sub(new G(ki)),64,128).toNumber(),u=Gn(d.add(new G(hi)),64,128).toNumber();return f==u?f:V.getSqrtPriceX64FromTick(u).lte(e)?u:f}},bt=class{static getTickWithPriceAndTickspacing(e,t,n,i){let o=V.getTickFromSqrtPriceX64(V.priceToSqrtPriceX64(e,n,i))/t;return o<0?o=Math.floor(o):o=Math.ceil(o),o*t}static roundPriceWithTickspacing(e,t,n,i){let s=bt.getTickWithPriceAndTickspacing(e,t,n,i),o=V.getSqrtPriceX64FromTick(s);return V.sqrtPriceX64ToPrice(o,n,i)}},j=class{static addDelta(e,t){return e.add(t)}static getTokenAmountAFromLiquidity(e,t,n,i){if(e.gt(t)&&([e,t]=[t,e]),!e.gt(H))throw new Error("sqrtPriceX64A must greater than 0");let s=n.ushln(Wt),o=t.sub(e);return i?v.mulDivRoundingUp(v.mulDivCeil(s,o,t),qe,e):v.mulDivFloor(s,o,t).div(e)}static getTokenAmountBFromLiquidity(e,t,n,i){if(e.gt(t)&&([e,t]=[t,e]),!e.gt(H))throw new Error("sqrtPriceX64A must greater than 0");return i?v.mulDivCeil(n,t.sub(e),Ne):v.mulDivFloor(n,t.sub(e),Ne)}static getLiquidityFromTokenAmountA(e,t,n,i){e.gt(t)&&([e,t]=[t,e]);let s=n.mul(e).mul(t),o=t.sub(e),r=s.div(o);return i?v.mulDivRoundingUp(r,qe,On):r.shrn(Wt)}static getLiquidityFromTokenAmountB(e,t,n){return e.gt(t)&&([e,t]=[t,e]),v.mulDivFloor(n,On,t.sub(e))}static getLiquidityFromTokenAmounts(e,t,n,i,s){if(t.gt(n)&&([t,n]=[n,t]),e.lte(t))return j.getLiquidityFromTokenAmountA(t,n,i,!1);if(e.lt(n)){let o=j.getLiquidityFromTokenAmountA(e,n,i,!1),r=j.getLiquidityFromTokenAmountB(t,e,s);return o.lt(r)?o:r}else return j.getLiquidityFromTokenAmountB(t,n,s)}static getAmountsFromLiquidity(e,t,n,i,s){if(t.gt(n)&&([t,n]=[n,t]),e.lte(t))return{amountA:j.getTokenAmountAFromLiquidity(t,n,i,s),amountB:new G(0)};if(e.lt(n)){let o=j.getTokenAmountAFromLiquidity(e,n,i,s),r=j.getTokenAmountBFromLiquidity(t,e,i,s);return{amountA:o,amountB:r}}else return{amountA:new G(0),amountB:j.getTokenAmountBFromLiquidity(t,n,i,s)}}static getAmountsFromLiquidityWithSlippage(e,t,n,i,s,o,r){let{amountA:a,amountB:c}=j.getAmountsFromLiquidity(e,t,n,i,o),l=s?1+r:1-r,d=new G(new He(a.toString()).mul(l).toFixed(0)),f=new G(new He(c.toString()).mul(l).toFixed(0));return{amountSlippageA:d,amountSlippageB:f}}static getAmountsOutFromLiquidity({poolInfo:e,tickLower:t,tickUpper:n,liquidity:i,slippage:s,add:o,epochInfo:r,amountAddFee:a}){var w,k,T,A;let c=V.priceToSqrtPriceX64(new He(e.price),e.mintA.decimals,e.mintB.decimals),l=V.getSqrtPriceX64FromTick(t),d=V.getSqrtPriceX64FromTick(n),f=o?1+s:1-s,u=j.getAmountsFromLiquidity(c,l,d,i,o),[m,p]=[me(u.amountA,(w=e.mintA.extensions)==null?void 0:w.feeConfig,r,a),me(u.amountB,(k=e.mintB.extensions)==null?void 0:k.feeConfig,r,a)],[b,g]=[me(new G(new He(u.amountA.toString()).mul(f).toFixed(0)),(T=e.mintA.extensions)==null?void 0:T.feeConfig,r,a),me(new G(new He(u.amountB.toString()).mul(f).toFixed(0)),(A=e.mintB.extensions)==null?void 0:A.feeConfig,r,a)];return{liquidity:i,amountA:m,amountB:p,amountSlippageA:b,amountSlippageB:g,expirationTime:at(m.expirationTime,p.expirationTime)}}},yt=class{static swapCompute(e,t,n,i,s,o,r,a,c,l,d,f,u,m,p=!1){if(f.eq(H))throw new Error("amountSpecified must not be 0");if(m||(m=o?Ge.add(qe):Ue.sub(qe)),o){if(m.lt(Ge))throw new Error("sqrtPriceX64 must greater than MIN_SQRT_PRICE_X64");if(m.gte(d))throw new Error("sqrtPriceX64 must smaller than current")}else{if(m.gt(Ue))throw new Error("sqrtPriceX64 must smaller than MAX_SQRT_PRICE_X64");if(m.lte(d))throw new Error("sqrtPriceX64 must greater than current")}let b=f.gt(H),g={amountSpecifiedRemaining:f,amountCalculated:H,sqrtPriceX64:d,tick:c>u?Math.min(u+Y.tickCount(l)-1,c):u,accounts:[],liquidity:a,feeAmount:new G(0)},w=u,k=n[u],T=0,A=!o&&k.startTickIndex===g.tick;for(;!g.amountSpecifiedRemaining.eq(H)&&!g.sqrtPriceX64.eq(m);){T>10;let P={};P.sqrtPriceStartX64=g.sqrtPriceX64;let x=M.nextInitTick(k,g.tick,l,o,A),h=x||null,B=null;if(!(h!=null&&h.liquidityGross.gtn(0))){let L=pe.nextInitializedTickArrayStartIndex({tickCurrent:g.tick,tickSpacing:l,tickArrayBitmap:i,exBitmapInfo:s},w,o);if(!L.isExist){if(p)return{allTrade:!1,amountSpecifiedRemaining:g.amountSpecifiedRemaining,amountCalculated:g.amountCalculated,feeAmount:g.feeAmount,sqrtPriceX64:g.sqrtPriceX64,liquidity:g.liquidity,tickCurrent:g.tick,accounts:g.accounts};throw Error("swapCompute LiquidityInsufficient")}w=L.nextStartIndex;let{publicKey:C}=z(e,t,w);B=C,k=n[w];try{h=M.firstInitializedTick(k,o)}catch{throw Error("not found next tick info")}}P.tickNext=h.tick,P.initialized=h.liquidityGross.gtn(0),u!==w&&B&&(g.accounts.push(B),u=w),P.tickNext<Be?P.tickNext=Be:P.tickNext>Se&&(P.tickNext=Se),P.sqrtPriceNextX64=V.getSqrtPriceX64FromTick(P.tickNext);let K;if(o&&P.sqrtPriceNextX64.lt(m)||!o&&P.sqrtPriceNextX64.gt(m)?K=m:K=P.sqrtPriceNextX64,[g.sqrtPriceX64,P.amountIn,P.amountOut,P.feeAmount]=yt.swapStepCompute(g.sqrtPriceX64,K,g.liquidity,g.amountSpecifiedRemaining,r,o),g.feeAmount=g.feeAmount.add(P.feeAmount),b?(g.amountSpecifiedRemaining=g.amountSpecifiedRemaining.sub(P.amountIn.add(P.feeAmount)),g.amountCalculated=g.amountCalculated.sub(P.amountOut)):(g.amountSpecifiedRemaining=g.amountSpecifiedRemaining.add(P.amountOut),g.amountCalculated=g.amountCalculated.add(P.amountIn.add(P.feeAmount))),g.sqrtPriceX64.eq(P.sqrtPriceNextX64)){if(P.initialized){let L=h.liquidityNet;o&&(L=L.mul(et)),g.liquidity=j.addDelta(g.liquidity,L)}A=P.tickNext!=g.tick&&!o&&k.startTickIndex===P.tickNext,g.tick=o?P.tickNext-1:P.tickNext}else if(g.sqrtPriceX64!=P.sqrtPriceStartX64){let L=V.getTickFromSqrtPriceX64(g.sqrtPriceX64);A=L!=g.tick&&!o&&k.startTickIndex===L,g.tick=L}++T}try{let{nextStartIndex:P,isExist:x}=Y.nextInitializedTickArray(g.tick,l,o,i,s);x&&u!==P&&(g.accounts.push(z(e,t,P).publicKey),u=P)}catch{}return{allTrade:!0,amountSpecifiedRemaining:H,amountCalculated:g.amountCalculated,feeAmount:g.feeAmount,sqrtPriceX64:g.sqrtPriceX64,liquidity:g.liquidity,tickCurrent:g.tick,accounts:g.accounts}}static swapStepCompute(e,t,n,i,s,o){let r={sqrtPriceX64Next:new G(0),amountIn:new G(0),amountOut:new G(0),feeAmount:new G(0)},a=i.gte(H);if(a){let l=v.mulDivFloor(i,un.sub(new G(s.toString())),un);r.amountIn=o?j.getTokenAmountAFromLiquidity(t,e,n,!0):j.getTokenAmountBFromLiquidity(e,t,n,!0),l.gte(r.amountIn)?r.sqrtPriceX64Next=t:r.sqrtPriceX64Next=V.getNextSqrtPriceX64FromInput(e,n,l,o)}else r.amountOut=o?j.getTokenAmountBFromLiquidity(t,e,n,!1):j.getTokenAmountAFromLiquidity(e,t,n,!1),i.mul(et).gte(r.amountOut)?r.sqrtPriceX64Next=t:r.sqrtPriceX64Next=V.getNextSqrtPriceX64FromOutput(e,n,i.mul(et),o);let c=t.eq(r.sqrtPriceX64Next);return o?(c&&a||(r.amountIn=j.getTokenAmountAFromLiquidity(r.sqrtPriceX64Next,e,n,!0)),c&&!a||(r.amountOut=j.getTokenAmountBFromLiquidity(r.sqrtPriceX64Next,e,n,!1))):(r.amountIn=c&&a?r.amountIn:j.getTokenAmountBFromLiquidity(e,r.sqrtPriceX64Next,n,!0),r.amountOut=c&&!a?r.amountOut:j.getTokenAmountAFromLiquidity(e,r.sqrtPriceX64Next,n,!1)),!a&&r.amountOut.gt(i.mul(et))&&(r.amountOut=i.mul(et)),a&&!r.sqrtPriceX64Next.eq(t)?r.feeAmount=i.sub(r.amountIn):r.feeAmount=v.mulDivCeil(r.amountIn,new G(s),un.sub(new G(s))),[r.sqrtPriceX64Next,r.amountIn,r.amountOut,r.feeAmount]}};var Pe=60,ft=512,M=class{static getTickArrayAddressByTick(e,t,n,i){let s=M.getTickArrayStartIndexByTick(n,i),{publicKey:o}=z(e,t,s);return o}static getTickOffsetInArray(e,t){if(e%t!=0)throw new Error("tickIndex % tickSpacing not equal 0");let n=M.getTickArrayStartIndexByTick(e,t),i=Math.floor((e-n)/t);if(i<0||i>=Pe)throw new Error("tick offset in array overflow");return i}static getTickArrayBitIndex(e,t){let n=Y.tickCount(t),i=e/n;return e<0&&e%n!=0?i=Math.ceil(i)-1:i=Math.floor(i),i}static getTickArrayStartIndexByTick(e,t){return this.getTickArrayBitIndex(e,t)*Y.tickCount(t)}static getTickArrayOffsetInBitmapByTick(e,t){let n=t*Pe,i=Math.floor(e/n)+512;return Math.abs(i)}static checkTickArrayIsInitialized(e,t,n){let i=n*Pe,s=Math.floor(t/i)+512,o=Math.abs(s);return{isInitialized:e.testn(o),startIndex:(o-512)*i}}static getNextTickArrayStartIndex(e,t,n){return n?e-t*Pe:e+t*Pe}static mergeTickArrayBitmap(e){let t=new Jr(0);for(let n=0;n<e.length;n++)t=t.add(e[n].shln(64*n));return t}static getInitializedTickArrayInRange(e,t,n,i,s){let o=Math.floor(i/(n*Pe));return[...M.searchLowBitFromStart(e,t,o-1,s,n),...M.searchHightBitFromStart(e,t,o,s,n)]}static getAllInitializedTickArrayStartIndex(e,t,n){return M.searchHightBitFromStart(e,t,-7680,ft,n)}static getAllInitializedTickArrayInfo(e,t,n,i,s){let o=[],r=M.getAllInitializedTickArrayStartIndex(n,i,s);for(let a of r){let{publicKey:c}=z(e,t,a);o.push({tickArrayStartIndex:a,tickArrayAddress:c})}return o}static getAllInitializedTickInTickArray(e){return e.ticks.filter(t=>t.liquidityGross.gtn(0))}static searchLowBitFromStart(e,t,n,i,s){let o=[...[...t.negativeTickArrayBitmap].reverse(),e.slice(0,8),e.slice(8,16),...t.positiveTickArrayBitmap].map(c=>M.mergeTickArrayBitmap(c)),r=[];for(;n>=-7680;){let c=Math.floor((n+7680)/512),l=(n+7680)%512;if(o[c].testn(l)&&r.push(n),n--,r.length===i)break}let a=Y.tickCount(s);return r.map(c=>c*a)}static searchHightBitFromStart(e,t,n,i,s){let o=[...[...t.negativeTickArrayBitmap].reverse(),e.slice(0,8),e.slice(8,16),...t.positiveTickArrayBitmap].map(c=>M.mergeTickArrayBitmap(c)),r=[];for(;n<7680;){let c=Math.floor((n+7680)/512),l=(n+7680)%512;if(o[c].testn(l)&&r.push(n),n++,r.length===i)break}let a=Y.tickCount(s);return r.map(c=>c*a)}static checkIsOutOfBoundary(e){return e<Be||e>Se}static nextInitTick(e,t,n,i,s){if(Y.getArrayStartIndex(t,n)!=e.startTickIndex)return null;let r=Math.floor((t-e.startTickIndex)/n);if(i)for(;r>=0;){if(e.ticks[r].liquidityGross.gtn(0))return e.ticks[r];r=r-1}else for(s||(r=r+1);r<Pe;){if(e.ticks[r].liquidityGross.gtn(0))return e.ticks[r];r=r+1}return null}static firstInitializedTick(e,t){if(t){let n=Pe-1;for(;n>=0;){if(e.ticks[n].liquidityGross.gtn(0))return e.ticks[n];n=n-1}}else{let n=0;for(;n<Pe;){if(e.ticks[n].liquidityGross.gtn(0))return e.ticks[n];n=n+1}}throw Error(`firstInitializedTick check error: ${e} - ${t}`)}static _getTickPriceLegacy({poolInfo:e,tick:t,baseIn:n}){let i=V.getSqrtPriceX64FromTick(t),s=V.sqrtPriceX64ToPrice(i,e.mintA.decimals,e.mintB.decimals);return n?{tick:t,price:s,tickSqrtPriceX64:i}:{tick:t,price:new xt(1).div(s),tickSqrtPriceX64:i}}static _getPriceAndTickLegacy({poolInfo:e,price:t,baseIn:n}){let i=n?t:new xt(1).div(t),s=bt.getTickWithPriceAndTickspacing(i,e.ammConfig.tickSpacing,e.mintA.decimals,e.mintB.decimals),o=V.getSqrtPriceX64FromTick(s),r=V.sqrtPriceX64ToPrice(o,e.mintA.decimals,e.mintB.decimals);return n?{tick:s,price:r}:{tick:s,price:new xt(1).div(r)}}static getTickPrice({poolInfo:e,tick:t,baseIn:n}){let i=V.getSqrtPriceX64FromTick(t),s=V.sqrtPriceX64ToPrice(i,e.mintA.decimals,e.mintB.decimals);return n?{tick:t,price:s,tickSqrtPriceX64:i}:{tick:t,price:new xt(1).div(s),tickSqrtPriceX64:i}}static getPriceAndTick({poolInfo:e,price:t,baseIn:n}){let i=n?t:new xt(1).div(t),s=bt.getTickWithPriceAndTickspacing(i,e.config.tickSpacing,e.mintA.decimals,e.mintB.decimals),o=V.getSqrtPriceX64FromTick(s),r=V.sqrtPriceX64ToPrice(o,e.mintA.decimals,e.mintB.decimals);return n?{tick:s,price:r}:{tick:s,price:new xt(1).div(r)}}};var Ei=$([Re(8),ye("bump"),_t("index"),ne(""),Tt("protocolFeeRate"),Tt("tradeFeeRate"),_t("tickSpacing"),de(E(),8,"")]),$r=$([Tt("blockTimestamp"),gi("tickCumulative"),de(E(),4)]),Di=$([Re(8),Ie("initialized"),E("recentEpoch"),_t("observationIndex"),ne("poolId"),de($r,100,"observations"),de(E(),4)]),eo=$([ye("rewardState"),E("openTime"),E("endTime"),E("lastUpdateTime"),X("emissionsPerSecondX64"),E("rewardTotalEmissioned"),E("rewardClaimed"),ne("tokenMint"),ne("tokenVault"),ne("creator"),X("rewardGrowthGlobalX64")]),mn=$([Re(8),ye("bump"),ne("ammConfig"),ne("creator"),ne("mintA"),ne("mintB"),ne("vaultA"),ne("vaultB"),ne("observationId"),ye("mintDecimalsA"),ye("mintDecimalsB"),_t("tickSpacing"),X("liquidity"),X("sqrtPriceX64"),se("tickCurrent"),Tt(),X("feeGrowthGlobalX64A"),X("feeGrowthGlobalX64B"),E("protocolFeesTokenA"),E("protocolFeesTokenB"),X("swapInAmountTokenA"),X("swapOutAmountTokenB"),X("swapInAmountTokenB"),X("swapOutAmountTokenA"),ye("status"),de(ye(),7,""),de(eo,3,"rewardInfos"),de(E(),16,"tickArrayBitmap"),E("totalFeesTokenA"),E("totalFeesClaimedTokenA"),E("totalFeesTokenB"),E("totalFeesClaimedTokenB"),E("fundFeesTokenA"),E("fundFeesTokenB"),E("startTime"),de(E(),15*4-3,"padding")]),to=$([X("growthInsideLastX64"),E("rewardAmountOwed")]),ht=$([Re(8),ye("bump"),ne("nftMint"),ne("poolId"),se("tickLower"),se("tickUpper"),X("liquidity"),X("feeGrowthInsideLastX64A"),X("feeGrowthInsideLastX64B"),E("tokenFeesOwedA"),E("tokenFeesOwedB"),de(to,3,"rewardInfos"),de(E(),8,"")]),Cm=$([Re(8),ye("bump"),ne("poolId"),se("tickLowerIndex"),se("tickUpperIndex"),X("liquidity"),X("feeGrowthInsideLastX64A"),X("feeGrowthInsideLastX64B"),E("tokenFeesOwedA"),E("tokenFeesOwedB"),de(X(),3,"rewardGrowthInside"),de(E(),8,"")]),no=$([se("tick"),Pi("liquidityNet"),X("liquidityGross"),X("feeGrowthOutsideX64A"),X("feeGrowthOutsideX64B"),de(X(),3,"rewardGrowthsOutsideX64"),de(Tt(),13,"")]),Ht=$([Re(8),ne("poolId"),se("startTickIndex"),de(no,Pe,"ticks"),ye("initializedTickCount"),de(ye(),115,"")]),Vi=$([Re(329),de(ne(),100,"whitelistMints")]),Fi=$([Re(8),ne("poolId"),de(de(E(),8),Wn,"positiveTickArrayBitmap"),de(de(E(),8),Wn,"negativeTickArrayBitmap")]),Km=$([E(),ye("bump"),ne("owner"),ne("poolId"),ne("positionId"),ne("nftAccount"),de(E(),8)]),vi=$([Re(8),ye("bump"),ne("lockOwner"),ne("poolId"),ne("positionId"),ne("nftAccount"),ne("lockNftMint"),E("recentEpoch"),de(E(),8)]);Di.span;var _i=Te("Raydium_Clmm"),Oe={createPool:[233,146,209,142,207,104,64,188],initReward:[95,135,192,196,242,129,230,68],setRewardEmissions:[112,52,167,75,32,201,211,137],openPosition:[77,184,74,214,112,86,241,199],openPositionWithTokenEx:[77,255,174,82,125,29,201,46],closePosition:[123,134,81,0,49,68,98,98],increaseLiquidity:[133,29,89,223,69,238,176,10],decreaseLiquidity:[58,127,188,62,79,82,196,96],swap:[43,4,237,11,26,201,30,98],collectReward:[18,237,166,197,34,16,213,144]},Wi=[188,37,179,131,82,150,84,73],qi=[16,72,250,198,14,162,212,19],ce=class{static createPoolInstruction(e,t,n,i,s,o,r,a,c,l,d,f,u,m){let p=$([X("sqrtPriceX64"),E("zero")]),b=[{pubkey:n,isSigner:!0,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:c,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:f,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!1},{pubkey:d,isSigner:!1,isWritable:!1},{pubkey:nt.programId,isSigner:!1,isWritable:!1},{pubkey:rt,isSigner:!1,isWritable:!1},...(m==null?void 0:m.map(k=>({pubkey:k,isSigner:!1,isWritable:!1})))||[]],g=Buffer.alloc(p.span);p.encode({sqrtPriceX64:u,zero:H},g);let w=Buffer.from([...Oe.createPool,...g]);return new xe({keys:b,programId:e,data:w})}static async createPoolInstructions(e){let{programId:t,owner:n,mintA:i,mintB:s,ammConfigId:o,initialPriceX64:r,extendMintAccount:a}=e,[c,l]=[new S(i.address),new S(s.address)],{publicKey:d}=Ki(t,o,c,l),{publicKey:f}=Ri(t,d),{publicKey:u}=Dn(t,d,c),{publicKey:m}=Dn(t,d,l),p=ge(t,d).publicKey,b=[this.createPoolInstruction(t,d,n,o,f,c,u,new S(i.programId||te),l,m,new S(s.programId||te),p,r,a)];return{signers:[],instructions:b,instructionTypes:[re.CreateAccount,re.ClmmCreatePool],address:{poolId:d,observationId:f,exBitmapAccount:p,mintAVault:u,mintBVault:m},lookupTableAddress:[]}}static openPositionFromLiquidityInstruction(e,t,n,i,s,o,r,a,c,l,d,f,u,m,p,b,g,w,k,T,A,P,x,h,B,K){let L=$([se("tickLowerIndex"),se("tickUpperIndex"),se("tickArrayLowerStartIndex"),se("tickArrayUpperStartIndex"),X("liquidity"),E("amountMaxA"),E("amountMaxB"),Ie("withMetadata"),ye("optionBaseFlag"),Ie("baseFlag")]),C=[...K?[{pubkey:K,isSigner:!1,isWritable:!0}]:[]],N=[{pubkey:t,isSigner:!0,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!1},{pubkey:s,isSigner:!0,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:d,isSigner:!1,isWritable:!0},{pubkey:f,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:m,isSigner:!1,isWritable:!0},{pubkey:p,isSigner:!1,isWritable:!0},{pubkey:rt,isSigner:!1,isWritable:!1},{pubkey:nt.programId,isSigner:!1,isWritable:!1},{pubkey:te,isSigner:!1,isWritable:!1},{pubkey:jt,isSigner:!1,isWritable:!1},{pubkey:mt,isSigner:!1,isWritable:!1},{pubkey:be,isSigner:!1,isWritable:!1},{pubkey:b,isSigner:!1,isWritable:!1},{pubkey:g,isSigner:!1,isWritable:!1},...C],I=Buffer.alloc(L.span);L.encode({tickLowerIndex:w,tickUpperIndex:k,tickArrayLowerStartIndex:T,tickArrayUpperStartIndex:A,liquidity:P,amountMaxA:x,amountMaxB:h,withMetadata:B==="create",baseFlag:!1,optionBaseFlag:0},I);let F=Buffer.from([...Oe.openPosition,...I]);return new xe({keys:N,programId:e,data:F})}static openPositionFromLiquidityInstruction22(e,t,n,i,s,o,r,a,c,l,d,f,u,m,p,b,g,w,k,T,A,P,x,h,B){let K=$([se("tickLowerIndex"),se("tickUpperIndex"),se("tickArrayLowerStartIndex"),se("tickArrayUpperStartIndex"),X("liquidity"),E("amountMaxA"),E("amountMaxB"),Ie("withMetadata"),ye("optionBaseFlag"),Ie("baseFlag")]),L=[...B?[{pubkey:B,isSigner:!1,isWritable:!0}]:[]],C=[{pubkey:t,isSigner:!0,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!1},{pubkey:s,isSigner:!0,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:d,isSigner:!1,isWritable:!0},{pubkey:f,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:m,isSigner:!1,isWritable:!0},{pubkey:rt,isSigner:!1,isWritable:!1},{pubkey:nt.programId,isSigner:!1,isWritable:!1},{pubkey:te,isSigner:!1,isWritable:!1},{pubkey:jt,isSigner:!1,isWritable:!1},{pubkey:be,isSigner:!1,isWritable:!1},{pubkey:p,isSigner:!1,isWritable:!1},{pubkey:b,isSigner:!1,isWritable:!1},...L],N=Buffer.alloc(K.span);K.encode({tickLowerIndex:g,tickUpperIndex:w,tickArrayLowerStartIndex:k,tickArrayUpperStartIndex:T,liquidity:A,amountMaxA:P,amountMaxB:x,withMetadata:h==="create",baseFlag:!1,optionBaseFlag:0},N);let I=Buffer.from([...Oe.openPositionWithTokenEx,...N]);return new xe({keys:C,programId:e,data:I})}static async openPositionInstructions({poolInfo:e,poolKeys:t,ownerInfo:n,tickLower:i,tickUpper:s,liquidity:o,amountMaxA:r,amountMaxB:a,withMetadata:c,getEphemeralSigners:l,nft2022:d}){let f=[],[u,m]=[new S(e.programId),new S(e.id)],p;if(l)p=new S((await l(1))[0]);else{let B=dn.generate();f.push(B),p=B.publicKey}let b=M.getTickArrayStartIndexByTick(i,e.config.tickSpacing),g=M.getTickArrayStartIndexByTick(s,e.config.tickSpacing),{publicKey:w}=z(u,m,b),{publicKey:k}=z(u,m,g),{publicKey:T}=d?oe(n.wallet,p,be):oe(n.wallet,p,te),{publicKey:A}=Gt(p),{publicKey:P}=Ce(u,p),{publicKey:x}=Ve(u,m,i,s),h=d?this.openPositionFromLiquidityInstruction22(u,n.feePayer,m,n.wallet,p,T,x,w,k,P,n.tokenAccountA,n.tokenAccountB,new S(t.vault.A),new S(t.vault.B),new S(e.mintA.address),new S(e.mintB.address),i,s,b,g,o,r,a,c,pe.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing,[b,g])?ge(u,m).publicKey:void 0):this.openPositionFromLiquidityInstruction(u,n.feePayer,m,n.wallet,p,T,A,x,w,k,P,n.tokenAccountA,n.tokenAccountB,new S(t.vault.A),new S(t.vault.B),new S(e.mintA.address),new S(e.mintB.address),i,s,b,g,o,r,a,c,pe.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing,[b,g])?ge(u,m).publicKey:void 0);return{signers:f,instructions:[h],instructionTypes:[re.ClmmOpenPosition],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[],address:{nftMint:p,tickArrayLower:w,tickArrayUpper:k,positionNftAccount:T,metadataAccount:A,personalPosition:P,protocolPosition:x}}}static async openPositionFromBaseInstructions({poolInfo:e,poolKeys:t,ownerInfo:n,tickLower:i,tickUpper:s,base:o,baseAmount:r,otherAmountMax:a,withMetadata:c,getEphemeralSigners:l,nft2022:d}){let f=[],[u,m]=[new S(e.programId),new S(e.id)],p;if(l)p=new S((await l(1))[0]);else{let B=dn.generate();f.push(B),p=B.publicKey}let b=M.getTickArrayStartIndexByTick(i,e.config.tickSpacing),g=M.getTickArrayStartIndexByTick(s,e.config.tickSpacing),{publicKey:w}=z(u,m,b),{publicKey:k}=z(u,m,g),{publicKey:T}=d?oe(n.wallet,p,be):oe(n.wallet,p,te),{publicKey:A}=Gt(p),{publicKey:P}=Ce(u,p),{publicKey:x}=Ve(u,m,i,s),h=d?this.openPositionFromBaseInstruction22(u,n.feePayer,m,n.wallet,p,T,x,w,k,P,n.tokenAccountA,n.tokenAccountB,new S(t.vault.A),new S(t.vault.B),new S(e.mintA.address),new S(e.mintB.address),i,s,b,g,c,o,r,a,pe.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing,[b,g])?ge(u,m).publicKey:void 0):this.openPositionFromBaseInstruction(u,n.feePayer,m,n.wallet,p,T,A,x,w,k,P,n.tokenAccountA,n.tokenAccountB,new S(t.vault.A),new S(t.vault.B),new S(e.mintA.address),new S(e.mintB.address),i,s,b,g,c,o,r,a,pe.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing,[b,g])?ge(u,m).publicKey:void 0);return{address:{nftMint:p,tickArrayLower:w,tickArrayUpper:k,positionNftAccount:T,metadataAccount:A,personalPosition:P,protocolPosition:x},instructions:[h],signers:f,instructionTypes:[re.ClmmOpenPosition],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[]}}static openPositionFromBaseInstruction(e,t,n,i,s,o,r,a,c,l,d,f,u,m,p,b,g,w,k,T,A,P,x,h,B,K){let L=$([se("tickLowerIndex"),se("tickUpperIndex"),se("tickArrayLowerStartIndex"),se("tickArrayUpperStartIndex"),X("liquidity"),E("amountMaxA"),E("amountMaxB"),Ie("withMetadata"),ye("optionBaseFlag"),Ie("baseFlag")]),C=[...K?[{pubkey:K,isSigner:!1,isWritable:!0}]:[]],N=[{pubkey:t,isSigner:!0,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!1},{pubkey:s,isSigner:!0,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:d,isSigner:!1,isWritable:!0},{pubkey:f,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:m,isSigner:!1,isWritable:!0},{pubkey:p,isSigner:!1,isWritable:!0},{pubkey:rt,isSigner:!1,isWritable:!1},{pubkey:nt.programId,isSigner:!1,isWritable:!1},{pubkey:te,isSigner:!1,isWritable:!1},{pubkey:jt,isSigner:!1,isWritable:!1},{pubkey:mt,isSigner:!1,isWritable:!1},{pubkey:be,isSigner:!1,isWritable:!1},{pubkey:b,isSigner:!1,isWritable:!1},{pubkey:g,isSigner:!1,isWritable:!1},...C],I=Buffer.alloc(L.span);L.encode({tickLowerIndex:w,tickUpperIndex:k,tickArrayLowerStartIndex:T,tickArrayUpperStartIndex:A,liquidity:new Un(0),amountMaxA:x==="MintA"?h:B,amountMaxB:x==="MintA"?B:h,withMetadata:P==="create",baseFlag:x==="MintA",optionBaseFlag:1},I);let F=Buffer.from([...Oe.openPosition,...I]);return new xe({keys:N,programId:e,data:F})}static openPositionFromBaseInstruction22(e,t,n,i,s,o,r,a,c,l,d,f,u,m,p,b,g,w,k,T,A,P,x,h,B){let K=$([se("tickLowerIndex"),se("tickUpperIndex"),se("tickArrayLowerStartIndex"),se("tickArrayUpperStartIndex"),X("liquidity"),E("amountMaxA"),E("amountMaxB"),Ie("withMetadata"),ye("optionBaseFlag"),Ie("baseFlag")]),L=[...B?[{pubkey:B,isSigner:!1,isWritable:!0}]:[]],C=[{pubkey:t,isSigner:!0,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!1},{pubkey:s,isSigner:!0,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:d,isSigner:!1,isWritable:!0},{pubkey:f,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:m,isSigner:!1,isWritable:!0},{pubkey:rt,isSigner:!1,isWritable:!1},{pubkey:nt.programId,isSigner:!1,isWritable:!1},{pubkey:te,isSigner:!1,isWritable:!1},{pubkey:jt,isSigner:!1,isWritable:!1},{pubkey:be,isSigner:!1,isWritable:!1},{pubkey:p,isSigner:!1,isWritable:!1},{pubkey:b,isSigner:!1,isWritable:!1},...L],N=Buffer.alloc(K.span);K.encode({tickLowerIndex:g,tickUpperIndex:w,tickArrayLowerStartIndex:k,tickArrayUpperStartIndex:T,liquidity:new Un(0),amountMaxA:P==="MintA"?x:h,amountMaxB:P==="MintA"?h:x,withMetadata:A==="create",baseFlag:P==="MintA",optionBaseFlag:1},N);let I=Buffer.from([...Oe.openPositionWithTokenEx,...N]);return new xe({keys:C,programId:e,data:I})}static async openPositionFromLiquidityInstructions({poolInfo:e,poolKeys:t,ownerInfo:n,tickLower:i,tickUpper:s,liquidity:o,amountMaxA:r,amountMaxB:a,withMetadata:c,getEphemeralSigners:l,nft2022:d}){let f,u=[];if(l)f=new S((await l(1))[0]);else{let B=dn.generate();u.push(B),f=B.publicKey}let[m,p]=[new S(e.programId),new S(e.id)],b=M.getTickArrayStartIndexByTick(i,e.config.tickSpacing),g=M.getTickArrayStartIndexByTick(s,e.config.tickSpacing),{publicKey:w}=z(m,p,b),{publicKey:k}=z(m,p,g),{publicKey:T}=d?oe(n.wallet,f,be):oe(n.wallet,f,te),{publicKey:A}=Gt(f),{publicKey:P}=Ce(m,f),{publicKey:x}=Ve(m,p,i,s),h=d?this.openPositionFromLiquidityInstruction22(m,n.wallet,p,n.wallet,f,T,x,w,k,P,n.tokenAccountA,n.tokenAccountB,new S(t.vault.A),new S(t.vault.B),new S(t.mintA.address),new S(t.mintB.address),i,s,b,g,o,r,a,c,pe.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing,[b,g])?ge(m,p).publicKey:void 0):this.openPositionFromLiquidityInstruction(m,n.wallet,p,n.wallet,f,T,A,x,w,k,P,n.tokenAccountA,n.tokenAccountB,new S(t.vault.A),new S(t.vault.B),new S(t.mintA.address),new S(t.mintB.address),i,s,b,g,o,r,a,c,pe.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing,[b,g])?ge(m,p).publicKey:void 0);return{address:{nftMint:f,tickArrayLower:w,tickArrayUpper:k,positionNftAccount:T,metadataAccount:A,personalPosition:P,protocolPosition:x},instructions:[h],signers:u,instructionTypes:[re.ClmmOpenPosition],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[]}}static closePositionInstruction(e,t,n,i,s,o){let r=$([]),a=[{pubkey:t,isSigner:!0,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:nt.programId,isSigner:!1,isWritable:!1},{pubkey:o?be:te,isSigner:!1,isWritable:!1}],c=Buffer.alloc(r.span);r.encode({},c);let l=Buffer.from([...Oe.closePosition,...c]);return new xe({keys:a,programId:e,data:l})}static closePositionInstructions({poolInfo:e,poolKeys:t,ownerInfo:n,ownerPosition:i,nft2022:s}){let o=new S(e.programId),r=s?oe(n.wallet,i.nftMint,be).publicKey:oe(n.wallet,i.nftMint,te).publicKey,{publicKey:a}=Ce(o,i.nftMint),c=[];return c.push(this.closePositionInstruction(o,n.wallet,i.nftMint,r,a,s)),{address:{positionNftAccount:r,personalPosition:a},signers:[],instructions:c,instructionTypes:[re.ClmmClosePosition],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[]}}static increasePositionFromLiquidityInstruction(e,t,n,i,s,o,r,a,c,l,d,f,u,m,p,b,g,w){let k=$([X("liquidity"),E("amountMaxA"),E("amountMaxB"),ye("optionBaseFlag"),Ie("baseFlag")]),T=[...w?[{pubkey:w,isSigner:!1,isWritable:!0}]:[]],A=[{pubkey:t,isSigner:!0,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:d,isSigner:!1,isWritable:!0},{pubkey:f,isSigner:!1,isWritable:!0},{pubkey:te,isSigner:!1,isWritable:!1},{pubkey:be,isSigner:!1,isWritable:!1},{pubkey:u,isSigner:!1,isWritable:!1},{pubkey:m,isSigner:!1,isWritable:!1},...T],P=Buffer.alloc(k.span);k.encode({liquidity:p,amountMaxA:b,amountMaxB:g,optionBaseFlag:0,baseFlag:!1},P);let x=Buffer.from([...Oe.increaseLiquidity,...P]);return new xe({keys:A,programId:e,data:x})}static increasePositionFromLiquidityInstructions({poolInfo:e,poolKeys:t,ownerPosition:n,ownerInfo:i,liquidity:s,amountMaxA:o,amountMaxB:r,nft2022:a}){let[c,l]=[new S(e.programId),new S(e.id)],d=M.getTickArrayStartIndexByTick(n.tickLower,e.config.tickSpacing),f=M.getTickArrayStartIndexByTick(n.tickUpper,e.config.tickSpacing),{publicKey:u}=z(c,l,d),{publicKey:m}=z(c,l,f),{publicKey:p}=a?oe(i.wallet,n.nftMint,be):oe(i.wallet,n.nftMint,te),{publicKey:b}=Ce(c,n.nftMint),{publicKey:g}=Ve(c,l,n.tickLower,n.tickUpper),w=this.increasePositionFromLiquidityInstruction(c,i.wallet,p,b,l,g,u,m,i.tokenAccountA,i.tokenAccountB,new S(t.vault.A),new S(t.vault.B),new S(e.mintA.address),new S(e.mintB.address),s,o,r,pe.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing,[d,f])?ge(c,l).publicKey:void 0);return{address:{tickArrayLower:u,tickArrayUpper:m,positionNftAccount:p,personalPosition:b,protocolPosition:g},signers:[],instructions:[w],instructionTypes:[re.ClmmIncreasePosition],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[]}}static increasePositionFromBaseInstructions({poolInfo:e,poolKeys:t,ownerPosition:n,ownerInfo:i,base:s,baseAmount:o,otherAmountMax:r,nft2022:a}){let[c,l]=[new S(e.programId),new S(e.id)],d=M.getTickArrayStartIndexByTick(n.tickLower,e.config.tickSpacing),f=M.getTickArrayStartIndexByTick(n.tickUpper,e.config.tickSpacing),{publicKey:u}=z(c,l,d),{publicKey:m}=z(c,l,f),{publicKey:p}=a?oe(i.wallet,n.nftMint,be):oe(i.wallet,n.nftMint,te),{publicKey:b}=Ce(c,n.nftMint),{publicKey:g}=Ve(c,l,n.tickLower,n.tickUpper);return{address:{tickArrayLower:u,tickArrayUpper:m,positionNftAccount:p,personalPosition:b,protocolPosition:g},instructions:[this.increasePositionFromBaseInstruction(c,i.wallet,p,b,l,g,u,m,i.tokenAccountA,i.tokenAccountB,new S(t.vault.A),new S(t.vault.B),new S(e.mintA.address),new S(e.mintB.address),s,o,r,pe.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing,[d,f])?ge(c,l).publicKey:void 0)],signers:[],instructionTypes:[re.ClmmIncreasePosition],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[]}}static increasePositionFromBaseInstruction(e,t,n,i,s,o,r,a,c,l,d,f,u,m,p,b,g,w){let k=$([X("liquidity"),E("amountMaxA"),E("amountMaxB"),ye("optionBaseFlag"),Ie("baseFlag")]),T=[...w?[{pubkey:w,isSigner:!1,isWritable:!0}]:[]],A=[{pubkey:t,isSigner:!0,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:d,isSigner:!1,isWritable:!0},{pubkey:f,isSigner:!1,isWritable:!0},{pubkey:te,isSigner:!1,isWritable:!1},{pubkey:be,isSigner:!1,isWritable:!1},{pubkey:u,isSigner:!1,isWritable:!1},{pubkey:m,isSigner:!1,isWritable:!1},...T],P=Buffer.alloc(k.span);k.encode({liquidity:new Un(0),amountMaxA:p==="MintA"?b:g,amountMaxB:p==="MintA"?g:b,baseFlag:p==="MintA",optionBaseFlag:1},P);let x=Buffer.from([...Oe.increaseLiquidity,...P]);return new xe({keys:A,programId:e,data:x})}static decreaseLiquidityInstruction(e,t,n,i,s,o,r,a,c,l,d,f,u,m,p,b,g,w,k){let T=$([X("liquidity"),E("amountMinA"),E("amountMinB")]),A=[...k?[{pubkey:k,isSigner:!1,isWritable:!0}]:[],...p.map(B=>[{pubkey:B.poolRewardVault,isSigner:!1,isWritable:!0},{pubkey:B.ownerRewardVault,isSigner:!1,isWritable:!0},{pubkey:B.rewardMint,isSigner:!1,isWritable:!1}]).flat()],P=[{pubkey:t,isSigner:!0,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:d,isSigner:!1,isWritable:!0},{pubkey:f,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:te,isSigner:!1,isWritable:!1},{pubkey:be,isSigner:!1,isWritable:!1},{pubkey:en,isSigner:!1,isWritable:!1},{pubkey:u,isSigner:!1,isWritable:!1},{pubkey:m,isSigner:!1,isWritable:!1},...A],x=Buffer.alloc(T.span);T.encode({liquidity:b,amountMinA:g,amountMinB:w},x);let h=Buffer.from([...Oe.decreaseLiquidity,...x]);return new xe({keys:P,programId:e,data:h})}static decreaseLiquidityInstructions({poolInfo:e,poolKeys:t,ownerPosition:n,ownerInfo:i,liquidity:s,amountMinA:o,amountMinB:r,programId:a,nft2022:c}){let[l,d]=[new S(e.programId),new S(e.id)],f=M.getTickArrayStartIndexByTick(n.tickLower,e.config.tickSpacing),u=M.getTickArrayStartIndexByTick(n.tickUpper,e.config.tickSpacing),{publicKey:m}=z(l,d,f),{publicKey:p}=z(l,d,u),{publicKey:b}=c?oe(i.wallet,n.nftMint,be):oe(i.wallet,n.nftMint,a),{publicKey:g}=Ce(l,n.nftMint),{publicKey:w}=Ve(l,d,n.tickLower,n.tickUpper),k=[];for(let P=0;P<e.rewardDefaultInfos.length;P++)k.push({poolRewardVault:new S(t.rewardInfos[P].vault),ownerRewardVault:i.rewardAccounts[P],rewardMint:new S(e.rewardDefaultInfos[P].mint.address)});let T=[],A=this.decreaseLiquidityInstruction(l,i.wallet,b,g,d,w,m,p,i.tokenAccountA,i.tokenAccountB,new S(t.vault.A),new S(t.vault.B),new S(e.mintA.address),new S(e.mintB.address),k,s,o,r,pe.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing,[f,u])?ge(l,d).publicKey:void 0);return T.push(A),{address:{tickArrayLower:m,tickArrayUpper:p,positionNftAccount:b,personalPosition:g,protocolPosition:w},signers:[],instructions:T,instructionTypes:[re.ClmmDecreasePosition],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[]}}static swapInstruction(e,t,n,i,s,o,r,a,c,l,d,f,u,m,p,b,g){let w=$([E("amount"),E("otherAmountThreshold"),X("sqrtPriceLimitX64"),Ie("isBaseInput")]),k=[...g?[{pubkey:g,isSigner:!1,isWritable:!0}]:[],...d.map(x=>({pubkey:x,isSigner:!1,isWritable:!0}))],T=[{pubkey:t,isSigner:!0,isWritable:!1},{pubkey:i,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:f,isSigner:!1,isWritable:!0},{pubkey:te,isSigner:!1,isWritable:!1},{pubkey:be,isSigner:!1,isWritable:!1},{pubkey:en,isSigner:!1,isWritable:!1},{pubkey:c,isSigner:!1,isWritable:!1},{pubkey:l,isSigner:!1,isWritable:!1},...k],A=Buffer.alloc(w.span);w.encode({amount:u,otherAmountThreshold:m,sqrtPriceLimitX64:p,isBaseInput:b},A);let P=Buffer.from([...Oe.swap,...A]);return new xe({keys:T,programId:e,data:P})}static makeSwapBaseInInstructions({poolInfo:e,poolKeys:t,observationId:n,ownerInfo:i,inputMint:s,amountIn:o,amountOutMin:r,sqrtPriceLimitX64:a,remainingAccounts:c}){let[l,d]=[new S(e.programId),new S(e.id)],[f,u]=[new S(t.vault.A),new S(t.vault.B)],[m,p]=[new S(e.mintA.address),new S(e.mintB.address)],b=e.mintA.address===s.toString(),g=[this.swapInstruction(l,i.wallet,d,new S(e.config.id),b?i.tokenAccountA:i.tokenAccountB,b?i.tokenAccountB:i.tokenAccountA,b?f:u,b?u:f,b?m:p,b?p:m,c,n,o,r,a,!0,ge(l,d).publicKey)];return{signers:[],instructions:g,instructionTypes:[re.ClmmSwapBaseIn],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[],address:{}}}static makeSwapBaseOutInstructions({poolInfo:e,poolKeys:t,observationId:n,ownerInfo:i,outputMint:s,amountOut:o,amountInMax:r,sqrtPriceLimitX64:a,remainingAccounts:c}){let[l,d]=[new S(e.programId),new S(e.id)],[f,u]=[new S(t.vault.A),new S(t.vault.B)],[m,p]=[new S(e.mintA.address),new S(e.mintB.address)],b=e.mintA.address===s.toBase58(),g=[this.swapInstruction(l,i.wallet,d,new S(e.config.id),b?i.tokenAccountB:i.tokenAccountA,b?i.tokenAccountA:i.tokenAccountB,b?u:f,b?f:u,b?p:m,b?m:p,c,n,o,r,a,!1,ge(l,d).publicKey)];return{signers:[],instructions:g,instructionTypes:[re.ClmmSwapBaseOut],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[],address:{}}}static initRewardInstruction(e,t,n,i,s,o,r,a,c,l,d,f){let u=$([E("openTime"),E("endTime"),X("emissionsPerSecondX64")]),m=[{pubkey:t,isSigner:!0,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!1},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!1},{pubkey:nt.programId,isSigner:!1,isWritable:!1},{pubkey:rt,isSigner:!1,isWritable:!1}],p=Buffer.alloc(u.span);u.encode({openTime:we(l),endTime:we(d),emissionsPerSecondX64:f},p);let b=Buffer.from([...Oe.initReward,...p]);return new xe({keys:m,programId:e,data:b})}static initRewardInstructions({poolInfo:e,poolKeys:t,ownerInfo:n,rewardInfo:i}){let[s,o]=[new S(e.programId),new S(e.id)],r=Li(s,o,i.mint).publicKey,a=Ut(s).publicKey,c=[this.initRewardInstruction(s,n.wallet,o,a,new S(e.config.id),n.tokenAccount,i.programId,i.mint,r,i.openTime,i.endTime,i.emissionsPerSecondX64)];return{address:{poolRewardVault:r,operationId:a},signers:[],instructions:c,instructionTypes:[re.ClmmInitReward],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[]}}static setRewardInstruction(e,t,n,i,s,o,r,a,c,l,d,f){let u=$([ye("rewardIndex"),X("emissionsPerSecondX64"),E("openTime"),E("endTime")]),m=[{pubkey:t,isSigner:!0,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:te,isSigner:!1,isWritable:!1},{pubkey:be,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0}],p=Buffer.alloc(u.span);u.encode({rewardIndex:c,emissionsPerSecondX64:f,openTime:we(l),endTime:we(d)},p);let b=Buffer.from([...Oe.setRewardEmissions,...p]);return new xe({keys:m,programId:e,data:b})}static setRewardInstructions({poolInfo:e,poolKeys:t,ownerInfo:n,rewardInfo:i}){let[s,o]=[new S(e.programId),new S(e.id)],r,a,c;for(let f=0;f<e.rewardDefaultInfos.length;f++)e.rewardDefaultInfos[f].mint.address===i.mint.toString()&&(r=f,a=new S(t.rewardInfos[f].vault),c=new S(t.rewardInfos[f].mint.address));(r===void 0||a===void 0)&&_i.logWithError("reward mint check error","no reward mint",e.rewardDefaultInfos);let l=Ut(s).publicKey,d=[this.setRewardInstruction(s,n.wallet,o,l,new S(e.config.id),n.tokenAccount,a,c,r,i.openTime,i.endTime,i.emissionsPerSecondX64)];return{address:{rewardVault:a,operationId:l},signers:[],instructions:d,instructionTypes:[re.ClmmSetReward],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[]}}static collectRewardInstruction(e,t,n,i,s,o,r){let a=$([ye("rewardIndex")]),c=[{pubkey:t,isSigner:!0,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:te,isSigner:!1,isWritable:!1},{pubkey:be,isSigner:!1,isWritable:!1},{pubkey:en,isSigner:!1,isWritable:!1}],l=Buffer.alloc(a.span);a.encode({rewardIndex:r},l);let d=Buffer.from([...Oe.collectReward,...l]);return new xe({keys:c,programId:e,data:d})}static collectRewardInstructions({poolInfo:e,poolKeys:t,ownerInfo:n,rewardMint:i}){let[s,o]=[new S(e.programId),new S(e.id)],r,a;for(let l=0;l<e.rewardDefaultInfos.length;l++)e.rewardDefaultInfos[l].mint.address===i.toString()&&(r=l,a=new S(t.rewardInfos[l].vault));(r===void 0||a===void 0)&&_i.logWithError("reward mint check error","no reward mint",e.rewardDefaultInfos);let c=[this.collectRewardInstruction(s,n.wallet,o,n.tokenAccount,a,i,r)];return{address:{rewardVault:a},signers:[],instructions:c,instructionTypes:[re.ClmmCollectReward],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[]}}static async makeLockPositions({programId:e,authProgramId:t,poolProgramId:n,payer:i,wallet:s,nftMint:o,nft2022:r,getEphemeralSigners:a}){let c=[],l;if(a)l=new S((await a(1))[0]);else{let g=dn.generate();c.push(g),l=g.publicKey}let d=r?oe(s,o,be).publicKey:oe(s,o,te).publicKey,{publicKey:f}=Ce(n,o),u=kt(e,l).publicKey,m=oe(s,l,te).publicKey,p=Gt(l).publicKey,b=ce.lockPositionInstructionV2({programId:e,auth:t,payer:i,positionOwner:s,lockOwner:s,positionNftAccount:d,positionId:f,lockPositionId:u,lockNftMint:l,lockNftAccount:m,metadataAccount:p,withMetadata:!0,nft2022:r,positionNftMint:o,authPositionNftAccount:oe(t,o,r?be:te).publicKey,positionNftProgram:r?be:te});return{address:{positionId:f,lockPositionId:u,lockNftAccount:m,lockNftMint:l,positionNftAccount:d,metadataAccount:p},instructions:[b],signers:c,instructionTypes:[re.ClmmLockPosition],lookupTableAddress:[]}}static lockPositionInstructionV2({programId:e,auth:t,payer:n,positionOwner:i,lockOwner:s,positionNftAccount:o,positionId:r,positionNftMint:a,authPositionNftAccount:c,positionNftProgram:l,lockPositionId:d,lockNftMint:f,lockNftAccount:u,metadataAccount:m,withMetadata:p}){let b=[{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!0,isWritable:!0},{pubkey:i,isSigner:!0,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!1},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:d,isSigner:!1,isWritable:!0},{pubkey:f,isSigner:!0,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:m,isSigner:!1,isWritable:!0},{pubkey:mt,isSigner:!1,isWritable:!1},{pubkey:jt,isSigner:!1,isWritable:!1},{pubkey:rt,isSigner:!1,isWritable:!1},{pubkey:te,isSigner:!1,isWritable:!1},{pubkey:l,isSigner:!1,isWritable:!1},{pubkey:nt.programId,isSigner:!1,isWritable:!1}],g=$([Ie("withMetadata")]),w=Buffer.alloc(g.span);g.encode({withMetadata:p},w);let k=Buffer.from([...Wi,...w]);return new xe({keys:b,programId:e,data:k})}static lockPositionInstruction({programId:e,authProgramId:t,poolProgramId:n,owner:i,positionNft:s}){let{publicKey:o}=oe(i,s,te),{publicKey:r}=Ce(n,s),a=[{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:i,isSigner:!0,isWritable:!1},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!1},{pubkey:Vn(e,r).publicKey,isSigner:!1,isWritable:!0},{pubkey:te,isSigner:!1,isWritable:!1},{pubkey:nt.programId,isSigner:!1,isWritable:!1}];return new xe({keys:a,programId:e,data:Buffer.from(Wi)})}static harvestLockPositionInstruction(e){let[t,n]=[new S(e.poolKeys.programId),new S(e.poolKeys.id)],i=M.getTickArrayStartIndexByTick(e.ownerPosition.tickLower,e.poolKeys.config.tickSpacing),s=M.getTickArrayStartIndexByTick(e.ownerPosition.tickUpper,e.poolKeys.config.tickSpacing),{publicKey:o}=z(t,n,i),{publicKey:r}=z(t,n,s),{publicKey:a}=oe(e.owner,e.ownerPosition.nftMint,te),{publicKey:c}=Ce(t,e.ownerPosition.nftMint),{publicKey:l}=Ve(t,n,e.ownerPosition.tickLower,e.ownerPosition.tickUpper),d=[];for(let m=0;m<e.poolKeys.rewardInfos.length;m++)d.push({poolRewardVault:new S(e.poolKeys.rewardInfos[m].vault),ownerRewardVault:e.ownerRewardAccounts[m],rewardMint:new S(e.poolKeys.rewardInfos[m].mint.address)});let f=[...d.map(m=>[{pubkey:m.poolRewardVault,isSigner:!1,isWritable:!0},{pubkey:m.ownerRewardVault,isSigner:!1,isWritable:!0},{pubkey:m.rewardMint,isSigner:!1,isWritable:!1}]).flat()],u=[{pubkey:e.authProgramId,isSigner:!1,isWritable:!1},{pubkey:Vn(e.programId,c).publicKey,isSigner:!1,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:e.owner,isSigner:!0,isWritable:!1},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:new S(e.poolKeys.vault.A),isSigner:!1,isWritable:!0},{pubkey:new S(e.poolKeys.vault.B),isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:e.userVaultA,isSigner:!1,isWritable:!0},{pubkey:e.userVaultB,isSigner:!1,isWritable:!0},{pubkey:te,isSigner:!1,isWritable:!1},{pubkey:be,isSigner:!1,isWritable:!1},{pubkey:Tn,isSigner:!1,isWritable:!1},{pubkey:new S(e.poolKeys.mintA.address),isSigner:!1,isWritable:!1},{pubkey:new S(e.poolKeys.mintB.address),isSigner:!1,isWritable:!1},...f];return new xe({keys:u,programId:e.programId,data:Buffer.from(qi)})}static harvestLockPositionInstructionV2({programId:e,auth:t,lockPositionId:n,clmmProgram:i,lockOwner:s,lockNftMint:o,lockNftAccount:r,positionNftAccount:a,positionId:c,poolId:l,protocolPosition:d,vaultA:f,vaultB:u,tickArrayLower:m,tickArrayUpper:p,userVaultA:b,userVaultB:g,mintA:w,mintB:k,rewardAccounts:T,exTickArrayBitmap:A}){let P=[...A?[{pubkey:A,isSigner:!1,isWritable:!0}]:[],...T.map(h=>[{pubkey:h.poolRewardVault,isSigner:!1,isWritable:!0},{pubkey:h.ownerRewardVault,isSigner:!1,isWritable:!0},{pubkey:h.rewardMint,isSigner:!1,isWritable:!1}]).flat()],x=[{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:s,isSigner:!0,isWritable:!1},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:i,isSigner:!1,isWritable:!1},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:d,isSigner:!1,isWritable:!0},{pubkey:f,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:m,isSigner:!1,isWritable:!0},{pubkey:p,isSigner:!1,isWritable:!0},{pubkey:b,isSigner:!1,isWritable:!0},{pubkey:g,isSigner:!1,isWritable:!0},{pubkey:te,isSigner:!1,isWritable:!1},{pubkey:be,isSigner:!1,isWritable:!1},{pubkey:Tn,isSigner:!1,isWritable:!1},{pubkey:w,isSigner:!1,isWritable:!1},{pubkey:k,isSigner:!1,isWritable:!1},...P];return new xe({keys:x,programId:e,data:Buffer.from(qi)})}};var Xn=class extends vt{constructor(e){super(e)}async getClmmPoolKeys(e){return(await this.scope.api.fetchPoolKeysById({idList:[e]}))[0]}async createPool(e){var x;let{programId:t,owner:n=((x=this.scope.owner)==null?void 0:x.publicKey)||R.default,mint1:i,mint2:s,ammConfig:o,initialPrice:r,computeBudgetConfig:a,forerunCreate:c,getObserveState:l,txVersion:d,txTipConfig:f,feePayer:u}=e,m=this.createTxBuilder(u),[p,b,g]=new Ke(new R(i.address).toBuffer()).gt(new Ke(new R(s.address).toBuffer()))?[s,i,new gt(1).div(r)]:[i,s,r],w=V.priceToSqrtPriceX64(g,p.decimals,b.decimals),k=[],T=[];p.programId===ct.toBase58()&&T.push(vn(t,new R(p.address)).publicKey),b.programId===ct.toBase58()&&T.push(vn(t,new R(b.address)).publicKey),(await this.scope.connection.getMultipleAccountsInfo(T)).forEach((h,B)=>{h&&k.push(T[B])});let P=await ce.createPoolInstructions({connection:this.scope.connection,programId:t,owner:n,mintA:p,mintB:b,ammConfigId:o.id,initialPriceX64:w,forerunCreate:!l&&c,extendMintAccount:k});return m.addInstruction(P),m.addCustomComputeBudget(a),m.addTipInstruction(f),m.versionBuild({txVersion:d,extInfo:{address:U(O({},P.address),{observationId:P.address.observationId.toBase58(),exBitmapAccount:P.address.exBitmapAccount.toBase58(),programId:t.toString(),id:P.address.poolId.toString(),mintA:p,mintB:b,openTime:"0",vault:{A:P.address.mintAVault.toString(),B:P.address.mintBVault.toString()},rewardInfos:[],config:{id:o.id.toString(),index:o.index,protocolFeeRate:o.protocolFeeRate,tradeFeeRate:o.tradeFeeRate,tickSpacing:o.tickSpacing,fundFeeRate:o.fundFeeRate,description:o.description,defaultRange:0,defaultRangePoint:[]}}),mockPoolInfo:O({type:"Concentrated",rewardDefaultPoolInfos:"Clmm",id:P.address.poolId.toString(),mintA:p,mintB:b,feeRate:o.tradeFeeRate,openTime:"0",programId:t.toString(),price:g.toNumber(),config:{id:o.id.toString(),index:o.index,protocolFeeRate:o.protocolFeeRate,tradeFeeRate:o.tradeFeeRate,tickSpacing:o.tickSpacing,fundFeeRate:o.fundFeeRate,description:o.description,defaultRange:0,defaultRangePoint:[]},burnPercent:0},xi),forerunCreate:c}})}async openPositionFromBase({poolInfo:e,poolKeys:t,ownerInfo:n,tickLower:i,tickUpper:s,base:o,baseAmount:r,otherAmountMax:a,nft2022:c,associatedOnly:l=!0,checkCreateATAOwner:d=!1,withMetadata:f="create",getEphemeralSigners:u,computeBudgetConfig:m,txTipConfig:p,txVersion:b,feePayer:g}){this.scope.availability.addConcentratedPosition===!1&&this.logAndCreateError("add position feature disabled in your region"),this.scope.checkOwner();let w=this.createTxBuilder(g),k=null,T=null,A=n.useSOLBalance&&e.mintA.address===Q.toString(),P=n.useSOLBalance&&e.mintB.address===Q.toString(),[x,h]=o==="MintA"?[r,a]:[a,r],{account:B,instructionParams:K}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:e.mintA.programId,mint:new R(e.mintA.address),owner:this.scope.ownerPubKey,createInfo:A||x.isZero()?{payer:this.scope.ownerPubKey,amount:x}:void 0,skipCloseAccount:!A,notUseTokenAccount:A,associatedOnly:A?!1:l,checkCreateATAOwner:d});B&&(k=B),w.addInstruction(K||{});let{account:L,instructionParams:C}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:e.mintB.programId,mint:new R(e.mintB.address),owner:this.scope.ownerPubKey,createInfo:P||h.isZero()?{payer:this.scope.ownerPubKey,amount:h}:void 0,skipCloseAccount:!P,notUseTokenAccount:P,associatedOnly:P?!1:l,checkCreateATAOwner:d});L&&(T=L),w.addInstruction(C||{}),(!k||!T)&&this.logAndCreateError("cannot found target token accounts","tokenAccounts",{ownerTokenAccountA:k==null?void 0:k.toBase58(),ownerTokenAccountB:T==null?void 0:T.toBase58()});let N=t||await this.getClmmPoolKeys(e.id),I=await ce.openPositionFromBaseInstructions({poolInfo:e,poolKeys:N,ownerInfo:U(O({},n),{feePayer:this.scope.ownerPubKey,wallet:this.scope.ownerPubKey,tokenAccountA:k,tokenAccountB:T}),tickLower:i,tickUpper:s,base:o,baseAmount:r,otherAmountMax:a,withMetadata:f,getEphemeralSigners:u,nft2022:c});return w.addInstruction(I),w.addCustomComputeBudget(m),w.addTipInstruction(p),w.versionBuild({txVersion:b,extInfo:O({},I.address)})}async openPositionFromLiquidity({poolInfo:e,poolKeys:t,ownerInfo:n,amountMaxA:i,amountMaxB:s,tickLower:o,tickUpper:r,liquidity:a,associatedOnly:c=!0,checkCreateATAOwner:l=!1,withMetadata:d="create",txVersion:f,computeBudgetConfig:u,txTipConfig:m,getEphemeralSigners:p,nft2022:b,feePayer:g}){this.scope.availability.createConcentratedPosition===!1&&this.logAndCreateError("open position feature disabled in your region");let w=this.createTxBuilder(g),k=null,T=null,A=n.useSOLBalance&&e.mintA.address===Q.toBase58(),P=n.useSOLBalance&&e.mintB.address===Q.toBase58(),{account:x,instructionParams:h}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:e.mintA.programId,mint:new R(e.mintA.address),owner:this.scope.ownerPubKey,createInfo:A||i.isZero()?{payer:this.scope.ownerPubKey,amount:i}:void 0,skipCloseAccount:!A,notUseTokenAccount:A,associatedOnly:A?!1:c,checkCreateATAOwner:l});x&&(k=x),w.addInstruction(h||{});let{account:B,instructionParams:K}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:e.mintB.programId,mint:new R(e.mintB.address),owner:this.scope.ownerPubKey,createInfo:P||s.isZero()?{payer:this.scope.ownerPubKey,amount:s}:void 0,skipCloseAccount:!P,notUseTokenAccount:P,associatedOnly:P?!1:c,checkCreateATAOwner:l});B&&(T=B),w.addInstruction(K||{}),(k===void 0||T===void 0)&&this.logAndCreateError("cannot found target token accounts","tokenAccounts",this.scope.account.tokenAccounts);let L=t||await this.getClmmPoolKeys(e.id),C=await ce.openPositionFromLiquidityInstructions({poolInfo:e,poolKeys:L,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccountA:k,tokenAccountB:T},tickLower:o,tickUpper:r,liquidity:a,amountMaxA:i,amountMaxB:s,withMetadata:d,getEphemeralSigners:p,nft2022:b});return w.addInstruction(C),w.addCustomComputeBudget(u),w.addTipInstruction(m),w.versionBuild({txVersion:f,extInfo:{address:C.address}})}async increasePositionFromLiquidity(e){var K;let{poolInfo:t,poolKeys:n,ownerPosition:i,amountMaxA:s,amountMaxB:o,liquidity:r,ownerInfo:a,associatedOnly:c=!0,checkCreateATAOwner:l=!1,computeBudgetConfig:d,txTipConfig:f,txVersion:u,feePayer:m}=e,p=this.createTxBuilder(m),b,g,w=a.useSOLBalance&&t.mintA.address===Q.toString(),k=a.useSOLBalance&&t.mintB.address===Q.toString(),{account:T,instructionParams:A}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:t.mintA.programId,mint:new R(t.mintA.address),notUseTokenAccount:w,owner:this.scope.ownerPubKey,createInfo:w||s.isZero()?{payer:this.scope.ownerPubKey,amount:s}:void 0,skipCloseAccount:!w,associatedOnly:w?!1:c,checkCreateATAOwner:l});T&&(b=T),p.addInstruction(A||{});let{account:P,instructionParams:x}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:t.mintB.programId,mint:new R(t.mintB.address),owner:this.scope.ownerPubKey,createInfo:k||o.isZero()?{payer:this.scope.ownerPubKey,amount:o}:void 0,notUseTokenAccount:k,skipCloseAccount:!k,associatedOnly:k?!1:c,checkCreateATAOwner:l});P&&(g=P),p.addInstruction(x||{}),!b&&!g&&this.logAndCreateError("cannot found target token accounts","tokenAccounts",this.scope.account.tokenAccounts);let h=n!=null?n:await this.getClmmPoolKeys(t.id),B=ce.increasePositionFromLiquidityInstructions({poolInfo:t,poolKeys:h,ownerPosition:i,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccountA:b,tokenAccountB:g},liquidity:r,amountMaxA:s,amountMaxB:o,nft2022:(K=await this.scope.connection.getAccountInfo(i.nftMint))==null?void 0:K.owner.equals(ct)});return p.addInstruction(B),p.addCustomComputeBudget(d),p.addTipInstruction(f),p.versionBuild({txVersion:u,extInfo:{address:B.address}})}async increasePositionFromBase(e){var B;let{poolInfo:t,ownerPosition:n,base:i,baseAmount:s,otherAmountMax:o,ownerInfo:r,associatedOnly:a=!0,checkCreateATAOwner:c=!1,computeBudgetConfig:l,txTipConfig:d,txVersion:f,feePayer:u}=e,m=this.createTxBuilder(u),p,b,g=r.useSOLBalance&&t.mintA.address===Q.toString(),w=r.useSOLBalance&&t.mintB.address===Q.toString(),{account:k,instructionParams:T}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:t.mintA.programId,mint:new R(t.mintA.address),notUseTokenAccount:g,owner:this.scope.ownerPubKey,createInfo:g||(i==="MintA"?s:o).isZero()?{payer:this.scope.ownerPubKey,amount:i==="MintA"?s:o}:void 0,skipCloseAccount:!g,associatedOnly:g?!1:a,checkCreateATAOwner:c});k&&(p=k),m.addInstruction(T||{});let{account:A,instructionParams:P}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:t.mintB.programId,mint:new R(t.mintB.address),owner:this.scope.ownerPubKey,createInfo:w||(i==="MintA"?o:s).isZero()?{payer:this.scope.ownerPubKey,amount:i==="MintA"?o:s}:void 0,notUseTokenAccount:w,skipCloseAccount:!w,associatedOnly:w?!1:a,checkCreateATAOwner:c});A&&(b=A),m.addInstruction(P||{}),!p&&!b&&this.logAndCreateError("cannot found target token accounts","tokenAccounts",this.scope.account.tokenAccounts);let x=await this.getClmmPoolKeys(t.id),h=ce.increasePositionFromBaseInstructions({poolInfo:t,poolKeys:x,ownerPosition:n,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccountA:p,tokenAccountB:b},base:i,baseAmount:s,otherAmountMax:o,nft2022:(B=await this.scope.connection.getAccountInfo(n.nftMint))==null?void 0:B.owner.equals(ct)});return m.addInstruction(h),m.addCustomComputeBudget(l),m.addTipInstruction(d),m.versionBuild({txVersion:f,extInfo:{address:h.address}})}async decreaseLiquidity(e){var N;let{poolInfo:t,poolKeys:n,ownerPosition:i,ownerInfo:s,amountMinA:o,amountMinB:r,liquidity:a,associatedOnly:c=!0,checkCreateATAOwner:l=!1,computeBudgetConfig:d,txTipConfig:f,txVersion:u,feePayer:m}=e;this.scope.availability.removeConcentratedPosition===!1&&this.logAndCreateError("remove position feature disabled in your region");let p=this.createTxBuilder(m),b=s.useSOLBalance&&t.mintA.address===Q.toString(),g=s.useSOLBalance&&t.mintB.address===Q.toString(),w,k,{account:T,instructionParams:A}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:t.mintA.programId,mint:new R(t.mintA.address),notUseTokenAccount:b,owner:this.scope.ownerPubKey,createInfo:{payer:this.scope.ownerPubKey,amount:0},skipCloseAccount:!b,associatedOnly:b?!1:c,checkCreateATAOwner:l});w=T,A&&p.addInstruction(A);let{account:P,instructionParams:x}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:t.mintB.programId,mint:new R(t.mintB.address),notUseTokenAccount:g,owner:this.scope.ownerPubKey,createInfo:{payer:this.scope.ownerPubKey,amount:0},skipCloseAccount:!g,associatedOnly:g?!1:c,checkCreateATAOwner:l});k=P,x&&p.addInstruction(x);let h=[];for(let I of t.rewardDefaultInfos){let F=s.useSOLBalance&&I.mint.address===Q.toString(),q;if(I.mint.address===t.mintA.address)q=w;else if(I.mint.address===t.mintB.address)q=k;else{let{account:ue,instructionParams:fe}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:new R(I.mint.programId),mint:new R(I.mint.address),notUseTokenAccount:F,owner:this.scope.ownerPubKey,createInfo:{payer:this.scope.ownerPubKey,amount:0},skipCloseAccount:!F,associatedOnly:F?!1:c,checkCreateATAOwner:l});q=ue,fe&&p.addInstruction(fe)}h.push(q)}!w&&!k&&this.logAndCreateError("cannot found target token accounts","tokenAccounts",this.scope.account.tokenAccountRawInfos);let B=n!=null?n:await this.getClmmPoolKeys(t.id),K=(N=await this.scope.connection.getAccountInfo(i.nftMint))==null?void 0:N.owner.equals(ct),L=await ce.decreaseLiquidityInstructions({poolInfo:t,poolKeys:B,ownerPosition:i,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccountA:w,tokenAccountB:k,rewardAccounts:h},liquidity:a,amountMinA:o,amountMinB:r,nft2022:K});p.addInstruction({instructions:L.instructions,instructionTypes:[re.ClmmDecreasePosition]});let C=O({},L.address);if(s.closePosition){let I=await ce.closePositionInstructions({poolInfo:t,poolKeys:B,ownerInfo:{wallet:this.scope.ownerPubKey},ownerPosition:i,nft2022:K});p.addInstruction({endInstructions:I.instructions,endInstructionTypes:I.instructionTypes}),C=O(O({},C),I.address)}return p.addCustomComputeBudget(d),p.addTipInstruction(f),p.versionBuild({txVersion:u,extInfo:{address:C}})}async lockPosition(e){var m;let{programId:t=Mt,authProgramId:n=nn,poolProgramId:i=Nt,ownerPosition:s,payer:o,computeBudgetConfig:r,txTipConfig:a,txVersion:c,getEphemeralSigners:l,feePayer:d}=e,f=this.createTxBuilder(d),u=await ce.makeLockPositions({programId:t,authProgramId:n,poolProgramId:i,wallet:this.scope.ownerPubKey,payer:o!=null?o:this.scope.ownerPubKey,nftMint:s.nftMint,getEphemeralSigners:l,nft2022:(m=await this.scope.connection.getAccountInfo(s.nftMint))==null?void 0:m.owner.equals(ct)});return f.addInstruction(u),f.addCustomComputeBudget(r),f.addTipInstruction(a),f.versionBuild({txVersion:c,extInfo:u.address})}async harvestLockPosition(e){let{programId:t=Mt,authProgramId:n=nn,clmmProgram:i=Nt,poolKeys:s,lockData:o,ownerInfo:r={useSOLBalance:!0},associatedOnly:a=!0,checkCreateATAOwner:c=!1,computeBudgetConfig:l,txTipConfig:d,txVersion:f,feePayer:u}=e,m=s||await this.getClmmPoolKeys(o.poolId.toString()),p=this.createTxBuilder(u),b=await this.scope.connection.getAccountInfo(o.positionId);b||this.logger.logWithError("position not found",o.positionId);let g=ht.decode(b.data),w=r.useSOLBalance&&m.mintA.address===Q.toString(),k=r.useSOLBalance&&m.mintB.address===Q.toString(),T,A,{account:P,instructionParams:x}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:m.mintA.programId,mint:new R(m.mintA.address),notUseTokenAccount:w,owner:this.scope.ownerPubKey,createInfo:{payer:this.scope.ownerPubKey,amount:0},skipCloseAccount:!w,associatedOnly:w?!1:a,checkCreateATAOwner:c});T=P,x&&p.addInstruction(x);let{account:h,instructionParams:B}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:m.mintB.programId,mint:new R(m.mintB.address),notUseTokenAccount:k,owner:this.scope.ownerPubKey,createInfo:{payer:this.scope.ownerPubKey,amount:0},skipCloseAccount:!k,associatedOnly:k?!1:a,checkCreateATAOwner:c});A=h,B&&p.addInstruction(B);let K={},L=[];for(let ee of m.rewardInfos){let ie=r.useSOLBalance&&ee.mint.address===Q.toString(),ve=K[ee.mint.address];if(!ve){let{account:Xi,instructionParams:Hn}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:new R(ee.mint.programId),mint:new R(ee.mint.address),notUseTokenAccount:ie,owner:this.scope.ownerPubKey,skipCloseAccount:!ie,createInfo:{payer:this.scope.ownerPubKey,amount:0},associatedOnly:ie?!1:a});ve=Xi,Hn&&p.addInstruction(Hn)}K[ee.mint.address]=ve,L.push(ve)}let C=kt(t,o.lockNftMint).publicKey,N=oe(this.scope.ownerPubKey,o.lockNftMint,Zt).publicKey,I=M.getTickArrayStartIndexByTick(g.tickLower,m.config.tickSpacing),F=M.getTickArrayStartIndexByTick(g.tickUpper,m.config.tickSpacing),{publicKey:q}=z(new R(m.programId),o.poolId,I),{publicKey:ue}=z(new R(m.programId),o.poolId,F),{publicKey:fe}=Ve(new R(m.programId),o.poolId,g.tickLower,g.tickUpper),Le=[];for(let ee=0;ee<m.rewardInfos.length;ee++)Le.push({poolRewardVault:new R(m.rewardInfos[ee].vault),ownerRewardVault:L[ee],rewardMint:new R(m.rewardInfos[ee].mint.address)});let ze=await ce.harvestLockPositionInstructionV2({programId:t,auth:n,lockPositionId:C,clmmProgram:i,lockOwner:this.scope.ownerPubKey,lockNftMint:o.lockNftMint,lockNftAccount:N,positionNftAccount:o.nftAccount,positionId:o.positionId,poolId:o.poolId,protocolPosition:fe,vaultA:new R(m.vault.A),vaultB:new R(m.vault.B),tickArrayLower:q,tickArrayUpper:ue,userVaultA:T,userVaultB:A,mintA:new R(m.mintA.address),mintB:new R(m.mintB.address),rewardAccounts:Le,exTickArrayBitmap:ge(i,o.poolId).publicKey});return p.addInstruction({instructions:[ze],instructionTypes:[re.ClmmHarvestLockPosition]}),p.addCustomComputeBudget(l),p.addTipInstruction(d),p.versionBuild({txVersion:f})}async closePosition({poolInfo:e,poolKeys:t,ownerPosition:n,txVersion:i,computeBudgetConfig:s,txTipConfig:o,feePayer:r}){var d;this.scope.availability.removeConcentratedPosition===!1&&this.logAndCreateError("remove position feature disabled in your region");let a=this.createTxBuilder(r),c=t!=null?t:await this.getClmmPoolKeys(e.id),l=ce.closePositionInstructions({poolInfo:e,poolKeys:c,ownerInfo:{wallet:this.scope.ownerPubKey},ownerPosition:n,nft2022:(d=await this.scope.connection.getAccountInfo(n.nftMint))==null?void 0:d.owner.equals(ct)});return a.addCustomComputeBudget(s),a.addTipInstruction(o),a.addInstruction(l).versionBuild({txVersion:i,extInfo:{address:l.address}})}async initReward({poolInfo:e,ownerInfo:t,rewardInfo:n,associatedOnly:i=!0,checkCreateATAOwner:s=!1,computeBudgetConfig:o,txVersion:r,feePayer:a}){n.endTime<=n.openTime&&this.logAndCreateError("reward time error","rewardInfo",n);let c=this.createTxBuilder(a),l=t.useSOLBalance&&n.mint.address.toString()===Q.toString(),d=n.perSecond.mul(n.endTime-n.openTime),{account:f,instructionParams:u}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:new R(n.mint.address),mint:new R(n.mint.address),notUseTokenAccount:!!l,skipCloseAccount:!l,owner:this.scope.ownerPubKey,createInfo:l?{payer:t.feePayer||this.scope.ownerPubKey,amount:new Ke(new gt(d.toFixed(0)).gte(d)?d.toFixed(0):d.add(1).toFixed(0))}:void 0,associatedOnly:l?!1:i,checkCreateATAOwner:s});u&&c.addInstruction(u),f||this.logAndCreateError("no money","ownerRewardAccount",this.scope.account.tokenAccountRawInfos);let m=await this.getClmmPoolKeys(e.id),p=ce.initRewardInstructions({poolInfo:e,poolKeys:m,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccount:f},rewardInfo:{programId:new R(n.mint.programId),mint:new R(n.mint.address),openTime:n.openTime,endTime:n.endTime,emissionsPerSecondX64:v.decimalToX64(n.perSecond)}});return c.addInstruction(p),c.addCustomComputeBudget(o),c.versionBuild({txVersion:r,extInfo:{address:p.address}})}async initRewards({poolInfo:e,poolKeys:t,ownerInfo:n,rewardInfos:i,associatedOnly:s=!0,checkCreateATAOwner:o=!1,computeBudgetConfig:r,txTipConfig:a,txVersion:c,feePayer:l}){for(let u of i)u.endTime<=u.openTime&&this.logAndCreateError("reward time error","rewardInfo",u);let d=this.createTxBuilder(l),f={};for(let u of i){let m=n.useSOLBalance&&u.mint.address===Q.toString(),p=u.perSecond.mul(u.endTime-u.openTime),{account:b,instructionParams:g}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:new R(u.mint.programId),mint:new R(u.mint.address),notUseTokenAccount:!!m,skipCloseAccount:!m,owner:this.scope.ownerPubKey,createInfo:m?{payer:n.feePayer||this.scope.ownerPubKey,amount:new Ke(new gt(p.toFixed(0)).gte(p)?p.toFixed(0):p.add(1).toFixed(0))}:void 0,associatedOnly:m?!1:s,checkCreateATAOwner:o});g&&d.addInstruction(g),b||this.logAndCreateError("no money","ownerRewardAccount",this.scope.account.tokenAccountRawInfos);let w=t!=null?t:await this.getClmmPoolKeys(e.id),k=ce.initRewardInstructions({poolInfo:e,poolKeys:w,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccount:b},rewardInfo:{programId:new R(u.mint.programId),mint:new R(u.mint.address),openTime:u.openTime,endTime:u.endTime,emissionsPerSecondX64:v.decimalToX64(u.perSecond)}});f=O(O({},f),k.address),d.addInstruction(k)}return d.addCustomComputeBudget(r),d.addTipInstruction(a),d.versionBuild({txVersion:c,extInfo:{address:f}})}async setReward({poolInfo:e,ownerInfo:t,rewardInfo:n,associatedOnly:i=!0,checkCreateATAOwner:s=!1,computeBudgetConfig:o,txTipConfig:r,txVersion:a,feePayer:c}){n.endTime<=n.openTime&&this.logAndCreateError("reward time error","rewardInfo",n);let l=this.createTxBuilder(c),d=t.useSOLBalance&&n.mint.equals(Q),{account:f,instructionParams:u}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:n.programId,mint:n.mint,notUseTokenAccount:d,owner:this.scope.ownerPubKey,createInfo:d?{payer:t.feePayer||this.scope.ownerPubKey,amount:new Ke(new gt(n.perSecond.mul(n.endTime-n.openTime).toFixed(0)).gte(n.perSecond.mul(n.endTime-n.openTime))?n.perSecond.mul(n.endTime-n.openTime).toFixed(0):n.perSecond.mul(n.endTime-n.openTime).add(1).toFixed(0))}:void 0,associatedOnly:d?!1:i,checkCreateATAOwner:s});u&&l.addInstruction(u),f||this.logAndCreateError("no money","ownerRewardAccount",this.scope.account.tokenAccountRawInfos);let m=await this.getClmmPoolKeys(e.id),p=ce.setRewardInstructions({poolInfo:e,poolKeys:m,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccount:f},rewardInfo:{mint:n.mint,openTime:n.openTime,endTime:n.endTime,emissionsPerSecondX64:v.decimalToX64(n.perSecond)}});return l.addInstruction(p),l.addCustomComputeBudget(o),l.addTipInstruction(r),l.versionBuild({txVersion:a,extInfo:{address:p.address}})}async setRewards({poolInfo:e,poolKeys:t,ownerInfo:n,rewardInfos:i,associatedOnly:s=!0,checkCreateATAOwner:o=!1,computeBudgetConfig:r,txTipConfig:a,txVersion:c,feePayer:l}){let d=this.createTxBuilder(l),f={};for(let u of i){u.endTime<=u.openTime&&this.logAndCreateError("reward time error","rewardInfo",u);let m=n.useSOLBalance&&u.mint.address===Q.toString(),{account:p,instructionParams:b}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:new R(u.mint.programId),mint:new R(u.mint.address),notUseTokenAccount:m,owner:this.scope.ownerPubKey,createInfo:m?{payer:n.feePayer||this.scope.ownerPubKey,amount:new Ke(new gt(u.perSecond.mul(u.endTime-u.openTime).toFixed(0)).gte(u.perSecond.mul(u.endTime-u.openTime))?u.perSecond.mul(u.endTime-u.openTime).toFixed(0):u.perSecond.mul(u.endTime-u.openTime).add(1).toFixed(0))}:void 0,associatedOnly:m?!1:s,checkCreateATAOwner:o});b&&d.addInstruction(b),p||this.logAndCreateError("no money","ownerRewardAccount",this.scope.account.tokenAccountRawInfos);let g=t!=null?t:await this.getClmmPoolKeys(e.id),w=ce.setRewardInstructions({poolInfo:e,poolKeys:g,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccount:p},rewardInfo:{mint:new R(u.mint.address),openTime:u.openTime,endTime:u.endTime,emissionsPerSecondX64:v.decimalToX64(u.perSecond)}});d.addInstruction(w),f=O(O({},f),w.address)}return d.addCustomComputeBudget(r),d.addTipInstruction(a),d.versionBuild({txVersion:c,extInfo:{address:f}})}async collectReward({poolInfo:e,ownerInfo:t,rewardMint:n,associatedOnly:i=!0,checkCreateATAOwner:s=!1,computeBudgetConfig:o,txTipConfig:r,txVersion:a,feePayer:c}){let l=e.rewardDefaultInfos.find(g=>g.mint.address===n.toString());l||this.logAndCreateError("reward mint error","not found reward mint",n);let d=this.createTxBuilder(c),f=t.useSOLBalance&&n.equals(Q),{account:u,instructionParams:m}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:new R(l.mint.programId),mint:n,notUseTokenAccount:f,owner:this.scope.ownerPubKey,skipCloseAccount:!f,createInfo:{payer:t.feePayer||this.scope.ownerPubKey,amount:0},associatedOnly:f?!1:i,checkCreateATAOwner:s});m&&d.addInstruction(m),u||this.logAndCreateError("no money","ownerRewardAccount",this.scope.account.tokenAccountRawInfos);let p=await this.getClmmPoolKeys(e.id),b=ce.collectRewardInstructions({poolInfo:e,poolKeys:p,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccount:u},rewardMint:n});return d.addInstruction(b),d.addCustomComputeBudget(o),d.addTipInstruction(r),d.versionBuild({txVersion:a,extInfo:{address:b.address}})}async collectRewards({poolInfo:e,ownerInfo:t,rewardMints:n,associatedOnly:i=!0,checkCreateATAOwner:s=!1,computeBudgetConfig:o,txTipConfig:r,feePayer:a}){let c=this.createTxBuilder(a),l={};for(let d of n){let f=e.rewardDefaultInfos.find(w=>w.mint.address===d.toString());if(!f){this.logAndCreateError("reward mint error","not found reward mint",d);continue}let u=t.useSOLBalance&&d.equals(Q),{account:m,instructionParams:p}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:new R(f.mint.programId),mint:d,notUseTokenAccount:u,owner:this.scope.ownerPubKey,skipCloseAccount:!u,createInfo:{payer:t.feePayer||this.scope.ownerPubKey,amount:0},associatedOnly:u?!1:i,checkCreateATAOwner:s});m||this.logAndCreateError("no money","ownerRewardAccount",this.scope.account.tokenAccountRawInfos),p&&c.addInstruction(p);let b=await this.getClmmPoolKeys(e.id),g=ce.collectRewardInstructions({poolInfo:e,poolKeys:b,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccount:m},rewardMint:d});c.addInstruction(g),l=O(O({},l),g.address)}return c.addCustomComputeBudget(o),c.addTipInstruction(r),c.build({address:l})}async swap({poolInfo:e,poolKeys:t,inputMint:n,amountIn:i,amountOutMin:s,priceLimit:o,observationId:r,ownerInfo:a,remainingAccounts:c,associatedOnly:l=!0,checkCreateATAOwner:d=!1,txVersion:f,computeBudgetConfig:u,txTipConfig:m,feePayer:p}){let b=this.createTxBuilder(p),g=n.toString()===e.mintA.address,w=a.useSOLBalance&&e.mintA.address===Q.toBase58(),k=a.useSOLBalance&&e.mintB.address===Q.toBase58(),T;!o||o.equals(new gt(0))?T=g?Ge.add(new Ke(1)):Ue.sub(new Ke(1)):T=V.priceToSqrtPriceX64(o,e.mintA.decimals,e.mintB.decimals);let A;if(!A){let{account:h,instructionParams:B}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:e.mintA.programId,mint:new R(e.mintA.address),notUseTokenAccount:w,owner:this.scope.ownerPubKey,skipCloseAccount:!w,createInfo:w||!g?{payer:a.feePayer||this.scope.ownerPubKey,amount:g?i:0}:void 0,associatedOnly:w?!1:l,checkCreateATAOwner:d});A=h,B&&b.addInstruction(B)}let P;if(!P){let{account:h,instructionParams:B}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:e.mintB.programId,mint:new R(e.mintB.address),notUseTokenAccount:k,owner:this.scope.ownerPubKey,skipCloseAccount:!k,createInfo:k||g?{payer:a.feePayer||this.scope.ownerPubKey,amount:g?0:i}:void 0,associatedOnly:k?!1:l,checkCreateATAOwner:d});P=h,B&&b.addInstruction(B)}(!A||!P)&&this.logAndCreateError("user do not have token account",{tokenA:e.mintA.symbol||e.mintA.address,tokenB:e.mintB.symbol||e.mintB.address,ownerTokenAccountA:A,ownerTokenAccountB:P,mintAUseSOLBalance:w,mintBUseSOLBalance:k,associatedOnly:l});let x=t!=null?t:await this.getClmmPoolKeys(e.id);return b.addInstruction(ce.makeSwapBaseInInstructions({poolInfo:e,poolKeys:x,observationId:r,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccountA:A,tokenAccountB:P},inputMint:new R(n),amountIn:i,amountOutMin:s,sqrtPriceLimitX64:T,remainingAccounts:c})),b.addCustomComputeBudget(u),b.addTipInstruction(m),b.versionBuild({txVersion:f})}async swapBaseOut({poolInfo:e,poolKeys:t,outputMint:n,amountOut:i,amountInMax:s,priceLimit:o,observationId:r,ownerInfo:a,remainingAccounts:c,associatedOnly:l=!0,checkCreateATAOwner:d=!1,txVersion:f,computeBudgetConfig:u,txTipConfig:m,feePayer:p}){let b=this.createTxBuilder(p),g=n.toString()===e.mintB.address,w=a.useSOLBalance&&e.mintA.address===Q.toBase58(),k=a.useSOLBalance&&e.mintB.address===Q.toBase58(),T;!o||o.equals(new gt(0))?T=n.toString()===e.mintB.address?Ge.add(new Ke(1)):Ue.sub(new Ke(1)):T=V.priceToSqrtPriceX64(o,e.mintA.decimals,e.mintB.decimals);let A;if(!A){let{account:h,instructionParams:B}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:e.mintA.programId,mint:new R(e.mintA.address),notUseTokenAccount:w,owner:this.scope.ownerPubKey,skipCloseAccount:!w,createInfo:w||!g?{payer:a.feePayer||this.scope.ownerPubKey,amount:g?s:0}:void 0,associatedOnly:w?!1:l,checkCreateATAOwner:d});A=h,B&&b.addInstruction(B)}let P;if(!P){let{account:h,instructionParams:B}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:e.mintB.programId,mint:new R(e.mintB.address),notUseTokenAccount:k,owner:this.scope.ownerPubKey,skipCloseAccount:!k,createInfo:k||g?{payer:a.feePayer||this.scope.ownerPubKey,amount:g?0:s}:void 0,associatedOnly:k?!1:l,checkCreateATAOwner:d});P=h,B&&b.addInstruction(B)}(!A||!P)&&this.logAndCreateError("user do not have token account",{tokenA:e.mintA.symbol||e.mintA.address,tokenB:e.mintB.symbol||e.mintB.address,ownerTokenAccountA:A,ownerTokenAccountB:P,mintAUseSOLBalance:w,mintBUseSOLBalance:k,associatedOnly:l});let x=t!=null?t:await this.getClmmPoolKeys(e.id);return b.addInstruction(ce.makeSwapBaseOutInstructions({poolInfo:e,poolKeys:x,observationId:r,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccountA:A,tokenAccountB:P},outputMint:new R(n),amountOut:i,amountInMax:s,sqrtPriceLimitX64:T,remainingAccounts:c})),b.addCustomComputeBudget(u),b.addTipInstruction(m),b.versionBuild({txVersion:f})}async harvestAllRewards({allPoolInfo:e,allPositions:t,lockInfo:n,ownerInfo:i,associatedOnly:s=!0,checkCreateATAOwner:o=!1,programId:r,txVersion:a,computeBudgetConfig:c,feePayer:l,lockProgram:d=Mt,lockAuth:f=nn,clmmProgram:u=Nt}){var k,T;let m={};for(let A of this.scope.account.tokenAccountRawInfos)s?oe(this.scope.ownerPubKey,A.accountInfo.mint,r).publicKey.equals(A.pubkey)&&(m[A.accountInfo.mint.toString()]=A.pubkey):m[A.accountInfo.mint.toString()]=A.pubkey;let p=Object.values(t).flat().map(A=>A.nftMint),b=await Ze(this.scope.connection,p.map(A=>({pubkey:A}))),g={};b.forEach(A=>{var P,x;g[A.pubkey.toBase58()]=(x=(P=A==null?void 0:A.accountInfo)==null?void 0:P.owner)!=null?x:null});let w=this.createTxBuilder(l);for(let A of Object.values(e)){if(t[A.id]===void 0||!t[A.id].find(I=>!I.liquidity.isZero()||I.rewardInfos.find(F=>!F.rewardAmountOwed.isZero())))continue;let P=A,x=i.useSOLBalance&&P.mintA.address===Q.toString(),h=i.useSOLBalance&&P.mintB.address===Q.toString(),B=m[P.mintA.address];if(!B)if(x){let{account:I,instructionParams:F}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:P.mintA.programId,mint:new R(P.mintA.address),notUseTokenAccount:x,owner:this.scope.ownerPubKey,skipCloseAccount:!x,createInfo:{payer:i.feePayer||this.scope.ownerPubKey,amount:0},associatedOnly:x?!1:s,checkCreateATAOwner:o});B=I,F&&w.addInstruction(F)}else{let I=new R(P.mintA.address);B=this.scope.account.getAssociatedTokenAccount(I,new R(P.mintA.programId)),w.addInstruction({instructions:[Ui(this.scope.ownerPubKey,B,this.scope.ownerPubKey,I,new R(P.mintA.programId))]})}let K=m[P.mintB.address];if(!K)if(h){let{account:I,instructionParams:F}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:P.mintB.programId,mint:new R(P.mintB.address),notUseTokenAccount:h,owner:this.scope.ownerPubKey,skipCloseAccount:!h,createInfo:{payer:i.feePayer||this.scope.ownerPubKey,amount:0},associatedOnly:h?!1:s,checkCreateATAOwner:o});K=I,F&&w.addInstruction(F)}else{let I=new R(P.mintB.address);K=this.scope.account.getAssociatedTokenAccount(I,new R(P.mintB.programId)),w.addInstruction({instructions:[Ui(this.scope.ownerPubKey,K,this.scope.ownerPubKey,I,new R(P.mintB.programId))]})}m[P.mintA.address]=B,m[P.mintB.address]=K;let L=[];for(let I of P.rewardDefaultInfos){let F=i.useSOLBalance&&I.mint.address===Q.toString(),q=m[I.mint.address];if(!q){let{account:ue,instructionParams:fe}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:new R(I.mint.programId),mint:new R(I.mint.address),notUseTokenAccount:F,owner:this.scope.ownerPubKey,skipCloseAccount:!F,createInfo:{payer:i.feePayer||this.scope.ownerPubKey,amount:0},associatedOnly:F?!1:s});q=ue,fe&&w.addInstruction(fe)}m[I.mint.address]=q,L.push(q)}let C=await this.getClmmPoolKeys(P.id),N=[];for(let I=0;I<C.rewardInfos.length;I++)N.push({poolRewardVault:new R(C.rewardInfos[I].vault),ownerRewardVault:L[I],rewardMint:new R(C.rewardInfos[I].mint.address)});for(let I of t[A.id]){let F=(k=n==null?void 0:n[A.id])==null?void 0:k[I.nftMint.toBase58()];if(F){let q=oe(this.scope.ownerPubKey,F.lockNftMint,Zt).publicKey,ue=M.getTickArrayStartIndexByTick(I.tickLower,C.config.tickSpacing),fe=M.getTickArrayStartIndexByTick(I.tickUpper,C.config.tickSpacing),{publicKey:Le}=z(new R(C.programId),F.poolId,ue),{publicKey:ze}=z(new R(C.programId),F.poolId,fe),{publicKey:ee}=Ve(new R(C.programId),F.poolId,I.tickLower,I.tickUpper),ie=kt(d,F.lockNftMint).publicKey,ve=ce.harvestLockPositionInstructionV2({programId:d,auth:f,lockPositionId:ie,clmmProgram:u,lockOwner:this.scope.ownerPubKey,lockNftMint:F.lockNftMint,lockNftAccount:q,positionNftAccount:F.nftAccount,positionId:F.positionId,poolId:F.poolId,protocolPosition:ee,vaultA:new R(C.vault.A),vaultB:new R(C.vault.B),tickArrayLower:Le,tickArrayUpper:ze,userVaultA:B,userVaultB:K,mintA:new R(C.mintA.address),mintB:new R(C.mintB.address),rewardAccounts:N,exTickArrayBitmap:ge(u,F.poolId).publicKey});w.addInstruction({instructions:[ve],instructionTypes:[re.ClmmHarvestLockPosition],lookupTableAddress:C.lookupTableAccount?[C.lookupTableAccount]:[]})}else{let q=ce.decreaseLiquidityInstructions({poolInfo:P,poolKeys:C,ownerPosition:I,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccountA:B,tokenAccountB:K,rewardAccounts:L},liquidity:new Ke(0),amountMinA:new Ke(0),amountMinB:new Ke(0),nft2022:(T=g[I.nftMint.toBase58()])==null?void 0:T.equals(ct)});w.addInstruction(q)}}}return a===0?w.sizeCheckBuildV0({computeBudgetConfig:c}):w.sizeCheckBuild({computeBudgetConfig:c})}async getWhiteListMint({programId:e}){let t=await this.scope.connection.getAccountInfo(Ut(e).publicKey);return t?Vi.decode(t.data).whitelistMints.filter(i=>!i.equals(R.default)):[]}async getOwnerPositionInfo({programId:e=Nt}){await this.scope.account.fetchWalletTokenAccounts();let n=this.scope.account.tokenAccountRawInfos.filter(o=>o.accountInfo.amount.eq(new Ke(1))).map(o=>Ce(new R(e),o.accountInfo.mint).publicKey),i=await this.scope.connection.getMultipleAccountsInfo(n),s=[];return i.forEach(o=>{if(!o)return;let r=ht.decode(o.data);s.push(r)}),s}async getOwnerLockedPositionInfo({programId:e=Mt}){await this.scope.account.fetchWalletTokenAccounts();let n=this.scope.account.tokenAccountRawInfos.filter(a=>a.accountInfo.amount.eq(new Ke(1))).map(a=>kt(new R(e),a.accountInfo.mint).publicKey),i=await this.scope.connection.getMultipleAccountsInfo(n),s=[];i.forEach(a=>{if(!a)return;let c=vi.decode(a.data);s.push(c)});let o=await this.scope.connection.getMultipleAccountsInfo(s.map(a=>a.positionId)),r=[];return o.forEach(a=>{if(!a)return;let c=ht.decode(a.data);r.push(c)}),s.map((a,c)=>({position:r[c],lockInfo:a}))}async getRpcClmmPoolInfo({poolId:e}){return(await this.getRpcClmmPoolInfos({poolIds:[e]}))[String(e)]}async getRpcClmmPoolInfos({poolIds:e,config:t}){let n=await Ze(this.scope.connection,e.map(s=>({pubkey:new R(s)})),t),i={};for(let s=0;s<e.length;s++){let o=n[s];if(o===null||!o.accountInfo)throw Error("fetch pool info error: "+String(e[s]));let r=mn.decode(o.accountInfo.data),a=V.sqrtPriceX64ToPrice(r.sqrtPriceX64,r.mintDecimalsA,r.mintDecimalsB).toNumber();i[String(e[s])]=U(O({},r),{currentPrice:a,programId:o.accountInfo.owner})}return i}async getComputeClmmPoolInfos({clmmPoolsRpcInfo:e,mintInfos:t}){let n=new Set(Object.keys(e).map(a=>e[a].ammConfig.toBase58())),i=await Ze(this.scope.connection,Array.from(n).map(a=>({pubkey:new R(a)}))),s={};i.forEach(a=>{!a.accountInfo||(s[a.pubkey.toBase58()]=Ei.decode(a.accountInfo.data))});let o=await pe.fetchComputeMultipleClmmInfo({connection:this.scope.connection,rpcDataMap:e,poolList:Object.keys(e).map(a=>{var d,f,u,m;let[c,l]=[e[a].mintA.toBase58(),e[a].mintB.toBase58()];return{id:a,programId:e[a].programId.toBase58(),mintA:sn({address:c,decimals:e[a].mintDecimalsA,programId:t[c].programId.toBase58()||Zt.toBase58(),extensions:{feeConfig:(d=t[c])!=null&&d.feeConfig?Kn((f=t[c])==null?void 0:f.feeConfig):void 0}}),mintB:sn({address:l,decimals:e[a].mintDecimalsB,programId:t[l].programId.toBase58()||Zt.toBase58(),extensions:{feeConfig:(u=t[l])!=null&&u.feeConfig?Kn((m=t[l])==null?void 0:m.feeConfig):void 0}}),price:e[a].currentPrice,config:U(O({},s[e[a].ammConfig.toBase58()]),{id:e[a].ammConfig.toBase58(),fundFeeRate:0,description:"",defaultRange:0,defaultRangePoint:[]})}})}),r=await pe.fetchMultiplePoolTickArrays({connection:this.scope.connection,poolKeys:Object.values(o)});return{computeClmmPoolInfo:o,computePoolTickData:r}}async getPoolInfoFromRpc(e){var l;let t=await this.getRpcClmmPoolInfo({poolId:e}),n=new Set([t.mintA.toBase58(),t.mintB.toBase58()]),i=await $n({connection:this.scope.connection,mints:Array.from(n).map(d=>new R(d))}),{computeClmmPoolInfo:s,computePoolTickData:o}=await this.scope.clmm.getComputeClmmPoolInfos({clmmPoolsRpcInfo:{[e]:t},mintInfos:i}),r=await Ze(this.scope.connection,[{pubkey:t.vaultA},{pubkey:t.vaultB}]),a=Oi(s[e]);if(!r[0].accountInfo||!r[1].accountInfo)throw new Error("pool vault data not found");a.mintAmountA=Number(Gi.decode(r[0].accountInfo.data).amount.toString()),a.mintAmountB=Number(Gi.decode((l=r[1].accountInfo)==null?void 0:l.data).amount.toString());let c=U(O({},s[e]),{exBitmapAccount:s[e].exBitmapAccount.toBase58(),observationId:s[e].observationId.toBase58(),id:e,programId:t.programId.toBase58(),openTime:t.startTime.toString(),vault:{A:t.vaultA.toBase58(),B:t.vaultB.toBase58()},config:a.config,rewardInfos:s[e].rewardInfos.filter(d=>!d.tokenVault.equals(R.default)).map(d=>({mint:sn({address:d.tokenMint.toBase58(),programId:Zt.toBase58(),decimals:10}),vault:d.tokenVault.toBase58()}))});return{poolInfo:a,poolKeys:c,computePoolInfo:s[e],tickData:o}}};export{Wr as AMM_CONFIG_SEED,Ai as BIT_PRECISION,Xn as Clmm,Ei as ClmmConfigLayout,ce as ClmmInstrument,Wn as EXTENSION_TICKARRAY_BITMAP_SIZE,un as FEE_RATE_DENOMINATOR,Yr as FETCH_TICKARRAY_COUNT,_r as Fee,Ti as LOG_B_2_X32,ki as LOG_B_P_ERR_MARGIN_LOWER_X64,hi as LOG_B_P_ERR_MARGIN_UPPER_X64,j as LiquidityMath,vi as LockClPositionLayoutV2,Km as LockPositionLayout,Ue as MAX_SQRT_PRICE_X64,ul as MAX_SQRT_PRICE_X64_SUB_ONE,Se as MAX_TICK,Ge as MIN_SQRT_PRICE_X64,cl as MIN_SQRT_PRICE_X64_ADD_ONE,Be as MIN_TICK,v as MathUtil,On as MaxU64,wi as MaxUint128,et as NEGATIVE_ONE,jr as OBSERVATION_SEED,qe as ONE,Hr as OPERATION_SEED,Di as ObservationInfoLayout,$r as ObservationLayout,Vi as OperationLayout,Ni as POOL_LOCK_ID_SEED,Ur as POOL_REWARD_VAULT_SEED,qr as POOL_SEED,zr as POOL_TICK_ARRAY_BITMAP_SEED,Gr as POOL_VAULT_SEED,Ci as POSITION_SEED,mn as PoolInfoLayout,pe as PoolUtils,ht as PositionInfoLayout,to as PositionRewardInfoLayout,Xt as PositionUtils,Cm as ProtocolPositionLayout,cn as Q128,Ne as Q64,eo as RewardInfo,Zr as SUPPORT_MINT_SEED,V as SqrtPriceMath,yt as SwapMath,ft as TICK_ARRAY_BITMAP_SIZE,Xr as TICK_ARRAY_SEED,Pe as TICK_ARRAY_SIZE,ll as TICK_SPACINGS,tt as TickArrayBitmap,Fi as TickArrayBitmapExtensionLayout,zt as TickArrayBitmapExtensionUtils,Ht as TickArrayLayout,no as TickLayout,bt as TickMath,Y as TickQuery,M as TickUtils,Wt as U64Resolution,dl as U64_IGNORE_RANGE,H as ZERO,Oi as clmmComputeInfoToApiInfo,rm as getLiquidityFromAmounts,wl as getPdaAmmConfigId,ge as getPdaExBitmapAccount,kt as getPdaLockClPositionIdV2,Vn as getPdaLockPositionId,Gt as getPdaMetadataKey,vn as getPdaMintExAccount,Ri as getPdaObservationAccount,Ut as getPdaOperationAccount,Ce as getPdaPersonalPositionAddress,Ki as getPdaPoolId,Li as getPdaPoolRewardVaulId,Dn as getPdaPoolVaultId,Ve as getPdaProtocolPositionAddress,z as getPdaTickArrayAddress,fl as i16ToBytes,ln as i32ToBytes,qt as isZero,Fn as leadingZeros,Si as leastSignificantBit,ml as mockCreatePoolInfo,xi as mockV3CreatePoolInfo,Ii as mostSignificantBit,En as trailingZeros,Bi as u16ToBytes,yl as u32ToBytes};
//# sourceMappingURL=index.mjs.map