var zi=Object.defineProperty,Yi=Object.defineProperties;var ji=Object.getOwnPropertyDescriptors;var Zt=Object.getOwnPropertySymbols;var jn=Object.prototype.hasOwnProperty,Zn=Object.prototype.propertyIsEnumerable;var Yn=(y,e,t)=>e in y?zi(y,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):y[e]=t,O=(y,e)=>{for(var t in e||(e={}))jn.call(e,t)&&Yn(y,t,e[t]);if(Zt)for(var t of Zt(e))Zn.call(e,t)&&Yn(y,t,e[t]);return y},U=(y,e)=>Yi(y,ji(e));var lt=(y,e)=>{var t={};for(var n in y)jn.call(y,n)&&e.indexOf(n)<0&&(t[n]=y[n]);if(y!=null&&Zt)for(var n of Zt(y))e.indexOf(n)<0&&Zn.call(y,n)&&(t[n]=y[n]);return t};import{PublicKey as L}from"@solana/web3.js";import Ke from"bn.js";import Pt from"decimal.js";import{PublicKey as $n}from"@solana/web3.js";import{get as Qn,set as Zi}from"lodash";var pn=class{constructor(e){this.logLevel=e.logLevel!==void 0?e.logLevel:0,this.name=e.name}set level(e){this.logLevel=e}get time(){return Date.now().toString()}get moduleName(){return this.name}isLogLevel(e){return e<=this.logLevel}error(...e){return this.isLogLevel(0)?(console.error(this.time,this.name,"sdk logger error",...e),this):this}logWithError(...e){let t=e.map(n=>typeof n=="object"?JSON.stringify(n):n).join(", ");throw new Error(t)}warning(...e){return this.isLogLevel(1)?(console.warn(this.time,this.name,"sdk logger warning",...e),this):this}info(...e){return this.isLogLevel(2)?(console.info(this.time,this.name,"sdk logger info",...e),this):this}debug(...e){return this.isLogLevel(3)?(console.debug(this.time,this.name,"sdk logger debug",...e),this):this}},Jn={},Qi={};function Ae(y){let e=Qn(Jn,y);if(!e){let t=Qn(Qi,y);e=new pn({name:y,logLevel:t}),Zi(Jn,y,e)}return e}import{MINT_SIZE as Ji,TOKEN_PROGRAM_ID as $i,getTransferFeeConfig as er,unpackMint as tr}from"@solana/spl-token";var fn=Ae("Raydium_accountInfo_util");async function Ye(y,e,t){let{batchRequest:n,commitment:i="confirmed",chunkCount:s=100}=O({batchRequest:!1},t),o=yn(e,s),r=new Array(o.length).fill([]);if(n){let a=o.map(d=>{let f=y._buildArgs([d.map(u=>u.toBase58())],i,"base64");return{methodName:"getMultipleAccounts",args:f}}),c=yn(a,10);r=(await(await Promise.all(c.map(async d=>await y._rpcBatchRequest(d)))).flat()).map(d=>(d.error&&fn.logWithError(`failed to get info for multiple accounts, RPC_ERROR, ${d.error.message}`),d.result.value.map(f=>{if(f){let{data:u,executable:m,lamports:p,owner:b,rentEpoch:g}=f;return u.length!==2&&u[1]!=="base64"&&fn.logWithError("info must be base64 encoded, RPC_ERROR"),{data:Buffer.from(u[0],"base64"),executable:m,lamports:p,owner:new $n(b),rentEpoch:g}}return null})))}else try{r=await Promise.all(o.map(a=>y.getMultipleAccountsInfo(a,i)))}catch(a){a instanceof Error&&fn.logWithError(`failed to get info for multiple accounts, RPC_ERROR, ${a.message}`)}return r.flat()}async function je(y,e,t){let n=await Ye(y,e.map(i=>i.pubkey),t);return e.map((i,s)=>U(O({},i),{accountInfo:n[s]}))}async function ei({connection:y,mints:e,config:t}){var s,o,r;if(e.length===0)return{};let n=await je(y,e.map(a=>({pubkey:mt(a)})),t),i={};for(let a of n){if(!a.accountInfo||a.accountInfo.data.length<Ji){console.log("invalid mint account",a.pubkey.toBase58());continue}let c=tr(a.pubkey,a.accountInfo,(s=a.accountInfo)==null?void 0:s.owner);i[a.pubkey.toString()]=U(O({},c),{programId:((o=a.accountInfo)==null?void 0:o.owner)||$i,feeConfig:(r=er(c))!=null?r:void 0})}return i[$n.default.toBase58()]=i[Q.toBase58()],i}import Ze from"bn.js";import Ws from"decimal.js";import ur from"big.js";import $t from"bn.js";import nr from"toformat";var ir=nr,It=ir;import Jt from"big.js";import or from"bn.js";import sr from"decimal.js-light";import St from"bn.js";var ti=9007199254740991;function we(y){let e=Ae("Raydium_parseBigNumberish");if(y instanceof St)return y;if(typeof y=="string"){if(y.match(/^-?[0-9]+$/))return new St(y);e.logWithError(`invalid BigNumberish string: ${y}`)}return typeof y=="number"?(y%1&&e.logWithError(`BigNumberish number underflow: ${y}`),(y>=ti||y<=-ti)&&e.logWithError(`BigNumberish number overflow: ${y}`),new St(String(y))):typeof y=="bigint"?new St(y.toString()):(e.error(`invalid BigNumberish value: ${y}`),new St(0))}var Qt=Ae("module/fraction"),bn=It(Jt),Ct=It(sr),ar={[0]:Ct.ROUND_DOWN,[1]:Ct.ROUND_HALF_UP,[2]:Ct.ROUND_UP},cr={[0]:Jt.roundDown,[1]:Jt.roundHalfUp,[2]:Jt.roundUp},J=class{constructor(e,t=new or(1)){this.numerator=we(e),this.denominator=we(t)}get quotient(){return this.numerator.div(this.denominator)}invert(){return new J(this.denominator,this.numerator)}add(e){let t=e instanceof J?e:new J(we(e));return this.denominator.eq(t.denominator)?new J(this.numerator.add(t.numerator),this.denominator):new J(this.numerator.mul(t.denominator).add(t.numerator.mul(this.denominator)),this.denominator.mul(t.denominator))}sub(e){let t=e instanceof J?e:new J(we(e));return this.denominator.eq(t.denominator)?new J(this.numerator.sub(t.numerator),this.denominator):new J(this.numerator.mul(t.denominator).sub(t.numerator.mul(this.denominator)),this.denominator.mul(t.denominator))}mul(e){let t=e instanceof J?e:new J(we(e));return new J(this.numerator.mul(t.numerator),this.denominator.mul(t.denominator))}div(e){let t=e instanceof J?e:new J(we(e));return new J(this.numerator.mul(t.denominator),this.denominator.mul(t.numerator))}toSignificant(e,t={groupSeparator:""},n=1){Number.isInteger(e)||Qt.logWithError(`${e} is not an integer.`),e<=0&&Qt.logWithError(`${e} is not positive.`),Ct.set({precision:e+1,rounding:ar[n]});let i=new Ct(this.numerator.toString()).div(this.denominator.toString()).toSignificantDigits(e);return i.toFormat(i.decimalPlaces(),t)}toFixed(e,t={groupSeparator:""},n=1){return Number.isInteger(e)||Qt.logWithError(`${e} is not an integer.`),e<0&&Qt.logWithError(`${e} is negative.`),bn.DP=e,bn.RM=cr[n]||1,new bn(this.numerator.toString()).div(this.denominator.toString()).toFormat(e,t)}isZero(){return this.numerator.isZero()}};var lr=Ae("Raydium_amount"),ni=It(ur);function mr(y,e){let t="0",n="0";if(y.includes(".")){let i=y.split(".");i.length===2?([t,n]=i,n=n.padEnd(e,"0")):lr.logWithError(`invalid number string, num: ${y}`)}else t=y;return[t,n.slice(0,e)||n]}var ke=class extends J{constructor(t,n,i=!0,s){let o=new $t(0),r=gn.pow(new $t(t.decimals));if(i)o=we(n);else{let a=new $t(0),c=new $t(0);if(typeof n=="string"||typeof n=="number"||typeof n=="bigint"){let[l,d]=mr(n.toString(),t.decimals);a=we(l),c=we(d)}a=a.mul(r),o=a.add(c)}super(o,r);this.logger=Ae(s||"TokenAmount"),this.token=t}get raw(){return this.numerator}isZero(){return this.raw.isZero()}gt(t){return this.token.equals(t.token)||this.logger.logWithError("gt token not equals"),this.raw.gt(t.raw)}lt(t){return this.token.equals(t.token)||this.logger.logWithError("lt token not equals"),this.raw.lt(t.raw)}add(t){return this.token.equals(t.token)||this.logger.logWithError("add token not equals"),new ke(this.token,this.raw.add(t.raw))}subtract(t){return this.token.equals(t.token)||this.logger.logWithError("sub token not equals"),new ke(this.token,this.raw.sub(t.raw))}toSignificant(t=this.token.decimals,n,i=0){return super.toSignificant(t,n,i)}toFixed(t=this.token.decimals,n,i=0){return t>this.token.decimals&&this.logger.logWithError("decimals overflow"),super.toFixed(t,n,i)}toExact(t={groupSeparator:""}){return ni.DP=this.token.decimals,new ni(this.numerator.toString()).div(this.denominator.toString()).toFormat(t)}};import{PublicKey as dr}from"@solana/web3.js";import{TOKEN_PROGRAM_ID as ii}from"@solana/spl-token";var Pn={chainId:101,address:dr.default.toBase58(),programId:ii.toBase58(),decimals:9,symbol:"SOL",name:"solana",logoURI:"https://img-v1.raydium.io/icon/So11111111111111111111111111111111111111112.png",tags:[],priority:2,type:"raydium",extensions:{coingeckoId:"solana"}},it={chainId:101,address:"So11111111111111111111111111111111111111112",programId:ii.toBase58(),decimals:9,symbol:"WSOL",name:"Wrapped SOL",logoURI:"https://img-v1.raydium.io/icon/So11111111111111111111111111111111111111112.png",tags:[],priority:2,type:"raydium",extensions:{coingeckoId:"solana"}};import{PublicKey as kn}from"@solana/web3.js";import{PublicKey as le,SystemProgram as ri,SYSVAR_RENT_PUBKEY as pr}from"@solana/web3.js";import{TOKEN_PROGRAM_ID as fr}from"@solana/spl-token";function wn({pubkey:y,isSigner:e=!1,isWritable:t=!0}){return{pubkey:y,isWritable:t,isSigner:e}}var Ho=[wn({pubkey:fr,isWritable:!1}),wn({pubkey:ri.programId,isWritable:!1}),wn({pubkey:pr,isWritable:!1})];function Tn({publicKey:y,transformSol:e}){let t=oi(y.toString());if(t instanceof le)return e&&t.equals(Kt)?Q:t;if(e&&t.toString()===Kt.toBase58())return Q;if(typeof t=="string"){if(t===le.default.toBase58())return le.default;try{return new le(t)}catch{throw new Error("invalid public key")}}throw new Error("invalid public key")}function oi(y){try{return new le(y)}catch{return y}}var en=new le("MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr"),An=new le("MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr"),rt=new le("SysvarRent111111111111111111111111111111111"),zo=new le("SysvarC1ock11111111111111111111111111111111"),dt=new le("metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s"),Yo=new le("Sysvar1nstructions1111111111111111111111111"),jo=ri.programId,Zo=new le("4k3Dyjzvzp8eMZWUXbBCjEvwSkkk59S5iCNLY3QrkX6R"),Qo=new le("Ea5SjE2Y6yvCeW5dYTn7PYMuW5ikXkvbGdcmSnXeaLjS"),Jo=new le("SRMuApVNdxXokk5GT7XD5cUUgXMBCoAz2LHeuAoKWRt"),$o=new le("EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v"),es=new le("Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB"),ts=new le("mSoLzYCxHdYgdzU16g5QSh3i5K3z3KZK7ytfqcJm7So"),ns=new le("7dHbWXmci3dT8UFYWYZweBLXgycu7Y3iL6trKn1Y7ARj"),is=new le("USDH1SM1ojwWUga67PGrgFWUHibbjqMvuMaDkRJTgkX"),rs=new le("NRVwhjBQiUPYtfDT5zRBVJajzFQHaBUNtC7SNVvqRFa"),os=new le("ANAxByE6G2WjFp7A4NqtWYXb3mgruyzZYg3spfxe6Lbo"),ss=new le("7vfCXTUXx5WJV5JADk17DUJ4ksgau7utNKj4b963voxs"),Q=new le("So11111111111111111111111111111111111111112"),Kt=le.default;function mt(y){return Tn({publicKey:y,transformSol:!0})}var hn=class{constructor({mint:e,decimals:t,symbol:n,name:i,skipMint:s=!1,isToken2022:o=!1}){if(e===Kt.toBase58()||e instanceof kn&&Kt.equals(e)){this.decimals=it.decimals,this.symbol=it.symbol,this.name=it.name,this.mint=new kn(it.address),this.isToken2022=!1;return}this.decimals=t,this.symbol=n||e.toString().substring(0,6),this.name=i||e.toString().substring(0,6),this.mint=s?kn.default:Tn({publicKey:e}),this.isToken2022=o}equals(e){return this===e?!0:this.mint.equals(e.mint)}},ve=hn;ve.WSOL=new hn(U(O({},it),{mint:it.address}));var xn=class{constructor({decimals:e,symbol:t="UNKNOWN",name:n="UNKNOWN"}){this.decimals=e,this.symbol=t,this.name=n}equals(e){return this===e}},tn=xn;tn.SOL=new xn(Pn);import yr from"bn.js";var si=new J(new yr(100)),ot=class extends J{toSignificant(e=5,t,n){return this.mul(si).toSignificant(e,t,n)}toFixed(e=2,t,n){return this.mul(si).toFixed(e,t,n)}};var br=Ae("Raydium_price"),Ee=class extends J{constructor(t){let{baseToken:n,quoteToken:i,numerator:s,denominator:o}=t;super(s,o);this.baseToken=n,this.quoteToken=i,this.scalar=new J(Bn(n.decimals),Bn(i.decimals))}get raw(){return new J(this.numerator,this.denominator)}get adjusted(){return super.mul(this.scalar)}invert(){return new Ee({baseToken:this.quoteToken,quoteToken:this.baseToken,denominator:this.numerator,numerator:this.denominator})}mul(t){this.quoteToken!==t.baseToken&&br.logWithError("mul token not equals");let n=super.mul(t);return new Ee({baseToken:this.baseToken,quoteToken:t.quoteToken,denominator:n.denominator,numerator:n.numerator})}toSignificant(t=this.quoteToken.decimals,n,i){return this.adjusted.toSignificant(t,n,i)}toFixed(t=this.quoteToken.decimals,n,i){return this.adjusted.toFixed(t,n,i)}};var gr=new Ze(0),Zs=new Ze(1),Qs=new Ze(2),Js=new Ze(3),$s=new Ze(5),gn=new Ze(10),ea=new Ze(100),ta=new Ze(1e3),na=new Ze(1e4);function Bn(y){return gn.pow(we(y))}function yn(y,e=1,t=[]){let n=[...y];if(e<=0)return t;for(;n.length;)t.push(n.splice(0,e));return t}var We=class{constructor(e){this._owner=e}get publicKey(){return We.isKeyPair(this._owner)?this._owner.publicKey:this._owner}get signer(){return We.isKeyPair(this._owner)?this._owner:void 0}get isKeyPair(){return We.isKeyPair(this._owner)}get isPublicKey(){return We.isPublicKey(this._owner)}static isKeyPair(e){return e.secretKey!==void 0}static isPublicKey(e){return!We.isKeyPair(e)}};import{PublicKey as xr}from"@solana/web3.js";import{TOKEN_PROGRAM_ID as Br}from"@solana/spl-token";import{ComputeBudgetProgram as ai,Keypair as ui,PublicKey as Pr,Transaction as li,TransactionMessage as wr,VersionedTransaction as mi}from"@solana/web3.js";var re={CreateAccount:"CreateAccount",InitAccount:"InitAccount",CreateATA:"CreateATA",CloseAccount:"CloseAccount",TransferAmount:"TransferAmount",InitMint:"InitMint",MintTo:"MintTo",InitMarket:"InitMarket",Util1216OwnerClaim:"Util1216OwnerClaim",SetComputeUnitPrice:"SetComputeUnitPrice",SetComputeUnitLimit:"SetComputeUnitLimit",ClmmCreatePool:"ClmmCreatePool",ClmmOpenPosition:"ClmmOpenPosition",ClmmIncreasePosition:"ClmmIncreasePosition",ClmmDecreasePosition:"ClmmDecreasePosition",ClmmClosePosition:"ClmmClosePosition",ClmmSwapBaseIn:"ClmmSwapBaseIn",ClmmSwapBaseOut:"ClmmSwapBaseOut",ClmmInitReward:"ClmmInitReward",ClmmSetReward:"ClmmSetReward",ClmmCollectReward:"ClmmCollectReward",ClmmLockPosition:"ClmmLockPosition",ClmmHarvestLockPosition:"ClmmHarvestLockPosition",AmmV4Swap:"AmmV4Swap",AmmV4AddLiquidity:"AmmV4AddLiquidity",AmmV4RemoveLiquidity:"AmmV4RemoveLiquidity",AmmV4SimulatePoolInfo:"AmmV4SimulatePoolInfo",AmmV4SwapBaseIn:"AmmV4SwapBaseIn",AmmV4SwapBaseOut:"AmmV4SwapBaseOut",AmmV4CreatePool:"AmmV4CreatePool",AmmV4InitPool:"AmmV4InitPool",AmmV5AddLiquidity:"AmmV5AddLiquidity",AmmV5RemoveLiquidity:"AmmV5RemoveLiquidity",AmmV5SimulatePoolInfo:"AmmV5SimulatePoolInfo",AmmV5SwapBaseIn:"AmmV5SwapBaseIn",AmmV5SwapBaseOut:"AmmV5SwapBaseOut",RouteSwap:"RouteSwap",RouteSwap1:"RouteSwap1",RouteSwap2:"RouteSwap2",FarmV3Deposit:"FarmV3Deposit",FarmV3Withdraw:"FarmV3Withdraw",FarmV3CreateLedger:"FarmV3CreateLedger",FarmV4Withdraw:"FarmV4Withdraw",FarmV5Deposit:"FarmV5Deposit",FarmV5Withdraw:"FarmV5Withdraw",FarmV5CreateLedger:"FarmV5CreateLedger",FarmV6Deposit:"FarmV6Deposit",FarmV6Withdraw:"FarmV6Withdraw",FarmV6Create:"FarmV6Create",FarmV6Restart:"FarmV6Restart",FarmV6CreatorAddReward:"FarmV6CreatorAddReward",FarmV6CreatorWithdraw:"FarmV6CreatorWithdraw",CpmmCreatePool:"CpmmCreatePool",CpmmAddLiquidity:"CpmmAddLiquidity",CpmmWithdrawLiquidity:"CpmmWithdrawLiquidity",CpmmSwapBaseIn:"CpmmSwapBaseIn",CpmmSwapBaseOut:"CpmmSwapBaseOut",CpmmLockLp:"CpmmLockLp",CpmmCollectLockFee:"CpmmCollectLockFee",TransferTip:"TransferTip"};import{TOKEN_PROGRAM_ID as Tr}from"@solana/spl-token";var ci=Ae("Raydium_txUtil"),di=1644;function Rt(y){let e=[],t=[];return y.microLamports&&(e.push(ai.setComputeUnitPrice({microLamports:y.microLamports})),t.push(re.SetComputeUnitPrice)),y.units&&(e.push(ai.setComputeUnitLimit({units:y.units})),t.push(re.SetComputeUnitLimit)),{instructions:e,instructionTypes:t}}async function pt(y,e){var n,i;let t=e!=null?e:"confirmed";return(i=await((n=y.getLatestBlockhash)==null?void 0:n.call(y,{commitment:t})))==null?void 0:i.blockhash}async function Lt(y,e){return y.getSignatureStatuses([e]),new Promise((t,n)=>{let i=setTimeout(n,6e4);y.onSignature(e,s=>{if(clearTimeout(i),!s.err){t("");return}n(Object.assign(s.err,{txId:e}))},"confirmed")})}function Ar(y,e){y.length<1&&ci.logWithError(`no instructions provided: ${y.toString()}`),e.length<1&&ci.logWithError(`no signers provided:, ${e.toString()}`);let t=new li;t.recentBlockhash="11111111111111111111111111111111",t.feePayer=e[0],t.add(...y);try{return Buffer.from(t.serialize({verifySignatures:!1})).toString("base64").length<di}catch{return!1}}function he(y,e){let[t,n]=Pr.findProgramAddressSync(y,e);return{publicKey:t,nonce:n}}function Nt({instructions:y,payer:e,signers:t}){return Ar(y,[e,...t])}function Qe({instructions:y,payer:e,lookupTableAddressAccount:t,recentBlockhash:n=ui.generate().publicKey.toString()}){let s=new wr({payerKey:e,recentBlockhash:n,instructions:y}).compileToV0Message(Object.values(t!=null?t:{}));try{return Buffer.from(new mi(s).serialize()).toString("base64").length<di}catch{return!1}}var kr=y=>Buffer.isBuffer(y)?y:y instanceof Uint8Array?Buffer.from(y.buffer,y.byteOffset,y.byteLength):Buffer.from(y),hr=y=>{let e=y.serialize({requireAllSignatures:!1,verifySignatures:!1});y instanceof mi&&(e=kr(e));try{return e instanceof Buffer?e.toString("base64"):Buffer.from(e).toString("base64")}catch{return e.toString("base64")}};function st(y){let e=[];return y.forEach(t=>{t instanceof li&&(t.recentBlockhash||(t.recentBlockhash=Tr.toBase58()),t.feePayer||(t.feePayer=ui.generate().publicKey)),e.push(hr(t))}),console.log("simulate tx string:",e),e}function oe(y,e,t){return he([y.toBuffer(),(t!=null?t:Br).toBuffer(),e.toBuffer()],new xr("ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL"))}import{PublicKey as D}from"@solana/web3.js";var ha=new D("EhhTKczWMGQt46ynNeRX1WfeagwwJd7ufHvCDjRxjo5Q"),xa=new D("CBuCnLe26faBpcBP2fktp4rp8abpcAnTWft6ZrP5Q4T"),Ba=new D("9KEPoZmtHUrBbhWN1v1KWLMkkvwY6WLtAVUCPRtRjP4z"),Ia=new D("FarmqiPv5eAj3j1GMdMCMUGXqPUvmquZtMy86QH6rzhG"),Sa=new D("CLaimxFqjHzgTJtAGHU47NPhg6qrc5sCnpC4tBLyABQS"),Ca=new D("srmqPvymJeFKQ4zGQed1GFppgkRHL9kaELCbyksJtPX"),Ka=new D("9xQeWvG816bUx9EPjHmaT23yvVM2ZWbrrpZb9PusVFin"),Ra=new D("675kPX9MHTjS2zt1qfr1NYHuzeLXfQM9H24wFSUt1Mp8"),La=new D("5quBtoiQqxF9Jv6KYKctB59NT3gtJD2Y65kdnB1Uev3h"),Na=new D("CDSr3ssLcRB6XYPJwAfFt18MZvEZp4LjHcvzBVZ45duo"),Mt=new D("CAMMCzo5YL8w4VFF8KVHrK22GGUsp5VTaW7grrKgrWqK"),Ot=new D("LockrWmn6K5twhz3y9w1dQERbmgSaRkfnTeTKbpofwE"),nn=new D("kN1kEznaF5Xbd8LYuqtEFcxzWSBk5Fv6ygX6SqEGJVy"),Ma=new D("CDSr3ssLcRB6XYPJwAfFt18MZvEZp4LjHcvzBVZ45duo"),Oa=new D("routeUGWgWzqBWFcrCfv8tritsqukccJPu3q5GPP3xS"),Fa=new D("7YttLkHDoNj9wyDur5pM1ejNaAvT9X4eqaYcHQqtj2G5"),Ea=new D("6FJon3QE27qgPVggARueB22hLvoh22VzJpXv4rBEoSLF"),Da=new D("CC12se5To1CdEuw7fDS27B7Geo5jJyL7t5UK2B44NgiH"),_a=new D("9HzJyW1qZsEiSfMUf6L2jo3CcTKAyBmSyKdwQeYisHrC"),Va=new D("DropEU8AvevN3UrXWXTMuz3rqnMczQVNjq3kcSdW2SQi"),va=new D("CPMMoo8L3F4NbTegBCKVNunggL7H1ZpdTHKxQB5qKP1C"),Wa=new D("GpMZbSM2GgvTKHJirzeGfMFoaZ8UR2X7F4v8vHTvxFbL"),qa=new D("DNXgeM9EiiaAbaWvwjHj9fQQLAX5ZsfHyvmYUNRAdNC8"),Ga=new D("LockrWmn6K5twhz3y9w1dQERbmgSaRkfnTeTKbpofwE"),Ua=new D("3f7GcQFG397GAaEnv51zR6tsTVihYRydnydDD1cXekxH"),Xa=new D("LanMV9sAd7wArD4vJFi2qDdfnVhFxYSUg6eADduJ3uj"),Ha=new D("WLHv2UAZm6z4KyaaELi5pjdbJh6RESMva1Rnn8pJVVh"),za=new D("DRay6fNdQ5J82H7xV6uq2aV3mNrUZ1J4PgSKsWgptcm6"),Ya=new D("5xqNaZXX5eUi4p5HU4oz9i5QnwRNT2y6oN7yyn4qENeq"),ja=new D("4Bu96XjU84XjPDSpveTVf6LYGCkfW5FK7SNkREWcEfV4"),Za=new D("6s1xP3hpbAfFoNtUNF8mfHsjr2Bd97JxFJRWLbL6aHuX");var Qa={OPEN_BOOK_PROGRAM:new D("EoTcMgcDRTJVZDMZWBoU6rhYHZfkNTVEAfz3uUJRcYGj"),SERUM_PROGRAM_ID_V3:new D("Ray1111111111111111111111111111111111111111"),AMM_V4:new D("DRaya7Kj3aMWQSy19kSjvmuwq9docCHofyP9kanQGaav"),AMM_STABLE:new D("DRayDdXc1NZQ9C3hRWmoSf8zK4iapgMnjdNZWrfwsP8m"),CLMM_PROGRAM_ID:new D("DRayAUgENGQBKVaX8owNhgzkEDyoHTGVEGHVJT1E9pfH"),CLMM_LOCK_PROGRAM_ID:new D("DRay25Usp3YJAi7beckgpGUC7mGJ2cR1AVPxhYfwVCUX"),CLMM_LOCK_AUTH_ID:new D("6Aoh8h2Lw2m5UGxYR8AdAL87jTWYeKoxM52mJRzfYwN"),CREATE_CPMM_POOL_PROGRAM:new D("DRaycpLY18LhpbydsBWbVJtxpNv9oXPgjRSfpF2bWpYb"),CREATE_CPMM_POOL_AUTH:new D("CXniRufdq5xL8t8jZAPxsPZDpuudwuJSPWnbcD5Y5Nxq"),CREATE_CPMM_POOL_FEE_ACC:new D("3oE58BKVt8KuYkGxx8zBojugnymWmBiyafWgMrnb6eYy"),LOCK_CPMM_PROGRAM:new D("DRay25Usp3YJAi7beckgpGUC7mGJ2cR1AVPxhYfwVCUX"),LOCK_CPMM_AUTH:new D("7qWVV8UY2bRJfDLP4s37YzBPKUkVB46DStYJBpYbQzu3"),UTIL1216:D.default,Router:new D("DRaybByLpbUL57LJARs3j8BitTxVfzBg351EaMr5UTCd"),FARM_PROGRAM_ID_V3:new D("DRayWyrLmEW5KEeqs8kdTMMaBabapqagaBC7KWpGtJeZ"),FARM_PROGRAM_ID_V4:new D("Ray1111111111111111111111111111111111111111"),FARM_PROGRAM_ID_V5:new D("DRayiCGSZgku1GTK6rXD6mVDdingXy6APAH1R6R5L2LC"),FARM_PROGRAM_ID_V6:new D("DRayzbYakXs45ELHkzH6vC3fuhQqTAnv5A68gdFuvZyZ"),LAUNCHPAD_PROGRAM:new D("DRay6fNdQ5J82H7xV6uq2aV3mNrUZ1J4PgSKsWgptcm6"),LAUNCHPAD_AUTH:new D("5xqNaZXX5eUi4p5HU4oz9i5QnwRNT2y6oN7yyn4qENeq"),LAUNCHPAD_PLATFORM:new D("2Jx4KTDrVSdWNazuGpcA8n3ZLTRGGBDxAWhuKe2Xcj2a"),LAUNCHPAD_CONFIG:new D("7ZR4zD7PYfY2XxoG1Gxcy2EgEeGYrpxrwzPuwdUBssEt"),FEE_DESTINATION_ID:new D("9y8ENuuZ3b19quffx9hQvRVygG5ky6snHfRvGpuSfeJy"),MODEL_DATA_PUBKEY:new D("Ray1111111111111111111111111111111111111111")};import De from"bn.js";var Ft=1e4;function me(y,e,t,n){if(e===void 0)return{amount:y,fee:void 0,expirationTime:void 0};let i=U(O({},e),{olderTransferFee:{epoch:BigInt(e.olderTransferFee.epoch),maximumFee:BigInt(e.olderTransferFee.maximumFee),transferFeeBasisPoints:e.olderTransferFee.transferFeeBasisPoints},newerTransferFee:{epoch:BigInt(e.newerTransferFee.epoch),maximumFee:BigInt(e.newerTransferFee.maximumFee),transferFeeBasisPoints:e.newerTransferFee.transferFeeBasisPoints}}),s=t.epoch<i.newerTransferFee.epoch?i.olderTransferFee:i.newerTransferFee,o=new De(s.maximumFee.toString()),r=t.epoch<i.newerTransferFee.epoch?(Number(i.newerTransferFee.epoch)*t.slotsInEpoch-t.absoluteSlot)*400/1e3:void 0;if(n)if(s.transferFeeBasisPoints===Ft){let a=new De(s.maximumFee.toString());return{amount:y.add(a),fee:a,expirationTime:r}}else{let a=In(y.mul(new De(Ft)),new De(Ft-s.transferFeeBasisPoints)),c=new De(s.maximumFee.toString()),l=a.sub(y).gt(c)?y.add(c):a,d=In(l.mul(new De(s.transferFeeBasisPoints)),new De(Ft)),f=d.gt(o)?o:d;return{amount:l,fee:f,expirationTime:r}}else{let a=In(y.mul(new De(s.transferFeeBasisPoints)),new De(Ft)),c=a.gt(o)?o:a;return{amount:y,fee:c,expirationTime:r}}}function at(y,e){return y===void 0?e:e===void 0?y:Math.min(y,e)}function In(y,e){let{div:t,mod:n}=y.divmod(e);return n.gt(new De(0))?t.add(new De(1)):t}import{PublicKey as Sn,AddressLookupTableAccount as Tt}from"@solana/web3.js";async function rn({connection:y,address:e,cluster:t="mainnet"}){let n=await Ye(y,[...new Set(e.map(s=>s.toString()))].map(s=>new Sn(s))),i={};for(let s=0;s<e.length;s++){let o=n[s],r=e[s];if(!o)continue;let a=new Tt({key:r,state:Tt.deserialize(o.data)});i[r.toString()]=a,t==="devnet"?wt[r.toString()]=a:ct[r.toString()]=a}return i}var ct={},Cn=async y=>{let e="AcL1Vo8oy1ULiavEcjSUcwfBSForXMudcZvDZy5nzJkU";if(ct[e])return ct;let t=new Sn(e),n=await y.getAccountInfo(t);return n&&(ct[e]=new Tt({key:t,state:Tt.deserialize(n.data)})),ct},wt={},on=async y=>{let e="EFhMuDw1PKEuckuFRW9PavNfTH4LKP5uKHgyXDmWpFCq";if(wt[e])return wt;let t=new Sn(e),n=await y.getAccountInfo(t);return n&&(wt[e]=new Tt({key:t,state:Tt.deserialize(n.data)})),wt};import{PublicKey as ft,sendAndConfirmTransaction as Kn,SystemProgram as Sr,Transaction as Et,TransactionMessage as Je,VersionedTransaction as $e}from"@solana/web3.js";import Cr from"axios";var Dt=2e3,_t=class{constructor(e){this.instructions=[];this.endInstructions=[];this.lookupTableAddress=[];this.signers=[];this.instructionTypes=[];this.endInstructionTypes=[];this.connection=e.connection,this.feePayer=e.feePayer,this.signAllTransactions=e.signAllTransactions,this.owner=e.owner,this.cluster=e.cluster,this.blockhashCommitment=e.blockhashCommitment,this.loopMultiTxStatus=!!e.loopMultiTxStatus}get AllTxData(){return{instructions:this.instructions,endInstructions:this.endInstructions,signers:this.signers,instructionTypes:this.instructionTypes,endInstructionTypes:this.endInstructionTypes,lookupTableAddress:this.lookupTableAddress}}get allInstructions(){return[...this.instructions,...this.endInstructions]}async getComputeBudgetConfig(){var n;let e=(await Cr.get(`https://solanacompass.com/api/fees?cacheFreshTime=${3e5}`)).data,{avg:t}=(n=e==null?void 0:e[15])!=null?n:{};if(!!t)return{units:6e5,microLamports:Math.min(Math.ceil(t*1e6/6e5),25e3)}}addCustomComputeBudget(e){if(e){let{instructions:t,instructionTypes:n}=Rt(e);return this.instructions.unshift(...t),this.instructionTypes.unshift(...n),!0}return!1}addTipInstruction(e){var t;return e?(this.endInstructions.push(Sr.transfer({fromPubkey:(t=e.feePayer)!=null?t:this.feePayer,toPubkey:new ft(e.address),lamports:BigInt(e.amount.toString())})),this.endInstructionTypes.push(re.TransferTip),!0):!1}async calComputeBudget({config:e,defaultIns:t}){try{let n=e||await this.getComputeBudgetConfig();if(this.addCustomComputeBudget(n))return;t&&this.instructions.unshift(...t)}catch{t&&this.instructions.unshift(...t)}}addInstruction({instructions:e=[],endInstructions:t=[],signers:n=[],instructionTypes:i=[],endInstructionTypes:s=[],lookupTableAddress:o=[]}){return this.instructions.push(...e),this.endInstructions.push(...t),this.signers.push(...n),this.instructionTypes.push(...i),this.endInstructionTypes.push(...s),this.lookupTableAddress.push(...o.filter(r=>r!==ft.default.toString())),this}async versionBuild({txVersion:e,extInfo:t}){return e===0?await this.buildV0(O({},t||{})):this.build(t)}build(e){var n;let t=new Et;return this.allInstructions.length&&t.add(...this.allInstructions),t.feePayer=this.feePayer,((n=this.owner)==null?void 0:n.signer)&&!this.signers.some(i=>i.publicKey.equals(this.owner.publicKey))&&this.signers.push(this.owner.signer),{builder:this,transaction:t,signers:this.signers,instructionTypes:[...this.instructionTypes,...this.endInstructionTypes],execute:async i=>{var l;let{recentBlockHash:s,skipPreflight:o=!0,sendAndConfirm:r,notSendToRpc:a}=i||{},c=s!=null?s:await pt(this.connection,this.blockhashCommitment);if(t.recentBlockhash=c,this.signers.length&&t.sign(...this.signers),st([t]),(l=this.owner)!=null&&l.isKeyPair)return{txId:r?await Kn(this.connection,t,this.signers.find(f=>f.publicKey.equals(this.owner.publicKey))?this.signers:[...this.signers,this.owner.signer],{skipPreflight:o}):await this.connection.sendRawTransaction(t.serialize(),{skipPreflight:o}),signedTx:t};if(this.signAllTransactions){let d=await this.signAllTransactions([t]);if(this.signers.length)for(let f of d)try{f.sign(...this.signers)}catch{}return{txId:a?"":await this.connection.sendRawTransaction(d[0].serialize(),{skipPreflight:o}),signedTx:d[0]}}throw new Error("please provide owner in keypair format or signAllTransactions function")},extInfo:e||{}}}buildMultiTx(e){var c;let{extraPreBuildData:t=[],extInfo:n}=e,{transaction:i}=this.build(n),s=t.filter(l=>l.transaction.instructions.length>0),o=[i,...s.map(l=>l.transaction)],r=[this.signers,...s.map(l=>l.signers)],a=[...this.instructionTypes,...s.map(l=>l.instructionTypes).flat()];return(c=this.owner)!=null&&c.signer&&r.forEach(l=>{l.some(d=>d.publicKey.equals(this.owner.publicKey))||this.signers.push(this.owner.signer)}),{builder:this,transactions:o,signers:r,instructionTypes:a,execute:async l=>{var g;let{sequentially:d,onTxUpdate:f,skipTxCount:u=0,recentBlockHash:m,skipPreflight:p=!0}=l||{},b=m!=null?m:await pt(this.connection,this.blockhashCommitment);if((g=this.owner)!=null&&g.isKeyPair){if(d){let w=[],k=0;for(let A of o){if(++k,k<=u)continue;let T=await Kn(this.connection,A,this.signers.find(P=>P.publicKey.equals(this.owner.publicKey))?this.signers:[...this.signers,this.owner.signer],{skipPreflight:p});w.push(T)}return{txIds:w,signedTxs:o}}return{txIds:await await Promise.all(o.map(async w=>(w.recentBlockhash=b,await this.connection.sendRawTransaction(w.serialize(),{skipPreflight:p})))),signedTxs:o}}if(this.signAllTransactions){let w=o.map((A,T)=>(A.recentBlockhash=b,r[T].length&&A.sign(...r[T]),A));st(w);let k=await this.signAllTransactions(w);if(d){let A=0,T=[],P=async()=>{if(!k[A])return;let x=await this.connection.sendRawTransaction(k[A].serialize(),{skipPreflight:p});T.push({txId:x,status:"sent",signedTx:k[A]}),f==null||f([...T]),A++;let h=!1,B=null,K=null,R=C=>{B!==null&&clearInterval(B),K!==null&&this.connection.removeSignatureListener(K);let N=T.findIndex(I=>I.txId===x);if(N>-1){if(T[N].status==="error"||T[N].status==="success")return;T[N].status=C.err?"error":"success"}f==null||f([...T]),C.err||P()};this.loopMultiTxStatus&&(B=setInterval(async()=>{var C;if(h){clearInterval(B);return}try{let N=await this.connection.getTransaction(x,{commitment:"confirmed",maxSupportedTransactionVersion:0});N&&(h=!0,clearInterval(B),R({err:((C=N.meta)==null?void 0:C.err)||null}),console.log("tx status from getTransaction:",x))}catch(N){h=!0,clearInterval(B),console.error("getTransaction timeout:",N,x)}},Dt)),K=this.connection.onSignature(x,C=>{if(h){this.connection.removeSignatureListener(K);return}h=!0,R(C)},"confirmed"),this.connection.getSignatureStatus(x)};return await P(),{txIds:T.map(x=>x.txId),signedTxs:k}}else{let A=[];for(let T=0;T<k.length;T+=1){let P=await this.connection.sendRawTransaction(k[T].serialize(),{skipPreflight:p});A.push(P)}return{txIds:A,signedTxs:k}}}throw new Error("please provide owner in keypair format or signAllTransactions function")},extInfo:n||{}}}async versionMultiBuild({extraPreBuildData:e,txVersion:t,extInfo:n}){return t===0?await this.buildV0MultiTx({extraPreBuildData:e,buildProps:n||{}}):this.buildMultiTx({extraPreBuildData:e,extInfo:n})}async buildV0(e){var p;let m=e||{},{lookupTableCache:t={},lookupTableAddress:n=[],forerunCreate:i,recentBlockhash:s}=m,o=lt(m,["lookupTableCache","lookupTableAddress","forerunCreate","recentBlockhash"]),r=O(O({},this.cluster==="devnet"?await on(this.connection):await Cn(this.connection)),t),a=Array.from(new Set([...n,...this.lookupTableAddress])),c=[];for(let b of a)r[b]===void 0&&c.push(new ft(b));let l=await rn({connection:this.connection,address:c});for(let[b,g]of Object.entries(l))r[b]=g;let d=i?ft.default.toBase58():s!=null?s:await pt(this.connection,this.blockhashCommitment),f=new Je({payerKey:this.feePayer,recentBlockhash:d,instructions:[...this.allInstructions]}).compileToV0Message(Object.values(r));((p=this.owner)==null?void 0:p.signer)&&!this.signers.some(b=>b.publicKey.equals(this.owner.publicKey))&&this.signers.push(this.owner.signer);let u=new $e(f);return u.sign(this.signers),{builder:this,transaction:u,signers:this.signers,instructionTypes:[...this.instructionTypes,...this.endInstructionTypes],execute:async b=>{var A;let{skipPreflight:g=!0,sendAndConfirm:w,notSendToRpc:k}=b||{};if(st([u]),(A=this.owner)!=null&&A.isKeyPair){let T=await this.connection.sendTransaction(u,{skipPreflight:g});return w&&await Lt(this.connection,T),{txId:T,signedTx:u}}if(this.signAllTransactions){let T=await this.signAllTransactions([u]);if(this.signers.length)for(let P of T)try{P.sign(this.signers)}catch{}return{txId:k?"":await this.connection.sendTransaction(T[0],{skipPreflight:g}),signedTx:T[0]}}throw new Error("please provide owner in keypair format or signAllTransactions function")},extInfo:o||{}}}async buildV0MultiTx(e){var c;let{extraPreBuildData:t=[],buildProps:n}=e,{transaction:i}=await this.buildV0(n),s=t.filter(l=>l.builder.instructions.length>0),o=[i,...s.map(l=>l.transaction)],r=[this.signers,...s.map(l=>l.signers)],a=[...this.instructionTypes,...s.map(l=>l.instructionTypes).flat()];return(c=this.owner)!=null&&c.signer&&r.forEach(l=>{l.some(d=>d.publicKey.equals(this.owner.publicKey))||this.signers.push(this.owner.signer)}),o.forEach(async(l,d)=>{l.sign(r[d])}),{builder:this,transactions:o,signers:r,instructionTypes:a,buildProps:n,execute:async l=>{var p;let{sequentially:d,onTxUpdate:f,recentBlockHash:u,skipPreflight:m=!0}=l||{};if(u&&o.forEach(b=>b.message.recentBlockhash=u),st(o),(p=this.owner)!=null&&p.isKeyPair){if(d){let b=[];for(let g of o){let w=await this.connection.sendTransaction(g,{skipPreflight:m});await Lt(this.connection,w),b.push(w)}return{txIds:b,signedTxs:o}}return{txIds:await Promise.all(o.map(async b=>await this.connection.sendTransaction(b,{skipPreflight:m}))),signedTxs:o}}if(this.signAllTransactions){let b=await this.signAllTransactions(o);if(d){let g=0,w=[],k=async()=>{if(!b[g])return;let A=await this.connection.sendTransaction(b[g],{skipPreflight:m});w.push({txId:A,status:"sent",signedTx:b[g]}),f==null||f([...w]),g++;let T=!1,P=null,x=null,h=B=>{P!==null&&clearInterval(P),x!==null&&this.connection.removeSignatureListener(x);let K=w.findIndex(R=>R.txId===A);if(K>-1){if(w[K].status==="error"||w[K].status==="success")return;w[K].status=B.err?"error":"success"}f==null||f([...w]),B.err||k()};this.loopMultiTxStatus&&(P=setInterval(async()=>{var B;if(T){clearInterval(P);return}try{let K=await this.connection.getTransaction(A,{commitment:"confirmed",maxSupportedTransactionVersion:0});K&&(T=!0,clearInterval(P),h({err:((B=K.meta)==null?void 0:B.err)||null}),console.log("tx status from getTransaction:",A))}catch(K){T=!0,clearInterval(P),console.error("getTransaction timeout:",K,A)}},Dt)),x=this.connection.onSignature(A,B=>{if(T){this.connection.removeSignatureListener(x);return}T=!0,h(B)},"confirmed"),this.connection.getSignatureStatus(A)};return k(),{txIds:[],signedTxs:b}}else{let g=[];for(let w=0;w<b.length;w+=1){let k=await this.connection.sendTransaction(b[w],{skipPreflight:m});g.push(k)}return{txIds:g,signedTxs:b}}}throw new Error("please provide owner in keypair format or signAllTransactions function")},extInfo:n||{}}}async sizeCheckBuild(e){var f;let d=e||{},{splitIns:t=[],computeBudgetConfig:n}=d,i=lt(d,["splitIns","computeBudgetConfig"]),s=n?Rt(n):{instructions:[],instructionTypes:[]},o=this.signers.reduce((u,m)=>U(O({},u),{[m.publicKey.toBase58()]:m}),{}),r=[],a=[],c=[],l=0;if(this.allInstructions.forEach(u=>{let m=[...c,u],p=n?[...s.instructions,...m]:m,g=[...new Set(m.map(w=>w.keys.filter(k=>k.isSigner).map(k=>k.pubkey.toString())).flat()).values()].map(w=>new ft(w));if(u!==t[l]&&c.length<12&&(Nt({instructions:p,payer:this.feePayer,signers:g})||Nt({instructions:m,payer:this.feePayer,signers:g})))c.push(u);else{if(c.length===0)throw Error("item ins too big");l+=u===t[l]?1:0,Nt({instructions:n?[...s.instructions,...c]:[...c],payer:this.feePayer,signers:g})?r.push(new Et().add(...s.instructions,...c)):r.push(new Et().add(...c)),a.push(Array.from(new Set(c.map(w=>w.keys.filter(k=>k.isSigner).map(k=>k.pubkey.toString())).flat())).map(w=>o[w]).filter(w=>w!==void 0)),c=[u]}}),c.length>0){let m=[...new Set(c.map(p=>p.keys.filter(b=>b.isSigner).map(b=>b.pubkey.toString())).flat()).values()].map(p=>o[p]).filter(p=>p!==void 0);Nt({instructions:n?[...s.instructions,...c]:[...c],payer:this.feePayer,signers:m.map(p=>p.publicKey)})?r.push(new Et().add(...s.instructions,...c)):r.push(new Et().add(...c)),a.push(m)}return r.forEach(u=>u.feePayer=this.feePayer),(f=this.owner)!=null&&f.signer&&a.forEach(u=>{u.some(m=>m.publicKey.equals(this.owner.publicKey))||u.push(this.owner.signer)}),{builder:this,transactions:r,signers:a,instructionTypes:this.instructionTypes,execute:async u=>{var A;let{sequentially:m,onTxUpdate:p,skipTxCount:b=0,recentBlockHash:g,skipPreflight:w=!0}=u||{},k=g!=null?g:await pt(this.connection,this.blockhashCommitment);if(r.forEach(async(T,P)=>{T.recentBlockhash=k,a[P].length&&T.sign(...a[P])}),st(r),(A=this.owner)!=null&&A.isKeyPair){if(m){let T=0,P=[];for(let x of r){if(++T,T<=b){P.push("tx skipped");continue}let h=await Kn(this.connection,x,this.signers.find(B=>B.publicKey.equals(this.owner.publicKey))?this.signers:[...this.signers,this.owner.signer],{skipPreflight:w});P.push(h)}return{txIds:P,signedTxs:r}}return{txIds:await Promise.all(r.map(async T=>await this.connection.sendRawTransaction(T.serialize(),{skipPreflight:w}))),signedTxs:r}}if(this.signAllTransactions){let T=await this.signAllTransactions(r.slice(b,r.length)),P=[...r.slice(0,b),...T];if(m){let x=0,h=[],B=async()=>{if(!P[x])return;x<b&&(h.push({txId:"",status:"success",signedTx:P[x]}),p==null||p([...h]),x++,B());let K=await this.connection.sendRawTransaction(P[x].serialize(),{skipPreflight:w});h.push({txId:K,status:"sent",signedTx:P[x]}),p==null||p([...h]),x++;let R=!1,C=null,N=null,I=F=>{C!==null&&clearInterval(C),N!==null&&this.connection.removeSignatureListener(N);let q=h.findIndex(ue=>ue.txId===K);if(q>-1){if(h[q].status==="error"||h[q].status==="success")return;h[q].status=F.err?"error":"success"}p==null||p([...h]),F.err||B()};this.loopMultiTxStatus&&(C=setInterval(async()=>{var F;if(R){clearInterval(C);return}try{let q=await this.connection.getTransaction(K,{commitment:"confirmed",maxSupportedTransactionVersion:0});q&&(R=!0,clearInterval(C),I({err:((F=q.meta)==null?void 0:F.err)||null}),console.log("tx status from getTransaction:",K))}catch(q){R=!0,clearInterval(C),console.error("getTransaction timeout:",q,K)}},Dt)),N=this.connection.onSignature(K,F=>{if(R){this.connection.removeSignatureListener(N);return}R=!0,I(F)},"confirmed"),this.connection.getSignatureStatus(K)};return await B(),{txIds:h.map(K=>K.txId),signedTxs:P}}else{let x=[];for(let h=0;h<P.length;h+=1){let B=await this.connection.sendRawTransaction(P[h].serialize(),{skipPreflight:w});x.push(B)}return{txIds:x,signedTxs:P}}}throw new Error("please provide owner in keypair format or signAllTransactions function")},extInfo:i||{}}}async sizeCheckBuildV0(e){var k;let w=e||{},{computeBudgetConfig:t,splitIns:n=[],lookupTableCache:i={},lookupTableAddress:s=[]}=w,o=lt(w,["computeBudgetConfig","splitIns","lookupTableCache","lookupTableAddress"]),r=O(O({},this.cluster==="devnet"?await on(this.connection):ct),i),a=Array.from(new Set([...this.lookupTableAddress,...s])),c=[];for(let A of a)r[A]===void 0&&c.push(new ft(A));let l=await rn({connection:this.connection,address:c});for(let[A,T]of Object.entries(l))r[A]=T;let d=t?Rt(t):{instructions:[],instructionTypes:[]},f=await pt(this.connection,this.blockhashCommitment),u=this.signers.reduce((A,T)=>U(O({},A),{[T.publicKey.toBase58()]:T}),{}),m=[],p=[],b=[],g=0;if(this.allInstructions.forEach(A=>{let T=[...b,A],P=t?[...d.instructions,...T]:T;if(A!==n[g]&&b.length<12&&(Qe({instructions:P,payer:this.feePayer,lookupTableAddressAccount:r})||Qe({instructions:T,payer:this.feePayer,lookupTableAddressAccount:r})))b.push(A);else{if(b.length===0)throw Error("item ins too big");g+=A===n[g]?1:0;let x={};for(let h of[...new Set(a)])r[h]!==void 0&&(x[h]=r[h]);if(t&&Qe({instructions:[...d.instructions,...b],payer:this.feePayer,lookupTableAddressAccount:r,recentBlockhash:f})){let h=new Je({payerKey:this.feePayer,recentBlockhash:f,instructions:[...d.instructions,...b]}).compileToV0Message(Object.values(r));m.push(new $e(h))}else{let h=new Je({payerKey:this.feePayer,recentBlockhash:f,instructions:[...b]}).compileToV0Message(Object.values(r));m.push(new $e(h))}p.push(Array.from(new Set(b.map(h=>h.keys.filter(B=>B.isSigner).map(B=>B.pubkey.toString())).flat())).map(h=>u[h]).filter(h=>h!==void 0)),b=[A]}}),b.length>0){let T=[...new Set(b.map(P=>P.keys.filter(x=>x.isSigner).map(x=>x.pubkey.toString())).flat()).values()].map(P=>u[P]).filter(P=>P!==void 0);if(t&&Qe({instructions:[...d.instructions,...b],payer:this.feePayer,lookupTableAddressAccount:r,recentBlockhash:f})){let P=new Je({payerKey:this.feePayer,recentBlockhash:f,instructions:[...d.instructions,...b]}).compileToV0Message(Object.values(r));m.push(new $e(P))}else{let P=new Je({payerKey:this.feePayer,recentBlockhash:f,instructions:[...b]}).compileToV0Message(Object.values(r));m.push(new $e(P))}p.push(T)}return(k=this.owner)!=null&&k.signer&&p.forEach(A=>{A.some(T=>T.publicKey.equals(this.owner.publicKey))||A.push(this.owner.signer)}),m.forEach((A,T)=>{A.sign(p[T])}),{builder:this,transactions:m,buildProps:e,signers:p,blockHash:f,instructionTypes:this.instructionTypes,execute:async A=>{var K;let{sequentially:T,onTxUpdate:P,skipTxCount:x=0,recentBlockHash:h,skipPreflight:B=!0}=A||{};if(m.map(async(R,C)=>{p[C].length&&R.sign(p[C]),h&&(R.message.recentBlockhash=h)}),st(m),(K=this.owner)!=null&&K.isKeyPair){if(T){let R=0,C=[];for(let N of m){if(++R,R<=x){console.log("skip tx: ",R),C.push("tx skipped");continue}let I=await this.connection.sendTransaction(N,{skipPreflight:B});await Lt(this.connection,I),C.push(I)}return{txIds:C,signedTxs:m}}return{txIds:await Promise.all(m.map(async R=>await this.connection.sendTransaction(R,{skipPreflight:B}))),signedTxs:m}}if(this.signAllTransactions){let R=await this.signAllTransactions(m.slice(x,m.length)),C=[...m.slice(0,x),...R];if(T){let N=0,I=[],F=async()=>{if(!C[N])return;if(N<x){I.push({txId:"",status:"success",signedTx:C[N]}),P==null||P([...I]),N++,F();return}let q=await this.connection.sendTransaction(C[N],{skipPreflight:B});I.push({txId:q,status:"sent",signedTx:C[N]}),P==null||P([...I]),N++;let ue=!1,fe=null,Re=null,ze=ee=>{fe!==null&&clearInterval(fe),Re!==null&&this.connection.removeSignatureListener(Re);let ie=I.findIndex(Ve=>Ve.txId===q);if(ie>-1){if(I[ie].status==="error"||I[ie].status==="success")return;I[ie].status=ee.err?"error":"success"}P==null||P([...I]),ee.err||F()};this.loopMultiTxStatus&&(fe=setInterval(async()=>{var ee;if(ue){clearInterval(fe);return}try{let ie=await this.connection.getTransaction(q,{commitment:"confirmed",maxSupportedTransactionVersion:0});ie&&(ue=!0,clearInterval(fe),ze({err:((ee=ie.meta)==null?void 0:ee.err)||null}),console.log("tx status from getTransaction:",q))}catch(ie){ue=!0,clearInterval(fe),console.error("getTransaction timeout:",ie,q)}},Dt)),Re=this.connection.onSignature(q,ee=>{if(ue){this.connection.removeSignatureListener(Re);return}ue=!0,ze(ee)},"confirmed"),this.connection.getSignatureStatus(q)};return F(),{txIds:[],signedTxs:C}}else{let N=[];for(let I=0;I<C.length;I+=1){let F=await this.connection.sendTransaction(C[I],{skipPreflight:B});N.push(F)}return{txIds:N,signedTxs:C}}}throw new Error("please provide owner in keypair format or signAllTransactions function")},extInfo:o||{}}}async buildSniperTransaction(e){var k;let w=e||{},{computeBudgetConfig:t,splitIns:n=[],lookupTableCache:i={},lookupTableAddress:s=[]}=w,o=lt(w,["computeBudgetConfig","splitIns","lookupTableCache","lookupTableAddress"]),r=O(O({},this.cluster==="devnet"?await on(this.connection):await Cn(this.connection)),i),a=Array.from(new Set([...this.lookupTableAddress,...s])),c=[];for(let A of a)r[A]===void 0&&c.push(new ft(A));let l=await rn({connection:this.connection,address:c});for(let[A,T]of Object.entries(l))r[A]=T;let d=t?Rt(t):{instructions:[],instructionTypes:[]},f=await pt(this.connection,this.blockhashCommitment),u=this.signers.reduce((A,T)=>U(O({},A),{[T.publicKey.toBase58()]:T}),{}),m=[],p=[],b=[],g=0;if(this.allInstructions.forEach(A=>{let T=[...b,A],P=t?[...d.instructions,...T]:T;if(A!==n[g]&&b.length<12&&(Qe({instructions:P,payer:this.feePayer,lookupTableAddressAccount:r})||Qe({instructions:T,payer:this.feePayer,lookupTableAddressAccount:r})))b.push(A);else{if(b.length===0)throw Error("item ins too big");g+=A===n[g]?1:0;let x={};for(let h of[...new Set(a)])r[h]!==void 0&&(x[h]=r[h]);if(t&&Qe({instructions:[...d.instructions,...b],payer:this.feePayer,lookupTableAddressAccount:r,recentBlockhash:f})){let h=new Je({payerKey:this.feePayer,recentBlockhash:f,instructions:[...d.instructions,...b]}).compileToV0Message(Object.values(r));m.push(new $e(h))}else{let h=new Je({payerKey:this.feePayer,recentBlockhash:f,instructions:[...b]}).compileToV0Message(Object.values(r));m.push(new $e(h))}p.push(Array.from(new Set(b.map(h=>h.keys.filter(B=>B.isSigner).map(B=>B.pubkey.toString())).flat())).map(h=>u[h]).filter(h=>h!==void 0)),b=[A]}}),b.length>0){let T=[...new Set(b.map(P=>P.keys.filter(x=>x.isSigner).map(x=>x.pubkey.toString())).flat()).values()].map(P=>u[P]).filter(P=>P!==void 0);if(t&&Qe({instructions:[...d.instructions,...b],payer:this.feePayer,lookupTableAddressAccount:r,recentBlockhash:f})){let P=new Je({payerKey:this.feePayer,recentBlockhash:f,instructions:[...d.instructions,...b]}).compileToV0Message(Object.values(r));m.push(new $e(P))}else{let P=new Je({payerKey:this.feePayer,recentBlockhash:f,instructions:[...b]}).compileToV0Message(Object.values(r));m.push(new $e(P))}p.push(T)}return(k=this.owner)!=null&&k.signer&&p.forEach(A=>{A.some(T=>T.publicKey.equals(this.owner.publicKey))||A.push(this.owner.signer)}),m.forEach((A,T)=>{A.sign(p[T])}),{builder:this,transactions:m,buildProps:e,signers:p,instructionTypes:this.instructionTypes,execute:async A=>{var K;let{sequentially:T,onTxUpdate:P,skipTxCount:x=0,recentBlockHash:h,skipPreflight:B=!0}=A||{};if(m.map(async(R,C)=>{p[C].length&&R.sign(p[C]),h&&(R.message.recentBlockhash=h)}),st(m),(K=this.owner)!=null&&K.isKeyPair){if(T){let R=0,C=[];for(let N of m){if(++R,R<=x){console.log("skip tx: ",R),C.push("tx skipped");continue}let I=await this.connection.sendTransaction(N,{skipPreflight:B});await Lt(this.connection,I),C.push(I)}return{txIds:C,signedTxs:m}}return{txIds:await Promise.all(m.map(async R=>await this.connection.sendTransaction(R,{skipPreflight:B}))),signedTxs:m}}if(this.signAllTransactions){let R=await this.signAllTransactions(m.slice(x,m.length)),C=[...m.slice(0,x),...R];if(T){let N=0,I=[],F=async()=>{if(!C[N])return;if(N<x){I.push({txId:"",status:"success",signedTx:C[N]}),P==null||P([...I]),N++,F();return}let q=await this.connection.sendTransaction(C[N],{skipPreflight:B});I.push({txId:q,status:"sent",signedTx:C[N]}),P==null||P([...I]),N++;let ue=!1,fe=null,Re=null,ze=ee=>{fe!==null&&clearInterval(fe),Re!==null&&this.connection.removeSignatureListener(Re);let ie=I.findIndex(Ve=>Ve.txId===q);if(ie>-1){if(I[ie].status==="error"||I[ie].status==="success")return;I[ie].status=ee.err?"error":"success"}P==null||P([...I]),ee.err||F()};this.loopMultiTxStatus&&(fe=setInterval(async()=>{var ee;if(ue){clearInterval(fe);return}try{let ie=await this.connection.getTransaction(q,{commitment:"confirmed",maxSupportedTransactionVersion:0});ie&&(ue=!0,clearInterval(fe),ze({err:((ee=ie.meta)==null?void 0:ee.err)||null}),console.log("tx status from getTransaction:",q))}catch(ie){ue=!0,clearInterval(fe),console.error("getTransaction timeout:",ie,q)}},Dt)),Re=this.connection.onSignature(q,ee=>{if(ue){this.connection.removeSignatureListener(Re);return}ue=!0,ze(ee)},"confirmed"),this.connection.getSignatureStatus(q)};return F(),{txIds:[],signedTxs:C}}else{let N=[];for(let I=0;I<C.length;I+=1){let F=await this.connection.sendTransaction(C[I],{skipPreflight:B});N.push(F)}return{txIds:N,signedTxs:C}}}throw new Error("please provide owner in keypair format or signAllTransactions function")},extInfo:o||{}}}};import{PublicKey as wc}from"@solana/web3.js";import Ac from"bn.js";import Kr from"bn.js";var Ic=new Kr(1e6);import{AccountLayout as Ui,createAssociatedTokenAccountIdempotentInstruction as Xi,TOKEN_2022_PROGRAM_ID as ut,TOKEN_PROGRAM_ID as jt}from"@solana/spl-token";import{PublicKey as jc}from"@solana/web3.js";import{MintLayout as Qc,TOKEN_PROGRAM_ID as $c}from"@solana/spl-token";var sn=i=>{var s=i,{address:y,programId:e,decimals:t}=s,n=lt(s,["address","programId","decimals"]);return O({chainId:101,address:mt(y).toBase58(),programId:e,logoURI:"",symbol:"",name:"",decimals:t,tags:[],extensions:n.extensions||{}},n)},Rn=y=>y?U(O({},y),{transferFeeConfigAuthority:y.transferFeeConfigAuthority.toBase58(),withdrawWithheldAuthority:y.withdrawWithheldAuthority.toBase58(),withheldAmount:y.withheldAmount.toString(),olderTransferFee:U(O({},y.olderTransferFee),{epoch:y.olderTransferFee.epoch.toString(),maximumFee:y.olderTransferFee.maximumFee.toString()}),newerTransferFee:U(O({},y.newerTransferFee),{epoch:y.newerTransferFee.epoch.toString(),maximumFee:y.newerTransferFee.maximumFee.toString()})}):void 0;var Ln=(...y)=>y.map(e=>{try{return typeof e=="object"?JSON.stringify(e):e}catch{return e}}).join(", "),Vt=class{constructor({scope:e,moduleName:t}){this.disabled=!1;this.scope=e,this.logger=Ae(t)}createTxBuilder(e){return this.scope.checkOwner(),new _t({connection:this.scope.connection,feePayer:e||this.scope.ownerPubKey,cluster:this.scope.cluster,owner:this.scope.owner,blockhashCommitment:this.scope.blockhashCommitment,loopMultiTxStatus:this.scope.loopMultiTxStatus,api:this.scope.api,signAllTransactions:this.scope.signAllTransactions})}createSniperTxBuilder(e,t){let n=new We(e);return new _t({connection:this.scope.connection,feePayer:t,cluster:this.scope.cluster,owner:n,blockhashCommitment:this.scope.blockhashCommitment,loopMultiTxStatus:this.scope.loopMultiTxStatus,api:this.scope.api,signAllTransactions:this.scope.signAllTransactions})}logDebug(...e){this.logger.debug(Ln(e))}logInfo(...e){this.logger.info(Ln(e))}logAndCreateError(...e){let t=Ln(e);throw new Error(t)}checkDisabled(){(this.disabled||!this.scope)&&this.logAndCreateError("module not working")}};import{Keypair as dn,PublicKey as S,SystemProgram as nt,TransactionInstruction as xe}from"@solana/web3.js";import Xn from"bn.js";import{ASSOCIATED_TOKEN_PROGRAM_ID as Yt,TOKEN_2022_PROGRAM_ID as be,TOKEN_PROGRAM_ID as te}from"@solana/spl-token";import{PublicKey as _r}from"@solana/web3.js";import bi,{isBN as gi}from"bn.js";import{bits as mu,BitStructure as du,blob as Rr,Blob as pu,cstr as fu,f32 as yu,f32be as bu,f64 as gu,f64be as Pu,greedy as wu,Layout as Lr,ns64 as Tu,ns64be as Au,nu64 as ku,nu64be as hu,offset as xu,s16 as Bu,s16be as Iu,s24 as Su,s24be as Cu,s32 as Nr,s32be as Ku,s40 as Ru,s40be as Lu,s48 as Nu,s48be as Mu,s8 as Ou,seq as Mr,struct as Fu,Structure as Or,u16 as Fr,u16be as Eu,u24 as Du,u24be as _u,u32 as Vu,u32be as vu,u40 as Wu,u40be as qu,u48 as Gu,u48be as Uu,u8 as Er,UInt as Dr,union as Xu,Union as Hu,unionLayoutDiscriminator as zu,utf8 as Yu}from"@solana/buffer-layout";var Nn=Lr,pi=Or;var Mn=Dr;var fi=Er,vt=Fr;var se=Nr;var yi=Mr;var Le=Rr;var At=class extends Nn{constructor(t,n,i){super(t,i);this.blob=Le(t),this.signed=n}decode(t,n=0){let i=new bi(this.blob.decode(t,n),10,"le");return this.signed?i.fromTwos(this.span*8).clone():i}encode(t,n,i=0){return typeof t=="number"&&(t=new bi(t)),this.signed&&(t=t.toTwos(this.span*8)),this.blob.encode(t.toArrayLike(Buffer,"le",this.span),n,i)}};function ye(y){return new Mn(1,y)}function kt(y){return new Mn(4,y)}function E(y){return new At(8,!1,y)}function X(y){return new At(16,!1,y)}function Pi(y){return new At(8,!0,y)}function wi(y){return new At(16,!0,y)}var an=class extends Nn{constructor(t,n,i,s){super(t.span,s);this.layout=t,this.decoder=n,this.encoder=i}decode(t,n){return this.decoder(this.layout.decode(t,n))}encode(t,n,i){return this.layout.encode(this.encoder(t),n,i)}getSpan(t,n){return this.layout.getSpan(t,n)}};function ne(y){return new an(Le(32),e=>new _r(e),e=>e.toBuffer(),y)}function Ie(y){return new an(fi(),Vr,vr,y)}function Vr(y){if(y===0)return!1;if(y===1)return!0;throw new Error("Invalid bool: "+y)}function vr(y){return y?1:0}var On=class extends pi{decode(e,t){return super.decode(e,t)}};function $(y,e,t){return new On(y,e,t)}function de(y,e,t){let n,i=typeof e=="number"?e:gi(e)?e.toNumber():new Proxy(e,{get(s,o){if(!n){let r=Reflect.get(s,"count");n=gi(r)?r.toNumber():r,Reflect.set(s,"count",n)}return Reflect.get(s,o)},set(s,o,r){return o==="count"&&(n=r),Reflect.set(s,o,r)}});return yi(y,i,t)}import $r from"bn.js";import Bt from"decimal.js";import Fe from"bn.js";var H=new Fe(0),qe=new Fe(1),et=new Fe(-1),Ne=new Fe(1).shln(64),cn=new Fe(1).shln(128),Fn=Ne.sub(qe),Wt=64,Ti=cn.subn(1),Be=-443636,Se=-Be,Ge=new Fe("4295048016"),Ue=new Fe("79226673521066979257578248091"),cl=new Fe("4295048017"),ul=new Fe("79226673521066979257578248090"),Ai=16,ki="59543866431248",hi="184467440737095516",xi="15793534762490258745",un=new Fe(10).pow(new Fe(6)),Wr=(n=>(n[n.rate_500=500]="rate_500",n[n.rate_3000=3e3]="rate_3000",n[n.rate_10000=1e4]="rate_10000",n))(Wr||{}),ll={[500]:10,[3e3]:60,[1e4]:200},ml={version:6,liquidity:H,tickCurrent:0,feeGrowthGlobalX64A:H,feeGrowthGlobalX64B:H,protocolFeesTokenA:H,protocolFeesTokenB:H,swapInAmountTokenA:H,swapOutAmountTokenB:H,swapInAmountTokenB:H,swapOutAmountTokenA:H,tickArrayBitmap:[],rewardInfos:[],day:{volume:0,volumeFee:0,feeA:0,feeB:0,feeApr:0,rewardApr:{A:0,B:0,C:0},apr:0,priceMax:0,priceMin:0},week:{volume:0,volumeFee:0,feeA:0,feeB:0,feeApr:0,rewardApr:{A:0,B:0,C:0},apr:0,priceMax:0,priceMin:0},month:{volume:0,volumeFee:0,feeA:0,feeB:0,feeApr:0,rewardApr:{A:0,B:0,C:0},apr:0,priceMax:0,priceMin:0},tvl:0},Bi={tvl:0,volumeQuote:0,mintAmountA:0,mintAmountB:0,rewardDefaultInfos:[],farmUpcomingCount:0,farmOngoingCount:0,farmFinishedCount:0,day:{volume:0,volumeQuote:0,volumeFee:0,apr:0,feeApr:0,priceMin:0,priceMax:0,rewardApr:[0]},week:{volume:0,volumeQuote:0,volumeFee:0,apr:0,feeApr:0,priceMin:0,priceMax:0,rewardApr:[0]},month:{volume:0,volumeQuote:0,volumeFee:0,apr:0,feeApr:0,priceMin:0,priceMax:0,rewardApr:[0]},pooltype:[]},dl=new Fe("18446744073700000000");import G from"bn.js";import He from"decimal.js";function Ii(y){let e=new ArrayBuffer(2);return new DataView(e).setUint16(0,y,!1),new Uint8Array(e)}function fl(y){let e=new ArrayBuffer(2);return new DataView(e).setInt16(0,y,!1),new Uint8Array(e)}function yl(y){let e=new ArrayBuffer(4);return new DataView(e).setUint32(0,y,!1),new Uint8Array(e)}function ln(y){let e=new ArrayBuffer(4);return new DataView(e).setInt32(0,y,!1),new Uint8Array(e)}function En(y,e){let t=0;for(let n=y-1;n>=0&&!e.testn(n);n--)t++;return t}function Dn(y,e){let t=0;for(let n=0;n<y&&!e.testn(n);n++)t++;return t}function qt(y,e){for(let t=0;t<y;t++)if(e.testn(t))return!1;return!0}function Si(y,e){return qt(y,e)?null:En(y,e)}function Ci(y,e){return qt(y,e)?null:Dn(y,e)}var qr=Buffer.from("amm_config","utf8"),Gr=Buffer.from("pool","utf8"),Ur=Buffer.from("pool_vault","utf8"),Xr=Buffer.from("pool_reward_vault","utf8"),Ki=Buffer.from("position","utf8"),Hr=Buffer.from("tick_array","utf8"),zr=Buffer.from("operation","utf8"),Yr=Buffer.from("pool_tick_array_bitmap_extension","utf8"),jr=Buffer.from("observation","utf8");function wl(y,e){return he([qr,Ii(e)],y)}function Ri(y,e,t,n){return he([Gr,e.toBuffer(),t.toBuffer(),n.toBuffer()],y)}function _n(y,e,t){return he([Ur,e.toBuffer(),t.toBuffer()],y)}function Li(y,e,t){return he([Xr,e.toBuffer(),t.toBuffer()],y)}function z(y,e,t){return he([Hr,e.toBuffer(),ln(t)],y)}function _e(y,e,t,n){return he([Ki,e.toBuffer(),ln(t),ln(n)],y)}function Ce(y,e){return he([Ki,e.toBuffer()],y)}function Gt(y){return he([Buffer.from("metadata","utf8"),dt.toBuffer(),y.toBuffer()],dt)}function Ut(y){return he([zr],y)}function ge(y,e){return he([Yr,e.toBuffer()],y)}function Ni(y,e){return he([jr,e.toBuffer()],y)}var Mi=Buffer.from("locked_position","utf8");function Vn(y,e){return he([Mi,e.toBuffer()],y)}function ht(y,e){return he([Mi,e.toBuffer()],y)}var Zr=Buffer.from("support_mint","utf8");function vn(y,e){return he([Zr,e.toBuffer()],y)}import{PublicKey as Me}from"@solana/web3.js";import{TOKEN_2022_PROGRAM_ID as Oi}from"@solana/spl-token";import ae from"bn.js";import j from"decimal.js";import Xe from"bn.js";import Wn from"decimal.js";var Xt=class{static getfeeGrowthInside(e,t,n){let i=new Xe(0),s=new Xe(0);e.tickCurrent>=t.tick?(i=t.feeGrowthOutsideX64A,s=t.feeGrowthOutsideX64B):(i=e.feeGrowthGlobalX64A.sub(t.feeGrowthOutsideX64A),s=e.feeGrowthGlobalX64B.sub(t.feeGrowthOutsideX64B));let o=new Xe(0),r=new Xe(0);e.tickCurrent<n.tick?(o=n.feeGrowthOutsideX64A,r=n.feeGrowthOutsideX64B):(o=e.feeGrowthGlobalX64A.sub(n.feeGrowthOutsideX64A),r=e.feeGrowthGlobalX64B.sub(n.feeGrowthOutsideX64B));let a=V.wrappingSubU128(V.wrappingSubU128(e.feeGrowthGlobalX64A,i),o),c=V.wrappingSubU128(V.wrappingSubU128(e.feeGrowthGlobalX64B,s),r);return{feeGrowthInsideX64A:a,feeGrowthInsideBX64:c}}static GetPositionFees(e,t,n,i){let{feeGrowthInsideX64A:s,feeGrowthInsideBX64:o}=this.getfeeGrowthInside(e,n,i),r=V.mulDivFloor(V.wrappingSubU128(s,t.feeGrowthInsideLastX64A),t.liquidity,Ne),a=t.tokenFeesOwedA.add(r),c=V.mulDivFloor(V.wrappingSubU128(o,t.feeGrowthInsideLastX64B),t.liquidity,Ne),l=t.tokenFeesOwedB.add(c);return{tokenFeeAmountA:a,tokenFeeAmountB:l}}static GetPositionFeesV2(e,t,n,i){let{feeGrowthInsideX64A:s,feeGrowthInsideBX64:o}=this.getfeeGrowthInside(e,n,i),r=V.mulDivFloor(V.wrappingSubU128(s,t.feeGrowthInsideLastX64A),t.liquidity,Ne),a=t.tokenFeesOwedA.add(r),c=V.mulDivFloor(V.wrappingSubU128(o,t.feeGrowthInsideLastX64B),t.liquidity,Ne),l=t.tokenFeesOwedB.add(c);return{tokenFeeAmountA:a,tokenFeeAmountB:l}}static GetPositionRewardsV2(e,t,n,i){let s=[],o=this.getRewardGrowthInsideV2(e.tickCurrent,n,i,e.rewardInfos);for(let r=0;r<o.length;r++){let a=o[r],c=t.rewardInfos[r],l=V.wrappingSubU128(a,c.growthInsideLastX64),d=V.mulDivFloor(l,t.liquidity,Ne),f=c.rewardAmountOwed.add(d);s.push(f)}return s}static GetPositionRewards(e,t,n,i){let s=[],o=this.getRewardGrowthInside(e.tickCurrent,n,i,e.rewardInfos);for(let r=0;r<o.length;r++){let a=o[r],c=t.rewardInfos[r],l=V.wrappingSubU128(a,c.growthInsideLastX64),d=V.mulDivFloor(l,t.liquidity,Ne),f=c.rewardAmountOwed.add(d);s.push(f)}return s}static getRewardGrowthInside(e,t,n,i){let s=[];for(let o=0;o<i.length;o++){let r=new Xe(0);t.liquidityGross.eqn(0)?r=i[o].rewardGrowthGlobalX64:e<t.tick?r=i[o].rewardGrowthGlobalX64.sub(t.rewardGrowthsOutsideX64[o]):r=t.rewardGrowthsOutsideX64[o];let a=new Xe(0);n.liquidityGross.eqn(0)||(e<n.tick?a=n.rewardGrowthsOutsideX64[o]:a=i[o].rewardGrowthGlobalX64.sub(n.rewardGrowthsOutsideX64[o])),s.push(V.wrappingSubU128(V.wrappingSubU128(i[o].rewardGrowthGlobalX64,r),a))}return s}static getRewardGrowthInsideV2(e,t,n,i){let s=[];for(let o=0;o<i.length;o++){let r=new Xe(0);t.liquidityGross.eqn(0)?r=i[o].rewardGrowthGlobalX64:e<t.tick?r=i[o].rewardGrowthGlobalX64.sub(t.rewardGrowthsOutsideX64[o]):r=t.rewardGrowthsOutsideX64[o];let a=new Xe(0);n.liquidityGross.eqn(0)||(e<n.tick?a=n.rewardGrowthsOutsideX64[o]:a=i[o].rewardGrowthGlobalX64.sub(n.rewardGrowthsOutsideX64[o])),s.push(V.wrappingSubU128(V.wrappingSubU128(i[o].rewardGrowthGlobalX64,r),a))}return s}static getAmountsFromLiquidity({poolInfo:e,ownerPosition:t,liquidity:n,slippage:i,add:s,epochInfo:o}){var b,g,w,k;let r=_.priceToSqrtPriceX64(new Wn(e.price),e.mintA.decimals,e.mintB.decimals),a=_.getSqrtPriceX64FromTick(t.tickLower),c=_.getSqrtPriceX64FromTick(t.tickUpper),l=s?1+i:1-i,d=Y.getAmountsFromLiquidity(r,a,c,n,s),[f,u]=[me(d.amountA,(b=e.mintA.extensions)==null?void 0:b.feeConfig,o,!0),me(d.amountB,(g=e.mintB.extensions)==null?void 0:g.feeConfig,o,!0)],[m,p]=[me(new Xe(new Wn(d.amountA.toString()).mul(l).toFixed(0)),(w=e.mintA.extensions)==null?void 0:w.feeConfig,o,!0),me(new Xe(new Wn(d.amountB.toString()).mul(l).toFixed(0)),(k=e.mintB.extensions)==null?void 0:k.feeConfig,o,!0)];return{liquidity:n,amountA:f,amountB:u,amountSlippageA:m,amountSlippageB:p,expirationTime:at(f.expirationTime,u.expirationTime)}}};var Qr=15,Z=class{static async getTickArrays(e,t,n,i,s,o,r){let a=[],c=M.getTickArrayStartIndexByTick(i,s),l=M.getInitializedTickArrayInRange(o,r,s,c,Math.floor(Qr/2));for(let u=0;u<l.length;u++){let{publicKey:m}=z(t,n,l[u]);a.push(m)}let d=(await Ye(e,a)).map(u=>u!==null?Ht.decode(u.data):null),f={};for(let u=0;u<a.length;u++){let m=d[u];m!==null&&(f[m.startTickIndex]=U(O({},m),{address:a[u]}))}return f}static nextInitializedTick(e,t,n,i,s,o){let{initializedTick:r,tickArrayAddress:a,tickArrayStartTickIndex:c}=this.nextInitializedTickInOneArray(e,t,n,i,s,o);for(;r==null||r.liquidityGross.lten(0);){if(c=M.getNextTickArrayStartIndex(c,s,o),this.checkIsValidStartIndex(c,s))throw new Error("No enough initialized tickArray");let l=n[c];if(l===void 0)continue;let{nextTick:d,tickArrayAddress:f,tickArrayStartTickIndex:u}=this.firstInitializedTickInOneArray(e,t,l,o);[r,a,c]=[d,f,u]}if(r==null)throw new Error("No invaild tickArray cache");return{nextTick:r,tickArrayAddress:a,tickArrayStartTickIndex:c}}static nextInitializedTickArray(e,t,n,i,s){let o=Math.floor(e/Z.tickCount(t)),r=n?M.searchLowBitFromStart(i,s,o-1,1,t):M.searchHightBitFromStart(i,s,o+1,1,t);return r.length>0?{isExist:!0,nextStartIndex:r[0]}:{isExist:!1,nextStartIndex:0}}static firstInitializedTickInOneArray(e,t,n,i){let s;if(i){let r=Pe-1;for(;r>=0;){let a=n.ticks[r];if(a.liquidityGross.gtn(0)){s=a;break}r=r-1}}else{let r=0;for(;r<Pe;){let a=n.ticks[r];if(a.liquidityGross.gtn(0)){s=a;break}r=r+1}}let{publicKey:o}=z(e,t,n.startTickIndex);return{nextTick:s,tickArrayAddress:o,tickArrayStartTickIndex:n.startTickIndex}}static nextInitializedTickInOneArray(e,t,n,i,s,o){let r=M.getTickArrayStartIndexByTick(i,s),a=Math.floor((i-r)/s),c=n[r];if(c==null)return{initializedTick:void 0,tickArrayAddress:void 0,tickArrayStartTickIndex:r};let l;if(o)for(;a>=0;){let f=c.ticks[a];if(f.liquidityGross.gtn(0)){l=f;break}a=a-1}else for(a=a+1;a<Pe;){let f=c.ticks[a];if(f.liquidityGross.gtn(0)){l=f;break}a=a+1}let{publicKey:d}=z(e,t,r);return{initializedTick:l,tickArrayAddress:d,tickArrayStartTickIndex:c.startTickIndex}}static getArrayStartIndex(e,t){let n=this.tickCount(t);return Math.floor(e/n)*n}static checkIsValidStartIndex(e,t){if(M.checkIsOutOfBoundary(e)){if(e>Se)return!1;let n=M.getTickArrayStartIndexByTick(Be,t);return e==n}return e%this.tickCount(t)==0}static tickCount(e){return Pe*e}};var qn=14,tt=class{static maxTickInTickarrayBitmap(e){return e*Pe*yt}static getBitmapTickBoundary(e,t){let n=this.maxTickInTickarrayBitmap(t),i=Math.floor(Math.abs(e)/n);e<0&&Math.abs(e)%n!=0&&(i+=1);let s=n*i;return e<0?{minValue:-s,maxValue:-s+n}:{minValue:s,maxValue:s+n}}static nextInitializedTickArrayStartIndex(e,t,n,i){if(!Z.checkIsValidStartIndex(t,n))throw Error("nextInitializedTickArrayStartIndex check error");let s=this.maxTickInTickarrayBitmap(n),o=i?t-Z.tickCount(n):t+Z.tickCount(n);if(o<-s||o>=s)return{isInit:!1,tickIndex:t};let r=n*Pe,a=o/r+512;o<0&&o%r!=0&&a--;let c=Math.abs(a);if(i){let l=e.shln(1024-c-1),d=Si(1024,l);if(d!==null){let f=(c-d-512)*r;return{isInit:!0,tickIndex:f}}else return{isInit:!1,tickIndex:-s}}else{let l=e.shrn(c),d=Ci(1024,l);if(d!==null){let f=(c+d-512)*r;return{isInit:!0,tickIndex:f}}else return{isInit:!1,tickIndex:s-Z.tickCount(n)}}}},zt=class{static getBitmapOffset(e,t){if(!Z.checkIsValidStartIndex(e,t))throw new Error("No enough initialized tickArray");this.checkExtensionBoundary(e,t);let n=tt.maxTickInTickarrayBitmap(t),i=Math.floor(Math.abs(e)/n)-1;return e<0&&Math.abs(e)%n===0&&i--,i}static getBitmap(e,t,n){let i=this.getBitmapOffset(e,t);return e<0?{offset:i,tickarrayBitmap:n.negativeTickArrayBitmap[i]}:{offset:i,tickarrayBitmap:n.positiveTickArrayBitmap[i]}}static checkExtensionBoundary(e,t){let{positiveTickBoundary:n,negativeTickBoundary:i}=this.extensionTickBoundary(t);if(e>=i&&e<n)throw Error("checkExtensionBoundary -> InvalidTickArrayBoundary")}static extensionTickBoundary(e){let t=tt.maxTickInTickarrayBitmap(e),n=-t;if(Se<=t)throw Error(`extensionTickBoundary check error: ${Se}, ${t}`);if(n<=Be)throw Error(`extensionTickBoundary check error: ${n}, ${Be}`);return{positiveTickBoundary:t,negativeTickBoundary:n}}static checkTickArrayIsInit(e,t,n){let{tickarrayBitmap:i}=this.getBitmap(e,t,n),s=this.tickArrayOffsetInBitmap(e,t);return{isInitialized:M.mergeTickArrayBitmap(i).testn(s),startIndex:e}}static nextInitializedTickArrayFromOneBitmap(e,t,n,i){let s=Z.tickCount(t),o=n?e-s:e+s,{tickarrayBitmap:r}=this.getBitmap(o,t,i);return this.nextInitializedTickArrayInBitmap(r,o,t,n)}static nextInitializedTickArrayInBitmap(e,t,n,i){let{minValue:s,maxValue:o}=tt.getBitmapTickBoundary(t,n),r=this.tickArrayOffsetInBitmap(t,n);if(i){let a=M.mergeTickArrayBitmap(e).shln(yt-1-r),c=qt(512,a)?null:En(512,a);if(c!==null){let l=t-c*Z.tickCount(n);return{isInit:!0,tickIndex:l}}else return{isInit:!1,tickIndex:s}}else{let a=M.mergeTickArrayBitmap(e).shrn(r),c=qt(512,a)?null:Dn(512,a);if(c!==null){let l=t+c*Z.tickCount(n);return{isInit:!0,tickIndex:l}}else return{isInit:!1,tickIndex:o-Z.tickCount(n)}}}static tickArrayOffsetInBitmap(e,t){let n=Math.abs(e)%tt.maxTickInTickarrayBitmap(t),i=Math.floor(n/Z.tickCount(t));return e<0&&n!=0&&(i=yt-i),i}};var pe=class{static getOutputAmountAndRemainAccounts(e,t,n,i,s,o=!1){let r=n.toBase58()===e.mintA.address,a=[],{isExist:c,startIndex:l,nextAccountMeta:d}=this.getFirstInitializedTickArray(e,r);if(!c||l===void 0||!d)throw new Error("Invalid tick array");a.push(d);let{allTrade:f,amountCalculated:u,accounts:m,sqrtPriceX64:p,feeAmount:b}=bt.swapCompute(e.programId,e.id,t,e.tickArrayBitmap,e.exBitmapInfo,r,e.ammConfig.tradeFeeRate,e.liquidity,e.tickCurrent,e.tickSpacing,e.sqrtPriceX64,i,l,s,o);return a.push(...m),{allTrade:f,expectedAmountOut:u.mul(et),remainingAccounts:a,executionPrice:p,feeAmount:b}}static getInputAmountAndRemainAccounts(e,t,n,i,s){let o=n.toBase58()===e.mintB.address,r=[],{isExist:a,startIndex:c,nextAccountMeta:l}=this.getFirstInitializedTickArray(e,o);if(!a||c===void 0||!l)throw new Error("Invalid tick array");try{let p=this.preInitializedTickArrayStartIndex(e,o);if(p.isExist){let{publicKey:b}=z(e.programId,e.id,p.nextStartIndex);r.push(b)}}catch{}r.push(l);let{amountCalculated:d,accounts:f,sqrtPriceX64:u,feeAmount:m}=bt.swapCompute(e.programId,e.id,t,e.tickArrayBitmap,e.exBitmapInfo,o,e.ammConfig.tradeFeeRate,e.liquidity,e.tickCurrent,e.tickSpacing,e.sqrtPriceX64,i.mul(et),c,s);return r.push(...f),{expectedAmountIn:d,remainingAccounts:r,executionPrice:u,feeAmount:m}}static getFirstInitializedTickArray(e,t){let{isInitialized:n,startIndex:i}=pe.isOverflowDefaultTickarrayBitmap(e.tickSpacing,[e.tickCurrent])?zt.checkTickArrayIsInit(Z.getArrayStartIndex(e.tickCurrent,e.tickSpacing),e.tickSpacing,e.exBitmapInfo):M.checkTickArrayIsInitialized(M.mergeTickArrayBitmap(e.tickArrayBitmap),e.tickCurrent,e.tickSpacing);if(n){let{publicKey:r}=z(e.programId,e.id,i);return{isExist:!0,startIndex:i,nextAccountMeta:r}}let{isExist:s,nextStartIndex:o}=this.nextInitializedTickArrayStartIndex(e,Z.getArrayStartIndex(e.tickCurrent,e.tickSpacing),t);if(s){let{publicKey:r}=z(e.programId,e.id,o);return{isExist:!0,startIndex:o,nextAccountMeta:r}}return{isExist:!1,nextAccountMeta:void 0,startIndex:void 0}}static preInitializedTickArrayStartIndex(e,t){let n=Math.floor(e.tickCurrent/Z.tickCount(e.tickSpacing)),i=t?M.searchHightBitFromStart(e.tickArrayBitmap,e.exBitmapInfo,n+1,1,e.tickSpacing):M.searchLowBitFromStart(e.tickArrayBitmap,e.exBitmapInfo,n-1,1,e.tickSpacing);return i.length>0?{isExist:!0,nextStartIndex:i[0]}:{isExist:!1,nextStartIndex:0}}static nextInitializedTickArrayStartIndex(e,t,n){for(t=Z.getArrayStartIndex(e.tickCurrent,e.tickSpacing);;){let{isInit:i,tickIndex:s}=tt.nextInitializedTickArrayStartIndex(M.mergeTickArrayBitmap(e.tickArrayBitmap),t,e.tickSpacing,n);if(i)return{isExist:!0,nextStartIndex:s};t=s;let{isInit:o,tickIndex:r}=zt.nextInitializedTickArrayFromOneBitmap(t,e.tickSpacing,n,e.exBitmapInfo);if(o)return{isExist:!0,nextStartIndex:r};if(t=r,t<Be||t>Se)return{isExist:!1,nextStartIndex:0}}}static async updatePoolRewardInfos({connection:e,apiPoolInfo:t,chainTime:n,poolLiquidity:i,rewardInfos:s}){var r,a,c;let o=[];for(let l=0;l<s.length;l++){let d=s[l],f=(c=(r=t.rewardDefaultInfos[l])==null?void 0:r.mint.programId)!=null?c:(a=await e.getAccountInfo(d.tokenMint))==null?void 0:a.owner;if(f===void 0)throw Error("get new reward mint info error");let u=U(O({},d),{perSecond:V.x64ToDecimal(d.emissionsPerSecondX64),remainingRewards:void 0,tokenProgramId:new Me(f)});if(u.tokenMint.equals(Me.default))continue;if(n<=u.openTime.toNumber()||i.eq(H)){o.push(u);continue}let m=new ae(Math.min(u.endTime.toNumber(),n)),p=m.sub(u.lastUpdateTime),b=V.mulDivFloor(p,u.emissionsPerSecondX64,i),g=u.rewardGrowthGlobalX64.add(b),w=V.mulDivFloor(p,u.emissionsPerSecondX64,Ne),k=u.rewardTotalEmissioned.add(w);o.push(U(O({},u),{rewardGrowthGlobalX64:g,rewardTotalEmissioned:k,lastUpdateTime:m}))}return o}static isOverflowDefaultTickarrayBitmap(e,t){let{maxTickBoundary:n,minTickBoundary:i}=this.tickRange(e);for(let s of t){let o=M.getTickArrayStartIndexByTick(s,e);if(o>=n||o<i)return!0}return!1}static tickRange(e){let t=tt.maxTickInTickarrayBitmap(e),n=-t;return t>Se&&(t=Z.getArrayStartIndex(Se,e)+Z.tickCount(e)),n<Be&&(n=Z.getArrayStartIndex(Be,e)),{maxTickBoundary:t,minTickBoundary:n}}static get_tick_array_offset(e,t){if(!Z.checkIsValidStartIndex(e,t))throw new Error("No enough initialized tickArray");return e/Z.tickCount(t)*yt}static async fetchExBitmaps({connection:e,exBitmapAddress:t,batchRequest:n}){let i=await je(e,t.map(o=>({pubkey:o})),{batchRequest:n}),s={};for(let o of i)o.accountInfo!==null&&(s[o.pubkey.toString()]=Ei.decode(o.accountInfo.data));return s}static async fetchMultiplePoolTickArrays({connection:e,poolKeys:t,batchRequest:n}){let i={},s=[];for(let a of t){let c=M.getTickArrayStartIndexByTick(a.tickCurrent,a.tickSpacing),l=M.getInitializedTickArrayInRange(a.tickArrayBitmap,a.exBitmapInfo,a.tickSpacing,c,7);for(let d of l){let{publicKey:f}=z(a.programId,a.id,d);s.push({pubkey:f}),i[f.toString()]=a.id}}let o=await je(e,s,{batchRequest:n}),r={};for(let a of o){if(!a.accountInfo)continue;let c=i[a.pubkey.toString()];if(!c)continue;r[c.toString()]===void 0&&(r[c.toString()]={});let l=Ht.decode(a.accountInfo.data);r[c.toString()][l.startTickIndex]=U(O({},l),{address:a.pubkey})}return r}static async fetchPoolsAccountPosition({pools:e,connection:t,ownerInfo:n,batchRequest:i=!1,updateOwnerRewardAndFee:s=!0}){var r;let o=[];for(let a=0;a<e.length;a++){let c=e[a];c!==null&&(o.find(l=>l.equals(c.state.programId))||o.push(c.state.programId))}if(n){let a=n.tokenAccounts.map(f=>f.accountInfo.mint),c=[];for(let f of a)for(let u of o)c.push(Ce(u,f).publicKey);let l=await Ye(t,c,{batchRequest:i}),d={};for(let f of l){if(f===null)continue;let u=xt.decode(f.data),m=u.poolId.toString(),p=e.find(h=>h.state.id.toBase58()===m);if(p===void 0)continue;let b=p.state,g=M._getTickPriceLegacy({poolInfo:b,tick:u.tickLower,baseIn:!0}),w=M._getTickPriceLegacy({poolInfo:b,tick:u.tickUpper,baseIn:!0}),{amountA:k,amountB:A}=Y.getAmountsFromLiquidity(b.sqrtPriceX64,g.tickSqrtPriceX64,w.tickSqrtPriceX64,u.liquidity,!1),T=1/(1-Math.sqrt(Math.sqrt(g.price.div(w.price).toNumber())));p.positionAccount=[...(r=p.positionAccount)!=null?r:[],{poolId:u.poolId,nftMint:u.nftMint,priceLower:g.price,priceUpper:w.price,amountA:k,amountB:A,tickLower:u.tickLower,tickUpper:u.tickUpper,liquidity:u.liquidity,feeGrowthInsideLastX64A:u.feeGrowthInsideLastX64A,feeGrowthInsideLastX64B:u.feeGrowthInsideLastX64B,tokenFeesOwedA:u.tokenFeesOwedA,tokenFeesOwedB:u.tokenFeesOwedB,rewardInfos:u.rewardInfos.map(h=>U(O({},h),{pendingReward:new ae(0)})),leverage:T,tokenFeeAmountA:new ae(0),tokenFeeAmountB:new ae(0)}];let P=await M.getTickArrayAddressByTick(p.state.programId,u.poolId,u.tickLower,p.state.tickSpacing),x=await M.getTickArrayAddressByTick(p.state.programId,u.poolId,u.tickUpper,p.state.tickSpacing);d[`${p.state.programId.toString()}-${u.poolId.toString()}-${u.tickLower}`]=P,d[`${p.state.programId.toString()}-${u.poolId.toString()}-${u.tickUpper}`]=x}if(s){let f=Object.values(d),u=await Ye(t,f,{batchRequest:i}),m={};for(let p=0;p<f.length;p++){let b=u[p];if(b===null)continue;let g=f[p].toString();m[g]=Ht.decode(b.data)}for(let{state:p,positionAccount:b}of e)if(!!b)for(let g of b){let w=`${p.programId.toString()}-${p.id.toString()}-${g.tickLower}`,k=`${p.programId.toString()}-${p.id.toString()}-${g.tickUpper}`,A=m[d[w].toString()],T=m[d[k].toString()],P=A.ticks[M.getTickOffsetInArray(g.tickLower,p.tickSpacing)],x=T.ticks[M.getTickOffsetInArray(g.tickUpper,p.tickSpacing)],{tokenFeeAmountA:h,tokenFeeAmountB:B}=await Xt.GetPositionFees(p,g,P,x),K=await Xt.GetPositionRewards(p,g,P,x);g.tokenFeeAmountA=h.gte(new ae(0))?h:new ae(0),g.tokenFeeAmountB=B.gte(new ae(0))?B:new ae(0);for(let R=0;R<K.length;R++)g.rewardInfos[R].pendingReward=K[R].gte(new ae(0))?K[R]:new ae(0)}}}return e}static computeAmountOut({poolInfo:e,tickArrayCache:t,baseMint:n,epochInfo:i,amountIn:s,slippage:o,priceLimit:r=new j(0),catchLiquidityInsufficient:a=!1}){var C;let c,l=n.toBase58()===e.mintA.address,[d,f]=l?[e.mintA.extensions.feeConfig,e.mintB.extensions.feeConfig]:[e.mintB.extensions.feeConfig,e.mintA.extensions.feeConfig];r.equals(new j(0))?c=l?Ge.add(new ae(1)):Ue.sub(new ae(1)):c=_.priceToSqrtPriceX64(r,e.mintA.decimals,e.mintB.decimals);let u=me(s,d,i,!1),{allTrade:m,expectedAmountOut:p,remainingAccounts:b,executionPrice:g,feeAmount:w}=pe.getOutputAmountAndRemainAccounts(e,t,n,u.amount.sub((C=u.fee)!=null?C:H),c,a),k=me(p,f,i,!1),A=_.sqrtPriceX64ToPrice(g,e.mintA.decimals,e.mintB.decimals),T=l?A:new j(1).div(A),P=p.mul(new ae(Math.floor((1-o)*1e10))).div(new ae(1e10)),x=me(P,f,i,!1),h=l?e.currentPrice:new j(1).div(e.currentPrice),B=new j(T).sub(h).abs(),K=h,R=new ot(new j(B).mul(10**15).toFixed(0),new j(K).mul(10**15).toFixed(0));return{allTrade:m,realAmountIn:u,amountOut:k,minAmountOut:x,expirationTime:at(u.expirationTime,k.expirationTime),currentPrice:e.currentPrice,executionPrice:T,priceImpact:R,fee:w,remainingAccounts:b,executionPriceX64:g}}static computeAmountOutFormat({poolInfo:e,tickArrayCache:t,amountIn:n,tokenOut:i,slippage:s,epochInfo:o,catchLiquidityInsufficient:r=!1}){let a=i.address===e.mintB.address,[c,l]=a?[e.mintA,e.mintB]:[e.mintB,e.mintA],[d,f]=[new ve(U(O({},c),{mint:c.address,isToken2022:c.programId===Oi.toBase58()})),new ve(U(O({},l),{mint:l.address,isToken2022:l.programId===Oi.toBase58()}))],{allTrade:u,realAmountIn:m,amountOut:p,minAmountOut:b,expirationTime:g,currentPrice:w,executionPrice:k,priceImpact:A,fee:T,remainingAccounts:P,executionPriceX64:x}=pe.computeAmountOut({poolInfo:e,tickArrayCache:t,baseMint:new Me(c.address),amountIn:n,slippage:s,epochInfo:o,catchLiquidityInsufficient:r}),h=U(O({},m),{amount:new ke(d,m.amount),fee:m.fee===void 0?void 0:new ke(d,m.fee)}),B=U(O({},p),{amount:new ke(f,p.amount),fee:p.fee===void 0?void 0:new ke(f,p.fee)}),K=U(O({},b),{amount:new ke(f,b.amount),fee:b.fee===void 0?void 0:new ke(f,b.fee)}),R=new Ee({baseToken:d,denominator:new ae(10).pow(new ae(20+d.decimals)),quoteToken:f,numerator:w.mul(new j(10**(20+f.decimals))).toFixed(0)}),C=new Ee({baseToken:d,denominator:new ae(10).pow(new ae(20+d.decimals)),quoteToken:f,numerator:k.mul(new j(10**(20+f.decimals))).toFixed(0)}),N=new ke(d,T);return{allTrade:u,realAmountIn:h,amountOut:B,minAmountOut:K,expirationTime:g,currentPrice:R,executionPrice:C,priceImpact:A,fee:N,remainingAccounts:P,executionPriceX64:x}}static computeAmountIn({poolInfo:e,tickArrayCache:t,baseMint:n,epochInfo:i,amountOut:s,slippage:o,priceLimit:r=new j(0)}){var K;let a=n.toBase58()===e.mintA.address,c={[e.mintA.address]:e.mintA.extensions.feeConfig,[e.mintB.address]:e.mintB.extensions.feeConfig},l;r.equals(new j(0))?l=a?Ue.sub(new ae(1)):Ge.add(new ae(1)):l=_.priceToSqrtPriceX64(r,e.mintA.decimals,e.mintB.decimals);let d=me(s,c[n.toString()],i,!0),{expectedAmountIn:f,remainingAccounts:u,executionPrice:m,feeAmount:p}=pe.getInputAmountAndRemainAccounts(e,t,n,d.amount.sub((K=d.fee)!=null?K:H),l),b=a?e.mintB.address:e.mintA.address,g=me(f,c[b],i,!1),w=_.sqrtPriceX64ToPrice(m,e.mintA.decimals,e.mintB.decimals),k=a?w:new j(1).div(w),A=f.mul(new ae(Math.floor((1+o)*1e10))).div(new ae(1e10)),T=me(A,c[b],i,!0),P=a?e.currentPrice:new j(1).div(e.currentPrice),x=new j(k).sub(P).abs(),h=P,B=new ot(new j(x).mul(10**15).toFixed(0),new j(h).mul(10**15).toFixed(0));return{amountIn:g,maxAmountIn:T,realAmountOut:d,expirationTime:at(g.expirationTime,d.expirationTime),currentPrice:e.currentPrice,executionPrice:k,priceImpact:B,fee:p,remainingAccounts:u}}static estimateAprsForPriceRangeMultiplier({poolInfo:e,aprType:t,positionTickLowerIndex:n,positionTickUpperIndex:i}){var m,p,b;let s=e[t],o=M.getTickPrice({poolInfo:e,tick:n,baseIn:!0}).price.toNumber(),r=M.getTickPrice({poolInfo:e,tick:i,baseIn:!0}).price.toNumber(),a=Math.max(o,s.priceMin),l=Math.min(r,s.priceMax)-a,d=r-o,f=s.priceMax-s.priceMin,u;return l<=0?u=0:d===l?u=f/l:f===l?u=l/d:u=l/f*(l/d),{feeApr:s.feeApr*u,rewardsApr:[((m=s.rewardApr[0])!=null?m:0)*u,((p=s.rewardApr[1])!=null?p:0)*u,((b=s.rewardApr[2])!=null?b:0)*u],apr:s.apr*u}}static estimateAprsForPriceRangeDelta({poolInfo:e,poolLiquidity:t,aprType:n,mintPrice:i,liquidity:s,positionTickLowerIndex:o,positionTickUpperIndex:r,chainTime:a}){let c=n==="day"?1:n==="week"?7:n==="month"?30:0,l=e[n],d=i[mt(e.mintA.address).toString()],f=i[mt(e.mintB.address).toString()],u=e.mintA.decimals,m=e.mintB.decimals;if(!l||!d||!f)return{feeApr:0,rewardsApr:[0,0,0],apr:0};let p=_.priceToSqrtPriceX64(new j(e.price),e.mintA.decimals,e.mintB.decimals),b=_.getSqrtPriceX64FromTick(o),g=_.getSqrtPriceX64FromTick(r),{amountSlippageA:w,amountSlippageB:k}=Y.getAmountsFromLiquidityWithSlippage(p,b,g,t,!1,!1,0),{amountSlippageA:A,amountSlippageB:T}=Y.getAmountsFromLiquidityWithSlippage(p,b,g,s,!1,!1,0),P=new j(w.toString()).div(new j(10).pow(u)).mul(d.value).add(new j(k.toString()).div(new j(10).pow(m)).mul(f.value)),x=new j(A.toString()).div(new j(10).pow(u)).mul(d.value).add(new j(T.toString()).div(new j(10).pow(m)).mul(f.value)),h=new j(1).div(P.add(x)),K=new j(l.volumeFee).mul(365).div(c).mul(h).mul(100).toNumber(),R=3600*24*365,C=e.rewardDefaultInfos.map(N=>{var q,ue;let I=N.mint.decimals,F=i[N.mint.address];return a<((q=N.startTime)!=null?q:0)||a>((ue=N.endTime)!=null?ue:0)||!N.perSecond||!F||I===void 0?0:new j(F.value).mul(new j(N.perSecond).mul(R)).div(new j(10).pow(I)).mul(h).mul(100).toNumber()});return{feeApr:K,rewardsApr:C,apr:K+C.reduce((N,I)=>N+I,0)}}static async getLiquidityAmountOutFromAmountIn({poolInfo:e,inputA:t,tickLower:n,tickUpper:i,amount:s,slippage:o,add:r,epochInfo:a,amountHasFee:c}){var g,w;let l=_.priceToSqrtPriceX64(new j(e.price),e.mintA.decimals,e.mintB.decimals),d=_.getSqrtPriceX64FromTick(n),f=_.getSqrtPriceX64FromTick(i),u=me(s,(g=e[t?"mintA":"mintB"].extensions)==null?void 0:g.feeConfig,a,!c),m=new ae(new j(u.amount.sub((w=u.fee)!=null?w:H).toString()).toFixed(0)),p;if(l.lte(d))p=t?Y.getLiquidityFromTokenAmountA(d,f,m,!r):new ae(0);else if(l.lte(f)){let k=Y.getLiquidityFromTokenAmountA(l,f,m,!r),A=Y.getLiquidityFromTokenAmountB(d,l,m);p=t?k:A}else p=t?new ae(0):Y.getLiquidityFromTokenAmountB(d,f,m);let b=await pe.getAmountsFromLiquidity({epochInfo:a,poolInfo:e,tickLower:n,tickUpper:i,liquidity:p,slippage:o,add:r});return{liquidity:p,amountA:t?u:b.amountA,amountB:t?b.amountB:u,amountSlippageA:t?u:b.amountSlippageA,amountSlippageB:t?b.amountSlippageB:u,expirationTime:b.expirationTime}}static async getAmountsFromLiquidity({epochInfo:e,poolInfo:t,tickLower:n,tickUpper:i,liquidity:s,slippage:o,add:r}){var b,g,w,k;let a=_.getSqrtPriceX64FromTick(n),c=_.getSqrtPriceX64FromTick(i),l=r?1+o:1-o,d=Y.getAmountsFromLiquidity(_.priceToSqrtPriceX64(new j(t.price),t.mintA.decimals,t.mintB.decimals),a,c,s,r),[f,u]=[me(d.amountA,(b=t.mintA.extensions)==null?void 0:b.feeConfig,e,!0),me(d.amountB,(g=t.mintB.extensions)==null?void 0:g.feeConfig,e,!0)],[m,p]=[me(d.amountA.muln(l),(w=t.mintA.extensions)==null?void 0:w.feeConfig,e,!0),me(d.amountB.muln(l),(k=t.mintB.extensions)==null?void 0:k.feeConfig,e,!0)];return{liquidity:s,amountA:f,amountB:u,amountSlippageA:m,amountSlippageB:p,expirationTime:at(f.expirationTime,u.expirationTime)}}static async fetchComputeMultipleClmmInfo({connection:e,poolList:t,rpcDataMap:n={}}){let i=t.filter(a=>!n[a.id]).map(a=>new Me(a.id));(await Ye(e,i)).forEach((a,c)=>{!a||(n[i[c].toBase58()]=mn.decode(a.data))});let o=t.map(a=>ge(new Me(a.programId),new Me(a.id)).publicKey),r=await pe.fetchExBitmaps({connection:e,exBitmapAddress:o,batchRequest:!1});return t.reduce((a,c)=>U(O({},a),{[c.id]:U(O({},n[c.id]),{id:new Me(c.id),version:6,programId:new Me(c.programId),mintA:c.mintA,mintB:c.mintB,ammConfig:U(O({},c.config),{id:new Me(c.config.id),fundOwner:""}),currentPrice:new j(c.price),exBitmapAccount:ge(new Me(c.programId),new Me(c.id)).publicKey,exBitmapInfo:r[ge(new Me(c.programId),new Me(c.id)).publicKey.toBase58()],startTime:n[c.id].startTime.toNumber(),rewardInfos:n[c.id].rewardInfos})}),{})}static async fetchComputeClmmInfo({connection:e,poolInfo:t,rpcData:n}){return(await this.fetchComputeMultipleClmmInfo({connection:e,rpcDataMap:n?{[t.id]:n}:void 0,poolList:[t]}))[t.id]}};function om({poolInfo:y,tickLower:e,tickUpper:t,amountA:n,amountB:i,slippage:s,add:o,epochInfo:r,amountHasFee:a}){var k,A,T,P;let[c,l,d,f]=e<t?[e,t,n,i]:[t,e,i,n],u=_.priceToSqrtPriceX64(new j(y.price),y.mintA.decimals,y.mintB.decimals),m=_.getSqrtPriceX64FromTick(c),p=_.getSqrtPriceX64FromTick(l),[b,g]=[me(d,(k=y.mintA.extensions)==null?void 0:k.feeConfig,r,!a),me(f,(A=y.mintB.extensions)==null?void 0:A.feeConfig,r,!a)],w=Y.getLiquidityFromTokenAmounts(u,m,p,b.amount.sub((T=b.fee)!=null?T:H),g.amount.sub((P=g.fee)!=null?P:H));return Y.getAmountsOutFromLiquidity({poolInfo:y,tickLower:e,tickUpper:t,liquidity:w,slippage:s,add:o,epochInfo:r,amountAddFee:!a})}var Gn={volume:0,volumeQuote:0,volumeFee:0,apr:0,feeApr:0,priceMin:0,priceMax:0,rewardApr:[]};function Fi(y){return U(O({},y),{type:"Concentrated",programId:y.programId.toString(),id:y.id.toString(),rewardDefaultInfos:[],rewardDefaultPoolInfos:"Clmm",price:y.currentPrice.toNumber(),mintAmountA:0,mintAmountB:0,feeRate:y.ammConfig.tradeFeeRate,openTime:y.startTime.toString(),tvl:0,day:Gn,week:Gn,month:Gn,pooltype:[],farmUpcomingCount:0,farmOngoingCount:0,farmFinishedCount:0,burnPercent:0,config:U(O({},y.ammConfig),{id:y.ammConfig.id.toString(),defaultRange:0,defaultRangePoint:[]})})}var V=class{static mulDivRoundingUp(e,t,n){let i=e.mul(t),s=i.div(n);return i.mod(n).eq(H)||(s=s.add(qe)),s}static mulDivFloor(e,t,n){if(n.eq(H))throw new Error("division by 0");return e.mul(t).div(n)}static mulDivCeil(e,t,n){if(n.eq(H))throw new Error("division by 0");return e.mul(t).add(n.sub(qe)).div(n)}static x64ToDecimal(e,t){return new He(e.toString()).div(He.pow(2,64)).toDecimalPlaces(t)}static decimalToX64(e){return new G(e.mul(He.pow(2,64)).floor().toFixed())}static wrappingSubU128(e,t){return e.add(cn).sub(t).mod(cn)}};function Te(y,e){return Un(y.mul(e),64,256)}function Jr(y,e,t){let n=y.toTwos(t).shln(e);return n.imaskn(t+1),n.fromTwos(t)}function Un(y,e,t){let n=y.toTwos(t).shrn(e);return n.imaskn(t-e+1),n.fromTwos(t-e)}var _=class{static sqrtPriceX64ToPrice(e,t,n){return V.x64ToDecimal(e).pow(2).mul(He.pow(10,t-n))}static priceToSqrtPriceX64(e,t,n){return V.decimalToX64(e.mul(He.pow(10,n-t)).sqrt())}static getNextSqrtPriceX64FromInput(e,t,n,i){if(!e.gt(H))throw new Error("sqrtPriceX64 must greater than 0");if(!t.gt(H))throw new Error("liquidity must greater than 0");return i?this.getNextSqrtPriceFromTokenAmountARoundingUp(e,t,n,!0):this.getNextSqrtPriceFromTokenAmountBRoundingDown(e,t,n,!0)}static getNextSqrtPriceX64FromOutput(e,t,n,i){if(!e.gt(H))throw new Error("sqrtPriceX64 must greater than 0");if(!t.gt(H))throw new Error("liquidity must greater than 0");return i?this.getNextSqrtPriceFromTokenAmountBRoundingDown(e,t,n,!1):this.getNextSqrtPriceFromTokenAmountARoundingUp(e,t,n,!1)}static getNextSqrtPriceFromTokenAmountARoundingUp(e,t,n,i){if(n.eq(H))return e;let s=t.shln(Wt);if(i){let o=s,r=s.add(n.mul(e));return r.gte(o)?V.mulDivCeil(o,e,r):V.mulDivRoundingUp(o,qe,o.div(e).add(n))}else{let o=n.mul(e);if(!s.gt(o))throw new Error("getNextSqrtPriceFromTokenAmountARoundingUp,liquidityLeftShift must gt amountMulSqrtPrice");let r=s.sub(o);return V.mulDivCeil(s,e,r)}}static getNextSqrtPriceFromTokenAmountBRoundingDown(e,t,n,i){let s=n.shln(Wt);if(i)return e.add(s.div(t));{let o=V.mulDivRoundingUp(s,qe,t);if(!e.gt(o))throw new Error("getNextSqrtPriceFromTokenAmountBRoundingDown sqrtPriceX64 must gt amountDivLiquidity");return e.sub(o)}}static getSqrtPriceX64FromTick(e){if(!Number.isInteger(e))throw new Error("tick must be integer");if(e<Be||e>Se)throw new Error("tick must be in MIN_TICK and MAX_TICK");let t=e<0?e*-1:e,n=(t&1)!=0?new G("18445821805675395072"):new G("18446744073709551616");return(t&2)!=0&&(n=Te(n,new G("18444899583751176192"))),(t&4)!=0&&(n=Te(n,new G("18443055278223355904"))),(t&8)!=0&&(n=Te(n,new G("18439367220385607680"))),(t&16)!=0&&(n=Te(n,new G("18431993317065453568"))),(t&32)!=0&&(n=Te(n,new G("18417254355718170624"))),(t&64)!=0&&(n=Te(n,new G("18387811781193609216"))),(t&128)!=0&&(n=Te(n,new G("18329067761203558400"))),(t&256)!=0&&(n=Te(n,new G("18212142134806163456"))),(t&512)!=0&&(n=Te(n,new G("17980523815641700352"))),(t&1024)!=0&&(n=Te(n,new G("17526086738831433728"))),(t&2048)!=0&&(n=Te(n,new G("16651378430235570176"))),(t&4096)!=0&&(n=Te(n,new G("15030750278694412288"))),(t&8192)!=0&&(n=Te(n,new G("12247334978884435968"))),(t&16384)!=0&&(n=Te(n,new G("8131365268886854656"))),(t&32768)!=0&&(n=Te(n,new G("3584323654725218816"))),(t&65536)!=0&&(n=Te(n,new G("696457651848324352"))),(t&131072)!=0&&(n=Te(n,new G("26294789957507116"))),(t&262144)!=0&&(n=Te(n,new G("37481735321082"))),e>0&&(n=Ti.div(n)),n}static getTickFromPrice(e,t,n){return _.getTickFromSqrtPriceX64(_.priceToSqrtPriceX64(e,t,n))}static getTickFromSqrtPriceX64(e){if(e.gt(Ue)||e.lt(Ge))throw new Error("Provided sqrtPrice is not within the supported sqrtPrice range.");let t=e.bitLength()-1,n=new G(t-64),i=Jr(n,32,128),s=new G("8000000000000000","hex"),o=0,r=new G(0),a=t>=64?e.shrn(t-63):e.shln(63-t);for(;s.gt(new G(0))&&o<Ai;){a=a.mul(a);let m=a.shrn(127);a=a.shrn(63+m.toNumber()),r=r.add(s.mul(m)),s=s.shrn(1),o+=1}let c=r.shrn(32),d=i.add(c).mul(new G(ki)),f=Un(d.sub(new G(hi)),64,128).toNumber(),u=Un(d.add(new G(xi)),64,128).toNumber();return f==u?f:_.getSqrtPriceX64FromTick(u).lte(e)?u:f}},gt=class{static getTickWithPriceAndTickspacing(e,t,n,i){let o=_.getTickFromSqrtPriceX64(_.priceToSqrtPriceX64(e,n,i))/t;return o<0?o=Math.floor(o):o=Math.ceil(o),o*t}static roundPriceWithTickspacing(e,t,n,i){let s=gt.getTickWithPriceAndTickspacing(e,t,n,i),o=_.getSqrtPriceX64FromTick(s);return _.sqrtPriceX64ToPrice(o,n,i)}},Y=class{static addDelta(e,t){return e.add(t)}static getTokenAmountAFromLiquidity(e,t,n,i){if(e.gt(t)&&([e,t]=[t,e]),!e.gt(H))throw new Error("sqrtPriceX64A must greater than 0");let s=n.ushln(Wt),o=t.sub(e);return i?V.mulDivRoundingUp(V.mulDivCeil(s,o,t),qe,e):V.mulDivFloor(s,o,t).div(e)}static getTokenAmountBFromLiquidity(e,t,n,i){if(e.gt(t)&&([e,t]=[t,e]),!e.gt(H))throw new Error("sqrtPriceX64A must greater than 0");return i?V.mulDivCeil(n,t.sub(e),Ne):V.mulDivFloor(n,t.sub(e),Ne)}static getLiquidityFromTokenAmountA(e,t,n,i){e.gt(t)&&([e,t]=[t,e]);let s=n.mul(e).mul(t),o=t.sub(e),r=s.div(o);return i?V.mulDivRoundingUp(r,qe,Fn):r.shrn(Wt)}static getLiquidityFromTokenAmountB(e,t,n){return e.gt(t)&&([e,t]=[t,e]),V.mulDivFloor(n,Fn,t.sub(e))}static getLiquidityFromTokenAmounts(e,t,n,i,s){if(t.gt(n)&&([t,n]=[n,t]),e.lte(t))return Y.getLiquidityFromTokenAmountA(t,n,i,!1);if(e.lt(n)){let o=Y.getLiquidityFromTokenAmountA(e,n,i,!1),r=Y.getLiquidityFromTokenAmountB(t,e,s);return o.lt(r)?o:r}else return Y.getLiquidityFromTokenAmountB(t,n,s)}static getAmountsFromLiquidity(e,t,n,i,s){if(t.gt(n)&&([t,n]=[n,t]),e.lte(t))return{amountA:Y.getTokenAmountAFromLiquidity(t,n,i,s),amountB:new G(0)};if(e.lt(n)){let o=Y.getTokenAmountAFromLiquidity(e,n,i,s),r=Y.getTokenAmountBFromLiquidity(t,e,i,s);return{amountA:o,amountB:r}}else return{amountA:new G(0),amountB:Y.getTokenAmountBFromLiquidity(t,n,i,s)}}static getAmountsFromLiquidityWithSlippage(e,t,n,i,s,o,r){let{amountA:a,amountB:c}=Y.getAmountsFromLiquidity(e,t,n,i,o),l=s?1+r:1-r,d=new G(new He(a.toString()).mul(l).toFixed(0)),f=new G(new He(c.toString()).mul(l).toFixed(0));return{amountSlippageA:d,amountSlippageB:f}}static getAmountsOutFromLiquidity({poolInfo:e,tickLower:t,tickUpper:n,liquidity:i,slippage:s,add:o,epochInfo:r,amountAddFee:a}){var w,k,A,T;let c=_.priceToSqrtPriceX64(new He(e.price),e.mintA.decimals,e.mintB.decimals),l=_.getSqrtPriceX64FromTick(t),d=_.getSqrtPriceX64FromTick(n),f=o?1+s:1-s,u=Y.getAmountsFromLiquidity(c,l,d,i,o),[m,p]=[me(u.amountA,(w=e.mintA.extensions)==null?void 0:w.feeConfig,r,a),me(u.amountB,(k=e.mintB.extensions)==null?void 0:k.feeConfig,r,a)],[b,g]=[me(new G(new He(u.amountA.toString()).mul(f).toFixed(0)),(A=e.mintA.extensions)==null?void 0:A.feeConfig,r,a),me(new G(new He(u.amountB.toString()).mul(f).toFixed(0)),(T=e.mintB.extensions)==null?void 0:T.feeConfig,r,a)];return{liquidity:i,amountA:m,amountB:p,amountSlippageA:b,amountSlippageB:g,expirationTime:at(m.expirationTime,p.expirationTime)}}},bt=class{static swapCompute(e,t,n,i,s,o,r,a,c,l,d,f,u,m,p=!1){if(f.eq(H))throw new Error("amountSpecified must not be 0");if(m||(m=o?Ge.add(qe):Ue.sub(qe)),o){if(m.lt(Ge))throw new Error("sqrtPriceX64 must greater than MIN_SQRT_PRICE_X64");if(m.gte(d))throw new Error("sqrtPriceX64 must smaller than current")}else{if(m.gt(Ue))throw new Error("sqrtPriceX64 must smaller than MAX_SQRT_PRICE_X64");if(m.lte(d))throw new Error("sqrtPriceX64 must greater than current")}let b=f.gt(H),g={amountSpecifiedRemaining:f,amountCalculated:H,sqrtPriceX64:d,tick:c>u?Math.min(u+Z.tickCount(l)-1,c):u,accounts:[],liquidity:a,feeAmount:new G(0)},w=u,k=n[u],A=0,T=!o&&k.startTickIndex===g.tick;for(;!g.amountSpecifiedRemaining.eq(H)&&!g.sqrtPriceX64.eq(m);){A>10;let P={};P.sqrtPriceStartX64=g.sqrtPriceX64;let x=M.nextInitTick(k,g.tick,l,o,T),h=x||null,B=null;if(!(h!=null&&h.liquidityGross.gtn(0))){let R=pe.nextInitializedTickArrayStartIndex({tickCurrent:g.tick,tickSpacing:l,tickArrayBitmap:i,exBitmapInfo:s},w,o);if(!R.isExist){if(p)return{allTrade:!1,amountSpecifiedRemaining:g.amountSpecifiedRemaining,amountCalculated:g.amountCalculated,feeAmount:g.feeAmount,sqrtPriceX64:g.sqrtPriceX64,liquidity:g.liquidity,tickCurrent:g.tick,accounts:g.accounts};throw Error("swapCompute LiquidityInsufficient")}w=R.nextStartIndex;let{publicKey:C}=z(e,t,w);B=C,k=n[w];try{h=M.firstInitializedTick(k,o)}catch{throw Error("not found next tick info")}}P.tickNext=h.tick,P.initialized=h.liquidityGross.gtn(0),u!==w&&B&&(g.accounts.push(B),u=w),P.tickNext<Be?P.tickNext=Be:P.tickNext>Se&&(P.tickNext=Se),P.sqrtPriceNextX64=_.getSqrtPriceX64FromTick(P.tickNext);let K;if(o&&P.sqrtPriceNextX64.lt(m)||!o&&P.sqrtPriceNextX64.gt(m)?K=m:K=P.sqrtPriceNextX64,[g.sqrtPriceX64,P.amountIn,P.amountOut,P.feeAmount]=bt.swapStepCompute(g.sqrtPriceX64,K,g.liquidity,g.amountSpecifiedRemaining,r,o),g.feeAmount=g.feeAmount.add(P.feeAmount),b?(g.amountSpecifiedRemaining=g.amountSpecifiedRemaining.sub(P.amountIn.add(P.feeAmount)),g.amountCalculated=g.amountCalculated.sub(P.amountOut)):(g.amountSpecifiedRemaining=g.amountSpecifiedRemaining.add(P.amountOut),g.amountCalculated=g.amountCalculated.add(P.amountIn.add(P.feeAmount))),g.sqrtPriceX64.eq(P.sqrtPriceNextX64)){if(P.initialized){let R=h.liquidityNet;o&&(R=R.mul(et)),g.liquidity=Y.addDelta(g.liquidity,R)}T=P.tickNext!=g.tick&&!o&&k.startTickIndex===P.tickNext,g.tick=o?P.tickNext-1:P.tickNext}else if(g.sqrtPriceX64!=P.sqrtPriceStartX64){let R=_.getTickFromSqrtPriceX64(g.sqrtPriceX64);T=R!=g.tick&&!o&&k.startTickIndex===R,g.tick=R}++A}try{let{nextStartIndex:P,isExist:x}=Z.nextInitializedTickArray(g.tick,l,o,i,s);x&&u!==P&&(g.accounts.push(z(e,t,P).publicKey),u=P)}catch{}return{allTrade:!0,amountSpecifiedRemaining:H,amountCalculated:g.amountCalculated,feeAmount:g.feeAmount,sqrtPriceX64:g.sqrtPriceX64,liquidity:g.liquidity,tickCurrent:g.tick,accounts:g.accounts}}static swapStepCompute(e,t,n,i,s,o){let r={sqrtPriceX64Next:new G(0),amountIn:new G(0),amountOut:new G(0),feeAmount:new G(0)},a=i.gte(H);if(a){let l=V.mulDivFloor(i,un.sub(new G(s.toString())),un);r.amountIn=o?Y.getTokenAmountAFromLiquidity(t,e,n,!0):Y.getTokenAmountBFromLiquidity(e,t,n,!0),l.gte(r.amountIn)?r.sqrtPriceX64Next=t:r.sqrtPriceX64Next=_.getNextSqrtPriceX64FromInput(e,n,l,o)}else r.amountOut=o?Y.getTokenAmountBFromLiquidity(t,e,n,!1):Y.getTokenAmountAFromLiquidity(e,t,n,!1),i.mul(et).gte(r.amountOut)?r.sqrtPriceX64Next=t:r.sqrtPriceX64Next=_.getNextSqrtPriceX64FromOutput(e,n,i.mul(et),o);let c=t.eq(r.sqrtPriceX64Next);return o?(c&&a||(r.amountIn=Y.getTokenAmountAFromLiquidity(r.sqrtPriceX64Next,e,n,!0)),c&&!a||(r.amountOut=Y.getTokenAmountBFromLiquidity(r.sqrtPriceX64Next,e,n,!1))):(r.amountIn=c&&a?r.amountIn:Y.getTokenAmountBFromLiquidity(e,r.sqrtPriceX64Next,n,!0),r.amountOut=c&&!a?r.amountOut:Y.getTokenAmountAFromLiquidity(e,r.sqrtPriceX64Next,n,!1)),!a&&r.amountOut.gt(i.mul(et))&&(r.amountOut=i.mul(et)),a&&!r.sqrtPriceX64Next.eq(t)?r.feeAmount=i.sub(r.amountIn):r.feeAmount=V.mulDivCeil(r.amountIn,new G(s),un.sub(new G(s))),[r.sqrtPriceX64Next,r.amountIn,r.amountOut,r.feeAmount]}};var Pe=60,yt=512,M=class{static getTickArrayAddressByTick(e,t,n,i){let s=M.getTickArrayStartIndexByTick(n,i),{publicKey:o}=z(e,t,s);return o}static getTickOffsetInArray(e,t){if(e%t!=0)throw new Error("tickIndex % tickSpacing not equal 0");let n=M.getTickArrayStartIndexByTick(e,t),i=Math.floor((e-n)/t);if(i<0||i>=Pe)throw new Error("tick offset in array overflow");return i}static getTickArrayBitIndex(e,t){let n=Z.tickCount(t),i=e/n;return e<0&&e%n!=0?i=Math.ceil(i)-1:i=Math.floor(i),i}static getTickArrayStartIndexByTick(e,t){return this.getTickArrayBitIndex(e,t)*Z.tickCount(t)}static getTickArrayOffsetInBitmapByTick(e,t){let n=t*Pe,i=Math.floor(e/n)+512;return Math.abs(i)}static checkTickArrayIsInitialized(e,t,n){let i=n*Pe,s=Math.floor(t/i)+512,o=Math.abs(s);return{isInitialized:e.testn(o),startIndex:(o-512)*i}}static getNextTickArrayStartIndex(e,t,n){return n?e-t*Pe:e+t*Pe}static mergeTickArrayBitmap(e){let t=new $r(0);for(let n=0;n<e.length;n++)t=t.add(e[n].shln(64*n));return t}static getInitializedTickArrayInRange(e,t,n,i,s){let o=Math.floor(i/(n*Pe));return[...M.searchLowBitFromStart(e,t,o-1,s,n),...M.searchHightBitFromStart(e,t,o,s,n)]}static getAllInitializedTickArrayStartIndex(e,t,n){return M.searchHightBitFromStart(e,t,-7680,yt,n)}static getAllInitializedTickArrayInfo(e,t,n,i,s){let o=[],r=M.getAllInitializedTickArrayStartIndex(n,i,s);for(let a of r){let{publicKey:c}=z(e,t,a);o.push({tickArrayStartIndex:a,tickArrayAddress:c})}return o}static getAllInitializedTickInTickArray(e){return e.ticks.filter(t=>t.liquidityGross.gtn(0))}static searchLowBitFromStart(e,t,n,i,s){let o=[...[...t.negativeTickArrayBitmap].reverse(),e.slice(0,8),e.slice(8,16),...t.positiveTickArrayBitmap].map(c=>M.mergeTickArrayBitmap(c)),r=[];for(;n>=-7680;){let c=Math.floor((n+7680)/512),l=(n+7680)%512;if(o[c].testn(l)&&r.push(n),n--,r.length===i)break}let a=Z.tickCount(s);return r.map(c=>c*a)}static searchHightBitFromStart(e,t,n,i,s){let o=[...[...t.negativeTickArrayBitmap].reverse(),e.slice(0,8),e.slice(8,16),...t.positiveTickArrayBitmap].map(c=>M.mergeTickArrayBitmap(c)),r=[];for(;n<7680;){let c=Math.floor((n+7680)/512),l=(n+7680)%512;if(o[c].testn(l)&&r.push(n),n++,r.length===i)break}let a=Z.tickCount(s);return r.map(c=>c*a)}static checkIsOutOfBoundary(e){return e<Be||e>Se}static nextInitTick(e,t,n,i,s){if(Z.getArrayStartIndex(t,n)!=e.startTickIndex)return null;let r=Math.floor((t-e.startTickIndex)/n);if(i)for(;r>=0;){if(e.ticks[r].liquidityGross.gtn(0))return e.ticks[r];r=r-1}else for(s||(r=r+1);r<Pe;){if(e.ticks[r].liquidityGross.gtn(0))return e.ticks[r];r=r+1}return null}static firstInitializedTick(e,t){if(t){let n=Pe-1;for(;n>=0;){if(e.ticks[n].liquidityGross.gtn(0))return e.ticks[n];n=n-1}}else{let n=0;for(;n<Pe;){if(e.ticks[n].liquidityGross.gtn(0))return e.ticks[n];n=n+1}}throw Error(`firstInitializedTick check error: ${e} - ${t}`)}static _getTickPriceLegacy({poolInfo:e,tick:t,baseIn:n}){let i=_.getSqrtPriceX64FromTick(t),s=_.sqrtPriceX64ToPrice(i,e.mintA.decimals,e.mintB.decimals);return n?{tick:t,price:s,tickSqrtPriceX64:i}:{tick:t,price:new Bt(1).div(s),tickSqrtPriceX64:i}}static _getPriceAndTickLegacy({poolInfo:e,price:t,baseIn:n}){let i=n?t:new Bt(1).div(t),s=gt.getTickWithPriceAndTickspacing(i,e.ammConfig.tickSpacing,e.mintA.decimals,e.mintB.decimals),o=_.getSqrtPriceX64FromTick(s),r=_.sqrtPriceX64ToPrice(o,e.mintA.decimals,e.mintB.decimals);return n?{tick:s,price:r}:{tick:s,price:new Bt(1).div(r)}}static getTickPrice({poolInfo:e,tick:t,baseIn:n}){let i=_.getSqrtPriceX64FromTick(t),s=_.sqrtPriceX64ToPrice(i,e.mintA.decimals,e.mintB.decimals);return n?{tick:t,price:s,tickSqrtPriceX64:i}:{tick:t,price:new Bt(1).div(s),tickSqrtPriceX64:i}}static getPriceAndTick({poolInfo:e,price:t,baseIn:n}){let i=n?t:new Bt(1).div(t),s=gt.getTickWithPriceAndTickspacing(i,e.config.tickSpacing,e.mintA.decimals,e.mintB.decimals),o=_.getSqrtPriceX64FromTick(s),r=_.sqrtPriceX64ToPrice(o,e.mintA.decimals,e.mintB.decimals);return n?{tick:s,price:r}:{tick:s,price:new Bt(1).div(r)}}};var Di=$([Le(8),ye("bump"),vt("index"),ne(""),kt("protocolFeeRate"),kt("tradeFeeRate"),vt("tickSpacing"),de(E(),8,"")]),eo=$([kt("blockTimestamp"),Pi("tickCumulative"),de(E(),4)]),_i=$([Le(8),Ie("initialized"),E("recentEpoch"),vt("observationIndex"),ne("poolId"),de(eo,100,"observations"),de(E(),4)]),to=$([ye("rewardState"),E("openTime"),E("endTime"),E("lastUpdateTime"),X("emissionsPerSecondX64"),E("rewardTotalEmissioned"),E("rewardClaimed"),ne("tokenMint"),ne("tokenVault"),ne("creator"),X("rewardGrowthGlobalX64")]),mn=$([Le(8),ye("bump"),ne("ammConfig"),ne("creator"),ne("mintA"),ne("mintB"),ne("vaultA"),ne("vaultB"),ne("observationId"),ye("mintDecimalsA"),ye("mintDecimalsB"),vt("tickSpacing"),X("liquidity"),X("sqrtPriceX64"),se("tickCurrent"),kt(),X("feeGrowthGlobalX64A"),X("feeGrowthGlobalX64B"),E("protocolFeesTokenA"),E("protocolFeesTokenB"),X("swapInAmountTokenA"),X("swapOutAmountTokenB"),X("swapInAmountTokenB"),X("swapOutAmountTokenA"),ye("status"),de(ye(),7,""),de(to,3,"rewardInfos"),de(E(),16,"tickArrayBitmap"),E("totalFeesTokenA"),E("totalFeesClaimedTokenA"),E("totalFeesTokenB"),E("totalFeesClaimedTokenB"),E("fundFeesTokenA"),E("fundFeesTokenB"),E("startTime"),de(E(),15*4-3,"padding")]),no=$([X("growthInsideLastX64"),E("rewardAmountOwed")]),xt=$([Le(8),ye("bump"),ne("nftMint"),ne("poolId"),se("tickLower"),se("tickUpper"),X("liquidity"),X("feeGrowthInsideLastX64A"),X("feeGrowthInsideLastX64B"),E("tokenFeesOwedA"),E("tokenFeesOwedB"),de(no,3,"rewardInfos"),de(E(),8,"")]),Km=$([Le(8),ye("bump"),ne("poolId"),se("tickLowerIndex"),se("tickUpperIndex"),X("liquidity"),X("feeGrowthInsideLastX64A"),X("feeGrowthInsideLastX64B"),E("tokenFeesOwedA"),E("tokenFeesOwedB"),de(X(),3,"rewardGrowthInside"),de(E(),8,"")]),io=$([se("tick"),wi("liquidityNet"),X("liquidityGross"),X("feeGrowthOutsideX64A"),X("feeGrowthOutsideX64B"),de(X(),3,"rewardGrowthsOutsideX64"),de(kt(),13,"")]),Ht=$([Le(8),ne("poolId"),se("startTickIndex"),de(io,Pe,"ticks"),ye("initializedTickCount"),de(ye(),115,"")]),Vi=$([Le(329),de(ne(),100,"whitelistMints")]),Ei=$([Le(8),ne("poolId"),de(de(E(),8),qn,"positiveTickArrayBitmap"),de(de(E(),8),qn,"negativeTickArrayBitmap")]),Rm=$([E(),ye("bump"),ne("owner"),ne("poolId"),ne("positionId"),ne("nftAccount"),de(E(),8)]),vi=$([Le(8),ye("bump"),ne("lockOwner"),ne("poolId"),ne("positionId"),ne("nftAccount"),ne("lockNftMint"),E("recentEpoch"),de(E(),8)]);_i.span;var Wi=Ae("Raydium_Clmm"),Oe={createPool:[233,146,209,142,207,104,64,188],initReward:[95,135,192,196,242,129,230,68],setRewardEmissions:[112,52,167,75,32,201,211,137],openPosition:[77,184,74,214,112,86,241,199],openPositionWithTokenEx:[77,255,174,82,125,29,201,46],closePosition:[123,134,81,0,49,68,98,98],increaseLiquidity:[133,29,89,223,69,238,176,10],decreaseLiquidity:[58,127,188,62,79,82,196,96],swap:[43,4,237,11,26,201,30,98],collectReward:[18,237,166,197,34,16,213,144]},qi=[188,37,179,131,82,150,84,73],Gi=[16,72,250,198,14,162,212,19],ce=class{static createPoolInstruction(e,t,n,i,s,o,r,a,c,l,d,f,u,m){let p=$([X("sqrtPriceX64"),E("zero")]),b=[{pubkey:n,isSigner:!0,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:c,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:f,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!1},{pubkey:d,isSigner:!1,isWritable:!1},{pubkey:nt.programId,isSigner:!1,isWritable:!1},{pubkey:rt,isSigner:!1,isWritable:!1},...(m==null?void 0:m.map(k=>({pubkey:k,isSigner:!1,isWritable:!1})))||[]],g=Buffer.alloc(p.span);p.encode({sqrtPriceX64:u,zero:H},g);let w=Buffer.from([...Oe.createPool,...g]);return new xe({keys:b,programId:e,data:w})}static async createPoolInstructions(e){let{programId:t,owner:n,mintA:i,mintB:s,ammConfigId:o,initialPriceX64:r,extendMintAccount:a}=e,[c,l]=[new S(i.address),new S(s.address)],{publicKey:d}=Ri(t,o,c,l),{publicKey:f}=Ni(t,d),{publicKey:u}=_n(t,d,c),{publicKey:m}=_n(t,d,l),p=ge(t,d).publicKey,b=[this.createPoolInstruction(t,d,n,o,f,c,u,new S(i.programId||te),l,m,new S(s.programId||te),p,r,a)];return{signers:[],instructions:b,instructionTypes:[re.CreateAccount,re.ClmmCreatePool],address:{poolId:d,observationId:f,exBitmapAccount:p,mintAVault:u,mintBVault:m},lookupTableAddress:[]}}static openPositionFromLiquidityInstruction(e,t,n,i,s,o,r,a,c,l,d,f,u,m,p,b,g,w,k,A,T,P,x,h,B,K){let R=$([se("tickLowerIndex"),se("tickUpperIndex"),se("tickArrayLowerStartIndex"),se("tickArrayUpperStartIndex"),X("liquidity"),E("amountMaxA"),E("amountMaxB"),Ie("withMetadata"),ye("optionBaseFlag"),Ie("baseFlag")]),C=[...K?[{pubkey:K,isSigner:!1,isWritable:!0}]:[]],N=[{pubkey:t,isSigner:!0,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!1},{pubkey:s,isSigner:!0,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:d,isSigner:!1,isWritable:!0},{pubkey:f,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:m,isSigner:!1,isWritable:!0},{pubkey:p,isSigner:!1,isWritable:!0},{pubkey:rt,isSigner:!1,isWritable:!1},{pubkey:nt.programId,isSigner:!1,isWritable:!1},{pubkey:te,isSigner:!1,isWritable:!1},{pubkey:Yt,isSigner:!1,isWritable:!1},{pubkey:dt,isSigner:!1,isWritable:!1},{pubkey:be,isSigner:!1,isWritable:!1},{pubkey:b,isSigner:!1,isWritable:!1},{pubkey:g,isSigner:!1,isWritable:!1},...C],I=Buffer.alloc(R.span);R.encode({tickLowerIndex:w,tickUpperIndex:k,tickArrayLowerStartIndex:A,tickArrayUpperStartIndex:T,liquidity:P,amountMaxA:x,amountMaxB:h,withMetadata:B==="create",baseFlag:!1,optionBaseFlag:0},I);let F=Buffer.from([...Oe.openPosition,...I]);return new xe({keys:N,programId:e,data:F})}static openPositionFromLiquidityInstruction22(e,t,n,i,s,o,r,a,c,l,d,f,u,m,p,b,g,w,k,A,T,P,x,h,B){let K=$([se("tickLowerIndex"),se("tickUpperIndex"),se("tickArrayLowerStartIndex"),se("tickArrayUpperStartIndex"),X("liquidity"),E("amountMaxA"),E("amountMaxB"),Ie("withMetadata"),ye("optionBaseFlag"),Ie("baseFlag")]),R=[...B?[{pubkey:B,isSigner:!1,isWritable:!0}]:[]],C=[{pubkey:t,isSigner:!0,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!1},{pubkey:s,isSigner:!0,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:d,isSigner:!1,isWritable:!0},{pubkey:f,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:m,isSigner:!1,isWritable:!0},{pubkey:rt,isSigner:!1,isWritable:!1},{pubkey:nt.programId,isSigner:!1,isWritable:!1},{pubkey:te,isSigner:!1,isWritable:!1},{pubkey:Yt,isSigner:!1,isWritable:!1},{pubkey:be,isSigner:!1,isWritable:!1},{pubkey:p,isSigner:!1,isWritable:!1},{pubkey:b,isSigner:!1,isWritable:!1},...R],N=Buffer.alloc(K.span);K.encode({tickLowerIndex:g,tickUpperIndex:w,tickArrayLowerStartIndex:k,tickArrayUpperStartIndex:A,liquidity:T,amountMaxA:P,amountMaxB:x,withMetadata:h==="create",baseFlag:!1,optionBaseFlag:0},N);let I=Buffer.from([...Oe.openPositionWithTokenEx,...N]);return new xe({keys:C,programId:e,data:I})}static async openPositionInstructions({poolInfo:e,poolKeys:t,ownerInfo:n,tickLower:i,tickUpper:s,liquidity:o,amountMaxA:r,amountMaxB:a,withMetadata:c,getEphemeralSigners:l,nft2022:d}){let f=[],[u,m]=[new S(e.programId),new S(e.id)],p;if(l)p=new S((await l(1))[0]);else{let B=dn.generate();f.push(B),p=B.publicKey}let b=M.getTickArrayStartIndexByTick(i,e.config.tickSpacing),g=M.getTickArrayStartIndexByTick(s,e.config.tickSpacing),{publicKey:w}=z(u,m,b),{publicKey:k}=z(u,m,g),{publicKey:A}=d?oe(n.wallet,p,be):oe(n.wallet,p,te),{publicKey:T}=Gt(p),{publicKey:P}=Ce(u,p),{publicKey:x}=_e(u,m,i,s),h=d?this.openPositionFromLiquidityInstruction22(u,n.feePayer,m,n.wallet,p,A,x,w,k,P,n.tokenAccountA,n.tokenAccountB,new S(t.vault.A),new S(t.vault.B),new S(e.mintA.address),new S(e.mintB.address),i,s,b,g,o,r,a,c,pe.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing,[b,g])?ge(u,m).publicKey:void 0):this.openPositionFromLiquidityInstruction(u,n.feePayer,m,n.wallet,p,A,T,x,w,k,P,n.tokenAccountA,n.tokenAccountB,new S(t.vault.A),new S(t.vault.B),new S(e.mintA.address),new S(e.mintB.address),i,s,b,g,o,r,a,c,pe.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing,[b,g])?ge(u,m).publicKey:void 0);return{signers:f,instructions:[h],instructionTypes:[re.ClmmOpenPosition],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[],address:{nftMint:p,tickArrayLower:w,tickArrayUpper:k,positionNftAccount:A,metadataAccount:T,personalPosition:P,protocolPosition:x}}}static async openPositionFromBaseInstructions({poolInfo:e,poolKeys:t,ownerInfo:n,tickLower:i,tickUpper:s,base:o,baseAmount:r,otherAmountMax:a,withMetadata:c,getEphemeralSigners:l,nft2022:d}){let f=[],[u,m]=[new S(e.programId),new S(e.id)],p;if(l)p=new S((await l(1))[0]);else{let B=dn.generate();f.push(B),p=B.publicKey}let b=M.getTickArrayStartIndexByTick(i,e.config.tickSpacing),g=M.getTickArrayStartIndexByTick(s,e.config.tickSpacing),{publicKey:w}=z(u,m,b),{publicKey:k}=z(u,m,g),{publicKey:A}=d?oe(n.wallet,p,be):oe(n.wallet,p,te),{publicKey:T}=Gt(p),{publicKey:P}=Ce(u,p),{publicKey:x}=_e(u,m,i,s),h=d?this.openPositionFromBaseInstruction22(u,n.feePayer,m,n.wallet,p,A,x,w,k,P,n.tokenAccountA,n.tokenAccountB,new S(t.vault.A),new S(t.vault.B),new S(e.mintA.address),new S(e.mintB.address),i,s,b,g,c,o,r,a,pe.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing,[b,g])?ge(u,m).publicKey:void 0):this.openPositionFromBaseInstruction(u,n.feePayer,m,n.wallet,p,A,T,x,w,k,P,n.tokenAccountA,n.tokenAccountB,new S(t.vault.A),new S(t.vault.B),new S(e.mintA.address),new S(e.mintB.address),i,s,b,g,c,o,r,a,pe.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing,[b,g])?ge(u,m).publicKey:void 0);return{address:{nftMint:p,tickArrayLower:w,tickArrayUpper:k,positionNftAccount:A,metadataAccount:T,personalPosition:P,protocolPosition:x},instructions:[h],signers:f,instructionTypes:[re.ClmmOpenPosition],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[]}}static openPositionFromBaseInstruction(e,t,n,i,s,o,r,a,c,l,d,f,u,m,p,b,g,w,k,A,T,P,x,h,B,K){let R=$([se("tickLowerIndex"),se("tickUpperIndex"),se("tickArrayLowerStartIndex"),se("tickArrayUpperStartIndex"),X("liquidity"),E("amountMaxA"),E("amountMaxB"),Ie("withMetadata"),ye("optionBaseFlag"),Ie("baseFlag")]),C=[...K?[{pubkey:K,isSigner:!1,isWritable:!0}]:[]],N=[{pubkey:t,isSigner:!0,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!1},{pubkey:s,isSigner:!0,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:d,isSigner:!1,isWritable:!0},{pubkey:f,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:m,isSigner:!1,isWritable:!0},{pubkey:p,isSigner:!1,isWritable:!0},{pubkey:rt,isSigner:!1,isWritable:!1},{pubkey:nt.programId,isSigner:!1,isWritable:!1},{pubkey:te,isSigner:!1,isWritable:!1},{pubkey:Yt,isSigner:!1,isWritable:!1},{pubkey:dt,isSigner:!1,isWritable:!1},{pubkey:be,isSigner:!1,isWritable:!1},{pubkey:b,isSigner:!1,isWritable:!1},{pubkey:g,isSigner:!1,isWritable:!1},...C],I=Buffer.alloc(R.span);R.encode({tickLowerIndex:w,tickUpperIndex:k,tickArrayLowerStartIndex:A,tickArrayUpperStartIndex:T,liquidity:new Xn(0),amountMaxA:x==="MintA"?h:B,amountMaxB:x==="MintA"?B:h,withMetadata:P==="create",baseFlag:x==="MintA",optionBaseFlag:1},I);let F=Buffer.from([...Oe.openPosition,...I]);return new xe({keys:N,programId:e,data:F})}static openPositionFromBaseInstruction22(e,t,n,i,s,o,r,a,c,l,d,f,u,m,p,b,g,w,k,A,T,P,x,h,B){let K=$([se("tickLowerIndex"),se("tickUpperIndex"),se("tickArrayLowerStartIndex"),se("tickArrayUpperStartIndex"),X("liquidity"),E("amountMaxA"),E("amountMaxB"),Ie("withMetadata"),ye("optionBaseFlag"),Ie("baseFlag")]),R=[...B?[{pubkey:B,isSigner:!1,isWritable:!0}]:[]],C=[{pubkey:t,isSigner:!0,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!1},{pubkey:s,isSigner:!0,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:d,isSigner:!1,isWritable:!0},{pubkey:f,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:m,isSigner:!1,isWritable:!0},{pubkey:rt,isSigner:!1,isWritable:!1},{pubkey:nt.programId,isSigner:!1,isWritable:!1},{pubkey:te,isSigner:!1,isWritable:!1},{pubkey:Yt,isSigner:!1,isWritable:!1},{pubkey:be,isSigner:!1,isWritable:!1},{pubkey:p,isSigner:!1,isWritable:!1},{pubkey:b,isSigner:!1,isWritable:!1},...R],N=Buffer.alloc(K.span);K.encode({tickLowerIndex:g,tickUpperIndex:w,tickArrayLowerStartIndex:k,tickArrayUpperStartIndex:A,liquidity:new Xn(0),amountMaxA:P==="MintA"?x:h,amountMaxB:P==="MintA"?h:x,withMetadata:T==="create",baseFlag:P==="MintA",optionBaseFlag:1},N);let I=Buffer.from([...Oe.openPositionWithTokenEx,...N]);return new xe({keys:C,programId:e,data:I})}static async openPositionFromLiquidityInstructions({poolInfo:e,poolKeys:t,ownerInfo:n,tickLower:i,tickUpper:s,liquidity:o,amountMaxA:r,amountMaxB:a,withMetadata:c,getEphemeralSigners:l,nft2022:d}){let f,u=[];if(l)f=new S((await l(1))[0]);else{let B=dn.generate();u.push(B),f=B.publicKey}let[m,p]=[new S(e.programId),new S(e.id)],b=M.getTickArrayStartIndexByTick(i,e.config.tickSpacing),g=M.getTickArrayStartIndexByTick(s,e.config.tickSpacing),{publicKey:w}=z(m,p,b),{publicKey:k}=z(m,p,g),{publicKey:A}=d?oe(n.wallet,f,be):oe(n.wallet,f,te),{publicKey:T}=Gt(f),{publicKey:P}=Ce(m,f),{publicKey:x}=_e(m,p,i,s),h=d?this.openPositionFromLiquidityInstruction22(m,n.wallet,p,n.wallet,f,A,x,w,k,P,n.tokenAccountA,n.tokenAccountB,new S(t.vault.A),new S(t.vault.B),new S(t.mintA.address),new S(t.mintB.address),i,s,b,g,o,r,a,c,pe.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing,[b,g])?ge(m,p).publicKey:void 0):this.openPositionFromLiquidityInstruction(m,n.wallet,p,n.wallet,f,A,T,x,w,k,P,n.tokenAccountA,n.tokenAccountB,new S(t.vault.A),new S(t.vault.B),new S(t.mintA.address),new S(t.mintB.address),i,s,b,g,o,r,a,c,pe.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing,[b,g])?ge(m,p).publicKey:void 0);return{address:{nftMint:f,tickArrayLower:w,tickArrayUpper:k,positionNftAccount:A,metadataAccount:T,personalPosition:P,protocolPosition:x},instructions:[h],signers:u,instructionTypes:[re.ClmmOpenPosition],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[]}}static closePositionInstruction(e,t,n,i,s,o){let r=$([]),a=[{pubkey:t,isSigner:!0,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:nt.programId,isSigner:!1,isWritable:!1},{pubkey:o?be:te,isSigner:!1,isWritable:!1}],c=Buffer.alloc(r.span);r.encode({},c);let l=Buffer.from([...Oe.closePosition,...c]);return new xe({keys:a,programId:e,data:l})}static closePositionInstructions({poolInfo:e,poolKeys:t,ownerInfo:n,ownerPosition:i,nft2022:s}){let o=new S(e.programId),r=s?oe(n.wallet,i.nftMint,be).publicKey:oe(n.wallet,i.nftMint,te).publicKey,{publicKey:a}=Ce(o,i.nftMint),c=[];return c.push(this.closePositionInstruction(o,n.wallet,i.nftMint,r,a,s)),{address:{positionNftAccount:r,personalPosition:a},signers:[],instructions:c,instructionTypes:[re.ClmmClosePosition],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[]}}static increasePositionFromLiquidityInstruction(e,t,n,i,s,o,r,a,c,l,d,f,u,m,p,b,g,w){let k=$([X("liquidity"),E("amountMaxA"),E("amountMaxB"),ye("optionBaseFlag"),Ie("baseFlag")]),A=[...w?[{pubkey:w,isSigner:!1,isWritable:!0}]:[]],T=[{pubkey:t,isSigner:!0,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:d,isSigner:!1,isWritable:!0},{pubkey:f,isSigner:!1,isWritable:!0},{pubkey:te,isSigner:!1,isWritable:!1},{pubkey:be,isSigner:!1,isWritable:!1},{pubkey:u,isSigner:!1,isWritable:!1},{pubkey:m,isSigner:!1,isWritable:!1},...A],P=Buffer.alloc(k.span);k.encode({liquidity:p,amountMaxA:b,amountMaxB:g,optionBaseFlag:0,baseFlag:!1},P);let x=Buffer.from([...Oe.increaseLiquidity,...P]);return new xe({keys:T,programId:e,data:x})}static increasePositionFromLiquidityInstructions({poolInfo:e,poolKeys:t,ownerPosition:n,ownerInfo:i,liquidity:s,amountMaxA:o,amountMaxB:r,nft2022:a}){let[c,l]=[new S(e.programId),new S(e.id)],d=M.getTickArrayStartIndexByTick(n.tickLower,e.config.tickSpacing),f=M.getTickArrayStartIndexByTick(n.tickUpper,e.config.tickSpacing),{publicKey:u}=z(c,l,d),{publicKey:m}=z(c,l,f),{publicKey:p}=a?oe(i.wallet,n.nftMint,be):oe(i.wallet,n.nftMint,te),{publicKey:b}=Ce(c,n.nftMint),{publicKey:g}=_e(c,l,n.tickLower,n.tickUpper),w=this.increasePositionFromLiquidityInstruction(c,i.wallet,p,b,l,g,u,m,i.tokenAccountA,i.tokenAccountB,new S(t.vault.A),new S(t.vault.B),new S(e.mintA.address),new S(e.mintB.address),s,o,r,pe.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing,[d,f])?ge(c,l).publicKey:void 0);return{address:{tickArrayLower:u,tickArrayUpper:m,positionNftAccount:p,personalPosition:b,protocolPosition:g},signers:[],instructions:[w],instructionTypes:[re.ClmmIncreasePosition],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[]}}static increasePositionFromBaseInstructions({poolInfo:e,poolKeys:t,ownerPosition:n,ownerInfo:i,base:s,baseAmount:o,otherAmountMax:r,nft2022:a}){let[c,l]=[new S(e.programId),new S(e.id)],d=M.getTickArrayStartIndexByTick(n.tickLower,e.config.tickSpacing),f=M.getTickArrayStartIndexByTick(n.tickUpper,e.config.tickSpacing),{publicKey:u}=z(c,l,d),{publicKey:m}=z(c,l,f),{publicKey:p}=a?oe(i.wallet,n.nftMint,be):oe(i.wallet,n.nftMint,te),{publicKey:b}=Ce(c,n.nftMint),{publicKey:g}=_e(c,l,n.tickLower,n.tickUpper);return{address:{tickArrayLower:u,tickArrayUpper:m,positionNftAccount:p,personalPosition:b,protocolPosition:g},instructions:[this.increasePositionFromBaseInstruction(c,i.wallet,p,b,l,g,u,m,i.tokenAccountA,i.tokenAccountB,new S(t.vault.A),new S(t.vault.B),new S(e.mintA.address),new S(e.mintB.address),s,o,r,pe.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing,[d,f])?ge(c,l).publicKey:void 0)],signers:[],instructionTypes:[re.ClmmIncreasePosition],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[]}}static increasePositionFromBaseInstruction(e,t,n,i,s,o,r,a,c,l,d,f,u,m,p,b,g,w){let k=$([X("liquidity"),E("amountMaxA"),E("amountMaxB"),ye("optionBaseFlag"),Ie("baseFlag")]),A=[...w?[{pubkey:w,isSigner:!1,isWritable:!0}]:[]],T=[{pubkey:t,isSigner:!0,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:d,isSigner:!1,isWritable:!0},{pubkey:f,isSigner:!1,isWritable:!0},{pubkey:te,isSigner:!1,isWritable:!1},{pubkey:be,isSigner:!1,isWritable:!1},{pubkey:u,isSigner:!1,isWritable:!1},{pubkey:m,isSigner:!1,isWritable:!1},...A],P=Buffer.alloc(k.span);k.encode({liquidity:new Xn(0),amountMaxA:p==="MintA"?b:g,amountMaxB:p==="MintA"?g:b,baseFlag:p==="MintA",optionBaseFlag:1},P);let x=Buffer.from([...Oe.increaseLiquidity,...P]);return new xe({keys:T,programId:e,data:x})}static decreaseLiquidityInstruction(e,t,n,i,s,o,r,a,c,l,d,f,u,m,p,b,g,w,k){let A=$([X("liquidity"),E("amountMinA"),E("amountMinB")]),T=[...k?[{pubkey:k,isSigner:!1,isWritable:!0}]:[],...p.map(B=>[{pubkey:B.poolRewardVault,isSigner:!1,isWritable:!0},{pubkey:B.ownerRewardVault,isSigner:!1,isWritable:!0},{pubkey:B.rewardMint,isSigner:!1,isWritable:!1}]).flat()],P=[{pubkey:t,isSigner:!0,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:d,isSigner:!1,isWritable:!0},{pubkey:f,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:te,isSigner:!1,isWritable:!1},{pubkey:be,isSigner:!1,isWritable:!1},{pubkey:en,isSigner:!1,isWritable:!1},{pubkey:u,isSigner:!1,isWritable:!1},{pubkey:m,isSigner:!1,isWritable:!1},...T],x=Buffer.alloc(A.span);A.encode({liquidity:b,amountMinA:g,amountMinB:w},x);let h=Buffer.from([...Oe.decreaseLiquidity,...x]);return new xe({keys:P,programId:e,data:h})}static decreaseLiquidityInstructions({poolInfo:e,poolKeys:t,ownerPosition:n,ownerInfo:i,liquidity:s,amountMinA:o,amountMinB:r,programId:a,nft2022:c}){let[l,d]=[new S(e.programId),new S(e.id)],f=M.getTickArrayStartIndexByTick(n.tickLower,e.config.tickSpacing),u=M.getTickArrayStartIndexByTick(n.tickUpper,e.config.tickSpacing),{publicKey:m}=z(l,d,f),{publicKey:p}=z(l,d,u),{publicKey:b}=c?oe(i.wallet,n.nftMint,be):oe(i.wallet,n.nftMint,a),{publicKey:g}=Ce(l,n.nftMint),{publicKey:w}=_e(l,d,n.tickLower,n.tickUpper),k=[];for(let P=0;P<e.rewardDefaultInfos.length;P++)k.push({poolRewardVault:new S(t.rewardInfos[P].vault),ownerRewardVault:i.rewardAccounts[P],rewardMint:new S(e.rewardDefaultInfos[P].mint.address)});let A=[],T=this.decreaseLiquidityInstruction(l,i.wallet,b,g,d,w,m,p,i.tokenAccountA,i.tokenAccountB,new S(t.vault.A),new S(t.vault.B),new S(e.mintA.address),new S(e.mintB.address),k,s,o,r,pe.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing,[f,u])?ge(l,d).publicKey:void 0);return A.push(T),{address:{tickArrayLower:m,tickArrayUpper:p,positionNftAccount:b,personalPosition:g,protocolPosition:w},signers:[],instructions:A,instructionTypes:[re.ClmmDecreasePosition],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[]}}static swapInstruction(e,t,n,i,s,o,r,a,c,l,d,f,u,m,p,b,g){let w=$([E("amount"),E("otherAmountThreshold"),X("sqrtPriceLimitX64"),Ie("isBaseInput")]),k=[...g?[{pubkey:g,isSigner:!1,isWritable:!0}]:[],...d.map(x=>({pubkey:x,isSigner:!1,isWritable:!0}))],A=[{pubkey:t,isSigner:!0,isWritable:!1},{pubkey:i,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:f,isSigner:!1,isWritable:!0},{pubkey:te,isSigner:!1,isWritable:!1},{pubkey:be,isSigner:!1,isWritable:!1},{pubkey:en,isSigner:!1,isWritable:!1},{pubkey:c,isSigner:!1,isWritable:!1},{pubkey:l,isSigner:!1,isWritable:!1},...k],T=Buffer.alloc(w.span);w.encode({amount:u,otherAmountThreshold:m,sqrtPriceLimitX64:p,isBaseInput:b},T);let P=Buffer.from([...Oe.swap,...T]);return new xe({keys:A,programId:e,data:P})}static makeSwapBaseInInstructions({poolInfo:e,poolKeys:t,observationId:n,ownerInfo:i,inputMint:s,amountIn:o,amountOutMin:r,sqrtPriceLimitX64:a,remainingAccounts:c}){let[l,d]=[new S(e.programId),new S(e.id)],[f,u]=[new S(t.vault.A),new S(t.vault.B)],[m,p]=[new S(e.mintA.address),new S(e.mintB.address)],b=e.mintA.address===s.toString(),g=[this.swapInstruction(l,i.wallet,d,new S(e.config.id),b?i.tokenAccountA:i.tokenAccountB,b?i.tokenAccountB:i.tokenAccountA,b?f:u,b?u:f,b?m:p,b?p:m,c,n,o,r,a,!0,ge(l,d).publicKey)];return{signers:[],instructions:g,instructionTypes:[re.ClmmSwapBaseIn],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[],address:{}}}static makeSwapBaseOutInstructions({poolInfo:e,poolKeys:t,observationId:n,ownerInfo:i,outputMint:s,amountOut:o,amountInMax:r,sqrtPriceLimitX64:a,remainingAccounts:c}){let[l,d]=[new S(e.programId),new S(e.id)],[f,u]=[new S(t.vault.A),new S(t.vault.B)],[m,p]=[new S(e.mintA.address),new S(e.mintB.address)],b=e.mintA.address===s.toBase58(),g=[this.swapInstruction(l,i.wallet,d,new S(e.config.id),b?i.tokenAccountB:i.tokenAccountA,b?i.tokenAccountA:i.tokenAccountB,b?u:f,b?f:u,b?p:m,b?m:p,c,n,o,r,a,!1,ge(l,d).publicKey)];return{signers:[],instructions:g,instructionTypes:[re.ClmmSwapBaseOut],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[],address:{}}}static initRewardInstruction(e,t,n,i,s,o,r,a,c,l,d,f){let u=$([E("openTime"),E("endTime"),X("emissionsPerSecondX64")]),m=[{pubkey:t,isSigner:!0,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!1},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!1},{pubkey:nt.programId,isSigner:!1,isWritable:!1},{pubkey:rt,isSigner:!1,isWritable:!1}],p=Buffer.alloc(u.span);u.encode({openTime:we(l),endTime:we(d),emissionsPerSecondX64:f},p);let b=Buffer.from([...Oe.initReward,...p]);return new xe({keys:m,programId:e,data:b})}static initRewardInstructions({poolInfo:e,poolKeys:t,ownerInfo:n,rewardInfo:i}){let[s,o]=[new S(e.programId),new S(e.id)],r=Li(s,o,i.mint).publicKey,a=Ut(s).publicKey,c=[this.initRewardInstruction(s,n.wallet,o,a,new S(e.config.id),n.tokenAccount,i.programId,i.mint,r,i.openTime,i.endTime,i.emissionsPerSecondX64)];return{address:{poolRewardVault:r,operationId:a},signers:[],instructions:c,instructionTypes:[re.ClmmInitReward],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[]}}static setRewardInstruction(e,t,n,i,s,o,r,a,c,l,d,f){let u=$([ye("rewardIndex"),X("emissionsPerSecondX64"),E("openTime"),E("endTime")]),m=[{pubkey:t,isSigner:!0,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:te,isSigner:!1,isWritable:!1},{pubkey:be,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0}],p=Buffer.alloc(u.span);u.encode({rewardIndex:c,emissionsPerSecondX64:f,openTime:we(l),endTime:we(d)},p);let b=Buffer.from([...Oe.setRewardEmissions,...p]);return new xe({keys:m,programId:e,data:b})}static setRewardInstructions({poolInfo:e,poolKeys:t,ownerInfo:n,rewardInfo:i}){let[s,o]=[new S(e.programId),new S(e.id)],r,a,c;for(let f=0;f<e.rewardDefaultInfos.length;f++)e.rewardDefaultInfos[f].mint.address===i.mint.toString()&&(r=f,a=new S(t.rewardInfos[f].vault),c=new S(t.rewardInfos[f].mint.address));(r===void 0||a===void 0)&&Wi.logWithError("reward mint check error","no reward mint",e.rewardDefaultInfos);let l=Ut(s).publicKey,d=[this.setRewardInstruction(s,n.wallet,o,l,new S(e.config.id),n.tokenAccount,a,c,r,i.openTime,i.endTime,i.emissionsPerSecondX64)];return{address:{rewardVault:a,operationId:l},signers:[],instructions:d,instructionTypes:[re.ClmmSetReward],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[]}}static collectRewardInstruction(e,t,n,i,s,o,r){let a=$([ye("rewardIndex")]),c=[{pubkey:t,isSigner:!0,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:te,isSigner:!1,isWritable:!1},{pubkey:be,isSigner:!1,isWritable:!1},{pubkey:en,isSigner:!1,isWritable:!1}],l=Buffer.alloc(a.span);a.encode({rewardIndex:r},l);let d=Buffer.from([...Oe.collectReward,...l]);return new xe({keys:c,programId:e,data:d})}static collectRewardInstructions({poolInfo:e,poolKeys:t,ownerInfo:n,rewardMint:i}){let[s,o]=[new S(e.programId),new S(e.id)],r,a;for(let l=0;l<e.rewardDefaultInfos.length;l++)e.rewardDefaultInfos[l].mint.address===i.toString()&&(r=l,a=new S(t.rewardInfos[l].vault));(r===void 0||a===void 0)&&Wi.logWithError("reward mint check error","no reward mint",e.rewardDefaultInfos);let c=[this.collectRewardInstruction(s,n.wallet,o,n.tokenAccount,a,i,r)];return{address:{rewardVault:a},signers:[],instructions:c,instructionTypes:[re.ClmmCollectReward],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[]}}static async makeLockPositions({programId:e,authProgramId:t,poolProgramId:n,payer:i,wallet:s,nftMint:o,nft2022:r,getEphemeralSigners:a}){let c=[],l;if(a)l=new S((await a(1))[0]);else{let g=dn.generate();c.push(g),l=g.publicKey}let d=r?oe(s,o,be).publicKey:oe(s,o,te).publicKey,{publicKey:f}=Ce(n,o),u=ht(e,l).publicKey,m=oe(s,l,te).publicKey,p=Gt(l).publicKey,b=ce.lockPositionInstructionV2({programId:e,auth:t,payer:i,positionOwner:s,lockOwner:s,positionNftAccount:d,positionId:f,lockPositionId:u,lockNftMint:l,lockNftAccount:m,metadataAccount:p,withMetadata:!0,nft2022:r,positionNftMint:o,authPositionNftAccount:oe(t,o,r?be:te).publicKey,positionNftProgram:r?be:te});return{address:{positionId:f,lockPositionId:u,lockNftAccount:m,lockNftMint:l,positionNftAccount:d,metadataAccount:p},instructions:[b],signers:c,instructionTypes:[re.ClmmLockPosition],lookupTableAddress:[]}}static lockPositionInstructionV2({programId:e,auth:t,payer:n,positionOwner:i,lockOwner:s,positionNftAccount:o,positionId:r,positionNftMint:a,authPositionNftAccount:c,positionNftProgram:l,lockPositionId:d,lockNftMint:f,lockNftAccount:u,metadataAccount:m,withMetadata:p}){let b=[{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!0,isWritable:!0},{pubkey:i,isSigner:!0,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!1},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:d,isSigner:!1,isWritable:!0},{pubkey:f,isSigner:!0,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:m,isSigner:!1,isWritable:!0},{pubkey:dt,isSigner:!1,isWritable:!1},{pubkey:Yt,isSigner:!1,isWritable:!1},{pubkey:rt,isSigner:!1,isWritable:!1},{pubkey:te,isSigner:!1,isWritable:!1},{pubkey:l,isSigner:!1,isWritable:!1},{pubkey:nt.programId,isSigner:!1,isWritable:!1}],g=$([Ie("withMetadata")]),w=Buffer.alloc(g.span);g.encode({withMetadata:p},w);let k=Buffer.from([...qi,...w]);return new xe({keys:b,programId:e,data:k})}static lockPositionInstruction({programId:e,authProgramId:t,poolProgramId:n,owner:i,positionNft:s}){let{publicKey:o}=oe(i,s,te),{publicKey:r}=Ce(n,s),a=[{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:i,isSigner:!0,isWritable:!1},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!1},{pubkey:Vn(e,r).publicKey,isSigner:!1,isWritable:!0},{pubkey:te,isSigner:!1,isWritable:!1},{pubkey:nt.programId,isSigner:!1,isWritable:!1}];return new xe({keys:a,programId:e,data:Buffer.from(qi)})}static harvestLockPositionInstruction(e){let[t,n]=[new S(e.poolKeys.programId),new S(e.poolKeys.id)],i=M.getTickArrayStartIndexByTick(e.ownerPosition.tickLower,e.poolKeys.config.tickSpacing),s=M.getTickArrayStartIndexByTick(e.ownerPosition.tickUpper,e.poolKeys.config.tickSpacing),{publicKey:o}=z(t,n,i),{publicKey:r}=z(t,n,s),{publicKey:a}=oe(e.owner,e.ownerPosition.nftMint,te),{publicKey:c}=Ce(t,e.ownerPosition.nftMint),{publicKey:l}=_e(t,n,e.ownerPosition.tickLower,e.ownerPosition.tickUpper),d=[];for(let m=0;m<e.poolKeys.rewardInfos.length;m++)d.push({poolRewardVault:new S(e.poolKeys.rewardInfos[m].vault),ownerRewardVault:e.ownerRewardAccounts[m],rewardMint:new S(e.poolKeys.rewardInfos[m].mint.address)});let f=[...d.map(m=>[{pubkey:m.poolRewardVault,isSigner:!1,isWritable:!0},{pubkey:m.ownerRewardVault,isSigner:!1,isWritable:!0},{pubkey:m.rewardMint,isSigner:!1,isWritable:!1}]).flat()],u=[{pubkey:e.authProgramId,isSigner:!1,isWritable:!1},{pubkey:Vn(e.programId,c).publicKey,isSigner:!1,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:e.owner,isSigner:!0,isWritable:!1},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:new S(e.poolKeys.vault.A),isSigner:!1,isWritable:!0},{pubkey:new S(e.poolKeys.vault.B),isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:e.userVaultA,isSigner:!1,isWritable:!0},{pubkey:e.userVaultB,isSigner:!1,isWritable:!0},{pubkey:te,isSigner:!1,isWritable:!1},{pubkey:be,isSigner:!1,isWritable:!1},{pubkey:An,isSigner:!1,isWritable:!1},{pubkey:new S(e.poolKeys.mintA.address),isSigner:!1,isWritable:!1},{pubkey:new S(e.poolKeys.mintB.address),isSigner:!1,isWritable:!1},...f];return new xe({keys:u,programId:e.programId,data:Buffer.from(Gi)})}static harvestLockPositionInstructionV2({programId:e,auth:t,lockPositionId:n,clmmProgram:i,lockOwner:s,lockNftMint:o,lockNftAccount:r,positionNftAccount:a,positionId:c,poolId:l,protocolPosition:d,vaultA:f,vaultB:u,tickArrayLower:m,tickArrayUpper:p,userVaultA:b,userVaultB:g,mintA:w,mintB:k,rewardAccounts:A,exTickArrayBitmap:T}){let P=[...T?[{pubkey:T,isSigner:!1,isWritable:!0}]:[],...A.map(h=>[{pubkey:h.poolRewardVault,isSigner:!1,isWritable:!0},{pubkey:h.ownerRewardVault,isSigner:!1,isWritable:!0},{pubkey:h.rewardMint,isSigner:!1,isWritable:!1}]).flat()],x=[{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:s,isSigner:!0,isWritable:!1},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:i,isSigner:!1,isWritable:!1},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:d,isSigner:!1,isWritable:!0},{pubkey:f,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:m,isSigner:!1,isWritable:!0},{pubkey:p,isSigner:!1,isWritable:!0},{pubkey:b,isSigner:!1,isWritable:!0},{pubkey:g,isSigner:!1,isWritable:!0},{pubkey:te,isSigner:!1,isWritable:!1},{pubkey:be,isSigner:!1,isWritable:!1},{pubkey:An,isSigner:!1,isWritable:!1},{pubkey:w,isSigner:!1,isWritable:!1},{pubkey:k,isSigner:!1,isWritable:!1},...P];return new xe({keys:x,programId:e,data:Buffer.from(Gi)})}};var Hn=class extends Vt{constructor(e){super(e)}async getClmmPoolKeys(e){return(await this.scope.api.fetchPoolKeysById({idList:[e]}))[0]}async createPool(e){var x;let{programId:t,owner:n=((x=this.scope.owner)==null?void 0:x.publicKey)||L.default,mint1:i,mint2:s,ammConfig:o,initialPrice:r,computeBudgetConfig:a,forerunCreate:c,getObserveState:l,txVersion:d,txTipConfig:f,feePayer:u}=e,m=this.createTxBuilder(u),[p,b,g]=new Ke(new L(i.address).toBuffer()).gt(new Ke(new L(s.address).toBuffer()))?[s,i,new Pt(1).div(r)]:[i,s,r],w=_.priceToSqrtPriceX64(g,p.decimals,b.decimals),k=[],A=[];p.programId===ut.toBase58()&&A.push(vn(t,new L(p.address)).publicKey),b.programId===ut.toBase58()&&A.push(vn(t,new L(b.address)).publicKey),(await this.scope.connection.getMultipleAccountsInfo(A)).forEach((h,B)=>{h&&k.push(A[B])});let P=await ce.createPoolInstructions({connection:this.scope.connection,programId:t,owner:n,mintA:p,mintB:b,ammConfigId:o.id,initialPriceX64:w,forerunCreate:!l&&c,extendMintAccount:k});return m.addInstruction(P),m.addCustomComputeBudget(a),m.addTipInstruction(f),m.versionBuild({txVersion:d,extInfo:{address:U(O({},P.address),{observationId:P.address.observationId.toBase58(),exBitmapAccount:P.address.exBitmapAccount.toBase58(),programId:t.toString(),id:P.address.poolId.toString(),mintA:p,mintB:b,openTime:"0",vault:{A:P.address.mintAVault.toString(),B:P.address.mintBVault.toString()},rewardInfos:[],config:{id:o.id.toString(),index:o.index,protocolFeeRate:o.protocolFeeRate,tradeFeeRate:o.tradeFeeRate,tickSpacing:o.tickSpacing,fundFeeRate:o.fundFeeRate,description:o.description,defaultRange:0,defaultRangePoint:[]}}),mockPoolInfo:O({type:"Concentrated",rewardDefaultPoolInfos:"Clmm",id:P.address.poolId.toString(),mintA:p,mintB:b,feeRate:o.tradeFeeRate,openTime:"0",programId:t.toString(),price:g.toNumber(),config:{id:o.id.toString(),index:o.index,protocolFeeRate:o.protocolFeeRate,tradeFeeRate:o.tradeFeeRate,tickSpacing:o.tickSpacing,fundFeeRate:o.fundFeeRate,description:o.description,defaultRange:0,defaultRangePoint:[]},burnPercent:0},Bi),forerunCreate:c}})}async openPositionFromBase({poolInfo:e,poolKeys:t,ownerInfo:n,tickLower:i,tickUpper:s,base:o,baseAmount:r,otherAmountMax:a,nft2022:c,associatedOnly:l=!0,checkCreateATAOwner:d=!1,withMetadata:f="create",getEphemeralSigners:u,computeBudgetConfig:m,txTipConfig:p,txVersion:b,feePayer:g}){this.scope.availability.addConcentratedPosition===!1&&this.logAndCreateError("add position feature disabled in your region"),this.scope.checkOwner();let w=this.createTxBuilder(g),k=null,A=null,T=n.useSOLBalance&&e.mintA.address===Q.toString(),P=n.useSOLBalance&&e.mintB.address===Q.toString(),[x,h]=o==="MintA"?[r,a]:[a,r],{account:B,instructionParams:K}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:e.mintA.programId,mint:new L(e.mintA.address),owner:this.scope.ownerPubKey,createInfo:T||x.isZero()?{payer:this.scope.ownerPubKey,amount:x}:void 0,skipCloseAccount:!T,notUseTokenAccount:T,associatedOnly:T?!1:l,checkCreateATAOwner:d});B&&(k=B),w.addInstruction(K||{});let{account:R,instructionParams:C}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:e.mintB.programId,mint:new L(e.mintB.address),owner:this.scope.ownerPubKey,createInfo:P||h.isZero()?{payer:this.scope.ownerPubKey,amount:h}:void 0,skipCloseAccount:!P,notUseTokenAccount:P,associatedOnly:P?!1:l,checkCreateATAOwner:d});R&&(A=R),w.addInstruction(C||{}),(!k||!A)&&this.logAndCreateError("cannot found target token accounts","tokenAccounts",{ownerTokenAccountA:k==null?void 0:k.toBase58(),ownerTokenAccountB:A==null?void 0:A.toBase58()});let N=t||await this.getClmmPoolKeys(e.id),I=await ce.openPositionFromBaseInstructions({poolInfo:e,poolKeys:N,ownerInfo:U(O({},n),{feePayer:this.scope.ownerPubKey,wallet:this.scope.ownerPubKey,tokenAccountA:k,tokenAccountB:A}),tickLower:i,tickUpper:s,base:o,baseAmount:r,otherAmountMax:a,withMetadata:f,getEphemeralSigners:u,nft2022:c});return w.addInstruction(I),w.addCustomComputeBudget(m),w.addTipInstruction(p),w.versionBuild({txVersion:b,extInfo:O({},I.address)})}async openPositionFromLiquidity({poolInfo:e,poolKeys:t,ownerInfo:n,amountMaxA:i,amountMaxB:s,tickLower:o,tickUpper:r,liquidity:a,associatedOnly:c=!0,checkCreateATAOwner:l=!1,withMetadata:d="create",txVersion:f,computeBudgetConfig:u,txTipConfig:m,getEphemeralSigners:p,nft2022:b,feePayer:g}){this.scope.availability.createConcentratedPosition===!1&&this.logAndCreateError("open position feature disabled in your region");let w=this.createTxBuilder(g),k=null,A=null,T=n.useSOLBalance&&e.mintA.address===Q.toBase58(),P=n.useSOLBalance&&e.mintB.address===Q.toBase58(),{account:x,instructionParams:h}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:e.mintA.programId,mint:new L(e.mintA.address),owner:this.scope.ownerPubKey,createInfo:T||i.isZero()?{payer:this.scope.ownerPubKey,amount:i}:void 0,skipCloseAccount:!T,notUseTokenAccount:T,associatedOnly:T?!1:c,checkCreateATAOwner:l});x&&(k=x),w.addInstruction(h||{});let{account:B,instructionParams:K}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:e.mintB.programId,mint:new L(e.mintB.address),owner:this.scope.ownerPubKey,createInfo:P||s.isZero()?{payer:this.scope.ownerPubKey,amount:s}:void 0,skipCloseAccount:!P,notUseTokenAccount:P,associatedOnly:P?!1:c,checkCreateATAOwner:l});B&&(A=B),w.addInstruction(K||{}),(k===void 0||A===void 0)&&this.logAndCreateError("cannot found target token accounts","tokenAccounts",this.scope.account.tokenAccounts);let R=t||await this.getClmmPoolKeys(e.id),C=await ce.openPositionFromLiquidityInstructions({poolInfo:e,poolKeys:R,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccountA:k,tokenAccountB:A},tickLower:o,tickUpper:r,liquidity:a,amountMaxA:i,amountMaxB:s,withMetadata:d,getEphemeralSigners:p,nft2022:b});return w.addInstruction(C),w.addCustomComputeBudget(u),w.addTipInstruction(m),w.versionBuild({txVersion:f,extInfo:{address:C.address}})}async increasePositionFromLiquidity(e){var K;let{poolInfo:t,poolKeys:n,ownerPosition:i,amountMaxA:s,amountMaxB:o,liquidity:r,ownerInfo:a,associatedOnly:c=!0,checkCreateATAOwner:l=!1,computeBudgetConfig:d,txTipConfig:f,txVersion:u,feePayer:m}=e,p=this.createTxBuilder(m),b,g,w=a.useSOLBalance&&t.mintA.address===Q.toString(),k=a.useSOLBalance&&t.mintB.address===Q.toString(),{account:A,instructionParams:T}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:t.mintA.programId,mint:new L(t.mintA.address),notUseTokenAccount:w,owner:this.scope.ownerPubKey,createInfo:w||s.isZero()?{payer:this.scope.ownerPubKey,amount:s}:void 0,skipCloseAccount:!w,associatedOnly:w?!1:c,checkCreateATAOwner:l});A&&(b=A),p.addInstruction(T||{});let{account:P,instructionParams:x}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:t.mintB.programId,mint:new L(t.mintB.address),owner:this.scope.ownerPubKey,createInfo:k||o.isZero()?{payer:this.scope.ownerPubKey,amount:o}:void 0,notUseTokenAccount:k,skipCloseAccount:!k,associatedOnly:k?!1:c,checkCreateATAOwner:l});P&&(g=P),p.addInstruction(x||{}),!b&&!g&&this.logAndCreateError("cannot found target token accounts","tokenAccounts",this.scope.account.tokenAccounts);let h=n!=null?n:await this.getClmmPoolKeys(t.id),B=ce.increasePositionFromLiquidityInstructions({poolInfo:t,poolKeys:h,ownerPosition:i,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccountA:b,tokenAccountB:g},liquidity:r,amountMaxA:s,amountMaxB:o,nft2022:(K=await this.scope.connection.getAccountInfo(i.nftMint))==null?void 0:K.owner.equals(ut)});return p.addInstruction(B),p.addCustomComputeBudget(d),p.addTipInstruction(f),p.versionBuild({txVersion:u,extInfo:{address:B.address}})}async increasePositionFromBase(e){var B;let{poolInfo:t,ownerPosition:n,base:i,baseAmount:s,otherAmountMax:o,ownerInfo:r,associatedOnly:a=!0,checkCreateATAOwner:c=!1,computeBudgetConfig:l,txTipConfig:d,txVersion:f,feePayer:u}=e,m=this.createTxBuilder(u),p,b,g=r.useSOLBalance&&t.mintA.address===Q.toString(),w=r.useSOLBalance&&t.mintB.address===Q.toString(),{account:k,instructionParams:A}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:t.mintA.programId,mint:new L(t.mintA.address),notUseTokenAccount:g,owner:this.scope.ownerPubKey,createInfo:g||(i==="MintA"?s:o).isZero()?{payer:this.scope.ownerPubKey,amount:i==="MintA"?s:o}:void 0,skipCloseAccount:!g,associatedOnly:g?!1:a,checkCreateATAOwner:c});k&&(p=k),m.addInstruction(A||{});let{account:T,instructionParams:P}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:t.mintB.programId,mint:new L(t.mintB.address),owner:this.scope.ownerPubKey,createInfo:w||(i==="MintA"?o:s).isZero()?{payer:this.scope.ownerPubKey,amount:i==="MintA"?o:s}:void 0,notUseTokenAccount:w,skipCloseAccount:!w,associatedOnly:w?!1:a,checkCreateATAOwner:c});T&&(b=T),m.addInstruction(P||{}),!p&&!b&&this.logAndCreateError("cannot found target token accounts","tokenAccounts",this.scope.account.tokenAccounts);let x=await this.getClmmPoolKeys(t.id),h=ce.increasePositionFromBaseInstructions({poolInfo:t,poolKeys:x,ownerPosition:n,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccountA:p,tokenAccountB:b},base:i,baseAmount:s,otherAmountMax:o,nft2022:(B=await this.scope.connection.getAccountInfo(n.nftMint))==null?void 0:B.owner.equals(ut)});return m.addInstruction(h),m.addCustomComputeBudget(l),m.addTipInstruction(d),m.versionBuild({txVersion:f,extInfo:{address:h.address}})}async decreaseLiquidity(e){var N;let{poolInfo:t,poolKeys:n,ownerPosition:i,ownerInfo:s,amountMinA:o,amountMinB:r,liquidity:a,associatedOnly:c=!0,checkCreateATAOwner:l=!1,computeBudgetConfig:d,txTipConfig:f,txVersion:u,feePayer:m}=e;this.scope.availability.removeConcentratedPosition===!1&&this.logAndCreateError("remove position feature disabled in your region");let p=this.createTxBuilder(m),b=s.useSOLBalance&&t.mintA.address===Q.toString(),g=s.useSOLBalance&&t.mintB.address===Q.toString(),w,k,{account:A,instructionParams:T}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:t.mintA.programId,mint:new L(t.mintA.address),notUseTokenAccount:b,owner:this.scope.ownerPubKey,createInfo:{payer:this.scope.ownerPubKey,amount:0},skipCloseAccount:!b,associatedOnly:b?!1:c,checkCreateATAOwner:l});w=A,T&&p.addInstruction(T);let{account:P,instructionParams:x}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:t.mintB.programId,mint:new L(t.mintB.address),notUseTokenAccount:g,owner:this.scope.ownerPubKey,createInfo:{payer:this.scope.ownerPubKey,amount:0},skipCloseAccount:!g,associatedOnly:g?!1:c,checkCreateATAOwner:l});k=P,x&&p.addInstruction(x);let h=[];for(let I of t.rewardDefaultInfos){let F=s.useSOLBalance&&I.mint.address===Q.toString(),q;if(I.mint.address===t.mintA.address)q=w;else if(I.mint.address===t.mintB.address)q=k;else{let{account:ue,instructionParams:fe}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:new L(I.mint.programId),mint:new L(I.mint.address),notUseTokenAccount:F,owner:this.scope.ownerPubKey,createInfo:{payer:this.scope.ownerPubKey,amount:0},skipCloseAccount:!F,associatedOnly:F?!1:c,checkCreateATAOwner:l});q=ue,fe&&p.addInstruction(fe)}h.push(q)}!w&&!k&&this.logAndCreateError("cannot found target token accounts","tokenAccounts",this.scope.account.tokenAccountRawInfos);let B=n!=null?n:await this.getClmmPoolKeys(t.id),K=(N=await this.scope.connection.getAccountInfo(i.nftMint))==null?void 0:N.owner.equals(ut),R=await ce.decreaseLiquidityInstructions({poolInfo:t,poolKeys:B,ownerPosition:i,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccountA:w,tokenAccountB:k,rewardAccounts:h},liquidity:a,amountMinA:o,amountMinB:r,nft2022:K});p.addInstruction({instructions:R.instructions,instructionTypes:[re.ClmmDecreasePosition]});let C=O({},R.address);if(s.closePosition){let I=await ce.closePositionInstructions({poolInfo:t,poolKeys:B,ownerInfo:{wallet:this.scope.ownerPubKey},ownerPosition:i,nft2022:K});p.addInstruction({endInstructions:I.instructions,endInstructionTypes:I.instructionTypes}),C=O(O({},C),I.address)}return p.addCustomComputeBudget(d),p.addTipInstruction(f),p.versionBuild({txVersion:u,extInfo:{address:C}})}async lockPosition(e){var m;let{programId:t=Ot,authProgramId:n=nn,poolProgramId:i=Mt,ownerPosition:s,payer:o,computeBudgetConfig:r,txTipConfig:a,txVersion:c,getEphemeralSigners:l,feePayer:d}=e,f=this.createTxBuilder(d),u=await ce.makeLockPositions({programId:t,authProgramId:n,poolProgramId:i,wallet:this.scope.ownerPubKey,payer:o!=null?o:this.scope.ownerPubKey,nftMint:s.nftMint,getEphemeralSigners:l,nft2022:(m=await this.scope.connection.getAccountInfo(s.nftMint))==null?void 0:m.owner.equals(ut)});return f.addInstruction(u),f.addCustomComputeBudget(r),f.addTipInstruction(a),f.versionBuild({txVersion:c,extInfo:u.address})}async harvestLockPosition(e){let{programId:t=Ot,authProgramId:n=nn,clmmProgram:i=Mt,poolKeys:s,lockData:o,ownerInfo:r={useSOLBalance:!0},associatedOnly:a=!0,checkCreateATAOwner:c=!1,computeBudgetConfig:l,txTipConfig:d,txVersion:f,feePayer:u}=e,m=s||await this.getClmmPoolKeys(o.poolId.toString()),p=this.createTxBuilder(u),b=await this.scope.connection.getAccountInfo(o.positionId);b||this.logger.logWithError("position not found",o.positionId);let g=xt.decode(b.data),w=r.useSOLBalance&&m.mintA.address===Q.toString(),k=r.useSOLBalance&&m.mintB.address===Q.toString(),A,T,{account:P,instructionParams:x}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:m.mintA.programId,mint:new L(m.mintA.address),notUseTokenAccount:w,owner:this.scope.ownerPubKey,createInfo:{payer:this.scope.ownerPubKey,amount:0},skipCloseAccount:!w,associatedOnly:w?!1:a,checkCreateATAOwner:c});A=P,x&&p.addInstruction(x);let{account:h,instructionParams:B}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:m.mintB.programId,mint:new L(m.mintB.address),notUseTokenAccount:k,owner:this.scope.ownerPubKey,createInfo:{payer:this.scope.ownerPubKey,amount:0},skipCloseAccount:!k,associatedOnly:k?!1:a,checkCreateATAOwner:c});T=h,B&&p.addInstruction(B);let K={},R=[];for(let ee of m.rewardInfos){let ie=r.useSOLBalance&&ee.mint.address===Q.toString(),Ve=K[ee.mint.address];if(!Ve){let{account:Hi,instructionParams:zn}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:new L(ee.mint.programId),mint:new L(ee.mint.address),notUseTokenAccount:ie,owner:this.scope.ownerPubKey,skipCloseAccount:!ie,createInfo:{payer:this.scope.ownerPubKey,amount:0},associatedOnly:ie?!1:a});Ve=Hi,zn&&p.addInstruction(zn)}K[ee.mint.address]=Ve,R.push(Ve)}let C=ht(t,o.lockNftMint).publicKey,N=oe(this.scope.ownerPubKey,o.lockNftMint,jt).publicKey,I=M.getTickArrayStartIndexByTick(g.tickLower,m.config.tickSpacing),F=M.getTickArrayStartIndexByTick(g.tickUpper,m.config.tickSpacing),{publicKey:q}=z(new L(m.programId),o.poolId,I),{publicKey:ue}=z(new L(m.programId),o.poolId,F),{publicKey:fe}=_e(new L(m.programId),o.poolId,g.tickLower,g.tickUpper),Re=[];for(let ee=0;ee<m.rewardInfos.length;ee++)Re.push({poolRewardVault:new L(m.rewardInfos[ee].vault),ownerRewardVault:R[ee],rewardMint:new L(m.rewardInfos[ee].mint.address)});let ze=await ce.harvestLockPositionInstructionV2({programId:t,auth:n,lockPositionId:C,clmmProgram:i,lockOwner:this.scope.ownerPubKey,lockNftMint:o.lockNftMint,lockNftAccount:N,positionNftAccount:o.nftAccount,positionId:o.positionId,poolId:o.poolId,protocolPosition:fe,vaultA:new L(m.vault.A),vaultB:new L(m.vault.B),tickArrayLower:q,tickArrayUpper:ue,userVaultA:A,userVaultB:T,mintA:new L(m.mintA.address),mintB:new L(m.mintB.address),rewardAccounts:Re,exTickArrayBitmap:ge(i,o.poolId).publicKey});return p.addInstruction({instructions:[ze],instructionTypes:[re.ClmmHarvestLockPosition]}),p.addCustomComputeBudget(l),p.addTipInstruction(d),p.versionBuild({txVersion:f})}async closePosition({poolInfo:e,poolKeys:t,ownerPosition:n,txVersion:i,computeBudgetConfig:s,txTipConfig:o,feePayer:r}){var d;this.scope.availability.removeConcentratedPosition===!1&&this.logAndCreateError("remove position feature disabled in your region");let a=this.createTxBuilder(r),c=t!=null?t:await this.getClmmPoolKeys(e.id),l=ce.closePositionInstructions({poolInfo:e,poolKeys:c,ownerInfo:{wallet:this.scope.ownerPubKey},ownerPosition:n,nft2022:(d=await this.scope.connection.getAccountInfo(n.nftMint))==null?void 0:d.owner.equals(ut)});return a.addCustomComputeBudget(s),a.addTipInstruction(o),a.addInstruction(l).versionBuild({txVersion:i,extInfo:{address:l.address}})}async initReward({poolInfo:e,ownerInfo:t,rewardInfo:n,associatedOnly:i=!0,checkCreateATAOwner:s=!1,computeBudgetConfig:o,txVersion:r,feePayer:a}){n.endTime<=n.openTime&&this.logAndCreateError("reward time error","rewardInfo",n);let c=this.createTxBuilder(a),l=t.useSOLBalance&&n.mint.address.toString()===Q.toString(),d=n.perSecond.mul(n.endTime-n.openTime),{account:f,instructionParams:u}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:new L(n.mint.address),mint:new L(n.mint.address),notUseTokenAccount:!!l,skipCloseAccount:!l,owner:this.scope.ownerPubKey,createInfo:l?{payer:t.feePayer||this.scope.ownerPubKey,amount:new Ke(new Pt(d.toFixed(0)).gte(d)?d.toFixed(0):d.add(1).toFixed(0))}:void 0,associatedOnly:l?!1:i,checkCreateATAOwner:s});u&&c.addInstruction(u),f||this.logAndCreateError("no money","ownerRewardAccount",this.scope.account.tokenAccountRawInfos);let m=await this.getClmmPoolKeys(e.id),p=ce.initRewardInstructions({poolInfo:e,poolKeys:m,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccount:f},rewardInfo:{programId:new L(n.mint.programId),mint:new L(n.mint.address),openTime:n.openTime,endTime:n.endTime,emissionsPerSecondX64:V.decimalToX64(n.perSecond)}});return c.addInstruction(p),c.addCustomComputeBudget(o),c.versionBuild({txVersion:r,extInfo:{address:p.address}})}async initRewards({poolInfo:e,poolKeys:t,ownerInfo:n,rewardInfos:i,associatedOnly:s=!0,checkCreateATAOwner:o=!1,computeBudgetConfig:r,txTipConfig:a,txVersion:c,feePayer:l}){for(let u of i)u.endTime<=u.openTime&&this.logAndCreateError("reward time error","rewardInfo",u);let d=this.createTxBuilder(l),f={};for(let u of i){let m=n.useSOLBalance&&u.mint.address===Q.toString(),p=u.perSecond.mul(u.endTime-u.openTime),{account:b,instructionParams:g}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:new L(u.mint.programId),mint:new L(u.mint.address),notUseTokenAccount:!!m,skipCloseAccount:!m,owner:this.scope.ownerPubKey,createInfo:m?{payer:n.feePayer||this.scope.ownerPubKey,amount:new Ke(new Pt(p.toFixed(0)).gte(p)?p.toFixed(0):p.add(1).toFixed(0))}:void 0,associatedOnly:m?!1:s,checkCreateATAOwner:o});g&&d.addInstruction(g),b||this.logAndCreateError("no money","ownerRewardAccount",this.scope.account.tokenAccountRawInfos);let w=t!=null?t:await this.getClmmPoolKeys(e.id),k=ce.initRewardInstructions({poolInfo:e,poolKeys:w,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccount:b},rewardInfo:{programId:new L(u.mint.programId),mint:new L(u.mint.address),openTime:u.openTime,endTime:u.endTime,emissionsPerSecondX64:V.decimalToX64(u.perSecond)}});f=O(O({},f),k.address),d.addInstruction(k)}return d.addCustomComputeBudget(r),d.addTipInstruction(a),d.versionBuild({txVersion:c,extInfo:{address:f}})}async setReward({poolInfo:e,ownerInfo:t,rewardInfo:n,associatedOnly:i=!0,checkCreateATAOwner:s=!1,computeBudgetConfig:o,txTipConfig:r,txVersion:a,feePayer:c}){n.endTime<=n.openTime&&this.logAndCreateError("reward time error","rewardInfo",n);let l=this.createTxBuilder(c),d=t.useSOLBalance&&n.mint.equals(Q),{account:f,instructionParams:u}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:n.programId,mint:n.mint,notUseTokenAccount:d,owner:this.scope.ownerPubKey,createInfo:d?{payer:t.feePayer||this.scope.ownerPubKey,amount:new Ke(new Pt(n.perSecond.mul(n.endTime-n.openTime).toFixed(0)).gte(n.perSecond.mul(n.endTime-n.openTime))?n.perSecond.mul(n.endTime-n.openTime).toFixed(0):n.perSecond.mul(n.endTime-n.openTime).add(1).toFixed(0))}:void 0,associatedOnly:d?!1:i,checkCreateATAOwner:s});u&&l.addInstruction(u),f||this.logAndCreateError("no money","ownerRewardAccount",this.scope.account.tokenAccountRawInfos);let m=await this.getClmmPoolKeys(e.id),p=ce.setRewardInstructions({poolInfo:e,poolKeys:m,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccount:f},rewardInfo:{mint:n.mint,openTime:n.openTime,endTime:n.endTime,emissionsPerSecondX64:V.decimalToX64(n.perSecond)}});return l.addInstruction(p),l.addCustomComputeBudget(o),l.addTipInstruction(r),l.versionBuild({txVersion:a,extInfo:{address:p.address}})}async setRewards({poolInfo:e,poolKeys:t,ownerInfo:n,rewardInfos:i,associatedOnly:s=!0,checkCreateATAOwner:o=!1,computeBudgetConfig:r,txTipConfig:a,txVersion:c,feePayer:l}){let d=this.createTxBuilder(l),f={};for(let u of i){u.endTime<=u.openTime&&this.logAndCreateError("reward time error","rewardInfo",u);let m=n.useSOLBalance&&u.mint.address===Q.toString(),{account:p,instructionParams:b}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:new L(u.mint.programId),mint:new L(u.mint.address),notUseTokenAccount:m,owner:this.scope.ownerPubKey,createInfo:m?{payer:n.feePayer||this.scope.ownerPubKey,amount:new Ke(new Pt(u.perSecond.mul(u.endTime-u.openTime).toFixed(0)).gte(u.perSecond.mul(u.endTime-u.openTime))?u.perSecond.mul(u.endTime-u.openTime).toFixed(0):u.perSecond.mul(u.endTime-u.openTime).add(1).toFixed(0))}:void 0,associatedOnly:m?!1:s,checkCreateATAOwner:o});b&&d.addInstruction(b),p||this.logAndCreateError("no money","ownerRewardAccount",this.scope.account.tokenAccountRawInfos);let g=t!=null?t:await this.getClmmPoolKeys(e.id),w=ce.setRewardInstructions({poolInfo:e,poolKeys:g,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccount:p},rewardInfo:{mint:new L(u.mint.address),openTime:u.openTime,endTime:u.endTime,emissionsPerSecondX64:V.decimalToX64(u.perSecond)}});d.addInstruction(w),f=O(O({},f),w.address)}return d.addCustomComputeBudget(r),d.addTipInstruction(a),d.versionBuild({txVersion:c,extInfo:{address:f}})}async collectReward({poolInfo:e,ownerInfo:t,rewardMint:n,associatedOnly:i=!0,checkCreateATAOwner:s=!1,computeBudgetConfig:o,txTipConfig:r,txVersion:a,feePayer:c}){let l=e.rewardDefaultInfos.find(g=>g.mint.address===n.toString());l||this.logAndCreateError("reward mint error","not found reward mint",n);let d=this.createTxBuilder(c),f=t.useSOLBalance&&n.equals(Q),{account:u,instructionParams:m}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:new L(l.mint.programId),mint:n,notUseTokenAccount:f,owner:this.scope.ownerPubKey,skipCloseAccount:!f,createInfo:{payer:t.feePayer||this.scope.ownerPubKey,amount:0},associatedOnly:f?!1:i,checkCreateATAOwner:s});m&&d.addInstruction(m),u||this.logAndCreateError("no money","ownerRewardAccount",this.scope.account.tokenAccountRawInfos);let p=await this.getClmmPoolKeys(e.id),b=ce.collectRewardInstructions({poolInfo:e,poolKeys:p,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccount:u},rewardMint:n});return d.addInstruction(b),d.addCustomComputeBudget(o),d.addTipInstruction(r),d.versionBuild({txVersion:a,extInfo:{address:b.address}})}async collectRewards({poolInfo:e,ownerInfo:t,rewardMints:n,associatedOnly:i=!0,checkCreateATAOwner:s=!1,computeBudgetConfig:o,txTipConfig:r,feePayer:a}){let c=this.createTxBuilder(a),l={};for(let d of n){let f=e.rewardDefaultInfos.find(w=>w.mint.address===d.toString());if(!f){this.logAndCreateError("reward mint error","not found reward mint",d);continue}let u=t.useSOLBalance&&d.equals(Q),{account:m,instructionParams:p}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:new L(f.mint.programId),mint:d,notUseTokenAccount:u,owner:this.scope.ownerPubKey,skipCloseAccount:!u,createInfo:{payer:t.feePayer||this.scope.ownerPubKey,amount:0},associatedOnly:u?!1:i,checkCreateATAOwner:s});m||this.logAndCreateError("no money","ownerRewardAccount",this.scope.account.tokenAccountRawInfos),p&&c.addInstruction(p);let b=await this.getClmmPoolKeys(e.id),g=ce.collectRewardInstructions({poolInfo:e,poolKeys:b,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccount:m},rewardMint:d});c.addInstruction(g),l=O(O({},l),g.address)}return c.addCustomComputeBudget(o),c.addTipInstruction(r),c.build({address:l})}async swap({poolInfo:e,poolKeys:t,inputMint:n,amountIn:i,amountOutMin:s,priceLimit:o,observationId:r,ownerInfo:a,remainingAccounts:c,associatedOnly:l=!0,checkCreateATAOwner:d=!1,txVersion:f,computeBudgetConfig:u,txTipConfig:m,feePayer:p}){let b=this.createTxBuilder(p),g=n.toString()===e.mintA.address,w=a.useSOLBalance&&e.mintA.address===Q.toBase58(),k=a.useSOLBalance&&e.mintB.address===Q.toBase58(),A;!o||o.equals(new Pt(0))?A=g?Ge.add(new Ke(1)):Ue.sub(new Ke(1)):A=_.priceToSqrtPriceX64(o,e.mintA.decimals,e.mintB.decimals);let T;if(!T){let{account:h,instructionParams:B}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:e.mintA.programId,mint:new L(e.mintA.address),notUseTokenAccount:w,owner:this.scope.ownerPubKey,skipCloseAccount:!w,createInfo:w||!g?{payer:a.feePayer||this.scope.ownerPubKey,amount:g?i:0}:void 0,associatedOnly:w?!1:l,checkCreateATAOwner:d});T=h,B&&b.addInstruction(B)}let P;if(!P){let{account:h,instructionParams:B}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:e.mintB.programId,mint:new L(e.mintB.address),notUseTokenAccount:k,owner:this.scope.ownerPubKey,skipCloseAccount:!k,createInfo:k||g?{payer:a.feePayer||this.scope.ownerPubKey,amount:g?0:i}:void 0,associatedOnly:k?!1:l,checkCreateATAOwner:d});P=h,B&&b.addInstruction(B)}(!T||!P)&&this.logAndCreateError("user do not have token account",{tokenA:e.mintA.symbol||e.mintA.address,tokenB:e.mintB.symbol||e.mintB.address,ownerTokenAccountA:T,ownerTokenAccountB:P,mintAUseSOLBalance:w,mintBUseSOLBalance:k,associatedOnly:l});let x=t!=null?t:await this.getClmmPoolKeys(e.id);return b.addInstruction(ce.makeSwapBaseInInstructions({poolInfo:e,poolKeys:x,observationId:r,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccountA:T,tokenAccountB:P},inputMint:new L(n),amountIn:i,amountOutMin:s,sqrtPriceLimitX64:A,remainingAccounts:c})),b.addCustomComputeBudget(u),b.addTipInstruction(m),b.versionBuild({txVersion:f})}async swapBaseOut({poolInfo:e,poolKeys:t,outputMint:n,amountOut:i,amountInMax:s,priceLimit:o,observationId:r,ownerInfo:a,remainingAccounts:c,associatedOnly:l=!0,checkCreateATAOwner:d=!1,txVersion:f,computeBudgetConfig:u,txTipConfig:m,feePayer:p}){let b=this.createTxBuilder(p),g=n.toString()===e.mintB.address,w=a.useSOLBalance&&e.mintA.address===Q.toBase58(),k=a.useSOLBalance&&e.mintB.address===Q.toBase58(),A;!o||o.equals(new Pt(0))?A=n.toString()===e.mintB.address?Ge.add(new Ke(1)):Ue.sub(new Ke(1)):A=_.priceToSqrtPriceX64(o,e.mintA.decimals,e.mintB.decimals);let T;if(!T){let{account:h,instructionParams:B}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:e.mintA.programId,mint:new L(e.mintA.address),notUseTokenAccount:w,owner:this.scope.ownerPubKey,skipCloseAccount:!w,createInfo:w||!g?{payer:a.feePayer||this.scope.ownerPubKey,amount:g?s:0}:void 0,associatedOnly:w?!1:l,checkCreateATAOwner:d});T=h,B&&b.addInstruction(B)}let P;if(!P){let{account:h,instructionParams:B}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:e.mintB.programId,mint:new L(e.mintB.address),notUseTokenAccount:k,owner:this.scope.ownerPubKey,skipCloseAccount:!k,createInfo:k||g?{payer:a.feePayer||this.scope.ownerPubKey,amount:g?0:s}:void 0,associatedOnly:k?!1:l,checkCreateATAOwner:d});P=h,B&&b.addInstruction(B)}(!T||!P)&&this.logAndCreateError("user do not have token account",{tokenA:e.mintA.symbol||e.mintA.address,tokenB:e.mintB.symbol||e.mintB.address,ownerTokenAccountA:T,ownerTokenAccountB:P,mintAUseSOLBalance:w,mintBUseSOLBalance:k,associatedOnly:l});let x=t!=null?t:await this.getClmmPoolKeys(e.id);return b.addInstruction(ce.makeSwapBaseOutInstructions({poolInfo:e,poolKeys:x,observationId:r,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccountA:T,tokenAccountB:P},outputMint:new L(n),amountOut:i,amountInMax:s,sqrtPriceLimitX64:A,remainingAccounts:c})),b.addCustomComputeBudget(u),b.addTipInstruction(m),b.versionBuild({txVersion:f})}async harvestAllRewards({allPoolInfo:e,allPositions:t,lockInfo:n,ownerInfo:i,associatedOnly:s=!0,checkCreateATAOwner:o=!1,programId:r,txVersion:a,computeBudgetConfig:c,feePayer:l,lockProgram:d=Ot,lockAuth:f=nn,clmmProgram:u=Mt}){var k,A;let m={};for(let T of this.scope.account.tokenAccountRawInfos)s?oe(this.scope.ownerPubKey,T.accountInfo.mint,r).publicKey.equals(T.pubkey)&&(m[T.accountInfo.mint.toString()]=T.pubkey):m[T.accountInfo.mint.toString()]=T.pubkey;let p=Object.values(t).flat().map(T=>T.nftMint),b=await je(this.scope.connection,p.map(T=>({pubkey:T}))),g={};b.forEach(T=>{var P,x;g[T.pubkey.toBase58()]=(x=(P=T==null?void 0:T.accountInfo)==null?void 0:P.owner)!=null?x:null});let w=this.createTxBuilder(l);for(let T of Object.values(e)){if(t[T.id]===void 0||!t[T.id].find(I=>!I.liquidity.isZero()||I.rewardInfos.find(F=>!F.rewardAmountOwed.isZero())))continue;let P=T,x=i.useSOLBalance&&P.mintA.address===Q.toString(),h=i.useSOLBalance&&P.mintB.address===Q.toString(),B=m[P.mintA.address];if(!B)if(x){let{account:I,instructionParams:F}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:P.mintA.programId,mint:new L(P.mintA.address),notUseTokenAccount:x,owner:this.scope.ownerPubKey,skipCloseAccount:!x,createInfo:{payer:i.feePayer||this.scope.ownerPubKey,amount:0},associatedOnly:x?!1:s,checkCreateATAOwner:o});B=I,F&&w.addInstruction(F)}else{let I=new L(P.mintA.address);B=this.scope.account.getAssociatedTokenAccount(I,new L(P.mintA.programId)),w.addInstruction({instructions:[Xi(this.scope.ownerPubKey,B,this.scope.ownerPubKey,I,new L(P.mintA.programId))]})}let K=m[P.mintB.address];if(!K)if(h){let{account:I,instructionParams:F}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:P.mintB.programId,mint:new L(P.mintB.address),notUseTokenAccount:h,owner:this.scope.ownerPubKey,skipCloseAccount:!h,createInfo:{payer:i.feePayer||this.scope.ownerPubKey,amount:0},associatedOnly:h?!1:s,checkCreateATAOwner:o});K=I,F&&w.addInstruction(F)}else{let I=new L(P.mintB.address);K=this.scope.account.getAssociatedTokenAccount(I,new L(P.mintB.programId)),w.addInstruction({instructions:[Xi(this.scope.ownerPubKey,K,this.scope.ownerPubKey,I,new L(P.mintB.programId))]})}m[P.mintA.address]=B,m[P.mintB.address]=K;let R=[];for(let I of P.rewardDefaultInfos){let F=i.useSOLBalance&&I.mint.address===Q.toString(),q=m[I.mint.address];if(!q){let{account:ue,instructionParams:fe}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:new L(I.mint.programId),mint:new L(I.mint.address),notUseTokenAccount:F,owner:this.scope.ownerPubKey,skipCloseAccount:!F,createInfo:{payer:i.feePayer||this.scope.ownerPubKey,amount:0},associatedOnly:F?!1:s});q=ue,fe&&w.addInstruction(fe)}m[I.mint.address]=q,R.push(q)}let C=await this.getClmmPoolKeys(P.id),N=[];for(let I=0;I<C.rewardInfos.length;I++)N.push({poolRewardVault:new L(C.rewardInfos[I].vault),ownerRewardVault:R[I],rewardMint:new L(C.rewardInfos[I].mint.address)});for(let I of t[T.id]){let F=(k=n==null?void 0:n[T.id])==null?void 0:k[I.nftMint.toBase58()];if(F){let q=oe(this.scope.ownerPubKey,F.lockNftMint,jt).publicKey,ue=M.getTickArrayStartIndexByTick(I.tickLower,C.config.tickSpacing),fe=M.getTickArrayStartIndexByTick(I.tickUpper,C.config.tickSpacing),{publicKey:Re}=z(new L(C.programId),F.poolId,ue),{publicKey:ze}=z(new L(C.programId),F.poolId,fe),{publicKey:ee}=_e(new L(C.programId),F.poolId,I.tickLower,I.tickUpper),ie=ht(d,F.lockNftMint).publicKey,Ve=ce.harvestLockPositionInstructionV2({programId:d,auth:f,lockPositionId:ie,clmmProgram:u,lockOwner:this.scope.ownerPubKey,lockNftMint:F.lockNftMint,lockNftAccount:q,positionNftAccount:F.nftAccount,positionId:F.positionId,poolId:F.poolId,protocolPosition:ee,vaultA:new L(C.vault.A),vaultB:new L(C.vault.B),tickArrayLower:Re,tickArrayUpper:ze,userVaultA:B,userVaultB:K,mintA:new L(C.mintA.address),mintB:new L(C.mintB.address),rewardAccounts:N,exTickArrayBitmap:ge(u,F.poolId).publicKey});w.addInstruction({instructions:[Ve],instructionTypes:[re.ClmmHarvestLockPosition],lookupTableAddress:C.lookupTableAccount?[C.lookupTableAccount]:[]})}else{let q=ce.decreaseLiquidityInstructions({poolInfo:P,poolKeys:C,ownerPosition:I,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccountA:B,tokenAccountB:K,rewardAccounts:R},liquidity:new Ke(0),amountMinA:new Ke(0),amountMinB:new Ke(0),nft2022:(A=g[I.nftMint.toBase58()])==null?void 0:A.equals(ut)});w.addInstruction(q)}}}return a===0?w.sizeCheckBuildV0({computeBudgetConfig:c}):w.sizeCheckBuild({computeBudgetConfig:c})}async getWhiteListMint({programId:e}){let t=await this.scope.connection.getAccountInfo(Ut(e).publicKey);return t?Vi.decode(t.data).whitelistMints.filter(i=>!i.equals(L.default)):[]}async getOwnerPositionInfo({programId:e=Mt}){await this.scope.account.fetchWalletTokenAccounts();let n=this.scope.account.tokenAccountRawInfos.filter(o=>o.accountInfo.amount.eq(new Ke(1))).map(o=>Ce(new L(e),o.accountInfo.mint).publicKey),i=await this.scope.connection.getMultipleAccountsInfo(n),s=[];return i.forEach(o=>{if(!o)return;let r=xt.decode(o.data);s.push(r)}),s}async getOwnerLockedPositionInfo({programId:e=Ot}){await this.scope.account.fetchWalletTokenAccounts();let n=this.scope.account.tokenAccountRawInfos.filter(a=>a.accountInfo.amount.eq(new Ke(1))).map(a=>ht(new L(e),a.accountInfo.mint).publicKey),i=await this.scope.connection.getMultipleAccountsInfo(n),s=[];i.forEach(a=>{if(!a)return;let c=vi.decode(a.data);s.push(c)});let o=await this.scope.connection.getMultipleAccountsInfo(s.map(a=>a.positionId)),r=[];return o.forEach(a=>{if(!a)return;let c=xt.decode(a.data);r.push(c)}),s.map((a,c)=>({position:r[c],lockInfo:a}))}async getRpcClmmPoolInfo({poolId:e}){return(await this.getRpcClmmPoolInfos({poolIds:[e]}))[String(e)]}async getRpcClmmPoolInfos({poolIds:e,config:t}){let n=await je(this.scope.connection,e.map(s=>({pubkey:new L(s)})),t),i={};for(let s=0;s<e.length;s++){let o=n[s];if(o===null||!o.accountInfo)throw Error("fetch pool info error: "+String(e[s]));let r=mn.decode(o.accountInfo.data),a=_.sqrtPriceX64ToPrice(r.sqrtPriceX64,r.mintDecimalsA,r.mintDecimalsB).toNumber();i[String(e[s])]=U(O({},r),{currentPrice:a,programId:o.accountInfo.owner})}return i}async getComputeClmmPoolInfos({clmmPoolsRpcInfo:e,mintInfos:t}){let n=new Set(Object.keys(e).map(a=>e[a].ammConfig.toBase58())),i=await je(this.scope.connection,Array.from(n).map(a=>({pubkey:new L(a)}))),s={};i.forEach(a=>{!a.accountInfo||(s[a.pubkey.toBase58()]=Di.decode(a.accountInfo.data))});let o=await pe.fetchComputeMultipleClmmInfo({connection:this.scope.connection,rpcDataMap:e,poolList:Object.keys(e).map(a=>{var d,f,u,m;let[c,l]=[e[a].mintA.toBase58(),e[a].mintB.toBase58()];return{id:a,programId:e[a].programId.toBase58(),mintA:sn({address:c,decimals:e[a].mintDecimalsA,programId:t[c].programId.toBase58()||jt.toBase58(),extensions:{feeConfig:(d=t[c])!=null&&d.feeConfig?Rn((f=t[c])==null?void 0:f.feeConfig):void 0}}),mintB:sn({address:l,decimals:e[a].mintDecimalsB,programId:t[l].programId.toBase58()||jt.toBase58(),extensions:{feeConfig:(u=t[l])!=null&&u.feeConfig?Rn((m=t[l])==null?void 0:m.feeConfig):void 0}}),price:e[a].currentPrice,config:U(O({},s[e[a].ammConfig.toBase58()]),{id:e[a].ammConfig.toBase58(),fundFeeRate:0,description:"",defaultRange:0,defaultRangePoint:[]})}})}),r=await pe.fetchMultiplePoolTickArrays({connection:this.scope.connection,poolKeys:Object.values(o)});return{computeClmmPoolInfo:o,computePoolTickData:r}}async getPoolInfoFromRpc(e){var l;let t=await this.getRpcClmmPoolInfo({poolId:e}),n=new Set([t.mintA.toBase58(),t.mintB.toBase58()]),i=await ei({connection:this.scope.connection,mints:Array.from(n).map(d=>new L(d))}),{computeClmmPoolInfo:s,computePoolTickData:o}=await this.scope.clmm.getComputeClmmPoolInfos({clmmPoolsRpcInfo:{[e]:t},mintInfos:i}),r=await je(this.scope.connection,[{pubkey:t.vaultA},{pubkey:t.vaultB}]),a=Fi(s[e]);if(!r[0].accountInfo||!r[1].accountInfo)throw new Error("pool vault data not found");a.mintAmountA=Number(Ui.decode(r[0].accountInfo.data).amount.toString()),a.mintAmountB=Number(Ui.decode((l=r[1].accountInfo)==null?void 0:l.data).amount.toString());let c=U(O({},s[e]),{exBitmapAccount:s[e].exBitmapAccount.toBase58(),observationId:s[e].observationId.toBase58(),id:e,programId:t.programId.toBase58(),openTime:t.startTime.toString(),vault:{A:t.vaultA.toBase58(),B:t.vaultB.toBase58()},config:a.config,rewardInfos:s[e].rewardInfos.filter(d=>!d.tokenVault.equals(L.default)).map(d=>({mint:sn({address:d.tokenMint.toBase58(),programId:jt.toBase58(),decimals:10}),vault:d.tokenVault.toBase58()}))});return{poolInfo:a,poolKeys:c,computePoolInfo:s[e],tickData:o}}};export{qr as AMM_CONFIG_SEED,Ai as BIT_PRECISION,Hn as Clmm,Di as ClmmConfigLayout,ce as ClmmInstrument,qn as EXTENSION_TICKARRAY_BITMAP_SIZE,un as FEE_RATE_DENOMINATOR,Qr as FETCH_TICKARRAY_COUNT,Wr as Fee,ki as LOG_B_2_X32,hi as LOG_B_P_ERR_MARGIN_LOWER_X64,xi as LOG_B_P_ERR_MARGIN_UPPER_X64,Y as LiquidityMath,vi as LockClPositionLayoutV2,Rm as LockPositionLayout,Ue as MAX_SQRT_PRICE_X64,ul as MAX_SQRT_PRICE_X64_SUB_ONE,Se as MAX_TICK,Ge as MIN_SQRT_PRICE_X64,cl as MIN_SQRT_PRICE_X64_ADD_ONE,Be as MIN_TICK,V as MathUtil,Fn as MaxU64,Ti as MaxUint128,et as NEGATIVE_ONE,jr as OBSERVATION_SEED,qe as ONE,zr as OPERATION_SEED,_i as ObservationInfoLayout,eo as ObservationLayout,Vi as OperationLayout,Mi as POOL_LOCK_ID_SEED,Xr as POOL_REWARD_VAULT_SEED,Gr as POOL_SEED,Yr as POOL_TICK_ARRAY_BITMAP_SEED,Ur as POOL_VAULT_SEED,Ki as POSITION_SEED,mn as PoolInfoLayout,pe as PoolUtils,xt as PositionInfoLayout,no as PositionRewardInfoLayout,Xt as PositionUtils,Km as ProtocolPositionLayout,cn as Q128,Ne as Q64,to as RewardInfo,Zr as SUPPORT_MINT_SEED,_ as SqrtPriceMath,bt as SwapMath,yt as TICK_ARRAY_BITMAP_SIZE,Hr as TICK_ARRAY_SEED,Pe as TICK_ARRAY_SIZE,ll as TICK_SPACINGS,tt as TickArrayBitmap,Ei as TickArrayBitmapExtensionLayout,zt as TickArrayBitmapExtensionUtils,Ht as TickArrayLayout,io as TickLayout,gt as TickMath,Z as TickQuery,M as TickUtils,Wt as U64Resolution,dl as U64_IGNORE_RANGE,H as ZERO,Fi as clmmComputeInfoToApiInfo,om as getLiquidityFromAmounts,wl as getPdaAmmConfigId,ge as getPdaExBitmapAccount,ht as getPdaLockClPositionIdV2,Vn as getPdaLockPositionId,Gt as getPdaMetadataKey,vn as getPdaMintExAccount,Ni as getPdaObservationAccount,Ut as getPdaOperationAccount,Ce as getPdaPersonalPositionAddress,Ri as getPdaPoolId,Li as getPdaPoolRewardVaulId,_n as getPdaPoolVaultId,_e as getPdaProtocolPositionAddress,z as getPdaTickArrayAddress,fl as i16ToBytes,ln as i32ToBytes,qt as isZero,En as leadingZeros,Ci as leastSignificantBit,ml as mockCreatePoolInfo,Bi as mockV3CreatePoolInfo,Si as mostSignificantBit,Dn as trailingZeros,Ii as u16ToBytes,yl as u32ToBytes};
//# sourceMappingURL=index.mjs.map