var Xi=Object.defineProperty,zi=Object.defineProperties;var Hi=Object.getOwnPropertyDescriptors;var Ut=Object.getOwnPropertySymbols;var Hn=Object.prototype.hasOwnProperty,jn=Object.prototype.propertyIsEnumerable;var zn=(b,e,t)=>e in b?Xi(b,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):b[e]=t,F=(b,e)=>{for(var t in e||(e={}))Hn.call(e,t)&&zn(b,t,e[t]);if(Ut)for(var t of Ut(e))jn.call(e,t)&&zn(b,t,e[t]);return b},G=(b,e)=>zi(b,Hi(e));var mt=(b,e)=>{var t={};for(var n in b)Hn.call(b,n)&&e.indexOf(n)<0&&(t[n]=b[n]);if(b!=null&&Ut)for(var n of Ut(b))e.indexOf(n)<0&&jn.call(b,n)&&(t[n]=b[n]);return t};import{PublicKey as R}from"@solana/web3.js";import Ke from"bn.js";import ut from"decimal.js";import{PublicKey as Qn}from"@solana/web3.js";import{get as Zn,set as ji}from"lodash";var ln=class{constructor(e){this.logLevel=e.logLevel!==void 0?e.logLevel:0,this.name=e.name}set level(e){this.logLevel=e}get time(){return Date.now().toString()}get moduleName(){return this.name}isLogLevel(e){return e<=this.logLevel}error(...e){return this.isLogLevel(0)?(console.error(this.time,this.name,"sdk logger error",...e),this):this}logWithError(...e){let t=e.map(n=>typeof n=="object"?JSON.stringify(n):n).join(", ");throw new Error(t)}warning(...e){return this.isLogLevel(1)?(console.warn(this.time,this.name,"sdk logger warning",...e),this):this}info(...e){return this.isLogLevel(2)?(console.info(this.time,this.name,"sdk logger info",...e),this):this}debug(...e){return this.isLogLevel(3)?(console.debug(this.time,this.name,"sdk logger debug",...e),this):this}},Yn={},Zi={};function Ae(b){let e=Zn(Yn,b);if(!e){let t=Zn(Zi,b);e=new ln({name:b,logLevel:t}),ji(Yn,b,e)}return e}import{MINT_SIZE as Yi,TOKEN_PROGRAM_ID as Qi,getTransferFeeConfig as Ji,unpackMint as $i}from"@solana/spl-token";var mn=Ae("Raydium_accountInfo_util");async function Xe(b,e,t){let{batchRequest:n,commitment:i="confirmed",chunkCount:o=100}=F({batchRequest:!1},t),r=dn(e,o),s=new Array(r.length).fill([]);if(n){let a=r.map(d=>{let f=b._buildArgs([d.map(u=>u.toBase58())],i,"base64");return{methodName:"getMultipleAccounts",args:f}}),c=dn(a,10);s=(await(await Promise.all(c.map(async d=>await b._rpcBatchRequest(d)))).flat()).map(d=>(d.error&&mn.logWithError(`failed to get info for multiple accounts, RPC_ERROR, ${d.error.message}`),d.result.value.map(f=>{if(f){let{data:u,executable:m,lamports:p,owner:y,rentEpoch:g}=f;return u.length!==2&&u[1]!=="base64"&&mn.logWithError("info must be base64 encoded, RPC_ERROR"),{data:Buffer.from(u[0],"base64"),executable:m,lamports:p,owner:new Qn(y),rentEpoch:g}}return null})))}else try{s=await Promise.all(r.map(a=>b.getMultipleAccountsInfo(a,i)))}catch(a){a instanceof Error&&mn.logWithError(`failed to get info for multiple accounts, RPC_ERROR, ${a.message}`)}return s.flat()}async function ze(b,e,t){let n=await Xe(b,e.map(i=>i.pubkey),t);return e.map((i,o)=>G(F({},i),{accountInfo:n[o]}))}async function Jn({connection:b,mints:e,config:t}){var o,r,s;if(e.length===0)return{};let n=await ze(b,e.map(a=>({pubkey:it(a)})),t),i={};for(let a of n){if(!a.accountInfo||a.accountInfo.data.length<Yi){console.log("invalid mint account",a.pubkey.toBase58());continue}let c=$i(a.pubkey,a.accountInfo,(o=a.accountInfo)==null?void 0:o.owner);i[a.pubkey.toString()]=G(F({},c),{programId:((r=a.accountInfo)==null?void 0:r.owner)||Qi,feeConfig:(s=Ji(c))!=null?s:void 0})}return i[Qn.default.toBase58()]=i[Q.toBase58()],i}import He from"bn.js";import Hs from"decimal.js";import ar from"big.js";import Ht from"bn.js";import er from"toformat";var tr=er,Tt=tr;import zt from"big.js";import ir from"bn.js";import rr from"decimal.js-light";import kt from"bn.js";var $n=9007199254740991;function ge(b){let e=Ae("Raydium_parseBigNumberish");if(b instanceof kt)return b;if(typeof b=="string"){if(b.match(/^-?[0-9]+$/))return new kt(b);e.logWithError(`invalid BigNumberish string: ${b}`)}return typeof b=="number"?(b%1&&e.logWithError(`BigNumberish number underflow: ${b}`),(b>=$n||b<=-$n)&&e.logWithError(`BigNumberish number overflow: ${b}`),new kt(String(b))):typeof b=="bigint"?new kt(b.toString()):(e.error(`invalid BigNumberish value: ${b}`),new kt(0))}var Xt=Ae("module/fraction"),pn=Tt(zt),xt=Tt(rr),or={[0]:xt.ROUND_DOWN,[1]:xt.ROUND_HALF_UP,[2]:xt.ROUND_UP},sr={[0]:zt.roundDown,[1]:zt.roundHalfUp,[2]:zt.roundUp},J=class{constructor(e,t=new ir(1)){this.numerator=ge(e),this.denominator=ge(t)}get quotient(){return this.numerator.div(this.denominator)}invert(){return new J(this.denominator,this.numerator)}add(e){let t=e instanceof J?e:new J(ge(e));return this.denominator.eq(t.denominator)?new J(this.numerator.add(t.numerator),this.denominator):new J(this.numerator.mul(t.denominator).add(t.numerator.mul(this.denominator)),this.denominator.mul(t.denominator))}sub(e){let t=e instanceof J?e:new J(ge(e));return this.denominator.eq(t.denominator)?new J(this.numerator.sub(t.numerator),this.denominator):new J(this.numerator.mul(t.denominator).sub(t.numerator.mul(this.denominator)),this.denominator.mul(t.denominator))}mul(e){let t=e instanceof J?e:new J(ge(e));return new J(this.numerator.mul(t.numerator),this.denominator.mul(t.denominator))}div(e){let t=e instanceof J?e:new J(ge(e));return new J(this.numerator.mul(t.denominator),this.denominator.mul(t.numerator))}toSignificant(e,t={groupSeparator:""},n=1){Number.isInteger(e)||Xt.logWithError(`${e} is not an integer.`),e<=0&&Xt.logWithError(`${e} is not positive.`),xt.set({precision:e+1,rounding:or[n]});let i=new xt(this.numerator.toString()).div(this.denominator.toString()).toSignificantDigits(e);return i.toFormat(i.decimalPlaces(),t)}toFixed(e,t={groupSeparator:""},n=1){return Number.isInteger(e)||Xt.logWithError(`${e} is not an integer.`),e<0&&Xt.logWithError(`${e} is negative.`),pn.DP=e,pn.RM=sr[n]||1,new pn(this.numerator.toString()).div(this.denominator.toString()).toFormat(e,t)}isZero(){return this.numerator.isZero()}};var cr=Ae("Raydium_amount"),ei=Tt(ar);function ur(b,e){let t="0",n="0";if(b.includes(".")){let i=b.split(".");i.length===2?([t,n]=i,n=n.padEnd(e,"0")):cr.logWithError(`invalid number string, num: ${b}`)}else t=b;return[t,n.slice(0,e)||n]}var we=class extends J{constructor(t,n,i=!0,o){let r=new Ht(0),s=fn.pow(new Ht(t.decimals));if(i)r=ge(n);else{let a=new Ht(0),c=new Ht(0);if(typeof n=="string"||typeof n=="number"||typeof n=="bigint"){let[l,d]=ur(n.toString(),t.decimals);a=ge(l),c=ge(d)}a=a.mul(s),r=a.add(c)}super(r,s);this.logger=Ae(o||"TokenAmount"),this.token=t}get raw(){return this.numerator}isZero(){return this.raw.isZero()}gt(t){return this.token.equals(t.token)||this.logger.logWithError("gt token not equals"),this.raw.gt(t.raw)}lt(t){return this.token.equals(t.token)||this.logger.logWithError("lt token not equals"),this.raw.lt(t.raw)}add(t){return this.token.equals(t.token)||this.logger.logWithError("add token not equals"),new we(this.token,this.raw.add(t.raw))}subtract(t){return this.token.equals(t.token)||this.logger.logWithError("sub token not equals"),new we(this.token,this.raw.sub(t.raw))}toSignificant(t=this.token.decimals,n,i=0){return super.toSignificant(t,n,i)}toFixed(t=this.token.decimals,n,i=0){return t>this.token.decimals&&this.logger.logWithError("decimals overflow"),super.toFixed(t,n,i)}toExact(t={groupSeparator:""}){return ei.DP=this.token.decimals,new ei(this.numerator.toString()).div(this.denominator.toString()).toFormat(t)}};import{PublicKey as lr}from"@solana/web3.js";import{TOKEN_PROGRAM_ID as ti}from"@solana/spl-token";var bn={chainId:101,address:lr.default.toBase58(),programId:ti.toBase58(),decimals:9,symbol:"SOL",name:"solana",logoURI:"https://img-v1.raydium.io/icon/So11111111111111111111111111111111111111112.png",tags:[],priority:2,type:"raydium",extensions:{coingeckoId:"solana"}},Je={chainId:101,address:"So11111111111111111111111111111111111111112",programId:ti.toBase58(),decimals:9,symbol:"WSOL",name:"Wrapped SOL",logoURI:"https://img-v1.raydium.io/icon/So11111111111111111111111111111111111111112.png",tags:[],priority:2,type:"raydium",extensions:{coingeckoId:"solana"}};import{PublicKey as An}from"@solana/web3.js";import{PublicKey as ae,SystemProgram as ni,SYSVAR_RENT_PUBKEY as mr}from"@solana/web3.js";import{TOKEN_PROGRAM_ID as dr}from"@solana/spl-token";function yn({pubkey:b,isSigner:e=!1,isWritable:t=!0}){return{pubkey:b,isWritable:t,isSigner:e}}var Uo=[yn({pubkey:dr,isWritable:!1}),yn({pubkey:ni.programId,isWritable:!1}),yn({pubkey:mr,isWritable:!1})];function gn({publicKey:b,transformSol:e}){let t=ii(b.toString());if(t instanceof ae)return e&&t.equals(ht)?Q:t;if(e&&t.toString()===ht.toBase58())return Q;if(typeof t=="string"){if(t===ae.default.toBase58())return ae.default;try{return new ae(t)}catch{throw new Error("invalid public key")}}throw new Error("invalid public key")}function ii(b){try{return new ae(b)}catch{return b}}var jt=new ae("MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr"),Pn=new ae("MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr"),$e=new ae("SysvarRent111111111111111111111111111111111"),Xo=new ae("SysvarC1ock11111111111111111111111111111111"),rt=new ae("metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s"),zo=new ae("Sysvar1nstructions1111111111111111111111111"),Ho=ni.programId,jo=new ae("4k3Dyjzvzp8eMZWUXbBCjEvwSkkk59S5iCNLY3QrkX6R"),Zo=new ae("Ea5SjE2Y6yvCeW5dYTn7PYMuW5ikXkvbGdcmSnXeaLjS"),Yo=new ae("SRMuApVNdxXokk5GT7XD5cUUgXMBCoAz2LHeuAoKWRt"),Qo=new ae("EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v"),Jo=new ae("Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB"),$o=new ae("mSoLzYCxHdYgdzU16g5QSh3i5K3z3KZK7ytfqcJm7So"),es=new ae("7dHbWXmci3dT8UFYWYZweBLXgycu7Y3iL6trKn1Y7ARj"),ts=new ae("USDH1SM1ojwWUga67PGrgFWUHibbjqMvuMaDkRJTgkX"),ns=new ae("NRVwhjBQiUPYtfDT5zRBVJajzFQHaBUNtC7SNVvqRFa"),is=new ae("ANAxByE6G2WjFp7A4NqtWYXb3mgruyzZYg3spfxe6Lbo"),rs=new ae("7vfCXTUXx5WJV5JADk17DUJ4ksgau7utNKj4b963voxs"),Q=new ae("So11111111111111111111111111111111111111112"),ht=ae.default;function it(b){return gn({publicKey:b,transformSol:!0})}var wn=class{constructor({mint:e,decimals:t,symbol:n,name:i,skipMint:o=!1,isToken2022:r=!1}){if(e===ht.toBase58()||e instanceof An&&ht.equals(e)){this.decimals=Je.decimals,this.symbol=Je.symbol,this.name=Je.name,this.mint=new An(Je.address),this.isToken2022=!1;return}this.decimals=t,this.symbol=n||e.toString().substring(0,6),this.name=i||e.toString().substring(0,6),this.mint=o?An.default:gn({publicKey:e}),this.isToken2022=r}equals(e){return this===e?!0:this.mint.equals(e.mint)}},Ve=wn;Ve.WSOL=new wn(G(F({},Je),{mint:Je.address}));var Tn=class{constructor({decimals:e,symbol:t="UNKNOWN",name:n="UNKNOWN"}){this.decimals=e,this.symbol=t,this.name=n}equals(e){return this===e}},Zt=Tn;Zt.SOL=new Tn(bn);import pr from"bn.js";var ri=new J(new pr(100)),et=class extends J{toSignificant(e=5,t,n){return this.mul(ri).toSignificant(e,t,n)}toFixed(e=2,t,n){return this.mul(ri).toFixed(e,t,n)}};var fr=Ae("Raydium_price"),Oe=class extends J{constructor(t){let{baseToken:n,quoteToken:i,numerator:o,denominator:r}=t;super(o,r);this.baseToken=n,this.quoteToken=i,this.scalar=new J(kn(n.decimals),kn(i.decimals))}get raw(){return new J(this.numerator,this.denominator)}get adjusted(){return super.mul(this.scalar)}invert(){return new Oe({baseToken:this.quoteToken,quoteToken:this.baseToken,denominator:this.numerator,numerator:this.denominator})}mul(t){this.quoteToken!==t.baseToken&&fr.logWithError("mul token not equals");let n=super.mul(t);return new Oe({baseToken:this.baseToken,quoteToken:t.quoteToken,denominator:n.denominator,numerator:n.numerator})}toSignificant(t=this.quoteToken.decimals,n,i){return this.adjusted.toSignificant(t,n,i)}toFixed(t=this.quoteToken.decimals,n,i){return this.adjusted.toFixed(t,n,i)}};import{PublicKey as Es}from"@solana/web3.js";import Vs from"bn.js";var br=new He(0),ia=new He(1),ra=new He(2),oa=new He(3),sa=new He(5),fn=new He(10),aa=new He(100),ca=new He(1e3),ua=new He(1e4);function kn(b){return fn.pow(ge(b))}function dn(b,e=1,t=[]){let n=[...b];if(e<=0)return t;for(;n.length;)t.push(n.splice(0,e));return t}import{PublicKey as kr}from"@solana/web3.js";import{TOKEN_PROGRAM_ID as xr}from"@solana/spl-token";import{ComputeBudgetProgram as oi,Keypair as ai,PublicKey as yr,Transaction as ci,TransactionMessage as gr,VersionedTransaction as ui}from"@solana/web3.js";var ne={CreateAccount:"CreateAccount",InitAccount:"InitAccount",CreateATA:"CreateATA",CloseAccount:"CloseAccount",TransferAmount:"TransferAmount",InitMint:"InitMint",MintTo:"MintTo",InitMarket:"InitMarket",Util1216OwnerClaim:"Util1216OwnerClaim",SetComputeUnitPrice:"SetComputeUnitPrice",SetComputeUnitLimit:"SetComputeUnitLimit",ClmmCreatePool:"ClmmCreatePool",ClmmOpenPosition:"ClmmOpenPosition",ClmmIncreasePosition:"ClmmIncreasePosition",ClmmDecreasePosition:"ClmmDecreasePosition",ClmmClosePosition:"ClmmClosePosition",ClmmSwapBaseIn:"ClmmSwapBaseIn",ClmmSwapBaseOut:"ClmmSwapBaseOut",ClmmInitReward:"ClmmInitReward",ClmmSetReward:"ClmmSetReward",ClmmCollectReward:"ClmmCollectReward",ClmmLockPosition:"ClmmLockPosition",ClmmHarvestLockPosition:"ClmmHarvestLockPosition",AmmV4Swap:"AmmV4Swap",AmmV4AddLiquidity:"AmmV4AddLiquidity",AmmV4RemoveLiquidity:"AmmV4RemoveLiquidity",AmmV4SimulatePoolInfo:"AmmV4SimulatePoolInfo",AmmV4SwapBaseIn:"AmmV4SwapBaseIn",AmmV4SwapBaseOut:"AmmV4SwapBaseOut",AmmV4CreatePool:"AmmV4CreatePool",AmmV4InitPool:"AmmV4InitPool",AmmV5AddLiquidity:"AmmV5AddLiquidity",AmmV5RemoveLiquidity:"AmmV5RemoveLiquidity",AmmV5SimulatePoolInfo:"AmmV5SimulatePoolInfo",AmmV5SwapBaseIn:"AmmV5SwapBaseIn",AmmV5SwapBaseOut:"AmmV5SwapBaseOut",RouteSwap:"RouteSwap",RouteSwap1:"RouteSwap1",RouteSwap2:"RouteSwap2",FarmV3Deposit:"FarmV3Deposit",FarmV3Withdraw:"FarmV3Withdraw",FarmV3CreateLedger:"FarmV3CreateLedger",FarmV4Withdraw:"FarmV4Withdraw",FarmV5Deposit:"FarmV5Deposit",FarmV5Withdraw:"FarmV5Withdraw",FarmV5CreateLedger:"FarmV5CreateLedger",FarmV6Deposit:"FarmV6Deposit",FarmV6Withdraw:"FarmV6Withdraw",FarmV6Create:"FarmV6Create",FarmV6Restart:"FarmV6Restart",FarmV6CreatorAddReward:"FarmV6CreatorAddReward",FarmV6CreatorWithdraw:"FarmV6CreatorWithdraw",CpmmCreatePool:"CpmmCreatePool",CpmmAddLiquidity:"CpmmAddLiquidity",CpmmWithdrawLiquidity:"CpmmWithdrawLiquidity",CpmmSwapBaseIn:"CpmmSwapBaseIn",CpmmSwapBaseOut:"CpmmSwapBaseOut",CpmmLockLp:"CpmmLockLp",CpmmCollectLockFee:"CpmmCollectLockFee",TransferTip:"TransferTip"};import{TOKEN_PROGRAM_ID as Pr}from"@solana/spl-token";var si=Ae("Raydium_txUtil"),li=1644;function Yt(b){let e=[],t=[];return b.microLamports&&(e.push(oi.setComputeUnitPrice({microLamports:b.microLamports})),t.push(ne.SetComputeUnitPrice)),b.units&&(e.push(oi.setComputeUnitLimit({units:b.units})),t.push(ne.SetComputeUnitLimit)),{instructions:e,instructionTypes:t}}async function dt(b,e){var n,i;let t=e!=null?e:"confirmed";return(i=await((n=b.getLatestBlockhash)==null?void 0:n.call(b,{commitment:t})))==null?void 0:i.blockhash}async function Qt(b,e){return b.getSignatureStatuses([e]),new Promise((t,n)=>{let i=setTimeout(n,6e4);b.onSignature(e,o=>{if(clearTimeout(i),!o.err){t("");return}n(Object.assign(o.err,{txId:e}))},"confirmed")})}function Ar(b,e){b.length<1&&si.logWithError(`no instructions provided: ${b.toString()}`),e.length<1&&si.logWithError(`no signers provided:, ${e.toString()}`);let t=new ci;t.recentBlockhash="11111111111111111111111111111111",t.feePayer=e[0],t.add(...b);try{return Buffer.from(t.serialize({verifySignatures:!1})).toString("base64").length<li}catch{return!1}}function Te(b,e){let[t,n]=yr.findProgramAddressSync(b,e);return{publicKey:t,nonce:n}}function Bt({instructions:b,payer:e,signers:t}){return Ar(b,[e,...t])}function It({instructions:b,payer:e,lookupTableAddressAccount:t,recentBlockhash:n=ai.generate().publicKey.toString()}){let o=new gr({payerKey:e,recentBlockhash:n,instructions:b}).compileToV0Message(Object.values(t!=null?t:{}));try{return Buffer.from(new ui(o).serialize()).toString("base64").length<li}catch{return!1}}var wr=b=>Buffer.isBuffer(b)?b:b instanceof Uint8Array?Buffer.from(b.buffer,b.byteOffset,b.byteLength):Buffer.from(b),Tr=b=>{let e=b.serialize({requireAllSignatures:!1,verifySignatures:!1});b instanceof ui&&(e=wr(e));try{return e instanceof Buffer?e.toString("base64"):Buffer.from(e).toString("base64")}catch{return e.toString("base64")}};function ot(b){let e=[];return b.forEach(t=>{t instanceof ci&&(t.recentBlockhash||(t.recentBlockhash=Pr.toBase58()),t.feePayer||(t.feePayer=ai.generate().publicKey)),e.push(Tr(t))}),console.log("simulate tx string:",e),e}function ie(b,e,t){return Te([b.toBuffer(),(t!=null?t:xr).toBuffer(),e.toBuffer()],new kr("ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL"))}import{PublicKey as E}from"@solana/web3.js";var Ra=new E("EhhTKczWMGQt46ynNeRX1WfeagwwJd7ufHvCDjRxjo5Q"),La=new E("CBuCnLe26faBpcBP2fktp4rp8abpcAnTWft6ZrP5Q4T"),Na=new E("9KEPoZmtHUrBbhWN1v1KWLMkkvwY6WLtAVUCPRtRjP4z"),Ma=new E("FarmqiPv5eAj3j1GMdMCMUGXqPUvmquZtMy86QH6rzhG"),Fa=new E("CLaimxFqjHzgTJtAGHU47NPhg6qrc5sCnpC4tBLyABQS"),Oa=new E("srmqPvymJeFKQ4zGQed1GFppgkRHL9kaELCbyksJtPX"),Ea=new E("9xQeWvG816bUx9EPjHmaT23yvVM2ZWbrrpZb9PusVFin"),Da=new E("675kPX9MHTjS2zt1qfr1NYHuzeLXfQM9H24wFSUt1Mp8"),Va=new E("5quBtoiQqxF9Jv6KYKctB59NT3gtJD2Y65kdnB1Uev3h"),_a=new E("CDSr3ssLcRB6XYPJwAfFt18MZvEZp4LjHcvzBVZ45duo"),St=new E("CAMMCzo5YL8w4VFF8KVHrK22GGUsp5VTaW7grrKgrWqK"),Ct=new E("LockrWmn6K5twhz3y9w1dQERbmgSaRkfnTeTKbpofwE"),Jt=new E("kN1kEznaF5Xbd8LYuqtEFcxzWSBk5Fv6ygX6SqEGJVy"),va=new E("CDSr3ssLcRB6XYPJwAfFt18MZvEZp4LjHcvzBVZ45duo"),Wa=new E("routeUGWgWzqBWFcrCfv8tritsqukccJPu3q5GPP3xS"),qa=new E("7YttLkHDoNj9wyDur5pM1ejNaAvT9X4eqaYcHQqtj2G5"),Ga=new E("6FJon3QE27qgPVggARueB22hLvoh22VzJpXv4rBEoSLF"),Ua=new E("CC12se5To1CdEuw7fDS27B7Geo5jJyL7t5UK2B44NgiH"),Xa=new E("9HzJyW1qZsEiSfMUf6L2jo3CcTKAyBmSyKdwQeYisHrC"),za=new E("DropEU8AvevN3UrXWXTMuz3rqnMczQVNjq3kcSdW2SQi"),Ha=new E("CPMMoo8L3F4NbTegBCKVNunggL7H1ZpdTHKxQB5qKP1C"),ja=new E("GpMZbSM2GgvTKHJirzeGfMFoaZ8UR2X7F4v8vHTvxFbL"),Za=new E("DNXgeM9EiiaAbaWvwjHj9fQQLAX5ZsfHyvmYUNRAdNC8"),Ya=new E("LockrWmn6K5twhz3y9w1dQERbmgSaRkfnTeTKbpofwE"),Qa=new E("3f7GcQFG397GAaEnv51zR6tsTVihYRydnydDD1cXekxH"),Ja=new E("LanMV9sAd7wArD4vJFi2qDdfnVhFxYSUg6eADduJ3uj"),$a=new E("WLHv2UAZm6z4KyaaELi5pjdbJh6RESMva1Rnn8pJVVh"),ec=new E("DRay6fNdQ5J82H7xV6uq2aV3mNrUZ1J4PgSKsWgptcm6"),tc=new E("5xqNaZXX5eUi4p5HU4oz9i5QnwRNT2y6oN7yyn4qENeq"),nc=new E("4Bu96XjU84XjPDSpveTVf6LYGCkfW5FK7SNkREWcEfV4"),ic=new E("6s1xP3hpbAfFoNtUNF8mfHsjr2Bd97JxFJRWLbL6aHuX");var rc={OPEN_BOOK_PROGRAM:new E("EoTcMgcDRTJVZDMZWBoU6rhYHZfkNTVEAfz3uUJRcYGj"),SERUM_PROGRAM_ID_V3:new E("Ray1111111111111111111111111111111111111111"),AMM_V4:new E("DRaya7Kj3aMWQSy19kSjvmuwq9docCHofyP9kanQGaav"),AMM_STABLE:new E("DRayDdXc1NZQ9C3hRWmoSf8zK4iapgMnjdNZWrfwsP8m"),CLMM_PROGRAM_ID:new E("DRayAUgENGQBKVaX8owNhgzkEDyoHTGVEGHVJT1E9pfH"),CLMM_LOCK_PROGRAM_ID:new E("DRay25Usp3YJAi7beckgpGUC7mGJ2cR1AVPxhYfwVCUX"),CLMM_LOCK_AUTH_ID:new E("6Aoh8h2Lw2m5UGxYR8AdAL87jTWYeKoxM52mJRzfYwN"),CREATE_CPMM_POOL_PROGRAM:new E("DRaycpLY18LhpbydsBWbVJtxpNv9oXPgjRSfpF2bWpYb"),CREATE_CPMM_POOL_AUTH:new E("CXniRufdq5xL8t8jZAPxsPZDpuudwuJSPWnbcD5Y5Nxq"),CREATE_CPMM_POOL_FEE_ACC:new E("3oE58BKVt8KuYkGxx8zBojugnymWmBiyafWgMrnb6eYy"),LOCK_CPMM_PROGRAM:new E("DRay25Usp3YJAi7beckgpGUC7mGJ2cR1AVPxhYfwVCUX"),LOCK_CPMM_AUTH:new E("7qWVV8UY2bRJfDLP4s37YzBPKUkVB46DStYJBpYbQzu3"),UTIL1216:E.default,Router:new E("DRaybByLpbUL57LJARs3j8BitTxVfzBg351EaMr5UTCd"),FARM_PROGRAM_ID_V3:new E("DRayWyrLmEW5KEeqs8kdTMMaBabapqagaBC7KWpGtJeZ"),FARM_PROGRAM_ID_V4:new E("Ray1111111111111111111111111111111111111111"),FARM_PROGRAM_ID_V5:new E("DRayiCGSZgku1GTK6rXD6mVDdingXy6APAH1R6R5L2LC"),FARM_PROGRAM_ID_V6:new E("DRayzbYakXs45ELHkzH6vC3fuhQqTAnv5A68gdFuvZyZ"),LAUNCHPAD_PROGRAM:new E("DRay6fNdQ5J82H7xV6uq2aV3mNrUZ1J4PgSKsWgptcm6"),LAUNCHPAD_AUTH:new E("5xqNaZXX5eUi4p5HU4oz9i5QnwRNT2y6oN7yyn4qENeq"),LAUNCHPAD_PLATFORM:new E("2Jx4KTDrVSdWNazuGpcA8n3ZLTRGGBDxAWhuKe2Xcj2a"),LAUNCHPAD_CONFIG:new E("7ZR4zD7PYfY2XxoG1Gxcy2EgEeGYrpxrwzPuwdUBssEt"),FEE_DESTINATION_ID:new E("9y8ENuuZ3b19quffx9hQvRVygG5ky6snHfRvGpuSfeJy"),MODEL_DATA_PUBKEY:new E("Ray1111111111111111111111111111111111111111")};import Ee from"bn.js";var Kt=1e4;function ce(b,e,t,n){if(e===void 0)return{amount:b,fee:void 0,expirationTime:void 0};let i=G(F({},e),{olderTransferFee:{epoch:BigInt(e.olderTransferFee.epoch),maximumFee:BigInt(e.olderTransferFee.maximumFee),transferFeeBasisPoints:e.olderTransferFee.transferFeeBasisPoints},newerTransferFee:{epoch:BigInt(e.newerTransferFee.epoch),maximumFee:BigInt(e.newerTransferFee.maximumFee),transferFeeBasisPoints:e.newerTransferFee.transferFeeBasisPoints}}),o=t.epoch<i.newerTransferFee.epoch?i.olderTransferFee:i.newerTransferFee,r=new Ee(o.maximumFee.toString()),s=t.epoch<i.newerTransferFee.epoch?(Number(i.newerTransferFee.epoch)*t.slotsInEpoch-t.absoluteSlot)*400/1e3:void 0;if(n)if(o.transferFeeBasisPoints===Kt){let a=new Ee(o.maximumFee.toString());return{amount:b.add(a),fee:a,expirationTime:s}}else{let a=xn(b.mul(new Ee(Kt)),new Ee(Kt-o.transferFeeBasisPoints)),c=new Ee(o.maximumFee.toString()),l=a.sub(b).gt(c)?b.add(c):a,d=xn(l.mul(new Ee(o.transferFeeBasisPoints)),new Ee(Kt)),f=d.gt(r)?r:d;return{amount:l,fee:f,expirationTime:s}}else{let a=xn(b.mul(new Ee(o.transferFeeBasisPoints)),new Ee(Kt)),c=a.gt(r)?r:a;return{amount:b,fee:c,expirationTime:s}}}function tt(b,e){return b===void 0?e:e===void 0?b:Math.min(b,e)}function xn(b,e){let{div:t,mod:n}=b.divmod(e);return n.gt(new Ee(0))?t.add(new Ee(1)):t}import{PublicKey as hn,AddressLookupTableAccount as ft}from"@solana/web3.js";async function Bn({connection:b,address:e,cluster:t="mainnet"}){let n=await Xe(b,[...new Set(e.map(o=>o.toString()))].map(o=>new hn(o))),i={};for(let o=0;o<e.length;o++){let r=n[o],s=e[o];if(!r)continue;let a=new ft({key:s,state:ft.deserialize(r.data)});i[s.toString()]=a,t==="devnet"?pt[s.toString()]=a:$t[s.toString()]=a}return i}var $t={AcL1Vo8oy1ULiavEcjSUcwfBSForXMudcZvDZy5nzJkU:new ft({key:new hn("AcL1Vo8oy1ULiavEcjSUcwfBSForXMudcZvDZy5nzJkU"),state:ft.deserialize(Buffer.from("AQAAAP//////////I1rcEwAAAAAvAQYwun9CU6c5Ikm2pAj+D9IEnCOR45nK+SFTGSdpd6J6AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAbd9uHXZaGT2cvhRs7reawctIXtX1s3kTqM9YV+/wCpBt324e51j94YQl285GzN2rYa/E2DuQ0n/r35KNihi/wFSlNQ+F3IgtYUpVZyeIopbd8eq6vQpgZ4iEky9O72oAVKU1qZKSEGTSTocWDaOHx8NbXdvJK7geQfqEBBBUSNBqfVFxksXFEhjMlMPUrxf1ja7gibof1E49vZigAAAAAGp9UXGMd0yShWY5hpHV62i164o5tLbVxzVVshAAAAAIyXJY9OJInxuz0QKRSODYMLWhOZ2v8QhASOe9jb6fhZC3BlsePRfEU4nVJ/awTDzVi4bHMaoP21SbbRvAP4KUbIScv+6Yw2LHF/6K0ZjUPibbSWXCirYPGuuVl7zT789IUPLW4CpHr4JNCatp3ELXDLKMv6JJ+37le50lbBJ2LvBkX2T9y7AHdNGviJAqQNtlDUDCnauQRWybsLji6nPM8Qkw5asQRvCdB3MbX6IEBwytOrpM32l4jQygKG9TKgR0vZScQ2AsM/IHeQ7RajUkyhuZdc8SGiqQz/7H34torNR/Wir3sl0ruUrVxJWEZfUg+QLNAxxODdBi53/OP7Ioil1cqeBM9dtZC3FLov4yyxWRM/wcGStyJX/QfTnLBAHqkqWotPKVlShCVQqpP9W5W1rOao65IMk5QuQ2kMIOxzDMKAy2vjGSxQODgBz0QwGA+eP4ZjIjrIAQaXENv31QfLlOdXSRCkaybRniDHF4C8YcwhcvsqrOVuTP4B2Na+9wLdtrB31uz2rtlFI5kahdsnp/d1SrASDInYCtTYtdoke4kX+hoKWcEWM4Tle8pTUkUVv4BxS6fje/EzKBE4Qu/YsA/yfEEFGcr8Z57VKDw8uQzpiru7g4lvjnfapW62W030syevD8k07SGoxUHiuT/ai7gAHWWhDsVmg/C63ajgpkH7Sn3GdutArDTfyqOkdqv4/IPC/EFFy7mGkfDd2C57N5a/4jC+BbmJy7wQaSEZr0CQU88lPtUxIVvzGjC95b8Ooss2TqmkrayGKofkPMGQn7Ux+9lfwBSNfxwH8NgbpqC/7LNlV4I7nCvsXf3p+ohQk9NrAJb2KAFpUqEIJ9ZBV7BYDzHF/ORKYlgtvPnXjudZQ6CEo5OzUDaNIomTCCsvhD16TxJjsbgne1kGnQPCFSoaxUbq2V1bPMFQ3VYP6wDZ9bKStCFKx9A3tNbwZFC5ZGAN83MFK7XoTy+OmmcFEr6rLOjfSuTfPvHJkSVxW6Qllwkl67XcBi5v00u2gQsbu+38sp+rd5pA/LvyWj4P94ZGZwc1tE2P88xekCLcAwZGb+UhFzL/7K26csOb57yM5bvF9xJrLEObOkAAAAAn+HWRkdcPKyFFMnVwEoD7vnD0jCKFIU1sImubYCxNTSVzsKpaQX+fzNxrLAI3L14JQnJx/D6Uk2LADIHGqnGELzjEbkBDAlaM77NkXMPfqXNLSveCkWI7UEgNs31WEWB6XHSYI/v5DklHOb4QTtDOR804PVbi3fjloZeLR2F8d4FuZmMMO7ck3Fnkn2zEMG5gOmqsygb6PjTitArVl52NhcSznTxVnguaIJxiZkAnurDmn3MWR0PC2GLghp2KJqHCc6QQ85odeIjFHKOlRlJyeSXVJmL8vb1UgOzsbJPVP8p6zM4M3C1Sd7uWIHP33G42AP2Zg8ucn/n6meQjjD266JgCWdxZD6PXs9CsnIeL7SSG0/6lGb9xfP0ZcWkCXB/3hjxHYVXjra/GPOeXGk0fLLKjCbk+mgs2w6d2oCwimBipTzuoZ30GiI8ij8VRzD5CzMWtu2m21eDBIfjGAEo4pQeNNonKcqzV/cleX8ySZLOHsz8PtBCrLqF+VkLm9hOzIT+6i/nIf6keR4GWKMOD4AvqfpjHoD4DuhBpz8P28+DxkGrDXXr/nr20x291VPvcTU/b+b+o2kC9G0kcXeTlLjU6a2TQXWlZ4gBUdBl1jgT7mObSTpLblNiXZsLkbmVXZwvFKXua5cUKlWed/w30skmEUraTuQqtqr5fHZPW9n57EmeTif6LjHL2YJFZkQU+TrJmFzqzmF4/b8OwrPQAprl8mX3q4LUIdAS/a+11B6DWD1Xk2++Sn94dLC4xjkO4Wtlw8c4XuzciVbepHOmnoWzVu/0y3KCrLCSfQxQ3br8DJCoVzhgtPsS2nZZjsBGIZgnU0QpMv+2MnRsnKwdp1VsrCX84j/qvaZn4WhKunippgTbN2EUs0tPTP55Qfgj+nKmjtWW5IYs72FrEwJKYoNfsmqaF4o5pf4v9zgPwVwY/5I4XJKUL2L25m9kAQcW/K+H1RTFEUoj8Z4ajpOmAB/dG0COmCphVMW2CCMvnxhcGiSgPnpDuWu6qiJ7NG7ye5kvHgefgqPLeicspNJ5EpL3XiRNLM2tmJLI1awAwOyd6iHv0dCkMYRKaa6rcaZeYwmKCkckm0kM2JNmnmmAaBQQ7mwmIM0IMxX4f5W6j9PqZWcJxF7r17T/lQBAmcjoupRiJifbnXCNUv9GhpRF19WcBdeKbivRJVlGop6I2RS6lGImJ9udcI1S/0aGlEXX1ZwF14puK9ElWUainojZFYVHLHD6dIP2ESjqBzg3ol1/wB7+/ylGwd9LS7wSZ2A630CJSVKwH47K9P4bB8PEQP8BwjMFa7xQHOqZFP1XqaQ==","base64"))})},pt={},In=async b=>{let e="EFhMuDw1PKEuckuFRW9PavNfTH4LKP5uKHgyXDmWpFCq";if(pt[e])return pt;let t=new hn(e),n=await b.getAccountInfo(t);return n&&(pt[e]=new ft({key:t,state:ft.deserialize(n.data)})),pt};import{PublicKey as bt,sendAndConfirmTransaction as Sn,SystemProgram as Br,Transaction as Rt,TransactionMessage as Lt,VersionedTransaction as Nt}from"@solana/web3.js";import Ir from"axios";var en=2e3,tn=class{constructor(e){this.instructions=[];this.endInstructions=[];this.lookupTableAddress=[];this.signers=[];this.instructionTypes=[];this.endInstructionTypes=[];this.connection=e.connection,this.feePayer=e.feePayer,this.signAllTransactions=e.signAllTransactions,this.owner=e.owner,this.cluster=e.cluster,this.blockhashCommitment=e.blockhashCommitment,this.loopMultiTxStatus=!!e.loopMultiTxStatus}get AllTxData(){return{instructions:this.instructions,endInstructions:this.endInstructions,signers:this.signers,instructionTypes:this.instructionTypes,endInstructionTypes:this.endInstructionTypes,lookupTableAddress:this.lookupTableAddress}}get allInstructions(){return[...this.instructions,...this.endInstructions]}async getComputeBudgetConfig(){var n;let e=(await Ir.get(`https://solanacompass.com/api/fees?cacheFreshTime=${3e5}`)).data,{avg:t}=(n=e==null?void 0:e[15])!=null?n:{};if(!!t)return{units:6e5,microLamports:Math.min(Math.ceil(t*1e6/6e5),25e3)}}addCustomComputeBudget(e){if(e){let{instructions:t,instructionTypes:n}=Yt(e);return this.instructions.unshift(...t),this.instructionTypes.unshift(...n),!0}return!1}addTipInstruction(e){var t;return e?(this.endInstructions.push(Br.transfer({fromPubkey:(t=e.feePayer)!=null?t:this.feePayer,toPubkey:new bt(e.address),lamports:BigInt(e.amount.toString())})),this.endInstructionTypes.push(ne.TransferTip),!0):!1}async calComputeBudget({config:e,defaultIns:t}){try{let n=e||await this.getComputeBudgetConfig();if(this.addCustomComputeBudget(n))return;t&&this.instructions.unshift(...t)}catch{t&&this.instructions.unshift(...t)}}addInstruction({instructions:e=[],endInstructions:t=[],signers:n=[],instructionTypes:i=[],endInstructionTypes:o=[],lookupTableAddress:r=[]}){return this.instructions.push(...e),this.endInstructions.push(...t),this.signers.push(...n),this.instructionTypes.push(...i),this.endInstructionTypes.push(...o),this.lookupTableAddress.push(...r.filter(s=>s!==bt.default.toString())),this}async versionBuild({txVersion:e,extInfo:t}){return e===0?await this.buildV0(F({},t||{})):this.build(t)}build(e){var n;let t=new Rt;return this.allInstructions.length&&t.add(...this.allInstructions),t.feePayer=this.feePayer,((n=this.owner)==null?void 0:n.signer)&&!this.signers.some(i=>i.publicKey.equals(this.owner.publicKey))&&this.signers.push(this.owner.signer),{builder:this,transaction:t,signers:this.signers,instructionTypes:[...this.instructionTypes,...this.endInstructionTypes],execute:async i=>{var l;let{recentBlockHash:o,skipPreflight:r=!0,sendAndConfirm:s,notSendToRpc:a}=i||{},c=o!=null?o:await dt(this.connection,this.blockhashCommitment);if(t.recentBlockhash=c,this.signers.length&&t.sign(...this.signers),ot([t]),(l=this.owner)!=null&&l.isKeyPair)return{txId:s?await Sn(this.connection,t,this.signers.find(f=>f.publicKey.equals(this.owner.publicKey))?this.signers:[...this.signers,this.owner.signer],{skipPreflight:r}):await this.connection.sendRawTransaction(t.serialize(),{skipPreflight:r}),signedTx:t};if(this.signAllTransactions){let d=await this.signAllTransactions([t]);if(this.signers.length)for(let f of d)try{f.sign(...this.signers)}catch{}return{txId:a?"":await this.connection.sendRawTransaction(d[0].serialize(),{skipPreflight:r}),signedTx:d[0]}}throw new Error("please provide owner in keypair format or signAllTransactions function")},extInfo:e||{}}}buildMultiTx(e){var c;let{extraPreBuildData:t=[],extInfo:n}=e,{transaction:i}=this.build(n),o=t.filter(l=>l.transaction.instructions.length>0),r=[i,...o.map(l=>l.transaction)],s=[this.signers,...o.map(l=>l.signers)],a=[...this.instructionTypes,...o.map(l=>l.instructionTypes).flat()];return(c=this.owner)!=null&&c.signer&&s.forEach(l=>{l.some(d=>d.publicKey.equals(this.owner.publicKey))||this.signers.push(this.owner.signer)}),{builder:this,transactions:r,signers:s,instructionTypes:a,execute:async l=>{var g;let{sequentially:d,onTxUpdate:f,skipTxCount:u=0,recentBlockHash:m,skipPreflight:p=!0}=l||{},y=m!=null?m:await dt(this.connection,this.blockhashCommitment);if((g=this.owner)!=null&&g.isKeyPair){if(d){let A=[],T=0;for(let k of r){if(++T,T<=u)continue;let w=await Sn(this.connection,k,this.signers.find(P=>P.publicKey.equals(this.owner.publicKey))?this.signers:[...this.signers,this.owner.signer],{skipPreflight:p});A.push(w)}return{txIds:A,signedTxs:r}}return{txIds:await await Promise.all(r.map(async A=>(A.recentBlockhash=y,await this.connection.sendRawTransaction(A.serialize(),{skipPreflight:p})))),signedTxs:r}}if(this.signAllTransactions){let A=r.map((k,w)=>(k.recentBlockhash=y,s[w].length&&k.sign(...s[w]),k));ot(A);let T=await this.signAllTransactions(A);if(d){let k=0,w=[],P=async()=>{if(!T[k])return;let x=await this.connection.sendRawTransaction(T[k].serialize(),{skipPreflight:p});w.push({txId:x,status:"sent",signedTx:T[k]}),f==null||f([...w]),k++;let h=!1,B=null,C=null,L=K=>{B!==null&&clearInterval(B),C!==null&&this.connection.removeSignatureListener(C);let M=w.findIndex(S=>S.txId===x);if(M>-1){if(w[M].status==="error"||w[M].status==="success")return;w[M].status=K.err?"error":"success"}f==null||f([...w]),K.err||P()};this.loopMultiTxStatus&&(B=setInterval(async()=>{var K;if(h){clearInterval(B);return}try{let M=await this.connection.getTransaction(x,{commitment:"confirmed",maxSupportedTransactionVersion:0});M&&(h=!0,clearInterval(B),L({err:((K=M.meta)==null?void 0:K.err)||null}),console.log("tx status from getTransaction:",x))}catch(M){h=!0,clearInterval(B),console.error("getTransaction timeout:",M,x)}},en)),C=this.connection.onSignature(x,K=>{if(h){this.connection.removeSignatureListener(C);return}h=!0,L(K)},"confirmed"),this.connection.getSignatureStatus(x)};return await P(),{txIds:w.map(x=>x.txId),signedTxs:T}}else{let k=[];for(let w=0;w<T.length;w+=1){let P=await this.connection.sendRawTransaction(T[w].serialize(),{skipPreflight:p});k.push(P)}return{txIds:k,signedTxs:T}}}throw new Error("please provide owner in keypair format or signAllTransactions function")},extInfo:n||{}}}async versionMultiBuild({extraPreBuildData:e,txVersion:t,extInfo:n}){return t===0?await this.buildV0MultiTx({extraPreBuildData:e,buildProps:n||{}}):this.buildMultiTx({extraPreBuildData:e,extInfo:n})}async buildV0(e){var p;let m=e||{},{lookupTableCache:t={},lookupTableAddress:n=[],forerunCreate:i,recentBlockhash:o}=m,r=mt(m,["lookupTableCache","lookupTableAddress","forerunCreate","recentBlockhash"]),s=F(F({},this.cluster==="devnet"?await In(this.connection):$t),t),a=Array.from(new Set([...n,...this.lookupTableAddress])),c=[];for(let y of a)s[y]===void 0&&c.push(new bt(y));let l=await Bn({connection:this.connection,address:c});for(let[y,g]of Object.entries(l))s[y]=g;let d=i?bt.default.toBase58():o!=null?o:await dt(this.connection,this.blockhashCommitment),f=new Lt({payerKey:this.feePayer,recentBlockhash:d,instructions:[...this.allInstructions]}).compileToV0Message(Object.values(s));((p=this.owner)==null?void 0:p.signer)&&!this.signers.some(y=>y.publicKey.equals(this.owner.publicKey))&&this.signers.push(this.owner.signer);let u=new Nt(f);return u.sign(this.signers),{builder:this,transaction:u,signers:this.signers,instructionTypes:[...this.instructionTypes,...this.endInstructionTypes],execute:async y=>{var k;let{skipPreflight:g=!0,sendAndConfirm:A,notSendToRpc:T}=y||{};if(ot([u]),(k=this.owner)!=null&&k.isKeyPair){let w=await this.connection.sendTransaction(u,{skipPreflight:g});return A&&await Qt(this.connection,w),{txId:w,signedTx:u}}if(this.signAllTransactions){let w=await this.signAllTransactions([u]);if(this.signers.length)for(let P of w)try{P.sign(this.signers)}catch{}return{txId:T?"":await this.connection.sendTransaction(w[0],{skipPreflight:g}),signedTx:w[0]}}throw new Error("please provide owner in keypair format or signAllTransactions function")},extInfo:r||{}}}async buildV0MultiTx(e){var c;let{extraPreBuildData:t=[],buildProps:n}=e,{transaction:i}=await this.buildV0(n),o=t.filter(l=>l.builder.instructions.length>0),r=[i,...o.map(l=>l.transaction)],s=[this.signers,...o.map(l=>l.signers)],a=[...this.instructionTypes,...o.map(l=>l.instructionTypes).flat()];return(c=this.owner)!=null&&c.signer&&s.forEach(l=>{l.some(d=>d.publicKey.equals(this.owner.publicKey))||this.signers.push(this.owner.signer)}),r.forEach(async(l,d)=>{l.sign(s[d])}),{builder:this,transactions:r,signers:s,instructionTypes:a,buildProps:n,execute:async l=>{var p;let{sequentially:d,onTxUpdate:f,recentBlockHash:u,skipPreflight:m=!0}=l||{};if(u&&r.forEach(y=>y.message.recentBlockhash=u),ot(r),(p=this.owner)!=null&&p.isKeyPair){if(d){let y=[];for(let g of r){let A=await this.connection.sendTransaction(g,{skipPreflight:m});await Qt(this.connection,A),y.push(A)}return{txIds:y,signedTxs:r}}return{txIds:await Promise.all(r.map(async y=>await this.connection.sendTransaction(y,{skipPreflight:m}))),signedTxs:r}}if(this.signAllTransactions){let y=await this.signAllTransactions(r);if(d){let g=0,A=[],T=async()=>{if(!y[g])return;let k=await this.connection.sendTransaction(y[g],{skipPreflight:m});A.push({txId:k,status:"sent",signedTx:y[g]}),f==null||f([...A]),g++;let w=!1,P=null,x=null,h=B=>{P!==null&&clearInterval(P),x!==null&&this.connection.removeSignatureListener(x);let C=A.findIndex(L=>L.txId===k);if(C>-1){if(A[C].status==="error"||A[C].status==="success")return;A[C].status=B.err?"error":"success"}f==null||f([...A]),B.err||T()};this.loopMultiTxStatus&&(P=setInterval(async()=>{var B;if(w){clearInterval(P);return}try{let C=await this.connection.getTransaction(k,{commitment:"confirmed",maxSupportedTransactionVersion:0});C&&(w=!0,clearInterval(P),h({err:((B=C.meta)==null?void 0:B.err)||null}),console.log("tx status from getTransaction:",k))}catch(C){w=!0,clearInterval(P),console.error("getTransaction timeout:",C,k)}},en)),x=this.connection.onSignature(k,B=>{if(w){this.connection.removeSignatureListener(x);return}w=!0,h(B)},"confirmed"),this.connection.getSignatureStatus(k)};return T(),{txIds:[],signedTxs:y}}else{let g=[];for(let A=0;A<y.length;A+=1){let T=await this.connection.sendTransaction(y[A],{skipPreflight:m});g.push(T)}return{txIds:g,signedTxs:y}}}throw new Error("please provide owner in keypair format or signAllTransactions function")},extInfo:n||{}}}async sizeCheckBuild(e){var f;let d=e||{},{splitIns:t=[],computeBudgetConfig:n}=d,i=mt(d,["splitIns","computeBudgetConfig"]),o=n?Yt(n):{instructions:[],instructionTypes:[]},r=this.signers.reduce((u,m)=>G(F({},u),{[m.publicKey.toBase58()]:m}),{}),s=[],a=[],c=[],l=0;if(this.allInstructions.forEach(u=>{let m=[...c,u],p=n?[...o.instructions,...m]:m,g=[...new Set(m.map(A=>A.keys.filter(T=>T.isSigner).map(T=>T.pubkey.toString())).flat()).values()].map(A=>new bt(A));if(u!==t[l]&&c.length<12&&(Bt({instructions:p,payer:this.feePayer,signers:g})||Bt({instructions:m,payer:this.feePayer,signers:g})))c.push(u);else{if(c.length===0)throw Error("item ins too big");l+=u===t[l]?1:0,Bt({instructions:n?[...o.instructions,...c]:[...c],payer:this.feePayer,signers:g})?s.push(new Rt().add(...o.instructions,...c)):s.push(new Rt().add(...c)),a.push(Array.from(new Set(c.map(A=>A.keys.filter(T=>T.isSigner).map(T=>T.pubkey.toString())).flat())).map(A=>r[A]).filter(A=>A!==void 0)),c=[u]}}),c.length>0){let m=[...new Set(c.map(p=>p.keys.filter(y=>y.isSigner).map(y=>y.pubkey.toString())).flat()).values()].map(p=>r[p]).filter(p=>p!==void 0);Bt({instructions:n?[...o.instructions,...c]:[...c],payer:this.feePayer,signers:m.map(p=>p.publicKey)})?s.push(new Rt().add(...o.instructions,...c)):s.push(new Rt().add(...c)),a.push(m)}return s.forEach(u=>u.feePayer=this.feePayer),(f=this.owner)!=null&&f.signer&&a.forEach(u=>{u.some(m=>m.publicKey.equals(this.owner.publicKey))||u.push(this.owner.signer)}),{builder:this,transactions:s,signers:a,instructionTypes:this.instructionTypes,execute:async u=>{var k;let{sequentially:m,onTxUpdate:p,skipTxCount:y=0,recentBlockHash:g,skipPreflight:A=!0}=u||{},T=g!=null?g:await dt(this.connection,this.blockhashCommitment);if(s.forEach(async(w,P)=>{w.recentBlockhash=T,a[P].length&&w.sign(...a[P])}),ot(s),(k=this.owner)!=null&&k.isKeyPair){if(m){let w=0,P=[];for(let x of s){if(++w,w<=y){P.push("tx skipped");continue}let h=await Sn(this.connection,x,this.signers.find(B=>B.publicKey.equals(this.owner.publicKey))?this.signers:[...this.signers,this.owner.signer],{skipPreflight:A});P.push(h)}return{txIds:P,signedTxs:s}}return{txIds:await Promise.all(s.map(async w=>await this.connection.sendRawTransaction(w.serialize(),{skipPreflight:A}))),signedTxs:s}}if(this.signAllTransactions){let w=await this.signAllTransactions(s.slice(y,s.length)),P=[...s.slice(0,y),...w];if(m){let x=0,h=[],B=async()=>{if(!P[x])return;x<y&&(h.push({txId:"",status:"success",signedTx:P[x]}),p==null||p([...h]),x++,B());let C=await this.connection.sendRawTransaction(P[x].serialize(),{skipPreflight:A});h.push({txId:C,status:"sent",signedTx:P[x]}),p==null||p([...h]),x++;let L=!1,K=null,M=null,S=V=>{K!==null&&clearInterval(K),M!==null&&this.connection.removeSignatureListener(M);let U=h.findIndex(ye=>ye.txId===C);if(U>-1){if(h[U].status==="error"||h[U].status==="success")return;h[U].status=V.err?"error":"success"}p==null||p([...h]),V.err||B()};this.loopMultiTxStatus&&(K=setInterval(async()=>{var V;if(L){clearInterval(K);return}try{let U=await this.connection.getTransaction(C,{commitment:"confirmed",maxSupportedTransactionVersion:0});U&&(L=!0,clearInterval(K),S({err:((V=U.meta)==null?void 0:V.err)||null}),console.log("tx status from getTransaction:",C))}catch(U){L=!0,clearInterval(K),console.error("getTransaction timeout:",U,C)}},en)),M=this.connection.onSignature(C,V=>{if(L){this.connection.removeSignatureListener(M);return}L=!0,S(V)},"confirmed"),this.connection.getSignatureStatus(C)};return await B(),{txIds:h.map(C=>C.txId),signedTxs:P}}else{let x=[];for(let h=0;h<P.length;h+=1){let B=await this.connection.sendRawTransaction(P[h].serialize(),{skipPreflight:A});x.push(B)}return{txIds:x,signedTxs:P}}}throw new Error("please provide owner in keypair format or signAllTransactions function")},extInfo:i||{}}}async sizeCheckBuildV0(e){var T;let A=e||{},{computeBudgetConfig:t,splitIns:n=[],lookupTableCache:i={},lookupTableAddress:o=[]}=A,r=mt(A,["computeBudgetConfig","splitIns","lookupTableCache","lookupTableAddress"]),s=F(F({},this.cluster==="devnet"?await In(this.connection):$t),i),a=Array.from(new Set([...this.lookupTableAddress,...o])),c=[];for(let k of a)s[k]===void 0&&c.push(new bt(k));let l=await Bn({connection:this.connection,address:c});for(let[k,w]of Object.entries(l))s[k]=w;let d=t?Yt(t):{instructions:[],instructionTypes:[]},f=await dt(this.connection,this.blockhashCommitment),u=this.signers.reduce((k,w)=>G(F({},k),{[w.publicKey.toBase58()]:w}),{}),m=[],p=[],y=[],g=0;if(this.allInstructions.forEach(k=>{let w=[...y,k],P=t?[...d.instructions,...w]:w;if(k!==n[g]&&y.length<12&&(It({instructions:P,payer:this.feePayer,lookupTableAddressAccount:s})||It({instructions:w,payer:this.feePayer,lookupTableAddressAccount:s})))y.push(k);else{if(y.length===0)throw Error("item ins too big");g+=k===n[g]?1:0;let x={};for(let h of[...new Set(a)])s[h]!==void 0&&(x[h]=s[h]);if(t&&It({instructions:[...d.instructions,...y],payer:this.feePayer,lookupTableAddressAccount:s,recentBlockhash:f})){let h=new Lt({payerKey:this.feePayer,recentBlockhash:f,instructions:[...d.instructions,...y]}).compileToV0Message(Object.values(s));m.push(new Nt(h))}else{let h=new Lt({payerKey:this.feePayer,recentBlockhash:f,instructions:[...y]}).compileToV0Message(Object.values(s));m.push(new Nt(h))}p.push(Array.from(new Set(y.map(h=>h.keys.filter(B=>B.isSigner).map(B=>B.pubkey.toString())).flat())).map(h=>u[h]).filter(h=>h!==void 0)),y=[k]}}),y.length>0){let w=[...new Set(y.map(P=>P.keys.filter(x=>x.isSigner).map(x=>x.pubkey.toString())).flat()).values()].map(P=>u[P]).filter(P=>P!==void 0);if(t&&It({instructions:[...d.instructions,...y],payer:this.feePayer,lookupTableAddressAccount:s,recentBlockhash:f})){let P=new Lt({payerKey:this.feePayer,recentBlockhash:f,instructions:[...d.instructions,...y]}).compileToV0Message(Object.values(s));m.push(new Nt(P))}else{let P=new Lt({payerKey:this.feePayer,recentBlockhash:f,instructions:[...y]}).compileToV0Message(Object.values(s));m.push(new Nt(P))}p.push(w)}return(T=this.owner)!=null&&T.signer&&p.forEach(k=>{k.some(w=>w.publicKey.equals(this.owner.publicKey))||k.push(this.owner.signer)}),m.forEach((k,w)=>{k.sign(p[w])}),{builder:this,transactions:m,buildProps:e,signers:p,instructionTypes:this.instructionTypes,execute:async k=>{var C;let{sequentially:w,onTxUpdate:P,skipTxCount:x=0,recentBlockHash:h,skipPreflight:B=!0}=k||{};if(m.map(async(L,K)=>{p[K].length&&L.sign(p[K]),h&&(L.message.recentBlockhash=h)}),ot(m),(C=this.owner)!=null&&C.isKeyPair){if(w){let L=0,K=[];for(let M of m){if(++L,L<=x){console.log("skip tx: ",L),K.push("tx skipped");continue}let S=await this.connection.sendTransaction(M,{skipPreflight:B});await Qt(this.connection,S),K.push(S)}return{txIds:K,signedTxs:m}}return{txIds:await Promise.all(m.map(async L=>await this.connection.sendTransaction(L,{skipPreflight:B}))),signedTxs:m}}if(this.signAllTransactions){let L=await this.signAllTransactions(m.slice(x,m.length)),K=[...m.slice(0,x),...L];if(w){let M=0,S=[],V=async()=>{if(!K[M])return;if(M<x){S.push({txId:"",status:"success",signedTx:K[M]}),P==null||P([...S]),M++,V();return}let U=await this.connection.sendTransaction(K[M],{skipPreflight:B});S.push({txId:U,status:"sent",signedTx:K[M]}),P==null||P([...S]),M++;let ye=!1,xe=null,Ue=null,lt=pe=>{xe!==null&&clearInterval(xe),Ue!==null&&this.connection.removeSignatureListener(Ue);let Be=S.findIndex(Qe=>Qe.txId===U);if(Be>-1){if(S[Be].status==="error"||S[Be].status==="success")return;S[Be].status=pe.err?"error":"success"}P==null||P([...S]),pe.err||V()};this.loopMultiTxStatus&&(xe=setInterval(async()=>{var pe;if(ye){clearInterval(xe);return}try{let Be=await this.connection.getTransaction(U,{commitment:"confirmed",maxSupportedTransactionVersion:0});Be&&(ye=!0,clearInterval(xe),lt({err:((pe=Be.meta)==null?void 0:pe.err)||null}),console.log("tx status from getTransaction:",U))}catch(Be){ye=!0,clearInterval(xe),console.error("getTransaction timeout:",Be,U)}},en)),Ue=this.connection.onSignature(U,pe=>{if(ye){this.connection.removeSignatureListener(Ue);return}ye=!0,lt(pe)},"confirmed"),this.connection.getSignatureStatus(U)};return V(),{txIds:[],signedTxs:K}}else{let M=[];for(let S=0;S<K.length;S+=1){let V=await this.connection.sendTransaction(K[S],{skipPreflight:B});M.push(V)}return{txIds:M,signedTxs:K}}}throw new Error("please provide owner in keypair format or signAllTransactions function")},extInfo:r||{}}}};import Sr from"bn.js";var Bc=new Sr(1e6);import{AccountLayout as qi,createAssociatedTokenAccountIdempotentInstruction as Gi,TOKEN_2022_PROGRAM_ID as nt,TOKEN_PROGRAM_ID as Gt}from"@solana/spl-token";import{PublicKey as jc}from"@solana/web3.js";import{MintLayout as Yc,TOKEN_PROGRAM_ID as Jc}from"@solana/spl-token";var nn=i=>{var o=i,{address:b,programId:e,decimals:t}=o,n=mt(o,["address","programId","decimals"]);return F({chainId:101,address:it(b).toBase58(),programId:e,logoURI:"",symbol:"",name:"",decimals:t,tags:[],extensions:n.extensions||{}},n)},Cn=b=>b?G(F({},b),{transferFeeConfigAuthority:b.transferFeeConfigAuthority.toBase58(),withdrawWithheldAuthority:b.withdrawWithheldAuthority.toBase58(),withheldAmount:b.withheldAmount.toString(),olderTransferFee:G(F({},b.olderTransferFee),{epoch:b.olderTransferFee.epoch.toString(),maximumFee:b.olderTransferFee.maximumFee.toString()}),newerTransferFee:G(F({},b.newerTransferFee),{epoch:b.newerTransferFee.epoch.toString(),maximumFee:b.newerTransferFee.maximumFee.toString()})}):void 0;var Kn=(...b)=>b.map(e=>{try{return typeof e=="object"?JSON.stringify(e):e}catch{return e}}).join(", "),Mt=class{constructor({scope:e,moduleName:t}){this.disabled=!1;this.scope=e,this.logger=Ae(t)}createTxBuilder(e){return this.scope.checkOwner(),new tn({connection:this.scope.connection,feePayer:e||this.scope.ownerPubKey,cluster:this.scope.cluster,owner:this.scope.owner,blockhashCommitment:this.scope.blockhashCommitment,loopMultiTxStatus:this.scope.loopMultiTxStatus,api:this.scope.api,signAllTransactions:this.scope.signAllTransactions})}logDebug(...e){this.logger.debug(Kn(e))}logInfo(...e){this.logger.info(Kn(e))}logAndCreateError(...e){let t=Kn(e);throw new Error(t)}checkDisabled(){(this.disabled||!this.scope)&&this.logAndCreateError("module not working")}};import{Keypair as un,PublicKey as I,SystemProgram as Ye,TransactionInstruction as ke}from"@solana/web3.js";import Gn from"bn.js";import{ASSOCIATED_TOKEN_PROGRAM_ID as qt,TOKEN_2022_PROGRAM_ID as de,TOKEN_PROGRAM_ID as ee}from"@solana/spl-token";import{PublicKey as Er}from"@solana/web3.js";import fi,{isBN as bi}from"bn.js";import{bits as uu,BitStructure as lu,blob as Cr,Blob as mu,cstr as du,f32 as pu,f32be as fu,f64 as bu,f64be as yu,greedy as gu,Layout as Kr,ns64 as Pu,ns64be as Au,nu64 as wu,nu64be as Tu,offset as ku,s16 as xu,s16be as hu,s24 as Bu,s24be as Iu,s32 as Rr,s32be as Su,s40 as Cu,s40be as Ku,s48 as Ru,s48be as Lu,s8 as Nu,seq as Lr,struct as Mu,Structure as Nr,u16 as Mr,u16be as Fu,u24 as Ou,u24be as Eu,u32 as Du,u32be as Vu,u40 as _u,u40be as vu,u48 as Wu,u48be as qu,u8 as Fr,UInt as Or,union as Gu,Union as Uu,unionLayoutDiscriminator as Xu,utf8 as zu}from"@solana/buffer-layout";var Rn=Kr,mi=Nr;var Ln=Or;var di=Fr,Ft=Mr;var re=Rr;var pi=Lr;var Re=Cr;var yt=class extends Rn{constructor(t,n,i){super(t,i);this.blob=Re(t),this.signed=n}decode(t,n=0){let i=new fi(this.blob.decode(t,n),10,"le");return this.signed?i.fromTwos(this.span*8).clone():i}encode(t,n,i=0){return typeof t=="number"&&(t=new fi(t)),this.signed&&(t=t.toTwos(this.span*8)),this.blob.encode(t.toArrayLike(Buffer,"le",this.span),n,i)}};function me(b){return new Ln(1,b)}function gt(b){return new Ln(4,b)}function O(b){return new yt(8,!1,b)}function X(b){return new yt(16,!1,b)}function yi(b){return new yt(8,!0,b)}function gi(b){return new yt(16,!0,b)}var rn=class extends Rn{constructor(t,n,i,o){super(t.span,o);this.layout=t,this.decoder=n,this.encoder=i}decode(t,n){return this.decoder(this.layout.decode(t,n))}encode(t,n,i){return this.layout.encode(this.encoder(t),n,i)}getSpan(t,n){return this.layout.getSpan(t,n)}};function te(b){return new rn(Re(32),e=>new Er(e),e=>e.toBuffer(),b)}function Ie(b){return new rn(di(),Dr,Vr,b)}function Dr(b){if(b===0)return!1;if(b===1)return!0;throw new Error("Invalid bool: "+b)}function Vr(b){return b?1:0}var Nn=class extends mi{decode(e,t){return super.decode(e,t)}};function $(b,e,t){return new Nn(b,e,t)}function ue(b,e,t){let n,i=typeof e=="number"?e:bi(e)?e.toNumber():new Proxy(e,{get(o,r){if(!n){let s=Reflect.get(o,"count");n=bi(s)?s.toNumber():s,Reflect.set(o,"count",n)}return Reflect.get(o,r)},set(o,r,s){return r==="count"&&(n=s),Reflect.set(o,r,s)}});return pi(b,i,t)}import Qr from"bn.js";import wt from"decimal.js";import Fe from"bn.js";var z=new Fe(0),_e=new Fe(1),je=new Fe(-1),Le=new Fe(1).shln(64),on=new Fe(1).shln(128),Mn=Le.sub(_e),Ot=64,Pi=on.subn(1),he=-443636,Se=-he,ve=new Fe("4295048016"),We=new Fe("79226673521066979257578248091"),sl=new Fe("4295048017"),al=new Fe("79226673521066979257578248090"),Ai=16,wi="59543866431248",Ti="184467440737095516",ki="15793534762490258745",sn=new Fe(10).pow(new Fe(6)),_r=(n=>(n[n.rate_500=500]="rate_500",n[n.rate_3000=3e3]="rate_3000",n[n.rate_10000=1e4]="rate_10000",n))(_r||{}),cl={[500]:10,[3e3]:60,[1e4]:200},ul={version:6,liquidity:z,tickCurrent:0,feeGrowthGlobalX64A:z,feeGrowthGlobalX64B:z,protocolFeesTokenA:z,protocolFeesTokenB:z,swapInAmountTokenA:z,swapOutAmountTokenB:z,swapInAmountTokenB:z,swapOutAmountTokenA:z,tickArrayBitmap:[],rewardInfos:[],day:{volume:0,volumeFee:0,feeA:0,feeB:0,feeApr:0,rewardApr:{A:0,B:0,C:0},apr:0,priceMax:0,priceMin:0},week:{volume:0,volumeFee:0,feeA:0,feeB:0,feeApr:0,rewardApr:{A:0,B:0,C:0},apr:0,priceMax:0,priceMin:0},month:{volume:0,volumeFee:0,feeA:0,feeB:0,feeApr:0,rewardApr:{A:0,B:0,C:0},apr:0,priceMax:0,priceMin:0},tvl:0},xi={tvl:0,volumeQuote:0,mintAmountA:0,mintAmountB:0,rewardDefaultInfos:[],farmUpcomingCount:0,farmOngoingCount:0,farmFinishedCount:0,day:{volume:0,volumeQuote:0,volumeFee:0,apr:0,feeApr:0,priceMin:0,priceMax:0,rewardApr:[0]},week:{volume:0,volumeQuote:0,volumeFee:0,apr:0,feeApr:0,priceMin:0,priceMax:0,rewardApr:[0]},month:{volume:0,volumeQuote:0,volumeFee:0,apr:0,feeApr:0,priceMin:0,priceMax:0,rewardApr:[0]},pooltype:[]},ll=new Fe("18446744073700000000");import q from"bn.js";import Ge from"decimal.js";function hi(b){let e=new ArrayBuffer(2);return new DataView(e).setUint16(0,b,!1),new Uint8Array(e)}function dl(b){let e=new ArrayBuffer(2);return new DataView(e).setInt16(0,b,!1),new Uint8Array(e)}function pl(b){let e=new ArrayBuffer(4);return new DataView(e).setUint32(0,b,!1),new Uint8Array(e)}function an(b){let e=new ArrayBuffer(4);return new DataView(e).setInt32(0,b,!1),new Uint8Array(e)}function Fn(b,e){let t=0;for(let n=b-1;n>=0&&!e.testn(n);n--)t++;return t}function On(b,e){let t=0;for(let n=0;n<b&&!e.testn(n);n++)t++;return t}function Et(b,e){for(let t=0;t<b;t++)if(e.testn(t))return!1;return!0}function Bi(b,e){return Et(b,e)?null:Fn(b,e)}function Ii(b,e){return Et(b,e)?null:On(b,e)}var vr=Buffer.from("amm_config","utf8"),Wr=Buffer.from("pool","utf8"),qr=Buffer.from("pool_vault","utf8"),Gr=Buffer.from("pool_reward_vault","utf8"),Si=Buffer.from("position","utf8"),Ur=Buffer.from("tick_array","utf8"),Xr=Buffer.from("operation","utf8"),zr=Buffer.from("pool_tick_array_bitmap_extension","utf8"),Hr=Buffer.from("observation","utf8");function gl(b,e){return Te([vr,hi(e)],b)}function Ci(b,e,t,n){return Te([Wr,e.toBuffer(),t.toBuffer(),n.toBuffer()],b)}function En(b,e,t){return Te([qr,e.toBuffer(),t.toBuffer()],b)}function Ki(b,e,t){return Te([Gr,e.toBuffer(),t.toBuffer()],b)}function H(b,e,t){return Te([Ur,e.toBuffer(),an(t)],b)}function De(b,e,t,n){return Te([Si,e.toBuffer(),an(t),an(n)],b)}function Ce(b,e){return Te([Si,e.toBuffer()],b)}function Dt(b){return Te([Buffer.from("metadata","utf8"),rt.toBuffer(),b.toBuffer()],rt)}function Vt(b){return Te([Xr],b)}function fe(b,e){return Te([zr,e.toBuffer()],b)}function Ri(b,e){return Te([Hr,e.toBuffer()],b)}var Li=Buffer.from("locked_position","utf8");function Dn(b,e){return Te([Li,e.toBuffer()],b)}function Pt(b,e){return Te([Li,e.toBuffer()],b)}var jr=Buffer.from("support_mint","utf8");function Vn(b,e){return Te([jr,e.toBuffer()],b)}import{PublicKey as Ne}from"@solana/web3.js";import{TOKEN_2022_PROGRAM_ID as Ni}from"@solana/spl-token";import oe from"bn.js";import Z from"decimal.js";import qe from"bn.js";import _n from"decimal.js";var _t=class{static getfeeGrowthInside(e,t,n){let i=new qe(0),o=new qe(0);e.tickCurrent>=t.tick?(i=t.feeGrowthOutsideX64A,o=t.feeGrowthOutsideX64B):(i=e.feeGrowthGlobalX64A.sub(t.feeGrowthOutsideX64A),o=e.feeGrowthGlobalX64B.sub(t.feeGrowthOutsideX64B));let r=new qe(0),s=new qe(0);e.tickCurrent<n.tick?(r=n.feeGrowthOutsideX64A,s=n.feeGrowthOutsideX64B):(r=e.feeGrowthGlobalX64A.sub(n.feeGrowthOutsideX64A),s=e.feeGrowthGlobalX64B.sub(n.feeGrowthOutsideX64B));let a=_.wrappingSubU128(_.wrappingSubU128(e.feeGrowthGlobalX64A,i),r),c=_.wrappingSubU128(_.wrappingSubU128(e.feeGrowthGlobalX64B,o),s);return{feeGrowthInsideX64A:a,feeGrowthInsideBX64:c}}static GetPositionFees(e,t,n,i){let{feeGrowthInsideX64A:o,feeGrowthInsideBX64:r}=this.getfeeGrowthInside(e,n,i),s=_.mulDivFloor(_.wrappingSubU128(o,t.feeGrowthInsideLastX64A),t.liquidity,Le),a=t.tokenFeesOwedA.add(s),c=_.mulDivFloor(_.wrappingSubU128(r,t.feeGrowthInsideLastX64B),t.liquidity,Le),l=t.tokenFeesOwedB.add(c);return{tokenFeeAmountA:a,tokenFeeAmountB:l}}static GetPositionFeesV2(e,t,n,i){let{feeGrowthInsideX64A:o,feeGrowthInsideBX64:r}=this.getfeeGrowthInside(e,n,i),s=_.mulDivFloor(_.wrappingSubU128(o,t.feeGrowthInsideLastX64A),t.liquidity,Le),a=t.tokenFeesOwedA.add(s),c=_.mulDivFloor(_.wrappingSubU128(r,t.feeGrowthInsideLastX64B),t.liquidity,Le),l=t.tokenFeesOwedB.add(c);return{tokenFeeAmountA:a,tokenFeeAmountB:l}}static GetPositionRewardsV2(e,t,n,i){let o=[],r=this.getRewardGrowthInsideV2(e.tickCurrent,n,i,e.rewardInfos);for(let s=0;s<r.length;s++){let a=r[s],c=t.rewardInfos[s],l=_.wrappingSubU128(a,c.growthInsideLastX64),d=_.mulDivFloor(l,t.liquidity,Le),f=c.rewardAmountOwed.add(d);o.push(f)}return o}static GetPositionRewards(e,t,n,i){let o=[],r=this.getRewardGrowthInside(e.tickCurrent,n,i,e.rewardInfos);for(let s=0;s<r.length;s++){let a=r[s],c=t.rewardInfos[s],l=_.wrappingSubU128(a,c.growthInsideLastX64),d=_.mulDivFloor(l,t.liquidity,Le),f=c.rewardAmountOwed.add(d);o.push(f)}return o}static getRewardGrowthInside(e,t,n,i){let o=[];for(let r=0;r<i.length;r++){let s=new qe(0);t.liquidityGross.eqn(0)?s=i[r].rewardGrowthGlobalX64:e<t.tick?s=i[r].rewardGrowthGlobalX64.sub(t.rewardGrowthsOutsideX64[r]):s=t.rewardGrowthsOutsideX64[r];let a=new qe(0);n.liquidityGross.eqn(0)||(e<n.tick?a=n.rewardGrowthsOutsideX64[r]:a=i[r].rewardGrowthGlobalX64.sub(n.rewardGrowthsOutsideX64[r])),o.push(_.wrappingSubU128(_.wrappingSubU128(i[r].rewardGrowthGlobalX64,s),a))}return o}static getRewardGrowthInsideV2(e,t,n,i){let o=[];for(let r=0;r<i.length;r++){let s=new qe(0);t.liquidityGross.eqn(0)?s=i[r].rewardGrowthGlobalX64:e<t.tick?s=i[r].rewardGrowthGlobalX64.sub(t.rewardGrowthsOutsideX64[r]):s=t.rewardGrowthsOutsideX64[r];let a=new qe(0);n.liquidityGross.eqn(0)||(e<n.tick?a=n.rewardGrowthsOutsideX64[r]:a=i[r].rewardGrowthGlobalX64.sub(n.rewardGrowthsOutsideX64[r])),o.push(_.wrappingSubU128(_.wrappingSubU128(i[r].rewardGrowthGlobalX64,s),a))}return o}static getAmountsFromLiquidity({poolInfo:e,ownerPosition:t,liquidity:n,slippage:i,add:o,epochInfo:r}){var y,g,A,T;let s=D.priceToSqrtPriceX64(new _n(e.price),e.mintA.decimals,e.mintB.decimals),a=D.getSqrtPriceX64FromTick(t.tickLower),c=D.getSqrtPriceX64FromTick(t.tickUpper),l=o?1+i:1-i,d=j.getAmountsFromLiquidity(s,a,c,n,o),[f,u]=[ce(d.amountA,(y=e.mintA.extensions)==null?void 0:y.feeConfig,r,!0),ce(d.amountB,(g=e.mintB.extensions)==null?void 0:g.feeConfig,r,!0)],[m,p]=[ce(new qe(new _n(d.amountA.toString()).mul(l).toFixed(0)),(A=e.mintA.extensions)==null?void 0:A.feeConfig,r,!0),ce(new qe(new _n(d.amountB.toString()).mul(l).toFixed(0)),(T=e.mintB.extensions)==null?void 0:T.feeConfig,r,!0)];return{liquidity:n,amountA:f,amountB:u,amountSlippageA:m,amountSlippageB:p,expirationTime:tt(f.expirationTime,u.expirationTime)}}};var Zr=15,Y=class{static async getTickArrays(e,t,n,i,o,r,s){let a=[],c=N.getTickArrayStartIndexByTick(i,o),l=N.getInitializedTickArrayInRange(r,s,o,c,Math.floor(Zr/2));for(let u=0;u<l.length;u++){let{publicKey:m}=H(t,n,l[u]);a.push(m)}let d=(await Xe(e,a)).map(u=>u!==null?vt.decode(u.data):null),f={};for(let u=0;u<a.length;u++){let m=d[u];m!==null&&(f[m.startTickIndex]=G(F({},m),{address:a[u]}))}return f}static nextInitializedTick(e,t,n,i,o,r){let{initializedTick:s,tickArrayAddress:a,tickArrayStartTickIndex:c}=this.nextInitializedTickInOneArray(e,t,n,i,o,r);for(;s==null||s.liquidityGross.lten(0);){if(c=N.getNextTickArrayStartIndex(c,o,r),this.checkIsValidStartIndex(c,o))throw new Error("No enough initialized tickArray");let l=n[c];if(l===void 0)continue;let{nextTick:d,tickArrayAddress:f,tickArrayStartTickIndex:u}=this.firstInitializedTickInOneArray(e,t,l,r);[s,a,c]=[d,f,u]}if(s==null)throw new Error("No invaild tickArray cache");return{nextTick:s,tickArrayAddress:a,tickArrayStartTickIndex:c}}static nextInitializedTickArray(e,t,n,i,o){let r=Math.floor(e/Y.tickCount(t)),s=n?N.searchLowBitFromStart(i,o,r-1,1,t):N.searchHightBitFromStart(i,o,r+1,1,t);return s.length>0?{isExist:!0,nextStartIndex:s[0]}:{isExist:!1,nextStartIndex:0}}static firstInitializedTickInOneArray(e,t,n,i){let o;if(i){let s=be-1;for(;s>=0;){let a=n.ticks[s];if(a.liquidityGross.gtn(0)){o=a;break}s=s-1}}else{let s=0;for(;s<be;){let a=n.ticks[s];if(a.liquidityGross.gtn(0)){o=a;break}s=s+1}}let{publicKey:r}=H(e,t,n.startTickIndex);return{nextTick:o,tickArrayAddress:r,tickArrayStartTickIndex:n.startTickIndex}}static nextInitializedTickInOneArray(e,t,n,i,o,r){let s=N.getTickArrayStartIndexByTick(i,o),a=Math.floor((i-s)/o),c=n[s];if(c==null)return{initializedTick:void 0,tickArrayAddress:void 0,tickArrayStartTickIndex:s};let l;if(r)for(;a>=0;){let f=c.ticks[a];if(f.liquidityGross.gtn(0)){l=f;break}a=a-1}else for(a=a+1;a<be;){let f=c.ticks[a];if(f.liquidityGross.gtn(0)){l=f;break}a=a+1}let{publicKey:d}=H(e,t,s);return{initializedTick:l,tickArrayAddress:d,tickArrayStartTickIndex:c.startTickIndex}}static getArrayStartIndex(e,t){let n=this.tickCount(t);return Math.floor(e/n)*n}static checkIsValidStartIndex(e,t){if(N.checkIsOutOfBoundary(e)){if(e>Se)return!1;let n=N.getTickArrayStartIndexByTick(he,t);return e==n}return e%this.tickCount(t)==0}static tickCount(e){return be*e}};var vn=14,Ze=class{static maxTickInTickarrayBitmap(e){return e*be*st}static getBitmapTickBoundary(e,t){let n=this.maxTickInTickarrayBitmap(t),i=Math.floor(Math.abs(e)/n);e<0&&Math.abs(e)%n!=0&&(i+=1);let o=n*i;return e<0?{minValue:-o,maxValue:-o+n}:{minValue:o,maxValue:o+n}}static nextInitializedTickArrayStartIndex(e,t,n,i){if(!Y.checkIsValidStartIndex(t,n))throw Error("nextInitializedTickArrayStartIndex check error");let o=this.maxTickInTickarrayBitmap(n),r=i?t-Y.tickCount(n):t+Y.tickCount(n);if(r<-o||r>=o)return{isInit:!1,tickIndex:t};let s=n*be,a=r/s+512;r<0&&r%s!=0&&a--;let c=Math.abs(a);if(i){let l=e.shln(1024-c-1),d=Bi(1024,l);if(d!==null){let f=(c-d-512)*s;return{isInit:!0,tickIndex:f}}else return{isInit:!1,tickIndex:-o}}else{let l=e.shrn(c),d=Ii(1024,l);if(d!==null){let f=(c+d-512)*s;return{isInit:!0,tickIndex:f}}else return{isInit:!1,tickIndex:o-Y.tickCount(n)}}}},Wt=class{static getBitmapOffset(e,t){if(!Y.checkIsValidStartIndex(e,t))throw new Error("No enough initialized tickArray");this.checkExtensionBoundary(e,t);let n=Ze.maxTickInTickarrayBitmap(t),i=Math.floor(Math.abs(e)/n)-1;return e<0&&Math.abs(e)%n===0&&i--,i}static getBitmap(e,t,n){let i=this.getBitmapOffset(e,t);return e<0?{offset:i,tickarrayBitmap:n.negativeTickArrayBitmap[i]}:{offset:i,tickarrayBitmap:n.positiveTickArrayBitmap[i]}}static checkExtensionBoundary(e,t){let{positiveTickBoundary:n,negativeTickBoundary:i}=this.extensionTickBoundary(t);if(e>=i&&e<n)throw Error("checkExtensionBoundary -> InvalidTickArrayBoundary")}static extensionTickBoundary(e){let t=Ze.maxTickInTickarrayBitmap(e),n=-t;if(Se<=t)throw Error(`extensionTickBoundary check error: ${Se}, ${t}`);if(n<=he)throw Error(`extensionTickBoundary check error: ${n}, ${he}`);return{positiveTickBoundary:t,negativeTickBoundary:n}}static checkTickArrayIsInit(e,t,n){let{tickarrayBitmap:i}=this.getBitmap(e,t,n),o=this.tickArrayOffsetInBitmap(e,t);return{isInitialized:N.mergeTickArrayBitmap(i).testn(o),startIndex:e}}static nextInitializedTickArrayFromOneBitmap(e,t,n,i){let o=Y.tickCount(t),r=n?e-o:e+o,{tickarrayBitmap:s}=this.getBitmap(r,t,i);return this.nextInitializedTickArrayInBitmap(s,r,t,n)}static nextInitializedTickArrayInBitmap(e,t,n,i){let{minValue:o,maxValue:r}=Ze.getBitmapTickBoundary(t,n),s=this.tickArrayOffsetInBitmap(t,n);if(i){let a=N.mergeTickArrayBitmap(e).shln(st-1-s),c=Et(512,a)?null:Fn(512,a);if(c!==null){let l=t-c*Y.tickCount(n);return{isInit:!0,tickIndex:l}}else return{isInit:!1,tickIndex:o}}else{let a=N.mergeTickArrayBitmap(e).shrn(s),c=Et(512,a)?null:On(512,a);if(c!==null){let l=t+c*Y.tickCount(n);return{isInit:!0,tickIndex:l}}else return{isInit:!1,tickIndex:r-Y.tickCount(n)}}}static tickArrayOffsetInBitmap(e,t){let n=Math.abs(e)%Ze.maxTickInTickarrayBitmap(t),i=Math.floor(n/Y.tickCount(t));return e<0&&n!=0&&(i=st-i),i}};var le=class{static getOutputAmountAndRemainAccounts(e,t,n,i,o,r=!1){let s=n.toBase58()===e.mintA.address,a=[],{isExist:c,startIndex:l,nextAccountMeta:d}=this.getFirstInitializedTickArray(e,s);if(!c||l===void 0||!d)throw new Error("Invalid tick array");a.push(d);let{allTrade:f,amountCalculated:u,accounts:m,sqrtPriceX64:p,feeAmount:y}=at.swapCompute(e.programId,e.id,t,e.tickArrayBitmap,e.exBitmapInfo,s,e.ammConfig.tradeFeeRate,e.liquidity,e.tickCurrent,e.tickSpacing,e.sqrtPriceX64,i,l,o,r);return a.push(...m),{allTrade:f,expectedAmountOut:u.mul(je),remainingAccounts:a,executionPrice:p,feeAmount:y}}static getInputAmountAndRemainAccounts(e,t,n,i,o){let r=n.toBase58()===e.mintB.address,s=[],{isExist:a,startIndex:c,nextAccountMeta:l}=this.getFirstInitializedTickArray(e,r);if(!a||c===void 0||!l)throw new Error("Invalid tick array");try{let p=this.preInitializedTickArrayStartIndex(e,r);if(p.isExist){let{publicKey:y}=H(e.programId,e.id,p.nextStartIndex);s.push(y)}}catch{}s.push(l);let{amountCalculated:d,accounts:f,sqrtPriceX64:u,feeAmount:m}=at.swapCompute(e.programId,e.id,t,e.tickArrayBitmap,e.exBitmapInfo,r,e.ammConfig.tradeFeeRate,e.liquidity,e.tickCurrent,e.tickSpacing,e.sqrtPriceX64,i.mul(je),c,o);return s.push(...f),{expectedAmountIn:d,remainingAccounts:s,executionPrice:u,feeAmount:m}}static getFirstInitializedTickArray(e,t){let{isInitialized:n,startIndex:i}=le.isOverflowDefaultTickarrayBitmap(e.tickSpacing,[e.tickCurrent])?Wt.checkTickArrayIsInit(Y.getArrayStartIndex(e.tickCurrent,e.tickSpacing),e.tickSpacing,e.exBitmapInfo):N.checkTickArrayIsInitialized(N.mergeTickArrayBitmap(e.tickArrayBitmap),e.tickCurrent,e.tickSpacing);if(n){let{publicKey:s}=H(e.programId,e.id,i);return{isExist:!0,startIndex:i,nextAccountMeta:s}}let{isExist:o,nextStartIndex:r}=this.nextInitializedTickArrayStartIndex(e,Y.getArrayStartIndex(e.tickCurrent,e.tickSpacing),t);if(o){let{publicKey:s}=H(e.programId,e.id,r);return{isExist:!0,startIndex:r,nextAccountMeta:s}}return{isExist:!1,nextAccountMeta:void 0,startIndex:void 0}}static preInitializedTickArrayStartIndex(e,t){let n=Math.floor(e.tickCurrent/Y.tickCount(e.tickSpacing)),i=t?N.searchHightBitFromStart(e.tickArrayBitmap,e.exBitmapInfo,n+1,1,e.tickSpacing):N.searchLowBitFromStart(e.tickArrayBitmap,e.exBitmapInfo,n-1,1,e.tickSpacing);return i.length>0?{isExist:!0,nextStartIndex:i[0]}:{isExist:!1,nextStartIndex:0}}static nextInitializedTickArrayStartIndex(e,t,n){for(t=Y.getArrayStartIndex(e.tickCurrent,e.tickSpacing);;){let{isInit:i,tickIndex:o}=Ze.nextInitializedTickArrayStartIndex(N.mergeTickArrayBitmap(e.tickArrayBitmap),t,e.tickSpacing,n);if(i)return{isExist:!0,nextStartIndex:o};t=o;let{isInit:r,tickIndex:s}=Wt.nextInitializedTickArrayFromOneBitmap(t,e.tickSpacing,n,e.exBitmapInfo);if(r)return{isExist:!0,nextStartIndex:s};if(t=s,t<he||t>Se)return{isExist:!1,nextStartIndex:0}}}static async updatePoolRewardInfos({connection:e,apiPoolInfo:t,chainTime:n,poolLiquidity:i,rewardInfos:o}){var s,a,c;let r=[];for(let l=0;l<o.length;l++){let d=o[l],f=(c=(s=t.rewardDefaultInfos[l])==null?void 0:s.mint.programId)!=null?c:(a=await e.getAccountInfo(d.tokenMint))==null?void 0:a.owner;if(f===void 0)throw Error("get new reward mint info error");let u=G(F({},d),{perSecond:_.x64ToDecimal(d.emissionsPerSecondX64),remainingRewards:void 0,tokenProgramId:new Ne(f)});if(u.tokenMint.equals(Ne.default))continue;if(n<=u.openTime.toNumber()||i.eq(z)){r.push(u);continue}let m=new oe(Math.min(u.endTime.toNumber(),n)),p=m.sub(u.lastUpdateTime),y=_.mulDivFloor(p,u.emissionsPerSecondX64,i),g=u.rewardGrowthGlobalX64.add(y),A=_.mulDivFloor(p,u.emissionsPerSecondX64,Le),T=u.rewardTotalEmissioned.add(A);r.push(G(F({},u),{rewardGrowthGlobalX64:g,rewardTotalEmissioned:T,lastUpdateTime:m}))}return r}static isOverflowDefaultTickarrayBitmap(e,t){let{maxTickBoundary:n,minTickBoundary:i}=this.tickRange(e);for(let o of t){let r=N.getTickArrayStartIndexByTick(o,e);if(r>=n||r<i)return!0}return!1}static tickRange(e){let t=Ze.maxTickInTickarrayBitmap(e),n=-t;return t>Se&&(t=Y.getArrayStartIndex(Se,e)+Y.tickCount(e)),n<he&&(n=Y.getArrayStartIndex(he,e)),{maxTickBoundary:t,minTickBoundary:n}}static get_tick_array_offset(e,t){if(!Y.checkIsValidStartIndex(e,t))throw new Error("No enough initialized tickArray");return e/Y.tickCount(t)*st}static async fetchExBitmaps({connection:e,exBitmapAddress:t,batchRequest:n}){let i=await ze(e,t.map(r=>({pubkey:r})),{batchRequest:n}),o={};for(let r of i)r.accountInfo!==null&&(o[r.pubkey.toString()]=Fi.decode(r.accountInfo.data));return o}static async fetchMultiplePoolTickArrays({connection:e,poolKeys:t,batchRequest:n}){let i={},o=[];for(let a of t){let c=N.getTickArrayStartIndexByTick(a.tickCurrent,a.tickSpacing),l=N.getInitializedTickArrayInRange(a.tickArrayBitmap,a.exBitmapInfo,a.tickSpacing,c,7);for(let d of l){let{publicKey:f}=H(a.programId,a.id,d);o.push({pubkey:f}),i[f.toString()]=a.id}}let r=await ze(e,o,{batchRequest:n}),s={};for(let a of r){if(!a.accountInfo)continue;let c=i[a.pubkey.toString()];if(!c)continue;s[c.toString()]===void 0&&(s[c.toString()]={});let l=vt.decode(a.accountInfo.data);s[c.toString()][l.startTickIndex]=G(F({},l),{address:a.pubkey})}return s}static async fetchPoolsAccountPosition({pools:e,connection:t,ownerInfo:n,batchRequest:i=!1,updateOwnerRewardAndFee:o=!0}){var s;let r=[];for(let a=0;a<e.length;a++){let c=e[a];c!==null&&(r.find(l=>l.equals(c.state.programId))||r.push(c.state.programId))}if(n){let a=n.tokenAccounts.map(f=>f.accountInfo.mint),c=[];for(let f of a)for(let u of r)c.push(Ce(u,f).publicKey);let l=await Xe(t,c,{batchRequest:i}),d={};for(let f of l){if(f===null)continue;let u=At.decode(f.data),m=u.poolId.toString(),p=e.find(h=>h.state.id.toBase58()===m);if(p===void 0)continue;let y=p.state,g=N._getTickPriceLegacy({poolInfo:y,tick:u.tickLower,baseIn:!0}),A=N._getTickPriceLegacy({poolInfo:y,tick:u.tickUpper,baseIn:!0}),{amountA:T,amountB:k}=j.getAmountsFromLiquidity(y.sqrtPriceX64,g.tickSqrtPriceX64,A.tickSqrtPriceX64,u.liquidity,!1),w=1/(1-Math.sqrt(Math.sqrt(g.price.div(A.price).toNumber())));p.positionAccount=[...(s=p.positionAccount)!=null?s:[],{poolId:u.poolId,nftMint:u.nftMint,priceLower:g.price,priceUpper:A.price,amountA:T,amountB:k,tickLower:u.tickLower,tickUpper:u.tickUpper,liquidity:u.liquidity,feeGrowthInsideLastX64A:u.feeGrowthInsideLastX64A,feeGrowthInsideLastX64B:u.feeGrowthInsideLastX64B,tokenFeesOwedA:u.tokenFeesOwedA,tokenFeesOwedB:u.tokenFeesOwedB,rewardInfos:u.rewardInfos.map(h=>G(F({},h),{pendingReward:new oe(0)})),leverage:w,tokenFeeAmountA:new oe(0),tokenFeeAmountB:new oe(0)}];let P=await N.getTickArrayAddressByTick(p.state.programId,u.poolId,u.tickLower,p.state.tickSpacing),x=await N.getTickArrayAddressByTick(p.state.programId,u.poolId,u.tickUpper,p.state.tickSpacing);d[`${p.state.programId.toString()}-${u.poolId.toString()}-${u.tickLower}`]=P,d[`${p.state.programId.toString()}-${u.poolId.toString()}-${u.tickUpper}`]=x}if(o){let f=Object.values(d),u=await Xe(t,f,{batchRequest:i}),m={};for(let p=0;p<f.length;p++){let y=u[p];if(y===null)continue;let g=f[p].toString();m[g]=vt.decode(y.data)}for(let{state:p,positionAccount:y}of e)if(!!y)for(let g of y){let A=`${p.programId.toString()}-${p.id.toString()}-${g.tickLower}`,T=`${p.programId.toString()}-${p.id.toString()}-${g.tickUpper}`,k=m[d[A].toString()],w=m[d[T].toString()],P=k.ticks[N.getTickOffsetInArray(g.tickLower,p.tickSpacing)],x=w.ticks[N.getTickOffsetInArray(g.tickUpper,p.tickSpacing)],{tokenFeeAmountA:h,tokenFeeAmountB:B}=await _t.GetPositionFees(p,g,P,x),C=await _t.GetPositionRewards(p,g,P,x);g.tokenFeeAmountA=h.gte(new oe(0))?h:new oe(0),g.tokenFeeAmountB=B.gte(new oe(0))?B:new oe(0);for(let L=0;L<C.length;L++)g.rewardInfos[L].pendingReward=C[L].gte(new oe(0))?C[L]:new oe(0)}}}return e}static computeAmountOut({poolInfo:e,tickArrayCache:t,baseMint:n,epochInfo:i,amountIn:o,slippage:r,priceLimit:s=new Z(0),catchLiquidityInsufficient:a=!1}){var K;let c,l=n.toBase58()===e.mintA.address,[d,f]=l?[e.mintA.extensions.feeConfig,e.mintB.extensions.feeConfig]:[e.mintB.extensions.feeConfig,e.mintA.extensions.feeConfig];s.equals(new Z(0))?c=l?ve.add(new oe(1)):We.sub(new oe(1)):c=D.priceToSqrtPriceX64(s,e.mintA.decimals,e.mintB.decimals);let u=ce(o,d,i,!1),{allTrade:m,expectedAmountOut:p,remainingAccounts:y,executionPrice:g,feeAmount:A}=le.getOutputAmountAndRemainAccounts(e,t,n,u.amount.sub((K=u.fee)!=null?K:z),c,a),T=ce(p,f,i,!1),k=D.sqrtPriceX64ToPrice(g,e.mintA.decimals,e.mintB.decimals),w=l?k:new Z(1).div(k),P=p.mul(new oe(Math.floor((1-r)*1e10))).div(new oe(1e10)),x=ce(P,f,i,!1),h=l?e.currentPrice:new Z(1).div(e.currentPrice),B=new Z(w).sub(h).abs(),C=h,L=new et(new Z(B).mul(10**15).toFixed(0),new Z(C).mul(10**15).toFixed(0));return{allTrade:m,realAmountIn:u,amountOut:T,minAmountOut:x,expirationTime:tt(u.expirationTime,T.expirationTime),currentPrice:e.currentPrice,executionPrice:w,priceImpact:L,fee:A,remainingAccounts:y,executionPriceX64:g}}static computeAmountOutFormat({poolInfo:e,tickArrayCache:t,amountIn:n,tokenOut:i,slippage:o,epochInfo:r,catchLiquidityInsufficient:s=!1}){let a=i.address===e.mintB.address,[c,l]=a?[e.mintA,e.mintB]:[e.mintB,e.mintA],[d,f]=[new Ve(G(F({},c),{mint:c.address,isToken2022:c.programId===Ni.toBase58()})),new Ve(G(F({},l),{mint:l.address,isToken2022:l.programId===Ni.toBase58()}))],{allTrade:u,realAmountIn:m,amountOut:p,minAmountOut:y,expirationTime:g,currentPrice:A,executionPrice:T,priceImpact:k,fee:w,remainingAccounts:P,executionPriceX64:x}=le.computeAmountOut({poolInfo:e,tickArrayCache:t,baseMint:new Ne(c.address),amountIn:n,slippage:o,epochInfo:r,catchLiquidityInsufficient:s}),h=G(F({},m),{amount:new we(d,m.amount),fee:m.fee===void 0?void 0:new we(d,m.fee)}),B=G(F({},p),{amount:new we(f,p.amount),fee:p.fee===void 0?void 0:new we(f,p.fee)}),C=G(F({},y),{amount:new we(f,y.amount),fee:y.fee===void 0?void 0:new we(f,y.fee)}),L=new Oe({baseToken:d,denominator:new oe(10).pow(new oe(20+d.decimals)),quoteToken:f,numerator:A.mul(new Z(10**(20+f.decimals))).toFixed(0)}),K=new Oe({baseToken:d,denominator:new oe(10).pow(new oe(20+d.decimals)),quoteToken:f,numerator:T.mul(new Z(10**(20+f.decimals))).toFixed(0)}),M=new we(d,w);return{allTrade:u,realAmountIn:h,amountOut:B,minAmountOut:C,expirationTime:g,currentPrice:L,executionPrice:K,priceImpact:k,fee:M,remainingAccounts:P,executionPriceX64:x}}static computeAmountIn({poolInfo:e,tickArrayCache:t,baseMint:n,epochInfo:i,amountOut:o,slippage:r,priceLimit:s=new Z(0)}){var C;let a=n.toBase58()===e.mintA.address,c={[e.mintA.address]:e.mintA.extensions.feeConfig,[e.mintB.address]:e.mintB.extensions.feeConfig},l;s.equals(new Z(0))?l=a?We.sub(new oe(1)):ve.add(new oe(1)):l=D.priceToSqrtPriceX64(s,e.mintA.decimals,e.mintB.decimals);let d=ce(o,c[n.toString()],i,!0),{expectedAmountIn:f,remainingAccounts:u,executionPrice:m,feeAmount:p}=le.getInputAmountAndRemainAccounts(e,t,n,d.amount.sub((C=d.fee)!=null?C:z),l),y=a?e.mintB.address:e.mintA.address,g=ce(f,c[y],i,!1),A=D.sqrtPriceX64ToPrice(m,e.mintA.decimals,e.mintB.decimals),T=a?A:new Z(1).div(A),k=f.mul(new oe(Math.floor((1+r)*1e10))).div(new oe(1e10)),w=ce(k,c[y],i,!0),P=a?e.currentPrice:new Z(1).div(e.currentPrice),x=new Z(T).sub(P).abs(),h=P,B=new et(new Z(x).mul(10**15).toFixed(0),new Z(h).mul(10**15).toFixed(0));return{amountIn:g,maxAmountIn:w,realAmountOut:d,expirationTime:tt(g.expirationTime,d.expirationTime),currentPrice:e.currentPrice,executionPrice:T,priceImpact:B,fee:p,remainingAccounts:u}}static estimateAprsForPriceRangeMultiplier({poolInfo:e,aprType:t,positionTickLowerIndex:n,positionTickUpperIndex:i}){var m,p,y;let o=e[t],r=N.getTickPrice({poolInfo:e,tick:n,baseIn:!0}).price.toNumber(),s=N.getTickPrice({poolInfo:e,tick:i,baseIn:!0}).price.toNumber(),a=Math.max(r,o.priceMin),l=Math.min(s,o.priceMax)-a,d=s-r,f=o.priceMax-o.priceMin,u;return l<=0?u=0:d===l?u=f/l:f===l?u=l/d:u=l/f*(l/d),{feeApr:o.feeApr*u,rewardsApr:[((m=o.rewardApr[0])!=null?m:0)*u,((p=o.rewardApr[1])!=null?p:0)*u,((y=o.rewardApr[2])!=null?y:0)*u],apr:o.apr*u}}static estimateAprsForPriceRangeDelta({poolInfo:e,poolLiquidity:t,aprType:n,mintPrice:i,liquidity:o,positionTickLowerIndex:r,positionTickUpperIndex:s,chainTime:a}){let c=n==="day"?1:n==="week"?7:n==="month"?30:0,l=e[n],d=i[it(e.mintA.address).toString()],f=i[it(e.mintB.address).toString()],u=e.mintA.decimals,m=e.mintB.decimals;if(!l||!d||!f)return{feeApr:0,rewardsApr:[0,0,0],apr:0};let p=D.priceToSqrtPriceX64(new Z(e.price),e.mintA.decimals,e.mintB.decimals),y=D.getSqrtPriceX64FromTick(r),g=D.getSqrtPriceX64FromTick(s),{amountSlippageA:A,amountSlippageB:T}=j.getAmountsFromLiquidityWithSlippage(p,y,g,t,!1,!1,0),{amountSlippageA:k,amountSlippageB:w}=j.getAmountsFromLiquidityWithSlippage(p,y,g,o,!1,!1,0),P=new Z(A.toString()).div(new Z(10).pow(u)).mul(d.value).add(new Z(T.toString()).div(new Z(10).pow(m)).mul(f.value)),x=new Z(k.toString()).div(new Z(10).pow(u)).mul(d.value).add(new Z(w.toString()).div(new Z(10).pow(m)).mul(f.value)),h=new Z(1).div(P.add(x)),C=new Z(l.volumeFee).mul(365).div(c).mul(h).mul(100).toNumber(),L=3600*24*365,K=e.rewardDefaultInfos.map(M=>{var U,ye;let S=M.mint.decimals,V=i[M.mint.address];return a<((U=M.startTime)!=null?U:0)||a>((ye=M.endTime)!=null?ye:0)||!M.perSecond||!V||S===void 0?0:new Z(V.value).mul(new Z(M.perSecond).mul(L)).div(new Z(10).pow(S)).mul(h).mul(100).toNumber()});return{feeApr:C,rewardsApr:K,apr:C+K.reduce((M,S)=>M+S,0)}}static async getLiquidityAmountOutFromAmountIn({poolInfo:e,inputA:t,tickLower:n,tickUpper:i,amount:o,slippage:r,add:s,epochInfo:a,amountHasFee:c}){var g,A;let l=D.priceToSqrtPriceX64(new Z(e.price),e.mintA.decimals,e.mintB.decimals),d=D.getSqrtPriceX64FromTick(n),f=D.getSqrtPriceX64FromTick(i),u=ce(o,(g=e[t?"mintA":"mintB"].extensions)==null?void 0:g.feeConfig,a,!c),m=new oe(new Z(u.amount.sub((A=u.fee)!=null?A:z).toString()).toFixed(0)),p;if(l.lte(d))p=t?j.getLiquidityFromTokenAmountA(d,f,m,!s):new oe(0);else if(l.lte(f)){let T=j.getLiquidityFromTokenAmountA(l,f,m,!s),k=j.getLiquidityFromTokenAmountB(d,l,m);p=t?T:k}else p=t?new oe(0):j.getLiquidityFromTokenAmountB(d,f,m);let y=await le.getAmountsFromLiquidity({epochInfo:a,poolInfo:e,tickLower:n,tickUpper:i,liquidity:p,slippage:r,add:s});return{liquidity:p,amountA:t?u:y.amountA,amountB:t?y.amountB:u,amountSlippageA:t?u:y.amountSlippageA,amountSlippageB:t?y.amountSlippageB:u,expirationTime:y.expirationTime}}static async getAmountsFromLiquidity({epochInfo:e,poolInfo:t,tickLower:n,tickUpper:i,liquidity:o,slippage:r,add:s}){var y,g,A,T;let a=D.getSqrtPriceX64FromTick(n),c=D.getSqrtPriceX64FromTick(i),l=s?1+r:1-r,d=j.getAmountsFromLiquidity(D.priceToSqrtPriceX64(new Z(t.price),t.mintA.decimals,t.mintB.decimals),a,c,o,s),[f,u]=[ce(d.amountA,(y=t.mintA.extensions)==null?void 0:y.feeConfig,e,!0),ce(d.amountB,(g=t.mintB.extensions)==null?void 0:g.feeConfig,e,!0)],[m,p]=[ce(d.amountA.muln(l),(A=t.mintA.extensions)==null?void 0:A.feeConfig,e,!0),ce(d.amountB.muln(l),(T=t.mintB.extensions)==null?void 0:T.feeConfig,e,!0)];return{liquidity:o,amountA:f,amountB:u,amountSlippageA:m,amountSlippageB:p,expirationTime:tt(f.expirationTime,u.expirationTime)}}static async fetchComputeMultipleClmmInfo({connection:e,poolList:t,rpcDataMap:n={}}){let i=t.filter(a=>!n[a.id]).map(a=>new Ne(a.id));(await Xe(e,i)).forEach((a,c)=>{!a||(n[i[c].toBase58()]=cn.decode(a.data))});let r=t.map(a=>fe(new Ne(a.programId),new Ne(a.id)).publicKey),s=await le.fetchExBitmaps({connection:e,exBitmapAddress:r,batchRequest:!1});return t.reduce((a,c)=>G(F({},a),{[c.id]:G(F({},n[c.id]),{id:new Ne(c.id),version:6,programId:new Ne(c.programId),mintA:c.mintA,mintB:c.mintB,ammConfig:G(F({},c.config),{id:new Ne(c.config.id),fundOwner:""}),currentPrice:new Z(c.price),exBitmapAccount:fe(new Ne(c.programId),new Ne(c.id)).publicKey,exBitmapInfo:s[fe(new Ne(c.programId),new Ne(c.id)).publicKey.toBase58()],startTime:n[c.id].startTime.toNumber(),rewardInfos:n[c.id].rewardInfos})}),{})}static async fetchComputeClmmInfo({connection:e,poolInfo:t,rpcData:n}){return(await this.fetchComputeMultipleClmmInfo({connection:e,rpcDataMap:n?{[t.id]:n}:void 0,poolList:[t]}))[t.id]}};function nm({poolInfo:b,tickLower:e,tickUpper:t,amountA:n,amountB:i,slippage:o,add:r,epochInfo:s,amountHasFee:a}){var T,k,w,P;let[c,l,d,f]=e<t?[e,t,n,i]:[t,e,i,n],u=D.priceToSqrtPriceX64(new Z(b.price),b.mintA.decimals,b.mintB.decimals),m=D.getSqrtPriceX64FromTick(c),p=D.getSqrtPriceX64FromTick(l),[y,g]=[ce(d,(T=b.mintA.extensions)==null?void 0:T.feeConfig,s,!a),ce(f,(k=b.mintB.extensions)==null?void 0:k.feeConfig,s,!a)],A=j.getLiquidityFromTokenAmounts(u,m,p,y.amount.sub((w=y.fee)!=null?w:z),g.amount.sub((P=g.fee)!=null?P:z));return j.getAmountsOutFromLiquidity({poolInfo:b,tickLower:e,tickUpper:t,liquidity:A,slippage:o,add:r,epochInfo:s,amountAddFee:!a})}var Wn={volume:0,volumeQuote:0,volumeFee:0,apr:0,feeApr:0,priceMin:0,priceMax:0,rewardApr:[]};function Mi(b){return G(F({},b),{type:"Concentrated",programId:b.programId.toString(),id:b.id.toString(),rewardDefaultInfos:[],rewardDefaultPoolInfos:"Clmm",price:b.currentPrice.toNumber(),mintAmountA:0,mintAmountB:0,feeRate:b.ammConfig.tradeFeeRate,openTime:b.startTime.toString(),tvl:0,day:Wn,week:Wn,month:Wn,pooltype:[],farmUpcomingCount:0,farmOngoingCount:0,farmFinishedCount:0,burnPercent:0,config:G(F({},b.ammConfig),{id:b.ammConfig.id.toString(),defaultRange:0,defaultRangePoint:[]})})}var _=class{static mulDivRoundingUp(e,t,n){let i=e.mul(t),o=i.div(n);return i.mod(n).eq(z)||(o=o.add(_e)),o}static mulDivFloor(e,t,n){if(n.eq(z))throw new Error("division by 0");return e.mul(t).div(n)}static mulDivCeil(e,t,n){if(n.eq(z))throw new Error("division by 0");return e.mul(t).add(n.sub(_e)).div(n)}static x64ToDecimal(e,t){return new Ge(e.toString()).div(Ge.pow(2,64)).toDecimalPlaces(t)}static decimalToX64(e){return new q(e.mul(Ge.pow(2,64)).floor().toFixed())}static wrappingSubU128(e,t){return e.add(on).sub(t).mod(on)}};function Pe(b,e){return qn(b.mul(e),64,256)}function Yr(b,e,t){let n=b.toTwos(t).shln(e);return n.imaskn(t+1),n.fromTwos(t)}function qn(b,e,t){let n=b.toTwos(t).shrn(e);return n.imaskn(t-e+1),n.fromTwos(t-e)}var D=class{static sqrtPriceX64ToPrice(e,t,n){return _.x64ToDecimal(e).pow(2).mul(Ge.pow(10,t-n))}static priceToSqrtPriceX64(e,t,n){return _.decimalToX64(e.mul(Ge.pow(10,n-t)).sqrt())}static getNextSqrtPriceX64FromInput(e,t,n,i){if(!e.gt(z))throw new Error("sqrtPriceX64 must greater than 0");if(!t.gt(z))throw new Error("liquidity must greater than 0");return i?this.getNextSqrtPriceFromTokenAmountARoundingUp(e,t,n,!0):this.getNextSqrtPriceFromTokenAmountBRoundingDown(e,t,n,!0)}static getNextSqrtPriceX64FromOutput(e,t,n,i){if(!e.gt(z))throw new Error("sqrtPriceX64 must greater than 0");if(!t.gt(z))throw new Error("liquidity must greater than 0");return i?this.getNextSqrtPriceFromTokenAmountBRoundingDown(e,t,n,!1):this.getNextSqrtPriceFromTokenAmountARoundingUp(e,t,n,!1)}static getNextSqrtPriceFromTokenAmountARoundingUp(e,t,n,i){if(n.eq(z))return e;let o=t.shln(Ot);if(i){let r=o,s=o.add(n.mul(e));return s.gte(r)?_.mulDivCeil(r,e,s):_.mulDivRoundingUp(r,_e,r.div(e).add(n))}else{let r=n.mul(e);if(!o.gt(r))throw new Error("getNextSqrtPriceFromTokenAmountARoundingUp,liquidityLeftShift must gt amountMulSqrtPrice");let s=o.sub(r);return _.mulDivCeil(o,e,s)}}static getNextSqrtPriceFromTokenAmountBRoundingDown(e,t,n,i){let o=n.shln(Ot);if(i)return e.add(o.div(t));{let r=_.mulDivRoundingUp(o,_e,t);if(!e.gt(r))throw new Error("getNextSqrtPriceFromTokenAmountBRoundingDown sqrtPriceX64 must gt amountDivLiquidity");return e.sub(r)}}static getSqrtPriceX64FromTick(e){if(!Number.isInteger(e))throw new Error("tick must be integer");if(e<he||e>Se)throw new Error("tick must be in MIN_TICK and MAX_TICK");let t=e<0?e*-1:e,n=(t&1)!=0?new q("18445821805675395072"):new q("18446744073709551616");return(t&2)!=0&&(n=Pe(n,new q("18444899583751176192"))),(t&4)!=0&&(n=Pe(n,new q("18443055278223355904"))),(t&8)!=0&&(n=Pe(n,new q("18439367220385607680"))),(t&16)!=0&&(n=Pe(n,new q("18431993317065453568"))),(t&32)!=0&&(n=Pe(n,new q("18417254355718170624"))),(t&64)!=0&&(n=Pe(n,new q("18387811781193609216"))),(t&128)!=0&&(n=Pe(n,new q("18329067761203558400"))),(t&256)!=0&&(n=Pe(n,new q("18212142134806163456"))),(t&512)!=0&&(n=Pe(n,new q("17980523815641700352"))),(t&1024)!=0&&(n=Pe(n,new q("17526086738831433728"))),(t&2048)!=0&&(n=Pe(n,new q("16651378430235570176"))),(t&4096)!=0&&(n=Pe(n,new q("15030750278694412288"))),(t&8192)!=0&&(n=Pe(n,new q("12247334978884435968"))),(t&16384)!=0&&(n=Pe(n,new q("8131365268886854656"))),(t&32768)!=0&&(n=Pe(n,new q("3584323654725218816"))),(t&65536)!=0&&(n=Pe(n,new q("696457651848324352"))),(t&131072)!=0&&(n=Pe(n,new q("26294789957507116"))),(t&262144)!=0&&(n=Pe(n,new q("37481735321082"))),e>0&&(n=Pi.div(n)),n}static getTickFromPrice(e,t,n){return D.getTickFromSqrtPriceX64(D.priceToSqrtPriceX64(e,t,n))}static getTickFromSqrtPriceX64(e){if(e.gt(We)||e.lt(ve))throw new Error("Provided sqrtPrice is not within the supported sqrtPrice range.");let t=e.bitLength()-1,n=new q(t-64),i=Yr(n,32,128),o=new q("8000000000000000","hex"),r=0,s=new q(0),a=t>=64?e.shrn(t-63):e.shln(63-t);for(;o.gt(new q(0))&&r<Ai;){a=a.mul(a);let m=a.shrn(127);a=a.shrn(63+m.toNumber()),s=s.add(o.mul(m)),o=o.shrn(1),r+=1}let c=s.shrn(32),d=i.add(c).mul(new q(wi)),f=qn(d.sub(new q(Ti)),64,128).toNumber(),u=qn(d.add(new q(ki)),64,128).toNumber();return f==u?f:D.getSqrtPriceX64FromTick(u).lte(e)?u:f}},ct=class{static getTickWithPriceAndTickspacing(e,t,n,i){let r=D.getTickFromSqrtPriceX64(D.priceToSqrtPriceX64(e,n,i))/t;return r<0?r=Math.floor(r):r=Math.ceil(r),r*t}static roundPriceWithTickspacing(e,t,n,i){let o=ct.getTickWithPriceAndTickspacing(e,t,n,i),r=D.getSqrtPriceX64FromTick(o);return D.sqrtPriceX64ToPrice(r,n,i)}},j=class{static addDelta(e,t){return e.add(t)}static getTokenAmountAFromLiquidity(e,t,n,i){if(e.gt(t)&&([e,t]=[t,e]),!e.gt(z))throw new Error("sqrtPriceX64A must greater than 0");let o=n.ushln(Ot),r=t.sub(e);return i?_.mulDivRoundingUp(_.mulDivCeil(o,r,t),_e,e):_.mulDivFloor(o,r,t).div(e)}static getTokenAmountBFromLiquidity(e,t,n,i){if(e.gt(t)&&([e,t]=[t,e]),!e.gt(z))throw new Error("sqrtPriceX64A must greater than 0");return i?_.mulDivCeil(n,t.sub(e),Le):_.mulDivFloor(n,t.sub(e),Le)}static getLiquidityFromTokenAmountA(e,t,n,i){e.gt(t)&&([e,t]=[t,e]);let o=n.mul(e).mul(t),r=t.sub(e),s=o.div(r);return i?_.mulDivRoundingUp(s,_e,Mn):s.shrn(Ot)}static getLiquidityFromTokenAmountB(e,t,n){return e.gt(t)&&([e,t]=[t,e]),_.mulDivFloor(n,Mn,t.sub(e))}static getLiquidityFromTokenAmounts(e,t,n,i,o){if(t.gt(n)&&([t,n]=[n,t]),e.lte(t))return j.getLiquidityFromTokenAmountA(t,n,i,!1);if(e.lt(n)){let r=j.getLiquidityFromTokenAmountA(e,n,i,!1),s=j.getLiquidityFromTokenAmountB(t,e,o);return r.lt(s)?r:s}else return j.getLiquidityFromTokenAmountB(t,n,o)}static getAmountsFromLiquidity(e,t,n,i,o){if(t.gt(n)&&([t,n]=[n,t]),e.lte(t))return{amountA:j.getTokenAmountAFromLiquidity(t,n,i,o),amountB:new q(0)};if(e.lt(n)){let r=j.getTokenAmountAFromLiquidity(e,n,i,o),s=j.getTokenAmountBFromLiquidity(t,e,i,o);return{amountA:r,amountB:s}}else return{amountA:new q(0),amountB:j.getTokenAmountBFromLiquidity(t,n,i,o)}}static getAmountsFromLiquidityWithSlippage(e,t,n,i,o,r,s){let{amountA:a,amountB:c}=j.getAmountsFromLiquidity(e,t,n,i,r),l=o?1+s:1-s,d=new q(new Ge(a.toString()).mul(l).toFixed(0)),f=new q(new Ge(c.toString()).mul(l).toFixed(0));return{amountSlippageA:d,amountSlippageB:f}}static getAmountsOutFromLiquidity({poolInfo:e,tickLower:t,tickUpper:n,liquidity:i,slippage:o,add:r,epochInfo:s,amountAddFee:a}){var A,T,k,w;let c=D.priceToSqrtPriceX64(new Ge(e.price),e.mintA.decimals,e.mintB.decimals),l=D.getSqrtPriceX64FromTick(t),d=D.getSqrtPriceX64FromTick(n),f=r?1+o:1-o,u=j.getAmountsFromLiquidity(c,l,d,i,r),[m,p]=[ce(u.amountA,(A=e.mintA.extensions)==null?void 0:A.feeConfig,s,a),ce(u.amountB,(T=e.mintB.extensions)==null?void 0:T.feeConfig,s,a)],[y,g]=[ce(new q(new Ge(u.amountA.toString()).mul(f).toFixed(0)),(k=e.mintA.extensions)==null?void 0:k.feeConfig,s,a),ce(new q(new Ge(u.amountB.toString()).mul(f).toFixed(0)),(w=e.mintB.extensions)==null?void 0:w.feeConfig,s,a)];return{liquidity:i,amountA:m,amountB:p,amountSlippageA:y,amountSlippageB:g,expirationTime:tt(m.expirationTime,p.expirationTime)}}},at=class{static swapCompute(e,t,n,i,o,r,s,a,c,l,d,f,u,m,p=!1){if(f.eq(z))throw new Error("amountSpecified must not be 0");if(m||(m=r?ve.add(_e):We.sub(_e)),r){if(m.lt(ve))throw new Error("sqrtPriceX64 must greater than MIN_SQRT_PRICE_X64");if(m.gte(d))throw new Error("sqrtPriceX64 must smaller than current")}else{if(m.gt(We))throw new Error("sqrtPriceX64 must smaller than MAX_SQRT_PRICE_X64");if(m.lte(d))throw new Error("sqrtPriceX64 must greater than current")}let y=f.gt(z),g={amountSpecifiedRemaining:f,amountCalculated:z,sqrtPriceX64:d,tick:c>u?Math.min(u+Y.tickCount(l)-1,c):u,accounts:[],liquidity:a,feeAmount:new q(0)},A=u,T=n[u],k=0,w=!r&&T.startTickIndex===g.tick;for(;!g.amountSpecifiedRemaining.eq(z)&&!g.sqrtPriceX64.eq(m);){k>10;let P={};P.sqrtPriceStartX64=g.sqrtPriceX64;let x=N.nextInitTick(T,g.tick,l,r,w),h=x||null,B=null;if(!(h!=null&&h.liquidityGross.gtn(0))){let L=le.nextInitializedTickArrayStartIndex({tickCurrent:g.tick,tickSpacing:l,tickArrayBitmap:i,exBitmapInfo:o},A,r);if(!L.isExist){if(p)return{allTrade:!1,amountSpecifiedRemaining:g.amountSpecifiedRemaining,amountCalculated:g.amountCalculated,feeAmount:g.feeAmount,sqrtPriceX64:g.sqrtPriceX64,liquidity:g.liquidity,tickCurrent:g.tick,accounts:g.accounts};throw Error("swapCompute LiquidityInsufficient")}A=L.nextStartIndex;let{publicKey:K}=H(e,t,A);B=K,T=n[A];try{h=N.firstInitializedTick(T,r)}catch{throw Error("not found next tick info")}}P.tickNext=h.tick,P.initialized=h.liquidityGross.gtn(0),u!==A&&B&&(g.accounts.push(B),u=A),P.tickNext<he?P.tickNext=he:P.tickNext>Se&&(P.tickNext=Se),P.sqrtPriceNextX64=D.getSqrtPriceX64FromTick(P.tickNext);let C;if(r&&P.sqrtPriceNextX64.lt(m)||!r&&P.sqrtPriceNextX64.gt(m)?C=m:C=P.sqrtPriceNextX64,[g.sqrtPriceX64,P.amountIn,P.amountOut,P.feeAmount]=at.swapStepCompute(g.sqrtPriceX64,C,g.liquidity,g.amountSpecifiedRemaining,s,r),g.feeAmount=g.feeAmount.add(P.feeAmount),y?(g.amountSpecifiedRemaining=g.amountSpecifiedRemaining.sub(P.amountIn.add(P.feeAmount)),g.amountCalculated=g.amountCalculated.sub(P.amountOut)):(g.amountSpecifiedRemaining=g.amountSpecifiedRemaining.add(P.amountOut),g.amountCalculated=g.amountCalculated.add(P.amountIn.add(P.feeAmount))),g.sqrtPriceX64.eq(P.sqrtPriceNextX64)){if(P.initialized){let L=h.liquidityNet;r&&(L=L.mul(je)),g.liquidity=j.addDelta(g.liquidity,L)}w=P.tickNext!=g.tick&&!r&&T.startTickIndex===P.tickNext,g.tick=r?P.tickNext-1:P.tickNext}else if(g.sqrtPriceX64!=P.sqrtPriceStartX64){let L=D.getTickFromSqrtPriceX64(g.sqrtPriceX64);w=L!=g.tick&&!r&&T.startTickIndex===L,g.tick=L}++k}try{let{nextStartIndex:P,isExist:x}=Y.nextInitializedTickArray(g.tick,l,r,i,o);x&&u!==P&&(g.accounts.push(H(e,t,P).publicKey),u=P)}catch{}return{allTrade:!0,amountSpecifiedRemaining:z,amountCalculated:g.amountCalculated,feeAmount:g.feeAmount,sqrtPriceX64:g.sqrtPriceX64,liquidity:g.liquidity,tickCurrent:g.tick,accounts:g.accounts}}static swapStepCompute(e,t,n,i,o,r){let s={sqrtPriceX64Next:new q(0),amountIn:new q(0),amountOut:new q(0),feeAmount:new q(0)},a=i.gte(z);if(a){let l=_.mulDivFloor(i,sn.sub(new q(o.toString())),sn);s.amountIn=r?j.getTokenAmountAFromLiquidity(t,e,n,!0):j.getTokenAmountBFromLiquidity(e,t,n,!0),l.gte(s.amountIn)?s.sqrtPriceX64Next=t:s.sqrtPriceX64Next=D.getNextSqrtPriceX64FromInput(e,n,l,r)}else s.amountOut=r?j.getTokenAmountBFromLiquidity(t,e,n,!1):j.getTokenAmountAFromLiquidity(e,t,n,!1),i.mul(je).gte(s.amountOut)?s.sqrtPriceX64Next=t:s.sqrtPriceX64Next=D.getNextSqrtPriceX64FromOutput(e,n,i.mul(je),r);let c=t.eq(s.sqrtPriceX64Next);return r?(c&&a||(s.amountIn=j.getTokenAmountAFromLiquidity(s.sqrtPriceX64Next,e,n,!0)),c&&!a||(s.amountOut=j.getTokenAmountBFromLiquidity(s.sqrtPriceX64Next,e,n,!1))):(s.amountIn=c&&a?s.amountIn:j.getTokenAmountBFromLiquidity(e,s.sqrtPriceX64Next,n,!0),s.amountOut=c&&!a?s.amountOut:j.getTokenAmountAFromLiquidity(e,s.sqrtPriceX64Next,n,!1)),!a&&s.amountOut.gt(i.mul(je))&&(s.amountOut=i.mul(je)),a&&!s.sqrtPriceX64Next.eq(t)?s.feeAmount=i.sub(s.amountIn):s.feeAmount=_.mulDivCeil(s.amountIn,new q(o),sn.sub(new q(o))),[s.sqrtPriceX64Next,s.amountIn,s.amountOut,s.feeAmount]}};var be=60,st=512,N=class{static getTickArrayAddressByTick(e,t,n,i){let o=N.getTickArrayStartIndexByTick(n,i),{publicKey:r}=H(e,t,o);return r}static getTickOffsetInArray(e,t){if(e%t!=0)throw new Error("tickIndex % tickSpacing not equal 0");let n=N.getTickArrayStartIndexByTick(e,t),i=Math.floor((e-n)/t);if(i<0||i>=be)throw new Error("tick offset in array overflow");return i}static getTickArrayBitIndex(e,t){let n=Y.tickCount(t),i=e/n;return e<0&&e%n!=0?i=Math.ceil(i)-1:i=Math.floor(i),i}static getTickArrayStartIndexByTick(e,t){return this.getTickArrayBitIndex(e,t)*Y.tickCount(t)}static getTickArrayOffsetInBitmapByTick(e,t){let n=t*be,i=Math.floor(e/n)+512;return Math.abs(i)}static checkTickArrayIsInitialized(e,t,n){let i=n*be,o=Math.floor(t/i)+512,r=Math.abs(o);return{isInitialized:e.testn(r),startIndex:(r-512)*i}}static getNextTickArrayStartIndex(e,t,n){return n?e-t*be:e+t*be}static mergeTickArrayBitmap(e){let t=new Qr(0);for(let n=0;n<e.length;n++)t=t.add(e[n].shln(64*n));return t}static getInitializedTickArrayInRange(e,t,n,i,o){let r=Math.floor(i/(n*be));return[...N.searchLowBitFromStart(e,t,r-1,o,n),...N.searchHightBitFromStart(e,t,r,o,n)]}static getAllInitializedTickArrayStartIndex(e,t,n){return N.searchHightBitFromStart(e,t,-7680,st,n)}static getAllInitializedTickArrayInfo(e,t,n,i,o){let r=[],s=N.getAllInitializedTickArrayStartIndex(n,i,o);for(let a of s){let{publicKey:c}=H(e,t,a);r.push({tickArrayStartIndex:a,tickArrayAddress:c})}return r}static getAllInitializedTickInTickArray(e){return e.ticks.filter(t=>t.liquidityGross.gtn(0))}static searchLowBitFromStart(e,t,n,i,o){let r=[...[...t.negativeTickArrayBitmap].reverse(),e.slice(0,8),e.slice(8,16),...t.positiveTickArrayBitmap].map(c=>N.mergeTickArrayBitmap(c)),s=[];for(;n>=-7680;){let c=Math.floor((n+7680)/512),l=(n+7680)%512;if(r[c].testn(l)&&s.push(n),n--,s.length===i)break}let a=Y.tickCount(o);return s.map(c=>c*a)}static searchHightBitFromStart(e,t,n,i,o){let r=[...[...t.negativeTickArrayBitmap].reverse(),e.slice(0,8),e.slice(8,16),...t.positiveTickArrayBitmap].map(c=>N.mergeTickArrayBitmap(c)),s=[];for(;n<7680;){let c=Math.floor((n+7680)/512),l=(n+7680)%512;if(r[c].testn(l)&&s.push(n),n++,s.length===i)break}let a=Y.tickCount(o);return s.map(c=>c*a)}static checkIsOutOfBoundary(e){return e<he||e>Se}static nextInitTick(e,t,n,i,o){if(Y.getArrayStartIndex(t,n)!=e.startTickIndex)return null;let s=Math.floor((t-e.startTickIndex)/n);if(i)for(;s>=0;){if(e.ticks[s].liquidityGross.gtn(0))return e.ticks[s];s=s-1}else for(o||(s=s+1);s<be;){if(e.ticks[s].liquidityGross.gtn(0))return e.ticks[s];s=s+1}return null}static firstInitializedTick(e,t){if(t){let n=be-1;for(;n>=0;){if(e.ticks[n].liquidityGross.gtn(0))return e.ticks[n];n=n-1}}else{let n=0;for(;n<be;){if(e.ticks[n].liquidityGross.gtn(0))return e.ticks[n];n=n+1}}throw Error(`firstInitializedTick check error: ${e} - ${t}`)}static _getTickPriceLegacy({poolInfo:e,tick:t,baseIn:n}){let i=D.getSqrtPriceX64FromTick(t),o=D.sqrtPriceX64ToPrice(i,e.mintA.decimals,e.mintB.decimals);return n?{tick:t,price:o,tickSqrtPriceX64:i}:{tick:t,price:new wt(1).div(o),tickSqrtPriceX64:i}}static _getPriceAndTickLegacy({poolInfo:e,price:t,baseIn:n}){let i=n?t:new wt(1).div(t),o=ct.getTickWithPriceAndTickspacing(i,e.ammConfig.tickSpacing,e.mintA.decimals,e.mintB.decimals),r=D.getSqrtPriceX64FromTick(o),s=D.sqrtPriceX64ToPrice(r,e.mintA.decimals,e.mintB.decimals);return n?{tick:o,price:s}:{tick:o,price:new wt(1).div(s)}}static getTickPrice({poolInfo:e,tick:t,baseIn:n}){let i=D.getSqrtPriceX64FromTick(t),o=D.sqrtPriceX64ToPrice(i,e.mintA.decimals,e.mintB.decimals);return n?{tick:t,price:o,tickSqrtPriceX64:i}:{tick:t,price:new wt(1).div(o),tickSqrtPriceX64:i}}static getPriceAndTick({poolInfo:e,price:t,baseIn:n}){let i=n?t:new wt(1).div(t),o=ct.getTickWithPriceAndTickspacing(i,e.config.tickSpacing,e.mintA.decimals,e.mintB.decimals),r=D.getSqrtPriceX64FromTick(o),s=D.sqrtPriceX64ToPrice(r,e.mintA.decimals,e.mintB.decimals);return n?{tick:o,price:s}:{tick:o,price:new wt(1).div(s)}}};var Oi=$([Re(8),me("bump"),Ft("index"),te(""),gt("protocolFeeRate"),gt("tradeFeeRate"),Ft("tickSpacing"),ue(O(),8,"")]),Jr=$([gt("blockTimestamp"),yi("tickCumulative"),ue(O(),4)]),Ei=$([Re(8),Ie("initialized"),O("recentEpoch"),Ft("observationIndex"),te("poolId"),ue(Jr,100,"observations"),ue(O(),4)]),$r=$([me("rewardState"),O("openTime"),O("endTime"),O("lastUpdateTime"),X("emissionsPerSecondX64"),O("rewardTotalEmissioned"),O("rewardClaimed"),te("tokenMint"),te("tokenVault"),te("creator"),X("rewardGrowthGlobalX64")]),cn=$([Re(8),me("bump"),te("ammConfig"),te("creator"),te("mintA"),te("mintB"),te("vaultA"),te("vaultB"),te("observationId"),me("mintDecimalsA"),me("mintDecimalsB"),Ft("tickSpacing"),X("liquidity"),X("sqrtPriceX64"),re("tickCurrent"),gt(),X("feeGrowthGlobalX64A"),X("feeGrowthGlobalX64B"),O("protocolFeesTokenA"),O("protocolFeesTokenB"),X("swapInAmountTokenA"),X("swapOutAmountTokenB"),X("swapInAmountTokenB"),X("swapOutAmountTokenA"),me("status"),ue(me(),7,""),ue($r,3,"rewardInfos"),ue(O(),16,"tickArrayBitmap"),O("totalFeesTokenA"),O("totalFeesClaimedTokenA"),O("totalFeesTokenB"),O("totalFeesClaimedTokenB"),O("fundFeesTokenA"),O("fundFeesTokenB"),O("startTime"),ue(O(),15*4-3,"padding")]),eo=$([X("growthInsideLastX64"),O("rewardAmountOwed")]),At=$([Re(8),me("bump"),te("nftMint"),te("poolId"),re("tickLower"),re("tickUpper"),X("liquidity"),X("feeGrowthInsideLastX64A"),X("feeGrowthInsideLastX64B"),O("tokenFeesOwedA"),O("tokenFeesOwedB"),ue(eo,3,"rewardInfos"),ue(O(),8,"")]),Im=$([Re(8),me("bump"),te("poolId"),re("tickLowerIndex"),re("tickUpperIndex"),X("liquidity"),X("feeGrowthInsideLastX64A"),X("feeGrowthInsideLastX64B"),O("tokenFeesOwedA"),O("tokenFeesOwedB"),ue(X(),3,"rewardGrowthInside"),ue(O(),8,"")]),to=$([re("tick"),gi("liquidityNet"),X("liquidityGross"),X("feeGrowthOutsideX64A"),X("feeGrowthOutsideX64B"),ue(X(),3,"rewardGrowthsOutsideX64"),ue(gt(),13,"")]),vt=$([Re(8),te("poolId"),re("startTickIndex"),ue(to,be,"ticks"),me("initializedTickCount"),ue(me(),115,"")]),Di=$([Re(329),ue(te(),100,"whitelistMints")]),Fi=$([Re(8),te("poolId"),ue(ue(O(),8),vn,"positiveTickArrayBitmap"),ue(ue(O(),8),vn,"negativeTickArrayBitmap")]),Sm=$([O(),me("bump"),te("owner"),te("poolId"),te("positionId"),te("nftAccount"),ue(O(),8)]),Vi=$([Re(8),me("bump"),te("lockOwner"),te("poolId"),te("positionId"),te("nftAccount"),te("lockNftMint"),O("recentEpoch"),ue(O(),8)]);Ei.span;var _i=Ae("Raydium_Clmm"),Me={createPool:[233,146,209,142,207,104,64,188],initReward:[95,135,192,196,242,129,230,68],setRewardEmissions:[112,52,167,75,32,201,211,137],openPosition:[77,184,74,214,112,86,241,199],openPositionWithTokenEx:[77,255,174,82,125,29,201,46],closePosition:[123,134,81,0,49,68,98,98],increaseLiquidity:[133,29,89,223,69,238,176,10],decreaseLiquidity:[58,127,188,62,79,82,196,96],swap:[43,4,237,11,26,201,30,98],collectReward:[18,237,166,197,34,16,213,144]},vi=[188,37,179,131,82,150,84,73],Wi=[16,72,250,198,14,162,212,19],se=class{static createPoolInstruction(e,t,n,i,o,r,s,a,c,l,d,f,u,m){let p=$([X("sqrtPriceX64"),O("zero")]),y=[{pubkey:n,isSigner:!0,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!1},{pubkey:c,isSigner:!1,isWritable:!1},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:f,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!1},{pubkey:d,isSigner:!1,isWritable:!1},{pubkey:Ye.programId,isSigner:!1,isWritable:!1},{pubkey:$e,isSigner:!1,isWritable:!1},...(m==null?void 0:m.map(T=>({pubkey:T,isSigner:!1,isWritable:!1})))||[]],g=Buffer.alloc(p.span);p.encode({sqrtPriceX64:u,zero:z},g);let A=Buffer.from([...Me.createPool,...g]);return new ke({keys:y,programId:e,data:A})}static async createPoolInstructions(e){let{programId:t,owner:n,mintA:i,mintB:o,ammConfigId:r,initialPriceX64:s,extendMintAccount:a}=e,[c,l]=[new I(i.address),new I(o.address)],{publicKey:d}=Ci(t,r,c,l),{publicKey:f}=Ri(t,d),{publicKey:u}=En(t,d,c),{publicKey:m}=En(t,d,l),p=fe(t,d).publicKey,y=[this.createPoolInstruction(t,d,n,r,f,c,u,new I(i.programId||ee),l,m,new I(o.programId||ee),p,s,a)];return{signers:[],instructions:y,instructionTypes:[ne.CreateAccount,ne.ClmmCreatePool],address:{poolId:d,observationId:f,exBitmapAccount:p,mintAVault:u,mintBVault:m},lookupTableAddress:[]}}static openPositionFromLiquidityInstruction(e,t,n,i,o,r,s,a,c,l,d,f,u,m,p,y,g,A,T,k,w,P,x,h,B,C){let L=$([re("tickLowerIndex"),re("tickUpperIndex"),re("tickArrayLowerStartIndex"),re("tickArrayUpperStartIndex"),X("liquidity"),O("amountMaxA"),O("amountMaxB"),Ie("withMetadata"),me("optionBaseFlag"),Ie("baseFlag")]),K=[...C?[{pubkey:C,isSigner:!1,isWritable:!0}]:[]],M=[{pubkey:t,isSigner:!0,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!0,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:d,isSigner:!1,isWritable:!0},{pubkey:f,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:m,isSigner:!1,isWritable:!0},{pubkey:p,isSigner:!1,isWritable:!0},{pubkey:$e,isSigner:!1,isWritable:!1},{pubkey:Ye.programId,isSigner:!1,isWritable:!1},{pubkey:ee,isSigner:!1,isWritable:!1},{pubkey:qt,isSigner:!1,isWritable:!1},{pubkey:rt,isSigner:!1,isWritable:!1},{pubkey:de,isSigner:!1,isWritable:!1},{pubkey:y,isSigner:!1,isWritable:!1},{pubkey:g,isSigner:!1,isWritable:!1},...K],S=Buffer.alloc(L.span);L.encode({tickLowerIndex:A,tickUpperIndex:T,tickArrayLowerStartIndex:k,tickArrayUpperStartIndex:w,liquidity:P,amountMaxA:x,amountMaxB:h,withMetadata:B==="create",baseFlag:!1,optionBaseFlag:0},S);let V=Buffer.from([...Me.openPosition,...S]);return new ke({keys:M,programId:e,data:V})}static openPositionFromLiquidityInstruction22(e,t,n,i,o,r,s,a,c,l,d,f,u,m,p,y,g,A,T,k,w,P,x,h,B){let C=$([re("tickLowerIndex"),re("tickUpperIndex"),re("tickArrayLowerStartIndex"),re("tickArrayUpperStartIndex"),X("liquidity"),O("amountMaxA"),O("amountMaxB"),Ie("withMetadata"),me("optionBaseFlag"),Ie("baseFlag")]),L=[...B?[{pubkey:B,isSigner:!1,isWritable:!0}]:[]],K=[{pubkey:t,isSigner:!0,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!0,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:d,isSigner:!1,isWritable:!0},{pubkey:f,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:m,isSigner:!1,isWritable:!0},{pubkey:$e,isSigner:!1,isWritable:!1},{pubkey:Ye.programId,isSigner:!1,isWritable:!1},{pubkey:ee,isSigner:!1,isWritable:!1},{pubkey:qt,isSigner:!1,isWritable:!1},{pubkey:de,isSigner:!1,isWritable:!1},{pubkey:p,isSigner:!1,isWritable:!1},{pubkey:y,isSigner:!1,isWritable:!1},...L],M=Buffer.alloc(C.span);C.encode({tickLowerIndex:g,tickUpperIndex:A,tickArrayLowerStartIndex:T,tickArrayUpperStartIndex:k,liquidity:w,amountMaxA:P,amountMaxB:x,withMetadata:h==="create",baseFlag:!1,optionBaseFlag:0},M);let S=Buffer.from([...Me.openPositionWithTokenEx,...M]);return new ke({keys:K,programId:e,data:S})}static async openPositionInstructions({poolInfo:e,poolKeys:t,ownerInfo:n,tickLower:i,tickUpper:o,liquidity:r,amountMaxA:s,amountMaxB:a,withMetadata:c,getEphemeralSigners:l,nft2022:d}){let f=[],[u,m]=[new I(e.programId),new I(e.id)],p;if(l)p=new I((await l(1))[0]);else{let B=un.generate();f.push(B),p=B.publicKey}let y=N.getTickArrayStartIndexByTick(i,e.config.tickSpacing),g=N.getTickArrayStartIndexByTick(o,e.config.tickSpacing),{publicKey:A}=H(u,m,y),{publicKey:T}=H(u,m,g),{publicKey:k}=d?ie(n.wallet,p,de):ie(n.wallet,p,ee),{publicKey:w}=Dt(p),{publicKey:P}=Ce(u,p),{publicKey:x}=De(u,m,i,o),h=d?this.openPositionFromLiquidityInstruction22(u,n.feePayer,m,n.wallet,p,k,x,A,T,P,n.tokenAccountA,n.tokenAccountB,new I(t.vault.A),new I(t.vault.B),new I(e.mintA.address),new I(e.mintB.address),i,o,y,g,r,s,a,c,le.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing,[y,g])?fe(u,m).publicKey:void 0):this.openPositionFromLiquidityInstruction(u,n.feePayer,m,n.wallet,p,k,w,x,A,T,P,n.tokenAccountA,n.tokenAccountB,new I(t.vault.A),new I(t.vault.B),new I(e.mintA.address),new I(e.mintB.address),i,o,y,g,r,s,a,c,le.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing,[y,g])?fe(u,m).publicKey:void 0);return{signers:f,instructions:[h],instructionTypes:[ne.ClmmOpenPosition],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[],address:{nftMint:p,tickArrayLower:A,tickArrayUpper:T,positionNftAccount:k,metadataAccount:w,personalPosition:P,protocolPosition:x}}}static async openPositionFromBaseInstructions({poolInfo:e,poolKeys:t,ownerInfo:n,tickLower:i,tickUpper:o,base:r,baseAmount:s,otherAmountMax:a,withMetadata:c,getEphemeralSigners:l,nft2022:d}){let f=[],[u,m]=[new I(e.programId),new I(e.id)],p;if(l)p=new I((await l(1))[0]);else{let B=un.generate();f.push(B),p=B.publicKey}let y=N.getTickArrayStartIndexByTick(i,e.config.tickSpacing),g=N.getTickArrayStartIndexByTick(o,e.config.tickSpacing),{publicKey:A}=H(u,m,y),{publicKey:T}=H(u,m,g),{publicKey:k}=d?ie(n.wallet,p,de):ie(n.wallet,p,ee),{publicKey:w}=Dt(p),{publicKey:P}=Ce(u,p),{publicKey:x}=De(u,m,i,o),h=d?this.openPositionFromBaseInstruction22(u,n.feePayer,m,n.wallet,p,k,x,A,T,P,n.tokenAccountA,n.tokenAccountB,new I(t.vault.A),new I(t.vault.B),new I(e.mintA.address),new I(e.mintB.address),i,o,y,g,c,r,s,a,le.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing,[y,g])?fe(u,m).publicKey:void 0):this.openPositionFromBaseInstruction(u,n.feePayer,m,n.wallet,p,k,w,x,A,T,P,n.tokenAccountA,n.tokenAccountB,new I(t.vault.A),new I(t.vault.B),new I(e.mintA.address),new I(e.mintB.address),i,o,y,g,c,r,s,a,le.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing,[y,g])?fe(u,m).publicKey:void 0);return{address:{nftMint:p,tickArrayLower:A,tickArrayUpper:T,positionNftAccount:k,metadataAccount:w,personalPosition:P,protocolPosition:x},instructions:[h],signers:f,instructionTypes:[ne.ClmmOpenPosition],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[]}}static openPositionFromBaseInstruction(e,t,n,i,o,r,s,a,c,l,d,f,u,m,p,y,g,A,T,k,w,P,x,h,B,C){let L=$([re("tickLowerIndex"),re("tickUpperIndex"),re("tickArrayLowerStartIndex"),re("tickArrayUpperStartIndex"),X("liquidity"),O("amountMaxA"),O("amountMaxB"),Ie("withMetadata"),me("optionBaseFlag"),Ie("baseFlag")]),K=[...C?[{pubkey:C,isSigner:!1,isWritable:!0}]:[]],M=[{pubkey:t,isSigner:!0,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!0,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:d,isSigner:!1,isWritable:!0},{pubkey:f,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:m,isSigner:!1,isWritable:!0},{pubkey:p,isSigner:!1,isWritable:!0},{pubkey:$e,isSigner:!1,isWritable:!1},{pubkey:Ye.programId,isSigner:!1,isWritable:!1},{pubkey:ee,isSigner:!1,isWritable:!1},{pubkey:qt,isSigner:!1,isWritable:!1},{pubkey:rt,isSigner:!1,isWritable:!1},{pubkey:de,isSigner:!1,isWritable:!1},{pubkey:y,isSigner:!1,isWritable:!1},{pubkey:g,isSigner:!1,isWritable:!1},...K],S=Buffer.alloc(L.span);L.encode({tickLowerIndex:A,tickUpperIndex:T,tickArrayLowerStartIndex:k,tickArrayUpperStartIndex:w,liquidity:new Gn(0),amountMaxA:x==="MintA"?h:B,amountMaxB:x==="MintA"?B:h,withMetadata:P==="create",baseFlag:x==="MintA",optionBaseFlag:1},S);let V=Buffer.from([...Me.openPosition,...S]);return new ke({keys:M,programId:e,data:V})}static openPositionFromBaseInstruction22(e,t,n,i,o,r,s,a,c,l,d,f,u,m,p,y,g,A,T,k,w,P,x,h,B){let C=$([re("tickLowerIndex"),re("tickUpperIndex"),re("tickArrayLowerStartIndex"),re("tickArrayUpperStartIndex"),X("liquidity"),O("amountMaxA"),O("amountMaxB"),Ie("withMetadata"),me("optionBaseFlag"),Ie("baseFlag")]),L=[...B?[{pubkey:B,isSigner:!1,isWritable:!0}]:[]],K=[{pubkey:t,isSigner:!0,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!0,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:d,isSigner:!1,isWritable:!0},{pubkey:f,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:m,isSigner:!1,isWritable:!0},{pubkey:$e,isSigner:!1,isWritable:!1},{pubkey:Ye.programId,isSigner:!1,isWritable:!1},{pubkey:ee,isSigner:!1,isWritable:!1},{pubkey:qt,isSigner:!1,isWritable:!1},{pubkey:de,isSigner:!1,isWritable:!1},{pubkey:p,isSigner:!1,isWritable:!1},{pubkey:y,isSigner:!1,isWritable:!1},...L],M=Buffer.alloc(C.span);C.encode({tickLowerIndex:g,tickUpperIndex:A,tickArrayLowerStartIndex:T,tickArrayUpperStartIndex:k,liquidity:new Gn(0),amountMaxA:P==="MintA"?x:h,amountMaxB:P==="MintA"?h:x,withMetadata:w==="create",baseFlag:P==="MintA",optionBaseFlag:1},M);let S=Buffer.from([...Me.openPositionWithTokenEx,...M]);return new ke({keys:K,programId:e,data:S})}static async openPositionFromLiquidityInstructions({poolInfo:e,poolKeys:t,ownerInfo:n,tickLower:i,tickUpper:o,liquidity:r,amountMaxA:s,amountMaxB:a,withMetadata:c,getEphemeralSigners:l,nft2022:d}){let f,u=[];if(l)f=new I((await l(1))[0]);else{let B=un.generate();u.push(B),f=B.publicKey}let[m,p]=[new I(e.programId),new I(e.id)],y=N.getTickArrayStartIndexByTick(i,e.config.tickSpacing),g=N.getTickArrayStartIndexByTick(o,e.config.tickSpacing),{publicKey:A}=H(m,p,y),{publicKey:T}=H(m,p,g),{publicKey:k}=d?ie(n.wallet,f,de):ie(n.wallet,f,ee),{publicKey:w}=Dt(f),{publicKey:P}=Ce(m,f),{publicKey:x}=De(m,p,i,o),h=d?this.openPositionFromLiquidityInstruction22(m,n.wallet,p,n.wallet,f,k,x,A,T,P,n.tokenAccountA,n.tokenAccountB,new I(t.vault.A),new I(t.vault.B),new I(t.mintA.address),new I(t.mintB.address),i,o,y,g,r,s,a,c,le.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing,[y,g])?fe(m,p).publicKey:void 0):this.openPositionFromLiquidityInstruction(m,n.wallet,p,n.wallet,f,k,w,x,A,T,P,n.tokenAccountA,n.tokenAccountB,new I(t.vault.A),new I(t.vault.B),new I(t.mintA.address),new I(t.mintB.address),i,o,y,g,r,s,a,c,le.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing,[y,g])?fe(m,p).publicKey:void 0);return{address:{nftMint:f,tickArrayLower:A,tickArrayUpper:T,positionNftAccount:k,metadataAccount:w,personalPosition:P,protocolPosition:x},instructions:[h],signers:u,instructionTypes:[ne.ClmmOpenPosition],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[]}}static closePositionInstruction(e,t,n,i,o,r){let s=$([]),a=[{pubkey:t,isSigner:!0,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:Ye.programId,isSigner:!1,isWritable:!1},{pubkey:r?de:ee,isSigner:!1,isWritable:!1}],c=Buffer.alloc(s.span);s.encode({},c);let l=Buffer.from([...Me.closePosition,...c]);return new ke({keys:a,programId:e,data:l})}static closePositionInstructions({poolInfo:e,poolKeys:t,ownerInfo:n,ownerPosition:i,nft2022:o}){let r=new I(e.programId),s=o?ie(n.wallet,i.nftMint,de).publicKey:ie(n.wallet,i.nftMint,ee).publicKey,{publicKey:a}=Ce(r,i.nftMint),c=[];return c.push(this.closePositionInstruction(r,n.wallet,i.nftMint,s,a,o)),{address:{positionNftAccount:s,personalPosition:a},signers:[],instructions:c,instructionTypes:[ne.ClmmClosePosition],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[]}}static increasePositionFromLiquidityInstruction(e,t,n,i,o,r,s,a,c,l,d,f,u,m,p,y,g,A){let T=$([X("liquidity"),O("amountMaxA"),O("amountMaxB"),me("optionBaseFlag"),Ie("baseFlag")]),k=[...A?[{pubkey:A,isSigner:!1,isWritable:!0}]:[]],w=[{pubkey:t,isSigner:!0,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:d,isSigner:!1,isWritable:!0},{pubkey:f,isSigner:!1,isWritable:!0},{pubkey:ee,isSigner:!1,isWritable:!1},{pubkey:de,isSigner:!1,isWritable:!1},{pubkey:u,isSigner:!1,isWritable:!1},{pubkey:m,isSigner:!1,isWritable:!1},...k],P=Buffer.alloc(T.span);T.encode({liquidity:p,amountMaxA:y,amountMaxB:g,optionBaseFlag:0,baseFlag:!1},P);let x=Buffer.from([...Me.increaseLiquidity,...P]);return new ke({keys:w,programId:e,data:x})}static increasePositionFromLiquidityInstructions({poolInfo:e,poolKeys:t,ownerPosition:n,ownerInfo:i,liquidity:o,amountMaxA:r,amountMaxB:s,nft2022:a}){let[c,l]=[new I(e.programId),new I(e.id)],d=N.getTickArrayStartIndexByTick(n.tickLower,e.config.tickSpacing),f=N.getTickArrayStartIndexByTick(n.tickUpper,e.config.tickSpacing),{publicKey:u}=H(c,l,d),{publicKey:m}=H(c,l,f),{publicKey:p}=a?ie(i.wallet,n.nftMint,de):ie(i.wallet,n.nftMint,ee),{publicKey:y}=Ce(c,n.nftMint),{publicKey:g}=De(c,l,n.tickLower,n.tickUpper),A=this.increasePositionFromLiquidityInstruction(c,i.wallet,p,y,l,g,u,m,i.tokenAccountA,i.tokenAccountB,new I(t.vault.A),new I(t.vault.B),new I(e.mintA.address),new I(e.mintB.address),o,r,s,le.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing,[d,f])?fe(c,l).publicKey:void 0);return{address:{tickArrayLower:u,tickArrayUpper:m,positionNftAccount:p,personalPosition:y,protocolPosition:g},signers:[],instructions:[A],instructionTypes:[ne.ClmmIncreasePosition],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[]}}static increasePositionFromBaseInstructions({poolInfo:e,poolKeys:t,ownerPosition:n,ownerInfo:i,base:o,baseAmount:r,otherAmountMax:s,nft2022:a}){let[c,l]=[new I(e.programId),new I(e.id)],d=N.getTickArrayStartIndexByTick(n.tickLower,e.config.tickSpacing),f=N.getTickArrayStartIndexByTick(n.tickUpper,e.config.tickSpacing),{publicKey:u}=H(c,l,d),{publicKey:m}=H(c,l,f),{publicKey:p}=a?ie(i.wallet,n.nftMint,de):ie(i.wallet,n.nftMint,ee),{publicKey:y}=Ce(c,n.nftMint),{publicKey:g}=De(c,l,n.tickLower,n.tickUpper);return{address:{tickArrayLower:u,tickArrayUpper:m,positionNftAccount:p,personalPosition:y,protocolPosition:g},instructions:[this.increasePositionFromBaseInstruction(c,i.wallet,p,y,l,g,u,m,i.tokenAccountA,i.tokenAccountB,new I(t.vault.A),new I(t.vault.B),new I(e.mintA.address),new I(e.mintB.address),o,r,s,le.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing,[d,f])?fe(c,l).publicKey:void 0)],signers:[],instructionTypes:[ne.ClmmIncreasePosition],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[]}}static increasePositionFromBaseInstruction(e,t,n,i,o,r,s,a,c,l,d,f,u,m,p,y,g,A){let T=$([X("liquidity"),O("amountMaxA"),O("amountMaxB"),me("optionBaseFlag"),Ie("baseFlag")]),k=[...A?[{pubkey:A,isSigner:!1,isWritable:!0}]:[]],w=[{pubkey:t,isSigner:!0,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:d,isSigner:!1,isWritable:!0},{pubkey:f,isSigner:!1,isWritable:!0},{pubkey:ee,isSigner:!1,isWritable:!1},{pubkey:de,isSigner:!1,isWritable:!1},{pubkey:u,isSigner:!1,isWritable:!1},{pubkey:m,isSigner:!1,isWritable:!1},...k],P=Buffer.alloc(T.span);T.encode({liquidity:new Gn(0),amountMaxA:p==="MintA"?y:g,amountMaxB:p==="MintA"?g:y,baseFlag:p==="MintA",optionBaseFlag:1},P);let x=Buffer.from([...Me.increaseLiquidity,...P]);return new ke({keys:w,programId:e,data:x})}static decreaseLiquidityInstruction(e,t,n,i,o,r,s,a,c,l,d,f,u,m,p,y,g,A,T){let k=$([X("liquidity"),O("amountMinA"),O("amountMinB")]),w=[...T?[{pubkey:T,isSigner:!1,isWritable:!0}]:[],...p.map(B=>[{pubkey:B.poolRewardVault,isSigner:!1,isWritable:!0},{pubkey:B.ownerRewardVault,isSigner:!1,isWritable:!0},{pubkey:B.rewardMint,isSigner:!1,isWritable:!1}]).flat()],P=[{pubkey:t,isSigner:!0,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:d,isSigner:!1,isWritable:!0},{pubkey:f,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:ee,isSigner:!1,isWritable:!1},{pubkey:de,isSigner:!1,isWritable:!1},{pubkey:jt,isSigner:!1,isWritable:!1},{pubkey:u,isSigner:!1,isWritable:!1},{pubkey:m,isSigner:!1,isWritable:!1},...w],x=Buffer.alloc(k.span);k.encode({liquidity:y,amountMinA:g,amountMinB:A},x);let h=Buffer.from([...Me.decreaseLiquidity,...x]);return new ke({keys:P,programId:e,data:h})}static decreaseLiquidityInstructions({poolInfo:e,poolKeys:t,ownerPosition:n,ownerInfo:i,liquidity:o,amountMinA:r,amountMinB:s,programId:a,nft2022:c}){let[l,d]=[new I(e.programId),new I(e.id)],f=N.getTickArrayStartIndexByTick(n.tickLower,e.config.tickSpacing),u=N.getTickArrayStartIndexByTick(n.tickUpper,e.config.tickSpacing),{publicKey:m}=H(l,d,f),{publicKey:p}=H(l,d,u),{publicKey:y}=c?ie(i.wallet,n.nftMint,de):ie(i.wallet,n.nftMint,a),{publicKey:g}=Ce(l,n.nftMint),{publicKey:A}=De(l,d,n.tickLower,n.tickUpper),T=[];for(let P=0;P<e.rewardDefaultInfos.length;P++)T.push({poolRewardVault:new I(t.rewardInfos[P].vault),ownerRewardVault:i.rewardAccounts[P],rewardMint:new I(e.rewardDefaultInfos[P].mint.address)});let k=[],w=this.decreaseLiquidityInstruction(l,i.wallet,y,g,d,A,m,p,i.tokenAccountA,i.tokenAccountB,new I(t.vault.A),new I(t.vault.B),new I(e.mintA.address),new I(e.mintB.address),T,o,r,s,le.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing,[f,u])?fe(l,d).publicKey:void 0);return k.push(w),{address:{tickArrayLower:m,tickArrayUpper:p,positionNftAccount:y,personalPosition:g,protocolPosition:A},signers:[],instructions:k,instructionTypes:[ne.ClmmDecreasePosition],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[]}}static swapInstruction(e,t,n,i,o,r,s,a,c,l,d,f,u,m,p,y,g){let A=$([O("amount"),O("otherAmountThreshold"),X("sqrtPriceLimitX64"),Ie("isBaseInput")]),T=[...g?[{pubkey:g,isSigner:!1,isWritable:!0}]:[],...d.map(x=>({pubkey:x,isSigner:!1,isWritable:!0}))],k=[{pubkey:t,isSigner:!0,isWritable:!1},{pubkey:i,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:f,isSigner:!1,isWritable:!0},{pubkey:ee,isSigner:!1,isWritable:!1},{pubkey:de,isSigner:!1,isWritable:!1},{pubkey:jt,isSigner:!1,isWritable:!1},{pubkey:c,isSigner:!1,isWritable:!1},{pubkey:l,isSigner:!1,isWritable:!1},...T],w=Buffer.alloc(A.span);A.encode({amount:u,otherAmountThreshold:m,sqrtPriceLimitX64:p,isBaseInput:y},w);let P=Buffer.from([...Me.swap,...w]);return new ke({keys:k,programId:e,data:P})}static makeSwapBaseInInstructions({poolInfo:e,poolKeys:t,observationId:n,ownerInfo:i,inputMint:o,amountIn:r,amountOutMin:s,sqrtPriceLimitX64:a,remainingAccounts:c}){let[l,d]=[new I(e.programId),new I(e.id)],[f,u]=[new I(t.vault.A),new I(t.vault.B)],[m,p]=[new I(e.mintA.address),new I(e.mintB.address)],y=e.mintA.address===o.toString(),g=[this.swapInstruction(l,i.wallet,d,new I(e.config.id),y?i.tokenAccountA:i.tokenAccountB,y?i.tokenAccountB:i.tokenAccountA,y?f:u,y?u:f,y?m:p,y?p:m,c,n,r,s,a,!0,fe(l,d).publicKey)];return{signers:[],instructions:g,instructionTypes:[ne.ClmmSwapBaseIn],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[],address:{}}}static makeSwapBaseOutInstructions({poolInfo:e,poolKeys:t,observationId:n,ownerInfo:i,outputMint:o,amountOut:r,amountInMax:s,sqrtPriceLimitX64:a,remainingAccounts:c}){let[l,d]=[new I(e.programId),new I(e.id)],[f,u]=[new I(t.vault.A),new I(t.vault.B)],[m,p]=[new I(e.mintA.address),new I(e.mintB.address)],y=e.mintA.address===o.toBase58(),g=[this.swapInstruction(l,i.wallet,d,new I(e.config.id),y?i.tokenAccountB:i.tokenAccountA,y?i.tokenAccountA:i.tokenAccountB,y?u:f,y?f:u,y?p:m,y?m:p,c,n,r,s,a,!1,fe(l,d).publicKey)];return{signers:[],instructions:g,instructionTypes:[ne.ClmmSwapBaseOut],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[],address:{}}}static initRewardInstruction(e,t,n,i,o,r,s,a,c,l,d,f){let u=$([O("openTime"),O("endTime"),X("emissionsPerSecondX64")]),m=[{pubkey:t,isSigner:!0,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!1},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!1},{pubkey:Ye.programId,isSigner:!1,isWritable:!1},{pubkey:$e,isSigner:!1,isWritable:!1}],p=Buffer.alloc(u.span);u.encode({openTime:ge(l),endTime:ge(d),emissionsPerSecondX64:f},p);let y=Buffer.from([...Me.initReward,...p]);return new ke({keys:m,programId:e,data:y})}static initRewardInstructions({poolInfo:e,poolKeys:t,ownerInfo:n,rewardInfo:i}){let[o,r]=[new I(e.programId),new I(e.id)],s=Ki(o,r,i.mint).publicKey,a=Vt(o).publicKey,c=[this.initRewardInstruction(o,n.wallet,r,a,new I(e.config.id),n.tokenAccount,i.programId,i.mint,s,i.openTime,i.endTime,i.emissionsPerSecondX64)];return{address:{poolRewardVault:s,operationId:a},signers:[],instructions:c,instructionTypes:[ne.ClmmInitReward],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[]}}static setRewardInstruction(e,t,n,i,o,r,s,a,c,l,d,f){let u=$([me("rewardIndex"),X("emissionsPerSecondX64"),O("openTime"),O("endTime")]),m=[{pubkey:t,isSigner:!0,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:ee,isSigner:!1,isWritable:!1},{pubkey:de,isSigner:!1,isWritable:!1},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0}],p=Buffer.alloc(u.span);u.encode({rewardIndex:c,emissionsPerSecondX64:f,openTime:ge(l),endTime:ge(d)},p);let y=Buffer.from([...Me.setRewardEmissions,...p]);return new ke({keys:m,programId:e,data:y})}static setRewardInstructions({poolInfo:e,poolKeys:t,ownerInfo:n,rewardInfo:i}){let[o,r]=[new I(e.programId),new I(e.id)],s,a,c;for(let f=0;f<e.rewardDefaultInfos.length;f++)e.rewardDefaultInfos[f].mint.address===i.mint.toString()&&(s=f,a=new I(t.rewardInfos[f].vault),c=new I(t.rewardInfos[f].mint.address));(s===void 0||a===void 0)&&_i.logWithError("reward mint check error","no reward mint",e.rewardDefaultInfos);let l=Vt(o).publicKey,d=[this.setRewardInstruction(o,n.wallet,r,l,new I(e.config.id),n.tokenAccount,a,c,s,i.openTime,i.endTime,i.emissionsPerSecondX64)];return{address:{rewardVault:a,operationId:l},signers:[],instructions:d,instructionTypes:[ne.ClmmSetReward],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[]}}static collectRewardInstruction(e,t,n,i,o,r,s){let a=$([me("rewardIndex")]),c=[{pubkey:t,isSigner:!0,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!1},{pubkey:ee,isSigner:!1,isWritable:!1},{pubkey:de,isSigner:!1,isWritable:!1},{pubkey:jt,isSigner:!1,isWritable:!1}],l=Buffer.alloc(a.span);a.encode({rewardIndex:s},l);let d=Buffer.from([...Me.collectReward,...l]);return new ke({keys:c,programId:e,data:d})}static collectRewardInstructions({poolInfo:e,poolKeys:t,ownerInfo:n,rewardMint:i}){let[o,r]=[new I(e.programId),new I(e.id)],s,a;for(let l=0;l<e.rewardDefaultInfos.length;l++)e.rewardDefaultInfos[l].mint.address===i.toString()&&(s=l,a=new I(t.rewardInfos[l].vault));(s===void 0||a===void 0)&&_i.logWithError("reward mint check error","no reward mint",e.rewardDefaultInfos);let c=[this.collectRewardInstruction(o,n.wallet,r,n.tokenAccount,a,i,s)];return{address:{rewardVault:a},signers:[],instructions:c,instructionTypes:[ne.ClmmCollectReward],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[]}}static async makeLockPositions({programId:e,authProgramId:t,poolProgramId:n,payer:i,wallet:o,nftMint:r,nft2022:s,getEphemeralSigners:a}){let c=[],l;if(a)l=new I((await a(1))[0]);else{let g=un.generate();c.push(g),l=g.publicKey}let d=s?ie(o,r,de).publicKey:ie(o,r,ee).publicKey,{publicKey:f}=Ce(n,r),u=Pt(e,l).publicKey,m=ie(o,l,ee).publicKey,p=Dt(l).publicKey,y=se.lockPositionInstructionV2({programId:e,auth:t,payer:i,positionOwner:o,lockOwner:o,positionNftAccount:d,positionId:f,lockPositionId:u,lockNftMint:l,lockNftAccount:m,metadataAccount:p,withMetadata:!0,nft2022:s,positionNftMint:r,authPositionNftAccount:ie(t,r,s?de:ee).publicKey,positionNftProgram:s?de:ee});return{address:{positionId:f,lockPositionId:u,lockNftAccount:m,lockNftMint:l,positionNftAccount:d,metadataAccount:p},instructions:[y],signers:c,instructionTypes:[ne.ClmmLockPosition],lookupTableAddress:[]}}static lockPositionInstructionV2({programId:e,auth:t,payer:n,positionOwner:i,lockOwner:o,positionNftAccount:r,positionId:s,positionNftMint:a,authPositionNftAccount:c,positionNftProgram:l,lockPositionId:d,lockNftMint:f,lockNftAccount:u,metadataAccount:m,withMetadata:p}){let y=[{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!0,isWritable:!0},{pubkey:i,isSigner:!0,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!1},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:d,isSigner:!1,isWritable:!0},{pubkey:f,isSigner:!0,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:m,isSigner:!1,isWritable:!0},{pubkey:rt,isSigner:!1,isWritable:!1},{pubkey:qt,isSigner:!1,isWritable:!1},{pubkey:$e,isSigner:!1,isWritable:!1},{pubkey:ee,isSigner:!1,isWritable:!1},{pubkey:l,isSigner:!1,isWritable:!1},{pubkey:Ye.programId,isSigner:!1,isWritable:!1}],g=$([Ie("withMetadata")]),A=Buffer.alloc(g.span);g.encode({withMetadata:p},A);let T=Buffer.from([...vi,...A]);return new ke({keys:y,programId:e,data:T})}static lockPositionInstruction({programId:e,authProgramId:t,poolProgramId:n,owner:i,positionNft:o}){let{publicKey:r}=ie(i,o,ee),{publicKey:s}=Ce(n,o),a=[{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:i,isSigner:!0,isWritable:!1},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!1},{pubkey:Dn(e,s).publicKey,isSigner:!1,isWritable:!0},{pubkey:ee,isSigner:!1,isWritable:!1},{pubkey:Ye.programId,isSigner:!1,isWritable:!1}];return new ke({keys:a,programId:e,data:Buffer.from(vi)})}static harvestLockPositionInstruction(e){let[t,n]=[new I(e.poolKeys.programId),new I(e.poolKeys.id)],i=N.getTickArrayStartIndexByTick(e.ownerPosition.tickLower,e.poolKeys.config.tickSpacing),o=N.getTickArrayStartIndexByTick(e.ownerPosition.tickUpper,e.poolKeys.config.tickSpacing),{publicKey:r}=H(t,n,i),{publicKey:s}=H(t,n,o),{publicKey:a}=ie(e.owner,e.ownerPosition.nftMint,ee),{publicKey:c}=Ce(t,e.ownerPosition.nftMint),{publicKey:l}=De(t,n,e.ownerPosition.tickLower,e.ownerPosition.tickUpper),d=[];for(let m=0;m<e.poolKeys.rewardInfos.length;m++)d.push({poolRewardVault:new I(e.poolKeys.rewardInfos[m].vault),ownerRewardVault:e.ownerRewardAccounts[m],rewardMint:new I(e.poolKeys.rewardInfos[m].mint.address)});let f=[...d.map(m=>[{pubkey:m.poolRewardVault,isSigner:!1,isWritable:!0},{pubkey:m.ownerRewardVault,isSigner:!1,isWritable:!0},{pubkey:m.rewardMint,isSigner:!1,isWritable:!1}]).flat()],u=[{pubkey:e.authProgramId,isSigner:!1,isWritable:!1},{pubkey:Dn(e.programId,c).publicKey,isSigner:!1,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:e.owner,isSigner:!0,isWritable:!1},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:new I(e.poolKeys.vault.A),isSigner:!1,isWritable:!0},{pubkey:new I(e.poolKeys.vault.B),isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:e.userVaultA,isSigner:!1,isWritable:!0},{pubkey:e.userVaultB,isSigner:!1,isWritable:!0},{pubkey:ee,isSigner:!1,isWritable:!1},{pubkey:de,isSigner:!1,isWritable:!1},{pubkey:Pn,isSigner:!1,isWritable:!1},{pubkey:new I(e.poolKeys.mintA.address),isSigner:!1,isWritable:!1},{pubkey:new I(e.poolKeys.mintB.address),isSigner:!1,isWritable:!1},...f];return new ke({keys:u,programId:e.programId,data:Buffer.from(Wi)})}static harvestLockPositionInstructionV2({programId:e,auth:t,lockPositionId:n,clmmProgram:i,lockOwner:o,lockNftMint:r,lockNftAccount:s,positionNftAccount:a,positionId:c,poolId:l,protocolPosition:d,vaultA:f,vaultB:u,tickArrayLower:m,tickArrayUpper:p,userVaultA:y,userVaultB:g,mintA:A,mintB:T,rewardAccounts:k,exTickArrayBitmap:w}){let P=[...w?[{pubkey:w,isSigner:!1,isWritable:!0}]:[],...k.map(h=>[{pubkey:h.poolRewardVault,isSigner:!1,isWritable:!0},{pubkey:h.ownerRewardVault,isSigner:!1,isWritable:!0},{pubkey:h.rewardMint,isSigner:!1,isWritable:!1}]).flat()],x=[{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!0,isWritable:!1},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:i,isSigner:!1,isWritable:!1},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:d,isSigner:!1,isWritable:!0},{pubkey:f,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:m,isSigner:!1,isWritable:!0},{pubkey:p,isSigner:!1,isWritable:!0},{pubkey:y,isSigner:!1,isWritable:!0},{pubkey:g,isSigner:!1,isWritable:!0},{pubkey:ee,isSigner:!1,isWritable:!1},{pubkey:de,isSigner:!1,isWritable:!1},{pubkey:Pn,isSigner:!1,isWritable:!1},{pubkey:A,isSigner:!1,isWritable:!1},{pubkey:T,isSigner:!1,isWritable:!1},...P];return new ke({keys:x,programId:e,data:Buffer.from(Wi)})}};var Un=class extends Mt{constructor(e){super(e)}async getClmmPoolKeys(e){return(await this.scope.api.fetchPoolKeysById({idList:[e]}))[0]}async createPool(e){var x;let{programId:t,owner:n=((x=this.scope.owner)==null?void 0:x.publicKey)||R.default,mint1:i,mint2:o,ammConfig:r,initialPrice:s,computeBudgetConfig:a,forerunCreate:c,getObserveState:l,txVersion:d,txTipConfig:f,feePayer:u}=e,m=this.createTxBuilder(u),[p,y,g]=new Ke(new R(i.address).toBuffer()).gt(new Ke(new R(o.address).toBuffer()))?[o,i,new ut(1).div(s)]:[i,o,s],A=D.priceToSqrtPriceX64(g,p.decimals,y.decimals),T=[],k=[];p.programId===nt.toBase58()&&k.push(Vn(t,new R(p.address)).publicKey),y.programId===nt.toBase58()&&k.push(Vn(t,new R(y.address)).publicKey),(await this.scope.connection.getMultipleAccountsInfo(k)).forEach((h,B)=>{h&&T.push(k[B])});let P=await se.createPoolInstructions({connection:this.scope.connection,programId:t,owner:n,mintA:p,mintB:y,ammConfigId:r.id,initialPriceX64:A,forerunCreate:!l&&c,extendMintAccount:T});return m.addInstruction(P),m.addCustomComputeBudget(a),m.addTipInstruction(f),m.versionBuild({txVersion:d,extInfo:{address:G(F({},P.address),{observationId:P.address.observationId.toBase58(),exBitmapAccount:P.address.exBitmapAccount.toBase58(),programId:t.toString(),id:P.address.poolId.toString(),mintA:p,mintB:y,openTime:"0",vault:{A:P.address.mintAVault.toString(),B:P.address.mintBVault.toString()},rewardInfos:[],config:{id:r.id.toString(),index:r.index,protocolFeeRate:r.protocolFeeRate,tradeFeeRate:r.tradeFeeRate,tickSpacing:r.tickSpacing,fundFeeRate:r.fundFeeRate,description:r.description,defaultRange:0,defaultRangePoint:[]}}),mockPoolInfo:F({type:"Concentrated",rewardDefaultPoolInfos:"Clmm",id:P.address.poolId.toString(),mintA:p,mintB:y,feeRate:r.tradeFeeRate,openTime:"0",programId:t.toString(),price:g.toNumber(),config:{id:r.id.toString(),index:r.index,protocolFeeRate:r.protocolFeeRate,tradeFeeRate:r.tradeFeeRate,tickSpacing:r.tickSpacing,fundFeeRate:r.fundFeeRate,description:r.description,defaultRange:0,defaultRangePoint:[]},burnPercent:0},xi),forerunCreate:c}})}async openPositionFromBase({poolInfo:e,poolKeys:t,ownerInfo:n,tickLower:i,tickUpper:o,base:r,baseAmount:s,otherAmountMax:a,nft2022:c,associatedOnly:l=!0,checkCreateATAOwner:d=!1,withMetadata:f="create",getEphemeralSigners:u,computeBudgetConfig:m,txTipConfig:p,txVersion:y,feePayer:g}){this.scope.availability.addConcentratedPosition===!1&&this.logAndCreateError("add position feature disabled in your region"),this.scope.checkOwner();let A=this.createTxBuilder(g),T=null,k=null,w=n.useSOLBalance&&e.mintA.address===Q.toString(),P=n.useSOLBalance&&e.mintB.address===Q.toString(),[x,h]=r==="MintA"?[s,a]:[a,s],{account:B,instructionParams:C}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:e.mintA.programId,mint:new R(e.mintA.address),owner:this.scope.ownerPubKey,createInfo:w||x.isZero()?{payer:this.scope.ownerPubKey,amount:x}:void 0,skipCloseAccount:!w,notUseTokenAccount:w,associatedOnly:w?!1:l,checkCreateATAOwner:d});B&&(T=B),A.addInstruction(C||{});let{account:L,instructionParams:K}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:e.mintB.programId,mint:new R(e.mintB.address),owner:this.scope.ownerPubKey,createInfo:P||h.isZero()?{payer:this.scope.ownerPubKey,amount:h}:void 0,skipCloseAccount:!P,notUseTokenAccount:P,associatedOnly:P?!1:l,checkCreateATAOwner:d});L&&(k=L),A.addInstruction(K||{}),(!T||!k)&&this.logAndCreateError("cannot found target token accounts","tokenAccounts",{ownerTokenAccountA:T==null?void 0:T.toBase58(),ownerTokenAccountB:k==null?void 0:k.toBase58()});let M=t||await this.getClmmPoolKeys(e.id),S=await se.openPositionFromBaseInstructions({poolInfo:e,poolKeys:M,ownerInfo:G(F({},n),{feePayer:this.scope.ownerPubKey,wallet:this.scope.ownerPubKey,tokenAccountA:T,tokenAccountB:k}),tickLower:i,tickUpper:o,base:r,baseAmount:s,otherAmountMax:a,withMetadata:f,getEphemeralSigners:u,nft2022:c});return A.addInstruction(S),A.addCustomComputeBudget(m),A.addTipInstruction(p),A.versionBuild({txVersion:y,extInfo:F({},S.address)})}async openPositionFromLiquidity({poolInfo:e,poolKeys:t,ownerInfo:n,amountMaxA:i,amountMaxB:o,tickLower:r,tickUpper:s,liquidity:a,associatedOnly:c=!0,checkCreateATAOwner:l=!1,withMetadata:d="create",txVersion:f,computeBudgetConfig:u,txTipConfig:m,getEphemeralSigners:p,nft2022:y,feePayer:g}){this.scope.availability.createConcentratedPosition===!1&&this.logAndCreateError("open position feature disabled in your region");let A=this.createTxBuilder(g),T=null,k=null,w=n.useSOLBalance&&e.mintA.address===Q.toBase58(),P=n.useSOLBalance&&e.mintB.address===Q.toBase58(),{account:x,instructionParams:h}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:e.mintA.programId,mint:new R(e.mintA.address),owner:this.scope.ownerPubKey,createInfo:w||i.isZero()?{payer:this.scope.ownerPubKey,amount:i}:void 0,skipCloseAccount:!w,notUseTokenAccount:w,associatedOnly:w?!1:c,checkCreateATAOwner:l});x&&(T=x),A.addInstruction(h||{});let{account:B,instructionParams:C}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:e.mintB.programId,mint:new R(e.mintB.address),owner:this.scope.ownerPubKey,createInfo:P||o.isZero()?{payer:this.scope.ownerPubKey,amount:o}:void 0,skipCloseAccount:!P,notUseTokenAccount:P,associatedOnly:P?!1:c,checkCreateATAOwner:l});B&&(k=B),A.addInstruction(C||{}),(T===void 0||k===void 0)&&this.logAndCreateError("cannot found target token accounts","tokenAccounts",this.scope.account.tokenAccounts);let L=t||await this.getClmmPoolKeys(e.id),K=await se.openPositionFromLiquidityInstructions({poolInfo:e,poolKeys:L,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccountA:T,tokenAccountB:k},tickLower:r,tickUpper:s,liquidity:a,amountMaxA:i,amountMaxB:o,withMetadata:d,getEphemeralSigners:p,nft2022:y});return A.addInstruction(K),A.addCustomComputeBudget(u),A.addTipInstruction(m),A.versionBuild({txVersion:f,extInfo:{address:K.address}})}async increasePositionFromLiquidity(e){var C;let{poolInfo:t,poolKeys:n,ownerPosition:i,amountMaxA:o,amountMaxB:r,liquidity:s,ownerInfo:a,associatedOnly:c=!0,checkCreateATAOwner:l=!1,computeBudgetConfig:d,txTipConfig:f,txVersion:u,feePayer:m}=e,p=this.createTxBuilder(m),y,g,A=a.useSOLBalance&&t.mintA.address===Q.toString(),T=a.useSOLBalance&&t.mintB.address===Q.toString(),{account:k,instructionParams:w}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:t.mintA.programId,mint:new R(t.mintA.address),notUseTokenAccount:A,owner:this.scope.ownerPubKey,createInfo:A||o.isZero()?{payer:this.scope.ownerPubKey,amount:o}:void 0,skipCloseAccount:!A,associatedOnly:A?!1:c,checkCreateATAOwner:l});k&&(y=k),p.addInstruction(w||{});let{account:P,instructionParams:x}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:t.mintB.programId,mint:new R(t.mintB.address),owner:this.scope.ownerPubKey,createInfo:T||r.isZero()?{payer:this.scope.ownerPubKey,amount:r}:void 0,notUseTokenAccount:T,skipCloseAccount:!T,associatedOnly:T?!1:c,checkCreateATAOwner:l});P&&(g=P),p.addInstruction(x||{}),!y&&!g&&this.logAndCreateError("cannot found target token accounts","tokenAccounts",this.scope.account.tokenAccounts);let h=n!=null?n:await this.getClmmPoolKeys(t.id),B=se.increasePositionFromLiquidityInstructions({poolInfo:t,poolKeys:h,ownerPosition:i,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccountA:y,tokenAccountB:g},liquidity:s,amountMaxA:o,amountMaxB:r,nft2022:(C=await this.scope.connection.getAccountInfo(i.nftMint))==null?void 0:C.owner.equals(nt)});return p.addInstruction(B),p.addCustomComputeBudget(d),p.addTipInstruction(f),p.versionBuild({txVersion:u,extInfo:{address:B.address}})}async increasePositionFromBase(e){var B;let{poolInfo:t,ownerPosition:n,base:i,baseAmount:o,otherAmountMax:r,ownerInfo:s,associatedOnly:a=!0,checkCreateATAOwner:c=!1,computeBudgetConfig:l,txTipConfig:d,txVersion:f,feePayer:u}=e,m=this.createTxBuilder(u),p,y,g=s.useSOLBalance&&t.mintA.address===Q.toString(),A=s.useSOLBalance&&t.mintB.address===Q.toString(),{account:T,instructionParams:k}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:t.mintA.programId,mint:new R(t.mintA.address),notUseTokenAccount:g,owner:this.scope.ownerPubKey,createInfo:g||(i==="MintA"?o:r).isZero()?{payer:this.scope.ownerPubKey,amount:i==="MintA"?o:r}:void 0,skipCloseAccount:!g,associatedOnly:g?!1:a,checkCreateATAOwner:c});T&&(p=T),m.addInstruction(k||{});let{account:w,instructionParams:P}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:t.mintB.programId,mint:new R(t.mintB.address),owner:this.scope.ownerPubKey,createInfo:A||(i==="MintA"?r:o).isZero()?{payer:this.scope.ownerPubKey,amount:i==="MintA"?r:o}:void 0,notUseTokenAccount:A,skipCloseAccount:!A,associatedOnly:A?!1:a,checkCreateATAOwner:c});w&&(y=w),m.addInstruction(P||{}),!p&&!y&&this.logAndCreateError("cannot found target token accounts","tokenAccounts",this.scope.account.tokenAccounts);let x=await this.getClmmPoolKeys(t.id),h=se.increasePositionFromBaseInstructions({poolInfo:t,poolKeys:x,ownerPosition:n,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccountA:p,tokenAccountB:y},base:i,baseAmount:o,otherAmountMax:r,nft2022:(B=await this.scope.connection.getAccountInfo(n.nftMint))==null?void 0:B.owner.equals(nt)});return m.addInstruction(h),m.addCustomComputeBudget(l),m.addTipInstruction(d),m.versionBuild({txVersion:f,extInfo:{address:h.address}})}async decreaseLiquidity(e){var M;let{poolInfo:t,poolKeys:n,ownerPosition:i,ownerInfo:o,amountMinA:r,amountMinB:s,liquidity:a,associatedOnly:c=!0,checkCreateATAOwner:l=!1,computeBudgetConfig:d,txTipConfig:f,txVersion:u,feePayer:m}=e;this.scope.availability.removeConcentratedPosition===!1&&this.logAndCreateError("remove position feature disabled in your region");let p=this.createTxBuilder(m),y=o.useSOLBalance&&t.mintA.address===Q.toString(),g=o.useSOLBalance&&t.mintB.address===Q.toString(),A,T,{account:k,instructionParams:w}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:t.mintA.programId,mint:new R(t.mintA.address),notUseTokenAccount:y,owner:this.scope.ownerPubKey,createInfo:{payer:this.scope.ownerPubKey,amount:0},skipCloseAccount:!y,associatedOnly:y?!1:c,checkCreateATAOwner:l});A=k,w&&p.addInstruction(w);let{account:P,instructionParams:x}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:t.mintB.programId,mint:new R(t.mintB.address),notUseTokenAccount:g,owner:this.scope.ownerPubKey,createInfo:{payer:this.scope.ownerPubKey,amount:0},skipCloseAccount:!g,associatedOnly:g?!1:c,checkCreateATAOwner:l});T=P,x&&p.addInstruction(x);let h=[];for(let S of t.rewardDefaultInfos){let V=o.useSOLBalance&&S.mint.address===Q.toString(),U;if(S.mint.address===t.mintA.address)U=A;else if(S.mint.address===t.mintB.address)U=T;else{let{account:ye,instructionParams:xe}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:new R(S.mint.programId),mint:new R(S.mint.address),notUseTokenAccount:V,owner:this.scope.ownerPubKey,createInfo:{payer:this.scope.ownerPubKey,amount:0},skipCloseAccount:!V,associatedOnly:V?!1:c,checkCreateATAOwner:l});U=ye,xe&&p.addInstruction(xe)}h.push(U)}!A&&!T&&this.logAndCreateError("cannot found target token accounts","tokenAccounts",this.scope.account.tokenAccountRawInfos);let B=n!=null?n:await this.getClmmPoolKeys(t.id),C=(M=await this.scope.connection.getAccountInfo(i.nftMint))==null?void 0:M.owner.equals(nt),L=await se.decreaseLiquidityInstructions({poolInfo:t,poolKeys:B,ownerPosition:i,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccountA:A,tokenAccountB:T,rewardAccounts:h},liquidity:a,amountMinA:r,amountMinB:s,nft2022:C});p.addInstruction({instructions:L.instructions,instructionTypes:[ne.ClmmDecreasePosition]});let K=F({},L.address);if(o.closePosition){let S=await se.closePositionInstructions({poolInfo:t,poolKeys:B,ownerInfo:{wallet:this.scope.ownerPubKey},ownerPosition:i,nft2022:C});p.addInstruction({endInstructions:S.instructions,endInstructionTypes:S.instructionTypes}),K=F(F({},K),S.address)}return p.addCustomComputeBudget(d),p.addTipInstruction(f),p.versionBuild({txVersion:u,extInfo:{address:K}})}async lockPosition(e){var m;let{programId:t=Ct,authProgramId:n=Jt,poolProgramId:i=St,ownerPosition:o,payer:r,computeBudgetConfig:s,txTipConfig:a,txVersion:c,getEphemeralSigners:l,feePayer:d}=e,f=this.createTxBuilder(d),u=await se.makeLockPositions({programId:t,authProgramId:n,poolProgramId:i,wallet:this.scope.ownerPubKey,payer:r!=null?r:this.scope.ownerPubKey,nftMint:o.nftMint,getEphemeralSigners:l,nft2022:(m=await this.scope.connection.getAccountInfo(o.nftMint))==null?void 0:m.owner.equals(nt)});return f.addInstruction(u),f.addCustomComputeBudget(s),f.addTipInstruction(a),f.versionBuild({txVersion:c,extInfo:u.address})}async harvestLockPosition(e){let{programId:t=Ct,authProgramId:n=Jt,clmmProgram:i=St,poolKeys:o,lockData:r,ownerInfo:s={useSOLBalance:!0},associatedOnly:a=!0,checkCreateATAOwner:c=!1,computeBudgetConfig:l,txTipConfig:d,txVersion:f,feePayer:u}=e,m=o||await this.getClmmPoolKeys(r.poolId.toString()),p=this.createTxBuilder(u),y=await this.scope.connection.getAccountInfo(r.positionId);y||this.logger.logWithError("position not found",r.positionId);let g=At.decode(y.data),A=s.useSOLBalance&&m.mintA.address===Q.toString(),T=s.useSOLBalance&&m.mintB.address===Q.toString(),k,w,{account:P,instructionParams:x}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:m.mintA.programId,mint:new R(m.mintA.address),notUseTokenAccount:A,owner:this.scope.ownerPubKey,createInfo:{payer:this.scope.ownerPubKey,amount:0},skipCloseAccount:!A,associatedOnly:A?!1:a,checkCreateATAOwner:c});k=P,x&&p.addInstruction(x);let{account:h,instructionParams:B}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:m.mintB.programId,mint:new R(m.mintB.address),notUseTokenAccount:T,owner:this.scope.ownerPubKey,createInfo:{payer:this.scope.ownerPubKey,amount:0},skipCloseAccount:!T,associatedOnly:T?!1:a,checkCreateATAOwner:c});w=h,B&&p.addInstruction(B);let C={},L=[];for(let pe of m.rewardInfos){let Be=s.useSOLBalance&&pe.mint.address===Q.toString(),Qe=C[pe.mint.address];if(!Qe){let{account:Ui,instructionParams:Xn}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:new R(pe.mint.programId),mint:new R(pe.mint.address),notUseTokenAccount:Be,owner:this.scope.ownerPubKey,skipCloseAccount:!Be,createInfo:{payer:this.scope.ownerPubKey,amount:0},associatedOnly:Be?!1:a});Qe=Ui,Xn&&p.addInstruction(Xn)}C[pe.mint.address]=Qe,L.push(Qe)}let K=Pt(t,r.lockNftMint).publicKey,M=ie(this.scope.ownerPubKey,r.lockNftMint,Gt).publicKey,S=N.getTickArrayStartIndexByTick(g.tickLower,m.config.tickSpacing),V=N.getTickArrayStartIndexByTick(g.tickUpper,m.config.tickSpacing),{publicKey:U}=H(new R(m.programId),r.poolId,S),{publicKey:ye}=H(new R(m.programId),r.poolId,V),{publicKey:xe}=De(new R(m.programId),r.poolId,g.tickLower,g.tickUpper),Ue=[];for(let pe=0;pe<m.rewardInfos.length;pe++)Ue.push({poolRewardVault:new R(m.rewardInfos[pe].vault),ownerRewardVault:L[pe],rewardMint:new R(m.rewardInfos[pe].mint.address)});let lt=await se.harvestLockPositionInstructionV2({programId:t,auth:n,lockPositionId:K,clmmProgram:i,lockOwner:this.scope.ownerPubKey,lockNftMint:r.lockNftMint,lockNftAccount:M,positionNftAccount:r.nftAccount,positionId:r.positionId,poolId:r.poolId,protocolPosition:xe,vaultA:new R(m.vault.A),vaultB:new R(m.vault.B),tickArrayLower:U,tickArrayUpper:ye,userVaultA:k,userVaultB:w,mintA:new R(m.mintA.address),mintB:new R(m.mintB.address),rewardAccounts:Ue,exTickArrayBitmap:fe(i,r.poolId).publicKey});return p.addInstruction({instructions:[lt],instructionTypes:[ne.ClmmHarvestLockPosition]}),p.addCustomComputeBudget(l),p.addTipInstruction(d),p.versionBuild({txVersion:f})}async closePosition({poolInfo:e,poolKeys:t,ownerPosition:n,txVersion:i,computeBudgetConfig:o,txTipConfig:r,feePayer:s}){var d;this.scope.availability.removeConcentratedPosition===!1&&this.logAndCreateError("remove position feature disabled in your region");let a=this.createTxBuilder(s),c=t!=null?t:await this.getClmmPoolKeys(e.id),l=se.closePositionInstructions({poolInfo:e,poolKeys:c,ownerInfo:{wallet:this.scope.ownerPubKey},ownerPosition:n,nft2022:(d=await this.scope.connection.getAccountInfo(n.nftMint))==null?void 0:d.owner.equals(nt)});return a.addCustomComputeBudget(o),a.addTipInstruction(r),a.addInstruction(l).versionBuild({txVersion:i,extInfo:{address:l.address}})}async initReward({poolInfo:e,ownerInfo:t,rewardInfo:n,associatedOnly:i=!0,checkCreateATAOwner:o=!1,computeBudgetConfig:r,txVersion:s,feePayer:a}){n.endTime<=n.openTime&&this.logAndCreateError("reward time error","rewardInfo",n);let c=this.createTxBuilder(a),l=t.useSOLBalance&&n.mint.address.toString()===Q.toString(),d=n.perSecond.mul(n.endTime-n.openTime),{account:f,instructionParams:u}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:new R(n.mint.address),mint:new R(n.mint.address),notUseTokenAccount:!!l,skipCloseAccount:!l,owner:this.scope.ownerPubKey,createInfo:l?{payer:t.feePayer||this.scope.ownerPubKey,amount:new Ke(new ut(d.toFixed(0)).gte(d)?d.toFixed(0):d.add(1).toFixed(0))}:void 0,associatedOnly:l?!1:i,checkCreateATAOwner:o});u&&c.addInstruction(u),f||this.logAndCreateError("no money","ownerRewardAccount",this.scope.account.tokenAccountRawInfos);let m=await this.getClmmPoolKeys(e.id),p=se.initRewardInstructions({poolInfo:e,poolKeys:m,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccount:f},rewardInfo:{programId:new R(n.mint.programId),mint:new R(n.mint.address),openTime:n.openTime,endTime:n.endTime,emissionsPerSecondX64:_.decimalToX64(n.perSecond)}});return c.addInstruction(p),c.addCustomComputeBudget(r),c.versionBuild({txVersion:s,extInfo:{address:p.address}})}async initRewards({poolInfo:e,poolKeys:t,ownerInfo:n,rewardInfos:i,associatedOnly:o=!0,checkCreateATAOwner:r=!1,computeBudgetConfig:s,txTipConfig:a,txVersion:c,feePayer:l}){for(let u of i)u.endTime<=u.openTime&&this.logAndCreateError("reward time error","rewardInfo",u);let d=this.createTxBuilder(l),f={};for(let u of i){let m=n.useSOLBalance&&u.mint.address===Q.toString(),p=u.perSecond.mul(u.endTime-u.openTime),{account:y,instructionParams:g}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:new R(u.mint.programId),mint:new R(u.mint.address),notUseTokenAccount:!!m,skipCloseAccount:!m,owner:this.scope.ownerPubKey,createInfo:m?{payer:n.feePayer||this.scope.ownerPubKey,amount:new Ke(new ut(p.toFixed(0)).gte(p)?p.toFixed(0):p.add(1).toFixed(0))}:void 0,associatedOnly:m?!1:o,checkCreateATAOwner:r});g&&d.addInstruction(g),y||this.logAndCreateError("no money","ownerRewardAccount",this.scope.account.tokenAccountRawInfos);let A=t!=null?t:await this.getClmmPoolKeys(e.id),T=se.initRewardInstructions({poolInfo:e,poolKeys:A,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccount:y},rewardInfo:{programId:new R(u.mint.programId),mint:new R(u.mint.address),openTime:u.openTime,endTime:u.endTime,emissionsPerSecondX64:_.decimalToX64(u.perSecond)}});f=F(F({},f),T.address),d.addInstruction(T)}return d.addCustomComputeBudget(s),d.addTipInstruction(a),d.versionBuild({txVersion:c,extInfo:{address:f}})}async setReward({poolInfo:e,ownerInfo:t,rewardInfo:n,associatedOnly:i=!0,checkCreateATAOwner:o=!1,computeBudgetConfig:r,txTipConfig:s,txVersion:a,feePayer:c}){n.endTime<=n.openTime&&this.logAndCreateError("reward time error","rewardInfo",n);let l=this.createTxBuilder(c),d=t.useSOLBalance&&n.mint.equals(Q),{account:f,instructionParams:u}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:n.programId,mint:n.mint,notUseTokenAccount:d,owner:this.scope.ownerPubKey,createInfo:d?{payer:t.feePayer||this.scope.ownerPubKey,amount:new Ke(new ut(n.perSecond.mul(n.endTime-n.openTime).toFixed(0)).gte(n.perSecond.mul(n.endTime-n.openTime))?n.perSecond.mul(n.endTime-n.openTime).toFixed(0):n.perSecond.mul(n.endTime-n.openTime).add(1).toFixed(0))}:void 0,associatedOnly:d?!1:i,checkCreateATAOwner:o});u&&l.addInstruction(u),f||this.logAndCreateError("no money","ownerRewardAccount",this.scope.account.tokenAccountRawInfos);let m=await this.getClmmPoolKeys(e.id),p=se.setRewardInstructions({poolInfo:e,poolKeys:m,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccount:f},rewardInfo:{mint:n.mint,openTime:n.openTime,endTime:n.endTime,emissionsPerSecondX64:_.decimalToX64(n.perSecond)}});return l.addInstruction(p),l.addCustomComputeBudget(r),l.addTipInstruction(s),l.versionBuild({txVersion:a,extInfo:{address:p.address}})}async setRewards({poolInfo:e,poolKeys:t,ownerInfo:n,rewardInfos:i,associatedOnly:o=!0,checkCreateATAOwner:r=!1,computeBudgetConfig:s,txTipConfig:a,txVersion:c,feePayer:l}){let d=this.createTxBuilder(l),f={};for(let u of i){u.endTime<=u.openTime&&this.logAndCreateError("reward time error","rewardInfo",u);let m=n.useSOLBalance&&u.mint.address===Q.toString(),{account:p,instructionParams:y}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:new R(u.mint.programId),mint:new R(u.mint.address),notUseTokenAccount:m,owner:this.scope.ownerPubKey,createInfo:m?{payer:n.feePayer||this.scope.ownerPubKey,amount:new Ke(new ut(u.perSecond.mul(u.endTime-u.openTime).toFixed(0)).gte(u.perSecond.mul(u.endTime-u.openTime))?u.perSecond.mul(u.endTime-u.openTime).toFixed(0):u.perSecond.mul(u.endTime-u.openTime).add(1).toFixed(0))}:void 0,associatedOnly:m?!1:o,checkCreateATAOwner:r});y&&d.addInstruction(y),p||this.logAndCreateError("no money","ownerRewardAccount",this.scope.account.tokenAccountRawInfos);let g=t!=null?t:await this.getClmmPoolKeys(e.id),A=se.setRewardInstructions({poolInfo:e,poolKeys:g,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccount:p},rewardInfo:{mint:new R(u.mint.address),openTime:u.openTime,endTime:u.endTime,emissionsPerSecondX64:_.decimalToX64(u.perSecond)}});d.addInstruction(A),f=F(F({},f),A.address)}return d.addCustomComputeBudget(s),d.addTipInstruction(a),d.versionBuild({txVersion:c,extInfo:{address:f}})}async collectReward({poolInfo:e,ownerInfo:t,rewardMint:n,associatedOnly:i=!0,checkCreateATAOwner:o=!1,computeBudgetConfig:r,txTipConfig:s,txVersion:a,feePayer:c}){let l=e.rewardDefaultInfos.find(g=>g.mint.address===n.toString());l||this.logAndCreateError("reward mint error","not found reward mint",n);let d=this.createTxBuilder(c),f=t.useSOLBalance&&n.equals(Q),{account:u,instructionParams:m}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:new R(l.mint.programId),mint:n,notUseTokenAccount:f,owner:this.scope.ownerPubKey,skipCloseAccount:!f,createInfo:{payer:t.feePayer||this.scope.ownerPubKey,amount:0},associatedOnly:f?!1:i,checkCreateATAOwner:o});m&&d.addInstruction(m),u||this.logAndCreateError("no money","ownerRewardAccount",this.scope.account.tokenAccountRawInfos);let p=await this.getClmmPoolKeys(e.id),y=se.collectRewardInstructions({poolInfo:e,poolKeys:p,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccount:u},rewardMint:n});return d.addInstruction(y),d.addCustomComputeBudget(r),d.addTipInstruction(s),d.versionBuild({txVersion:a,extInfo:{address:y.address}})}async collectRewards({poolInfo:e,ownerInfo:t,rewardMints:n,associatedOnly:i=!0,checkCreateATAOwner:o=!1,computeBudgetConfig:r,txTipConfig:s,feePayer:a}){let c=this.createTxBuilder(a),l={};for(let d of n){let f=e.rewardDefaultInfos.find(A=>A.mint.address===d.toString());if(!f){this.logAndCreateError("reward mint error","not found reward mint",d);continue}let u=t.useSOLBalance&&d.equals(Q),{account:m,instructionParams:p}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:new R(f.mint.programId),mint:d,notUseTokenAccount:u,owner:this.scope.ownerPubKey,skipCloseAccount:!u,createInfo:{payer:t.feePayer||this.scope.ownerPubKey,amount:0},associatedOnly:u?!1:i,checkCreateATAOwner:o});m||this.logAndCreateError("no money","ownerRewardAccount",this.scope.account.tokenAccountRawInfos),p&&c.addInstruction(p);let y=await this.getClmmPoolKeys(e.id),g=se.collectRewardInstructions({poolInfo:e,poolKeys:y,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccount:m},rewardMint:d});c.addInstruction(g),l=F(F({},l),g.address)}return c.addCustomComputeBudget(r),c.addTipInstruction(s),c.build({address:l})}async swap({poolInfo:e,poolKeys:t,inputMint:n,amountIn:i,amountOutMin:o,priceLimit:r,observationId:s,ownerInfo:a,remainingAccounts:c,associatedOnly:l=!0,checkCreateATAOwner:d=!1,txVersion:f,computeBudgetConfig:u,txTipConfig:m,feePayer:p}){let y=this.createTxBuilder(p),g=n.toString()===e.mintA.address,A=a.useSOLBalance&&e.mintA.address===Q.toBase58(),T=a.useSOLBalance&&e.mintB.address===Q.toBase58(),k;!r||r.equals(new ut(0))?k=g?ve.add(new Ke(1)):We.sub(new Ke(1)):k=D.priceToSqrtPriceX64(r,e.mintA.decimals,e.mintB.decimals);let w;if(!w){let{account:h,instructionParams:B}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:e.mintA.programId,mint:new R(e.mintA.address),notUseTokenAccount:A,owner:this.scope.ownerPubKey,skipCloseAccount:!A,createInfo:A||!g?{payer:a.feePayer||this.scope.ownerPubKey,amount:g?i:0}:void 0,associatedOnly:A?!1:l,checkCreateATAOwner:d});w=h,B&&y.addInstruction(B)}let P;if(!P){let{account:h,instructionParams:B}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:e.mintB.programId,mint:new R(e.mintB.address),notUseTokenAccount:T,owner:this.scope.ownerPubKey,skipCloseAccount:!T,createInfo:T||g?{payer:a.feePayer||this.scope.ownerPubKey,amount:g?0:i}:void 0,associatedOnly:T?!1:l,checkCreateATAOwner:d});P=h,B&&y.addInstruction(B)}(!w||!P)&&this.logAndCreateError("user do not have token account",{tokenA:e.mintA.symbol||e.mintA.address,tokenB:e.mintB.symbol||e.mintB.address,ownerTokenAccountA:w,ownerTokenAccountB:P,mintAUseSOLBalance:A,mintBUseSOLBalance:T,associatedOnly:l});let x=t!=null?t:await this.getClmmPoolKeys(e.id);return y.addInstruction(se.makeSwapBaseInInstructions({poolInfo:e,poolKeys:x,observationId:s,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccountA:w,tokenAccountB:P},inputMint:new R(n),amountIn:i,amountOutMin:o,sqrtPriceLimitX64:k,remainingAccounts:c})),y.addCustomComputeBudget(u),y.addTipInstruction(m),y.versionBuild({txVersion:f})}async swapBaseOut({poolInfo:e,poolKeys:t,outputMint:n,amountOut:i,amountInMax:o,priceLimit:r,observationId:s,ownerInfo:a,remainingAccounts:c,associatedOnly:l=!0,checkCreateATAOwner:d=!1,txVersion:f,computeBudgetConfig:u,txTipConfig:m,feePayer:p}){let y=this.createTxBuilder(p),g=n.toString()===e.mintB.address,A=a.useSOLBalance&&e.mintA.address===Q.toBase58(),T=a.useSOLBalance&&e.mintB.address===Q.toBase58(),k;!r||r.equals(new ut(0))?k=n.toString()===e.mintB.address?ve.add(new Ke(1)):We.sub(new Ke(1)):k=D.priceToSqrtPriceX64(r,e.mintA.decimals,e.mintB.decimals);let w;if(!w){let{account:h,instructionParams:B}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:e.mintA.programId,mint:new R(e.mintA.address),notUseTokenAccount:A,owner:this.scope.ownerPubKey,skipCloseAccount:!A,createInfo:A||!g?{payer:a.feePayer||this.scope.ownerPubKey,amount:g?o:0}:void 0,associatedOnly:A?!1:l,checkCreateATAOwner:d});w=h,B&&y.addInstruction(B)}let P;if(!P){let{account:h,instructionParams:B}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:e.mintB.programId,mint:new R(e.mintB.address),notUseTokenAccount:T,owner:this.scope.ownerPubKey,skipCloseAccount:!T,createInfo:T||g?{payer:a.feePayer||this.scope.ownerPubKey,amount:g?0:o}:void 0,associatedOnly:T?!1:l,checkCreateATAOwner:d});P=h,B&&y.addInstruction(B)}(!w||!P)&&this.logAndCreateError("user do not have token account",{tokenA:e.mintA.symbol||e.mintA.address,tokenB:e.mintB.symbol||e.mintB.address,ownerTokenAccountA:w,ownerTokenAccountB:P,mintAUseSOLBalance:A,mintBUseSOLBalance:T,associatedOnly:l});let x=t!=null?t:await this.getClmmPoolKeys(e.id);return y.addInstruction(se.makeSwapBaseOutInstructions({poolInfo:e,poolKeys:x,observationId:s,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccountA:w,tokenAccountB:P},outputMint:new R(n),amountOut:i,amountInMax:o,sqrtPriceLimitX64:k,remainingAccounts:c})),y.addCustomComputeBudget(u),y.addTipInstruction(m),y.versionBuild({txVersion:f})}async harvestAllRewards({allPoolInfo:e,allPositions:t,lockInfo:n,ownerInfo:i,associatedOnly:o=!0,checkCreateATAOwner:r=!1,programId:s,txVersion:a,computeBudgetConfig:c,feePayer:l,lockProgram:d=Ct,lockAuth:f=Jt,clmmProgram:u=St}){var T,k;let m={};for(let w of this.scope.account.tokenAccountRawInfos)o?ie(this.scope.ownerPubKey,w.accountInfo.mint,s).publicKey.equals(w.pubkey)&&(m[w.accountInfo.mint.toString()]=w.pubkey):m[w.accountInfo.mint.toString()]=w.pubkey;let p=Object.values(t).flat().map(w=>w.nftMint),y=await ze(this.scope.connection,p.map(w=>({pubkey:w}))),g={};y.forEach(w=>{var P,x;g[w.pubkey.toBase58()]=(x=(P=w==null?void 0:w.accountInfo)==null?void 0:P.owner)!=null?x:null});let A=this.createTxBuilder(l);for(let w of Object.values(e)){if(t[w.id]===void 0||!t[w.id].find(S=>!S.liquidity.isZero()||S.rewardInfos.find(V=>!V.rewardAmountOwed.isZero())))continue;let P=w,x=i.useSOLBalance&&P.mintA.address===Q.toString(),h=i.useSOLBalance&&P.mintB.address===Q.toString(),B=m[P.mintA.address];if(!B)if(x){let{account:S,instructionParams:V}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:P.mintA.programId,mint:new R(P.mintA.address),notUseTokenAccount:x,owner:this.scope.ownerPubKey,skipCloseAccount:!x,createInfo:{payer:i.feePayer||this.scope.ownerPubKey,amount:0},associatedOnly:x?!1:o,checkCreateATAOwner:r});B=S,V&&A.addInstruction(V)}else{let S=new R(P.mintA.address);B=this.scope.account.getAssociatedTokenAccount(S,new R(P.mintA.programId)),A.addInstruction({instructions:[Gi(this.scope.ownerPubKey,B,this.scope.ownerPubKey,S,new R(P.mintA.programId))]})}let C=m[P.mintB.address];if(!C)if(h){let{account:S,instructionParams:V}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:P.mintB.programId,mint:new R(P.mintB.address),notUseTokenAccount:h,owner:this.scope.ownerPubKey,skipCloseAccount:!h,createInfo:{payer:i.feePayer||this.scope.ownerPubKey,amount:0},associatedOnly:h?!1:o,checkCreateATAOwner:r});C=S,V&&A.addInstruction(V)}else{let S=new R(P.mintB.address);C=this.scope.account.getAssociatedTokenAccount(S,new R(P.mintB.programId)),A.addInstruction({instructions:[Gi(this.scope.ownerPubKey,C,this.scope.ownerPubKey,S,new R(P.mintB.programId))]})}m[P.mintA.address]=B,m[P.mintB.address]=C;let L=[];for(let S of P.rewardDefaultInfos){let V=i.useSOLBalance&&S.mint.address===Q.toString(),U=m[S.mint.address];if(!U){let{account:ye,instructionParams:xe}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:new R(S.mint.programId),mint:new R(S.mint.address),notUseTokenAccount:V,owner:this.scope.ownerPubKey,skipCloseAccount:!V,createInfo:{payer:i.feePayer||this.scope.ownerPubKey,amount:0},associatedOnly:V?!1:o});U=ye,xe&&A.addInstruction(xe)}m[S.mint.address]=U,L.push(U)}let K=await this.getClmmPoolKeys(P.id),M=[];for(let S=0;S<K.rewardInfos.length;S++)M.push({poolRewardVault:new R(K.rewardInfos[S].vault),ownerRewardVault:L[S],rewardMint:new R(K.rewardInfos[S].mint.address)});for(let S of t[w.id]){let V=(T=n==null?void 0:n[w.id])==null?void 0:T[S.nftMint.toBase58()];if(V){let U=ie(this.scope.ownerPubKey,V.lockNftMint,Gt).publicKey,ye=N.getTickArrayStartIndexByTick(S.tickLower,K.config.tickSpacing),xe=N.getTickArrayStartIndexByTick(S.tickUpper,K.config.tickSpacing),{publicKey:Ue}=H(new R(K.programId),V.poolId,ye),{publicKey:lt}=H(new R(K.programId),V.poolId,xe),{publicKey:pe}=De(new R(K.programId),V.poolId,S.tickLower,S.tickUpper),Be=Pt(d,V.lockNftMint).publicKey,Qe=se.harvestLockPositionInstructionV2({programId:d,auth:f,lockPositionId:Be,clmmProgram:u,lockOwner:this.scope.ownerPubKey,lockNftMint:V.lockNftMint,lockNftAccount:U,positionNftAccount:V.nftAccount,positionId:V.positionId,poolId:V.poolId,protocolPosition:pe,vaultA:new R(K.vault.A),vaultB:new R(K.vault.B),tickArrayLower:Ue,tickArrayUpper:lt,userVaultA:B,userVaultB:C,mintA:new R(K.mintA.address),mintB:new R(K.mintB.address),rewardAccounts:M,exTickArrayBitmap:fe(u,V.poolId).publicKey});A.addInstruction({instructions:[Qe],instructionTypes:[ne.ClmmHarvestLockPosition],lookupTableAddress:K.lookupTableAccount?[K.lookupTableAccount]:[]})}else{let U=se.decreaseLiquidityInstructions({poolInfo:P,poolKeys:K,ownerPosition:S,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccountA:B,tokenAccountB:C,rewardAccounts:L},liquidity:new Ke(0),amountMinA:new Ke(0),amountMinB:new Ke(0),nft2022:(k=g[S.nftMint.toBase58()])==null?void 0:k.equals(nt)});A.addInstruction(U)}}}return a===0?A.sizeCheckBuildV0({computeBudgetConfig:c}):A.sizeCheckBuild({computeBudgetConfig:c})}async getWhiteListMint({programId:e}){let t=await this.scope.connection.getAccountInfo(Vt(e).publicKey);return t?Di.decode(t.data).whitelistMints.filter(i=>!i.equals(R.default)):[]}async getOwnerPositionInfo({programId:e=St}){await this.scope.account.fetchWalletTokenAccounts();let n=this.scope.account.tokenAccountRawInfos.filter(r=>r.accountInfo.amount.eq(new Ke(1))).map(r=>Ce(new R(e),r.accountInfo.mint).publicKey),i=await this.scope.connection.getMultipleAccountsInfo(n),o=[];return i.forEach(r=>{if(!r)return;let s=At.decode(r.data);o.push(s)}),o}async getOwnerLockedPositionInfo({programId:e=Ct}){await this.scope.account.fetchWalletTokenAccounts();let n=this.scope.account.tokenAccountRawInfos.filter(a=>a.accountInfo.amount.eq(new Ke(1))).map(a=>Pt(new R(e),a.accountInfo.mint).publicKey),i=await this.scope.connection.getMultipleAccountsInfo(n),o=[];i.forEach(a=>{if(!a)return;let c=Vi.decode(a.data);o.push(c)});let r=await this.scope.connection.getMultipleAccountsInfo(o.map(a=>a.positionId)),s=[];return r.forEach(a=>{if(!a)return;let c=At.decode(a.data);s.push(c)}),o.map((a,c)=>({position:s[c],lockInfo:a}))}async getRpcClmmPoolInfo({poolId:e}){return(await this.getRpcClmmPoolInfos({poolIds:[e]}))[String(e)]}async getRpcClmmPoolInfos({poolIds:e,config:t}){let n=await ze(this.scope.connection,e.map(o=>({pubkey:new R(o)})),t),i={};for(let o=0;o<e.length;o++){let r=n[o];if(r===null||!r.accountInfo)throw Error("fetch pool info error: "+String(e[o]));let s=cn.decode(r.accountInfo.data),a=D.sqrtPriceX64ToPrice(s.sqrtPriceX64,s.mintDecimalsA,s.mintDecimalsB).toNumber();i[String(e[o])]=G(F({},s),{currentPrice:a,programId:r.accountInfo.owner})}return i}async getComputeClmmPoolInfos({clmmPoolsRpcInfo:e,mintInfos:t}){let n=new Set(Object.keys(e).map(a=>e[a].ammConfig.toBase58())),i=await ze(this.scope.connection,Array.from(n).map(a=>({pubkey:new R(a)}))),o={};i.forEach(a=>{!a.accountInfo||(o[a.pubkey.toBase58()]=Oi.decode(a.accountInfo.data))});let r=await le.fetchComputeMultipleClmmInfo({connection:this.scope.connection,rpcDataMap:e,poolList:Object.keys(e).map(a=>{var d,f,u,m;let[c,l]=[e[a].mintA.toBase58(),e[a].mintB.toBase58()];return{id:a,programId:e[a].programId.toBase58(),mintA:nn({address:c,decimals:e[a].mintDecimalsA,programId:t[c].programId.toBase58()||Gt.toBase58(),extensions:{feeConfig:(d=t[c])!=null&&d.feeConfig?Cn((f=t[c])==null?void 0:f.feeConfig):void 0}}),mintB:nn({address:l,decimals:e[a].mintDecimalsB,programId:t[l].programId.toBase58()||Gt.toBase58(),extensions:{feeConfig:(u=t[l])!=null&&u.feeConfig?Cn((m=t[l])==null?void 0:m.feeConfig):void 0}}),price:e[a].currentPrice,config:G(F({},o[e[a].ammConfig.toBase58()]),{id:e[a].ammConfig.toBase58(),fundFeeRate:0,description:"",defaultRange:0,defaultRangePoint:[]})}})}),s=await le.fetchMultiplePoolTickArrays({connection:this.scope.connection,poolKeys:Object.values(r)});return{computeClmmPoolInfo:r,computePoolTickData:s}}async getPoolInfoFromRpc(e){var l;let t=await this.getRpcClmmPoolInfo({poolId:e}),n=new Set([t.mintA.toBase58(),t.mintB.toBase58()]),i=await Jn({connection:this.scope.connection,mints:Array.from(n).map(d=>new R(d))}),{computeClmmPoolInfo:o,computePoolTickData:r}=await this.scope.clmm.getComputeClmmPoolInfos({clmmPoolsRpcInfo:{[e]:t},mintInfos:i}),s=await ze(this.scope.connection,[{pubkey:t.vaultA},{pubkey:t.vaultB}]),a=Mi(o[e]);if(!s[0].accountInfo||!s[1].accountInfo)throw new Error("pool vault data not found");a.mintAmountA=Number(qi.decode(s[0].accountInfo.data).amount.toString()),a.mintAmountB=Number(qi.decode((l=s[1].accountInfo)==null?void 0:l.data).amount.toString());let c=G(F({},o[e]),{exBitmapAccount:o[e].exBitmapAccount.toBase58(),observationId:o[e].observationId.toBase58(),id:e,programId:t.programId.toBase58(),openTime:t.startTime.toString(),vault:{A:t.vaultA.toBase58(),B:t.vaultB.toBase58()},config:a.config,rewardInfos:o[e].rewardInfos.filter(d=>!d.tokenVault.equals(R.default)).map(d=>({mint:nn({address:d.tokenMint.toBase58(),programId:Gt.toBase58(),decimals:10}),vault:d.tokenVault.toBase58()}))});return{poolInfo:a,poolKeys:c,computePoolInfo:o[e],tickData:r}}};export{vr as AMM_CONFIG_SEED,Ai as BIT_PRECISION,Un as Clmm,Oi as ClmmConfigLayout,se as ClmmInstrument,vn as EXTENSION_TICKARRAY_BITMAP_SIZE,sn as FEE_RATE_DENOMINATOR,Zr as FETCH_TICKARRAY_COUNT,_r as Fee,wi as LOG_B_2_X32,Ti as LOG_B_P_ERR_MARGIN_LOWER_X64,ki as LOG_B_P_ERR_MARGIN_UPPER_X64,j as LiquidityMath,Vi as LockClPositionLayoutV2,Sm as LockPositionLayout,We as MAX_SQRT_PRICE_X64,al as MAX_SQRT_PRICE_X64_SUB_ONE,Se as MAX_TICK,ve as MIN_SQRT_PRICE_X64,sl as MIN_SQRT_PRICE_X64_ADD_ONE,he as MIN_TICK,_ as MathUtil,Mn as MaxU64,Pi as MaxUint128,je as NEGATIVE_ONE,Hr as OBSERVATION_SEED,_e as ONE,Xr as OPERATION_SEED,Ei as ObservationInfoLayout,Jr as ObservationLayout,Di as OperationLayout,Li as POOL_LOCK_ID_SEED,Gr as POOL_REWARD_VAULT_SEED,Wr as POOL_SEED,zr as POOL_TICK_ARRAY_BITMAP_SEED,qr as POOL_VAULT_SEED,Si as POSITION_SEED,cn as PoolInfoLayout,le as PoolUtils,At as PositionInfoLayout,eo as PositionRewardInfoLayout,_t as PositionUtils,Im as ProtocolPositionLayout,on as Q128,Le as Q64,$r as RewardInfo,jr as SUPPORT_MINT_SEED,D as SqrtPriceMath,at as SwapMath,st as TICK_ARRAY_BITMAP_SIZE,Ur as TICK_ARRAY_SEED,be as TICK_ARRAY_SIZE,cl as TICK_SPACINGS,Ze as TickArrayBitmap,Fi as TickArrayBitmapExtensionLayout,Wt as TickArrayBitmapExtensionUtils,vt as TickArrayLayout,to as TickLayout,ct as TickMath,Y as TickQuery,N as TickUtils,Ot as U64Resolution,ll as U64_IGNORE_RANGE,z as ZERO,Mi as clmmComputeInfoToApiInfo,nm as getLiquidityFromAmounts,gl as getPdaAmmConfigId,fe as getPdaExBitmapAccount,Pt as getPdaLockClPositionIdV2,Dn as getPdaLockPositionId,Dt as getPdaMetadataKey,Vn as getPdaMintExAccount,Ri as getPdaObservationAccount,Vt as getPdaOperationAccount,Ce as getPdaPersonalPositionAddress,Ci as getPdaPoolId,Ki as getPdaPoolRewardVaulId,En as getPdaPoolVaultId,De as getPdaProtocolPositionAddress,H as getPdaTickArrayAddress,dl as i16ToBytes,an as i32ToBytes,Et as isZero,Fn as leadingZeros,Ii as leastSignificantBit,ul as mockCreatePoolInfo,xi as mockV3CreatePoolInfo,Bi as mostSignificantBit,On as trailingZeros,hi as u16ToBytes,pl as u32ToBytes};
//# sourceMappingURL=index.mjs.map