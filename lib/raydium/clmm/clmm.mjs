var Hi=Object.defineProperty,zi=Object.defineProperties;var ji=Object.getOwnPropertyDescriptors;var Zt=Object.getOwnPropertySymbols;var jn=Object.prototype.hasOwnProperty,Yn=Object.prototype.propertyIsEnumerable;var zn=(b,e,t)=>e in b?Hi(b,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):b[e]=t,O=(b,e)=>{for(var t in e||(e={}))jn.call(e,t)&&zn(b,t,e[t]);if(Zt)for(var t of Zt(e))Yn.call(e,t)&&zn(b,t,e[t]);return b},U=(b,e)=>zi(b,ji(e));var lt=(b,e)=>{var t={};for(var n in b)jn.call(b,n)&&e.indexOf(n)<0&&(t[n]=b[n]);if(b!=null&&Zt)for(var n of Zt(b))e.indexOf(n)<0&&Yn.call(b,n)&&(t[n]=b[n]);return t};import{PublicKey as R}from"@solana/web3.js";import Ce from"bn.js";import wt from"decimal.js";import{PublicKey as Jn}from"@solana/web3.js";import{get as Zn,set as Yi}from"lodash";var pn=class{constructor(e){this.logLevel=e.logLevel!==void 0?e.logLevel:0,this.name=e.name}set level(e){this.logLevel=e}get time(){return Date.now().toString()}get moduleName(){return this.name}isLogLevel(e){return e<=this.logLevel}error(...e){return this.isLogLevel(0)?(console.error(this.time,this.name,"sdk logger error",...e),this):this}logWithError(...e){let t=e.map(n=>typeof n=="object"?JSON.stringify(n):n).join(", ");throw new Error(t)}warning(...e){return this.isLogLevel(1)?(console.warn(this.time,this.name,"sdk logger warning",...e),this):this}info(...e){return this.isLogLevel(2)?(console.info(this.time,this.name,"sdk logger info",...e),this):this}debug(...e){return this.isLogLevel(3)?(console.debug(this.time,this.name,"sdk logger debug",...e),this):this}},Qn={},Zi={};function Te(b){let e=Zn(Qn,b);if(!e){let t=Zn(Zi,b);e=new pn({name:b,logLevel:t}),Yi(Qn,b,e)}return e}import{MINT_SIZE as Qi,TOKEN_PROGRAM_ID as Ji,getTransferFeeConfig as $i,unpackMint as er}from"@solana/spl-token";var fn=Te("Raydium_accountInfo_util");async function je(b,e,t){let{batchRequest:n,commitment:i="confirmed",chunkCount:s=100}=O({batchRequest:!1},t),r=yn(e,s),o=new Array(r.length).fill([]);if(n){let a=r.map(d=>{let f=b._buildArgs([d.map(u=>u.toBase58())],i,"base64");return{methodName:"getMultipleAccounts",args:f}}),c=yn(a,10);o=(await(await Promise.all(c.map(async d=>await b._rpcBatchRequest(d)))).flat()).map(d=>(d.error&&fn.logWithError(`failed to get info for multiple accounts, RPC_ERROR, ${d.error.message}`),d.result.value.map(f=>{if(f){let{data:u,executable:m,lamports:p,owner:y,rentEpoch:g}=f;return u.length!==2&&u[1]!=="base64"&&fn.logWithError("info must be base64 encoded, RPC_ERROR"),{data:Buffer.from(u[0],"base64"),executable:m,lamports:p,owner:new Jn(y),rentEpoch:g}}return null})))}else try{o=await Promise.all(r.map(a=>b.getMultipleAccountsInfo(a,i)))}catch(a){a instanceof Error&&fn.logWithError(`failed to get info for multiple accounts, RPC_ERROR, ${a.message}`)}return o.flat()}async function Ye(b,e,t){let n=await je(b,e.map(i=>i.pubkey),t);return e.map((i,s)=>U(O({},i),{accountInfo:n[s]}))}async function $n({connection:b,mints:e,config:t}){var s,r,o;if(e.length===0)return{};let n=await Ye(b,e.map(a=>({pubkey:mt(a)})),t),i={};for(let a of n){if(!a.accountInfo||a.accountInfo.data.length<Qi){console.log("invalid mint account",a.pubkey.toBase58());continue}let c=er(a.pubkey,a.accountInfo,(s=a.accountInfo)==null?void 0:s.owner);i[a.pubkey.toString()]=U(O({},c),{programId:((r=a.accountInfo)==null?void 0:r.owner)||Ji,feeConfig:(o=$i(c))!=null?o:void 0})}return i[Jn.default.toBase58()]=i[Z.toBase58()],i}import Ze from"bn.js";import Ds from"decimal.js";import cr from"big.js";import $t from"bn.js";import tr from"toformat";var nr=tr,It=nr;import Jt from"big.js";import rr from"bn.js";import or from"decimal.js-light";import St from"bn.js";var ei=9007199254740991;function Pe(b){let e=Te("Raydium_parseBigNumberish");if(b instanceof St)return b;if(typeof b=="string"){if(b.match(/^-?[0-9]+$/))return new St(b);e.logWithError(`invalid BigNumberish string: ${b}`)}return typeof b=="number"?(b%1&&e.logWithError(`BigNumberish number underflow: ${b}`),(b>=ei||b<=-ei)&&e.logWithError(`BigNumberish number overflow: ${b}`),new St(String(b))):typeof b=="bigint"?new St(b.toString()):(e.error(`invalid BigNumberish value: ${b}`),new St(0))}var Qt=Te("module/fraction"),bn=It(Jt),Kt=It(or),sr={[0]:Kt.ROUND_DOWN,[1]:Kt.ROUND_HALF_UP,[2]:Kt.ROUND_UP},ar={[0]:Jt.roundDown,[1]:Jt.roundHalfUp,[2]:Jt.roundUp},Q=class{constructor(e,t=new rr(1)){this.numerator=Pe(e),this.denominator=Pe(t)}get quotient(){return this.numerator.div(this.denominator)}invert(){return new Q(this.denominator,this.numerator)}add(e){let t=e instanceof Q?e:new Q(Pe(e));return this.denominator.eq(t.denominator)?new Q(this.numerator.add(t.numerator),this.denominator):new Q(this.numerator.mul(t.denominator).add(t.numerator.mul(this.denominator)),this.denominator.mul(t.denominator))}sub(e){let t=e instanceof Q?e:new Q(Pe(e));return this.denominator.eq(t.denominator)?new Q(this.numerator.sub(t.numerator),this.denominator):new Q(this.numerator.mul(t.denominator).sub(t.numerator.mul(this.denominator)),this.denominator.mul(t.denominator))}mul(e){let t=e instanceof Q?e:new Q(Pe(e));return new Q(this.numerator.mul(t.numerator),this.denominator.mul(t.denominator))}div(e){let t=e instanceof Q?e:new Q(Pe(e));return new Q(this.numerator.mul(t.denominator),this.denominator.mul(t.numerator))}toSignificant(e,t={groupSeparator:""},n=1){Number.isInteger(e)||Qt.logWithError(`${e} is not an integer.`),e<=0&&Qt.logWithError(`${e} is not positive.`),Kt.set({precision:e+1,rounding:sr[n]});let i=new Kt(this.numerator.toString()).div(this.denominator.toString()).toSignificantDigits(e);return i.toFormat(i.decimalPlaces(),t)}toFixed(e,t={groupSeparator:""},n=1){return Number.isInteger(e)||Qt.logWithError(`${e} is not an integer.`),e<0&&Qt.logWithError(`${e} is negative.`),bn.DP=e,bn.RM=ar[n]||1,new bn(this.numerator.toString()).div(this.denominator.toString()).toFormat(e,t)}isZero(){return this.numerator.isZero()}};var ur=Te("Raydium_amount"),ti=It(cr);function lr(b,e){let t="0",n="0";if(b.includes(".")){let i=b.split(".");i.length===2?([t,n]=i,n=n.padEnd(e,"0")):ur.logWithError(`invalid number string, num: ${b}`)}else t=b;return[t,n.slice(0,e)||n]}var Ae=class extends Q{constructor(t,n,i=!0,s){let r=new $t(0),o=gn.pow(new $t(t.decimals));if(i)r=Pe(n);else{let a=new $t(0),c=new $t(0);if(typeof n=="string"||typeof n=="number"||typeof n=="bigint"){let[l,d]=lr(n.toString(),t.decimals);a=Pe(l),c=Pe(d)}a=a.mul(o),r=a.add(c)}super(r,o);this.logger=Te(s||"TokenAmount"),this.token=t}get raw(){return this.numerator}isZero(){return this.raw.isZero()}gt(t){return this.token.equals(t.token)||this.logger.logWithError("gt token not equals"),this.raw.gt(t.raw)}lt(t){return this.token.equals(t.token)||this.logger.logWithError("lt token not equals"),this.raw.lt(t.raw)}add(t){return this.token.equals(t.token)||this.logger.logWithError("add token not equals"),new Ae(this.token,this.raw.add(t.raw))}subtract(t){return this.token.equals(t.token)||this.logger.logWithError("sub token not equals"),new Ae(this.token,this.raw.sub(t.raw))}toSignificant(t=this.token.decimals,n,i=0){return super.toSignificant(t,n,i)}toFixed(t=this.token.decimals,n,i=0){return t>this.token.decimals&&this.logger.logWithError("decimals overflow"),super.toFixed(t,n,i)}toExact(t={groupSeparator:""}){return ti.DP=this.token.decimals,new ti(this.numerator.toString()).div(this.denominator.toString()).toFormat(t)}};import{PublicKey as mr}from"@solana/web3.js";import{TOKEN_PROGRAM_ID as ni}from"@solana/spl-token";var wn={chainId:101,address:mr.default.toBase58(),programId:ni.toBase58(),decimals:9,symbol:"SOL",name:"solana",logoURI:"https://img-v1.raydium.io/icon/So11111111111111111111111111111111111111112.png",tags:[],priority:2,type:"raydium",extensions:{coingeckoId:"solana"}},it={chainId:101,address:"So11111111111111111111111111111111111111112",programId:ni.toBase58(),decimals:9,symbol:"WSOL",name:"Wrapped SOL",logoURI:"https://img-v1.raydium.io/icon/So11111111111111111111111111111111111111112.png",tags:[],priority:2,type:"raydium",extensions:{coingeckoId:"solana"}};import{PublicKey as An}from"@solana/web3.js";import{PublicKey as ue,SystemProgram as ii,SYSVAR_RENT_PUBKEY as dr}from"@solana/web3.js";import{TOKEN_PROGRAM_ID as pr}from"@solana/spl-token";function Pn({pubkey:b,isSigner:e=!1,isWritable:t=!0}){return{pubkey:b,isWritable:t,isSigner:e}}var Go=[Pn({pubkey:pr,isWritable:!1}),Pn({pubkey:ii.programId,isWritable:!1}),Pn({pubkey:dr,isWritable:!1})];function kn({publicKey:b,transformSol:e}){let t=ri(b.toString());if(t instanceof ue)return e&&t.equals(Ct)?Z:t;if(e&&t.toString()===Ct.toBase58())return Z;if(typeof t=="string"){if(t===ue.default.toBase58())return ue.default;try{return new ue(t)}catch{throw new Error("invalid public key")}}throw new Error("invalid public key")}function ri(b){try{return new ue(b)}catch{return b}}var en=new ue("MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr"),Tn=new ue("MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr"),rt=new ue("SysvarRent111111111111111111111111111111111"),Uo=new ue("SysvarC1ock11111111111111111111111111111111"),dt=new ue("metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s"),Xo=new ue("Sysvar1nstructions1111111111111111111111111"),Ho=ii.programId,zo=new ue("4k3Dyjzvzp8eMZWUXbBCjEvwSkkk59S5iCNLY3QrkX6R"),jo=new ue("Ea5SjE2Y6yvCeW5dYTn7PYMuW5ikXkvbGdcmSnXeaLjS"),Yo=new ue("SRMuApVNdxXokk5GT7XD5cUUgXMBCoAz2LHeuAoKWRt"),Zo=new ue("EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v"),Qo=new ue("Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB"),Jo=new ue("mSoLzYCxHdYgdzU16g5QSh3i5K3z3KZK7ytfqcJm7So"),$o=new ue("7dHbWXmci3dT8UFYWYZweBLXgycu7Y3iL6trKn1Y7ARj"),es=new ue("USDH1SM1ojwWUga67PGrgFWUHibbjqMvuMaDkRJTgkX"),ts=new ue("NRVwhjBQiUPYtfDT5zRBVJajzFQHaBUNtC7SNVvqRFa"),ns=new ue("ANAxByE6G2WjFp7A4NqtWYXb3mgruyzZYg3spfxe6Lbo"),is=new ue("7vfCXTUXx5WJV5JADk17DUJ4ksgau7utNKj4b963voxs"),Z=new ue("So11111111111111111111111111111111111111112"),Ct=ue.default;function mt(b){return kn({publicKey:b,transformSol:!0})}var hn=class{constructor({mint:e,decimals:t,symbol:n,name:i,skipMint:s=!1,isToken2022:r=!1}){if(e===Ct.toBase58()||e instanceof An&&Ct.equals(e)){this.decimals=it.decimals,this.symbol=it.symbol,this.name=it.name,this.mint=new An(it.address),this.isToken2022=!1;return}this.decimals=t,this.symbol=n||e.toString().substring(0,6),this.name=i||e.toString().substring(0,6),this.mint=s?An.default:kn({publicKey:e}),this.isToken2022=r}equals(e){return this===e?!0:this.mint.equals(e.mint)}},ve=hn;ve.WSOL=new hn(U(O({},it),{mint:it.address}));var xn=class{constructor({decimals:e,symbol:t="UNKNOWN",name:n="UNKNOWN"}){this.decimals=e,this.symbol=t,this.name=n}equals(e){return this===e}},tn=xn;tn.SOL=new xn(wn);import fr from"bn.js";var oi=new Q(new fr(100)),ot=class extends Q{toSignificant(e=5,t,n){return this.mul(oi).toSignificant(e,t,n)}toFixed(e=2,t,n){return this.mul(oi).toFixed(e,t,n)}};var yr=Te("Raydium_price"),Ee=class extends Q{constructor(t){let{baseToken:n,quoteToken:i,numerator:s,denominator:r}=t;super(s,r);this.baseToken=n,this.quoteToken=i,this.scalar=new Q(Bn(n.decimals),Bn(i.decimals))}get raw(){return new Q(this.numerator,this.denominator)}get adjusted(){return super.mul(this.scalar)}invert(){return new Ee({baseToken:this.quoteToken,quoteToken:this.baseToken,denominator:this.numerator,numerator:this.denominator})}mul(t){this.quoteToken!==t.baseToken&&yr.logWithError("mul token not equals");let n=super.mul(t);return new Ee({baseToken:this.baseToken,quoteToken:t.quoteToken,denominator:n.denominator,numerator:n.numerator})}toSignificant(t=this.quoteToken.decimals,n,i){return this.adjusted.toSignificant(t,n,i)}toFixed(t=this.quoteToken.decimals,n,i){return this.adjusted.toFixed(t,n,i)}};var br=new Ze(0),zs=new Ze(1),js=new Ze(2),Ys=new Ze(3),Zs=new Ze(5),gn=new Ze(10),Qs=new Ze(100),Js=new Ze(1e3),$s=new Ze(1e4);function Bn(b){return gn.pow(Pe(b))}function yn(b,e=1,t=[]){let n=[...b];if(e<=0)return t;for(;n.length;)t.push(n.splice(0,e));return t}var Ve=class{constructor(e){this._owner=e}get publicKey(){return Ve.isKeyPair(this._owner)?this._owner.publicKey:this._owner}get signer(){return Ve.isKeyPair(this._owner)?this._owner:void 0}get isKeyPair(){return Ve.isKeyPair(this._owner)}get isPublicKey(){return Ve.isPublicKey(this._owner)}static isKeyPair(e){return e.secretKey!==void 0}static isPublicKey(e){return!Ve.isKeyPair(e)}};import{PublicKey as hr}from"@solana/web3.js";import{TOKEN_PROGRAM_ID as xr}from"@solana/spl-token";import{ComputeBudgetProgram as si,Keypair as ci,PublicKey as gr,Transaction as ui,TransactionMessage as wr,VersionedTransaction as li}from"@solana/web3.js";var ie={CreateAccount:"CreateAccount",InitAccount:"InitAccount",CreateATA:"CreateATA",CloseAccount:"CloseAccount",TransferAmount:"TransferAmount",InitMint:"InitMint",MintTo:"MintTo",InitMarket:"InitMarket",Util1216OwnerClaim:"Util1216OwnerClaim",SetComputeUnitPrice:"SetComputeUnitPrice",SetComputeUnitLimit:"SetComputeUnitLimit",ClmmCreatePool:"ClmmCreatePool",ClmmOpenPosition:"ClmmOpenPosition",ClmmIncreasePosition:"ClmmIncreasePosition",ClmmDecreasePosition:"ClmmDecreasePosition",ClmmClosePosition:"ClmmClosePosition",ClmmSwapBaseIn:"ClmmSwapBaseIn",ClmmSwapBaseOut:"ClmmSwapBaseOut",ClmmInitReward:"ClmmInitReward",ClmmSetReward:"ClmmSetReward",ClmmCollectReward:"ClmmCollectReward",ClmmLockPosition:"ClmmLockPosition",ClmmHarvestLockPosition:"ClmmHarvestLockPosition",AmmV4Swap:"AmmV4Swap",AmmV4AddLiquidity:"AmmV4AddLiquidity",AmmV4RemoveLiquidity:"AmmV4RemoveLiquidity",AmmV4SimulatePoolInfo:"AmmV4SimulatePoolInfo",AmmV4SwapBaseIn:"AmmV4SwapBaseIn",AmmV4SwapBaseOut:"AmmV4SwapBaseOut",AmmV4CreatePool:"AmmV4CreatePool",AmmV4InitPool:"AmmV4InitPool",AmmV5AddLiquidity:"AmmV5AddLiquidity",AmmV5RemoveLiquidity:"AmmV5RemoveLiquidity",AmmV5SimulatePoolInfo:"AmmV5SimulatePoolInfo",AmmV5SwapBaseIn:"AmmV5SwapBaseIn",AmmV5SwapBaseOut:"AmmV5SwapBaseOut",RouteSwap:"RouteSwap",RouteSwap1:"RouteSwap1",RouteSwap2:"RouteSwap2",FarmV3Deposit:"FarmV3Deposit",FarmV3Withdraw:"FarmV3Withdraw",FarmV3CreateLedger:"FarmV3CreateLedger",FarmV4Withdraw:"FarmV4Withdraw",FarmV5Deposit:"FarmV5Deposit",FarmV5Withdraw:"FarmV5Withdraw",FarmV5CreateLedger:"FarmV5CreateLedger",FarmV6Deposit:"FarmV6Deposit",FarmV6Withdraw:"FarmV6Withdraw",FarmV6Create:"FarmV6Create",FarmV6Restart:"FarmV6Restart",FarmV6CreatorAddReward:"FarmV6CreatorAddReward",FarmV6CreatorWithdraw:"FarmV6CreatorWithdraw",CpmmCreatePool:"CpmmCreatePool",CpmmAddLiquidity:"CpmmAddLiquidity",CpmmWithdrawLiquidity:"CpmmWithdrawLiquidity",CpmmSwapBaseIn:"CpmmSwapBaseIn",CpmmSwapBaseOut:"CpmmSwapBaseOut",CpmmLockLp:"CpmmLockLp",CpmmCollectLockFee:"CpmmCollectLockFee",TransferTip:"TransferTip"};import{TOKEN_PROGRAM_ID as Pr}from"@solana/spl-token";var ai=Te("Raydium_txUtil"),mi=1644;function Lt(b){let e=[],t=[];return b.microLamports&&(e.push(si.setComputeUnitPrice({microLamports:b.microLamports})),t.push(ie.SetComputeUnitPrice)),b.units&&(e.push(si.setComputeUnitLimit({units:b.units})),t.push(ie.SetComputeUnitLimit)),{instructions:e,instructionTypes:t}}async function pt(b,e){var n,i;let t=e!=null?e:"confirmed";return(i=await((n=b.getLatestBlockhash)==null?void 0:n.call(b,{commitment:t})))==null?void 0:i.blockhash}async function Rt(b,e){return b.getSignatureStatuses([e]),new Promise((t,n)=>{let i=setTimeout(n,6e4);b.onSignature(e,s=>{if(clearTimeout(i),!s.err){t("");return}n(Object.assign(s.err,{txId:e}))},"confirmed")})}function kr(b,e){b.length<1&&ai.logWithError(`no instructions provided: ${b.toString()}`),e.length<1&&ai.logWithError(`no signers provided:, ${e.toString()}`);let t=new ui;t.recentBlockhash="11111111111111111111111111111111",t.feePayer=e[0],t.add(...b);try{return Buffer.from(t.serialize({verifySignatures:!1})).toString("base64").length<mi}catch{return!1}}function xe(b,e){let[t,n]=gr.findProgramAddressSync(b,e);return{publicKey:t,nonce:n}}function Nt({instructions:b,payer:e,signers:t}){return kr(b,[e,...t])}function Qe({instructions:b,payer:e,lookupTableAddressAccount:t,recentBlockhash:n=ci.generate().publicKey.toString()}){let s=new wr({payerKey:e,recentBlockhash:n,instructions:b}).compileToV0Message(Object.values(t!=null?t:{}));try{return Buffer.from(new li(s).serialize()).toString("base64").length<mi}catch{return!1}}var Tr=b=>Buffer.isBuffer(b)?b:b instanceof Uint8Array?Buffer.from(b.buffer,b.byteOffset,b.byteLength):Buffer.from(b),Ar=b=>{let e=b.serialize({requireAllSignatures:!1,verifySignatures:!1});b instanceof li&&(e=Tr(e));try{return e instanceof Buffer?e.toString("base64"):Buffer.from(e).toString("base64")}catch{return e.toString("base64")}};function st(b){let e=[];return b.forEach(t=>{t instanceof ui&&(t.recentBlockhash||(t.recentBlockhash=Pr.toBase58()),t.feePayer||(t.feePayer=ci.generate().publicKey)),e.push(Ar(t))}),console.log("simulate tx string:",e),e}function re(b,e,t){return xe([b.toBuffer(),(t!=null?t:xr).toBuffer(),e.toBuffer()],new hr("ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL"))}import{PublicKey as _}from"@solana/web3.js";var ka=new _("EhhTKczWMGQt46ynNeRX1WfeagwwJd7ufHvCDjRxjo5Q"),Ta=new _("CBuCnLe26faBpcBP2fktp4rp8abpcAnTWft6ZrP5Q4T"),Aa=new _("9KEPoZmtHUrBbhWN1v1KWLMkkvwY6WLtAVUCPRtRjP4z"),ha=new _("FarmqiPv5eAj3j1GMdMCMUGXqPUvmquZtMy86QH6rzhG"),xa=new _("CLaimxFqjHzgTJtAGHU47NPhg6qrc5sCnpC4tBLyABQS"),Ba=new _("srmqPvymJeFKQ4zGQed1GFppgkRHL9kaELCbyksJtPX"),Ia=new _("9xQeWvG816bUx9EPjHmaT23yvVM2ZWbrrpZb9PusVFin"),Sa=new _("675kPX9MHTjS2zt1qfr1NYHuzeLXfQM9H24wFSUt1Mp8"),Ka=new _("5quBtoiQqxF9Jv6KYKctB59NT3gtJD2Y65kdnB1Uev3h"),Ca=new _("CDSr3ssLcRB6XYPJwAfFt18MZvEZp4LjHcvzBVZ45duo"),Mt=new _("CAMMCzo5YL8w4VFF8KVHrK22GGUsp5VTaW7grrKgrWqK"),Ot=new _("LockrWmn6K5twhz3y9w1dQERbmgSaRkfnTeTKbpofwE"),nn=new _("kN1kEznaF5Xbd8LYuqtEFcxzWSBk5Fv6ygX6SqEGJVy"),La=new _("CDSr3ssLcRB6XYPJwAfFt18MZvEZp4LjHcvzBVZ45duo"),Ra=new _("routeUGWgWzqBWFcrCfv8tritsqukccJPu3q5GPP3xS"),Na=new _("7YttLkHDoNj9wyDur5pM1ejNaAvT9X4eqaYcHQqtj2G5"),Ma=new _("6FJon3QE27qgPVggARueB22hLvoh22VzJpXv4rBEoSLF"),Oa=new _("CC12se5To1CdEuw7fDS27B7Geo5jJyL7t5UK2B44NgiH"),Fa=new _("9HzJyW1qZsEiSfMUf6L2jo3CcTKAyBmSyKdwQeYisHrC"),Ea=new _("DropEU8AvevN3UrXWXTMuz3rqnMczQVNjq3kcSdW2SQi"),_a=new _("CPMMoo8L3F4NbTegBCKVNunggL7H1ZpdTHKxQB5qKP1C"),Da=new _("GpMZbSM2GgvTKHJirzeGfMFoaZ8UR2X7F4v8vHTvxFbL"),Wa=new _("DNXgeM9EiiaAbaWvwjHj9fQQLAX5ZsfHyvmYUNRAdNC8"),va=new _("LockrWmn6K5twhz3y9w1dQERbmgSaRkfnTeTKbpofwE"),Va=new _("3f7GcQFG397GAaEnv51zR6tsTVihYRydnydDD1cXekxH"),qa=new _("LanMV9sAd7wArD4vJFi2qDdfnVhFxYSUg6eADduJ3uj"),Ga=new _("WLHv2UAZm6z4KyaaELi5pjdbJh6RESMva1Rnn8pJVVh"),Ua=new _("DRay6fNdQ5J82H7xV6uq2aV3mNrUZ1J4PgSKsWgptcm6"),Xa=new _("5xqNaZXX5eUi4p5HU4oz9i5QnwRNT2y6oN7yyn4qENeq"),Ha=new _("4Bu96XjU84XjPDSpveTVf6LYGCkfW5FK7SNkREWcEfV4"),za=new _("6s1xP3hpbAfFoNtUNF8mfHsjr2Bd97JxFJRWLbL6aHuX");var ja={OPEN_BOOK_PROGRAM:new _("EoTcMgcDRTJVZDMZWBoU6rhYHZfkNTVEAfz3uUJRcYGj"),SERUM_PROGRAM_ID_V3:new _("Ray1111111111111111111111111111111111111111"),AMM_V4:new _("DRaya7Kj3aMWQSy19kSjvmuwq9docCHofyP9kanQGaav"),AMM_STABLE:new _("DRayDdXc1NZQ9C3hRWmoSf8zK4iapgMnjdNZWrfwsP8m"),CLMM_PROGRAM_ID:new _("DRayAUgENGQBKVaX8owNhgzkEDyoHTGVEGHVJT1E9pfH"),CLMM_LOCK_PROGRAM_ID:new _("DRay25Usp3YJAi7beckgpGUC7mGJ2cR1AVPxhYfwVCUX"),CLMM_LOCK_AUTH_ID:new _("6Aoh8h2Lw2m5UGxYR8AdAL87jTWYeKoxM52mJRzfYwN"),CREATE_CPMM_POOL_PROGRAM:new _("DRaycpLY18LhpbydsBWbVJtxpNv9oXPgjRSfpF2bWpYb"),CREATE_CPMM_POOL_AUTH:new _("CXniRufdq5xL8t8jZAPxsPZDpuudwuJSPWnbcD5Y5Nxq"),CREATE_CPMM_POOL_FEE_ACC:new _("3oE58BKVt8KuYkGxx8zBojugnymWmBiyafWgMrnb6eYy"),LOCK_CPMM_PROGRAM:new _("DRay25Usp3YJAi7beckgpGUC7mGJ2cR1AVPxhYfwVCUX"),LOCK_CPMM_AUTH:new _("7qWVV8UY2bRJfDLP4s37YzBPKUkVB46DStYJBpYbQzu3"),UTIL1216:_.default,Router:new _("DRaybByLpbUL57LJARs3j8BitTxVfzBg351EaMr5UTCd"),FARM_PROGRAM_ID_V3:new _("DRayWyrLmEW5KEeqs8kdTMMaBabapqagaBC7KWpGtJeZ"),FARM_PROGRAM_ID_V4:new _("Ray1111111111111111111111111111111111111111"),FARM_PROGRAM_ID_V5:new _("DRayiCGSZgku1GTK6rXD6mVDdingXy6APAH1R6R5L2LC"),FARM_PROGRAM_ID_V6:new _("DRayzbYakXs45ELHkzH6vC3fuhQqTAnv5A68gdFuvZyZ"),LAUNCHPAD_PROGRAM:new _("DRay6fNdQ5J82H7xV6uq2aV3mNrUZ1J4PgSKsWgptcm6"),LAUNCHPAD_AUTH:new _("5xqNaZXX5eUi4p5HU4oz9i5QnwRNT2y6oN7yyn4qENeq"),LAUNCHPAD_PLATFORM:new _("2Jx4KTDrVSdWNazuGpcA8n3ZLTRGGBDxAWhuKe2Xcj2a"),LAUNCHPAD_CONFIG:new _("7ZR4zD7PYfY2XxoG1Gxcy2EgEeGYrpxrwzPuwdUBssEt"),FEE_DESTINATION_ID:new _("9y8ENuuZ3b19quffx9hQvRVygG5ky6snHfRvGpuSfeJy"),MODEL_DATA_PUBKEY:new _("Ray1111111111111111111111111111111111111111")};import _e from"bn.js";var Ft=1e4;function be(b,e,t,n){if(e===void 0)return{amount:b,fee:void 0,expirationTime:void 0};let i=U(O({},e),{olderTransferFee:{epoch:BigInt(e.olderTransferFee.epoch),maximumFee:BigInt(e.olderTransferFee.maximumFee),transferFeeBasisPoints:e.olderTransferFee.transferFeeBasisPoints},newerTransferFee:{epoch:BigInt(e.newerTransferFee.epoch),maximumFee:BigInt(e.newerTransferFee.maximumFee),transferFeeBasisPoints:e.newerTransferFee.transferFeeBasisPoints}}),s=t.epoch<i.newerTransferFee.epoch?i.olderTransferFee:i.newerTransferFee,r=new _e(s.maximumFee.toString()),o=t.epoch<i.newerTransferFee.epoch?(Number(i.newerTransferFee.epoch)*t.slotsInEpoch-t.absoluteSlot)*400/1e3:void 0;if(n)if(s.transferFeeBasisPoints===Ft){let a=new _e(s.maximumFee.toString());return{amount:b.add(a),fee:a,expirationTime:o}}else{let a=In(b.mul(new _e(Ft)),new _e(Ft-s.transferFeeBasisPoints)),c=new _e(s.maximumFee.toString()),l=a.sub(b).gt(c)?b.add(c):a,d=In(l.mul(new _e(s.transferFeeBasisPoints)),new _e(Ft)),f=d.gt(r)?r:d;return{amount:l,fee:f,expirationTime:o}}else{let a=In(b.mul(new _e(s.transferFeeBasisPoints)),new _e(Ft)),c=a.gt(r)?r:a;return{amount:b,fee:c,expirationTime:o}}}function at(b,e){return b===void 0?e:e===void 0?b:Math.min(b,e)}function In(b,e){let{div:t,mod:n}=b.divmod(e);return n.gt(new _e(0))?t.add(new _e(1)):t}import{PublicKey as Sn,AddressLookupTableAccount as kt}from"@solana/web3.js";async function rn({connection:b,address:e,cluster:t="mainnet"}){let n=await je(b,[...new Set(e.map(s=>s.toString()))].map(s=>new Sn(s))),i={};for(let s=0;s<e.length;s++){let r=n[s],o=e[s];if(!r)continue;let a=new kt({key:o,state:kt.deserialize(r.data)});i[o.toString()]=a,t==="devnet"?Pt[o.toString()]=a:ct[o.toString()]=a}return i}var ct={},Kn=async b=>{let e="AcL1Vo8oy1ULiavEcjSUcwfBSForXMudcZvDZy5nzJkU";if(ct[e])return ct;let t=new Sn(e),n=await b.getAccountInfo(t);return n&&(ct[e]=new kt({key:t,state:kt.deserialize(n.data)})),ct},Pt={},on=async b=>{let e="EFhMuDw1PKEuckuFRW9PavNfTH4LKP5uKHgyXDmWpFCq";if(Pt[e])return Pt;let t=new Sn(e),n=await b.getAccountInfo(t);return n&&(Pt[e]=new kt({key:t,state:kt.deserialize(n.data)})),Pt};import{PublicKey as ft,sendAndConfirmTransaction as Cn,SystemProgram as Ir,Transaction as Et,TransactionMessage as Je,VersionedTransaction as $e}from"@solana/web3.js";import Sr from"axios";var _t=2e3,Dt=class{constructor(e){this.instructions=[];this.endInstructions=[];this.lookupTableAddress=[];this.signers=[];this.instructionTypes=[];this.endInstructionTypes=[];this.connection=e.connection,this.feePayer=e.feePayer,this.signAllTransactions=e.signAllTransactions,this.owner=e.owner,this.cluster=e.cluster,this.blockhashCommitment=e.blockhashCommitment,this.loopMultiTxStatus=!!e.loopMultiTxStatus}get AllTxData(){return{instructions:this.instructions,endInstructions:this.endInstructions,signers:this.signers,instructionTypes:this.instructionTypes,endInstructionTypes:this.endInstructionTypes,lookupTableAddress:this.lookupTableAddress}}get allInstructions(){return[...this.instructions,...this.endInstructions]}async getComputeBudgetConfig(){var n;let e=(await Sr.get(`https://solanacompass.com/api/fees?cacheFreshTime=${3e5}`)).data,{avg:t}=(n=e==null?void 0:e[15])!=null?n:{};if(!!t)return{units:6e5,microLamports:Math.min(Math.ceil(t*1e6/6e5),25e3)}}addCustomComputeBudget(e){if(e){let{instructions:t,instructionTypes:n}=Lt(e);return this.instructions.unshift(...t),this.instructionTypes.unshift(...n),!0}return!1}addTipInstruction(e){var t;return e?(this.endInstructions.push(Ir.transfer({fromPubkey:(t=e.feePayer)!=null?t:this.feePayer,toPubkey:new ft(e.address),lamports:BigInt(e.amount.toString())})),this.endInstructionTypes.push(ie.TransferTip),!0):!1}async calComputeBudget({config:e,defaultIns:t}){try{let n=e||await this.getComputeBudgetConfig();if(this.addCustomComputeBudget(n))return;t&&this.instructions.unshift(...t)}catch{t&&this.instructions.unshift(...t)}}addInstruction({instructions:e=[],endInstructions:t=[],signers:n=[],instructionTypes:i=[],endInstructionTypes:s=[],lookupTableAddress:r=[]}){return this.instructions.push(...e),this.endInstructions.push(...t),this.signers.push(...n),this.instructionTypes.push(...i),this.endInstructionTypes.push(...s),this.lookupTableAddress.push(...r.filter(o=>o!==ft.default.toString())),this}async versionBuild({txVersion:e,extInfo:t}){return e===0?await this.buildV0(O({},t||{})):this.build(t)}build(e){var n;let t=new Et;return this.allInstructions.length&&t.add(...this.allInstructions),t.feePayer=this.feePayer,((n=this.owner)==null?void 0:n.signer)&&!this.signers.some(i=>i.publicKey.equals(this.owner.publicKey))&&this.signers.push(this.owner.signer),{builder:this,transaction:t,signers:this.signers,instructionTypes:[...this.instructionTypes,...this.endInstructionTypes],execute:async i=>{var l;let{recentBlockHash:s,skipPreflight:r=!0,sendAndConfirm:o,notSendToRpc:a}=i||{},c=s!=null?s:await pt(this.connection,this.blockhashCommitment);if(t.recentBlockhash=c,this.signers.length&&t.sign(...this.signers),st([t]),(l=this.owner)!=null&&l.isKeyPair)return{txId:o?await Cn(this.connection,t,this.signers.find(f=>f.publicKey.equals(this.owner.publicKey))?this.signers:[...this.signers,this.owner.signer],{skipPreflight:r}):await this.connection.sendRawTransaction(t.serialize(),{skipPreflight:r}),signedTx:t};if(this.signAllTransactions){let d=await this.signAllTransactions([t]);if(this.signers.length)for(let f of d)try{f.sign(...this.signers)}catch{}return{txId:a?"":await this.connection.sendRawTransaction(d[0].serialize(),{skipPreflight:r}),signedTx:d[0]}}throw new Error("please provide owner in keypair format or signAllTransactions function")},extInfo:e||{}}}buildMultiTx(e){var c;let{extraPreBuildData:t=[],extInfo:n}=e,{transaction:i}=this.build(n),s=t.filter(l=>l.transaction.instructions.length>0),r=[i,...s.map(l=>l.transaction)],o=[this.signers,...s.map(l=>l.signers)],a=[...this.instructionTypes,...s.map(l=>l.instructionTypes).flat()];return(c=this.owner)!=null&&c.signer&&o.forEach(l=>{l.some(d=>d.publicKey.equals(this.owner.publicKey))||this.signers.push(this.owner.signer)}),{builder:this,transactions:r,signers:o,instructionTypes:a,execute:async l=>{var g;let{sequentially:d,onTxUpdate:f,skipTxCount:u=0,recentBlockHash:m,skipPreflight:p=!0}=l||{},y=m!=null?m:await pt(this.connection,this.blockhashCommitment);if((g=this.owner)!=null&&g.isKeyPair){if(d){let P=[],A=0;for(let T of r){if(++A,A<=u)continue;let k=await Cn(this.connection,T,this.signers.find(w=>w.publicKey.equals(this.owner.publicKey))?this.signers:[...this.signers,this.owner.signer],{skipPreflight:p});P.push(k)}return{txIds:P,signedTxs:r}}return{txIds:await await Promise.all(r.map(async P=>(P.recentBlockhash=y,await this.connection.sendRawTransaction(P.serialize(),{skipPreflight:p})))),signedTxs:r}}if(this.signAllTransactions){let P=r.map((T,k)=>(T.recentBlockhash=y,o[k].length&&T.sign(...o[k]),T));st(P);let A=await this.signAllTransactions(P);if(d){let T=0,k=[],w=async()=>{if(!A[T])return;let x=await this.connection.sendRawTransaction(A[T].serialize(),{skipPreflight:p});k.push({txId:x,status:"sent",signedTx:A[T]}),f==null||f([...k]),T++;let h=!1,B=null,C=null,L=K=>{B!==null&&clearInterval(B),C!==null&&this.connection.removeSignatureListener(C);let N=k.findIndex(I=>I.txId===x);if(N>-1){if(k[N].status==="error"||k[N].status==="success")return;k[N].status=K.err?"error":"success"}f==null||f([...k]),K.err||w()};this.loopMultiTxStatus&&(B=setInterval(async()=>{var K;if(h){clearInterval(B);return}try{let N=await this.connection.getTransaction(x,{commitment:"confirmed",maxSupportedTransactionVersion:0});N&&(h=!0,clearInterval(B),L({err:((K=N.meta)==null?void 0:K.err)||null}),console.log("tx status from getTransaction:",x))}catch(N){h=!0,clearInterval(B),console.error("getTransaction timeout:",N,x)}},_t)),C=this.connection.onSignature(x,K=>{if(h){this.connection.removeSignatureListener(C);return}h=!0,L(K)},"confirmed"),this.connection.getSignatureStatus(x)};return await w(),{txIds:k.map(x=>x.txId),signedTxs:A}}else{let T=[];for(let k=0;k<A.length;k+=1){let w=await this.connection.sendRawTransaction(A[k].serialize(),{skipPreflight:p});T.push(w)}return{txIds:T,signedTxs:A}}}throw new Error("please provide owner in keypair format or signAllTransactions function")},extInfo:n||{}}}async versionMultiBuild({extraPreBuildData:e,txVersion:t,extInfo:n}){return t===0?await this.buildV0MultiTx({extraPreBuildData:e,buildProps:n||{}}):this.buildMultiTx({extraPreBuildData:e,extInfo:n})}async buildV0(e){var p;let m=e||{},{lookupTableCache:t={},lookupTableAddress:n=[],forerunCreate:i,recentBlockhash:s}=m,r=lt(m,["lookupTableCache","lookupTableAddress","forerunCreate","recentBlockhash"]),o=O(O({},this.cluster==="devnet"?await on(this.connection):await Kn(this.connection)),t),a=Array.from(new Set([...n,...this.lookupTableAddress])),c=[];for(let y of a)o[y]===void 0&&c.push(new ft(y));let l=await rn({connection:this.connection,address:c});for(let[y,g]of Object.entries(l))o[y]=g;let d=i?ft.default.toBase58():s!=null?s:await pt(this.connection,this.blockhashCommitment),f=new Je({payerKey:this.feePayer,recentBlockhash:d,instructions:[...this.allInstructions]}).compileToV0Message(Object.values(o));((p=this.owner)==null?void 0:p.signer)&&!this.signers.some(y=>y.publicKey.equals(this.owner.publicKey))&&this.signers.push(this.owner.signer);let u=new $e(f);return u.sign(this.signers),{builder:this,transaction:u,signers:this.signers,instructionTypes:[...this.instructionTypes,...this.endInstructionTypes],execute:async y=>{var T;let{skipPreflight:g=!0,sendAndConfirm:P,notSendToRpc:A}=y||{};if(st([u]),(T=this.owner)!=null&&T.isKeyPair){let k=await this.connection.sendTransaction(u,{skipPreflight:g});return P&&await Rt(this.connection,k),{txId:k,signedTx:u}}if(this.signAllTransactions){let k=await this.signAllTransactions([u]);if(this.signers.length)for(let w of k)try{w.sign(this.signers)}catch{}return{txId:A?"":await this.connection.sendTransaction(k[0],{skipPreflight:g}),signedTx:k[0]}}throw new Error("please provide owner in keypair format or signAllTransactions function")},extInfo:r||{}}}async buildV0MultiTx(e){var c;let{extraPreBuildData:t=[],buildProps:n}=e,{transaction:i}=await this.buildV0(n),s=t.filter(l=>l.builder.instructions.length>0),r=[i,...s.map(l=>l.transaction)],o=[this.signers,...s.map(l=>l.signers)],a=[...this.instructionTypes,...s.map(l=>l.instructionTypes).flat()];return(c=this.owner)!=null&&c.signer&&o.forEach(l=>{l.some(d=>d.publicKey.equals(this.owner.publicKey))||this.signers.push(this.owner.signer)}),r.forEach(async(l,d)=>{l.sign(o[d])}),{builder:this,transactions:r,signers:o,instructionTypes:a,buildProps:n,execute:async l=>{var p;let{sequentially:d,onTxUpdate:f,recentBlockHash:u,skipPreflight:m=!0}=l||{};if(u&&r.forEach(y=>y.message.recentBlockhash=u),st(r),(p=this.owner)!=null&&p.isKeyPair){if(d){let y=[];for(let g of r){let P=await this.connection.sendTransaction(g,{skipPreflight:m});await Rt(this.connection,P),y.push(P)}return{txIds:y,signedTxs:r}}return{txIds:await Promise.all(r.map(async y=>await this.connection.sendTransaction(y,{skipPreflight:m}))),signedTxs:r}}if(this.signAllTransactions){let y=await this.signAllTransactions(r);if(d){let g=0,P=[],A=async()=>{if(!y[g])return;let T=await this.connection.sendTransaction(y[g],{skipPreflight:m});P.push({txId:T,status:"sent",signedTx:y[g]}),f==null||f([...P]),g++;let k=!1,w=null,x=null,h=B=>{w!==null&&clearInterval(w),x!==null&&this.connection.removeSignatureListener(x);let C=P.findIndex(L=>L.txId===T);if(C>-1){if(P[C].status==="error"||P[C].status==="success")return;P[C].status=B.err?"error":"success"}f==null||f([...P]),B.err||A()};this.loopMultiTxStatus&&(w=setInterval(async()=>{var B;if(k){clearInterval(w);return}try{let C=await this.connection.getTransaction(T,{commitment:"confirmed",maxSupportedTransactionVersion:0});C&&(k=!0,clearInterval(w),h({err:((B=C.meta)==null?void 0:B.err)||null}),console.log("tx status from getTransaction:",T))}catch(C){k=!0,clearInterval(w),console.error("getTransaction timeout:",C,T)}},_t)),x=this.connection.onSignature(T,B=>{if(k){this.connection.removeSignatureListener(x);return}k=!0,h(B)},"confirmed"),this.connection.getSignatureStatus(T)};return A(),{txIds:[],signedTxs:y}}else{let g=[];for(let P=0;P<y.length;P+=1){let A=await this.connection.sendTransaction(y[P],{skipPreflight:m});g.push(A)}return{txIds:g,signedTxs:y}}}throw new Error("please provide owner in keypair format or signAllTransactions function")},extInfo:n||{}}}async sizeCheckBuild(e){var f;let d=e||{},{splitIns:t=[],computeBudgetConfig:n}=d,i=lt(d,["splitIns","computeBudgetConfig"]),s=n?Lt(n):{instructions:[],instructionTypes:[]},r=this.signers.reduce((u,m)=>U(O({},u),{[m.publicKey.toBase58()]:m}),{}),o=[],a=[],c=[],l=0;if(this.allInstructions.forEach(u=>{let m=[...c,u],p=n?[...s.instructions,...m]:m,g=[...new Set(m.map(P=>P.keys.filter(A=>A.isSigner).map(A=>A.pubkey.toString())).flat()).values()].map(P=>new ft(P));if(u!==t[l]&&c.length<12&&(Nt({instructions:p,payer:this.feePayer,signers:g})||Nt({instructions:m,payer:this.feePayer,signers:g})))c.push(u);else{if(c.length===0)throw Error("item ins too big");l+=u===t[l]?1:0,Nt({instructions:n?[...s.instructions,...c]:[...c],payer:this.feePayer,signers:g})?o.push(new Et().add(...s.instructions,...c)):o.push(new Et().add(...c)),a.push(Array.from(new Set(c.map(P=>P.keys.filter(A=>A.isSigner).map(A=>A.pubkey.toString())).flat())).map(P=>r[P]).filter(P=>P!==void 0)),c=[u]}}),c.length>0){let m=[...new Set(c.map(p=>p.keys.filter(y=>y.isSigner).map(y=>y.pubkey.toString())).flat()).values()].map(p=>r[p]).filter(p=>p!==void 0);Nt({instructions:n?[...s.instructions,...c]:[...c],payer:this.feePayer,signers:m.map(p=>p.publicKey)})?o.push(new Et().add(...s.instructions,...c)):o.push(new Et().add(...c)),a.push(m)}return o.forEach(u=>u.feePayer=this.feePayer),(f=this.owner)!=null&&f.signer&&a.forEach(u=>{u.some(m=>m.publicKey.equals(this.owner.publicKey))||u.push(this.owner.signer)}),{builder:this,transactions:o,signers:a,instructionTypes:this.instructionTypes,execute:async u=>{var T;let{sequentially:m,onTxUpdate:p,skipTxCount:y=0,recentBlockHash:g,skipPreflight:P=!0}=u||{},A=g!=null?g:await pt(this.connection,this.blockhashCommitment);if(o.forEach(async(k,w)=>{k.recentBlockhash=A,a[w].length&&k.sign(...a[w])}),st(o),(T=this.owner)!=null&&T.isKeyPair){if(m){let k=0,w=[];for(let x of o){if(++k,k<=y){w.push("tx skipped");continue}let h=await Cn(this.connection,x,this.signers.find(B=>B.publicKey.equals(this.owner.publicKey))?this.signers:[...this.signers,this.owner.signer],{skipPreflight:P});w.push(h)}return{txIds:w,signedTxs:o}}return{txIds:await Promise.all(o.map(async k=>await this.connection.sendRawTransaction(k.serialize(),{skipPreflight:P}))),signedTxs:o}}if(this.signAllTransactions){let k=await this.signAllTransactions(o.slice(y,o.length)),w=[...o.slice(0,y),...k];if(m){let x=0,h=[],B=async()=>{if(!w[x])return;x<y&&(h.push({txId:"",status:"success",signedTx:w[x]}),p==null||p([...h]),x++,B());let C=await this.connection.sendRawTransaction(w[x].serialize(),{skipPreflight:P});h.push({txId:C,status:"sent",signedTx:w[x]}),p==null||p([...h]),x++;let L=!1,K=null,N=null,I=F=>{K!==null&&clearInterval(K),N!==null&&this.connection.removeSignatureListener(N);let v=h.findIndex(ce=>ce.txId===C);if(v>-1){if(h[v].status==="error"||h[v].status==="success")return;h[v].status=F.err?"error":"success"}p==null||p([...h]),F.err||B()};this.loopMultiTxStatus&&(K=setInterval(async()=>{var F;if(L){clearInterval(K);return}try{let v=await this.connection.getTransaction(C,{commitment:"confirmed",maxSupportedTransactionVersion:0});v&&(L=!0,clearInterval(K),I({err:((F=v.meta)==null?void 0:F.err)||null}),console.log("tx status from getTransaction:",C))}catch(v){L=!0,clearInterval(K),console.error("getTransaction timeout:",v,C)}},_t)),N=this.connection.onSignature(C,F=>{if(L){this.connection.removeSignatureListener(N);return}L=!0,I(F)},"confirmed"),this.connection.getSignatureStatus(C)};return await B(),{txIds:h.map(C=>C.txId),signedTxs:w}}else{let x=[];for(let h=0;h<w.length;h+=1){let B=await this.connection.sendRawTransaction(w[h].serialize(),{skipPreflight:P});x.push(B)}return{txIds:x,signedTxs:w}}}throw new Error("please provide owner in keypair format or signAllTransactions function")},extInfo:i||{}}}async sizeCheckBuildV0(e){var A;let P=e||{},{computeBudgetConfig:t,splitIns:n=[],lookupTableCache:i={},lookupTableAddress:s=[]}=P,r=lt(P,["computeBudgetConfig","splitIns","lookupTableCache","lookupTableAddress"]),o=O(O({},this.cluster==="devnet"?await on(this.connection):ct),i),a=Array.from(new Set([...this.lookupTableAddress,...s])),c=[];for(let T of a)o[T]===void 0&&c.push(new ft(T));let l=await rn({connection:this.connection,address:c});for(let[T,k]of Object.entries(l))o[T]=k;let d=t?Lt(t):{instructions:[],instructionTypes:[]},f=await pt(this.connection,this.blockhashCommitment),u=this.signers.reduce((T,k)=>U(O({},T),{[k.publicKey.toBase58()]:k}),{}),m=[],p=[],y=[],g=0;if(this.allInstructions.forEach(T=>{let k=[...y,T],w=t?[...d.instructions,...k]:k;if(T!==n[g]&&y.length<12&&(Qe({instructions:w,payer:this.feePayer,lookupTableAddressAccount:o})||Qe({instructions:k,payer:this.feePayer,lookupTableAddressAccount:o})))y.push(T);else{if(y.length===0)throw Error("item ins too big");g+=T===n[g]?1:0;let x={};for(let h of[...new Set(a)])o[h]!==void 0&&(x[h]=o[h]);if(t&&Qe({instructions:[...d.instructions,...y],payer:this.feePayer,lookupTableAddressAccount:o,recentBlockhash:f})){let h=new Je({payerKey:this.feePayer,recentBlockhash:f,instructions:[...d.instructions,...y]}).compileToV0Message(Object.values(o));m.push(new $e(h))}else{let h=new Je({payerKey:this.feePayer,recentBlockhash:f,instructions:[...y]}).compileToV0Message(Object.values(o));m.push(new $e(h))}p.push(Array.from(new Set(y.map(h=>h.keys.filter(B=>B.isSigner).map(B=>B.pubkey.toString())).flat())).map(h=>u[h]).filter(h=>h!==void 0)),y=[T]}}),y.length>0){let k=[...new Set(y.map(w=>w.keys.filter(x=>x.isSigner).map(x=>x.pubkey.toString())).flat()).values()].map(w=>u[w]).filter(w=>w!==void 0);if(t&&Qe({instructions:[...d.instructions,...y],payer:this.feePayer,lookupTableAddressAccount:o,recentBlockhash:f})){let w=new Je({payerKey:this.feePayer,recentBlockhash:f,instructions:[...d.instructions,...y]}).compileToV0Message(Object.values(o));m.push(new $e(w))}else{let w=new Je({payerKey:this.feePayer,recentBlockhash:f,instructions:[...y]}).compileToV0Message(Object.values(o));m.push(new $e(w))}p.push(k)}return(A=this.owner)!=null&&A.signer&&p.forEach(T=>{T.some(k=>k.publicKey.equals(this.owner.publicKey))||T.push(this.owner.signer)}),m.forEach((T,k)=>{T.sign(p[k])}),{builder:this,transactions:m,buildProps:e,signers:p,blockHash:f,instructionTypes:this.instructionTypes,execute:async T=>{var C;let{sequentially:k,onTxUpdate:w,skipTxCount:x=0,recentBlockHash:h,skipPreflight:B=!0}=T||{};if(m.map(async(L,K)=>{p[K].length&&L.sign(p[K]),h&&(L.message.recentBlockhash=h)}),st(m),(C=this.owner)!=null&&C.isKeyPair){if(k){let L=0,K=[];for(let N of m){if(++L,L<=x){console.log("skip tx: ",L),K.push("tx skipped");continue}let I=await this.connection.sendTransaction(N,{skipPreflight:B});await Rt(this.connection,I),K.push(I)}return{txIds:K,signedTxs:m}}return{txIds:await Promise.all(m.map(async L=>await this.connection.sendTransaction(L,{skipPreflight:B}))),signedTxs:m}}if(this.signAllTransactions){let L=await this.signAllTransactions(m.slice(x,m.length)),K=[...m.slice(0,x),...L];if(k){let N=0,I=[],F=async()=>{if(!K[N])return;if(N<x){I.push({txId:"",status:"success",signedTx:K[N]}),w==null||w([...I]),N++,F();return}let v=await this.connection.sendTransaction(K[N],{skipPreflight:B});I.push({txId:v,status:"sent",signedTx:K[N]}),w==null||w([...I]),N++;let ce=!1,pe=null,Le=null,ze=$=>{pe!==null&&clearInterval(pe),Le!==null&&this.connection.removeSignatureListener(Le);let ne=I.findIndex(We=>We.txId===v);if(ne>-1){if(I[ne].status==="error"||I[ne].status==="success")return;I[ne].status=$.err?"error":"success"}w==null||w([...I]),$.err||F()};this.loopMultiTxStatus&&(pe=setInterval(async()=>{var $;if(ce){clearInterval(pe);return}try{let ne=await this.connection.getTransaction(v,{commitment:"confirmed",maxSupportedTransactionVersion:0});ne&&(ce=!0,clearInterval(pe),ze({err:(($=ne.meta)==null?void 0:$.err)||null}),console.log("tx status from getTransaction:",v))}catch(ne){ce=!0,clearInterval(pe),console.error("getTransaction timeout:",ne,v)}},_t)),Le=this.connection.onSignature(v,$=>{if(ce){this.connection.removeSignatureListener(Le);return}ce=!0,ze($)},"confirmed"),this.connection.getSignatureStatus(v)};return F(),{txIds:[],signedTxs:K}}else{let N=[];for(let I=0;I<K.length;I+=1){let F=await this.connection.sendTransaction(K[I],{skipPreflight:B});N.push(F)}return{txIds:N,signedTxs:K}}}throw new Error("please provide owner in keypair format or signAllTransactions function")},extInfo:r||{}}}async buildSniperTransaction(e){var A;let P=e||{},{computeBudgetConfig:t,splitIns:n=[],lookupTableCache:i={},lookupTableAddress:s=[]}=P,r=lt(P,["computeBudgetConfig","splitIns","lookupTableCache","lookupTableAddress"]),o=O(O({},this.cluster==="devnet"?await on(this.connection):await Kn(this.connection)),i),a=Array.from(new Set([...this.lookupTableAddress,...s])),c=[];for(let T of a)o[T]===void 0&&c.push(new ft(T));let l=await rn({connection:this.connection,address:c});for(let[T,k]of Object.entries(l))o[T]=k;let d=t?Lt(t):{instructions:[],instructionTypes:[]},f=await pt(this.connection,this.blockhashCommitment),u=this.signers.reduce((T,k)=>U(O({},T),{[k.publicKey.toBase58()]:k}),{}),m=[],p=[],y=[],g=0;if(this.allInstructions.forEach(T=>{let k=[...y,T],w=t?[...d.instructions,...k]:k;if(T!==n[g]&&y.length<12&&(Qe({instructions:w,payer:this.feePayer,lookupTableAddressAccount:o})||Qe({instructions:k,payer:this.feePayer,lookupTableAddressAccount:o})))y.push(T);else{if(y.length===0)throw Error("item ins too big");g+=T===n[g]?1:0;let x={};for(let h of[...new Set(a)])o[h]!==void 0&&(x[h]=o[h]);if(t&&Qe({instructions:[...d.instructions,...y],payer:this.feePayer,lookupTableAddressAccount:o,recentBlockhash:f})){let h=new Je({payerKey:this.feePayer,recentBlockhash:f,instructions:[...d.instructions,...y]}).compileToV0Message(Object.values(o));m.push(new $e(h))}else{let h=new Je({payerKey:this.feePayer,recentBlockhash:f,instructions:[...y]}).compileToV0Message(Object.values(o));m.push(new $e(h))}p.push(Array.from(new Set(y.map(h=>h.keys.filter(B=>B.isSigner).map(B=>B.pubkey.toString())).flat())).map(h=>u[h]).filter(h=>h!==void 0)),y=[T]}}),y.length>0){let k=[...new Set(y.map(w=>w.keys.filter(x=>x.isSigner).map(x=>x.pubkey.toString())).flat()).values()].map(w=>u[w]).filter(w=>w!==void 0);if(t&&Qe({instructions:[...d.instructions,...y],payer:this.feePayer,lookupTableAddressAccount:o,recentBlockhash:f})){let w=new Je({payerKey:this.feePayer,recentBlockhash:f,instructions:[...d.instructions,...y]}).compileToV0Message(Object.values(o));m.push(new $e(w))}else{let w=new Je({payerKey:this.feePayer,recentBlockhash:f,instructions:[...y]}).compileToV0Message(Object.values(o));m.push(new $e(w))}p.push(k)}return(A=this.owner)!=null&&A.signer&&p.forEach(T=>{T.some(k=>k.publicKey.equals(this.owner.publicKey))||T.push(this.owner.signer)}),m.forEach((T,k)=>{T.sign(p[k])}),{builder:this,transactions:m,buildProps:e,signers:p,instructionTypes:this.instructionTypes,execute:async T=>{var C;let{sequentially:k,onTxUpdate:w,skipTxCount:x=0,recentBlockHash:h,skipPreflight:B=!0}=T||{};if(m.map(async(L,K)=>{p[K].length&&L.sign(p[K]),h&&(L.message.recentBlockhash=h)}),st(m),(C=this.owner)!=null&&C.isKeyPair){if(k){let L=0,K=[];for(let N of m){if(++L,L<=x){console.log("skip tx: ",L),K.push("tx skipped");continue}let I=await this.connection.sendTransaction(N,{skipPreflight:B});await Rt(this.connection,I),K.push(I)}return{txIds:K,signedTxs:m}}return{txIds:await Promise.all(m.map(async L=>await this.connection.sendTransaction(L,{skipPreflight:B}))),signedTxs:m}}if(this.signAllTransactions){let L=await this.signAllTransactions(m.slice(x,m.length)),K=[...m.slice(0,x),...L];if(k){let N=0,I=[],F=async()=>{if(!K[N])return;if(N<x){I.push({txId:"",status:"success",signedTx:K[N]}),w==null||w([...I]),N++,F();return}let v=await this.connection.sendTransaction(K[N],{skipPreflight:B});I.push({txId:v,status:"sent",signedTx:K[N]}),w==null||w([...I]),N++;let ce=!1,pe=null,Le=null,ze=$=>{pe!==null&&clearInterval(pe),Le!==null&&this.connection.removeSignatureListener(Le);let ne=I.findIndex(We=>We.txId===v);if(ne>-1){if(I[ne].status==="error"||I[ne].status==="success")return;I[ne].status=$.err?"error":"success"}w==null||w([...I]),$.err||F()};this.loopMultiTxStatus&&(pe=setInterval(async()=>{var $;if(ce){clearInterval(pe);return}try{let ne=await this.connection.getTransaction(v,{commitment:"confirmed",maxSupportedTransactionVersion:0});ne&&(ce=!0,clearInterval(pe),ze({err:(($=ne.meta)==null?void 0:$.err)||null}),console.log("tx status from getTransaction:",v))}catch(ne){ce=!0,clearInterval(pe),console.error("getTransaction timeout:",ne,v)}},_t)),Le=this.connection.onSignature(v,$=>{if(ce){this.connection.removeSignatureListener(Le);return}ce=!0,ze($)},"confirmed"),this.connection.getSignatureStatus(v)};return F(),{txIds:[],signedTxs:K}}else{let N=[];for(let I=0;I<K.length;I+=1){let F=await this.connection.sendTransaction(K[I],{skipPreflight:B});N.push(F)}return{txIds:N,signedTxs:K}}}throw new Error("please provide owner in keypair format or signAllTransactions function")},extInfo:r||{}}}};import{PublicKey as bc}from"@solana/web3.js";import wc from"bn.js";import Kr from"bn.js";var hc=new Kr(1e6);import{AccountLayout as qi,createAssociatedTokenAccountIdempotentInstruction as Gi,TOKEN_2022_PROGRAM_ID as ut,TOKEN_PROGRAM_ID as Yt}from"@solana/spl-token";import{PublicKey as Hc}from"@solana/web3.js";import{MintLayout as jc,TOKEN_PROGRAM_ID as Zc}from"@solana/spl-token";var sn=i=>{var s=i,{address:b,programId:e,decimals:t}=s,n=lt(s,["address","programId","decimals"]);return O({chainId:101,address:mt(b).toBase58(),programId:e,logoURI:"",symbol:"",name:"",decimals:t,tags:[],extensions:n.extensions||{}},n)},Ln=b=>b?U(O({},b),{transferFeeConfigAuthority:b.transferFeeConfigAuthority.toBase58(),withdrawWithheldAuthority:b.withdrawWithheldAuthority.toBase58(),withheldAmount:b.withheldAmount.toString(),olderTransferFee:U(O({},b.olderTransferFee),{epoch:b.olderTransferFee.epoch.toString(),maximumFee:b.olderTransferFee.maximumFee.toString()}),newerTransferFee:U(O({},b.newerTransferFee),{epoch:b.newerTransferFee.epoch.toString(),maximumFee:b.newerTransferFee.maximumFee.toString()})}):void 0;var Rn=(...b)=>b.map(e=>{try{return typeof e=="object"?JSON.stringify(e):e}catch{return e}}).join(", "),Wt=class{constructor({scope:e,moduleName:t}){this.disabled=!1;this.scope=e,this.logger=Te(t)}createTxBuilder(e){return this.scope.checkOwner(),new Dt({connection:this.scope.connection,feePayer:e||this.scope.ownerPubKey,cluster:this.scope.cluster,owner:this.scope.owner,blockhashCommitment:this.scope.blockhashCommitment,loopMultiTxStatus:this.scope.loopMultiTxStatus,api:this.scope.api,signAllTransactions:this.scope.signAllTransactions})}createSniperTxBuilder(e,t){let n=new Ve(e);return new Dt({connection:this.scope.connection,feePayer:t,cluster:this.scope.cluster,owner:n,blockhashCommitment:this.scope.blockhashCommitment,loopMultiTxStatus:this.scope.loopMultiTxStatus,api:this.scope.api,signAllTransactions:this.scope.signAllTransactions})}logDebug(...e){this.logger.debug(Rn(e))}logInfo(...e){this.logger.info(Rn(e))}logAndCreateError(...e){let t=Rn(e);throw new Error(t)}checkDisabled(){(this.disabled||!this.scope)&&this.logAndCreateError("module not working")}};import{Keypair as dn,PublicKey as S,SystemProgram as nt,TransactionInstruction as he}from"@solana/web3.js";import Xn from"bn.js";import{ASSOCIATED_TOKEN_PROGRAM_ID as jt,TOKEN_2022_PROGRAM_ID as ye,TOKEN_PROGRAM_ID as ee}from"@solana/spl-token";import{PublicKey as _r}from"@solana/web3.js";import yi,{isBN as bi}from"bn.js";import{bits as cu,BitStructure as uu,blob as Cr,Blob as lu,cstr as mu,f32 as du,f32be as pu,f64 as fu,f64be as yu,greedy as bu,Layout as Lr,ns64 as gu,ns64be as wu,nu64 as Pu,nu64be as ku,offset as Tu,s16 as Au,s16be as hu,s24 as xu,s24be as Bu,s32 as Rr,s32be as Iu,s40 as Su,s40be as Ku,s48 as Cu,s48be as Lu,s8 as Ru,seq as Nr,struct as Nu,Structure as Mr,u16 as Or,u16be as Mu,u24 as Ou,u24be as Fu,u32 as Eu,u32be as _u,u40 as Du,u40be as Wu,u48 as vu,u48be as Vu,u8 as Fr,UInt as Er,union as qu,Union as Gu,unionLayoutDiscriminator as Uu,utf8 as Xu}from"@solana/buffer-layout";var Nn=Lr,di=Mr;var Mn=Er;var pi=Fr,vt=Or;var oe=Rr;var fi=Nr;var Re=Cr;var Tt=class extends Nn{constructor(t,n,i){super(t,i);this.blob=Re(t),this.signed=n}decode(t,n=0){let i=new yi(this.blob.decode(t,n),10,"le");return this.signed?i.fromTwos(this.span*8).clone():i}encode(t,n,i=0){return typeof t=="number"&&(t=new yi(t)),this.signed&&(t=t.toTwos(this.span*8)),this.blob.encode(t.toArrayLike(Buffer,"le",this.span),n,i)}};function fe(b){return new Mn(1,b)}function At(b){return new Mn(4,b)}function E(b){return new Tt(8,!1,b)}function X(b){return new Tt(16,!1,b)}function gi(b){return new Tt(8,!0,b)}function wi(b){return new Tt(16,!0,b)}var an=class extends Nn{constructor(t,n,i,s){super(t.span,s);this.layout=t,this.decoder=n,this.encoder=i}decode(t,n){return this.decoder(this.layout.decode(t,n))}encode(t,n,i){return this.layout.encode(this.encoder(t),n,i)}getSpan(t,n){return this.layout.getSpan(t,n)}};function te(b){return new an(Re(32),e=>new _r(e),e=>e.toBuffer(),b)}function Ie(b){return new an(pi(),Dr,Wr,b)}function Dr(b){if(b===0)return!1;if(b===1)return!0;throw new Error("Invalid bool: "+b)}function Wr(b){return b?1:0}var On=class extends di{decode(e,t){return super.decode(e,t)}};function J(b,e,t){return new On(b,e,t)}function le(b,e,t){let n,i=typeof e=="number"?e:bi(e)?e.toNumber():new Proxy(e,{get(s,r){if(!n){let o=Reflect.get(s,"count");n=bi(o)?o.toNumber():o,Reflect.set(s,"count",n)}return Reflect.get(s,r)},set(s,r,o){return r==="count"&&(n=o),Reflect.set(s,r,o)}});return fi(b,i,t)}import Zr from"bn.js";import Bt from"decimal.js";import Fe from"bn.js";var me=new Fe(0),qe=new Fe(1),et=new Fe(-1),Ne=new Fe(1).shln(64),cn=new Fe(1).shln(128),Fn=Ne.sub(qe),Vt=64,Pi=cn.subn(1),Be=-443636,Se=-Be,Ge=new Fe("4295048016"),Ue=new Fe("79226673521066979257578248091"),ol=new Fe("4295048017"),sl=new Fe("79226673521066979257578248090"),ki=16,Ti="59543866431248",Ai="184467440737095516",hi="15793534762490258745",un=new Fe(10).pow(new Fe(6));var xi={tvl:0,volumeQuote:0,mintAmountA:0,mintAmountB:0,rewardDefaultInfos:[],farmUpcomingCount:0,farmOngoingCount:0,farmFinishedCount:0,day:{volume:0,volumeQuote:0,volumeFee:0,apr:0,feeApr:0,priceMin:0,priceMax:0,rewardApr:[0]},week:{volume:0,volumeQuote:0,volumeFee:0,apr:0,feeApr:0,priceMin:0,priceMax:0,rewardApr:[0]},month:{volume:0,volumeQuote:0,volumeFee:0,apr:0,feeApr:0,priceMin:0,priceMax:0,rewardApr:[0]},pooltype:[]},al=new Fe("18446744073700000000");import G from"bn.js";import He from"decimal.js";function ln(b){let e=new ArrayBuffer(4);return new DataView(e).setInt32(0,b,!1),new Uint8Array(e)}function En(b,e){let t=0;for(let n=b-1;n>=0&&!e.testn(n);n--)t++;return t}function _n(b,e){let t=0;for(let n=0;n<b&&!e.testn(n);n++)t++;return t}function qt(b,e){for(let t=0;t<b;t++)if(e.testn(t))return!1;return!0}function Bi(b,e){return qt(b,e)?null:En(b,e)}function Ii(b,e){return qt(b,e)?null:_n(b,e)}var pl=Buffer.from("amm_config","utf8"),vr=Buffer.from("pool","utf8"),Vr=Buffer.from("pool_vault","utf8"),qr=Buffer.from("pool_reward_vault","utf8"),Si=Buffer.from("position","utf8"),Gr=Buffer.from("tick_array","utf8"),Ur=Buffer.from("operation","utf8"),Xr=Buffer.from("pool_tick_array_bitmap_extension","utf8"),Hr=Buffer.from("observation","utf8");function Ki(b,e,t,n){return xe([vr,e.toBuffer(),t.toBuffer(),n.toBuffer()],b)}function Dn(b,e,t){return xe([Vr,e.toBuffer(),t.toBuffer()],b)}function Ci(b,e,t){return xe([qr,e.toBuffer(),t.toBuffer()],b)}function H(b,e,t){return xe([Gr,e.toBuffer(),ln(t)],b)}function De(b,e,t,n){return xe([Si,e.toBuffer(),ln(t),ln(n)],b)}function Ke(b,e){return xe([Si,e.toBuffer()],b)}function Gt(b){return xe([Buffer.from("metadata","utf8"),dt.toBuffer(),b.toBuffer()],dt)}function Ut(b){return xe([Ur],b)}function ge(b,e){return xe([Xr,e.toBuffer()],b)}function Li(b,e){return xe([Hr,e.toBuffer()],b)}var Ri=Buffer.from("locked_position","utf8");function Wn(b,e){return xe([Ri,e.toBuffer()],b)}function ht(b,e){return xe([Ri,e.toBuffer()],b)}var zr=Buffer.from("support_mint","utf8");function vn(b,e){return xe([zr,e.toBuffer()],b)}import{PublicKey as Me}from"@solana/web3.js";import{TOKEN_2022_PROGRAM_ID as Ni}from"@solana/spl-token";import se from"bn.js";import j from"decimal.js";import Xe from"bn.js";import Vn from"decimal.js";var Xt=class{static getfeeGrowthInside(e,t,n){let i=new Xe(0),s=new Xe(0);e.tickCurrent>=t.tick?(i=t.feeGrowthOutsideX64A,s=t.feeGrowthOutsideX64B):(i=e.feeGrowthGlobalX64A.sub(t.feeGrowthOutsideX64A),s=e.feeGrowthGlobalX64B.sub(t.feeGrowthOutsideX64B));let r=new Xe(0),o=new Xe(0);e.tickCurrent<n.tick?(r=n.feeGrowthOutsideX64A,o=n.feeGrowthOutsideX64B):(r=e.feeGrowthGlobalX64A.sub(n.feeGrowthOutsideX64A),o=e.feeGrowthGlobalX64B.sub(n.feeGrowthOutsideX64B));let a=W.wrappingSubU128(W.wrappingSubU128(e.feeGrowthGlobalX64A,i),r),c=W.wrappingSubU128(W.wrappingSubU128(e.feeGrowthGlobalX64B,s),o);return{feeGrowthInsideX64A:a,feeGrowthInsideBX64:c}}static GetPositionFees(e,t,n,i){let{feeGrowthInsideX64A:s,feeGrowthInsideBX64:r}=this.getfeeGrowthInside(e,n,i),o=W.mulDivFloor(W.wrappingSubU128(s,t.feeGrowthInsideLastX64A),t.liquidity,Ne),a=t.tokenFeesOwedA.add(o),c=W.mulDivFloor(W.wrappingSubU128(r,t.feeGrowthInsideLastX64B),t.liquidity,Ne),l=t.tokenFeesOwedB.add(c);return{tokenFeeAmountA:a,tokenFeeAmountB:l}}static GetPositionFeesV2(e,t,n,i){let{feeGrowthInsideX64A:s,feeGrowthInsideBX64:r}=this.getfeeGrowthInside(e,n,i),o=W.mulDivFloor(W.wrappingSubU128(s,t.feeGrowthInsideLastX64A),t.liquidity,Ne),a=t.tokenFeesOwedA.add(o),c=W.mulDivFloor(W.wrappingSubU128(r,t.feeGrowthInsideLastX64B),t.liquidity,Ne),l=t.tokenFeesOwedB.add(c);return{tokenFeeAmountA:a,tokenFeeAmountB:l}}static GetPositionRewardsV2(e,t,n,i){let s=[],r=this.getRewardGrowthInsideV2(e.tickCurrent,n,i,e.rewardInfos);for(let o=0;o<r.length;o++){let a=r[o],c=t.rewardInfos[o],l=W.wrappingSubU128(a,c.growthInsideLastX64),d=W.mulDivFloor(l,t.liquidity,Ne),f=c.rewardAmountOwed.add(d);s.push(f)}return s}static GetPositionRewards(e,t,n,i){let s=[],r=this.getRewardGrowthInside(e.tickCurrent,n,i,e.rewardInfos);for(let o=0;o<r.length;o++){let a=r[o],c=t.rewardInfos[o],l=W.wrappingSubU128(a,c.growthInsideLastX64),d=W.mulDivFloor(l,t.liquidity,Ne),f=c.rewardAmountOwed.add(d);s.push(f)}return s}static getRewardGrowthInside(e,t,n,i){let s=[];for(let r=0;r<i.length;r++){let o=new Xe(0);t.liquidityGross.eqn(0)?o=i[r].rewardGrowthGlobalX64:e<t.tick?o=i[r].rewardGrowthGlobalX64.sub(t.rewardGrowthsOutsideX64[r]):o=t.rewardGrowthsOutsideX64[r];let a=new Xe(0);n.liquidityGross.eqn(0)||(e<n.tick?a=n.rewardGrowthsOutsideX64[r]:a=i[r].rewardGrowthGlobalX64.sub(n.rewardGrowthsOutsideX64[r])),s.push(W.wrappingSubU128(W.wrappingSubU128(i[r].rewardGrowthGlobalX64,o),a))}return s}static getRewardGrowthInsideV2(e,t,n,i){let s=[];for(let r=0;r<i.length;r++){let o=new Xe(0);t.liquidityGross.eqn(0)?o=i[r].rewardGrowthGlobalX64:e<t.tick?o=i[r].rewardGrowthGlobalX64.sub(t.rewardGrowthsOutsideX64[r]):o=t.rewardGrowthsOutsideX64[r];let a=new Xe(0);n.liquidityGross.eqn(0)||(e<n.tick?a=n.rewardGrowthsOutsideX64[r]:a=i[r].rewardGrowthGlobalX64.sub(n.rewardGrowthsOutsideX64[r])),s.push(W.wrappingSubU128(W.wrappingSubU128(i[r].rewardGrowthGlobalX64,o),a))}return s}static getAmountsFromLiquidity({poolInfo:e,ownerPosition:t,liquidity:n,slippage:i,add:s,epochInfo:r}){var y,g,P,A;let o=D.priceToSqrtPriceX64(new Vn(e.price),e.mintA.decimals,e.mintB.decimals),a=D.getSqrtPriceX64FromTick(t.tickLower),c=D.getSqrtPriceX64FromTick(t.tickUpper),l=s?1+i:1-i,d=Y.getAmountsFromLiquidity(o,a,c,n,s),[f,u]=[be(d.amountA,(y=e.mintA.extensions)==null?void 0:y.feeConfig,r,!0),be(d.amountB,(g=e.mintB.extensions)==null?void 0:g.feeConfig,r,!0)],[m,p]=[be(new Xe(new Vn(d.amountA.toString()).mul(l).toFixed(0)),(P=e.mintA.extensions)==null?void 0:P.feeConfig,r,!0),be(new Xe(new Vn(d.amountB.toString()).mul(l).toFixed(0)),(A=e.mintB.extensions)==null?void 0:A.feeConfig,r,!0)];return{liquidity:n,amountA:f,amountB:u,amountSlippageA:m,amountSlippageB:p,expirationTime:at(f.expirationTime,u.expirationTime)}}};var jr=15,z=class{static async getTickArrays(e,t,n,i,s,r,o){let a=[],c=M.getTickArrayStartIndexByTick(i,s),l=M.getInitializedTickArrayInRange(r,o,s,c,Math.floor(jr/2));for(let u=0;u<l.length;u++){let{publicKey:m}=H(t,n,l[u]);a.push(m)}let d=(await je(e,a)).map(u=>u!==null?Ht.decode(u.data):null),f={};for(let u=0;u<a.length;u++){let m=d[u];m!==null&&(f[m.startTickIndex]=U(O({},m),{address:a[u]}))}return f}static nextInitializedTick(e,t,n,i,s,r){let{initializedTick:o,tickArrayAddress:a,tickArrayStartTickIndex:c}=this.nextInitializedTickInOneArray(e,t,n,i,s,r);for(;o==null||o.liquidityGross.lten(0);){if(c=M.getNextTickArrayStartIndex(c,s,r),this.checkIsValidStartIndex(c,s))throw new Error("No enough initialized tickArray");let l=n[c];if(l===void 0)continue;let{nextTick:d,tickArrayAddress:f,tickArrayStartTickIndex:u}=this.firstInitializedTickInOneArray(e,t,l,r);[o,a,c]=[d,f,u]}if(o==null)throw new Error("No invaild tickArray cache");return{nextTick:o,tickArrayAddress:a,tickArrayStartTickIndex:c}}static nextInitializedTickArray(e,t,n,i,s){let r=Math.floor(e/z.tickCount(t)),o=n?M.searchLowBitFromStart(i,s,r-1,1,t):M.searchHightBitFromStart(i,s,r+1,1,t);return o.length>0?{isExist:!0,nextStartIndex:o[0]}:{isExist:!1,nextStartIndex:0}}static firstInitializedTickInOneArray(e,t,n,i){let s;if(i){let o=we-1;for(;o>=0;){let a=n.ticks[o];if(a.liquidityGross.gtn(0)){s=a;break}o=o-1}}else{let o=0;for(;o<we;){let a=n.ticks[o];if(a.liquidityGross.gtn(0)){s=a;break}o=o+1}}let{publicKey:r}=H(e,t,n.startTickIndex);return{nextTick:s,tickArrayAddress:r,tickArrayStartTickIndex:n.startTickIndex}}static nextInitializedTickInOneArray(e,t,n,i,s,r){let o=M.getTickArrayStartIndexByTick(i,s),a=Math.floor((i-o)/s),c=n[o];if(c==null)return{initializedTick:void 0,tickArrayAddress:void 0,tickArrayStartTickIndex:o};let l;if(r)for(;a>=0;){let f=c.ticks[a];if(f.liquidityGross.gtn(0)){l=f;break}a=a-1}else for(a=a+1;a<we;){let f=c.ticks[a];if(f.liquidityGross.gtn(0)){l=f;break}a=a+1}let{publicKey:d}=H(e,t,o);return{initializedTick:l,tickArrayAddress:d,tickArrayStartTickIndex:c.startTickIndex}}static getArrayStartIndex(e,t){let n=this.tickCount(t);return Math.floor(e/n)*n}static checkIsValidStartIndex(e,t){if(M.checkIsOutOfBoundary(e)){if(e>Se)return!1;let n=M.getTickArrayStartIndexByTick(Be,t);return e==n}return e%this.tickCount(t)==0}static tickCount(e){return we*e}};var qn=14,tt=class{static maxTickInTickarrayBitmap(e){return e*we*yt}static getBitmapTickBoundary(e,t){let n=this.maxTickInTickarrayBitmap(t),i=Math.floor(Math.abs(e)/n);e<0&&Math.abs(e)%n!=0&&(i+=1);let s=n*i;return e<0?{minValue:-s,maxValue:-s+n}:{minValue:s,maxValue:s+n}}static nextInitializedTickArrayStartIndex(e,t,n,i){if(!z.checkIsValidStartIndex(t,n))throw Error("nextInitializedTickArrayStartIndex check error");let s=this.maxTickInTickarrayBitmap(n),r=i?t-z.tickCount(n):t+z.tickCount(n);if(r<-s||r>=s)return{isInit:!1,tickIndex:t};let o=n*we,a=r/o+512;r<0&&r%o!=0&&a--;let c=Math.abs(a);if(i){let l=e.shln(1024-c-1),d=Bi(1024,l);if(d!==null){let f=(c-d-512)*o;return{isInit:!0,tickIndex:f}}else return{isInit:!1,tickIndex:-s}}else{let l=e.shrn(c),d=Ii(1024,l);if(d!==null){let f=(c+d-512)*o;return{isInit:!0,tickIndex:f}}else return{isInit:!1,tickIndex:s-z.tickCount(n)}}}},zt=class{static getBitmapOffset(e,t){if(!z.checkIsValidStartIndex(e,t))throw new Error("No enough initialized tickArray");this.checkExtensionBoundary(e,t);let n=tt.maxTickInTickarrayBitmap(t),i=Math.floor(Math.abs(e)/n)-1;return e<0&&Math.abs(e)%n===0&&i--,i}static getBitmap(e,t,n){let i=this.getBitmapOffset(e,t);return e<0?{offset:i,tickarrayBitmap:n.negativeTickArrayBitmap[i]}:{offset:i,tickarrayBitmap:n.positiveTickArrayBitmap[i]}}static checkExtensionBoundary(e,t){let{positiveTickBoundary:n,negativeTickBoundary:i}=this.extensionTickBoundary(t);if(e>=i&&e<n)throw Error("checkExtensionBoundary -> InvalidTickArrayBoundary")}static extensionTickBoundary(e){let t=tt.maxTickInTickarrayBitmap(e),n=-t;if(Se<=t)throw Error(`extensionTickBoundary check error: ${Se}, ${t}`);if(n<=Be)throw Error(`extensionTickBoundary check error: ${n}, ${Be}`);return{positiveTickBoundary:t,negativeTickBoundary:n}}static checkTickArrayIsInit(e,t,n){let{tickarrayBitmap:i}=this.getBitmap(e,t,n),s=this.tickArrayOffsetInBitmap(e,t);return{isInitialized:M.mergeTickArrayBitmap(i).testn(s),startIndex:e}}static nextInitializedTickArrayFromOneBitmap(e,t,n,i){let s=z.tickCount(t),r=n?e-s:e+s,{tickarrayBitmap:o}=this.getBitmap(r,t,i);return this.nextInitializedTickArrayInBitmap(o,r,t,n)}static nextInitializedTickArrayInBitmap(e,t,n,i){let{minValue:s,maxValue:r}=tt.getBitmapTickBoundary(t,n),o=this.tickArrayOffsetInBitmap(t,n);if(i){let a=M.mergeTickArrayBitmap(e).shln(yt-1-o),c=qt(512,a)?null:En(512,a);if(c!==null){let l=t-c*z.tickCount(n);return{isInit:!0,tickIndex:l}}else return{isInit:!1,tickIndex:s}}else{let a=M.mergeTickArrayBitmap(e).shrn(o),c=qt(512,a)?null:_n(512,a);if(c!==null){let l=t+c*z.tickCount(n);return{isInit:!0,tickIndex:l}}else return{isInit:!1,tickIndex:r-z.tickCount(n)}}}static tickArrayOffsetInBitmap(e,t){let n=Math.abs(e)%tt.maxTickInTickarrayBitmap(t),i=Math.floor(n/z.tickCount(t));return e<0&&n!=0&&(i=yt-i),i}};var de=class{static getOutputAmountAndRemainAccounts(e,t,n,i,s,r=!1){let o=n.toBase58()===e.mintA.address,a=[],{isExist:c,startIndex:l,nextAccountMeta:d}=this.getFirstInitializedTickArray(e,o);if(!c||l===void 0||!d)throw new Error("Invalid tick array");a.push(d);let{allTrade:f,amountCalculated:u,accounts:m,sqrtPriceX64:p,feeAmount:y}=bt.swapCompute(e.programId,e.id,t,e.tickArrayBitmap,e.exBitmapInfo,o,e.ammConfig.tradeFeeRate,e.liquidity,e.tickCurrent,e.tickSpacing,e.sqrtPriceX64,i,l,s,r);return a.push(...m),{allTrade:f,expectedAmountOut:u.mul(et),remainingAccounts:a,executionPrice:p,feeAmount:y}}static getInputAmountAndRemainAccounts(e,t,n,i,s){let r=n.toBase58()===e.mintB.address,o=[],{isExist:a,startIndex:c,nextAccountMeta:l}=this.getFirstInitializedTickArray(e,r);if(!a||c===void 0||!l)throw new Error("Invalid tick array");try{let p=this.preInitializedTickArrayStartIndex(e,r);if(p.isExist){let{publicKey:y}=H(e.programId,e.id,p.nextStartIndex);o.push(y)}}catch{}o.push(l);let{amountCalculated:d,accounts:f,sqrtPriceX64:u,feeAmount:m}=bt.swapCompute(e.programId,e.id,t,e.tickArrayBitmap,e.exBitmapInfo,r,e.ammConfig.tradeFeeRate,e.liquidity,e.tickCurrent,e.tickSpacing,e.sqrtPriceX64,i.mul(et),c,s);return o.push(...f),{expectedAmountIn:d,remainingAccounts:o,executionPrice:u,feeAmount:m}}static getFirstInitializedTickArray(e,t){let{isInitialized:n,startIndex:i}=de.isOverflowDefaultTickarrayBitmap(e.tickSpacing,[e.tickCurrent])?zt.checkTickArrayIsInit(z.getArrayStartIndex(e.tickCurrent,e.tickSpacing),e.tickSpacing,e.exBitmapInfo):M.checkTickArrayIsInitialized(M.mergeTickArrayBitmap(e.tickArrayBitmap),e.tickCurrent,e.tickSpacing);if(n){let{publicKey:o}=H(e.programId,e.id,i);return{isExist:!0,startIndex:i,nextAccountMeta:o}}let{isExist:s,nextStartIndex:r}=this.nextInitializedTickArrayStartIndex(e,z.getArrayStartIndex(e.tickCurrent,e.tickSpacing),t);if(s){let{publicKey:o}=H(e.programId,e.id,r);return{isExist:!0,startIndex:r,nextAccountMeta:o}}return{isExist:!1,nextAccountMeta:void 0,startIndex:void 0}}static preInitializedTickArrayStartIndex(e,t){let n=Math.floor(e.tickCurrent/z.tickCount(e.tickSpacing)),i=t?M.searchHightBitFromStart(e.tickArrayBitmap,e.exBitmapInfo,n+1,1,e.tickSpacing):M.searchLowBitFromStart(e.tickArrayBitmap,e.exBitmapInfo,n-1,1,e.tickSpacing);return i.length>0?{isExist:!0,nextStartIndex:i[0]}:{isExist:!1,nextStartIndex:0}}static nextInitializedTickArrayStartIndex(e,t,n){for(t=z.getArrayStartIndex(e.tickCurrent,e.tickSpacing);;){let{isInit:i,tickIndex:s}=tt.nextInitializedTickArrayStartIndex(M.mergeTickArrayBitmap(e.tickArrayBitmap),t,e.tickSpacing,n);if(i)return{isExist:!0,nextStartIndex:s};t=s;let{isInit:r,tickIndex:o}=zt.nextInitializedTickArrayFromOneBitmap(t,e.tickSpacing,n,e.exBitmapInfo);if(r)return{isExist:!0,nextStartIndex:o};if(t=o,t<Be||t>Se)return{isExist:!1,nextStartIndex:0}}}static async updatePoolRewardInfos({connection:e,apiPoolInfo:t,chainTime:n,poolLiquidity:i,rewardInfos:s}){var o,a,c;let r=[];for(let l=0;l<s.length;l++){let d=s[l],f=(c=(o=t.rewardDefaultInfos[l])==null?void 0:o.mint.programId)!=null?c:(a=await e.getAccountInfo(d.tokenMint))==null?void 0:a.owner;if(f===void 0)throw Error("get new reward mint info error");let u=U(O({},d),{perSecond:W.x64ToDecimal(d.emissionsPerSecondX64),remainingRewards:void 0,tokenProgramId:new Me(f)});if(u.tokenMint.equals(Me.default))continue;if(n<=u.openTime.toNumber()||i.eq(me)){r.push(u);continue}let m=new se(Math.min(u.endTime.toNumber(),n)),p=m.sub(u.lastUpdateTime),y=W.mulDivFloor(p,u.emissionsPerSecondX64,i),g=u.rewardGrowthGlobalX64.add(y),P=W.mulDivFloor(p,u.emissionsPerSecondX64,Ne),A=u.rewardTotalEmissioned.add(P);r.push(U(O({},u),{rewardGrowthGlobalX64:g,rewardTotalEmissioned:A,lastUpdateTime:m}))}return r}static isOverflowDefaultTickarrayBitmap(e,t){let{maxTickBoundary:n,minTickBoundary:i}=this.tickRange(e);for(let s of t){let r=M.getTickArrayStartIndexByTick(s,e);if(r>=n||r<i)return!0}return!1}static tickRange(e){let t=tt.maxTickInTickarrayBitmap(e),n=-t;return t>Se&&(t=z.getArrayStartIndex(Se,e)+z.tickCount(e)),n<Be&&(n=z.getArrayStartIndex(Be,e)),{maxTickBoundary:t,minTickBoundary:n}}static get_tick_array_offset(e,t){if(!z.checkIsValidStartIndex(e,t))throw new Error("No enough initialized tickArray");return e/z.tickCount(t)*yt}static async fetchExBitmaps({connection:e,exBitmapAddress:t,batchRequest:n}){let i=await Ye(e,t.map(r=>({pubkey:r})),{batchRequest:n}),s={};for(let r of i)r.accountInfo!==null&&(s[r.pubkey.toString()]=Oi.decode(r.accountInfo.data));return s}static async fetchMultiplePoolTickArrays({connection:e,poolKeys:t,batchRequest:n}){let i={},s=[];for(let a of t){let c=M.getTickArrayStartIndexByTick(a.tickCurrent,a.tickSpacing),l=M.getInitializedTickArrayInRange(a.tickArrayBitmap,a.exBitmapInfo,a.tickSpacing,c,7);for(let d of l){let{publicKey:f}=H(a.programId,a.id,d);s.push({pubkey:f}),i[f.toString()]=a.id}}let r=await Ye(e,s,{batchRequest:n}),o={};for(let a of r){if(!a.accountInfo)continue;let c=i[a.pubkey.toString()];if(!c)continue;o[c.toString()]===void 0&&(o[c.toString()]={});let l=Ht.decode(a.accountInfo.data);o[c.toString()][l.startTickIndex]=U(O({},l),{address:a.pubkey})}return o}static async fetchPoolsAccountPosition({pools:e,connection:t,ownerInfo:n,batchRequest:i=!1,updateOwnerRewardAndFee:s=!0}){var o;let r=[];for(let a=0;a<e.length;a++){let c=e[a];c!==null&&(r.find(l=>l.equals(c.state.programId))||r.push(c.state.programId))}if(n){let a=n.tokenAccounts.map(f=>f.accountInfo.mint),c=[];for(let f of a)for(let u of r)c.push(Ke(u,f).publicKey);let l=await je(t,c,{batchRequest:i}),d={};for(let f of l){if(f===null)continue;let u=xt.decode(f.data),m=u.poolId.toString(),p=e.find(h=>h.state.id.toBase58()===m);if(p===void 0)continue;let y=p.state,g=M._getTickPriceLegacy({poolInfo:y,tick:u.tickLower,baseIn:!0}),P=M._getTickPriceLegacy({poolInfo:y,tick:u.tickUpper,baseIn:!0}),{amountA:A,amountB:T}=Y.getAmountsFromLiquidity(y.sqrtPriceX64,g.tickSqrtPriceX64,P.tickSqrtPriceX64,u.liquidity,!1),k=1/(1-Math.sqrt(Math.sqrt(g.price.div(P.price).toNumber())));p.positionAccount=[...(o=p.positionAccount)!=null?o:[],{poolId:u.poolId,nftMint:u.nftMint,priceLower:g.price,priceUpper:P.price,amountA:A,amountB:T,tickLower:u.tickLower,tickUpper:u.tickUpper,liquidity:u.liquidity,feeGrowthInsideLastX64A:u.feeGrowthInsideLastX64A,feeGrowthInsideLastX64B:u.feeGrowthInsideLastX64B,tokenFeesOwedA:u.tokenFeesOwedA,tokenFeesOwedB:u.tokenFeesOwedB,rewardInfos:u.rewardInfos.map(h=>U(O({},h),{pendingReward:new se(0)})),leverage:k,tokenFeeAmountA:new se(0),tokenFeeAmountB:new se(0)}];let w=await M.getTickArrayAddressByTick(p.state.programId,u.poolId,u.tickLower,p.state.tickSpacing),x=await M.getTickArrayAddressByTick(p.state.programId,u.poolId,u.tickUpper,p.state.tickSpacing);d[`${p.state.programId.toString()}-${u.poolId.toString()}-${u.tickLower}`]=w,d[`${p.state.programId.toString()}-${u.poolId.toString()}-${u.tickUpper}`]=x}if(s){let f=Object.values(d),u=await je(t,f,{batchRequest:i}),m={};for(let p=0;p<f.length;p++){let y=u[p];if(y===null)continue;let g=f[p].toString();m[g]=Ht.decode(y.data)}for(let{state:p,positionAccount:y}of e)if(!!y)for(let g of y){let P=`${p.programId.toString()}-${p.id.toString()}-${g.tickLower}`,A=`${p.programId.toString()}-${p.id.toString()}-${g.tickUpper}`,T=m[d[P].toString()],k=m[d[A].toString()],w=T.ticks[M.getTickOffsetInArray(g.tickLower,p.tickSpacing)],x=k.ticks[M.getTickOffsetInArray(g.tickUpper,p.tickSpacing)],{tokenFeeAmountA:h,tokenFeeAmountB:B}=await Xt.GetPositionFees(p,g,w,x),C=await Xt.GetPositionRewards(p,g,w,x);g.tokenFeeAmountA=h.gte(new se(0))?h:new se(0),g.tokenFeeAmountB=B.gte(new se(0))?B:new se(0);for(let L=0;L<C.length;L++)g.rewardInfos[L].pendingReward=C[L].gte(new se(0))?C[L]:new se(0)}}}return e}static computeAmountOut({poolInfo:e,tickArrayCache:t,baseMint:n,epochInfo:i,amountIn:s,slippage:r,priceLimit:o=new j(0),catchLiquidityInsufficient:a=!1}){var K;let c,l=n.toBase58()===e.mintA.address,[d,f]=l?[e.mintA.extensions.feeConfig,e.mintB.extensions.feeConfig]:[e.mintB.extensions.feeConfig,e.mintA.extensions.feeConfig];o.equals(new j(0))?c=l?Ge.add(new se(1)):Ue.sub(new se(1)):c=D.priceToSqrtPriceX64(o,e.mintA.decimals,e.mintB.decimals);let u=be(s,d,i,!1),{allTrade:m,expectedAmountOut:p,remainingAccounts:y,executionPrice:g,feeAmount:P}=de.getOutputAmountAndRemainAccounts(e,t,n,u.amount.sub((K=u.fee)!=null?K:me),c,a),A=be(p,f,i,!1),T=D.sqrtPriceX64ToPrice(g,e.mintA.decimals,e.mintB.decimals),k=l?T:new j(1).div(T),w=p.mul(new se(Math.floor((1-r)*1e10))).div(new se(1e10)),x=be(w,f,i,!1),h=l?e.currentPrice:new j(1).div(e.currentPrice),B=new j(k).sub(h).abs(),C=h,L=new ot(new j(B).mul(10**15).toFixed(0),new j(C).mul(10**15).toFixed(0));return{allTrade:m,realAmountIn:u,amountOut:A,minAmountOut:x,expirationTime:at(u.expirationTime,A.expirationTime),currentPrice:e.currentPrice,executionPrice:k,priceImpact:L,fee:P,remainingAccounts:y,executionPriceX64:g}}static computeAmountOutFormat({poolInfo:e,tickArrayCache:t,amountIn:n,tokenOut:i,slippage:s,epochInfo:r,catchLiquidityInsufficient:o=!1}){let a=i.address===e.mintB.address,[c,l]=a?[e.mintA,e.mintB]:[e.mintB,e.mintA],[d,f]=[new ve(U(O({},c),{mint:c.address,isToken2022:c.programId===Ni.toBase58()})),new ve(U(O({},l),{mint:l.address,isToken2022:l.programId===Ni.toBase58()}))],{allTrade:u,realAmountIn:m,amountOut:p,minAmountOut:y,expirationTime:g,currentPrice:P,executionPrice:A,priceImpact:T,fee:k,remainingAccounts:w,executionPriceX64:x}=de.computeAmountOut({poolInfo:e,tickArrayCache:t,baseMint:new Me(c.address),amountIn:n,slippage:s,epochInfo:r,catchLiquidityInsufficient:o}),h=U(O({},m),{amount:new Ae(d,m.amount),fee:m.fee===void 0?void 0:new Ae(d,m.fee)}),B=U(O({},p),{amount:new Ae(f,p.amount),fee:p.fee===void 0?void 0:new Ae(f,p.fee)}),C=U(O({},y),{amount:new Ae(f,y.amount),fee:y.fee===void 0?void 0:new Ae(f,y.fee)}),L=new Ee({baseToken:d,denominator:new se(10).pow(new se(20+d.decimals)),quoteToken:f,numerator:P.mul(new j(10**(20+f.decimals))).toFixed(0)}),K=new Ee({baseToken:d,denominator:new se(10).pow(new se(20+d.decimals)),quoteToken:f,numerator:A.mul(new j(10**(20+f.decimals))).toFixed(0)}),N=new Ae(d,k);return{allTrade:u,realAmountIn:h,amountOut:B,minAmountOut:C,expirationTime:g,currentPrice:L,executionPrice:K,priceImpact:T,fee:N,remainingAccounts:w,executionPriceX64:x}}static computeAmountIn({poolInfo:e,tickArrayCache:t,baseMint:n,epochInfo:i,amountOut:s,slippage:r,priceLimit:o=new j(0)}){var C;let a=n.toBase58()===e.mintA.address,c={[e.mintA.address]:e.mintA.extensions.feeConfig,[e.mintB.address]:e.mintB.extensions.feeConfig},l;o.equals(new j(0))?l=a?Ue.sub(new se(1)):Ge.add(new se(1)):l=D.priceToSqrtPriceX64(o,e.mintA.decimals,e.mintB.decimals);let d=be(s,c[n.toString()],i,!0),{expectedAmountIn:f,remainingAccounts:u,executionPrice:m,feeAmount:p}=de.getInputAmountAndRemainAccounts(e,t,n,d.amount.sub((C=d.fee)!=null?C:me),l),y=a?e.mintB.address:e.mintA.address,g=be(f,c[y],i,!1),P=D.sqrtPriceX64ToPrice(m,e.mintA.decimals,e.mintB.decimals),A=a?P:new j(1).div(P),T=f.mul(new se(Math.floor((1+r)*1e10))).div(new se(1e10)),k=be(T,c[y],i,!0),w=a?e.currentPrice:new j(1).div(e.currentPrice),x=new j(A).sub(w).abs(),h=w,B=new ot(new j(x).mul(10**15).toFixed(0),new j(h).mul(10**15).toFixed(0));return{amountIn:g,maxAmountIn:k,realAmountOut:d,expirationTime:at(g.expirationTime,d.expirationTime),currentPrice:e.currentPrice,executionPrice:A,priceImpact:B,fee:p,remainingAccounts:u}}static estimateAprsForPriceRangeMultiplier({poolInfo:e,aprType:t,positionTickLowerIndex:n,positionTickUpperIndex:i}){var m,p,y;let s=e[t],r=M.getTickPrice({poolInfo:e,tick:n,baseIn:!0}).price.toNumber(),o=M.getTickPrice({poolInfo:e,tick:i,baseIn:!0}).price.toNumber(),a=Math.max(r,s.priceMin),l=Math.min(o,s.priceMax)-a,d=o-r,f=s.priceMax-s.priceMin,u;return l<=0?u=0:d===l?u=f/l:f===l?u=l/d:u=l/f*(l/d),{feeApr:s.feeApr*u,rewardsApr:[((m=s.rewardApr[0])!=null?m:0)*u,((p=s.rewardApr[1])!=null?p:0)*u,((y=s.rewardApr[2])!=null?y:0)*u],apr:s.apr*u}}static estimateAprsForPriceRangeDelta({poolInfo:e,poolLiquidity:t,aprType:n,mintPrice:i,liquidity:s,positionTickLowerIndex:r,positionTickUpperIndex:o,chainTime:a}){let c=n==="day"?1:n==="week"?7:n==="month"?30:0,l=e[n],d=i[mt(e.mintA.address).toString()],f=i[mt(e.mintB.address).toString()],u=e.mintA.decimals,m=e.mintB.decimals;if(!l||!d||!f)return{feeApr:0,rewardsApr:[0,0,0],apr:0};let p=D.priceToSqrtPriceX64(new j(e.price),e.mintA.decimals,e.mintB.decimals),y=D.getSqrtPriceX64FromTick(r),g=D.getSqrtPriceX64FromTick(o),{amountSlippageA:P,amountSlippageB:A}=Y.getAmountsFromLiquidityWithSlippage(p,y,g,t,!1,!1,0),{amountSlippageA:T,amountSlippageB:k}=Y.getAmountsFromLiquidityWithSlippage(p,y,g,s,!1,!1,0),w=new j(P.toString()).div(new j(10).pow(u)).mul(d.value).add(new j(A.toString()).div(new j(10).pow(m)).mul(f.value)),x=new j(T.toString()).div(new j(10).pow(u)).mul(d.value).add(new j(k.toString()).div(new j(10).pow(m)).mul(f.value)),h=new j(1).div(w.add(x)),C=new j(l.volumeFee).mul(365).div(c).mul(h).mul(100).toNumber(),L=3600*24*365,K=e.rewardDefaultInfos.map(N=>{var v,ce;let I=N.mint.decimals,F=i[N.mint.address];return a<((v=N.startTime)!=null?v:0)||a>((ce=N.endTime)!=null?ce:0)||!N.perSecond||!F||I===void 0?0:new j(F.value).mul(new j(N.perSecond).mul(L)).div(new j(10).pow(I)).mul(h).mul(100).toNumber()});return{feeApr:C,rewardsApr:K,apr:C+K.reduce((N,I)=>N+I,0)}}static async getLiquidityAmountOutFromAmountIn({poolInfo:e,inputA:t,tickLower:n,tickUpper:i,amount:s,slippage:r,add:o,epochInfo:a,amountHasFee:c}){var g,P;let l=D.priceToSqrtPriceX64(new j(e.price),e.mintA.decimals,e.mintB.decimals),d=D.getSqrtPriceX64FromTick(n),f=D.getSqrtPriceX64FromTick(i),u=be(s,(g=e[t?"mintA":"mintB"].extensions)==null?void 0:g.feeConfig,a,!c),m=new se(new j(u.amount.sub((P=u.fee)!=null?P:me).toString()).toFixed(0)),p;if(l.lte(d))p=t?Y.getLiquidityFromTokenAmountA(d,f,m,!o):new se(0);else if(l.lte(f)){let A=Y.getLiquidityFromTokenAmountA(l,f,m,!o),T=Y.getLiquidityFromTokenAmountB(d,l,m);p=t?A:T}else p=t?new se(0):Y.getLiquidityFromTokenAmountB(d,f,m);let y=await de.getAmountsFromLiquidity({epochInfo:a,poolInfo:e,tickLower:n,tickUpper:i,liquidity:p,slippage:r,add:o});return{liquidity:p,amountA:t?u:y.amountA,amountB:t?y.amountB:u,amountSlippageA:t?u:y.amountSlippageA,amountSlippageB:t?y.amountSlippageB:u,expirationTime:y.expirationTime}}static async getAmountsFromLiquidity({epochInfo:e,poolInfo:t,tickLower:n,tickUpper:i,liquidity:s,slippage:r,add:o}){var y,g,P,A;let a=D.getSqrtPriceX64FromTick(n),c=D.getSqrtPriceX64FromTick(i),l=o?1+r:1-r,d=Y.getAmountsFromLiquidity(D.priceToSqrtPriceX64(new j(t.price),t.mintA.decimals,t.mintB.decimals),a,c,s,o),[f,u]=[be(d.amountA,(y=t.mintA.extensions)==null?void 0:y.feeConfig,e,!0),be(d.amountB,(g=t.mintB.extensions)==null?void 0:g.feeConfig,e,!0)],[m,p]=[be(d.amountA.muln(l),(P=t.mintA.extensions)==null?void 0:P.feeConfig,e,!0),be(d.amountB.muln(l),(A=t.mintB.extensions)==null?void 0:A.feeConfig,e,!0)];return{liquidity:s,amountA:f,amountB:u,amountSlippageA:m,amountSlippageB:p,expirationTime:at(f.expirationTime,u.expirationTime)}}static async fetchComputeMultipleClmmInfo({connection:e,poolList:t,rpcDataMap:n={}}){let i=t.filter(a=>!n[a.id]).map(a=>new Me(a.id));(await je(e,i)).forEach((a,c)=>{!a||(n[i[c].toBase58()]=mn.decode(a.data))});let r=t.map(a=>ge(new Me(a.programId),new Me(a.id)).publicKey),o=await de.fetchExBitmaps({connection:e,exBitmapAddress:r,batchRequest:!1});return t.reduce((a,c)=>U(O({},a),{[c.id]:U(O({},n[c.id]),{id:new Me(c.id),version:6,programId:new Me(c.programId),mintA:c.mintA,mintB:c.mintB,ammConfig:U(O({},c.config),{id:new Me(c.config.id),fundOwner:""}),currentPrice:new j(c.price),exBitmapAccount:ge(new Me(c.programId),new Me(c.id)).publicKey,exBitmapInfo:o[ge(new Me(c.programId),new Me(c.id)).publicKey.toBase58()],startTime:n[c.id].startTime.toNumber(),rewardInfos:n[c.id].rewardInfos})}),{})}static async fetchComputeClmmInfo({connection:e,poolInfo:t,rpcData:n}){return(await this.fetchComputeMultipleClmmInfo({connection:e,rpcDataMap:n?{[t.id]:n}:void 0,poolList:[t]}))[t.id]}};var Gn={volume:0,volumeQuote:0,volumeFee:0,apr:0,feeApr:0,priceMin:0,priceMax:0,rewardApr:[]};function Mi(b){return U(O({},b),{type:"Concentrated",programId:b.programId.toString(),id:b.id.toString(),rewardDefaultInfos:[],rewardDefaultPoolInfos:"Clmm",price:b.currentPrice.toNumber(),mintAmountA:0,mintAmountB:0,feeRate:b.ammConfig.tradeFeeRate,openTime:b.startTime.toString(),tvl:0,day:Gn,week:Gn,month:Gn,pooltype:[],farmUpcomingCount:0,farmOngoingCount:0,farmFinishedCount:0,burnPercent:0,config:U(O({},b.ammConfig),{id:b.ammConfig.id.toString(),defaultRange:0,defaultRangePoint:[]})})}var W=class{static mulDivRoundingUp(e,t,n){let i=e.mul(t),s=i.div(n);return i.mod(n).eq(me)||(s=s.add(qe)),s}static mulDivFloor(e,t,n){if(n.eq(me))throw new Error("division by 0");return e.mul(t).div(n)}static mulDivCeil(e,t,n){if(n.eq(me))throw new Error("division by 0");return e.mul(t).add(n.sub(qe)).div(n)}static x64ToDecimal(e,t){return new He(e.toString()).div(He.pow(2,64)).toDecimalPlaces(t)}static decimalToX64(e){return new G(e.mul(He.pow(2,64)).floor().toFixed())}static wrappingSubU128(e,t){return e.add(cn).sub(t).mod(cn)}};function ke(b,e){return Un(b.mul(e),64,256)}function Yr(b,e,t){let n=b.toTwos(t).shln(e);return n.imaskn(t+1),n.fromTwos(t)}function Un(b,e,t){let n=b.toTwos(t).shrn(e);return n.imaskn(t-e+1),n.fromTwos(t-e)}var D=class{static sqrtPriceX64ToPrice(e,t,n){return W.x64ToDecimal(e).pow(2).mul(He.pow(10,t-n))}static priceToSqrtPriceX64(e,t,n){return W.decimalToX64(e.mul(He.pow(10,n-t)).sqrt())}static getNextSqrtPriceX64FromInput(e,t,n,i){if(!e.gt(me))throw new Error("sqrtPriceX64 must greater than 0");if(!t.gt(me))throw new Error("liquidity must greater than 0");return i?this.getNextSqrtPriceFromTokenAmountARoundingUp(e,t,n,!0):this.getNextSqrtPriceFromTokenAmountBRoundingDown(e,t,n,!0)}static getNextSqrtPriceX64FromOutput(e,t,n,i){if(!e.gt(me))throw new Error("sqrtPriceX64 must greater than 0");if(!t.gt(me))throw new Error("liquidity must greater than 0");return i?this.getNextSqrtPriceFromTokenAmountBRoundingDown(e,t,n,!1):this.getNextSqrtPriceFromTokenAmountARoundingUp(e,t,n,!1)}static getNextSqrtPriceFromTokenAmountARoundingUp(e,t,n,i){if(n.eq(me))return e;let s=t.shln(Vt);if(i){let r=s,o=s.add(n.mul(e));return o.gte(r)?W.mulDivCeil(r,e,o):W.mulDivRoundingUp(r,qe,r.div(e).add(n))}else{let r=n.mul(e);if(!s.gt(r))throw new Error("getNextSqrtPriceFromTokenAmountARoundingUp,liquidityLeftShift must gt amountMulSqrtPrice");let o=s.sub(r);return W.mulDivCeil(s,e,o)}}static getNextSqrtPriceFromTokenAmountBRoundingDown(e,t,n,i){let s=n.shln(Vt);if(i)return e.add(s.div(t));{let r=W.mulDivRoundingUp(s,qe,t);if(!e.gt(r))throw new Error("getNextSqrtPriceFromTokenAmountBRoundingDown sqrtPriceX64 must gt amountDivLiquidity");return e.sub(r)}}static getSqrtPriceX64FromTick(e){if(!Number.isInteger(e))throw new Error("tick must be integer");if(e<Be||e>Se)throw new Error("tick must be in MIN_TICK and MAX_TICK");let t=e<0?e*-1:e,n=(t&1)!=0?new G("18445821805675395072"):new G("18446744073709551616");return(t&2)!=0&&(n=ke(n,new G("18444899583751176192"))),(t&4)!=0&&(n=ke(n,new G("18443055278223355904"))),(t&8)!=0&&(n=ke(n,new G("18439367220385607680"))),(t&16)!=0&&(n=ke(n,new G("18431993317065453568"))),(t&32)!=0&&(n=ke(n,new G("18417254355718170624"))),(t&64)!=0&&(n=ke(n,new G("18387811781193609216"))),(t&128)!=0&&(n=ke(n,new G("18329067761203558400"))),(t&256)!=0&&(n=ke(n,new G("18212142134806163456"))),(t&512)!=0&&(n=ke(n,new G("17980523815641700352"))),(t&1024)!=0&&(n=ke(n,new G("17526086738831433728"))),(t&2048)!=0&&(n=ke(n,new G("16651378430235570176"))),(t&4096)!=0&&(n=ke(n,new G("15030750278694412288"))),(t&8192)!=0&&(n=ke(n,new G("12247334978884435968"))),(t&16384)!=0&&(n=ke(n,new G("8131365268886854656"))),(t&32768)!=0&&(n=ke(n,new G("3584323654725218816"))),(t&65536)!=0&&(n=ke(n,new G("696457651848324352"))),(t&131072)!=0&&(n=ke(n,new G("26294789957507116"))),(t&262144)!=0&&(n=ke(n,new G("37481735321082"))),e>0&&(n=Pi.div(n)),n}static getTickFromPrice(e,t,n){return D.getTickFromSqrtPriceX64(D.priceToSqrtPriceX64(e,t,n))}static getTickFromSqrtPriceX64(e){if(e.gt(Ue)||e.lt(Ge))throw new Error("Provided sqrtPrice is not within the supported sqrtPrice range.");let t=e.bitLength()-1,n=new G(t-64),i=Yr(n,32,128),s=new G("8000000000000000","hex"),r=0,o=new G(0),a=t>=64?e.shrn(t-63):e.shln(63-t);for(;s.gt(new G(0))&&r<ki;){a=a.mul(a);let m=a.shrn(127);a=a.shrn(63+m.toNumber()),o=o.add(s.mul(m)),s=s.shrn(1),r+=1}let c=o.shrn(32),d=i.add(c).mul(new G(Ti)),f=Un(d.sub(new G(Ai)),64,128).toNumber(),u=Un(d.add(new G(hi)),64,128).toNumber();return f==u?f:D.getSqrtPriceX64FromTick(u).lte(e)?u:f}},gt=class{static getTickWithPriceAndTickspacing(e,t,n,i){let r=D.getTickFromSqrtPriceX64(D.priceToSqrtPriceX64(e,n,i))/t;return r<0?r=Math.floor(r):r=Math.ceil(r),r*t}static roundPriceWithTickspacing(e,t,n,i){let s=gt.getTickWithPriceAndTickspacing(e,t,n,i),r=D.getSqrtPriceX64FromTick(s);return D.sqrtPriceX64ToPrice(r,n,i)}},Y=class{static addDelta(e,t){return e.add(t)}static getTokenAmountAFromLiquidity(e,t,n,i){if(e.gt(t)&&([e,t]=[t,e]),!e.gt(me))throw new Error("sqrtPriceX64A must greater than 0");let s=n.ushln(Vt),r=t.sub(e);return i?W.mulDivRoundingUp(W.mulDivCeil(s,r,t),qe,e):W.mulDivFloor(s,r,t).div(e)}static getTokenAmountBFromLiquidity(e,t,n,i){if(e.gt(t)&&([e,t]=[t,e]),!e.gt(me))throw new Error("sqrtPriceX64A must greater than 0");return i?W.mulDivCeil(n,t.sub(e),Ne):W.mulDivFloor(n,t.sub(e),Ne)}static getLiquidityFromTokenAmountA(e,t,n,i){e.gt(t)&&([e,t]=[t,e]);let s=n.mul(e).mul(t),r=t.sub(e),o=s.div(r);return i?W.mulDivRoundingUp(o,qe,Fn):o.shrn(Vt)}static getLiquidityFromTokenAmountB(e,t,n){return e.gt(t)&&([e,t]=[t,e]),W.mulDivFloor(n,Fn,t.sub(e))}static getLiquidityFromTokenAmounts(e,t,n,i,s){if(t.gt(n)&&([t,n]=[n,t]),e.lte(t))return Y.getLiquidityFromTokenAmountA(t,n,i,!1);if(e.lt(n)){let r=Y.getLiquidityFromTokenAmountA(e,n,i,!1),o=Y.getLiquidityFromTokenAmountB(t,e,s);return r.lt(o)?r:o}else return Y.getLiquidityFromTokenAmountB(t,n,s)}static getAmountsFromLiquidity(e,t,n,i,s){if(t.gt(n)&&([t,n]=[n,t]),e.lte(t))return{amountA:Y.getTokenAmountAFromLiquidity(t,n,i,s),amountB:new G(0)};if(e.lt(n)){let r=Y.getTokenAmountAFromLiquidity(e,n,i,s),o=Y.getTokenAmountBFromLiquidity(t,e,i,s);return{amountA:r,amountB:o}}else return{amountA:new G(0),amountB:Y.getTokenAmountBFromLiquidity(t,n,i,s)}}static getAmountsFromLiquidityWithSlippage(e,t,n,i,s,r,o){let{amountA:a,amountB:c}=Y.getAmountsFromLiquidity(e,t,n,i,r),l=s?1+o:1-o,d=new G(new He(a.toString()).mul(l).toFixed(0)),f=new G(new He(c.toString()).mul(l).toFixed(0));return{amountSlippageA:d,amountSlippageB:f}}static getAmountsOutFromLiquidity({poolInfo:e,tickLower:t,tickUpper:n,liquidity:i,slippage:s,add:r,epochInfo:o,amountAddFee:a}){var P,A,T,k;let c=D.priceToSqrtPriceX64(new He(e.price),e.mintA.decimals,e.mintB.decimals),l=D.getSqrtPriceX64FromTick(t),d=D.getSqrtPriceX64FromTick(n),f=r?1+s:1-s,u=Y.getAmountsFromLiquidity(c,l,d,i,r),[m,p]=[be(u.amountA,(P=e.mintA.extensions)==null?void 0:P.feeConfig,o,a),be(u.amountB,(A=e.mintB.extensions)==null?void 0:A.feeConfig,o,a)],[y,g]=[be(new G(new He(u.amountA.toString()).mul(f).toFixed(0)),(T=e.mintA.extensions)==null?void 0:T.feeConfig,o,a),be(new G(new He(u.amountB.toString()).mul(f).toFixed(0)),(k=e.mintB.extensions)==null?void 0:k.feeConfig,o,a)];return{liquidity:i,amountA:m,amountB:p,amountSlippageA:y,amountSlippageB:g,expirationTime:at(m.expirationTime,p.expirationTime)}}},bt=class{static swapCompute(e,t,n,i,s,r,o,a,c,l,d,f,u,m,p=!1){if(f.eq(me))throw new Error("amountSpecified must not be 0");if(m||(m=r?Ge.add(qe):Ue.sub(qe)),r){if(m.lt(Ge))throw new Error("sqrtPriceX64 must greater than MIN_SQRT_PRICE_X64");if(m.gte(d))throw new Error("sqrtPriceX64 must smaller than current")}else{if(m.gt(Ue))throw new Error("sqrtPriceX64 must smaller than MAX_SQRT_PRICE_X64");if(m.lte(d))throw new Error("sqrtPriceX64 must greater than current")}let y=f.gt(me),g={amountSpecifiedRemaining:f,amountCalculated:me,sqrtPriceX64:d,tick:c>u?Math.min(u+z.tickCount(l)-1,c):u,accounts:[],liquidity:a,feeAmount:new G(0)},P=u,A=n[u],T=0,k=!r&&A.startTickIndex===g.tick;for(;!g.amountSpecifiedRemaining.eq(me)&&!g.sqrtPriceX64.eq(m);){T>10;let w={};w.sqrtPriceStartX64=g.sqrtPriceX64;let x=M.nextInitTick(A,g.tick,l,r,k),h=x||null,B=null;if(!(h!=null&&h.liquidityGross.gtn(0))){let L=de.nextInitializedTickArrayStartIndex({tickCurrent:g.tick,tickSpacing:l,tickArrayBitmap:i,exBitmapInfo:s},P,r);if(!L.isExist){if(p)return{allTrade:!1,amountSpecifiedRemaining:g.amountSpecifiedRemaining,amountCalculated:g.amountCalculated,feeAmount:g.feeAmount,sqrtPriceX64:g.sqrtPriceX64,liquidity:g.liquidity,tickCurrent:g.tick,accounts:g.accounts};throw Error("swapCompute LiquidityInsufficient")}P=L.nextStartIndex;let{publicKey:K}=H(e,t,P);B=K,A=n[P];try{h=M.firstInitializedTick(A,r)}catch{throw Error("not found next tick info")}}w.tickNext=h.tick,w.initialized=h.liquidityGross.gtn(0),u!==P&&B&&(g.accounts.push(B),u=P),w.tickNext<Be?w.tickNext=Be:w.tickNext>Se&&(w.tickNext=Se),w.sqrtPriceNextX64=D.getSqrtPriceX64FromTick(w.tickNext);let C;if(r&&w.sqrtPriceNextX64.lt(m)||!r&&w.sqrtPriceNextX64.gt(m)?C=m:C=w.sqrtPriceNextX64,[g.sqrtPriceX64,w.amountIn,w.amountOut,w.feeAmount]=bt.swapStepCompute(g.sqrtPriceX64,C,g.liquidity,g.amountSpecifiedRemaining,o,r),g.feeAmount=g.feeAmount.add(w.feeAmount),y?(g.amountSpecifiedRemaining=g.amountSpecifiedRemaining.sub(w.amountIn.add(w.feeAmount)),g.amountCalculated=g.amountCalculated.sub(w.amountOut)):(g.amountSpecifiedRemaining=g.amountSpecifiedRemaining.add(w.amountOut),g.amountCalculated=g.amountCalculated.add(w.amountIn.add(w.feeAmount))),g.sqrtPriceX64.eq(w.sqrtPriceNextX64)){if(w.initialized){let L=h.liquidityNet;r&&(L=L.mul(et)),g.liquidity=Y.addDelta(g.liquidity,L)}k=w.tickNext!=g.tick&&!r&&A.startTickIndex===w.tickNext,g.tick=r?w.tickNext-1:w.tickNext}else if(g.sqrtPriceX64!=w.sqrtPriceStartX64){let L=D.getTickFromSqrtPriceX64(g.sqrtPriceX64);k=L!=g.tick&&!r&&A.startTickIndex===L,g.tick=L}++T}try{let{nextStartIndex:w,isExist:x}=z.nextInitializedTickArray(g.tick,l,r,i,s);x&&u!==w&&(g.accounts.push(H(e,t,w).publicKey),u=w)}catch{}return{allTrade:!0,amountSpecifiedRemaining:me,amountCalculated:g.amountCalculated,feeAmount:g.feeAmount,sqrtPriceX64:g.sqrtPriceX64,liquidity:g.liquidity,tickCurrent:g.tick,accounts:g.accounts}}static swapStepCompute(e,t,n,i,s,r){let o={sqrtPriceX64Next:new G(0),amountIn:new G(0),amountOut:new G(0),feeAmount:new G(0)},a=i.gte(me);if(a){let l=W.mulDivFloor(i,un.sub(new G(s.toString())),un);o.amountIn=r?Y.getTokenAmountAFromLiquidity(t,e,n,!0):Y.getTokenAmountBFromLiquidity(e,t,n,!0),l.gte(o.amountIn)?o.sqrtPriceX64Next=t:o.sqrtPriceX64Next=D.getNextSqrtPriceX64FromInput(e,n,l,r)}else o.amountOut=r?Y.getTokenAmountBFromLiquidity(t,e,n,!1):Y.getTokenAmountAFromLiquidity(e,t,n,!1),i.mul(et).gte(o.amountOut)?o.sqrtPriceX64Next=t:o.sqrtPriceX64Next=D.getNextSqrtPriceX64FromOutput(e,n,i.mul(et),r);let c=t.eq(o.sqrtPriceX64Next);return r?(c&&a||(o.amountIn=Y.getTokenAmountAFromLiquidity(o.sqrtPriceX64Next,e,n,!0)),c&&!a||(o.amountOut=Y.getTokenAmountBFromLiquidity(o.sqrtPriceX64Next,e,n,!1))):(o.amountIn=c&&a?o.amountIn:Y.getTokenAmountBFromLiquidity(e,o.sqrtPriceX64Next,n,!0),o.amountOut=c&&!a?o.amountOut:Y.getTokenAmountAFromLiquidity(e,o.sqrtPriceX64Next,n,!1)),!a&&o.amountOut.gt(i.mul(et))&&(o.amountOut=i.mul(et)),a&&!o.sqrtPriceX64Next.eq(t)?o.feeAmount=i.sub(o.amountIn):o.feeAmount=W.mulDivCeil(o.amountIn,new G(s),un.sub(new G(s))),[o.sqrtPriceX64Next,o.amountIn,o.amountOut,o.feeAmount]}};var we=60,yt=512,M=class{static getTickArrayAddressByTick(e,t,n,i){let s=M.getTickArrayStartIndexByTick(n,i),{publicKey:r}=H(e,t,s);return r}static getTickOffsetInArray(e,t){if(e%t!=0)throw new Error("tickIndex % tickSpacing not equal 0");let n=M.getTickArrayStartIndexByTick(e,t),i=Math.floor((e-n)/t);if(i<0||i>=we)throw new Error("tick offset in array overflow");return i}static getTickArrayBitIndex(e,t){let n=z.tickCount(t),i=e/n;return e<0&&e%n!=0?i=Math.ceil(i)-1:i=Math.floor(i),i}static getTickArrayStartIndexByTick(e,t){return this.getTickArrayBitIndex(e,t)*z.tickCount(t)}static getTickArrayOffsetInBitmapByTick(e,t){let n=t*we,i=Math.floor(e/n)+512;return Math.abs(i)}static checkTickArrayIsInitialized(e,t,n){let i=n*we,s=Math.floor(t/i)+512,r=Math.abs(s);return{isInitialized:e.testn(r),startIndex:(r-512)*i}}static getNextTickArrayStartIndex(e,t,n){return n?e-t*we:e+t*we}static mergeTickArrayBitmap(e){let t=new Zr(0);for(let n=0;n<e.length;n++)t=t.add(e[n].shln(64*n));return t}static getInitializedTickArrayInRange(e,t,n,i,s){let r=Math.floor(i/(n*we));return[...M.searchLowBitFromStart(e,t,r-1,s,n),...M.searchHightBitFromStart(e,t,r,s,n)]}static getAllInitializedTickArrayStartIndex(e,t,n){return M.searchHightBitFromStart(e,t,-7680,yt,n)}static getAllInitializedTickArrayInfo(e,t,n,i,s){let r=[],o=M.getAllInitializedTickArrayStartIndex(n,i,s);for(let a of o){let{publicKey:c}=H(e,t,a);r.push({tickArrayStartIndex:a,tickArrayAddress:c})}return r}static getAllInitializedTickInTickArray(e){return e.ticks.filter(t=>t.liquidityGross.gtn(0))}static searchLowBitFromStart(e,t,n,i,s){let r=[...[...t.negativeTickArrayBitmap].reverse(),e.slice(0,8),e.slice(8,16),...t.positiveTickArrayBitmap].map(c=>M.mergeTickArrayBitmap(c)),o=[];for(;n>=-7680;){let c=Math.floor((n+7680)/512),l=(n+7680)%512;if(r[c].testn(l)&&o.push(n),n--,o.length===i)break}let a=z.tickCount(s);return o.map(c=>c*a)}static searchHightBitFromStart(e,t,n,i,s){let r=[...[...t.negativeTickArrayBitmap].reverse(),e.slice(0,8),e.slice(8,16),...t.positiveTickArrayBitmap].map(c=>M.mergeTickArrayBitmap(c)),o=[];for(;n<7680;){let c=Math.floor((n+7680)/512),l=(n+7680)%512;if(r[c].testn(l)&&o.push(n),n++,o.length===i)break}let a=z.tickCount(s);return o.map(c=>c*a)}static checkIsOutOfBoundary(e){return e<Be||e>Se}static nextInitTick(e,t,n,i,s){if(z.getArrayStartIndex(t,n)!=e.startTickIndex)return null;let o=Math.floor((t-e.startTickIndex)/n);if(i)for(;o>=0;){if(e.ticks[o].liquidityGross.gtn(0))return e.ticks[o];o=o-1}else for(s||(o=o+1);o<we;){if(e.ticks[o].liquidityGross.gtn(0))return e.ticks[o];o=o+1}return null}static firstInitializedTick(e,t){if(t){let n=we-1;for(;n>=0;){if(e.ticks[n].liquidityGross.gtn(0))return e.ticks[n];n=n-1}}else{let n=0;for(;n<we;){if(e.ticks[n].liquidityGross.gtn(0))return e.ticks[n];n=n+1}}throw Error(`firstInitializedTick check error: ${e} - ${t}`)}static _getTickPriceLegacy({poolInfo:e,tick:t,baseIn:n}){let i=D.getSqrtPriceX64FromTick(t),s=D.sqrtPriceX64ToPrice(i,e.mintA.decimals,e.mintB.decimals);return n?{tick:t,price:s,tickSqrtPriceX64:i}:{tick:t,price:new Bt(1).div(s),tickSqrtPriceX64:i}}static _getPriceAndTickLegacy({poolInfo:e,price:t,baseIn:n}){let i=n?t:new Bt(1).div(t),s=gt.getTickWithPriceAndTickspacing(i,e.ammConfig.tickSpacing,e.mintA.decimals,e.mintB.decimals),r=D.getSqrtPriceX64FromTick(s),o=D.sqrtPriceX64ToPrice(r,e.mintA.decimals,e.mintB.decimals);return n?{tick:s,price:o}:{tick:s,price:new Bt(1).div(o)}}static getTickPrice({poolInfo:e,tick:t,baseIn:n}){let i=D.getSqrtPriceX64FromTick(t),s=D.sqrtPriceX64ToPrice(i,e.mintA.decimals,e.mintB.decimals);return n?{tick:t,price:s,tickSqrtPriceX64:i}:{tick:t,price:new Bt(1).div(s),tickSqrtPriceX64:i}}static getPriceAndTick({poolInfo:e,price:t,baseIn:n}){let i=n?t:new Bt(1).div(t),s=gt.getTickWithPriceAndTickspacing(i,e.config.tickSpacing,e.mintA.decimals,e.mintB.decimals),r=D.getSqrtPriceX64FromTick(s),o=D.sqrtPriceX64ToPrice(r,e.mintA.decimals,e.mintB.decimals);return n?{tick:s,price:o}:{tick:s,price:new Bt(1).div(o)}}};var Fi=J([Re(8),fe("bump"),vt("index"),te(""),At("protocolFeeRate"),At("tradeFeeRate"),vt("tickSpacing"),le(E(),8,"")]),Qr=J([At("blockTimestamp"),gi("tickCumulative"),le(E(),4)]),Ei=J([Re(8),Ie("initialized"),E("recentEpoch"),vt("observationIndex"),te("poolId"),le(Qr,100,"observations"),le(E(),4)]),Jr=J([fe("rewardState"),E("openTime"),E("endTime"),E("lastUpdateTime"),X("emissionsPerSecondX64"),E("rewardTotalEmissioned"),E("rewardClaimed"),te("tokenMint"),te("tokenVault"),te("creator"),X("rewardGrowthGlobalX64")]),mn=J([Re(8),fe("bump"),te("ammConfig"),te("creator"),te("mintA"),te("mintB"),te("vaultA"),te("vaultB"),te("observationId"),fe("mintDecimalsA"),fe("mintDecimalsB"),vt("tickSpacing"),X("liquidity"),X("sqrtPriceX64"),oe("tickCurrent"),At(),X("feeGrowthGlobalX64A"),X("feeGrowthGlobalX64B"),E("protocolFeesTokenA"),E("protocolFeesTokenB"),X("swapInAmountTokenA"),X("swapOutAmountTokenB"),X("swapInAmountTokenB"),X("swapOutAmountTokenA"),fe("status"),le(fe(),7,""),le(Jr,3,"rewardInfos"),le(E(),16,"tickArrayBitmap"),E("totalFeesTokenA"),E("totalFeesClaimedTokenA"),E("totalFeesTokenB"),E("totalFeesClaimedTokenB"),E("fundFeesTokenA"),E("fundFeesTokenB"),E("startTime"),le(E(),15*4-3,"padding")]),$r=J([X("growthInsideLastX64"),E("rewardAmountOwed")]),xt=J([Re(8),fe("bump"),te("nftMint"),te("poolId"),oe("tickLower"),oe("tickUpper"),X("liquidity"),X("feeGrowthInsideLastX64A"),X("feeGrowthInsideLastX64B"),E("tokenFeesOwedA"),E("tokenFeesOwedB"),le($r,3,"rewardInfos"),le(E(),8,"")]),Am=J([Re(8),fe("bump"),te("poolId"),oe("tickLowerIndex"),oe("tickUpperIndex"),X("liquidity"),X("feeGrowthInsideLastX64A"),X("feeGrowthInsideLastX64B"),E("tokenFeesOwedA"),E("tokenFeesOwedB"),le(X(),3,"rewardGrowthInside"),le(E(),8,"")]),eo=J([oe("tick"),wi("liquidityNet"),X("liquidityGross"),X("feeGrowthOutsideX64A"),X("feeGrowthOutsideX64B"),le(X(),3,"rewardGrowthsOutsideX64"),le(At(),13,"")]),Ht=J([Re(8),te("poolId"),oe("startTickIndex"),le(eo,we,"ticks"),fe("initializedTickCount"),le(fe(),115,"")]),_i=J([Re(329),le(te(),100,"whitelistMints")]),Oi=J([Re(8),te("poolId"),le(le(E(),8),qn,"positiveTickArrayBitmap"),le(le(E(),8),qn,"negativeTickArrayBitmap")]),hm=J([E(),fe("bump"),te("owner"),te("poolId"),te("positionId"),te("nftAccount"),le(E(),8)]),Di=J([Re(8),fe("bump"),te("lockOwner"),te("poolId"),te("positionId"),te("nftAccount"),te("lockNftMint"),E("recentEpoch"),le(E(),8)]);Ei.span;var Wi=Te("Raydium_Clmm"),Oe={createPool:[233,146,209,142,207,104,64,188],initReward:[95,135,192,196,242,129,230,68],setRewardEmissions:[112,52,167,75,32,201,211,137],openPosition:[77,184,74,214,112,86,241,199],openPositionWithTokenEx:[77,255,174,82,125,29,201,46],closePosition:[123,134,81,0,49,68,98,98],increaseLiquidity:[133,29,89,223,69,238,176,10],decreaseLiquidity:[58,127,188,62,79,82,196,96],swap:[43,4,237,11,26,201,30,98],collectReward:[18,237,166,197,34,16,213,144]},vi=[188,37,179,131,82,150,84,73],Vi=[16,72,250,198,14,162,212,19],ae=class{static createPoolInstruction(e,t,n,i,s,r,o,a,c,l,d,f,u,m){let p=J([X("sqrtPriceX64"),E("zero")]),y=[{pubkey:n,isSigner:!0,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!1},{pubkey:c,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:f,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!1},{pubkey:d,isSigner:!1,isWritable:!1},{pubkey:nt.programId,isSigner:!1,isWritable:!1},{pubkey:rt,isSigner:!1,isWritable:!1},...(m==null?void 0:m.map(A=>({pubkey:A,isSigner:!1,isWritable:!1})))||[]],g=Buffer.alloc(p.span);p.encode({sqrtPriceX64:u,zero:me},g);let P=Buffer.from([...Oe.createPool,...g]);return new he({keys:y,programId:e,data:P})}static async createPoolInstructions(e){let{programId:t,owner:n,mintA:i,mintB:s,ammConfigId:r,initialPriceX64:o,extendMintAccount:a}=e,[c,l]=[new S(i.address),new S(s.address)],{publicKey:d}=Ki(t,r,c,l),{publicKey:f}=Li(t,d),{publicKey:u}=Dn(t,d,c),{publicKey:m}=Dn(t,d,l),p=ge(t,d).publicKey,y=[this.createPoolInstruction(t,d,n,r,f,c,u,new S(i.programId||ee),l,m,new S(s.programId||ee),p,o,a)];return{signers:[],instructions:y,instructionTypes:[ie.CreateAccount,ie.ClmmCreatePool],address:{poolId:d,observationId:f,exBitmapAccount:p,mintAVault:u,mintBVault:m},lookupTableAddress:[]}}static openPositionFromLiquidityInstruction(e,t,n,i,s,r,o,a,c,l,d,f,u,m,p,y,g,P,A,T,k,w,x,h,B,C){let L=J([oe("tickLowerIndex"),oe("tickUpperIndex"),oe("tickArrayLowerStartIndex"),oe("tickArrayUpperStartIndex"),X("liquidity"),E("amountMaxA"),E("amountMaxB"),Ie("withMetadata"),fe("optionBaseFlag"),Ie("baseFlag")]),K=[...C?[{pubkey:C,isSigner:!1,isWritable:!0}]:[]],N=[{pubkey:t,isSigner:!0,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!1},{pubkey:s,isSigner:!0,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:d,isSigner:!1,isWritable:!0},{pubkey:f,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:m,isSigner:!1,isWritable:!0},{pubkey:p,isSigner:!1,isWritable:!0},{pubkey:rt,isSigner:!1,isWritable:!1},{pubkey:nt.programId,isSigner:!1,isWritable:!1},{pubkey:ee,isSigner:!1,isWritable:!1},{pubkey:jt,isSigner:!1,isWritable:!1},{pubkey:dt,isSigner:!1,isWritable:!1},{pubkey:ye,isSigner:!1,isWritable:!1},{pubkey:y,isSigner:!1,isWritable:!1},{pubkey:g,isSigner:!1,isWritable:!1},...K],I=Buffer.alloc(L.span);L.encode({tickLowerIndex:P,tickUpperIndex:A,tickArrayLowerStartIndex:T,tickArrayUpperStartIndex:k,liquidity:w,amountMaxA:x,amountMaxB:h,withMetadata:B==="create",baseFlag:!1,optionBaseFlag:0},I);let F=Buffer.from([...Oe.openPosition,...I]);return new he({keys:N,programId:e,data:F})}static openPositionFromLiquidityInstruction22(e,t,n,i,s,r,o,a,c,l,d,f,u,m,p,y,g,P,A,T,k,w,x,h,B){let C=J([oe("tickLowerIndex"),oe("tickUpperIndex"),oe("tickArrayLowerStartIndex"),oe("tickArrayUpperStartIndex"),X("liquidity"),E("amountMaxA"),E("amountMaxB"),Ie("withMetadata"),fe("optionBaseFlag"),Ie("baseFlag")]),L=[...B?[{pubkey:B,isSigner:!1,isWritable:!0}]:[]],K=[{pubkey:t,isSigner:!0,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!1},{pubkey:s,isSigner:!0,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:d,isSigner:!1,isWritable:!0},{pubkey:f,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:m,isSigner:!1,isWritable:!0},{pubkey:rt,isSigner:!1,isWritable:!1},{pubkey:nt.programId,isSigner:!1,isWritable:!1},{pubkey:ee,isSigner:!1,isWritable:!1},{pubkey:jt,isSigner:!1,isWritable:!1},{pubkey:ye,isSigner:!1,isWritable:!1},{pubkey:p,isSigner:!1,isWritable:!1},{pubkey:y,isSigner:!1,isWritable:!1},...L],N=Buffer.alloc(C.span);C.encode({tickLowerIndex:g,tickUpperIndex:P,tickArrayLowerStartIndex:A,tickArrayUpperStartIndex:T,liquidity:k,amountMaxA:w,amountMaxB:x,withMetadata:h==="create",baseFlag:!1,optionBaseFlag:0},N);let I=Buffer.from([...Oe.openPositionWithTokenEx,...N]);return new he({keys:K,programId:e,data:I})}static async openPositionInstructions({poolInfo:e,poolKeys:t,ownerInfo:n,tickLower:i,tickUpper:s,liquidity:r,amountMaxA:o,amountMaxB:a,withMetadata:c,getEphemeralSigners:l,nft2022:d}){let f=[],[u,m]=[new S(e.programId),new S(e.id)],p;if(l)p=new S((await l(1))[0]);else{let B=dn.generate();f.push(B),p=B.publicKey}let y=M.getTickArrayStartIndexByTick(i,e.config.tickSpacing),g=M.getTickArrayStartIndexByTick(s,e.config.tickSpacing),{publicKey:P}=H(u,m,y),{publicKey:A}=H(u,m,g),{publicKey:T}=d?re(n.wallet,p,ye):re(n.wallet,p,ee),{publicKey:k}=Gt(p),{publicKey:w}=Ke(u,p),{publicKey:x}=De(u,m,i,s),h=d?this.openPositionFromLiquidityInstruction22(u,n.feePayer,m,n.wallet,p,T,x,P,A,w,n.tokenAccountA,n.tokenAccountB,new S(t.vault.A),new S(t.vault.B),new S(e.mintA.address),new S(e.mintB.address),i,s,y,g,r,o,a,c,de.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing,[y,g])?ge(u,m).publicKey:void 0):this.openPositionFromLiquidityInstruction(u,n.feePayer,m,n.wallet,p,T,k,x,P,A,w,n.tokenAccountA,n.tokenAccountB,new S(t.vault.A),new S(t.vault.B),new S(e.mintA.address),new S(e.mintB.address),i,s,y,g,r,o,a,c,de.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing,[y,g])?ge(u,m).publicKey:void 0);return{signers:f,instructions:[h],instructionTypes:[ie.ClmmOpenPosition],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[],address:{nftMint:p,tickArrayLower:P,tickArrayUpper:A,positionNftAccount:T,metadataAccount:k,personalPosition:w,protocolPosition:x}}}static async openPositionFromBaseInstructions({poolInfo:e,poolKeys:t,ownerInfo:n,tickLower:i,tickUpper:s,base:r,baseAmount:o,otherAmountMax:a,withMetadata:c,getEphemeralSigners:l,nft2022:d}){let f=[],[u,m]=[new S(e.programId),new S(e.id)],p;if(l)p=new S((await l(1))[0]);else{let B=dn.generate();f.push(B),p=B.publicKey}let y=M.getTickArrayStartIndexByTick(i,e.config.tickSpacing),g=M.getTickArrayStartIndexByTick(s,e.config.tickSpacing),{publicKey:P}=H(u,m,y),{publicKey:A}=H(u,m,g),{publicKey:T}=d?re(n.wallet,p,ye):re(n.wallet,p,ee),{publicKey:k}=Gt(p),{publicKey:w}=Ke(u,p),{publicKey:x}=De(u,m,i,s),h=d?this.openPositionFromBaseInstruction22(u,n.feePayer,m,n.wallet,p,T,x,P,A,w,n.tokenAccountA,n.tokenAccountB,new S(t.vault.A),new S(t.vault.B),new S(e.mintA.address),new S(e.mintB.address),i,s,y,g,c,r,o,a,de.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing,[y,g])?ge(u,m).publicKey:void 0):this.openPositionFromBaseInstruction(u,n.feePayer,m,n.wallet,p,T,k,x,P,A,w,n.tokenAccountA,n.tokenAccountB,new S(t.vault.A),new S(t.vault.B),new S(e.mintA.address),new S(e.mintB.address),i,s,y,g,c,r,o,a,de.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing,[y,g])?ge(u,m).publicKey:void 0);return{address:{nftMint:p,tickArrayLower:P,tickArrayUpper:A,positionNftAccount:T,metadataAccount:k,personalPosition:w,protocolPosition:x},instructions:[h],signers:f,instructionTypes:[ie.ClmmOpenPosition],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[]}}static openPositionFromBaseInstruction(e,t,n,i,s,r,o,a,c,l,d,f,u,m,p,y,g,P,A,T,k,w,x,h,B,C){let L=J([oe("tickLowerIndex"),oe("tickUpperIndex"),oe("tickArrayLowerStartIndex"),oe("tickArrayUpperStartIndex"),X("liquidity"),E("amountMaxA"),E("amountMaxB"),Ie("withMetadata"),fe("optionBaseFlag"),Ie("baseFlag")]),K=[...C?[{pubkey:C,isSigner:!1,isWritable:!0}]:[]],N=[{pubkey:t,isSigner:!0,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!1},{pubkey:s,isSigner:!0,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:d,isSigner:!1,isWritable:!0},{pubkey:f,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:m,isSigner:!1,isWritable:!0},{pubkey:p,isSigner:!1,isWritable:!0},{pubkey:rt,isSigner:!1,isWritable:!1},{pubkey:nt.programId,isSigner:!1,isWritable:!1},{pubkey:ee,isSigner:!1,isWritable:!1},{pubkey:jt,isSigner:!1,isWritable:!1},{pubkey:dt,isSigner:!1,isWritable:!1},{pubkey:ye,isSigner:!1,isWritable:!1},{pubkey:y,isSigner:!1,isWritable:!1},{pubkey:g,isSigner:!1,isWritable:!1},...K],I=Buffer.alloc(L.span);L.encode({tickLowerIndex:P,tickUpperIndex:A,tickArrayLowerStartIndex:T,tickArrayUpperStartIndex:k,liquidity:new Xn(0),amountMaxA:x==="MintA"?h:B,amountMaxB:x==="MintA"?B:h,withMetadata:w==="create",baseFlag:x==="MintA",optionBaseFlag:1},I);let F=Buffer.from([...Oe.openPosition,...I]);return new he({keys:N,programId:e,data:F})}static openPositionFromBaseInstruction22(e,t,n,i,s,r,o,a,c,l,d,f,u,m,p,y,g,P,A,T,k,w,x,h,B){let C=J([oe("tickLowerIndex"),oe("tickUpperIndex"),oe("tickArrayLowerStartIndex"),oe("tickArrayUpperStartIndex"),X("liquidity"),E("amountMaxA"),E("amountMaxB"),Ie("withMetadata"),fe("optionBaseFlag"),Ie("baseFlag")]),L=[...B?[{pubkey:B,isSigner:!1,isWritable:!0}]:[]],K=[{pubkey:t,isSigner:!0,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!1},{pubkey:s,isSigner:!0,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:d,isSigner:!1,isWritable:!0},{pubkey:f,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:m,isSigner:!1,isWritable:!0},{pubkey:rt,isSigner:!1,isWritable:!1},{pubkey:nt.programId,isSigner:!1,isWritable:!1},{pubkey:ee,isSigner:!1,isWritable:!1},{pubkey:jt,isSigner:!1,isWritable:!1},{pubkey:ye,isSigner:!1,isWritable:!1},{pubkey:p,isSigner:!1,isWritable:!1},{pubkey:y,isSigner:!1,isWritable:!1},...L],N=Buffer.alloc(C.span);C.encode({tickLowerIndex:g,tickUpperIndex:P,tickArrayLowerStartIndex:A,tickArrayUpperStartIndex:T,liquidity:new Xn(0),amountMaxA:w==="MintA"?x:h,amountMaxB:w==="MintA"?h:x,withMetadata:k==="create",baseFlag:w==="MintA",optionBaseFlag:1},N);let I=Buffer.from([...Oe.openPositionWithTokenEx,...N]);return new he({keys:K,programId:e,data:I})}static async openPositionFromLiquidityInstructions({poolInfo:e,poolKeys:t,ownerInfo:n,tickLower:i,tickUpper:s,liquidity:r,amountMaxA:o,amountMaxB:a,withMetadata:c,getEphemeralSigners:l,nft2022:d}){let f,u=[];if(l)f=new S((await l(1))[0]);else{let B=dn.generate();u.push(B),f=B.publicKey}let[m,p]=[new S(e.programId),new S(e.id)],y=M.getTickArrayStartIndexByTick(i,e.config.tickSpacing),g=M.getTickArrayStartIndexByTick(s,e.config.tickSpacing),{publicKey:P}=H(m,p,y),{publicKey:A}=H(m,p,g),{publicKey:T}=d?re(n.wallet,f,ye):re(n.wallet,f,ee),{publicKey:k}=Gt(f),{publicKey:w}=Ke(m,f),{publicKey:x}=De(m,p,i,s),h=d?this.openPositionFromLiquidityInstruction22(m,n.wallet,p,n.wallet,f,T,x,P,A,w,n.tokenAccountA,n.tokenAccountB,new S(t.vault.A),new S(t.vault.B),new S(t.mintA.address),new S(t.mintB.address),i,s,y,g,r,o,a,c,de.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing,[y,g])?ge(m,p).publicKey:void 0):this.openPositionFromLiquidityInstruction(m,n.wallet,p,n.wallet,f,T,k,x,P,A,w,n.tokenAccountA,n.tokenAccountB,new S(t.vault.A),new S(t.vault.B),new S(t.mintA.address),new S(t.mintB.address),i,s,y,g,r,o,a,c,de.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing,[y,g])?ge(m,p).publicKey:void 0);return{address:{nftMint:f,tickArrayLower:P,tickArrayUpper:A,positionNftAccount:T,metadataAccount:k,personalPosition:w,protocolPosition:x},instructions:[h],signers:u,instructionTypes:[ie.ClmmOpenPosition],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[]}}static closePositionInstruction(e,t,n,i,s,r){let o=J([]),a=[{pubkey:t,isSigner:!0,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:nt.programId,isSigner:!1,isWritable:!1},{pubkey:r?ye:ee,isSigner:!1,isWritable:!1}],c=Buffer.alloc(o.span);o.encode({},c);let l=Buffer.from([...Oe.closePosition,...c]);return new he({keys:a,programId:e,data:l})}static closePositionInstructions({poolInfo:e,poolKeys:t,ownerInfo:n,ownerPosition:i,nft2022:s}){let r=new S(e.programId),o=s?re(n.wallet,i.nftMint,ye).publicKey:re(n.wallet,i.nftMint,ee).publicKey,{publicKey:a}=Ke(r,i.nftMint),c=[];return c.push(this.closePositionInstruction(r,n.wallet,i.nftMint,o,a,s)),{address:{positionNftAccount:o,personalPosition:a},signers:[],instructions:c,instructionTypes:[ie.ClmmClosePosition],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[]}}static increasePositionFromLiquidityInstruction(e,t,n,i,s,r,o,a,c,l,d,f,u,m,p,y,g,P){let A=J([X("liquidity"),E("amountMaxA"),E("amountMaxB"),fe("optionBaseFlag"),Ie("baseFlag")]),T=[...P?[{pubkey:P,isSigner:!1,isWritable:!0}]:[]],k=[{pubkey:t,isSigner:!0,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:d,isSigner:!1,isWritable:!0},{pubkey:f,isSigner:!1,isWritable:!0},{pubkey:ee,isSigner:!1,isWritable:!1},{pubkey:ye,isSigner:!1,isWritable:!1},{pubkey:u,isSigner:!1,isWritable:!1},{pubkey:m,isSigner:!1,isWritable:!1},...T],w=Buffer.alloc(A.span);A.encode({liquidity:p,amountMaxA:y,amountMaxB:g,optionBaseFlag:0,baseFlag:!1},w);let x=Buffer.from([...Oe.increaseLiquidity,...w]);return new he({keys:k,programId:e,data:x})}static increasePositionFromLiquidityInstructions({poolInfo:e,poolKeys:t,ownerPosition:n,ownerInfo:i,liquidity:s,amountMaxA:r,amountMaxB:o,nft2022:a}){let[c,l]=[new S(e.programId),new S(e.id)],d=M.getTickArrayStartIndexByTick(n.tickLower,e.config.tickSpacing),f=M.getTickArrayStartIndexByTick(n.tickUpper,e.config.tickSpacing),{publicKey:u}=H(c,l,d),{publicKey:m}=H(c,l,f),{publicKey:p}=a?re(i.wallet,n.nftMint,ye):re(i.wallet,n.nftMint,ee),{publicKey:y}=Ke(c,n.nftMint),{publicKey:g}=De(c,l,n.tickLower,n.tickUpper),P=this.increasePositionFromLiquidityInstruction(c,i.wallet,p,y,l,g,u,m,i.tokenAccountA,i.tokenAccountB,new S(t.vault.A),new S(t.vault.B),new S(e.mintA.address),new S(e.mintB.address),s,r,o,de.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing,[d,f])?ge(c,l).publicKey:void 0);return{address:{tickArrayLower:u,tickArrayUpper:m,positionNftAccount:p,personalPosition:y,protocolPosition:g},signers:[],instructions:[P],instructionTypes:[ie.ClmmIncreasePosition],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[]}}static increasePositionFromBaseInstructions({poolInfo:e,poolKeys:t,ownerPosition:n,ownerInfo:i,base:s,baseAmount:r,otherAmountMax:o,nft2022:a}){let[c,l]=[new S(e.programId),new S(e.id)],d=M.getTickArrayStartIndexByTick(n.tickLower,e.config.tickSpacing),f=M.getTickArrayStartIndexByTick(n.tickUpper,e.config.tickSpacing),{publicKey:u}=H(c,l,d),{publicKey:m}=H(c,l,f),{publicKey:p}=a?re(i.wallet,n.nftMint,ye):re(i.wallet,n.nftMint,ee),{publicKey:y}=Ke(c,n.nftMint),{publicKey:g}=De(c,l,n.tickLower,n.tickUpper);return{address:{tickArrayLower:u,tickArrayUpper:m,positionNftAccount:p,personalPosition:y,protocolPosition:g},instructions:[this.increasePositionFromBaseInstruction(c,i.wallet,p,y,l,g,u,m,i.tokenAccountA,i.tokenAccountB,new S(t.vault.A),new S(t.vault.B),new S(e.mintA.address),new S(e.mintB.address),s,r,o,de.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing,[d,f])?ge(c,l).publicKey:void 0)],signers:[],instructionTypes:[ie.ClmmIncreasePosition],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[]}}static increasePositionFromBaseInstruction(e,t,n,i,s,r,o,a,c,l,d,f,u,m,p,y,g,P){let A=J([X("liquidity"),E("amountMaxA"),E("amountMaxB"),fe("optionBaseFlag"),Ie("baseFlag")]),T=[...P?[{pubkey:P,isSigner:!1,isWritable:!0}]:[]],k=[{pubkey:t,isSigner:!0,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:d,isSigner:!1,isWritable:!0},{pubkey:f,isSigner:!1,isWritable:!0},{pubkey:ee,isSigner:!1,isWritable:!1},{pubkey:ye,isSigner:!1,isWritable:!1},{pubkey:u,isSigner:!1,isWritable:!1},{pubkey:m,isSigner:!1,isWritable:!1},...T],w=Buffer.alloc(A.span);A.encode({liquidity:new Xn(0),amountMaxA:p==="MintA"?y:g,amountMaxB:p==="MintA"?g:y,baseFlag:p==="MintA",optionBaseFlag:1},w);let x=Buffer.from([...Oe.increaseLiquidity,...w]);return new he({keys:k,programId:e,data:x})}static decreaseLiquidityInstruction(e,t,n,i,s,r,o,a,c,l,d,f,u,m,p,y,g,P,A){let T=J([X("liquidity"),E("amountMinA"),E("amountMinB")]),k=[...A?[{pubkey:A,isSigner:!1,isWritable:!0}]:[],...p.map(B=>[{pubkey:B.poolRewardVault,isSigner:!1,isWritable:!0},{pubkey:B.ownerRewardVault,isSigner:!1,isWritable:!0},{pubkey:B.rewardMint,isSigner:!1,isWritable:!1}]).flat()],w=[{pubkey:t,isSigner:!0,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:d,isSigner:!1,isWritable:!0},{pubkey:f,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:ee,isSigner:!1,isWritable:!1},{pubkey:ye,isSigner:!1,isWritable:!1},{pubkey:en,isSigner:!1,isWritable:!1},{pubkey:u,isSigner:!1,isWritable:!1},{pubkey:m,isSigner:!1,isWritable:!1},...k],x=Buffer.alloc(T.span);T.encode({liquidity:y,amountMinA:g,amountMinB:P},x);let h=Buffer.from([...Oe.decreaseLiquidity,...x]);return new he({keys:w,programId:e,data:h})}static decreaseLiquidityInstructions({poolInfo:e,poolKeys:t,ownerPosition:n,ownerInfo:i,liquidity:s,amountMinA:r,amountMinB:o,programId:a,nft2022:c}){let[l,d]=[new S(e.programId),new S(e.id)],f=M.getTickArrayStartIndexByTick(n.tickLower,e.config.tickSpacing),u=M.getTickArrayStartIndexByTick(n.tickUpper,e.config.tickSpacing),{publicKey:m}=H(l,d,f),{publicKey:p}=H(l,d,u),{publicKey:y}=c?re(i.wallet,n.nftMint,ye):re(i.wallet,n.nftMint,a),{publicKey:g}=Ke(l,n.nftMint),{publicKey:P}=De(l,d,n.tickLower,n.tickUpper),A=[];for(let w=0;w<e.rewardDefaultInfos.length;w++)A.push({poolRewardVault:new S(t.rewardInfos[w].vault),ownerRewardVault:i.rewardAccounts[w],rewardMint:new S(e.rewardDefaultInfos[w].mint.address)});let T=[],k=this.decreaseLiquidityInstruction(l,i.wallet,y,g,d,P,m,p,i.tokenAccountA,i.tokenAccountB,new S(t.vault.A),new S(t.vault.B),new S(e.mintA.address),new S(e.mintB.address),A,s,r,o,de.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing,[f,u])?ge(l,d).publicKey:void 0);return T.push(k),{address:{tickArrayLower:m,tickArrayUpper:p,positionNftAccount:y,personalPosition:g,protocolPosition:P},signers:[],instructions:T,instructionTypes:[ie.ClmmDecreasePosition],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[]}}static swapInstruction(e,t,n,i,s,r,o,a,c,l,d,f,u,m,p,y,g){let P=J([E("amount"),E("otherAmountThreshold"),X("sqrtPriceLimitX64"),Ie("isBaseInput")]),A=[...g?[{pubkey:g,isSigner:!1,isWritable:!0}]:[],...d.map(x=>({pubkey:x,isSigner:!1,isWritable:!0}))],T=[{pubkey:t,isSigner:!0,isWritable:!1},{pubkey:i,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:f,isSigner:!1,isWritable:!0},{pubkey:ee,isSigner:!1,isWritable:!1},{pubkey:ye,isSigner:!1,isWritable:!1},{pubkey:en,isSigner:!1,isWritable:!1},{pubkey:c,isSigner:!1,isWritable:!1},{pubkey:l,isSigner:!1,isWritable:!1},...A],k=Buffer.alloc(P.span);P.encode({amount:u,otherAmountThreshold:m,sqrtPriceLimitX64:p,isBaseInput:y},k);let w=Buffer.from([...Oe.swap,...k]);return new he({keys:T,programId:e,data:w})}static makeSwapBaseInInstructions({poolInfo:e,poolKeys:t,observationId:n,ownerInfo:i,inputMint:s,amountIn:r,amountOutMin:o,sqrtPriceLimitX64:a,remainingAccounts:c}){let[l,d]=[new S(e.programId),new S(e.id)],[f,u]=[new S(t.vault.A),new S(t.vault.B)],[m,p]=[new S(e.mintA.address),new S(e.mintB.address)],y=e.mintA.address===s.toString(),g=[this.swapInstruction(l,i.wallet,d,new S(e.config.id),y?i.tokenAccountA:i.tokenAccountB,y?i.tokenAccountB:i.tokenAccountA,y?f:u,y?u:f,y?m:p,y?p:m,c,n,r,o,a,!0,ge(l,d).publicKey)];return{signers:[],instructions:g,instructionTypes:[ie.ClmmSwapBaseIn],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[],address:{}}}static makeSwapBaseOutInstructions({poolInfo:e,poolKeys:t,observationId:n,ownerInfo:i,outputMint:s,amountOut:r,amountInMax:o,sqrtPriceLimitX64:a,remainingAccounts:c}){let[l,d]=[new S(e.programId),new S(e.id)],[f,u]=[new S(t.vault.A),new S(t.vault.B)],[m,p]=[new S(e.mintA.address),new S(e.mintB.address)],y=e.mintA.address===s.toBase58(),g=[this.swapInstruction(l,i.wallet,d,new S(e.config.id),y?i.tokenAccountB:i.tokenAccountA,y?i.tokenAccountA:i.tokenAccountB,y?u:f,y?f:u,y?p:m,y?m:p,c,n,r,o,a,!1,ge(l,d).publicKey)];return{signers:[],instructions:g,instructionTypes:[ie.ClmmSwapBaseOut],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[],address:{}}}static initRewardInstruction(e,t,n,i,s,r,o,a,c,l,d,f){let u=J([E("openTime"),E("endTime"),X("emissionsPerSecondX64")]),m=[{pubkey:t,isSigner:!0,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!1},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:nt.programId,isSigner:!1,isWritable:!1},{pubkey:rt,isSigner:!1,isWritable:!1}],p=Buffer.alloc(u.span);u.encode({openTime:Pe(l),endTime:Pe(d),emissionsPerSecondX64:f},p);let y=Buffer.from([...Oe.initReward,...p]);return new he({keys:m,programId:e,data:y})}static initRewardInstructions({poolInfo:e,poolKeys:t,ownerInfo:n,rewardInfo:i}){let[s,r]=[new S(e.programId),new S(e.id)],o=Ci(s,r,i.mint).publicKey,a=Ut(s).publicKey,c=[this.initRewardInstruction(s,n.wallet,r,a,new S(e.config.id),n.tokenAccount,i.programId,i.mint,o,i.openTime,i.endTime,i.emissionsPerSecondX64)];return{address:{poolRewardVault:o,operationId:a},signers:[],instructions:c,instructionTypes:[ie.ClmmInitReward],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[]}}static setRewardInstruction(e,t,n,i,s,r,o,a,c,l,d,f){let u=J([fe("rewardIndex"),X("emissionsPerSecondX64"),E("openTime"),E("endTime")]),m=[{pubkey:t,isSigner:!0,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:ee,isSigner:!1,isWritable:!1},{pubkey:ye,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0}],p=Buffer.alloc(u.span);u.encode({rewardIndex:c,emissionsPerSecondX64:f,openTime:Pe(l),endTime:Pe(d)},p);let y=Buffer.from([...Oe.setRewardEmissions,...p]);return new he({keys:m,programId:e,data:y})}static setRewardInstructions({poolInfo:e,poolKeys:t,ownerInfo:n,rewardInfo:i}){let[s,r]=[new S(e.programId),new S(e.id)],o,a,c;for(let f=0;f<e.rewardDefaultInfos.length;f++)e.rewardDefaultInfos[f].mint.address===i.mint.toString()&&(o=f,a=new S(t.rewardInfos[f].vault),c=new S(t.rewardInfos[f].mint.address));(o===void 0||a===void 0)&&Wi.logWithError("reward mint check error","no reward mint",e.rewardDefaultInfos);let l=Ut(s).publicKey,d=[this.setRewardInstruction(s,n.wallet,r,l,new S(e.config.id),n.tokenAccount,a,c,o,i.openTime,i.endTime,i.emissionsPerSecondX64)];return{address:{rewardVault:a,operationId:l},signers:[],instructions:d,instructionTypes:[ie.ClmmSetReward],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[]}}static collectRewardInstruction(e,t,n,i,s,r,o){let a=J([fe("rewardIndex")]),c=[{pubkey:t,isSigner:!0,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!1},{pubkey:ee,isSigner:!1,isWritable:!1},{pubkey:ye,isSigner:!1,isWritable:!1},{pubkey:en,isSigner:!1,isWritable:!1}],l=Buffer.alloc(a.span);a.encode({rewardIndex:o},l);let d=Buffer.from([...Oe.collectReward,...l]);return new he({keys:c,programId:e,data:d})}static collectRewardInstructions({poolInfo:e,poolKeys:t,ownerInfo:n,rewardMint:i}){let[s,r]=[new S(e.programId),new S(e.id)],o,a;for(let l=0;l<e.rewardDefaultInfos.length;l++)e.rewardDefaultInfos[l].mint.address===i.toString()&&(o=l,a=new S(t.rewardInfos[l].vault));(o===void 0||a===void 0)&&Wi.logWithError("reward mint check error","no reward mint",e.rewardDefaultInfos);let c=[this.collectRewardInstruction(s,n.wallet,r,n.tokenAccount,a,i,o)];return{address:{rewardVault:a},signers:[],instructions:c,instructionTypes:[ie.ClmmCollectReward],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[]}}static async makeLockPositions({programId:e,authProgramId:t,poolProgramId:n,payer:i,wallet:s,nftMint:r,nft2022:o,getEphemeralSigners:a}){let c=[],l;if(a)l=new S((await a(1))[0]);else{let g=dn.generate();c.push(g),l=g.publicKey}let d=o?re(s,r,ye).publicKey:re(s,r,ee).publicKey,{publicKey:f}=Ke(n,r),u=ht(e,l).publicKey,m=re(s,l,ee).publicKey,p=Gt(l).publicKey,y=ae.lockPositionInstructionV2({programId:e,auth:t,payer:i,positionOwner:s,lockOwner:s,positionNftAccount:d,positionId:f,lockPositionId:u,lockNftMint:l,lockNftAccount:m,metadataAccount:p,withMetadata:!0,nft2022:o,positionNftMint:r,authPositionNftAccount:re(t,r,o?ye:ee).publicKey,positionNftProgram:o?ye:ee});return{address:{positionId:f,lockPositionId:u,lockNftAccount:m,lockNftMint:l,positionNftAccount:d,metadataAccount:p},instructions:[y],signers:c,instructionTypes:[ie.ClmmLockPosition],lookupTableAddress:[]}}static lockPositionInstructionV2({programId:e,auth:t,payer:n,positionOwner:i,lockOwner:s,positionNftAccount:r,positionId:o,positionNftMint:a,authPositionNftAccount:c,positionNftProgram:l,lockPositionId:d,lockNftMint:f,lockNftAccount:u,metadataAccount:m,withMetadata:p}){let y=[{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!0,isWritable:!0},{pubkey:i,isSigner:!0,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:d,isSigner:!1,isWritable:!0},{pubkey:f,isSigner:!0,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:m,isSigner:!1,isWritable:!0},{pubkey:dt,isSigner:!1,isWritable:!1},{pubkey:jt,isSigner:!1,isWritable:!1},{pubkey:rt,isSigner:!1,isWritable:!1},{pubkey:ee,isSigner:!1,isWritable:!1},{pubkey:l,isSigner:!1,isWritable:!1},{pubkey:nt.programId,isSigner:!1,isWritable:!1}],g=J([Ie("withMetadata")]),P=Buffer.alloc(g.span);g.encode({withMetadata:p},P);let A=Buffer.from([...vi,...P]);return new he({keys:y,programId:e,data:A})}static lockPositionInstruction({programId:e,authProgramId:t,poolProgramId:n,owner:i,positionNft:s}){let{publicKey:r}=re(i,s,ee),{publicKey:o}=Ke(n,s),a=[{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:i,isSigner:!0,isWritable:!1},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:Wn(e,o).publicKey,isSigner:!1,isWritable:!0},{pubkey:ee,isSigner:!1,isWritable:!1},{pubkey:nt.programId,isSigner:!1,isWritable:!1}];return new he({keys:a,programId:e,data:Buffer.from(vi)})}static harvestLockPositionInstruction(e){let[t,n]=[new S(e.poolKeys.programId),new S(e.poolKeys.id)],i=M.getTickArrayStartIndexByTick(e.ownerPosition.tickLower,e.poolKeys.config.tickSpacing),s=M.getTickArrayStartIndexByTick(e.ownerPosition.tickUpper,e.poolKeys.config.tickSpacing),{publicKey:r}=H(t,n,i),{publicKey:o}=H(t,n,s),{publicKey:a}=re(e.owner,e.ownerPosition.nftMint,ee),{publicKey:c}=Ke(t,e.ownerPosition.nftMint),{publicKey:l}=De(t,n,e.ownerPosition.tickLower,e.ownerPosition.tickUpper),d=[];for(let m=0;m<e.poolKeys.rewardInfos.length;m++)d.push({poolRewardVault:new S(e.poolKeys.rewardInfos[m].vault),ownerRewardVault:e.ownerRewardAccounts[m],rewardMint:new S(e.poolKeys.rewardInfos[m].mint.address)});let f=[...d.map(m=>[{pubkey:m.poolRewardVault,isSigner:!1,isWritable:!0},{pubkey:m.ownerRewardVault,isSigner:!1,isWritable:!0},{pubkey:m.rewardMint,isSigner:!1,isWritable:!1}]).flat()],u=[{pubkey:e.authProgramId,isSigner:!1,isWritable:!1},{pubkey:Wn(e.programId,c).publicKey,isSigner:!1,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:e.owner,isSigner:!0,isWritable:!1},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:new S(e.poolKeys.vault.A),isSigner:!1,isWritable:!0},{pubkey:new S(e.poolKeys.vault.B),isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:e.userVaultA,isSigner:!1,isWritable:!0},{pubkey:e.userVaultB,isSigner:!1,isWritable:!0},{pubkey:ee,isSigner:!1,isWritable:!1},{pubkey:ye,isSigner:!1,isWritable:!1},{pubkey:Tn,isSigner:!1,isWritable:!1},{pubkey:new S(e.poolKeys.mintA.address),isSigner:!1,isWritable:!1},{pubkey:new S(e.poolKeys.mintB.address),isSigner:!1,isWritable:!1},...f];return new he({keys:u,programId:e.programId,data:Buffer.from(Vi)})}static harvestLockPositionInstructionV2({programId:e,auth:t,lockPositionId:n,clmmProgram:i,lockOwner:s,lockNftMint:r,lockNftAccount:o,positionNftAccount:a,positionId:c,poolId:l,protocolPosition:d,vaultA:f,vaultB:u,tickArrayLower:m,tickArrayUpper:p,userVaultA:y,userVaultB:g,mintA:P,mintB:A,rewardAccounts:T,exTickArrayBitmap:k}){let w=[...k?[{pubkey:k,isSigner:!1,isWritable:!0}]:[],...T.map(h=>[{pubkey:h.poolRewardVault,isSigner:!1,isWritable:!0},{pubkey:h.ownerRewardVault,isSigner:!1,isWritable:!0},{pubkey:h.rewardMint,isSigner:!1,isWritable:!1}]).flat()],x=[{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:s,isSigner:!0,isWritable:!1},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:i,isSigner:!1,isWritable:!1},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:d,isSigner:!1,isWritable:!0},{pubkey:f,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:m,isSigner:!1,isWritable:!0},{pubkey:p,isSigner:!1,isWritable:!0},{pubkey:y,isSigner:!1,isWritable:!0},{pubkey:g,isSigner:!1,isWritable:!0},{pubkey:ee,isSigner:!1,isWritable:!1},{pubkey:ye,isSigner:!1,isWritable:!1},{pubkey:Tn,isSigner:!1,isWritable:!1},{pubkey:P,isSigner:!1,isWritable:!1},{pubkey:A,isSigner:!1,isWritable:!1},...w];return new he({keys:x,programId:e,data:Buffer.from(Vi)})}};var Ui=class extends Wt{constructor(e){super(e)}async getClmmPoolKeys(e){return(await this.scope.api.fetchPoolKeysById({idList:[e]}))[0]}async createPool(e){var x;let{programId:t,owner:n=((x=this.scope.owner)==null?void 0:x.publicKey)||R.default,mint1:i,mint2:s,ammConfig:r,initialPrice:o,computeBudgetConfig:a,forerunCreate:c,getObserveState:l,txVersion:d,txTipConfig:f,feePayer:u}=e,m=this.createTxBuilder(u),[p,y,g]=new Ce(new R(i.address).toBuffer()).gt(new Ce(new R(s.address).toBuffer()))?[s,i,new wt(1).div(o)]:[i,s,o],P=D.priceToSqrtPriceX64(g,p.decimals,y.decimals),A=[],T=[];p.programId===ut.toBase58()&&T.push(vn(t,new R(p.address)).publicKey),y.programId===ut.toBase58()&&T.push(vn(t,new R(y.address)).publicKey),(await this.scope.connection.getMultipleAccountsInfo(T)).forEach((h,B)=>{h&&A.push(T[B])});let w=await ae.createPoolInstructions({connection:this.scope.connection,programId:t,owner:n,mintA:p,mintB:y,ammConfigId:r.id,initialPriceX64:P,forerunCreate:!l&&c,extendMintAccount:A});return m.addInstruction(w),m.addCustomComputeBudget(a),m.addTipInstruction(f),m.versionBuild({txVersion:d,extInfo:{address:U(O({},w.address),{observationId:w.address.observationId.toBase58(),exBitmapAccount:w.address.exBitmapAccount.toBase58(),programId:t.toString(),id:w.address.poolId.toString(),mintA:p,mintB:y,openTime:"0",vault:{A:w.address.mintAVault.toString(),B:w.address.mintBVault.toString()},rewardInfos:[],config:{id:r.id.toString(),index:r.index,protocolFeeRate:r.protocolFeeRate,tradeFeeRate:r.tradeFeeRate,tickSpacing:r.tickSpacing,fundFeeRate:r.fundFeeRate,description:r.description,defaultRange:0,defaultRangePoint:[]}}),mockPoolInfo:O({type:"Concentrated",rewardDefaultPoolInfos:"Clmm",id:w.address.poolId.toString(),mintA:p,mintB:y,feeRate:r.tradeFeeRate,openTime:"0",programId:t.toString(),price:g.toNumber(),config:{id:r.id.toString(),index:r.index,protocolFeeRate:r.protocolFeeRate,tradeFeeRate:r.tradeFeeRate,tickSpacing:r.tickSpacing,fundFeeRate:r.fundFeeRate,description:r.description,defaultRange:0,defaultRangePoint:[]},burnPercent:0},xi),forerunCreate:c}})}async openPositionFromBase({poolInfo:e,poolKeys:t,ownerInfo:n,tickLower:i,tickUpper:s,base:r,baseAmount:o,otherAmountMax:a,nft2022:c,associatedOnly:l=!0,checkCreateATAOwner:d=!1,withMetadata:f="create",getEphemeralSigners:u,computeBudgetConfig:m,txTipConfig:p,txVersion:y,feePayer:g}){this.scope.availability.addConcentratedPosition===!1&&this.logAndCreateError("add position feature disabled in your region"),this.scope.checkOwner();let P=this.createTxBuilder(g),A=null,T=null,k=n.useSOLBalance&&e.mintA.address===Z.toString(),w=n.useSOLBalance&&e.mintB.address===Z.toString(),[x,h]=r==="MintA"?[o,a]:[a,o],{account:B,instructionParams:C}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:e.mintA.programId,mint:new R(e.mintA.address),owner:this.scope.ownerPubKey,createInfo:k||x.isZero()?{payer:this.scope.ownerPubKey,amount:x}:void 0,skipCloseAccount:!k,notUseTokenAccount:k,associatedOnly:k?!1:l,checkCreateATAOwner:d});B&&(A=B),P.addInstruction(C||{});let{account:L,instructionParams:K}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:e.mintB.programId,mint:new R(e.mintB.address),owner:this.scope.ownerPubKey,createInfo:w||h.isZero()?{payer:this.scope.ownerPubKey,amount:h}:void 0,skipCloseAccount:!w,notUseTokenAccount:w,associatedOnly:w?!1:l,checkCreateATAOwner:d});L&&(T=L),P.addInstruction(K||{}),(!A||!T)&&this.logAndCreateError("cannot found target token accounts","tokenAccounts",{ownerTokenAccountA:A==null?void 0:A.toBase58(),ownerTokenAccountB:T==null?void 0:T.toBase58()});let N=t||await this.getClmmPoolKeys(e.id),I=await ae.openPositionFromBaseInstructions({poolInfo:e,poolKeys:N,ownerInfo:U(O({},n),{feePayer:this.scope.ownerPubKey,wallet:this.scope.ownerPubKey,tokenAccountA:A,tokenAccountB:T}),tickLower:i,tickUpper:s,base:r,baseAmount:o,otherAmountMax:a,withMetadata:f,getEphemeralSigners:u,nft2022:c});return P.addInstruction(I),P.addCustomComputeBudget(m),P.addTipInstruction(p),P.versionBuild({txVersion:y,extInfo:O({},I.address)})}async openPositionFromLiquidity({poolInfo:e,poolKeys:t,ownerInfo:n,amountMaxA:i,amountMaxB:s,tickLower:r,tickUpper:o,liquidity:a,associatedOnly:c=!0,checkCreateATAOwner:l=!1,withMetadata:d="create",txVersion:f,computeBudgetConfig:u,txTipConfig:m,getEphemeralSigners:p,nft2022:y,feePayer:g}){this.scope.availability.createConcentratedPosition===!1&&this.logAndCreateError("open position feature disabled in your region");let P=this.createTxBuilder(g),A=null,T=null,k=n.useSOLBalance&&e.mintA.address===Z.toBase58(),w=n.useSOLBalance&&e.mintB.address===Z.toBase58(),{account:x,instructionParams:h}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:e.mintA.programId,mint:new R(e.mintA.address),owner:this.scope.ownerPubKey,createInfo:k||i.isZero()?{payer:this.scope.ownerPubKey,amount:i}:void 0,skipCloseAccount:!k,notUseTokenAccount:k,associatedOnly:k?!1:c,checkCreateATAOwner:l});x&&(A=x),P.addInstruction(h||{});let{account:B,instructionParams:C}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:e.mintB.programId,mint:new R(e.mintB.address),owner:this.scope.ownerPubKey,createInfo:w||s.isZero()?{payer:this.scope.ownerPubKey,amount:s}:void 0,skipCloseAccount:!w,notUseTokenAccount:w,associatedOnly:w?!1:c,checkCreateATAOwner:l});B&&(T=B),P.addInstruction(C||{}),(A===void 0||T===void 0)&&this.logAndCreateError("cannot found target token accounts","tokenAccounts",this.scope.account.tokenAccounts);let L=t||await this.getClmmPoolKeys(e.id),K=await ae.openPositionFromLiquidityInstructions({poolInfo:e,poolKeys:L,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccountA:A,tokenAccountB:T},tickLower:r,tickUpper:o,liquidity:a,amountMaxA:i,amountMaxB:s,withMetadata:d,getEphemeralSigners:p,nft2022:y});return P.addInstruction(K),P.addCustomComputeBudget(u),P.addTipInstruction(m),P.versionBuild({txVersion:f,extInfo:{address:K.address}})}async increasePositionFromLiquidity(e){var C;let{poolInfo:t,poolKeys:n,ownerPosition:i,amountMaxA:s,amountMaxB:r,liquidity:o,ownerInfo:a,associatedOnly:c=!0,checkCreateATAOwner:l=!1,computeBudgetConfig:d,txTipConfig:f,txVersion:u,feePayer:m}=e,p=this.createTxBuilder(m),y,g,P=a.useSOLBalance&&t.mintA.address===Z.toString(),A=a.useSOLBalance&&t.mintB.address===Z.toString(),{account:T,instructionParams:k}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:t.mintA.programId,mint:new R(t.mintA.address),notUseTokenAccount:P,owner:this.scope.ownerPubKey,createInfo:P||s.isZero()?{payer:this.scope.ownerPubKey,amount:s}:void 0,skipCloseAccount:!P,associatedOnly:P?!1:c,checkCreateATAOwner:l});T&&(y=T),p.addInstruction(k||{});let{account:w,instructionParams:x}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:t.mintB.programId,mint:new R(t.mintB.address),owner:this.scope.ownerPubKey,createInfo:A||r.isZero()?{payer:this.scope.ownerPubKey,amount:r}:void 0,notUseTokenAccount:A,skipCloseAccount:!A,associatedOnly:A?!1:c,checkCreateATAOwner:l});w&&(g=w),p.addInstruction(x||{}),!y&&!g&&this.logAndCreateError("cannot found target token accounts","tokenAccounts",this.scope.account.tokenAccounts);let h=n!=null?n:await this.getClmmPoolKeys(t.id),B=ae.increasePositionFromLiquidityInstructions({poolInfo:t,poolKeys:h,ownerPosition:i,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccountA:y,tokenAccountB:g},liquidity:o,amountMaxA:s,amountMaxB:r,nft2022:(C=await this.scope.connection.getAccountInfo(i.nftMint))==null?void 0:C.owner.equals(ut)});return p.addInstruction(B),p.addCustomComputeBudget(d),p.addTipInstruction(f),p.versionBuild({txVersion:u,extInfo:{address:B.address}})}async increasePositionFromBase(e){var B;let{poolInfo:t,ownerPosition:n,base:i,baseAmount:s,otherAmountMax:r,ownerInfo:o,associatedOnly:a=!0,checkCreateATAOwner:c=!1,computeBudgetConfig:l,txTipConfig:d,txVersion:f,feePayer:u}=e,m=this.createTxBuilder(u),p,y,g=o.useSOLBalance&&t.mintA.address===Z.toString(),P=o.useSOLBalance&&t.mintB.address===Z.toString(),{account:A,instructionParams:T}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:t.mintA.programId,mint:new R(t.mintA.address),notUseTokenAccount:g,owner:this.scope.ownerPubKey,createInfo:g||(i==="MintA"?s:r).isZero()?{payer:this.scope.ownerPubKey,amount:i==="MintA"?s:r}:void 0,skipCloseAccount:!g,associatedOnly:g?!1:a,checkCreateATAOwner:c});A&&(p=A),m.addInstruction(T||{});let{account:k,instructionParams:w}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:t.mintB.programId,mint:new R(t.mintB.address),owner:this.scope.ownerPubKey,createInfo:P||(i==="MintA"?r:s).isZero()?{payer:this.scope.ownerPubKey,amount:i==="MintA"?r:s}:void 0,notUseTokenAccount:P,skipCloseAccount:!P,associatedOnly:P?!1:a,checkCreateATAOwner:c});k&&(y=k),m.addInstruction(w||{}),!p&&!y&&this.logAndCreateError("cannot found target token accounts","tokenAccounts",this.scope.account.tokenAccounts);let x=await this.getClmmPoolKeys(t.id),h=ae.increasePositionFromBaseInstructions({poolInfo:t,poolKeys:x,ownerPosition:n,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccountA:p,tokenAccountB:y},base:i,baseAmount:s,otherAmountMax:r,nft2022:(B=await this.scope.connection.getAccountInfo(n.nftMint))==null?void 0:B.owner.equals(ut)});return m.addInstruction(h),m.addCustomComputeBudget(l),m.addTipInstruction(d),m.versionBuild({txVersion:f,extInfo:{address:h.address}})}async decreaseLiquidity(e){var N;let{poolInfo:t,poolKeys:n,ownerPosition:i,ownerInfo:s,amountMinA:r,amountMinB:o,liquidity:a,associatedOnly:c=!0,checkCreateATAOwner:l=!1,computeBudgetConfig:d,txTipConfig:f,txVersion:u,feePayer:m}=e;this.scope.availability.removeConcentratedPosition===!1&&this.logAndCreateError("remove position feature disabled in your region");let p=this.createTxBuilder(m),y=s.useSOLBalance&&t.mintA.address===Z.toString(),g=s.useSOLBalance&&t.mintB.address===Z.toString(),P,A,{account:T,instructionParams:k}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:t.mintA.programId,mint:new R(t.mintA.address),notUseTokenAccount:y,owner:this.scope.ownerPubKey,createInfo:{payer:this.scope.ownerPubKey,amount:0},skipCloseAccount:!y,associatedOnly:y?!1:c,checkCreateATAOwner:l});P=T,k&&p.addInstruction(k);let{account:w,instructionParams:x}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:t.mintB.programId,mint:new R(t.mintB.address),notUseTokenAccount:g,owner:this.scope.ownerPubKey,createInfo:{payer:this.scope.ownerPubKey,amount:0},skipCloseAccount:!g,associatedOnly:g?!1:c,checkCreateATAOwner:l});A=w,x&&p.addInstruction(x);let h=[];for(let I of t.rewardDefaultInfos){let F=s.useSOLBalance&&I.mint.address===Z.toString(),v;if(I.mint.address===t.mintA.address)v=P;else if(I.mint.address===t.mintB.address)v=A;else{let{account:ce,instructionParams:pe}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:new R(I.mint.programId),mint:new R(I.mint.address),notUseTokenAccount:F,owner:this.scope.ownerPubKey,createInfo:{payer:this.scope.ownerPubKey,amount:0},skipCloseAccount:!F,associatedOnly:F?!1:c,checkCreateATAOwner:l});v=ce,pe&&p.addInstruction(pe)}h.push(v)}!P&&!A&&this.logAndCreateError("cannot found target token accounts","tokenAccounts",this.scope.account.tokenAccountRawInfos);let B=n!=null?n:await this.getClmmPoolKeys(t.id),C=(N=await this.scope.connection.getAccountInfo(i.nftMint))==null?void 0:N.owner.equals(ut),L=await ae.decreaseLiquidityInstructions({poolInfo:t,poolKeys:B,ownerPosition:i,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccountA:P,tokenAccountB:A,rewardAccounts:h},liquidity:a,amountMinA:r,amountMinB:o,nft2022:C});p.addInstruction({instructions:L.instructions,instructionTypes:[ie.ClmmDecreasePosition]});let K=O({},L.address);if(s.closePosition){let I=await ae.closePositionInstructions({poolInfo:t,poolKeys:B,ownerInfo:{wallet:this.scope.ownerPubKey},ownerPosition:i,nft2022:C});p.addInstruction({endInstructions:I.instructions,endInstructionTypes:I.instructionTypes}),K=O(O({},K),I.address)}return p.addCustomComputeBudget(d),p.addTipInstruction(f),p.versionBuild({txVersion:u,extInfo:{address:K}})}async lockPosition(e){var m;let{programId:t=Ot,authProgramId:n=nn,poolProgramId:i=Mt,ownerPosition:s,payer:r,computeBudgetConfig:o,txTipConfig:a,txVersion:c,getEphemeralSigners:l,feePayer:d}=e,f=this.createTxBuilder(d),u=await ae.makeLockPositions({programId:t,authProgramId:n,poolProgramId:i,wallet:this.scope.ownerPubKey,payer:r!=null?r:this.scope.ownerPubKey,nftMint:s.nftMint,getEphemeralSigners:l,nft2022:(m=await this.scope.connection.getAccountInfo(s.nftMint))==null?void 0:m.owner.equals(ut)});return f.addInstruction(u),f.addCustomComputeBudget(o),f.addTipInstruction(a),f.versionBuild({txVersion:c,extInfo:u.address})}async harvestLockPosition(e){let{programId:t=Ot,authProgramId:n=nn,clmmProgram:i=Mt,poolKeys:s,lockData:r,ownerInfo:o={useSOLBalance:!0},associatedOnly:a=!0,checkCreateATAOwner:c=!1,computeBudgetConfig:l,txTipConfig:d,txVersion:f,feePayer:u}=e,m=s||await this.getClmmPoolKeys(r.poolId.toString()),p=this.createTxBuilder(u),y=await this.scope.connection.getAccountInfo(r.positionId);y||this.logger.logWithError("position not found",r.positionId);let g=xt.decode(y.data),P=o.useSOLBalance&&m.mintA.address===Z.toString(),A=o.useSOLBalance&&m.mintB.address===Z.toString(),T,k,{account:w,instructionParams:x}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:m.mintA.programId,mint:new R(m.mintA.address),notUseTokenAccount:P,owner:this.scope.ownerPubKey,createInfo:{payer:this.scope.ownerPubKey,amount:0},skipCloseAccount:!P,associatedOnly:P?!1:a,checkCreateATAOwner:c});T=w,x&&p.addInstruction(x);let{account:h,instructionParams:B}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:m.mintB.programId,mint:new R(m.mintB.address),notUseTokenAccount:A,owner:this.scope.ownerPubKey,createInfo:{payer:this.scope.ownerPubKey,amount:0},skipCloseAccount:!A,associatedOnly:A?!1:a,checkCreateATAOwner:c});k=h,B&&p.addInstruction(B);let C={},L=[];for(let $ of m.rewardInfos){let ne=o.useSOLBalance&&$.mint.address===Z.toString(),We=C[$.mint.address];if(!We){let{account:Xi,instructionParams:Hn}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:new R($.mint.programId),mint:new R($.mint.address),notUseTokenAccount:ne,owner:this.scope.ownerPubKey,skipCloseAccount:!ne,createInfo:{payer:this.scope.ownerPubKey,amount:0},associatedOnly:ne?!1:a});We=Xi,Hn&&p.addInstruction(Hn)}C[$.mint.address]=We,L.push(We)}let K=ht(t,r.lockNftMint).publicKey,N=re(this.scope.ownerPubKey,r.lockNftMint,Yt).publicKey,I=M.getTickArrayStartIndexByTick(g.tickLower,m.config.tickSpacing),F=M.getTickArrayStartIndexByTick(g.tickUpper,m.config.tickSpacing),{publicKey:v}=H(new R(m.programId),r.poolId,I),{publicKey:ce}=H(new R(m.programId),r.poolId,F),{publicKey:pe}=De(new R(m.programId),r.poolId,g.tickLower,g.tickUpper),Le=[];for(let $=0;$<m.rewardInfos.length;$++)Le.push({poolRewardVault:new R(m.rewardInfos[$].vault),ownerRewardVault:L[$],rewardMint:new R(m.rewardInfos[$].mint.address)});let ze=await ae.harvestLockPositionInstructionV2({programId:t,auth:n,lockPositionId:K,clmmProgram:i,lockOwner:this.scope.ownerPubKey,lockNftMint:r.lockNftMint,lockNftAccount:N,positionNftAccount:r.nftAccount,positionId:r.positionId,poolId:r.poolId,protocolPosition:pe,vaultA:new R(m.vault.A),vaultB:new R(m.vault.B),tickArrayLower:v,tickArrayUpper:ce,userVaultA:T,userVaultB:k,mintA:new R(m.mintA.address),mintB:new R(m.mintB.address),rewardAccounts:Le,exTickArrayBitmap:ge(i,r.poolId).publicKey});return p.addInstruction({instructions:[ze],instructionTypes:[ie.ClmmHarvestLockPosition]}),p.addCustomComputeBudget(l),p.addTipInstruction(d),p.versionBuild({txVersion:f})}async closePosition({poolInfo:e,poolKeys:t,ownerPosition:n,txVersion:i,computeBudgetConfig:s,txTipConfig:r,feePayer:o}){var d;this.scope.availability.removeConcentratedPosition===!1&&this.logAndCreateError("remove position feature disabled in your region");let a=this.createTxBuilder(o),c=t!=null?t:await this.getClmmPoolKeys(e.id),l=ae.closePositionInstructions({poolInfo:e,poolKeys:c,ownerInfo:{wallet:this.scope.ownerPubKey},ownerPosition:n,nft2022:(d=await this.scope.connection.getAccountInfo(n.nftMint))==null?void 0:d.owner.equals(ut)});return a.addCustomComputeBudget(s),a.addTipInstruction(r),a.addInstruction(l).versionBuild({txVersion:i,extInfo:{address:l.address}})}async initReward({poolInfo:e,ownerInfo:t,rewardInfo:n,associatedOnly:i=!0,checkCreateATAOwner:s=!1,computeBudgetConfig:r,txVersion:o,feePayer:a}){n.endTime<=n.openTime&&this.logAndCreateError("reward time error","rewardInfo",n);let c=this.createTxBuilder(a),l=t.useSOLBalance&&n.mint.address.toString()===Z.toString(),d=n.perSecond.mul(n.endTime-n.openTime),{account:f,instructionParams:u}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:new R(n.mint.address),mint:new R(n.mint.address),notUseTokenAccount:!!l,skipCloseAccount:!l,owner:this.scope.ownerPubKey,createInfo:l?{payer:t.feePayer||this.scope.ownerPubKey,amount:new Ce(new wt(d.toFixed(0)).gte(d)?d.toFixed(0):d.add(1).toFixed(0))}:void 0,associatedOnly:l?!1:i,checkCreateATAOwner:s});u&&c.addInstruction(u),f||this.logAndCreateError("no money","ownerRewardAccount",this.scope.account.tokenAccountRawInfos);let m=await this.getClmmPoolKeys(e.id),p=ae.initRewardInstructions({poolInfo:e,poolKeys:m,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccount:f},rewardInfo:{programId:new R(n.mint.programId),mint:new R(n.mint.address),openTime:n.openTime,endTime:n.endTime,emissionsPerSecondX64:W.decimalToX64(n.perSecond)}});return c.addInstruction(p),c.addCustomComputeBudget(r),c.versionBuild({txVersion:o,extInfo:{address:p.address}})}async initRewards({poolInfo:e,poolKeys:t,ownerInfo:n,rewardInfos:i,associatedOnly:s=!0,checkCreateATAOwner:r=!1,computeBudgetConfig:o,txTipConfig:a,txVersion:c,feePayer:l}){for(let u of i)u.endTime<=u.openTime&&this.logAndCreateError("reward time error","rewardInfo",u);let d=this.createTxBuilder(l),f={};for(let u of i){let m=n.useSOLBalance&&u.mint.address===Z.toString(),p=u.perSecond.mul(u.endTime-u.openTime),{account:y,instructionParams:g}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:new R(u.mint.programId),mint:new R(u.mint.address),notUseTokenAccount:!!m,skipCloseAccount:!m,owner:this.scope.ownerPubKey,createInfo:m?{payer:n.feePayer||this.scope.ownerPubKey,amount:new Ce(new wt(p.toFixed(0)).gte(p)?p.toFixed(0):p.add(1).toFixed(0))}:void 0,associatedOnly:m?!1:s,checkCreateATAOwner:r});g&&d.addInstruction(g),y||this.logAndCreateError("no money","ownerRewardAccount",this.scope.account.tokenAccountRawInfos);let P=t!=null?t:await this.getClmmPoolKeys(e.id),A=ae.initRewardInstructions({poolInfo:e,poolKeys:P,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccount:y},rewardInfo:{programId:new R(u.mint.programId),mint:new R(u.mint.address),openTime:u.openTime,endTime:u.endTime,emissionsPerSecondX64:W.decimalToX64(u.perSecond)}});f=O(O({},f),A.address),d.addInstruction(A)}return d.addCustomComputeBudget(o),d.addTipInstruction(a),d.versionBuild({txVersion:c,extInfo:{address:f}})}async setReward({poolInfo:e,ownerInfo:t,rewardInfo:n,associatedOnly:i=!0,checkCreateATAOwner:s=!1,computeBudgetConfig:r,txTipConfig:o,txVersion:a,feePayer:c}){n.endTime<=n.openTime&&this.logAndCreateError("reward time error","rewardInfo",n);let l=this.createTxBuilder(c),d=t.useSOLBalance&&n.mint.equals(Z),{account:f,instructionParams:u}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:n.programId,mint:n.mint,notUseTokenAccount:d,owner:this.scope.ownerPubKey,createInfo:d?{payer:t.feePayer||this.scope.ownerPubKey,amount:new Ce(new wt(n.perSecond.mul(n.endTime-n.openTime).toFixed(0)).gte(n.perSecond.mul(n.endTime-n.openTime))?n.perSecond.mul(n.endTime-n.openTime).toFixed(0):n.perSecond.mul(n.endTime-n.openTime).add(1).toFixed(0))}:void 0,associatedOnly:d?!1:i,checkCreateATAOwner:s});u&&l.addInstruction(u),f||this.logAndCreateError("no money","ownerRewardAccount",this.scope.account.tokenAccountRawInfos);let m=await this.getClmmPoolKeys(e.id),p=ae.setRewardInstructions({poolInfo:e,poolKeys:m,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccount:f},rewardInfo:{mint:n.mint,openTime:n.openTime,endTime:n.endTime,emissionsPerSecondX64:W.decimalToX64(n.perSecond)}});return l.addInstruction(p),l.addCustomComputeBudget(r),l.addTipInstruction(o),l.versionBuild({txVersion:a,extInfo:{address:p.address}})}async setRewards({poolInfo:e,poolKeys:t,ownerInfo:n,rewardInfos:i,associatedOnly:s=!0,checkCreateATAOwner:r=!1,computeBudgetConfig:o,txTipConfig:a,txVersion:c,feePayer:l}){let d=this.createTxBuilder(l),f={};for(let u of i){u.endTime<=u.openTime&&this.logAndCreateError("reward time error","rewardInfo",u);let m=n.useSOLBalance&&u.mint.address===Z.toString(),{account:p,instructionParams:y}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:new R(u.mint.programId),mint:new R(u.mint.address),notUseTokenAccount:m,owner:this.scope.ownerPubKey,createInfo:m?{payer:n.feePayer||this.scope.ownerPubKey,amount:new Ce(new wt(u.perSecond.mul(u.endTime-u.openTime).toFixed(0)).gte(u.perSecond.mul(u.endTime-u.openTime))?u.perSecond.mul(u.endTime-u.openTime).toFixed(0):u.perSecond.mul(u.endTime-u.openTime).add(1).toFixed(0))}:void 0,associatedOnly:m?!1:s,checkCreateATAOwner:r});y&&d.addInstruction(y),p||this.logAndCreateError("no money","ownerRewardAccount",this.scope.account.tokenAccountRawInfos);let g=t!=null?t:await this.getClmmPoolKeys(e.id),P=ae.setRewardInstructions({poolInfo:e,poolKeys:g,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccount:p},rewardInfo:{mint:new R(u.mint.address),openTime:u.openTime,endTime:u.endTime,emissionsPerSecondX64:W.decimalToX64(u.perSecond)}});d.addInstruction(P),f=O(O({},f),P.address)}return d.addCustomComputeBudget(o),d.addTipInstruction(a),d.versionBuild({txVersion:c,extInfo:{address:f}})}async collectReward({poolInfo:e,ownerInfo:t,rewardMint:n,associatedOnly:i=!0,checkCreateATAOwner:s=!1,computeBudgetConfig:r,txTipConfig:o,txVersion:a,feePayer:c}){let l=e.rewardDefaultInfos.find(g=>g.mint.address===n.toString());l||this.logAndCreateError("reward mint error","not found reward mint",n);let d=this.createTxBuilder(c),f=t.useSOLBalance&&n.equals(Z),{account:u,instructionParams:m}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:new R(l.mint.programId),mint:n,notUseTokenAccount:f,owner:this.scope.ownerPubKey,skipCloseAccount:!f,createInfo:{payer:t.feePayer||this.scope.ownerPubKey,amount:0},associatedOnly:f?!1:i,checkCreateATAOwner:s});m&&d.addInstruction(m),u||this.logAndCreateError("no money","ownerRewardAccount",this.scope.account.tokenAccountRawInfos);let p=await this.getClmmPoolKeys(e.id),y=ae.collectRewardInstructions({poolInfo:e,poolKeys:p,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccount:u},rewardMint:n});return d.addInstruction(y),d.addCustomComputeBudget(r),d.addTipInstruction(o),d.versionBuild({txVersion:a,extInfo:{address:y.address}})}async collectRewards({poolInfo:e,ownerInfo:t,rewardMints:n,associatedOnly:i=!0,checkCreateATAOwner:s=!1,computeBudgetConfig:r,txTipConfig:o,feePayer:a}){let c=this.createTxBuilder(a),l={};for(let d of n){let f=e.rewardDefaultInfos.find(P=>P.mint.address===d.toString());if(!f){this.logAndCreateError("reward mint error","not found reward mint",d);continue}let u=t.useSOLBalance&&d.equals(Z),{account:m,instructionParams:p}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:new R(f.mint.programId),mint:d,notUseTokenAccount:u,owner:this.scope.ownerPubKey,skipCloseAccount:!u,createInfo:{payer:t.feePayer||this.scope.ownerPubKey,amount:0},associatedOnly:u?!1:i,checkCreateATAOwner:s});m||this.logAndCreateError("no money","ownerRewardAccount",this.scope.account.tokenAccountRawInfos),p&&c.addInstruction(p);let y=await this.getClmmPoolKeys(e.id),g=ae.collectRewardInstructions({poolInfo:e,poolKeys:y,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccount:m},rewardMint:d});c.addInstruction(g),l=O(O({},l),g.address)}return c.addCustomComputeBudget(r),c.addTipInstruction(o),c.build({address:l})}async swap({poolInfo:e,poolKeys:t,inputMint:n,amountIn:i,amountOutMin:s,priceLimit:r,observationId:o,ownerInfo:a,remainingAccounts:c,associatedOnly:l=!0,checkCreateATAOwner:d=!1,txVersion:f,computeBudgetConfig:u,txTipConfig:m,feePayer:p}){let y=this.createTxBuilder(p),g=n.toString()===e.mintA.address,P=a.useSOLBalance&&e.mintA.address===Z.toBase58(),A=a.useSOLBalance&&e.mintB.address===Z.toBase58(),T;!r||r.equals(new wt(0))?T=g?Ge.add(new Ce(1)):Ue.sub(new Ce(1)):T=D.priceToSqrtPriceX64(r,e.mintA.decimals,e.mintB.decimals);let k;if(!k){let{account:h,instructionParams:B}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:e.mintA.programId,mint:new R(e.mintA.address),notUseTokenAccount:P,owner:this.scope.ownerPubKey,skipCloseAccount:!P,createInfo:P||!g?{payer:a.feePayer||this.scope.ownerPubKey,amount:g?i:0}:void 0,associatedOnly:P?!1:l,checkCreateATAOwner:d});k=h,B&&y.addInstruction(B)}let w;if(!w){let{account:h,instructionParams:B}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:e.mintB.programId,mint:new R(e.mintB.address),notUseTokenAccount:A,owner:this.scope.ownerPubKey,skipCloseAccount:!A,createInfo:A||g?{payer:a.feePayer||this.scope.ownerPubKey,amount:g?0:i}:void 0,associatedOnly:A?!1:l,checkCreateATAOwner:d});w=h,B&&y.addInstruction(B)}(!k||!w)&&this.logAndCreateError("user do not have token account",{tokenA:e.mintA.symbol||e.mintA.address,tokenB:e.mintB.symbol||e.mintB.address,ownerTokenAccountA:k,ownerTokenAccountB:w,mintAUseSOLBalance:P,mintBUseSOLBalance:A,associatedOnly:l});let x=t!=null?t:await this.getClmmPoolKeys(e.id);return y.addInstruction(ae.makeSwapBaseInInstructions({poolInfo:e,poolKeys:x,observationId:o,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccountA:k,tokenAccountB:w},inputMint:new R(n),amountIn:i,amountOutMin:s,sqrtPriceLimitX64:T,remainingAccounts:c})),y.addCustomComputeBudget(u),y.addTipInstruction(m),y.versionBuild({txVersion:f})}async swapBaseOut({poolInfo:e,poolKeys:t,outputMint:n,amountOut:i,amountInMax:s,priceLimit:r,observationId:o,ownerInfo:a,remainingAccounts:c,associatedOnly:l=!0,checkCreateATAOwner:d=!1,txVersion:f,computeBudgetConfig:u,txTipConfig:m,feePayer:p}){let y=this.createTxBuilder(p),g=n.toString()===e.mintB.address,P=a.useSOLBalance&&e.mintA.address===Z.toBase58(),A=a.useSOLBalance&&e.mintB.address===Z.toBase58(),T;!r||r.equals(new wt(0))?T=n.toString()===e.mintB.address?Ge.add(new Ce(1)):Ue.sub(new Ce(1)):T=D.priceToSqrtPriceX64(r,e.mintA.decimals,e.mintB.decimals);let k;if(!k){let{account:h,instructionParams:B}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:e.mintA.programId,mint:new R(e.mintA.address),notUseTokenAccount:P,owner:this.scope.ownerPubKey,skipCloseAccount:!P,createInfo:P||!g?{payer:a.feePayer||this.scope.ownerPubKey,amount:g?s:0}:void 0,associatedOnly:P?!1:l,checkCreateATAOwner:d});k=h,B&&y.addInstruction(B)}let w;if(!w){let{account:h,instructionParams:B}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:e.mintB.programId,mint:new R(e.mintB.address),notUseTokenAccount:A,owner:this.scope.ownerPubKey,skipCloseAccount:!A,createInfo:A||g?{payer:a.feePayer||this.scope.ownerPubKey,amount:g?0:s}:void 0,associatedOnly:A?!1:l,checkCreateATAOwner:d});w=h,B&&y.addInstruction(B)}(!k||!w)&&this.logAndCreateError("user do not have token account",{tokenA:e.mintA.symbol||e.mintA.address,tokenB:e.mintB.symbol||e.mintB.address,ownerTokenAccountA:k,ownerTokenAccountB:w,mintAUseSOLBalance:P,mintBUseSOLBalance:A,associatedOnly:l});let x=t!=null?t:await this.getClmmPoolKeys(e.id);return y.addInstruction(ae.makeSwapBaseOutInstructions({poolInfo:e,poolKeys:x,observationId:o,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccountA:k,tokenAccountB:w},outputMint:new R(n),amountOut:i,amountInMax:s,sqrtPriceLimitX64:T,remainingAccounts:c})),y.addCustomComputeBudget(u),y.addTipInstruction(m),y.versionBuild({txVersion:f})}async harvestAllRewards({allPoolInfo:e,allPositions:t,lockInfo:n,ownerInfo:i,associatedOnly:s=!0,checkCreateATAOwner:r=!1,programId:o,txVersion:a,computeBudgetConfig:c,feePayer:l,lockProgram:d=Ot,lockAuth:f=nn,clmmProgram:u=Mt}){var A,T;let m={};for(let k of this.scope.account.tokenAccountRawInfos)s?re(this.scope.ownerPubKey,k.accountInfo.mint,o).publicKey.equals(k.pubkey)&&(m[k.accountInfo.mint.toString()]=k.pubkey):m[k.accountInfo.mint.toString()]=k.pubkey;let p=Object.values(t).flat().map(k=>k.nftMint),y=await Ye(this.scope.connection,p.map(k=>({pubkey:k}))),g={};y.forEach(k=>{var w,x;g[k.pubkey.toBase58()]=(x=(w=k==null?void 0:k.accountInfo)==null?void 0:w.owner)!=null?x:null});let P=this.createTxBuilder(l);for(let k of Object.values(e)){if(t[k.id]===void 0||!t[k.id].find(I=>!I.liquidity.isZero()||I.rewardInfos.find(F=>!F.rewardAmountOwed.isZero())))continue;let w=k,x=i.useSOLBalance&&w.mintA.address===Z.toString(),h=i.useSOLBalance&&w.mintB.address===Z.toString(),B=m[w.mintA.address];if(!B)if(x){let{account:I,instructionParams:F}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:w.mintA.programId,mint:new R(w.mintA.address),notUseTokenAccount:x,owner:this.scope.ownerPubKey,skipCloseAccount:!x,createInfo:{payer:i.feePayer||this.scope.ownerPubKey,amount:0},associatedOnly:x?!1:s,checkCreateATAOwner:r});B=I,F&&P.addInstruction(F)}else{let I=new R(w.mintA.address);B=this.scope.account.getAssociatedTokenAccount(I,new R(w.mintA.programId)),P.addInstruction({instructions:[Gi(this.scope.ownerPubKey,B,this.scope.ownerPubKey,I,new R(w.mintA.programId))]})}let C=m[w.mintB.address];if(!C)if(h){let{account:I,instructionParams:F}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:w.mintB.programId,mint:new R(w.mintB.address),notUseTokenAccount:h,owner:this.scope.ownerPubKey,skipCloseAccount:!h,createInfo:{payer:i.feePayer||this.scope.ownerPubKey,amount:0},associatedOnly:h?!1:s,checkCreateATAOwner:r});C=I,F&&P.addInstruction(F)}else{let I=new R(w.mintB.address);C=this.scope.account.getAssociatedTokenAccount(I,new R(w.mintB.programId)),P.addInstruction({instructions:[Gi(this.scope.ownerPubKey,C,this.scope.ownerPubKey,I,new R(w.mintB.programId))]})}m[w.mintA.address]=B,m[w.mintB.address]=C;let L=[];for(let I of w.rewardDefaultInfos){let F=i.useSOLBalance&&I.mint.address===Z.toString(),v=m[I.mint.address];if(!v){let{account:ce,instructionParams:pe}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:new R(I.mint.programId),mint:new R(I.mint.address),notUseTokenAccount:F,owner:this.scope.ownerPubKey,skipCloseAccount:!F,createInfo:{payer:i.feePayer||this.scope.ownerPubKey,amount:0},associatedOnly:F?!1:s});v=ce,pe&&P.addInstruction(pe)}m[I.mint.address]=v,L.push(v)}let K=await this.getClmmPoolKeys(w.id),N=[];for(let I=0;I<K.rewardInfos.length;I++)N.push({poolRewardVault:new R(K.rewardInfos[I].vault),ownerRewardVault:L[I],rewardMint:new R(K.rewardInfos[I].mint.address)});for(let I of t[k.id]){let F=(A=n==null?void 0:n[k.id])==null?void 0:A[I.nftMint.toBase58()];if(F){let v=re(this.scope.ownerPubKey,F.lockNftMint,Yt).publicKey,ce=M.getTickArrayStartIndexByTick(I.tickLower,K.config.tickSpacing),pe=M.getTickArrayStartIndexByTick(I.tickUpper,K.config.tickSpacing),{publicKey:Le}=H(new R(K.programId),F.poolId,ce),{publicKey:ze}=H(new R(K.programId),F.poolId,pe),{publicKey:$}=De(new R(K.programId),F.poolId,I.tickLower,I.tickUpper),ne=ht(d,F.lockNftMint).publicKey,We=ae.harvestLockPositionInstructionV2({programId:d,auth:f,lockPositionId:ne,clmmProgram:u,lockOwner:this.scope.ownerPubKey,lockNftMint:F.lockNftMint,lockNftAccount:v,positionNftAccount:F.nftAccount,positionId:F.positionId,poolId:F.poolId,protocolPosition:$,vaultA:new R(K.vault.A),vaultB:new R(K.vault.B),tickArrayLower:Le,tickArrayUpper:ze,userVaultA:B,userVaultB:C,mintA:new R(K.mintA.address),mintB:new R(K.mintB.address),rewardAccounts:N,exTickArrayBitmap:ge(u,F.poolId).publicKey});P.addInstruction({instructions:[We],instructionTypes:[ie.ClmmHarvestLockPosition],lookupTableAddress:K.lookupTableAccount?[K.lookupTableAccount]:[]})}else{let v=ae.decreaseLiquidityInstructions({poolInfo:w,poolKeys:K,ownerPosition:I,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccountA:B,tokenAccountB:C,rewardAccounts:L},liquidity:new Ce(0),amountMinA:new Ce(0),amountMinB:new Ce(0),nft2022:(T=g[I.nftMint.toBase58()])==null?void 0:T.equals(ut)});P.addInstruction(v)}}}return a===0?P.sizeCheckBuildV0({computeBudgetConfig:c}):P.sizeCheckBuild({computeBudgetConfig:c})}async getWhiteListMint({programId:e}){let t=await this.scope.connection.getAccountInfo(Ut(e).publicKey);return t?_i.decode(t.data).whitelistMints.filter(i=>!i.equals(R.default)):[]}async getOwnerPositionInfo({programId:e=Mt}){await this.scope.account.fetchWalletTokenAccounts();let n=this.scope.account.tokenAccountRawInfos.filter(r=>r.accountInfo.amount.eq(new Ce(1))).map(r=>Ke(new R(e),r.accountInfo.mint).publicKey),i=await this.scope.connection.getMultipleAccountsInfo(n),s=[];return i.forEach(r=>{if(!r)return;let o=xt.decode(r.data);s.push(o)}),s}async getOwnerLockedPositionInfo({programId:e=Ot}){await this.scope.account.fetchWalletTokenAccounts();let n=this.scope.account.tokenAccountRawInfos.filter(a=>a.accountInfo.amount.eq(new Ce(1))).map(a=>ht(new R(e),a.accountInfo.mint).publicKey),i=await this.scope.connection.getMultipleAccountsInfo(n),s=[];i.forEach(a=>{if(!a)return;let c=Di.decode(a.data);s.push(c)});let r=await this.scope.connection.getMultipleAccountsInfo(s.map(a=>a.positionId)),o=[];return r.forEach(a=>{if(!a)return;let c=xt.decode(a.data);o.push(c)}),s.map((a,c)=>({position:o[c],lockInfo:a}))}async getRpcClmmPoolInfo({poolId:e}){return(await this.getRpcClmmPoolInfos({poolIds:[e]}))[String(e)]}async getRpcClmmPoolInfos({poolIds:e,config:t}){let n=await Ye(this.scope.connection,e.map(s=>({pubkey:new R(s)})),t),i={};for(let s=0;s<e.length;s++){let r=n[s];if(r===null||!r.accountInfo)throw Error("fetch pool info error: "+String(e[s]));let o=mn.decode(r.accountInfo.data),a=D.sqrtPriceX64ToPrice(o.sqrtPriceX64,o.mintDecimalsA,o.mintDecimalsB).toNumber();i[String(e[s])]=U(O({},o),{currentPrice:a,programId:r.accountInfo.owner})}return i}async getComputeClmmPoolInfos({clmmPoolsRpcInfo:e,mintInfos:t}){let n=new Set(Object.keys(e).map(a=>e[a].ammConfig.toBase58())),i=await Ye(this.scope.connection,Array.from(n).map(a=>({pubkey:new R(a)}))),s={};i.forEach(a=>{!a.accountInfo||(s[a.pubkey.toBase58()]=Fi.decode(a.accountInfo.data))});let r=await de.fetchComputeMultipleClmmInfo({connection:this.scope.connection,rpcDataMap:e,poolList:Object.keys(e).map(a=>{var d,f,u,m;let[c,l]=[e[a].mintA.toBase58(),e[a].mintB.toBase58()];return{id:a,programId:e[a].programId.toBase58(),mintA:sn({address:c,decimals:e[a].mintDecimalsA,programId:t[c].programId.toBase58()||Yt.toBase58(),extensions:{feeConfig:(d=t[c])!=null&&d.feeConfig?Ln((f=t[c])==null?void 0:f.feeConfig):void 0}}),mintB:sn({address:l,decimals:e[a].mintDecimalsB,programId:t[l].programId.toBase58()||Yt.toBase58(),extensions:{feeConfig:(u=t[l])!=null&&u.feeConfig?Ln((m=t[l])==null?void 0:m.feeConfig):void 0}}),price:e[a].currentPrice,config:U(O({},s[e[a].ammConfig.toBase58()]),{id:e[a].ammConfig.toBase58(),fundFeeRate:0,description:"",defaultRange:0,defaultRangePoint:[]})}})}),o=await de.fetchMultiplePoolTickArrays({connection:this.scope.connection,poolKeys:Object.values(r)});return{computeClmmPoolInfo:r,computePoolTickData:o}}async getPoolInfoFromRpc(e){var l;let t=await this.getRpcClmmPoolInfo({poolId:e}),n=new Set([t.mintA.toBase58(),t.mintB.toBase58()]),i=await $n({connection:this.scope.connection,mints:Array.from(n).map(d=>new R(d))}),{computeClmmPoolInfo:s,computePoolTickData:r}=await this.scope.clmm.getComputeClmmPoolInfos({clmmPoolsRpcInfo:{[e]:t},mintInfos:i}),o=await Ye(this.scope.connection,[{pubkey:t.vaultA},{pubkey:t.vaultB}]),a=Mi(s[e]);if(!o[0].accountInfo||!o[1].accountInfo)throw new Error("pool vault data not found");a.mintAmountA=Number(qi.decode(o[0].accountInfo.data).amount.toString()),a.mintAmountB=Number(qi.decode((l=o[1].accountInfo)==null?void 0:l.data).amount.toString());let c=U(O({},s[e]),{exBitmapAccount:s[e].exBitmapAccount.toBase58(),observationId:s[e].observationId.toBase58(),id:e,programId:t.programId.toBase58(),openTime:t.startTime.toString(),vault:{A:t.vaultA.toBase58(),B:t.vaultB.toBase58()},config:a.config,rewardInfos:s[e].rewardInfos.filter(d=>!d.tokenVault.equals(R.default)).map(d=>({mint:sn({address:d.tokenMint.toBase58(),programId:Yt.toBase58(),decimals:10}),vault:d.tokenVault.toBase58()}))});return{poolInfo:a,poolKeys:c,computePoolInfo:s[e],tickData:r}}};export{Ui as Clmm};
//# sourceMappingURL=clmm.mjs.map