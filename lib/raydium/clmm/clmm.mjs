var Ui=Object.defineProperty,Xi=Object.defineProperties;var zi=Object.getOwnPropertyDescriptors;var Ut=Object.getOwnPropertySymbols;var zn=Object.prototype.hasOwnProperty,Hn=Object.prototype.propertyIsEnumerable;var Xn=(y,e,t)=>e in y?Ui(y,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):y[e]=t,O=(y,e)=>{for(var t in e||(e={}))zn.call(e,t)&&Xn(y,t,e[t]);if(Ut)for(var t of Ut(e))Hn.call(e,t)&&Xn(y,t,e[t]);return y},G=(y,e)=>Xi(y,zi(e));var mt=(y,e)=>{var t={};for(var n in y)zn.call(y,n)&&e.indexOf(n)<0&&(t[n]=y[n]);if(y!=null&&Ut)for(var n of Ut(y))e.indexOf(n)<0&&Hn.call(y,n)&&(t[n]=y[n]);return t};import{PublicKey as L}from"@solana/web3.js";import Ke from"bn.js";import ut from"decimal.js";import{PublicKey as Qn}from"@solana/web3.js";import{get as jn,set as Hi}from"lodash";var ln=class{constructor(e){this.logLevel=e.logLevel!==void 0?e.logLevel:0,this.name=e.name}set level(e){this.logLevel=e}get time(){return Date.now().toString()}get moduleName(){return this.name}isLogLevel(e){return e<=this.logLevel}error(...e){return this.isLogLevel(0)?(console.error(this.time,this.name,"sdk logger error",...e),this):this}logWithError(...e){let t=e.map(n=>typeof n=="object"?JSON.stringify(n):n).join(", ");throw new Error(t)}warning(...e){return this.isLogLevel(1)?(console.warn(this.time,this.name,"sdk logger warning",...e),this):this}info(...e){return this.isLogLevel(2)?(console.info(this.time,this.name,"sdk logger info",...e),this):this}debug(...e){return this.isLogLevel(3)?(console.debug(this.time,this.name,"sdk logger debug",...e),this):this}},Zn={},ji={};function Pe(y){let e=jn(Zn,y);if(!e){let t=jn(ji,y);e=new ln({name:y,logLevel:t}),Hi(Zn,y,e)}return e}import{MINT_SIZE as Zi,TOKEN_PROGRAM_ID as Qi,getTransferFeeConfig as Yi,unpackMint as Ji}from"@solana/spl-token";var mn=Pe("Raydium_accountInfo_util");async function Xe(y,e,t){let{batchRequest:n,commitment:i="confirmed",chunkCount:o=100}=O({batchRequest:!1},t),r=dn(e,o),s=new Array(r.length).fill([]);if(n){let a=r.map(d=>{let f=y._buildArgs([d.map(u=>u.toBase58())],i,"base64");return{methodName:"getMultipleAccounts",args:f}}),c=dn(a,10);s=(await(await Promise.all(c.map(async d=>await y._rpcBatchRequest(d)))).flat()).map(d=>(d.error&&mn.logWithError(`failed to get info for multiple accounts, RPC_ERROR, ${d.error.message}`),d.result.value.map(f=>{if(f){let{data:u,executable:m,lamports:p,owner:b,rentEpoch:g}=f;return u.length!==2&&u[1]!=="base64"&&mn.logWithError("info must be base64 encoded, RPC_ERROR"),{data:Buffer.from(u[0],"base64"),executable:m,lamports:p,owner:new Qn(b),rentEpoch:g}}return null})))}else try{s=await Promise.all(r.map(a=>y.getMultipleAccountsInfo(a,i)))}catch(a){a instanceof Error&&mn.logWithError(`failed to get info for multiple accounts, RPC_ERROR, ${a.message}`)}return s.flat()}async function ze(y,e,t){let n=await Xe(y,e.map(i=>i.pubkey),t);return e.map((i,o)=>G(O({},i),{accountInfo:n[o]}))}async function Yn({connection:y,mints:e,config:t}){var o,r,s;if(e.length===0)return{};let n=await ze(y,e.map(a=>({pubkey:it(a)})),t),i={};for(let a of n){if(!a.accountInfo||a.accountInfo.data.length<Zi){console.log("invalid mint account",a.pubkey.toBase58());continue}let c=Ji(a.pubkey,a.accountInfo,(o=a.accountInfo)==null?void 0:o.owner);i[a.pubkey.toString()]=G(O({},c),{programId:((r=a.accountInfo)==null?void 0:r.owner)||Qi,feeConfig:(s=Yi(c))!=null?s:void 0})}return i[Qn.default.toBase58()]=i[Q.toBase58()],i}import He from"bn.js";import Us from"decimal.js";import sr from"big.js";import Ht from"bn.js";import $i from"toformat";var er=$i,At=er;import zt from"big.js";import nr from"bn.js";import ir from"decimal.js-light";import Tt from"bn.js";var Jn=9007199254740991;function ge(y){let e=Pe("Raydium_parseBigNumberish");if(y instanceof Tt)return y;if(typeof y=="string"){if(y.match(/^-?[0-9]+$/))return new Tt(y);e.logWithError(`invalid BigNumberish string: ${y}`)}return typeof y=="number"?(y%1&&e.logWithError(`BigNumberish number underflow: ${y}`),(y>=Jn||y<=-Jn)&&e.logWithError(`BigNumberish number overflow: ${y}`),new Tt(String(y))):typeof y=="bigint"?new Tt(y.toString()):(e.error(`invalid BigNumberish value: ${y}`),new Tt(0))}var Xt=Pe("module/fraction"),pn=At(zt),ht=At(ir),rr={[0]:ht.ROUND_DOWN,[1]:ht.ROUND_HALF_UP,[2]:ht.ROUND_UP},or={[0]:zt.roundDown,[1]:zt.roundHalfUp,[2]:zt.roundUp},Y=class{constructor(e,t=new nr(1)){this.numerator=ge(e),this.denominator=ge(t)}get quotient(){return this.numerator.div(this.denominator)}invert(){return new Y(this.denominator,this.numerator)}add(e){let t=e instanceof Y?e:new Y(ge(e));return this.denominator.eq(t.denominator)?new Y(this.numerator.add(t.numerator),this.denominator):new Y(this.numerator.mul(t.denominator).add(t.numerator.mul(this.denominator)),this.denominator.mul(t.denominator))}sub(e){let t=e instanceof Y?e:new Y(ge(e));return this.denominator.eq(t.denominator)?new Y(this.numerator.sub(t.numerator),this.denominator):new Y(this.numerator.mul(t.denominator).sub(t.numerator.mul(this.denominator)),this.denominator.mul(t.denominator))}mul(e){let t=e instanceof Y?e:new Y(ge(e));return new Y(this.numerator.mul(t.numerator),this.denominator.mul(t.denominator))}div(e){let t=e instanceof Y?e:new Y(ge(e));return new Y(this.numerator.mul(t.denominator),this.denominator.mul(t.numerator))}toSignificant(e,t={groupSeparator:""},n=1){Number.isInteger(e)||Xt.logWithError(`${e} is not an integer.`),e<=0&&Xt.logWithError(`${e} is not positive.`),ht.set({precision:e+1,rounding:rr[n]});let i=new ht(this.numerator.toString()).div(this.denominator.toString()).toSignificantDigits(e);return i.toFormat(i.decimalPlaces(),t)}toFixed(e,t={groupSeparator:""},n=1){return Number.isInteger(e)||Xt.logWithError(`${e} is not an integer.`),e<0&&Xt.logWithError(`${e} is negative.`),pn.DP=e,pn.RM=or[n]||1,new pn(this.numerator.toString()).div(this.denominator.toString()).toFormat(e,t)}isZero(){return this.numerator.isZero()}};var ar=Pe("Raydium_amount"),$n=At(sr);function cr(y,e){let t="0",n="0";if(y.includes(".")){let i=y.split(".");i.length===2?([t,n]=i,n=n.padEnd(e,"0")):ar.logWithError(`invalid number string, num: ${y}`)}else t=y;return[t,n.slice(0,e)||n]}var ke=class extends Y{constructor(t,n,i=!0,o){let r=new Ht(0),s=fn.pow(new Ht(t.decimals));if(i)r=ge(n);else{let a=new Ht(0),c=new Ht(0);if(typeof n=="string"||typeof n=="number"||typeof n=="bigint"){let[l,d]=cr(n.toString(),t.decimals);a=ge(l),c=ge(d)}a=a.mul(s),r=a.add(c)}super(r,s);this.logger=Pe(o||"TokenAmount"),this.token=t}get raw(){return this.numerator}isZero(){return this.raw.isZero()}gt(t){return this.token.equals(t.token)||this.logger.logWithError("gt token not equals"),this.raw.gt(t.raw)}lt(t){return this.token.equals(t.token)||this.logger.logWithError("lt token not equals"),this.raw.lt(t.raw)}add(t){return this.token.equals(t.token)||this.logger.logWithError("add token not equals"),new ke(this.token,this.raw.add(t.raw))}subtract(t){return this.token.equals(t.token)||this.logger.logWithError("sub token not equals"),new ke(this.token,this.raw.sub(t.raw))}toSignificant(t=this.token.decimals,n,i=0){return super.toSignificant(t,n,i)}toFixed(t=this.token.decimals,n,i=0){return t>this.token.decimals&&this.logger.logWithError("decimals overflow"),super.toFixed(t,n,i)}toExact(t={groupSeparator:""}){return $n.DP=this.token.decimals,new $n(this.numerator.toString()).div(this.denominator.toString()).toFormat(t)}};import{PublicKey as ur}from"@solana/web3.js";import{TOKEN_PROGRAM_ID as ei}from"@solana/spl-token";var yn={chainId:101,address:ur.default.toBase58(),programId:ei.toBase58(),decimals:9,symbol:"SOL",name:"solana",logoURI:"https://img-v1.raydium.io/icon/So11111111111111111111111111111111111111112.png",tags:[],priority:2,type:"raydium",extensions:{coingeckoId:"solana"}},Je={chainId:101,address:"So11111111111111111111111111111111111111112",programId:ei.toBase58(),decimals:9,symbol:"WSOL",name:"Wrapped SOL",logoURI:"https://img-v1.raydium.io/icon/So11111111111111111111111111111111111111112.png",tags:[],priority:2,type:"raydium",extensions:{coingeckoId:"solana"}};import{PublicKey as Pn}from"@solana/web3.js";import{PublicKey as se,SystemProgram as ti,SYSVAR_RENT_PUBKEY as lr}from"@solana/web3.js";import{TOKEN_PROGRAM_ID as mr}from"@solana/spl-token";function bn({pubkey:y,isSigner:e=!1,isWritable:t=!0}){return{pubkey:y,isWritable:t,isSigner:e}}var Vo=[bn({pubkey:mr,isWritable:!1}),bn({pubkey:ti.programId,isWritable:!1}),bn({pubkey:lr,isWritable:!1})];function gn({publicKey:y,transformSol:e}){let t=ni(y.toString());if(t instanceof se)return e&&t.equals(xt)?Q:t;if(e&&t.toString()===xt.toBase58())return Q;if(typeof t=="string"){if(t===se.default.toBase58())return se.default;try{return new se(t)}catch{throw new Error("invalid public key")}}throw new Error("invalid public key")}function ni(y){try{return new se(y)}catch{return y}}var jt=new se("MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr"),wn=new se("MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr"),$e=new se("SysvarRent111111111111111111111111111111111"),qo=new se("SysvarC1ock11111111111111111111111111111111"),rt=new se("metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s"),Go=new se("Sysvar1nstructions1111111111111111111111111"),Uo=ti.programId,Xo=new se("4k3Dyjzvzp8eMZWUXbBCjEvwSkkk59S5iCNLY3QrkX6R"),zo=new se("Ea5SjE2Y6yvCeW5dYTn7PYMuW5ikXkvbGdcmSnXeaLjS"),Ho=new se("SRMuApVNdxXokk5GT7XD5cUUgXMBCoAz2LHeuAoKWRt"),jo=new se("EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v"),Zo=new se("Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB"),Qo=new se("mSoLzYCxHdYgdzU16g5QSh3i5K3z3KZK7ytfqcJm7So"),Yo=new se("7dHbWXmci3dT8UFYWYZweBLXgycu7Y3iL6trKn1Y7ARj"),Jo=new se("USDH1SM1ojwWUga67PGrgFWUHibbjqMvuMaDkRJTgkX"),$o=new se("NRVwhjBQiUPYtfDT5zRBVJajzFQHaBUNtC7SNVvqRFa"),es=new se("ANAxByE6G2WjFp7A4NqtWYXb3mgruyzZYg3spfxe6Lbo"),ts=new se("7vfCXTUXx5WJV5JADk17DUJ4ksgau7utNKj4b963voxs"),Q=new se("So11111111111111111111111111111111111111112"),xt=se.default;function it(y){return gn({publicKey:y,transformSol:!0})}var kn=class{constructor({mint:e,decimals:t,symbol:n,name:i,skipMint:o=!1,isToken2022:r=!1}){if(e===xt.toBase58()||e instanceof Pn&&xt.equals(e)){this.decimals=Je.decimals,this.symbol=Je.symbol,this.name=Je.name,this.mint=new Pn(Je.address),this.isToken2022=!1;return}this.decimals=t,this.symbol=n||e.toString().substring(0,6),this.name=i||e.toString().substring(0,6),this.mint=o?Pn.default:gn({publicKey:e}),this.isToken2022=r}equals(e){return this===e?!0:this.mint.equals(e.mint)}},_e=kn;_e.WSOL=new kn(G(O({},Je),{mint:Je.address}));var An=class{constructor({decimals:e,symbol:t="UNKNOWN",name:n="UNKNOWN"}){this.decimals=e,this.symbol=t,this.name=n}equals(e){return this===e}},Zt=An;Zt.SOL=new An(yn);import dr from"bn.js";var ii=new Y(new dr(100)),et=class extends Y{toSignificant(e=5,t,n){return this.mul(ii).toSignificant(e,t,n)}toFixed(e=2,t,n){return this.mul(ii).toFixed(e,t,n)}};var pr=Pe("Raydium_price"),Fe=class extends Y{constructor(t){let{baseToken:n,quoteToken:i,numerator:o,denominator:r}=t;super(o,r);this.baseToken=n,this.quoteToken=i,this.scalar=new Y(Tn(n.decimals),Tn(i.decimals))}get raw(){return new Y(this.numerator,this.denominator)}get adjusted(){return super.mul(this.scalar)}invert(){return new Fe({baseToken:this.quoteToken,quoteToken:this.baseToken,denominator:this.numerator,numerator:this.denominator})}mul(t){this.quoteToken!==t.baseToken&&pr.logWithError("mul token not equals");let n=super.mul(t);return new Fe({baseToken:this.baseToken,quoteToken:t.quoteToken,denominator:n.denominator,numerator:n.numerator})}toSignificant(t=this.quoteToken.decimals,n,i){return this.adjusted.toSignificant(t,n,i)}toFixed(t=this.quoteToken.decimals,n,i){return this.adjusted.toFixed(t,n,i)}};import{PublicKey as Ms}from"@solana/web3.js";import Fs from"bn.js";var fr=new He(0),ea=new He(1),ta=new He(2),na=new He(3),ia=new He(5),fn=new He(10),ra=new He(100),oa=new He(1e3),sa=new He(1e4);function Tn(y){return fn.pow(ge(y))}function dn(y,e=1,t=[]){let n=[...y];if(e<=0)return t;for(;n.length;)t.push(n.splice(0,e));return t}import{PublicKey as Ar}from"@solana/web3.js";import{TOKEN_PROGRAM_ID as Tr}from"@solana/spl-token";import{ComputeBudgetProgram as ri,Keypair as si,PublicKey as yr,Transaction as ai,TransactionMessage as br,VersionedTransaction as ci}from"@solana/web3.js";var te={CreateAccount:"CreateAccount",InitAccount:"InitAccount",CreateATA:"CreateATA",CloseAccount:"CloseAccount",TransferAmount:"TransferAmount",InitMint:"InitMint",MintTo:"MintTo",InitMarket:"InitMarket",Util1216OwnerClaim:"Util1216OwnerClaim",SetComputeUnitPrice:"SetComputeUnitPrice",SetComputeUnitLimit:"SetComputeUnitLimit",ClmmCreatePool:"ClmmCreatePool",ClmmOpenPosition:"ClmmOpenPosition",ClmmIncreasePosition:"ClmmIncreasePosition",ClmmDecreasePosition:"ClmmDecreasePosition",ClmmClosePosition:"ClmmClosePosition",ClmmSwapBaseIn:"ClmmSwapBaseIn",ClmmSwapBaseOut:"ClmmSwapBaseOut",ClmmInitReward:"ClmmInitReward",ClmmSetReward:"ClmmSetReward",ClmmCollectReward:"ClmmCollectReward",ClmmLockPosition:"ClmmLockPosition",ClmmHarvestLockPosition:"ClmmHarvestLockPosition",AmmV4Swap:"AmmV4Swap",AmmV4AddLiquidity:"AmmV4AddLiquidity",AmmV4RemoveLiquidity:"AmmV4RemoveLiquidity",AmmV4SimulatePoolInfo:"AmmV4SimulatePoolInfo",AmmV4SwapBaseIn:"AmmV4SwapBaseIn",AmmV4SwapBaseOut:"AmmV4SwapBaseOut",AmmV4CreatePool:"AmmV4CreatePool",AmmV4InitPool:"AmmV4InitPool",AmmV5AddLiquidity:"AmmV5AddLiquidity",AmmV5RemoveLiquidity:"AmmV5RemoveLiquidity",AmmV5SimulatePoolInfo:"AmmV5SimulatePoolInfo",AmmV5SwapBaseIn:"AmmV5SwapBaseIn",AmmV5SwapBaseOut:"AmmV5SwapBaseOut",RouteSwap:"RouteSwap",RouteSwap1:"RouteSwap1",RouteSwap2:"RouteSwap2",FarmV3Deposit:"FarmV3Deposit",FarmV3Withdraw:"FarmV3Withdraw",FarmV3CreateLedger:"FarmV3CreateLedger",FarmV4Withdraw:"FarmV4Withdraw",FarmV5Deposit:"FarmV5Deposit",FarmV5Withdraw:"FarmV5Withdraw",FarmV5CreateLedger:"FarmV5CreateLedger",FarmV6Deposit:"FarmV6Deposit",FarmV6Withdraw:"FarmV6Withdraw",FarmV6Create:"FarmV6Create",FarmV6Restart:"FarmV6Restart",FarmV6CreatorAddReward:"FarmV6CreatorAddReward",FarmV6CreatorWithdraw:"FarmV6CreatorWithdraw",CpmmCreatePool:"CpmmCreatePool",CpmmAddLiquidity:"CpmmAddLiquidity",CpmmWithdrawLiquidity:"CpmmWithdrawLiquidity",CpmmSwapBaseIn:"CpmmSwapBaseIn",CpmmSwapBaseOut:"CpmmSwapBaseOut",CpmmLockLp:"CpmmLockLp",CpmmCollectLockFee:"CpmmCollectLockFee",TransferTip:"TransferTip"};import{TOKEN_PROGRAM_ID as gr}from"@solana/spl-token";var oi=Pe("Raydium_txUtil"),ui=1644;function Qt(y){let e=[],t=[];return y.microLamports&&(e.push(ri.setComputeUnitPrice({microLamports:y.microLamports})),t.push(te.SetComputeUnitPrice)),y.units&&(e.push(ri.setComputeUnitLimit({units:y.units})),t.push(te.SetComputeUnitLimit)),{instructions:e,instructionTypes:t}}async function dt(y,e){var n,i;let t=e!=null?e:"confirmed";return(i=await((n=y.getLatestBlockhash)==null?void 0:n.call(y,{commitment:t})))==null?void 0:i.blockhash}async function Yt(y,e){return y.getSignatureStatuses([e]),new Promise((t,n)=>{let i=setTimeout(n,6e4);y.onSignature(e,o=>{if(clearTimeout(i),!o.err){t("");return}n(Object.assign(o.err,{txId:e}))},"confirmed")})}function wr(y,e){y.length<1&&oi.logWithError(`no instructions provided: ${y.toString()}`),e.length<1&&oi.logWithError(`no signers provided:, ${e.toString()}`);let t=new ai;t.recentBlockhash="11111111111111111111111111111111",t.feePayer=e[0],t.add(...y);try{return Buffer.from(t.serialize({verifySignatures:!1})).toString("base64").length<ui}catch{return!1}}function he(y,e){let[t,n]=yr.findProgramAddressSync(y,e);return{publicKey:t,nonce:n}}function Bt({instructions:y,payer:e,signers:t}){return wr(y,[e,...t])}function It({instructions:y,payer:e,lookupTableAddressAccount:t,recentBlockhash:n=si.generate().publicKey.toString()}){let o=new br({payerKey:e,recentBlockhash:n,instructions:y}).compileToV0Message(Object.values(t!=null?t:{}));try{return Buffer.from(new ci(o).serialize()).toString("base64").length<ui}catch{return!1}}var Pr=y=>Buffer.isBuffer(y)?y:y instanceof Uint8Array?Buffer.from(y.buffer,y.byteOffset,y.byteLength):Buffer.from(y),kr=y=>{let e=y.serialize({requireAllSignatures:!1,verifySignatures:!1});y instanceof ci&&(e=Pr(e));try{return e instanceof Buffer?e.toString("base64"):Buffer.from(e).toString("base64")}catch{return e.toString("base64")}};function ot(y){let e=[];return y.forEach(t=>{t instanceof ai&&(t.recentBlockhash||(t.recentBlockhash=gr.toBase58()),t.feePayer||(t.feePayer=si.generate().publicKey)),e.push(kr(t))}),console.log("simulate tx string:",e),e}function ne(y,e,t){return he([y.toBuffer(),(t!=null?t:Tr).toBuffer(),e.toBuffer()],new Ar("ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL"))}import{PublicKey as E}from"@solana/web3.js";var Sa=new E("EhhTKczWMGQt46ynNeRX1WfeagwwJd7ufHvCDjRxjo5Q"),Ca=new E("CBuCnLe26faBpcBP2fktp4rp8abpcAnTWft6ZrP5Q4T"),Ka=new E("9KEPoZmtHUrBbhWN1v1KWLMkkvwY6WLtAVUCPRtRjP4z"),La=new E("FarmqiPv5eAj3j1GMdMCMUGXqPUvmquZtMy86QH6rzhG"),Ra=new E("CLaimxFqjHzgTJtAGHU47NPhg6qrc5sCnpC4tBLyABQS"),Na=new E("srmqPvymJeFKQ4zGQed1GFppgkRHL9kaELCbyksJtPX"),Ma=new E("9xQeWvG816bUx9EPjHmaT23yvVM2ZWbrrpZb9PusVFin"),Oa=new E("675kPX9MHTjS2zt1qfr1NYHuzeLXfQM9H24wFSUt1Mp8"),Fa=new E("5quBtoiQqxF9Jv6KYKctB59NT3gtJD2Y65kdnB1Uev3h"),Ea=new E("CDSr3ssLcRB6XYPJwAfFt18MZvEZp4LjHcvzBVZ45duo"),St=new E("CAMMCzo5YL8w4VFF8KVHrK22GGUsp5VTaW7grrKgrWqK"),Ct=new E("LockrWmn6K5twhz3y9w1dQERbmgSaRkfnTeTKbpofwE"),Jt=new E("kN1kEznaF5Xbd8LYuqtEFcxzWSBk5Fv6ygX6SqEGJVy"),Da=new E("CDSr3ssLcRB6XYPJwAfFt18MZvEZp4LjHcvzBVZ45duo"),_a=new E("routeUGWgWzqBWFcrCfv8tritsqukccJPu3q5GPP3xS"),Wa=new E("7YttLkHDoNj9wyDur5pM1ejNaAvT9X4eqaYcHQqtj2G5"),va=new E("6FJon3QE27qgPVggARueB22hLvoh22VzJpXv4rBEoSLF"),Va=new E("CC12se5To1CdEuw7fDS27B7Geo5jJyL7t5UK2B44NgiH"),qa=new E("9HzJyW1qZsEiSfMUf6L2jo3CcTKAyBmSyKdwQeYisHrC"),Ga=new E("DropEU8AvevN3UrXWXTMuz3rqnMczQVNjq3kcSdW2SQi"),Ua=new E("CPMMoo8L3F4NbTegBCKVNunggL7H1ZpdTHKxQB5qKP1C"),Xa=new E("GpMZbSM2GgvTKHJirzeGfMFoaZ8UR2X7F4v8vHTvxFbL"),za=new E("DNXgeM9EiiaAbaWvwjHj9fQQLAX5ZsfHyvmYUNRAdNC8"),Ha=new E("LockrWmn6K5twhz3y9w1dQERbmgSaRkfnTeTKbpofwE"),ja=new E("3f7GcQFG397GAaEnv51zR6tsTVihYRydnydDD1cXekxH"),Za=new E("LanMV9sAd7wArD4vJFi2qDdfnVhFxYSUg6eADduJ3uj"),Qa=new E("WLHv2UAZm6z4KyaaELi5pjdbJh6RESMva1Rnn8pJVVh"),Ya=new E("DRay6fNdQ5J82H7xV6uq2aV3mNrUZ1J4PgSKsWgptcm6"),Ja=new E("5xqNaZXX5eUi4p5HU4oz9i5QnwRNT2y6oN7yyn4qENeq"),$a=new E("4Bu96XjU84XjPDSpveTVf6LYGCkfW5FK7SNkREWcEfV4"),ec=new E("6s1xP3hpbAfFoNtUNF8mfHsjr2Bd97JxFJRWLbL6aHuX");var tc={OPEN_BOOK_PROGRAM:new E("EoTcMgcDRTJVZDMZWBoU6rhYHZfkNTVEAfz3uUJRcYGj"),SERUM_PROGRAM_ID_V3:new E("Ray1111111111111111111111111111111111111111"),AMM_V4:new E("DRaya7Kj3aMWQSy19kSjvmuwq9docCHofyP9kanQGaav"),AMM_STABLE:new E("DRayDdXc1NZQ9C3hRWmoSf8zK4iapgMnjdNZWrfwsP8m"),CLMM_PROGRAM_ID:new E("DRayAUgENGQBKVaX8owNhgzkEDyoHTGVEGHVJT1E9pfH"),CLMM_LOCK_PROGRAM_ID:new E("DRay25Usp3YJAi7beckgpGUC7mGJ2cR1AVPxhYfwVCUX"),CLMM_LOCK_AUTH_ID:new E("6Aoh8h2Lw2m5UGxYR8AdAL87jTWYeKoxM52mJRzfYwN"),CREATE_CPMM_POOL_PROGRAM:new E("DRaycpLY18LhpbydsBWbVJtxpNv9oXPgjRSfpF2bWpYb"),CREATE_CPMM_POOL_AUTH:new E("CXniRufdq5xL8t8jZAPxsPZDpuudwuJSPWnbcD5Y5Nxq"),CREATE_CPMM_POOL_FEE_ACC:new E("3oE58BKVt8KuYkGxx8zBojugnymWmBiyafWgMrnb6eYy"),LOCK_CPMM_PROGRAM:new E("DRay25Usp3YJAi7beckgpGUC7mGJ2cR1AVPxhYfwVCUX"),LOCK_CPMM_AUTH:new E("7qWVV8UY2bRJfDLP4s37YzBPKUkVB46DStYJBpYbQzu3"),UTIL1216:E.default,Router:new E("DRaybByLpbUL57LJARs3j8BitTxVfzBg351EaMr5UTCd"),FARM_PROGRAM_ID_V3:new E("DRayWyrLmEW5KEeqs8kdTMMaBabapqagaBC7KWpGtJeZ"),FARM_PROGRAM_ID_V4:new E("Ray1111111111111111111111111111111111111111"),FARM_PROGRAM_ID_V5:new E("DRayiCGSZgku1GTK6rXD6mVDdingXy6APAH1R6R5L2LC"),FARM_PROGRAM_ID_V6:new E("DRayzbYakXs45ELHkzH6vC3fuhQqTAnv5A68gdFuvZyZ"),LAUNCHPAD_PROGRAM:new E("DRay6fNdQ5J82H7xV6uq2aV3mNrUZ1J4PgSKsWgptcm6"),LAUNCHPAD_AUTH:new E("5xqNaZXX5eUi4p5HU4oz9i5QnwRNT2y6oN7yyn4qENeq"),LAUNCHPAD_PLATFORM:new E("2Jx4KTDrVSdWNazuGpcA8n3ZLTRGGBDxAWhuKe2Xcj2a"),LAUNCHPAD_CONFIG:new E("7ZR4zD7PYfY2XxoG1Gxcy2EgEeGYrpxrwzPuwdUBssEt"),FEE_DESTINATION_ID:new E("9y8ENuuZ3b19quffx9hQvRVygG5ky6snHfRvGpuSfeJy"),MODEL_DATA_PUBKEY:new E("Ray1111111111111111111111111111111111111111")};import Ee from"bn.js";var Kt=1e4;function de(y,e,t,n){if(e===void 0)return{amount:y,fee:void 0,expirationTime:void 0};let i=G(O({},e),{olderTransferFee:{epoch:BigInt(e.olderTransferFee.epoch),maximumFee:BigInt(e.olderTransferFee.maximumFee),transferFeeBasisPoints:e.olderTransferFee.transferFeeBasisPoints},newerTransferFee:{epoch:BigInt(e.newerTransferFee.epoch),maximumFee:BigInt(e.newerTransferFee.maximumFee),transferFeeBasisPoints:e.newerTransferFee.transferFeeBasisPoints}}),o=t.epoch<i.newerTransferFee.epoch?i.olderTransferFee:i.newerTransferFee,r=new Ee(o.maximumFee.toString()),s=t.epoch<i.newerTransferFee.epoch?(Number(i.newerTransferFee.epoch)*t.slotsInEpoch-t.absoluteSlot)*400/1e3:void 0;if(n)if(o.transferFeeBasisPoints===Kt){let a=new Ee(o.maximumFee.toString());return{amount:y.add(a),fee:a,expirationTime:s}}else{let a=hn(y.mul(new Ee(Kt)),new Ee(Kt-o.transferFeeBasisPoints)),c=new Ee(o.maximumFee.toString()),l=a.sub(y).gt(c)?y.add(c):a,d=hn(l.mul(new Ee(o.transferFeeBasisPoints)),new Ee(Kt)),f=d.gt(r)?r:d;return{amount:l,fee:f,expirationTime:s}}else{let a=hn(y.mul(new Ee(o.transferFeeBasisPoints)),new Ee(Kt)),c=a.gt(r)?r:a;return{amount:y,fee:c,expirationTime:s}}}function tt(y,e){return y===void 0?e:e===void 0?y:Math.min(y,e)}function hn(y,e){let{div:t,mod:n}=y.divmod(e);return n.gt(new Ee(0))?t.add(new Ee(1)):t}import{PublicKey as xn,AddressLookupTableAccount as ft}from"@solana/web3.js";async function Bn({connection:y,address:e,cluster:t="mainnet"}){let n=await Xe(y,[...new Set(e.map(o=>o.toString()))].map(o=>new xn(o))),i={};for(let o=0;o<e.length;o++){let r=n[o],s=e[o];if(!r)continue;let a=new ft({key:s,state:ft.deserialize(r.data)});i[s.toString()]=a,t==="devnet"?pt[s.toString()]=a:$t[s.toString()]=a}return i}var $t={AcL1Vo8oy1ULiavEcjSUcwfBSForXMudcZvDZy5nzJkU:new ft({key:new xn("AcL1Vo8oy1ULiavEcjSUcwfBSForXMudcZvDZy5nzJkU"),state:ft.deserialize(Buffer.from("AQAAAP//////////I1rcEwAAAAAvAQYwun9CU6c5Ikm2pAj+D9IEnCOR45nK+SFTGSdpd6J6AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAbd9uHXZaGT2cvhRs7reawctIXtX1s3kTqM9YV+/wCpBt324e51j94YQl285GzN2rYa/E2DuQ0n/r35KNihi/wFSlNQ+F3IgtYUpVZyeIopbd8eq6vQpgZ4iEky9O72oAVKU1qZKSEGTSTocWDaOHx8NbXdvJK7geQfqEBBBUSNBqfVFxksXFEhjMlMPUrxf1ja7gibof1E49vZigAAAAAGp9UXGMd0yShWY5hpHV62i164o5tLbVxzVVshAAAAAIyXJY9OJInxuz0QKRSODYMLWhOZ2v8QhASOe9jb6fhZC3BlsePRfEU4nVJ/awTDzVi4bHMaoP21SbbRvAP4KUbIScv+6Yw2LHF/6K0ZjUPibbSWXCirYPGuuVl7zT789IUPLW4CpHr4JNCatp3ELXDLKMv6JJ+37le50lbBJ2LvBkX2T9y7AHdNGviJAqQNtlDUDCnauQRWybsLji6nPM8Qkw5asQRvCdB3MbX6IEBwytOrpM32l4jQygKG9TKgR0vZScQ2AsM/IHeQ7RajUkyhuZdc8SGiqQz/7H34torNR/Wir3sl0ruUrVxJWEZfUg+QLNAxxODdBi53/OP7Ioil1cqeBM9dtZC3FLov4yyxWRM/wcGStyJX/QfTnLBAHqkqWotPKVlShCVQqpP9W5W1rOao65IMk5QuQ2kMIOxzDMKAy2vjGSxQODgBz0QwGA+eP4ZjIjrIAQaXENv31QfLlOdXSRCkaybRniDHF4C8YcwhcvsqrOVuTP4B2Na+9wLdtrB31uz2rtlFI5kahdsnp/d1SrASDInYCtTYtdoke4kX+hoKWcEWM4Tle8pTUkUVv4BxS6fje/EzKBE4Qu/YsA/yfEEFGcr8Z57VKDw8uQzpiru7g4lvjnfapW62W030syevD8k07SGoxUHiuT/ai7gAHWWhDsVmg/C63ajgpkH7Sn3GdutArDTfyqOkdqv4/IPC/EFFy7mGkfDd2C57N5a/4jC+BbmJy7wQaSEZr0CQU88lPtUxIVvzGjC95b8Ooss2TqmkrayGKofkPMGQn7Ux+9lfwBSNfxwH8NgbpqC/7LNlV4I7nCvsXf3p+ohQk9NrAJb2KAFpUqEIJ9ZBV7BYDzHF/ORKYlgtvPnXjudZQ6CEo5OzUDaNIomTCCsvhD16TxJjsbgne1kGnQPCFSoaxUbq2V1bPMFQ3VYP6wDZ9bKStCFKx9A3tNbwZFC5ZGAN83MFK7XoTy+OmmcFEr6rLOjfSuTfPvHJkSVxW6Qllwkl67XcBi5v00u2gQsbu+38sp+rd5pA/LvyWj4P94ZGZwc1tE2P88xekCLcAwZGb+UhFzL/7K26csOb57yM5bvF9xJrLEObOkAAAAAn+HWRkdcPKyFFMnVwEoD7vnD0jCKFIU1sImubYCxNTSVzsKpaQX+fzNxrLAI3L14JQnJx/D6Uk2LADIHGqnGELzjEbkBDAlaM77NkXMPfqXNLSveCkWI7UEgNs31WEWB6XHSYI/v5DklHOb4QTtDOR804PVbi3fjloZeLR2F8d4FuZmMMO7ck3Fnkn2zEMG5gOmqsygb6PjTitArVl52NhcSznTxVnguaIJxiZkAnurDmn3MWR0PC2GLghp2KJqHCc6QQ85odeIjFHKOlRlJyeSXVJmL8vb1UgOzsbJPVP8p6zM4M3C1Sd7uWIHP33G42AP2Zg8ucn/n6meQjjD266JgCWdxZD6PXs9CsnIeL7SSG0/6lGb9xfP0ZcWkCXB/3hjxHYVXjra/GPOeXGk0fLLKjCbk+mgs2w6d2oCwimBipTzuoZ30GiI8ij8VRzD5CzMWtu2m21eDBIfjGAEo4pQeNNonKcqzV/cleX8ySZLOHsz8PtBCrLqF+VkLm9hOzIT+6i/nIf6keR4GWKMOD4AvqfpjHoD4DuhBpz8P28+DxkGrDXXr/nr20x291VPvcTU/b+b+o2kC9G0kcXeTlLjU6a2TQXWlZ4gBUdBl1jgT7mObSTpLblNiXZsLkbmVXZwvFKXua5cUKlWed/w30skmEUraTuQqtqr5fHZPW9n57EmeTif6LjHL2YJFZkQU+TrJmFzqzmF4/b8OwrPQAprl8mX3q4LUIdAS/a+11B6DWD1Xk2++Sn94dLC4xjkO4Wtlw8c4XuzciVbepHOmnoWzVu/0y3KCrLCSfQxQ3br8DJCoVzhgtPsS2nZZjsBGIZgnU0QpMv+2MnRsnKwdp1VsrCX84j/qvaZn4WhKunippgTbN2EUs0tPTP55Qfgj+nKmjtWW5IYs72FrEwJKYoNfsmqaF4o5pf4v9zgPwVwY/5I4XJKUL2L25m9kAQcW/K+H1RTFEUoj8Z4ajpOmAB/dG0COmCphVMW2CCMvnxhcGiSgPnpDuWu6qiJ7NG7ye5kvHgefgqPLeicspNJ5EpL3XiRNLM2tmJLI1awAwOyd6iHv0dCkMYRKaa6rcaZeYwmKCkckm0kM2JNmnmmAaBQQ7mwmIM0IMxX4f5W6j9PqZWcJxF7r17T/lQBAmcjoupRiJifbnXCNUv9GhpRF19WcBdeKbivRJVlGop6I2RS6lGImJ9udcI1S/0aGlEXX1ZwF14puK9ElWUainojZFYVHLHD6dIP2ESjqBzg3ol1/wB7+/ylGwd9LS7wSZ2A630CJSVKwH47K9P4bB8PEQP8BwjMFa7xQHOqZFP1XqaQ==","base64"))})},pt={},In=async y=>{let e="EFhMuDw1PKEuckuFRW9PavNfTH4LKP5uKHgyXDmWpFCq";if(pt[e])return pt;let t=new xn(e),n=await y.getAccountInfo(t);return n&&(pt[e]=new ft({key:t,state:ft.deserialize(n.data)})),pt};import{PublicKey as yt,sendAndConfirmTransaction as Sn,SystemProgram as xr,Transaction as Lt,TransactionMessage as Rt,VersionedTransaction as Nt}from"@solana/web3.js";import Br from"axios";var en=2e3,tn=class{constructor(e){this.instructions=[];this.endInstructions=[];this.lookupTableAddress=[];this.signers=[];this.instructionTypes=[];this.endInstructionTypes=[];this.connection=e.connection,this.feePayer=e.feePayer,this.signAllTransactions=e.signAllTransactions,this.owner=e.owner,this.cluster=e.cluster,this.blockhashCommitment=e.blockhashCommitment,this.loopMultiTxStatus=!!e.loopMultiTxStatus}get AllTxData(){return{instructions:this.instructions,endInstructions:this.endInstructions,signers:this.signers,instructionTypes:this.instructionTypes,endInstructionTypes:this.endInstructionTypes,lookupTableAddress:this.lookupTableAddress}}get allInstructions(){return[...this.instructions,...this.endInstructions]}async getComputeBudgetConfig(){var n;let e=(await Br.get(`https://solanacompass.com/api/fees?cacheFreshTime=${3e5}`)).data,{avg:t}=(n=e==null?void 0:e[15])!=null?n:{};if(!!t)return{units:6e5,microLamports:Math.min(Math.ceil(t*1e6/6e5),25e3)}}addCustomComputeBudget(e){if(e){let{instructions:t,instructionTypes:n}=Qt(e);return this.instructions.unshift(...t),this.instructionTypes.unshift(...n),!0}return!1}addTipInstruction(e){var t;return e?(this.endInstructions.push(xr.transfer({fromPubkey:(t=e.feePayer)!=null?t:this.feePayer,toPubkey:new yt(e.address),lamports:BigInt(e.amount.toString())})),this.endInstructionTypes.push(te.TransferTip),!0):!1}async calComputeBudget({config:e,defaultIns:t}){try{let n=e||await this.getComputeBudgetConfig();if(this.addCustomComputeBudget(n))return;t&&this.instructions.unshift(...t)}catch{t&&this.instructions.unshift(...t)}}addInstruction({instructions:e=[],endInstructions:t=[],signers:n=[],instructionTypes:i=[],endInstructionTypes:o=[],lookupTableAddress:r=[]}){return this.instructions.push(...e),this.endInstructions.push(...t),this.signers.push(...n),this.instructionTypes.push(...i),this.endInstructionTypes.push(...o),this.lookupTableAddress.push(...r.filter(s=>s!==yt.default.toString())),this}async versionBuild({txVersion:e,extInfo:t}){return e===0?await this.buildV0(O({},t||{})):this.build(t)}build(e){var n;let t=new Lt;return this.allInstructions.length&&t.add(...this.allInstructions),t.feePayer=this.feePayer,((n=this.owner)==null?void 0:n.signer)&&!this.signers.some(i=>i.publicKey.equals(this.owner.publicKey))&&this.signers.push(this.owner.signer),{builder:this,transaction:t,signers:this.signers,instructionTypes:[...this.instructionTypes,...this.endInstructionTypes],execute:async i=>{var l;let{recentBlockHash:o,skipPreflight:r=!0,sendAndConfirm:s,notSendToRpc:a}=i||{},c=o!=null?o:await dt(this.connection,this.blockhashCommitment);if(t.recentBlockhash=c,this.signers.length&&t.sign(...this.signers),ot([t]),(l=this.owner)!=null&&l.isKeyPair)return{txId:s?await Sn(this.connection,t,this.signers.find(f=>f.publicKey.equals(this.owner.publicKey))?this.signers:[...this.signers,this.owner.signer],{skipPreflight:r}):await this.connection.sendRawTransaction(t.serialize(),{skipPreflight:r}),signedTx:t};if(this.signAllTransactions){let d=await this.signAllTransactions([t]);if(this.signers.length)for(let f of d)try{f.sign(...this.signers)}catch{}return{txId:a?"":await this.connection.sendRawTransaction(d[0].serialize(),{skipPreflight:r}),signedTx:d[0]}}throw new Error("please provide owner in keypair format or signAllTransactions function")},extInfo:e||{}}}buildMultiTx(e){var c;let{extraPreBuildData:t=[],extInfo:n}=e,{transaction:i}=this.build(n),o=t.filter(l=>l.transaction.instructions.length>0),r=[i,...o.map(l=>l.transaction)],s=[this.signers,...o.map(l=>l.signers)],a=[...this.instructionTypes,...o.map(l=>l.instructionTypes).flat()];return(c=this.owner)!=null&&c.signer&&s.forEach(l=>{l.some(d=>d.publicKey.equals(this.owner.publicKey))||this.signers.push(this.owner.signer)}),{builder:this,transactions:r,signers:s,instructionTypes:a,execute:async l=>{var g;let{sequentially:d,onTxUpdate:f,skipTxCount:u=0,recentBlockHash:m,skipPreflight:p=!0}=l||{},b=m!=null?m:await dt(this.connection,this.blockhashCommitment);if((g=this.owner)!=null&&g.isKeyPair){if(d){let P=[],A=0;for(let T of r){if(++A,A<=u)continue;let k=await Sn(this.connection,T,this.signers.find(w=>w.publicKey.equals(this.owner.publicKey))?this.signers:[...this.signers,this.owner.signer],{skipPreflight:p});P.push(k)}return{txIds:P,signedTxs:r}}return{txIds:await await Promise.all(r.map(async P=>(P.recentBlockhash=b,await this.connection.sendRawTransaction(P.serialize(),{skipPreflight:p})))),signedTxs:r}}if(this.signAllTransactions){let P=r.map((T,k)=>(T.recentBlockhash=b,s[k].length&&T.sign(...s[k]),T));ot(P);let A=await this.signAllTransactions(P);if(d){let T=0,k=[],w=async()=>{if(!A[T])return;let h=await this.connection.sendRawTransaction(A[T].serialize(),{skipPreflight:p});k.push({txId:h,status:"sent",signedTx:A[T]}),f==null||f([...k]),T++;let x=!1,B=null,C=null,R=K=>{B!==null&&clearInterval(B),C!==null&&this.connection.removeSignatureListener(C);let M=k.findIndex(S=>S.txId===h);if(M>-1){if(k[M].status==="error"||k[M].status==="success")return;k[M].status=K.err?"error":"success"}f==null||f([...k]),K.err||w()};this.loopMultiTxStatus&&(B=setInterval(async()=>{var K;if(x){clearInterval(B);return}try{let M=await this.connection.getTransaction(h,{commitment:"confirmed",maxSupportedTransactionVersion:0});M&&(x=!0,clearInterval(B),R({err:((K=M.meta)==null?void 0:K.err)||null}),console.log("tx status from getTransaction:",h))}catch(M){x=!0,clearInterval(B),console.error("getTransaction timeout:",M,h)}},en)),C=this.connection.onSignature(h,K=>{if(x){this.connection.removeSignatureListener(C);return}x=!0,R(K)},"confirmed"),this.connection.getSignatureStatus(h)};return await w(),{txIds:k.map(h=>h.txId),signedTxs:A}}else{let T=[];for(let k=0;k<A.length;k+=1){let w=await this.connection.sendRawTransaction(A[k].serialize(),{skipPreflight:p});T.push(w)}return{txIds:T,signedTxs:A}}}throw new Error("please provide owner in keypair format or signAllTransactions function")},extInfo:n||{}}}async versionMultiBuild({extraPreBuildData:e,txVersion:t,extInfo:n}){return t===0?await this.buildV0MultiTx({extraPreBuildData:e,buildProps:n||{}}):this.buildMultiTx({extraPreBuildData:e,extInfo:n})}async buildV0(e){var p;let m=e||{},{lookupTableCache:t={},lookupTableAddress:n=[],forerunCreate:i,recentBlockhash:o}=m,r=mt(m,["lookupTableCache","lookupTableAddress","forerunCreate","recentBlockhash"]),s=O(O({},this.cluster==="devnet"?await In(this.connection):$t),t),a=Array.from(new Set([...n,...this.lookupTableAddress])),c=[];for(let b of a)s[b]===void 0&&c.push(new yt(b));let l=await Bn({connection:this.connection,address:c});for(let[b,g]of Object.entries(l))s[b]=g;let d=i?yt.default.toBase58():o!=null?o:await dt(this.connection,this.blockhashCommitment),f=new Rt({payerKey:this.feePayer,recentBlockhash:d,instructions:[...this.allInstructions]}).compileToV0Message(Object.values(s));((p=this.owner)==null?void 0:p.signer)&&!this.signers.some(b=>b.publicKey.equals(this.owner.publicKey))&&this.signers.push(this.owner.signer);let u=new Nt(f);return u.sign(this.signers),{builder:this,transaction:u,signers:this.signers,instructionTypes:[...this.instructionTypes,...this.endInstructionTypes],execute:async b=>{var T;let{skipPreflight:g=!0,sendAndConfirm:P,notSendToRpc:A}=b||{};if(ot([u]),(T=this.owner)!=null&&T.isKeyPair){let k=await this.connection.sendTransaction(u,{skipPreflight:g});return P&&await Yt(this.connection,k),{txId:k,signedTx:u}}if(this.signAllTransactions){let k=await this.signAllTransactions([u]);if(this.signers.length)for(let w of k)try{w.sign(this.signers)}catch{}return{txId:A?"":await this.connection.sendTransaction(k[0],{skipPreflight:g}),signedTx:k[0]}}throw new Error("please provide owner in keypair format or signAllTransactions function")},extInfo:r||{}}}async buildV0MultiTx(e){var c;let{extraPreBuildData:t=[],buildProps:n}=e,{transaction:i}=await this.buildV0(n),o=t.filter(l=>l.builder.instructions.length>0),r=[i,...o.map(l=>l.transaction)],s=[this.signers,...o.map(l=>l.signers)],a=[...this.instructionTypes,...o.map(l=>l.instructionTypes).flat()];return(c=this.owner)!=null&&c.signer&&s.forEach(l=>{l.some(d=>d.publicKey.equals(this.owner.publicKey))||this.signers.push(this.owner.signer)}),r.forEach(async(l,d)=>{l.sign(s[d])}),{builder:this,transactions:r,signers:s,instructionTypes:a,buildProps:n,execute:async l=>{var p;let{sequentially:d,onTxUpdate:f,recentBlockHash:u,skipPreflight:m=!0}=l||{};if(u&&r.forEach(b=>b.message.recentBlockhash=u),ot(r),(p=this.owner)!=null&&p.isKeyPair){if(d){let b=[];for(let g of r){let P=await this.connection.sendTransaction(g,{skipPreflight:m});await Yt(this.connection,P),b.push(P)}return{txIds:b,signedTxs:r}}return{txIds:await Promise.all(r.map(async b=>await this.connection.sendTransaction(b,{skipPreflight:m}))),signedTxs:r}}if(this.signAllTransactions){let b=await this.signAllTransactions(r);if(d){let g=0,P=[],A=async()=>{if(!b[g])return;let T=await this.connection.sendTransaction(b[g],{skipPreflight:m});P.push({txId:T,status:"sent",signedTx:b[g]}),f==null||f([...P]),g++;let k=!1,w=null,h=null,x=B=>{w!==null&&clearInterval(w),h!==null&&this.connection.removeSignatureListener(h);let C=P.findIndex(R=>R.txId===T);if(C>-1){if(P[C].status==="error"||P[C].status==="success")return;P[C].status=B.err?"error":"success"}f==null||f([...P]),B.err||A()};this.loopMultiTxStatus&&(w=setInterval(async()=>{var B;if(k){clearInterval(w);return}try{let C=await this.connection.getTransaction(T,{commitment:"confirmed",maxSupportedTransactionVersion:0});C&&(k=!0,clearInterval(w),x({err:((B=C.meta)==null?void 0:B.err)||null}),console.log("tx status from getTransaction:",T))}catch(C){k=!0,clearInterval(w),console.error("getTransaction timeout:",C,T)}},en)),h=this.connection.onSignature(T,B=>{if(k){this.connection.removeSignatureListener(h);return}k=!0,x(B)},"confirmed"),this.connection.getSignatureStatus(T)};return A(),{txIds:[],signedTxs:b}}else{let g=[];for(let P=0;P<b.length;P+=1){let A=await this.connection.sendTransaction(b[P],{skipPreflight:m});g.push(A)}return{txIds:g,signedTxs:b}}}throw new Error("please provide owner in keypair format or signAllTransactions function")},extInfo:n||{}}}async sizeCheckBuild(e){var f;let d=e||{},{splitIns:t=[],computeBudgetConfig:n}=d,i=mt(d,["splitIns","computeBudgetConfig"]),o=n?Qt(n):{instructions:[],instructionTypes:[]},r=this.signers.reduce((u,m)=>G(O({},u),{[m.publicKey.toBase58()]:m}),{}),s=[],a=[],c=[],l=0;if(this.allInstructions.forEach(u=>{let m=[...c,u],p=n?[...o.instructions,...m]:m,g=[...new Set(m.map(P=>P.keys.filter(A=>A.isSigner).map(A=>A.pubkey.toString())).flat()).values()].map(P=>new yt(P));if(u!==t[l]&&c.length<12&&(Bt({instructions:p,payer:this.feePayer,signers:g})||Bt({instructions:m,payer:this.feePayer,signers:g})))c.push(u);else{if(c.length===0)throw Error("item ins too big");l+=u===t[l]?1:0,Bt({instructions:n?[...o.instructions,...c]:[...c],payer:this.feePayer,signers:g})?s.push(new Lt().add(...o.instructions,...c)):s.push(new Lt().add(...c)),a.push(Array.from(new Set(c.map(P=>P.keys.filter(A=>A.isSigner).map(A=>A.pubkey.toString())).flat())).map(P=>r[P]).filter(P=>P!==void 0)),c=[u]}}),c.length>0){let m=[...new Set(c.map(p=>p.keys.filter(b=>b.isSigner).map(b=>b.pubkey.toString())).flat()).values()].map(p=>r[p]).filter(p=>p!==void 0);Bt({instructions:n?[...o.instructions,...c]:[...c],payer:this.feePayer,signers:m.map(p=>p.publicKey)})?s.push(new Lt().add(...o.instructions,...c)):s.push(new Lt().add(...c)),a.push(m)}return s.forEach(u=>u.feePayer=this.feePayer),(f=this.owner)!=null&&f.signer&&a.forEach(u=>{u.some(m=>m.publicKey.equals(this.owner.publicKey))||u.push(this.owner.signer)}),{builder:this,transactions:s,signers:a,instructionTypes:this.instructionTypes,execute:async u=>{var T;let{sequentially:m,onTxUpdate:p,skipTxCount:b=0,recentBlockHash:g,skipPreflight:P=!0}=u||{},A=g!=null?g:await dt(this.connection,this.blockhashCommitment);if(s.forEach(async(k,w)=>{k.recentBlockhash=A,a[w].length&&k.sign(...a[w])}),ot(s),(T=this.owner)!=null&&T.isKeyPair){if(m){let k=0,w=[];for(let h of s){if(++k,k<=b){w.push("tx skipped");continue}let x=await Sn(this.connection,h,this.signers.find(B=>B.publicKey.equals(this.owner.publicKey))?this.signers:[...this.signers,this.owner.signer],{skipPreflight:P});w.push(x)}return{txIds:w,signedTxs:s}}return{txIds:await Promise.all(s.map(async k=>await this.connection.sendRawTransaction(k.serialize(),{skipPreflight:P}))),signedTxs:s}}if(this.signAllTransactions){let k=await this.signAllTransactions(s.slice(b,s.length)),w=[...s.slice(0,b),...k];if(m){let h=0,x=[],B=async()=>{if(!w[h])return;h<b&&(x.push({txId:"",status:"success",signedTx:w[h]}),p==null||p([...x]),h++,B());let C=await this.connection.sendRawTransaction(w[h].serialize(),{skipPreflight:P});x.push({txId:C,status:"sent",signedTx:w[h]}),p==null||p([...x]),h++;let R=!1,K=null,M=null,S=D=>{K!==null&&clearInterval(K),M!==null&&this.connection.removeSignatureListener(M);let U=x.findIndex(be=>be.txId===C);if(U>-1){if(x[U].status==="error"||x[U].status==="success")return;x[U].status=D.err?"error":"success"}p==null||p([...x]),D.err||B()};this.loopMultiTxStatus&&(K=setInterval(async()=>{var D;if(R){clearInterval(K);return}try{let U=await this.connection.getTransaction(C,{commitment:"confirmed",maxSupportedTransactionVersion:0});U&&(R=!0,clearInterval(K),S({err:((D=U.meta)==null?void 0:D.err)||null}),console.log("tx status from getTransaction:",C))}catch(U){R=!0,clearInterval(K),console.error("getTransaction timeout:",U,C)}},en)),M=this.connection.onSignature(C,D=>{if(R){this.connection.removeSignatureListener(M);return}R=!0,S(D)},"confirmed"),this.connection.getSignatureStatus(C)};return await B(),{txIds:x.map(C=>C.txId),signedTxs:w}}else{let h=[];for(let x=0;x<w.length;x+=1){let B=await this.connection.sendRawTransaction(w[x].serialize(),{skipPreflight:P});h.push(B)}return{txIds:h,signedTxs:w}}}throw new Error("please provide owner in keypair format or signAllTransactions function")},extInfo:i||{}}}async sizeCheckBuildV0(e){var A;let P=e||{},{computeBudgetConfig:t,splitIns:n=[],lookupTableCache:i={},lookupTableAddress:o=[]}=P,r=mt(P,["computeBudgetConfig","splitIns","lookupTableCache","lookupTableAddress"]),s=O(O({},this.cluster==="devnet"?await In(this.connection):$t),i),a=Array.from(new Set([...this.lookupTableAddress,...o])),c=[];for(let T of a)s[T]===void 0&&c.push(new yt(T));let l=await Bn({connection:this.connection,address:c});for(let[T,k]of Object.entries(l))s[T]=k;let d=t?Qt(t):{instructions:[],instructionTypes:[]},f=await dt(this.connection,this.blockhashCommitment),u=this.signers.reduce((T,k)=>G(O({},T),{[k.publicKey.toBase58()]:k}),{}),m=[],p=[],b=[],g=0;if(this.allInstructions.forEach(T=>{let k=[...b,T],w=t?[...d.instructions,...k]:k;if(T!==n[g]&&b.length<12&&(It({instructions:w,payer:this.feePayer,lookupTableAddressAccount:s})||It({instructions:k,payer:this.feePayer,lookupTableAddressAccount:s})))b.push(T);else{if(b.length===0)throw Error("item ins too big");g+=T===n[g]?1:0;let h={};for(let x of[...new Set(a)])s[x]!==void 0&&(h[x]=s[x]);if(t&&It({instructions:[...d.instructions,...b],payer:this.feePayer,lookupTableAddressAccount:s,recentBlockhash:f})){let x=new Rt({payerKey:this.feePayer,recentBlockhash:f,instructions:[...d.instructions,...b]}).compileToV0Message(Object.values(s));m.push(new Nt(x))}else{let x=new Rt({payerKey:this.feePayer,recentBlockhash:f,instructions:[...b]}).compileToV0Message(Object.values(s));m.push(new Nt(x))}p.push(Array.from(new Set(b.map(x=>x.keys.filter(B=>B.isSigner).map(B=>B.pubkey.toString())).flat())).map(x=>u[x]).filter(x=>x!==void 0)),b=[T]}}),b.length>0){let k=[...new Set(b.map(w=>w.keys.filter(h=>h.isSigner).map(h=>h.pubkey.toString())).flat()).values()].map(w=>u[w]).filter(w=>w!==void 0);if(t&&It({instructions:[...d.instructions,...b],payer:this.feePayer,lookupTableAddressAccount:s,recentBlockhash:f})){let w=new Rt({payerKey:this.feePayer,recentBlockhash:f,instructions:[...d.instructions,...b]}).compileToV0Message(Object.values(s));m.push(new Nt(w))}else{let w=new Rt({payerKey:this.feePayer,recentBlockhash:f,instructions:[...b]}).compileToV0Message(Object.values(s));m.push(new Nt(w))}p.push(k)}return(A=this.owner)!=null&&A.signer&&p.forEach(T=>{T.some(k=>k.publicKey.equals(this.owner.publicKey))||T.push(this.owner.signer)}),m.forEach((T,k)=>{T.sign(p[k])}),{builder:this,transactions:m,buildProps:e,signers:p,instructionTypes:this.instructionTypes,execute:async T=>{var C;let{sequentially:k,onTxUpdate:w,skipTxCount:h=0,recentBlockHash:x,skipPreflight:B=!0}=T||{};if(m.map(async(R,K)=>{p[K].length&&R.sign(p[K]),x&&(R.message.recentBlockhash=x)}),ot(m),(C=this.owner)!=null&&C.isKeyPair){if(k){let R=0,K=[];for(let M of m){if(++R,R<=h){console.log("skip tx: ",R),K.push("tx skipped");continue}let S=await this.connection.sendTransaction(M,{skipPreflight:B});await Yt(this.connection,S),K.push(S)}return{txIds:K,signedTxs:m}}return{txIds:await Promise.all(m.map(async R=>await this.connection.sendTransaction(R,{skipPreflight:B}))),signedTxs:m}}if(this.signAllTransactions){let R=await this.signAllTransactions(m.slice(h,m.length)),K=[...m.slice(0,h),...R];if(k){let M=0,S=[],D=async()=>{if(!K[M])return;if(M<h){S.push({txId:"",status:"success",signedTx:K[M]}),w==null||w([...S]),M++,D();return}let U=await this.connection.sendTransaction(K[M],{skipPreflight:B});S.push({txId:U,status:"sent",signedTx:K[M]}),w==null||w([...S]),M++;let be=!1,Te=null,Ue=null,lt=pe=>{Te!==null&&clearInterval(Te),Ue!==null&&this.connection.removeSignatureListener(Ue);let Be=S.findIndex(Ye=>Ye.txId===U);if(Be>-1){if(S[Be].status==="error"||S[Be].status==="success")return;S[Be].status=pe.err?"error":"success"}w==null||w([...S]),pe.err||D()};this.loopMultiTxStatus&&(Te=setInterval(async()=>{var pe;if(be){clearInterval(Te);return}try{let Be=await this.connection.getTransaction(U,{commitment:"confirmed",maxSupportedTransactionVersion:0});Be&&(be=!0,clearInterval(Te),lt({err:((pe=Be.meta)==null?void 0:pe.err)||null}),console.log("tx status from getTransaction:",U))}catch(Be){be=!0,clearInterval(Te),console.error("getTransaction timeout:",Be,U)}},en)),Ue=this.connection.onSignature(U,pe=>{if(be){this.connection.removeSignatureListener(Ue);return}be=!0,lt(pe)},"confirmed"),this.connection.getSignatureStatus(U)};return D(),{txIds:[],signedTxs:K}}else{let M=[];for(let S=0;S<K.length;S+=1){let D=await this.connection.sendTransaction(K[S],{skipPreflight:B});M.push(D)}return{txIds:M,signedTxs:K}}}throw new Error("please provide owner in keypair format or signAllTransactions function")},extInfo:r||{}}}};import Ir from"bn.js";var Tc=new Ir(1e6);import{AccountLayout as vi,createAssociatedTokenAccountIdempotentInstruction as Vi,TOKEN_2022_PROGRAM_ID as nt,TOKEN_PROGRAM_ID as Gt}from"@solana/spl-token";import{PublicKey as Xc}from"@solana/web3.js";import{MintLayout as Hc,TOKEN_PROGRAM_ID as Zc}from"@solana/spl-token";var nn=i=>{var o=i,{address:y,programId:e,decimals:t}=o,n=mt(o,["address","programId","decimals"]);return O({chainId:101,address:it(y).toBase58(),programId:e,logoURI:"",symbol:"",name:"",decimals:t,tags:[],extensions:n.extensions||{}},n)},Cn=y=>y?G(O({},y),{transferFeeConfigAuthority:y.transferFeeConfigAuthority.toBase58(),withdrawWithheldAuthority:y.withdrawWithheldAuthority.toBase58(),withheldAmount:y.withheldAmount.toString(),olderTransferFee:G(O({},y.olderTransferFee),{epoch:y.olderTransferFee.epoch.toString(),maximumFee:y.olderTransferFee.maximumFee.toString()}),newerTransferFee:G(O({},y.newerTransferFee),{epoch:y.newerTransferFee.epoch.toString(),maximumFee:y.newerTransferFee.maximumFee.toString()})}):void 0;var Kn=(...y)=>y.map(e=>{try{return typeof e=="object"?JSON.stringify(e):e}catch{return e}}).join(", "),Mt=class{constructor({scope:e,moduleName:t}){this.disabled=!1;this.scope=e,this.logger=Pe(t)}createTxBuilder(e){return this.scope.checkOwner(),new tn({connection:this.scope.connection,feePayer:e||this.scope.ownerPubKey,cluster:this.scope.cluster,owner:this.scope.owner,blockhashCommitment:this.scope.blockhashCommitment,loopMultiTxStatus:this.scope.loopMultiTxStatus,api:this.scope.api,signAllTransactions:this.scope.signAllTransactions})}logDebug(...e){this.logger.debug(Kn(e))}logInfo(...e){this.logger.info(Kn(e))}logAndCreateError(...e){let t=Kn(e);throw new Error(t)}checkDisabled(){(this.disabled||!this.scope)&&this.logAndCreateError("module not working")}};import{Keypair as un,PublicKey as I,SystemProgram as Qe,TransactionInstruction as Ae}from"@solana/web3.js";import Gn from"bn.js";import{ASSOCIATED_TOKEN_PROGRAM_ID as qt,TOKEN_2022_PROGRAM_ID as me,TOKEN_PROGRAM_ID as $}from"@solana/spl-token";import{PublicKey as Fr}from"@solana/web3.js";import pi,{isBN as fi}from"bn.js";import{bits as su,BitStructure as au,blob as Sr,Blob as cu,cstr as uu,f32 as lu,f32be as mu,f64 as du,f64be as pu,greedy as fu,Layout as Cr,ns64 as yu,ns64be as bu,nu64 as gu,nu64be as wu,offset as Pu,s16 as ku,s16be as Au,s24 as Tu,s24be as hu,s32 as Kr,s32be as xu,s40 as Bu,s40be as Iu,s48 as Su,s48be as Cu,s8 as Ku,seq as Lr,struct as Lu,Structure as Rr,u16 as Nr,u16be as Ru,u24 as Nu,u24be as Mu,u32 as Ou,u32be as Fu,u40 as Eu,u40be as Du,u48 as _u,u48be as Wu,u8 as Mr,UInt as Or,union as vu,Union as Vu,unionLayoutDiscriminator as qu,utf8 as Gu}from"@solana/buffer-layout";var Ln=Cr,li=Rr;var Rn=Or;var mi=Mr,Ot=Nr;var ie=Kr;var di=Lr;var Le=Sr;var bt=class extends Ln{constructor(t,n,i){super(t,i);this.blob=Le(t),this.signed=n}decode(t,n=0){let i=new pi(this.blob.decode(t,n),10,"le");return this.signed?i.fromTwos(this.span*8).clone():i}encode(t,n,i=0){return typeof t=="number"&&(t=new pi(t)),this.signed&&(t=t.toTwos(this.span*8)),this.blob.encode(t.toArrayLike(Buffer,"le",this.span),n,i)}};function le(y){return new Rn(1,y)}function gt(y){return new Rn(4,y)}function F(y){return new bt(8,!1,y)}function X(y){return new bt(16,!1,y)}function yi(y){return new bt(8,!0,y)}function bi(y){return new bt(16,!0,y)}var rn=class extends Ln{constructor(t,n,i,o){super(t.span,o);this.layout=t,this.decoder=n,this.encoder=i}decode(t,n){return this.decoder(this.layout.decode(t,n))}encode(t,n,i){return this.layout.encode(this.encoder(t),n,i)}getSpan(t,n){return this.layout.getSpan(t,n)}};function ee(y){return new rn(Le(32),e=>new Fr(e),e=>e.toBuffer(),y)}function Ie(y){return new rn(mi(),Er,Dr,y)}function Er(y){if(y===0)return!1;if(y===1)return!0;throw new Error("Invalid bool: "+y)}function Dr(y){return y?1:0}var Nn=class extends li{decode(e,t){return super.decode(e,t)}};function J(y,e,t){return new Nn(y,e,t)}function ae(y,e,t){let n,i=typeof e=="number"?e:fi(e)?e.toNumber():new Proxy(e,{get(o,r){if(!n){let s=Reflect.get(o,"count");n=fi(s)?s.toNumber():s,Reflect.set(o,"count",n)}return Reflect.get(o,r)},set(o,r,s){return r==="count"&&(n=s),Reflect.set(o,r,s)}});return di(y,i,t)}import jr from"bn.js";import kt from"decimal.js";import Oe from"bn.js";var ce=new Oe(0),We=new Oe(1),je=new Oe(-1),Re=new Oe(1).shln(64),on=new Oe(1).shln(128),Mn=Re.sub(We),Ft=64,gi=on.subn(1),xe=-443636,Se=-xe,ve=new Oe("4295048016"),Ve=new Oe("79226673521066979257578248091"),il=new Oe("4295048017"),rl=new Oe("79226673521066979257578248090"),wi=16,Pi="59543866431248",ki="184467440737095516",Ai="15793534762490258745",sn=new Oe(10).pow(new Oe(6));var Ti={tvl:0,volumeQuote:0,mintAmountA:0,mintAmountB:0,rewardDefaultInfos:[],farmUpcomingCount:0,farmOngoingCount:0,farmFinishedCount:0,day:{volume:0,volumeQuote:0,volumeFee:0,apr:0,feeApr:0,priceMin:0,priceMax:0,rewardApr:[0]},week:{volume:0,volumeQuote:0,volumeFee:0,apr:0,feeApr:0,priceMin:0,priceMax:0,rewardApr:[0]},month:{volume:0,volumeQuote:0,volumeFee:0,apr:0,feeApr:0,priceMin:0,priceMax:0,rewardApr:[0]},pooltype:[]},ol=new Oe("18446744073700000000");import q from"bn.js";import Ge from"decimal.js";function an(y){let e=new ArrayBuffer(4);return new DataView(e).setInt32(0,y,!1),new Uint8Array(e)}function On(y,e){let t=0;for(let n=y-1;n>=0&&!e.testn(n);n--)t++;return t}function Fn(y,e){let t=0;for(let n=0;n<y&&!e.testn(n);n++)t++;return t}function Et(y,e){for(let t=0;t<y;t++)if(e.testn(t))return!1;return!0}function hi(y,e){return Et(y,e)?null:On(y,e)}function xi(y,e){return Et(y,e)?null:Fn(y,e)}var ml=Buffer.from("amm_config","utf8"),_r=Buffer.from("pool","utf8"),Wr=Buffer.from("pool_vault","utf8"),vr=Buffer.from("pool_reward_vault","utf8"),Bi=Buffer.from("position","utf8"),Vr=Buffer.from("tick_array","utf8"),qr=Buffer.from("operation","utf8"),Gr=Buffer.from("pool_tick_array_bitmap_extension","utf8"),Ur=Buffer.from("observation","utf8");function Ii(y,e,t,n){return he([_r,e.toBuffer(),t.toBuffer(),n.toBuffer()],y)}function En(y,e,t){return he([Wr,e.toBuffer(),t.toBuffer()],y)}function Si(y,e,t){return he([vr,e.toBuffer(),t.toBuffer()],y)}function z(y,e,t){return he([Vr,e.toBuffer(),an(t)],y)}function De(y,e,t,n){return he([Bi,e.toBuffer(),an(t),an(n)],y)}function Ce(y,e){return he([Bi,e.toBuffer()],y)}function Dt(y){return he([Buffer.from("metadata","utf8"),rt.toBuffer(),y.toBuffer()],rt)}function _t(y){return he([qr],y)}function fe(y,e){return he([Gr,e.toBuffer()],y)}function Ci(y,e){return he([Ur,e.toBuffer()],y)}var Ki=Buffer.from("locked_position","utf8");function Dn(y,e){return he([Ki,e.toBuffer()],y)}function wt(y,e){return he([Ki,e.toBuffer()],y)}var Xr=Buffer.from("support_mint","utf8");function _n(y,e){return he([Xr,e.toBuffer()],y)}import{PublicKey as Ne}from"@solana/web3.js";import{TOKEN_2022_PROGRAM_ID as Li}from"@solana/spl-token";import re from"bn.js";import j from"decimal.js";import qe from"bn.js";import Wn from"decimal.js";var Wt=class{static getfeeGrowthInside(e,t,n){let i=new qe(0),o=new qe(0);e.tickCurrent>=t.tick?(i=t.feeGrowthOutsideX64A,o=t.feeGrowthOutsideX64B):(i=e.feeGrowthGlobalX64A.sub(t.feeGrowthOutsideX64A),o=e.feeGrowthGlobalX64B.sub(t.feeGrowthOutsideX64B));let r=new qe(0),s=new qe(0);e.tickCurrent<n.tick?(r=n.feeGrowthOutsideX64A,s=n.feeGrowthOutsideX64B):(r=e.feeGrowthGlobalX64A.sub(n.feeGrowthOutsideX64A),s=e.feeGrowthGlobalX64B.sub(n.feeGrowthOutsideX64B));let a=W.wrappingSubU128(W.wrappingSubU128(e.feeGrowthGlobalX64A,i),r),c=W.wrappingSubU128(W.wrappingSubU128(e.feeGrowthGlobalX64B,o),s);return{feeGrowthInsideX64A:a,feeGrowthInsideBX64:c}}static GetPositionFees(e,t,n,i){let{feeGrowthInsideX64A:o,feeGrowthInsideBX64:r}=this.getfeeGrowthInside(e,n,i),s=W.mulDivFloor(W.wrappingSubU128(o,t.feeGrowthInsideLastX64A),t.liquidity,Re),a=t.tokenFeesOwedA.add(s),c=W.mulDivFloor(W.wrappingSubU128(r,t.feeGrowthInsideLastX64B),t.liquidity,Re),l=t.tokenFeesOwedB.add(c);return{tokenFeeAmountA:a,tokenFeeAmountB:l}}static GetPositionFeesV2(e,t,n,i){let{feeGrowthInsideX64A:o,feeGrowthInsideBX64:r}=this.getfeeGrowthInside(e,n,i),s=W.mulDivFloor(W.wrappingSubU128(o,t.feeGrowthInsideLastX64A),t.liquidity,Re),a=t.tokenFeesOwedA.add(s),c=W.mulDivFloor(W.wrappingSubU128(r,t.feeGrowthInsideLastX64B),t.liquidity,Re),l=t.tokenFeesOwedB.add(c);return{tokenFeeAmountA:a,tokenFeeAmountB:l}}static GetPositionRewardsV2(e,t,n,i){let o=[],r=this.getRewardGrowthInsideV2(e.tickCurrent,n,i,e.rewardInfos);for(let s=0;s<r.length;s++){let a=r[s],c=t.rewardInfos[s],l=W.wrappingSubU128(a,c.growthInsideLastX64),d=W.mulDivFloor(l,t.liquidity,Re),f=c.rewardAmountOwed.add(d);o.push(f)}return o}static GetPositionRewards(e,t,n,i){let o=[],r=this.getRewardGrowthInside(e.tickCurrent,n,i,e.rewardInfos);for(let s=0;s<r.length;s++){let a=r[s],c=t.rewardInfos[s],l=W.wrappingSubU128(a,c.growthInsideLastX64),d=W.mulDivFloor(l,t.liquidity,Re),f=c.rewardAmountOwed.add(d);o.push(f)}return o}static getRewardGrowthInside(e,t,n,i){let o=[];for(let r=0;r<i.length;r++){let s=new qe(0);t.liquidityGross.eqn(0)?s=i[r].rewardGrowthGlobalX64:e<t.tick?s=i[r].rewardGrowthGlobalX64.sub(t.rewardGrowthsOutsideX64[r]):s=t.rewardGrowthsOutsideX64[r];let a=new qe(0);n.liquidityGross.eqn(0)||(e<n.tick?a=n.rewardGrowthsOutsideX64[r]:a=i[r].rewardGrowthGlobalX64.sub(n.rewardGrowthsOutsideX64[r])),o.push(W.wrappingSubU128(W.wrappingSubU128(i[r].rewardGrowthGlobalX64,s),a))}return o}static getRewardGrowthInsideV2(e,t,n,i){let o=[];for(let r=0;r<i.length;r++){let s=new qe(0);t.liquidityGross.eqn(0)?s=i[r].rewardGrowthGlobalX64:e<t.tick?s=i[r].rewardGrowthGlobalX64.sub(t.rewardGrowthsOutsideX64[r]):s=t.rewardGrowthsOutsideX64[r];let a=new qe(0);n.liquidityGross.eqn(0)||(e<n.tick?a=n.rewardGrowthsOutsideX64[r]:a=i[r].rewardGrowthGlobalX64.sub(n.rewardGrowthsOutsideX64[r])),o.push(W.wrappingSubU128(W.wrappingSubU128(i[r].rewardGrowthGlobalX64,s),a))}return o}static getAmountsFromLiquidity({poolInfo:e,ownerPosition:t,liquidity:n,slippage:i,add:o,epochInfo:r}){var b,g,P,A;let s=_.priceToSqrtPriceX64(new Wn(e.price),e.mintA.decimals,e.mintB.decimals),a=_.getSqrtPriceX64FromTick(t.tickLower),c=_.getSqrtPriceX64FromTick(t.tickUpper),l=o?1+i:1-i,d=Z.getAmountsFromLiquidity(s,a,c,n,o),[f,u]=[de(d.amountA,(b=e.mintA.extensions)==null?void 0:b.feeConfig,r,!0),de(d.amountB,(g=e.mintB.extensions)==null?void 0:g.feeConfig,r,!0)],[m,p]=[de(new qe(new Wn(d.amountA.toString()).mul(l).toFixed(0)),(P=e.mintA.extensions)==null?void 0:P.feeConfig,r,!0),de(new qe(new Wn(d.amountB.toString()).mul(l).toFixed(0)),(A=e.mintB.extensions)==null?void 0:A.feeConfig,r,!0)];return{liquidity:n,amountA:f,amountB:u,amountSlippageA:m,amountSlippageB:p,expirationTime:tt(f.expirationTime,u.expirationTime)}}};var zr=15,H=class{static async getTickArrays(e,t,n,i,o,r,s){let a=[],c=N.getTickArrayStartIndexByTick(i,o),l=N.getInitializedTickArrayInRange(r,s,o,c,Math.floor(zr/2));for(let u=0;u<l.length;u++){let{publicKey:m}=z(t,n,l[u]);a.push(m)}let d=(await Xe(e,a)).map(u=>u!==null?vt.decode(u.data):null),f={};for(let u=0;u<a.length;u++){let m=d[u];m!==null&&(f[m.startTickIndex]=G(O({},m),{address:a[u]}))}return f}static nextInitializedTick(e,t,n,i,o,r){let{initializedTick:s,tickArrayAddress:a,tickArrayStartTickIndex:c}=this.nextInitializedTickInOneArray(e,t,n,i,o,r);for(;s==null||s.liquidityGross.lten(0);){if(c=N.getNextTickArrayStartIndex(c,o,r),this.checkIsValidStartIndex(c,o))throw new Error("No enough initialized tickArray");let l=n[c];if(l===void 0)continue;let{nextTick:d,tickArrayAddress:f,tickArrayStartTickIndex:u}=this.firstInitializedTickInOneArray(e,t,l,r);[s,a,c]=[d,f,u]}if(s==null)throw new Error("No invaild tickArray cache");return{nextTick:s,tickArrayAddress:a,tickArrayStartTickIndex:c}}static nextInitializedTickArray(e,t,n,i,o){let r=Math.floor(e/H.tickCount(t)),s=n?N.searchLowBitFromStart(i,o,r-1,1,t):N.searchHightBitFromStart(i,o,r+1,1,t);return s.length>0?{isExist:!0,nextStartIndex:s[0]}:{isExist:!1,nextStartIndex:0}}static firstInitializedTickInOneArray(e,t,n,i){let o;if(i){let s=ye-1;for(;s>=0;){let a=n.ticks[s];if(a.liquidityGross.gtn(0)){o=a;break}s=s-1}}else{let s=0;for(;s<ye;){let a=n.ticks[s];if(a.liquidityGross.gtn(0)){o=a;break}s=s+1}}let{publicKey:r}=z(e,t,n.startTickIndex);return{nextTick:o,tickArrayAddress:r,tickArrayStartTickIndex:n.startTickIndex}}static nextInitializedTickInOneArray(e,t,n,i,o,r){let s=N.getTickArrayStartIndexByTick(i,o),a=Math.floor((i-s)/o),c=n[s];if(c==null)return{initializedTick:void 0,tickArrayAddress:void 0,tickArrayStartTickIndex:s};let l;if(r)for(;a>=0;){let f=c.ticks[a];if(f.liquidityGross.gtn(0)){l=f;break}a=a-1}else for(a=a+1;a<ye;){let f=c.ticks[a];if(f.liquidityGross.gtn(0)){l=f;break}a=a+1}let{publicKey:d}=z(e,t,s);return{initializedTick:l,tickArrayAddress:d,tickArrayStartTickIndex:c.startTickIndex}}static getArrayStartIndex(e,t){let n=this.tickCount(t);return Math.floor(e/n)*n}static checkIsValidStartIndex(e,t){if(N.checkIsOutOfBoundary(e)){if(e>Se)return!1;let n=N.getTickArrayStartIndexByTick(xe,t);return e==n}return e%this.tickCount(t)==0}static tickCount(e){return ye*e}};var vn=14,Ze=class{static maxTickInTickarrayBitmap(e){return e*ye*st}static getBitmapTickBoundary(e,t){let n=this.maxTickInTickarrayBitmap(t),i=Math.floor(Math.abs(e)/n);e<0&&Math.abs(e)%n!=0&&(i+=1);let o=n*i;return e<0?{minValue:-o,maxValue:-o+n}:{minValue:o,maxValue:o+n}}static nextInitializedTickArrayStartIndex(e,t,n,i){if(!H.checkIsValidStartIndex(t,n))throw Error("nextInitializedTickArrayStartIndex check error");let o=this.maxTickInTickarrayBitmap(n),r=i?t-H.tickCount(n):t+H.tickCount(n);if(r<-o||r>=o)return{isInit:!1,tickIndex:t};let s=n*ye,a=r/s+512;r<0&&r%s!=0&&a--;let c=Math.abs(a);if(i){let l=e.shln(1024-c-1),d=hi(1024,l);if(d!==null){let f=(c-d-512)*s;return{isInit:!0,tickIndex:f}}else return{isInit:!1,tickIndex:-o}}else{let l=e.shrn(c),d=xi(1024,l);if(d!==null){let f=(c+d-512)*s;return{isInit:!0,tickIndex:f}}else return{isInit:!1,tickIndex:o-H.tickCount(n)}}}},Vt=class{static getBitmapOffset(e,t){if(!H.checkIsValidStartIndex(e,t))throw new Error("No enough initialized tickArray");this.checkExtensionBoundary(e,t);let n=Ze.maxTickInTickarrayBitmap(t),i=Math.floor(Math.abs(e)/n)-1;return e<0&&Math.abs(e)%n===0&&i--,i}static getBitmap(e,t,n){let i=this.getBitmapOffset(e,t);return e<0?{offset:i,tickarrayBitmap:n.negativeTickArrayBitmap[i]}:{offset:i,tickarrayBitmap:n.positiveTickArrayBitmap[i]}}static checkExtensionBoundary(e,t){let{positiveTickBoundary:n,negativeTickBoundary:i}=this.extensionTickBoundary(t);if(e>=i&&e<n)throw Error("checkExtensionBoundary -> InvalidTickArrayBoundary")}static extensionTickBoundary(e){let t=Ze.maxTickInTickarrayBitmap(e),n=-t;if(Se<=t)throw Error(`extensionTickBoundary check error: ${Se}, ${t}`);if(n<=xe)throw Error(`extensionTickBoundary check error: ${n}, ${xe}`);return{positiveTickBoundary:t,negativeTickBoundary:n}}static checkTickArrayIsInit(e,t,n){let{tickarrayBitmap:i}=this.getBitmap(e,t,n),o=this.tickArrayOffsetInBitmap(e,t);return{isInitialized:N.mergeTickArrayBitmap(i).testn(o),startIndex:e}}static nextInitializedTickArrayFromOneBitmap(e,t,n,i){let o=H.tickCount(t),r=n?e-o:e+o,{tickarrayBitmap:s}=this.getBitmap(r,t,i);return this.nextInitializedTickArrayInBitmap(s,r,t,n)}static nextInitializedTickArrayInBitmap(e,t,n,i){let{minValue:o,maxValue:r}=Ze.getBitmapTickBoundary(t,n),s=this.tickArrayOffsetInBitmap(t,n);if(i){let a=N.mergeTickArrayBitmap(e).shln(st-1-s),c=Et(512,a)?null:On(512,a);if(c!==null){let l=t-c*H.tickCount(n);return{isInit:!0,tickIndex:l}}else return{isInit:!1,tickIndex:o}}else{let a=N.mergeTickArrayBitmap(e).shrn(s),c=Et(512,a)?null:Fn(512,a);if(c!==null){let l=t+c*H.tickCount(n);return{isInit:!0,tickIndex:l}}else return{isInit:!1,tickIndex:r-H.tickCount(n)}}}static tickArrayOffsetInBitmap(e,t){let n=Math.abs(e)%Ze.maxTickInTickarrayBitmap(t),i=Math.floor(n/H.tickCount(t));return e<0&&n!=0&&(i=st-i),i}};var ue=class{static getOutputAmountAndRemainAccounts(e,t,n,i,o,r=!1){let s=n.toBase58()===e.mintA.address,a=[],{isExist:c,startIndex:l,nextAccountMeta:d}=this.getFirstInitializedTickArray(e,s);if(!c||l===void 0||!d)throw new Error("Invalid tick array");a.push(d);let{allTrade:f,amountCalculated:u,accounts:m,sqrtPriceX64:p,feeAmount:b}=at.swapCompute(e.programId,e.id,t,e.tickArrayBitmap,e.exBitmapInfo,s,e.ammConfig.tradeFeeRate,e.liquidity,e.tickCurrent,e.tickSpacing,e.sqrtPriceX64,i,l,o,r);return a.push(...m),{allTrade:f,expectedAmountOut:u.mul(je),remainingAccounts:a,executionPrice:p,feeAmount:b}}static getInputAmountAndRemainAccounts(e,t,n,i,o){let r=n.toBase58()===e.mintB.address,s=[],{isExist:a,startIndex:c,nextAccountMeta:l}=this.getFirstInitializedTickArray(e,r);if(!a||c===void 0||!l)throw new Error("Invalid tick array");try{let p=this.preInitializedTickArrayStartIndex(e,r);if(p.isExist){let{publicKey:b}=z(e.programId,e.id,p.nextStartIndex);s.push(b)}}catch{}s.push(l);let{amountCalculated:d,accounts:f,sqrtPriceX64:u,feeAmount:m}=at.swapCompute(e.programId,e.id,t,e.tickArrayBitmap,e.exBitmapInfo,r,e.ammConfig.tradeFeeRate,e.liquidity,e.tickCurrent,e.tickSpacing,e.sqrtPriceX64,i.mul(je),c,o);return s.push(...f),{expectedAmountIn:d,remainingAccounts:s,executionPrice:u,feeAmount:m}}static getFirstInitializedTickArray(e,t){let{isInitialized:n,startIndex:i}=ue.isOverflowDefaultTickarrayBitmap(e.tickSpacing,[e.tickCurrent])?Vt.checkTickArrayIsInit(H.getArrayStartIndex(e.tickCurrent,e.tickSpacing),e.tickSpacing,e.exBitmapInfo):N.checkTickArrayIsInitialized(N.mergeTickArrayBitmap(e.tickArrayBitmap),e.tickCurrent,e.tickSpacing);if(n){let{publicKey:s}=z(e.programId,e.id,i);return{isExist:!0,startIndex:i,nextAccountMeta:s}}let{isExist:o,nextStartIndex:r}=this.nextInitializedTickArrayStartIndex(e,H.getArrayStartIndex(e.tickCurrent,e.tickSpacing),t);if(o){let{publicKey:s}=z(e.programId,e.id,r);return{isExist:!0,startIndex:r,nextAccountMeta:s}}return{isExist:!1,nextAccountMeta:void 0,startIndex:void 0}}static preInitializedTickArrayStartIndex(e,t){let n=Math.floor(e.tickCurrent/H.tickCount(e.tickSpacing)),i=t?N.searchHightBitFromStart(e.tickArrayBitmap,e.exBitmapInfo,n+1,1,e.tickSpacing):N.searchLowBitFromStart(e.tickArrayBitmap,e.exBitmapInfo,n-1,1,e.tickSpacing);return i.length>0?{isExist:!0,nextStartIndex:i[0]}:{isExist:!1,nextStartIndex:0}}static nextInitializedTickArrayStartIndex(e,t,n){for(t=H.getArrayStartIndex(e.tickCurrent,e.tickSpacing);;){let{isInit:i,tickIndex:o}=Ze.nextInitializedTickArrayStartIndex(N.mergeTickArrayBitmap(e.tickArrayBitmap),t,e.tickSpacing,n);if(i)return{isExist:!0,nextStartIndex:o};t=o;let{isInit:r,tickIndex:s}=Vt.nextInitializedTickArrayFromOneBitmap(t,e.tickSpacing,n,e.exBitmapInfo);if(r)return{isExist:!0,nextStartIndex:s};if(t=s,t<xe||t>Se)return{isExist:!1,nextStartIndex:0}}}static async updatePoolRewardInfos({connection:e,apiPoolInfo:t,chainTime:n,poolLiquidity:i,rewardInfos:o}){var s,a,c;let r=[];for(let l=0;l<o.length;l++){let d=o[l],f=(c=(s=t.rewardDefaultInfos[l])==null?void 0:s.mint.programId)!=null?c:(a=await e.getAccountInfo(d.tokenMint))==null?void 0:a.owner;if(f===void 0)throw Error("get new reward mint info error");let u=G(O({},d),{perSecond:W.x64ToDecimal(d.emissionsPerSecondX64),remainingRewards:void 0,tokenProgramId:new Ne(f)});if(u.tokenMint.equals(Ne.default))continue;if(n<=u.openTime.toNumber()||i.eq(ce)){r.push(u);continue}let m=new re(Math.min(u.endTime.toNumber(),n)),p=m.sub(u.lastUpdateTime),b=W.mulDivFloor(p,u.emissionsPerSecondX64,i),g=u.rewardGrowthGlobalX64.add(b),P=W.mulDivFloor(p,u.emissionsPerSecondX64,Re),A=u.rewardTotalEmissioned.add(P);r.push(G(O({},u),{rewardGrowthGlobalX64:g,rewardTotalEmissioned:A,lastUpdateTime:m}))}return r}static isOverflowDefaultTickarrayBitmap(e,t){let{maxTickBoundary:n,minTickBoundary:i}=this.tickRange(e);for(let o of t){let r=N.getTickArrayStartIndexByTick(o,e);if(r>=n||r<i)return!0}return!1}static tickRange(e){let t=Ze.maxTickInTickarrayBitmap(e),n=-t;return t>Se&&(t=H.getArrayStartIndex(Se,e)+H.tickCount(e)),n<xe&&(n=H.getArrayStartIndex(xe,e)),{maxTickBoundary:t,minTickBoundary:n}}static get_tick_array_offset(e,t){if(!H.checkIsValidStartIndex(e,t))throw new Error("No enough initialized tickArray");return e/H.tickCount(t)*st}static async fetchExBitmaps({connection:e,exBitmapAddress:t,batchRequest:n}){let i=await ze(e,t.map(r=>({pubkey:r})),{batchRequest:n}),o={};for(let r of i)r.accountInfo!==null&&(o[r.pubkey.toString()]=Ni.decode(r.accountInfo.data));return o}static async fetchMultiplePoolTickArrays({connection:e,poolKeys:t,batchRequest:n}){let i={},o=[];for(let a of t){let c=N.getTickArrayStartIndexByTick(a.tickCurrent,a.tickSpacing),l=N.getInitializedTickArrayInRange(a.tickArrayBitmap,a.exBitmapInfo,a.tickSpacing,c,7);for(let d of l){let{publicKey:f}=z(a.programId,a.id,d);o.push({pubkey:f}),i[f.toString()]=a.id}}let r=await ze(e,o,{batchRequest:n}),s={};for(let a of r){if(!a.accountInfo)continue;let c=i[a.pubkey.toString()];if(!c)continue;s[c.toString()]===void 0&&(s[c.toString()]={});let l=vt.decode(a.accountInfo.data);s[c.toString()][l.startTickIndex]=G(O({},l),{address:a.pubkey})}return s}static async fetchPoolsAccountPosition({pools:e,connection:t,ownerInfo:n,batchRequest:i=!1,updateOwnerRewardAndFee:o=!0}){var s;let r=[];for(let a=0;a<e.length;a++){let c=e[a];c!==null&&(r.find(l=>l.equals(c.state.programId))||r.push(c.state.programId))}if(n){let a=n.tokenAccounts.map(f=>f.accountInfo.mint),c=[];for(let f of a)for(let u of r)c.push(Ce(u,f).publicKey);let l=await Xe(t,c,{batchRequest:i}),d={};for(let f of l){if(f===null)continue;let u=Pt.decode(f.data),m=u.poolId.toString(),p=e.find(x=>x.state.id.toBase58()===m);if(p===void 0)continue;let b=p.state,g=N._getTickPriceLegacy({poolInfo:b,tick:u.tickLower,baseIn:!0}),P=N._getTickPriceLegacy({poolInfo:b,tick:u.tickUpper,baseIn:!0}),{amountA:A,amountB:T}=Z.getAmountsFromLiquidity(b.sqrtPriceX64,g.tickSqrtPriceX64,P.tickSqrtPriceX64,u.liquidity,!1),k=1/(1-Math.sqrt(Math.sqrt(g.price.div(P.price).toNumber())));p.positionAccount=[...(s=p.positionAccount)!=null?s:[],{poolId:u.poolId,nftMint:u.nftMint,priceLower:g.price,priceUpper:P.price,amountA:A,amountB:T,tickLower:u.tickLower,tickUpper:u.tickUpper,liquidity:u.liquidity,feeGrowthInsideLastX64A:u.feeGrowthInsideLastX64A,feeGrowthInsideLastX64B:u.feeGrowthInsideLastX64B,tokenFeesOwedA:u.tokenFeesOwedA,tokenFeesOwedB:u.tokenFeesOwedB,rewardInfos:u.rewardInfos.map(x=>G(O({},x),{pendingReward:new re(0)})),leverage:k,tokenFeeAmountA:new re(0),tokenFeeAmountB:new re(0)}];let w=await N.getTickArrayAddressByTick(p.state.programId,u.poolId,u.tickLower,p.state.tickSpacing),h=await N.getTickArrayAddressByTick(p.state.programId,u.poolId,u.tickUpper,p.state.tickSpacing);d[`${p.state.programId.toString()}-${u.poolId.toString()}-${u.tickLower}`]=w,d[`${p.state.programId.toString()}-${u.poolId.toString()}-${u.tickUpper}`]=h}if(o){let f=Object.values(d),u=await Xe(t,f,{batchRequest:i}),m={};for(let p=0;p<f.length;p++){let b=u[p];if(b===null)continue;let g=f[p].toString();m[g]=vt.decode(b.data)}for(let{state:p,positionAccount:b}of e)if(!!b)for(let g of b){let P=`${p.programId.toString()}-${p.id.toString()}-${g.tickLower}`,A=`${p.programId.toString()}-${p.id.toString()}-${g.tickUpper}`,T=m[d[P].toString()],k=m[d[A].toString()],w=T.ticks[N.getTickOffsetInArray(g.tickLower,p.tickSpacing)],h=k.ticks[N.getTickOffsetInArray(g.tickUpper,p.tickSpacing)],{tokenFeeAmountA:x,tokenFeeAmountB:B}=await Wt.GetPositionFees(p,g,w,h),C=await Wt.GetPositionRewards(p,g,w,h);g.tokenFeeAmountA=x.gte(new re(0))?x:new re(0),g.tokenFeeAmountB=B.gte(new re(0))?B:new re(0);for(let R=0;R<C.length;R++)g.rewardInfos[R].pendingReward=C[R].gte(new re(0))?C[R]:new re(0)}}}return e}static computeAmountOut({poolInfo:e,tickArrayCache:t,baseMint:n,epochInfo:i,amountIn:o,slippage:r,priceLimit:s=new j(0),catchLiquidityInsufficient:a=!1}){var K;let c,l=n.toBase58()===e.mintA.address,[d,f]=l?[e.mintA.extensions.feeConfig,e.mintB.extensions.feeConfig]:[e.mintB.extensions.feeConfig,e.mintA.extensions.feeConfig];s.equals(new j(0))?c=l?ve.add(new re(1)):Ve.sub(new re(1)):c=_.priceToSqrtPriceX64(s,e.mintA.decimals,e.mintB.decimals);let u=de(o,d,i,!1),{allTrade:m,expectedAmountOut:p,remainingAccounts:b,executionPrice:g,feeAmount:P}=ue.getOutputAmountAndRemainAccounts(e,t,n,u.amount.sub((K=u.fee)!=null?K:ce),c,a),A=de(p,f,i,!1),T=_.sqrtPriceX64ToPrice(g,e.mintA.decimals,e.mintB.decimals),k=l?T:new j(1).div(T),w=p.mul(new re(Math.floor((1-r)*1e10))).div(new re(1e10)),h=de(w,f,i,!1),x=l?e.currentPrice:new j(1).div(e.currentPrice),B=new j(k).sub(x).abs(),C=x,R=new et(new j(B).mul(10**15).toFixed(0),new j(C).mul(10**15).toFixed(0));return{allTrade:m,realAmountIn:u,amountOut:A,minAmountOut:h,expirationTime:tt(u.expirationTime,A.expirationTime),currentPrice:e.currentPrice,executionPrice:k,priceImpact:R,fee:P,remainingAccounts:b,executionPriceX64:g}}static computeAmountOutFormat({poolInfo:e,tickArrayCache:t,amountIn:n,tokenOut:i,slippage:o,epochInfo:r,catchLiquidityInsufficient:s=!1}){let a=i.address===e.mintB.address,[c,l]=a?[e.mintA,e.mintB]:[e.mintB,e.mintA],[d,f]=[new _e(G(O({},c),{mint:c.address,isToken2022:c.programId===Li.toBase58()})),new _e(G(O({},l),{mint:l.address,isToken2022:l.programId===Li.toBase58()}))],{allTrade:u,realAmountIn:m,amountOut:p,minAmountOut:b,expirationTime:g,currentPrice:P,executionPrice:A,priceImpact:T,fee:k,remainingAccounts:w,executionPriceX64:h}=ue.computeAmountOut({poolInfo:e,tickArrayCache:t,baseMint:new Ne(c.address),amountIn:n,slippage:o,epochInfo:r,catchLiquidityInsufficient:s}),x=G(O({},m),{amount:new ke(d,m.amount),fee:m.fee===void 0?void 0:new ke(d,m.fee)}),B=G(O({},p),{amount:new ke(f,p.amount),fee:p.fee===void 0?void 0:new ke(f,p.fee)}),C=G(O({},b),{amount:new ke(f,b.amount),fee:b.fee===void 0?void 0:new ke(f,b.fee)}),R=new Fe({baseToken:d,denominator:new re(10).pow(new re(20+d.decimals)),quoteToken:f,numerator:P.mul(new j(10**(20+f.decimals))).toFixed(0)}),K=new Fe({baseToken:d,denominator:new re(10).pow(new re(20+d.decimals)),quoteToken:f,numerator:A.mul(new j(10**(20+f.decimals))).toFixed(0)}),M=new ke(d,k);return{allTrade:u,realAmountIn:x,amountOut:B,minAmountOut:C,expirationTime:g,currentPrice:R,executionPrice:K,priceImpact:T,fee:M,remainingAccounts:w,executionPriceX64:h}}static computeAmountIn({poolInfo:e,tickArrayCache:t,baseMint:n,epochInfo:i,amountOut:o,slippage:r,priceLimit:s=new j(0)}){var C;let a=n.toBase58()===e.mintA.address,c={[e.mintA.address]:e.mintA.extensions.feeConfig,[e.mintB.address]:e.mintB.extensions.feeConfig},l;s.equals(new j(0))?l=a?Ve.sub(new re(1)):ve.add(new re(1)):l=_.priceToSqrtPriceX64(s,e.mintA.decimals,e.mintB.decimals);let d=de(o,c[n.toString()],i,!0),{expectedAmountIn:f,remainingAccounts:u,executionPrice:m,feeAmount:p}=ue.getInputAmountAndRemainAccounts(e,t,n,d.amount.sub((C=d.fee)!=null?C:ce),l),b=a?e.mintB.address:e.mintA.address,g=de(f,c[b],i,!1),P=_.sqrtPriceX64ToPrice(m,e.mintA.decimals,e.mintB.decimals),A=a?P:new j(1).div(P),T=f.mul(new re(Math.floor((1+r)*1e10))).div(new re(1e10)),k=de(T,c[b],i,!0),w=a?e.currentPrice:new j(1).div(e.currentPrice),h=new j(A).sub(w).abs(),x=w,B=new et(new j(h).mul(10**15).toFixed(0),new j(x).mul(10**15).toFixed(0));return{amountIn:g,maxAmountIn:k,realAmountOut:d,expirationTime:tt(g.expirationTime,d.expirationTime),currentPrice:e.currentPrice,executionPrice:A,priceImpact:B,fee:p,remainingAccounts:u}}static estimateAprsForPriceRangeMultiplier({poolInfo:e,aprType:t,positionTickLowerIndex:n,positionTickUpperIndex:i}){var m,p,b;let o=e[t],r=N.getTickPrice({poolInfo:e,tick:n,baseIn:!0}).price.toNumber(),s=N.getTickPrice({poolInfo:e,tick:i,baseIn:!0}).price.toNumber(),a=Math.max(r,o.priceMin),l=Math.min(s,o.priceMax)-a,d=s-r,f=o.priceMax-o.priceMin,u;return l<=0?u=0:d===l?u=f/l:f===l?u=l/d:u=l/f*(l/d),{feeApr:o.feeApr*u,rewardsApr:[((m=o.rewardApr[0])!=null?m:0)*u,((p=o.rewardApr[1])!=null?p:0)*u,((b=o.rewardApr[2])!=null?b:0)*u],apr:o.apr*u}}static estimateAprsForPriceRangeDelta({poolInfo:e,poolLiquidity:t,aprType:n,mintPrice:i,liquidity:o,positionTickLowerIndex:r,positionTickUpperIndex:s,chainTime:a}){let c=n==="day"?1:n==="week"?7:n==="month"?30:0,l=e[n],d=i[it(e.mintA.address).toString()],f=i[it(e.mintB.address).toString()],u=e.mintA.decimals,m=e.mintB.decimals;if(!l||!d||!f)return{feeApr:0,rewardsApr:[0,0,0],apr:0};let p=_.priceToSqrtPriceX64(new j(e.price),e.mintA.decimals,e.mintB.decimals),b=_.getSqrtPriceX64FromTick(r),g=_.getSqrtPriceX64FromTick(s),{amountSlippageA:P,amountSlippageB:A}=Z.getAmountsFromLiquidityWithSlippage(p,b,g,t,!1,!1,0),{amountSlippageA:T,amountSlippageB:k}=Z.getAmountsFromLiquidityWithSlippage(p,b,g,o,!1,!1,0),w=new j(P.toString()).div(new j(10).pow(u)).mul(d.value).add(new j(A.toString()).div(new j(10).pow(m)).mul(f.value)),h=new j(T.toString()).div(new j(10).pow(u)).mul(d.value).add(new j(k.toString()).div(new j(10).pow(m)).mul(f.value)),x=new j(1).div(w.add(h)),C=new j(l.volumeFee).mul(365).div(c).mul(x).mul(100).toNumber(),R=3600*24*365,K=e.rewardDefaultInfos.map(M=>{var U,be;let S=M.mint.decimals,D=i[M.mint.address];return a<((U=M.startTime)!=null?U:0)||a>((be=M.endTime)!=null?be:0)||!M.perSecond||!D||S===void 0?0:new j(D.value).mul(new j(M.perSecond).mul(R)).div(new j(10).pow(S)).mul(x).mul(100).toNumber()});return{feeApr:C,rewardsApr:K,apr:C+K.reduce((M,S)=>M+S,0)}}static async getLiquidityAmountOutFromAmountIn({poolInfo:e,inputA:t,tickLower:n,tickUpper:i,amount:o,slippage:r,add:s,epochInfo:a,amountHasFee:c}){var g,P;let l=_.priceToSqrtPriceX64(new j(e.price),e.mintA.decimals,e.mintB.decimals),d=_.getSqrtPriceX64FromTick(n),f=_.getSqrtPriceX64FromTick(i),u=de(o,(g=e[t?"mintA":"mintB"].extensions)==null?void 0:g.feeConfig,a,!c),m=new re(new j(u.amount.sub((P=u.fee)!=null?P:ce).toString()).toFixed(0)),p;if(l.lte(d))p=t?Z.getLiquidityFromTokenAmountA(d,f,m,!s):new re(0);else if(l.lte(f)){let A=Z.getLiquidityFromTokenAmountA(l,f,m,!s),T=Z.getLiquidityFromTokenAmountB(d,l,m);p=t?A:T}else p=t?new re(0):Z.getLiquidityFromTokenAmountB(d,f,m);let b=await ue.getAmountsFromLiquidity({epochInfo:a,poolInfo:e,tickLower:n,tickUpper:i,liquidity:p,slippage:r,add:s});return{liquidity:p,amountA:t?u:b.amountA,amountB:t?b.amountB:u,amountSlippageA:t?u:b.amountSlippageA,amountSlippageB:t?b.amountSlippageB:u,expirationTime:b.expirationTime}}static async getAmountsFromLiquidity({epochInfo:e,poolInfo:t,tickLower:n,tickUpper:i,liquidity:o,slippage:r,add:s}){var b,g,P,A;let a=_.getSqrtPriceX64FromTick(n),c=_.getSqrtPriceX64FromTick(i),l=s?1+r:1-r,d=Z.getAmountsFromLiquidity(_.priceToSqrtPriceX64(new j(t.price),t.mintA.decimals,t.mintB.decimals),a,c,o,s),[f,u]=[de(d.amountA,(b=t.mintA.extensions)==null?void 0:b.feeConfig,e,!0),de(d.amountB,(g=t.mintB.extensions)==null?void 0:g.feeConfig,e,!0)],[m,p]=[de(d.amountA.muln(l),(P=t.mintA.extensions)==null?void 0:P.feeConfig,e,!0),de(d.amountB.muln(l),(A=t.mintB.extensions)==null?void 0:A.feeConfig,e,!0)];return{liquidity:o,amountA:f,amountB:u,amountSlippageA:m,amountSlippageB:p,expirationTime:tt(f.expirationTime,u.expirationTime)}}static async fetchComputeMultipleClmmInfo({connection:e,poolList:t,rpcDataMap:n={}}){let i=t.filter(a=>!n[a.id]).map(a=>new Ne(a.id));(await Xe(e,i)).forEach((a,c)=>{!a||(n[i[c].toBase58()]=cn.decode(a.data))});let r=t.map(a=>fe(new Ne(a.programId),new Ne(a.id)).publicKey),s=await ue.fetchExBitmaps({connection:e,exBitmapAddress:r,batchRequest:!1});return t.reduce((a,c)=>G(O({},a),{[c.id]:G(O({},n[c.id]),{id:new Ne(c.id),version:6,programId:new Ne(c.programId),mintA:c.mintA,mintB:c.mintB,ammConfig:G(O({},c.config),{id:new Ne(c.config.id),fundOwner:""}),currentPrice:new j(c.price),exBitmapAccount:fe(new Ne(c.programId),new Ne(c.id)).publicKey,exBitmapInfo:s[fe(new Ne(c.programId),new Ne(c.id)).publicKey.toBase58()],startTime:n[c.id].startTime.toNumber(),rewardInfos:n[c.id].rewardInfos})}),{})}static async fetchComputeClmmInfo({connection:e,poolInfo:t,rpcData:n}){return(await this.fetchComputeMultipleClmmInfo({connection:e,rpcDataMap:n?{[t.id]:n}:void 0,poolList:[t]}))[t.id]}};var Vn={volume:0,volumeQuote:0,volumeFee:0,apr:0,feeApr:0,priceMin:0,priceMax:0,rewardApr:[]};function Ri(y){return G(O({},y),{type:"Concentrated",programId:y.programId.toString(),id:y.id.toString(),rewardDefaultInfos:[],rewardDefaultPoolInfos:"Clmm",price:y.currentPrice.toNumber(),mintAmountA:0,mintAmountB:0,feeRate:y.ammConfig.tradeFeeRate,openTime:y.startTime.toString(),tvl:0,day:Vn,week:Vn,month:Vn,pooltype:[],farmUpcomingCount:0,farmOngoingCount:0,farmFinishedCount:0,burnPercent:0,config:G(O({},y.ammConfig),{id:y.ammConfig.id.toString(),defaultRange:0,defaultRangePoint:[]})})}var W=class{static mulDivRoundingUp(e,t,n){let i=e.mul(t),o=i.div(n);return i.mod(n).eq(ce)||(o=o.add(We)),o}static mulDivFloor(e,t,n){if(n.eq(ce))throw new Error("division by 0");return e.mul(t).div(n)}static mulDivCeil(e,t,n){if(n.eq(ce))throw new Error("division by 0");return e.mul(t).add(n.sub(We)).div(n)}static x64ToDecimal(e,t){return new Ge(e.toString()).div(Ge.pow(2,64)).toDecimalPlaces(t)}static decimalToX64(e){return new q(e.mul(Ge.pow(2,64)).floor().toFixed())}static wrappingSubU128(e,t){return e.add(on).sub(t).mod(on)}};function we(y,e){return qn(y.mul(e),64,256)}function Hr(y,e,t){let n=y.toTwos(t).shln(e);return n.imaskn(t+1),n.fromTwos(t)}function qn(y,e,t){let n=y.toTwos(t).shrn(e);return n.imaskn(t-e+1),n.fromTwos(t-e)}var _=class{static sqrtPriceX64ToPrice(e,t,n){return W.x64ToDecimal(e).pow(2).mul(Ge.pow(10,t-n))}static priceToSqrtPriceX64(e,t,n){return W.decimalToX64(e.mul(Ge.pow(10,n-t)).sqrt())}static getNextSqrtPriceX64FromInput(e,t,n,i){if(!e.gt(ce))throw new Error("sqrtPriceX64 must greater than 0");if(!t.gt(ce))throw new Error("liquidity must greater than 0");return i?this.getNextSqrtPriceFromTokenAmountARoundingUp(e,t,n,!0):this.getNextSqrtPriceFromTokenAmountBRoundingDown(e,t,n,!0)}static getNextSqrtPriceX64FromOutput(e,t,n,i){if(!e.gt(ce))throw new Error("sqrtPriceX64 must greater than 0");if(!t.gt(ce))throw new Error("liquidity must greater than 0");return i?this.getNextSqrtPriceFromTokenAmountBRoundingDown(e,t,n,!1):this.getNextSqrtPriceFromTokenAmountARoundingUp(e,t,n,!1)}static getNextSqrtPriceFromTokenAmountARoundingUp(e,t,n,i){if(n.eq(ce))return e;let o=t.shln(Ft);if(i){let r=o,s=o.add(n.mul(e));return s.gte(r)?W.mulDivCeil(r,e,s):W.mulDivRoundingUp(r,We,r.div(e).add(n))}else{let r=n.mul(e);if(!o.gt(r))throw new Error("getNextSqrtPriceFromTokenAmountARoundingUp,liquidityLeftShift must gt amountMulSqrtPrice");let s=o.sub(r);return W.mulDivCeil(o,e,s)}}static getNextSqrtPriceFromTokenAmountBRoundingDown(e,t,n,i){let o=n.shln(Ft);if(i)return e.add(o.div(t));{let r=W.mulDivRoundingUp(o,We,t);if(!e.gt(r))throw new Error("getNextSqrtPriceFromTokenAmountBRoundingDown sqrtPriceX64 must gt amountDivLiquidity");return e.sub(r)}}static getSqrtPriceX64FromTick(e){if(!Number.isInteger(e))throw new Error("tick must be integer");if(e<xe||e>Se)throw new Error("tick must be in MIN_TICK and MAX_TICK");let t=e<0?e*-1:e,n=(t&1)!=0?new q("18445821805675395072"):new q("18446744073709551616");return(t&2)!=0&&(n=we(n,new q("18444899583751176192"))),(t&4)!=0&&(n=we(n,new q("18443055278223355904"))),(t&8)!=0&&(n=we(n,new q("18439367220385607680"))),(t&16)!=0&&(n=we(n,new q("18431993317065453568"))),(t&32)!=0&&(n=we(n,new q("18417254355718170624"))),(t&64)!=0&&(n=we(n,new q("18387811781193609216"))),(t&128)!=0&&(n=we(n,new q("18329067761203558400"))),(t&256)!=0&&(n=we(n,new q("18212142134806163456"))),(t&512)!=0&&(n=we(n,new q("17980523815641700352"))),(t&1024)!=0&&(n=we(n,new q("17526086738831433728"))),(t&2048)!=0&&(n=we(n,new q("16651378430235570176"))),(t&4096)!=0&&(n=we(n,new q("15030750278694412288"))),(t&8192)!=0&&(n=we(n,new q("12247334978884435968"))),(t&16384)!=0&&(n=we(n,new q("8131365268886854656"))),(t&32768)!=0&&(n=we(n,new q("3584323654725218816"))),(t&65536)!=0&&(n=we(n,new q("696457651848324352"))),(t&131072)!=0&&(n=we(n,new q("26294789957507116"))),(t&262144)!=0&&(n=we(n,new q("37481735321082"))),e>0&&(n=gi.div(n)),n}static getTickFromPrice(e,t,n){return _.getTickFromSqrtPriceX64(_.priceToSqrtPriceX64(e,t,n))}static getTickFromSqrtPriceX64(e){if(e.gt(Ve)||e.lt(ve))throw new Error("Provided sqrtPrice is not within the supported sqrtPrice range.");let t=e.bitLength()-1,n=new q(t-64),i=Hr(n,32,128),o=new q("8000000000000000","hex"),r=0,s=new q(0),a=t>=64?e.shrn(t-63):e.shln(63-t);for(;o.gt(new q(0))&&r<wi;){a=a.mul(a);let m=a.shrn(127);a=a.shrn(63+m.toNumber()),s=s.add(o.mul(m)),o=o.shrn(1),r+=1}let c=s.shrn(32),d=i.add(c).mul(new q(Pi)),f=qn(d.sub(new q(ki)),64,128).toNumber(),u=qn(d.add(new q(Ai)),64,128).toNumber();return f==u?f:_.getSqrtPriceX64FromTick(u).lte(e)?u:f}},ct=class{static getTickWithPriceAndTickspacing(e,t,n,i){let r=_.getTickFromSqrtPriceX64(_.priceToSqrtPriceX64(e,n,i))/t;return r<0?r=Math.floor(r):r=Math.ceil(r),r*t}static roundPriceWithTickspacing(e,t,n,i){let o=ct.getTickWithPriceAndTickspacing(e,t,n,i),r=_.getSqrtPriceX64FromTick(o);return _.sqrtPriceX64ToPrice(r,n,i)}},Z=class{static addDelta(e,t){return e.add(t)}static getTokenAmountAFromLiquidity(e,t,n,i){if(e.gt(t)&&([e,t]=[t,e]),!e.gt(ce))throw new Error("sqrtPriceX64A must greater than 0");let o=n.ushln(Ft),r=t.sub(e);return i?W.mulDivRoundingUp(W.mulDivCeil(o,r,t),We,e):W.mulDivFloor(o,r,t).div(e)}static getTokenAmountBFromLiquidity(e,t,n,i){if(e.gt(t)&&([e,t]=[t,e]),!e.gt(ce))throw new Error("sqrtPriceX64A must greater than 0");return i?W.mulDivCeil(n,t.sub(e),Re):W.mulDivFloor(n,t.sub(e),Re)}static getLiquidityFromTokenAmountA(e,t,n,i){e.gt(t)&&([e,t]=[t,e]);let o=n.mul(e).mul(t),r=t.sub(e),s=o.div(r);return i?W.mulDivRoundingUp(s,We,Mn):s.shrn(Ft)}static getLiquidityFromTokenAmountB(e,t,n){return e.gt(t)&&([e,t]=[t,e]),W.mulDivFloor(n,Mn,t.sub(e))}static getLiquidityFromTokenAmounts(e,t,n,i,o){if(t.gt(n)&&([t,n]=[n,t]),e.lte(t))return Z.getLiquidityFromTokenAmountA(t,n,i,!1);if(e.lt(n)){let r=Z.getLiquidityFromTokenAmountA(e,n,i,!1),s=Z.getLiquidityFromTokenAmountB(t,e,o);return r.lt(s)?r:s}else return Z.getLiquidityFromTokenAmountB(t,n,o)}static getAmountsFromLiquidity(e,t,n,i,o){if(t.gt(n)&&([t,n]=[n,t]),e.lte(t))return{amountA:Z.getTokenAmountAFromLiquidity(t,n,i,o),amountB:new q(0)};if(e.lt(n)){let r=Z.getTokenAmountAFromLiquidity(e,n,i,o),s=Z.getTokenAmountBFromLiquidity(t,e,i,o);return{amountA:r,amountB:s}}else return{amountA:new q(0),amountB:Z.getTokenAmountBFromLiquidity(t,n,i,o)}}static getAmountsFromLiquidityWithSlippage(e,t,n,i,o,r,s){let{amountA:a,amountB:c}=Z.getAmountsFromLiquidity(e,t,n,i,r),l=o?1+s:1-s,d=new q(new Ge(a.toString()).mul(l).toFixed(0)),f=new q(new Ge(c.toString()).mul(l).toFixed(0));return{amountSlippageA:d,amountSlippageB:f}}static getAmountsOutFromLiquidity({poolInfo:e,tickLower:t,tickUpper:n,liquidity:i,slippage:o,add:r,epochInfo:s,amountAddFee:a}){var P,A,T,k;let c=_.priceToSqrtPriceX64(new Ge(e.price),e.mintA.decimals,e.mintB.decimals),l=_.getSqrtPriceX64FromTick(t),d=_.getSqrtPriceX64FromTick(n),f=r?1+o:1-o,u=Z.getAmountsFromLiquidity(c,l,d,i,r),[m,p]=[de(u.amountA,(P=e.mintA.extensions)==null?void 0:P.feeConfig,s,a),de(u.amountB,(A=e.mintB.extensions)==null?void 0:A.feeConfig,s,a)],[b,g]=[de(new q(new Ge(u.amountA.toString()).mul(f).toFixed(0)),(T=e.mintA.extensions)==null?void 0:T.feeConfig,s,a),de(new q(new Ge(u.amountB.toString()).mul(f).toFixed(0)),(k=e.mintB.extensions)==null?void 0:k.feeConfig,s,a)];return{liquidity:i,amountA:m,amountB:p,amountSlippageA:b,amountSlippageB:g,expirationTime:tt(m.expirationTime,p.expirationTime)}}},at=class{static swapCompute(e,t,n,i,o,r,s,a,c,l,d,f,u,m,p=!1){if(f.eq(ce))throw new Error("amountSpecified must not be 0");if(m||(m=r?ve.add(We):Ve.sub(We)),r){if(m.lt(ve))throw new Error("sqrtPriceX64 must greater than MIN_SQRT_PRICE_X64");if(m.gte(d))throw new Error("sqrtPriceX64 must smaller than current")}else{if(m.gt(Ve))throw new Error("sqrtPriceX64 must smaller than MAX_SQRT_PRICE_X64");if(m.lte(d))throw new Error("sqrtPriceX64 must greater than current")}let b=f.gt(ce),g={amountSpecifiedRemaining:f,amountCalculated:ce,sqrtPriceX64:d,tick:c>u?Math.min(u+H.tickCount(l)-1,c):u,accounts:[],liquidity:a,feeAmount:new q(0)},P=u,A=n[u],T=0,k=!r&&A.startTickIndex===g.tick;for(;!g.amountSpecifiedRemaining.eq(ce)&&!g.sqrtPriceX64.eq(m);){T>10;let w={};w.sqrtPriceStartX64=g.sqrtPriceX64;let h=N.nextInitTick(A,g.tick,l,r,k),x=h||null,B=null;if(!(x!=null&&x.liquidityGross.gtn(0))){let R=ue.nextInitializedTickArrayStartIndex({tickCurrent:g.tick,tickSpacing:l,tickArrayBitmap:i,exBitmapInfo:o},P,r);if(!R.isExist){if(p)return{allTrade:!1,amountSpecifiedRemaining:g.amountSpecifiedRemaining,amountCalculated:g.amountCalculated,feeAmount:g.feeAmount,sqrtPriceX64:g.sqrtPriceX64,liquidity:g.liquidity,tickCurrent:g.tick,accounts:g.accounts};throw Error("swapCompute LiquidityInsufficient")}P=R.nextStartIndex;let{publicKey:K}=z(e,t,P);B=K,A=n[P];try{x=N.firstInitializedTick(A,r)}catch{throw Error("not found next tick info")}}w.tickNext=x.tick,w.initialized=x.liquidityGross.gtn(0),u!==P&&B&&(g.accounts.push(B),u=P),w.tickNext<xe?w.tickNext=xe:w.tickNext>Se&&(w.tickNext=Se),w.sqrtPriceNextX64=_.getSqrtPriceX64FromTick(w.tickNext);let C;if(r&&w.sqrtPriceNextX64.lt(m)||!r&&w.sqrtPriceNextX64.gt(m)?C=m:C=w.sqrtPriceNextX64,[g.sqrtPriceX64,w.amountIn,w.amountOut,w.feeAmount]=at.swapStepCompute(g.sqrtPriceX64,C,g.liquidity,g.amountSpecifiedRemaining,s,r),g.feeAmount=g.feeAmount.add(w.feeAmount),b?(g.amountSpecifiedRemaining=g.amountSpecifiedRemaining.sub(w.amountIn.add(w.feeAmount)),g.amountCalculated=g.amountCalculated.sub(w.amountOut)):(g.amountSpecifiedRemaining=g.amountSpecifiedRemaining.add(w.amountOut),g.amountCalculated=g.amountCalculated.add(w.amountIn.add(w.feeAmount))),g.sqrtPriceX64.eq(w.sqrtPriceNextX64)){if(w.initialized){let R=x.liquidityNet;r&&(R=R.mul(je)),g.liquidity=Z.addDelta(g.liquidity,R)}k=w.tickNext!=g.tick&&!r&&A.startTickIndex===w.tickNext,g.tick=r?w.tickNext-1:w.tickNext}else if(g.sqrtPriceX64!=w.sqrtPriceStartX64){let R=_.getTickFromSqrtPriceX64(g.sqrtPriceX64);k=R!=g.tick&&!r&&A.startTickIndex===R,g.tick=R}++T}try{let{nextStartIndex:w,isExist:h}=H.nextInitializedTickArray(g.tick,l,r,i,o);h&&u!==w&&(g.accounts.push(z(e,t,w).publicKey),u=w)}catch{}return{allTrade:!0,amountSpecifiedRemaining:ce,amountCalculated:g.amountCalculated,feeAmount:g.feeAmount,sqrtPriceX64:g.sqrtPriceX64,liquidity:g.liquidity,tickCurrent:g.tick,accounts:g.accounts}}static swapStepCompute(e,t,n,i,o,r){let s={sqrtPriceX64Next:new q(0),amountIn:new q(0),amountOut:new q(0),feeAmount:new q(0)},a=i.gte(ce);if(a){let l=W.mulDivFloor(i,sn.sub(new q(o.toString())),sn);s.amountIn=r?Z.getTokenAmountAFromLiquidity(t,e,n,!0):Z.getTokenAmountBFromLiquidity(e,t,n,!0),l.gte(s.amountIn)?s.sqrtPriceX64Next=t:s.sqrtPriceX64Next=_.getNextSqrtPriceX64FromInput(e,n,l,r)}else s.amountOut=r?Z.getTokenAmountBFromLiquidity(t,e,n,!1):Z.getTokenAmountAFromLiquidity(e,t,n,!1),i.mul(je).gte(s.amountOut)?s.sqrtPriceX64Next=t:s.sqrtPriceX64Next=_.getNextSqrtPriceX64FromOutput(e,n,i.mul(je),r);let c=t.eq(s.sqrtPriceX64Next);return r?(c&&a||(s.amountIn=Z.getTokenAmountAFromLiquidity(s.sqrtPriceX64Next,e,n,!0)),c&&!a||(s.amountOut=Z.getTokenAmountBFromLiquidity(s.sqrtPriceX64Next,e,n,!1))):(s.amountIn=c&&a?s.amountIn:Z.getTokenAmountBFromLiquidity(e,s.sqrtPriceX64Next,n,!0),s.amountOut=c&&!a?s.amountOut:Z.getTokenAmountAFromLiquidity(e,s.sqrtPriceX64Next,n,!1)),!a&&s.amountOut.gt(i.mul(je))&&(s.amountOut=i.mul(je)),a&&!s.sqrtPriceX64Next.eq(t)?s.feeAmount=i.sub(s.amountIn):s.feeAmount=W.mulDivCeil(s.amountIn,new q(o),sn.sub(new q(o))),[s.sqrtPriceX64Next,s.amountIn,s.amountOut,s.feeAmount]}};var ye=60,st=512,N=class{static getTickArrayAddressByTick(e,t,n,i){let o=N.getTickArrayStartIndexByTick(n,i),{publicKey:r}=z(e,t,o);return r}static getTickOffsetInArray(e,t){if(e%t!=0)throw new Error("tickIndex % tickSpacing not equal 0");let n=N.getTickArrayStartIndexByTick(e,t),i=Math.floor((e-n)/t);if(i<0||i>=ye)throw new Error("tick offset in array overflow");return i}static getTickArrayBitIndex(e,t){let n=H.tickCount(t),i=e/n;return e<0&&e%n!=0?i=Math.ceil(i)-1:i=Math.floor(i),i}static getTickArrayStartIndexByTick(e,t){return this.getTickArrayBitIndex(e,t)*H.tickCount(t)}static getTickArrayOffsetInBitmapByTick(e,t){let n=t*ye,i=Math.floor(e/n)+512;return Math.abs(i)}static checkTickArrayIsInitialized(e,t,n){let i=n*ye,o=Math.floor(t/i)+512,r=Math.abs(o);return{isInitialized:e.testn(r),startIndex:(r-512)*i}}static getNextTickArrayStartIndex(e,t,n){return n?e-t*ye:e+t*ye}static mergeTickArrayBitmap(e){let t=new jr(0);for(let n=0;n<e.length;n++)t=t.add(e[n].shln(64*n));return t}static getInitializedTickArrayInRange(e,t,n,i,o){let r=Math.floor(i/(n*ye));return[...N.searchLowBitFromStart(e,t,r-1,o,n),...N.searchHightBitFromStart(e,t,r,o,n)]}static getAllInitializedTickArrayStartIndex(e,t,n){return N.searchHightBitFromStart(e,t,-7680,st,n)}static getAllInitializedTickArrayInfo(e,t,n,i,o){let r=[],s=N.getAllInitializedTickArrayStartIndex(n,i,o);for(let a of s){let{publicKey:c}=z(e,t,a);r.push({tickArrayStartIndex:a,tickArrayAddress:c})}return r}static getAllInitializedTickInTickArray(e){return e.ticks.filter(t=>t.liquidityGross.gtn(0))}static searchLowBitFromStart(e,t,n,i,o){let r=[...[...t.negativeTickArrayBitmap].reverse(),e.slice(0,8),e.slice(8,16),...t.positiveTickArrayBitmap].map(c=>N.mergeTickArrayBitmap(c)),s=[];for(;n>=-7680;){let c=Math.floor((n+7680)/512),l=(n+7680)%512;if(r[c].testn(l)&&s.push(n),n--,s.length===i)break}let a=H.tickCount(o);return s.map(c=>c*a)}static searchHightBitFromStart(e,t,n,i,o){let r=[...[...t.negativeTickArrayBitmap].reverse(),e.slice(0,8),e.slice(8,16),...t.positiveTickArrayBitmap].map(c=>N.mergeTickArrayBitmap(c)),s=[];for(;n<7680;){let c=Math.floor((n+7680)/512),l=(n+7680)%512;if(r[c].testn(l)&&s.push(n),n++,s.length===i)break}let a=H.tickCount(o);return s.map(c=>c*a)}static checkIsOutOfBoundary(e){return e<xe||e>Se}static nextInitTick(e,t,n,i,o){if(H.getArrayStartIndex(t,n)!=e.startTickIndex)return null;let s=Math.floor((t-e.startTickIndex)/n);if(i)for(;s>=0;){if(e.ticks[s].liquidityGross.gtn(0))return e.ticks[s];s=s-1}else for(o||(s=s+1);s<ye;){if(e.ticks[s].liquidityGross.gtn(0))return e.ticks[s];s=s+1}return null}static firstInitializedTick(e,t){if(t){let n=ye-1;for(;n>=0;){if(e.ticks[n].liquidityGross.gtn(0))return e.ticks[n];n=n-1}}else{let n=0;for(;n<ye;){if(e.ticks[n].liquidityGross.gtn(0))return e.ticks[n];n=n+1}}throw Error(`firstInitializedTick check error: ${e} - ${t}`)}static _getTickPriceLegacy({poolInfo:e,tick:t,baseIn:n}){let i=_.getSqrtPriceX64FromTick(t),o=_.sqrtPriceX64ToPrice(i,e.mintA.decimals,e.mintB.decimals);return n?{tick:t,price:o,tickSqrtPriceX64:i}:{tick:t,price:new kt(1).div(o),tickSqrtPriceX64:i}}static _getPriceAndTickLegacy({poolInfo:e,price:t,baseIn:n}){let i=n?t:new kt(1).div(t),o=ct.getTickWithPriceAndTickspacing(i,e.ammConfig.tickSpacing,e.mintA.decimals,e.mintB.decimals),r=_.getSqrtPriceX64FromTick(o),s=_.sqrtPriceX64ToPrice(r,e.mintA.decimals,e.mintB.decimals);return n?{tick:o,price:s}:{tick:o,price:new kt(1).div(s)}}static getTickPrice({poolInfo:e,tick:t,baseIn:n}){let i=_.getSqrtPriceX64FromTick(t),o=_.sqrtPriceX64ToPrice(i,e.mintA.decimals,e.mintB.decimals);return n?{tick:t,price:o,tickSqrtPriceX64:i}:{tick:t,price:new kt(1).div(o),tickSqrtPriceX64:i}}static getPriceAndTick({poolInfo:e,price:t,baseIn:n}){let i=n?t:new kt(1).div(t),o=ct.getTickWithPriceAndTickspacing(i,e.config.tickSpacing,e.mintA.decimals,e.mintB.decimals),r=_.getSqrtPriceX64FromTick(o),s=_.sqrtPriceX64ToPrice(r,e.mintA.decimals,e.mintB.decimals);return n?{tick:o,price:s}:{tick:o,price:new kt(1).div(s)}}};var Mi=J([Le(8),le("bump"),Ot("index"),ee(""),gt("protocolFeeRate"),gt("tradeFeeRate"),Ot("tickSpacing"),ae(F(),8,"")]),Zr=J([gt("blockTimestamp"),yi("tickCumulative"),ae(F(),4)]),Oi=J([Le(8),Ie("initialized"),F("recentEpoch"),Ot("observationIndex"),ee("poolId"),ae(Zr,100,"observations"),ae(F(),4)]),Qr=J([le("rewardState"),F("openTime"),F("endTime"),F("lastUpdateTime"),X("emissionsPerSecondX64"),F("rewardTotalEmissioned"),F("rewardClaimed"),ee("tokenMint"),ee("tokenVault"),ee("creator"),X("rewardGrowthGlobalX64")]),cn=J([Le(8),le("bump"),ee("ammConfig"),ee("creator"),ee("mintA"),ee("mintB"),ee("vaultA"),ee("vaultB"),ee("observationId"),le("mintDecimalsA"),le("mintDecimalsB"),Ot("tickSpacing"),X("liquidity"),X("sqrtPriceX64"),ie("tickCurrent"),gt(),X("feeGrowthGlobalX64A"),X("feeGrowthGlobalX64B"),F("protocolFeesTokenA"),F("protocolFeesTokenB"),X("swapInAmountTokenA"),X("swapOutAmountTokenB"),X("swapInAmountTokenB"),X("swapOutAmountTokenA"),le("status"),ae(le(),7,""),ae(Qr,3,"rewardInfos"),ae(F(),16,"tickArrayBitmap"),F("totalFeesTokenA"),F("totalFeesClaimedTokenA"),F("totalFeesTokenB"),F("totalFeesClaimedTokenB"),F("fundFeesTokenA"),F("fundFeesTokenB"),F("startTime"),ae(F(),15*4-3,"padding")]),Yr=J([X("growthInsideLastX64"),F("rewardAmountOwed")]),Pt=J([Le(8),le("bump"),ee("nftMint"),ee("poolId"),ie("tickLower"),ie("tickUpper"),X("liquidity"),X("feeGrowthInsideLastX64A"),X("feeGrowthInsideLastX64B"),F("tokenFeesOwedA"),F("tokenFeesOwedB"),ae(Yr,3,"rewardInfos"),ae(F(),8,"")]),Pm=J([Le(8),le("bump"),ee("poolId"),ie("tickLowerIndex"),ie("tickUpperIndex"),X("liquidity"),X("feeGrowthInsideLastX64A"),X("feeGrowthInsideLastX64B"),F("tokenFeesOwedA"),F("tokenFeesOwedB"),ae(X(),3,"rewardGrowthInside"),ae(F(),8,"")]),Jr=J([ie("tick"),bi("liquidityNet"),X("liquidityGross"),X("feeGrowthOutsideX64A"),X("feeGrowthOutsideX64B"),ae(X(),3,"rewardGrowthsOutsideX64"),ae(gt(),13,"")]),vt=J([Le(8),ee("poolId"),ie("startTickIndex"),ae(Jr,ye,"ticks"),le("initializedTickCount"),ae(le(),115,"")]),Fi=J([Le(329),ae(ee(),100,"whitelistMints")]),Ni=J([Le(8),ee("poolId"),ae(ae(F(),8),vn,"positiveTickArrayBitmap"),ae(ae(F(),8),vn,"negativeTickArrayBitmap")]),km=J([F(),le("bump"),ee("owner"),ee("poolId"),ee("positionId"),ee("nftAccount"),ae(F(),8)]),Ei=J([Le(8),le("bump"),ee("lockOwner"),ee("poolId"),ee("positionId"),ee("nftAccount"),ee("lockNftMint"),F("recentEpoch"),ae(F(),8)]);Oi.span;var Di=Pe("Raydium_Clmm"),Me={createPool:[233,146,209,142,207,104,64,188],initReward:[95,135,192,196,242,129,230,68],setRewardEmissions:[112,52,167,75,32,201,211,137],openPosition:[77,184,74,214,112,86,241,199],openPositionWithTokenEx:[77,255,174,82,125,29,201,46],closePosition:[123,134,81,0,49,68,98,98],increaseLiquidity:[133,29,89,223,69,238,176,10],decreaseLiquidity:[58,127,188,62,79,82,196,96],swap:[43,4,237,11,26,201,30,98],collectReward:[18,237,166,197,34,16,213,144]},_i=[188,37,179,131,82,150,84,73],Wi=[16,72,250,198,14,162,212,19],oe=class{static createPoolInstruction(e,t,n,i,o,r,s,a,c,l,d,f,u,m){let p=J([X("sqrtPriceX64"),F("zero")]),b=[{pubkey:n,isSigner:!0,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!1},{pubkey:c,isSigner:!1,isWritable:!1},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:f,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!1},{pubkey:d,isSigner:!1,isWritable:!1},{pubkey:Qe.programId,isSigner:!1,isWritable:!1},{pubkey:$e,isSigner:!1,isWritable:!1},...(m==null?void 0:m.map(A=>({pubkey:A,isSigner:!1,isWritable:!1})))||[]],g=Buffer.alloc(p.span);p.encode({sqrtPriceX64:u,zero:ce},g);let P=Buffer.from([...Me.createPool,...g]);return new Ae({keys:b,programId:e,data:P})}static async createPoolInstructions(e){let{programId:t,owner:n,mintA:i,mintB:o,ammConfigId:r,initialPriceX64:s,extendMintAccount:a}=e,[c,l]=[new I(i.address),new I(o.address)],{publicKey:d}=Ii(t,r,c,l),{publicKey:f}=Ci(t,d),{publicKey:u}=En(t,d,c),{publicKey:m}=En(t,d,l),p=fe(t,d).publicKey,b=[this.createPoolInstruction(t,d,n,r,f,c,u,new I(i.programId||$),l,m,new I(o.programId||$),p,s,a)];return{signers:[],instructions:b,instructionTypes:[te.CreateAccount,te.ClmmCreatePool],address:{poolId:d,observationId:f,exBitmapAccount:p,mintAVault:u,mintBVault:m},lookupTableAddress:[]}}static openPositionFromLiquidityInstruction(e,t,n,i,o,r,s,a,c,l,d,f,u,m,p,b,g,P,A,T,k,w,h,x,B,C){let R=J([ie("tickLowerIndex"),ie("tickUpperIndex"),ie("tickArrayLowerStartIndex"),ie("tickArrayUpperStartIndex"),X("liquidity"),F("amountMaxA"),F("amountMaxB"),Ie("withMetadata"),le("optionBaseFlag"),Ie("baseFlag")]),K=[...C?[{pubkey:C,isSigner:!1,isWritable:!0}]:[]],M=[{pubkey:t,isSigner:!0,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!0,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:d,isSigner:!1,isWritable:!0},{pubkey:f,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:m,isSigner:!1,isWritable:!0},{pubkey:p,isSigner:!1,isWritable:!0},{pubkey:$e,isSigner:!1,isWritable:!1},{pubkey:Qe.programId,isSigner:!1,isWritable:!1},{pubkey:$,isSigner:!1,isWritable:!1},{pubkey:qt,isSigner:!1,isWritable:!1},{pubkey:rt,isSigner:!1,isWritable:!1},{pubkey:me,isSigner:!1,isWritable:!1},{pubkey:b,isSigner:!1,isWritable:!1},{pubkey:g,isSigner:!1,isWritable:!1},...K],S=Buffer.alloc(R.span);R.encode({tickLowerIndex:P,tickUpperIndex:A,tickArrayLowerStartIndex:T,tickArrayUpperStartIndex:k,liquidity:w,amountMaxA:h,amountMaxB:x,withMetadata:B==="create",baseFlag:!1,optionBaseFlag:0},S);let D=Buffer.from([...Me.openPosition,...S]);return new Ae({keys:M,programId:e,data:D})}static openPositionFromLiquidityInstruction22(e,t,n,i,o,r,s,a,c,l,d,f,u,m,p,b,g,P,A,T,k,w,h,x,B){let C=J([ie("tickLowerIndex"),ie("tickUpperIndex"),ie("tickArrayLowerStartIndex"),ie("tickArrayUpperStartIndex"),X("liquidity"),F("amountMaxA"),F("amountMaxB"),Ie("withMetadata"),le("optionBaseFlag"),Ie("baseFlag")]),R=[...B?[{pubkey:B,isSigner:!1,isWritable:!0}]:[]],K=[{pubkey:t,isSigner:!0,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!0,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:d,isSigner:!1,isWritable:!0},{pubkey:f,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:m,isSigner:!1,isWritable:!0},{pubkey:$e,isSigner:!1,isWritable:!1},{pubkey:Qe.programId,isSigner:!1,isWritable:!1},{pubkey:$,isSigner:!1,isWritable:!1},{pubkey:qt,isSigner:!1,isWritable:!1},{pubkey:me,isSigner:!1,isWritable:!1},{pubkey:p,isSigner:!1,isWritable:!1},{pubkey:b,isSigner:!1,isWritable:!1},...R],M=Buffer.alloc(C.span);C.encode({tickLowerIndex:g,tickUpperIndex:P,tickArrayLowerStartIndex:A,tickArrayUpperStartIndex:T,liquidity:k,amountMaxA:w,amountMaxB:h,withMetadata:x==="create",baseFlag:!1,optionBaseFlag:0},M);let S=Buffer.from([...Me.openPositionWithTokenEx,...M]);return new Ae({keys:K,programId:e,data:S})}static async openPositionInstructions({poolInfo:e,poolKeys:t,ownerInfo:n,tickLower:i,tickUpper:o,liquidity:r,amountMaxA:s,amountMaxB:a,withMetadata:c,getEphemeralSigners:l,nft2022:d}){let f=[],[u,m]=[new I(e.programId),new I(e.id)],p;if(l)p=new I((await l(1))[0]);else{let B=un.generate();f.push(B),p=B.publicKey}let b=N.getTickArrayStartIndexByTick(i,e.config.tickSpacing),g=N.getTickArrayStartIndexByTick(o,e.config.tickSpacing),{publicKey:P}=z(u,m,b),{publicKey:A}=z(u,m,g),{publicKey:T}=d?ne(n.wallet,p,me):ne(n.wallet,p,$),{publicKey:k}=Dt(p),{publicKey:w}=Ce(u,p),{publicKey:h}=De(u,m,i,o),x=d?this.openPositionFromLiquidityInstruction22(u,n.feePayer,m,n.wallet,p,T,h,P,A,w,n.tokenAccountA,n.tokenAccountB,new I(t.vault.A),new I(t.vault.B),new I(e.mintA.address),new I(e.mintB.address),i,o,b,g,r,s,a,c,ue.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing,[b,g])?fe(u,m).publicKey:void 0):this.openPositionFromLiquidityInstruction(u,n.feePayer,m,n.wallet,p,T,k,h,P,A,w,n.tokenAccountA,n.tokenAccountB,new I(t.vault.A),new I(t.vault.B),new I(e.mintA.address),new I(e.mintB.address),i,o,b,g,r,s,a,c,ue.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing,[b,g])?fe(u,m).publicKey:void 0);return{signers:f,instructions:[x],instructionTypes:[te.ClmmOpenPosition],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[],address:{nftMint:p,tickArrayLower:P,tickArrayUpper:A,positionNftAccount:T,metadataAccount:k,personalPosition:w,protocolPosition:h}}}static async openPositionFromBaseInstructions({poolInfo:e,poolKeys:t,ownerInfo:n,tickLower:i,tickUpper:o,base:r,baseAmount:s,otherAmountMax:a,withMetadata:c,getEphemeralSigners:l,nft2022:d}){let f=[],[u,m]=[new I(e.programId),new I(e.id)],p;if(l)p=new I((await l(1))[0]);else{let B=un.generate();f.push(B),p=B.publicKey}let b=N.getTickArrayStartIndexByTick(i,e.config.tickSpacing),g=N.getTickArrayStartIndexByTick(o,e.config.tickSpacing),{publicKey:P}=z(u,m,b),{publicKey:A}=z(u,m,g),{publicKey:T}=d?ne(n.wallet,p,me):ne(n.wallet,p,$),{publicKey:k}=Dt(p),{publicKey:w}=Ce(u,p),{publicKey:h}=De(u,m,i,o),x=d?this.openPositionFromBaseInstruction22(u,n.feePayer,m,n.wallet,p,T,h,P,A,w,n.tokenAccountA,n.tokenAccountB,new I(t.vault.A),new I(t.vault.B),new I(e.mintA.address),new I(e.mintB.address),i,o,b,g,c,r,s,a,ue.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing,[b,g])?fe(u,m).publicKey:void 0):this.openPositionFromBaseInstruction(u,n.feePayer,m,n.wallet,p,T,k,h,P,A,w,n.tokenAccountA,n.tokenAccountB,new I(t.vault.A),new I(t.vault.B),new I(e.mintA.address),new I(e.mintB.address),i,o,b,g,c,r,s,a,ue.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing,[b,g])?fe(u,m).publicKey:void 0);return{address:{nftMint:p,tickArrayLower:P,tickArrayUpper:A,positionNftAccount:T,metadataAccount:k,personalPosition:w,protocolPosition:h},instructions:[x],signers:f,instructionTypes:[te.ClmmOpenPosition],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[]}}static openPositionFromBaseInstruction(e,t,n,i,o,r,s,a,c,l,d,f,u,m,p,b,g,P,A,T,k,w,h,x,B,C){let R=J([ie("tickLowerIndex"),ie("tickUpperIndex"),ie("tickArrayLowerStartIndex"),ie("tickArrayUpperStartIndex"),X("liquidity"),F("amountMaxA"),F("amountMaxB"),Ie("withMetadata"),le("optionBaseFlag"),Ie("baseFlag")]),K=[...C?[{pubkey:C,isSigner:!1,isWritable:!0}]:[]],M=[{pubkey:t,isSigner:!0,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!0,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:d,isSigner:!1,isWritable:!0},{pubkey:f,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:m,isSigner:!1,isWritable:!0},{pubkey:p,isSigner:!1,isWritable:!0},{pubkey:$e,isSigner:!1,isWritable:!1},{pubkey:Qe.programId,isSigner:!1,isWritable:!1},{pubkey:$,isSigner:!1,isWritable:!1},{pubkey:qt,isSigner:!1,isWritable:!1},{pubkey:rt,isSigner:!1,isWritable:!1},{pubkey:me,isSigner:!1,isWritable:!1},{pubkey:b,isSigner:!1,isWritable:!1},{pubkey:g,isSigner:!1,isWritable:!1},...K],S=Buffer.alloc(R.span);R.encode({tickLowerIndex:P,tickUpperIndex:A,tickArrayLowerStartIndex:T,tickArrayUpperStartIndex:k,liquidity:new Gn(0),amountMaxA:h==="MintA"?x:B,amountMaxB:h==="MintA"?B:x,withMetadata:w==="create",baseFlag:h==="MintA",optionBaseFlag:1},S);let D=Buffer.from([...Me.openPosition,...S]);return new Ae({keys:M,programId:e,data:D})}static openPositionFromBaseInstruction22(e,t,n,i,o,r,s,a,c,l,d,f,u,m,p,b,g,P,A,T,k,w,h,x,B){let C=J([ie("tickLowerIndex"),ie("tickUpperIndex"),ie("tickArrayLowerStartIndex"),ie("tickArrayUpperStartIndex"),X("liquidity"),F("amountMaxA"),F("amountMaxB"),Ie("withMetadata"),le("optionBaseFlag"),Ie("baseFlag")]),R=[...B?[{pubkey:B,isSigner:!1,isWritable:!0}]:[]],K=[{pubkey:t,isSigner:!0,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!0,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:d,isSigner:!1,isWritable:!0},{pubkey:f,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:m,isSigner:!1,isWritable:!0},{pubkey:$e,isSigner:!1,isWritable:!1},{pubkey:Qe.programId,isSigner:!1,isWritable:!1},{pubkey:$,isSigner:!1,isWritable:!1},{pubkey:qt,isSigner:!1,isWritable:!1},{pubkey:me,isSigner:!1,isWritable:!1},{pubkey:p,isSigner:!1,isWritable:!1},{pubkey:b,isSigner:!1,isWritable:!1},...R],M=Buffer.alloc(C.span);C.encode({tickLowerIndex:g,tickUpperIndex:P,tickArrayLowerStartIndex:A,tickArrayUpperStartIndex:T,liquidity:new Gn(0),amountMaxA:w==="MintA"?h:x,amountMaxB:w==="MintA"?x:h,withMetadata:k==="create",baseFlag:w==="MintA",optionBaseFlag:1},M);let S=Buffer.from([...Me.openPositionWithTokenEx,...M]);return new Ae({keys:K,programId:e,data:S})}static async openPositionFromLiquidityInstructions({poolInfo:e,poolKeys:t,ownerInfo:n,tickLower:i,tickUpper:o,liquidity:r,amountMaxA:s,amountMaxB:a,withMetadata:c,getEphemeralSigners:l,nft2022:d}){let f,u=[];if(l)f=new I((await l(1))[0]);else{let B=un.generate();u.push(B),f=B.publicKey}let[m,p]=[new I(e.programId),new I(e.id)],b=N.getTickArrayStartIndexByTick(i,e.config.tickSpacing),g=N.getTickArrayStartIndexByTick(o,e.config.tickSpacing),{publicKey:P}=z(m,p,b),{publicKey:A}=z(m,p,g),{publicKey:T}=d?ne(n.wallet,f,me):ne(n.wallet,f,$),{publicKey:k}=Dt(f),{publicKey:w}=Ce(m,f),{publicKey:h}=De(m,p,i,o),x=d?this.openPositionFromLiquidityInstruction22(m,n.wallet,p,n.wallet,f,T,h,P,A,w,n.tokenAccountA,n.tokenAccountB,new I(t.vault.A),new I(t.vault.B),new I(t.mintA.address),new I(t.mintB.address),i,o,b,g,r,s,a,c,ue.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing,[b,g])?fe(m,p).publicKey:void 0):this.openPositionFromLiquidityInstruction(m,n.wallet,p,n.wallet,f,T,k,h,P,A,w,n.tokenAccountA,n.tokenAccountB,new I(t.vault.A),new I(t.vault.B),new I(t.mintA.address),new I(t.mintB.address),i,o,b,g,r,s,a,c,ue.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing,[b,g])?fe(m,p).publicKey:void 0);return{address:{nftMint:f,tickArrayLower:P,tickArrayUpper:A,positionNftAccount:T,metadataAccount:k,personalPosition:w,protocolPosition:h},instructions:[x],signers:u,instructionTypes:[te.ClmmOpenPosition],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[]}}static closePositionInstruction(e,t,n,i,o,r){let s=J([]),a=[{pubkey:t,isSigner:!0,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:Qe.programId,isSigner:!1,isWritable:!1},{pubkey:r?me:$,isSigner:!1,isWritable:!1}],c=Buffer.alloc(s.span);s.encode({},c);let l=Buffer.from([...Me.closePosition,...c]);return new Ae({keys:a,programId:e,data:l})}static closePositionInstructions({poolInfo:e,poolKeys:t,ownerInfo:n,ownerPosition:i,nft2022:o}){let r=new I(e.programId),s=o?ne(n.wallet,i.nftMint,me).publicKey:ne(n.wallet,i.nftMint,$).publicKey,{publicKey:a}=Ce(r,i.nftMint),c=[];return c.push(this.closePositionInstruction(r,n.wallet,i.nftMint,s,a,o)),{address:{positionNftAccount:s,personalPosition:a},signers:[],instructions:c,instructionTypes:[te.ClmmClosePosition],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[]}}static increasePositionFromLiquidityInstruction(e,t,n,i,o,r,s,a,c,l,d,f,u,m,p,b,g,P){let A=J([X("liquidity"),F("amountMaxA"),F("amountMaxB"),le("optionBaseFlag"),Ie("baseFlag")]),T=[...P?[{pubkey:P,isSigner:!1,isWritable:!0}]:[]],k=[{pubkey:t,isSigner:!0,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:d,isSigner:!1,isWritable:!0},{pubkey:f,isSigner:!1,isWritable:!0},{pubkey:$,isSigner:!1,isWritable:!1},{pubkey:me,isSigner:!1,isWritable:!1},{pubkey:u,isSigner:!1,isWritable:!1},{pubkey:m,isSigner:!1,isWritable:!1},...T],w=Buffer.alloc(A.span);A.encode({liquidity:p,amountMaxA:b,amountMaxB:g,optionBaseFlag:0,baseFlag:!1},w);let h=Buffer.from([...Me.increaseLiquidity,...w]);return new Ae({keys:k,programId:e,data:h})}static increasePositionFromLiquidityInstructions({poolInfo:e,poolKeys:t,ownerPosition:n,ownerInfo:i,liquidity:o,amountMaxA:r,amountMaxB:s,nft2022:a}){let[c,l]=[new I(e.programId),new I(e.id)],d=N.getTickArrayStartIndexByTick(n.tickLower,e.config.tickSpacing),f=N.getTickArrayStartIndexByTick(n.tickUpper,e.config.tickSpacing),{publicKey:u}=z(c,l,d),{publicKey:m}=z(c,l,f),{publicKey:p}=a?ne(i.wallet,n.nftMint,me):ne(i.wallet,n.nftMint,$),{publicKey:b}=Ce(c,n.nftMint),{publicKey:g}=De(c,l,n.tickLower,n.tickUpper),P=this.increasePositionFromLiquidityInstruction(c,i.wallet,p,b,l,g,u,m,i.tokenAccountA,i.tokenAccountB,new I(t.vault.A),new I(t.vault.B),new I(e.mintA.address),new I(e.mintB.address),o,r,s,ue.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing,[d,f])?fe(c,l).publicKey:void 0);return{address:{tickArrayLower:u,tickArrayUpper:m,positionNftAccount:p,personalPosition:b,protocolPosition:g},signers:[],instructions:[P],instructionTypes:[te.ClmmIncreasePosition],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[]}}static increasePositionFromBaseInstructions({poolInfo:e,poolKeys:t,ownerPosition:n,ownerInfo:i,base:o,baseAmount:r,otherAmountMax:s,nft2022:a}){let[c,l]=[new I(e.programId),new I(e.id)],d=N.getTickArrayStartIndexByTick(n.tickLower,e.config.tickSpacing),f=N.getTickArrayStartIndexByTick(n.tickUpper,e.config.tickSpacing),{publicKey:u}=z(c,l,d),{publicKey:m}=z(c,l,f),{publicKey:p}=a?ne(i.wallet,n.nftMint,me):ne(i.wallet,n.nftMint,$),{publicKey:b}=Ce(c,n.nftMint),{publicKey:g}=De(c,l,n.tickLower,n.tickUpper);return{address:{tickArrayLower:u,tickArrayUpper:m,positionNftAccount:p,personalPosition:b,protocolPosition:g},instructions:[this.increasePositionFromBaseInstruction(c,i.wallet,p,b,l,g,u,m,i.tokenAccountA,i.tokenAccountB,new I(t.vault.A),new I(t.vault.B),new I(e.mintA.address),new I(e.mintB.address),o,r,s,ue.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing,[d,f])?fe(c,l).publicKey:void 0)],signers:[],instructionTypes:[te.ClmmIncreasePosition],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[]}}static increasePositionFromBaseInstruction(e,t,n,i,o,r,s,a,c,l,d,f,u,m,p,b,g,P){let A=J([X("liquidity"),F("amountMaxA"),F("amountMaxB"),le("optionBaseFlag"),Ie("baseFlag")]),T=[...P?[{pubkey:P,isSigner:!1,isWritable:!0}]:[]],k=[{pubkey:t,isSigner:!0,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:d,isSigner:!1,isWritable:!0},{pubkey:f,isSigner:!1,isWritable:!0},{pubkey:$,isSigner:!1,isWritable:!1},{pubkey:me,isSigner:!1,isWritable:!1},{pubkey:u,isSigner:!1,isWritable:!1},{pubkey:m,isSigner:!1,isWritable:!1},...T],w=Buffer.alloc(A.span);A.encode({liquidity:new Gn(0),amountMaxA:p==="MintA"?b:g,amountMaxB:p==="MintA"?g:b,baseFlag:p==="MintA",optionBaseFlag:1},w);let h=Buffer.from([...Me.increaseLiquidity,...w]);return new Ae({keys:k,programId:e,data:h})}static decreaseLiquidityInstruction(e,t,n,i,o,r,s,a,c,l,d,f,u,m,p,b,g,P,A){let T=J([X("liquidity"),F("amountMinA"),F("amountMinB")]),k=[...A?[{pubkey:A,isSigner:!1,isWritable:!0}]:[],...p.map(B=>[{pubkey:B.poolRewardVault,isSigner:!1,isWritable:!0},{pubkey:B.ownerRewardVault,isSigner:!1,isWritable:!0},{pubkey:B.rewardMint,isSigner:!1,isWritable:!1}]).flat()],w=[{pubkey:t,isSigner:!0,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:d,isSigner:!1,isWritable:!0},{pubkey:f,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:$,isSigner:!1,isWritable:!1},{pubkey:me,isSigner:!1,isWritable:!1},{pubkey:jt,isSigner:!1,isWritable:!1},{pubkey:u,isSigner:!1,isWritable:!1},{pubkey:m,isSigner:!1,isWritable:!1},...k],h=Buffer.alloc(T.span);T.encode({liquidity:b,amountMinA:g,amountMinB:P},h);let x=Buffer.from([...Me.decreaseLiquidity,...h]);return new Ae({keys:w,programId:e,data:x})}static decreaseLiquidityInstructions({poolInfo:e,poolKeys:t,ownerPosition:n,ownerInfo:i,liquidity:o,amountMinA:r,amountMinB:s,programId:a,nft2022:c}){let[l,d]=[new I(e.programId),new I(e.id)],f=N.getTickArrayStartIndexByTick(n.tickLower,e.config.tickSpacing),u=N.getTickArrayStartIndexByTick(n.tickUpper,e.config.tickSpacing),{publicKey:m}=z(l,d,f),{publicKey:p}=z(l,d,u),{publicKey:b}=c?ne(i.wallet,n.nftMint,me):ne(i.wallet,n.nftMint,a),{publicKey:g}=Ce(l,n.nftMint),{publicKey:P}=De(l,d,n.tickLower,n.tickUpper),A=[];for(let w=0;w<e.rewardDefaultInfos.length;w++)A.push({poolRewardVault:new I(t.rewardInfos[w].vault),ownerRewardVault:i.rewardAccounts[w],rewardMint:new I(e.rewardDefaultInfos[w].mint.address)});let T=[],k=this.decreaseLiquidityInstruction(l,i.wallet,b,g,d,P,m,p,i.tokenAccountA,i.tokenAccountB,new I(t.vault.A),new I(t.vault.B),new I(e.mintA.address),new I(e.mintB.address),A,o,r,s,ue.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing,[f,u])?fe(l,d).publicKey:void 0);return T.push(k),{address:{tickArrayLower:m,tickArrayUpper:p,positionNftAccount:b,personalPosition:g,protocolPosition:P},signers:[],instructions:T,instructionTypes:[te.ClmmDecreasePosition],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[]}}static swapInstruction(e,t,n,i,o,r,s,a,c,l,d,f,u,m,p,b,g){let P=J([F("amount"),F("otherAmountThreshold"),X("sqrtPriceLimitX64"),Ie("isBaseInput")]),A=[...g?[{pubkey:g,isSigner:!1,isWritable:!0}]:[],...d.map(h=>({pubkey:h,isSigner:!1,isWritable:!0}))],T=[{pubkey:t,isSigner:!0,isWritable:!1},{pubkey:i,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:f,isSigner:!1,isWritable:!0},{pubkey:$,isSigner:!1,isWritable:!1},{pubkey:me,isSigner:!1,isWritable:!1},{pubkey:jt,isSigner:!1,isWritable:!1},{pubkey:c,isSigner:!1,isWritable:!1},{pubkey:l,isSigner:!1,isWritable:!1},...A],k=Buffer.alloc(P.span);P.encode({amount:u,otherAmountThreshold:m,sqrtPriceLimitX64:p,isBaseInput:b},k);let w=Buffer.from([...Me.swap,...k]);return new Ae({keys:T,programId:e,data:w})}static makeSwapBaseInInstructions({poolInfo:e,poolKeys:t,observationId:n,ownerInfo:i,inputMint:o,amountIn:r,amountOutMin:s,sqrtPriceLimitX64:a,remainingAccounts:c}){let[l,d]=[new I(e.programId),new I(e.id)],[f,u]=[new I(t.vault.A),new I(t.vault.B)],[m,p]=[new I(e.mintA.address),new I(e.mintB.address)],b=e.mintA.address===o.toString(),g=[this.swapInstruction(l,i.wallet,d,new I(e.config.id),b?i.tokenAccountA:i.tokenAccountB,b?i.tokenAccountB:i.tokenAccountA,b?f:u,b?u:f,b?m:p,b?p:m,c,n,r,s,a,!0,fe(l,d).publicKey)];return{signers:[],instructions:g,instructionTypes:[te.ClmmSwapBaseIn],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[],address:{}}}static makeSwapBaseOutInstructions({poolInfo:e,poolKeys:t,observationId:n,ownerInfo:i,outputMint:o,amountOut:r,amountInMax:s,sqrtPriceLimitX64:a,remainingAccounts:c}){let[l,d]=[new I(e.programId),new I(e.id)],[f,u]=[new I(t.vault.A),new I(t.vault.B)],[m,p]=[new I(e.mintA.address),new I(e.mintB.address)],b=e.mintA.address===o.toBase58(),g=[this.swapInstruction(l,i.wallet,d,new I(e.config.id),b?i.tokenAccountB:i.tokenAccountA,b?i.tokenAccountA:i.tokenAccountB,b?u:f,b?f:u,b?p:m,b?m:p,c,n,r,s,a,!1,fe(l,d).publicKey)];return{signers:[],instructions:g,instructionTypes:[te.ClmmSwapBaseOut],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[],address:{}}}static initRewardInstruction(e,t,n,i,o,r,s,a,c,l,d,f){let u=J([F("openTime"),F("endTime"),X("emissionsPerSecondX64")]),m=[{pubkey:t,isSigner:!0,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!1},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!1},{pubkey:Qe.programId,isSigner:!1,isWritable:!1},{pubkey:$e,isSigner:!1,isWritable:!1}],p=Buffer.alloc(u.span);u.encode({openTime:ge(l),endTime:ge(d),emissionsPerSecondX64:f},p);let b=Buffer.from([...Me.initReward,...p]);return new Ae({keys:m,programId:e,data:b})}static initRewardInstructions({poolInfo:e,poolKeys:t,ownerInfo:n,rewardInfo:i}){let[o,r]=[new I(e.programId),new I(e.id)],s=Si(o,r,i.mint).publicKey,a=_t(o).publicKey,c=[this.initRewardInstruction(o,n.wallet,r,a,new I(e.config.id),n.tokenAccount,i.programId,i.mint,s,i.openTime,i.endTime,i.emissionsPerSecondX64)];return{address:{poolRewardVault:s,operationId:a},signers:[],instructions:c,instructionTypes:[te.ClmmInitReward],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[]}}static setRewardInstruction(e,t,n,i,o,r,s,a,c,l,d,f){let u=J([le("rewardIndex"),X("emissionsPerSecondX64"),F("openTime"),F("endTime")]),m=[{pubkey:t,isSigner:!0,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:$,isSigner:!1,isWritable:!1},{pubkey:me,isSigner:!1,isWritable:!1},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0}],p=Buffer.alloc(u.span);u.encode({rewardIndex:c,emissionsPerSecondX64:f,openTime:ge(l),endTime:ge(d)},p);let b=Buffer.from([...Me.setRewardEmissions,...p]);return new Ae({keys:m,programId:e,data:b})}static setRewardInstructions({poolInfo:e,poolKeys:t,ownerInfo:n,rewardInfo:i}){let[o,r]=[new I(e.programId),new I(e.id)],s,a,c;for(let f=0;f<e.rewardDefaultInfos.length;f++)e.rewardDefaultInfos[f].mint.address===i.mint.toString()&&(s=f,a=new I(t.rewardInfos[f].vault),c=new I(t.rewardInfos[f].mint.address));(s===void 0||a===void 0)&&Di.logWithError("reward mint check error","no reward mint",e.rewardDefaultInfos);let l=_t(o).publicKey,d=[this.setRewardInstruction(o,n.wallet,r,l,new I(e.config.id),n.tokenAccount,a,c,s,i.openTime,i.endTime,i.emissionsPerSecondX64)];return{address:{rewardVault:a,operationId:l},signers:[],instructions:d,instructionTypes:[te.ClmmSetReward],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[]}}static collectRewardInstruction(e,t,n,i,o,r,s){let a=J([le("rewardIndex")]),c=[{pubkey:t,isSigner:!0,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!1},{pubkey:$,isSigner:!1,isWritable:!1},{pubkey:me,isSigner:!1,isWritable:!1},{pubkey:jt,isSigner:!1,isWritable:!1}],l=Buffer.alloc(a.span);a.encode({rewardIndex:s},l);let d=Buffer.from([...Me.collectReward,...l]);return new Ae({keys:c,programId:e,data:d})}static collectRewardInstructions({poolInfo:e,poolKeys:t,ownerInfo:n,rewardMint:i}){let[o,r]=[new I(e.programId),new I(e.id)],s,a;for(let l=0;l<e.rewardDefaultInfos.length;l++)e.rewardDefaultInfos[l].mint.address===i.toString()&&(s=l,a=new I(t.rewardInfos[l].vault));(s===void 0||a===void 0)&&Di.logWithError("reward mint check error","no reward mint",e.rewardDefaultInfos);let c=[this.collectRewardInstruction(o,n.wallet,r,n.tokenAccount,a,i,s)];return{address:{rewardVault:a},signers:[],instructions:c,instructionTypes:[te.ClmmCollectReward],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[]}}static async makeLockPositions({programId:e,authProgramId:t,poolProgramId:n,payer:i,wallet:o,nftMint:r,nft2022:s,getEphemeralSigners:a}){let c=[],l;if(a)l=new I((await a(1))[0]);else{let g=un.generate();c.push(g),l=g.publicKey}let d=s?ne(o,r,me).publicKey:ne(o,r,$).publicKey,{publicKey:f}=Ce(n,r),u=wt(e,l).publicKey,m=ne(o,l,$).publicKey,p=Dt(l).publicKey,b=oe.lockPositionInstructionV2({programId:e,auth:t,payer:i,positionOwner:o,lockOwner:o,positionNftAccount:d,positionId:f,lockPositionId:u,lockNftMint:l,lockNftAccount:m,metadataAccount:p,withMetadata:!0,nft2022:s,positionNftMint:r,authPositionNftAccount:ne(t,r,s?me:$).publicKey,positionNftProgram:s?me:$});return{address:{positionId:f,lockPositionId:u,lockNftAccount:m,lockNftMint:l,positionNftAccount:d,metadataAccount:p},instructions:[b],signers:c,instructionTypes:[te.ClmmLockPosition],lookupTableAddress:[]}}static lockPositionInstructionV2({programId:e,auth:t,payer:n,positionOwner:i,lockOwner:o,positionNftAccount:r,positionId:s,positionNftMint:a,authPositionNftAccount:c,positionNftProgram:l,lockPositionId:d,lockNftMint:f,lockNftAccount:u,metadataAccount:m,withMetadata:p}){let b=[{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!0,isWritable:!0},{pubkey:i,isSigner:!0,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!1},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:d,isSigner:!1,isWritable:!0},{pubkey:f,isSigner:!0,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:m,isSigner:!1,isWritable:!0},{pubkey:rt,isSigner:!1,isWritable:!1},{pubkey:qt,isSigner:!1,isWritable:!1},{pubkey:$e,isSigner:!1,isWritable:!1},{pubkey:$,isSigner:!1,isWritable:!1},{pubkey:l,isSigner:!1,isWritable:!1},{pubkey:Qe.programId,isSigner:!1,isWritable:!1}],g=J([Ie("withMetadata")]),P=Buffer.alloc(g.span);g.encode({withMetadata:p},P);let A=Buffer.from([..._i,...P]);return new Ae({keys:b,programId:e,data:A})}static lockPositionInstruction({programId:e,authProgramId:t,poolProgramId:n,owner:i,positionNft:o}){let{publicKey:r}=ne(i,o,$),{publicKey:s}=Ce(n,o),a=[{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:i,isSigner:!0,isWritable:!1},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!1},{pubkey:Dn(e,s).publicKey,isSigner:!1,isWritable:!0},{pubkey:$,isSigner:!1,isWritable:!1},{pubkey:Qe.programId,isSigner:!1,isWritable:!1}];return new Ae({keys:a,programId:e,data:Buffer.from(_i)})}static harvestLockPositionInstruction(e){let[t,n]=[new I(e.poolKeys.programId),new I(e.poolKeys.id)],i=N.getTickArrayStartIndexByTick(e.ownerPosition.tickLower,e.poolKeys.config.tickSpacing),o=N.getTickArrayStartIndexByTick(e.ownerPosition.tickUpper,e.poolKeys.config.tickSpacing),{publicKey:r}=z(t,n,i),{publicKey:s}=z(t,n,o),{publicKey:a}=ne(e.owner,e.ownerPosition.nftMint,$),{publicKey:c}=Ce(t,e.ownerPosition.nftMint),{publicKey:l}=De(t,n,e.ownerPosition.tickLower,e.ownerPosition.tickUpper),d=[];for(let m=0;m<e.poolKeys.rewardInfos.length;m++)d.push({poolRewardVault:new I(e.poolKeys.rewardInfos[m].vault),ownerRewardVault:e.ownerRewardAccounts[m],rewardMint:new I(e.poolKeys.rewardInfos[m].mint.address)});let f=[...d.map(m=>[{pubkey:m.poolRewardVault,isSigner:!1,isWritable:!0},{pubkey:m.ownerRewardVault,isSigner:!1,isWritable:!0},{pubkey:m.rewardMint,isSigner:!1,isWritable:!1}]).flat()],u=[{pubkey:e.authProgramId,isSigner:!1,isWritable:!1},{pubkey:Dn(e.programId,c).publicKey,isSigner:!1,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:e.owner,isSigner:!0,isWritable:!1},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:new I(e.poolKeys.vault.A),isSigner:!1,isWritable:!0},{pubkey:new I(e.poolKeys.vault.B),isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:e.userVaultA,isSigner:!1,isWritable:!0},{pubkey:e.userVaultB,isSigner:!1,isWritable:!0},{pubkey:$,isSigner:!1,isWritable:!1},{pubkey:me,isSigner:!1,isWritable:!1},{pubkey:wn,isSigner:!1,isWritable:!1},{pubkey:new I(e.poolKeys.mintA.address),isSigner:!1,isWritable:!1},{pubkey:new I(e.poolKeys.mintB.address),isSigner:!1,isWritable:!1},...f];return new Ae({keys:u,programId:e.programId,data:Buffer.from(Wi)})}static harvestLockPositionInstructionV2({programId:e,auth:t,lockPositionId:n,clmmProgram:i,lockOwner:o,lockNftMint:r,lockNftAccount:s,positionNftAccount:a,positionId:c,poolId:l,protocolPosition:d,vaultA:f,vaultB:u,tickArrayLower:m,tickArrayUpper:p,userVaultA:b,userVaultB:g,mintA:P,mintB:A,rewardAccounts:T,exTickArrayBitmap:k}){let w=[...k?[{pubkey:k,isSigner:!1,isWritable:!0}]:[],...T.map(x=>[{pubkey:x.poolRewardVault,isSigner:!1,isWritable:!0},{pubkey:x.ownerRewardVault,isSigner:!1,isWritable:!0},{pubkey:x.rewardMint,isSigner:!1,isWritable:!1}]).flat()],h=[{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!0,isWritable:!1},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:i,isSigner:!1,isWritable:!1},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:d,isSigner:!1,isWritable:!0},{pubkey:f,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:m,isSigner:!1,isWritable:!0},{pubkey:p,isSigner:!1,isWritable:!0},{pubkey:b,isSigner:!1,isWritable:!0},{pubkey:g,isSigner:!1,isWritable:!0},{pubkey:$,isSigner:!1,isWritable:!1},{pubkey:me,isSigner:!1,isWritable:!1},{pubkey:wn,isSigner:!1,isWritable:!1},{pubkey:P,isSigner:!1,isWritable:!1},{pubkey:A,isSigner:!1,isWritable:!1},...w];return new Ae({keys:h,programId:e,data:Buffer.from(Wi)})}};var qi=class extends Mt{constructor(e){super(e)}async getClmmPoolKeys(e){return(await this.scope.api.fetchPoolKeysById({idList:[e]}))[0]}async createPool(e){var h;let{programId:t,owner:n=((h=this.scope.owner)==null?void 0:h.publicKey)||L.default,mint1:i,mint2:o,ammConfig:r,initialPrice:s,computeBudgetConfig:a,forerunCreate:c,getObserveState:l,txVersion:d,txTipConfig:f,feePayer:u}=e,m=this.createTxBuilder(u),[p,b,g]=new Ke(new L(i.address).toBuffer()).gt(new Ke(new L(o.address).toBuffer()))?[o,i,new ut(1).div(s)]:[i,o,s],P=_.priceToSqrtPriceX64(g,p.decimals,b.decimals),A=[],T=[];p.programId===nt.toBase58()&&T.push(_n(t,new L(p.address)).publicKey),b.programId===nt.toBase58()&&T.push(_n(t,new L(b.address)).publicKey),(await this.scope.connection.getMultipleAccountsInfo(T)).forEach((x,B)=>{x&&A.push(T[B])});let w=await oe.createPoolInstructions({connection:this.scope.connection,programId:t,owner:n,mintA:p,mintB:b,ammConfigId:r.id,initialPriceX64:P,forerunCreate:!l&&c,extendMintAccount:A});return m.addInstruction(w),m.addCustomComputeBudget(a),m.addTipInstruction(f),m.versionBuild({txVersion:d,extInfo:{address:G(O({},w.address),{observationId:w.address.observationId.toBase58(),exBitmapAccount:w.address.exBitmapAccount.toBase58(),programId:t.toString(),id:w.address.poolId.toString(),mintA:p,mintB:b,openTime:"0",vault:{A:w.address.mintAVault.toString(),B:w.address.mintBVault.toString()},rewardInfos:[],config:{id:r.id.toString(),index:r.index,protocolFeeRate:r.protocolFeeRate,tradeFeeRate:r.tradeFeeRate,tickSpacing:r.tickSpacing,fundFeeRate:r.fundFeeRate,description:r.description,defaultRange:0,defaultRangePoint:[]}}),mockPoolInfo:O({type:"Concentrated",rewardDefaultPoolInfos:"Clmm",id:w.address.poolId.toString(),mintA:p,mintB:b,feeRate:r.tradeFeeRate,openTime:"0",programId:t.toString(),price:g.toNumber(),config:{id:r.id.toString(),index:r.index,protocolFeeRate:r.protocolFeeRate,tradeFeeRate:r.tradeFeeRate,tickSpacing:r.tickSpacing,fundFeeRate:r.fundFeeRate,description:r.description,defaultRange:0,defaultRangePoint:[]},burnPercent:0},Ti),forerunCreate:c}})}async openPositionFromBase({poolInfo:e,poolKeys:t,ownerInfo:n,tickLower:i,tickUpper:o,base:r,baseAmount:s,otherAmountMax:a,nft2022:c,associatedOnly:l=!0,checkCreateATAOwner:d=!1,withMetadata:f="create",getEphemeralSigners:u,computeBudgetConfig:m,txTipConfig:p,txVersion:b,feePayer:g}){this.scope.availability.addConcentratedPosition===!1&&this.logAndCreateError("add position feature disabled in your region"),this.scope.checkOwner();let P=this.createTxBuilder(g),A=null,T=null,k=n.useSOLBalance&&e.mintA.address===Q.toString(),w=n.useSOLBalance&&e.mintB.address===Q.toString(),[h,x]=r==="MintA"?[s,a]:[a,s],{account:B,instructionParams:C}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:e.mintA.programId,mint:new L(e.mintA.address),owner:this.scope.ownerPubKey,createInfo:k||h.isZero()?{payer:this.scope.ownerPubKey,amount:h}:void 0,skipCloseAccount:!k,notUseTokenAccount:k,associatedOnly:k?!1:l,checkCreateATAOwner:d});B&&(A=B),P.addInstruction(C||{});let{account:R,instructionParams:K}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:e.mintB.programId,mint:new L(e.mintB.address),owner:this.scope.ownerPubKey,createInfo:w||x.isZero()?{payer:this.scope.ownerPubKey,amount:x}:void 0,skipCloseAccount:!w,notUseTokenAccount:w,associatedOnly:w?!1:l,checkCreateATAOwner:d});R&&(T=R),P.addInstruction(K||{}),(!A||!T)&&this.logAndCreateError("cannot found target token accounts","tokenAccounts",{ownerTokenAccountA:A==null?void 0:A.toBase58(),ownerTokenAccountB:T==null?void 0:T.toBase58()});let M=t||await this.getClmmPoolKeys(e.id),S=await oe.openPositionFromBaseInstructions({poolInfo:e,poolKeys:M,ownerInfo:G(O({},n),{feePayer:this.scope.ownerPubKey,wallet:this.scope.ownerPubKey,tokenAccountA:A,tokenAccountB:T}),tickLower:i,tickUpper:o,base:r,baseAmount:s,otherAmountMax:a,withMetadata:f,getEphemeralSigners:u,nft2022:c});return P.addInstruction(S),P.addCustomComputeBudget(m),P.addTipInstruction(p),P.versionBuild({txVersion:b,extInfo:O({},S.address)})}async openPositionFromLiquidity({poolInfo:e,poolKeys:t,ownerInfo:n,amountMaxA:i,amountMaxB:o,tickLower:r,tickUpper:s,liquidity:a,associatedOnly:c=!0,checkCreateATAOwner:l=!1,withMetadata:d="create",txVersion:f,computeBudgetConfig:u,txTipConfig:m,getEphemeralSigners:p,nft2022:b,feePayer:g}){this.scope.availability.createConcentratedPosition===!1&&this.logAndCreateError("open position feature disabled in your region");let P=this.createTxBuilder(g),A=null,T=null,k=n.useSOLBalance&&e.mintA.address===Q.toBase58(),w=n.useSOLBalance&&e.mintB.address===Q.toBase58(),{account:h,instructionParams:x}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:e.mintA.programId,mint:new L(e.mintA.address),owner:this.scope.ownerPubKey,createInfo:k||i.isZero()?{payer:this.scope.ownerPubKey,amount:i}:void 0,skipCloseAccount:!k,notUseTokenAccount:k,associatedOnly:k?!1:c,checkCreateATAOwner:l});h&&(A=h),P.addInstruction(x||{});let{account:B,instructionParams:C}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:e.mintB.programId,mint:new L(e.mintB.address),owner:this.scope.ownerPubKey,createInfo:w||o.isZero()?{payer:this.scope.ownerPubKey,amount:o}:void 0,skipCloseAccount:!w,notUseTokenAccount:w,associatedOnly:w?!1:c,checkCreateATAOwner:l});B&&(T=B),P.addInstruction(C||{}),(A===void 0||T===void 0)&&this.logAndCreateError("cannot found target token accounts","tokenAccounts",this.scope.account.tokenAccounts);let R=t||await this.getClmmPoolKeys(e.id),K=await oe.openPositionFromLiquidityInstructions({poolInfo:e,poolKeys:R,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccountA:A,tokenAccountB:T},tickLower:r,tickUpper:s,liquidity:a,amountMaxA:i,amountMaxB:o,withMetadata:d,getEphemeralSigners:p,nft2022:b});return P.addInstruction(K),P.addCustomComputeBudget(u),P.addTipInstruction(m),P.versionBuild({txVersion:f,extInfo:{address:K.address}})}async increasePositionFromLiquidity(e){var C;let{poolInfo:t,poolKeys:n,ownerPosition:i,amountMaxA:o,amountMaxB:r,liquidity:s,ownerInfo:a,associatedOnly:c=!0,checkCreateATAOwner:l=!1,computeBudgetConfig:d,txTipConfig:f,txVersion:u,feePayer:m}=e,p=this.createTxBuilder(m),b,g,P=a.useSOLBalance&&t.mintA.address===Q.toString(),A=a.useSOLBalance&&t.mintB.address===Q.toString(),{account:T,instructionParams:k}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:t.mintA.programId,mint:new L(t.mintA.address),notUseTokenAccount:P,owner:this.scope.ownerPubKey,createInfo:P||o.isZero()?{payer:this.scope.ownerPubKey,amount:o}:void 0,skipCloseAccount:!P,associatedOnly:P?!1:c,checkCreateATAOwner:l});T&&(b=T),p.addInstruction(k||{});let{account:w,instructionParams:h}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:t.mintB.programId,mint:new L(t.mintB.address),owner:this.scope.ownerPubKey,createInfo:A||r.isZero()?{payer:this.scope.ownerPubKey,amount:r}:void 0,notUseTokenAccount:A,skipCloseAccount:!A,associatedOnly:A?!1:c,checkCreateATAOwner:l});w&&(g=w),p.addInstruction(h||{}),!b&&!g&&this.logAndCreateError("cannot found target token accounts","tokenAccounts",this.scope.account.tokenAccounts);let x=n!=null?n:await this.getClmmPoolKeys(t.id),B=oe.increasePositionFromLiquidityInstructions({poolInfo:t,poolKeys:x,ownerPosition:i,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccountA:b,tokenAccountB:g},liquidity:s,amountMaxA:o,amountMaxB:r,nft2022:(C=await this.scope.connection.getAccountInfo(i.nftMint))==null?void 0:C.owner.equals(nt)});return p.addInstruction(B),p.addCustomComputeBudget(d),p.addTipInstruction(f),p.versionBuild({txVersion:u,extInfo:{address:B.address}})}async increasePositionFromBase(e){var B;let{poolInfo:t,ownerPosition:n,base:i,baseAmount:o,otherAmountMax:r,ownerInfo:s,associatedOnly:a=!0,checkCreateATAOwner:c=!1,computeBudgetConfig:l,txTipConfig:d,txVersion:f,feePayer:u}=e,m=this.createTxBuilder(u),p,b,g=s.useSOLBalance&&t.mintA.address===Q.toString(),P=s.useSOLBalance&&t.mintB.address===Q.toString(),{account:A,instructionParams:T}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:t.mintA.programId,mint:new L(t.mintA.address),notUseTokenAccount:g,owner:this.scope.ownerPubKey,createInfo:g||(i==="MintA"?o:r).isZero()?{payer:this.scope.ownerPubKey,amount:i==="MintA"?o:r}:void 0,skipCloseAccount:!g,associatedOnly:g?!1:a,checkCreateATAOwner:c});A&&(p=A),m.addInstruction(T||{});let{account:k,instructionParams:w}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:t.mintB.programId,mint:new L(t.mintB.address),owner:this.scope.ownerPubKey,createInfo:P||(i==="MintA"?r:o).isZero()?{payer:this.scope.ownerPubKey,amount:i==="MintA"?r:o}:void 0,notUseTokenAccount:P,skipCloseAccount:!P,associatedOnly:P?!1:a,checkCreateATAOwner:c});k&&(b=k),m.addInstruction(w||{}),!p&&!b&&this.logAndCreateError("cannot found target token accounts","tokenAccounts",this.scope.account.tokenAccounts);let h=await this.getClmmPoolKeys(t.id),x=oe.increasePositionFromBaseInstructions({poolInfo:t,poolKeys:h,ownerPosition:n,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccountA:p,tokenAccountB:b},base:i,baseAmount:o,otherAmountMax:r,nft2022:(B=await this.scope.connection.getAccountInfo(n.nftMint))==null?void 0:B.owner.equals(nt)});return m.addInstruction(x),m.addCustomComputeBudget(l),m.addTipInstruction(d),m.versionBuild({txVersion:f,extInfo:{address:x.address}})}async decreaseLiquidity(e){var M;let{poolInfo:t,poolKeys:n,ownerPosition:i,ownerInfo:o,amountMinA:r,amountMinB:s,liquidity:a,associatedOnly:c=!0,checkCreateATAOwner:l=!1,computeBudgetConfig:d,txTipConfig:f,txVersion:u,feePayer:m}=e;this.scope.availability.removeConcentratedPosition===!1&&this.logAndCreateError("remove position feature disabled in your region");let p=this.createTxBuilder(m),b=o.useSOLBalance&&t.mintA.address===Q.toString(),g=o.useSOLBalance&&t.mintB.address===Q.toString(),P,A,{account:T,instructionParams:k}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:t.mintA.programId,mint:new L(t.mintA.address),notUseTokenAccount:b,owner:this.scope.ownerPubKey,createInfo:{payer:this.scope.ownerPubKey,amount:0},skipCloseAccount:!b,associatedOnly:b?!1:c,checkCreateATAOwner:l});P=T,k&&p.addInstruction(k);let{account:w,instructionParams:h}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:t.mintB.programId,mint:new L(t.mintB.address),notUseTokenAccount:g,owner:this.scope.ownerPubKey,createInfo:{payer:this.scope.ownerPubKey,amount:0},skipCloseAccount:!g,associatedOnly:g?!1:c,checkCreateATAOwner:l});A=w,h&&p.addInstruction(h);let x=[];for(let S of t.rewardDefaultInfos){let D=o.useSOLBalance&&S.mint.address===Q.toString(),U;if(S.mint.address===t.mintA.address)U=P;else if(S.mint.address===t.mintB.address)U=A;else{let{account:be,instructionParams:Te}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:new L(S.mint.programId),mint:new L(S.mint.address),notUseTokenAccount:D,owner:this.scope.ownerPubKey,createInfo:{payer:this.scope.ownerPubKey,amount:0},skipCloseAccount:!D,associatedOnly:D?!1:c,checkCreateATAOwner:l});U=be,Te&&p.addInstruction(Te)}x.push(U)}!P&&!A&&this.logAndCreateError("cannot found target token accounts","tokenAccounts",this.scope.account.tokenAccountRawInfos);let B=n!=null?n:await this.getClmmPoolKeys(t.id),C=(M=await this.scope.connection.getAccountInfo(i.nftMint))==null?void 0:M.owner.equals(nt),R=await oe.decreaseLiquidityInstructions({poolInfo:t,poolKeys:B,ownerPosition:i,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccountA:P,tokenAccountB:A,rewardAccounts:x},liquidity:a,amountMinA:r,amountMinB:s,nft2022:C});p.addInstruction({instructions:R.instructions,instructionTypes:[te.ClmmDecreasePosition]});let K=O({},R.address);if(o.closePosition){let S=await oe.closePositionInstructions({poolInfo:t,poolKeys:B,ownerInfo:{wallet:this.scope.ownerPubKey},ownerPosition:i,nft2022:C});p.addInstruction({endInstructions:S.instructions,endInstructionTypes:S.instructionTypes}),K=O(O({},K),S.address)}return p.addCustomComputeBudget(d),p.addTipInstruction(f),p.versionBuild({txVersion:u,extInfo:{address:K}})}async lockPosition(e){var m;let{programId:t=Ct,authProgramId:n=Jt,poolProgramId:i=St,ownerPosition:o,payer:r,computeBudgetConfig:s,txTipConfig:a,txVersion:c,getEphemeralSigners:l,feePayer:d}=e,f=this.createTxBuilder(d),u=await oe.makeLockPositions({programId:t,authProgramId:n,poolProgramId:i,wallet:this.scope.ownerPubKey,payer:r!=null?r:this.scope.ownerPubKey,nftMint:o.nftMint,getEphemeralSigners:l,nft2022:(m=await this.scope.connection.getAccountInfo(o.nftMint))==null?void 0:m.owner.equals(nt)});return f.addInstruction(u),f.addCustomComputeBudget(s),f.addTipInstruction(a),f.versionBuild({txVersion:c,extInfo:u.address})}async harvestLockPosition(e){let{programId:t=Ct,authProgramId:n=Jt,clmmProgram:i=St,poolKeys:o,lockData:r,ownerInfo:s={useSOLBalance:!0},associatedOnly:a=!0,checkCreateATAOwner:c=!1,computeBudgetConfig:l,txTipConfig:d,txVersion:f,feePayer:u}=e,m=o||await this.getClmmPoolKeys(r.poolId.toString()),p=this.createTxBuilder(u),b=await this.scope.connection.getAccountInfo(r.positionId);b||this.logger.logWithError("position not found",r.positionId);let g=Pt.decode(b.data),P=s.useSOLBalance&&m.mintA.address===Q.toString(),A=s.useSOLBalance&&m.mintB.address===Q.toString(),T,k,{account:w,instructionParams:h}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:m.mintA.programId,mint:new L(m.mintA.address),notUseTokenAccount:P,owner:this.scope.ownerPubKey,createInfo:{payer:this.scope.ownerPubKey,amount:0},skipCloseAccount:!P,associatedOnly:P?!1:a,checkCreateATAOwner:c});T=w,h&&p.addInstruction(h);let{account:x,instructionParams:B}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:m.mintB.programId,mint:new L(m.mintB.address),notUseTokenAccount:A,owner:this.scope.ownerPubKey,createInfo:{payer:this.scope.ownerPubKey,amount:0},skipCloseAccount:!A,associatedOnly:A?!1:a,checkCreateATAOwner:c});k=x,B&&p.addInstruction(B);let C={},R=[];for(let pe of m.rewardInfos){let Be=s.useSOLBalance&&pe.mint.address===Q.toString(),Ye=C[pe.mint.address];if(!Ye){let{account:Gi,instructionParams:Un}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:new L(pe.mint.programId),mint:new L(pe.mint.address),notUseTokenAccount:Be,owner:this.scope.ownerPubKey,skipCloseAccount:!Be,createInfo:{payer:this.scope.ownerPubKey,amount:0},associatedOnly:Be?!1:a});Ye=Gi,Un&&p.addInstruction(Un)}C[pe.mint.address]=Ye,R.push(Ye)}let K=wt(t,r.lockNftMint).publicKey,M=ne(this.scope.ownerPubKey,r.lockNftMint,Gt).publicKey,S=N.getTickArrayStartIndexByTick(g.tickLower,m.config.tickSpacing),D=N.getTickArrayStartIndexByTick(g.tickUpper,m.config.tickSpacing),{publicKey:U}=z(new L(m.programId),r.poolId,S),{publicKey:be}=z(new L(m.programId),r.poolId,D),{publicKey:Te}=De(new L(m.programId),r.poolId,g.tickLower,g.tickUpper),Ue=[];for(let pe=0;pe<m.rewardInfos.length;pe++)Ue.push({poolRewardVault:new L(m.rewardInfos[pe].vault),ownerRewardVault:R[pe],rewardMint:new L(m.rewardInfos[pe].mint.address)});let lt=await oe.harvestLockPositionInstructionV2({programId:t,auth:n,lockPositionId:K,clmmProgram:i,lockOwner:this.scope.ownerPubKey,lockNftMint:r.lockNftMint,lockNftAccount:M,positionNftAccount:r.nftAccount,positionId:r.positionId,poolId:r.poolId,protocolPosition:Te,vaultA:new L(m.vault.A),vaultB:new L(m.vault.B),tickArrayLower:U,tickArrayUpper:be,userVaultA:T,userVaultB:k,mintA:new L(m.mintA.address),mintB:new L(m.mintB.address),rewardAccounts:Ue,exTickArrayBitmap:fe(i,r.poolId).publicKey});return p.addInstruction({instructions:[lt],instructionTypes:[te.ClmmHarvestLockPosition]}),p.addCustomComputeBudget(l),p.addTipInstruction(d),p.versionBuild({txVersion:f})}async closePosition({poolInfo:e,poolKeys:t,ownerPosition:n,txVersion:i,computeBudgetConfig:o,txTipConfig:r,feePayer:s}){var d;this.scope.availability.removeConcentratedPosition===!1&&this.logAndCreateError("remove position feature disabled in your region");let a=this.createTxBuilder(s),c=t!=null?t:await this.getClmmPoolKeys(e.id),l=oe.closePositionInstructions({poolInfo:e,poolKeys:c,ownerInfo:{wallet:this.scope.ownerPubKey},ownerPosition:n,nft2022:(d=await this.scope.connection.getAccountInfo(n.nftMint))==null?void 0:d.owner.equals(nt)});return a.addCustomComputeBudget(o),a.addTipInstruction(r),a.addInstruction(l).versionBuild({txVersion:i,extInfo:{address:l.address}})}async initReward({poolInfo:e,ownerInfo:t,rewardInfo:n,associatedOnly:i=!0,checkCreateATAOwner:o=!1,computeBudgetConfig:r,txVersion:s,feePayer:a}){n.endTime<=n.openTime&&this.logAndCreateError("reward time error","rewardInfo",n);let c=this.createTxBuilder(a),l=t.useSOLBalance&&n.mint.address.toString()===Q.toString(),d=n.perSecond.mul(n.endTime-n.openTime),{account:f,instructionParams:u}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:new L(n.mint.address),mint:new L(n.mint.address),notUseTokenAccount:!!l,skipCloseAccount:!l,owner:this.scope.ownerPubKey,createInfo:l?{payer:t.feePayer||this.scope.ownerPubKey,amount:new Ke(new ut(d.toFixed(0)).gte(d)?d.toFixed(0):d.add(1).toFixed(0))}:void 0,associatedOnly:l?!1:i,checkCreateATAOwner:o});u&&c.addInstruction(u),f||this.logAndCreateError("no money","ownerRewardAccount",this.scope.account.tokenAccountRawInfos);let m=await this.getClmmPoolKeys(e.id),p=oe.initRewardInstructions({poolInfo:e,poolKeys:m,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccount:f},rewardInfo:{programId:new L(n.mint.programId),mint:new L(n.mint.address),openTime:n.openTime,endTime:n.endTime,emissionsPerSecondX64:W.decimalToX64(n.perSecond)}});return c.addInstruction(p),c.addCustomComputeBudget(r),c.versionBuild({txVersion:s,extInfo:{address:p.address}})}async initRewards({poolInfo:e,poolKeys:t,ownerInfo:n,rewardInfos:i,associatedOnly:o=!0,checkCreateATAOwner:r=!1,computeBudgetConfig:s,txTipConfig:a,txVersion:c,feePayer:l}){for(let u of i)u.endTime<=u.openTime&&this.logAndCreateError("reward time error","rewardInfo",u);let d=this.createTxBuilder(l),f={};for(let u of i){let m=n.useSOLBalance&&u.mint.address===Q.toString(),p=u.perSecond.mul(u.endTime-u.openTime),{account:b,instructionParams:g}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:new L(u.mint.programId),mint:new L(u.mint.address),notUseTokenAccount:!!m,skipCloseAccount:!m,owner:this.scope.ownerPubKey,createInfo:m?{payer:n.feePayer||this.scope.ownerPubKey,amount:new Ke(new ut(p.toFixed(0)).gte(p)?p.toFixed(0):p.add(1).toFixed(0))}:void 0,associatedOnly:m?!1:o,checkCreateATAOwner:r});g&&d.addInstruction(g),b||this.logAndCreateError("no money","ownerRewardAccount",this.scope.account.tokenAccountRawInfos);let P=t!=null?t:await this.getClmmPoolKeys(e.id),A=oe.initRewardInstructions({poolInfo:e,poolKeys:P,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccount:b},rewardInfo:{programId:new L(u.mint.programId),mint:new L(u.mint.address),openTime:u.openTime,endTime:u.endTime,emissionsPerSecondX64:W.decimalToX64(u.perSecond)}});f=O(O({},f),A.address),d.addInstruction(A)}return d.addCustomComputeBudget(s),d.addTipInstruction(a),d.versionBuild({txVersion:c,extInfo:{address:f}})}async setReward({poolInfo:e,ownerInfo:t,rewardInfo:n,associatedOnly:i=!0,checkCreateATAOwner:o=!1,computeBudgetConfig:r,txTipConfig:s,txVersion:a,feePayer:c}){n.endTime<=n.openTime&&this.logAndCreateError("reward time error","rewardInfo",n);let l=this.createTxBuilder(c),d=t.useSOLBalance&&n.mint.equals(Q),{account:f,instructionParams:u}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:n.programId,mint:n.mint,notUseTokenAccount:d,owner:this.scope.ownerPubKey,createInfo:d?{payer:t.feePayer||this.scope.ownerPubKey,amount:new Ke(new ut(n.perSecond.mul(n.endTime-n.openTime).toFixed(0)).gte(n.perSecond.mul(n.endTime-n.openTime))?n.perSecond.mul(n.endTime-n.openTime).toFixed(0):n.perSecond.mul(n.endTime-n.openTime).add(1).toFixed(0))}:void 0,associatedOnly:d?!1:i,checkCreateATAOwner:o});u&&l.addInstruction(u),f||this.logAndCreateError("no money","ownerRewardAccount",this.scope.account.tokenAccountRawInfos);let m=await this.getClmmPoolKeys(e.id),p=oe.setRewardInstructions({poolInfo:e,poolKeys:m,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccount:f},rewardInfo:{mint:n.mint,openTime:n.openTime,endTime:n.endTime,emissionsPerSecondX64:W.decimalToX64(n.perSecond)}});return l.addInstruction(p),l.addCustomComputeBudget(r),l.addTipInstruction(s),l.versionBuild({txVersion:a,extInfo:{address:p.address}})}async setRewards({poolInfo:e,poolKeys:t,ownerInfo:n,rewardInfos:i,associatedOnly:o=!0,checkCreateATAOwner:r=!1,computeBudgetConfig:s,txTipConfig:a,txVersion:c,feePayer:l}){let d=this.createTxBuilder(l),f={};for(let u of i){u.endTime<=u.openTime&&this.logAndCreateError("reward time error","rewardInfo",u);let m=n.useSOLBalance&&u.mint.address===Q.toString(),{account:p,instructionParams:b}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:new L(u.mint.programId),mint:new L(u.mint.address),notUseTokenAccount:m,owner:this.scope.ownerPubKey,createInfo:m?{payer:n.feePayer||this.scope.ownerPubKey,amount:new Ke(new ut(u.perSecond.mul(u.endTime-u.openTime).toFixed(0)).gte(u.perSecond.mul(u.endTime-u.openTime))?u.perSecond.mul(u.endTime-u.openTime).toFixed(0):u.perSecond.mul(u.endTime-u.openTime).add(1).toFixed(0))}:void 0,associatedOnly:m?!1:o,checkCreateATAOwner:r});b&&d.addInstruction(b),p||this.logAndCreateError("no money","ownerRewardAccount",this.scope.account.tokenAccountRawInfos);let g=t!=null?t:await this.getClmmPoolKeys(e.id),P=oe.setRewardInstructions({poolInfo:e,poolKeys:g,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccount:p},rewardInfo:{mint:new L(u.mint.address),openTime:u.openTime,endTime:u.endTime,emissionsPerSecondX64:W.decimalToX64(u.perSecond)}});d.addInstruction(P),f=O(O({},f),P.address)}return d.addCustomComputeBudget(s),d.addTipInstruction(a),d.versionBuild({txVersion:c,extInfo:{address:f}})}async collectReward({poolInfo:e,ownerInfo:t,rewardMint:n,associatedOnly:i=!0,checkCreateATAOwner:o=!1,computeBudgetConfig:r,txTipConfig:s,txVersion:a,feePayer:c}){let l=e.rewardDefaultInfos.find(g=>g.mint.address===n.toString());l||this.logAndCreateError("reward mint error","not found reward mint",n);let d=this.createTxBuilder(c),f=t.useSOLBalance&&n.equals(Q),{account:u,instructionParams:m}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:new L(l.mint.programId),mint:n,notUseTokenAccount:f,owner:this.scope.ownerPubKey,skipCloseAccount:!f,createInfo:{payer:t.feePayer||this.scope.ownerPubKey,amount:0},associatedOnly:f?!1:i,checkCreateATAOwner:o});m&&d.addInstruction(m),u||this.logAndCreateError("no money","ownerRewardAccount",this.scope.account.tokenAccountRawInfos);let p=await this.getClmmPoolKeys(e.id),b=oe.collectRewardInstructions({poolInfo:e,poolKeys:p,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccount:u},rewardMint:n});return d.addInstruction(b),d.addCustomComputeBudget(r),d.addTipInstruction(s),d.versionBuild({txVersion:a,extInfo:{address:b.address}})}async collectRewards({poolInfo:e,ownerInfo:t,rewardMints:n,associatedOnly:i=!0,checkCreateATAOwner:o=!1,computeBudgetConfig:r,txTipConfig:s,feePayer:a}){let c=this.createTxBuilder(a),l={};for(let d of n){let f=e.rewardDefaultInfos.find(P=>P.mint.address===d.toString());if(!f){this.logAndCreateError("reward mint error","not found reward mint",d);continue}let u=t.useSOLBalance&&d.equals(Q),{account:m,instructionParams:p}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:new L(f.mint.programId),mint:d,notUseTokenAccount:u,owner:this.scope.ownerPubKey,skipCloseAccount:!u,createInfo:{payer:t.feePayer||this.scope.ownerPubKey,amount:0},associatedOnly:u?!1:i,checkCreateATAOwner:o});m||this.logAndCreateError("no money","ownerRewardAccount",this.scope.account.tokenAccountRawInfos),p&&c.addInstruction(p);let b=await this.getClmmPoolKeys(e.id),g=oe.collectRewardInstructions({poolInfo:e,poolKeys:b,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccount:m},rewardMint:d});c.addInstruction(g),l=O(O({},l),g.address)}return c.addCustomComputeBudget(r),c.addTipInstruction(s),c.build({address:l})}async swap({poolInfo:e,poolKeys:t,inputMint:n,amountIn:i,amountOutMin:o,priceLimit:r,observationId:s,ownerInfo:a,remainingAccounts:c,associatedOnly:l=!0,checkCreateATAOwner:d=!1,txVersion:f,computeBudgetConfig:u,txTipConfig:m,feePayer:p}){let b=this.createTxBuilder(p),g=n.toString()===e.mintA.address,P=a.useSOLBalance&&e.mintA.address===Q.toBase58(),A=a.useSOLBalance&&e.mintB.address===Q.toBase58(),T;!r||r.equals(new ut(0))?T=g?ve.add(new Ke(1)):Ve.sub(new Ke(1)):T=_.priceToSqrtPriceX64(r,e.mintA.decimals,e.mintB.decimals);let k;if(!k){let{account:x,instructionParams:B}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:e.mintA.programId,mint:new L(e.mintA.address),notUseTokenAccount:P,owner:this.scope.ownerPubKey,skipCloseAccount:!P,createInfo:P||!g?{payer:a.feePayer||this.scope.ownerPubKey,amount:g?i:0}:void 0,associatedOnly:P?!1:l,checkCreateATAOwner:d});k=x,B&&b.addInstruction(B)}let w;if(!w){let{account:x,instructionParams:B}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:e.mintB.programId,mint:new L(e.mintB.address),notUseTokenAccount:A,owner:this.scope.ownerPubKey,skipCloseAccount:!A,createInfo:A||g?{payer:a.feePayer||this.scope.ownerPubKey,amount:g?0:i}:void 0,associatedOnly:A?!1:l,checkCreateATAOwner:d});w=x,B&&b.addInstruction(B)}(!k||!w)&&this.logAndCreateError("user do not have token account",{tokenA:e.mintA.symbol||e.mintA.address,tokenB:e.mintB.symbol||e.mintB.address,ownerTokenAccountA:k,ownerTokenAccountB:w,mintAUseSOLBalance:P,mintBUseSOLBalance:A,associatedOnly:l});let h=t!=null?t:await this.getClmmPoolKeys(e.id);return b.addInstruction(oe.makeSwapBaseInInstructions({poolInfo:e,poolKeys:h,observationId:s,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccountA:k,tokenAccountB:w},inputMint:new L(n),amountIn:i,amountOutMin:o,sqrtPriceLimitX64:T,remainingAccounts:c})),b.addCustomComputeBudget(u),b.addTipInstruction(m),b.versionBuild({txVersion:f})}async swapBaseOut({poolInfo:e,poolKeys:t,outputMint:n,amountOut:i,amountInMax:o,priceLimit:r,observationId:s,ownerInfo:a,remainingAccounts:c,associatedOnly:l=!0,checkCreateATAOwner:d=!1,txVersion:f,computeBudgetConfig:u,txTipConfig:m,feePayer:p}){let b=this.createTxBuilder(p),g=n.toString()===e.mintB.address,P=a.useSOLBalance&&e.mintA.address===Q.toBase58(),A=a.useSOLBalance&&e.mintB.address===Q.toBase58(),T;!r||r.equals(new ut(0))?T=n.toString()===e.mintB.address?ve.add(new Ke(1)):Ve.sub(new Ke(1)):T=_.priceToSqrtPriceX64(r,e.mintA.decimals,e.mintB.decimals);let k;if(!k){let{account:x,instructionParams:B}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:e.mintA.programId,mint:new L(e.mintA.address),notUseTokenAccount:P,owner:this.scope.ownerPubKey,skipCloseAccount:!P,createInfo:P||!g?{payer:a.feePayer||this.scope.ownerPubKey,amount:g?o:0}:void 0,associatedOnly:P?!1:l,checkCreateATAOwner:d});k=x,B&&b.addInstruction(B)}let w;if(!w){let{account:x,instructionParams:B}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:e.mintB.programId,mint:new L(e.mintB.address),notUseTokenAccount:A,owner:this.scope.ownerPubKey,skipCloseAccount:!A,createInfo:A||g?{payer:a.feePayer||this.scope.ownerPubKey,amount:g?0:o}:void 0,associatedOnly:A?!1:l,checkCreateATAOwner:d});w=x,B&&b.addInstruction(B)}(!k||!w)&&this.logAndCreateError("user do not have token account",{tokenA:e.mintA.symbol||e.mintA.address,tokenB:e.mintB.symbol||e.mintB.address,ownerTokenAccountA:k,ownerTokenAccountB:w,mintAUseSOLBalance:P,mintBUseSOLBalance:A,associatedOnly:l});let h=t!=null?t:await this.getClmmPoolKeys(e.id);return b.addInstruction(oe.makeSwapBaseOutInstructions({poolInfo:e,poolKeys:h,observationId:s,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccountA:k,tokenAccountB:w},outputMint:new L(n),amountOut:i,amountInMax:o,sqrtPriceLimitX64:T,remainingAccounts:c})),b.addCustomComputeBudget(u),b.addTipInstruction(m),b.versionBuild({txVersion:f})}async harvestAllRewards({allPoolInfo:e,allPositions:t,lockInfo:n,ownerInfo:i,associatedOnly:o=!0,checkCreateATAOwner:r=!1,programId:s,txVersion:a,computeBudgetConfig:c,feePayer:l,lockProgram:d=Ct,lockAuth:f=Jt,clmmProgram:u=St}){var A,T;let m={};for(let k of this.scope.account.tokenAccountRawInfos)o?ne(this.scope.ownerPubKey,k.accountInfo.mint,s).publicKey.equals(k.pubkey)&&(m[k.accountInfo.mint.toString()]=k.pubkey):m[k.accountInfo.mint.toString()]=k.pubkey;let p=Object.values(t).flat().map(k=>k.nftMint),b=await ze(this.scope.connection,p.map(k=>({pubkey:k}))),g={};b.forEach(k=>{var w,h;g[k.pubkey.toBase58()]=(h=(w=k==null?void 0:k.accountInfo)==null?void 0:w.owner)!=null?h:null});let P=this.createTxBuilder(l);for(let k of Object.values(e)){if(t[k.id]===void 0||!t[k.id].find(S=>!S.liquidity.isZero()||S.rewardInfos.find(D=>!D.rewardAmountOwed.isZero())))continue;let w=k,h=i.useSOLBalance&&w.mintA.address===Q.toString(),x=i.useSOLBalance&&w.mintB.address===Q.toString(),B=m[w.mintA.address];if(!B)if(h){let{account:S,instructionParams:D}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:w.mintA.programId,mint:new L(w.mintA.address),notUseTokenAccount:h,owner:this.scope.ownerPubKey,skipCloseAccount:!h,createInfo:{payer:i.feePayer||this.scope.ownerPubKey,amount:0},associatedOnly:h?!1:o,checkCreateATAOwner:r});B=S,D&&P.addInstruction(D)}else{let S=new L(w.mintA.address);B=this.scope.account.getAssociatedTokenAccount(S,new L(w.mintA.programId)),P.addInstruction({instructions:[Vi(this.scope.ownerPubKey,B,this.scope.ownerPubKey,S,new L(w.mintA.programId))]})}let C=m[w.mintB.address];if(!C)if(x){let{account:S,instructionParams:D}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:w.mintB.programId,mint:new L(w.mintB.address),notUseTokenAccount:x,owner:this.scope.ownerPubKey,skipCloseAccount:!x,createInfo:{payer:i.feePayer||this.scope.ownerPubKey,amount:0},associatedOnly:x?!1:o,checkCreateATAOwner:r});C=S,D&&P.addInstruction(D)}else{let S=new L(w.mintB.address);C=this.scope.account.getAssociatedTokenAccount(S,new L(w.mintB.programId)),P.addInstruction({instructions:[Vi(this.scope.ownerPubKey,C,this.scope.ownerPubKey,S,new L(w.mintB.programId))]})}m[w.mintA.address]=B,m[w.mintB.address]=C;let R=[];for(let S of w.rewardDefaultInfos){let D=i.useSOLBalance&&S.mint.address===Q.toString(),U=m[S.mint.address];if(!U){let{account:be,instructionParams:Te}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:new L(S.mint.programId),mint:new L(S.mint.address),notUseTokenAccount:D,owner:this.scope.ownerPubKey,skipCloseAccount:!D,createInfo:{payer:i.feePayer||this.scope.ownerPubKey,amount:0},associatedOnly:D?!1:o});U=be,Te&&P.addInstruction(Te)}m[S.mint.address]=U,R.push(U)}let K=await this.getClmmPoolKeys(w.id),M=[];for(let S=0;S<K.rewardInfos.length;S++)M.push({poolRewardVault:new L(K.rewardInfos[S].vault),ownerRewardVault:R[S],rewardMint:new L(K.rewardInfos[S].mint.address)});for(let S of t[k.id]){let D=(A=n==null?void 0:n[k.id])==null?void 0:A[S.nftMint.toBase58()];if(D){let U=ne(this.scope.ownerPubKey,D.lockNftMint,Gt).publicKey,be=N.getTickArrayStartIndexByTick(S.tickLower,K.config.tickSpacing),Te=N.getTickArrayStartIndexByTick(S.tickUpper,K.config.tickSpacing),{publicKey:Ue}=z(new L(K.programId),D.poolId,be),{publicKey:lt}=z(new L(K.programId),D.poolId,Te),{publicKey:pe}=De(new L(K.programId),D.poolId,S.tickLower,S.tickUpper),Be=wt(d,D.lockNftMint).publicKey,Ye=oe.harvestLockPositionInstructionV2({programId:d,auth:f,lockPositionId:Be,clmmProgram:u,lockOwner:this.scope.ownerPubKey,lockNftMint:D.lockNftMint,lockNftAccount:U,positionNftAccount:D.nftAccount,positionId:D.positionId,poolId:D.poolId,protocolPosition:pe,vaultA:new L(K.vault.A),vaultB:new L(K.vault.B),tickArrayLower:Ue,tickArrayUpper:lt,userVaultA:B,userVaultB:C,mintA:new L(K.mintA.address),mintB:new L(K.mintB.address),rewardAccounts:M,exTickArrayBitmap:fe(u,D.poolId).publicKey});P.addInstruction({instructions:[Ye],instructionTypes:[te.ClmmHarvestLockPosition],lookupTableAddress:K.lookupTableAccount?[K.lookupTableAccount]:[]})}else{let U=oe.decreaseLiquidityInstructions({poolInfo:w,poolKeys:K,ownerPosition:S,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccountA:B,tokenAccountB:C,rewardAccounts:R},liquidity:new Ke(0),amountMinA:new Ke(0),amountMinB:new Ke(0),nft2022:(T=g[S.nftMint.toBase58()])==null?void 0:T.equals(nt)});P.addInstruction(U)}}}return a===0?P.sizeCheckBuildV0({computeBudgetConfig:c}):P.sizeCheckBuild({computeBudgetConfig:c})}async getWhiteListMint({programId:e}){let t=await this.scope.connection.getAccountInfo(_t(e).publicKey);return t?Fi.decode(t.data).whitelistMints.filter(i=>!i.equals(L.default)):[]}async getOwnerPositionInfo({programId:e=St}){await this.scope.account.fetchWalletTokenAccounts();let n=this.scope.account.tokenAccountRawInfos.filter(r=>r.accountInfo.amount.eq(new Ke(1))).map(r=>Ce(new L(e),r.accountInfo.mint).publicKey),i=await this.scope.connection.getMultipleAccountsInfo(n),o=[];return i.forEach(r=>{if(!r)return;let s=Pt.decode(r.data);o.push(s)}),o}async getOwnerLockedPositionInfo({programId:e=Ct}){await this.scope.account.fetchWalletTokenAccounts();let n=this.scope.account.tokenAccountRawInfos.filter(a=>a.accountInfo.amount.eq(new Ke(1))).map(a=>wt(new L(e),a.accountInfo.mint).publicKey),i=await this.scope.connection.getMultipleAccountsInfo(n),o=[];i.forEach(a=>{if(!a)return;let c=Ei.decode(a.data);o.push(c)});let r=await this.scope.connection.getMultipleAccountsInfo(o.map(a=>a.positionId)),s=[];return r.forEach(a=>{if(!a)return;let c=Pt.decode(a.data);s.push(c)}),o.map((a,c)=>({position:s[c],lockInfo:a}))}async getRpcClmmPoolInfo({poolId:e}){return(await this.getRpcClmmPoolInfos({poolIds:[e]}))[String(e)]}async getRpcClmmPoolInfos({poolIds:e,config:t}){let n=await ze(this.scope.connection,e.map(o=>({pubkey:new L(o)})),t),i={};for(let o=0;o<e.length;o++){let r=n[o];if(r===null||!r.accountInfo)throw Error("fetch pool info error: "+String(e[o]));let s=cn.decode(r.accountInfo.data),a=_.sqrtPriceX64ToPrice(s.sqrtPriceX64,s.mintDecimalsA,s.mintDecimalsB).toNumber();i[String(e[o])]=G(O({},s),{currentPrice:a,programId:r.accountInfo.owner})}return i}async getComputeClmmPoolInfos({clmmPoolsRpcInfo:e,mintInfos:t}){let n=new Set(Object.keys(e).map(a=>e[a].ammConfig.toBase58())),i=await ze(this.scope.connection,Array.from(n).map(a=>({pubkey:new L(a)}))),o={};i.forEach(a=>{!a.accountInfo||(o[a.pubkey.toBase58()]=Mi.decode(a.accountInfo.data))});let r=await ue.fetchComputeMultipleClmmInfo({connection:this.scope.connection,rpcDataMap:e,poolList:Object.keys(e).map(a=>{var d,f,u,m;let[c,l]=[e[a].mintA.toBase58(),e[a].mintB.toBase58()];return{id:a,programId:e[a].programId.toBase58(),mintA:nn({address:c,decimals:e[a].mintDecimalsA,programId:t[c].programId.toBase58()||Gt.toBase58(),extensions:{feeConfig:(d=t[c])!=null&&d.feeConfig?Cn((f=t[c])==null?void 0:f.feeConfig):void 0}}),mintB:nn({address:l,decimals:e[a].mintDecimalsB,programId:t[l].programId.toBase58()||Gt.toBase58(),extensions:{feeConfig:(u=t[l])!=null&&u.feeConfig?Cn((m=t[l])==null?void 0:m.feeConfig):void 0}}),price:e[a].currentPrice,config:G(O({},o[e[a].ammConfig.toBase58()]),{id:e[a].ammConfig.toBase58(),fundFeeRate:0,description:"",defaultRange:0,defaultRangePoint:[]})}})}),s=await ue.fetchMultiplePoolTickArrays({connection:this.scope.connection,poolKeys:Object.values(r)});return{computeClmmPoolInfo:r,computePoolTickData:s}}async getPoolInfoFromRpc(e){var l;let t=await this.getRpcClmmPoolInfo({poolId:e}),n=new Set([t.mintA.toBase58(),t.mintB.toBase58()]),i=await Yn({connection:this.scope.connection,mints:Array.from(n).map(d=>new L(d))}),{computeClmmPoolInfo:o,computePoolTickData:r}=await this.scope.clmm.getComputeClmmPoolInfos({clmmPoolsRpcInfo:{[e]:t},mintInfos:i}),s=await ze(this.scope.connection,[{pubkey:t.vaultA},{pubkey:t.vaultB}]),a=Ri(o[e]);if(!s[0].accountInfo||!s[1].accountInfo)throw new Error("pool vault data not found");a.mintAmountA=Number(vi.decode(s[0].accountInfo.data).amount.toString()),a.mintAmountB=Number(vi.decode((l=s[1].accountInfo)==null?void 0:l.data).amount.toString());let c=G(O({},o[e]),{exBitmapAccount:o[e].exBitmapAccount.toBase58(),observationId:o[e].observationId.toBase58(),id:e,programId:t.programId.toBase58(),openTime:t.startTime.toString(),vault:{A:t.vaultA.toBase58(),B:t.vaultB.toBase58()},config:a.config,rewardInfos:o[e].rewardInfos.filter(d=>!d.tokenVault.equals(L.default)).map(d=>({mint:nn({address:d.tokenMint.toBase58(),programId:Gt.toBase58(),decimals:10}),vault:d.tokenVault.toBase58()}))});return{poolInfo:a,poolKeys:c,computePoolInfo:o[e],tickData:r}}};export{qi as Clmm};
//# sourceMappingURL=clmm.mjs.map