var Xi=Object.defineProperty,Hi=Object.defineProperties;var zi=Object.getOwnPropertyDescriptors;var Qt=Object.getOwnPropertySymbols;var zn=Object.prototype.hasOwnProperty,jn=Object.prototype.propertyIsEnumerable;var Hn=(g,e,t)=>e in g?Xi(g,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):g[e]=t,O=(g,e)=>{for(var t in e||(e={}))zn.call(e,t)&&Hn(g,t,e[t]);if(Qt)for(var t of Qt(e))jn.call(e,t)&&Hn(g,t,e[t]);return g},U=(g,e)=>Hi(g,zi(e));var ut=(g,e)=>{var t={};for(var n in g)zn.call(g,n)&&e.indexOf(n)<0&&(t[n]=g[n]);if(g!=null&&Qt)for(var n of Qt(g))e.indexOf(n)<0&&jn.call(g,n)&&(t[n]=g[n]);return t};import{PublicKey as R}from"@solana/web3.js";import Ke from"bn.js";import gt from"decimal.js";import{PublicKey as Yn}from"@solana/web3.js";import{get as Zn,set as ji}from"lodash";var pn=class{constructor(e){this.logLevel=e.logLevel!==void 0?e.logLevel:0,this.name=e.name}set level(e){this.logLevel=e}get time(){return Date.now().toString()}get moduleName(){return this.name}isLogLevel(e){return e<=this.logLevel}error(...e){return this.isLogLevel(0)?(console.error(this.time,this.name,"sdk logger error",...e),this):this}logWithError(...e){let t=e.map(n=>typeof n=="object"?JSON.stringify(n):n).join(", ");throw new Error(t)}warning(...e){return this.isLogLevel(1)?(console.warn(this.time,this.name,"sdk logger warning",...e),this):this}info(...e){return this.isLogLevel(2)?(console.info(this.time,this.name,"sdk logger info",...e),this):this}debug(...e){return this.isLogLevel(3)?(console.debug(this.time,this.name,"sdk logger debug",...e),this):this}},Qn={},Zi={};function Te(g){let e=Zn(Qn,g);if(!e){let t=Zn(Zi,g);e=new pn({name:g,logLevel:t}),ji(Qn,g,e)}return e}import{MINT_SIZE as Qi,TOKEN_PROGRAM_ID as Yi,getTransferFeeConfig as Ji,unpackMint as $i}from"@solana/spl-token";var fn=Te("Raydium_accountInfo_util");async function je(g,e,t){let{batchRequest:n,commitment:i="confirmed",chunkCount:s=100}=O({batchRequest:!1},t),r=yn(e,s),o=new Array(r.length).fill([]);if(n){let a=r.map(d=>{let f=g._buildArgs([d.map(u=>u.toBase58())],i,"base64");return{methodName:"getMultipleAccounts",args:f}}),c=yn(a,10);o=(await(await Promise.all(c.map(async d=>await g._rpcBatchRequest(d)))).flat()).map(d=>(d.error&&fn.logWithError(`failed to get info for multiple accounts, RPC_ERROR, ${d.error.message}`),d.result.value.map(f=>{if(f){let{data:u,executable:m,lamports:p,owner:y,rentEpoch:b}=f;return u.length!==2&&u[1]!=="base64"&&fn.logWithError("info must be base64 encoded, RPC_ERROR"),{data:Buffer.from(u[0],"base64"),executable:m,lamports:p,owner:new Yn(y),rentEpoch:b}}return null})))}else try{o=await Promise.all(r.map(a=>g.getMultipleAccountsInfo(a,i)))}catch(a){a instanceof Error&&fn.logWithError(`failed to get info for multiple accounts, RPC_ERROR, ${a.message}`)}return o.flat()}async function Ze(g,e,t){let n=await je(g,e.map(i=>i.pubkey),t);return e.map((i,s)=>U(O({},i),{accountInfo:n[s]}))}async function Jn({connection:g,mints:e,config:t}){var s,r,o;if(e.length===0)return{};let n=await Ze(g,e.map(a=>({pubkey:lt(a)})),t),i={};for(let a of n){if(!a.accountInfo||a.accountInfo.data.length<Qi){console.log("invalid mint account",a.pubkey.toBase58());continue}let c=$i(a.pubkey,a.accountInfo,(s=a.accountInfo)==null?void 0:s.owner);i[a.pubkey.toString()]=U(O({},c),{programId:((r=a.accountInfo)==null?void 0:r.owner)||Yi,feeConfig:(o=Ji(c))!=null?o:void 0})}return i[Yn.default.toBase58()]=i[Q.toBase58()],i}import Qe from"bn.js";import Xs from"decimal.js";import ar from"big.js";import $t from"bn.js";import er from"toformat";var tr=er,Bt=tr;import Jt from"big.js";import ir from"bn.js";import rr from"decimal.js-light";import It from"bn.js";var $n=9007199254740991;function Pe(g){let e=Te("Raydium_parseBigNumberish");if(g instanceof It)return g;if(typeof g=="string"){if(g.match(/^-?[0-9]+$/))return new It(g);e.logWithError(`invalid BigNumberish string: ${g}`)}return typeof g=="number"?(g%1&&e.logWithError(`BigNumberish number underflow: ${g}`),(g>=$n||g<=-$n)&&e.logWithError(`BigNumberish number overflow: ${g}`),new It(String(g))):typeof g=="bigint"?new It(g.toString()):(e.error(`invalid BigNumberish value: ${g}`),new It(0))}var Yt=Te("module/fraction"),bn=Bt(Jt),St=Bt(rr),or={[0]:St.ROUND_DOWN,[1]:St.ROUND_HALF_UP,[2]:St.ROUND_UP},sr={[0]:Jt.roundDown,[1]:Jt.roundHalfUp,[2]:Jt.roundUp},Y=class{constructor(e,t=new ir(1)){this.numerator=Pe(e),this.denominator=Pe(t)}get quotient(){return this.numerator.div(this.denominator)}invert(){return new Y(this.denominator,this.numerator)}add(e){let t=e instanceof Y?e:new Y(Pe(e));return this.denominator.eq(t.denominator)?new Y(this.numerator.add(t.numerator),this.denominator):new Y(this.numerator.mul(t.denominator).add(t.numerator.mul(this.denominator)),this.denominator.mul(t.denominator))}sub(e){let t=e instanceof Y?e:new Y(Pe(e));return this.denominator.eq(t.denominator)?new Y(this.numerator.sub(t.numerator),this.denominator):new Y(this.numerator.mul(t.denominator).sub(t.numerator.mul(this.denominator)),this.denominator.mul(t.denominator))}mul(e){let t=e instanceof Y?e:new Y(Pe(e));return new Y(this.numerator.mul(t.numerator),this.denominator.mul(t.denominator))}div(e){let t=e instanceof Y?e:new Y(Pe(e));return new Y(this.numerator.mul(t.denominator),this.denominator.mul(t.numerator))}toSignificant(e,t={groupSeparator:""},n=1){Number.isInteger(e)||Yt.logWithError(`${e} is not an integer.`),e<=0&&Yt.logWithError(`${e} is not positive.`),St.set({precision:e+1,rounding:or[n]});let i=new St(this.numerator.toString()).div(this.denominator.toString()).toSignificantDigits(e);return i.toFormat(i.decimalPlaces(),t)}toFixed(e,t={groupSeparator:""},n=1){return Number.isInteger(e)||Yt.logWithError(`${e} is not an integer.`),e<0&&Yt.logWithError(`${e} is negative.`),bn.DP=e,bn.RM=sr[n]||1,new bn(this.numerator.toString()).div(this.denominator.toString()).toFormat(e,t)}isZero(){return this.numerator.isZero()}};var cr=Te("Raydium_amount"),ei=Bt(ar);function ur(g,e){let t="0",n="0";if(g.includes(".")){let i=g.split(".");i.length===2?([t,n]=i,n=n.padEnd(e,"0")):cr.logWithError(`invalid number string, num: ${g}`)}else t=g;return[t,n.slice(0,e)||n]}var Ae=class extends Y{constructor(t,n,i=!0,s){let r=new $t(0),o=gn.pow(new $t(t.decimals));if(i)r=Pe(n);else{let a=new $t(0),c=new $t(0);if(typeof n=="string"||typeof n=="number"||typeof n=="bigint"){let[l,d]=ur(n.toString(),t.decimals);a=Pe(l),c=Pe(d)}a=a.mul(o),r=a.add(c)}super(r,o);this.logger=Te(s||"TokenAmount"),this.token=t}get raw(){return this.numerator}isZero(){return this.raw.isZero()}gt(t){return this.token.equals(t.token)||this.logger.logWithError("gt token not equals"),this.raw.gt(t.raw)}lt(t){return this.token.equals(t.token)||this.logger.logWithError("lt token not equals"),this.raw.lt(t.raw)}add(t){return this.token.equals(t.token)||this.logger.logWithError("add token not equals"),new Ae(this.token,this.raw.add(t.raw))}subtract(t){return this.token.equals(t.token)||this.logger.logWithError("sub token not equals"),new Ae(this.token,this.raw.sub(t.raw))}toSignificant(t=this.token.decimals,n,i=0){return super.toSignificant(t,n,i)}toFixed(t=this.token.decimals,n,i=0){return t>this.token.decimals&&this.logger.logWithError("decimals overflow"),super.toFixed(t,n,i)}toExact(t={groupSeparator:""}){return ei.DP=this.token.decimals,new ei(this.numerator.toString()).div(this.denominator.toString()).toFormat(t)}};import{PublicKey as lr}from"@solana/web3.js";import{TOKEN_PROGRAM_ID as ti}from"@solana/spl-token";var wn={chainId:101,address:lr.default.toBase58(),programId:ti.toBase58(),decimals:9,symbol:"SOL",name:"solana",logoURI:"https://img-v1.raydium.io/icon/So11111111111111111111111111111111111111112.png",tags:[],priority:2,type:"raydium",extensions:{coingeckoId:"solana"}},it={chainId:101,address:"So11111111111111111111111111111111111111112",programId:ti.toBase58(),decimals:9,symbol:"WSOL",name:"Wrapped SOL",logoURI:"https://img-v1.raydium.io/icon/So11111111111111111111111111111111111111112.png",tags:[],priority:2,type:"raydium",extensions:{coingeckoId:"solana"}};import{PublicKey as An}from"@solana/web3.js";import{PublicKey as ue,SystemProgram as ni,SYSVAR_RENT_PUBKEY as mr}from"@solana/web3.js";import{TOKEN_PROGRAM_ID as dr}from"@solana/spl-token";function Pn({pubkey:g,isSigner:e=!1,isWritable:t=!0}){return{pubkey:g,isWritable:t,isSigner:e}}var qo=[Pn({pubkey:dr,isWritable:!1}),Pn({pubkey:ni.programId,isWritable:!1}),Pn({pubkey:mr,isWritable:!1})];function kn({publicKey:g,transformSol:e}){let t=ii(g.toString());if(t instanceof ue)return e&&t.equals(Ct)?Q:t;if(e&&t.toString()===Ct.toBase58())return Q;if(typeof t=="string"){if(t===ue.default.toBase58())return ue.default;try{return new ue(t)}catch{throw new Error("invalid public key")}}throw new Error("invalid public key")}function ii(g){try{return new ue(g)}catch{return g}}var en=new ue("MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr"),Tn=new ue("MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr"),rt=new ue("SysvarRent111111111111111111111111111111111"),Go=new ue("SysvarC1ock11111111111111111111111111111111"),mt=new ue("metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s"),Uo=new ue("Sysvar1nstructions1111111111111111111111111"),Xo=ni.programId,Ho=new ue("4k3Dyjzvzp8eMZWUXbBCjEvwSkkk59S5iCNLY3QrkX6R"),zo=new ue("Ea5SjE2Y6yvCeW5dYTn7PYMuW5ikXkvbGdcmSnXeaLjS"),jo=new ue("SRMuApVNdxXokk5GT7XD5cUUgXMBCoAz2LHeuAoKWRt"),Zo=new ue("EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v"),Qo=new ue("Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB"),Yo=new ue("mSoLzYCxHdYgdzU16g5QSh3i5K3z3KZK7ytfqcJm7So"),Jo=new ue("7dHbWXmci3dT8UFYWYZweBLXgycu7Y3iL6trKn1Y7ARj"),$o=new ue("USDH1SM1ojwWUga67PGrgFWUHibbjqMvuMaDkRJTgkX"),es=new ue("NRVwhjBQiUPYtfDT5zRBVJajzFQHaBUNtC7SNVvqRFa"),ts=new ue("ANAxByE6G2WjFp7A4NqtWYXb3mgruyzZYg3spfxe6Lbo"),ns=new ue("7vfCXTUXx5WJV5JADk17DUJ4ksgau7utNKj4b963voxs"),Q=new ue("So11111111111111111111111111111111111111112"),Ct=ue.default;function lt(g){return kn({publicKey:g,transformSol:!0})}var hn=class{constructor({mint:e,decimals:t,symbol:n,name:i,skipMint:s=!1,isToken2022:r=!1}){if(e===Ct.toBase58()||e instanceof An&&Ct.equals(e)){this.decimals=it.decimals,this.symbol=it.symbol,this.name=it.name,this.mint=new An(it.address),this.isToken2022=!1;return}this.decimals=t,this.symbol=n||e.toString().substring(0,6),this.name=i||e.toString().substring(0,6),this.mint=s?An.default:kn({publicKey:e}),this.isToken2022=r}equals(e){return this===e?!0:this.mint.equals(e.mint)}},ve=hn;ve.WSOL=new hn(U(O({},it),{mint:it.address}));var xn=class{constructor({decimals:e,symbol:t="UNKNOWN",name:n="UNKNOWN"}){this.decimals=e,this.symbol=t,this.name=n}equals(e){return this===e}},tn=xn;tn.SOL=new xn(wn);import pr from"bn.js";var ri=new Y(new pr(100)),ot=class extends Y{toSignificant(e=5,t,n){return this.mul(ri).toSignificant(e,t,n)}toFixed(e=2,t,n){return this.mul(ri).toFixed(e,t,n)}};var fr=Te("Raydium_price"),Ee=class extends Y{constructor(t){let{baseToken:n,quoteToken:i,numerator:s,denominator:r}=t;super(s,r);this.baseToken=n,this.quoteToken=i,this.scalar=new Y(Bn(n.decimals),Bn(i.decimals))}get raw(){return new Y(this.numerator,this.denominator)}get adjusted(){return super.mul(this.scalar)}invert(){return new Ee({baseToken:this.quoteToken,quoteToken:this.baseToken,denominator:this.numerator,numerator:this.denominator})}mul(t){this.quoteToken!==t.baseToken&&fr.logWithError("mul token not equals");let n=super.mul(t);return new Ee({baseToken:this.baseToken,quoteToken:t.quoteToken,denominator:n.denominator,numerator:n.numerator})}toSignificant(t=this.quoteToken.decimals,n,i){return this.adjusted.toSignificant(t,n,i)}toFixed(t=this.quoteToken.decimals,n,i){return this.adjusted.toFixed(t,n,i)}};import{PublicKey as Os}from"@solana/web3.js";import Es from"bn.js";var yr=new Qe(0),ta=new Qe(1),na=new Qe(2),ia=new Qe(3),ra=new Qe(5),gn=new Qe(10),oa=new Qe(100),sa=new Qe(1e3),aa=new Qe(1e4);function Bn(g){return gn.pow(Pe(g))}function yn(g,e=1,t=[]){let n=[...g];if(e<=0)return t;for(;n.length;)t.push(n.splice(0,e));return t}var Ve=class{constructor(e){this._owner=e}get publicKey(){return Ve.isKeyPair(this._owner)?this._owner.publicKey:this._owner}get signer(){return Ve.isKeyPair(this._owner)?this._owner:void 0}get isKeyPair(){return Ve.isKeyPair(this._owner)}get isPublicKey(){return Ve.isPublicKey(this._owner)}static isKeyPair(e){return e.secretKey!==void 0}static isPublicKey(e){return!Ve.isKeyPair(e)}};import{PublicKey as Ar}from"@solana/web3.js";import{TOKEN_PROGRAM_ID as hr}from"@solana/spl-token";import{ComputeBudgetProgram as oi,Keypair as ai,PublicKey as br,Transaction as ci,TransactionMessage as gr,VersionedTransaction as ui}from"@solana/web3.js";var ie={CreateAccount:"CreateAccount",InitAccount:"InitAccount",CreateATA:"CreateATA",CloseAccount:"CloseAccount",TransferAmount:"TransferAmount",InitMint:"InitMint",MintTo:"MintTo",InitMarket:"InitMarket",Util1216OwnerClaim:"Util1216OwnerClaim",SetComputeUnitPrice:"SetComputeUnitPrice",SetComputeUnitLimit:"SetComputeUnitLimit",ClmmCreatePool:"ClmmCreatePool",ClmmOpenPosition:"ClmmOpenPosition",ClmmIncreasePosition:"ClmmIncreasePosition",ClmmDecreasePosition:"ClmmDecreasePosition",ClmmClosePosition:"ClmmClosePosition",ClmmSwapBaseIn:"ClmmSwapBaseIn",ClmmSwapBaseOut:"ClmmSwapBaseOut",ClmmInitReward:"ClmmInitReward",ClmmSetReward:"ClmmSetReward",ClmmCollectReward:"ClmmCollectReward",ClmmLockPosition:"ClmmLockPosition",ClmmHarvestLockPosition:"ClmmHarvestLockPosition",AmmV4Swap:"AmmV4Swap",AmmV4AddLiquidity:"AmmV4AddLiquidity",AmmV4RemoveLiquidity:"AmmV4RemoveLiquidity",AmmV4SimulatePoolInfo:"AmmV4SimulatePoolInfo",AmmV4SwapBaseIn:"AmmV4SwapBaseIn",AmmV4SwapBaseOut:"AmmV4SwapBaseOut",AmmV4CreatePool:"AmmV4CreatePool",AmmV4InitPool:"AmmV4InitPool",AmmV5AddLiquidity:"AmmV5AddLiquidity",AmmV5RemoveLiquidity:"AmmV5RemoveLiquidity",AmmV5SimulatePoolInfo:"AmmV5SimulatePoolInfo",AmmV5SwapBaseIn:"AmmV5SwapBaseIn",AmmV5SwapBaseOut:"AmmV5SwapBaseOut",RouteSwap:"RouteSwap",RouteSwap1:"RouteSwap1",RouteSwap2:"RouteSwap2",FarmV3Deposit:"FarmV3Deposit",FarmV3Withdraw:"FarmV3Withdraw",FarmV3CreateLedger:"FarmV3CreateLedger",FarmV4Withdraw:"FarmV4Withdraw",FarmV5Deposit:"FarmV5Deposit",FarmV5Withdraw:"FarmV5Withdraw",FarmV5CreateLedger:"FarmV5CreateLedger",FarmV6Deposit:"FarmV6Deposit",FarmV6Withdraw:"FarmV6Withdraw",FarmV6Create:"FarmV6Create",FarmV6Restart:"FarmV6Restart",FarmV6CreatorAddReward:"FarmV6CreatorAddReward",FarmV6CreatorWithdraw:"FarmV6CreatorWithdraw",CpmmCreatePool:"CpmmCreatePool",CpmmAddLiquidity:"CpmmAddLiquidity",CpmmWithdrawLiquidity:"CpmmWithdrawLiquidity",CpmmSwapBaseIn:"CpmmSwapBaseIn",CpmmSwapBaseOut:"CpmmSwapBaseOut",CpmmLockLp:"CpmmLockLp",CpmmCollectLockFee:"CpmmCollectLockFee",TransferTip:"TransferTip"};import{TOKEN_PROGRAM_ID as wr}from"@solana/spl-token";var si=Te("Raydium_txUtil"),li=1644;function Kt(g){let e=[],t=[];return g.microLamports&&(e.push(oi.setComputeUnitPrice({microLamports:g.microLamports})),t.push(ie.SetComputeUnitPrice)),g.units&&(e.push(oi.setComputeUnitLimit({units:g.units})),t.push(ie.SetComputeUnitLimit)),{instructions:e,instructionTypes:t}}async function dt(g,e){var n,i;let t=e!=null?e:"confirmed";return(i=await((n=g.getLatestBlockhash)==null?void 0:n.call(g,{commitment:t})))==null?void 0:i.blockhash}async function Lt(g,e){return g.getSignatureStatuses([e]),new Promise((t,n)=>{let i=setTimeout(n,6e4);g.onSignature(e,s=>{if(clearTimeout(i),!s.err){t("");return}n(Object.assign(s.err,{txId:e}))},"confirmed")})}function Pr(g,e){g.length<1&&si.logWithError(`no instructions provided: ${g.toString()}`),e.length<1&&si.logWithError(`no signers provided:, ${e.toString()}`);let t=new ci;t.recentBlockhash="11111111111111111111111111111111",t.feePayer=e[0],t.add(...g);try{return Buffer.from(t.serialize({verifySignatures:!1})).toString("base64").length<li}catch{return!1}}function xe(g,e){let[t,n]=br.findProgramAddressSync(g,e);return{publicKey:t,nonce:n}}function Rt({instructions:g,payer:e,signers:t}){return Pr(g,[e,...t])}function Ye({instructions:g,payer:e,lookupTableAddressAccount:t,recentBlockhash:n=ai.generate().publicKey.toString()}){let s=new gr({payerKey:e,recentBlockhash:n,instructions:g}).compileToV0Message(Object.values(t!=null?t:{}));try{return Buffer.from(new ui(s).serialize()).toString("base64").length<li}catch{return!1}}var kr=g=>Buffer.isBuffer(g)?g:g instanceof Uint8Array?Buffer.from(g.buffer,g.byteOffset,g.byteLength):Buffer.from(g),Tr=g=>{let e=g.serialize({requireAllSignatures:!1,verifySignatures:!1});g instanceof ui&&(e=kr(e));try{return e instanceof Buffer?e.toString("base64"):Buffer.from(e).toString("base64")}catch{return e.toString("base64")}};function st(g){let e=[];return g.forEach(t=>{t instanceof ci&&(t.recentBlockhash||(t.recentBlockhash=wr.toBase58()),t.feePayer||(t.feePayer=ai.generate().publicKey)),e.push(Tr(t))}),console.log("simulate tx string:",e),e}function re(g,e,t){return xe([g.toBuffer(),(t!=null?t:hr).toBuffer(),e.toBuffer()],new Ar("ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL"))}import{PublicKey as D}from"@solana/web3.js";var Ca=new D("EhhTKczWMGQt46ynNeRX1WfeagwwJd7ufHvCDjRxjo5Q"),Ka=new D("CBuCnLe26faBpcBP2fktp4rp8abpcAnTWft6ZrP5Q4T"),La=new D("9KEPoZmtHUrBbhWN1v1KWLMkkvwY6WLtAVUCPRtRjP4z"),Ra=new D("FarmqiPv5eAj3j1GMdMCMUGXqPUvmquZtMy86QH6rzhG"),Na=new D("CLaimxFqjHzgTJtAGHU47NPhg6qrc5sCnpC4tBLyABQS"),Ma=new D("srmqPvymJeFKQ4zGQed1GFppgkRHL9kaELCbyksJtPX"),Oa=new D("9xQeWvG816bUx9EPjHmaT23yvVM2ZWbrrpZb9PusVFin"),Fa=new D("675kPX9MHTjS2zt1qfr1NYHuzeLXfQM9H24wFSUt1Mp8"),Ea=new D("5quBtoiQqxF9Jv6KYKctB59NT3gtJD2Y65kdnB1Uev3h"),Da=new D("CDSr3ssLcRB6XYPJwAfFt18MZvEZp4LjHcvzBVZ45duo"),Nt=new D("CAMMCzo5YL8w4VFF8KVHrK22GGUsp5VTaW7grrKgrWqK"),Mt=new D("LockrWmn6K5twhz3y9w1dQERbmgSaRkfnTeTKbpofwE"),nn=new D("kN1kEznaF5Xbd8LYuqtEFcxzWSBk5Fv6ygX6SqEGJVy"),_a=new D("CDSr3ssLcRB6XYPJwAfFt18MZvEZp4LjHcvzBVZ45duo"),Wa=new D("routeUGWgWzqBWFcrCfv8tritsqukccJPu3q5GPP3xS"),va=new D("7YttLkHDoNj9wyDur5pM1ejNaAvT9X4eqaYcHQqtj2G5"),Va=new D("6FJon3QE27qgPVggARueB22hLvoh22VzJpXv4rBEoSLF"),qa=new D("CC12se5To1CdEuw7fDS27B7Geo5jJyL7t5UK2B44NgiH"),Ga=new D("9HzJyW1qZsEiSfMUf6L2jo3CcTKAyBmSyKdwQeYisHrC"),Ua=new D("DropEU8AvevN3UrXWXTMuz3rqnMczQVNjq3kcSdW2SQi"),Xa=new D("CPMMoo8L3F4NbTegBCKVNunggL7H1ZpdTHKxQB5qKP1C"),Ha=new D("GpMZbSM2GgvTKHJirzeGfMFoaZ8UR2X7F4v8vHTvxFbL"),za=new D("DNXgeM9EiiaAbaWvwjHj9fQQLAX5ZsfHyvmYUNRAdNC8"),ja=new D("LockrWmn6K5twhz3y9w1dQERbmgSaRkfnTeTKbpofwE"),Za=new D("3f7GcQFG397GAaEnv51zR6tsTVihYRydnydDD1cXekxH"),Qa=new D("LanMV9sAd7wArD4vJFi2qDdfnVhFxYSUg6eADduJ3uj"),Ya=new D("WLHv2UAZm6z4KyaaELi5pjdbJh6RESMva1Rnn8pJVVh"),Ja=new D("DRay6fNdQ5J82H7xV6uq2aV3mNrUZ1J4PgSKsWgptcm6"),$a=new D("5xqNaZXX5eUi4p5HU4oz9i5QnwRNT2y6oN7yyn4qENeq"),ec=new D("4Bu96XjU84XjPDSpveTVf6LYGCkfW5FK7SNkREWcEfV4"),tc=new D("6s1xP3hpbAfFoNtUNF8mfHsjr2Bd97JxFJRWLbL6aHuX");var nc={OPEN_BOOK_PROGRAM:new D("EoTcMgcDRTJVZDMZWBoU6rhYHZfkNTVEAfz3uUJRcYGj"),SERUM_PROGRAM_ID_V3:new D("Ray1111111111111111111111111111111111111111"),AMM_V4:new D("DRaya7Kj3aMWQSy19kSjvmuwq9docCHofyP9kanQGaav"),AMM_STABLE:new D("DRayDdXc1NZQ9C3hRWmoSf8zK4iapgMnjdNZWrfwsP8m"),CLMM_PROGRAM_ID:new D("DRayAUgENGQBKVaX8owNhgzkEDyoHTGVEGHVJT1E9pfH"),CLMM_LOCK_PROGRAM_ID:new D("DRay25Usp3YJAi7beckgpGUC7mGJ2cR1AVPxhYfwVCUX"),CLMM_LOCK_AUTH_ID:new D("6Aoh8h2Lw2m5UGxYR8AdAL87jTWYeKoxM52mJRzfYwN"),CREATE_CPMM_POOL_PROGRAM:new D("DRaycpLY18LhpbydsBWbVJtxpNv9oXPgjRSfpF2bWpYb"),CREATE_CPMM_POOL_AUTH:new D("CXniRufdq5xL8t8jZAPxsPZDpuudwuJSPWnbcD5Y5Nxq"),CREATE_CPMM_POOL_FEE_ACC:new D("3oE58BKVt8KuYkGxx8zBojugnymWmBiyafWgMrnb6eYy"),LOCK_CPMM_PROGRAM:new D("DRay25Usp3YJAi7beckgpGUC7mGJ2cR1AVPxhYfwVCUX"),LOCK_CPMM_AUTH:new D("7qWVV8UY2bRJfDLP4s37YzBPKUkVB46DStYJBpYbQzu3"),UTIL1216:D.default,Router:new D("DRaybByLpbUL57LJARs3j8BitTxVfzBg351EaMr5UTCd"),FARM_PROGRAM_ID_V3:new D("DRayWyrLmEW5KEeqs8kdTMMaBabapqagaBC7KWpGtJeZ"),FARM_PROGRAM_ID_V4:new D("Ray1111111111111111111111111111111111111111"),FARM_PROGRAM_ID_V5:new D("DRayiCGSZgku1GTK6rXD6mVDdingXy6APAH1R6R5L2LC"),FARM_PROGRAM_ID_V6:new D("DRayzbYakXs45ELHkzH6vC3fuhQqTAnv5A68gdFuvZyZ"),LAUNCHPAD_PROGRAM:new D("DRay6fNdQ5J82H7xV6uq2aV3mNrUZ1J4PgSKsWgptcm6"),LAUNCHPAD_AUTH:new D("5xqNaZXX5eUi4p5HU4oz9i5QnwRNT2y6oN7yyn4qENeq"),LAUNCHPAD_PLATFORM:new D("2Jx4KTDrVSdWNazuGpcA8n3ZLTRGGBDxAWhuKe2Xcj2a"),LAUNCHPAD_CONFIG:new D("7ZR4zD7PYfY2XxoG1Gxcy2EgEeGYrpxrwzPuwdUBssEt"),FEE_DESTINATION_ID:new D("9y8ENuuZ3b19quffx9hQvRVygG5ky6snHfRvGpuSfeJy"),MODEL_DATA_PUBKEY:new D("Ray1111111111111111111111111111111111111111")};import De from"bn.js";var Ot=1e4;function be(g,e,t,n){if(e===void 0)return{amount:g,fee:void 0,expirationTime:void 0};let i=U(O({},e),{olderTransferFee:{epoch:BigInt(e.olderTransferFee.epoch),maximumFee:BigInt(e.olderTransferFee.maximumFee),transferFeeBasisPoints:e.olderTransferFee.transferFeeBasisPoints},newerTransferFee:{epoch:BigInt(e.newerTransferFee.epoch),maximumFee:BigInt(e.newerTransferFee.maximumFee),transferFeeBasisPoints:e.newerTransferFee.transferFeeBasisPoints}}),s=t.epoch<i.newerTransferFee.epoch?i.olderTransferFee:i.newerTransferFee,r=new De(s.maximumFee.toString()),o=t.epoch<i.newerTransferFee.epoch?(Number(i.newerTransferFee.epoch)*t.slotsInEpoch-t.absoluteSlot)*400/1e3:void 0;if(n)if(s.transferFeeBasisPoints===Ot){let a=new De(s.maximumFee.toString());return{amount:g.add(a),fee:a,expirationTime:o}}else{let a=In(g.mul(new De(Ot)),new De(Ot-s.transferFeeBasisPoints)),c=new De(s.maximumFee.toString()),l=a.sub(g).gt(c)?g.add(c):a,d=In(l.mul(new De(s.transferFeeBasisPoints)),new De(Ot)),f=d.gt(r)?r:d;return{amount:l,fee:f,expirationTime:o}}else{let a=In(g.mul(new De(s.transferFeeBasisPoints)),new De(Ot)),c=a.gt(r)?r:a;return{amount:g,fee:c,expirationTime:o}}}function at(g,e){return g===void 0?e:e===void 0?g:Math.min(g,e)}function In(g,e){let{div:t,mod:n}=g.divmod(e);return n.gt(new De(0))?t.add(new De(1)):t}import{PublicKey as Sn,AddressLookupTableAccount as Pt}from"@solana/web3.js";async function rn({connection:g,address:e,cluster:t="mainnet"}){let n=await je(g,[...new Set(e.map(s=>s.toString()))].map(s=>new Sn(s))),i={};for(let s=0;s<e.length;s++){let r=n[s],o=e[s];if(!r)continue;let a=new Pt({key:o,state:Pt.deserialize(r.data)});i[o.toString()]=a,t==="devnet"?wt[o.toString()]=a:Ft[o.toString()]=a}return i}var Ft={AcL1Vo8oy1ULiavEcjSUcwfBSForXMudcZvDZy5nzJkU:new Pt({key:new Sn("AcL1Vo8oy1ULiavEcjSUcwfBSForXMudcZvDZy5nzJkU"),state:Pt.deserialize(Buffer.from("AQAAAP//////////I1rcEwAAAAAvAQYwun9CU6c5Ikm2pAj+D9IEnCOR45nK+SFTGSdpd6J6AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAbd9uHXZaGT2cvhRs7reawctIXtX1s3kTqM9YV+/wCpBt324e51j94YQl285GzN2rYa/E2DuQ0n/r35KNihi/wFSlNQ+F3IgtYUpVZyeIopbd8eq6vQpgZ4iEky9O72oAVKU1qZKSEGTSTocWDaOHx8NbXdvJK7geQfqEBBBUSNBqfVFxksXFEhjMlMPUrxf1ja7gibof1E49vZigAAAAAGp9UXGMd0yShWY5hpHV62i164o5tLbVxzVVshAAAAAIyXJY9OJInxuz0QKRSODYMLWhOZ2v8QhASOe9jb6fhZC3BlsePRfEU4nVJ/awTDzVi4bHMaoP21SbbRvAP4KUbIScv+6Yw2LHF/6K0ZjUPibbSWXCirYPGuuVl7zT789IUPLW4CpHr4JNCatp3ELXDLKMv6JJ+37le50lbBJ2LvBkX2T9y7AHdNGviJAqQNtlDUDCnauQRWybsLji6nPM8Qkw5asQRvCdB3MbX6IEBwytOrpM32l4jQygKG9TKgR0vZScQ2AsM/IHeQ7RajUkyhuZdc8SGiqQz/7H34torNR/Wir3sl0ruUrVxJWEZfUg+QLNAxxODdBi53/OP7Ioil1cqeBM9dtZC3FLov4yyxWRM/wcGStyJX/QfTnLBAHqkqWotPKVlShCVQqpP9W5W1rOao65IMk5QuQ2kMIOxzDMKAy2vjGSxQODgBz0QwGA+eP4ZjIjrIAQaXENv31QfLlOdXSRCkaybRniDHF4C8YcwhcvsqrOVuTP4B2Na+9wLdtrB31uz2rtlFI5kahdsnp/d1SrASDInYCtTYtdoke4kX+hoKWcEWM4Tle8pTUkUVv4BxS6fje/EzKBE4Qu/YsA/yfEEFGcr8Z57VKDw8uQzpiru7g4lvjnfapW62W030syevD8k07SGoxUHiuT/ai7gAHWWhDsVmg/C63ajgpkH7Sn3GdutArDTfyqOkdqv4/IPC/EFFy7mGkfDd2C57N5a/4jC+BbmJy7wQaSEZr0CQU88lPtUxIVvzGjC95b8Ooss2TqmkrayGKofkPMGQn7Ux+9lfwBSNfxwH8NgbpqC/7LNlV4I7nCvsXf3p+ohQk9NrAJb2KAFpUqEIJ9ZBV7BYDzHF/ORKYlgtvPnXjudZQ6CEo5OzUDaNIomTCCsvhD16TxJjsbgne1kGnQPCFSoaxUbq2V1bPMFQ3VYP6wDZ9bKStCFKx9A3tNbwZFC5ZGAN83MFK7XoTy+OmmcFEr6rLOjfSuTfPvHJkSVxW6Qllwkl67XcBi5v00u2gQsbu+38sp+rd5pA/LvyWj4P94ZGZwc1tE2P88xekCLcAwZGb+UhFzL/7K26csOb57yM5bvF9xJrLEObOkAAAAAn+HWRkdcPKyFFMnVwEoD7vnD0jCKFIU1sImubYCxNTSVzsKpaQX+fzNxrLAI3L14JQnJx/D6Uk2LADIHGqnGELzjEbkBDAlaM77NkXMPfqXNLSveCkWI7UEgNs31WEWB6XHSYI/v5DklHOb4QTtDOR804PVbi3fjloZeLR2F8d4FuZmMMO7ck3Fnkn2zEMG5gOmqsygb6PjTitArVl52NhcSznTxVnguaIJxiZkAnurDmn3MWR0PC2GLghp2KJqHCc6QQ85odeIjFHKOlRlJyeSXVJmL8vb1UgOzsbJPVP8p6zM4M3C1Sd7uWIHP33G42AP2Zg8ucn/n6meQjjD266JgCWdxZD6PXs9CsnIeL7SSG0/6lGb9xfP0ZcWkCXB/3hjxHYVXjra/GPOeXGk0fLLKjCbk+mgs2w6d2oCwimBipTzuoZ30GiI8ij8VRzD5CzMWtu2m21eDBIfjGAEo4pQeNNonKcqzV/cleX8ySZLOHsz8PtBCrLqF+VkLm9hOzIT+6i/nIf6keR4GWKMOD4AvqfpjHoD4DuhBpz8P28+DxkGrDXXr/nr20x291VPvcTU/b+b+o2kC9G0kcXeTlLjU6a2TQXWlZ4gBUdBl1jgT7mObSTpLblNiXZsLkbmVXZwvFKXua5cUKlWed/w30skmEUraTuQqtqr5fHZPW9n57EmeTif6LjHL2YJFZkQU+TrJmFzqzmF4/b8OwrPQAprl8mX3q4LUIdAS/a+11B6DWD1Xk2++Sn94dLC4xjkO4Wtlw8c4XuzciVbepHOmnoWzVu/0y3KCrLCSfQxQ3br8DJCoVzhgtPsS2nZZjsBGIZgnU0QpMv+2MnRsnKwdp1VsrCX84j/qvaZn4WhKunippgTbN2EUs0tPTP55Qfgj+nKmjtWW5IYs72FrEwJKYoNfsmqaF4o5pf4v9zgPwVwY/5I4XJKUL2L25m9kAQcW/K+H1RTFEUoj8Z4ajpOmAB/dG0COmCphVMW2CCMvnxhcGiSgPnpDuWu6qiJ7NG7ye5kvHgefgqPLeicspNJ5EpL3XiRNLM2tmJLI1awAwOyd6iHv0dCkMYRKaa6rcaZeYwmKCkckm0kM2JNmnmmAaBQQ7mwmIM0IMxX4f5W6j9PqZWcJxF7r17T/lQBAmcjoupRiJifbnXCNUv9GhpRF19WcBdeKbivRJVlGop6I2RS6lGImJ9udcI1S/0aGlEXX1ZwF14puK9ElWUainojZFYVHLHD6dIP2ESjqBzg3ol1/wB7+/ylGwd9LS7wSZ2A630CJSVKwH47K9P4bB8PEQP8BwjMFa7xQHOqZFP1XqaQ==","base64"))})},wt={},on=async g=>{let e="EFhMuDw1PKEuckuFRW9PavNfTH4LKP5uKHgyXDmWpFCq";if(wt[e])return wt;let t=new Sn(e),n=await g.getAccountInfo(t);return n&&(wt[e]=new Pt({key:t,state:Pt.deserialize(n.data)})),wt};import{PublicKey as pt,sendAndConfirmTransaction as Cn,SystemProgram as Br,Transaction as Et,TransactionMessage as Je,VersionedTransaction as $e}from"@solana/web3.js";import Ir from"axios";var Dt=2e3,_t=class{constructor(e){this.instructions=[];this.endInstructions=[];this.lookupTableAddress=[];this.signers=[];this.instructionTypes=[];this.endInstructionTypes=[];this.connection=e.connection,this.feePayer=e.feePayer,this.signAllTransactions=e.signAllTransactions,this.owner=e.owner,this.cluster=e.cluster,this.blockhashCommitment=e.blockhashCommitment,this.loopMultiTxStatus=!!e.loopMultiTxStatus}get AllTxData(){return{instructions:this.instructions,endInstructions:this.endInstructions,signers:this.signers,instructionTypes:this.instructionTypes,endInstructionTypes:this.endInstructionTypes,lookupTableAddress:this.lookupTableAddress}}get allInstructions(){return[...this.instructions,...this.endInstructions]}async getComputeBudgetConfig(){var n;let e=(await Ir.get(`https://solanacompass.com/api/fees?cacheFreshTime=${3e5}`)).data,{avg:t}=(n=e==null?void 0:e[15])!=null?n:{};if(!!t)return{units:6e5,microLamports:Math.min(Math.ceil(t*1e6/6e5),25e3)}}addCustomComputeBudget(e){if(e){let{instructions:t,instructionTypes:n}=Kt(e);return this.instructions.unshift(...t),this.instructionTypes.unshift(...n),!0}return!1}addTipInstruction(e){var t;return e?(this.endInstructions.push(Br.transfer({fromPubkey:(t=e.feePayer)!=null?t:this.feePayer,toPubkey:new pt(e.address),lamports:BigInt(e.amount.toString())})),this.endInstructionTypes.push(ie.TransferTip),!0):!1}async calComputeBudget({config:e,defaultIns:t}){try{let n=e||await this.getComputeBudgetConfig();if(this.addCustomComputeBudget(n))return;t&&this.instructions.unshift(...t)}catch{t&&this.instructions.unshift(...t)}}addInstruction({instructions:e=[],endInstructions:t=[],signers:n=[],instructionTypes:i=[],endInstructionTypes:s=[],lookupTableAddress:r=[]}){return this.instructions.push(...e),this.endInstructions.push(...t),this.signers.push(...n),this.instructionTypes.push(...i),this.endInstructionTypes.push(...s),this.lookupTableAddress.push(...r.filter(o=>o!==pt.default.toString())),this}async versionBuild({txVersion:e,extInfo:t}){return e===0?await this.buildV0(O({},t||{})):this.build(t)}build(e){var n;let t=new Et;return this.allInstructions.length&&t.add(...this.allInstructions),t.feePayer=this.feePayer,((n=this.owner)==null?void 0:n.signer)&&!this.signers.some(i=>i.publicKey.equals(this.owner.publicKey))&&this.signers.push(this.owner.signer),{builder:this,transaction:t,signers:this.signers,instructionTypes:[...this.instructionTypes,...this.endInstructionTypes],execute:async i=>{var l;let{recentBlockHash:s,skipPreflight:r=!0,sendAndConfirm:o,notSendToRpc:a}=i||{},c=s!=null?s:await dt(this.connection,this.blockhashCommitment);if(t.recentBlockhash=c,this.signers.length&&t.sign(...this.signers),st([t]),(l=this.owner)!=null&&l.isKeyPair)return{txId:o?await Cn(this.connection,t,this.signers.find(f=>f.publicKey.equals(this.owner.publicKey))?this.signers:[...this.signers,this.owner.signer],{skipPreflight:r}):await this.connection.sendRawTransaction(t.serialize(),{skipPreflight:r}),signedTx:t};if(this.signAllTransactions){let d=await this.signAllTransactions([t]);if(this.signers.length)for(let f of d)try{f.sign(...this.signers)}catch{}return{txId:a?"":await this.connection.sendRawTransaction(d[0].serialize(),{skipPreflight:r}),signedTx:d[0]}}throw new Error("please provide owner in keypair format or signAllTransactions function")},extInfo:e||{}}}buildMultiTx(e){var c;let{extraPreBuildData:t=[],extInfo:n}=e,{transaction:i}=this.build(n),s=t.filter(l=>l.transaction.instructions.length>0),r=[i,...s.map(l=>l.transaction)],o=[this.signers,...s.map(l=>l.signers)],a=[...this.instructionTypes,...s.map(l=>l.instructionTypes).flat()];return(c=this.owner)!=null&&c.signer&&o.forEach(l=>{l.some(d=>d.publicKey.equals(this.owner.publicKey))||this.signers.push(this.owner.signer)}),{builder:this,transactions:r,signers:o,instructionTypes:a,execute:async l=>{var b;let{sequentially:d,onTxUpdate:f,skipTxCount:u=0,recentBlockHash:m,skipPreflight:p=!0}=l||{},y=m!=null?m:await dt(this.connection,this.blockhashCommitment);if((b=this.owner)!=null&&b.isKeyPair){if(d){let P=[],A=0;for(let T of r){if(++A,A<=u)continue;let k=await Cn(this.connection,T,this.signers.find(w=>w.publicKey.equals(this.owner.publicKey))?this.signers:[...this.signers,this.owner.signer],{skipPreflight:p});P.push(k)}return{txIds:P,signedTxs:r}}return{txIds:await await Promise.all(r.map(async P=>(P.recentBlockhash=y,await this.connection.sendRawTransaction(P.serialize(),{skipPreflight:p})))),signedTxs:r}}if(this.signAllTransactions){let P=r.map((T,k)=>(T.recentBlockhash=y,o[k].length&&T.sign(...o[k]),T));st(P);let A=await this.signAllTransactions(P);if(d){let T=0,k=[],w=async()=>{if(!A[T])return;let x=await this.connection.sendRawTransaction(A[T].serialize(),{skipPreflight:p});k.push({txId:x,status:"sent",signedTx:A[T]}),f==null||f([...k]),T++;let h=!1,B=null,K=null,L=C=>{B!==null&&clearInterval(B),K!==null&&this.connection.removeSignatureListener(K);let N=k.findIndex(I=>I.txId===x);if(N>-1){if(k[N].status==="error"||k[N].status==="success")return;k[N].status=C.err?"error":"success"}f==null||f([...k]),C.err||w()};this.loopMultiTxStatus&&(B=setInterval(async()=>{var C;if(h){clearInterval(B);return}try{let N=await this.connection.getTransaction(x,{commitment:"confirmed",maxSupportedTransactionVersion:0});N&&(h=!0,clearInterval(B),L({err:((C=N.meta)==null?void 0:C.err)||null}),console.log("tx status from getTransaction:",x))}catch(N){h=!0,clearInterval(B),console.error("getTransaction timeout:",N,x)}},Dt)),K=this.connection.onSignature(x,C=>{if(h){this.connection.removeSignatureListener(K);return}h=!0,L(C)},"confirmed"),this.connection.getSignatureStatus(x)};return await w(),{txIds:k.map(x=>x.txId),signedTxs:A}}else{let T=[];for(let k=0;k<A.length;k+=1){let w=await this.connection.sendRawTransaction(A[k].serialize(),{skipPreflight:p});T.push(w)}return{txIds:T,signedTxs:A}}}throw new Error("please provide owner in keypair format or signAllTransactions function")},extInfo:n||{}}}async versionMultiBuild({extraPreBuildData:e,txVersion:t,extInfo:n}){return t===0?await this.buildV0MultiTx({extraPreBuildData:e,buildProps:n||{}}):this.buildMultiTx({extraPreBuildData:e,extInfo:n})}async buildV0(e){var p;let m=e||{},{lookupTableCache:t={},lookupTableAddress:n=[],forerunCreate:i,recentBlockhash:s}=m,r=ut(m,["lookupTableCache","lookupTableAddress","forerunCreate","recentBlockhash"]),o=O(O({},this.cluster==="devnet"?await on(this.connection):Ft),t),a=Array.from(new Set([...n,...this.lookupTableAddress])),c=[];for(let y of a)o[y]===void 0&&c.push(new pt(y));let l=await rn({connection:this.connection,address:c});for(let[y,b]of Object.entries(l))o[y]=b;let d=i?pt.default.toBase58():s!=null?s:await dt(this.connection,this.blockhashCommitment),f=new Je({payerKey:this.feePayer,recentBlockhash:d,instructions:[...this.allInstructions]}).compileToV0Message(Object.values(o));((p=this.owner)==null?void 0:p.signer)&&!this.signers.some(y=>y.publicKey.equals(this.owner.publicKey))&&this.signers.push(this.owner.signer);let u=new $e(f);return u.sign(this.signers),{builder:this,transaction:u,signers:this.signers,instructionTypes:[...this.instructionTypes,...this.endInstructionTypes],execute:async y=>{var T;let{skipPreflight:b=!0,sendAndConfirm:P,notSendToRpc:A}=y||{};if(st([u]),(T=this.owner)!=null&&T.isKeyPair){let k=await this.connection.sendTransaction(u,{skipPreflight:b});return P&&await Lt(this.connection,k),{txId:k,signedTx:u}}if(this.signAllTransactions){let k=await this.signAllTransactions([u]);if(this.signers.length)for(let w of k)try{w.sign(this.signers)}catch{}return{txId:A?"":await this.connection.sendTransaction(k[0],{skipPreflight:b}),signedTx:k[0]}}throw new Error("please provide owner in keypair format or signAllTransactions function")},extInfo:r||{}}}async buildV0MultiTx(e){var c;let{extraPreBuildData:t=[],buildProps:n}=e,{transaction:i}=await this.buildV0(n),s=t.filter(l=>l.builder.instructions.length>0),r=[i,...s.map(l=>l.transaction)],o=[this.signers,...s.map(l=>l.signers)],a=[...this.instructionTypes,...s.map(l=>l.instructionTypes).flat()];return(c=this.owner)!=null&&c.signer&&o.forEach(l=>{l.some(d=>d.publicKey.equals(this.owner.publicKey))||this.signers.push(this.owner.signer)}),r.forEach(async(l,d)=>{l.sign(o[d])}),{builder:this,transactions:r,signers:o,instructionTypes:a,buildProps:n,execute:async l=>{var p;let{sequentially:d,onTxUpdate:f,recentBlockHash:u,skipPreflight:m=!0}=l||{};if(u&&r.forEach(y=>y.message.recentBlockhash=u),st(r),(p=this.owner)!=null&&p.isKeyPair){if(d){let y=[];for(let b of r){let P=await this.connection.sendTransaction(b,{skipPreflight:m});await Lt(this.connection,P),y.push(P)}return{txIds:y,signedTxs:r}}return{txIds:await Promise.all(r.map(async y=>await this.connection.sendTransaction(y,{skipPreflight:m}))),signedTxs:r}}if(this.signAllTransactions){let y=await this.signAllTransactions(r);if(d){let b=0,P=[],A=async()=>{if(!y[b])return;let T=await this.connection.sendTransaction(y[b],{skipPreflight:m});P.push({txId:T,status:"sent",signedTx:y[b]}),f==null||f([...P]),b++;let k=!1,w=null,x=null,h=B=>{w!==null&&clearInterval(w),x!==null&&this.connection.removeSignatureListener(x);let K=P.findIndex(L=>L.txId===T);if(K>-1){if(P[K].status==="error"||P[K].status==="success")return;P[K].status=B.err?"error":"success"}f==null||f([...P]),B.err||A()};this.loopMultiTxStatus&&(w=setInterval(async()=>{var B;if(k){clearInterval(w);return}try{let K=await this.connection.getTransaction(T,{commitment:"confirmed",maxSupportedTransactionVersion:0});K&&(k=!0,clearInterval(w),h({err:((B=K.meta)==null?void 0:B.err)||null}),console.log("tx status from getTransaction:",T))}catch(K){k=!0,clearInterval(w),console.error("getTransaction timeout:",K,T)}},Dt)),x=this.connection.onSignature(T,B=>{if(k){this.connection.removeSignatureListener(x);return}k=!0,h(B)},"confirmed"),this.connection.getSignatureStatus(T)};return A(),{txIds:[],signedTxs:y}}else{let b=[];for(let P=0;P<y.length;P+=1){let A=await this.connection.sendTransaction(y[P],{skipPreflight:m});b.push(A)}return{txIds:b,signedTxs:y}}}throw new Error("please provide owner in keypair format or signAllTransactions function")},extInfo:n||{}}}async sizeCheckBuild(e){var f;let d=e||{},{splitIns:t=[],computeBudgetConfig:n}=d,i=ut(d,["splitIns","computeBudgetConfig"]),s=n?Kt(n):{instructions:[],instructionTypes:[]},r=this.signers.reduce((u,m)=>U(O({},u),{[m.publicKey.toBase58()]:m}),{}),o=[],a=[],c=[],l=0;if(this.allInstructions.forEach(u=>{let m=[...c,u],p=n?[...s.instructions,...m]:m,b=[...new Set(m.map(P=>P.keys.filter(A=>A.isSigner).map(A=>A.pubkey.toString())).flat()).values()].map(P=>new pt(P));if(u!==t[l]&&c.length<12&&(Rt({instructions:p,payer:this.feePayer,signers:b})||Rt({instructions:m,payer:this.feePayer,signers:b})))c.push(u);else{if(c.length===0)throw Error("item ins too big");l+=u===t[l]?1:0,Rt({instructions:n?[...s.instructions,...c]:[...c],payer:this.feePayer,signers:b})?o.push(new Et().add(...s.instructions,...c)):o.push(new Et().add(...c)),a.push(Array.from(new Set(c.map(P=>P.keys.filter(A=>A.isSigner).map(A=>A.pubkey.toString())).flat())).map(P=>r[P]).filter(P=>P!==void 0)),c=[u]}}),c.length>0){let m=[...new Set(c.map(p=>p.keys.filter(y=>y.isSigner).map(y=>y.pubkey.toString())).flat()).values()].map(p=>r[p]).filter(p=>p!==void 0);Rt({instructions:n?[...s.instructions,...c]:[...c],payer:this.feePayer,signers:m.map(p=>p.publicKey)})?o.push(new Et().add(...s.instructions,...c)):o.push(new Et().add(...c)),a.push(m)}return o.forEach(u=>u.feePayer=this.feePayer),(f=this.owner)!=null&&f.signer&&a.forEach(u=>{u.some(m=>m.publicKey.equals(this.owner.publicKey))||u.push(this.owner.signer)}),{builder:this,transactions:o,signers:a,instructionTypes:this.instructionTypes,execute:async u=>{var T;let{sequentially:m,onTxUpdate:p,skipTxCount:y=0,recentBlockHash:b,skipPreflight:P=!0}=u||{},A=b!=null?b:await dt(this.connection,this.blockhashCommitment);if(o.forEach(async(k,w)=>{k.recentBlockhash=A,a[w].length&&k.sign(...a[w])}),st(o),(T=this.owner)!=null&&T.isKeyPair){if(m){let k=0,w=[];for(let x of o){if(++k,k<=y){w.push("tx skipped");continue}let h=await Cn(this.connection,x,this.signers.find(B=>B.publicKey.equals(this.owner.publicKey))?this.signers:[...this.signers,this.owner.signer],{skipPreflight:P});w.push(h)}return{txIds:w,signedTxs:o}}return{txIds:await Promise.all(o.map(async k=>await this.connection.sendRawTransaction(k.serialize(),{skipPreflight:P}))),signedTxs:o}}if(this.signAllTransactions){let k=await this.signAllTransactions(o.slice(y,o.length)),w=[...o.slice(0,y),...k];if(m){let x=0,h=[],B=async()=>{if(!w[x])return;x<y&&(h.push({txId:"",status:"success",signedTx:w[x]}),p==null||p([...h]),x++,B());let K=await this.connection.sendRawTransaction(w[x].serialize(),{skipPreflight:P});h.push({txId:K,status:"sent",signedTx:w[x]}),p==null||p([...h]),x++;let L=!1,C=null,N=null,I=F=>{C!==null&&clearInterval(C),N!==null&&this.connection.removeSignatureListener(N);let v=h.findIndex(ce=>ce.txId===K);if(v>-1){if(h[v].status==="error"||h[v].status==="success")return;h[v].status=F.err?"error":"success"}p==null||p([...h]),F.err||B()};this.loopMultiTxStatus&&(C=setInterval(async()=>{var F;if(L){clearInterval(C);return}try{let v=await this.connection.getTransaction(K,{commitment:"confirmed",maxSupportedTransactionVersion:0});v&&(L=!0,clearInterval(C),I({err:((F=v.meta)==null?void 0:F.err)||null}),console.log("tx status from getTransaction:",K))}catch(v){L=!0,clearInterval(C),console.error("getTransaction timeout:",v,K)}},Dt)),N=this.connection.onSignature(K,F=>{if(L){this.connection.removeSignatureListener(N);return}L=!0,I(F)},"confirmed"),this.connection.getSignatureStatus(K)};return await B(),{txIds:h.map(K=>K.txId),signedTxs:w}}else{let x=[];for(let h=0;h<w.length;h+=1){let B=await this.connection.sendRawTransaction(w[h].serialize(),{skipPreflight:P});x.push(B)}return{txIds:x,signedTxs:w}}}throw new Error("please provide owner in keypair format or signAllTransactions function")},extInfo:i||{}}}async sizeCheckBuildV0(e){var A;let P=e||{},{computeBudgetConfig:t,splitIns:n=[],lookupTableCache:i={},lookupTableAddress:s=[]}=P,r=ut(P,["computeBudgetConfig","splitIns","lookupTableCache","lookupTableAddress"]),o=O(O({},this.cluster==="devnet"?await on(this.connection):Ft),i),a=Array.from(new Set([...this.lookupTableAddress,...s])),c=[];for(let T of a)o[T]===void 0&&c.push(new pt(T));let l=await rn({connection:this.connection,address:c});for(let[T,k]of Object.entries(l))o[T]=k;let d=t?Kt(t):{instructions:[],instructionTypes:[]},f=await dt(this.connection,this.blockhashCommitment),u=this.signers.reduce((T,k)=>U(O({},T),{[k.publicKey.toBase58()]:k}),{}),m=[],p=[],y=[],b=0;if(this.allInstructions.forEach(T=>{let k=[...y,T],w=t?[...d.instructions,...k]:k;if(T!==n[b]&&y.length<12&&(Ye({instructions:w,payer:this.feePayer,lookupTableAddressAccount:o})||Ye({instructions:k,payer:this.feePayer,lookupTableAddressAccount:o})))y.push(T);else{if(y.length===0)throw Error("item ins too big");b+=T===n[b]?1:0;let x={};for(let h of[...new Set(a)])o[h]!==void 0&&(x[h]=o[h]);if(t&&Ye({instructions:[...d.instructions,...y],payer:this.feePayer,lookupTableAddressAccount:o,recentBlockhash:f})){let h=new Je({payerKey:this.feePayer,recentBlockhash:f,instructions:[...d.instructions,...y]}).compileToV0Message(Object.values(o));m.push(new $e(h))}else{let h=new Je({payerKey:this.feePayer,recentBlockhash:f,instructions:[...y]}).compileToV0Message(Object.values(o));m.push(new $e(h))}p.push(Array.from(new Set(y.map(h=>h.keys.filter(B=>B.isSigner).map(B=>B.pubkey.toString())).flat())).map(h=>u[h]).filter(h=>h!==void 0)),y=[T]}}),y.length>0){let k=[...new Set(y.map(w=>w.keys.filter(x=>x.isSigner).map(x=>x.pubkey.toString())).flat()).values()].map(w=>u[w]).filter(w=>w!==void 0);if(t&&Ye({instructions:[...d.instructions,...y],payer:this.feePayer,lookupTableAddressAccount:o,recentBlockhash:f})){let w=new Je({payerKey:this.feePayer,recentBlockhash:f,instructions:[...d.instructions,...y]}).compileToV0Message(Object.values(o));m.push(new $e(w))}else{let w=new Je({payerKey:this.feePayer,recentBlockhash:f,instructions:[...y]}).compileToV0Message(Object.values(o));m.push(new $e(w))}p.push(k)}return(A=this.owner)!=null&&A.signer&&p.forEach(T=>{T.some(k=>k.publicKey.equals(this.owner.publicKey))||T.push(this.owner.signer)}),m.forEach((T,k)=>{T.sign(p[k])}),{builder:this,transactions:m,buildProps:e,signers:p,instructionTypes:this.instructionTypes,execute:async T=>{var K;let{sequentially:k,onTxUpdate:w,skipTxCount:x=0,recentBlockHash:h,skipPreflight:B=!0}=T||{};if(m.map(async(L,C)=>{p[C].length&&L.sign(p[C]),h&&(L.message.recentBlockhash=h)}),st(m),(K=this.owner)!=null&&K.isKeyPair){if(k){let L=0,C=[];for(let N of m){if(++L,L<=x){console.log("skip tx: ",L),C.push("tx skipped");continue}let I=await this.connection.sendTransaction(N,{skipPreflight:B});await Lt(this.connection,I),C.push(I)}return{txIds:C,signedTxs:m}}return{txIds:await Promise.all(m.map(async L=>await this.connection.sendTransaction(L,{skipPreflight:B}))),signedTxs:m}}if(this.signAllTransactions){let L=await this.signAllTransactions(m.slice(x,m.length)),C=[...m.slice(0,x),...L];if(k){let N=0,I=[],F=async()=>{if(!C[N])return;if(N<x){I.push({txId:"",status:"success",signedTx:C[N]}),w==null||w([...I]),N++,F();return}let v=await this.connection.sendTransaction(C[N],{skipPreflight:B});I.push({txId:v,status:"sent",signedTx:C[N]}),w==null||w([...I]),N++;let ce=!1,pe=null,Le=null,ze=$=>{pe!==null&&clearInterval(pe),Le!==null&&this.connection.removeSignatureListener(Le);let ne=I.findIndex(We=>We.txId===v);if(ne>-1){if(I[ne].status==="error"||I[ne].status==="success")return;I[ne].status=$.err?"error":"success"}w==null||w([...I]),$.err||F()};this.loopMultiTxStatus&&(pe=setInterval(async()=>{var $;if(ce){clearInterval(pe);return}try{let ne=await this.connection.getTransaction(v,{commitment:"confirmed",maxSupportedTransactionVersion:0});ne&&(ce=!0,clearInterval(pe),ze({err:(($=ne.meta)==null?void 0:$.err)||null}),console.log("tx status from getTransaction:",v))}catch(ne){ce=!0,clearInterval(pe),console.error("getTransaction timeout:",ne,v)}},Dt)),Le=this.connection.onSignature(v,$=>{if(ce){this.connection.removeSignatureListener(Le);return}ce=!0,ze($)},"confirmed"),this.connection.getSignatureStatus(v)};return F(),{txIds:[],signedTxs:C}}else{let N=[];for(let I=0;I<C.length;I+=1){let F=await this.connection.sendTransaction(C[I],{skipPreflight:B});N.push(F)}return{txIds:N,signedTxs:C}}}throw new Error("please provide owner in keypair format or signAllTransactions function")},extInfo:r||{}}}async buildSniperTransaction(e){var A;let P=e||{},{computeBudgetConfig:t,splitIns:n=[],lookupTableCache:i={},lookupTableAddress:s=[]}=P,r=ut(P,["computeBudgetConfig","splitIns","lookupTableCache","lookupTableAddress"]),o=O(O({},this.cluster==="devnet"?await on(this.connection):Ft),i),a=Array.from(new Set([...this.lookupTableAddress,...s])),c=[];for(let T of a)o[T]===void 0&&c.push(new pt(T));let l=await rn({connection:this.connection,address:c});for(let[T,k]of Object.entries(l))o[T]=k;let d=t?Kt(t):{instructions:[],instructionTypes:[]},f=await dt(this.connection,this.blockhashCommitment),u=this.signers.reduce((T,k)=>U(O({},T),{[k.publicKey.toBase58()]:k}),{}),m=[],p=[],y=[],b=0;if(this.allInstructions.forEach(T=>{let k=[...y,T],w=t?[...d.instructions,...k]:k;if(T!==n[b]&&y.length<12&&(Ye({instructions:w,payer:this.feePayer,lookupTableAddressAccount:o})||Ye({instructions:k,payer:this.feePayer,lookupTableAddressAccount:o})))y.push(T);else{if(y.length===0)throw Error("item ins too big");b+=T===n[b]?1:0;let x={};for(let h of[...new Set(a)])o[h]!==void 0&&(x[h]=o[h]);if(t&&Ye({instructions:[...d.instructions,...y],payer:this.feePayer,lookupTableAddressAccount:o,recentBlockhash:f})){let h=new Je({payerKey:this.feePayer,recentBlockhash:f,instructions:[...d.instructions,...y]}).compileToV0Message(Object.values(o));m.push(new $e(h))}else{let h=new Je({payerKey:this.feePayer,recentBlockhash:f,instructions:[...y]}).compileToV0Message(Object.values(o));m.push(new $e(h))}p.push(Array.from(new Set(y.map(h=>h.keys.filter(B=>B.isSigner).map(B=>B.pubkey.toString())).flat())).map(h=>u[h]).filter(h=>h!==void 0)),y=[T]}}),y.length>0){let k=[...new Set(y.map(w=>w.keys.filter(x=>x.isSigner).map(x=>x.pubkey.toString())).flat()).values()].map(w=>u[w]).filter(w=>w!==void 0);if(t&&Ye({instructions:[...d.instructions,...y],payer:this.feePayer,lookupTableAddressAccount:o,recentBlockhash:f})){let w=new Je({payerKey:this.feePayer,recentBlockhash:f,instructions:[...d.instructions,...y]}).compileToV0Message(Object.values(o));m.push(new $e(w))}else{let w=new Je({payerKey:this.feePayer,recentBlockhash:f,instructions:[...y]}).compileToV0Message(Object.values(o));m.push(new $e(w))}p.push(k)}return(A=this.owner)!=null&&A.signer&&p.forEach(T=>{T.some(k=>k.publicKey.equals(this.owner.publicKey))||T.push(this.owner.signer)}),m.forEach((T,k)=>{T.sign(p[k])}),{builder:this,transactions:m,buildProps:e,signers:p,instructionTypes:this.instructionTypes,execute:async T=>{var K;let{sequentially:k,onTxUpdate:w,skipTxCount:x=0,recentBlockHash:h,skipPreflight:B=!0}=T||{};if(m.map(async(L,C)=>{p[C].length&&L.sign(p[C]),h&&(L.message.recentBlockhash=h)}),st(m),(K=this.owner)!=null&&K.isKeyPair){if(k){let L=0,C=[];for(let N of m){if(++L,L<=x){console.log("skip tx: ",L),C.push("tx skipped");continue}let I=await this.connection.sendTransaction(N,{skipPreflight:B});await Lt(this.connection,I),C.push(I)}return{txIds:C,signedTxs:m}}return{txIds:await Promise.all(m.map(async L=>await this.connection.sendTransaction(L,{skipPreflight:B}))),signedTxs:m}}if(this.signAllTransactions){let L=await this.signAllTransactions(m.slice(x,m.length)),C=[...m.slice(0,x),...L];if(k){let N=0,I=[],F=async()=>{if(!C[N])return;if(N<x){I.push({txId:"",status:"success",signedTx:C[N]}),w==null||w([...I]),N++,F();return}let v=await this.connection.sendTransaction(C[N],{skipPreflight:B});I.push({txId:v,status:"sent",signedTx:C[N]}),w==null||w([...I]),N++;let ce=!1,pe=null,Le=null,ze=$=>{pe!==null&&clearInterval(pe),Le!==null&&this.connection.removeSignatureListener(Le);let ne=I.findIndex(We=>We.txId===v);if(ne>-1){if(I[ne].status==="error"||I[ne].status==="success")return;I[ne].status=$.err?"error":"success"}w==null||w([...I]),$.err||F()};this.loopMultiTxStatus&&(pe=setInterval(async()=>{var $;if(ce){clearInterval(pe);return}try{let ne=await this.connection.getTransaction(v,{commitment:"confirmed",maxSupportedTransactionVersion:0});ne&&(ce=!0,clearInterval(pe),ze({err:(($=ne.meta)==null?void 0:$.err)||null}),console.log("tx status from getTransaction:",v))}catch(ne){ce=!0,clearInterval(pe),console.error("getTransaction timeout:",ne,v)}},Dt)),Le=this.connection.onSignature(v,$=>{if(ce){this.connection.removeSignatureListener(Le);return}ce=!0,ze($)},"confirmed"),this.connection.getSignatureStatus(v)};return F(),{txIds:[],signedTxs:C}}else{let N=[];for(let I=0;I<C.length;I+=1){let F=await this.connection.sendTransaction(C[I],{skipPreflight:B});N.push(F)}return{txIds:N,signedTxs:C}}}throw new Error("please provide owner in keypair format or signAllTransactions function")},extInfo:r||{}}}};import Sr from"bn.js";var hc=new Sr(1e6);import{AccountLayout as Vi,createAssociatedTokenAccountIdempotentInstruction as qi,TOKEN_2022_PROGRAM_ID as ct,TOKEN_PROGRAM_ID as Zt}from"@solana/spl-token";import{PublicKey as Hc}from"@solana/web3.js";import{MintLayout as jc,TOKEN_PROGRAM_ID as Qc}from"@solana/spl-token";var sn=i=>{var s=i,{address:g,programId:e,decimals:t}=s,n=ut(s,["address","programId","decimals"]);return O({chainId:101,address:lt(g).toBase58(),programId:e,logoURI:"",symbol:"",name:"",decimals:t,tags:[],extensions:n.extensions||{}},n)},Kn=g=>g?U(O({},g),{transferFeeConfigAuthority:g.transferFeeConfigAuthority.toBase58(),withdrawWithheldAuthority:g.withdrawWithheldAuthority.toBase58(),withheldAmount:g.withheldAmount.toString(),olderTransferFee:U(O({},g.olderTransferFee),{epoch:g.olderTransferFee.epoch.toString(),maximumFee:g.olderTransferFee.maximumFee.toString()}),newerTransferFee:U(O({},g.newerTransferFee),{epoch:g.newerTransferFee.epoch.toString(),maximumFee:g.newerTransferFee.maximumFee.toString()})}):void 0;var Ln=(...g)=>g.map(e=>{try{return typeof e=="object"?JSON.stringify(e):e}catch{return e}}).join(", "),Wt=class{constructor({scope:e,moduleName:t}){this.disabled=!1;this.scope=e,this.logger=Te(t)}createTxBuilder(e){return this.scope.checkOwner(),new _t({connection:this.scope.connection,feePayer:e||this.scope.ownerPubKey,cluster:this.scope.cluster,owner:this.scope.owner,blockhashCommitment:this.scope.blockhashCommitment,loopMultiTxStatus:this.scope.loopMultiTxStatus,api:this.scope.api,signAllTransactions:this.scope.signAllTransactions})}createSniperTxBuilder(e,t){let n=new Ve(e);return new _t({connection:this.scope.connection,feePayer:t,cluster:this.scope.cluster,owner:n,blockhashCommitment:this.scope.blockhashCommitment,loopMultiTxStatus:this.scope.loopMultiTxStatus,api:this.scope.api,signAllTransactions:this.scope.signAllTransactions})}logDebug(...e){this.logger.debug(Ln(e))}logInfo(...e){this.logger.info(Ln(e))}logAndCreateError(...e){let t=Ln(e);throw new Error(t)}checkDisabled(){(this.disabled||!this.scope)&&this.logAndCreateError("module not working")}};import{Keypair as dn,PublicKey as S,SystemProgram as nt,TransactionInstruction as he}from"@solana/web3.js";import Un from"bn.js";import{ASSOCIATED_TOKEN_PROGRAM_ID as jt,TOKEN_2022_PROGRAM_ID as ye,TOKEN_PROGRAM_ID as ee}from"@solana/spl-token";import{PublicKey as Er}from"@solana/web3.js";import fi,{isBN as yi}from"bn.js";import{bits as cu,BitStructure as uu,blob as Cr,Blob as lu,cstr as mu,f32 as du,f32be as pu,f64 as fu,f64be as yu,greedy as bu,Layout as Kr,ns64 as gu,ns64be as wu,nu64 as Pu,nu64be as ku,offset as Tu,s16 as Au,s16be as hu,s24 as xu,s24be as Bu,s32 as Lr,s32be as Iu,s40 as Su,s40be as Cu,s48 as Ku,s48be as Lu,s8 as Ru,seq as Rr,struct as Nu,Structure as Nr,u16 as Mr,u16be as Mu,u24 as Ou,u24be as Fu,u32 as Eu,u32be as Du,u40 as _u,u40be as Wu,u48 as vu,u48be as Vu,u8 as Or,UInt as Fr,union as qu,Union as Gu,unionLayoutDiscriminator as Uu,utf8 as Xu}from"@solana/buffer-layout";var Rn=Kr,mi=Nr;var Nn=Fr;var di=Or,vt=Mr;var oe=Lr;var pi=Rr;var Re=Cr;var kt=class extends Rn{constructor(t,n,i){super(t,i);this.blob=Re(t),this.signed=n}decode(t,n=0){let i=new fi(this.blob.decode(t,n),10,"le");return this.signed?i.fromTwos(this.span*8).clone():i}encode(t,n,i=0){return typeof t=="number"&&(t=new fi(t)),this.signed&&(t=t.toTwos(this.span*8)),this.blob.encode(t.toArrayLike(Buffer,"le",this.span),n,i)}};function fe(g){return new Nn(1,g)}function Tt(g){return new Nn(4,g)}function E(g){return new kt(8,!1,g)}function X(g){return new kt(16,!1,g)}function bi(g){return new kt(8,!0,g)}function gi(g){return new kt(16,!0,g)}var an=class extends Rn{constructor(t,n,i,s){super(t.span,s);this.layout=t,this.decoder=n,this.encoder=i}decode(t,n){return this.decoder(this.layout.decode(t,n))}encode(t,n,i){return this.layout.encode(this.encoder(t),n,i)}getSpan(t,n){return this.layout.getSpan(t,n)}};function te(g){return new an(Re(32),e=>new Er(e),e=>e.toBuffer(),g)}function Ie(g){return new an(di(),Dr,_r,g)}function Dr(g){if(g===0)return!1;if(g===1)return!0;throw new Error("Invalid bool: "+g)}function _r(g){return g?1:0}var Mn=class extends mi{decode(e,t){return super.decode(e,t)}};function J(g,e,t){return new Mn(g,e,t)}function le(g,e,t){let n,i=typeof e=="number"?e:yi(e)?e.toNumber():new Proxy(e,{get(s,r){if(!n){let o=Reflect.get(s,"count");n=yi(o)?o.toNumber():o,Reflect.set(s,"count",n)}return Reflect.get(s,r)},set(s,r,o){return r==="count"&&(n=o),Reflect.set(s,r,o)}});return pi(g,i,t)}import Zr from"bn.js";import xt from"decimal.js";import Fe from"bn.js";var me=new Fe(0),qe=new Fe(1),et=new Fe(-1),Ne=new Fe(1).shln(64),cn=new Fe(1).shln(128),On=Ne.sub(qe),Vt=64,wi=cn.subn(1),Be=-443636,Se=-Be,Ge=new Fe("4295048016"),Ue=new Fe("79226673521066979257578248091"),ol=new Fe("4295048017"),sl=new Fe("79226673521066979257578248090"),Pi=16,ki="59543866431248",Ti="184467440737095516",Ai="15793534762490258745",un=new Fe(10).pow(new Fe(6));var hi={tvl:0,volumeQuote:0,mintAmountA:0,mintAmountB:0,rewardDefaultInfos:[],farmUpcomingCount:0,farmOngoingCount:0,farmFinishedCount:0,day:{volume:0,volumeQuote:0,volumeFee:0,apr:0,feeApr:0,priceMin:0,priceMax:0,rewardApr:[0]},week:{volume:0,volumeQuote:0,volumeFee:0,apr:0,feeApr:0,priceMin:0,priceMax:0,rewardApr:[0]},month:{volume:0,volumeQuote:0,volumeFee:0,apr:0,feeApr:0,priceMin:0,priceMax:0,rewardApr:[0]},pooltype:[]},al=new Fe("18446744073700000000");import G from"bn.js";import He from"decimal.js";function ln(g){let e=new ArrayBuffer(4);return new DataView(e).setInt32(0,g,!1),new Uint8Array(e)}function Fn(g,e){let t=0;for(let n=g-1;n>=0&&!e.testn(n);n--)t++;return t}function En(g,e){let t=0;for(let n=0;n<g&&!e.testn(n);n++)t++;return t}function qt(g,e){for(let t=0;t<g;t++)if(e.testn(t))return!1;return!0}function xi(g,e){return qt(g,e)?null:Fn(g,e)}function Bi(g,e){return qt(g,e)?null:En(g,e)}var pl=Buffer.from("amm_config","utf8"),Wr=Buffer.from("pool","utf8"),vr=Buffer.from("pool_vault","utf8"),Vr=Buffer.from("pool_reward_vault","utf8"),Ii=Buffer.from("position","utf8"),qr=Buffer.from("tick_array","utf8"),Gr=Buffer.from("operation","utf8"),Ur=Buffer.from("pool_tick_array_bitmap_extension","utf8"),Xr=Buffer.from("observation","utf8");function Si(g,e,t,n){return xe([Wr,e.toBuffer(),t.toBuffer(),n.toBuffer()],g)}function Dn(g,e,t){return xe([vr,e.toBuffer(),t.toBuffer()],g)}function Ci(g,e,t){return xe([Vr,e.toBuffer(),t.toBuffer()],g)}function H(g,e,t){return xe([qr,e.toBuffer(),ln(t)],g)}function _e(g,e,t,n){return xe([Ii,e.toBuffer(),ln(t),ln(n)],g)}function Ce(g,e){return xe([Ii,e.toBuffer()],g)}function Gt(g){return xe([Buffer.from("metadata","utf8"),mt.toBuffer(),g.toBuffer()],mt)}function Ut(g){return xe([Gr],g)}function ge(g,e){return xe([Ur,e.toBuffer()],g)}function Ki(g,e){return xe([Xr,e.toBuffer()],g)}var Li=Buffer.from("locked_position","utf8");function _n(g,e){return xe([Li,e.toBuffer()],g)}function At(g,e){return xe([Li,e.toBuffer()],g)}var Hr=Buffer.from("support_mint","utf8");function Wn(g,e){return xe([Hr,e.toBuffer()],g)}import{PublicKey as Me}from"@solana/web3.js";import{TOKEN_2022_PROGRAM_ID as Ri}from"@solana/spl-token";import se from"bn.js";import j from"decimal.js";import Xe from"bn.js";import vn from"decimal.js";var Xt=class{static getfeeGrowthInside(e,t,n){let i=new Xe(0),s=new Xe(0);e.tickCurrent>=t.tick?(i=t.feeGrowthOutsideX64A,s=t.feeGrowthOutsideX64B):(i=e.feeGrowthGlobalX64A.sub(t.feeGrowthOutsideX64A),s=e.feeGrowthGlobalX64B.sub(t.feeGrowthOutsideX64B));let r=new Xe(0),o=new Xe(0);e.tickCurrent<n.tick?(r=n.feeGrowthOutsideX64A,o=n.feeGrowthOutsideX64B):(r=e.feeGrowthGlobalX64A.sub(n.feeGrowthOutsideX64A),o=e.feeGrowthGlobalX64B.sub(n.feeGrowthOutsideX64B));let a=W.wrappingSubU128(W.wrappingSubU128(e.feeGrowthGlobalX64A,i),r),c=W.wrappingSubU128(W.wrappingSubU128(e.feeGrowthGlobalX64B,s),o);return{feeGrowthInsideX64A:a,feeGrowthInsideBX64:c}}static GetPositionFees(e,t,n,i){let{feeGrowthInsideX64A:s,feeGrowthInsideBX64:r}=this.getfeeGrowthInside(e,n,i),o=W.mulDivFloor(W.wrappingSubU128(s,t.feeGrowthInsideLastX64A),t.liquidity,Ne),a=t.tokenFeesOwedA.add(o),c=W.mulDivFloor(W.wrappingSubU128(r,t.feeGrowthInsideLastX64B),t.liquidity,Ne),l=t.tokenFeesOwedB.add(c);return{tokenFeeAmountA:a,tokenFeeAmountB:l}}static GetPositionFeesV2(e,t,n,i){let{feeGrowthInsideX64A:s,feeGrowthInsideBX64:r}=this.getfeeGrowthInside(e,n,i),o=W.mulDivFloor(W.wrappingSubU128(s,t.feeGrowthInsideLastX64A),t.liquidity,Ne),a=t.tokenFeesOwedA.add(o),c=W.mulDivFloor(W.wrappingSubU128(r,t.feeGrowthInsideLastX64B),t.liquidity,Ne),l=t.tokenFeesOwedB.add(c);return{tokenFeeAmountA:a,tokenFeeAmountB:l}}static GetPositionRewardsV2(e,t,n,i){let s=[],r=this.getRewardGrowthInsideV2(e.tickCurrent,n,i,e.rewardInfos);for(let o=0;o<r.length;o++){let a=r[o],c=t.rewardInfos[o],l=W.wrappingSubU128(a,c.growthInsideLastX64),d=W.mulDivFloor(l,t.liquidity,Ne),f=c.rewardAmountOwed.add(d);s.push(f)}return s}static GetPositionRewards(e,t,n,i){let s=[],r=this.getRewardGrowthInside(e.tickCurrent,n,i,e.rewardInfos);for(let o=0;o<r.length;o++){let a=r[o],c=t.rewardInfos[o],l=W.wrappingSubU128(a,c.growthInsideLastX64),d=W.mulDivFloor(l,t.liquidity,Ne),f=c.rewardAmountOwed.add(d);s.push(f)}return s}static getRewardGrowthInside(e,t,n,i){let s=[];for(let r=0;r<i.length;r++){let o=new Xe(0);t.liquidityGross.eqn(0)?o=i[r].rewardGrowthGlobalX64:e<t.tick?o=i[r].rewardGrowthGlobalX64.sub(t.rewardGrowthsOutsideX64[r]):o=t.rewardGrowthsOutsideX64[r];let a=new Xe(0);n.liquidityGross.eqn(0)||(e<n.tick?a=n.rewardGrowthsOutsideX64[r]:a=i[r].rewardGrowthGlobalX64.sub(n.rewardGrowthsOutsideX64[r])),s.push(W.wrappingSubU128(W.wrappingSubU128(i[r].rewardGrowthGlobalX64,o),a))}return s}static getRewardGrowthInsideV2(e,t,n,i){let s=[];for(let r=0;r<i.length;r++){let o=new Xe(0);t.liquidityGross.eqn(0)?o=i[r].rewardGrowthGlobalX64:e<t.tick?o=i[r].rewardGrowthGlobalX64.sub(t.rewardGrowthsOutsideX64[r]):o=t.rewardGrowthsOutsideX64[r];let a=new Xe(0);n.liquidityGross.eqn(0)||(e<n.tick?a=n.rewardGrowthsOutsideX64[r]:a=i[r].rewardGrowthGlobalX64.sub(n.rewardGrowthsOutsideX64[r])),s.push(W.wrappingSubU128(W.wrappingSubU128(i[r].rewardGrowthGlobalX64,o),a))}return s}static getAmountsFromLiquidity({poolInfo:e,ownerPosition:t,liquidity:n,slippage:i,add:s,epochInfo:r}){var y,b,P,A;let o=_.priceToSqrtPriceX64(new vn(e.price),e.mintA.decimals,e.mintB.decimals),a=_.getSqrtPriceX64FromTick(t.tickLower),c=_.getSqrtPriceX64FromTick(t.tickUpper),l=s?1+i:1-i,d=Z.getAmountsFromLiquidity(o,a,c,n,s),[f,u]=[be(d.amountA,(y=e.mintA.extensions)==null?void 0:y.feeConfig,r,!0),be(d.amountB,(b=e.mintB.extensions)==null?void 0:b.feeConfig,r,!0)],[m,p]=[be(new Xe(new vn(d.amountA.toString()).mul(l).toFixed(0)),(P=e.mintA.extensions)==null?void 0:P.feeConfig,r,!0),be(new Xe(new vn(d.amountB.toString()).mul(l).toFixed(0)),(A=e.mintB.extensions)==null?void 0:A.feeConfig,r,!0)];return{liquidity:n,amountA:f,amountB:u,amountSlippageA:m,amountSlippageB:p,expirationTime:at(f.expirationTime,u.expirationTime)}}};var zr=15,z=class{static async getTickArrays(e,t,n,i,s,r,o){let a=[],c=M.getTickArrayStartIndexByTick(i,s),l=M.getInitializedTickArrayInRange(r,o,s,c,Math.floor(zr/2));for(let u=0;u<l.length;u++){let{publicKey:m}=H(t,n,l[u]);a.push(m)}let d=(await je(e,a)).map(u=>u!==null?Ht.decode(u.data):null),f={};for(let u=0;u<a.length;u++){let m=d[u];m!==null&&(f[m.startTickIndex]=U(O({},m),{address:a[u]}))}return f}static nextInitializedTick(e,t,n,i,s,r){let{initializedTick:o,tickArrayAddress:a,tickArrayStartTickIndex:c}=this.nextInitializedTickInOneArray(e,t,n,i,s,r);for(;o==null||o.liquidityGross.lten(0);){if(c=M.getNextTickArrayStartIndex(c,s,r),this.checkIsValidStartIndex(c,s))throw new Error("No enough initialized tickArray");let l=n[c];if(l===void 0)continue;let{nextTick:d,tickArrayAddress:f,tickArrayStartTickIndex:u}=this.firstInitializedTickInOneArray(e,t,l,r);[o,a,c]=[d,f,u]}if(o==null)throw new Error("No invaild tickArray cache");return{nextTick:o,tickArrayAddress:a,tickArrayStartTickIndex:c}}static nextInitializedTickArray(e,t,n,i,s){let r=Math.floor(e/z.tickCount(t)),o=n?M.searchLowBitFromStart(i,s,r-1,1,t):M.searchHightBitFromStart(i,s,r+1,1,t);return o.length>0?{isExist:!0,nextStartIndex:o[0]}:{isExist:!1,nextStartIndex:0}}static firstInitializedTickInOneArray(e,t,n,i){let s;if(i){let o=we-1;for(;o>=0;){let a=n.ticks[o];if(a.liquidityGross.gtn(0)){s=a;break}o=o-1}}else{let o=0;for(;o<we;){let a=n.ticks[o];if(a.liquidityGross.gtn(0)){s=a;break}o=o+1}}let{publicKey:r}=H(e,t,n.startTickIndex);return{nextTick:s,tickArrayAddress:r,tickArrayStartTickIndex:n.startTickIndex}}static nextInitializedTickInOneArray(e,t,n,i,s,r){let o=M.getTickArrayStartIndexByTick(i,s),a=Math.floor((i-o)/s),c=n[o];if(c==null)return{initializedTick:void 0,tickArrayAddress:void 0,tickArrayStartTickIndex:o};let l;if(r)for(;a>=0;){let f=c.ticks[a];if(f.liquidityGross.gtn(0)){l=f;break}a=a-1}else for(a=a+1;a<we;){let f=c.ticks[a];if(f.liquidityGross.gtn(0)){l=f;break}a=a+1}let{publicKey:d}=H(e,t,o);return{initializedTick:l,tickArrayAddress:d,tickArrayStartTickIndex:c.startTickIndex}}static getArrayStartIndex(e,t){let n=this.tickCount(t);return Math.floor(e/n)*n}static checkIsValidStartIndex(e,t){if(M.checkIsOutOfBoundary(e)){if(e>Se)return!1;let n=M.getTickArrayStartIndexByTick(Be,t);return e==n}return e%this.tickCount(t)==0}static tickCount(e){return we*e}};var Vn=14,tt=class{static maxTickInTickarrayBitmap(e){return e*we*ft}static getBitmapTickBoundary(e,t){let n=this.maxTickInTickarrayBitmap(t),i=Math.floor(Math.abs(e)/n);e<0&&Math.abs(e)%n!=0&&(i+=1);let s=n*i;return e<0?{minValue:-s,maxValue:-s+n}:{minValue:s,maxValue:s+n}}static nextInitializedTickArrayStartIndex(e,t,n,i){if(!z.checkIsValidStartIndex(t,n))throw Error("nextInitializedTickArrayStartIndex check error");let s=this.maxTickInTickarrayBitmap(n),r=i?t-z.tickCount(n):t+z.tickCount(n);if(r<-s||r>=s)return{isInit:!1,tickIndex:t};let o=n*we,a=r/o+512;r<0&&r%o!=0&&a--;let c=Math.abs(a);if(i){let l=e.shln(1024-c-1),d=xi(1024,l);if(d!==null){let f=(c-d-512)*o;return{isInit:!0,tickIndex:f}}else return{isInit:!1,tickIndex:-s}}else{let l=e.shrn(c),d=Bi(1024,l);if(d!==null){let f=(c+d-512)*o;return{isInit:!0,tickIndex:f}}else return{isInit:!1,tickIndex:s-z.tickCount(n)}}}},zt=class{static getBitmapOffset(e,t){if(!z.checkIsValidStartIndex(e,t))throw new Error("No enough initialized tickArray");this.checkExtensionBoundary(e,t);let n=tt.maxTickInTickarrayBitmap(t),i=Math.floor(Math.abs(e)/n)-1;return e<0&&Math.abs(e)%n===0&&i--,i}static getBitmap(e,t,n){let i=this.getBitmapOffset(e,t);return e<0?{offset:i,tickarrayBitmap:n.negativeTickArrayBitmap[i]}:{offset:i,tickarrayBitmap:n.positiveTickArrayBitmap[i]}}static checkExtensionBoundary(e,t){let{positiveTickBoundary:n,negativeTickBoundary:i}=this.extensionTickBoundary(t);if(e>=i&&e<n)throw Error("checkExtensionBoundary -> InvalidTickArrayBoundary")}static extensionTickBoundary(e){let t=tt.maxTickInTickarrayBitmap(e),n=-t;if(Se<=t)throw Error(`extensionTickBoundary check error: ${Se}, ${t}`);if(n<=Be)throw Error(`extensionTickBoundary check error: ${n}, ${Be}`);return{positiveTickBoundary:t,negativeTickBoundary:n}}static checkTickArrayIsInit(e,t,n){let{tickarrayBitmap:i}=this.getBitmap(e,t,n),s=this.tickArrayOffsetInBitmap(e,t);return{isInitialized:M.mergeTickArrayBitmap(i).testn(s),startIndex:e}}static nextInitializedTickArrayFromOneBitmap(e,t,n,i){let s=z.tickCount(t),r=n?e-s:e+s,{tickarrayBitmap:o}=this.getBitmap(r,t,i);return this.nextInitializedTickArrayInBitmap(o,r,t,n)}static nextInitializedTickArrayInBitmap(e,t,n,i){let{minValue:s,maxValue:r}=tt.getBitmapTickBoundary(t,n),o=this.tickArrayOffsetInBitmap(t,n);if(i){let a=M.mergeTickArrayBitmap(e).shln(ft-1-o),c=qt(512,a)?null:Fn(512,a);if(c!==null){let l=t-c*z.tickCount(n);return{isInit:!0,tickIndex:l}}else return{isInit:!1,tickIndex:s}}else{let a=M.mergeTickArrayBitmap(e).shrn(o),c=qt(512,a)?null:En(512,a);if(c!==null){let l=t+c*z.tickCount(n);return{isInit:!0,tickIndex:l}}else return{isInit:!1,tickIndex:r-z.tickCount(n)}}}static tickArrayOffsetInBitmap(e,t){let n=Math.abs(e)%tt.maxTickInTickarrayBitmap(t),i=Math.floor(n/z.tickCount(t));return e<0&&n!=0&&(i=ft-i),i}};var de=class{static getOutputAmountAndRemainAccounts(e,t,n,i,s,r=!1){let o=n.toBase58()===e.mintA.address,a=[],{isExist:c,startIndex:l,nextAccountMeta:d}=this.getFirstInitializedTickArray(e,o);if(!c||l===void 0||!d)throw new Error("Invalid tick array");a.push(d);let{allTrade:f,amountCalculated:u,accounts:m,sqrtPriceX64:p,feeAmount:y}=yt.swapCompute(e.programId,e.id,t,e.tickArrayBitmap,e.exBitmapInfo,o,e.ammConfig.tradeFeeRate,e.liquidity,e.tickCurrent,e.tickSpacing,e.sqrtPriceX64,i,l,s,r);return a.push(...m),{allTrade:f,expectedAmountOut:u.mul(et),remainingAccounts:a,executionPrice:p,feeAmount:y}}static getInputAmountAndRemainAccounts(e,t,n,i,s){let r=n.toBase58()===e.mintB.address,o=[],{isExist:a,startIndex:c,nextAccountMeta:l}=this.getFirstInitializedTickArray(e,r);if(!a||c===void 0||!l)throw new Error("Invalid tick array");try{let p=this.preInitializedTickArrayStartIndex(e,r);if(p.isExist){let{publicKey:y}=H(e.programId,e.id,p.nextStartIndex);o.push(y)}}catch{}o.push(l);let{amountCalculated:d,accounts:f,sqrtPriceX64:u,feeAmount:m}=yt.swapCompute(e.programId,e.id,t,e.tickArrayBitmap,e.exBitmapInfo,r,e.ammConfig.tradeFeeRate,e.liquidity,e.tickCurrent,e.tickSpacing,e.sqrtPriceX64,i.mul(et),c,s);return o.push(...f),{expectedAmountIn:d,remainingAccounts:o,executionPrice:u,feeAmount:m}}static getFirstInitializedTickArray(e,t){let{isInitialized:n,startIndex:i}=de.isOverflowDefaultTickarrayBitmap(e.tickSpacing,[e.tickCurrent])?zt.checkTickArrayIsInit(z.getArrayStartIndex(e.tickCurrent,e.tickSpacing),e.tickSpacing,e.exBitmapInfo):M.checkTickArrayIsInitialized(M.mergeTickArrayBitmap(e.tickArrayBitmap),e.tickCurrent,e.tickSpacing);if(n){let{publicKey:o}=H(e.programId,e.id,i);return{isExist:!0,startIndex:i,nextAccountMeta:o}}let{isExist:s,nextStartIndex:r}=this.nextInitializedTickArrayStartIndex(e,z.getArrayStartIndex(e.tickCurrent,e.tickSpacing),t);if(s){let{publicKey:o}=H(e.programId,e.id,r);return{isExist:!0,startIndex:r,nextAccountMeta:o}}return{isExist:!1,nextAccountMeta:void 0,startIndex:void 0}}static preInitializedTickArrayStartIndex(e,t){let n=Math.floor(e.tickCurrent/z.tickCount(e.tickSpacing)),i=t?M.searchHightBitFromStart(e.tickArrayBitmap,e.exBitmapInfo,n+1,1,e.tickSpacing):M.searchLowBitFromStart(e.tickArrayBitmap,e.exBitmapInfo,n-1,1,e.tickSpacing);return i.length>0?{isExist:!0,nextStartIndex:i[0]}:{isExist:!1,nextStartIndex:0}}static nextInitializedTickArrayStartIndex(e,t,n){for(t=z.getArrayStartIndex(e.tickCurrent,e.tickSpacing);;){let{isInit:i,tickIndex:s}=tt.nextInitializedTickArrayStartIndex(M.mergeTickArrayBitmap(e.tickArrayBitmap),t,e.tickSpacing,n);if(i)return{isExist:!0,nextStartIndex:s};t=s;let{isInit:r,tickIndex:o}=zt.nextInitializedTickArrayFromOneBitmap(t,e.tickSpacing,n,e.exBitmapInfo);if(r)return{isExist:!0,nextStartIndex:o};if(t=o,t<Be||t>Se)return{isExist:!1,nextStartIndex:0}}}static async updatePoolRewardInfos({connection:e,apiPoolInfo:t,chainTime:n,poolLiquidity:i,rewardInfos:s}){var o,a,c;let r=[];for(let l=0;l<s.length;l++){let d=s[l],f=(c=(o=t.rewardDefaultInfos[l])==null?void 0:o.mint.programId)!=null?c:(a=await e.getAccountInfo(d.tokenMint))==null?void 0:a.owner;if(f===void 0)throw Error("get new reward mint info error");let u=U(O({},d),{perSecond:W.x64ToDecimal(d.emissionsPerSecondX64),remainingRewards:void 0,tokenProgramId:new Me(f)});if(u.tokenMint.equals(Me.default))continue;if(n<=u.openTime.toNumber()||i.eq(me)){r.push(u);continue}let m=new se(Math.min(u.endTime.toNumber(),n)),p=m.sub(u.lastUpdateTime),y=W.mulDivFloor(p,u.emissionsPerSecondX64,i),b=u.rewardGrowthGlobalX64.add(y),P=W.mulDivFloor(p,u.emissionsPerSecondX64,Ne),A=u.rewardTotalEmissioned.add(P);r.push(U(O({},u),{rewardGrowthGlobalX64:b,rewardTotalEmissioned:A,lastUpdateTime:m}))}return r}static isOverflowDefaultTickarrayBitmap(e,t){let{maxTickBoundary:n,minTickBoundary:i}=this.tickRange(e);for(let s of t){let r=M.getTickArrayStartIndexByTick(s,e);if(r>=n||r<i)return!0}return!1}static tickRange(e){let t=tt.maxTickInTickarrayBitmap(e),n=-t;return t>Se&&(t=z.getArrayStartIndex(Se,e)+z.tickCount(e)),n<Be&&(n=z.getArrayStartIndex(Be,e)),{maxTickBoundary:t,minTickBoundary:n}}static get_tick_array_offset(e,t){if(!z.checkIsValidStartIndex(e,t))throw new Error("No enough initialized tickArray");return e/z.tickCount(t)*ft}static async fetchExBitmaps({connection:e,exBitmapAddress:t,batchRequest:n}){let i=await Ze(e,t.map(r=>({pubkey:r})),{batchRequest:n}),s={};for(let r of i)r.accountInfo!==null&&(s[r.pubkey.toString()]=Mi.decode(r.accountInfo.data));return s}static async fetchMultiplePoolTickArrays({connection:e,poolKeys:t,batchRequest:n}){let i={},s=[];for(let a of t){let c=M.getTickArrayStartIndexByTick(a.tickCurrent,a.tickSpacing),l=M.getInitializedTickArrayInRange(a.tickArrayBitmap,a.exBitmapInfo,a.tickSpacing,c,7);for(let d of l){let{publicKey:f}=H(a.programId,a.id,d);s.push({pubkey:f}),i[f.toString()]=a.id}}let r=await Ze(e,s,{batchRequest:n}),o={};for(let a of r){if(!a.accountInfo)continue;let c=i[a.pubkey.toString()];if(!c)continue;o[c.toString()]===void 0&&(o[c.toString()]={});let l=Ht.decode(a.accountInfo.data);o[c.toString()][l.startTickIndex]=U(O({},l),{address:a.pubkey})}return o}static async fetchPoolsAccountPosition({pools:e,connection:t,ownerInfo:n,batchRequest:i=!1,updateOwnerRewardAndFee:s=!0}){var o;let r=[];for(let a=0;a<e.length;a++){let c=e[a];c!==null&&(r.find(l=>l.equals(c.state.programId))||r.push(c.state.programId))}if(n){let a=n.tokenAccounts.map(f=>f.accountInfo.mint),c=[];for(let f of a)for(let u of r)c.push(Ce(u,f).publicKey);let l=await je(t,c,{batchRequest:i}),d={};for(let f of l){if(f===null)continue;let u=ht.decode(f.data),m=u.poolId.toString(),p=e.find(h=>h.state.id.toBase58()===m);if(p===void 0)continue;let y=p.state,b=M._getTickPriceLegacy({poolInfo:y,tick:u.tickLower,baseIn:!0}),P=M._getTickPriceLegacy({poolInfo:y,tick:u.tickUpper,baseIn:!0}),{amountA:A,amountB:T}=Z.getAmountsFromLiquidity(y.sqrtPriceX64,b.tickSqrtPriceX64,P.tickSqrtPriceX64,u.liquidity,!1),k=1/(1-Math.sqrt(Math.sqrt(b.price.div(P.price).toNumber())));p.positionAccount=[...(o=p.positionAccount)!=null?o:[],{poolId:u.poolId,nftMint:u.nftMint,priceLower:b.price,priceUpper:P.price,amountA:A,amountB:T,tickLower:u.tickLower,tickUpper:u.tickUpper,liquidity:u.liquidity,feeGrowthInsideLastX64A:u.feeGrowthInsideLastX64A,feeGrowthInsideLastX64B:u.feeGrowthInsideLastX64B,tokenFeesOwedA:u.tokenFeesOwedA,tokenFeesOwedB:u.tokenFeesOwedB,rewardInfos:u.rewardInfos.map(h=>U(O({},h),{pendingReward:new se(0)})),leverage:k,tokenFeeAmountA:new se(0),tokenFeeAmountB:new se(0)}];let w=await M.getTickArrayAddressByTick(p.state.programId,u.poolId,u.tickLower,p.state.tickSpacing),x=await M.getTickArrayAddressByTick(p.state.programId,u.poolId,u.tickUpper,p.state.tickSpacing);d[`${p.state.programId.toString()}-${u.poolId.toString()}-${u.tickLower}`]=w,d[`${p.state.programId.toString()}-${u.poolId.toString()}-${u.tickUpper}`]=x}if(s){let f=Object.values(d),u=await je(t,f,{batchRequest:i}),m={};for(let p=0;p<f.length;p++){let y=u[p];if(y===null)continue;let b=f[p].toString();m[b]=Ht.decode(y.data)}for(let{state:p,positionAccount:y}of e)if(!!y)for(let b of y){let P=`${p.programId.toString()}-${p.id.toString()}-${b.tickLower}`,A=`${p.programId.toString()}-${p.id.toString()}-${b.tickUpper}`,T=m[d[P].toString()],k=m[d[A].toString()],w=T.ticks[M.getTickOffsetInArray(b.tickLower,p.tickSpacing)],x=k.ticks[M.getTickOffsetInArray(b.tickUpper,p.tickSpacing)],{tokenFeeAmountA:h,tokenFeeAmountB:B}=await Xt.GetPositionFees(p,b,w,x),K=await Xt.GetPositionRewards(p,b,w,x);b.tokenFeeAmountA=h.gte(new se(0))?h:new se(0),b.tokenFeeAmountB=B.gte(new se(0))?B:new se(0);for(let L=0;L<K.length;L++)b.rewardInfos[L].pendingReward=K[L].gte(new se(0))?K[L]:new se(0)}}}return e}static computeAmountOut({poolInfo:e,tickArrayCache:t,baseMint:n,epochInfo:i,amountIn:s,slippage:r,priceLimit:o=new j(0),catchLiquidityInsufficient:a=!1}){var C;let c,l=n.toBase58()===e.mintA.address,[d,f]=l?[e.mintA.extensions.feeConfig,e.mintB.extensions.feeConfig]:[e.mintB.extensions.feeConfig,e.mintA.extensions.feeConfig];o.equals(new j(0))?c=l?Ge.add(new se(1)):Ue.sub(new se(1)):c=_.priceToSqrtPriceX64(o,e.mintA.decimals,e.mintB.decimals);let u=be(s,d,i,!1),{allTrade:m,expectedAmountOut:p,remainingAccounts:y,executionPrice:b,feeAmount:P}=de.getOutputAmountAndRemainAccounts(e,t,n,u.amount.sub((C=u.fee)!=null?C:me),c,a),A=be(p,f,i,!1),T=_.sqrtPriceX64ToPrice(b,e.mintA.decimals,e.mintB.decimals),k=l?T:new j(1).div(T),w=p.mul(new se(Math.floor((1-r)*1e10))).div(new se(1e10)),x=be(w,f,i,!1),h=l?e.currentPrice:new j(1).div(e.currentPrice),B=new j(k).sub(h).abs(),K=h,L=new ot(new j(B).mul(10**15).toFixed(0),new j(K).mul(10**15).toFixed(0));return{allTrade:m,realAmountIn:u,amountOut:A,minAmountOut:x,expirationTime:at(u.expirationTime,A.expirationTime),currentPrice:e.currentPrice,executionPrice:k,priceImpact:L,fee:P,remainingAccounts:y,executionPriceX64:b}}static computeAmountOutFormat({poolInfo:e,tickArrayCache:t,amountIn:n,tokenOut:i,slippage:s,epochInfo:r,catchLiquidityInsufficient:o=!1}){let a=i.address===e.mintB.address,[c,l]=a?[e.mintA,e.mintB]:[e.mintB,e.mintA],[d,f]=[new ve(U(O({},c),{mint:c.address,isToken2022:c.programId===Ri.toBase58()})),new ve(U(O({},l),{mint:l.address,isToken2022:l.programId===Ri.toBase58()}))],{allTrade:u,realAmountIn:m,amountOut:p,minAmountOut:y,expirationTime:b,currentPrice:P,executionPrice:A,priceImpact:T,fee:k,remainingAccounts:w,executionPriceX64:x}=de.computeAmountOut({poolInfo:e,tickArrayCache:t,baseMint:new Me(c.address),amountIn:n,slippage:s,epochInfo:r,catchLiquidityInsufficient:o}),h=U(O({},m),{amount:new Ae(d,m.amount),fee:m.fee===void 0?void 0:new Ae(d,m.fee)}),B=U(O({},p),{amount:new Ae(f,p.amount),fee:p.fee===void 0?void 0:new Ae(f,p.fee)}),K=U(O({},y),{amount:new Ae(f,y.amount),fee:y.fee===void 0?void 0:new Ae(f,y.fee)}),L=new Ee({baseToken:d,denominator:new se(10).pow(new se(20+d.decimals)),quoteToken:f,numerator:P.mul(new j(10**(20+f.decimals))).toFixed(0)}),C=new Ee({baseToken:d,denominator:new se(10).pow(new se(20+d.decimals)),quoteToken:f,numerator:A.mul(new j(10**(20+f.decimals))).toFixed(0)}),N=new Ae(d,k);return{allTrade:u,realAmountIn:h,amountOut:B,minAmountOut:K,expirationTime:b,currentPrice:L,executionPrice:C,priceImpact:T,fee:N,remainingAccounts:w,executionPriceX64:x}}static computeAmountIn({poolInfo:e,tickArrayCache:t,baseMint:n,epochInfo:i,amountOut:s,slippage:r,priceLimit:o=new j(0)}){var K;let a=n.toBase58()===e.mintA.address,c={[e.mintA.address]:e.mintA.extensions.feeConfig,[e.mintB.address]:e.mintB.extensions.feeConfig},l;o.equals(new j(0))?l=a?Ue.sub(new se(1)):Ge.add(new se(1)):l=_.priceToSqrtPriceX64(o,e.mintA.decimals,e.mintB.decimals);let d=be(s,c[n.toString()],i,!0),{expectedAmountIn:f,remainingAccounts:u,executionPrice:m,feeAmount:p}=de.getInputAmountAndRemainAccounts(e,t,n,d.amount.sub((K=d.fee)!=null?K:me),l),y=a?e.mintB.address:e.mintA.address,b=be(f,c[y],i,!1),P=_.sqrtPriceX64ToPrice(m,e.mintA.decimals,e.mintB.decimals),A=a?P:new j(1).div(P),T=f.mul(new se(Math.floor((1+r)*1e10))).div(new se(1e10)),k=be(T,c[y],i,!0),w=a?e.currentPrice:new j(1).div(e.currentPrice),x=new j(A).sub(w).abs(),h=w,B=new ot(new j(x).mul(10**15).toFixed(0),new j(h).mul(10**15).toFixed(0));return{amountIn:b,maxAmountIn:k,realAmountOut:d,expirationTime:at(b.expirationTime,d.expirationTime),currentPrice:e.currentPrice,executionPrice:A,priceImpact:B,fee:p,remainingAccounts:u}}static estimateAprsForPriceRangeMultiplier({poolInfo:e,aprType:t,positionTickLowerIndex:n,positionTickUpperIndex:i}){var m,p,y;let s=e[t],r=M.getTickPrice({poolInfo:e,tick:n,baseIn:!0}).price.toNumber(),o=M.getTickPrice({poolInfo:e,tick:i,baseIn:!0}).price.toNumber(),a=Math.max(r,s.priceMin),l=Math.min(o,s.priceMax)-a,d=o-r,f=s.priceMax-s.priceMin,u;return l<=0?u=0:d===l?u=f/l:f===l?u=l/d:u=l/f*(l/d),{feeApr:s.feeApr*u,rewardsApr:[((m=s.rewardApr[0])!=null?m:0)*u,((p=s.rewardApr[1])!=null?p:0)*u,((y=s.rewardApr[2])!=null?y:0)*u],apr:s.apr*u}}static estimateAprsForPriceRangeDelta({poolInfo:e,poolLiquidity:t,aprType:n,mintPrice:i,liquidity:s,positionTickLowerIndex:r,positionTickUpperIndex:o,chainTime:a}){let c=n==="day"?1:n==="week"?7:n==="month"?30:0,l=e[n],d=i[lt(e.mintA.address).toString()],f=i[lt(e.mintB.address).toString()],u=e.mintA.decimals,m=e.mintB.decimals;if(!l||!d||!f)return{feeApr:0,rewardsApr:[0,0,0],apr:0};let p=_.priceToSqrtPriceX64(new j(e.price),e.mintA.decimals,e.mintB.decimals),y=_.getSqrtPriceX64FromTick(r),b=_.getSqrtPriceX64FromTick(o),{amountSlippageA:P,amountSlippageB:A}=Z.getAmountsFromLiquidityWithSlippage(p,y,b,t,!1,!1,0),{amountSlippageA:T,amountSlippageB:k}=Z.getAmountsFromLiquidityWithSlippage(p,y,b,s,!1,!1,0),w=new j(P.toString()).div(new j(10).pow(u)).mul(d.value).add(new j(A.toString()).div(new j(10).pow(m)).mul(f.value)),x=new j(T.toString()).div(new j(10).pow(u)).mul(d.value).add(new j(k.toString()).div(new j(10).pow(m)).mul(f.value)),h=new j(1).div(w.add(x)),K=new j(l.volumeFee).mul(365).div(c).mul(h).mul(100).toNumber(),L=3600*24*365,C=e.rewardDefaultInfos.map(N=>{var v,ce;let I=N.mint.decimals,F=i[N.mint.address];return a<((v=N.startTime)!=null?v:0)||a>((ce=N.endTime)!=null?ce:0)||!N.perSecond||!F||I===void 0?0:new j(F.value).mul(new j(N.perSecond).mul(L)).div(new j(10).pow(I)).mul(h).mul(100).toNumber()});return{feeApr:K,rewardsApr:C,apr:K+C.reduce((N,I)=>N+I,0)}}static async getLiquidityAmountOutFromAmountIn({poolInfo:e,inputA:t,tickLower:n,tickUpper:i,amount:s,slippage:r,add:o,epochInfo:a,amountHasFee:c}){var b,P;let l=_.priceToSqrtPriceX64(new j(e.price),e.mintA.decimals,e.mintB.decimals),d=_.getSqrtPriceX64FromTick(n),f=_.getSqrtPriceX64FromTick(i),u=be(s,(b=e[t?"mintA":"mintB"].extensions)==null?void 0:b.feeConfig,a,!c),m=new se(new j(u.amount.sub((P=u.fee)!=null?P:me).toString()).toFixed(0)),p;if(l.lte(d))p=t?Z.getLiquidityFromTokenAmountA(d,f,m,!o):new se(0);else if(l.lte(f)){let A=Z.getLiquidityFromTokenAmountA(l,f,m,!o),T=Z.getLiquidityFromTokenAmountB(d,l,m);p=t?A:T}else p=t?new se(0):Z.getLiquidityFromTokenAmountB(d,f,m);let y=await de.getAmountsFromLiquidity({epochInfo:a,poolInfo:e,tickLower:n,tickUpper:i,liquidity:p,slippage:r,add:o});return{liquidity:p,amountA:t?u:y.amountA,amountB:t?y.amountB:u,amountSlippageA:t?u:y.amountSlippageA,amountSlippageB:t?y.amountSlippageB:u,expirationTime:y.expirationTime}}static async getAmountsFromLiquidity({epochInfo:e,poolInfo:t,tickLower:n,tickUpper:i,liquidity:s,slippage:r,add:o}){var y,b,P,A;let a=_.getSqrtPriceX64FromTick(n),c=_.getSqrtPriceX64FromTick(i),l=o?1+r:1-r,d=Z.getAmountsFromLiquidity(_.priceToSqrtPriceX64(new j(t.price),t.mintA.decimals,t.mintB.decimals),a,c,s,o),[f,u]=[be(d.amountA,(y=t.mintA.extensions)==null?void 0:y.feeConfig,e,!0),be(d.amountB,(b=t.mintB.extensions)==null?void 0:b.feeConfig,e,!0)],[m,p]=[be(d.amountA.muln(l),(P=t.mintA.extensions)==null?void 0:P.feeConfig,e,!0),be(d.amountB.muln(l),(A=t.mintB.extensions)==null?void 0:A.feeConfig,e,!0)];return{liquidity:s,amountA:f,amountB:u,amountSlippageA:m,amountSlippageB:p,expirationTime:at(f.expirationTime,u.expirationTime)}}static async fetchComputeMultipleClmmInfo({connection:e,poolList:t,rpcDataMap:n={}}){let i=t.filter(a=>!n[a.id]).map(a=>new Me(a.id));(await je(e,i)).forEach((a,c)=>{!a||(n[i[c].toBase58()]=mn.decode(a.data))});let r=t.map(a=>ge(new Me(a.programId),new Me(a.id)).publicKey),o=await de.fetchExBitmaps({connection:e,exBitmapAddress:r,batchRequest:!1});return t.reduce((a,c)=>U(O({},a),{[c.id]:U(O({},n[c.id]),{id:new Me(c.id),version:6,programId:new Me(c.programId),mintA:c.mintA,mintB:c.mintB,ammConfig:U(O({},c.config),{id:new Me(c.config.id),fundOwner:""}),currentPrice:new j(c.price),exBitmapAccount:ge(new Me(c.programId),new Me(c.id)).publicKey,exBitmapInfo:o[ge(new Me(c.programId),new Me(c.id)).publicKey.toBase58()],startTime:n[c.id].startTime.toNumber(),rewardInfos:n[c.id].rewardInfos})}),{})}static async fetchComputeClmmInfo({connection:e,poolInfo:t,rpcData:n}){return(await this.fetchComputeMultipleClmmInfo({connection:e,rpcDataMap:n?{[t.id]:n}:void 0,poolList:[t]}))[t.id]}};var qn={volume:0,volumeQuote:0,volumeFee:0,apr:0,feeApr:0,priceMin:0,priceMax:0,rewardApr:[]};function Ni(g){return U(O({},g),{type:"Concentrated",programId:g.programId.toString(),id:g.id.toString(),rewardDefaultInfos:[],rewardDefaultPoolInfos:"Clmm",price:g.currentPrice.toNumber(),mintAmountA:0,mintAmountB:0,feeRate:g.ammConfig.tradeFeeRate,openTime:g.startTime.toString(),tvl:0,day:qn,week:qn,month:qn,pooltype:[],farmUpcomingCount:0,farmOngoingCount:0,farmFinishedCount:0,burnPercent:0,config:U(O({},g.ammConfig),{id:g.ammConfig.id.toString(),defaultRange:0,defaultRangePoint:[]})})}var W=class{static mulDivRoundingUp(e,t,n){let i=e.mul(t),s=i.div(n);return i.mod(n).eq(me)||(s=s.add(qe)),s}static mulDivFloor(e,t,n){if(n.eq(me))throw new Error("division by 0");return e.mul(t).div(n)}static mulDivCeil(e,t,n){if(n.eq(me))throw new Error("division by 0");return e.mul(t).add(n.sub(qe)).div(n)}static x64ToDecimal(e,t){return new He(e.toString()).div(He.pow(2,64)).toDecimalPlaces(t)}static decimalToX64(e){return new G(e.mul(He.pow(2,64)).floor().toFixed())}static wrappingSubU128(e,t){return e.add(cn).sub(t).mod(cn)}};function ke(g,e){return Gn(g.mul(e),64,256)}function jr(g,e,t){let n=g.toTwos(t).shln(e);return n.imaskn(t+1),n.fromTwos(t)}function Gn(g,e,t){let n=g.toTwos(t).shrn(e);return n.imaskn(t-e+1),n.fromTwos(t-e)}var _=class{static sqrtPriceX64ToPrice(e,t,n){return W.x64ToDecimal(e).pow(2).mul(He.pow(10,t-n))}static priceToSqrtPriceX64(e,t,n){return W.decimalToX64(e.mul(He.pow(10,n-t)).sqrt())}static getNextSqrtPriceX64FromInput(e,t,n,i){if(!e.gt(me))throw new Error("sqrtPriceX64 must greater than 0");if(!t.gt(me))throw new Error("liquidity must greater than 0");return i?this.getNextSqrtPriceFromTokenAmountARoundingUp(e,t,n,!0):this.getNextSqrtPriceFromTokenAmountBRoundingDown(e,t,n,!0)}static getNextSqrtPriceX64FromOutput(e,t,n,i){if(!e.gt(me))throw new Error("sqrtPriceX64 must greater than 0");if(!t.gt(me))throw new Error("liquidity must greater than 0");return i?this.getNextSqrtPriceFromTokenAmountBRoundingDown(e,t,n,!1):this.getNextSqrtPriceFromTokenAmountARoundingUp(e,t,n,!1)}static getNextSqrtPriceFromTokenAmountARoundingUp(e,t,n,i){if(n.eq(me))return e;let s=t.shln(Vt);if(i){let r=s,o=s.add(n.mul(e));return o.gte(r)?W.mulDivCeil(r,e,o):W.mulDivRoundingUp(r,qe,r.div(e).add(n))}else{let r=n.mul(e);if(!s.gt(r))throw new Error("getNextSqrtPriceFromTokenAmountARoundingUp,liquidityLeftShift must gt amountMulSqrtPrice");let o=s.sub(r);return W.mulDivCeil(s,e,o)}}static getNextSqrtPriceFromTokenAmountBRoundingDown(e,t,n,i){let s=n.shln(Vt);if(i)return e.add(s.div(t));{let r=W.mulDivRoundingUp(s,qe,t);if(!e.gt(r))throw new Error("getNextSqrtPriceFromTokenAmountBRoundingDown sqrtPriceX64 must gt amountDivLiquidity");return e.sub(r)}}static getSqrtPriceX64FromTick(e){if(!Number.isInteger(e))throw new Error("tick must be integer");if(e<Be||e>Se)throw new Error("tick must be in MIN_TICK and MAX_TICK");let t=e<0?e*-1:e,n=(t&1)!=0?new G("18445821805675395072"):new G("18446744073709551616");return(t&2)!=0&&(n=ke(n,new G("18444899583751176192"))),(t&4)!=0&&(n=ke(n,new G("18443055278223355904"))),(t&8)!=0&&(n=ke(n,new G("18439367220385607680"))),(t&16)!=0&&(n=ke(n,new G("18431993317065453568"))),(t&32)!=0&&(n=ke(n,new G("18417254355718170624"))),(t&64)!=0&&(n=ke(n,new G("18387811781193609216"))),(t&128)!=0&&(n=ke(n,new G("18329067761203558400"))),(t&256)!=0&&(n=ke(n,new G("18212142134806163456"))),(t&512)!=0&&(n=ke(n,new G("17980523815641700352"))),(t&1024)!=0&&(n=ke(n,new G("17526086738831433728"))),(t&2048)!=0&&(n=ke(n,new G("16651378430235570176"))),(t&4096)!=0&&(n=ke(n,new G("15030750278694412288"))),(t&8192)!=0&&(n=ke(n,new G("12247334978884435968"))),(t&16384)!=0&&(n=ke(n,new G("8131365268886854656"))),(t&32768)!=0&&(n=ke(n,new G("3584323654725218816"))),(t&65536)!=0&&(n=ke(n,new G("696457651848324352"))),(t&131072)!=0&&(n=ke(n,new G("26294789957507116"))),(t&262144)!=0&&(n=ke(n,new G("37481735321082"))),e>0&&(n=wi.div(n)),n}static getTickFromPrice(e,t,n){return _.getTickFromSqrtPriceX64(_.priceToSqrtPriceX64(e,t,n))}static getTickFromSqrtPriceX64(e){if(e.gt(Ue)||e.lt(Ge))throw new Error("Provided sqrtPrice is not within the supported sqrtPrice range.");let t=e.bitLength()-1,n=new G(t-64),i=jr(n,32,128),s=new G("8000000000000000","hex"),r=0,o=new G(0),a=t>=64?e.shrn(t-63):e.shln(63-t);for(;s.gt(new G(0))&&r<Pi;){a=a.mul(a);let m=a.shrn(127);a=a.shrn(63+m.toNumber()),o=o.add(s.mul(m)),s=s.shrn(1),r+=1}let c=o.shrn(32),d=i.add(c).mul(new G(ki)),f=Gn(d.sub(new G(Ti)),64,128).toNumber(),u=Gn(d.add(new G(Ai)),64,128).toNumber();return f==u?f:_.getSqrtPriceX64FromTick(u).lte(e)?u:f}},bt=class{static getTickWithPriceAndTickspacing(e,t,n,i){let r=_.getTickFromSqrtPriceX64(_.priceToSqrtPriceX64(e,n,i))/t;return r<0?r=Math.floor(r):r=Math.ceil(r),r*t}static roundPriceWithTickspacing(e,t,n,i){let s=bt.getTickWithPriceAndTickspacing(e,t,n,i),r=_.getSqrtPriceX64FromTick(s);return _.sqrtPriceX64ToPrice(r,n,i)}},Z=class{static addDelta(e,t){return e.add(t)}static getTokenAmountAFromLiquidity(e,t,n,i){if(e.gt(t)&&([e,t]=[t,e]),!e.gt(me))throw new Error("sqrtPriceX64A must greater than 0");let s=n.ushln(Vt),r=t.sub(e);return i?W.mulDivRoundingUp(W.mulDivCeil(s,r,t),qe,e):W.mulDivFloor(s,r,t).div(e)}static getTokenAmountBFromLiquidity(e,t,n,i){if(e.gt(t)&&([e,t]=[t,e]),!e.gt(me))throw new Error("sqrtPriceX64A must greater than 0");return i?W.mulDivCeil(n,t.sub(e),Ne):W.mulDivFloor(n,t.sub(e),Ne)}static getLiquidityFromTokenAmountA(e,t,n,i){e.gt(t)&&([e,t]=[t,e]);let s=n.mul(e).mul(t),r=t.sub(e),o=s.div(r);return i?W.mulDivRoundingUp(o,qe,On):o.shrn(Vt)}static getLiquidityFromTokenAmountB(e,t,n){return e.gt(t)&&([e,t]=[t,e]),W.mulDivFloor(n,On,t.sub(e))}static getLiquidityFromTokenAmounts(e,t,n,i,s){if(t.gt(n)&&([t,n]=[n,t]),e.lte(t))return Z.getLiquidityFromTokenAmountA(t,n,i,!1);if(e.lt(n)){let r=Z.getLiquidityFromTokenAmountA(e,n,i,!1),o=Z.getLiquidityFromTokenAmountB(t,e,s);return r.lt(o)?r:o}else return Z.getLiquidityFromTokenAmountB(t,n,s)}static getAmountsFromLiquidity(e,t,n,i,s){if(t.gt(n)&&([t,n]=[n,t]),e.lte(t))return{amountA:Z.getTokenAmountAFromLiquidity(t,n,i,s),amountB:new G(0)};if(e.lt(n)){let r=Z.getTokenAmountAFromLiquidity(e,n,i,s),o=Z.getTokenAmountBFromLiquidity(t,e,i,s);return{amountA:r,amountB:o}}else return{amountA:new G(0),amountB:Z.getTokenAmountBFromLiquidity(t,n,i,s)}}static getAmountsFromLiquidityWithSlippage(e,t,n,i,s,r,o){let{amountA:a,amountB:c}=Z.getAmountsFromLiquidity(e,t,n,i,r),l=s?1+o:1-o,d=new G(new He(a.toString()).mul(l).toFixed(0)),f=new G(new He(c.toString()).mul(l).toFixed(0));return{amountSlippageA:d,amountSlippageB:f}}static getAmountsOutFromLiquidity({poolInfo:e,tickLower:t,tickUpper:n,liquidity:i,slippage:s,add:r,epochInfo:o,amountAddFee:a}){var P,A,T,k;let c=_.priceToSqrtPriceX64(new He(e.price),e.mintA.decimals,e.mintB.decimals),l=_.getSqrtPriceX64FromTick(t),d=_.getSqrtPriceX64FromTick(n),f=r?1+s:1-s,u=Z.getAmountsFromLiquidity(c,l,d,i,r),[m,p]=[be(u.amountA,(P=e.mintA.extensions)==null?void 0:P.feeConfig,o,a),be(u.amountB,(A=e.mintB.extensions)==null?void 0:A.feeConfig,o,a)],[y,b]=[be(new G(new He(u.amountA.toString()).mul(f).toFixed(0)),(T=e.mintA.extensions)==null?void 0:T.feeConfig,o,a),be(new G(new He(u.amountB.toString()).mul(f).toFixed(0)),(k=e.mintB.extensions)==null?void 0:k.feeConfig,o,a)];return{liquidity:i,amountA:m,amountB:p,amountSlippageA:y,amountSlippageB:b,expirationTime:at(m.expirationTime,p.expirationTime)}}},yt=class{static swapCompute(e,t,n,i,s,r,o,a,c,l,d,f,u,m,p=!1){if(f.eq(me))throw new Error("amountSpecified must not be 0");if(m||(m=r?Ge.add(qe):Ue.sub(qe)),r){if(m.lt(Ge))throw new Error("sqrtPriceX64 must greater than MIN_SQRT_PRICE_X64");if(m.gte(d))throw new Error("sqrtPriceX64 must smaller than current")}else{if(m.gt(Ue))throw new Error("sqrtPriceX64 must smaller than MAX_SQRT_PRICE_X64");if(m.lte(d))throw new Error("sqrtPriceX64 must greater than current")}let y=f.gt(me),b={amountSpecifiedRemaining:f,amountCalculated:me,sqrtPriceX64:d,tick:c>u?Math.min(u+z.tickCount(l)-1,c):u,accounts:[],liquidity:a,feeAmount:new G(0)},P=u,A=n[u],T=0,k=!r&&A.startTickIndex===b.tick;for(;!b.amountSpecifiedRemaining.eq(me)&&!b.sqrtPriceX64.eq(m);){T>10;let w={};w.sqrtPriceStartX64=b.sqrtPriceX64;let x=M.nextInitTick(A,b.tick,l,r,k),h=x||null,B=null;if(!(h!=null&&h.liquidityGross.gtn(0))){let L=de.nextInitializedTickArrayStartIndex({tickCurrent:b.tick,tickSpacing:l,tickArrayBitmap:i,exBitmapInfo:s},P,r);if(!L.isExist){if(p)return{allTrade:!1,amountSpecifiedRemaining:b.amountSpecifiedRemaining,amountCalculated:b.amountCalculated,feeAmount:b.feeAmount,sqrtPriceX64:b.sqrtPriceX64,liquidity:b.liquidity,tickCurrent:b.tick,accounts:b.accounts};throw Error("swapCompute LiquidityInsufficient")}P=L.nextStartIndex;let{publicKey:C}=H(e,t,P);B=C,A=n[P];try{h=M.firstInitializedTick(A,r)}catch{throw Error("not found next tick info")}}w.tickNext=h.tick,w.initialized=h.liquidityGross.gtn(0),u!==P&&B&&(b.accounts.push(B),u=P),w.tickNext<Be?w.tickNext=Be:w.tickNext>Se&&(w.tickNext=Se),w.sqrtPriceNextX64=_.getSqrtPriceX64FromTick(w.tickNext);let K;if(r&&w.sqrtPriceNextX64.lt(m)||!r&&w.sqrtPriceNextX64.gt(m)?K=m:K=w.sqrtPriceNextX64,[b.sqrtPriceX64,w.amountIn,w.amountOut,w.feeAmount]=yt.swapStepCompute(b.sqrtPriceX64,K,b.liquidity,b.amountSpecifiedRemaining,o,r),b.feeAmount=b.feeAmount.add(w.feeAmount),y?(b.amountSpecifiedRemaining=b.amountSpecifiedRemaining.sub(w.amountIn.add(w.feeAmount)),b.amountCalculated=b.amountCalculated.sub(w.amountOut)):(b.amountSpecifiedRemaining=b.amountSpecifiedRemaining.add(w.amountOut),b.amountCalculated=b.amountCalculated.add(w.amountIn.add(w.feeAmount))),b.sqrtPriceX64.eq(w.sqrtPriceNextX64)){if(w.initialized){let L=h.liquidityNet;r&&(L=L.mul(et)),b.liquidity=Z.addDelta(b.liquidity,L)}k=w.tickNext!=b.tick&&!r&&A.startTickIndex===w.tickNext,b.tick=r?w.tickNext-1:w.tickNext}else if(b.sqrtPriceX64!=w.sqrtPriceStartX64){let L=_.getTickFromSqrtPriceX64(b.sqrtPriceX64);k=L!=b.tick&&!r&&A.startTickIndex===L,b.tick=L}++T}try{let{nextStartIndex:w,isExist:x}=z.nextInitializedTickArray(b.tick,l,r,i,s);x&&u!==w&&(b.accounts.push(H(e,t,w).publicKey),u=w)}catch{}return{allTrade:!0,amountSpecifiedRemaining:me,amountCalculated:b.amountCalculated,feeAmount:b.feeAmount,sqrtPriceX64:b.sqrtPriceX64,liquidity:b.liquidity,tickCurrent:b.tick,accounts:b.accounts}}static swapStepCompute(e,t,n,i,s,r){let o={sqrtPriceX64Next:new G(0),amountIn:new G(0),amountOut:new G(0),feeAmount:new G(0)},a=i.gte(me);if(a){let l=W.mulDivFloor(i,un.sub(new G(s.toString())),un);o.amountIn=r?Z.getTokenAmountAFromLiquidity(t,e,n,!0):Z.getTokenAmountBFromLiquidity(e,t,n,!0),l.gte(o.amountIn)?o.sqrtPriceX64Next=t:o.sqrtPriceX64Next=_.getNextSqrtPriceX64FromInput(e,n,l,r)}else o.amountOut=r?Z.getTokenAmountBFromLiquidity(t,e,n,!1):Z.getTokenAmountAFromLiquidity(e,t,n,!1),i.mul(et).gte(o.amountOut)?o.sqrtPriceX64Next=t:o.sqrtPriceX64Next=_.getNextSqrtPriceX64FromOutput(e,n,i.mul(et),r);let c=t.eq(o.sqrtPriceX64Next);return r?(c&&a||(o.amountIn=Z.getTokenAmountAFromLiquidity(o.sqrtPriceX64Next,e,n,!0)),c&&!a||(o.amountOut=Z.getTokenAmountBFromLiquidity(o.sqrtPriceX64Next,e,n,!1))):(o.amountIn=c&&a?o.amountIn:Z.getTokenAmountBFromLiquidity(e,o.sqrtPriceX64Next,n,!0),o.amountOut=c&&!a?o.amountOut:Z.getTokenAmountAFromLiquidity(e,o.sqrtPriceX64Next,n,!1)),!a&&o.amountOut.gt(i.mul(et))&&(o.amountOut=i.mul(et)),a&&!o.sqrtPriceX64Next.eq(t)?o.feeAmount=i.sub(o.amountIn):o.feeAmount=W.mulDivCeil(o.amountIn,new G(s),un.sub(new G(s))),[o.sqrtPriceX64Next,o.amountIn,o.amountOut,o.feeAmount]}};var we=60,ft=512,M=class{static getTickArrayAddressByTick(e,t,n,i){let s=M.getTickArrayStartIndexByTick(n,i),{publicKey:r}=H(e,t,s);return r}static getTickOffsetInArray(e,t){if(e%t!=0)throw new Error("tickIndex % tickSpacing not equal 0");let n=M.getTickArrayStartIndexByTick(e,t),i=Math.floor((e-n)/t);if(i<0||i>=we)throw new Error("tick offset in array overflow");return i}static getTickArrayBitIndex(e,t){let n=z.tickCount(t),i=e/n;return e<0&&e%n!=0?i=Math.ceil(i)-1:i=Math.floor(i),i}static getTickArrayStartIndexByTick(e,t){return this.getTickArrayBitIndex(e,t)*z.tickCount(t)}static getTickArrayOffsetInBitmapByTick(e,t){let n=t*we,i=Math.floor(e/n)+512;return Math.abs(i)}static checkTickArrayIsInitialized(e,t,n){let i=n*we,s=Math.floor(t/i)+512,r=Math.abs(s);return{isInitialized:e.testn(r),startIndex:(r-512)*i}}static getNextTickArrayStartIndex(e,t,n){return n?e-t*we:e+t*we}static mergeTickArrayBitmap(e){let t=new Zr(0);for(let n=0;n<e.length;n++)t=t.add(e[n].shln(64*n));return t}static getInitializedTickArrayInRange(e,t,n,i,s){let r=Math.floor(i/(n*we));return[...M.searchLowBitFromStart(e,t,r-1,s,n),...M.searchHightBitFromStart(e,t,r,s,n)]}static getAllInitializedTickArrayStartIndex(e,t,n){return M.searchHightBitFromStart(e,t,-7680,ft,n)}static getAllInitializedTickArrayInfo(e,t,n,i,s){let r=[],o=M.getAllInitializedTickArrayStartIndex(n,i,s);for(let a of o){let{publicKey:c}=H(e,t,a);r.push({tickArrayStartIndex:a,tickArrayAddress:c})}return r}static getAllInitializedTickInTickArray(e){return e.ticks.filter(t=>t.liquidityGross.gtn(0))}static searchLowBitFromStart(e,t,n,i,s){let r=[...[...t.negativeTickArrayBitmap].reverse(),e.slice(0,8),e.slice(8,16),...t.positiveTickArrayBitmap].map(c=>M.mergeTickArrayBitmap(c)),o=[];for(;n>=-7680;){let c=Math.floor((n+7680)/512),l=(n+7680)%512;if(r[c].testn(l)&&o.push(n),n--,o.length===i)break}let a=z.tickCount(s);return o.map(c=>c*a)}static searchHightBitFromStart(e,t,n,i,s){let r=[...[...t.negativeTickArrayBitmap].reverse(),e.slice(0,8),e.slice(8,16),...t.positiveTickArrayBitmap].map(c=>M.mergeTickArrayBitmap(c)),o=[];for(;n<7680;){let c=Math.floor((n+7680)/512),l=(n+7680)%512;if(r[c].testn(l)&&o.push(n),n++,o.length===i)break}let a=z.tickCount(s);return o.map(c=>c*a)}static checkIsOutOfBoundary(e){return e<Be||e>Se}static nextInitTick(e,t,n,i,s){if(z.getArrayStartIndex(t,n)!=e.startTickIndex)return null;let o=Math.floor((t-e.startTickIndex)/n);if(i)for(;o>=0;){if(e.ticks[o].liquidityGross.gtn(0))return e.ticks[o];o=o-1}else for(s||(o=o+1);o<we;){if(e.ticks[o].liquidityGross.gtn(0))return e.ticks[o];o=o+1}return null}static firstInitializedTick(e,t){if(t){let n=we-1;for(;n>=0;){if(e.ticks[n].liquidityGross.gtn(0))return e.ticks[n];n=n-1}}else{let n=0;for(;n<we;){if(e.ticks[n].liquidityGross.gtn(0))return e.ticks[n];n=n+1}}throw Error(`firstInitializedTick check error: ${e} - ${t}`)}static _getTickPriceLegacy({poolInfo:e,tick:t,baseIn:n}){let i=_.getSqrtPriceX64FromTick(t),s=_.sqrtPriceX64ToPrice(i,e.mintA.decimals,e.mintB.decimals);return n?{tick:t,price:s,tickSqrtPriceX64:i}:{tick:t,price:new xt(1).div(s),tickSqrtPriceX64:i}}static _getPriceAndTickLegacy({poolInfo:e,price:t,baseIn:n}){let i=n?t:new xt(1).div(t),s=bt.getTickWithPriceAndTickspacing(i,e.ammConfig.tickSpacing,e.mintA.decimals,e.mintB.decimals),r=_.getSqrtPriceX64FromTick(s),o=_.sqrtPriceX64ToPrice(r,e.mintA.decimals,e.mintB.decimals);return n?{tick:s,price:o}:{tick:s,price:new xt(1).div(o)}}static getTickPrice({poolInfo:e,tick:t,baseIn:n}){let i=_.getSqrtPriceX64FromTick(t),s=_.sqrtPriceX64ToPrice(i,e.mintA.decimals,e.mintB.decimals);return n?{tick:t,price:s,tickSqrtPriceX64:i}:{tick:t,price:new xt(1).div(s),tickSqrtPriceX64:i}}static getPriceAndTick({poolInfo:e,price:t,baseIn:n}){let i=n?t:new xt(1).div(t),s=bt.getTickWithPriceAndTickspacing(i,e.config.tickSpacing,e.mintA.decimals,e.mintB.decimals),r=_.getSqrtPriceX64FromTick(s),o=_.sqrtPriceX64ToPrice(r,e.mintA.decimals,e.mintB.decimals);return n?{tick:s,price:o}:{tick:s,price:new xt(1).div(o)}}};var Oi=J([Re(8),fe("bump"),vt("index"),te(""),Tt("protocolFeeRate"),Tt("tradeFeeRate"),vt("tickSpacing"),le(E(),8,"")]),Qr=J([Tt("blockTimestamp"),bi("tickCumulative"),le(E(),4)]),Fi=J([Re(8),Ie("initialized"),E("recentEpoch"),vt("observationIndex"),te("poolId"),le(Qr,100,"observations"),le(E(),4)]),Yr=J([fe("rewardState"),E("openTime"),E("endTime"),E("lastUpdateTime"),X("emissionsPerSecondX64"),E("rewardTotalEmissioned"),E("rewardClaimed"),te("tokenMint"),te("tokenVault"),te("creator"),X("rewardGrowthGlobalX64")]),mn=J([Re(8),fe("bump"),te("ammConfig"),te("creator"),te("mintA"),te("mintB"),te("vaultA"),te("vaultB"),te("observationId"),fe("mintDecimalsA"),fe("mintDecimalsB"),vt("tickSpacing"),X("liquidity"),X("sqrtPriceX64"),oe("tickCurrent"),Tt(),X("feeGrowthGlobalX64A"),X("feeGrowthGlobalX64B"),E("protocolFeesTokenA"),E("protocolFeesTokenB"),X("swapInAmountTokenA"),X("swapOutAmountTokenB"),X("swapInAmountTokenB"),X("swapOutAmountTokenA"),fe("status"),le(fe(),7,""),le(Yr,3,"rewardInfos"),le(E(),16,"tickArrayBitmap"),E("totalFeesTokenA"),E("totalFeesClaimedTokenA"),E("totalFeesTokenB"),E("totalFeesClaimedTokenB"),E("fundFeesTokenA"),E("fundFeesTokenB"),E("startTime"),le(E(),15*4-3,"padding")]),Jr=J([X("growthInsideLastX64"),E("rewardAmountOwed")]),ht=J([Re(8),fe("bump"),te("nftMint"),te("poolId"),oe("tickLower"),oe("tickUpper"),X("liquidity"),X("feeGrowthInsideLastX64A"),X("feeGrowthInsideLastX64B"),E("tokenFeesOwedA"),E("tokenFeesOwedB"),le(Jr,3,"rewardInfos"),le(E(),8,"")]),Tm=J([Re(8),fe("bump"),te("poolId"),oe("tickLowerIndex"),oe("tickUpperIndex"),X("liquidity"),X("feeGrowthInsideLastX64A"),X("feeGrowthInsideLastX64B"),E("tokenFeesOwedA"),E("tokenFeesOwedB"),le(X(),3,"rewardGrowthInside"),le(E(),8,"")]),$r=J([oe("tick"),gi("liquidityNet"),X("liquidityGross"),X("feeGrowthOutsideX64A"),X("feeGrowthOutsideX64B"),le(X(),3,"rewardGrowthsOutsideX64"),le(Tt(),13,"")]),Ht=J([Re(8),te("poolId"),oe("startTickIndex"),le($r,we,"ticks"),fe("initializedTickCount"),le(fe(),115,"")]),Ei=J([Re(329),le(te(),100,"whitelistMints")]),Mi=J([Re(8),te("poolId"),le(le(E(),8),Vn,"positiveTickArrayBitmap"),le(le(E(),8),Vn,"negativeTickArrayBitmap")]),Am=J([E(),fe("bump"),te("owner"),te("poolId"),te("positionId"),te("nftAccount"),le(E(),8)]),Di=J([Re(8),fe("bump"),te("lockOwner"),te("poolId"),te("positionId"),te("nftAccount"),te("lockNftMint"),E("recentEpoch"),le(E(),8)]);Fi.span;var _i=Te("Raydium_Clmm"),Oe={createPool:[233,146,209,142,207,104,64,188],initReward:[95,135,192,196,242,129,230,68],setRewardEmissions:[112,52,167,75,32,201,211,137],openPosition:[77,184,74,214,112,86,241,199],openPositionWithTokenEx:[77,255,174,82,125,29,201,46],closePosition:[123,134,81,0,49,68,98,98],increaseLiquidity:[133,29,89,223,69,238,176,10],decreaseLiquidity:[58,127,188,62,79,82,196,96],swap:[43,4,237,11,26,201,30,98],collectReward:[18,237,166,197,34,16,213,144]},Wi=[188,37,179,131,82,150,84,73],vi=[16,72,250,198,14,162,212,19],ae=class{static createPoolInstruction(e,t,n,i,s,r,o,a,c,l,d,f,u,m){let p=J([X("sqrtPriceX64"),E("zero")]),y=[{pubkey:n,isSigner:!0,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!1},{pubkey:c,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:f,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!1},{pubkey:d,isSigner:!1,isWritable:!1},{pubkey:nt.programId,isSigner:!1,isWritable:!1},{pubkey:rt,isSigner:!1,isWritable:!1},...(m==null?void 0:m.map(A=>({pubkey:A,isSigner:!1,isWritable:!1})))||[]],b=Buffer.alloc(p.span);p.encode({sqrtPriceX64:u,zero:me},b);let P=Buffer.from([...Oe.createPool,...b]);return new he({keys:y,programId:e,data:P})}static async createPoolInstructions(e){let{programId:t,owner:n,mintA:i,mintB:s,ammConfigId:r,initialPriceX64:o,extendMintAccount:a}=e,[c,l]=[new S(i.address),new S(s.address)],{publicKey:d}=Si(t,r,c,l),{publicKey:f}=Ki(t,d),{publicKey:u}=Dn(t,d,c),{publicKey:m}=Dn(t,d,l),p=ge(t,d).publicKey,y=[this.createPoolInstruction(t,d,n,r,f,c,u,new S(i.programId||ee),l,m,new S(s.programId||ee),p,o,a)];return{signers:[],instructions:y,instructionTypes:[ie.CreateAccount,ie.ClmmCreatePool],address:{poolId:d,observationId:f,exBitmapAccount:p,mintAVault:u,mintBVault:m},lookupTableAddress:[]}}static openPositionFromLiquidityInstruction(e,t,n,i,s,r,o,a,c,l,d,f,u,m,p,y,b,P,A,T,k,w,x,h,B,K){let L=J([oe("tickLowerIndex"),oe("tickUpperIndex"),oe("tickArrayLowerStartIndex"),oe("tickArrayUpperStartIndex"),X("liquidity"),E("amountMaxA"),E("amountMaxB"),Ie("withMetadata"),fe("optionBaseFlag"),Ie("baseFlag")]),C=[...K?[{pubkey:K,isSigner:!1,isWritable:!0}]:[]],N=[{pubkey:t,isSigner:!0,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!1},{pubkey:s,isSigner:!0,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:d,isSigner:!1,isWritable:!0},{pubkey:f,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:m,isSigner:!1,isWritable:!0},{pubkey:p,isSigner:!1,isWritable:!0},{pubkey:rt,isSigner:!1,isWritable:!1},{pubkey:nt.programId,isSigner:!1,isWritable:!1},{pubkey:ee,isSigner:!1,isWritable:!1},{pubkey:jt,isSigner:!1,isWritable:!1},{pubkey:mt,isSigner:!1,isWritable:!1},{pubkey:ye,isSigner:!1,isWritable:!1},{pubkey:y,isSigner:!1,isWritable:!1},{pubkey:b,isSigner:!1,isWritable:!1},...C],I=Buffer.alloc(L.span);L.encode({tickLowerIndex:P,tickUpperIndex:A,tickArrayLowerStartIndex:T,tickArrayUpperStartIndex:k,liquidity:w,amountMaxA:x,amountMaxB:h,withMetadata:B==="create",baseFlag:!1,optionBaseFlag:0},I);let F=Buffer.from([...Oe.openPosition,...I]);return new he({keys:N,programId:e,data:F})}static openPositionFromLiquidityInstruction22(e,t,n,i,s,r,o,a,c,l,d,f,u,m,p,y,b,P,A,T,k,w,x,h,B){let K=J([oe("tickLowerIndex"),oe("tickUpperIndex"),oe("tickArrayLowerStartIndex"),oe("tickArrayUpperStartIndex"),X("liquidity"),E("amountMaxA"),E("amountMaxB"),Ie("withMetadata"),fe("optionBaseFlag"),Ie("baseFlag")]),L=[...B?[{pubkey:B,isSigner:!1,isWritable:!0}]:[]],C=[{pubkey:t,isSigner:!0,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!1},{pubkey:s,isSigner:!0,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:d,isSigner:!1,isWritable:!0},{pubkey:f,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:m,isSigner:!1,isWritable:!0},{pubkey:rt,isSigner:!1,isWritable:!1},{pubkey:nt.programId,isSigner:!1,isWritable:!1},{pubkey:ee,isSigner:!1,isWritable:!1},{pubkey:jt,isSigner:!1,isWritable:!1},{pubkey:ye,isSigner:!1,isWritable:!1},{pubkey:p,isSigner:!1,isWritable:!1},{pubkey:y,isSigner:!1,isWritable:!1},...L],N=Buffer.alloc(K.span);K.encode({tickLowerIndex:b,tickUpperIndex:P,tickArrayLowerStartIndex:A,tickArrayUpperStartIndex:T,liquidity:k,amountMaxA:w,amountMaxB:x,withMetadata:h==="create",baseFlag:!1,optionBaseFlag:0},N);let I=Buffer.from([...Oe.openPositionWithTokenEx,...N]);return new he({keys:C,programId:e,data:I})}static async openPositionInstructions({poolInfo:e,poolKeys:t,ownerInfo:n,tickLower:i,tickUpper:s,liquidity:r,amountMaxA:o,amountMaxB:a,withMetadata:c,getEphemeralSigners:l,nft2022:d}){let f=[],[u,m]=[new S(e.programId),new S(e.id)],p;if(l)p=new S((await l(1))[0]);else{let B=dn.generate();f.push(B),p=B.publicKey}let y=M.getTickArrayStartIndexByTick(i,e.config.tickSpacing),b=M.getTickArrayStartIndexByTick(s,e.config.tickSpacing),{publicKey:P}=H(u,m,y),{publicKey:A}=H(u,m,b),{publicKey:T}=d?re(n.wallet,p,ye):re(n.wallet,p,ee),{publicKey:k}=Gt(p),{publicKey:w}=Ce(u,p),{publicKey:x}=_e(u,m,i,s),h=d?this.openPositionFromLiquidityInstruction22(u,n.feePayer,m,n.wallet,p,T,x,P,A,w,n.tokenAccountA,n.tokenAccountB,new S(t.vault.A),new S(t.vault.B),new S(e.mintA.address),new S(e.mintB.address),i,s,y,b,r,o,a,c,de.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing,[y,b])?ge(u,m).publicKey:void 0):this.openPositionFromLiquidityInstruction(u,n.feePayer,m,n.wallet,p,T,k,x,P,A,w,n.tokenAccountA,n.tokenAccountB,new S(t.vault.A),new S(t.vault.B),new S(e.mintA.address),new S(e.mintB.address),i,s,y,b,r,o,a,c,de.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing,[y,b])?ge(u,m).publicKey:void 0);return{signers:f,instructions:[h],instructionTypes:[ie.ClmmOpenPosition],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[],address:{nftMint:p,tickArrayLower:P,tickArrayUpper:A,positionNftAccount:T,metadataAccount:k,personalPosition:w,protocolPosition:x}}}static async openPositionFromBaseInstructions({poolInfo:e,poolKeys:t,ownerInfo:n,tickLower:i,tickUpper:s,base:r,baseAmount:o,otherAmountMax:a,withMetadata:c,getEphemeralSigners:l,nft2022:d}){let f=[],[u,m]=[new S(e.programId),new S(e.id)],p;if(l)p=new S((await l(1))[0]);else{let B=dn.generate();f.push(B),p=B.publicKey}let y=M.getTickArrayStartIndexByTick(i,e.config.tickSpacing),b=M.getTickArrayStartIndexByTick(s,e.config.tickSpacing),{publicKey:P}=H(u,m,y),{publicKey:A}=H(u,m,b),{publicKey:T}=d?re(n.wallet,p,ye):re(n.wallet,p,ee),{publicKey:k}=Gt(p),{publicKey:w}=Ce(u,p),{publicKey:x}=_e(u,m,i,s),h=d?this.openPositionFromBaseInstruction22(u,n.feePayer,m,n.wallet,p,T,x,P,A,w,n.tokenAccountA,n.tokenAccountB,new S(t.vault.A),new S(t.vault.B),new S(e.mintA.address),new S(e.mintB.address),i,s,y,b,c,r,o,a,de.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing,[y,b])?ge(u,m).publicKey:void 0):this.openPositionFromBaseInstruction(u,n.feePayer,m,n.wallet,p,T,k,x,P,A,w,n.tokenAccountA,n.tokenAccountB,new S(t.vault.A),new S(t.vault.B),new S(e.mintA.address),new S(e.mintB.address),i,s,y,b,c,r,o,a,de.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing,[y,b])?ge(u,m).publicKey:void 0);return{address:{nftMint:p,tickArrayLower:P,tickArrayUpper:A,positionNftAccount:T,metadataAccount:k,personalPosition:w,protocolPosition:x},instructions:[h],signers:f,instructionTypes:[ie.ClmmOpenPosition],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[]}}static openPositionFromBaseInstruction(e,t,n,i,s,r,o,a,c,l,d,f,u,m,p,y,b,P,A,T,k,w,x,h,B,K){let L=J([oe("tickLowerIndex"),oe("tickUpperIndex"),oe("tickArrayLowerStartIndex"),oe("tickArrayUpperStartIndex"),X("liquidity"),E("amountMaxA"),E("amountMaxB"),Ie("withMetadata"),fe("optionBaseFlag"),Ie("baseFlag")]),C=[...K?[{pubkey:K,isSigner:!1,isWritable:!0}]:[]],N=[{pubkey:t,isSigner:!0,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!1},{pubkey:s,isSigner:!0,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:d,isSigner:!1,isWritable:!0},{pubkey:f,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:m,isSigner:!1,isWritable:!0},{pubkey:p,isSigner:!1,isWritable:!0},{pubkey:rt,isSigner:!1,isWritable:!1},{pubkey:nt.programId,isSigner:!1,isWritable:!1},{pubkey:ee,isSigner:!1,isWritable:!1},{pubkey:jt,isSigner:!1,isWritable:!1},{pubkey:mt,isSigner:!1,isWritable:!1},{pubkey:ye,isSigner:!1,isWritable:!1},{pubkey:y,isSigner:!1,isWritable:!1},{pubkey:b,isSigner:!1,isWritable:!1},...C],I=Buffer.alloc(L.span);L.encode({tickLowerIndex:P,tickUpperIndex:A,tickArrayLowerStartIndex:T,tickArrayUpperStartIndex:k,liquidity:new Un(0),amountMaxA:x==="MintA"?h:B,amountMaxB:x==="MintA"?B:h,withMetadata:w==="create",baseFlag:x==="MintA",optionBaseFlag:1},I);let F=Buffer.from([...Oe.openPosition,...I]);return new he({keys:N,programId:e,data:F})}static openPositionFromBaseInstruction22(e,t,n,i,s,r,o,a,c,l,d,f,u,m,p,y,b,P,A,T,k,w,x,h,B){let K=J([oe("tickLowerIndex"),oe("tickUpperIndex"),oe("tickArrayLowerStartIndex"),oe("tickArrayUpperStartIndex"),X("liquidity"),E("amountMaxA"),E("amountMaxB"),Ie("withMetadata"),fe("optionBaseFlag"),Ie("baseFlag")]),L=[...B?[{pubkey:B,isSigner:!1,isWritable:!0}]:[]],C=[{pubkey:t,isSigner:!0,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!1},{pubkey:s,isSigner:!0,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:d,isSigner:!1,isWritable:!0},{pubkey:f,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:m,isSigner:!1,isWritable:!0},{pubkey:rt,isSigner:!1,isWritable:!1},{pubkey:nt.programId,isSigner:!1,isWritable:!1},{pubkey:ee,isSigner:!1,isWritable:!1},{pubkey:jt,isSigner:!1,isWritable:!1},{pubkey:ye,isSigner:!1,isWritable:!1},{pubkey:p,isSigner:!1,isWritable:!1},{pubkey:y,isSigner:!1,isWritable:!1},...L],N=Buffer.alloc(K.span);K.encode({tickLowerIndex:b,tickUpperIndex:P,tickArrayLowerStartIndex:A,tickArrayUpperStartIndex:T,liquidity:new Un(0),amountMaxA:w==="MintA"?x:h,amountMaxB:w==="MintA"?h:x,withMetadata:k==="create",baseFlag:w==="MintA",optionBaseFlag:1},N);let I=Buffer.from([...Oe.openPositionWithTokenEx,...N]);return new he({keys:C,programId:e,data:I})}static async openPositionFromLiquidityInstructions({poolInfo:e,poolKeys:t,ownerInfo:n,tickLower:i,tickUpper:s,liquidity:r,amountMaxA:o,amountMaxB:a,withMetadata:c,getEphemeralSigners:l,nft2022:d}){let f,u=[];if(l)f=new S((await l(1))[0]);else{let B=dn.generate();u.push(B),f=B.publicKey}let[m,p]=[new S(e.programId),new S(e.id)],y=M.getTickArrayStartIndexByTick(i,e.config.tickSpacing),b=M.getTickArrayStartIndexByTick(s,e.config.tickSpacing),{publicKey:P}=H(m,p,y),{publicKey:A}=H(m,p,b),{publicKey:T}=d?re(n.wallet,f,ye):re(n.wallet,f,ee),{publicKey:k}=Gt(f),{publicKey:w}=Ce(m,f),{publicKey:x}=_e(m,p,i,s),h=d?this.openPositionFromLiquidityInstruction22(m,n.wallet,p,n.wallet,f,T,x,P,A,w,n.tokenAccountA,n.tokenAccountB,new S(t.vault.A),new S(t.vault.B),new S(t.mintA.address),new S(t.mintB.address),i,s,y,b,r,o,a,c,de.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing,[y,b])?ge(m,p).publicKey:void 0):this.openPositionFromLiquidityInstruction(m,n.wallet,p,n.wallet,f,T,k,x,P,A,w,n.tokenAccountA,n.tokenAccountB,new S(t.vault.A),new S(t.vault.B),new S(t.mintA.address),new S(t.mintB.address),i,s,y,b,r,o,a,c,de.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing,[y,b])?ge(m,p).publicKey:void 0);return{address:{nftMint:f,tickArrayLower:P,tickArrayUpper:A,positionNftAccount:T,metadataAccount:k,personalPosition:w,protocolPosition:x},instructions:[h],signers:u,instructionTypes:[ie.ClmmOpenPosition],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[]}}static closePositionInstruction(e,t,n,i,s,r){let o=J([]),a=[{pubkey:t,isSigner:!0,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:nt.programId,isSigner:!1,isWritable:!1},{pubkey:r?ye:ee,isSigner:!1,isWritable:!1}],c=Buffer.alloc(o.span);o.encode({},c);let l=Buffer.from([...Oe.closePosition,...c]);return new he({keys:a,programId:e,data:l})}static closePositionInstructions({poolInfo:e,poolKeys:t,ownerInfo:n,ownerPosition:i,nft2022:s}){let r=new S(e.programId),o=s?re(n.wallet,i.nftMint,ye).publicKey:re(n.wallet,i.nftMint,ee).publicKey,{publicKey:a}=Ce(r,i.nftMint),c=[];return c.push(this.closePositionInstruction(r,n.wallet,i.nftMint,o,a,s)),{address:{positionNftAccount:o,personalPosition:a},signers:[],instructions:c,instructionTypes:[ie.ClmmClosePosition],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[]}}static increasePositionFromLiquidityInstruction(e,t,n,i,s,r,o,a,c,l,d,f,u,m,p,y,b,P){let A=J([X("liquidity"),E("amountMaxA"),E("amountMaxB"),fe("optionBaseFlag"),Ie("baseFlag")]),T=[...P?[{pubkey:P,isSigner:!1,isWritable:!0}]:[]],k=[{pubkey:t,isSigner:!0,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:d,isSigner:!1,isWritable:!0},{pubkey:f,isSigner:!1,isWritable:!0},{pubkey:ee,isSigner:!1,isWritable:!1},{pubkey:ye,isSigner:!1,isWritable:!1},{pubkey:u,isSigner:!1,isWritable:!1},{pubkey:m,isSigner:!1,isWritable:!1},...T],w=Buffer.alloc(A.span);A.encode({liquidity:p,amountMaxA:y,amountMaxB:b,optionBaseFlag:0,baseFlag:!1},w);let x=Buffer.from([...Oe.increaseLiquidity,...w]);return new he({keys:k,programId:e,data:x})}static increasePositionFromLiquidityInstructions({poolInfo:e,poolKeys:t,ownerPosition:n,ownerInfo:i,liquidity:s,amountMaxA:r,amountMaxB:o,nft2022:a}){let[c,l]=[new S(e.programId),new S(e.id)],d=M.getTickArrayStartIndexByTick(n.tickLower,e.config.tickSpacing),f=M.getTickArrayStartIndexByTick(n.tickUpper,e.config.tickSpacing),{publicKey:u}=H(c,l,d),{publicKey:m}=H(c,l,f),{publicKey:p}=a?re(i.wallet,n.nftMint,ye):re(i.wallet,n.nftMint,ee),{publicKey:y}=Ce(c,n.nftMint),{publicKey:b}=_e(c,l,n.tickLower,n.tickUpper),P=this.increasePositionFromLiquidityInstruction(c,i.wallet,p,y,l,b,u,m,i.tokenAccountA,i.tokenAccountB,new S(t.vault.A),new S(t.vault.B),new S(e.mintA.address),new S(e.mintB.address),s,r,o,de.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing,[d,f])?ge(c,l).publicKey:void 0);return{address:{tickArrayLower:u,tickArrayUpper:m,positionNftAccount:p,personalPosition:y,protocolPosition:b},signers:[],instructions:[P],instructionTypes:[ie.ClmmIncreasePosition],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[]}}static increasePositionFromBaseInstructions({poolInfo:e,poolKeys:t,ownerPosition:n,ownerInfo:i,base:s,baseAmount:r,otherAmountMax:o,nft2022:a}){let[c,l]=[new S(e.programId),new S(e.id)],d=M.getTickArrayStartIndexByTick(n.tickLower,e.config.tickSpacing),f=M.getTickArrayStartIndexByTick(n.tickUpper,e.config.tickSpacing),{publicKey:u}=H(c,l,d),{publicKey:m}=H(c,l,f),{publicKey:p}=a?re(i.wallet,n.nftMint,ye):re(i.wallet,n.nftMint,ee),{publicKey:y}=Ce(c,n.nftMint),{publicKey:b}=_e(c,l,n.tickLower,n.tickUpper);return{address:{tickArrayLower:u,tickArrayUpper:m,positionNftAccount:p,personalPosition:y,protocolPosition:b},instructions:[this.increasePositionFromBaseInstruction(c,i.wallet,p,y,l,b,u,m,i.tokenAccountA,i.tokenAccountB,new S(t.vault.A),new S(t.vault.B),new S(e.mintA.address),new S(e.mintB.address),s,r,o,de.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing,[d,f])?ge(c,l).publicKey:void 0)],signers:[],instructionTypes:[ie.ClmmIncreasePosition],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[]}}static increasePositionFromBaseInstruction(e,t,n,i,s,r,o,a,c,l,d,f,u,m,p,y,b,P){let A=J([X("liquidity"),E("amountMaxA"),E("amountMaxB"),fe("optionBaseFlag"),Ie("baseFlag")]),T=[...P?[{pubkey:P,isSigner:!1,isWritable:!0}]:[]],k=[{pubkey:t,isSigner:!0,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:d,isSigner:!1,isWritable:!0},{pubkey:f,isSigner:!1,isWritable:!0},{pubkey:ee,isSigner:!1,isWritable:!1},{pubkey:ye,isSigner:!1,isWritable:!1},{pubkey:u,isSigner:!1,isWritable:!1},{pubkey:m,isSigner:!1,isWritable:!1},...T],w=Buffer.alloc(A.span);A.encode({liquidity:new Un(0),amountMaxA:p==="MintA"?y:b,amountMaxB:p==="MintA"?b:y,baseFlag:p==="MintA",optionBaseFlag:1},w);let x=Buffer.from([...Oe.increaseLiquidity,...w]);return new he({keys:k,programId:e,data:x})}static decreaseLiquidityInstruction(e,t,n,i,s,r,o,a,c,l,d,f,u,m,p,y,b,P,A){let T=J([X("liquidity"),E("amountMinA"),E("amountMinB")]),k=[...A?[{pubkey:A,isSigner:!1,isWritable:!0}]:[],...p.map(B=>[{pubkey:B.poolRewardVault,isSigner:!1,isWritable:!0},{pubkey:B.ownerRewardVault,isSigner:!1,isWritable:!0},{pubkey:B.rewardMint,isSigner:!1,isWritable:!1}]).flat()],w=[{pubkey:t,isSigner:!0,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:d,isSigner:!1,isWritable:!0},{pubkey:f,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:ee,isSigner:!1,isWritable:!1},{pubkey:ye,isSigner:!1,isWritable:!1},{pubkey:en,isSigner:!1,isWritable:!1},{pubkey:u,isSigner:!1,isWritable:!1},{pubkey:m,isSigner:!1,isWritable:!1},...k],x=Buffer.alloc(T.span);T.encode({liquidity:y,amountMinA:b,amountMinB:P},x);let h=Buffer.from([...Oe.decreaseLiquidity,...x]);return new he({keys:w,programId:e,data:h})}static decreaseLiquidityInstructions({poolInfo:e,poolKeys:t,ownerPosition:n,ownerInfo:i,liquidity:s,amountMinA:r,amountMinB:o,programId:a,nft2022:c}){let[l,d]=[new S(e.programId),new S(e.id)],f=M.getTickArrayStartIndexByTick(n.tickLower,e.config.tickSpacing),u=M.getTickArrayStartIndexByTick(n.tickUpper,e.config.tickSpacing),{publicKey:m}=H(l,d,f),{publicKey:p}=H(l,d,u),{publicKey:y}=c?re(i.wallet,n.nftMint,ye):re(i.wallet,n.nftMint,a),{publicKey:b}=Ce(l,n.nftMint),{publicKey:P}=_e(l,d,n.tickLower,n.tickUpper),A=[];for(let w=0;w<e.rewardDefaultInfos.length;w++)A.push({poolRewardVault:new S(t.rewardInfos[w].vault),ownerRewardVault:i.rewardAccounts[w],rewardMint:new S(e.rewardDefaultInfos[w].mint.address)});let T=[],k=this.decreaseLiquidityInstruction(l,i.wallet,y,b,d,P,m,p,i.tokenAccountA,i.tokenAccountB,new S(t.vault.A),new S(t.vault.B),new S(e.mintA.address),new S(e.mintB.address),A,s,r,o,de.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing,[f,u])?ge(l,d).publicKey:void 0);return T.push(k),{address:{tickArrayLower:m,tickArrayUpper:p,positionNftAccount:y,personalPosition:b,protocolPosition:P},signers:[],instructions:T,instructionTypes:[ie.ClmmDecreasePosition],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[]}}static swapInstruction(e,t,n,i,s,r,o,a,c,l,d,f,u,m,p,y,b){let P=J([E("amount"),E("otherAmountThreshold"),X("sqrtPriceLimitX64"),Ie("isBaseInput")]),A=[...b?[{pubkey:b,isSigner:!1,isWritable:!0}]:[],...d.map(x=>({pubkey:x,isSigner:!1,isWritable:!0}))],T=[{pubkey:t,isSigner:!0,isWritable:!1},{pubkey:i,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:f,isSigner:!1,isWritable:!0},{pubkey:ee,isSigner:!1,isWritable:!1},{pubkey:ye,isSigner:!1,isWritable:!1},{pubkey:en,isSigner:!1,isWritable:!1},{pubkey:c,isSigner:!1,isWritable:!1},{pubkey:l,isSigner:!1,isWritable:!1},...A],k=Buffer.alloc(P.span);P.encode({amount:u,otherAmountThreshold:m,sqrtPriceLimitX64:p,isBaseInput:y},k);let w=Buffer.from([...Oe.swap,...k]);return new he({keys:T,programId:e,data:w})}static makeSwapBaseInInstructions({poolInfo:e,poolKeys:t,observationId:n,ownerInfo:i,inputMint:s,amountIn:r,amountOutMin:o,sqrtPriceLimitX64:a,remainingAccounts:c}){let[l,d]=[new S(e.programId),new S(e.id)],[f,u]=[new S(t.vault.A),new S(t.vault.B)],[m,p]=[new S(e.mintA.address),new S(e.mintB.address)],y=e.mintA.address===s.toString(),b=[this.swapInstruction(l,i.wallet,d,new S(e.config.id),y?i.tokenAccountA:i.tokenAccountB,y?i.tokenAccountB:i.tokenAccountA,y?f:u,y?u:f,y?m:p,y?p:m,c,n,r,o,a,!0,ge(l,d).publicKey)];return{signers:[],instructions:b,instructionTypes:[ie.ClmmSwapBaseIn],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[],address:{}}}static makeSwapBaseOutInstructions({poolInfo:e,poolKeys:t,observationId:n,ownerInfo:i,outputMint:s,amountOut:r,amountInMax:o,sqrtPriceLimitX64:a,remainingAccounts:c}){let[l,d]=[new S(e.programId),new S(e.id)],[f,u]=[new S(t.vault.A),new S(t.vault.B)],[m,p]=[new S(e.mintA.address),new S(e.mintB.address)],y=e.mintA.address===s.toBase58(),b=[this.swapInstruction(l,i.wallet,d,new S(e.config.id),y?i.tokenAccountB:i.tokenAccountA,y?i.tokenAccountA:i.tokenAccountB,y?u:f,y?f:u,y?p:m,y?m:p,c,n,r,o,a,!1,ge(l,d).publicKey)];return{signers:[],instructions:b,instructionTypes:[ie.ClmmSwapBaseOut],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[],address:{}}}static initRewardInstruction(e,t,n,i,s,r,o,a,c,l,d,f){let u=J([E("openTime"),E("endTime"),X("emissionsPerSecondX64")]),m=[{pubkey:t,isSigner:!0,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!1},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:nt.programId,isSigner:!1,isWritable:!1},{pubkey:rt,isSigner:!1,isWritable:!1}],p=Buffer.alloc(u.span);u.encode({openTime:Pe(l),endTime:Pe(d),emissionsPerSecondX64:f},p);let y=Buffer.from([...Oe.initReward,...p]);return new he({keys:m,programId:e,data:y})}static initRewardInstructions({poolInfo:e,poolKeys:t,ownerInfo:n,rewardInfo:i}){let[s,r]=[new S(e.programId),new S(e.id)],o=Ci(s,r,i.mint).publicKey,a=Ut(s).publicKey,c=[this.initRewardInstruction(s,n.wallet,r,a,new S(e.config.id),n.tokenAccount,i.programId,i.mint,o,i.openTime,i.endTime,i.emissionsPerSecondX64)];return{address:{poolRewardVault:o,operationId:a},signers:[],instructions:c,instructionTypes:[ie.ClmmInitReward],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[]}}static setRewardInstruction(e,t,n,i,s,r,o,a,c,l,d,f){let u=J([fe("rewardIndex"),X("emissionsPerSecondX64"),E("openTime"),E("endTime")]),m=[{pubkey:t,isSigner:!0,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:ee,isSigner:!1,isWritable:!1},{pubkey:ye,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0}],p=Buffer.alloc(u.span);u.encode({rewardIndex:c,emissionsPerSecondX64:f,openTime:Pe(l),endTime:Pe(d)},p);let y=Buffer.from([...Oe.setRewardEmissions,...p]);return new he({keys:m,programId:e,data:y})}static setRewardInstructions({poolInfo:e,poolKeys:t,ownerInfo:n,rewardInfo:i}){let[s,r]=[new S(e.programId),new S(e.id)],o,a,c;for(let f=0;f<e.rewardDefaultInfos.length;f++)e.rewardDefaultInfos[f].mint.address===i.mint.toString()&&(o=f,a=new S(t.rewardInfos[f].vault),c=new S(t.rewardInfos[f].mint.address));(o===void 0||a===void 0)&&_i.logWithError("reward mint check error","no reward mint",e.rewardDefaultInfos);let l=Ut(s).publicKey,d=[this.setRewardInstruction(s,n.wallet,r,l,new S(e.config.id),n.tokenAccount,a,c,o,i.openTime,i.endTime,i.emissionsPerSecondX64)];return{address:{rewardVault:a,operationId:l},signers:[],instructions:d,instructionTypes:[ie.ClmmSetReward],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[]}}static collectRewardInstruction(e,t,n,i,s,r,o){let a=J([fe("rewardIndex")]),c=[{pubkey:t,isSigner:!0,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!1},{pubkey:ee,isSigner:!1,isWritable:!1},{pubkey:ye,isSigner:!1,isWritable:!1},{pubkey:en,isSigner:!1,isWritable:!1}],l=Buffer.alloc(a.span);a.encode({rewardIndex:o},l);let d=Buffer.from([...Oe.collectReward,...l]);return new he({keys:c,programId:e,data:d})}static collectRewardInstructions({poolInfo:e,poolKeys:t,ownerInfo:n,rewardMint:i}){let[s,r]=[new S(e.programId),new S(e.id)],o,a;for(let l=0;l<e.rewardDefaultInfos.length;l++)e.rewardDefaultInfos[l].mint.address===i.toString()&&(o=l,a=new S(t.rewardInfos[l].vault));(o===void 0||a===void 0)&&_i.logWithError("reward mint check error","no reward mint",e.rewardDefaultInfos);let c=[this.collectRewardInstruction(s,n.wallet,r,n.tokenAccount,a,i,o)];return{address:{rewardVault:a},signers:[],instructions:c,instructionTypes:[ie.ClmmCollectReward],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[]}}static async makeLockPositions({programId:e,authProgramId:t,poolProgramId:n,payer:i,wallet:s,nftMint:r,nft2022:o,getEphemeralSigners:a}){let c=[],l;if(a)l=new S((await a(1))[0]);else{let b=dn.generate();c.push(b),l=b.publicKey}let d=o?re(s,r,ye).publicKey:re(s,r,ee).publicKey,{publicKey:f}=Ce(n,r),u=At(e,l).publicKey,m=re(s,l,ee).publicKey,p=Gt(l).publicKey,y=ae.lockPositionInstructionV2({programId:e,auth:t,payer:i,positionOwner:s,lockOwner:s,positionNftAccount:d,positionId:f,lockPositionId:u,lockNftMint:l,lockNftAccount:m,metadataAccount:p,withMetadata:!0,nft2022:o,positionNftMint:r,authPositionNftAccount:re(t,r,o?ye:ee).publicKey,positionNftProgram:o?ye:ee});return{address:{positionId:f,lockPositionId:u,lockNftAccount:m,lockNftMint:l,positionNftAccount:d,metadataAccount:p},instructions:[y],signers:c,instructionTypes:[ie.ClmmLockPosition],lookupTableAddress:[]}}static lockPositionInstructionV2({programId:e,auth:t,payer:n,positionOwner:i,lockOwner:s,positionNftAccount:r,positionId:o,positionNftMint:a,authPositionNftAccount:c,positionNftProgram:l,lockPositionId:d,lockNftMint:f,lockNftAccount:u,metadataAccount:m,withMetadata:p}){let y=[{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!0,isWritable:!0},{pubkey:i,isSigner:!0,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:d,isSigner:!1,isWritable:!0},{pubkey:f,isSigner:!0,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:m,isSigner:!1,isWritable:!0},{pubkey:mt,isSigner:!1,isWritable:!1},{pubkey:jt,isSigner:!1,isWritable:!1},{pubkey:rt,isSigner:!1,isWritable:!1},{pubkey:ee,isSigner:!1,isWritable:!1},{pubkey:l,isSigner:!1,isWritable:!1},{pubkey:nt.programId,isSigner:!1,isWritable:!1}],b=J([Ie("withMetadata")]),P=Buffer.alloc(b.span);b.encode({withMetadata:p},P);let A=Buffer.from([...Wi,...P]);return new he({keys:y,programId:e,data:A})}static lockPositionInstruction({programId:e,authProgramId:t,poolProgramId:n,owner:i,positionNft:s}){let{publicKey:r}=re(i,s,ee),{publicKey:o}=Ce(n,s),a=[{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:i,isSigner:!0,isWritable:!1},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:_n(e,o).publicKey,isSigner:!1,isWritable:!0},{pubkey:ee,isSigner:!1,isWritable:!1},{pubkey:nt.programId,isSigner:!1,isWritable:!1}];return new he({keys:a,programId:e,data:Buffer.from(Wi)})}static harvestLockPositionInstruction(e){let[t,n]=[new S(e.poolKeys.programId),new S(e.poolKeys.id)],i=M.getTickArrayStartIndexByTick(e.ownerPosition.tickLower,e.poolKeys.config.tickSpacing),s=M.getTickArrayStartIndexByTick(e.ownerPosition.tickUpper,e.poolKeys.config.tickSpacing),{publicKey:r}=H(t,n,i),{publicKey:o}=H(t,n,s),{publicKey:a}=re(e.owner,e.ownerPosition.nftMint,ee),{publicKey:c}=Ce(t,e.ownerPosition.nftMint),{publicKey:l}=_e(t,n,e.ownerPosition.tickLower,e.ownerPosition.tickUpper),d=[];for(let m=0;m<e.poolKeys.rewardInfos.length;m++)d.push({poolRewardVault:new S(e.poolKeys.rewardInfos[m].vault),ownerRewardVault:e.ownerRewardAccounts[m],rewardMint:new S(e.poolKeys.rewardInfos[m].mint.address)});let f=[...d.map(m=>[{pubkey:m.poolRewardVault,isSigner:!1,isWritable:!0},{pubkey:m.ownerRewardVault,isSigner:!1,isWritable:!0},{pubkey:m.rewardMint,isSigner:!1,isWritable:!1}]).flat()],u=[{pubkey:e.authProgramId,isSigner:!1,isWritable:!1},{pubkey:_n(e.programId,c).publicKey,isSigner:!1,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:e.owner,isSigner:!0,isWritable:!1},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:new S(e.poolKeys.vault.A),isSigner:!1,isWritable:!0},{pubkey:new S(e.poolKeys.vault.B),isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:e.userVaultA,isSigner:!1,isWritable:!0},{pubkey:e.userVaultB,isSigner:!1,isWritable:!0},{pubkey:ee,isSigner:!1,isWritable:!1},{pubkey:ye,isSigner:!1,isWritable:!1},{pubkey:Tn,isSigner:!1,isWritable:!1},{pubkey:new S(e.poolKeys.mintA.address),isSigner:!1,isWritable:!1},{pubkey:new S(e.poolKeys.mintB.address),isSigner:!1,isWritable:!1},...f];return new he({keys:u,programId:e.programId,data:Buffer.from(vi)})}static harvestLockPositionInstructionV2({programId:e,auth:t,lockPositionId:n,clmmProgram:i,lockOwner:s,lockNftMint:r,lockNftAccount:o,positionNftAccount:a,positionId:c,poolId:l,protocolPosition:d,vaultA:f,vaultB:u,tickArrayLower:m,tickArrayUpper:p,userVaultA:y,userVaultB:b,mintA:P,mintB:A,rewardAccounts:T,exTickArrayBitmap:k}){let w=[...k?[{pubkey:k,isSigner:!1,isWritable:!0}]:[],...T.map(h=>[{pubkey:h.poolRewardVault,isSigner:!1,isWritable:!0},{pubkey:h.ownerRewardVault,isSigner:!1,isWritable:!0},{pubkey:h.rewardMint,isSigner:!1,isWritable:!1}]).flat()],x=[{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:s,isSigner:!0,isWritable:!1},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:i,isSigner:!1,isWritable:!1},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:d,isSigner:!1,isWritable:!0},{pubkey:f,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:m,isSigner:!1,isWritable:!0},{pubkey:p,isSigner:!1,isWritable:!0},{pubkey:y,isSigner:!1,isWritable:!0},{pubkey:b,isSigner:!1,isWritable:!0},{pubkey:ee,isSigner:!1,isWritable:!1},{pubkey:ye,isSigner:!1,isWritable:!1},{pubkey:Tn,isSigner:!1,isWritable:!1},{pubkey:P,isSigner:!1,isWritable:!1},{pubkey:A,isSigner:!1,isWritable:!1},...w];return new he({keys:x,programId:e,data:Buffer.from(vi)})}};var Gi=class extends Wt{constructor(e){super(e)}async getClmmPoolKeys(e){return(await this.scope.api.fetchPoolKeysById({idList:[e]}))[0]}async createPool(e){var x;let{programId:t,owner:n=((x=this.scope.owner)==null?void 0:x.publicKey)||R.default,mint1:i,mint2:s,ammConfig:r,initialPrice:o,computeBudgetConfig:a,forerunCreate:c,getObserveState:l,txVersion:d,txTipConfig:f,feePayer:u}=e,m=this.createTxBuilder(u),[p,y,b]=new Ke(new R(i.address).toBuffer()).gt(new Ke(new R(s.address).toBuffer()))?[s,i,new gt(1).div(o)]:[i,s,o],P=_.priceToSqrtPriceX64(b,p.decimals,y.decimals),A=[],T=[];p.programId===ct.toBase58()&&T.push(Wn(t,new R(p.address)).publicKey),y.programId===ct.toBase58()&&T.push(Wn(t,new R(y.address)).publicKey),(await this.scope.connection.getMultipleAccountsInfo(T)).forEach((h,B)=>{h&&A.push(T[B])});let w=await ae.createPoolInstructions({connection:this.scope.connection,programId:t,owner:n,mintA:p,mintB:y,ammConfigId:r.id,initialPriceX64:P,forerunCreate:!l&&c,extendMintAccount:A});return m.addInstruction(w),m.addCustomComputeBudget(a),m.addTipInstruction(f),m.versionBuild({txVersion:d,extInfo:{address:U(O({},w.address),{observationId:w.address.observationId.toBase58(),exBitmapAccount:w.address.exBitmapAccount.toBase58(),programId:t.toString(),id:w.address.poolId.toString(),mintA:p,mintB:y,openTime:"0",vault:{A:w.address.mintAVault.toString(),B:w.address.mintBVault.toString()},rewardInfos:[],config:{id:r.id.toString(),index:r.index,protocolFeeRate:r.protocolFeeRate,tradeFeeRate:r.tradeFeeRate,tickSpacing:r.tickSpacing,fundFeeRate:r.fundFeeRate,description:r.description,defaultRange:0,defaultRangePoint:[]}}),mockPoolInfo:O({type:"Concentrated",rewardDefaultPoolInfos:"Clmm",id:w.address.poolId.toString(),mintA:p,mintB:y,feeRate:r.tradeFeeRate,openTime:"0",programId:t.toString(),price:b.toNumber(),config:{id:r.id.toString(),index:r.index,protocolFeeRate:r.protocolFeeRate,tradeFeeRate:r.tradeFeeRate,tickSpacing:r.tickSpacing,fundFeeRate:r.fundFeeRate,description:r.description,defaultRange:0,defaultRangePoint:[]},burnPercent:0},hi),forerunCreate:c}})}async openPositionFromBase({poolInfo:e,poolKeys:t,ownerInfo:n,tickLower:i,tickUpper:s,base:r,baseAmount:o,otherAmountMax:a,nft2022:c,associatedOnly:l=!0,checkCreateATAOwner:d=!1,withMetadata:f="create",getEphemeralSigners:u,computeBudgetConfig:m,txTipConfig:p,txVersion:y,feePayer:b}){this.scope.availability.addConcentratedPosition===!1&&this.logAndCreateError("add position feature disabled in your region"),this.scope.checkOwner();let P=this.createTxBuilder(b),A=null,T=null,k=n.useSOLBalance&&e.mintA.address===Q.toString(),w=n.useSOLBalance&&e.mintB.address===Q.toString(),[x,h]=r==="MintA"?[o,a]:[a,o],{account:B,instructionParams:K}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:e.mintA.programId,mint:new R(e.mintA.address),owner:this.scope.ownerPubKey,createInfo:k||x.isZero()?{payer:this.scope.ownerPubKey,amount:x}:void 0,skipCloseAccount:!k,notUseTokenAccount:k,associatedOnly:k?!1:l,checkCreateATAOwner:d});B&&(A=B),P.addInstruction(K||{});let{account:L,instructionParams:C}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:e.mintB.programId,mint:new R(e.mintB.address),owner:this.scope.ownerPubKey,createInfo:w||h.isZero()?{payer:this.scope.ownerPubKey,amount:h}:void 0,skipCloseAccount:!w,notUseTokenAccount:w,associatedOnly:w?!1:l,checkCreateATAOwner:d});L&&(T=L),P.addInstruction(C||{}),(!A||!T)&&this.logAndCreateError("cannot found target token accounts","tokenAccounts",{ownerTokenAccountA:A==null?void 0:A.toBase58(),ownerTokenAccountB:T==null?void 0:T.toBase58()});let N=t||await this.getClmmPoolKeys(e.id),I=await ae.openPositionFromBaseInstructions({poolInfo:e,poolKeys:N,ownerInfo:U(O({},n),{feePayer:this.scope.ownerPubKey,wallet:this.scope.ownerPubKey,tokenAccountA:A,tokenAccountB:T}),tickLower:i,tickUpper:s,base:r,baseAmount:o,otherAmountMax:a,withMetadata:f,getEphemeralSigners:u,nft2022:c});return P.addInstruction(I),P.addCustomComputeBudget(m),P.addTipInstruction(p),P.versionBuild({txVersion:y,extInfo:O({},I.address)})}async openPositionFromLiquidity({poolInfo:e,poolKeys:t,ownerInfo:n,amountMaxA:i,amountMaxB:s,tickLower:r,tickUpper:o,liquidity:a,associatedOnly:c=!0,checkCreateATAOwner:l=!1,withMetadata:d="create",txVersion:f,computeBudgetConfig:u,txTipConfig:m,getEphemeralSigners:p,nft2022:y,feePayer:b}){this.scope.availability.createConcentratedPosition===!1&&this.logAndCreateError("open position feature disabled in your region");let P=this.createTxBuilder(b),A=null,T=null,k=n.useSOLBalance&&e.mintA.address===Q.toBase58(),w=n.useSOLBalance&&e.mintB.address===Q.toBase58(),{account:x,instructionParams:h}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:e.mintA.programId,mint:new R(e.mintA.address),owner:this.scope.ownerPubKey,createInfo:k||i.isZero()?{payer:this.scope.ownerPubKey,amount:i}:void 0,skipCloseAccount:!k,notUseTokenAccount:k,associatedOnly:k?!1:c,checkCreateATAOwner:l});x&&(A=x),P.addInstruction(h||{});let{account:B,instructionParams:K}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:e.mintB.programId,mint:new R(e.mintB.address),owner:this.scope.ownerPubKey,createInfo:w||s.isZero()?{payer:this.scope.ownerPubKey,amount:s}:void 0,skipCloseAccount:!w,notUseTokenAccount:w,associatedOnly:w?!1:c,checkCreateATAOwner:l});B&&(T=B),P.addInstruction(K||{}),(A===void 0||T===void 0)&&this.logAndCreateError("cannot found target token accounts","tokenAccounts",this.scope.account.tokenAccounts);let L=t||await this.getClmmPoolKeys(e.id),C=await ae.openPositionFromLiquidityInstructions({poolInfo:e,poolKeys:L,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccountA:A,tokenAccountB:T},tickLower:r,tickUpper:o,liquidity:a,amountMaxA:i,amountMaxB:s,withMetadata:d,getEphemeralSigners:p,nft2022:y});return P.addInstruction(C),P.addCustomComputeBudget(u),P.addTipInstruction(m),P.versionBuild({txVersion:f,extInfo:{address:C.address}})}async increasePositionFromLiquidity(e){var K;let{poolInfo:t,poolKeys:n,ownerPosition:i,amountMaxA:s,amountMaxB:r,liquidity:o,ownerInfo:a,associatedOnly:c=!0,checkCreateATAOwner:l=!1,computeBudgetConfig:d,txTipConfig:f,txVersion:u,feePayer:m}=e,p=this.createTxBuilder(m),y,b,P=a.useSOLBalance&&t.mintA.address===Q.toString(),A=a.useSOLBalance&&t.mintB.address===Q.toString(),{account:T,instructionParams:k}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:t.mintA.programId,mint:new R(t.mintA.address),notUseTokenAccount:P,owner:this.scope.ownerPubKey,createInfo:P||s.isZero()?{payer:this.scope.ownerPubKey,amount:s}:void 0,skipCloseAccount:!P,associatedOnly:P?!1:c,checkCreateATAOwner:l});T&&(y=T),p.addInstruction(k||{});let{account:w,instructionParams:x}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:t.mintB.programId,mint:new R(t.mintB.address),owner:this.scope.ownerPubKey,createInfo:A||r.isZero()?{payer:this.scope.ownerPubKey,amount:r}:void 0,notUseTokenAccount:A,skipCloseAccount:!A,associatedOnly:A?!1:c,checkCreateATAOwner:l});w&&(b=w),p.addInstruction(x||{}),!y&&!b&&this.logAndCreateError("cannot found target token accounts","tokenAccounts",this.scope.account.tokenAccounts);let h=n!=null?n:await this.getClmmPoolKeys(t.id),B=ae.increasePositionFromLiquidityInstructions({poolInfo:t,poolKeys:h,ownerPosition:i,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccountA:y,tokenAccountB:b},liquidity:o,amountMaxA:s,amountMaxB:r,nft2022:(K=await this.scope.connection.getAccountInfo(i.nftMint))==null?void 0:K.owner.equals(ct)});return p.addInstruction(B),p.addCustomComputeBudget(d),p.addTipInstruction(f),p.versionBuild({txVersion:u,extInfo:{address:B.address}})}async increasePositionFromBase(e){var B;let{poolInfo:t,ownerPosition:n,base:i,baseAmount:s,otherAmountMax:r,ownerInfo:o,associatedOnly:a=!0,checkCreateATAOwner:c=!1,computeBudgetConfig:l,txTipConfig:d,txVersion:f,feePayer:u}=e,m=this.createTxBuilder(u),p,y,b=o.useSOLBalance&&t.mintA.address===Q.toString(),P=o.useSOLBalance&&t.mintB.address===Q.toString(),{account:A,instructionParams:T}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:t.mintA.programId,mint:new R(t.mintA.address),notUseTokenAccount:b,owner:this.scope.ownerPubKey,createInfo:b||(i==="MintA"?s:r).isZero()?{payer:this.scope.ownerPubKey,amount:i==="MintA"?s:r}:void 0,skipCloseAccount:!b,associatedOnly:b?!1:a,checkCreateATAOwner:c});A&&(p=A),m.addInstruction(T||{});let{account:k,instructionParams:w}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:t.mintB.programId,mint:new R(t.mintB.address),owner:this.scope.ownerPubKey,createInfo:P||(i==="MintA"?r:s).isZero()?{payer:this.scope.ownerPubKey,amount:i==="MintA"?r:s}:void 0,notUseTokenAccount:P,skipCloseAccount:!P,associatedOnly:P?!1:a,checkCreateATAOwner:c});k&&(y=k),m.addInstruction(w||{}),!p&&!y&&this.logAndCreateError("cannot found target token accounts","tokenAccounts",this.scope.account.tokenAccounts);let x=await this.getClmmPoolKeys(t.id),h=ae.increasePositionFromBaseInstructions({poolInfo:t,poolKeys:x,ownerPosition:n,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccountA:p,tokenAccountB:y},base:i,baseAmount:s,otherAmountMax:r,nft2022:(B=await this.scope.connection.getAccountInfo(n.nftMint))==null?void 0:B.owner.equals(ct)});return m.addInstruction(h),m.addCustomComputeBudget(l),m.addTipInstruction(d),m.versionBuild({txVersion:f,extInfo:{address:h.address}})}async decreaseLiquidity(e){var N;let{poolInfo:t,poolKeys:n,ownerPosition:i,ownerInfo:s,amountMinA:r,amountMinB:o,liquidity:a,associatedOnly:c=!0,checkCreateATAOwner:l=!1,computeBudgetConfig:d,txTipConfig:f,txVersion:u,feePayer:m}=e;this.scope.availability.removeConcentratedPosition===!1&&this.logAndCreateError("remove position feature disabled in your region");let p=this.createTxBuilder(m),y=s.useSOLBalance&&t.mintA.address===Q.toString(),b=s.useSOLBalance&&t.mintB.address===Q.toString(),P,A,{account:T,instructionParams:k}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:t.mintA.programId,mint:new R(t.mintA.address),notUseTokenAccount:y,owner:this.scope.ownerPubKey,createInfo:{payer:this.scope.ownerPubKey,amount:0},skipCloseAccount:!y,associatedOnly:y?!1:c,checkCreateATAOwner:l});P=T,k&&p.addInstruction(k);let{account:w,instructionParams:x}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:t.mintB.programId,mint:new R(t.mintB.address),notUseTokenAccount:b,owner:this.scope.ownerPubKey,createInfo:{payer:this.scope.ownerPubKey,amount:0},skipCloseAccount:!b,associatedOnly:b?!1:c,checkCreateATAOwner:l});A=w,x&&p.addInstruction(x);let h=[];for(let I of t.rewardDefaultInfos){let F=s.useSOLBalance&&I.mint.address===Q.toString(),v;if(I.mint.address===t.mintA.address)v=P;else if(I.mint.address===t.mintB.address)v=A;else{let{account:ce,instructionParams:pe}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:new R(I.mint.programId),mint:new R(I.mint.address),notUseTokenAccount:F,owner:this.scope.ownerPubKey,createInfo:{payer:this.scope.ownerPubKey,amount:0},skipCloseAccount:!F,associatedOnly:F?!1:c,checkCreateATAOwner:l});v=ce,pe&&p.addInstruction(pe)}h.push(v)}!P&&!A&&this.logAndCreateError("cannot found target token accounts","tokenAccounts",this.scope.account.tokenAccountRawInfos);let B=n!=null?n:await this.getClmmPoolKeys(t.id),K=(N=await this.scope.connection.getAccountInfo(i.nftMint))==null?void 0:N.owner.equals(ct),L=await ae.decreaseLiquidityInstructions({poolInfo:t,poolKeys:B,ownerPosition:i,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccountA:P,tokenAccountB:A,rewardAccounts:h},liquidity:a,amountMinA:r,amountMinB:o,nft2022:K});p.addInstruction({instructions:L.instructions,instructionTypes:[ie.ClmmDecreasePosition]});let C=O({},L.address);if(s.closePosition){let I=await ae.closePositionInstructions({poolInfo:t,poolKeys:B,ownerInfo:{wallet:this.scope.ownerPubKey},ownerPosition:i,nft2022:K});p.addInstruction({endInstructions:I.instructions,endInstructionTypes:I.instructionTypes}),C=O(O({},C),I.address)}return p.addCustomComputeBudget(d),p.addTipInstruction(f),p.versionBuild({txVersion:u,extInfo:{address:C}})}async lockPosition(e){var m;let{programId:t=Mt,authProgramId:n=nn,poolProgramId:i=Nt,ownerPosition:s,payer:r,computeBudgetConfig:o,txTipConfig:a,txVersion:c,getEphemeralSigners:l,feePayer:d}=e,f=this.createTxBuilder(d),u=await ae.makeLockPositions({programId:t,authProgramId:n,poolProgramId:i,wallet:this.scope.ownerPubKey,payer:r!=null?r:this.scope.ownerPubKey,nftMint:s.nftMint,getEphemeralSigners:l,nft2022:(m=await this.scope.connection.getAccountInfo(s.nftMint))==null?void 0:m.owner.equals(ct)});return f.addInstruction(u),f.addCustomComputeBudget(o),f.addTipInstruction(a),f.versionBuild({txVersion:c,extInfo:u.address})}async harvestLockPosition(e){let{programId:t=Mt,authProgramId:n=nn,clmmProgram:i=Nt,poolKeys:s,lockData:r,ownerInfo:o={useSOLBalance:!0},associatedOnly:a=!0,checkCreateATAOwner:c=!1,computeBudgetConfig:l,txTipConfig:d,txVersion:f,feePayer:u}=e,m=s||await this.getClmmPoolKeys(r.poolId.toString()),p=this.createTxBuilder(u),y=await this.scope.connection.getAccountInfo(r.positionId);y||this.logger.logWithError("position not found",r.positionId);let b=ht.decode(y.data),P=o.useSOLBalance&&m.mintA.address===Q.toString(),A=o.useSOLBalance&&m.mintB.address===Q.toString(),T,k,{account:w,instructionParams:x}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:m.mintA.programId,mint:new R(m.mintA.address),notUseTokenAccount:P,owner:this.scope.ownerPubKey,createInfo:{payer:this.scope.ownerPubKey,amount:0},skipCloseAccount:!P,associatedOnly:P?!1:a,checkCreateATAOwner:c});T=w,x&&p.addInstruction(x);let{account:h,instructionParams:B}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:m.mintB.programId,mint:new R(m.mintB.address),notUseTokenAccount:A,owner:this.scope.ownerPubKey,createInfo:{payer:this.scope.ownerPubKey,amount:0},skipCloseAccount:!A,associatedOnly:A?!1:a,checkCreateATAOwner:c});k=h,B&&p.addInstruction(B);let K={},L=[];for(let $ of m.rewardInfos){let ne=o.useSOLBalance&&$.mint.address===Q.toString(),We=K[$.mint.address];if(!We){let{account:Ui,instructionParams:Xn}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:new R($.mint.programId),mint:new R($.mint.address),notUseTokenAccount:ne,owner:this.scope.ownerPubKey,skipCloseAccount:!ne,createInfo:{payer:this.scope.ownerPubKey,amount:0},associatedOnly:ne?!1:a});We=Ui,Xn&&p.addInstruction(Xn)}K[$.mint.address]=We,L.push(We)}let C=At(t,r.lockNftMint).publicKey,N=re(this.scope.ownerPubKey,r.lockNftMint,Zt).publicKey,I=M.getTickArrayStartIndexByTick(b.tickLower,m.config.tickSpacing),F=M.getTickArrayStartIndexByTick(b.tickUpper,m.config.tickSpacing),{publicKey:v}=H(new R(m.programId),r.poolId,I),{publicKey:ce}=H(new R(m.programId),r.poolId,F),{publicKey:pe}=_e(new R(m.programId),r.poolId,b.tickLower,b.tickUpper),Le=[];for(let $=0;$<m.rewardInfos.length;$++)Le.push({poolRewardVault:new R(m.rewardInfos[$].vault),ownerRewardVault:L[$],rewardMint:new R(m.rewardInfos[$].mint.address)});let ze=await ae.harvestLockPositionInstructionV2({programId:t,auth:n,lockPositionId:C,clmmProgram:i,lockOwner:this.scope.ownerPubKey,lockNftMint:r.lockNftMint,lockNftAccount:N,positionNftAccount:r.nftAccount,positionId:r.positionId,poolId:r.poolId,protocolPosition:pe,vaultA:new R(m.vault.A),vaultB:new R(m.vault.B),tickArrayLower:v,tickArrayUpper:ce,userVaultA:T,userVaultB:k,mintA:new R(m.mintA.address),mintB:new R(m.mintB.address),rewardAccounts:Le,exTickArrayBitmap:ge(i,r.poolId).publicKey});return p.addInstruction({instructions:[ze],instructionTypes:[ie.ClmmHarvestLockPosition]}),p.addCustomComputeBudget(l),p.addTipInstruction(d),p.versionBuild({txVersion:f})}async closePosition({poolInfo:e,poolKeys:t,ownerPosition:n,txVersion:i,computeBudgetConfig:s,txTipConfig:r,feePayer:o}){var d;this.scope.availability.removeConcentratedPosition===!1&&this.logAndCreateError("remove position feature disabled in your region");let a=this.createTxBuilder(o),c=t!=null?t:await this.getClmmPoolKeys(e.id),l=ae.closePositionInstructions({poolInfo:e,poolKeys:c,ownerInfo:{wallet:this.scope.ownerPubKey},ownerPosition:n,nft2022:(d=await this.scope.connection.getAccountInfo(n.nftMint))==null?void 0:d.owner.equals(ct)});return a.addCustomComputeBudget(s),a.addTipInstruction(r),a.addInstruction(l).versionBuild({txVersion:i,extInfo:{address:l.address}})}async initReward({poolInfo:e,ownerInfo:t,rewardInfo:n,associatedOnly:i=!0,checkCreateATAOwner:s=!1,computeBudgetConfig:r,txVersion:o,feePayer:a}){n.endTime<=n.openTime&&this.logAndCreateError("reward time error","rewardInfo",n);let c=this.createTxBuilder(a),l=t.useSOLBalance&&n.mint.address.toString()===Q.toString(),d=n.perSecond.mul(n.endTime-n.openTime),{account:f,instructionParams:u}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:new R(n.mint.address),mint:new R(n.mint.address),notUseTokenAccount:!!l,skipCloseAccount:!l,owner:this.scope.ownerPubKey,createInfo:l?{payer:t.feePayer||this.scope.ownerPubKey,amount:new Ke(new gt(d.toFixed(0)).gte(d)?d.toFixed(0):d.add(1).toFixed(0))}:void 0,associatedOnly:l?!1:i,checkCreateATAOwner:s});u&&c.addInstruction(u),f||this.logAndCreateError("no money","ownerRewardAccount",this.scope.account.tokenAccountRawInfos);let m=await this.getClmmPoolKeys(e.id),p=ae.initRewardInstructions({poolInfo:e,poolKeys:m,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccount:f},rewardInfo:{programId:new R(n.mint.programId),mint:new R(n.mint.address),openTime:n.openTime,endTime:n.endTime,emissionsPerSecondX64:W.decimalToX64(n.perSecond)}});return c.addInstruction(p),c.addCustomComputeBudget(r),c.versionBuild({txVersion:o,extInfo:{address:p.address}})}async initRewards({poolInfo:e,poolKeys:t,ownerInfo:n,rewardInfos:i,associatedOnly:s=!0,checkCreateATAOwner:r=!1,computeBudgetConfig:o,txTipConfig:a,txVersion:c,feePayer:l}){for(let u of i)u.endTime<=u.openTime&&this.logAndCreateError("reward time error","rewardInfo",u);let d=this.createTxBuilder(l),f={};for(let u of i){let m=n.useSOLBalance&&u.mint.address===Q.toString(),p=u.perSecond.mul(u.endTime-u.openTime),{account:y,instructionParams:b}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:new R(u.mint.programId),mint:new R(u.mint.address),notUseTokenAccount:!!m,skipCloseAccount:!m,owner:this.scope.ownerPubKey,createInfo:m?{payer:n.feePayer||this.scope.ownerPubKey,amount:new Ke(new gt(p.toFixed(0)).gte(p)?p.toFixed(0):p.add(1).toFixed(0))}:void 0,associatedOnly:m?!1:s,checkCreateATAOwner:r});b&&d.addInstruction(b),y||this.logAndCreateError("no money","ownerRewardAccount",this.scope.account.tokenAccountRawInfos);let P=t!=null?t:await this.getClmmPoolKeys(e.id),A=ae.initRewardInstructions({poolInfo:e,poolKeys:P,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccount:y},rewardInfo:{programId:new R(u.mint.programId),mint:new R(u.mint.address),openTime:u.openTime,endTime:u.endTime,emissionsPerSecondX64:W.decimalToX64(u.perSecond)}});f=O(O({},f),A.address),d.addInstruction(A)}return d.addCustomComputeBudget(o),d.addTipInstruction(a),d.versionBuild({txVersion:c,extInfo:{address:f}})}async setReward({poolInfo:e,ownerInfo:t,rewardInfo:n,associatedOnly:i=!0,checkCreateATAOwner:s=!1,computeBudgetConfig:r,txTipConfig:o,txVersion:a,feePayer:c}){n.endTime<=n.openTime&&this.logAndCreateError("reward time error","rewardInfo",n);let l=this.createTxBuilder(c),d=t.useSOLBalance&&n.mint.equals(Q),{account:f,instructionParams:u}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:n.programId,mint:n.mint,notUseTokenAccount:d,owner:this.scope.ownerPubKey,createInfo:d?{payer:t.feePayer||this.scope.ownerPubKey,amount:new Ke(new gt(n.perSecond.mul(n.endTime-n.openTime).toFixed(0)).gte(n.perSecond.mul(n.endTime-n.openTime))?n.perSecond.mul(n.endTime-n.openTime).toFixed(0):n.perSecond.mul(n.endTime-n.openTime).add(1).toFixed(0))}:void 0,associatedOnly:d?!1:i,checkCreateATAOwner:s});u&&l.addInstruction(u),f||this.logAndCreateError("no money","ownerRewardAccount",this.scope.account.tokenAccountRawInfos);let m=await this.getClmmPoolKeys(e.id),p=ae.setRewardInstructions({poolInfo:e,poolKeys:m,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccount:f},rewardInfo:{mint:n.mint,openTime:n.openTime,endTime:n.endTime,emissionsPerSecondX64:W.decimalToX64(n.perSecond)}});return l.addInstruction(p),l.addCustomComputeBudget(r),l.addTipInstruction(o),l.versionBuild({txVersion:a,extInfo:{address:p.address}})}async setRewards({poolInfo:e,poolKeys:t,ownerInfo:n,rewardInfos:i,associatedOnly:s=!0,checkCreateATAOwner:r=!1,computeBudgetConfig:o,txTipConfig:a,txVersion:c,feePayer:l}){let d=this.createTxBuilder(l),f={};for(let u of i){u.endTime<=u.openTime&&this.logAndCreateError("reward time error","rewardInfo",u);let m=n.useSOLBalance&&u.mint.address===Q.toString(),{account:p,instructionParams:y}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:new R(u.mint.programId),mint:new R(u.mint.address),notUseTokenAccount:m,owner:this.scope.ownerPubKey,createInfo:m?{payer:n.feePayer||this.scope.ownerPubKey,amount:new Ke(new gt(u.perSecond.mul(u.endTime-u.openTime).toFixed(0)).gte(u.perSecond.mul(u.endTime-u.openTime))?u.perSecond.mul(u.endTime-u.openTime).toFixed(0):u.perSecond.mul(u.endTime-u.openTime).add(1).toFixed(0))}:void 0,associatedOnly:m?!1:s,checkCreateATAOwner:r});y&&d.addInstruction(y),p||this.logAndCreateError("no money","ownerRewardAccount",this.scope.account.tokenAccountRawInfos);let b=t!=null?t:await this.getClmmPoolKeys(e.id),P=ae.setRewardInstructions({poolInfo:e,poolKeys:b,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccount:p},rewardInfo:{mint:new R(u.mint.address),openTime:u.openTime,endTime:u.endTime,emissionsPerSecondX64:W.decimalToX64(u.perSecond)}});d.addInstruction(P),f=O(O({},f),P.address)}return d.addCustomComputeBudget(o),d.addTipInstruction(a),d.versionBuild({txVersion:c,extInfo:{address:f}})}async collectReward({poolInfo:e,ownerInfo:t,rewardMint:n,associatedOnly:i=!0,checkCreateATAOwner:s=!1,computeBudgetConfig:r,txTipConfig:o,txVersion:a,feePayer:c}){let l=e.rewardDefaultInfos.find(b=>b.mint.address===n.toString());l||this.logAndCreateError("reward mint error","not found reward mint",n);let d=this.createTxBuilder(c),f=t.useSOLBalance&&n.equals(Q),{account:u,instructionParams:m}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:new R(l.mint.programId),mint:n,notUseTokenAccount:f,owner:this.scope.ownerPubKey,skipCloseAccount:!f,createInfo:{payer:t.feePayer||this.scope.ownerPubKey,amount:0},associatedOnly:f?!1:i,checkCreateATAOwner:s});m&&d.addInstruction(m),u||this.logAndCreateError("no money","ownerRewardAccount",this.scope.account.tokenAccountRawInfos);let p=await this.getClmmPoolKeys(e.id),y=ae.collectRewardInstructions({poolInfo:e,poolKeys:p,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccount:u},rewardMint:n});return d.addInstruction(y),d.addCustomComputeBudget(r),d.addTipInstruction(o),d.versionBuild({txVersion:a,extInfo:{address:y.address}})}async collectRewards({poolInfo:e,ownerInfo:t,rewardMints:n,associatedOnly:i=!0,checkCreateATAOwner:s=!1,computeBudgetConfig:r,txTipConfig:o,feePayer:a}){let c=this.createTxBuilder(a),l={};for(let d of n){let f=e.rewardDefaultInfos.find(P=>P.mint.address===d.toString());if(!f){this.logAndCreateError("reward mint error","not found reward mint",d);continue}let u=t.useSOLBalance&&d.equals(Q),{account:m,instructionParams:p}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:new R(f.mint.programId),mint:d,notUseTokenAccount:u,owner:this.scope.ownerPubKey,skipCloseAccount:!u,createInfo:{payer:t.feePayer||this.scope.ownerPubKey,amount:0},associatedOnly:u?!1:i,checkCreateATAOwner:s});m||this.logAndCreateError("no money","ownerRewardAccount",this.scope.account.tokenAccountRawInfos),p&&c.addInstruction(p);let y=await this.getClmmPoolKeys(e.id),b=ae.collectRewardInstructions({poolInfo:e,poolKeys:y,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccount:m},rewardMint:d});c.addInstruction(b),l=O(O({},l),b.address)}return c.addCustomComputeBudget(r),c.addTipInstruction(o),c.build({address:l})}async swap({poolInfo:e,poolKeys:t,inputMint:n,amountIn:i,amountOutMin:s,priceLimit:r,observationId:o,ownerInfo:a,remainingAccounts:c,associatedOnly:l=!0,checkCreateATAOwner:d=!1,txVersion:f,computeBudgetConfig:u,txTipConfig:m,feePayer:p}){let y=this.createTxBuilder(p),b=n.toString()===e.mintA.address,P=a.useSOLBalance&&e.mintA.address===Q.toBase58(),A=a.useSOLBalance&&e.mintB.address===Q.toBase58(),T;!r||r.equals(new gt(0))?T=b?Ge.add(new Ke(1)):Ue.sub(new Ke(1)):T=_.priceToSqrtPriceX64(r,e.mintA.decimals,e.mintB.decimals);let k;if(!k){let{account:h,instructionParams:B}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:e.mintA.programId,mint:new R(e.mintA.address),notUseTokenAccount:P,owner:this.scope.ownerPubKey,skipCloseAccount:!P,createInfo:P||!b?{payer:a.feePayer||this.scope.ownerPubKey,amount:b?i:0}:void 0,associatedOnly:P?!1:l,checkCreateATAOwner:d});k=h,B&&y.addInstruction(B)}let w;if(!w){let{account:h,instructionParams:B}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:e.mintB.programId,mint:new R(e.mintB.address),notUseTokenAccount:A,owner:this.scope.ownerPubKey,skipCloseAccount:!A,createInfo:A||b?{payer:a.feePayer||this.scope.ownerPubKey,amount:b?0:i}:void 0,associatedOnly:A?!1:l,checkCreateATAOwner:d});w=h,B&&y.addInstruction(B)}(!k||!w)&&this.logAndCreateError("user do not have token account",{tokenA:e.mintA.symbol||e.mintA.address,tokenB:e.mintB.symbol||e.mintB.address,ownerTokenAccountA:k,ownerTokenAccountB:w,mintAUseSOLBalance:P,mintBUseSOLBalance:A,associatedOnly:l});let x=t!=null?t:await this.getClmmPoolKeys(e.id);return y.addInstruction(ae.makeSwapBaseInInstructions({poolInfo:e,poolKeys:x,observationId:o,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccountA:k,tokenAccountB:w},inputMint:new R(n),amountIn:i,amountOutMin:s,sqrtPriceLimitX64:T,remainingAccounts:c})),y.addCustomComputeBudget(u),y.addTipInstruction(m),y.versionBuild({txVersion:f})}async swapBaseOut({poolInfo:e,poolKeys:t,outputMint:n,amountOut:i,amountInMax:s,priceLimit:r,observationId:o,ownerInfo:a,remainingAccounts:c,associatedOnly:l=!0,checkCreateATAOwner:d=!1,txVersion:f,computeBudgetConfig:u,txTipConfig:m,feePayer:p}){let y=this.createTxBuilder(p),b=n.toString()===e.mintB.address,P=a.useSOLBalance&&e.mintA.address===Q.toBase58(),A=a.useSOLBalance&&e.mintB.address===Q.toBase58(),T;!r||r.equals(new gt(0))?T=n.toString()===e.mintB.address?Ge.add(new Ke(1)):Ue.sub(new Ke(1)):T=_.priceToSqrtPriceX64(r,e.mintA.decimals,e.mintB.decimals);let k;if(!k){let{account:h,instructionParams:B}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:e.mintA.programId,mint:new R(e.mintA.address),notUseTokenAccount:P,owner:this.scope.ownerPubKey,skipCloseAccount:!P,createInfo:P||!b?{payer:a.feePayer||this.scope.ownerPubKey,amount:b?s:0}:void 0,associatedOnly:P?!1:l,checkCreateATAOwner:d});k=h,B&&y.addInstruction(B)}let w;if(!w){let{account:h,instructionParams:B}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:e.mintB.programId,mint:new R(e.mintB.address),notUseTokenAccount:A,owner:this.scope.ownerPubKey,skipCloseAccount:!A,createInfo:A||b?{payer:a.feePayer||this.scope.ownerPubKey,amount:b?0:s}:void 0,associatedOnly:A?!1:l,checkCreateATAOwner:d});w=h,B&&y.addInstruction(B)}(!k||!w)&&this.logAndCreateError("user do not have token account",{tokenA:e.mintA.symbol||e.mintA.address,tokenB:e.mintB.symbol||e.mintB.address,ownerTokenAccountA:k,ownerTokenAccountB:w,mintAUseSOLBalance:P,mintBUseSOLBalance:A,associatedOnly:l});let x=t!=null?t:await this.getClmmPoolKeys(e.id);return y.addInstruction(ae.makeSwapBaseOutInstructions({poolInfo:e,poolKeys:x,observationId:o,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccountA:k,tokenAccountB:w},outputMint:new R(n),amountOut:i,amountInMax:s,sqrtPriceLimitX64:T,remainingAccounts:c})),y.addCustomComputeBudget(u),y.addTipInstruction(m),y.versionBuild({txVersion:f})}async harvestAllRewards({allPoolInfo:e,allPositions:t,lockInfo:n,ownerInfo:i,associatedOnly:s=!0,checkCreateATAOwner:r=!1,programId:o,txVersion:a,computeBudgetConfig:c,feePayer:l,lockProgram:d=Mt,lockAuth:f=nn,clmmProgram:u=Nt}){var A,T;let m={};for(let k of this.scope.account.tokenAccountRawInfos)s?re(this.scope.ownerPubKey,k.accountInfo.mint,o).publicKey.equals(k.pubkey)&&(m[k.accountInfo.mint.toString()]=k.pubkey):m[k.accountInfo.mint.toString()]=k.pubkey;let p=Object.values(t).flat().map(k=>k.nftMint),y=await Ze(this.scope.connection,p.map(k=>({pubkey:k}))),b={};y.forEach(k=>{var w,x;b[k.pubkey.toBase58()]=(x=(w=k==null?void 0:k.accountInfo)==null?void 0:w.owner)!=null?x:null});let P=this.createTxBuilder(l);for(let k of Object.values(e)){if(t[k.id]===void 0||!t[k.id].find(I=>!I.liquidity.isZero()||I.rewardInfos.find(F=>!F.rewardAmountOwed.isZero())))continue;let w=k,x=i.useSOLBalance&&w.mintA.address===Q.toString(),h=i.useSOLBalance&&w.mintB.address===Q.toString(),B=m[w.mintA.address];if(!B)if(x){let{account:I,instructionParams:F}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:w.mintA.programId,mint:new R(w.mintA.address),notUseTokenAccount:x,owner:this.scope.ownerPubKey,skipCloseAccount:!x,createInfo:{payer:i.feePayer||this.scope.ownerPubKey,amount:0},associatedOnly:x?!1:s,checkCreateATAOwner:r});B=I,F&&P.addInstruction(F)}else{let I=new R(w.mintA.address);B=this.scope.account.getAssociatedTokenAccount(I,new R(w.mintA.programId)),P.addInstruction({instructions:[qi(this.scope.ownerPubKey,B,this.scope.ownerPubKey,I,new R(w.mintA.programId))]})}let K=m[w.mintB.address];if(!K)if(h){let{account:I,instructionParams:F}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:w.mintB.programId,mint:new R(w.mintB.address),notUseTokenAccount:h,owner:this.scope.ownerPubKey,skipCloseAccount:!h,createInfo:{payer:i.feePayer||this.scope.ownerPubKey,amount:0},associatedOnly:h?!1:s,checkCreateATAOwner:r});K=I,F&&P.addInstruction(F)}else{let I=new R(w.mintB.address);K=this.scope.account.getAssociatedTokenAccount(I,new R(w.mintB.programId)),P.addInstruction({instructions:[qi(this.scope.ownerPubKey,K,this.scope.ownerPubKey,I,new R(w.mintB.programId))]})}m[w.mintA.address]=B,m[w.mintB.address]=K;let L=[];for(let I of w.rewardDefaultInfos){let F=i.useSOLBalance&&I.mint.address===Q.toString(),v=m[I.mint.address];if(!v){let{account:ce,instructionParams:pe}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:new R(I.mint.programId),mint:new R(I.mint.address),notUseTokenAccount:F,owner:this.scope.ownerPubKey,skipCloseAccount:!F,createInfo:{payer:i.feePayer||this.scope.ownerPubKey,amount:0},associatedOnly:F?!1:s});v=ce,pe&&P.addInstruction(pe)}m[I.mint.address]=v,L.push(v)}let C=await this.getClmmPoolKeys(w.id),N=[];for(let I=0;I<C.rewardInfos.length;I++)N.push({poolRewardVault:new R(C.rewardInfos[I].vault),ownerRewardVault:L[I],rewardMint:new R(C.rewardInfos[I].mint.address)});for(let I of t[k.id]){let F=(A=n==null?void 0:n[k.id])==null?void 0:A[I.nftMint.toBase58()];if(F){let v=re(this.scope.ownerPubKey,F.lockNftMint,Zt).publicKey,ce=M.getTickArrayStartIndexByTick(I.tickLower,C.config.tickSpacing),pe=M.getTickArrayStartIndexByTick(I.tickUpper,C.config.tickSpacing),{publicKey:Le}=H(new R(C.programId),F.poolId,ce),{publicKey:ze}=H(new R(C.programId),F.poolId,pe),{publicKey:$}=_e(new R(C.programId),F.poolId,I.tickLower,I.tickUpper),ne=At(d,F.lockNftMint).publicKey,We=ae.harvestLockPositionInstructionV2({programId:d,auth:f,lockPositionId:ne,clmmProgram:u,lockOwner:this.scope.ownerPubKey,lockNftMint:F.lockNftMint,lockNftAccount:v,positionNftAccount:F.nftAccount,positionId:F.positionId,poolId:F.poolId,protocolPosition:$,vaultA:new R(C.vault.A),vaultB:new R(C.vault.B),tickArrayLower:Le,tickArrayUpper:ze,userVaultA:B,userVaultB:K,mintA:new R(C.mintA.address),mintB:new R(C.mintB.address),rewardAccounts:N,exTickArrayBitmap:ge(u,F.poolId).publicKey});P.addInstruction({instructions:[We],instructionTypes:[ie.ClmmHarvestLockPosition],lookupTableAddress:C.lookupTableAccount?[C.lookupTableAccount]:[]})}else{let v=ae.decreaseLiquidityInstructions({poolInfo:w,poolKeys:C,ownerPosition:I,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccountA:B,tokenAccountB:K,rewardAccounts:L},liquidity:new Ke(0),amountMinA:new Ke(0),amountMinB:new Ke(0),nft2022:(T=b[I.nftMint.toBase58()])==null?void 0:T.equals(ct)});P.addInstruction(v)}}}return a===0?P.sizeCheckBuildV0({computeBudgetConfig:c}):P.sizeCheckBuild({computeBudgetConfig:c})}async getWhiteListMint({programId:e}){let t=await this.scope.connection.getAccountInfo(Ut(e).publicKey);return t?Ei.decode(t.data).whitelistMints.filter(i=>!i.equals(R.default)):[]}async getOwnerPositionInfo({programId:e=Nt}){await this.scope.account.fetchWalletTokenAccounts();let n=this.scope.account.tokenAccountRawInfos.filter(r=>r.accountInfo.amount.eq(new Ke(1))).map(r=>Ce(new R(e),r.accountInfo.mint).publicKey),i=await this.scope.connection.getMultipleAccountsInfo(n),s=[];return i.forEach(r=>{if(!r)return;let o=ht.decode(r.data);s.push(o)}),s}async getOwnerLockedPositionInfo({programId:e=Mt}){await this.scope.account.fetchWalletTokenAccounts();let n=this.scope.account.tokenAccountRawInfos.filter(a=>a.accountInfo.amount.eq(new Ke(1))).map(a=>At(new R(e),a.accountInfo.mint).publicKey),i=await this.scope.connection.getMultipleAccountsInfo(n),s=[];i.forEach(a=>{if(!a)return;let c=Di.decode(a.data);s.push(c)});let r=await this.scope.connection.getMultipleAccountsInfo(s.map(a=>a.positionId)),o=[];return r.forEach(a=>{if(!a)return;let c=ht.decode(a.data);o.push(c)}),s.map((a,c)=>({position:o[c],lockInfo:a}))}async getRpcClmmPoolInfo({poolId:e}){return(await this.getRpcClmmPoolInfos({poolIds:[e]}))[String(e)]}async getRpcClmmPoolInfos({poolIds:e,config:t}){let n=await Ze(this.scope.connection,e.map(s=>({pubkey:new R(s)})),t),i={};for(let s=0;s<e.length;s++){let r=n[s];if(r===null||!r.accountInfo)throw Error("fetch pool info error: "+String(e[s]));let o=mn.decode(r.accountInfo.data),a=_.sqrtPriceX64ToPrice(o.sqrtPriceX64,o.mintDecimalsA,o.mintDecimalsB).toNumber();i[String(e[s])]=U(O({},o),{currentPrice:a,programId:r.accountInfo.owner})}return i}async getComputeClmmPoolInfos({clmmPoolsRpcInfo:e,mintInfos:t}){let n=new Set(Object.keys(e).map(a=>e[a].ammConfig.toBase58())),i=await Ze(this.scope.connection,Array.from(n).map(a=>({pubkey:new R(a)}))),s={};i.forEach(a=>{!a.accountInfo||(s[a.pubkey.toBase58()]=Oi.decode(a.accountInfo.data))});let r=await de.fetchComputeMultipleClmmInfo({connection:this.scope.connection,rpcDataMap:e,poolList:Object.keys(e).map(a=>{var d,f,u,m;let[c,l]=[e[a].mintA.toBase58(),e[a].mintB.toBase58()];return{id:a,programId:e[a].programId.toBase58(),mintA:sn({address:c,decimals:e[a].mintDecimalsA,programId:t[c].programId.toBase58()||Zt.toBase58(),extensions:{feeConfig:(d=t[c])!=null&&d.feeConfig?Kn((f=t[c])==null?void 0:f.feeConfig):void 0}}),mintB:sn({address:l,decimals:e[a].mintDecimalsB,programId:t[l].programId.toBase58()||Zt.toBase58(),extensions:{feeConfig:(u=t[l])!=null&&u.feeConfig?Kn((m=t[l])==null?void 0:m.feeConfig):void 0}}),price:e[a].currentPrice,config:U(O({},s[e[a].ammConfig.toBase58()]),{id:e[a].ammConfig.toBase58(),fundFeeRate:0,description:"",defaultRange:0,defaultRangePoint:[]})}})}),o=await de.fetchMultiplePoolTickArrays({connection:this.scope.connection,poolKeys:Object.values(r)});return{computeClmmPoolInfo:r,computePoolTickData:o}}async getPoolInfoFromRpc(e){var l;let t=await this.getRpcClmmPoolInfo({poolId:e}),n=new Set([t.mintA.toBase58(),t.mintB.toBase58()]),i=await Jn({connection:this.scope.connection,mints:Array.from(n).map(d=>new R(d))}),{computeClmmPoolInfo:s,computePoolTickData:r}=await this.scope.clmm.getComputeClmmPoolInfos({clmmPoolsRpcInfo:{[e]:t},mintInfos:i}),o=await Ze(this.scope.connection,[{pubkey:t.vaultA},{pubkey:t.vaultB}]),a=Ni(s[e]);if(!o[0].accountInfo||!o[1].accountInfo)throw new Error("pool vault data not found");a.mintAmountA=Number(Vi.decode(o[0].accountInfo.data).amount.toString()),a.mintAmountB=Number(Vi.decode((l=o[1].accountInfo)==null?void 0:l.data).amount.toString());let c=U(O({},s[e]),{exBitmapAccount:s[e].exBitmapAccount.toBase58(),observationId:s[e].observationId.toBase58(),id:e,programId:t.programId.toBase58(),openTime:t.startTime.toString(),vault:{A:t.vaultA.toBase58(),B:t.vaultB.toBase58()},config:a.config,rewardInfos:s[e].rewardInfos.filter(d=>!d.tokenVault.equals(R.default)).map(d=>({mint:sn({address:d.tokenMint.toBase58(),programId:Zt.toBase58(),decimals:10}),vault:d.tokenVault.toBase58()}))});return{poolInfo:a,poolKeys:c,computePoolInfo:s[e],tickData:r}}};export{Gi as Clmm};
//# sourceMappingURL=clmm.mjs.map