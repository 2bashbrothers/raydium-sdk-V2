var el=Object.defineProperty,tl=Object.defineProperties;var nl=Object.getOwnPropertyDescriptors;var Ci=Object.getOwnPropertySymbols;var Sa=Object.prototype.hasOwnProperty,Ka=Object.prototype.propertyIsEnumerable;var xa=(m,e,t)=>e in m?el(m,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):m[e]=t,N=(m,e)=>{for(var t in e||(e={}))Sa.call(e,t)&&xa(m,t,e[t]);if(Ci)for(var t of Ci(e))Ka.call(e,t)&&xa(m,t,e[t]);return m},W=(m,e)=>tl(m,nl(e));var Ee=(m,e)=>{var t={};for(var n in m)Sa.call(m,n)&&e.indexOf(n)<0&&(t[n]=m[n]);if(m!=null&&Ci)for(var n of Ci(m))e.indexOf(n)<0&&Ka.call(m,n)&&(t[n]=m[n]);return t};import{merge as cp}from"lodash";import eu from"axios";import{PublicKey as La}from"@solana/web3.js";import{get as Ca,set as ol}from"lodash";var Wr=class{constructor(e){this.logLevel=e.logLevel!==void 0?e.logLevel:0,this.name=e.name}set level(e){this.logLevel=e}get time(){return Date.now().toString()}get moduleName(){return this.name}isLogLevel(e){return e<=this.logLevel}error(...e){return this.isLogLevel(0)?(console.error(this.time,this.name,"sdk logger error",...e),this):this}logWithError(...e){let t=e.map(n=>typeof n=="object"?JSON.stringify(n):n).join(", ");throw new Error(t)}warning(...e){return this.isLogLevel(1)?(console.warn(this.time,this.name,"sdk logger warning",...e),this):this}info(...e){return this.isLogLevel(2)?(console.info(this.time,this.name,"sdk logger info",...e),this):this}debug(...e){return this.isLogLevel(3)?(console.debug(this.time,this.name,"sdk logger debug",...e),this):this}},Ra={},il={};function fe(m){let e=Ca(Ra,m);if(!e){let t=Ca(il,m);e=new Wr({name:m,logLevel:t}),ol(Ra,m,e)}return e}import{MINT_SIZE as rl,TOKEN_PROGRAM_ID as sl,getTransferFeeConfig as al,unpackMint as ul}from"@solana/spl-token";var qr=fe("Raydium_accountInfo_util");async function Gt(m,e,t){let{batchRequest:n,commitment:o="confirmed",chunkCount:r=100}=N({batchRequest:!1},t),i=Ur(e,r),s=new Array(i.length).fill([]);if(n){let u=i.map(l=>{let d=m._buildArgs([l.map(p=>p.toBase58())],o,"base64");return{methodName:"getMultipleAccounts",args:d}}),a=Ur(u,10);s=(await(await Promise.all(a.map(async l=>await m._rpcBatchRequest(l)))).flat()).map(l=>(l.error&&qr.logWithError(`failed to get info for multiple accounts, RPC_ERROR, ${l.error.message}`),l.result.value.map(d=>{if(d){let{data:p,executable:f,lamports:y,owner:b,rentEpoch:g}=d;return p.length!==2&&p[1]!=="base64"&&qr.logWithError("info must be base64 encoded, RPC_ERROR"),{data:Buffer.from(p[0],"base64"),executable:f,lamports:y,owner:new La(b),rentEpoch:g}}return null})))}else try{s=await Promise.all(i.map(u=>m.getMultipleAccountsInfo(u,o)))}catch(u){u instanceof Error&&qr.logWithError(`failed to get info for multiple accounts, RPC_ERROR, ${u.message}`)}return s.flat()}async function Re(m,e,t){let n=await Gt(m,e.map(o=>o.pubkey),t);return e.map((o,r)=>W(N({},o),{accountInfo:n[r]}))}async function io({connection:m,mints:e,config:t}){var r,i,s;if(e.length===0)return{};let n=await Re(m,e.map(u=>({pubkey:at(u)})),t),o={};for(let u of n){if(!u.accountInfo||u.accountInfo.data.length<rl){console.log("invalid mint account",u.pubkey.toBase58());continue}let a=ul(u.pubkey,u.accountInfo,(r=u.accountInfo)==null?void 0:r.owner);o[u.pubkey.toString()]=W(N({},a),{programId:((i=u.accountInfo)==null?void 0:i.owner)||sl,feeConfig:(s=al(a))!=null?s:void 0})}return o[La.default.toBase58()]=o[j.toBase58()],o}import en from"bn.js";import $f from"decimal.js";import bl from"big.js";import Oi from"bn.js";import cl from"toformat";var ll=cl,Co=ll;import Li from"big.js";import dl from"bn.js";import pl from"decimal.js-light";import Ro from"bn.js";var Oa=9007199254740991;function $(m){let e=fe("Raydium_parseBigNumberish");if(m instanceof Ro)return m;if(typeof m=="string"){if(m.match(/^-?[0-9]+$/))return new Ro(m);e.logWithError(`invalid BigNumberish string: ${m}`)}return typeof m=="number"?(m%1&&e.logWithError(`BigNumberish number underflow: ${m}`),(m>=Oa||m<=-Oa)&&e.logWithError(`BigNumberish number overflow: ${m}`),new Ro(String(m))):typeof m=="bigint"?new Ro(m.toString()):(e.error(`invalid BigNumberish value: ${m}`),new Ro(0))}var Ri=fe("module/fraction"),Gr=Co(Li),Lo=Co(pl),fl={[0]:Lo.ROUND_DOWN,[1]:Lo.ROUND_HALF_UP,[2]:Lo.ROUND_UP},yl={[0]:Li.roundDown,[1]:Li.roundHalfUp,[2]:Li.roundUp},ke=class{constructor(e,t=new dl(1)){this.numerator=$(e),this.denominator=$(t)}get quotient(){return this.numerator.div(this.denominator)}invert(){return new ke(this.denominator,this.numerator)}add(e){let t=e instanceof ke?e:new ke($(e));return this.denominator.eq(t.denominator)?new ke(this.numerator.add(t.numerator),this.denominator):new ke(this.numerator.mul(t.denominator).add(t.numerator.mul(this.denominator)),this.denominator.mul(t.denominator))}sub(e){let t=e instanceof ke?e:new ke($(e));return this.denominator.eq(t.denominator)?new ke(this.numerator.sub(t.numerator),this.denominator):new ke(this.numerator.mul(t.denominator).sub(t.numerator.mul(this.denominator)),this.denominator.mul(t.denominator))}mul(e){let t=e instanceof ke?e:new ke($(e));return new ke(this.numerator.mul(t.numerator),this.denominator.mul(t.denominator))}div(e){let t=e instanceof ke?e:new ke($(e));return new ke(this.numerator.mul(t.denominator),this.denominator.mul(t.numerator))}toSignificant(e,t={groupSeparator:""},n=1){Number.isInteger(e)||Ri.logWithError(`${e} is not an integer.`),e<=0&&Ri.logWithError(`${e} is not positive.`),Lo.set({precision:e+1,rounding:fl[n]});let o=new Lo(this.numerator.toString()).div(this.denominator.toString()).toSignificantDigits(e);return o.toFormat(o.decimalPlaces(),t)}toFixed(e,t={groupSeparator:""},n=1){return Number.isInteger(e)||Ri.logWithError(`${e} is not an integer.`),e<0&&Ri.logWithError(`${e} is negative.`),Gr.DP=e,Gr.RM=yl[n]||1,new Gr(this.numerator.toString()).div(this.denominator.toString()).toFormat(e,t)}isZero(){return this.numerator.isZero()}};var gl=fe("Raydium_amount"),Na=Co(bl);function Al(m,e){let t="0",n="0";if(m.includes(".")){let o=m.split(".");o.length===2?([t,n]=o,n=n.padEnd(e,"0")):gl.logWithError(`invalid number string, num: ${m}`)}else t=m;return[t,n.slice(0,e)||n]}var Be=class extends ke{constructor(t,n,o=!0,r){let i=new Oi(0),s=Xr.pow(new Oi(t.decimals));if(o)i=$(n);else{let u=new Oi(0),a=new Oi(0);if(typeof n=="string"||typeof n=="number"||typeof n=="bigint"){let[c,l]=Al(n.toString(),t.decimals);u=$(c),a=$(l)}u=u.mul(s),i=u.add(a)}super(i,s);this.logger=fe(r||"TokenAmount"),this.token=t}get raw(){return this.numerator}isZero(){return this.raw.isZero()}gt(t){return this.token.equals(t.token)||this.logger.logWithError("gt token not equals"),this.raw.gt(t.raw)}lt(t){return this.token.equals(t.token)||this.logger.logWithError("lt token not equals"),this.raw.lt(t.raw)}add(t){return this.token.equals(t.token)||this.logger.logWithError("add token not equals"),new Be(this.token,this.raw.add(t.raw))}subtract(t){return this.token.equals(t.token)||this.logger.logWithError("sub token not equals"),new Be(this.token,this.raw.sub(t.raw))}toSignificant(t=this.token.decimals,n,o=0){return super.toSignificant(t,n,o)}toFixed(t=this.token.decimals,n,o=0){return t>this.token.decimals&&this.logger.logWithError("decimals overflow"),super.toFixed(t,n,o)}toExact(t={groupSeparator:""}){return Na.DP=this.token.decimals,new Na(this.numerator.toString()).div(this.denominator.toString()).toFormat(t)}};import{PublicKey as Pl}from"@solana/web3.js";import{TOKEN_PROGRAM_ID as Ma}from"@solana/spl-token";var An={chainId:101,address:Pl.default.toBase58(),programId:Ma.toBase58(),decimals:9,symbol:"SOL",name:"solana",logoURI:"https://img-v1.raydium.io/icon/So11111111111111111111111111111111111111112.png",tags:[],priority:2,type:"raydium",extensions:{coingeckoId:"solana"}},ut={chainId:101,address:"So11111111111111111111111111111111111111112",programId:Ma.toBase58(),decimals:9,symbol:"WSOL",name:"Wrapped SOL",logoURI:"https://img-v1.raydium.io/icon/So11111111111111111111111111111111111111112.png",tags:[],priority:2,type:"raydium",extensions:{coingeckoId:"solana"}};import{PublicKey as Hr}from"@solana/web3.js";import{PublicKey as _e,SystemProgram as va,SYSVAR_RENT_PUBKEY as wl}from"@solana/web3.js";import{TOKEN_PROGRAM_ID as kl}from"@solana/spl-token";function B({pubkey:m,isSigner:e=!1,isWritable:t=!0}){return{pubkey:m,isWritable:t,isSigner:e}}var zr=[B({pubkey:kl,isWritable:!1}),B({pubkey:va.programId,isWritable:!1}),B({pubkey:wl,isWritable:!1})];function Qr({publicKey:m,transformSol:e}){let t=jr(m.toString());if(t instanceof _e)return e&&t.equals($e)?j:t;if(e&&t.toString()===$e.toBase58())return j;if(typeof t=="string"){if(t===_e.default.toBase58())return _e.default;try{return new _e(t)}catch{throw new Error("invalid public key")}}throw new Error("invalid public key")}function jr(m){try{return new _e(m)}catch{return m}}var Ni=new _e("MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr"),Pn=new _e("MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr"),ot=new _e("SysvarRent111111111111111111111111111111111"),_a=new _e("SysvarC1ock11111111111111111111111111111111"),Xt=new _e("metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s"),hl=new _e("Sysvar1nstructions1111111111111111111111111"),Yr=va.programId,tf=new _e("4k3Dyjzvzp8eMZWUXbBCjEvwSkkk59S5iCNLY3QrkX6R"),nf=new _e("Ea5SjE2Y6yvCeW5dYTn7PYMuW5ikXkvbGdcmSnXeaLjS"),of=new _e("SRMuApVNdxXokk5GT7XD5cUUgXMBCoAz2LHeuAoKWRt"),rf=new _e("EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v"),sf=new _e("Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB"),af=new _e("mSoLzYCxHdYgdzU16g5QSh3i5K3z3KZK7ytfqcJm7So"),uf=new _e("7dHbWXmci3dT8UFYWYZweBLXgycu7Y3iL6trKn1Y7ARj"),cf=new _e("USDH1SM1ojwWUga67PGrgFWUHibbjqMvuMaDkRJTgkX"),lf=new _e("NRVwhjBQiUPYtfDT5zRBVJajzFQHaBUNtC7SNVvqRFa"),mf=new _e("ANAxByE6G2WjFp7A4NqtWYXb3mgruyzZYg3spfxe6Lbo"),df=new _e("7vfCXTUXx5WJV5JADk17DUJ4ksgau7utNKj4b963voxs"),j=new _e("So11111111111111111111111111111111111111112"),$e=_e.default;function at(m){return Qr({publicKey:m,transformSol:!0})}var Zr=class{constructor({mint:e,decimals:t,symbol:n,name:o,skipMint:r=!1,isToken2022:i=!1}){if(e===$e.toBase58()||e instanceof Hr&&$e.equals(e)){this.decimals=ut.decimals,this.symbol=ut.symbol,this.name=ut.name,this.mint=new Hr(ut.address),this.isToken2022=!1;return}this.decimals=t,this.symbol=n||e.toString().substring(0,6),this.name=o||e.toString().substring(0,6),this.mint=r?Hr.default:Qr({publicKey:e}),this.isToken2022=i}equals(e){return this===e?!0:this.mint.equals(e.mint)}},Fe=Zr;Fe.WSOL=new Zr(W(N({},ut),{mint:ut.address}));var $r=class{constructor({decimals:e,symbol:t="UNKNOWN",name:n="UNKNOWN"}){this.decimals=e,this.symbol=t,this.name=n}equals(e){return this===e}},Mi=$r;Mi.SOL=new $r(An);import Tl from"bn.js";var Fa=new ke(new Tl(100)),Je=class extends ke{toSignificant(e=5,t,n){return this.mul(Fa).toSignificant(e,t,n)}toFixed(e=2,t,n){return this.mul(Fa).toFixed(e,t,n)}};var Il=fe("Raydium_price"),At=class extends ke{constructor(t){let{baseToken:n,quoteToken:o,numerator:r,denominator:i}=t;super(r,i);this.baseToken=n,this.quoteToken=o,this.scalar=new ke(Jr(n.decimals),Jr(o.decimals))}get raw(){return new ke(this.numerator,this.denominator)}get adjusted(){return super.mul(this.scalar)}invert(){return new At({baseToken:this.quoteToken,quoteToken:this.baseToken,denominator:this.numerator,numerator:this.denominator})}mul(t){this.quoteToken!==t.baseToken&&Il.logWithError("mul token not equals");let n=super.mul(t);return new At({baseToken:this.baseToken,quoteToken:t.quoteToken,denominator:n.denominator,numerator:n.numerator})}toSignificant(t=this.quoteToken.decimals,n,o){return this.adjusted.toSignificant(t,n,o)}toFixed(t=this.quoteToken.decimals,n,o){return this.adjusted.toFixed(t,n,o)}};import{PublicKey as Bl}from"@solana/web3.js";import xl from"bn.js";function Va(m){return typeof m=="object"&&m!==null&&![Fe,Be,Bl,ke,xl,At,Je].some(e=>typeof e=="object"&&m instanceof e)}function it(m){return typeof m=="string"?jr(m):Array.isArray(m)?m.map(e=>it(e)):Va(m)?Object.fromEntries(Object.entries(m).map(([e,t])=>[e,it(t)])):m}var Pt=new en(0),Ea=new en(1),uy=new en(2),cy=new en(3),ly=new en(5),Xr=new en(10),my=new en(100),dy=new en(1e3),py=new en(1e4);function Jr(m){return Xr.pow($(m))}function vi(m,e){let t=m.divmod(e);return t.mod.isZero()?t.div:t.div.isNeg()?t.div.isubn(1):t.div.iaddn(1)}function _i(m,e,t){return m.mul(e).add(t).sub(new en(1)).div(t)}function es(m,e,t){return m.mul(e).div(t)}function Ur(m,e=1,t=[]){let n=[...m];if(e<=0)return t;for(;n.length;)t.push(n.splice(0,e));return t}var zt=class{constructor(e){this._owner=e}get publicKey(){return zt.isKeyPair(this._owner)?this._owner.publicKey:this._owner}get signer(){return zt.isKeyPair(this._owner)?this._owner:void 0}get isKeyPair(){return zt.isKeyPair(this._owner)}get isPublicKey(){return zt.isPublicKey(this._owner)}static isKeyPair(e){return e.secretKey!==void 0}static isPublicKey(e){return!zt.isKeyPair(e)}};import{PublicKey as Ol}from"@solana/web3.js";import{TOKEN_PROGRAM_ID as Nl}from"@solana/spl-token";import{ComputeBudgetProgram as Da,Keypair as qa,PublicKey as Sl,Transaction as Ua,TransactionMessage as Kl,VersionedTransaction as Ga}from"@solana/web3.js";var q={CreateAccount:"CreateAccount",InitAccount:"InitAccount",CreateATA:"CreateATA",CloseAccount:"CloseAccount",TransferAmount:"TransferAmount",InitMint:"InitMint",MintTo:"MintTo",InitMarket:"InitMarket",Util1216OwnerClaim:"Util1216OwnerClaim",SetComputeUnitPrice:"SetComputeUnitPrice",SetComputeUnitLimit:"SetComputeUnitLimit",ClmmCreatePool:"ClmmCreatePool",ClmmOpenPosition:"ClmmOpenPosition",ClmmIncreasePosition:"ClmmIncreasePosition",ClmmDecreasePosition:"ClmmDecreasePosition",ClmmClosePosition:"ClmmClosePosition",ClmmSwapBaseIn:"ClmmSwapBaseIn",ClmmSwapBaseOut:"ClmmSwapBaseOut",ClmmInitReward:"ClmmInitReward",ClmmSetReward:"ClmmSetReward",ClmmCollectReward:"ClmmCollectReward",ClmmLockPosition:"ClmmLockPosition",ClmmHarvestLockPosition:"ClmmHarvestLockPosition",AmmV4Swap:"AmmV4Swap",AmmV4AddLiquidity:"AmmV4AddLiquidity",AmmV4RemoveLiquidity:"AmmV4RemoveLiquidity",AmmV4SimulatePoolInfo:"AmmV4SimulatePoolInfo",AmmV4SwapBaseIn:"AmmV4SwapBaseIn",AmmV4SwapBaseOut:"AmmV4SwapBaseOut",AmmV4CreatePool:"AmmV4CreatePool",AmmV4InitPool:"AmmV4InitPool",AmmV5AddLiquidity:"AmmV5AddLiquidity",AmmV5RemoveLiquidity:"AmmV5RemoveLiquidity",AmmV5SimulatePoolInfo:"AmmV5SimulatePoolInfo",AmmV5SwapBaseIn:"AmmV5SwapBaseIn",AmmV5SwapBaseOut:"AmmV5SwapBaseOut",RouteSwap:"RouteSwap",RouteSwap1:"RouteSwap1",RouteSwap2:"RouteSwap2",FarmV3Deposit:"FarmV3Deposit",FarmV3Withdraw:"FarmV3Withdraw",FarmV3CreateLedger:"FarmV3CreateLedger",FarmV4Withdraw:"FarmV4Withdraw",FarmV5Deposit:"FarmV5Deposit",FarmV5Withdraw:"FarmV5Withdraw",FarmV5CreateLedger:"FarmV5CreateLedger",FarmV6Deposit:"FarmV6Deposit",FarmV6Withdraw:"FarmV6Withdraw",FarmV6Create:"FarmV6Create",FarmV6Restart:"FarmV6Restart",FarmV6CreatorAddReward:"FarmV6CreatorAddReward",FarmV6CreatorWithdraw:"FarmV6CreatorWithdraw",CpmmCreatePool:"CpmmCreatePool",CpmmAddLiquidity:"CpmmAddLiquidity",CpmmWithdrawLiquidity:"CpmmWithdrawLiquidity",CpmmSwapBaseIn:"CpmmSwapBaseIn",CpmmSwapBaseOut:"CpmmSwapBaseOut",CpmmLockLp:"CpmmLockLp",CpmmCollectLockFee:"CpmmCollectLockFee",TransferTip:"TransferTip"};import{TOKEN_PROGRAM_ID as Cl}from"@solana/spl-token";var Wa=fe("Raydium_txUtil"),Xa=1644;function Fi(m){let e=[],t=[];return m.microLamports&&(e.push(Da.setComputeUnitPrice({microLamports:m.microLamports})),t.push(q.SetComputeUnitPrice)),m.units&&(e.push(Da.setComputeUnitLimit({units:m.units})),t.push(q.SetComputeUnitLimit)),{instructions:e,instructionTypes:t}}async function ro(m,e){var n,o;let t=e!=null?e:"confirmed";return(o=await((n=m.getLatestBlockhash)==null?void 0:n.call(m,{commitment:t})))==null?void 0:o.blockhash}async function Vi(m,e){return m.getSignatureStatuses([e]),new Promise((t,n)=>{let o=setTimeout(n,6e4);m.onSignature(e,r=>{if(clearTimeout(o),!r.err){t("");return}n(Object.assign(r.err,{txId:e}))},"confirmed")})}function ts(m,e){m.length<1&&Wa.logWithError(`no instructions provided: ${m.toString()}`),e.length<1&&Wa.logWithError(`no signers provided:, ${e.toString()}`);let t=new Ua;t.recentBlockhash="11111111111111111111111111111111",t.feePayer=e[0],t.add(...m);try{return Buffer.from(t.serialize({verifySignatures:!1})).toString("base64").length<Xa}catch{return!1}}function se(m,e){let[t,n]=Sl.findProgramAddressSync(m,e);return{publicKey:t,nonce:n}}function Oo({instructions:m,payer:e,signers:t}){return ts(m,[e,...t])}function No({instructions:m,payer:e,lookupTableAddressAccount:t,recentBlockhash:n=qa.generate().publicKey.toString()}){let r=new Kl({payerKey:e,recentBlockhash:n,instructions:m}).compileToV0Message(Object.values(t!=null?t:{}));try{return Buffer.from(new Ga(r).serialize()).toString("base64").length<Xa}catch{return!1}}var Rl=m=>Buffer.isBuffer(m)?m:m instanceof Uint8Array?Buffer.from(m.buffer,m.byteOffset,m.byteLength):Buffer.from(m),Ll=m=>{let e=m.serialize({requireAllSignatures:!1,verifySignatures:!1});m instanceof Ga&&(e=Rl(e));try{return e instanceof Buffer?e.toString("base64"):Buffer.from(e).toString("base64")}catch{return e.toString("base64")}};function Nn(m){let e=[];return m.forEach(t=>{t instanceof Ua&&(t.recentBlockhash||(t.recentBlockhash=Cl.toBase58()),t.feePayer||(t.feePayer=qa.generate().publicKey)),e.push(Ll(t))}),console.log("simulate tx string:",e),e}function J(m,e,t){return se([m.toBuffer(),(t!=null?t:Nl).toBuffer(),e.toBuffer()],new Ol("ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL"))}import{PublicKey as ee}from"@solana/web3.js";var za=new ee("EhhTKczWMGQt46ynNeRX1WfeagwwJd7ufHvCDjRxjo5Q"),Qa=new ee("CBuCnLe26faBpcBP2fktp4rp8abpcAnTWft6ZrP5Q4T"),ja=new ee("9KEPoZmtHUrBbhWN1v1KWLMkkvwY6WLtAVUCPRtRjP4z"),Mo=new ee("FarmqiPv5eAj3j1GMdMCMUGXqPUvmquZtMy86QH6rzhG"),My=new ee("CLaimxFqjHzgTJtAGHU47NPhg6qrc5sCnpC4tBLyABQS"),Ya=new ee("srmqPvymJeFKQ4zGQed1GFppgkRHL9kaELCbyksJtPX"),ns=new ee("9xQeWvG816bUx9EPjHmaT23yvVM2ZWbrrpZb9PusVFin"),Ei=new ee("675kPX9MHTjS2zt1qfr1NYHuzeLXfQM9H24wFSUt1Mp8"),vy=new ee("5quBtoiQqxF9Jv6KYKctB59NT3gtJD2Y65kdnB1Uev3h"),Ha=new ee("CDSr3ssLcRB6XYPJwAfFt18MZvEZp4LjHcvzBVZ45duo"),Mn=new ee("CAMMCzo5YL8w4VFF8KVHrK22GGUsp5VTaW7grrKgrWqK"),vo=new ee("LockrWmn6K5twhz3y9w1dQERbmgSaRkfnTeTKbpofwE"),Di=new ee("kN1kEznaF5Xbd8LYuqtEFcxzWSBk5Fv6ygX6SqEGJVy"),vn=new ee("CDSr3ssLcRB6XYPJwAfFt18MZvEZp4LjHcvzBVZ45duo"),_y=new ee("routeUGWgWzqBWFcrCfv8tritsqukccJPu3q5GPP3xS"),Za=new ee("7YttLkHDoNj9wyDur5pM1ejNaAvT9X4eqaYcHQqtj2G5"),Ml=new ee("6FJon3QE27qgPVggARueB22hLvoh22VzJpXv4rBEoSLF"),vl=new ee("CC12se5To1CdEuw7fDS27B7Geo5jJyL7t5UK2B44NgiH"),_l=new ee("9HzJyW1qZsEiSfMUf6L2jo3CcTKAyBmSyKdwQeYisHrC"),Fl=new ee("DropEU8AvevN3UrXWXTMuz3rqnMczQVNjq3kcSdW2SQi"),Wi=new ee("CPMMoo8L3F4NbTegBCKVNunggL7H1ZpdTHKxQB5qKP1C"),$a=new ee("GpMZbSM2GgvTKHJirzeGfMFoaZ8UR2X7F4v8vHTvxFbL"),Fy=new ee("DNXgeM9EiiaAbaWvwjHj9fQQLAX5ZsfHyvmYUNRAdNC8"),qi=new ee("LockrWmn6K5twhz3y9w1dQERbmgSaRkfnTeTKbpofwE"),Ui=new ee("3f7GcQFG397GAaEnv51zR6tsTVihYRydnydDD1cXekxH"),rt=new ee("LanMV9sAd7wArD4vJFi2qDdfnVhFxYSUg6eADduJ3uj"),Vy=new ee("WLHv2UAZm6z4KyaaELi5pjdbJh6RESMva1Rnn8pJVVh"),Ey=new ee("DRay6fNdQ5J82H7xV6uq2aV3mNrUZ1J4PgSKsWgptcm6"),Dy=new ee("5xqNaZXX5eUi4p5HU4oz9i5QnwRNT2y6oN7yyn4qENeq"),Wy=new ee("4Bu96XjU84XjPDSpveTVf6LYGCkfW5FK7SNkREWcEfV4"),qy=new ee("6s1xP3hpbAfFoNtUNF8mfHsjr2Bd97JxFJRWLbL6aHuX"),_o={IDO_PROGRAM_ID_V1:Ml,IDO_PROGRAM_ID_V2:vl,IDO_PROGRAM_ID_V3:_l,IDO_PROGRAM_ID_V4:Fl};var un={OPEN_BOOK_PROGRAM:new ee("EoTcMgcDRTJVZDMZWBoU6rhYHZfkNTVEAfz3uUJRcYGj"),SERUM_PROGRAM_ID_V3:new ee("Ray1111111111111111111111111111111111111111"),AMM_V4:new ee("DRaya7Kj3aMWQSy19kSjvmuwq9docCHofyP9kanQGaav"),AMM_STABLE:new ee("DRayDdXc1NZQ9C3hRWmoSf8zK4iapgMnjdNZWrfwsP8m"),CLMM_PROGRAM_ID:new ee("DRayAUgENGQBKVaX8owNhgzkEDyoHTGVEGHVJT1E9pfH"),CLMM_LOCK_PROGRAM_ID:new ee("DRay25Usp3YJAi7beckgpGUC7mGJ2cR1AVPxhYfwVCUX"),CLMM_LOCK_AUTH_ID:new ee("6Aoh8h2Lw2m5UGxYR8AdAL87jTWYeKoxM52mJRzfYwN"),CREATE_CPMM_POOL_PROGRAM:new ee("DRaycpLY18LhpbydsBWbVJtxpNv9oXPgjRSfpF2bWpYb"),CREATE_CPMM_POOL_AUTH:new ee("CXniRufdq5xL8t8jZAPxsPZDpuudwuJSPWnbcD5Y5Nxq"),CREATE_CPMM_POOL_FEE_ACC:new ee("3oE58BKVt8KuYkGxx8zBojugnymWmBiyafWgMrnb6eYy"),LOCK_CPMM_PROGRAM:new ee("DRay25Usp3YJAi7beckgpGUC7mGJ2cR1AVPxhYfwVCUX"),LOCK_CPMM_AUTH:new ee("7qWVV8UY2bRJfDLP4s37YzBPKUkVB46DStYJBpYbQzu3"),UTIL1216:ee.default,Router:new ee("DRaybByLpbUL57LJARs3j8BitTxVfzBg351EaMr5UTCd"),FARM_PROGRAM_ID_V3:new ee("DRayWyrLmEW5KEeqs8kdTMMaBabapqagaBC7KWpGtJeZ"),FARM_PROGRAM_ID_V4:new ee("Ray1111111111111111111111111111111111111111"),FARM_PROGRAM_ID_V5:new ee("DRayiCGSZgku1GTK6rXD6mVDdingXy6APAH1R6R5L2LC"),FARM_PROGRAM_ID_V6:new ee("DRayzbYakXs45ELHkzH6vC3fuhQqTAnv5A68gdFuvZyZ"),LAUNCHPAD_PROGRAM:new ee("DRay6fNdQ5J82H7xV6uq2aV3mNrUZ1J4PgSKsWgptcm6"),LAUNCHPAD_AUTH:new ee("5xqNaZXX5eUi4p5HU4oz9i5QnwRNT2y6oN7yyn4qENeq"),LAUNCHPAD_PLATFORM:new ee("2Jx4KTDrVSdWNazuGpcA8n3ZLTRGGBDxAWhuKe2Xcj2a"),LAUNCHPAD_CONFIG:new ee("7ZR4zD7PYfY2XxoG1Gxcy2EgEeGYrpxrwzPuwdUBssEt"),FEE_DESTINATION_ID:new ee("9y8ENuuZ3b19quffx9hQvRVygG5ky6snHfRvGpuSfeJy"),MODEL_DATA_PUBKEY:new ee("Ray1111111111111111111111111111111111111111")};import Oe from"bn.js";var tn=1e4;function xe(m,e,t,n){if(e===void 0)return{amount:m,fee:void 0,expirationTime:void 0};let o=W(N({},e),{olderTransferFee:{epoch:BigInt(e.olderTransferFee.epoch),maximumFee:BigInt(e.olderTransferFee.maximumFee),transferFeeBasisPoints:e.olderTransferFee.transferFeeBasisPoints},newerTransferFee:{epoch:BigInt(e.newerTransferFee.epoch),maximumFee:BigInt(e.newerTransferFee.maximumFee),transferFeeBasisPoints:e.newerTransferFee.transferFeeBasisPoints}}),r=t.epoch<o.newerTransferFee.epoch?o.olderTransferFee:o.newerTransferFee,i=new Oe(r.maximumFee.toString()),s=t.epoch<o.newerTransferFee.epoch?(Number(o.newerTransferFee.epoch)*t.slotsInEpoch-t.absoluteSlot)*400/1e3:void 0;if(n)if(r.transferFeeBasisPoints===tn){let u=new Oe(r.maximumFee.toString());return{amount:m.add(u),fee:u,expirationTime:s}}else{let u=Qt(m.mul(new Oe(tn)),new Oe(tn-r.transferFeeBasisPoints)),a=new Oe(r.maximumFee.toString()),c=u.sub(m).gt(a)?m.add(a):u,l=Qt(c.mul(new Oe(r.transferFeeBasisPoints)),new Oe(tn)),d=l.gt(i)?i:l;return{amount:c,fee:d,expirationTime:s}}else{let u=Qt(m.mul(new Oe(r.transferFeeBasisPoints)),new Oe(tn)),a=u.gt(i)?i:u;return{amount:m,fee:a,expirationTime:s}}}function jt(m,e){return m===void 0?e:e===void 0?m:Math.min(m,e)}function Qt(m,e){let{div:t,mod:n}=m.divmod(e);return n.gt(new Oe(0))?t.add(new Oe(1)):t}function _n(m,e){if(m.isZero())return new Oe(0);let t=m.div(e);return t.isZero()?new Oe(1):m.mod(e).gt(new Oe(0))?t.add(new Oe(1)):t}function os(m,e,t){if(e===void 0)return{amount:m,fee:void 0,expirationTime:void 0};let n=Math.floor(t/432e3),o=n<e.newerTransferFee.epoch?e.olderTransferFee:e.newerTransferFee,r=new Oe(o.maximumFee.toString()),i=n<e.newerTransferFee.epoch?(Number(e.newerTransferFee.epoch)*432e3-t)*400/1e3:void 0,s=Qt(m.mul(new Oe(o.transferFeeBasisPoints)),new Oe(tn)),u=s.gt(r)?r:s;return{amount:m,fee:u,expirationTime:i}}function is(m,e,t){if(e===void 0)return{amount:m,fee:void 0,expirationTime:void 0};let n=Math.floor(t/432e3),o=n<e.newerTransferFee.epoch?e.olderTransferFee:e.newerTransferFee,r=new Oe(o.maximumFee.toString()),i=n<e.newerTransferFee.epoch?(Number(e.newerTransferFee.epoch)*432e3-t)*400/1e3:void 0;if(o.transferFeeBasisPoints===tn){let s=new Oe(o.maximumFee.toString());return{amount:m.add(s),fee:s,expirationTime:i}}else{let s=Qt(m.mul(new Oe(tn)),new Oe(tn-o.transferFeeBasisPoints)),u=new Oe(o.maximumFee.toString()),a=s.sub(m).gt(u)?m.add(u):s,c=Qt(a.mul(new Oe(o.transferFeeBasisPoints)),new Oe(tn)),l=c.gt(r)?r:c;return{amount:a,fee:l,expirationTime:i}}}import{PublicKey as rs,AddressLookupTableAccount as ao}from"@solana/web3.js";async function ss({connection:m,address:e,cluster:t="mainnet"}){let n=await Gt(m,[...new Set(e.map(r=>r.toString()))].map(r=>new rs(r))),o={};for(let r=0;r<e.length;r++){let i=n[r],s=e[r];if(!i)continue;let u=new ao({key:s,state:ao.deserialize(i.data)});o[s.toString()]=u,t==="devnet"?so[s.toString()]=u:Gi[s.toString()]=u}return o}var Gi={AcL1Vo8oy1ULiavEcjSUcwfBSForXMudcZvDZy5nzJkU:new ao({key:new rs("AcL1Vo8oy1ULiavEcjSUcwfBSForXMudcZvDZy5nzJkU"),state:ao.deserialize(Buffer.from("AQAAAP//////////I1rcEwAAAAAvAQYwun9CU6c5Ikm2pAj+D9IEnCOR45nK+SFTGSdpd6J6AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAbd9uHXZaGT2cvhRs7reawctIXtX1s3kTqM9YV+/wCpBt324e51j94YQl285GzN2rYa/E2DuQ0n/r35KNihi/wFSlNQ+F3IgtYUpVZyeIopbd8eq6vQpgZ4iEky9O72oAVKU1qZKSEGTSTocWDaOHx8NbXdvJK7geQfqEBBBUSNBqfVFxksXFEhjMlMPUrxf1ja7gibof1E49vZigAAAAAGp9UXGMd0yShWY5hpHV62i164o5tLbVxzVVshAAAAAIyXJY9OJInxuz0QKRSODYMLWhOZ2v8QhASOe9jb6fhZC3BlsePRfEU4nVJ/awTDzVi4bHMaoP21SbbRvAP4KUbIScv+6Yw2LHF/6K0ZjUPibbSWXCirYPGuuVl7zT789IUPLW4CpHr4JNCatp3ELXDLKMv6JJ+37le50lbBJ2LvBkX2T9y7AHdNGviJAqQNtlDUDCnauQRWybsLji6nPM8Qkw5asQRvCdB3MbX6IEBwytOrpM32l4jQygKG9TKgR0vZScQ2AsM/IHeQ7RajUkyhuZdc8SGiqQz/7H34torNR/Wir3sl0ruUrVxJWEZfUg+QLNAxxODdBi53/OP7Ioil1cqeBM9dtZC3FLov4yyxWRM/wcGStyJX/QfTnLBAHqkqWotPKVlShCVQqpP9W5W1rOao65IMk5QuQ2kMIOxzDMKAy2vjGSxQODgBz0QwGA+eP4ZjIjrIAQaXENv31QfLlOdXSRCkaybRniDHF4C8YcwhcvsqrOVuTP4B2Na+9wLdtrB31uz2rtlFI5kahdsnp/d1SrASDInYCtTYtdoke4kX+hoKWcEWM4Tle8pTUkUVv4BxS6fje/EzKBE4Qu/YsA/yfEEFGcr8Z57VKDw8uQzpiru7g4lvjnfapW62W030syevD8k07SGoxUHiuT/ai7gAHWWhDsVmg/C63ajgpkH7Sn3GdutArDTfyqOkdqv4/IPC/EFFy7mGkfDd2C57N5a/4jC+BbmJy7wQaSEZr0CQU88lPtUxIVvzGjC95b8Ooss2TqmkrayGKofkPMGQn7Ux+9lfwBSNfxwH8NgbpqC/7LNlV4I7nCvsXf3p+ohQk9NrAJb2KAFpUqEIJ9ZBV7BYDzHF/ORKYlgtvPnXjudZQ6CEo5OzUDaNIomTCCsvhD16TxJjsbgne1kGnQPCFSoaxUbq2V1bPMFQ3VYP6wDZ9bKStCFKx9A3tNbwZFC5ZGAN83MFK7XoTy+OmmcFEr6rLOjfSuTfPvHJkSVxW6Qllwkl67XcBi5v00u2gQsbu+38sp+rd5pA/LvyWj4P94ZGZwc1tE2P88xekCLcAwZGb+UhFzL/7K26csOb57yM5bvF9xJrLEObOkAAAAAn+HWRkdcPKyFFMnVwEoD7vnD0jCKFIU1sImubYCxNTSVzsKpaQX+fzNxrLAI3L14JQnJx/D6Uk2LADIHGqnGELzjEbkBDAlaM77NkXMPfqXNLSveCkWI7UEgNs31WEWB6XHSYI/v5DklHOb4QTtDOR804PVbi3fjloZeLR2F8d4FuZmMMO7ck3Fnkn2zEMG5gOmqsygb6PjTitArVl52NhcSznTxVnguaIJxiZkAnurDmn3MWR0PC2GLghp2KJqHCc6QQ85odeIjFHKOlRlJyeSXVJmL8vb1UgOzsbJPVP8p6zM4M3C1Sd7uWIHP33G42AP2Zg8ucn/n6meQjjD266JgCWdxZD6PXs9CsnIeL7SSG0/6lGb9xfP0ZcWkCXB/3hjxHYVXjra/GPOeXGk0fLLKjCbk+mgs2w6d2oCwimBipTzuoZ30GiI8ij8VRzD5CzMWtu2m21eDBIfjGAEo4pQeNNonKcqzV/cleX8ySZLOHsz8PtBCrLqF+VkLm9hOzIT+6i/nIf6keR4GWKMOD4AvqfpjHoD4DuhBpz8P28+DxkGrDXXr/nr20x291VPvcTU/b+b+o2kC9G0kcXeTlLjU6a2TQXWlZ4gBUdBl1jgT7mObSTpLblNiXZsLkbmVXZwvFKXua5cUKlWed/w30skmEUraTuQqtqr5fHZPW9n57EmeTif6LjHL2YJFZkQU+TrJmFzqzmF4/b8OwrPQAprl8mX3q4LUIdAS/a+11B6DWD1Xk2++Sn94dLC4xjkO4Wtlw8c4XuzciVbepHOmnoWzVu/0y3KCrLCSfQxQ3br8DJCoVzhgtPsS2nZZjsBGIZgnU0QpMv+2MnRsnKwdp1VsrCX84j/qvaZn4WhKunippgTbN2EUs0tPTP55Qfgj+nKmjtWW5IYs72FrEwJKYoNfsmqaF4o5pf4v9zgPwVwY/5I4XJKUL2L25m9kAQcW/K+H1RTFEUoj8Z4ajpOmAB/dG0COmCphVMW2CCMvnxhcGiSgPnpDuWu6qiJ7NG7ye5kvHgefgqPLeicspNJ5EpL3XiRNLM2tmJLI1awAwOyd6iHv0dCkMYRKaa6rcaZeYwmKCkckm0kM2JNmnmmAaBQQ7mwmIM0IMxX4f5W6j9PqZWcJxF7r17T/lQBAmcjoupRiJifbnXCNUv9GhpRF19WcBdeKbivRJVlGop6I2RS6lGImJ9udcI1S/0aGlEXX1ZwF14puK9ElWUainojZFYVHLHD6dIP2ESjqBzg3ol1/wB7+/ylGwd9LS7wSZ2A630CJSVKwH47K9P4bB8PEQP8BwjMFa7xQHOqZFP1XqaQ==","base64"))})},so={},as=async m=>{let e="EFhMuDw1PKEuckuFRW9PavNfTH4LKP5uKHgyXDmWpFCq";if(so[e])return so;let t=new rs(e),n=await m.getAccountInfo(t);return n&&(so[e]=new ao({key:t,state:ao.deserialize(n.data)})),so};import{PublicKey as uo,sendAndConfirmTransaction as us,SystemProgram as Vl,Transaction as Fo,TransactionMessage as Vo,VersionedTransaction as Eo}from"@solana/web3.js";import El from"axios";var Xi=2e3,zi=class{constructor(e){this.instructions=[];this.endInstructions=[];this.lookupTableAddress=[];this.signers=[];this.instructionTypes=[];this.endInstructionTypes=[];this.connection=e.connection,this.feePayer=e.feePayer,this.signAllTransactions=e.signAllTransactions,this.owner=e.owner,this.cluster=e.cluster,this.blockhashCommitment=e.blockhashCommitment,this.loopMultiTxStatus=!!e.loopMultiTxStatus}get AllTxData(){return{instructions:this.instructions,endInstructions:this.endInstructions,signers:this.signers,instructionTypes:this.instructionTypes,endInstructionTypes:this.endInstructionTypes,lookupTableAddress:this.lookupTableAddress}}get allInstructions(){return[...this.instructions,...this.endInstructions]}async getComputeBudgetConfig(){var n;let e=(await El.get(`https://solanacompass.com/api/fees?cacheFreshTime=${3e5}`)).data,{avg:t}=(n=e==null?void 0:e[15])!=null?n:{};if(!!t)return{units:6e5,microLamports:Math.min(Math.ceil(t*1e6/6e5),25e3)}}addCustomComputeBudget(e){if(e){let{instructions:t,instructionTypes:n}=Fi(e);return this.instructions.unshift(...t),this.instructionTypes.unshift(...n),!0}return!1}addTipInstruction(e){var t;return e?(this.endInstructions.push(Vl.transfer({fromPubkey:(t=e.feePayer)!=null?t:this.feePayer,toPubkey:new uo(e.address),lamports:BigInt(e.amount.toString())})),this.endInstructionTypes.push(q.TransferTip),!0):!1}async calComputeBudget({config:e,defaultIns:t}){try{let n=e||await this.getComputeBudgetConfig();if(this.addCustomComputeBudget(n))return;t&&this.instructions.unshift(...t)}catch{t&&this.instructions.unshift(...t)}}addInstruction({instructions:e=[],endInstructions:t=[],signers:n=[],instructionTypes:o=[],endInstructionTypes:r=[],lookupTableAddress:i=[]}){return this.instructions.push(...e),this.endInstructions.push(...t),this.signers.push(...n),this.instructionTypes.push(...o),this.endInstructionTypes.push(...r),this.lookupTableAddress.push(...i.filter(s=>s!==uo.default.toString())),this}async versionBuild({txVersion:e,extInfo:t}){return e===0?await this.buildV0(N({},t||{})):this.build(t)}build(e){var n;let t=new Fo;return this.allInstructions.length&&t.add(...this.allInstructions),t.feePayer=this.feePayer,((n=this.owner)==null?void 0:n.signer)&&!this.signers.some(o=>o.publicKey.equals(this.owner.publicKey))&&this.signers.push(this.owner.signer),{builder:this,transaction:t,signers:this.signers,instructionTypes:[...this.instructionTypes,...this.endInstructionTypes],execute:async o=>{var c;let{recentBlockHash:r,skipPreflight:i=!0,sendAndConfirm:s,notSendToRpc:u}=o||{},a=r!=null?r:await ro(this.connection,this.blockhashCommitment);if(t.recentBlockhash=a,this.signers.length&&t.sign(...this.signers),Nn([t]),(c=this.owner)!=null&&c.isKeyPair)return{txId:s?await us(this.connection,t,this.signers.find(d=>d.publicKey.equals(this.owner.publicKey))?this.signers:[...this.signers,this.owner.signer],{skipPreflight:i}):await this.connection.sendRawTransaction(t.serialize(),{skipPreflight:i}),signedTx:t};if(this.signAllTransactions){let l=await this.signAllTransactions([t]);if(this.signers.length)for(let d of l)try{d.sign(...this.signers)}catch{}return{txId:u?"":await this.connection.sendRawTransaction(l[0].serialize(),{skipPreflight:i}),signedTx:l[0]}}throw new Error("please provide owner in keypair format or signAllTransactions function")},extInfo:e||{}}}buildMultiTx(e){var a;let{extraPreBuildData:t=[],extInfo:n}=e,{transaction:o}=this.build(n),r=t.filter(c=>c.transaction.instructions.length>0),i=[o,...r.map(c=>c.transaction)],s=[this.signers,...r.map(c=>c.signers)],u=[...this.instructionTypes,...r.map(c=>c.instructionTypes).flat()];return(a=this.owner)!=null&&a.signer&&s.forEach(c=>{c.some(l=>l.publicKey.equals(this.owner.publicKey))||this.signers.push(this.owner.signer)}),{builder:this,transactions:i,signers:s,instructionTypes:u,execute:async c=>{var g;let{sequentially:l,onTxUpdate:d,skipTxCount:p=0,recentBlockHash:f,skipPreflight:y=!0}=c||{},b=f!=null?f:await ro(this.connection,this.blockhashCommitment);if((g=this.owner)!=null&&g.isKeyPair){if(l){let P=[],h=0;for(let I of i){if(++h,h<=p)continue;let k=await us(this.connection,I,this.signers.find(w=>w.publicKey.equals(this.owner.publicKey))?this.signers:[...this.signers,this.owner.signer],{skipPreflight:y});P.push(k)}return{txIds:P,signedTxs:i}}return{txIds:await await Promise.all(i.map(async P=>(P.recentBlockhash=b,await this.connection.sendRawTransaction(P.serialize(),{skipPreflight:y})))),signedTxs:i}}if(this.signAllTransactions){let P=i.map((I,k)=>(I.recentBlockhash=b,s[k].length&&I.sign(...s[k]),I));Nn(P);let h=await this.signAllTransactions(P);if(l){let I=0,k=[],w=async()=>{if(!h[I])return;let S=await this.connection.sendRawTransaction(h[I].serialize(),{skipPreflight:y});k.push({txId:S,status:"sent",signedTx:h[I]}),d==null||d([...k]),I++;let x=!1,K=null,T=null,C=M=>{K!==null&&clearInterval(K),T!==null&&this.connection.removeSignatureListener(T);let v=k.findIndex(R=>R.txId===S);if(v>-1){if(k[v].status==="error"||k[v].status==="success")return;k[v].status=M.err?"error":"success"}d==null||d([...k]),M.err||w()};this.loopMultiTxStatus&&(K=setInterval(async()=>{var M;if(x){clearInterval(K);return}try{let v=await this.connection.getTransaction(S,{commitment:"confirmed",maxSupportedTransactionVersion:0});v&&(x=!0,clearInterval(K),C({err:((M=v.meta)==null?void 0:M.err)||null}),console.log("tx status from getTransaction:",S))}catch(v){x=!0,clearInterval(K),console.error("getTransaction timeout:",v,S)}},Xi)),T=this.connection.onSignature(S,M=>{if(x){this.connection.removeSignatureListener(T);return}x=!0,C(M)},"confirmed"),this.connection.getSignatureStatus(S)};return await w(),{txIds:k.map(S=>S.txId),signedTxs:h}}else{let I=[];for(let k=0;k<h.length;k+=1){let w=await this.connection.sendRawTransaction(h[k].serialize(),{skipPreflight:y});I.push(w)}return{txIds:I,signedTxs:h}}}throw new Error("please provide owner in keypair format or signAllTransactions function")},extInfo:n||{}}}async versionMultiBuild({extraPreBuildData:e,txVersion:t,extInfo:n}){return t===0?await this.buildV0MultiTx({extraPreBuildData:e,buildProps:n||{}}):this.buildMultiTx({extraPreBuildData:e,extInfo:n})}async buildV0(e){var y;let f=e||{},{lookupTableCache:t={},lookupTableAddress:n=[],forerunCreate:o,recentBlockhash:r}=f,i=Ee(f,["lookupTableCache","lookupTableAddress","forerunCreate","recentBlockhash"]),s=N(N({},this.cluster==="devnet"?await as(this.connection):Gi),t),u=Array.from(new Set([...n,...this.lookupTableAddress])),a=[];for(let b of u)s[b]===void 0&&a.push(new uo(b));let c=await ss({connection:this.connection,address:a});for(let[b,g]of Object.entries(c))s[b]=g;let l=o?uo.default.toBase58():r!=null?r:await ro(this.connection,this.blockhashCommitment),d=new Vo({payerKey:this.feePayer,recentBlockhash:l,instructions:[...this.allInstructions]}).compileToV0Message(Object.values(s));((y=this.owner)==null?void 0:y.signer)&&!this.signers.some(b=>b.publicKey.equals(this.owner.publicKey))&&this.signers.push(this.owner.signer);let p=new Eo(d);return p.sign(this.signers),{builder:this,transaction:p,signers:this.signers,instructionTypes:[...this.instructionTypes,...this.endInstructionTypes],execute:async b=>{var I;let{skipPreflight:g=!0,sendAndConfirm:P,notSendToRpc:h}=b||{};if(Nn([p]),(I=this.owner)!=null&&I.isKeyPair){let k=await this.connection.sendTransaction(p,{skipPreflight:g});return P&&await Vi(this.connection,k),{txId:k,signedTx:p}}if(this.signAllTransactions){let k=await this.signAllTransactions([p]);if(this.signers.length)for(let w of k)try{w.sign(this.signers)}catch{}return{txId:h?"":await this.connection.sendTransaction(k[0],{skipPreflight:g}),signedTx:k[0]}}throw new Error("please provide owner in keypair format or signAllTransactions function")},extInfo:i||{}}}async buildV0MultiTx(e){var a;let{extraPreBuildData:t=[],buildProps:n}=e,{transaction:o}=await this.buildV0(n),r=t.filter(c=>c.builder.instructions.length>0),i=[o,...r.map(c=>c.transaction)],s=[this.signers,...r.map(c=>c.signers)],u=[...this.instructionTypes,...r.map(c=>c.instructionTypes).flat()];return(a=this.owner)!=null&&a.signer&&s.forEach(c=>{c.some(l=>l.publicKey.equals(this.owner.publicKey))||this.signers.push(this.owner.signer)}),i.forEach(async(c,l)=>{c.sign(s[l])}),{builder:this,transactions:i,signers:s,instructionTypes:u,buildProps:n,execute:async c=>{var y;let{sequentially:l,onTxUpdate:d,recentBlockHash:p,skipPreflight:f=!0}=c||{};if(p&&i.forEach(b=>b.message.recentBlockhash=p),Nn(i),(y=this.owner)!=null&&y.isKeyPair){if(l){let b=[];for(let g of i){let P=await this.connection.sendTransaction(g,{skipPreflight:f});await Vi(this.connection,P),b.push(P)}return{txIds:b,signedTxs:i}}return{txIds:await Promise.all(i.map(async b=>await this.connection.sendTransaction(b,{skipPreflight:f}))),signedTxs:i}}if(this.signAllTransactions){let b=await this.signAllTransactions(i);if(l){let g=0,P=[],h=async()=>{if(!b[g])return;let I=await this.connection.sendTransaction(b[g],{skipPreflight:f});P.push({txId:I,status:"sent",signedTx:b[g]}),d==null||d([...P]),g++;let k=!1,w=null,S=null,x=K=>{w!==null&&clearInterval(w),S!==null&&this.connection.removeSignatureListener(S);let T=P.findIndex(C=>C.txId===I);if(T>-1){if(P[T].status==="error"||P[T].status==="success")return;P[T].status=K.err?"error":"success"}d==null||d([...P]),K.err||h()};this.loopMultiTxStatus&&(w=setInterval(async()=>{var K;if(k){clearInterval(w);return}try{let T=await this.connection.getTransaction(I,{commitment:"confirmed",maxSupportedTransactionVersion:0});T&&(k=!0,clearInterval(w),x({err:((K=T.meta)==null?void 0:K.err)||null}),console.log("tx status from getTransaction:",I))}catch(T){k=!0,clearInterval(w),console.error("getTransaction timeout:",T,I)}},Xi)),S=this.connection.onSignature(I,K=>{if(k){this.connection.removeSignatureListener(S);return}k=!0,x(K)},"confirmed"),this.connection.getSignatureStatus(I)};return h(),{txIds:[],signedTxs:b}}else{let g=[];for(let P=0;P<b.length;P+=1){let h=await this.connection.sendTransaction(b[P],{skipPreflight:f});g.push(h)}return{txIds:g,signedTxs:b}}}throw new Error("please provide owner in keypair format or signAllTransactions function")},extInfo:n||{}}}async sizeCheckBuild(e){var d;let l=e||{},{splitIns:t=[],computeBudgetConfig:n}=l,o=Ee(l,["splitIns","computeBudgetConfig"]),r=n?Fi(n):{instructions:[],instructionTypes:[]},i=this.signers.reduce((p,f)=>W(N({},p),{[f.publicKey.toBase58()]:f}),{}),s=[],u=[],a=[],c=0;if(this.allInstructions.forEach(p=>{let f=[...a,p],y=n?[...r.instructions,...f]:f,g=[...new Set(f.map(P=>P.keys.filter(h=>h.isSigner).map(h=>h.pubkey.toString())).flat()).values()].map(P=>new uo(P));if(p!==t[c]&&a.length<12&&(Oo({instructions:y,payer:this.feePayer,signers:g})||Oo({instructions:f,payer:this.feePayer,signers:g})))a.push(p);else{if(a.length===0)throw Error("item ins too big");c+=p===t[c]?1:0,Oo({instructions:n?[...r.instructions,...a]:[...a],payer:this.feePayer,signers:g})?s.push(new Fo().add(...r.instructions,...a)):s.push(new Fo().add(...a)),u.push(Array.from(new Set(a.map(P=>P.keys.filter(h=>h.isSigner).map(h=>h.pubkey.toString())).flat())).map(P=>i[P]).filter(P=>P!==void 0)),a=[p]}}),a.length>0){let f=[...new Set(a.map(y=>y.keys.filter(b=>b.isSigner).map(b=>b.pubkey.toString())).flat()).values()].map(y=>i[y]).filter(y=>y!==void 0);Oo({instructions:n?[...r.instructions,...a]:[...a],payer:this.feePayer,signers:f.map(y=>y.publicKey)})?s.push(new Fo().add(...r.instructions,...a)):s.push(new Fo().add(...a)),u.push(f)}return s.forEach(p=>p.feePayer=this.feePayer),(d=this.owner)!=null&&d.signer&&u.forEach(p=>{p.some(f=>f.publicKey.equals(this.owner.publicKey))||p.push(this.owner.signer)}),{builder:this,transactions:s,signers:u,instructionTypes:this.instructionTypes,execute:async p=>{var I;let{sequentially:f,onTxUpdate:y,skipTxCount:b=0,recentBlockHash:g,skipPreflight:P=!0}=p||{},h=g!=null?g:await ro(this.connection,this.blockhashCommitment);if(s.forEach(async(k,w)=>{k.recentBlockhash=h,u[w].length&&k.sign(...u[w])}),Nn(s),(I=this.owner)!=null&&I.isKeyPair){if(f){let k=0,w=[];for(let S of s){if(++k,k<=b){w.push("tx skipped");continue}let x=await us(this.connection,S,this.signers.find(K=>K.publicKey.equals(this.owner.publicKey))?this.signers:[...this.signers,this.owner.signer],{skipPreflight:P});w.push(x)}return{txIds:w,signedTxs:s}}return{txIds:await Promise.all(s.map(async k=>await this.connection.sendRawTransaction(k.serialize(),{skipPreflight:P}))),signedTxs:s}}if(this.signAllTransactions){let k=await this.signAllTransactions(s.slice(b,s.length)),w=[...s.slice(0,b),...k];if(f){let S=0,x=[],K=async()=>{if(!w[S])return;S<b&&(x.push({txId:"",status:"success",signedTx:w[S]}),y==null||y([...x]),S++,K());let T=await this.connection.sendRawTransaction(w[S].serialize(),{skipPreflight:P});x.push({txId:T,status:"sent",signedTx:w[S]}),y==null||y([...x]),S++;let C=!1,M=null,v=null,R=L=>{M!==null&&clearInterval(M),v!==null&&this.connection.removeSignatureListener(v);let F=x.findIndex(X=>X.txId===T);if(F>-1){if(x[F].status==="error"||x[F].status==="success")return;x[F].status=L.err?"error":"success"}y==null||y([...x]),L.err||K()};this.loopMultiTxStatus&&(M=setInterval(async()=>{var L;if(C){clearInterval(M);return}try{let F=await this.connection.getTransaction(T,{commitment:"confirmed",maxSupportedTransactionVersion:0});F&&(C=!0,clearInterval(M),R({err:((L=F.meta)==null?void 0:L.err)||null}),console.log("tx status from getTransaction:",T))}catch(F){C=!0,clearInterval(M),console.error("getTransaction timeout:",F,T)}},Xi)),v=this.connection.onSignature(T,L=>{if(C){this.connection.removeSignatureListener(v);return}C=!0,R(L)},"confirmed"),this.connection.getSignatureStatus(T)};return await K(),{txIds:x.map(T=>T.txId),signedTxs:w}}else{let S=[];for(let x=0;x<w.length;x+=1){let K=await this.connection.sendRawTransaction(w[x].serialize(),{skipPreflight:P});S.push(K)}return{txIds:S,signedTxs:w}}}throw new Error("please provide owner in keypair format or signAllTransactions function")},extInfo:o||{}}}async sizeCheckBuildV0(e){var h;let P=e||{},{computeBudgetConfig:t,splitIns:n=[],lookupTableCache:o={},lookupTableAddress:r=[]}=P,i=Ee(P,["computeBudgetConfig","splitIns","lookupTableCache","lookupTableAddress"]),s=N(N({},this.cluster==="devnet"?await as(this.connection):Gi),o),u=Array.from(new Set([...this.lookupTableAddress,...r])),a=[];for(let I of u)s[I]===void 0&&a.push(new uo(I));let c=await ss({connection:this.connection,address:a});for(let[I,k]of Object.entries(c))s[I]=k;let l=t?Fi(t):{instructions:[],instructionTypes:[]},d=await ro(this.connection,this.blockhashCommitment),p=this.signers.reduce((I,k)=>W(N({},I),{[k.publicKey.toBase58()]:k}),{}),f=[],y=[],b=[],g=0;if(this.allInstructions.forEach(I=>{let k=[...b,I],w=t?[...l.instructions,...k]:k;if(I!==n[g]&&b.length<12&&(No({instructions:w,payer:this.feePayer,lookupTableAddressAccount:s})||No({instructions:k,payer:this.feePayer,lookupTableAddressAccount:s})))b.push(I);else{if(b.length===0)throw Error("item ins too big");g+=I===n[g]?1:0;let S={};for(let x of[...new Set(u)])s[x]!==void 0&&(S[x]=s[x]);if(t&&No({instructions:[...l.instructions,...b],payer:this.feePayer,lookupTableAddressAccount:s,recentBlockhash:d})){let x=new Vo({payerKey:this.feePayer,recentBlockhash:d,instructions:[...l.instructions,...b]}).compileToV0Message(Object.values(s));f.push(new Eo(x))}else{let x=new Vo({payerKey:this.feePayer,recentBlockhash:d,instructions:[...b]}).compileToV0Message(Object.values(s));f.push(new Eo(x))}y.push(Array.from(new Set(b.map(x=>x.keys.filter(K=>K.isSigner).map(K=>K.pubkey.toString())).flat())).map(x=>p[x]).filter(x=>x!==void 0)),b=[I]}}),b.length>0){let k=[...new Set(b.map(w=>w.keys.filter(S=>S.isSigner).map(S=>S.pubkey.toString())).flat()).values()].map(w=>p[w]).filter(w=>w!==void 0);if(t&&No({instructions:[...l.instructions,...b],payer:this.feePayer,lookupTableAddressAccount:s,recentBlockhash:d})){let w=new Vo({payerKey:this.feePayer,recentBlockhash:d,instructions:[...l.instructions,...b]}).compileToV0Message(Object.values(s));f.push(new Eo(w))}else{let w=new Vo({payerKey:this.feePayer,recentBlockhash:d,instructions:[...b]}).compileToV0Message(Object.values(s));f.push(new Eo(w))}y.push(k)}return(h=this.owner)!=null&&h.signer&&y.forEach(I=>{I.some(k=>k.publicKey.equals(this.owner.publicKey))||I.push(this.owner.signer)}),f.forEach((I,k)=>{I.sign(y[k])}),{builder:this,transactions:f,buildProps:e,signers:y,instructionTypes:this.instructionTypes,execute:async I=>{var T;let{sequentially:k,onTxUpdate:w,skipTxCount:S=0,recentBlockHash:x,skipPreflight:K=!0}=I||{};if(f.map(async(C,M)=>{y[M].length&&C.sign(y[M]),x&&(C.message.recentBlockhash=x)}),Nn(f),(T=this.owner)!=null&&T.isKeyPair){if(k){let C=0,M=[];for(let v of f){if(++C,C<=S){console.log("skip tx: ",C),M.push("tx skipped");continue}let R=await this.connection.sendTransaction(v,{skipPreflight:K});await Vi(this.connection,R),M.push(R)}return{txIds:M,signedTxs:f}}return{txIds:await Promise.all(f.map(async C=>await this.connection.sendTransaction(C,{skipPreflight:K}))),signedTxs:f}}if(this.signAllTransactions){let C=await this.signAllTransactions(f.slice(S,f.length)),M=[...f.slice(0,S),...C];if(k){let v=0,R=[],L=async()=>{if(!M[v])return;if(v<S){R.push({txId:"",status:"success",signedTx:M[v]}),w==null||w([...R]),v++,L();return}let F=await this.connection.sendTransaction(M[v],{skipPreflight:K});R.push({txId:F,status:"sent",signedTx:M[v]}),w==null||w([...R]),v++;let X=!1,H=null,re=null,ye=ue=>{H!==null&&clearInterval(H),re!==null&&this.connection.removeSignatureListener(re);let me=R.findIndex(pe=>pe.txId===F);if(me>-1){if(R[me].status==="error"||R[me].status==="success")return;R[me].status=ue.err?"error":"success"}w==null||w([...R]),ue.err||L()};this.loopMultiTxStatus&&(H=setInterval(async()=>{var ue;if(X){clearInterval(H);return}try{let me=await this.connection.getTransaction(F,{commitment:"confirmed",maxSupportedTransactionVersion:0});me&&(X=!0,clearInterval(H),ye({err:((ue=me.meta)==null?void 0:ue.err)||null}),console.log("tx status from getTransaction:",F))}catch(me){X=!0,clearInterval(H),console.error("getTransaction timeout:",me,F)}},Xi)),re=this.connection.onSignature(F,ue=>{if(X){this.connection.removeSignatureListener(re);return}X=!0,ye(ue)},"confirmed"),this.connection.getSignatureStatus(F)};return L(),{txIds:[],signedTxs:M}}else{let v=[];for(let R=0;R<M.length;R+=1){let L=await this.connection.sendTransaction(M[R],{skipPreflight:K});v.push(L)}return{txIds:v,signedTxs:M}}}throw new Error("please provide owner in keypair format or signAllTransactions function")},extInfo:i||{}}}};import Dl from"bn.js";var Yt=new Dl(1e6);var et={BASE_HOST:"https://api-v3.raydium.io",OWNER_BASE_HOST:"https://owner-v1.raydium.io",SERVICE_BASE_HOST:"https://service.raydium.io",MONITOR_BASE_HOST:"https://monitor.raydium.io",SERVICE_1_BASE_HOST:"https://service-v1.raydium.io",SEND_TRANSACTION:"/send-transaction",FARM_ARP:"/main/farm/info",FARM_ARP_LINE:"/main/farm-apr-tv",CLMM_CONFIG:"/main/clmm-config",CPMM_CONFIG:"/main/cpmm-config",VERSION:"/main/version",CHECK_AVAILABILITY:"/v3/main/AvailabilityCheckAPI",RPCS:"/main/rpcs",INFO:"/main/info",STAKE_POOLS:"/main/stake-pools",CHAIN_TIME:"/main/chain-time",TOKEN_LIST:"/mint/list",MINT_INFO_ID:"/mint/ids",JUP_TOKEN_LIST:"https://lite-api.jup.ag/tokens/v1/tagged/verified",POOL_LIST:"/pools/info/list",POOL_SEARCH_BY_ID:"/pools/info/ids",POOL_SEARCH_MINT:"/pools/info/mint",POOL_SEARCH_LP:"/pools/info/lps",POOL_KEY_BY_ID:"/pools/key/ids",POOL_LIQUIDITY_LINE:"/pools/line/liquidity",POOL_POSITION_LINE:"/pools/line/position",FARM_INFO:"/farms/info/ids",FARM_LP_INFO:"/farms/info/lp",FARM_KEYS:"/farms/key/ids",OWNER_CREATED_FARM:"/create-pool/{owner}",OWNER_IDO:"/main/ido/{owner}",OWNER_STAKE_FARMS:"/position/stake/{owner}",OWNER_LOCK_POSITION:"/position/clmm-lock/{owner}",IDO_KEYS:"/ido/key/ids",SWAP_HOST:"https://transaction-v1.raydium.io",SWAP_COMPUTE:"/compute/",SWAP_TX:"/transaction/",MINT_PRICE:"/mint/price",MIGRATE_CONFIG:"/main/migrate-lp",PRIORITY_FEE:"/main/auto-fee",CPMM_LOCK:"https://dynamic-ipfs.raydium.io/lock/cpmm/position"},Rb=N({},et);var Ja="ray_tab_hash",cs="ray_req_hash",Wl=()=>{if(typeof window===void 0)return"";let m=sessionStorage.getItem(Ja);return m||(m=`ray-${Date.now()}`,sessionStorage.setItem(Ja,m)),m},Qi=async n=>{var o=n,{logCount:m=1e3,removeLastLog:e}=o,t=Ee(o,["logCount","removeLastLog"]);if(typeof window===void 0)return new Promise(i=>i());let r=JSON.parse(localStorage.getItem(cs)||"[]").slice(0,m-1);e&&r.pop(),new Blob([JSON.stringify(t.data)]).size>1024&&(t.data=JSON.stringify(t.data).substring(0,200)+"..."),r.unshift(W(N({},t),{time:Date.now(),session:Wl()}));try{localStorage.setItem(cs,JSON.stringify(r))}catch{if(e){let i=!1,s=JSON.stringify(t.data).substring(0,100);for(r[0].data=s+(s.length>100?"...":"");!i;){r.pop();let u=JSON.stringify(t.data).substring(0,100);r[0].data=u+(u.length>100?"...":"");try{localStorage.setItem(cs,JSON.stringify(r)),i=!0}catch{i=!1}}return new Promise(u=>u())}return Qi(W(N({},t),{logCount:m,removeLastLog:!0}))}};import{TOKEN_2022_PROGRAM_ID as ql,TOKEN_PROGRAM_ID as Ul}from"@solana/spl-token";var ji=fe("Raydium_Api"),ls=new Map;var Yi=class{constructor({cluster:e,timeout:t,logRequests:n,logCount:o,urlConfigs:r}){this.cluster=e,this.urlConfigs=r||{},this.logCount=o||1e3,this.api=eu.create({baseURL:this.urlConfigs.BASE_HOST||et.BASE_HOST,timeout:t}),this.api.interceptors.request.use(i=>{let{method:s,baseURL:u,url:a}=i;return ji.debug(`${s==null?void 0:s.toUpperCase()} ${u}${a}`),i},i=>(ji.error("Request failed"),Promise.reject(i))),this.api.interceptors.response.use(i=>{let{config:s,data:u,status:a}=i,{method:c,baseURL:l,url:d}=s;return n&&Qi({status:a,url:`${l}${d}`,params:s.params,data:u,logCount:this.logCount}),ji.debug(`${c==null?void 0:c.toUpperCase()} ${l}${d}  ${a}`),u},i=>{let{config:s,response:u={}}=i,{status:a}=u,{method:c,baseURL:l,url:d}=s;return n&&Qi({status:a,url:`${l}${d}`,params:s.params,data:i.message,logCount:this.logCount}),ji.error(`${c.toUpperCase()} ${l}${d} ${a||i.message}`),Promise.reject(i)})}async getClmmConfigs(){return(await this.api.get(this.urlConfigs.CLMM_CONFIG||et.CLMM_CONFIG)).data}async getCpmmConfigs(){return(await this.api.get(this.urlConfigs.CPMM_CONFIG||et.CPMM_CONFIG)).data}async getClmmPoolLines(e){return(await this.api.get(`${this.urlConfigs.POOL_LIQUIDITY_LINE||et.POOL_LIQUIDITY_LINE}?pool_id=${e}`)).data}async getBlockSlotCountForSecond(e){if(!e)return 2;let n=(await eu.post(e,{id:"getRecentPerformanceSamples",jsonrpc:"2.0",method:"getRecentPerformanceSamples",params:[4]})).result.map(o=>o.numSlots);return n.reduce((o,r)=>o+r,0)/n.length/60}async getChainTimeOffset(){return(await this.api.get(this.urlConfigs.CHAIN_TIME||et.CHAIN_TIME)).data}async getRpcs(){return this.api.get(this.urlConfigs.RPCS||et.RPCS)}async getTokenList(){return(await this.api.get(this.urlConfigs.TOKEN_LIST||et.TOKEN_LIST)).data}async getJupTokenList(){return(await this.api.get("",{baseURL:this.urlConfigs.JUP_TOKEN_LIST||et.JUP_TOKEN_LIST})).map(t=>W(N({},t),{chainId:101,programId:t.tags.includes("token-2022")?ql.toBase58():Ul.toBase58()}))}async getTokenInfo(e){return(await this.api.get((this.urlConfigs.MINT_INFO_ID||et.MINT_INFO_ID)+`?mints=${e.map(n=>n.toString()).join(",")}`)).data}async getPoolList(e={}){let{type:t="all",sort:n="liquidity",order:o="desc",page:r=0,pageSize:i=100}=e;return(await this.api.get((this.urlConfigs.POOL_LIST||et.POOL_LIST)+`?poolType=${t}&poolSortField=${n}&sortType=${o}&page=${r}&pageSize=${i}`)).data}async fetchPoolById(e){let{ids:t}=e;return(await this.api.get((this.urlConfigs.POOL_SEARCH_BY_ID||et.POOL_SEARCH_BY_ID)+`?ids=${t}`)).data}async fetchPoolKeysById(e){let{idList:t}=e,n=[],o=t.filter(i=>ls.has(i)?(n.push(ls.get(i)),!1):!0),r=[];return o.length&&(r=(await this.api.get((this.urlConfigs.POOL_KEY_BY_ID||et.POOL_KEY_BY_ID)+`?ids=${o.join(",")}`)).data.filter(Boolean),r.forEach(s=>{ls.set(s.id,s)})),n.concat(r)}async fetchPoolByMints(e){let{mint1:t,mint2:n,type:o="all",sort:r="default",order:i="desc",page:s=1}=e,[u,a]=[t&&at(t).toBase58(),n&&n!=="undefined"?at(n).toBase58():""],[c,l]=a&&u>a?[a,u]:[u,a];return(await this.api.get((this.urlConfigs.POOL_SEARCH_MINT||et.POOL_SEARCH_MINT)+`?mint1=${c}&mint2=${l}&poolType=${o}&poolSortField=${r}&sortType=${i}&pageSize=100&page=${s}`)).data}async fetchFarmInfoById(e){let{ids:t}=e;return(await this.api.get((this.urlConfigs.FARM_INFO||et.FARM_INFO)+`?ids=${t}`)).data}async fetchFarmKeysById(e){let{ids:t}=e;return(await this.api.get((this.urlConfigs.FARM_KEYS||et.FARM_KEYS)+`?ids=${t}`)).data}async fetchAvailabilityStatus(){return(await this.api.get(this.urlConfigs.CHECK_AVAILABILITY||et.CHECK_AVAILABILITY)).data}};var Hi="please provide owner in load() initialization or you can set by calling raydium.setOwner(owner)",tu="please provide connection in load() initialization or set it by raydium.setConnection(connection)";import{PublicKey as or,SystemProgram as wm}from"@solana/web3.js";import{AccountLayout as po,createAssociatedTokenAccountIdempotentInstruction as ws,TOKEN_PROGRAM_ID as Tn,TOKEN_2022_PROGRAM_ID as km}from"@solana/spl-token";var ms=(...m)=>m.map(e=>{try{return typeof e=="object"?JSON.stringify(e):e}catch{return e}}).join(", "),Ne=class{constructor({scope:e,moduleName:t}){this.disabled=!1;this.scope=e,this.logger=fe(t)}createTxBuilder(e){return this.scope.checkOwner(),new zi({connection:this.scope.connection,feePayer:e||this.scope.ownerPubKey,cluster:this.scope.cluster,owner:this.scope.owner,blockhashCommitment:this.scope.blockhashCommitment,loopMultiTxStatus:this.scope.loopMultiTxStatus,api:this.scope.api,signAllTransactions:this.scope.signAllTransactions})}logDebug(...e){this.logger.debug(ms(e))}logInfo(...e){this.logger.info(ms(e))}logAndCreateError(...e){let t=ms(e);throw new Error(t)}checkDisabled(){(this.disabled||!this.scope)&&this.logAndCreateError("module not working")}};import{PublicKey as fm,SystemProgram as ym}from"@solana/web3.js";import bm from"bn.js";import{createCloseAccountInstruction as gm,createInitializeAccountInstruction as Am,createTransferInstruction as Pm,TOKEN_PROGRAM_ID as mo}from"@solana/spl-token";import{Keypair as lm,PublicKey as bu}from"@solana/web3.js";import mm from"bn.js";import{TOKEN_PROGRAM_ID as dm}from"@solana/spl-token";function Gl(m){return m instanceof Uint8Array||m!=null&&typeof m=="object"&&m.constructor.name==="Uint8Array"}function ds(m,...e){if(!Gl(m))throw new Error("Uint8Array expected");if(e.length>0&&!e.includes(m.length))throw new Error(`Uint8Array expected of length ${e}, not of length=${m.length}`)}function ps(m,e=!0){if(m.destroyed)throw new Error("Hash instance has been destroyed");if(e&&m.finished)throw new Error("Hash#digest() has already been called")}function nu(m,e){ds(m);let t=e.outputLen;if(m.length<t)throw new Error(`digestInto() expects output buffer of length at least ${t}`)}var $i=m=>new DataView(m.buffer,m.byteOffset,m.byteLength),Ht=(m,e)=>m<<32-e|m>>>e;var yg=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;function Xl(m){if(typeof m!="string")throw new Error(`utf8ToBytes expected string, got ${typeof m}`);return new Uint8Array(new TextEncoder().encode(m))}function fs(m){return typeof m=="string"&&(m=Xl(m)),ds(m),m}var Zi=class{clone(){return this._cloneInto()}},bg={}.toString;function ou(m){let e=n=>m().update(fs(n)).digest(),t=m();return e.outputLen=t.outputLen,e.blockLen=t.blockLen,e.create=()=>m(),e}function zl(m,e,t,n){if(typeof m.setBigUint64=="function")return m.setBigUint64(e,t,n);let o=BigInt(32),r=BigInt(4294967295),i=Number(t>>o&r),s=Number(t&r),u=n?4:0,a=n?0:4;m.setUint32(e+u,i,n),m.setUint32(e+a,s,n)}var iu=(m,e,t)=>m&e^~m&t,ru=(m,e,t)=>m&e^m&t^e&t,Ji=class extends Zi{constructor(e,t,n,o){super(),this.blockLen=e,this.outputLen=t,this.padOffset=n,this.isLE=o,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(e),this.view=$i(this.buffer)}update(e){ps(this);let{view:t,buffer:n,blockLen:o}=this;e=fs(e);let r=e.length;for(let i=0;i<r;){let s=Math.min(o-this.pos,r-i);if(s===o){let u=$i(e);for(;o<=r-i;i+=o)this.process(u,i);continue}n.set(e.subarray(i,i+s),this.pos),this.pos+=s,i+=s,this.pos===o&&(this.process(t,0),this.pos=0)}return this.length+=e.length,this.roundClean(),this}digestInto(e){ps(this),nu(e,this),this.finished=!0;let{buffer:t,view:n,blockLen:o,isLE:r}=this,{pos:i}=this;t[i++]=128,this.buffer.subarray(i).fill(0),this.padOffset>o-i&&(this.process(n,0),i=0);for(let l=i;l<o;l++)t[l]=0;zl(n,o-8,BigInt(this.length*8),r),this.process(n,0);let s=$i(e),u=this.outputLen;if(u%4)throw new Error("_sha2: outputLen should be aligned to 32bit");let a=u/4,c=this.get();if(a>c.length)throw new Error("_sha2: outputLen bigger than state");for(let l=0;l<a;l++)s.setUint32(4*l,c[l],r)}digest(){let{buffer:e,outputLen:t}=this;this.digestInto(e);let n=e.slice(0,t);return this.destroy(),n}_cloneInto(e){e||(e=new this.constructor),e.set(...this.get());let{blockLen:t,buffer:n,length:o,finished:r,destroyed:i,pos:s}=this;return e.length=o,e.pos=s,e.finished=r,e.destroyed=i,o%t&&e.buffer.set(n),e}};var Ql=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),wn=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),kn=new Uint32Array(64),ys=class extends Ji{constructor(){super(64,32,8,!1),this.A=wn[0]|0,this.B=wn[1]|0,this.C=wn[2]|0,this.D=wn[3]|0,this.E=wn[4]|0,this.F=wn[5]|0,this.G=wn[6]|0,this.H=wn[7]|0}get(){let{A:e,B:t,C:n,D:o,E:r,F:i,G:s,H:u}=this;return[e,t,n,o,r,i,s,u]}set(e,t,n,o,r,i,s,u){this.A=e|0,this.B=t|0,this.C=n|0,this.D=o|0,this.E=r|0,this.F=i|0,this.G=s|0,this.H=u|0}process(e,t){for(let l=0;l<16;l++,t+=4)kn[l]=e.getUint32(t,!1);for(let l=16;l<64;l++){let d=kn[l-15],p=kn[l-2],f=Ht(d,7)^Ht(d,18)^d>>>3,y=Ht(p,17)^Ht(p,19)^p>>>10;kn[l]=y+kn[l-7]+f+kn[l-16]|0}let{A:n,B:o,C:r,D:i,E:s,F:u,G:a,H:c}=this;for(let l=0;l<64;l++){let d=Ht(s,6)^Ht(s,11)^Ht(s,25),p=c+d+iu(s,u,a)+Ql[l]+kn[l]|0,y=(Ht(n,2)^Ht(n,13)^Ht(n,22))+ru(n,o,r)|0;c=a,a=u,u=s,s=i+p|0,i=r,r=o,o=n,n=p+y|0}n=n+this.A|0,o=o+this.B|0,r=r+this.C|0,i=i+this.D|0,s=s+this.E|0,u=u+this.F|0,a=a+this.G|0,c=c+this.H|0,this.set(n,o,r,i,s,u,a,c)}roundClean(){kn.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}};var su=ou(()=>new ys);import{PublicKey as sm}from"@solana/web3.js";import du,{isBN as pu}from"bn.js";import{bits as jl,BitStructure as Bg,blob as Yl,Blob as xg,cstr as Sg,f32 as Kg,f32be as Cg,f64 as Rg,f64be as Lg,greedy as Og,Layout as Hl,ns64 as Ng,ns64be as Mg,nu64 as Zl,nu64be as vg,offset as $l,s16 as _g,s16be as Fg,s24 as Vg,s24be as Eg,s32 as Jl,s32be as Dg,s40 as Wg,s40be as qg,s48 as Ug,s48be as Gg,s8 as Xg,seq as em,struct as zg,Structure as tm,u16 as nm,u16be as Qg,u24 as jg,u24be as Yg,u32 as om,u32be as Hg,u40 as Zg,u40be as $g,u48 as Jg,u48be as eA,u8 as im,UInt as rm,union as tA,Union as nA,unionLayoutDiscriminator as oA,utf8 as iA}from"@solana/buffer-layout";var er=Hl,au=tm;var bs=rm;var uu=im,Tt=nm;var tr=om;var cu=Zl;var Me=Jl;var lu=em;var he=Yl;var gs=jl,mu=$l;var Vn=class extends er{constructor(t,n,o){super(t,o);this.blob=he(t),this.signed=n}decode(t,n=0){let o=new du(this.blob.decode(t,n),10,"le");return this.signed?o.fromTwos(this.span*8).clone():o}encode(t,n,o=0){return typeof t=="number"&&(t=new du(t)),this.signed&&(t=t.toTwos(this.span*8)),this.blob.encode(t.toArrayLike(Buffer,"le",this.span),n,o)}},nr=class extends er{constructor(t){super(8,t);this._lower=gs(tr(),!1),this._upper=gs(tr(),!1)}addBoolean(t){this._lower.fields.length<32?this._lower.addBoolean(t):this._upper.addBoolean(t)}decode(t,n=0){let o=this._lower.decode(t,n),r=this._upper.decode(t,n+this._lower.span);return N(N({},o),r)}encode(t,n,o=0){return this._lower.encode(t,n,o)+this._upper.encode(t,n,o+this._lower.span)}};function D(m){return new bs(1,m)}function ct(m){return new bs(4,m)}function A(m){return new Vn(8,!1,m)}function te(m){return new Vn(16,!1,m)}function fu(m){return new Vn(1,!0,m)}function lo(m){return new Vn(8,!0,m)}function yu(m){return new Vn(16,!0,m)}var co=class extends er{constructor(t,n,o,r){super(t.span,r);this.layout=t,this.decoder=n,this.encoder=o}decode(t,n){return this.decoder(this.layout.decode(t,n))}encode(t,n,o){return this.layout.encode(this.encoder(t),n,o)}getSpan(t,n){return this.layout.getSpan(t,n)}};function O(m){return new co(he(32),e=>new sm(e),e=>e.toBuffer(),m)}function De(m){return new co(uu(),am,um,m)}function am(m){if(m===0)return!1;if(m===1)return!0;throw new Error("Invalid bool: "+m)}function um(m){return m?1:0}function cm(m){let e=tr("length"),t=_([e,he(mu(e,-e.span),"data")]);return new co(t,({data:n})=>n,n=>({data:n}),m)}function wt(m){return new co(cm(),e=>e.toString("utf-8"),e=>Buffer.from(e,"utf-8"),m)}var As=class extends au{decode(e,t){return super.decode(e,t)}};function _(m,e,t){return new As(m,e,t)}function Q(m,e,t){let n,o=typeof e=="number"?e:pu(e)?e.toNumber():new Proxy(e,{get(r,i){if(!n){let s=Reflect.get(r,"count");n=pu(s)?s.toNumber():s,Reflect.set(r,"count",n)}return Reflect.get(r,i)},set(r,i,s){return i==="count"&&(n=s),Reflect.set(r,i,s)}});return lu(m,o,t)}var En=_([O("mint"),O("owner"),A("amount"),ct("delegateOption"),O("delegate"),D("state"),ct("isNativeOption"),A("isNative"),A("delegatedAmount"),ct("closeAuthorityOption"),O("closeAuthority")]);var BA=fe("Raydium_Util");function gu({owner:m,solAccountResp:e,tokenAccountResp:t}){let n=[],o=[];for(let{pubkey:r,account:i}of t.value){let s=En.decode(i.data),{mint:u,amount:a}=s;n.push({publicKey:r,mint:u,amount:a,isAssociated:J(m,u,i.owner).publicKey.equals(r),isNative:!1,programId:i.owner}),o.push({pubkey:r,accountInfo:s,programId:i.owner})}return e&&n.push({mint:bu.default,amount:new mm(String(e.lamports)),isNative:!0,programId:e.owner}),{tokenAccounts:n,tokenAccountRawInfos:o}}function Ge({fromPublicKey:m,programId:e=dm,assignSeed:t}){let n=t?btoa(t).slice(0,32):lm.generate().publicKey.toBase58().slice(0,32);return{publicKey:pm(m,n,e),seed:n}}function pm(m,e,t){let n=Buffer.concat([m.toBuffer(),Buffer.from(e),t.toBuffer()]),o=su(n);return new bu(o)}function Ps(m){let{mint:e,tokenAccount:t,owner:n,programId:o=mo}=m;return Am(t,e,n,o)}function cn(m){let{tokenAccount:e,payer:t,multiSigners:n=[],owner:o,programId:r=mo}=m;return gm(e,t,o,n,r)}async function hn(m){let{connection:e,amount:t,commitment:n,payer:o,owner:r,skipCloseAccount:i}=m,s=await e.getMinimumBalanceForRentExemption(En.span,n),u=$(t).add(new bm(s)),a=Ge({fromPublicKey:o,programId:mo});return{addresses:{newAccount:a.publicKey},signers:[],instructions:[ym.createAccountWithSeed({fromPubkey:o,basePubkey:o,seed:a.seed,newAccountPubkey:a.publicKey,lamports:u.toNumber(),space:En.span,programId:mo}),Ps({mint:new fm(ut.address),tokenAccount:a.publicKey,owner:r,programId:mo})],instructionTypes:[q.CreateAccount,q.InitAccount],endInstructionTypes:i?[]:[q.CloseAccount],endInstructions:i?[]:[cn({tokenAccount:a.publicKey,payer:o,owner:r})]}}function Au({source:m,destination:e,owner:t,amount:n,multiSigners:o=[],tokenProgram:r=mo}){return Pm(m,e,t,BigInt(String(n)),o,r)}var Do=class extends Ne{constructor(t){super(t);this._tokenAccounts=[];this._tokenAccountRawInfos=[];this._accountListener=[];this._clientOwnedToken=!1;this._notSubscribeAccountChange=!1;this._accountFetchTime=0;let{tokenAccounts:n,tokenAccountRawInfos:o,notSubscribeAccountChange:r}=t;this._tokenAccounts=n||[],this._tokenAccountRawInfos=o||[],this._notSubscribeAccountChange=r!=null?r:!0,this._clientOwnedToken=!!(n||o)}get tokenAccounts(){return this._tokenAccounts}get tokenAccountRawInfos(){return this._tokenAccountRawInfos}set notSubscribeAccountChange(t){this._notSubscribeAccountChange=t}updateTokenAccount({tokenAccounts:t,tokenAccountRawInfos:n}){return t&&(this._tokenAccounts=t),n&&(this._tokenAccountRawInfos=n),this._accountChangeListenerId&&this.scope.connection.removeAccountChangeListener(this._accountChangeListenerId),this._accountChangeListenerId=void 0,this._clientOwnedToken=!0,this}addAccountChangeListener(t){return this._accountListener.push(t),this}removeAccountChangeListener(t){return this._accountListener=this._accountListener.filter(n=>n!==t),this}getAssociatedTokenAccount(t,n){return J(this.scope.ownerPubKey,t,n).publicKey}resetTokenAccounts(){this._clientOwnedToken||(this._tokenAccounts=[],this._tokenAccountRawInfos=[])}async fetchWalletTokenAccounts(t){if(this._clientOwnedToken||!(t!=null&&t.forceUpdate)&&this._tokenAccounts.length&&Date.now()-this._accountFetchTime<(this._notSubscribeAccountChange?1e3*5:1e3*60*3))return{tokenAccounts:this._tokenAccounts,tokenAccountRawInfos:this._tokenAccountRawInfos};this.scope.checkOwner();let o=N(N({},{}),t),[r,i,s]=await Promise.all([this.scope.connection.getAccountInfo(this.scope.ownerPubKey,o.commitment),this.scope.connection.getTokenAccountsByOwner(this.scope.ownerPubKey,{programId:Tn},o.commitment),this.scope.connection.getTokenAccountsByOwner(this.scope.ownerPubKey,{programId:km},o.commitment)]),{tokenAccounts:u,tokenAccountRawInfos:a}=gu({owner:this.scope.ownerPubKey,solAccountResp:r,tokenAccountResp:{context:i.context,value:[...i.value,...s.value]}});return this._tokenAccounts=u,this._tokenAccountRawInfos=a,this._accountFetchTime=Date.now(),this._notSubscribeAccountChange||(this._accountChangeListenerId&&this.scope.connection.removeAccountChangeListener(this._accountChangeListenerId),this._accountChangeListenerId=this.scope.connection.onAccountChange(this.scope.ownerPubKey,()=>{this.fetchWalletTokenAccounts({forceUpdate:!0}),this._accountListener.forEach(c=>c({tokenAccounts:this._tokenAccounts,tokenAccountRawInfos:this._tokenAccountRawInfos}))},{commitment:t==null?void 0:t.commitment})),{tokenAccounts:u,tokenAccountRawInfos:a}}clearAccountChangeCkb(){this._accountChangeListenerId!==void 0&&this.scope.connection.removeAccountChangeListener(this._accountChangeListenerId)}async getCreatedTokenAccount({mint:t,programId:n=Tn,associatedOnly:o=!0}){await this.fetchWalletTokenAccounts();let r=this._tokenAccounts.filter(({mint:s})=>s==null?void 0:s.equals(t)).sort((s,u)=>s.amount.lt(u.amount)?1:-1),i=this.getAssociatedTokenAccount(t,n);for(let s of r){let{publicKey:u}=s;if(u&&(!o||o&&i.equals(u)))return u}}async getOrCreateTokenAccount(t){var y,b,g,P;await this.fetchWalletTokenAccounts();let{mint:n,createInfo:o,associatedOnly:r,owner:i,notUseTokenAccount:s=!1,skipCloseAccount:u=!1,checkCreateATAOwner:a=!1,assignSeed:c}=t,l=new or(t.tokenProgram||Tn),d=this.getAssociatedTokenAccount(n,new or(l)),p=(s?[]:this.tokenAccountRawInfos).filter(h=>h.accountInfo.mint.equals(n)&&(!r||h.pubkey.equals(d))).sort((h,I)=>h.accountInfo.amount.lt(I.accountInfo.amount)?1:-1);if(o===void 0||p.length>0)return p.length>0?{account:p[0].pubkey}:{};let f={instructions:[],endInstructions:[],signers:[],instructionTypes:[],endInstructionTypes:[]};if(r){let h=ws(i,d,i,n,l),I=this.tokenAccountRawInfos.find(k=>k.pubkey.equals(d));if(a){let k=await this.scope.connection.getAccountInfo(d);if(k===null)(y=f.instructions)==null||y.push(h),f.instructionTypes.push(q.CreateATA);else if(!(k.owner.equals(l)&&po.decode(k.data).mint.equals(n)&&po.decode(k.data).owner.equals(i)))throw Error(`create ata check error -> mint: ${n.toString()}, ata: ${d.toString()}`)}else I===void 0&&(f.instructions.push(h),f.instructionTypes.push(q.CreateATA));if(n.equals(j)&&o.amount){let k=await hn({connection:this.scope.connection,owner:this.scope.ownerPubKey,payer:o.payer||this.scope.ownerPubKey,amount:(b=o.amount)!=null?b:0,skipCloseAccount:u});f.instructions.push(...k.instructions||[]),f.endInstructions.push(...k.endInstructions||[]),f.instructionTypes.push(...k.instructionTypes||[]),f.endInstructionTypes.push(...k.endInstructionTypes||[]),o.amount&&(f.instructions.push(Au({source:k.addresses.newAccount,destination:d,owner:this.scope.ownerPubKey,amount:o.amount,tokenProgram:Tn})),f.instructionTypes.push(q.TransferAmount))}return!u&&I===void 0&&(f.endInstructions.push(cn({owner:i,payer:o.payer||i,tokenAccount:d,programId:l})),f.endInstructionTypes.push(q.CloseAccount)),{account:d,instructionParams:f}}else{let h=Ge({fromPublicKey:i,programId:l,assignSeed:c}),I=await this.scope.connection.getMinimumBalanceForRentExemption(po.span),k=wm.createAccountWithSeed({fromPubkey:i,basePubkey:i,seed:h.seed,newAccountPubkey:h.publicKey,lamports:I+Number((P=(g=o.amount)==null?void 0:g.toString())!=null?P:0),space:po.span,programId:l});return f.instructions.push(k,Ps({mint:n,tokenAccount:h.publicKey,owner:this.scope.ownerPubKey,programId:l})),f.instructionTypes.push(q.CreateAccount),f.instructionTypes.push(q.InitAccount),u||(f.endInstructions.push(cn({owner:i,payer:o.payer||i,tokenAccount:h.publicKey,programId:l})),f.endInstructionTypes.push(q.CloseAccount)),{account:h.publicKey,instructionParams:f}}}async checkOrCreateAta({mint:t,programId:n=Tn,autoUnwrapWSOLToSOL:o}){var u;await this.fetchWalletTokenAccounts();let r=(u=this.scope.account.tokenAccounts.find(({mint:a})=>(a==null?void 0:a.toBase58())===t.toBase58()))==null?void 0:u.publicKey,i=this.scope.ownerPubKey,s={};if(!r){let a=this.getAssociatedTokenAccount(t,n),c=await ws(i,a,i,t,n);s.instructions=[c],s.instructionTypes=[q.CreateATA],r=a}return o&&j.toBase58()===t.toBase58()&&(s.endInstructions=[cn({owner:i,payer:i,tokenAccount:r,programId:n})],s.endInstructionTypes=[q.CloseAccount]),{pubKey:r,newInstructions:s}}async handleTokenAccount(t){let{side:n,amount:o,mint:r,programId:i=Tn,tokenAccount:s,payer:u=this.scope.ownerPubKey,bypassAssociatedCheck:a,skipCloseAccount:c,checkCreateATAOwner:l}=t,d=this.getAssociatedTokenAccount(r,i);if(new or(j).equals(r)){let p=await hn({connection:this.scope.connection,owner:this.scope.ownerPubKey,payer:u,amount:o,skipCloseAccount:c});return N({tokenAccount:p.addresses.newAccount},p)}else if(!s||n==="out"&&!d.equals(s)&&!a){let p=[],f=ws(this.scope.ownerPubKey,d,this.scope.ownerPubKey,r,i);if(l){let y=await this.scope.connection.getAccountInfo(d);if(y===null)p.push(f);else if(!(y.owner.equals(Tn)&&po.decode(y.data).mint.equals(r)&&po.decode(y.data).owner.equals(this.scope.ownerPubKey)))throw Error(`create ata check error -> mint: ${r.toString()}, ata: ${d.toString()}`)}else p.push(f);return{tokenAccount:d,instructions:p,instructionTypes:[q.CreateATA]}}return{tokenAccount:s}}async processTokenAccount(t){let{mint:n,programId:o=Tn,amount:r,useSOLBalance:i,handleTokenAccount:s,feePayer:u}=t,a,c=this.createTxBuilder(u);if(n.equals(new or(j))&&i){let l=await this.handleTokenAccount({side:"in",amount:r||0,mint:n,bypassAssociatedCheck:!0,programId:o}),{tokenAccount:p}=l,f=Ee(l,["tokenAccount"]);a=p,c.addInstruction(f)}else if(a=await this.getCreatedTokenAccount({mint:n,associatedOnly:!1,programId:o}),!a&&s){let d=await this.scope.account.handleTokenAccount({side:"in",amount:0,mint:n,bypassAssociatedCheck:!0,programId:o}),{tokenAccount:p}=d,f=Ee(d,["tokenAccount"]);a=p,c.addInstruction(f)}return N({tokenAccount:a},c.AllTxData)}};import{PublicKey as Te,SystemProgram as Vm}from"@solana/web3.js";import{createAssociatedTokenAccountIdempotentInstruction as Mu}from"@solana/spl-token";import Em from"decimal.js";import{PublicKey as Ss}from"@solana/web3.js";var ks=_([D("instruction")]),hs=_([D("instruction")]),hm=_([A("rewardState"),A("rewardOpenTime"),A("rewardEndTime"),A("rewardLastUpdateTime"),A("totalReward"),A("totalRewardEmissioned"),A("rewardClaimed"),A("rewardPerSecond"),te("accRewardPerShare"),O("rewardVault"),O("rewardMint"),O("rewardSender"),A("rewardType"),Q(A(),15,"padding")]),Tm=_([A("state"),A("nonce"),O("lpVault"),O("rewardVault"),O(),O(),A(),A(),A("totalReward"),te("perShareReward"),A("lastSlot"),A("perSlotReward")]),Im=_([A("state"),A("nonce"),O("lpVault"),O("rewardVaultA"),A("totalRewardA"),te("perShareRewardA"),A("perSlotRewardA"),D("option"),O("rewardVaultB"),he(7),A("totalRewardB"),te("perShareRewardB"),A("perSlotRewardB"),A("lastSlot"),O()]),Bm=_([A(),A("state"),A("nonce"),A("validRewardTokenNum"),te("rewardMultiplier"),A("rewardPeriodMax"),A("rewardPeriodMin"),A("rewardPeriodExtend"),O("lpMint"),O("lpVault"),Q(hm,5,"rewardInfos"),O("creator"),O(),Q(A(),32,"padding")]),xm=new Proxy(Tm,{get(m,e,t){return e==="decode"?(...n)=>{let o=m.decode(...n);return W(N({},o),{version:3,rewardInfos:[{rewardVault:o.rewardVault,totalReward:o.totalReward,perSlotReward:o.perSlotReward,perShareReward:o.perShareReward}]})}:Reflect.get(m,e,t)}}),Sm=new Proxy(Im,{get(m,e,t){return e==="decode"?(...n)=>{let o=m.decode(...n);return W(N({},o),{version:5,rewardInfos:[{rewardVault:o.rewardVaultA,totalReward:o.totalRewardA,perSlotReward:o.perSlotRewardA,perShareReward:o.perShareRewardA},{rewardVault:o.rewardVaultB,totalReward:o.totalRewardB,perSlotReward:o.perSlotRewardB,perShareReward:o.perShareRewardB}]})}:Reflect.get(m,e,t)}}),ir=new Proxy(Bm,{get(m,e,t){return e==="decode"?(...n)=>{let o=m.decode(...n);return W(N({},o),{version:6,rewardInfos:o.rewardInfos.map(r=>{var i;return W(N({},r),{rewardType:((i=Object.entries(In).find(s=>String(s[1])===r.rewardType.toString()))!=null?i:["Standard SPL"])[0]})})})}:Reflect.get(m,e,t)}}),Km=_([A("isSet"),A("rewardPerSecond"),A("rewardOpenTime"),A("rewardEndTime"),A("rewardType")]),Ts=_([D("instruction"),A("nonce"),Q(Km,5,"rewardTimeInfo")]),Is=_([D("instruction"),A("rewardReopenTime"),A("rewardEndTime"),A("rewardPerSecond")]),Bs=_([D("instruction"),A("isSet"),A("rewardPerSecond"),A("rewardOpenTime"),A("rewardEndTime"),A("rewardType")]),oP=_([A("state"),O("id"),O("owner"),A("deposited"),Q(A(),1,"rewardDebts")]),xs=_([A("state"),O("id"),O("owner"),A("deposited"),Q(te(),1,"rewardDebts"),A(""),A("voteLockedBalance"),Q(A(),15)]),iP=_([A("state"),O("id"),O("owner"),A("deposited"),Q(A(),2,"rewardDebts")]),Pu=_([A("state"),O("id"),O("owner"),A("deposited"),Q(te(),2,"rewardDebts"),Q(A(),17)]),wu=_([A(),A("state"),O("id"),O("owner"),A("deposited"),Q(te(),5,"rewardDebts"),Q(A(),16)]),It=_([D("instruction"),A("amount")]),Cm=_([O("mint"),O("grantAuthority"),A("baselineVoteWeightScaledFactor"),A("maxExtraLockupVoteWeightScaledFactor"),A("lockupSaturationSecs"),fu("digitShift"),Q(D(),7,"reserved1"),Q(A(),7,"reserved2")]),Rm=_([he(8),O("governanceProgramId"),O("realm"),O("realmGoverningTokenMint"),O("realmAuthority"),Q(D(),32,"reserved1"),Q(Cm,4,"votingMints"),lo("timeOffset"),D("bump"),Q(D(),7,"reserved2"),Q(A(),11,"reserved3")]),Lm=_([lo("startTime"),lo("endTime"),D("kind"),Q(D(),15,"reserved")]),Om=_([Q(Lm,1,"lockup"),A("amountDeposited_native"),A("amountInitiallyLockedNative"),De("isUsed"),De("allowClawback"),D("votingMintConfigIdx"),Q(D(),29,"reserved")]),Nm=_([he(8),O("voterAuthority"),O("registrar"),Q(Om,32,"deposits"),D("voterBump"),D("voterWweightRecordBump"),Q(D(),94,"reserved")]);import{NATIVE_MINT as pP}from"@solana/spl-token";var fP=fe("Raydium_farm_config"),ku=new Ss("4k3Dyjzvzp8eMZWUXbBCjEvwSkkk59S5iCNLY3QrkX6R"),hu=new Ss("FrspKwj8i3pNmKwXreTveC4fu7KL5ZbGeXdZBe2XViu1");var yP=new Ss("3TRTX4dXUpp2eqxi3tvQDFYUV7SdDJjcPE3Y4mbtftaX");var Tu={3:xs,5:Pu,6:wu},Ks=m=>[3,4,5,6].indexOf(m)!==-1,Cs=m=>{var i;let{version:e,rewardInfos:t,rewardTokenAccountsPublicKeys:n}=m,o=`rewardInfo:${JSON.stringify(t)}, rewardAccount:${JSON.stringify(n)}`,r={3:()=>{if(t.length!==1||n.length!==1)return`rewardInfos or rewardTokenAccounts lengths not equal 1: ${o}`},5:()=>{if(t.length!==n.length)return`rewardInfos and rewardTokenAccounts lengths not equal: ${o}`},6:()=>{if(!n.length||t.length!==n.length)return`no rewardTokenAccounts or rewardInfos and rewardTokenAccounts lengths not equal: ${o}`}};return(i=r[e])==null?void 0:i.call(r)},In={"Standard SPL":0,"Option tokens":1},Ot={[za.toString()]:3,[Qa.toString()]:4,[ja.toString()]:5,[Mo.toString()]:6,[un.FARM_PROGRAM_ID_V3.toString()]:3,[un.FARM_PROGRAM_ID_V4.toString()]:4,[un.FARM_PROGRAM_ID_V5.toString()]:5,[un.FARM_PROGRAM_ID_V6.toString()]:6};import{PublicKey as de,SystemProgram as xu,SYSVAR_CLOCK_PUBKEY as Uo,SYSVAR_RENT_PUBKEY as _m,TransactionInstruction as Mt}from"@solana/web3.js";import Su from"bn.js";import{ASSOCIATED_TOKEN_PROGRAM_ID as QP,createAssociatedTokenAccountIdempotentInstruction as jP,TOKEN_PROGRAM_ID as ln}from"@solana/spl-token";import Mm from"bn.js";var vm=fe("Raydium.farm.util");function Wo({programId:m,poolId:e,mint:t,type:n}){let{publicKey:o}=se([e.toBuffer(),t.toBuffer(),Buffer.from(n==="lpVault"?"lp_vault_associated_seed":n==="rewardVault"?"reward_vault_associated_seed":"","utf-8")],m);return o}function Nt({programId:m,poolId:e,owner:t,version:n}){let{publicKey:o}=se([e.toBuffer(),t.toBuffer(),Buffer.from(n===6?"farmer_info_associated_seed":"staker_info_v2_associated_seed","utf-8")],m);return o}var Iu=({programId:m,poolId:e})=>se([e.toBuffer()],m);function Bu(m){return{isSet:new Mm(1),rewardPerSecond:$(m.perSecond),rewardOpenTime:$(m.openTime),rewardEndTime:$(m.endTime),rewardType:$(In[m.rewardType])}}function Rs(m){return $(m.endTime).sub($(m.openTime)).mul($(m.perSecond))}function qo(m){let e=Tu[m];return e||vm.logWithError("invalid version",m),e}var Fm=fe("Raydium_farm_instruction"),rw={voterStakeRegistryCreateVoter:Buffer.from([6,24,245,52,243,255,148,25]),voterStakeRegistryCreateDepositEntry:Buffer.from([185,131,167,186,159,125,19,67]),voterStakeRegistryDeposit:Buffer.from([242,35,198,137,82,225,242,182]),voterStakeRegistryWithdraw:Buffer.from([183,18,70,156,148,109,161,34]),voterStakeRegistryUpdateVoterWeightRecord:Buffer.from([45,185,3,36,109,190,115,169])};function Go(m){let{version:e,id:t,ledger:n,programId:o,owner:r}=m,i={3:9,5:10}[e];i||Fm.logWithError(`invalid farm pool version: ${e}`);let s=Buffer.alloc(ks.span);ks.encode({instruction:i},s);let u=[B({pubkey:t}),B({pubkey:n}),B({pubkey:r,isWritable:!1}),B({pubkey:xu.programId,isWritable:!1}),B({pubkey:_m,isWritable:!1})];return{instruction:new Mt({programId:o,keys:u,data:s}),instructionType:q.FarmV3CreateLedger}}function Ku(m){var n;let e=Buffer.alloc(Ts.span);Ts.encode({instruction:0,nonce:new Su(m.nonce),rewardTimeInfo:m.rewardInfoConfig},e);let t=[...zr,B({pubkey:m.farmId}),B({pubkey:m.farmAuthority,isWritable:!1}),B({pubkey:m.lpVault}),B({pubkey:m.lpMint,isWritable:!1}),B({pubkey:m.lockVault}),B({pubkey:m.lockMint,isWritable:!1}),B({pubkey:(n=m.lockUserAccount)!=null?n:$e}),B({pubkey:m.owner,isWritable:!1,isSigner:!0})];for(let o of m.rewardInfo)t.push(B({pubkey:o.rewardMint,isWritable:!1}),B({pubkey:o.rewardVault}),B({pubkey:o.userRewardToken}));return{instruction:new Mt({programId:m.programId,keys:t,data:e}),instructionType:q.FarmV6Create}}function Cu(m){let e=Buffer.alloc(hs.span);hs.encode({instruction:5},e);let t=[B({pubkey:ln,isWritable:!1}),B({pubkey:m.id}),B({pubkey:m.authority,isWritable:!1}),B({pubkey:m.lpVault,isWritable:!1}),B({pubkey:m.rewardVault}),B({pubkey:m.userRewardToken}),B({pubkey:m.owner,isWritable:!1,isSigner:!0})];return{instruction:new Mt({programId:m.programId,keys:t,data:e}),instructionType:q.FarmV6CreatorWithdraw}}function Ls({payer:m,rewardVault:e,userRewardTokenPub:t,farmKeys:n,rewardInfo:o}){let r=Buffer.alloc(Is.span);Is.encode({instruction:3,rewardReopenTime:$(o.openTime),rewardEndTime:$(o.endTime),rewardPerSecond:$(o.perSecond)},r);let i=[B({pubkey:ln,isWritable:!1}),B({pubkey:n.id}),B({pubkey:n.lpVault,isWritable:!1}),B({pubkey:e}),B({pubkey:t}),B({pubkey:m,isWritable:!1,isSigner:!0})];return new Mt({programId:n.programId,keys:i,data:r})}function Os({payer:m,userRewardTokenPub:e,farmKeys:t,rewardVault:n,rewardInfo:o}){let r=Buffer.alloc(Bs.span);Bs.encode({instruction:4,isSet:new Su(1),rewardPerSecond:$(o.perSecond),rewardOpenTime:$(o.openTime),rewardEndTime:$(o.endTime),rewardType:$(In[o.rewardType])},r);let i=[...zr,B({pubkey:t.id}),B({pubkey:t.authority,isWritable:!1}),B({pubkey:o.mint,isWritable:!1}),B({pubkey:n}),B({pubkey:e}),B({pubkey:m,isWritable:!1,isSigner:!0})];return new Mt({programId:t.programId,keys:i,data:r})}function Xo(m){let{farmInfo:e,farmKeys:t,lpAccount:n,rewardAccounts:o,owner:r,amount:i}=m,[s,u]=[new de(e.programId),new de(e.id)],a=Nt({programId:s,poolId:u,owner:r,version:6}),c=Buffer.alloc(It.span);It.encode({instruction:2,amount:$(i)},c);let l=[B({pubkey:ln,isWritable:!1}),B({pubkey:u}),B({pubkey:new de(t.authority),isWritable:!1}),B({pubkey:new de(t.lpVault)}),B({pubkey:a}),B({pubkey:r,isWritable:!1,isSigner:!0}),B({pubkey:n})];for(let d=0;d<t.rewardInfos.length;d++)l.push(B({pubkey:new de(t.rewardInfos[d].vault)})),l.push(B({pubkey:o[d]}));return new Mt({programId:s,keys:l,data:c})}function zo(m){let{farmInfo:e,farmKeys:t,lpAccount:n,rewardAccounts:o,owner:r,amount:i,userAuxiliaryLedgers:s}=m,[u,a]=[new de(e.programId),new de(e.id)],c=Nt({programId:u,poolId:a,owner:r,version:5}),l=Buffer.alloc(It.span);It.encode({instruction:12,amount:$(i)},l);let d=[B({pubkey:a}),B({pubkey:new de(t.authority),isWritable:!1}),B({pubkey:c}),B({pubkey:r,isWritable:!1,isSigner:!0}),B({pubkey:n}),B({pubkey:new de(t.lpVault)}),B({pubkey:o[0]}),B({pubkey:new de(t.rewardInfos[0].vault)}),B({pubkey:Uo,isWritable:!1}),B({pubkey:ln,isWritable:!1})];for(let p=1;p<t.rewardInfos.length;p++)d.push(B({pubkey:o[p]})),d.push(B({pubkey:new de(t.rewardInfos[p].vault)}));if(s)for(let p of s)d.push(B({pubkey:p}));return new Mt({programId:u,keys:d,data:l})}function Ru(m){let{farmInfo:e,farmKeys:t,lpAccount:n,rewardAccounts:o,owner:r,amount:i,userAuxiliaryLedgers:s}=m,[u,a]=[new de(e.programId),new de(e.id)],c=_([D("instruction"),A("amount")]),l=[B({pubkey:a}),B({pubkey:new de(t.authority),isWritable:!1}),B({pubkey:s[0]}),B({pubkey:r,isSigner:!0,isWritable:!1}),B({pubkey:n}),B({pubkey:new de(t.lpVault)}),B({pubkey:o[0]}),B({pubkey:new de(t.rewardInfos[0].vault)}),B({pubkey:Uo,isWritable:!1}),B({pubkey:ln,isWritable:!1}),B({pubkey:o[1]}),B({pubkey:new de(t.rewardInfos[1].vault)})],d=Buffer.alloc(c.span);return c.encode({instruction:2,amount:i},d),new Mt({keys:l,programId:u,data:d})}function Qo(m){let{farmInfo:e,farmKeys:t,lpAccount:n,rewardAccounts:o,owner:r,amount:i,userAuxiliaryLedgers:s}=m,[u,a]=[new de(e.programId),new de(e.id)],c=Nt({programId:u,poolId:a,owner:r,version:3}),l=Buffer.alloc(It.span);It.encode({instruction:11,amount:$(i)},l);let d=[B({pubkey:a}),B({pubkey:new de(t.authority),isWritable:!1}),B({pubkey:c}),B({pubkey:r,isWritable:!1,isSigner:!0}),B({pubkey:n}),B({pubkey:new de(t.lpVault)}),B({pubkey:o[0]}),B({pubkey:new de(t.rewardInfos[0].vault)}),B({pubkey:Uo,isWritable:!1}),B({pubkey:ln,isWritable:!1})];if(s)for(let p of s)d.push(B({pubkey:p}));return new Mt({programId:u,keys:d,data:l})}function Lu(m){let{farmInfo:e,farmKeys:t,lpAccount:n,rewardAccounts:o,owner:r,amount:i,userAuxiliaryLedgers:s}=m,[u,a]=[new de(e.programId),new de(e.id)],c=Nt({programId:u,poolId:a,owner:r,version:3}),l=Buffer.alloc(It.span);It.encode({instruction:10,amount:$(i)},l);let d=[B({pubkey:a}),B({pubkey:new de(t.authority),isWritable:!1}),B({pubkey:c}),B({pubkey:r,isWritable:!1,isSigner:!0}),B({pubkey:n}),B({pubkey:new de(t.lpVault)}),B({pubkey:o[0]}),B({pubkey:new de(t.rewardInfos[0].vault)}),B({pubkey:Uo,isWritable:!1}),B({pubkey:ln,isWritable:!1})];if(s)for(let p of s)d.push(B({pubkey:p}));return new Mt({programId:u,keys:d,data:l})}function Ou(m){let{farmInfo:e,farmKeys:t,lpAccount:n,rewardAccounts:o,owner:r,amount:i,userAuxiliaryLedgers:s}=m,[u,a]=[new de(e.programId),new de(e.id)],c=Nt({programId:u,poolId:a,owner:r,version:5}),l=Buffer.alloc(It.span);It.encode({instruction:11,amount:$(i)},l);let d=[B({pubkey:a}),B({pubkey:new de(t.authority),isWritable:!1}),B({pubkey:c}),B({pubkey:r,isWritable:!1,isSigner:!0}),B({pubkey:n}),B({pubkey:new de(t.lpVault)}),B({pubkey:o[0]}),B({pubkey:new de(t.rewardInfos[0].vault)}),B({pubkey:Uo,isWritable:!1}),B({pubkey:ln,isWritable:!1})];for(let p=1;p<t.rewardInfos.length;p++)d.push(B({pubkey:o[p]})),d.push(B({pubkey:new de(t.rewardInfos[p].vault)}));if(s)for(let p of s)d.push(B({pubkey:p}));return new Mt({programId:u,keys:d,data:l})}function Nu(m){let{farmInfo:e,farmKeys:t,lpAccount:n,rewardAccounts:o,owner:r,amount:i}=m,[s,u]=[new de(e.programId),new de(e.id)],a=Nt({programId:s,poolId:u,owner:r,version:6}),c=Buffer.alloc(It.span);It.encode({instruction:1,amount:$(i)},c);let l=[B({pubkey:ln,isWritable:!1}),B({pubkey:xu.programId,isWritable:!1}),B({pubkey:u}),B({pubkey:new de(t.authority),isWritable:!1}),B({pubkey:new de(t.lpVault)}),B({pubkey:a}),B({pubkey:r,isWritable:!1,isSigner:!0}),B({pubkey:n})];for(let d=0;d<t.rewardInfos.length;d++)l.push(B({pubkey:new de(t.rewardInfos[d].vault)})),l.push(B({pubkey:o[d]}));return new Mt({programId:s,keys:l,data:c})}var jo=class extends Ne{async _getUserRewardInfo({payer:e,rewardInfo:t}){if(t.mint.equals($e)){let n=await hn({connection:this.scope.connection,owner:this.scope.ownerPubKey,payer:e,amount:Rs(W(N({},t),{openTime:t.openTime.toString(),endTime:t.endTime.toString()}))});return{rewardPubKey:n.addresses.newAccount,newInstruction:n}}return{rewardPubKey:await this.scope.account.getCreatedTokenAccount({mint:t.mint,associatedOnly:!1})}}async create({poolInfo:e,rewardInfos:t,payer:n,programId:o=Mo,txVersion:r,feePayer:i,lockProgram:s}){var S,x;this.checkDisabled(),this.scope.checkOwner();let a={lpMint:new Te(e.lpMint.address),lockInfo:{lockMint:(S=s==null?void 0:s.mint)!=null?S:ku,lockVault:(x=s==null?void 0:s.vault)!=null?x:hu},version:6,rewardInfos:t,programId:o},c=this.createTxBuilder(i),l=n!=null?n:this.scope.ownerPubKey,d=Ge({fromPublicKey:l,programId:a.programId}),p=await this.scope.connection.getMinimumBalanceForRentExemption(ir.span);c.addInstruction({instructions:[Vm.createAccountWithSeed({fromPubkey:l,basePubkey:l,seed:d.seed,newAccountPubkey:d.publicKey,lamports:p,space:ir.span,programId:a.programId})]});let{publicKey:f,nonce:y}=Iu({programId:new Te(a.programId),poolId:d.publicKey}),b=Wo({programId:a.programId,poolId:d.publicKey,mint:a.lpMint,type:"lpVault"}),g=[],P=[];for(let K of a.rewardInfos){K.openTime>=K.endTime&&this.logAndCreateError("start time error","rewardInfo.rewardOpenTime",K.openTime.toString()),isNaN(In[K.rewardType])&&this.logAndCreateError("rewardType error",K.rewardType),Number(K.perSecond)<=0&&this.logAndCreateError("rewardPerSecond error",K.perSecond),g.push(Bu(K));let{rewardPubKey:T,newInstruction:C}=await this._getUserRewardInfo({rewardInfo:K,payer:l});C&&c.addInstruction(C),T||this.logAndCreateError("cannot found target token accounts",this.scope.account.tokenAccounts);let M=K.mint.equals($e)?new Te(ut.address):K.mint;P.push({rewardMint:M,rewardVault:Wo({programId:a.programId,poolId:d.publicKey,mint:M,type:"rewardVault"}),userRewardToken:T})}let{account:h,instructionParams:I}=await this.scope.account.getOrCreateTokenAccount({mint:new Te(a.lockInfo.lockMint),owner:this.scope.ownerPubKey,skipCloseAccount:!1,createInfo:{payer:this.scope.ownerPubKey,amount:0},associatedOnly:!1});I&&c.addInstruction(I),h||this.logAndCreateError("cannot found lock vault","tokenAccounts",this.scope.account.tokenAccounts);let{instruction:k,instructionType:w}=Ku({farmId:d.publicKey,owner:this.scope.ownerPubKey,farmAuthority:f,lpVault:b,lpMint:a.lpMint,lockVault:a.lockInfo.lockVault,lockMint:a.lockInfo.lockMint,lockUserAccount:h,programId:a.programId,rewardInfo:P,rewardInfoConfig:g,nonce:y});return c.addInstruction({instructions:[k],instructionTypes:[w]}).versionBuild({txVersion:r,extInfo:{farmId:d.publicKey,farmAuthority:f,lpVault:b,lockUserAccount:h,nonce:y}})}async restartReward({farmInfo:e,payer:t,newRewardInfo:n,txVersion:o,feePayer:r}){var g;let i=Ot[e.programId];i!==6&&this.logAndCreateError("invalid farm version ",i);let s=it((await this.scope.api.fetchFarmKeysById({ids:e.id}))[0]),u={id:s.id,rewardInfos:e.rewardInfos,lpVault:s.lpVault,programId:s.programId};n.openTime>=n.endTime&&this.logAndCreateError("start time error","newRewardInfo",n);let a=t||this.scope.ownerPubKey,c=n.mint.equals($e)?new Te(ut.address):n.mint,l=u.rewardInfos.findIndex(P=>new Te(P.mint.address).equals(c)),d=s.rewardInfos[l];d||this.logAndCreateError("configuration does not exist","rewardMint",c);let p=(g=d.vault)!=null?g:$e,f=this.createTxBuilder(r),{rewardPubKey:y,newInstruction:b}=await this._getUserRewardInfo({rewardInfo:n,payer:a});return b&&f.addInstruction(b),y||this.logAndCreateError("cannot found target token accounts",this.scope.account.tokenAccounts),f.addInstruction({instructions:[Ls({payer:this.scope.ownerPubKey,rewardVault:p,userRewardTokenPub:y,farmKeys:u,rewardInfo:n})],instructionTypes:[q.FarmV6Restart]}).versionBuild({txVersion:o})}async restartRewards({farmInfo:e,payer:t,newRewardInfos:n,txVersion:o,feePayer:r}){var l;let i=Ot[e.programId];i!==6&&this.logAndCreateError("invalid farm version ",i);let s=it((await this.scope.api.fetchFarmKeysById({ids:e.id}))[0]),u={id:s.id,rewardInfos:e.rewardInfos,lpVault:s.lpVault,programId:s.programId};n.forEach(d=>{d.openTime>=d.endTime&&this.logAndCreateError("start time error","newRewardInfo",d)});let a=t||this.scope.ownerPubKey,c=this.createTxBuilder(r);for(let d of n){let p=d.mint.equals($e)?new Te(ut.address):d.mint,f=u.rewardInfos.findIndex(I=>new Te(I.mint.address).equals(p)),y=s.rewardInfos[f];y||this.logAndCreateError("configuration does not exist","rewardMint",p);let b=(l=y.vault)!=null?l:$e,{rewardPubKey:g,newInstruction:P}=await this._getUserRewardInfo({rewardInfo:d,payer:a});P&&c.addInstruction(P),g||this.logAndCreateError("cannot found target token accounts",this.scope.account.tokenAccounts);let h=Ls({payer:this.scope.ownerPubKey,rewardVault:b,userRewardTokenPub:g,farmKeys:u,rewardInfo:d});c.addInstruction({instructions:[h],instructionTypes:[q.FarmV6Restart]})}return c.versionBuild({txVersion:o})}async addNewRewardToken(e){let{txVersion:t,farmInfo:n,newRewardInfo:o,payer:r,feePayer:i}=e,s=Ot[n.programId];s!==6&&this.logAndCreateError("invalid farm version ",s);let u=it((await this.scope.api.fetchFarmKeysById({ids:n.id}))[0]),a=r!=null?r:this.scope.ownerPubKey,c=this.createTxBuilder(i),l=o.mint.equals($e)?new Te(ut.address):o.mint,d=Wo({programId:new Te(n.programId),poolId:new Te(n.id),mint:l,type:"rewardVault"}),{rewardPubKey:p,newInstruction:f}=await this._getUserRewardInfo({rewardInfo:o,payer:a});return f&&c.addInstruction(f),p||this.logAndCreateError("annot found target token accounts",this.scope.account.tokenAccounts),o.mint=l,c.addInstruction({instructions:[Os({payer:this.scope.ownerPubKey,userRewardTokenPub:p,farmKeys:u,rewardVault:d,rewardInfo:o})],instructionTypes:[q.FarmV6CreatorAddReward]}).versionBuild({txVersion:t})}async addNewRewardsToken(e){let{txVersion:t,farmInfo:n,newRewardInfos:o,payer:r,feePayer:i}=e,s=Ot[n.programId];s!==6&&this.logAndCreateError("invalid farm version ",s);let u=it((await this.scope.api.fetchFarmKeysById({ids:n.id}))[0]),a=r!=null?r:this.scope.ownerPubKey,c=this.createTxBuilder(i);for(let l of o){let d=l.mint.equals($e)?new Te(ut.address):l.mint,p=Wo({programId:new Te(n.programId),poolId:new Te(n.id),mint:d,type:"rewardVault"}),{rewardPubKey:f,newInstruction:y}=await this._getUserRewardInfo({rewardInfo:l,payer:a});y&&c.addInstruction(y),f||this.logAndCreateError("cannot found target token accounts",this.scope.account.tokenAccounts);let b=Os({payer:this.scope.ownerPubKey,userRewardTokenPub:f,farmKeys:u,rewardVault:p,rewardInfo:W(N({},l),{mint:d})});c.addInstruction({instructions:[b],instructionTypes:[q.FarmV6CreatorAddReward]})}return c.versionBuild({txVersion:t})}async deposit(e){let{txVersion:t,farmInfo:n,amount:o,feePayer:r,useSOLBalance:i,associatedOnly:s=!0,checkCreateATAOwner:u=!1,userAuxiliaryLedgers:a,computeBudgetConfig:c,txTipConfig:l}=e;this.scope.availability.addFarm===!1&&this.logAndCreateError("farm deposit feature disabled in your region");let{rewardInfos:d,programId:p}=n,f=Ot[p];f===4&&this.logAndCreateError("V4 has suspended deposits:",n.programId),Ks(f)||this.logAndCreateError("invalid farm program:",n.programId);let[y,b]=[new Te(n.programId),new Te(n.id)],g=(await this.scope.api.fetchFarmKeysById({ids:n.id}))[0],P=Nt({programId:y,poolId:b,owner:this.scope.ownerPubKey,version:f}),h=this.createTxBuilder(r);h.addCustomComputeBudget(c),h.addTipInstruction(l);let I={};for(let R of this.scope.account.tokenAccounts)if(s){let L=J(this.scope.ownerPubKey,R.mint,R.programId).publicKey;R.publicKey&&L.equals(R.publicKey)&&(I[R.mint.toString()]=R.publicKey)}else I[R.mint.toString()]=R.publicKey;let k=g.lpMint,w=I[k.address];w||this.logAndCreateError("you don't have any lp","lp zero",I);let S=[];for(let R of d){let L=i&&R.mint.address===j.toString(),F=I[R.mint.address];if(!F){let{account:X,instructionParams:H}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:R.mint.programId,mint:new Te(R.mint.address),notUseTokenAccount:L,createInfo:{payer:r||this.scope.ownerPubKey,amount:0},owner:this.scope.ownerPubKey,skipCloseAccount:!L,associatedOnly:L?!1:s,checkCreateATAOwner:u});F=X,H&&h.addInstruction(H)}I[R.mint.address]=F,S.push(F)}let x,K=await this.scope.connection.getAccountInfo(P);if(K&&(x=qo(f).decode(K.data)),n.programId!==Mo.toString()&&n.programId!==un.FARM_PROGRAM_ID_V6.toString()&&!x){let{instruction:R,instructionType:L}=Go({id:b,programId:y,version:f,ledger:P,owner:this.scope.ownerPubKey});h.addInstruction({instructions:[R],instructionTypes:[L]})}let T=Cs({version:f,rewardInfos:d,rewardTokenAccountsPublicKeys:S});T&&this.logAndCreateError(T);let C={amount:$(o),owner:this.scope.ownerPubKey,farmInfo:n,farmKeys:g,lpAccount:w,rewardAccounts:S,userAuxiliaryLedgers:a==null?void 0:a.map(R=>new Te(R))},M=f===6?Nu(C):f===5?Ou(C):Lu(C),v={3:q.FarmV3Deposit,5:q.FarmV5Deposit,6:q.FarmV6Deposit};return h.addInstruction({instructions:[M],instructionTypes:[v[f]]}).versionBuild({txVersion:t})}async withdraw(e){let{txVersion:t,farmInfo:n,amount:o,deposited:r,useSOLBalance:i,feePayer:s,associatedOnly:u=!0,checkCreateATAOwner:a=!1,userAuxiliaryLedgers:c,computeBudgetConfig:l,txTipConfig:d}=e,{rewardInfos:p}=n;this.scope.availability.removeFarm===!1&&this.logAndCreateError("farm withdraw feature disabled in your region");let f=Ot[n.programId];Ks(f)||this.logAndCreateError("invalid farm program:",n.programId);let y=(await this.scope.api.fetchFarmKeysById({ids:n.id}))[0],b=this.createTxBuilder(s);b.addCustomComputeBudget(l),b.addTipInstruction(d);let g={};for(let T of this.scope.account.tokenAccounts)if(u){let C=J(this.scope.ownerPubKey,T.mint).publicKey;T.publicKey&&C.equals(T.publicKey)&&(g[T.mint.toString()]=T.publicKey)}else g[T.mint.toString()]=T.publicKey;if(f!==4){let T=Nt({programId:new Te(n.programId),poolId:new Te(n.id),owner:this.scope.ownerPubKey,version:f}),C=await this.scope.connection.getAccountInfo(T);if(C)qo(f).decode(C.data).deposited.isZero()&&this.logAndCreateError("no deposited lp",{farmId:n.id});else if(f!==6){let{instruction:M,instructionType:v}=Go({id:new Te(y.id),programId:new Te(y.programId),version:f,ledger:T,owner:this.scope.ownerPubKey});b.addInstruction({instructions:[M],instructionTypes:[v]})}}r&&r.isZero()&&!(c||[]).length&&this.logAndCreateError("no deposited lp",{farmId:n.id});let P=y.lpMint.address,h=i&&P===j.toString(),I=g[P.toString()];if(!I){let{account:T,instructionParams:C}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:y.lpMint.programId,mint:new Te(P),notUseTokenAccount:h,createInfo:{payer:s||this.scope.ownerPubKey,amount:0},owner:this.scope.ownerPubKey,skipCloseAccount:!0,associatedOnly:h?!1:u,checkCreateATAOwner:a});I=T,C&&b.addInstruction(C)}g[P.toString()]=I;let k=[];for(let T of p){let C=i&&T.mint.address===j.toString(),M=g[T.mint.address];if(!M){let{account:v,instructionParams:R}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:T.mint.programId,mint:new Te(T.mint.address),notUseTokenAccount:C,createInfo:{payer:s||this.scope.ownerPubKey,amount:0},owner:this.scope.ownerPubKey,skipCloseAccount:!C,associatedOnly:C?!1:u,checkCreateATAOwner:a});M=v,R&&b.addInstruction(R)}g[T.mint.address]=M,k.push(M)}let w=Cs({version:f,rewardInfos:p,rewardTokenAccountsPublicKeys:k});w&&this.logAndCreateError(w);let S={amount:$(o),owner:this.scope.ownerPubKey,farmInfo:n,farmKeys:y,lpAccount:I,rewardAccounts:k,userAuxiliaryLedgers:c==null?void 0:c.map(T=>new Te(T))},x=f===6?Xo(S):f===5?zo(S):f===4?Ru(S):Qo(S),K={3:q.FarmV3Withdraw,4:q.FarmV4Withdraw,5:q.FarmV5Withdraw,6:q.FarmV6Withdraw};return b.addInstruction({instructions:[x],instructionTypes:[K[f]]}).versionBuild({txVersion:t})}async withdrawFarmReward({farmInfo:e,withdrawMint:t,txVersion:n,computeBudgetConfig:o,txTipConfig:r,feePayer:i}){var y;this.scope.checkOwner();let s=it((await this.scope.api.fetchFarmKeysById({ids:e.id}))[0]),u=Ot[e.programId];u!==6&&this.logAndCreateError("invalid farm version",u);let a=s.rewardInfos.find(b=>at(b.mint.address).equals(at(t)));a||this.logAndCreateError("withdraw mint error","rewardInfos",e);let c=(y=a==null?void 0:a.vault)!=null?y:$e,l=this.createTxBuilder(i),d;if(t.equals($e)||t.equals(Te.default)){let b=await hn({connection:this.scope.connection,owner:this.scope.ownerPubKey,payer:this.scope.ownerPubKey,amount:Rs(W(N({},a),{openTime:a.openTime,endTime:a.endTime,perSecond:new Em(a.perSecond).mul(10**a.mint.decimals).toString()}))});d=b.addresses.newAccount,l.addInstruction(b)}else{let b=await this.scope.account.getCreatedTokenAccount({mint:t});b===null?(d=await this.scope.account.getAssociatedTokenAccount(t),l.addInstruction({instructions:[Mu(this.scope.ownerPubKey,d,this.scope.ownerPubKey,t)],instructionTypes:[q.CreateATA]})):d=b}let{instruction:p,instructionType:f}=Cu({programId:s.programId,id:s.id,authority:s.authority,lpVault:s.lpVault,rewardVault:c,userRewardToken:d,owner:this.scope.ownerPubKey});return l.addCustomComputeBudget(o),l.addTipInstruction(r),l.addInstruction({instructions:[p],instructionTypes:[f]}).versionBuild({txVersion:n})}async harvestAllRewards(e){let{farmInfoList:t,useSOLBalance:n,feePayer:o,associatedOnly:r=!0,checkCreateATAOwner:i=!1,userAuxiliaryLedgers:s,txVersion:u,computeBudgetConfig:a}=e,c=this.createTxBuilder(o),l={};for(let f of this.scope.account.tokenAccounts)if(r){let y=J(this.scope.ownerPubKey,f.mint).publicKey;f.publicKey&&y.equals(f.publicKey)&&(l[f.mint.toString()]=f.publicKey)}else l[f.mint.toString()]=f.publicKey;let p=(await this.scope.api.fetchFarmKeysById({ids:Object.values(t).map(f=>f.id).join(",")})).reduce((f,y)=>W(N({},f),{[y.id]:y}),{});for(let f of Object.values(t)){let{programId:y,lpMint:b,rewardInfos:g,id:P}=f,h=Ot[y],I=b.address,k=n&&I===j.toString(),w=l[I];if(!w){let{account:M,instructionParams:v}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:b.programId,mint:new Te(I),notUseTokenAccount:k,createInfo:{payer:o||this.scope.ownerPubKey,amount:0},owner:this.scope.ownerPubKey,skipCloseAccount:!0,associatedOnly:k?!1:r,checkCreateATAOwner:i});w=M,v&&c.addInstruction(v)}l[I.toString()]=w;let S=[];for(let M of g){let v=n&&M.mint.address===j.toString(),R=l[M.mint.address];if(!R)if(v){let{account:L,instructionParams:F}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:M.mint.programId,mint:new Te(M.mint.address),notUseTokenAccount:v,createInfo:{payer:o||this.scope.ownerPubKey,amount:0},owner:this.scope.ownerPubKey,skipCloseAccount:!v,associatedOnly:v?!1:r,checkCreateATAOwner:i});R=L,F&&c.addInstruction(F)}else{let L=new Te(M.mint.address);R=this.scope.account.getAssociatedTokenAccount(L),c.addInstruction({instructions:[Mu(this.scope.ownerPubKey,R,this.scope.ownerPubKey,L)]})}l[M.mint.address]=R,S.push(R)}let x=p[P],K={amount:Pt,owner:this.scope.ownerPubKey,farmInfo:f,farmKeys:x,lpAccount:w,rewardAccounts:S,userAuxiliaryLedgers:s==null?void 0:s.map(M=>new Te(M))},T=h===6?Xo(K):h===5?zo(K):Qo(K),C={3:q.FarmV3Withdraw,5:q.FarmV5Withdraw,6:q.FarmV6Withdraw};c.addInstruction({instructions:[T],instructionTypes:[C[h]]})}return u===1?c.sizeCheckBuild({computeBudgetConfig:a}):c.sizeCheckBuildV0({computeBudgetConfig:a})}};import{PublicKey as je}from"@solana/web3.js";import{AccountLayout as xd,NATIVE_MINT as Ar,TOKEN_PROGRAM_ID as xn}from"@solana/spl-token";import{Keypair as lr,PublicKey as U,SystemProgram as fn,TransactionInstruction as st}from"@solana/web3.js";import Gs from"bn.js";import{ASSOCIATED_TOKEN_PROGRAM_ID as ni,TOKEN_2022_PROGRAM_ID as We,TOKEN_PROGRAM_ID as Se}from"@solana/spl-token";import Ym from"bn.js";import bo from"decimal.js";import vt from"bn.js";var Ve=new vt(0),Bt=new vt(1),mn=new vt(-1),Ye=new vt(1).shln(64),rr=new vt(1).shln(128),Yo=Ye.sub(Bt),Ho=64,vu=rr.subn(1),lt=-443636,ft=-lt,_t=new vt("4295048016"),Ft=new vt("79226673521066979257578248091"),sr=new vt("4295048017"),ar=new vt("79226673521066979257578248090"),_u=16,Fu="59543866431248",Vu="184467440737095516",Eu="15793534762490258745",ur=new vt(10).pow(new vt(6));var Du={tvl:0,volumeQuote:0,mintAmountA:0,mintAmountB:0,rewardDefaultInfos:[],farmUpcomingCount:0,farmOngoingCount:0,farmFinishedCount:0,day:{volume:0,volumeQuote:0,volumeFee:0,apr:0,feeApr:0,priceMin:0,priceMax:0,rewardApr:[0]},week:{volume:0,volumeQuote:0,volumeFee:0,apr:0,feeApr:0,priceMin:0,priceMax:0,rewardApr:[0]},month:{volume:0,volumeQuote:0,volumeFee:0,apr:0,feeApr:0,priceMin:0,priceMax:0,rewardApr:[0]},pooltype:[]},_w=new vt("18446744073700000000");import le from"bn.js";import on from"decimal.js";function cr(m){let e=new ArrayBuffer(4);return new DataView(e).setInt32(0,m,!1),new Uint8Array(e)}function Ns(m,e){let t=0;for(let n=m-1;n>=0&&!e.testn(n);n--)t++;return t}function Ms(m,e){let t=0;for(let n=0;n<m&&!e.testn(n);n++)t++;return t}function Zo(m,e){for(let t=0;t<m;t++)if(e.testn(t))return!1;return!0}function Wu(m,e){return Zo(m,e)?null:Ns(m,e)}function qu(m,e){return Zo(m,e)?null:Ms(m,e)}var Ww=Buffer.from("amm_config","utf8"),vs=Buffer.from("pool","utf8"),_s=Buffer.from("pool_vault","utf8"),Wm=Buffer.from("pool_reward_vault","utf8"),Uu=Buffer.from("position","utf8"),qm=Buffer.from("tick_array","utf8"),Um=Buffer.from("operation","utf8"),Gm=Buffer.from("pool_tick_array_bitmap_extension","utf8"),Xm=Buffer.from("observation","utf8");function Gu(m,e,t,n){return se([vs,e.toBuffer(),t.toBuffer(),n.toBuffer()],m)}function Fs(m,e,t){return se([_s,e.toBuffer(),t.toBuffer()],m)}function Xu(m,e,t){return se([Wm,e.toBuffer(),t.toBuffer()],m)}function be(m,e,t){return se([qm,e.toBuffer(),cr(t)],m)}function Zt(m,e,t,n){return se([Uu,e.toBuffer(),cr(t),cr(n)],m)}function yt(m,e){return se([Uu,e.toBuffer()],m)}function dn(m){return se([Buffer.from("metadata","utf8"),Xt.toBuffer(),m.toBuffer()],Xt)}function $o(m){return se([Um],m)}function Xe(m,e){return se([Gm,e.toBuffer()],m)}function zu(m,e){return se([Xm,e.toBuffer()],m)}var Qu=Buffer.from("locked_position","utf8");function Vs(m,e){return se([Qu,e.toBuffer()],m)}function fo(m,e){return se([Qu,e.toBuffer()],m)}var zm=Buffer.from("support_mint","utf8");function Es(m,e){return se([zm,e.toBuffer()],m)}import{PublicKey as xt}from"@solana/web3.js";import{TOKEN_2022_PROGRAM_ID as ju}from"@solana/spl-token";import ve from"bn.js";import Ae from"decimal.js";import nn from"bn.js";import Ds from"decimal.js";var Jo=class{static getfeeGrowthInside(e,t,n){let o=new nn(0),r=new nn(0);e.tickCurrent>=t.tick?(o=t.feeGrowthOutsideX64A,r=t.feeGrowthOutsideX64B):(o=e.feeGrowthGlobalX64A.sub(t.feeGrowthOutsideX64A),r=e.feeGrowthGlobalX64B.sub(t.feeGrowthOutsideX64B));let i=new nn(0),s=new nn(0);e.tickCurrent<n.tick?(i=n.feeGrowthOutsideX64A,s=n.feeGrowthOutsideX64B):(i=e.feeGrowthGlobalX64A.sub(n.feeGrowthOutsideX64A),s=e.feeGrowthGlobalX64B.sub(n.feeGrowthOutsideX64B));let u=ae.wrappingSubU128(ae.wrappingSubU128(e.feeGrowthGlobalX64A,o),i),a=ae.wrappingSubU128(ae.wrappingSubU128(e.feeGrowthGlobalX64B,r),s);return{feeGrowthInsideX64A:u,feeGrowthInsideBX64:a}}static GetPositionFees(e,t,n,o){let{feeGrowthInsideX64A:r,feeGrowthInsideBX64:i}=this.getfeeGrowthInside(e,n,o),s=ae.mulDivFloor(ae.wrappingSubU128(r,t.feeGrowthInsideLastX64A),t.liquidity,Ye),u=t.tokenFeesOwedA.add(s),a=ae.mulDivFloor(ae.wrappingSubU128(i,t.feeGrowthInsideLastX64B),t.liquidity,Ye),c=t.tokenFeesOwedB.add(a);return{tokenFeeAmountA:u,tokenFeeAmountB:c}}static GetPositionFeesV2(e,t,n,o){let{feeGrowthInsideX64A:r,feeGrowthInsideBX64:i}=this.getfeeGrowthInside(e,n,o),s=ae.mulDivFloor(ae.wrappingSubU128(r,t.feeGrowthInsideLastX64A),t.liquidity,Ye),u=t.tokenFeesOwedA.add(s),a=ae.mulDivFloor(ae.wrappingSubU128(i,t.feeGrowthInsideLastX64B),t.liquidity,Ye),c=t.tokenFeesOwedB.add(a);return{tokenFeeAmountA:u,tokenFeeAmountB:c}}static GetPositionRewardsV2(e,t,n,o){let r=[],i=this.getRewardGrowthInsideV2(e.tickCurrent,n,o,e.rewardInfos);for(let s=0;s<i.length;s++){let u=i[s],a=t.rewardInfos[s],c=ae.wrappingSubU128(u,a.growthInsideLastX64),l=ae.mulDivFloor(c,t.liquidity,Ye),d=a.rewardAmountOwed.add(l);r.push(d)}return r}static GetPositionRewards(e,t,n,o){let r=[],i=this.getRewardGrowthInside(e.tickCurrent,n,o,e.rewardInfos);for(let s=0;s<i.length;s++){let u=i[s],a=t.rewardInfos[s],c=ae.wrappingSubU128(u,a.growthInsideLastX64),l=ae.mulDivFloor(c,t.liquidity,Ye),d=a.rewardAmountOwed.add(l);r.push(d)}return r}static getRewardGrowthInside(e,t,n,o){let r=[];for(let i=0;i<o.length;i++){let s=new nn(0);t.liquidityGross.eqn(0)?s=o[i].rewardGrowthGlobalX64:e<t.tick?s=o[i].rewardGrowthGlobalX64.sub(t.rewardGrowthsOutsideX64[i]):s=t.rewardGrowthsOutsideX64[i];let u=new nn(0);n.liquidityGross.eqn(0)||(e<n.tick?u=n.rewardGrowthsOutsideX64[i]:u=o[i].rewardGrowthGlobalX64.sub(n.rewardGrowthsOutsideX64[i])),r.push(ae.wrappingSubU128(ae.wrappingSubU128(o[i].rewardGrowthGlobalX64,s),u))}return r}static getRewardGrowthInsideV2(e,t,n,o){let r=[];for(let i=0;i<o.length;i++){let s=new nn(0);t.liquidityGross.eqn(0)?s=o[i].rewardGrowthGlobalX64:e<t.tick?s=o[i].rewardGrowthGlobalX64.sub(t.rewardGrowthsOutsideX64[i]):s=t.rewardGrowthsOutsideX64[i];let u=new nn(0);n.liquidityGross.eqn(0)||(e<n.tick?u=n.rewardGrowthsOutsideX64[i]:u=o[i].rewardGrowthGlobalX64.sub(n.rewardGrowthsOutsideX64[i])),r.push(ae.wrappingSubU128(ae.wrappingSubU128(o[i].rewardGrowthGlobalX64,s),u))}return r}static getAmountsFromLiquidity({poolInfo:e,ownerPosition:t,liquidity:n,slippage:o,add:r,epochInfo:i}){var b,g,P,h;let s=ie.priceToSqrtPriceX64(new Ds(e.price),e.mintA.decimals,e.mintB.decimals),u=ie.getSqrtPriceX64FromTick(t.tickLower),a=ie.getSqrtPriceX64FromTick(t.tickUpper),c=r?1+o:1-o,l=Pe.getAmountsFromLiquidity(s,u,a,n,r),[d,p]=[xe(l.amountA,(b=e.mintA.extensions)==null?void 0:b.feeConfig,i,!0),xe(l.amountB,(g=e.mintB.extensions)==null?void 0:g.feeConfig,i,!0)],[f,y]=[xe(new nn(new Ds(l.amountA.toString()).mul(c).toFixed(0)),(P=e.mintA.extensions)==null?void 0:P.feeConfig,i,!0),xe(new nn(new Ds(l.amountB.toString()).mul(c).toFixed(0)),(h=e.mintB.extensions)==null?void 0:h.feeConfig,i,!0)];return{liquidity:n,amountA:d,amountB:p,amountSlippageA:f,amountSlippageB:y,expirationTime:jt(d.expirationTime,p.expirationTime)}}};var Qm=15,ge=class{static async getTickArrays(e,t,n,o,r,i,s){let u=[],a=Y.getTickArrayStartIndexByTick(o,r),c=Y.getInitializedTickArrayInRange(i,s,r,a,Math.floor(Qm/2));for(let p=0;p<c.length;p++){let{publicKey:f}=be(t,n,c[p]);u.push(f)}let l=(await Gt(e,u)).map(p=>p!==null?ei.decode(p.data):null),d={};for(let p=0;p<u.length;p++){let f=l[p];f!==null&&(d[f.startTickIndex]=W(N({},f),{address:u[p]}))}return d}static nextInitializedTick(e,t,n,o,r,i){let{initializedTick:s,tickArrayAddress:u,tickArrayStartTickIndex:a}=this.nextInitializedTickInOneArray(e,t,n,o,r,i);for(;s==null||s.liquidityGross.lten(0);){if(a=Y.getNextTickArrayStartIndex(a,r,i),this.checkIsValidStartIndex(a,r))throw new Error("No enough initialized tickArray");let c=n[a];if(c===void 0)continue;let{nextTick:l,tickArrayAddress:d,tickArrayStartTickIndex:p}=this.firstInitializedTickInOneArray(e,t,c,i);[s,u,a]=[l,d,p]}if(s==null)throw new Error("No invaild tickArray cache");return{nextTick:s,tickArrayAddress:u,tickArrayStartTickIndex:a}}static nextInitializedTickArray(e,t,n,o,r){let i=Math.floor(e/ge.tickCount(t)),s=n?Y.searchLowBitFromStart(o,r,i-1,1,t):Y.searchHightBitFromStart(o,r,i+1,1,t);return s.length>0?{isExist:!0,nextStartIndex:s[0]}:{isExist:!1,nextStartIndex:0}}static firstInitializedTickInOneArray(e,t,n,o){let r;if(o){let s=He-1;for(;s>=0;){let u=n.ticks[s];if(u.liquidityGross.gtn(0)){r=u;break}s=s-1}}else{let s=0;for(;s<He;){let u=n.ticks[s];if(u.liquidityGross.gtn(0)){r=u;break}s=s+1}}let{publicKey:i}=be(e,t,n.startTickIndex);return{nextTick:r,tickArrayAddress:i,tickArrayStartTickIndex:n.startTickIndex}}static nextInitializedTickInOneArray(e,t,n,o,r,i){let s=Y.getTickArrayStartIndexByTick(o,r),u=Math.floor((o-s)/r),a=n[s];if(a==null)return{initializedTick:void 0,tickArrayAddress:void 0,tickArrayStartTickIndex:s};let c;if(i)for(;u>=0;){let d=a.ticks[u];if(d.liquidityGross.gtn(0)){c=d;break}u=u-1}else for(u=u+1;u<He;){let d=a.ticks[u];if(d.liquidityGross.gtn(0)){c=d;break}u=u+1}let{publicKey:l}=be(e,t,s);return{initializedTick:c,tickArrayAddress:l,tickArrayStartTickIndex:a.startTickIndex}}static getArrayStartIndex(e,t){let n=this.tickCount(t);return Math.floor(e/n)*n}static checkIsValidStartIndex(e,t){if(Y.checkIsOutOfBoundary(e)){if(e>ft)return!1;let n=Y.getTickArrayStartIndexByTick(lt,t);return e==n}return e%this.tickCount(t)==0}static tickCount(e){return He*e}};var Ws=14,pn=class{static maxTickInTickarrayBitmap(e){return e*He*Dn}static getBitmapTickBoundary(e,t){let n=this.maxTickInTickarrayBitmap(t),o=Math.floor(Math.abs(e)/n);e<0&&Math.abs(e)%n!=0&&(o+=1);let r=n*o;return e<0?{minValue:-r,maxValue:-r+n}:{minValue:r,maxValue:r+n}}static nextInitializedTickArrayStartIndex(e,t,n,o){if(!ge.checkIsValidStartIndex(t,n))throw Error("nextInitializedTickArrayStartIndex check error");let r=this.maxTickInTickarrayBitmap(n),i=o?t-ge.tickCount(n):t+ge.tickCount(n);if(i<-r||i>=r)return{isInit:!1,tickIndex:t};let s=n*He,u=i/s+512;i<0&&i%s!=0&&u--;let a=Math.abs(u);if(o){let c=e.shln(1024-a-1),l=Wu(1024,c);if(l!==null){let d=(a-l-512)*s;return{isInit:!0,tickIndex:d}}else return{isInit:!1,tickIndex:-r}}else{let c=e.shrn(a),l=qu(1024,c);if(l!==null){let d=(a+l-512)*s;return{isInit:!0,tickIndex:d}}else return{isInit:!1,tickIndex:r-ge.tickCount(n)}}}},ti=class{static getBitmapOffset(e,t){if(!ge.checkIsValidStartIndex(e,t))throw new Error("No enough initialized tickArray");this.checkExtensionBoundary(e,t);let n=pn.maxTickInTickarrayBitmap(t),o=Math.floor(Math.abs(e)/n)-1;return e<0&&Math.abs(e)%n===0&&o--,o}static getBitmap(e,t,n){let o=this.getBitmapOffset(e,t);return e<0?{offset:o,tickarrayBitmap:n.negativeTickArrayBitmap[o]}:{offset:o,tickarrayBitmap:n.positiveTickArrayBitmap[o]}}static checkExtensionBoundary(e,t){let{positiveTickBoundary:n,negativeTickBoundary:o}=this.extensionTickBoundary(t);if(e>=o&&e<n)throw Error("checkExtensionBoundary -> InvalidTickArrayBoundary")}static extensionTickBoundary(e){let t=pn.maxTickInTickarrayBitmap(e),n=-t;if(ft<=t)throw Error(`extensionTickBoundary check error: ${ft}, ${t}`);if(n<=lt)throw Error(`extensionTickBoundary check error: ${n}, ${lt}`);return{positiveTickBoundary:t,negativeTickBoundary:n}}static checkTickArrayIsInit(e,t,n){let{tickarrayBitmap:o}=this.getBitmap(e,t,n),r=this.tickArrayOffsetInBitmap(e,t);return{isInitialized:Y.mergeTickArrayBitmap(o).testn(r),startIndex:e}}static nextInitializedTickArrayFromOneBitmap(e,t,n,o){let r=ge.tickCount(t),i=n?e-r:e+r,{tickarrayBitmap:s}=this.getBitmap(i,t,o);return this.nextInitializedTickArrayInBitmap(s,i,t,n)}static nextInitializedTickArrayInBitmap(e,t,n,o){let{minValue:r,maxValue:i}=pn.getBitmapTickBoundary(t,n),s=this.tickArrayOffsetInBitmap(t,n);if(o){let u=Y.mergeTickArrayBitmap(e).shln(Dn-1-s),a=Zo(512,u)?null:Ns(512,u);if(a!==null){let c=t-a*ge.tickCount(n);return{isInit:!0,tickIndex:c}}else return{isInit:!1,tickIndex:r}}else{let u=Y.mergeTickArrayBitmap(e).shrn(s),a=Zo(512,u)?null:Ms(512,u);if(a!==null){let c=t+a*ge.tickCount(n);return{isInit:!0,tickIndex:c}}else return{isInit:!1,tickIndex:i-ge.tickCount(n)}}}static tickArrayOffsetInBitmap(e,t){let n=Math.abs(e)%pn.maxTickInTickarrayBitmap(t),o=Math.floor(n/ge.tickCount(t));return e<0&&n!=0&&(o=Dn-o),o}};var Le=class{static getOutputAmountAndRemainAccounts(e,t,n,o,r,i=!1){let s=n.toBase58()===e.mintA.address,u=[],{isExist:a,startIndex:c,nextAccountMeta:l}=this.getFirstInitializedTickArray(e,s);if(!a||c===void 0||!l)throw new Error("Invalid tick array");u.push(l);let{allTrade:d,amountCalculated:p,accounts:f,sqrtPriceX64:y,feeAmount:b}=Wn.swapCompute(e.programId,e.id,t,e.tickArrayBitmap,e.exBitmapInfo,s,e.ammConfig.tradeFeeRate,e.liquidity,e.tickCurrent,e.tickSpacing,e.sqrtPriceX64,o,c,r,i);return u.push(...f),{allTrade:d,expectedAmountOut:p.mul(mn),remainingAccounts:u,executionPrice:y,feeAmount:b}}static getInputAmountAndRemainAccounts(e,t,n,o,r){let i=n.toBase58()===e.mintB.address,s=[],{isExist:u,startIndex:a,nextAccountMeta:c}=this.getFirstInitializedTickArray(e,i);if(!u||a===void 0||!c)throw new Error("Invalid tick array");try{let y=this.preInitializedTickArrayStartIndex(e,i);if(y.isExist){let{publicKey:b}=be(e.programId,e.id,y.nextStartIndex);s.push(b)}}catch{}s.push(c);let{amountCalculated:l,accounts:d,sqrtPriceX64:p,feeAmount:f}=Wn.swapCompute(e.programId,e.id,t,e.tickArrayBitmap,e.exBitmapInfo,i,e.ammConfig.tradeFeeRate,e.liquidity,e.tickCurrent,e.tickSpacing,e.sqrtPriceX64,o.mul(mn),a,r);return s.push(...d),{expectedAmountIn:l,remainingAccounts:s,executionPrice:p,feeAmount:f}}static getFirstInitializedTickArray(e,t){let{isInitialized:n,startIndex:o}=Le.isOverflowDefaultTickarrayBitmap(e.tickSpacing,[e.tickCurrent])?ti.checkTickArrayIsInit(ge.getArrayStartIndex(e.tickCurrent,e.tickSpacing),e.tickSpacing,e.exBitmapInfo):Y.checkTickArrayIsInitialized(Y.mergeTickArrayBitmap(e.tickArrayBitmap),e.tickCurrent,e.tickSpacing);if(n){let{publicKey:s}=be(e.programId,e.id,o);return{isExist:!0,startIndex:o,nextAccountMeta:s}}let{isExist:r,nextStartIndex:i}=this.nextInitializedTickArrayStartIndex(e,ge.getArrayStartIndex(e.tickCurrent,e.tickSpacing),t);if(r){let{publicKey:s}=be(e.programId,e.id,i);return{isExist:!0,startIndex:i,nextAccountMeta:s}}return{isExist:!1,nextAccountMeta:void 0,startIndex:void 0}}static preInitializedTickArrayStartIndex(e,t){let n=Math.floor(e.tickCurrent/ge.tickCount(e.tickSpacing)),o=t?Y.searchHightBitFromStart(e.tickArrayBitmap,e.exBitmapInfo,n+1,1,e.tickSpacing):Y.searchLowBitFromStart(e.tickArrayBitmap,e.exBitmapInfo,n-1,1,e.tickSpacing);return o.length>0?{isExist:!0,nextStartIndex:o[0]}:{isExist:!1,nextStartIndex:0}}static nextInitializedTickArrayStartIndex(e,t,n){for(t=ge.getArrayStartIndex(e.tickCurrent,e.tickSpacing);;){let{isInit:o,tickIndex:r}=pn.nextInitializedTickArrayStartIndex(Y.mergeTickArrayBitmap(e.tickArrayBitmap),t,e.tickSpacing,n);if(o)return{isExist:!0,nextStartIndex:r};t=r;let{isInit:i,tickIndex:s}=ti.nextInitializedTickArrayFromOneBitmap(t,e.tickSpacing,n,e.exBitmapInfo);if(i)return{isExist:!0,nextStartIndex:s};if(t=s,t<lt||t>ft)return{isExist:!1,nextStartIndex:0}}}static async updatePoolRewardInfos({connection:e,apiPoolInfo:t,chainTime:n,poolLiquidity:o,rewardInfos:r}){var s,u,a;let i=[];for(let c=0;c<r.length;c++){let l=r[c],d=(a=(s=t.rewardDefaultInfos[c])==null?void 0:s.mint.programId)!=null?a:(u=await e.getAccountInfo(l.tokenMint))==null?void 0:u.owner;if(d===void 0)throw Error("get new reward mint info error");let p=W(N({},l),{perSecond:ae.x64ToDecimal(l.emissionsPerSecondX64),remainingRewards:void 0,tokenProgramId:new xt(d)});if(p.tokenMint.equals(xt.default))continue;if(n<=p.openTime.toNumber()||o.eq(Ve)){i.push(p);continue}let f=new ve(Math.min(p.endTime.toNumber(),n)),y=f.sub(p.lastUpdateTime),b=ae.mulDivFloor(y,p.emissionsPerSecondX64,o),g=p.rewardGrowthGlobalX64.add(b),P=ae.mulDivFloor(y,p.emissionsPerSecondX64,Ye),h=p.rewardTotalEmissioned.add(P);i.push(W(N({},p),{rewardGrowthGlobalX64:g,rewardTotalEmissioned:h,lastUpdateTime:f}))}return i}static isOverflowDefaultTickarrayBitmap(e,t){let{maxTickBoundary:n,minTickBoundary:o}=this.tickRange(e);for(let r of t){let i=Y.getTickArrayStartIndexByTick(r,e);if(i>=n||i<o)return!0}return!1}static tickRange(e){let t=pn.maxTickInTickarrayBitmap(e),n=-t;return t>ft&&(t=ge.getArrayStartIndex(ft,e)+ge.tickCount(e)),n<lt&&(n=ge.getArrayStartIndex(lt,e)),{maxTickBoundary:t,minTickBoundary:n}}static get_tick_array_offset(e,t){if(!ge.checkIsValidStartIndex(e,t))throw new Error("No enough initialized tickArray");return e/ge.tickCount(t)*Dn}static async fetchExBitmaps({connection:e,exBitmapAddress:t,batchRequest:n}){let o=await Re(e,t.map(i=>({pubkey:i})),{batchRequest:n}),r={};for(let i of o)i.accountInfo!==null&&(r[i.pubkey.toString()]=Hu.decode(i.accountInfo.data));return r}static async fetchMultiplePoolTickArrays({connection:e,poolKeys:t,batchRequest:n}){let o={},r=[];for(let u of t){let a=Y.getTickArrayStartIndexByTick(u.tickCurrent,u.tickSpacing),c=Y.getInitializedTickArrayInRange(u.tickArrayBitmap,u.exBitmapInfo,u.tickSpacing,a,7);for(let l of c){let{publicKey:d}=be(u.programId,u.id,l);r.push({pubkey:d}),o[d.toString()]=u.id}}let i=await Re(e,r,{batchRequest:n}),s={};for(let u of i){if(!u.accountInfo)continue;let a=o[u.pubkey.toString()];if(!a)continue;s[a.toString()]===void 0&&(s[a.toString()]={});let c=ei.decode(u.accountInfo.data);s[a.toString()][c.startTickIndex]=W(N({},c),{address:u.pubkey})}return s}static async fetchPoolsAccountPosition({pools:e,connection:t,ownerInfo:n,batchRequest:o=!1,updateOwnerRewardAndFee:r=!0}){var s;let i=[];for(let u=0;u<e.length;u++){let a=e[u];a!==null&&(i.find(c=>c.equals(a.state.programId))||i.push(a.state.programId))}if(n){let u=n.tokenAccounts.map(d=>d.accountInfo.mint),a=[];for(let d of u)for(let p of i)a.push(yt(p,d).publicKey);let c=await Gt(t,a,{batchRequest:o}),l={};for(let d of c){if(d===null)continue;let p=yo.decode(d.data),f=p.poolId.toString(),y=e.find(x=>x.state.id.toBase58()===f);if(y===void 0)continue;let b=y.state,g=Y._getTickPriceLegacy({poolInfo:b,tick:p.tickLower,baseIn:!0}),P=Y._getTickPriceLegacy({poolInfo:b,tick:p.tickUpper,baseIn:!0}),{amountA:h,amountB:I}=Pe.getAmountsFromLiquidity(b.sqrtPriceX64,g.tickSqrtPriceX64,P.tickSqrtPriceX64,p.liquidity,!1),k=1/(1-Math.sqrt(Math.sqrt(g.price.div(P.price).toNumber())));y.positionAccount=[...(s=y.positionAccount)!=null?s:[],{poolId:p.poolId,nftMint:p.nftMint,priceLower:g.price,priceUpper:P.price,amountA:h,amountB:I,tickLower:p.tickLower,tickUpper:p.tickUpper,liquidity:p.liquidity,feeGrowthInsideLastX64A:p.feeGrowthInsideLastX64A,feeGrowthInsideLastX64B:p.feeGrowthInsideLastX64B,tokenFeesOwedA:p.tokenFeesOwedA,tokenFeesOwedB:p.tokenFeesOwedB,rewardInfos:p.rewardInfos.map(x=>W(N({},x),{pendingReward:new ve(0)})),leverage:k,tokenFeeAmountA:new ve(0),tokenFeeAmountB:new ve(0)}];let w=await Y.getTickArrayAddressByTick(y.state.programId,p.poolId,p.tickLower,y.state.tickSpacing),S=await Y.getTickArrayAddressByTick(y.state.programId,p.poolId,p.tickUpper,y.state.tickSpacing);l[`${y.state.programId.toString()}-${p.poolId.toString()}-${p.tickLower}`]=w,l[`${y.state.programId.toString()}-${p.poolId.toString()}-${p.tickUpper}`]=S}if(r){let d=Object.values(l),p=await Gt(t,d,{batchRequest:o}),f={};for(let y=0;y<d.length;y++){let b=p[y];if(b===null)continue;let g=d[y].toString();f[g]=ei.decode(b.data)}for(let{state:y,positionAccount:b}of e)if(!!b)for(let g of b){let P=`${y.programId.toString()}-${y.id.toString()}-${g.tickLower}`,h=`${y.programId.toString()}-${y.id.toString()}-${g.tickUpper}`,I=f[l[P].toString()],k=f[l[h].toString()],w=I.ticks[Y.getTickOffsetInArray(g.tickLower,y.tickSpacing)],S=k.ticks[Y.getTickOffsetInArray(g.tickUpper,y.tickSpacing)],{tokenFeeAmountA:x,tokenFeeAmountB:K}=await Jo.GetPositionFees(y,g,w,S),T=await Jo.GetPositionRewards(y,g,w,S);g.tokenFeeAmountA=x.gte(new ve(0))?x:new ve(0),g.tokenFeeAmountB=K.gte(new ve(0))?K:new ve(0);for(let C=0;C<T.length;C++)g.rewardInfos[C].pendingReward=T[C].gte(new ve(0))?T[C]:new ve(0)}}}return e}static computeAmountOut({poolInfo:e,tickArrayCache:t,baseMint:n,epochInfo:o,amountIn:r,slippage:i,priceLimit:s=new Ae(0),catchLiquidityInsufficient:u=!1}){var M;let a,c=n.toBase58()===e.mintA.address,[l,d]=c?[e.mintA.extensions.feeConfig,e.mintB.extensions.feeConfig]:[e.mintB.extensions.feeConfig,e.mintA.extensions.feeConfig];s.equals(new Ae(0))?a=c?_t.add(new ve(1)):Ft.sub(new ve(1)):a=ie.priceToSqrtPriceX64(s,e.mintA.decimals,e.mintB.decimals);let p=xe(r,l,o,!1),{allTrade:f,expectedAmountOut:y,remainingAccounts:b,executionPrice:g,feeAmount:P}=Le.getOutputAmountAndRemainAccounts(e,t,n,p.amount.sub((M=p.fee)!=null?M:Ve),a,u),h=xe(y,d,o,!1),I=ie.sqrtPriceX64ToPrice(g,e.mintA.decimals,e.mintB.decimals),k=c?I:new Ae(1).div(I),w=y.mul(new ve(Math.floor((1-i)*1e10))).div(new ve(1e10)),S=xe(w,d,o,!1),x=c?e.currentPrice:new Ae(1).div(e.currentPrice),K=new Ae(k).sub(x).abs(),T=x,C=new Je(new Ae(K).mul(10**15).toFixed(0),new Ae(T).mul(10**15).toFixed(0));return{allTrade:f,realAmountIn:p,amountOut:h,minAmountOut:S,expirationTime:jt(p.expirationTime,h.expirationTime),currentPrice:e.currentPrice,executionPrice:k,priceImpact:C,fee:P,remainingAccounts:b,executionPriceX64:g}}static computeAmountOutFormat({poolInfo:e,tickArrayCache:t,amountIn:n,tokenOut:o,slippage:r,epochInfo:i,catchLiquidityInsufficient:s=!1}){let u=o.address===e.mintB.address,[a,c]=u?[e.mintA,e.mintB]:[e.mintB,e.mintA],[l,d]=[new Fe(W(N({},a),{mint:a.address,isToken2022:a.programId===ju.toBase58()})),new Fe(W(N({},c),{mint:c.address,isToken2022:c.programId===ju.toBase58()}))],{allTrade:p,realAmountIn:f,amountOut:y,minAmountOut:b,expirationTime:g,currentPrice:P,executionPrice:h,priceImpact:I,fee:k,remainingAccounts:w,executionPriceX64:S}=Le.computeAmountOut({poolInfo:e,tickArrayCache:t,baseMint:new xt(a.address),amountIn:n,slippage:r,epochInfo:i,catchLiquidityInsufficient:s}),x=W(N({},f),{amount:new Be(l,f.amount),fee:f.fee===void 0?void 0:new Be(l,f.fee)}),K=W(N({},y),{amount:new Be(d,y.amount),fee:y.fee===void 0?void 0:new Be(d,y.fee)}),T=W(N({},b),{amount:new Be(d,b.amount),fee:b.fee===void 0?void 0:new Be(d,b.fee)}),C=new At({baseToken:l,denominator:new ve(10).pow(new ve(20+l.decimals)),quoteToken:d,numerator:P.mul(new Ae(10**(20+d.decimals))).toFixed(0)}),M=new At({baseToken:l,denominator:new ve(10).pow(new ve(20+l.decimals)),quoteToken:d,numerator:h.mul(new Ae(10**(20+d.decimals))).toFixed(0)}),v=new Be(l,k);return{allTrade:p,realAmountIn:x,amountOut:K,minAmountOut:T,expirationTime:g,currentPrice:C,executionPrice:M,priceImpact:I,fee:v,remainingAccounts:w,executionPriceX64:S}}static computeAmountIn({poolInfo:e,tickArrayCache:t,baseMint:n,epochInfo:o,amountOut:r,slippage:i,priceLimit:s=new Ae(0)}){var T;let u=n.toBase58()===e.mintA.address,a={[e.mintA.address]:e.mintA.extensions.feeConfig,[e.mintB.address]:e.mintB.extensions.feeConfig},c;s.equals(new Ae(0))?c=u?Ft.sub(new ve(1)):_t.add(new ve(1)):c=ie.priceToSqrtPriceX64(s,e.mintA.decimals,e.mintB.decimals);let l=xe(r,a[n.toString()],o,!0),{expectedAmountIn:d,remainingAccounts:p,executionPrice:f,feeAmount:y}=Le.getInputAmountAndRemainAccounts(e,t,n,l.amount.sub((T=l.fee)!=null?T:Ve),c),b=u?e.mintB.address:e.mintA.address,g=xe(d,a[b],o,!1),P=ie.sqrtPriceX64ToPrice(f,e.mintA.decimals,e.mintB.decimals),h=u?P:new Ae(1).div(P),I=d.mul(new ve(Math.floor((1+i)*1e10))).div(new ve(1e10)),k=xe(I,a[b],o,!0),w=u?e.currentPrice:new Ae(1).div(e.currentPrice),S=new Ae(h).sub(w).abs(),x=w,K=new Je(new Ae(S).mul(10**15).toFixed(0),new Ae(x).mul(10**15).toFixed(0));return{amountIn:g,maxAmountIn:k,realAmountOut:l,expirationTime:jt(g.expirationTime,l.expirationTime),currentPrice:e.currentPrice,executionPrice:h,priceImpact:K,fee:y,remainingAccounts:p}}static estimateAprsForPriceRangeMultiplier({poolInfo:e,aprType:t,positionTickLowerIndex:n,positionTickUpperIndex:o}){var f,y,b;let r=e[t],i=Y.getTickPrice({poolInfo:e,tick:n,baseIn:!0}).price.toNumber(),s=Y.getTickPrice({poolInfo:e,tick:o,baseIn:!0}).price.toNumber(),u=Math.max(i,r.priceMin),c=Math.min(s,r.priceMax)-u,l=s-i,d=r.priceMax-r.priceMin,p;return c<=0?p=0:l===c?p=d/c:d===c?p=c/l:p=c/d*(c/l),{feeApr:r.feeApr*p,rewardsApr:[((f=r.rewardApr[0])!=null?f:0)*p,((y=r.rewardApr[1])!=null?y:0)*p,((b=r.rewardApr[2])!=null?b:0)*p],apr:r.apr*p}}static estimateAprsForPriceRangeDelta({poolInfo:e,poolLiquidity:t,aprType:n,mintPrice:o,liquidity:r,positionTickLowerIndex:i,positionTickUpperIndex:s,chainTime:u}){let a=n==="day"?1:n==="week"?7:n==="month"?30:0,c=e[n],l=o[at(e.mintA.address).toString()],d=o[at(e.mintB.address).toString()],p=e.mintA.decimals,f=e.mintB.decimals;if(!c||!l||!d)return{feeApr:0,rewardsApr:[0,0,0],apr:0};let y=ie.priceToSqrtPriceX64(new Ae(e.price),e.mintA.decimals,e.mintB.decimals),b=ie.getSqrtPriceX64FromTick(i),g=ie.getSqrtPriceX64FromTick(s),{amountSlippageA:P,amountSlippageB:h}=Pe.getAmountsFromLiquidityWithSlippage(y,b,g,t,!1,!1,0),{amountSlippageA:I,amountSlippageB:k}=Pe.getAmountsFromLiquidityWithSlippage(y,b,g,r,!1,!1,0),w=new Ae(P.toString()).div(new Ae(10).pow(p)).mul(l.value).add(new Ae(h.toString()).div(new Ae(10).pow(f)).mul(d.value)),S=new Ae(I.toString()).div(new Ae(10).pow(p)).mul(l.value).add(new Ae(k.toString()).div(new Ae(10).pow(f)).mul(d.value)),x=new Ae(1).div(w.add(S)),T=new Ae(c.volumeFee).mul(365).div(a).mul(x).mul(100).toNumber(),C=3600*24*365,M=e.rewardDefaultInfos.map(v=>{var F,X;let R=v.mint.decimals,L=o[v.mint.address];return u<((F=v.startTime)!=null?F:0)||u>((X=v.endTime)!=null?X:0)||!v.perSecond||!L||R===void 0?0:new Ae(L.value).mul(new Ae(v.perSecond).mul(C)).div(new Ae(10).pow(R)).mul(x).mul(100).toNumber()});return{feeApr:T,rewardsApr:M,apr:T+M.reduce((v,R)=>v+R,0)}}static async getLiquidityAmountOutFromAmountIn({poolInfo:e,inputA:t,tickLower:n,tickUpper:o,amount:r,slippage:i,add:s,epochInfo:u,amountHasFee:a}){var g,P;let c=ie.priceToSqrtPriceX64(new Ae(e.price),e.mintA.decimals,e.mintB.decimals),l=ie.getSqrtPriceX64FromTick(n),d=ie.getSqrtPriceX64FromTick(o),p=xe(r,(g=e[t?"mintA":"mintB"].extensions)==null?void 0:g.feeConfig,u,!a),f=new ve(new Ae(p.amount.sub((P=p.fee)!=null?P:Ve).toString()).toFixed(0)),y;if(c.lte(l))y=t?Pe.getLiquidityFromTokenAmountA(l,d,f,!s):new ve(0);else if(c.lte(d)){let h=Pe.getLiquidityFromTokenAmountA(c,d,f,!s),I=Pe.getLiquidityFromTokenAmountB(l,c,f);y=t?h:I}else y=t?new ve(0):Pe.getLiquidityFromTokenAmountB(l,d,f);let b=await Le.getAmountsFromLiquidity({epochInfo:u,poolInfo:e,tickLower:n,tickUpper:o,liquidity:y,slippage:i,add:s});return{liquidity:y,amountA:t?p:b.amountA,amountB:t?b.amountB:p,amountSlippageA:t?p:b.amountSlippageA,amountSlippageB:t?b.amountSlippageB:p,expirationTime:b.expirationTime}}static async getAmountsFromLiquidity({epochInfo:e,poolInfo:t,tickLower:n,tickUpper:o,liquidity:r,slippage:i,add:s}){var b,g,P,h;let u=ie.getSqrtPriceX64FromTick(n),a=ie.getSqrtPriceX64FromTick(o),c=s?1+i:1-i,l=Pe.getAmountsFromLiquidity(ie.priceToSqrtPriceX64(new Ae(t.price),t.mintA.decimals,t.mintB.decimals),u,a,r,s),[d,p]=[xe(l.amountA,(b=t.mintA.extensions)==null?void 0:b.feeConfig,e,!0),xe(l.amountB,(g=t.mintB.extensions)==null?void 0:g.feeConfig,e,!0)],[f,y]=[xe(l.amountA.muln(c),(P=t.mintA.extensions)==null?void 0:P.feeConfig,e,!0),xe(l.amountB.muln(c),(h=t.mintB.extensions)==null?void 0:h.feeConfig,e,!0)];return{liquidity:r,amountA:d,amountB:p,amountSlippageA:f,amountSlippageB:y,expirationTime:jt(d.expirationTime,p.expirationTime)}}static async fetchComputeMultipleClmmInfo({connection:e,poolList:t,rpcDataMap:n={}}){let o=t.filter(u=>!n[u.id]).map(u=>new xt(u.id));(await Gt(e,o)).forEach((u,a)=>{!u||(n[o[a].toBase58()]=qn.decode(u.data))});let i=t.map(u=>Xe(new xt(u.programId),new xt(u.id)).publicKey),s=await Le.fetchExBitmaps({connection:e,exBitmapAddress:i,batchRequest:!1});return t.reduce((u,a)=>W(N({},u),{[a.id]:W(N({},n[a.id]),{id:new xt(a.id),version:6,programId:new xt(a.programId),mintA:a.mintA,mintB:a.mintB,ammConfig:W(N({},a.config),{id:new xt(a.config.id),fundOwner:""}),currentPrice:new Ae(a.price),exBitmapAccount:Xe(new xt(a.programId),new xt(a.id)).publicKey,exBitmapInfo:s[Xe(new xt(a.programId),new xt(a.id)).publicKey.toBase58()],startTime:n[a.id].startTime.toNumber(),rewardInfos:n[a.id].rewardInfos})}),{})}static async fetchComputeClmmInfo({connection:e,poolInfo:t,rpcData:n}){return(await this.fetchComputeMultipleClmmInfo({connection:e,rpcDataMap:n?{[t.id]:n}:void 0,poolList:[t]}))[t.id]}};var qs={volume:0,volumeQuote:0,volumeFee:0,apr:0,feeApr:0,priceMin:0,priceMax:0,rewardApr:[]};function Yu(m){return W(N({},m),{type:"Concentrated",programId:m.programId.toString(),id:m.id.toString(),rewardDefaultInfos:[],rewardDefaultPoolInfos:"Clmm",price:m.currentPrice.toNumber(),mintAmountA:0,mintAmountB:0,feeRate:m.ammConfig.tradeFeeRate,openTime:m.startTime.toString(),tvl:0,day:qs,week:qs,month:qs,pooltype:[],farmUpcomingCount:0,farmOngoingCount:0,farmFinishedCount:0,burnPercent:0,config:W(N({},m.ammConfig),{id:m.ammConfig.id.toString(),defaultRange:0,defaultRangePoint:[]})})}var ae=class{static mulDivRoundingUp(e,t,n){let o=e.mul(t),r=o.div(n);return o.mod(n).eq(Ve)||(r=r.add(Bt)),r}static mulDivFloor(e,t,n){if(n.eq(Ve))throw new Error("division by 0");return e.mul(t).div(n)}static mulDivCeil(e,t,n){if(n.eq(Ve))throw new Error("division by 0");return e.mul(t).add(n.sub(Bt)).div(n)}static x64ToDecimal(e,t){return new on(e.toString()).div(on.pow(2,64)).toDecimalPlaces(t)}static decimalToX64(e){return new le(e.mul(on.pow(2,64)).floor().toFixed())}static wrappingSubU128(e,t){return e.add(rr).sub(t).mod(rr)}};function tt(m,e){return Us(m.mul(e),64,256)}function jm(m,e,t){let n=m.toTwos(t).shln(e);return n.imaskn(t+1),n.fromTwos(t)}function Us(m,e,t){let n=m.toTwos(t).shrn(e);return n.imaskn(t-e+1),n.fromTwos(t-e)}var ie=class{static sqrtPriceX64ToPrice(e,t,n){return ae.x64ToDecimal(e).pow(2).mul(on.pow(10,t-n))}static priceToSqrtPriceX64(e,t,n){return ae.decimalToX64(e.mul(on.pow(10,n-t)).sqrt())}static getNextSqrtPriceX64FromInput(e,t,n,o){if(!e.gt(Ve))throw new Error("sqrtPriceX64 must greater than 0");if(!t.gt(Ve))throw new Error("liquidity must greater than 0");return o?this.getNextSqrtPriceFromTokenAmountARoundingUp(e,t,n,!0):this.getNextSqrtPriceFromTokenAmountBRoundingDown(e,t,n,!0)}static getNextSqrtPriceX64FromOutput(e,t,n,o){if(!e.gt(Ve))throw new Error("sqrtPriceX64 must greater than 0");if(!t.gt(Ve))throw new Error("liquidity must greater than 0");return o?this.getNextSqrtPriceFromTokenAmountBRoundingDown(e,t,n,!1):this.getNextSqrtPriceFromTokenAmountARoundingUp(e,t,n,!1)}static getNextSqrtPriceFromTokenAmountARoundingUp(e,t,n,o){if(n.eq(Ve))return e;let r=t.shln(Ho);if(o){let i=r,s=r.add(n.mul(e));return s.gte(i)?ae.mulDivCeil(i,e,s):ae.mulDivRoundingUp(i,Bt,i.div(e).add(n))}else{let i=n.mul(e);if(!r.gt(i))throw new Error("getNextSqrtPriceFromTokenAmountARoundingUp,liquidityLeftShift must gt amountMulSqrtPrice");let s=r.sub(i);return ae.mulDivCeil(r,e,s)}}static getNextSqrtPriceFromTokenAmountBRoundingDown(e,t,n,o){let r=n.shln(Ho);if(o)return e.add(r.div(t));{let i=ae.mulDivRoundingUp(r,Bt,t);if(!e.gt(i))throw new Error("getNextSqrtPriceFromTokenAmountBRoundingDown sqrtPriceX64 must gt amountDivLiquidity");return e.sub(i)}}static getSqrtPriceX64FromTick(e){if(!Number.isInteger(e))throw new Error("tick must be integer");if(e<lt||e>ft)throw new Error("tick must be in MIN_TICK and MAX_TICK");let t=e<0?e*-1:e,n=(t&1)!=0?new le("18445821805675395072"):new le("18446744073709551616");return(t&2)!=0&&(n=tt(n,new le("18444899583751176192"))),(t&4)!=0&&(n=tt(n,new le("18443055278223355904"))),(t&8)!=0&&(n=tt(n,new le("18439367220385607680"))),(t&16)!=0&&(n=tt(n,new le("18431993317065453568"))),(t&32)!=0&&(n=tt(n,new le("18417254355718170624"))),(t&64)!=0&&(n=tt(n,new le("18387811781193609216"))),(t&128)!=0&&(n=tt(n,new le("18329067761203558400"))),(t&256)!=0&&(n=tt(n,new le("18212142134806163456"))),(t&512)!=0&&(n=tt(n,new le("17980523815641700352"))),(t&1024)!=0&&(n=tt(n,new le("17526086738831433728"))),(t&2048)!=0&&(n=tt(n,new le("16651378430235570176"))),(t&4096)!=0&&(n=tt(n,new le("15030750278694412288"))),(t&8192)!=0&&(n=tt(n,new le("12247334978884435968"))),(t&16384)!=0&&(n=tt(n,new le("8131365268886854656"))),(t&32768)!=0&&(n=tt(n,new le("3584323654725218816"))),(t&65536)!=0&&(n=tt(n,new le("696457651848324352"))),(t&131072)!=0&&(n=tt(n,new le("26294789957507116"))),(t&262144)!=0&&(n=tt(n,new le("37481735321082"))),e>0&&(n=vu.div(n)),n}static getTickFromPrice(e,t,n){return ie.getTickFromSqrtPriceX64(ie.priceToSqrtPriceX64(e,t,n))}static getTickFromSqrtPriceX64(e){if(e.gt(Ft)||e.lt(_t))throw new Error("Provided sqrtPrice is not within the supported sqrtPrice range.");let t=e.bitLength()-1,n=new le(t-64),o=jm(n,32,128),r=new le("8000000000000000","hex"),i=0,s=new le(0),u=t>=64?e.shrn(t-63):e.shln(63-t);for(;r.gt(new le(0))&&i<_u;){u=u.mul(u);let f=u.shrn(127);u=u.shrn(63+f.toNumber()),s=s.add(r.mul(f)),r=r.shrn(1),i+=1}let a=s.shrn(32),l=o.add(a).mul(new le(Fu)),d=Us(l.sub(new le(Vu)),64,128).toNumber(),p=Us(l.add(new le(Eu)),64,128).toNumber();return d==p?d:ie.getSqrtPriceX64FromTick(p).lte(e)?p:d}},Un=class{static getTickWithPriceAndTickspacing(e,t,n,o){let i=ie.getTickFromSqrtPriceX64(ie.priceToSqrtPriceX64(e,n,o))/t;return i<0?i=Math.floor(i):i=Math.ceil(i),i*t}static roundPriceWithTickspacing(e,t,n,o){let r=Un.getTickWithPriceAndTickspacing(e,t,n,o),i=ie.getSqrtPriceX64FromTick(r);return ie.sqrtPriceX64ToPrice(i,n,o)}},Pe=class{static addDelta(e,t){return e.add(t)}static getTokenAmountAFromLiquidity(e,t,n,o){if(e.gt(t)&&([e,t]=[t,e]),!e.gt(Ve))throw new Error("sqrtPriceX64A must greater than 0");let r=n.ushln(Ho),i=t.sub(e);return o?ae.mulDivRoundingUp(ae.mulDivCeil(r,i,t),Bt,e):ae.mulDivFloor(r,i,t).div(e)}static getTokenAmountBFromLiquidity(e,t,n,o){if(e.gt(t)&&([e,t]=[t,e]),!e.gt(Ve))throw new Error("sqrtPriceX64A must greater than 0");return o?ae.mulDivCeil(n,t.sub(e),Ye):ae.mulDivFloor(n,t.sub(e),Ye)}static getLiquidityFromTokenAmountA(e,t,n,o){e.gt(t)&&([e,t]=[t,e]);let r=n.mul(e).mul(t),i=t.sub(e),s=r.div(i);return o?ae.mulDivRoundingUp(s,Bt,Yo):s.shrn(Ho)}static getLiquidityFromTokenAmountB(e,t,n){return e.gt(t)&&([e,t]=[t,e]),ae.mulDivFloor(n,Yo,t.sub(e))}static getLiquidityFromTokenAmounts(e,t,n,o,r){if(t.gt(n)&&([t,n]=[n,t]),e.lte(t))return Pe.getLiquidityFromTokenAmountA(t,n,o,!1);if(e.lt(n)){let i=Pe.getLiquidityFromTokenAmountA(e,n,o,!1),s=Pe.getLiquidityFromTokenAmountB(t,e,r);return i.lt(s)?i:s}else return Pe.getLiquidityFromTokenAmountB(t,n,r)}static getAmountsFromLiquidity(e,t,n,o,r){if(t.gt(n)&&([t,n]=[n,t]),e.lte(t))return{amountA:Pe.getTokenAmountAFromLiquidity(t,n,o,r),amountB:new le(0)};if(e.lt(n)){let i=Pe.getTokenAmountAFromLiquidity(e,n,o,r),s=Pe.getTokenAmountBFromLiquidity(t,e,o,r);return{amountA:i,amountB:s}}else return{amountA:new le(0),amountB:Pe.getTokenAmountBFromLiquidity(t,n,o,r)}}static getAmountsFromLiquidityWithSlippage(e,t,n,o,r,i,s){let{amountA:u,amountB:a}=Pe.getAmountsFromLiquidity(e,t,n,o,i),c=r?1+s:1-s,l=new le(new on(u.toString()).mul(c).toFixed(0)),d=new le(new on(a.toString()).mul(c).toFixed(0));return{amountSlippageA:l,amountSlippageB:d}}static getAmountsOutFromLiquidity({poolInfo:e,tickLower:t,tickUpper:n,liquidity:o,slippage:r,add:i,epochInfo:s,amountAddFee:u}){var P,h,I,k;let a=ie.priceToSqrtPriceX64(new on(e.price),e.mintA.decimals,e.mintB.decimals),c=ie.getSqrtPriceX64FromTick(t),l=ie.getSqrtPriceX64FromTick(n),d=i?1+r:1-r,p=Pe.getAmountsFromLiquidity(a,c,l,o,i),[f,y]=[xe(p.amountA,(P=e.mintA.extensions)==null?void 0:P.feeConfig,s,u),xe(p.amountB,(h=e.mintB.extensions)==null?void 0:h.feeConfig,s,u)],[b,g]=[xe(new le(new on(p.amountA.toString()).mul(d).toFixed(0)),(I=e.mintA.extensions)==null?void 0:I.feeConfig,s,u),xe(new le(new on(p.amountB.toString()).mul(d).toFixed(0)),(k=e.mintB.extensions)==null?void 0:k.feeConfig,s,u)];return{liquidity:o,amountA:f,amountB:y,amountSlippageA:b,amountSlippageB:g,expirationTime:jt(f.expirationTime,y.expirationTime)}}},Wn=class{static swapCompute(e,t,n,o,r,i,s,u,a,c,l,d,p,f,y=!1){if(d.eq(Ve))throw new Error("amountSpecified must not be 0");if(f||(f=i?_t.add(Bt):Ft.sub(Bt)),i){if(f.lt(_t))throw new Error("sqrtPriceX64 must greater than MIN_SQRT_PRICE_X64");if(f.gte(l))throw new Error("sqrtPriceX64 must smaller than current")}else{if(f.gt(Ft))throw new Error("sqrtPriceX64 must smaller than MAX_SQRT_PRICE_X64");if(f.lte(l))throw new Error("sqrtPriceX64 must greater than current")}let b=d.gt(Ve),g={amountSpecifiedRemaining:d,amountCalculated:Ve,sqrtPriceX64:l,tick:a>p?Math.min(p+ge.tickCount(c)-1,a):p,accounts:[],liquidity:u,feeAmount:new le(0)},P=p,h=n[p],I=0,k=!i&&h.startTickIndex===g.tick;for(;!g.amountSpecifiedRemaining.eq(Ve)&&!g.sqrtPriceX64.eq(f);){I>10;let w={};w.sqrtPriceStartX64=g.sqrtPriceX64;let S=Y.nextInitTick(h,g.tick,c,i,k),x=S||null,K=null;if(!(x!=null&&x.liquidityGross.gtn(0))){let C=Le.nextInitializedTickArrayStartIndex({tickCurrent:g.tick,tickSpacing:c,tickArrayBitmap:o,exBitmapInfo:r},P,i);if(!C.isExist){if(y)return{allTrade:!1,amountSpecifiedRemaining:g.amountSpecifiedRemaining,amountCalculated:g.amountCalculated,feeAmount:g.feeAmount,sqrtPriceX64:g.sqrtPriceX64,liquidity:g.liquidity,tickCurrent:g.tick,accounts:g.accounts};throw Error("swapCompute LiquidityInsufficient")}P=C.nextStartIndex;let{publicKey:M}=be(e,t,P);K=M,h=n[P];try{x=Y.firstInitializedTick(h,i)}catch{throw Error("not found next tick info")}}w.tickNext=x.tick,w.initialized=x.liquidityGross.gtn(0),p!==P&&K&&(g.accounts.push(K),p=P),w.tickNext<lt?w.tickNext=lt:w.tickNext>ft&&(w.tickNext=ft),w.sqrtPriceNextX64=ie.getSqrtPriceX64FromTick(w.tickNext);let T;if(i&&w.sqrtPriceNextX64.lt(f)||!i&&w.sqrtPriceNextX64.gt(f)?T=f:T=w.sqrtPriceNextX64,[g.sqrtPriceX64,w.amountIn,w.amountOut,w.feeAmount]=Wn.swapStepCompute(g.sqrtPriceX64,T,g.liquidity,g.amountSpecifiedRemaining,s,i),g.feeAmount=g.feeAmount.add(w.feeAmount),b?(g.amountSpecifiedRemaining=g.amountSpecifiedRemaining.sub(w.amountIn.add(w.feeAmount)),g.amountCalculated=g.amountCalculated.sub(w.amountOut)):(g.amountSpecifiedRemaining=g.amountSpecifiedRemaining.add(w.amountOut),g.amountCalculated=g.amountCalculated.add(w.amountIn.add(w.feeAmount))),g.sqrtPriceX64.eq(w.sqrtPriceNextX64)){if(w.initialized){let C=x.liquidityNet;i&&(C=C.mul(mn)),g.liquidity=Pe.addDelta(g.liquidity,C)}k=w.tickNext!=g.tick&&!i&&h.startTickIndex===w.tickNext,g.tick=i?w.tickNext-1:w.tickNext}else if(g.sqrtPriceX64!=w.sqrtPriceStartX64){let C=ie.getTickFromSqrtPriceX64(g.sqrtPriceX64);k=C!=g.tick&&!i&&h.startTickIndex===C,g.tick=C}++I}try{let{nextStartIndex:w,isExist:S}=ge.nextInitializedTickArray(g.tick,c,i,o,r);S&&p!==w&&(g.accounts.push(be(e,t,w).publicKey),p=w)}catch{}return{allTrade:!0,amountSpecifiedRemaining:Ve,amountCalculated:g.amountCalculated,feeAmount:g.feeAmount,sqrtPriceX64:g.sqrtPriceX64,liquidity:g.liquidity,tickCurrent:g.tick,accounts:g.accounts}}static swapStepCompute(e,t,n,o,r,i){let s={sqrtPriceX64Next:new le(0),amountIn:new le(0),amountOut:new le(0),feeAmount:new le(0)},u=o.gte(Ve);if(u){let c=ae.mulDivFloor(o,ur.sub(new le(r.toString())),ur);s.amountIn=i?Pe.getTokenAmountAFromLiquidity(t,e,n,!0):Pe.getTokenAmountBFromLiquidity(e,t,n,!0),c.gte(s.amountIn)?s.sqrtPriceX64Next=t:s.sqrtPriceX64Next=ie.getNextSqrtPriceX64FromInput(e,n,c,i)}else s.amountOut=i?Pe.getTokenAmountBFromLiquidity(t,e,n,!1):Pe.getTokenAmountAFromLiquidity(e,t,n,!1),o.mul(mn).gte(s.amountOut)?s.sqrtPriceX64Next=t:s.sqrtPriceX64Next=ie.getNextSqrtPriceX64FromOutput(e,n,o.mul(mn),i);let a=t.eq(s.sqrtPriceX64Next);return i?(a&&u||(s.amountIn=Pe.getTokenAmountAFromLiquidity(s.sqrtPriceX64Next,e,n,!0)),a&&!u||(s.amountOut=Pe.getTokenAmountBFromLiquidity(s.sqrtPriceX64Next,e,n,!1))):(s.amountIn=a&&u?s.amountIn:Pe.getTokenAmountBFromLiquidity(e,s.sqrtPriceX64Next,n,!0),s.amountOut=a&&!u?s.amountOut:Pe.getTokenAmountAFromLiquidity(e,s.sqrtPriceX64Next,n,!1)),!u&&s.amountOut.gt(o.mul(mn))&&(s.amountOut=o.mul(mn)),u&&!s.sqrtPriceX64Next.eq(t)?s.feeAmount=o.sub(s.amountIn):s.feeAmount=ae.mulDivCeil(s.amountIn,new le(r),ur.sub(new le(r))),[s.sqrtPriceX64Next,s.amountIn,s.amountOut,s.feeAmount]}};var He=60,Dn=512,Y=class{static getTickArrayAddressByTick(e,t,n,o){let r=Y.getTickArrayStartIndexByTick(n,o),{publicKey:i}=be(e,t,r);return i}static getTickOffsetInArray(e,t){if(e%t!=0)throw new Error("tickIndex % tickSpacing not equal 0");let n=Y.getTickArrayStartIndexByTick(e,t),o=Math.floor((e-n)/t);if(o<0||o>=He)throw new Error("tick offset in array overflow");return o}static getTickArrayBitIndex(e,t){let n=ge.tickCount(t),o=e/n;return e<0&&e%n!=0?o=Math.ceil(o)-1:o=Math.floor(o),o}static getTickArrayStartIndexByTick(e,t){return this.getTickArrayBitIndex(e,t)*ge.tickCount(t)}static getTickArrayOffsetInBitmapByTick(e,t){let n=t*He,o=Math.floor(e/n)+512;return Math.abs(o)}static checkTickArrayIsInitialized(e,t,n){let o=n*He,r=Math.floor(t/o)+512,i=Math.abs(r);return{isInitialized:e.testn(i),startIndex:(i-512)*o}}static getNextTickArrayStartIndex(e,t,n){return n?e-t*He:e+t*He}static mergeTickArrayBitmap(e){let t=new Ym(0);for(let n=0;n<e.length;n++)t=t.add(e[n].shln(64*n));return t}static getInitializedTickArrayInRange(e,t,n,o,r){let i=Math.floor(o/(n*He));return[...Y.searchLowBitFromStart(e,t,i-1,r,n),...Y.searchHightBitFromStart(e,t,i,r,n)]}static getAllInitializedTickArrayStartIndex(e,t,n){return Y.searchHightBitFromStart(e,t,-7680,Dn,n)}static getAllInitializedTickArrayInfo(e,t,n,o,r){let i=[],s=Y.getAllInitializedTickArrayStartIndex(n,o,r);for(let u of s){let{publicKey:a}=be(e,t,u);i.push({tickArrayStartIndex:u,tickArrayAddress:a})}return i}static getAllInitializedTickInTickArray(e){return e.ticks.filter(t=>t.liquidityGross.gtn(0))}static searchLowBitFromStart(e,t,n,o,r){let i=[...[...t.negativeTickArrayBitmap].reverse(),e.slice(0,8),e.slice(8,16),...t.positiveTickArrayBitmap].map(a=>Y.mergeTickArrayBitmap(a)),s=[];for(;n>=-7680;){let a=Math.floor((n+7680)/512),c=(n+7680)%512;if(i[a].testn(c)&&s.push(n),n--,s.length===o)break}let u=ge.tickCount(r);return s.map(a=>a*u)}static searchHightBitFromStart(e,t,n,o,r){let i=[...[...t.negativeTickArrayBitmap].reverse(),e.slice(0,8),e.slice(8,16),...t.positiveTickArrayBitmap].map(a=>Y.mergeTickArrayBitmap(a)),s=[];for(;n<7680;){let a=Math.floor((n+7680)/512),c=(n+7680)%512;if(i[a].testn(c)&&s.push(n),n++,s.length===o)break}let u=ge.tickCount(r);return s.map(a=>a*u)}static checkIsOutOfBoundary(e){return e<lt||e>ft}static nextInitTick(e,t,n,o,r){if(ge.getArrayStartIndex(t,n)!=e.startTickIndex)return null;let s=Math.floor((t-e.startTickIndex)/n);if(o)for(;s>=0;){if(e.ticks[s].liquidityGross.gtn(0))return e.ticks[s];s=s-1}else for(r||(s=s+1);s<He;){if(e.ticks[s].liquidityGross.gtn(0))return e.ticks[s];s=s+1}return null}static firstInitializedTick(e,t){if(t){let n=He-1;for(;n>=0;){if(e.ticks[n].liquidityGross.gtn(0))return e.ticks[n];n=n-1}}else{let n=0;for(;n<He;){if(e.ticks[n].liquidityGross.gtn(0))return e.ticks[n];n=n+1}}throw Error(`firstInitializedTick check error: ${e} - ${t}`)}static _getTickPriceLegacy({poolInfo:e,tick:t,baseIn:n}){let o=ie.getSqrtPriceX64FromTick(t),r=ie.sqrtPriceX64ToPrice(o,e.mintA.decimals,e.mintB.decimals);return n?{tick:t,price:r,tickSqrtPriceX64:o}:{tick:t,price:new bo(1).div(r),tickSqrtPriceX64:o}}static _getPriceAndTickLegacy({poolInfo:e,price:t,baseIn:n}){let o=n?t:new bo(1).div(t),r=Un.getTickWithPriceAndTickspacing(o,e.ammConfig.tickSpacing,e.mintA.decimals,e.mintB.decimals),i=ie.getSqrtPriceX64FromTick(r),s=ie.sqrtPriceX64ToPrice(i,e.mintA.decimals,e.mintB.decimals);return n?{tick:r,price:s}:{tick:r,price:new bo(1).div(s)}}static getTickPrice({poolInfo:e,tick:t,baseIn:n}){let o=ie.getSqrtPriceX64FromTick(t),r=ie.sqrtPriceX64ToPrice(o,e.mintA.decimals,e.mintB.decimals);return n?{tick:t,price:r,tickSqrtPriceX64:o}:{tick:t,price:new bo(1).div(r),tickSqrtPriceX64:o}}static getPriceAndTick({poolInfo:e,price:t,baseIn:n}){let o=n?t:new bo(1).div(t),r=Un.getTickWithPriceAndTickspacing(o,e.config.tickSpacing,e.mintA.decimals,e.mintB.decimals),i=ie.getSqrtPriceX64FromTick(r),s=ie.sqrtPriceX64ToPrice(i,e.mintA.decimals,e.mintB.decimals);return n?{tick:r,price:s}:{tick:r,price:new bo(1).div(s)}}};var Zu=_([he(8),D("bump"),Tt("index"),O(""),ct("protocolFeeRate"),ct("tradeFeeRate"),Tt("tickSpacing"),Q(A(),8,"")]),Hm=_([ct("blockTimestamp"),lo("tickCumulative"),Q(A(),4)]),$u=_([he(8),De("initialized"),A("recentEpoch"),Tt("observationIndex"),O("poolId"),Q(Hm,100,"observations"),Q(A(),4)]),Zm=_([D("rewardState"),A("openTime"),A("endTime"),A("lastUpdateTime"),te("emissionsPerSecondX64"),A("rewardTotalEmissioned"),A("rewardClaimed"),O("tokenMint"),O("tokenVault"),O("creator"),te("rewardGrowthGlobalX64")]),qn=_([he(8),D("bump"),O("ammConfig"),O("creator"),O("mintA"),O("mintB"),O("vaultA"),O("vaultB"),O("observationId"),D("mintDecimalsA"),D("mintDecimalsB"),Tt("tickSpacing"),te("liquidity"),te("sqrtPriceX64"),Me("tickCurrent"),ct(),te("feeGrowthGlobalX64A"),te("feeGrowthGlobalX64B"),A("protocolFeesTokenA"),A("protocolFeesTokenB"),te("swapInAmountTokenA"),te("swapOutAmountTokenB"),te("swapInAmountTokenB"),te("swapOutAmountTokenA"),D("status"),Q(D(),7,""),Q(Zm,3,"rewardInfos"),Q(A(),16,"tickArrayBitmap"),A("totalFeesTokenA"),A("totalFeesClaimedTokenA"),A("totalFeesTokenB"),A("totalFeesClaimedTokenB"),A("fundFeesTokenA"),A("fundFeesTokenB"),A("startTime"),Q(A(),15*4-3,"padding")]),$m=_([te("growthInsideLastX64"),A("rewardAmountOwed")]),yo=_([he(8),D("bump"),O("nftMint"),O("poolId"),Me("tickLower"),Me("tickUpper"),te("liquidity"),te("feeGrowthInsideLastX64A"),te("feeGrowthInsideLastX64B"),A("tokenFeesOwedA"),A("tokenFeesOwedB"),Q($m,3,"rewardInfos"),Q(A(),8,"")]),Yk=_([he(8),D("bump"),O("poolId"),Me("tickLowerIndex"),Me("tickUpperIndex"),te("liquidity"),te("feeGrowthInsideLastX64A"),te("feeGrowthInsideLastX64B"),A("tokenFeesOwedA"),A("tokenFeesOwedB"),Q(te(),3,"rewardGrowthInside"),Q(A(),8,"")]),Jm=_([Me("tick"),yu("liquidityNet"),te("liquidityGross"),te("feeGrowthOutsideX64A"),te("feeGrowthOutsideX64B"),Q(te(),3,"rewardGrowthsOutsideX64"),Q(ct(),13,"")]),ei=_([he(8),O("poolId"),Me("startTickIndex"),Q(Jm,He,"ticks"),D("initializedTickCount"),Q(D(),115,"")]),Ju=_([he(329),Q(O(),100,"whitelistMints")]),Hu=_([he(8),O("poolId"),Q(Q(A(),8),Ws,"positiveTickArrayBitmap"),Q(Q(A(),8),Ws,"negativeTickArrayBitmap")]),Hk=_([A(),D("bump"),O("owner"),O("poolId"),O("positionId"),O("nftAccount"),Q(A(),8)]),ec=_([he(8),D("bump"),O("lockOwner"),O("poolId"),O("positionId"),O("nftAccount"),O("lockNftMint"),A("recentEpoch"),Q(A(),8)]);$u.span;var tc=fe("Raydium_Clmm"),St={createPool:[233,146,209,142,207,104,64,188],initReward:[95,135,192,196,242,129,230,68],setRewardEmissions:[112,52,167,75,32,201,211,137],openPosition:[77,184,74,214,112,86,241,199],openPositionWithTokenEx:[77,255,174,82,125,29,201,46],closePosition:[123,134,81,0,49,68,98,98],increaseLiquidity:[133,29,89,223,69,238,176,10],decreaseLiquidity:[58,127,188,62,79,82,196,96],swap:[43,4,237,11,26,201,30,98],collectReward:[18,237,166,197,34,16,213,144]},nc=[188,37,179,131,82,150,84,73],oc=[16,72,250,198,14,162,212,19],Ke=class{static createPoolInstruction(e,t,n,o,r,i,s,u,a,c,l,d,p,f){let y=_([te("sqrtPriceX64"),A("zero")]),b=[{pubkey:n,isSigner:!0,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!1},{pubkey:a,isSigner:!1,isWritable:!1},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:d,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!1},{pubkey:l,isSigner:!1,isWritable:!1},{pubkey:fn.programId,isSigner:!1,isWritable:!1},{pubkey:ot,isSigner:!1,isWritable:!1},...(f==null?void 0:f.map(h=>({pubkey:h,isSigner:!1,isWritable:!1})))||[]],g=Buffer.alloc(y.span);y.encode({sqrtPriceX64:p,zero:Ve},g);let P=Buffer.from([...St.createPool,...g]);return new st({keys:b,programId:e,data:P})}static async createPoolInstructions(e){let{programId:t,owner:n,mintA:o,mintB:r,ammConfigId:i,initialPriceX64:s,extendMintAccount:u}=e,[a,c]=[new U(o.address),new U(r.address)],{publicKey:l}=Gu(t,i,a,c),{publicKey:d}=zu(t,l),{publicKey:p}=Fs(t,l,a),{publicKey:f}=Fs(t,l,c),y=Xe(t,l).publicKey,b=[this.createPoolInstruction(t,l,n,i,d,a,p,new U(o.programId||Se),c,f,new U(r.programId||Se),y,s,u)];return{signers:[],instructions:b,instructionTypes:[q.CreateAccount,q.ClmmCreatePool],address:{poolId:l,observationId:d,exBitmapAccount:y,mintAVault:p,mintBVault:f},lookupTableAddress:[]}}static openPositionFromLiquidityInstruction(e,t,n,o,r,i,s,u,a,c,l,d,p,f,y,b,g,P,h,I,k,w,S,x,K,T){let C=_([Me("tickLowerIndex"),Me("tickUpperIndex"),Me("tickArrayLowerStartIndex"),Me("tickArrayUpperStartIndex"),te("liquidity"),A("amountMaxA"),A("amountMaxB"),De("withMetadata"),D("optionBaseFlag"),De("baseFlag")]),M=[...T?[{pubkey:T,isSigner:!1,isWritable:!0}]:[]],v=[{pubkey:t,isSigner:!0,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!0,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:d,isSigner:!1,isWritable:!0},{pubkey:p,isSigner:!1,isWritable:!0},{pubkey:f,isSigner:!1,isWritable:!0},{pubkey:y,isSigner:!1,isWritable:!0},{pubkey:ot,isSigner:!1,isWritable:!1},{pubkey:fn.programId,isSigner:!1,isWritable:!1},{pubkey:Se,isSigner:!1,isWritable:!1},{pubkey:ni,isSigner:!1,isWritable:!1},{pubkey:Xt,isSigner:!1,isWritable:!1},{pubkey:We,isSigner:!1,isWritable:!1},{pubkey:b,isSigner:!1,isWritable:!1},{pubkey:g,isSigner:!1,isWritable:!1},...M],R=Buffer.alloc(C.span);C.encode({tickLowerIndex:P,tickUpperIndex:h,tickArrayLowerStartIndex:I,tickArrayUpperStartIndex:k,liquidity:w,amountMaxA:S,amountMaxB:x,withMetadata:K==="create",baseFlag:!1,optionBaseFlag:0},R);let L=Buffer.from([...St.openPosition,...R]);return new st({keys:v,programId:e,data:L})}static openPositionFromLiquidityInstruction22(e,t,n,o,r,i,s,u,a,c,l,d,p,f,y,b,g,P,h,I,k,w,S,x,K){let T=_([Me("tickLowerIndex"),Me("tickUpperIndex"),Me("tickArrayLowerStartIndex"),Me("tickArrayUpperStartIndex"),te("liquidity"),A("amountMaxA"),A("amountMaxB"),De("withMetadata"),D("optionBaseFlag"),De("baseFlag")]),C=[...K?[{pubkey:K,isSigner:!1,isWritable:!0}]:[]],M=[{pubkey:t,isSigner:!0,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!0,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:d,isSigner:!1,isWritable:!0},{pubkey:p,isSigner:!1,isWritable:!0},{pubkey:f,isSigner:!1,isWritable:!0},{pubkey:ot,isSigner:!1,isWritable:!1},{pubkey:fn.programId,isSigner:!1,isWritable:!1},{pubkey:Se,isSigner:!1,isWritable:!1},{pubkey:ni,isSigner:!1,isWritable:!1},{pubkey:We,isSigner:!1,isWritable:!1},{pubkey:y,isSigner:!1,isWritable:!1},{pubkey:b,isSigner:!1,isWritable:!1},...C],v=Buffer.alloc(T.span);T.encode({tickLowerIndex:g,tickUpperIndex:P,tickArrayLowerStartIndex:h,tickArrayUpperStartIndex:I,liquidity:k,amountMaxA:w,amountMaxB:S,withMetadata:x==="create",baseFlag:!1,optionBaseFlag:0},v);let R=Buffer.from([...St.openPositionWithTokenEx,...v]);return new st({keys:M,programId:e,data:R})}static async openPositionInstructions({poolInfo:e,poolKeys:t,ownerInfo:n,tickLower:o,tickUpper:r,liquidity:i,amountMaxA:s,amountMaxB:u,withMetadata:a,getEphemeralSigners:c,nft2022:l}){let d=[],[p,f]=[new U(e.programId),new U(e.id)],y;if(c)y=new U((await c(1))[0]);else{let K=lr.generate();d.push(K),y=K.publicKey}let b=Y.getTickArrayStartIndexByTick(o,e.config.tickSpacing),g=Y.getTickArrayStartIndexByTick(r,e.config.tickSpacing),{publicKey:P}=be(p,f,b),{publicKey:h}=be(p,f,g),{publicKey:I}=l?J(n.wallet,y,We):J(n.wallet,y,Se),{publicKey:k}=dn(y),{publicKey:w}=yt(p,y),{publicKey:S}=Zt(p,f,o,r),x=l?this.openPositionFromLiquidityInstruction22(p,n.feePayer,f,n.wallet,y,I,S,P,h,w,n.tokenAccountA,n.tokenAccountB,new U(t.vault.A),new U(t.vault.B),new U(e.mintA.address),new U(e.mintB.address),o,r,b,g,i,s,u,a,Le.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing,[b,g])?Xe(p,f).publicKey:void 0):this.openPositionFromLiquidityInstruction(p,n.feePayer,f,n.wallet,y,I,k,S,P,h,w,n.tokenAccountA,n.tokenAccountB,new U(t.vault.A),new U(t.vault.B),new U(e.mintA.address),new U(e.mintB.address),o,r,b,g,i,s,u,a,Le.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing,[b,g])?Xe(p,f).publicKey:void 0);return{signers:d,instructions:[x],instructionTypes:[q.ClmmOpenPosition],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[],address:{nftMint:y,tickArrayLower:P,tickArrayUpper:h,positionNftAccount:I,metadataAccount:k,personalPosition:w,protocolPosition:S}}}static async openPositionFromBaseInstructions({poolInfo:e,poolKeys:t,ownerInfo:n,tickLower:o,tickUpper:r,base:i,baseAmount:s,otherAmountMax:u,withMetadata:a,getEphemeralSigners:c,nft2022:l}){let d=[],[p,f]=[new U(e.programId),new U(e.id)],y;if(c)y=new U((await c(1))[0]);else{let K=lr.generate();d.push(K),y=K.publicKey}let b=Y.getTickArrayStartIndexByTick(o,e.config.tickSpacing),g=Y.getTickArrayStartIndexByTick(r,e.config.tickSpacing),{publicKey:P}=be(p,f,b),{publicKey:h}=be(p,f,g),{publicKey:I}=l?J(n.wallet,y,We):J(n.wallet,y,Se),{publicKey:k}=dn(y),{publicKey:w}=yt(p,y),{publicKey:S}=Zt(p,f,o,r),x=l?this.openPositionFromBaseInstruction22(p,n.feePayer,f,n.wallet,y,I,S,P,h,w,n.tokenAccountA,n.tokenAccountB,new U(t.vault.A),new U(t.vault.B),new U(e.mintA.address),new U(e.mintB.address),o,r,b,g,a,i,s,u,Le.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing,[b,g])?Xe(p,f).publicKey:void 0):this.openPositionFromBaseInstruction(p,n.feePayer,f,n.wallet,y,I,k,S,P,h,w,n.tokenAccountA,n.tokenAccountB,new U(t.vault.A),new U(t.vault.B),new U(e.mintA.address),new U(e.mintB.address),o,r,b,g,a,i,s,u,Le.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing,[b,g])?Xe(p,f).publicKey:void 0);return{address:{nftMint:y,tickArrayLower:P,tickArrayUpper:h,positionNftAccount:I,metadataAccount:k,personalPosition:w,protocolPosition:S},instructions:[x],signers:d,instructionTypes:[q.ClmmOpenPosition],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[]}}static openPositionFromBaseInstruction(e,t,n,o,r,i,s,u,a,c,l,d,p,f,y,b,g,P,h,I,k,w,S,x,K,T){let C=_([Me("tickLowerIndex"),Me("tickUpperIndex"),Me("tickArrayLowerStartIndex"),Me("tickArrayUpperStartIndex"),te("liquidity"),A("amountMaxA"),A("amountMaxB"),De("withMetadata"),D("optionBaseFlag"),De("baseFlag")]),M=[...T?[{pubkey:T,isSigner:!1,isWritable:!0}]:[]],v=[{pubkey:t,isSigner:!0,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!0,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:d,isSigner:!1,isWritable:!0},{pubkey:p,isSigner:!1,isWritable:!0},{pubkey:f,isSigner:!1,isWritable:!0},{pubkey:y,isSigner:!1,isWritable:!0},{pubkey:ot,isSigner:!1,isWritable:!1},{pubkey:fn.programId,isSigner:!1,isWritable:!1},{pubkey:Se,isSigner:!1,isWritable:!1},{pubkey:ni,isSigner:!1,isWritable:!1},{pubkey:Xt,isSigner:!1,isWritable:!1},{pubkey:We,isSigner:!1,isWritable:!1},{pubkey:b,isSigner:!1,isWritable:!1},{pubkey:g,isSigner:!1,isWritable:!1},...M],R=Buffer.alloc(C.span);C.encode({tickLowerIndex:P,tickUpperIndex:h,tickArrayLowerStartIndex:I,tickArrayUpperStartIndex:k,liquidity:new Gs(0),amountMaxA:S==="MintA"?x:K,amountMaxB:S==="MintA"?K:x,withMetadata:w==="create",baseFlag:S==="MintA",optionBaseFlag:1},R);let L=Buffer.from([...St.openPosition,...R]);return new st({keys:v,programId:e,data:L})}static openPositionFromBaseInstruction22(e,t,n,o,r,i,s,u,a,c,l,d,p,f,y,b,g,P,h,I,k,w,S,x,K){let T=_([Me("tickLowerIndex"),Me("tickUpperIndex"),Me("tickArrayLowerStartIndex"),Me("tickArrayUpperStartIndex"),te("liquidity"),A("amountMaxA"),A("amountMaxB"),De("withMetadata"),D("optionBaseFlag"),De("baseFlag")]),C=[...K?[{pubkey:K,isSigner:!1,isWritable:!0}]:[]],M=[{pubkey:t,isSigner:!0,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!0,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:d,isSigner:!1,isWritable:!0},{pubkey:p,isSigner:!1,isWritable:!0},{pubkey:f,isSigner:!1,isWritable:!0},{pubkey:ot,isSigner:!1,isWritable:!1},{pubkey:fn.programId,isSigner:!1,isWritable:!1},{pubkey:Se,isSigner:!1,isWritable:!1},{pubkey:ni,isSigner:!1,isWritable:!1},{pubkey:We,isSigner:!1,isWritable:!1},{pubkey:y,isSigner:!1,isWritable:!1},{pubkey:b,isSigner:!1,isWritable:!1},...C],v=Buffer.alloc(T.span);T.encode({tickLowerIndex:g,tickUpperIndex:P,tickArrayLowerStartIndex:h,tickArrayUpperStartIndex:I,liquidity:new Gs(0),amountMaxA:w==="MintA"?S:x,amountMaxB:w==="MintA"?x:S,withMetadata:k==="create",baseFlag:w==="MintA",optionBaseFlag:1},v);let R=Buffer.from([...St.openPositionWithTokenEx,...v]);return new st({keys:M,programId:e,data:R})}static async openPositionFromLiquidityInstructions({poolInfo:e,poolKeys:t,ownerInfo:n,tickLower:o,tickUpper:r,liquidity:i,amountMaxA:s,amountMaxB:u,withMetadata:a,getEphemeralSigners:c,nft2022:l}){let d,p=[];if(c)d=new U((await c(1))[0]);else{let K=lr.generate();p.push(K),d=K.publicKey}let[f,y]=[new U(e.programId),new U(e.id)],b=Y.getTickArrayStartIndexByTick(o,e.config.tickSpacing),g=Y.getTickArrayStartIndexByTick(r,e.config.tickSpacing),{publicKey:P}=be(f,y,b),{publicKey:h}=be(f,y,g),{publicKey:I}=l?J(n.wallet,d,We):J(n.wallet,d,Se),{publicKey:k}=dn(d),{publicKey:w}=yt(f,d),{publicKey:S}=Zt(f,y,o,r),x=l?this.openPositionFromLiquidityInstruction22(f,n.wallet,y,n.wallet,d,I,S,P,h,w,n.tokenAccountA,n.tokenAccountB,new U(t.vault.A),new U(t.vault.B),new U(t.mintA.address),new U(t.mintB.address),o,r,b,g,i,s,u,a,Le.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing,[b,g])?Xe(f,y).publicKey:void 0):this.openPositionFromLiquidityInstruction(f,n.wallet,y,n.wallet,d,I,k,S,P,h,w,n.tokenAccountA,n.tokenAccountB,new U(t.vault.A),new U(t.vault.B),new U(t.mintA.address),new U(t.mintB.address),o,r,b,g,i,s,u,a,Le.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing,[b,g])?Xe(f,y).publicKey:void 0);return{address:{nftMint:d,tickArrayLower:P,tickArrayUpper:h,positionNftAccount:I,metadataAccount:k,personalPosition:w,protocolPosition:S},instructions:[x],signers:p,instructionTypes:[q.ClmmOpenPosition],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[]}}static closePositionInstruction(e,t,n,o,r,i){let s=_([]),u=[{pubkey:t,isSigner:!0,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:fn.programId,isSigner:!1,isWritable:!1},{pubkey:i?We:Se,isSigner:!1,isWritable:!1}],a=Buffer.alloc(s.span);s.encode({},a);let c=Buffer.from([...St.closePosition,...a]);return new st({keys:u,programId:e,data:c})}static closePositionInstructions({poolInfo:e,poolKeys:t,ownerInfo:n,ownerPosition:o,nft2022:r}){let i=new U(e.programId),s=r?J(n.wallet,o.nftMint,We).publicKey:J(n.wallet,o.nftMint,Se).publicKey,{publicKey:u}=yt(i,o.nftMint),a=[];return a.push(this.closePositionInstruction(i,n.wallet,o.nftMint,s,u,r)),{address:{positionNftAccount:s,personalPosition:u},signers:[],instructions:a,instructionTypes:[q.ClmmClosePosition],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[]}}static increasePositionFromLiquidityInstruction(e,t,n,o,r,i,s,u,a,c,l,d,p,f,y,b,g,P){let h=_([te("liquidity"),A("amountMaxA"),A("amountMaxB"),D("optionBaseFlag"),De("baseFlag")]),I=[...P?[{pubkey:P,isSigner:!1,isWritable:!0}]:[]],k=[{pubkey:t,isSigner:!0,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:d,isSigner:!1,isWritable:!0},{pubkey:Se,isSigner:!1,isWritable:!1},{pubkey:We,isSigner:!1,isWritable:!1},{pubkey:p,isSigner:!1,isWritable:!1},{pubkey:f,isSigner:!1,isWritable:!1},...I],w=Buffer.alloc(h.span);h.encode({liquidity:y,amountMaxA:b,amountMaxB:g,optionBaseFlag:0,baseFlag:!1},w);let S=Buffer.from([...St.increaseLiquidity,...w]);return new st({keys:k,programId:e,data:S})}static increasePositionFromLiquidityInstructions({poolInfo:e,poolKeys:t,ownerPosition:n,ownerInfo:o,liquidity:r,amountMaxA:i,amountMaxB:s,nft2022:u}){let[a,c]=[new U(e.programId),new U(e.id)],l=Y.getTickArrayStartIndexByTick(n.tickLower,e.config.tickSpacing),d=Y.getTickArrayStartIndexByTick(n.tickUpper,e.config.tickSpacing),{publicKey:p}=be(a,c,l),{publicKey:f}=be(a,c,d),{publicKey:y}=u?J(o.wallet,n.nftMint,We):J(o.wallet,n.nftMint,Se),{publicKey:b}=yt(a,n.nftMint),{publicKey:g}=Zt(a,c,n.tickLower,n.tickUpper),P=this.increasePositionFromLiquidityInstruction(a,o.wallet,y,b,c,g,p,f,o.tokenAccountA,o.tokenAccountB,new U(t.vault.A),new U(t.vault.B),new U(e.mintA.address),new U(e.mintB.address),r,i,s,Le.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing,[l,d])?Xe(a,c).publicKey:void 0);return{address:{tickArrayLower:p,tickArrayUpper:f,positionNftAccount:y,personalPosition:b,protocolPosition:g},signers:[],instructions:[P],instructionTypes:[q.ClmmIncreasePosition],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[]}}static increasePositionFromBaseInstructions({poolInfo:e,poolKeys:t,ownerPosition:n,ownerInfo:o,base:r,baseAmount:i,otherAmountMax:s,nft2022:u}){let[a,c]=[new U(e.programId),new U(e.id)],l=Y.getTickArrayStartIndexByTick(n.tickLower,e.config.tickSpacing),d=Y.getTickArrayStartIndexByTick(n.tickUpper,e.config.tickSpacing),{publicKey:p}=be(a,c,l),{publicKey:f}=be(a,c,d),{publicKey:y}=u?J(o.wallet,n.nftMint,We):J(o.wallet,n.nftMint,Se),{publicKey:b}=yt(a,n.nftMint),{publicKey:g}=Zt(a,c,n.tickLower,n.tickUpper);return{address:{tickArrayLower:p,tickArrayUpper:f,positionNftAccount:y,personalPosition:b,protocolPosition:g},instructions:[this.increasePositionFromBaseInstruction(a,o.wallet,y,b,c,g,p,f,o.tokenAccountA,o.tokenAccountB,new U(t.vault.A),new U(t.vault.B),new U(e.mintA.address),new U(e.mintB.address),r,i,s,Le.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing,[l,d])?Xe(a,c).publicKey:void 0)],signers:[],instructionTypes:[q.ClmmIncreasePosition],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[]}}static increasePositionFromBaseInstruction(e,t,n,o,r,i,s,u,a,c,l,d,p,f,y,b,g,P){let h=_([te("liquidity"),A("amountMaxA"),A("amountMaxB"),D("optionBaseFlag"),De("baseFlag")]),I=[...P?[{pubkey:P,isSigner:!1,isWritable:!0}]:[]],k=[{pubkey:t,isSigner:!0,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:d,isSigner:!1,isWritable:!0},{pubkey:Se,isSigner:!1,isWritable:!1},{pubkey:We,isSigner:!1,isWritable:!1},{pubkey:p,isSigner:!1,isWritable:!1},{pubkey:f,isSigner:!1,isWritable:!1},...I],w=Buffer.alloc(h.span);h.encode({liquidity:new Gs(0),amountMaxA:y==="MintA"?b:g,amountMaxB:y==="MintA"?g:b,baseFlag:y==="MintA",optionBaseFlag:1},w);let S=Buffer.from([...St.increaseLiquidity,...w]);return new st({keys:k,programId:e,data:S})}static decreaseLiquidityInstruction(e,t,n,o,r,i,s,u,a,c,l,d,p,f,y,b,g,P,h){let I=_([te("liquidity"),A("amountMinA"),A("amountMinB")]),k=[...h?[{pubkey:h,isSigner:!1,isWritable:!0}]:[],...y.map(K=>[{pubkey:K.poolRewardVault,isSigner:!1,isWritable:!0},{pubkey:K.ownerRewardVault,isSigner:!1,isWritable:!0},{pubkey:K.rewardMint,isSigner:!1,isWritable:!1}]).flat()],w=[{pubkey:t,isSigner:!0,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:d,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:Se,isSigner:!1,isWritable:!1},{pubkey:We,isSigner:!1,isWritable:!1},{pubkey:Ni,isSigner:!1,isWritable:!1},{pubkey:p,isSigner:!1,isWritable:!1},{pubkey:f,isSigner:!1,isWritable:!1},...k],S=Buffer.alloc(I.span);I.encode({liquidity:b,amountMinA:g,amountMinB:P},S);let x=Buffer.from([...St.decreaseLiquidity,...S]);return new st({keys:w,programId:e,data:x})}static decreaseLiquidityInstructions({poolInfo:e,poolKeys:t,ownerPosition:n,ownerInfo:o,liquidity:r,amountMinA:i,amountMinB:s,programId:u,nft2022:a}){let[c,l]=[new U(e.programId),new U(e.id)],d=Y.getTickArrayStartIndexByTick(n.tickLower,e.config.tickSpacing),p=Y.getTickArrayStartIndexByTick(n.tickUpper,e.config.tickSpacing),{publicKey:f}=be(c,l,d),{publicKey:y}=be(c,l,p),{publicKey:b}=a?J(o.wallet,n.nftMint,We):J(o.wallet,n.nftMint,u),{publicKey:g}=yt(c,n.nftMint),{publicKey:P}=Zt(c,l,n.tickLower,n.tickUpper),h=[];for(let w=0;w<e.rewardDefaultInfos.length;w++)h.push({poolRewardVault:new U(t.rewardInfos[w].vault),ownerRewardVault:o.rewardAccounts[w],rewardMint:new U(e.rewardDefaultInfos[w].mint.address)});let I=[],k=this.decreaseLiquidityInstruction(c,o.wallet,b,g,l,P,f,y,o.tokenAccountA,o.tokenAccountB,new U(t.vault.A),new U(t.vault.B),new U(e.mintA.address),new U(e.mintB.address),h,r,i,s,Le.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing,[d,p])?Xe(c,l).publicKey:void 0);return I.push(k),{address:{tickArrayLower:f,tickArrayUpper:y,positionNftAccount:b,personalPosition:g,protocolPosition:P},signers:[],instructions:I,instructionTypes:[q.ClmmDecreasePosition],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[]}}static swapInstruction(e,t,n,o,r,i,s,u,a,c,l,d,p,f,y,b,g){let P=_([A("amount"),A("otherAmountThreshold"),te("sqrtPriceLimitX64"),De("isBaseInput")]),h=[...g?[{pubkey:g,isSigner:!1,isWritable:!0}]:[],...l.map(S=>({pubkey:S,isSigner:!1,isWritable:!0}))],I=[{pubkey:t,isSigner:!0,isWritable:!1},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:d,isSigner:!1,isWritable:!0},{pubkey:Se,isSigner:!1,isWritable:!1},{pubkey:We,isSigner:!1,isWritable:!1},{pubkey:Ni,isSigner:!1,isWritable:!1},{pubkey:a,isSigner:!1,isWritable:!1},{pubkey:c,isSigner:!1,isWritable:!1},...h],k=Buffer.alloc(P.span);P.encode({amount:p,otherAmountThreshold:f,sqrtPriceLimitX64:y,isBaseInput:b},k);let w=Buffer.from([...St.swap,...k]);return new st({keys:I,programId:e,data:w})}static makeSwapBaseInInstructions({poolInfo:e,poolKeys:t,observationId:n,ownerInfo:o,inputMint:r,amountIn:i,amountOutMin:s,sqrtPriceLimitX64:u,remainingAccounts:a}){let[c,l]=[new U(e.programId),new U(e.id)],[d,p]=[new U(t.vault.A),new U(t.vault.B)],[f,y]=[new U(e.mintA.address),new U(e.mintB.address)],b=e.mintA.address===r.toString(),g=[this.swapInstruction(c,o.wallet,l,new U(e.config.id),b?o.tokenAccountA:o.tokenAccountB,b?o.tokenAccountB:o.tokenAccountA,b?d:p,b?p:d,b?f:y,b?y:f,a,n,i,s,u,!0,Xe(c,l).publicKey)];return{signers:[],instructions:g,instructionTypes:[q.ClmmSwapBaseIn],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[],address:{}}}static makeSwapBaseOutInstructions({poolInfo:e,poolKeys:t,observationId:n,ownerInfo:o,outputMint:r,amountOut:i,amountInMax:s,sqrtPriceLimitX64:u,remainingAccounts:a}){let[c,l]=[new U(e.programId),new U(e.id)],[d,p]=[new U(t.vault.A),new U(t.vault.B)],[f,y]=[new U(e.mintA.address),new U(e.mintB.address)],b=e.mintA.address===r.toBase58(),g=[this.swapInstruction(c,o.wallet,l,new U(e.config.id),b?o.tokenAccountB:o.tokenAccountA,b?o.tokenAccountA:o.tokenAccountB,b?p:d,b?d:p,b?y:f,b?f:y,a,n,i,s,u,!1,Xe(c,l).publicKey)];return{signers:[],instructions:g,instructionTypes:[q.ClmmSwapBaseOut],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[],address:{}}}static initRewardInstruction(e,t,n,o,r,i,s,u,a,c,l,d){let p=_([A("openTime"),A("endTime"),te("emissionsPerSecondX64")]),f=[{pubkey:t,isSigner:!0,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!1},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!1},{pubkey:fn.programId,isSigner:!1,isWritable:!1},{pubkey:ot,isSigner:!1,isWritable:!1}],y=Buffer.alloc(p.span);p.encode({openTime:$(c),endTime:$(l),emissionsPerSecondX64:d},y);let b=Buffer.from([...St.initReward,...y]);return new st({keys:f,programId:e,data:b})}static initRewardInstructions({poolInfo:e,poolKeys:t,ownerInfo:n,rewardInfo:o}){let[r,i]=[new U(e.programId),new U(e.id)],s=Xu(r,i,o.mint).publicKey,u=$o(r).publicKey,a=[this.initRewardInstruction(r,n.wallet,i,u,new U(e.config.id),n.tokenAccount,o.programId,o.mint,s,o.openTime,o.endTime,o.emissionsPerSecondX64)];return{address:{poolRewardVault:s,operationId:u},signers:[],instructions:a,instructionTypes:[q.ClmmInitReward],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[]}}static setRewardInstruction(e,t,n,o,r,i,s,u,a,c,l,d){let p=_([D("rewardIndex"),te("emissionsPerSecondX64"),A("openTime"),A("endTime")]),f=[{pubkey:t,isSigner:!0,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:Se,isSigner:!1,isWritable:!1},{pubkey:We,isSigner:!1,isWritable:!1},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0}],y=Buffer.alloc(p.span);p.encode({rewardIndex:a,emissionsPerSecondX64:d,openTime:$(c),endTime:$(l)},y);let b=Buffer.from([...St.setRewardEmissions,...y]);return new st({keys:f,programId:e,data:b})}static setRewardInstructions({poolInfo:e,poolKeys:t,ownerInfo:n,rewardInfo:o}){let[r,i]=[new U(e.programId),new U(e.id)],s,u,a;for(let d=0;d<e.rewardDefaultInfos.length;d++)e.rewardDefaultInfos[d].mint.address===o.mint.toString()&&(s=d,u=new U(t.rewardInfos[d].vault),a=new U(t.rewardInfos[d].mint.address));(s===void 0||u===void 0)&&tc.logWithError("reward mint check error","no reward mint",e.rewardDefaultInfos);let c=$o(r).publicKey,l=[this.setRewardInstruction(r,n.wallet,i,c,new U(e.config.id),n.tokenAccount,u,a,s,o.openTime,o.endTime,o.emissionsPerSecondX64)];return{address:{rewardVault:u,operationId:c},signers:[],instructions:l,instructionTypes:[q.ClmmSetReward],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[]}}static collectRewardInstruction(e,t,n,o,r,i,s){let u=_([D("rewardIndex")]),a=[{pubkey:t,isSigner:!0,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!1},{pubkey:Se,isSigner:!1,isWritable:!1},{pubkey:We,isSigner:!1,isWritable:!1},{pubkey:Ni,isSigner:!1,isWritable:!1}],c=Buffer.alloc(u.span);u.encode({rewardIndex:s},c);let l=Buffer.from([...St.collectReward,...c]);return new st({keys:a,programId:e,data:l})}static collectRewardInstructions({poolInfo:e,poolKeys:t,ownerInfo:n,rewardMint:o}){let[r,i]=[new U(e.programId),new U(e.id)],s,u;for(let c=0;c<e.rewardDefaultInfos.length;c++)e.rewardDefaultInfos[c].mint.address===o.toString()&&(s=c,u=new U(t.rewardInfos[c].vault));(s===void 0||u===void 0)&&tc.logWithError("reward mint check error","no reward mint",e.rewardDefaultInfos);let a=[this.collectRewardInstruction(r,n.wallet,i,n.tokenAccount,u,o,s)];return{address:{rewardVault:u},signers:[],instructions:a,instructionTypes:[q.ClmmCollectReward],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[]}}static async makeLockPositions({programId:e,authProgramId:t,poolProgramId:n,payer:o,wallet:r,nftMint:i,nft2022:s,getEphemeralSigners:u}){let a=[],c;if(u)c=new U((await u(1))[0]);else{let g=lr.generate();a.push(g),c=g.publicKey}let l=s?J(r,i,We).publicKey:J(r,i,Se).publicKey,{publicKey:d}=yt(n,i),p=fo(e,c).publicKey,f=J(r,c,Se).publicKey,y=dn(c).publicKey,b=Ke.lockPositionInstructionV2({programId:e,auth:t,payer:o,positionOwner:r,lockOwner:r,positionNftAccount:l,positionId:d,lockPositionId:p,lockNftMint:c,lockNftAccount:f,metadataAccount:y,withMetadata:!0,nft2022:s,positionNftMint:i,authPositionNftAccount:J(t,i,s?We:Se).publicKey,positionNftProgram:s?We:Se});return{address:{positionId:d,lockPositionId:p,lockNftAccount:f,lockNftMint:c,positionNftAccount:l,metadataAccount:y},instructions:[b],signers:a,instructionTypes:[q.ClmmLockPosition],lookupTableAddress:[]}}static lockPositionInstructionV2({programId:e,auth:t,payer:n,positionOwner:o,lockOwner:r,positionNftAccount:i,positionId:s,positionNftMint:u,authPositionNftAccount:a,positionNftProgram:c,lockPositionId:l,lockNftMint:d,lockNftAccount:p,metadataAccount:f,withMetadata:y}){let b=[{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!0,isWritable:!0},{pubkey:o,isSigner:!0,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!1},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!1},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:d,isSigner:!0,isWritable:!0},{pubkey:p,isSigner:!1,isWritable:!0},{pubkey:f,isSigner:!1,isWritable:!0},{pubkey:Xt,isSigner:!1,isWritable:!1},{pubkey:ni,isSigner:!1,isWritable:!1},{pubkey:ot,isSigner:!1,isWritable:!1},{pubkey:Se,isSigner:!1,isWritable:!1},{pubkey:c,isSigner:!1,isWritable:!1},{pubkey:fn.programId,isSigner:!1,isWritable:!1}],g=_([De("withMetadata")]),P=Buffer.alloc(g.span);g.encode({withMetadata:y},P);let h=Buffer.from([...nc,...P]);return new st({keys:b,programId:e,data:h})}static lockPositionInstruction({programId:e,authProgramId:t,poolProgramId:n,owner:o,positionNft:r}){let{publicKey:i}=J(o,r,Se),{publicKey:s}=yt(n,r),u=[{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!0,isWritable:!1},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!1},{pubkey:Vs(e,s).publicKey,isSigner:!1,isWritable:!0},{pubkey:Se,isSigner:!1,isWritable:!1},{pubkey:fn.programId,isSigner:!1,isWritable:!1}];return new st({keys:u,programId:e,data:Buffer.from(nc)})}static harvestLockPositionInstruction(e){let[t,n]=[new U(e.poolKeys.programId),new U(e.poolKeys.id)],o=Y.getTickArrayStartIndexByTick(e.ownerPosition.tickLower,e.poolKeys.config.tickSpacing),r=Y.getTickArrayStartIndexByTick(e.ownerPosition.tickUpper,e.poolKeys.config.tickSpacing),{publicKey:i}=be(t,n,o),{publicKey:s}=be(t,n,r),{publicKey:u}=J(e.owner,e.ownerPosition.nftMint,Se),{publicKey:a}=yt(t,e.ownerPosition.nftMint),{publicKey:c}=Zt(t,n,e.ownerPosition.tickLower,e.ownerPosition.tickUpper),l=[];for(let f=0;f<e.poolKeys.rewardInfos.length;f++)l.push({poolRewardVault:new U(e.poolKeys.rewardInfos[f].vault),ownerRewardVault:e.ownerRewardAccounts[f],rewardMint:new U(e.poolKeys.rewardInfos[f].mint.address)});let d=[...l.map(f=>[{pubkey:f.poolRewardVault,isSigner:!1,isWritable:!0},{pubkey:f.ownerRewardVault,isSigner:!1,isWritable:!0},{pubkey:f.rewardMint,isSigner:!1,isWritable:!1}]).flat()],p=[{pubkey:e.authProgramId,isSigner:!1,isWritable:!1},{pubkey:Vs(e.programId,a).publicKey,isSigner:!1,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:e.owner,isSigner:!0,isWritable:!1},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:new U(e.poolKeys.vault.A),isSigner:!1,isWritable:!0},{pubkey:new U(e.poolKeys.vault.B),isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:e.userVaultA,isSigner:!1,isWritable:!0},{pubkey:e.userVaultB,isSigner:!1,isWritable:!0},{pubkey:Se,isSigner:!1,isWritable:!1},{pubkey:We,isSigner:!1,isWritable:!1},{pubkey:Pn,isSigner:!1,isWritable:!1},{pubkey:new U(e.poolKeys.mintA.address),isSigner:!1,isWritable:!1},{pubkey:new U(e.poolKeys.mintB.address),isSigner:!1,isWritable:!1},...d];return new st({keys:p,programId:e.programId,data:Buffer.from(oc)})}static harvestLockPositionInstructionV2({programId:e,auth:t,lockPositionId:n,clmmProgram:o,lockOwner:r,lockNftMint:i,lockNftAccount:s,positionNftAccount:u,positionId:a,poolId:c,protocolPosition:l,vaultA:d,vaultB:p,tickArrayLower:f,tickArrayUpper:y,userVaultA:b,userVaultB:g,mintA:P,mintB:h,rewardAccounts:I,exTickArrayBitmap:k}){let w=[...k?[{pubkey:k,isSigner:!1,isWritable:!0}]:[],...I.map(x=>[{pubkey:x.poolRewardVault,isSigner:!1,isWritable:!0},{pubkey:x.ownerRewardVault,isSigner:!1,isWritable:!0},{pubkey:x.rewardMint,isSigner:!1,isWritable:!1}]).flat()],S=[{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!0,isWritable:!1},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:d,isSigner:!1,isWritable:!0},{pubkey:p,isSigner:!1,isWritable:!0},{pubkey:f,isSigner:!1,isWritable:!0},{pubkey:y,isSigner:!1,isWritable:!0},{pubkey:b,isSigner:!1,isWritable:!0},{pubkey:g,isSigner:!1,isWritable:!0},{pubkey:Se,isSigner:!1,isWritable:!1},{pubkey:We,isSigner:!1,isWritable:!1},{pubkey:Pn,isSigner:!1,isWritable:!1},{pubkey:P,isSigner:!1,isWritable:!1},{pubkey:h,isSigner:!1,isWritable:!1},...w];return new st({keys:S,programId:e,data:Buffer.from(oc)})}};var ed=_([ct("mintAuthorityOption"),O("mintAuthority"),A("supply"),D("decimals"),D("isInitialized"),ct("freezeAuthorityOption"),O("freezeAuthority")]);import{PublicKey as gh}from"@solana/web3.js";import{MintLayout as Ph,TOKEN_PROGRAM_ID as kh}from"@solana/spl-token";var mr=m=>new Fe({mint:m.address,decimals:m.decimals,symbol:m.symbol,name:m.name}),oi=o=>{var r=o,{amount:m,isRaw:e,name:t}=r,n=Ee(r,["amount","isRaw","name"]);return new Be(new Fe({mint:at(n.address).toBase58(),decimals:n.decimals,symbol:n.symbol,name:t}),m,e,t)};var mt=o=>{var r=o,{address:m,programId:e,decimals:t}=r,n=Ee(r,["address","programId","decimals"]);return N({chainId:101,address:at(m).toBase58(),programId:e,logoURI:"",symbol:"",name:"",decimals:t,tags:[],extensions:n.extensions||{}},n)},Bn=m=>m?W(N({},m),{transferFeeConfigAuthority:m.transferFeeConfigAuthority.toBase58(),withdrawWithheldAuthority:m.withdrawWithheldAuthority.toBase58(),withheldAmount:m.withheldAmount.toString(),olderTransferFee:W(N({},m.olderTransferFee),{epoch:m.olderTransferFee.epoch.toString(),maximumFee:m.olderTransferFee.maximumFee.toString()}),newerTransferFee:W(N({},m.newerTransferFee),{epoch:m.newerTransferFee.epoch.toString(),maximumFee:m.newerTransferFee.maximumFee.toString()})}):void 0;import ic from"bn.js";var Xs=new ic(25),dr=new ic(1e4);import{PublicKey as rn,SystemProgram as nd,SYSVAR_RENT_PUBKEY as Dh,TransactionInstruction as go}from"@solana/web3.js";import{ASSOCIATED_TOKEN_PROGRAM_ID as od,TOKEN_PROGRAM_ID as ri}from"@solana/spl-token";var zs=_([D("instruction"),A("amountIn"),A("minAmountOut")]),Qs=_([D("instruction"),A("maxAmountIn"),A("amountOut")]),_h=_([D("instruction"),D("nonce")]),td=_([D("instruction"),D("nonce"),A("startTime")]),ii=_([A("status"),A("nonce"),A("maxOrder"),A("depth"),A("baseDecimal"),A("quoteDecimal"),A("state"),A("resetFlag"),A("minSize"),A("volMaxCutRatio"),A("amountWaveRatio"),A("baseLotSize"),A("quoteLotSize"),A("minPriceMultiplier"),A("maxPriceMultiplier"),A("systemDecimalValue"),A("minSeparateNumerator"),A("minSeparateDenominator"),A("tradeFeeNumerator"),A("tradeFeeDenominator"),A("pnlNumerator"),A("pnlDenominator"),A("swapFeeNumerator"),A("swapFeeDenominator"),A("baseNeedTakePnl"),A("quoteNeedTakePnl"),A("quoteTotalPnl"),A("baseTotalPnl"),A("poolOpenTime"),A("punishPcAmount"),A("punishCoinAmount"),A("orderbookToInitTime"),te("swapBaseInAmount"),te("swapQuoteOutAmount"),A("swapBase2QuoteFee"),te("swapQuoteInAmount"),te("swapBaseOutAmount"),A("swapQuote2BaseFee"),O("baseVault"),O("quoteVault"),O("baseMint"),O("quoteMint"),O("lpMint"),O("openOrders"),O("marketId"),O("marketProgramId"),O("targetOrders"),O("withdrawQueue"),O("lpVault"),O("owner"),A("lpReserve"),Q(A(),3,"padding")]),Fh=_([A("accountType"),A("status"),A("nonce"),A("maxOrder"),A("depth"),A("baseDecimal"),A("quoteDecimal"),A("state"),A("resetFlag"),A("minSize"),A("volMaxCutRatio"),A("amountWaveRatio"),A("baseLotSize"),A("quoteLotSize"),A("minPriceMultiplier"),A("maxPriceMultiplier"),A("systemDecimalsValue"),A("abortTradeFactor"),A("priceTickMultiplier"),A("priceTick"),A("minSeparateNumerator"),A("minSeparateDenominator"),A("tradeFeeNumerator"),A("tradeFeeDenominator"),A("pnlNumerator"),A("pnlDenominator"),A("swapFeeNumerator"),A("swapFeeDenominator"),A("baseNeedTakePnl"),A("quoteNeedTakePnl"),A("quoteTotalPnl"),A("baseTotalPnl"),A("poolOpenTime"),A("punishPcAmount"),A("punishCoinAmount"),A("orderbookToInitTime"),te("swapBaseInAmount"),te("swapQuoteOutAmount"),te("swapQuoteInAmount"),te("swapBaseOutAmount"),A("swapQuote2BaseFee"),A("swapBase2QuoteFee"),O("baseVault"),O("quoteVault"),O("baseMint"),O("quoteMint"),O("lpMint"),O("modelDataAccount"),O("openOrders"),O("marketId"),O("marketProgramId"),O("targetOrders"),O("owner"),Q(A(),64,"padding")]),js=_([D("instruction"),A("baseAmountIn"),A("quoteAmountIn"),A("fixedSide"),A("otherAmountMin")]),Ys=_([D("instruction"),A("lpAmount"),A("baseAmountMin"),A("quoteAmountMin")]);var rc=_([A("fee")]);var sc=fe("Raydium_liquidity_instruction");function ac(m){let{poolInfo:e,poolKeys:t,userKeys:n,baseAmountIn:o,quoteAmountIn:r,fixedSide:i,otherAmountMin:s,modelDataPubKey:u=vn}=m,a=Buffer.alloc(js.span);js.encode({instruction:3,baseAmountIn:$(o),quoteAmountIn:$(r),otherAmountMin:$(s),fixedSide:i==="base"?Pt:Ea},a);let c=[B({pubkey:ri,isWritable:!1}),B({pubkey:new rn(e.id)}),B({pubkey:new rn(t.authority),isWritable:!1}),B({pubkey:new rn(t.openOrders),isWritable:!1}),B({pubkey:new rn(t.targetOrders)}),B({pubkey:new rn(e.lpMint.address)}),B({pubkey:new rn(t.vault.A)}),B({pubkey:new rn(t.vault.B)})];return e.pooltype.includes("StablePool")&&c.push(B({pubkey:u})),c.push(B({pubkey:new rn(e.marketId),isWritable:!1}),B({pubkey:n.baseTokenAccount}),B({pubkey:n.quoteTokenAccount}),B({pubkey:n.lpTokenAccount}),B({pubkey:n.owner,isWritable:!1,isSigner:!0}),B({pubkey:new rn(t.marketEventQueue),isWritable:!1})),new go({programId:new rn(e.programId),keys:c,data:a})}function Hs(m){let{poolInfo:e,poolKeys:t,userKeys:n,lpAmount:o,baseAmountMin:r,quoteAmountMin:i,modelDataPubKey:s=vn}=m,u=it(t),a=4;if(e.pooltype.includes("StablePool")&&(a=5),a===4||a===5){let c=Buffer.alloc(Ys.span);Ys.encode({instruction:4,lpAmount:$(o),baseAmountMin:$(r),quoteAmountMin:$(i)},c);let l=[B({pubkey:ri,isWritable:!1}),B({pubkey:u.id}),B({pubkey:u.authority,isWritable:!1}),B({pubkey:u.openOrders}),B({pubkey:u.targetOrders}),B({pubkey:u.mintLp.address}),B({pubkey:u.vault.A}),B({pubkey:u.vault.B})];return a===5?l.push(B({pubkey:s})):(l.push(B({pubkey:u.id})),l.push(B({pubkey:u.id}))),l.push(B({pubkey:u.marketProgramId,isWritable:!1}),B({pubkey:u.marketId}),B({pubkey:u.marketBaseVault}),B({pubkey:u.marketQuoteVault}),B({pubkey:u.marketAuthority,isWritable:!1}),B({pubkey:n.lpTokenAccount}),B({pubkey:n.baseTokenAccount}),B({pubkey:n.quoteTokenAccount}),B({pubkey:n.owner,isWritable:!1,isSigner:!0}),B({pubkey:u.marketEventQueue}),B({pubkey:u.marketBids}),B({pubkey:u.marketAsks})),new go({programId:u.programId,keys:l,data:c})}return new go({programId:u.programId,keys:[]})}function Zs({programId:m,ammId:e,ammAuthority:t,ammOpenOrders:n,lpMint:o,coinMint:r,pcMint:i,coinVault:s,pcVault:u,withdrawQueue:a,ammTargetOrders:c,poolTempLp:l,marketProgramId:d,marketId:p,userWallet:f,userCoinVault:y,userPcVault:b,userLpVault:g,nonce:P,openTime:h,coinAmount:I,pcAmount:k,ammConfigId:w,feeDestinationId:S}){let x=_([D("instruction"),D("nonce"),A("openTime"),A("pcAmount"),A("coinAmount")]),K=[{pubkey:ri,isSigner:!1,isWritable:!1},{pubkey:od,isSigner:!1,isWritable:!1},{pubkey:nd.programId,isSigner:!1,isWritable:!1},{pubkey:ot,isSigner:!1,isWritable:!1},{pubkey:e,isSigner:!1,isWritable:!0},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!1},{pubkey:i,isSigner:!1,isWritable:!1},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:w,isSigner:!1,isWritable:!1},{pubkey:S,isSigner:!1,isWritable:!0},{pubkey:d,isSigner:!1,isWritable:!1},{pubkey:p,isSigner:!1,isWritable:!1},{pubkey:f,isSigner:!0,isWritable:!0},{pubkey:y,isSigner:!1,isWritable:!0},{pubkey:b,isSigner:!1,isWritable:!0},{pubkey:g,isSigner:!1,isWritable:!0}],T=Buffer.alloc(x.span);return x.encode({instruction:1,nonce:P,openTime:h,coinAmount:I,pcAmount:k},T),{instruction:new go({keys:K,programId:m,data:T}),instructionType:q.AmmV4CreatePool}}function id({poolKeys:m,userKeys:e,amountIn:t,minAmountOut:n,modelDataPubKey:o=vn},r){let i=it(m),s=Buffer.alloc(zs.span);zs.encode({instruction:9,amountIn:$(t),minAmountOut:$(n)},s);let u=[B({pubkey:ri,isWritable:!1}),B({pubkey:i.id}),B({pubkey:i.authority,isWritable:!1}),B({pubkey:i.openOrders})];return r===4&&u.push(B({pubkey:i.targetOrders})),u.push(B({pubkey:i.vault.A}),B({pubkey:i.vault.B})),r===5&&u.push(B({pubkey:o})),u.push(B({pubkey:i.marketProgramId,isWritable:!1}),B({pubkey:i.marketId}),B({pubkey:i.marketBids}),B({pubkey:i.marketAsks}),B({pubkey:i.marketEventQueue}),B({pubkey:i.marketBaseVault}),B({pubkey:i.marketQuoteVault}),B({pubkey:i.marketAuthority,isWritable:!1}),B({pubkey:e.tokenAccountIn}),B({pubkey:e.tokenAccountOut}),B({pubkey:e.owner,isWritable:!1,isSigner:!0})),new go({programId:i.programId,keys:u,data:s})}function rd({poolKeys:m,userKeys:e,maxAmountIn:t,amountOut:n,modelDataPubKey:o=vn},r){let i=it(m),s=Buffer.alloc(Qs.span);Qs.encode({instruction:11,maxAmountIn:$(t),amountOut:$(n)},s);let u=[B({pubkey:ri,isWritable:!1}),B({pubkey:i.id}),B({pubkey:i.authority,isWritable:!1}),B({pubkey:i.openOrders}),B({pubkey:i.targetOrders}),B({pubkey:i.vault.A}),B({pubkey:i.vault.B})];return r===5&&u.push(B({pubkey:o})),u.push(B({pubkey:i.marketProgramId,isWritable:!1}),B({pubkey:i.marketId}),B({pubkey:i.marketBids}),B({pubkey:i.marketAsks}),B({pubkey:i.marketEventQueue}),B({pubkey:i.marketBaseVault}),B({pubkey:i.marketQuoteVault}),B({pubkey:i.marketAuthority,isWritable:!1}),B({pubkey:e.tokenAccountIn}),B({pubkey:e.tokenAccountOut}),B({pubkey:e.owner,isWritable:!1,isSigner:!0})),new go({programId:i.programId,keys:u,data:s})}function pr(m){let{poolKeys:e,version:t,userKeys:n,amountIn:o,amountOut:r,fixedSide:i}=m;if(t===4||t===5){let s={poolKeys:e,userKeys:n};if(i==="in")return id(W(N({},s),{amountIn:o,minAmountOut:r}),t);if(i==="out")return rd(W(N({},s),{maxAmountIn:o,amountOut:r}),t);sc.logWithError("invalid params","params",m)}throw sc.logWithError("invalid version","poolKeys.version",t),new Error("invalid version")}var Xn=5e4,sd=_([A("x"),A("y"),A("price")]),ad=_([A("accountType"),A("status"),A("multiplier"),A("validDataCount"),Q(sd,Xn,"DataElement")]);function ud(m,e){return[0,Xn-2]}function cd(m){return[0,Xn-2]}function ld(m){return[0,Xn-2]}function md(m,e,t){let[n,o]=ud(e,t),r=n,i=o,s=0,u=e*m.multiplier/t;for(;r<=i;){if(s=Math.floor((i+r)/2),s===0||s>=Xn-2)return[s,s,!1];let a=m.DataElement[s].x*m.multiplier/m.DataElement[s].y,c=m.DataElement[s-1].x*m.multiplier/m.DataElement[s-1].y,l=m.DataElement[s+1].x*m.multiplier/m.DataElement[s+1].y;if(u===a)return[s,s,!0];if(u===c)return[s-1,s-1,!0];if(u===l)return[s+1,s+1,!0];if(u<c)i=s-1;else{if(u>c&&u<a)return[s-1,s,!0];if(u>a&&u<l)return[s,s+1,!0];r=s+1}}return[s,s,!1]}function $s(m,e,t){let[n,o,r]=md(m,e,t);if(!r)return 0;if(n===o){let i=m.DataElement[n].x;return e*m.multiplier/i}else{let i=m.DataElement[n].x,s=m.DataElement[n].y,u=m.DataElement[o].x,a=m.DataElement[o].y,c=t*(u*s-i*a),l=i*c,d=(u-i)*(e*s-i*t)*a,p=l+d;return e*m.multiplier*c/p}}function Gn(m,e,t){return e*m.multiplier/t}function uc(m,e,t){return e*t/m.multiplier}function dd(m,e){let[t,n]=cd(e),o=t,r=n,i=0,s=e;for(;o<r;){if(i=Math.floor((r+o)/2),i<=0||i>Xn-2)return[i,i,!1];let u=m.DataElement[i].x,a=m.DataElement[i-1].x,c=m.DataElement[i+1].x;if(s===u)return[i,i,!0];if(s===a)return[i-1,i-1,!0];if(s===c)return[i+1,i+1,!0];if(s<a)r=i-1;else{if(s>a&&s<u)return[i-1,i,!0];if(s>u&&s<c)return[i,i+1,!0];o=i+1}}return[i,i,!1]}function pd(m,e){let[t,n]=ld(e),o=t,r=n,i=0,s=e;for(;o<=r;){if(i=Math.floor((r+o)/2),i<=0||i>=Xn-2)return[i,i,!1];let u=m.DataElement[i].y,a=m.DataElement[i-1].y,c=m.DataElement[i+1].y;if(s===u)return[i,i,!0];if(s===a)return[i-1,i-1,!0];if(s===c)return[i+1,i+1,!0];if(s<c)o=i+1;else{if(s<a&&s>u)return[i-1,i,!0];if(s<u&&s>c)return[i,i+1,!0];r=i-1}}return[i,i,!1]}function cc(m,e,t,n){let o=n?e+t:e-t,[r,i,s]=dd(m,o);if(!s)return[0,0,!1,s];if(r===i)return[m.DataElement[i].price,m.DataElement[i].y,!1,s];{let u=m.DataElement[r].x,a=m.DataElement[i].x,c=m.DataElement[r].price,l=m.DataElement[i].price,d=m.DataElement[r].y,p=m.DataElement[i].y;if(e>=u&&e<=a)return n?[l,p,!0,s]:[c,d,!0,s];{let f,y;return n?(f=c+(l-c)*(e-u)/(a-u),y=d-(o-u)*m.multiplier/l):(f=c+(l-c)*(e-u)/(a-u),y=p+(a-o)*m.multiplier/c),[f,y,!1,s]}}}function fd(m,e,t,n){let o=n?e-t:e+t,[r,i,s]=pd(m,o);if(!s)return[0,0,!1,s];if(r===i)return[m.DataElement[i].price,m.DataElement[i].x,!1,s];{let u=m.DataElement[r].x,a=m.DataElement[i].x,c=m.DataElement[r].price,l=m.DataElement[i].price,d=m.DataElement[r].y,p=m.DataElement[i].y;if(e>=p&&e<=d)return n?[l,a,!0,s]:[c,u,!0,s];{let f,y;return n?(f=c+(l-c)*(d-e)/(d-p),y=u+l*(d-o)/m.multiplier):(f=c+(l-c)*(d-e)/(d-p),y=a-c*(o-p)/m.multiplier),[f,y,!1,s]}}}function yd(m,e){let t=cc(m,e,0,!1);return t[3]?t[0]:0}function lc(m,e,t,n){let o=$s(m,e,t),r=Gn(m,e,o),i=Gn(m,t,o),s=Gn(m,n,o),u=!0,[a,c,l,d]=cc(m,r,s,u);if(!d)return 0;if(l)return n*m.multiplier/a;{let p=i-c;return uc(m,p,o)}}function mc(m,e,t,n){let o=$s(m,e,t),r=Gn(m,e,o),i=Gn(m,t,o),s=Gn(m,n,o),u=!1,[a,c,l,d]=fd(m,i,s,u);if(!d)return 0;if(l)return n*a/m.multiplier;{let p=r-c;return uc(m,p,o)}}function bd(m){let e=ad.decode(m);return{accountType:e.accountType.toNumber(),status:e.status.toNumber(),multiplier:e.multiplier.toNumber(),validDataCount:e.validDataCount.toNumber(),DataElement:e.DataElement.map(t=>({x:t.x.toNumber(),y:t.y.toNumber(),price:t.price.toNumber()}))}}function dc(m,e,t,n){let o=yd(m,Gn(m,e,$s(m,e,t)))/m.multiplier;return n?o:1/o}var si=class{constructor({connection:e,modelDataPubKey:t=vn}){this._layoutData={accountType:0,status:0,multiplier:0,validDataCount:0,DataElement:[]};this.connection=e,this.modelDataPubKey=t}get stableModelData(){return this._layoutData}async initStableModelLayout(){if(this._layoutData.validDataCount===0&&this.connection){let e=await this.connection.getAccountInfo(this.modelDataPubKey);e&&(this._layoutData=bd(e==null?void 0:e.data))}}};import{PublicKey as Pd}from"@solana/web3.js";import bT from"bn.js";import fr from"decimal.js";import{TOKEN_PROGRAM_ID as wd}from"@solana/spl-token";import{PublicKey as gd}from"@solana/web3.js";var Ad=fe("Raydium_liquidity_serum");function pc({programId:m,marketId:e}){let t=[e.toBuffer()],n=0,o;for(;n<100;){try{let r=t.concat(Buffer.from([n]),Buffer.alloc(7));o=gd.createProgramAddressSync(r,m)}catch(r){if(r instanceof TypeError)throw r;n++;continue}return{publicKey:o,nonce:n}}throw Ad.logWithError("unable to find a viable program address nonce","params",{programId:m,marketId:e}),new Error("unable to find a viable program address nonce")}function yr({programId:m}){let{publicKey:e}=se([Buffer.from("amm_config_account_seed","utf-8")],m);return e}function zn({name:m,programId:e,marketId:t}){let{publicKey:n}=se([e.toBuffer(),t.toBuffer(),Buffer.from(m,"utf-8")],e);return n}function kd({programId:m,marketId:e}){let{publicKey:t}=se([m.toBuffer(),e.toBuffer(),Buffer.from("open_order_associated_seed","utf-8")],m);return t}function ea({programId:m}){return se([Buffer.from([97,109,109,32,97,117,116,104,111,114,105,116,121])],m)}function ta({version:m,marketVersion:e,marketId:t,baseMint:n,quoteMint:o,baseDecimals:r,quoteDecimals:i,programId:s,marketProgramId:u}){let a=zn({name:"amm_associated_seed",programId:s,marketId:t}),c=zn({name:"lp_mint_associated_seed",programId:s,marketId:t}),{publicKey:l,nonce:d}=ea({programId:s}),p=zn({name:"coin_vault_associated_seed",programId:s,marketId:t}),f=zn({name:"pc_vault_associated_seed",programId:s,marketId:t}),y=zn({name:"temp_lp_token_associated_seed",programId:s,marketId:t}),b=kd({programId:s,marketId:t}),g=zn({name:"target_associated_seed",programId:s,marketId:t}),P=zn({name:"withdraw_associated_seed",programId:s,marketId:t}),{publicKey:h}=pc({programId:u,marketId:t});return{id:a,baseMint:n,quoteMint:o,lpMint:c,baseDecimals:r,quoteDecimals:i,lpDecimals:r,version:m,programId:s,authority:l,nonce:d,baseVault:p,quoteVault:f,lpVault:y,openOrders:b,targetOrders:g,withdrawQueue:P,marketVersion:e,marketProgramId:u,marketId:t,marketAuthority:h,lookupTableAccount:Pd.default,configId:yr({programId:s})}}var Js={volume:0,volumeQuote:0,volumeFee:0,apr:0,feeApr:0,priceMin:0,priceMax:0,rewardApr:[]},br=m=>{let e={},t=wd.toBase58();return Object.keys(m).map(n=>{let o=m[n],[r,i]=[o.baseMint.toBase58(),o.quoteMint.toBase58()];e[n]={id:n,version:4,status:o.status.toNumber(),programId:o.programId.toBase58(),mintA:mt({address:r,programId:t,decimals:o.baseDecimal.toNumber()}),mintB:mt({address:i,programId:t,decimals:o.quoteDecimal.toNumber()}),rewardDefaultInfos:[],rewardDefaultPoolInfos:"Ecosystem",price:o.poolPrice.toNumber(),mintAmountA:new fr(o.mintAAmount.toString()).div(10**o.baseDecimal.toNumber()).toNumber(),mintAmountB:new fr(o.mintBAmount.toString()).div(10**o.quoteDecimal.toNumber()).toNumber(),baseReserve:o.baseReserve,quoteReserve:o.quoteReserve,feeRate:new fr(o.tradeFeeNumerator.toString()).div(o.tradeFeeDenominator.toString()).toNumber(),openTime:o.poolOpenTime.toString(),tvl:0,day:Js,week:Js,month:Js,pooltype:[],farmUpcomingCount:0,farmOngoingCount:0,farmFinishedCount:0,type:"Standard",marketId:o.marketId.toBase58(),configId:yr({programId:o.programId}).toBase58(),lpPrice:0,lpAmount:new fr(o.lpReserve.toString()).div(10**Math.min(o.baseDecimal.toNumber(),o.quoteDecimal.toNumber())).toNumber(),lpMint:mt({address:o.lpMint.toBase58(),programId:t,decimals:Math.min(o.baseDecimal.toNumber(),o.quoteDecimal.toNumber())}),burnPercent:0}}),e};import qe from"bn.js";import Ce from"decimal.js";import{PublicKey as ai}from"@solana/web3.js";import ui from"bn.js";import{TOKEN_PROGRAM_ID as gc}from"@solana/spl-token";import{SystemProgram as Qn,SYSVAR_RENT_PUBKEY as Td,Transaction as fc,TransactionInstruction as Id}from"@solana/web3.js";import{createInitializeAccountInstruction as yc,TOKEN_PROGRAM_ID as bc}from"@solana/spl-token";function hd(m="accountFlags"){let e=new nr(m);return e.addBoolean("initialized"),e.addBoolean("market"),e.addBoolean("openOrders"),e.addBoolean("requestQueue"),e.addBoolean("eventQueue"),e.addBoolean("bids"),e.addBoolean("asks"),e}var na=_([he(5),hd("accountFlags"),O("ownAddress"),A("vaultSignerNonce"),O("baseMint"),O("quoteMint"),O("baseVault"),A("baseDepositsTotal"),A("baseFeesAccrued"),O("quoteVault"),A("quoteDepositsTotal"),A("quoteFeesAccrued"),A("quoteDustThreshold"),O("requestQueue"),O("eventQueue"),O("bids"),O("asks"),A("baseLotSize"),A("quoteLotSize"),A("feeRateBps"),A("referrerRebatesAccrued"),he(7)]);function Bd({programId:m,marketInfo:e}){let t=_([D("version"),ct("instruction"),A("baseLotSize"),A("quoteLotSize"),Tt("feeRateBps"),A("vaultSignerNonce"),A("quoteDustThreshold")]),n=[{pubkey:e.id,isSigner:!1,isWritable:!0},{pubkey:e.requestQueue,isSigner:!1,isWritable:!0},{pubkey:e.eventQueue,isSigner:!1,isWritable:!0},{pubkey:e.bids,isSigner:!1,isWritable:!0},{pubkey:e.asks,isSigner:!1,isWritable:!0},{pubkey:e.baseVault,isSigner:!1,isWritable:!0},{pubkey:e.quoteVault,isSigner:!1,isWritable:!0},{pubkey:e.baseMint,isSigner:!1,isWritable:!1},{pubkey:e.quoteMint,isSigner:!1,isWritable:!1},{pubkey:e.authority?e.quoteMint:Td,isSigner:!1,isWritable:!1}].concat(e.authority?{pubkey:e.authority,isSigner:!1,isWritable:!1}:[]).concat(e.authority&&e.pruneAuthority?{pubkey:e.pruneAuthority,isSigner:!1,isWritable:!1}:[]),o=Buffer.alloc(t.span);return t.encode({version:0,instruction:0,baseLotSize:e.baseLotSize,quoteLotSize:e.quoteLotSize,feeRateBps:e.feeRateBps,vaultSignerNonce:e.vaultSignerNonce,quoteDustThreshold:e.quoteDustThreshold},o),new Id({keys:n,programId:m,data:o})}async function gr({connection:m,wallet:e,marketInfo:t}){var i,s,u,a,c,l,d,p;let n=new fc,o=await m.getMinimumBalanceForRentExemption(165);n.add(Qn.createAccountWithSeed({fromPubkey:e,basePubkey:e,seed:t.baseVault.seed,newAccountPubkey:t.baseVault.publicKey,lamports:o,space:165,programId:bc}),Qn.createAccountWithSeed({fromPubkey:e,basePubkey:e,seed:t.quoteVault.seed,newAccountPubkey:t.quoteVault.publicKey,lamports:o,space:165,programId:bc}),yc(t.baseVault.publicKey,t.baseMint,t.vaultOwner),yc(t.quoteVault.publicKey,t.quoteMint,t.vaultOwner),Qn.createAccountWithSeed({fromPubkey:e,basePubkey:e,seed:t.id.seed,newAccountPubkey:t.id.publicKey,lamports:await m.getMinimumBalanceForRentExemption(na.span),space:na.span,programId:t.programId}));let r=new fc;return r.add(Qn.createAccountWithSeed({fromPubkey:e,basePubkey:e,seed:t.requestQueue.seed,newAccountPubkey:t.requestQueue.publicKey,lamports:t.lowestFeeMarket?6208320:await m.getMinimumBalanceForRentExemption((i=t.requestQueueSpace)!=null?i:5120+12),space:t.lowestFeeMarket?764:(s=t.requestQueueSpace)!=null?s:5120+12,programId:t.programId}),Qn.createAccountWithSeed({fromPubkey:e,basePubkey:e,seed:t.eventQueue.seed,newAccountPubkey:t.eventQueue.publicKey,lamports:t.lowestFeeMarket?79594560:await m.getMinimumBalanceForRentExemption((u=t.eventQueueSpace)!=null?u:262144+12),space:t.lowestFeeMarket?11308:(a=t.eventQueueSpace)!=null?a:262144+12,programId:t.programId}),Qn.createAccountWithSeed({fromPubkey:e,basePubkey:e,seed:t.bids.seed,newAccountPubkey:t.bids.publicKey,lamports:t.lowestFeeMarket?101977920:await m.getMinimumBalanceForRentExemption((c=t.orderbookQueueSpace)!=null?c:65536+12),space:t.lowestFeeMarket?14524:(l=t.orderbookQueueSpace)!=null?l:65536+12,programId:t.programId}),Qn.createAccountWithSeed({fromPubkey:e,basePubkey:e,seed:t.asks.seed,newAccountPubkey:t.asks.publicKey,lamports:t.lowestFeeMarket?101977920:await m.getMinimumBalanceForRentExemption((d=t.orderbookQueueSpace)!=null?d:65536+12),space:t.lowestFeeMarket?14524:(p=t.orderbookQueueSpace)!=null?p:65536+12,programId:t.programId}),Bd({programId:t.programId,marketInfo:{id:t.id.publicKey,requestQueue:t.requestQueue.publicKey,eventQueue:t.eventQueue.publicKey,bids:t.bids.publicKey,asks:t.asks.publicKey,baseVault:t.baseVault.publicKey,quoteVault:t.quoteVault.publicKey,baseMint:t.baseMint,quoteMint:t.quoteMint,baseLotSize:t.baseLotSize,quoteLotSize:t.quoteLotSize,feeRateBps:t.feeRateBps,vaultSignerNonce:t.vaultSignerNonce,quoteDustThreshold:t.quoteDustThreshold}})),[{transaction:n,signer:[],instructionTypes:[q.CreateAccount,q.CreateAccount,q.InitAccount,q.InitAccount]},{transaction:r,signer:[],instructionTypes:[q.CreateAccount,q.CreateAccount,q.CreateAccount,q.CreateAccount,q.CreateAccount,q.InitMarket]}]}var Ao=class extends Ne{async create({baseInfo:e,quoteInfo:t,lotSize:n,tickSize:o,dexProgramId:r,requestQueueSpace:i,eventQueueSpace:s,orderbookQueueSpace:u,lowestFeeMarket:a,assignSeed:c,txVersion:l,computeBudgetConfig:d,txTipConfig:p,feePayer:f}){let y=this.scope.ownerPubKey,b=c?`${e.mint.toBase58().slice(0,10)}-${t.mint.toBase58().slice(0,10)}-${c}`:void 0,g=Ge({fromPublicKey:y,programId:r,assignSeed:b&&`${b}-market`}),P=Ge({fromPublicKey:y,programId:r,assignSeed:b&&`${b}-request`}),h=Ge({fromPublicKey:y,programId:r,assignSeed:b&&`${b}-event`}),I=Ge({fromPublicKey:y,programId:r,assignSeed:b&&`${b}-bids`}),k=Ge({fromPublicKey:y,programId:r,assignSeed:b&&`${b}-asks`}),w=Ge({fromPublicKey:y,programId:gc,assignSeed:b&&`${b}-baseVault`}),S=Ge({fromPublicKey:y,programId:gc,assignSeed:b&&`${b}-quoteVault`}),x=0,K=new ui(100);function T(){let X=new ui(0);for(;;)try{return{vaultOwner:ai.createProgramAddressSync([g.publicKey.toBuffer(),X.toArrayLike(Buffer,"le",8)],r),vaultSignerNonce:X}}catch{if(X.iaddn(1),X.gt(new ui(25555)))throw Error("find vault owner error")}}let{vaultOwner:C,vaultSignerNonce:M}=T(),v=new ui(Math.round(10**e.decimals*n)),R=new ui(Math.round(n*10**t.decimals*o));if(v.eq(Pt))throw Error("lot size is too small");if(R.eq(Pt))throw Error("tick size or lot size is too small");let L=await gr({connection:this.scope.connection,wallet:this.scope.ownerPubKey,marketInfo:{programId:r,id:g,baseMint:e.mint,quoteMint:t.mint,baseVault:w,quoteVault:S,vaultOwner:C,requestQueue:P,eventQueue:h,bids:I,asks:k,feeRateBps:x,quoteDustThreshold:K,vaultSignerNonce:M,baseLotSize:v,quoteLotSize:R,requestQueueSpace:i,eventQueueSpace:s,orderbookQueueSpace:u,lowestFeeMarket:a}}),F=this.createTxBuilder(f);F.addInstruction({instructions:L[0].transaction.instructions,signers:L[0].signer});for await(let X of L.slice(1,L.length))F.addInstruction({instructions:X.transaction.instructions,signers:X.signer,instructionTypes:X.instructionTypes});return l===0?F.sizeCheckBuildV0({computeBudgetConfig:d,address:{marketId:g.publicKey,requestQueue:P.publicKey,eventQueue:h.publicKey,bids:I.publicKey,asks:k.publicKey,baseVault:w.publicKey,quoteVault:S.publicKey,baseMint:new ai(e.mint),quoteMint:new ai(t.mint)}}):F.sizeCheckBuild({computeBudgetConfig:d,address:{marketId:g.publicKey,requestQueue:P.publicKey,eventQueue:h.publicKey,bids:I.publicKey,asks:k.publicKey,baseVault:w.publicKey,quoteVault:S.publicKey,baseMint:new ai(e.mint),quoteMint:new ai(t.mint)}})}};var ci=class extends Ne{constructor(t){super(t);this.stableLayout=new si({connection:this.scope.connection,modelDataPubKey:this.scope.cluster==="mainnet"?void 0:un.MODEL_DATA_PUBKEY})}async initLayout(){await this.stableLayout.initStableModelLayout()}async load(){this.checkDisabled()}computePairAmount({poolInfo:t,amount:n,slippage:o,baseIn:r}){let i=new qe(new Ce(n).mul(10**t[r?"mintA":"mintB"].decimals).toFixed(0)),s=mr(t[r?"mintB":"mintA"]),[u,a]=[new qe(new Ce(t.mintAmountA).mul(10**t.mintA.decimals).toString()),new qe(new Ce(t.mintAmountB).mul(10**t.mintB.decimals).toString())],c=new qe(new Ce(t.lpAmount).mul(10**t.lpMint.decimals).toFixed(0,Ce.ROUND_DOWN));this.logDebug("baseReserve:",u.toString(),"quoteReserve:",a.toString()),this.logDebug("tokenIn:",r?t.mintA.symbol:t.mintB.symbol,"amountIn:",i.toString(),"anotherToken:",r?t.mintB.symbol:t.mintA.symbol,"slippage:",`${o.toSignificant()}%`,"baseReserve",u.toString(),"quoteReserve",a.toString());let l=r?"base":"quote";this.logDebug("input side:",l);let d=Pt;i.isZero()||(d=l==="base"?vi(i.mul(a),u):vi(i.mul(u),a)),this.logDebug("amountRaw:",d.toString(),"lpAmount:",c.toString());let p=vi(i.mul(c),l==="base"?u:a);this.logDebug("liquidity:",p.toString());let f=new Je(new qe(1)).add(o),y=new Je(new qe(1)).sub(o),b=f.mul(d).quotient,g=y.mul(d).quotient,P=new Be(s,d),h=new Be(s,b),I=new Be(s,g);return this.logDebug("anotherAmount:",P.toFixed(),"maxAnotherAmount:",h.toFixed()),{anotherAmount:P,maxAnotherAmount:h,minAnotherAmount:I,liquidity:p}}async getAmmPoolKeys(t){return(await this.scope.api.fetchPoolKeysById({idList:[t]}))[0]}async addLiquidity(t){let{poolInfo:n,poolKeys:o,amountInA:r,amountInB:i,otherAmountMin:s,fixedSide:u,config:a,txVersion:c,computeBudgetConfig:l,txTipConfig:d,feePayer:p}=t;this.scope.availability.addStandardPosition===!1&&this.logAndCreateError("add liquidity feature disabled in your region"),this.logDebug("amountInA:",r,"amountInB:",i),(r.isZero()||i.isZero())&&this.logAndCreateError("amounts must greater than zero","amountInA & amountInB",{amountInA:r.toFixed(),amountInB:i.toFixed()});let{account:f}=this.scope,{bypassAssociatedCheck:y,checkCreateATAOwner:b}=N({bypassAssociatedCheck:!1,checkCreateATAOwner:!1},a),[g,P]=[r.token,i.token],h=await f.getCreatedTokenAccount({mint:g.mint,associatedOnly:!1}),I=await f.getCreatedTokenAccount({mint:P.mint,associatedOnly:!1});!h&&!I&&this.logAndCreateError("cannot found target token accounts","tokenAccounts",f.tokenAccounts);let k=await f.getCreatedTokenAccount({mint:new je(n.lpMint.address)}),w=[g,P],S=[h,I],x=[r.raw,i.raw],K=r.token.mint.toBase58()===n.mintA.address?"base":"quote",T="base";["quote","base"].includes(K)||this.logAndCreateError("invalid fixedSide","fixedSide",u),K==="quote"?(w.reverse(),S.reverse(),x.reverse(),T=u==="a"?"quote":"base"):K==="base"&&(T=u==="a"?"base":"quote");let[C,M]=w,[v,R]=S,[L,F]=x,X=o!=null?o:await this.getAmmPoolKeys(n.id),H=this.createTxBuilder(p),Z=await f.handleTokenAccount({side:"in",amount:L,mint:C.mint,tokenAccount:v,bypassAssociatedCheck:y,checkCreateATAOwner:b}),{tokenAccount:re}=Z,ye=Ee(Z,["tokenAccount"]);H.addInstruction(ye);let Ie=await f.handleTokenAccount({side:"in",amount:F,mint:M.mint,tokenAccount:R,bypassAssociatedCheck:y,checkCreateATAOwner:b}),{tokenAccount:ue}=Ie,me=Ee(Ie,["tokenAccount"]);H.addInstruction(me);let we=await f.handleTokenAccount({side:"out",amount:0,mint:new je(n.lpMint.address),tokenAccount:k,bypassAssociatedCheck:y,checkCreateATAOwner:b}),{tokenAccount:pe}=we,ce=Ee(we,["tokenAccount"]);return H.addInstruction(ce),H.addInstruction({instructions:[ac({poolInfo:n,poolKeys:X,userKeys:{baseTokenAccount:re,quoteTokenAccount:ue,lpTokenAccount:pe,owner:this.scope.ownerPubKey},baseAmountIn:L,quoteAmountIn:F,otherAmountMin:s.raw,fixedSide:T})],instructionTypes:[n.pooltype.includes("StablePool")?q.AmmV5AddLiquidity:q.AmmV4AddLiquidity],lookupTableAddress:X.lookupTableAccount?[X.lookupTableAccount]:[]}),H.addCustomComputeBudget(l),H.addTipInstruction(d),c===0?await H.buildV0():H.build()}async removeLiquidity(t){this.scope.availability.removeStandardPosition===!1&&this.logAndCreateError("remove liquidity feature disabled in your region");let{poolInfo:n,poolKeys:o,lpAmount:r,baseAmountMin:i,quoteAmountMin:s,config:u,txVersion:a,computeBudgetConfig:c,txTipConfig:l,feePayer:d}=t,p=o!=null?o:await this.getAmmPoolKeys(n.id),[f,y,b]=[new je(n.mintA.address),new je(n.mintB.address),new je(n.lpMint.address)];this.logDebug("lpAmount:",r),this.logDebug("baseAmountMin:",i),this.logDebug("quoteAmountMin:",s),r.isZero()&&this.logAndCreateError("amount must greater than zero","lpAmount",r.toString());let{account:g}=this.scope,P=await g.getCreatedTokenAccount({mint:b,associatedOnly:!1});P||this.logAndCreateError("cannot found lpTokenAccount","tokenAccounts",g.tokenAccounts);let h=await g.getCreatedTokenAccount({mint:f}),I=await g.getCreatedTokenAccount({mint:y}),k=this.createTxBuilder(d),{bypassAssociatedCheck:w,checkCreateATAOwner:S}=N({bypassAssociatedCheck:!1,checkCreateATAOwner:!1},u),M=await g.handleTokenAccount({side:"out",amount:0,mint:f,tokenAccount:h,bypassAssociatedCheck:w,checkCreateATAOwner:S}),{tokenAccount:x}=M,K=Ee(M,["tokenAccount"]);k.addInstruction(K);let v=await g.handleTokenAccount({side:"out",amount:0,mint:y,tokenAccount:I,bypassAssociatedCheck:w,checkCreateATAOwner:S}),{tokenAccount:T}=v,C=Ee(v,["tokenAccount"]);return k.addInstruction(C),k.addInstruction({instructions:[Hs({poolInfo:n,poolKeys:p,userKeys:{lpTokenAccount:P,baseTokenAccount:x,quoteTokenAccount:T,owner:this.scope.ownerPubKey},lpAmount:r,baseAmountMin:i,quoteAmountMin:s})],lookupTableAddress:p.lookupTableAccount?[p.lookupTableAccount]:[],instructionTypes:[n.pooltype.includes("StablePool")?q.AmmV5RemoveLiquidity:q.AmmV4RemoveLiquidity]}),k.addCustomComputeBudget(c),k.addTipInstruction(l),a===0?await k.buildV0():k.build()}async removeAllLpAndCreateClmmPosition({poolInfo:t,clmmPoolInfo:n,removeLpAmount:o,createPositionInfo:r,farmInfo:i,userFarmLpAmount:s,base:u,computeBudgetConfig:a,payer:c,userAuxiliaryLedgers:l,tokenProgram:d=xn,checkCreateATAOwner:p=!0,getEphemeralSigners:f,txVersion:y,feePayer:b}){if((this.scope.availability.removeStandardPosition===!1||this.scope.availability.createConcentratedPosition===!1)&&this.logAndCreateError("remove liquidity or create position feature disabled in your region"),!(t.mintA.address===n.mintA.address||t.mintA.address===n.mintB.address)||!(t.mintB.address===n.mintA.address||t.mintB.address===n.mintB.address))throw Error("mint check error");let g=this.createTxBuilder(b),P={};for(let X of this.scope.account.tokenAccountRawInfos)(P[X.accountInfo.mint.toString()]===void 0||J(this.scope.ownerPubKey,X.accountInfo.mint,xn).publicKey.equals(X.pubkey))&&(P[X.accountInfo.mint.toString()]=X.pubkey);let h=P[t.lpMint.address];if(h===void 0)throw Error("find lp account error in trade accounts");let I=o.add(s!=null?s:new qe(0)),k=t.mintA.address===Fe.WSOL.mint.toString(),w=t.mintB.address===Fe.WSOL.mint.toString(),{account:S,instructionParams:x}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:xn,mint:new je(t.mintA.address),owner:this.scope.ownerPubKey,createInfo:k?{payer:this.scope.ownerPubKey}:void 0,skipCloseAccount:!k,notUseTokenAccount:k,associatedOnly:!0,checkCreateATAOwner:p});if(g.addInstruction(x||{}),S===void 0)throw new Error("base token account not found");let{account:K,instructionParams:T}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:xn,mint:new je(t.mintB.address),owner:this.scope.ownerPubKey,createInfo:w?{payer:this.scope.ownerPubKey,amount:0}:void 0,skipCloseAccount:!w,notUseTokenAccount:w,associatedOnly:!0,checkCreateATAOwner:p});if(g.addInstruction(T||{}),K===void 0)throw new Error("quote token account not found");if(P[t.mintA.address]=S,P[t.mintB.address]=K,i!==void 0&&!(s!=null&&s.isZero())){let X=Ot[i.programId],H=Nt({programId:new je(i.programId),poolId:new je(i.id),owner:this.scope.ownerPubKey,version:X}),re,ye=await this.scope.connection.getAccountInfo(H);if(ye&&(re=qo(X).decode(ye.data)),X!==6&&!re){let{instruction:we,instructionType:pt}=Go({id:new je(i.id),programId:new je(i.programId),version:X,ledger:H,owner:this.scope.ownerPubKey});g.addInstruction({instructions:[we],instructionTypes:[pt]})}let ue=[];for(let we of i.rewardInfos){let pt=we.mint.address===Fe.WSOL.mint.toString();if(P[we.mint.address])ue.push(P[we.mint.address]);else{let{account:nt,instructionParams:an}=await this.scope.account.getOrCreateTokenAccount({mint:new je(we.mint.address),tokenProgram:d,owner:this.scope.ownerPubKey,skipCloseAccount:!pt,createInfo:{payer:c||this.scope.ownerPubKey},associatedOnly:!0,checkCreateATAOwner:p});nt||this.logAndCreateError("farm reward account not found:",we.mint.address),an&&g.addInstruction(an),ue.push(nt)}}let me=(await this.scope.api.fetchFarmKeysById({ids:i.id}))[0],pe={userAuxiliaryLedgers:l,amount:s,owner:this.scope.ownerPubKey,farmInfo:i,farmKeys:me,lpAccount:h,rewardAccounts:ue},ce=Ot[i.programId],Z=ce===6?Xo(pe):ce===5?zo(pe):Qo(pe),Ie={3:q.FarmV3Withdraw,5:q.FarmV5Withdraw,6:q.FarmV6Withdraw};g.addInstruction({instructions:[Z],instructionTypes:[Ie[ce]]})}let C=await this.getAmmPoolKeys(t.id),M=Hs({poolInfo:t,poolKeys:C,userKeys:{lpTokenAccount:h,baseTokenAccount:S,quoteTokenAccount:K,owner:this.scope.ownerPubKey},lpAmount:I,baseAmountMin:0,quoteAmountMin:0});g.addInstruction({instructions:[M],instructionTypes:[t.pooltype.includes("StablePool")?q.AmmV5RemoveLiquidity:q.AmmV4RemoveLiquidity],lookupTableAddress:C.lookupTableAccount?[C.lookupTableAccount]:[]});let[v,R]=t.mintA.address===n.mintA.address?[S,K]:[K,S],L=await this.scope.clmm.getClmmPoolKeys(n.id),F=await Ke.openPositionFromBaseInstructions(W(N({poolInfo:n,poolKeys:L,ownerInfo:{feePayer:this.scope.ownerPubKey,wallet:this.scope.ownerPubKey,tokenAccountA:v,tokenAccountB:R},withMetadata:"create"},r),{base:u,getEphemeralSigners:f}));return g.addInstruction({instructions:[...F.instructions],signers:F.signers,instructionTypes:[...F.instructionTypes],lookupTableAddress:L.lookupTableAccount?[L.lookupTableAccount]:[]}),y===0?g.sizeCheckBuildV0({computeBudgetConfig:a}):g.sizeCheckBuild({computeBudgetConfig:a})}async createPoolV4({programId:t,marketInfo:n,baseMintInfo:o,quoteMintInfo:r,baseAmount:i,quoteAmount:s,startTime:u,ownerInfo:a,associatedOnly:c=!1,checkCreateATAOwner:l=!1,tokenProgram:d,txVersion:p,feeDestinationId:f,computeBudgetConfig:y,txTipConfig:b,feePayer:g}){var R;let P=a.feePayer||((R=this.scope.owner)==null?void 0:R.publicKey),h=a.useSOLBalance&&o.mint.equals(Ar),I=a.useSOLBalance&&r.mint.equals(Ar),k=this.createTxBuilder(g),{account:w,instructionParams:S}=await this.scope.account.getOrCreateTokenAccount({mint:o.mint,owner:this.scope.ownerPubKey,createInfo:h?{payer:P,amount:i}:void 0,notUseTokenAccount:h,skipCloseAccount:!h,associatedOnly:h?!1:c,checkCreateATAOwner:l});k.addInstruction(S||{});let{account:x,instructionParams:K}=await this.scope.account.getOrCreateTokenAccount({mint:r.mint,owner:this.scope.ownerPubKey,createInfo:I?{payer:P,amount:s}:void 0,notUseTokenAccount:I,skipCloseAccount:!I,associatedOnly:I?!1:c,checkCreateATAOwner:l});if(k.addInstruction(K||{}),w===void 0||x===void 0)throw Error("you don't has some token account");let T=ta({version:4,marketVersion:3,marketId:n.marketId,baseMint:o.mint,quoteMint:r.mint,baseDecimals:o.decimals,quoteDecimals:r.decimals,programId:t,marketProgramId:n.programId}),C={programId:t,ammId:T.id,ammAuthority:T.authority,ammOpenOrders:T.openOrders,lpMint:T.lpMint,coinMint:T.baseMint,pcMint:T.quoteMint,coinVault:T.baseVault,pcVault:T.quoteVault,withdrawQueue:T.withdrawQueue,ammTargetOrders:T.targetOrders,poolTempLp:T.lpVault,marketProgramId:T.marketProgramId,marketId:T.marketId,ammConfigId:T.configId,feeDestinationId:f},{instruction:M,instructionType:v}=Zs(W(N({},C),{userWallet:this.scope.ownerPubKey,userCoinVault:w,userPcVault:x,userLpVault:J(this.scope.ownerPubKey,T.lpMint,d).publicKey,nonce:T.nonce,openTime:u,coinAmount:i,pcAmount:s}));return k.addInstruction({instructions:[M],instructionTypes:[v]}),k.addCustomComputeBudget(y),k.addTipInstruction(b),k.versionBuild({txVersion:p,extInfo:{address:C}})}async createMarketAndPoolV4({programId:t=Ei,marketProgram:n=Ya,feeDestinationId:o=Za,tokenProgram:r,baseMintInfo:i,quoteMintInfo:s,baseAmount:u,quoteAmount:a,startTime:c,ownerInfo:l,lowestFeeMarket:d,assignSeed:p,associatedOnly:f=!1,checkCreateATAOwner:y=!1,lotSize:b=1,tickSize:g=.01,txVersion:P,computeBudgetConfig:h,txTipConfig:I,feePayer:k}){var xo,So,Ko;let w=this.scope.ownerPubKey,S=l.feePayer||((xo=this.scope.owner)==null?void 0:xo.publicKey),x=l.useSOLBalance&&i.mint.equals(Ar),K=l.useSOLBalance&&s.mint.equals(Ar),T=p?`${i.mint.toBase58().slice(0,7)}-${s.mint.toBase58().slice(0,7)}-${p}`:void 0,C=Ge({fromPublicKey:w,programId:n,assignSeed:T&&`${T}-market`}),M=Ge({fromPublicKey:w,programId:n,assignSeed:T&&`${T}-request`}),v=Ge({fromPublicKey:w,programId:n,assignSeed:T&&`${T}-event`}),R=Ge({fromPublicKey:w,programId:n,assignSeed:T&&`${T}-bids`}),L=Ge({fromPublicKey:w,programId:n,assignSeed:T&&`${T}-asks`}),F=Ge({fromPublicKey:w,programId:xn,assignSeed:T&&`${T}-baseVault`}),X=Ge({fromPublicKey:w,programId:xn,assignSeed:T&&`${T}-quoteVault`}),H=0,re=new qe(100);function ye(){let ht=new qe(0);for(;;)try{return{vaultOwner:je.createProgramAddressSync([C.publicKey.toBuffer(),ht.toArrayLike(Buffer,"le",8)],n),vaultSignerNonce:ht}}catch{if(ht.iaddn(1),ht.gt(new qe(25555)))throw Error("find vault owner error")}}let{vaultOwner:ue,vaultSignerNonce:me}=ye(),pe=new qe(Math.round(10**i.decimals*b)),ce=new qe(Math.round(b*10**s.decimals*g));if(pe.eq(Pt))throw Error("lot size is too small");if(ce.eq(Pt))throw Error("tick size or lot size is too small");let Z=await gr({connection:this.scope.connection,wallet:this.scope.ownerPubKey,marketInfo:{programId:n,vaultOwner:ue,baseMint:i.mint,quoteMint:s.mint,id:C,baseVault:F,quoteVault:X,requestQueue:M,eventQueue:v,bids:R,asks:L,feeRateBps:H,quoteDustThreshold:re,vaultSignerNonce:me,baseLotSize:pe,quoteLotSize:ce,lowestFeeMarket:d}}),Ie=this.createTxBuilder(k);Ie.addInstruction({instructions:Z[0].transaction.instructions,signers:Z[0].signer});for await(let ht of Z.slice(1,Z.length))Ie.addInstruction({instructions:ht.transaction.instructions,signers:ht.signer,instructionTypes:ht.instructionTypes});let{account:we,instructionParams:pt}=await this.scope.account.getOrCreateTokenAccount({mint:i.mint,owner:this.scope.ownerPubKey,createInfo:x?{payer:S,amount:u}:void 0,notUseTokenAccount:x,skipCloseAccount:!x,associatedOnly:x?!1:f,checkCreateATAOwner:y,assignSeed:x&&T?`${T}-wsol`:void 0});Ie.addInstruction(pt||{});let{account:nt,instructionParams:an}=await this.scope.account.getOrCreateTokenAccount({mint:s.mint,owner:this.scope.ownerPubKey,createInfo:K?{payer:S,amount:a}:void 0,notUseTokenAccount:K,skipCloseAccount:!K,associatedOnly:K?!1:f,checkCreateATAOwner:y,assignSeed:K&&T?`${T}-wsol`:void 0});if(Ie.addInstruction(an||{}),we===void 0)throw Error("you don't has base token account");if(nt===void 0)throw Error("you don't has quote token account");let Ze=ta({version:4,marketVersion:3,marketId:C.publicKey,baseMint:i.mint,quoteMint:s.mint,baseDecimals:i.decimals,quoteDecimals:s.decimals,programId:t,marketProgramId:n}),On={programId:t,ammId:Ze.id,ammAuthority:Ze.authority,ammOpenOrders:Ze.openOrders,lpMint:Ze.lpMint,coinMint:Ze.baseMint,pcMint:Ze.quoteMint,coinVault:Ze.baseVault,pcVault:Ze.quoteVault,withdrawQueue:Ze.withdrawQueue,ammTargetOrders:Ze.targetOrders,poolTempLp:Ze.lpVault,marketProgramId:Ze.marketProgramId,marketId:Ze.marketId,ammConfigId:Ze.configId,feeDestinationId:o},{instruction:gt,instructionType:Bo}=Zs(W(N({},On),{userWallet:this.scope.ownerPubKey,userCoinVault:we,userPcVault:nt,userLpVault:J(this.scope.ownerPubKey,Ze.lpMint,r).publicKey,nonce:Ze.nonce,openTime:c,coinAmount:u,pcAmount:a}));Ie.addInstruction({instructions:[gt],instructionTypes:[Bo]});let oo=x||K?[((So=pt==null?void 0:pt.instructions)==null?void 0:So[0])||((Ko=an==null?void 0:an.instructions)==null?void 0:Ko[0])].filter(ht=>!!ht):void 0;return P===0?Ie.sizeCheckBuildV0({computeBudgetConfig:h,splitIns:oo,address:N({requestQueue:M.publicKey,eventQueue:v.publicKey,bids:R.publicKey,asks:L.publicKey,baseVault:F.publicKey,quoteVault:X.publicKey,baseMint:new je(i.mint),quoteMint:new je(s.mint)},On)}):Ie.sizeCheckBuild({computeBudgetConfig:h,splitIns:oo,address:N({requestQueue:M.publicKey,eventQueue:v.publicKey,bids:R.publicKey,asks:L.publicKey,baseVault:F.publicKey,quoteVault:X.publicKey,baseMint:new je(i.mint),quoteMint:new je(s.mint)},On)})}async getCreatePoolFee({programId:t}){let n=yr({programId:t}),o=await this.scope.connection.getAccountInfo(n,{dataSlice:{offset:536,length:8}});if(o===null)throw Error("get config account error");return rc.decode(o.data).fee}computeAmountOut({poolInfo:t,amountIn:n,mintIn:o,mintOut:r,slippage:i}){let[s,u]=[o.toString(),r.toString()];if(s!==t.mintA.address&&s!==t.mintB.address)throw new Error("toke not match");if(u!==t.mintA.address&&u!==t.mintB.address)throw new Error("toke not match");let{baseReserve:a,quoteReserve:c}=t,l=[a,c],d=[t.mintA.decimals,t.mintB.decimals],p=s==t.mintA.address?"base":"quote";p==="quote"&&(l.reverse(),d.reverse());let[f,y]=l,[b,g]=d,P=t.version===4,h;if(P)h=new Ce(y.toString()).div(10**g).div(new Ce(f.toString()).div(10**b));else{let v=dc(this.stableLayout.stableModelData,a.toNumber(),c.toNumber(),!1);p==="quote"?h=new Ce(1e6).div(v*1e6):h=new Ce(v*1e6).div(1e6)}let I=n,k=new qe(0),w=new qe(0);if(!I.isZero())if(P){w=Qt(I.mul(Xs),dr);let v=I.sub(w),R=f.add(v);k=y.mul(v).div(R)}else{w=I.mul(new qe(2)).div(new qe(1e4));let v=I.sub(w);p==="quote"?k=new qe(lc(this.stableLayout.stableModelData,c.toNumber(),a.toNumber(),v.toNumber())):k=new qe(mc(this.stableLayout.stableModelData,c.toNumber(),a.toNumber(),v.toNumber()))}let S=new qe(new Ce(k.toString()).mul(1-i).toFixed(0)),x=k,K=S,T=new Ce(k.toString()).div(new Ce(I.sub(w).toString()).toFixed(0));!I.isZero()&&!k.isZero()&&(T=new Ce(k.toString()).div(10**g).div(new Ce(I.sub(w).toString()).div(10**b)));let C=h.sub(T).div(h).mul(100);return{amountOut:x,minAmountOut:K,currentPrice:h,executionPrice:T,priceImpact:C,fee:w}}computeAmountIn({poolInfo:t,amountOut:n,mintIn:o,mintOut:r,slippage:i}){let{baseReserve:s,quoteReserve:u}=t;o.toString()!==t.mintA.address&&o.toString()!==t.mintB.address&&this.logAndCreateError("mintIn does not match pool"),r.toString()!==t.mintA.address&&r.toString()!==t.mintB.address&&this.logAndCreateError("mintOut does not match pool"),this.logDebug("baseReserve:",s.toString()),this.logDebug("quoteReserve:",u.toString());let a=o.toString()===t.mintA.address,[c,l]=a?[t.mintA,t.mintB]:[t.mintB,t.mintA];this.logDebug("currencyOut:",l.symbol||l.address),this.logDebug("amountOut:",new Ce(n.toString()).div(10**l.decimals).toDecimalPlaces(l.decimals).toString(),c.symbol||c.address),this.logDebug("slippage:",`${i*100}%`);let d=[s,u],p=a?"quote":"base";p==="base"&&d.reverse(),this.logDebug("output side:",p);let[f,y]=d,b=new Ce(y.toString()).div(10**t[a?"mintB":"mintA"].decimals).div(new Ce(f.toString()).div(10**t[a?"mintA":"mintB"].decimals));this.logDebug("currentPrice:",`1 ${c.symbol||c.address} \u2248 ${b.toString()} ${l.symbol||l.address}`),this.logDebug("currentPrice invert:",`1 ${l.symbol||l.address} \u2248 ${new Ce(1).div(b).toString()} ${c.symbol||c.address}`);let g=new qe(0),P=n;if(!P.isZero()){P.gt(y)&&(P=y.sub(new qe(1)));let K=y.sub(P);g=f.mul(P).div(K).mul(dr).div(dr.sub(Xs))}let h=new qe(new Ce(g.toString()).mul(1+i).toFixed(0)),I=g,k=h;this.logDebug("amountIn:",new Ce(I.toString()).div(10**c.decimals).toDecimalPlaces(c.decimals).toString()),this.logDebug("maxAmountIn:",new Ce(k.toString()).div(10**c.decimals).toDecimalPlaces(c.decimals).toString());let w=null;!g.isZero()&&!P.isZero()&&(w=new Ce(P.toString()).div(10**l.decimals).div(new Ce(g.toString()).div(10**c.decimals)),this.logDebug("executionPrice:",`1 ${l.symbol||l.address} \u2248 ${w.toDecimalPlaces(Math.max(t.mintA.decimals,t.mintB.decimals)).toString()} ${c.symbol||c.address}`),this.logDebug("executionPrice invert:",`1 ${l.symbol||l.address} \u2248 ${new Ce(1).div(w).toDecimalPlaces(Math.max(t.mintA.decimals,t.mintB.decimals)).toString()} ${c.symbol||c.address}`));let S=b.mul(I.toString()),x=S.sub(n.toString()).abs().div(S);return this.logDebug("priceImpact:",`${x.toString()}%`),{amountIn:I,maxAmountIn:k,currentPrice:b,executionPrice:w,priceImpact:x}}async swap({poolInfo:t,poolKeys:n,amountIn:o,amountOut:r,inputMint:i,fixedSide:s,txVersion:u,config:a,computeBudgetConfig:c,txTipConfig:l,feePayer:d}){let p=this.createTxBuilder(d),{associatedOnly:f=!0,inputUseSolBalance:y=!0,outputUseSolBalance:b=!0}=a||{},[g,P]=i===t.mintA.address?[t.mintA,t.mintB]:[t.mintB,t.mintA],h=y&&g.address===j.toBase58(),I=b&&P.address===j.toBase58(),{account:k,instructionParams:w}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:xn,mint:new je(g.address),owner:this.scope.ownerPubKey,createInfo:h?{payer:this.scope.ownerPubKey,amount:o}:void 0,skipCloseAccount:!h,notUseTokenAccount:h,associatedOnly:f});p.addInstruction(w||{}),k||this.logAndCreateError("input token account not found",{token:g.symbol||g.address,tokenAccountIn:k,inputTokenUseSolBalance:h,associatedOnly:f});let{account:S,instructionParams:x}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:xn,mint:new je(P.address),owner:this.scope.ownerPubKey,createInfo:{payer:this.scope.ownerPubKey,amount:0},skipCloseAccount:!I,notUseTokenAccount:I,associatedOnly:I?!1:f});p.addInstruction(x||{}),S===void 0&&this.logAndCreateError("output token account not found",{token:P.symbol||P.address,tokenAccountOut:S,outputTokenUseSolBalance:I,associatedOnly:f});let K=n||await this.getAmmPoolKeys(t.id),T=4;return t.pooltype.includes("StablePool")&&(T=5),p.addInstruction({instructions:[pr({version:T,poolKeys:K,userKeys:{tokenAccountIn:k,tokenAccountOut:S,owner:this.scope.ownerPubKey},amountIn:o,amountOut:r,fixedSide:s})],instructionTypes:[T===4?q.AmmV4SwapBaseIn:q.AmmV5SwapBaseIn]}),p.addCustomComputeBudget(c),p.addTipInstruction(l),p.versionBuild({txVersion:u})}async getRpcPoolInfo(t){return(await this.getRpcPoolInfos([t]))[t]}async getRpcPoolInfos(t,n){let o=await Re(this.scope.connection,t.map(c=>({pubkey:new je(c)})),n),r={},i=[];for(let c=0;c<t.length;c++){let l=o[c];if(l===null||!l.accountInfo)throw Error("fetch pool info error: "+String(t[c]));let d=ii.decode(l.accountInfo.data);r[String(t[c])]=W(N({},d),{programId:l.accountInfo.owner}),i.push(d.baseVault,d.quoteVault)}let s={},u=await Re(this.scope.connection,i.map(c=>({pubkey:new je(c)})),n);for(let c=0;c<i.length;c++){let l=u[c].accountInfo;if(l===null)throw Error("fetch vault info error: "+i[c]);s[String(i[c])]=new qe(xd.decode(l.data).amount.toString())}let a={};for(let[c,l]of Object.entries(r)){let d=s[l.baseVault.toString()].sub(l.baseNeedTakePnl),p=s[l.quoteVault.toString()].sub(l.quoteNeedTakePnl);a[c]=W(N({},l),{baseReserve:d,mintAAmount:s[l.baseVault.toString()],mintBAmount:s[l.quoteVault.toString()],quoteReserve:p,poolPrice:new Ce(p.toString()).div(new Ce(10).pow(l.quoteDecimal.toString())).div(new Ce(d.toString()).div(new Ce(10).pow(l.baseDecimal.toString())))})}return a}async getPoolInfoFromRpc({poolId:t}){let n=await this.getRpcPoolInfo(t),o=br({[t]:n}),r=o[t],i=await this.scope.tradeV2.computePoolToPoolKeys({pools:[o[t]],ammRpcData:{[t]:n}});return{poolRpcData:n,poolInfo:r,poolKeys:i[0]}}};import{PublicKey as z}from"@solana/web3.js";import bt from"bn.js";import jn from"decimal.js";import{AccountLayout as Ac,createAssociatedTokenAccountIdempotentInstruction as Pc,TOKEN_2022_PROGRAM_ID as Sn,TOKEN_PROGRAM_ID as li}from"@solana/spl-token";var mi=class extends Ne{constructor(e){super(e)}async getClmmPoolKeys(e){return(await this.scope.api.fetchPoolKeysById({idList:[e]}))[0]}async createPool(e){var S;let{programId:t,owner:n=((S=this.scope.owner)==null?void 0:S.publicKey)||z.default,mint1:o,mint2:r,ammConfig:i,initialPrice:s,computeBudgetConfig:u,forerunCreate:a,getObserveState:c,txVersion:l,txTipConfig:d,feePayer:p}=e,f=this.createTxBuilder(p),[y,b,g]=new bt(new z(o.address).toBuffer()).gt(new bt(new z(r.address).toBuffer()))?[r,o,new jn(1).div(s)]:[o,r,s],P=ie.priceToSqrtPriceX64(g,y.decimals,b.decimals),h=[],I=[];y.programId===Sn.toBase58()&&I.push(Es(t,new z(y.address)).publicKey),b.programId===Sn.toBase58()&&I.push(Es(t,new z(b.address)).publicKey),(await this.scope.connection.getMultipleAccountsInfo(I)).forEach((x,K)=>{x&&h.push(I[K])});let w=await Ke.createPoolInstructions({connection:this.scope.connection,programId:t,owner:n,mintA:y,mintB:b,ammConfigId:i.id,initialPriceX64:P,forerunCreate:!c&&a,extendMintAccount:h});return f.addInstruction(w),f.addCustomComputeBudget(u),f.addTipInstruction(d),f.versionBuild({txVersion:l,extInfo:{address:W(N({},w.address),{observationId:w.address.observationId.toBase58(),exBitmapAccount:w.address.exBitmapAccount.toBase58(),programId:t.toString(),id:w.address.poolId.toString(),mintA:y,mintB:b,openTime:"0",vault:{A:w.address.mintAVault.toString(),B:w.address.mintBVault.toString()},rewardInfos:[],config:{id:i.id.toString(),index:i.index,protocolFeeRate:i.protocolFeeRate,tradeFeeRate:i.tradeFeeRate,tickSpacing:i.tickSpacing,fundFeeRate:i.fundFeeRate,description:i.description,defaultRange:0,defaultRangePoint:[]}}),mockPoolInfo:N({type:"Concentrated",rewardDefaultPoolInfos:"Clmm",id:w.address.poolId.toString(),mintA:y,mintB:b,feeRate:i.tradeFeeRate,openTime:"0",programId:t.toString(),price:g.toNumber(),config:{id:i.id.toString(),index:i.index,protocolFeeRate:i.protocolFeeRate,tradeFeeRate:i.tradeFeeRate,tickSpacing:i.tickSpacing,fundFeeRate:i.fundFeeRate,description:i.description,defaultRange:0,defaultRangePoint:[]},burnPercent:0},Du),forerunCreate:a}})}async openPositionFromBase({poolInfo:e,poolKeys:t,ownerInfo:n,tickLower:o,tickUpper:r,base:i,baseAmount:s,otherAmountMax:u,nft2022:a,associatedOnly:c=!0,checkCreateATAOwner:l=!1,withMetadata:d="create",getEphemeralSigners:p,computeBudgetConfig:f,txTipConfig:y,txVersion:b,feePayer:g}){this.scope.availability.addConcentratedPosition===!1&&this.logAndCreateError("add position feature disabled in your region"),this.scope.checkOwner();let P=this.createTxBuilder(g),h=null,I=null,k=n.useSOLBalance&&e.mintA.address===j.toString(),w=n.useSOLBalance&&e.mintB.address===j.toString(),[S,x]=i==="MintA"?[s,u]:[u,s],{account:K,instructionParams:T}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:e.mintA.programId,mint:new z(e.mintA.address),owner:this.scope.ownerPubKey,createInfo:k||S.isZero()?{payer:this.scope.ownerPubKey,amount:S}:void 0,skipCloseAccount:!k,notUseTokenAccount:k,associatedOnly:k?!1:c,checkCreateATAOwner:l});K&&(h=K),P.addInstruction(T||{});let{account:C,instructionParams:M}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:e.mintB.programId,mint:new z(e.mintB.address),owner:this.scope.ownerPubKey,createInfo:w||x.isZero()?{payer:this.scope.ownerPubKey,amount:x}:void 0,skipCloseAccount:!w,notUseTokenAccount:w,associatedOnly:w?!1:c,checkCreateATAOwner:l});C&&(I=C),P.addInstruction(M||{}),(!h||!I)&&this.logAndCreateError("cannot found target token accounts","tokenAccounts",{ownerTokenAccountA:h==null?void 0:h.toBase58(),ownerTokenAccountB:I==null?void 0:I.toBase58()});let v=t||await this.getClmmPoolKeys(e.id),R=await Ke.openPositionFromBaseInstructions({poolInfo:e,poolKeys:v,ownerInfo:W(N({},n),{feePayer:this.scope.ownerPubKey,wallet:this.scope.ownerPubKey,tokenAccountA:h,tokenAccountB:I}),tickLower:o,tickUpper:r,base:i,baseAmount:s,otherAmountMax:u,withMetadata:d,getEphemeralSigners:p,nft2022:a});return P.addInstruction(R),P.addCustomComputeBudget(f),P.addTipInstruction(y),P.versionBuild({txVersion:b,extInfo:N({},R.address)})}async openPositionFromLiquidity({poolInfo:e,poolKeys:t,ownerInfo:n,amountMaxA:o,amountMaxB:r,tickLower:i,tickUpper:s,liquidity:u,associatedOnly:a=!0,checkCreateATAOwner:c=!1,withMetadata:l="create",txVersion:d,computeBudgetConfig:p,txTipConfig:f,getEphemeralSigners:y,nft2022:b,feePayer:g}){this.scope.availability.createConcentratedPosition===!1&&this.logAndCreateError("open position feature disabled in your region");let P=this.createTxBuilder(g),h=null,I=null,k=n.useSOLBalance&&e.mintA.address===j.toBase58(),w=n.useSOLBalance&&e.mintB.address===j.toBase58(),{account:S,instructionParams:x}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:e.mintA.programId,mint:new z(e.mintA.address),owner:this.scope.ownerPubKey,createInfo:k||o.isZero()?{payer:this.scope.ownerPubKey,amount:o}:void 0,skipCloseAccount:!k,notUseTokenAccount:k,associatedOnly:k?!1:a,checkCreateATAOwner:c});S&&(h=S),P.addInstruction(x||{});let{account:K,instructionParams:T}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:e.mintB.programId,mint:new z(e.mintB.address),owner:this.scope.ownerPubKey,createInfo:w||r.isZero()?{payer:this.scope.ownerPubKey,amount:r}:void 0,skipCloseAccount:!w,notUseTokenAccount:w,associatedOnly:w?!1:a,checkCreateATAOwner:c});K&&(I=K),P.addInstruction(T||{}),(h===void 0||I===void 0)&&this.logAndCreateError("cannot found target token accounts","tokenAccounts",this.scope.account.tokenAccounts);let C=t||await this.getClmmPoolKeys(e.id),M=await Ke.openPositionFromLiquidityInstructions({poolInfo:e,poolKeys:C,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccountA:h,tokenAccountB:I},tickLower:i,tickUpper:s,liquidity:u,amountMaxA:o,amountMaxB:r,withMetadata:l,getEphemeralSigners:y,nft2022:b});return P.addInstruction(M),P.addCustomComputeBudget(p),P.addTipInstruction(f),P.versionBuild({txVersion:d,extInfo:{address:M.address}})}async increasePositionFromLiquidity(e){var T;let{poolInfo:t,poolKeys:n,ownerPosition:o,amountMaxA:r,amountMaxB:i,liquidity:s,ownerInfo:u,associatedOnly:a=!0,checkCreateATAOwner:c=!1,computeBudgetConfig:l,txTipConfig:d,txVersion:p,feePayer:f}=e,y=this.createTxBuilder(f),b,g,P=u.useSOLBalance&&t.mintA.address===j.toString(),h=u.useSOLBalance&&t.mintB.address===j.toString(),{account:I,instructionParams:k}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:t.mintA.programId,mint:new z(t.mintA.address),notUseTokenAccount:P,owner:this.scope.ownerPubKey,createInfo:P||r.isZero()?{payer:this.scope.ownerPubKey,amount:r}:void 0,skipCloseAccount:!P,associatedOnly:P?!1:a,checkCreateATAOwner:c});I&&(b=I),y.addInstruction(k||{});let{account:w,instructionParams:S}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:t.mintB.programId,mint:new z(t.mintB.address),owner:this.scope.ownerPubKey,createInfo:h||i.isZero()?{payer:this.scope.ownerPubKey,amount:i}:void 0,notUseTokenAccount:h,skipCloseAccount:!h,associatedOnly:h?!1:a,checkCreateATAOwner:c});w&&(g=w),y.addInstruction(S||{}),!b&&!g&&this.logAndCreateError("cannot found target token accounts","tokenAccounts",this.scope.account.tokenAccounts);let x=n!=null?n:await this.getClmmPoolKeys(t.id),K=Ke.increasePositionFromLiquidityInstructions({poolInfo:t,poolKeys:x,ownerPosition:o,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccountA:b,tokenAccountB:g},liquidity:s,amountMaxA:r,amountMaxB:i,nft2022:(T=await this.scope.connection.getAccountInfo(o.nftMint))==null?void 0:T.owner.equals(Sn)});return y.addInstruction(K),y.addCustomComputeBudget(l),y.addTipInstruction(d),y.versionBuild({txVersion:p,extInfo:{address:K.address}})}async increasePositionFromBase(e){var K;let{poolInfo:t,ownerPosition:n,base:o,baseAmount:r,otherAmountMax:i,ownerInfo:s,associatedOnly:u=!0,checkCreateATAOwner:a=!1,computeBudgetConfig:c,txTipConfig:l,txVersion:d,feePayer:p}=e,f=this.createTxBuilder(p),y,b,g=s.useSOLBalance&&t.mintA.address===j.toString(),P=s.useSOLBalance&&t.mintB.address===j.toString(),{account:h,instructionParams:I}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:t.mintA.programId,mint:new z(t.mintA.address),notUseTokenAccount:g,owner:this.scope.ownerPubKey,createInfo:g||(o==="MintA"?r:i).isZero()?{payer:this.scope.ownerPubKey,amount:o==="MintA"?r:i}:void 0,skipCloseAccount:!g,associatedOnly:g?!1:u,checkCreateATAOwner:a});h&&(y=h),f.addInstruction(I||{});let{account:k,instructionParams:w}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:t.mintB.programId,mint:new z(t.mintB.address),owner:this.scope.ownerPubKey,createInfo:P||(o==="MintA"?i:r).isZero()?{payer:this.scope.ownerPubKey,amount:o==="MintA"?i:r}:void 0,notUseTokenAccount:P,skipCloseAccount:!P,associatedOnly:P?!1:u,checkCreateATAOwner:a});k&&(b=k),f.addInstruction(w||{}),!y&&!b&&this.logAndCreateError("cannot found target token accounts","tokenAccounts",this.scope.account.tokenAccounts);let S=await this.getClmmPoolKeys(t.id),x=Ke.increasePositionFromBaseInstructions({poolInfo:t,poolKeys:S,ownerPosition:n,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccountA:y,tokenAccountB:b},base:o,baseAmount:r,otherAmountMax:i,nft2022:(K=await this.scope.connection.getAccountInfo(n.nftMint))==null?void 0:K.owner.equals(Sn)});return f.addInstruction(x),f.addCustomComputeBudget(c),f.addTipInstruction(l),f.versionBuild({txVersion:d,extInfo:{address:x.address}})}async decreaseLiquidity(e){var v;let{poolInfo:t,poolKeys:n,ownerPosition:o,ownerInfo:r,amountMinA:i,amountMinB:s,liquidity:u,associatedOnly:a=!0,checkCreateATAOwner:c=!1,computeBudgetConfig:l,txTipConfig:d,txVersion:p,feePayer:f}=e;this.scope.availability.removeConcentratedPosition===!1&&this.logAndCreateError("remove position feature disabled in your region");let y=this.createTxBuilder(f),b=r.useSOLBalance&&t.mintA.address===j.toString(),g=r.useSOLBalance&&t.mintB.address===j.toString(),P,h,{account:I,instructionParams:k}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:t.mintA.programId,mint:new z(t.mintA.address),notUseTokenAccount:b,owner:this.scope.ownerPubKey,createInfo:{payer:this.scope.ownerPubKey,amount:0},skipCloseAccount:!b,associatedOnly:b?!1:a,checkCreateATAOwner:c});P=I,k&&y.addInstruction(k);let{account:w,instructionParams:S}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:t.mintB.programId,mint:new z(t.mintB.address),notUseTokenAccount:g,owner:this.scope.ownerPubKey,createInfo:{payer:this.scope.ownerPubKey,amount:0},skipCloseAccount:!g,associatedOnly:g?!1:a,checkCreateATAOwner:c});h=w,S&&y.addInstruction(S);let x=[];for(let R of t.rewardDefaultInfos){let L=r.useSOLBalance&&R.mint.address===j.toString(),F;if(R.mint.address===t.mintA.address)F=P;else if(R.mint.address===t.mintB.address)F=h;else{let{account:X,instructionParams:H}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:new z(R.mint.programId),mint:new z(R.mint.address),notUseTokenAccount:L,owner:this.scope.ownerPubKey,createInfo:{payer:this.scope.ownerPubKey,amount:0},skipCloseAccount:!L,associatedOnly:L?!1:a,checkCreateATAOwner:c});F=X,H&&y.addInstruction(H)}x.push(F)}!P&&!h&&this.logAndCreateError("cannot found target token accounts","tokenAccounts",this.scope.account.tokenAccountRawInfos);let K=n!=null?n:await this.getClmmPoolKeys(t.id),T=(v=await this.scope.connection.getAccountInfo(o.nftMint))==null?void 0:v.owner.equals(Sn),C=await Ke.decreaseLiquidityInstructions({poolInfo:t,poolKeys:K,ownerPosition:o,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccountA:P,tokenAccountB:h,rewardAccounts:x},liquidity:u,amountMinA:i,amountMinB:s,nft2022:T});y.addInstruction({instructions:C.instructions,instructionTypes:[q.ClmmDecreasePosition]});let M=N({},C.address);if(r.closePosition){let R=await Ke.closePositionInstructions({poolInfo:t,poolKeys:K,ownerInfo:{wallet:this.scope.ownerPubKey},ownerPosition:o,nft2022:T});y.addInstruction({endInstructions:R.instructions,endInstructionTypes:R.instructionTypes}),M=N(N({},M),R.address)}return y.addCustomComputeBudget(l),y.addTipInstruction(d),y.versionBuild({txVersion:p,extInfo:{address:M}})}async lockPosition(e){var f;let{programId:t=vo,authProgramId:n=Di,poolProgramId:o=Mn,ownerPosition:r,payer:i,computeBudgetConfig:s,txTipConfig:u,txVersion:a,getEphemeralSigners:c,feePayer:l}=e,d=this.createTxBuilder(l),p=await Ke.makeLockPositions({programId:t,authProgramId:n,poolProgramId:o,wallet:this.scope.ownerPubKey,payer:i!=null?i:this.scope.ownerPubKey,nftMint:r.nftMint,getEphemeralSigners:c,nft2022:(f=await this.scope.connection.getAccountInfo(r.nftMint))==null?void 0:f.owner.equals(Sn)});return d.addInstruction(p),d.addCustomComputeBudget(s),d.addTipInstruction(u),d.versionBuild({txVersion:a,extInfo:p.address})}async harvestLockPosition(e){let{programId:t=vo,authProgramId:n=Di,clmmProgram:o=Mn,poolKeys:r,lockData:i,ownerInfo:s={useSOLBalance:!0},associatedOnly:u=!0,checkCreateATAOwner:a=!1,computeBudgetConfig:c,txTipConfig:l,txVersion:d,feePayer:p}=e,f=r||await this.getClmmPoolKeys(i.poolId.toString()),y=this.createTxBuilder(p),b=await this.scope.connection.getAccountInfo(i.positionId);b||this.logger.logWithError("position not found",i.positionId);let g=yo.decode(b.data),P=s.useSOLBalance&&f.mintA.address===j.toString(),h=s.useSOLBalance&&f.mintB.address===j.toString(),I,k,{account:w,instructionParams:S}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:f.mintA.programId,mint:new z(f.mintA.address),notUseTokenAccount:P,owner:this.scope.ownerPubKey,createInfo:{payer:this.scope.ownerPubKey,amount:0},skipCloseAccount:!P,associatedOnly:P?!1:u,checkCreateATAOwner:a});I=w,S&&y.addInstruction(S);let{account:x,instructionParams:K}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:f.mintB.programId,mint:new z(f.mintB.address),notUseTokenAccount:h,owner:this.scope.ownerPubKey,createInfo:{payer:this.scope.ownerPubKey,amount:0},skipCloseAccount:!h,associatedOnly:h?!1:u,checkCreateATAOwner:a});k=x,K&&y.addInstruction(K);let T={},C=[];for(let ue of f.rewardInfos){let me=s.useSOLBalance&&ue.mint.address===j.toString(),pe=T[ue.mint.address];if(!pe){let{account:ce,instructionParams:Z}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:new z(ue.mint.programId),mint:new z(ue.mint.address),notUseTokenAccount:me,owner:this.scope.ownerPubKey,skipCloseAccount:!me,createInfo:{payer:this.scope.ownerPubKey,amount:0},associatedOnly:me?!1:u});pe=ce,Z&&y.addInstruction(Z)}T[ue.mint.address]=pe,C.push(pe)}let M=fo(t,i.lockNftMint).publicKey,v=J(this.scope.ownerPubKey,i.lockNftMint,li).publicKey,R=Y.getTickArrayStartIndexByTick(g.tickLower,f.config.tickSpacing),L=Y.getTickArrayStartIndexByTick(g.tickUpper,f.config.tickSpacing),{publicKey:F}=be(new z(f.programId),i.poolId,R),{publicKey:X}=be(new z(f.programId),i.poolId,L),{publicKey:H}=Zt(new z(f.programId),i.poolId,g.tickLower,g.tickUpper),re=[];for(let ue=0;ue<f.rewardInfos.length;ue++)re.push({poolRewardVault:new z(f.rewardInfos[ue].vault),ownerRewardVault:C[ue],rewardMint:new z(f.rewardInfos[ue].mint.address)});let ye=await Ke.harvestLockPositionInstructionV2({programId:t,auth:n,lockPositionId:M,clmmProgram:o,lockOwner:this.scope.ownerPubKey,lockNftMint:i.lockNftMint,lockNftAccount:v,positionNftAccount:i.nftAccount,positionId:i.positionId,poolId:i.poolId,protocolPosition:H,vaultA:new z(f.vault.A),vaultB:new z(f.vault.B),tickArrayLower:F,tickArrayUpper:X,userVaultA:I,userVaultB:k,mintA:new z(f.mintA.address),mintB:new z(f.mintB.address),rewardAccounts:re,exTickArrayBitmap:Xe(o,i.poolId).publicKey});return y.addInstruction({instructions:[ye],instructionTypes:[q.ClmmHarvestLockPosition]}),y.addCustomComputeBudget(c),y.addTipInstruction(l),y.versionBuild({txVersion:d})}async closePosition({poolInfo:e,poolKeys:t,ownerPosition:n,txVersion:o,computeBudgetConfig:r,txTipConfig:i,feePayer:s}){var l;this.scope.availability.removeConcentratedPosition===!1&&this.logAndCreateError("remove position feature disabled in your region");let u=this.createTxBuilder(s),a=t!=null?t:await this.getClmmPoolKeys(e.id),c=Ke.closePositionInstructions({poolInfo:e,poolKeys:a,ownerInfo:{wallet:this.scope.ownerPubKey},ownerPosition:n,nft2022:(l=await this.scope.connection.getAccountInfo(n.nftMint))==null?void 0:l.owner.equals(Sn)});return u.addCustomComputeBudget(r),u.addTipInstruction(i),u.addInstruction(c).versionBuild({txVersion:o,extInfo:{address:c.address}})}async initReward({poolInfo:e,ownerInfo:t,rewardInfo:n,associatedOnly:o=!0,checkCreateATAOwner:r=!1,computeBudgetConfig:i,txVersion:s,feePayer:u}){n.endTime<=n.openTime&&this.logAndCreateError("reward time error","rewardInfo",n);let a=this.createTxBuilder(u),c=t.useSOLBalance&&n.mint.address.toString()===j.toString(),l=n.perSecond.mul(n.endTime-n.openTime),{account:d,instructionParams:p}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:new z(n.mint.address),mint:new z(n.mint.address),notUseTokenAccount:!!c,skipCloseAccount:!c,owner:this.scope.ownerPubKey,createInfo:c?{payer:t.feePayer||this.scope.ownerPubKey,amount:new bt(new jn(l.toFixed(0)).gte(l)?l.toFixed(0):l.add(1).toFixed(0))}:void 0,associatedOnly:c?!1:o,checkCreateATAOwner:r});p&&a.addInstruction(p),d||this.logAndCreateError("no money","ownerRewardAccount",this.scope.account.tokenAccountRawInfos);let f=await this.getClmmPoolKeys(e.id),y=Ke.initRewardInstructions({poolInfo:e,poolKeys:f,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccount:d},rewardInfo:{programId:new z(n.mint.programId),mint:new z(n.mint.address),openTime:n.openTime,endTime:n.endTime,emissionsPerSecondX64:ae.decimalToX64(n.perSecond)}});return a.addInstruction(y),a.addCustomComputeBudget(i),a.versionBuild({txVersion:s,extInfo:{address:y.address}})}async initRewards({poolInfo:e,poolKeys:t,ownerInfo:n,rewardInfos:o,associatedOnly:r=!0,checkCreateATAOwner:i=!1,computeBudgetConfig:s,txTipConfig:u,txVersion:a,feePayer:c}){for(let p of o)p.endTime<=p.openTime&&this.logAndCreateError("reward time error","rewardInfo",p);let l=this.createTxBuilder(c),d={};for(let p of o){let f=n.useSOLBalance&&p.mint.address===j.toString(),y=p.perSecond.mul(p.endTime-p.openTime),{account:b,instructionParams:g}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:new z(p.mint.programId),mint:new z(p.mint.address),notUseTokenAccount:!!f,skipCloseAccount:!f,owner:this.scope.ownerPubKey,createInfo:f?{payer:n.feePayer||this.scope.ownerPubKey,amount:new bt(new jn(y.toFixed(0)).gte(y)?y.toFixed(0):y.add(1).toFixed(0))}:void 0,associatedOnly:f?!1:r,checkCreateATAOwner:i});g&&l.addInstruction(g),b||this.logAndCreateError("no money","ownerRewardAccount",this.scope.account.tokenAccountRawInfos);let P=t!=null?t:await this.getClmmPoolKeys(e.id),h=Ke.initRewardInstructions({poolInfo:e,poolKeys:P,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccount:b},rewardInfo:{programId:new z(p.mint.programId),mint:new z(p.mint.address),openTime:p.openTime,endTime:p.endTime,emissionsPerSecondX64:ae.decimalToX64(p.perSecond)}});d=N(N({},d),h.address),l.addInstruction(h)}return l.addCustomComputeBudget(s),l.addTipInstruction(u),l.versionBuild({txVersion:a,extInfo:{address:d}})}async setReward({poolInfo:e,ownerInfo:t,rewardInfo:n,associatedOnly:o=!0,checkCreateATAOwner:r=!1,computeBudgetConfig:i,txTipConfig:s,txVersion:u,feePayer:a}){n.endTime<=n.openTime&&this.logAndCreateError("reward time error","rewardInfo",n);let c=this.createTxBuilder(a),l=t.useSOLBalance&&n.mint.equals(j),{account:d,instructionParams:p}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:n.programId,mint:n.mint,notUseTokenAccount:l,owner:this.scope.ownerPubKey,createInfo:l?{payer:t.feePayer||this.scope.ownerPubKey,amount:new bt(new jn(n.perSecond.mul(n.endTime-n.openTime).toFixed(0)).gte(n.perSecond.mul(n.endTime-n.openTime))?n.perSecond.mul(n.endTime-n.openTime).toFixed(0):n.perSecond.mul(n.endTime-n.openTime).add(1).toFixed(0))}:void 0,associatedOnly:l?!1:o,checkCreateATAOwner:r});p&&c.addInstruction(p),d||this.logAndCreateError("no money","ownerRewardAccount",this.scope.account.tokenAccountRawInfos);let f=await this.getClmmPoolKeys(e.id),y=Ke.setRewardInstructions({poolInfo:e,poolKeys:f,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccount:d},rewardInfo:{mint:n.mint,openTime:n.openTime,endTime:n.endTime,emissionsPerSecondX64:ae.decimalToX64(n.perSecond)}});return c.addInstruction(y),c.addCustomComputeBudget(i),c.addTipInstruction(s),c.versionBuild({txVersion:u,extInfo:{address:y.address}})}async setRewards({poolInfo:e,poolKeys:t,ownerInfo:n,rewardInfos:o,associatedOnly:r=!0,checkCreateATAOwner:i=!1,computeBudgetConfig:s,txTipConfig:u,txVersion:a,feePayer:c}){let l=this.createTxBuilder(c),d={};for(let p of o){p.endTime<=p.openTime&&this.logAndCreateError("reward time error","rewardInfo",p);let f=n.useSOLBalance&&p.mint.address===j.toString(),{account:y,instructionParams:b}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:new z(p.mint.programId),mint:new z(p.mint.address),notUseTokenAccount:f,owner:this.scope.ownerPubKey,createInfo:f?{payer:n.feePayer||this.scope.ownerPubKey,amount:new bt(new jn(p.perSecond.mul(p.endTime-p.openTime).toFixed(0)).gte(p.perSecond.mul(p.endTime-p.openTime))?p.perSecond.mul(p.endTime-p.openTime).toFixed(0):p.perSecond.mul(p.endTime-p.openTime).add(1).toFixed(0))}:void 0,associatedOnly:f?!1:r,checkCreateATAOwner:i});b&&l.addInstruction(b),y||this.logAndCreateError("no money","ownerRewardAccount",this.scope.account.tokenAccountRawInfos);let g=t!=null?t:await this.getClmmPoolKeys(e.id),P=Ke.setRewardInstructions({poolInfo:e,poolKeys:g,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccount:y},rewardInfo:{mint:new z(p.mint.address),openTime:p.openTime,endTime:p.endTime,emissionsPerSecondX64:ae.decimalToX64(p.perSecond)}});l.addInstruction(P),d=N(N({},d),P.address)}return l.addCustomComputeBudget(s),l.addTipInstruction(u),l.versionBuild({txVersion:a,extInfo:{address:d}})}async collectReward({poolInfo:e,ownerInfo:t,rewardMint:n,associatedOnly:o=!0,checkCreateATAOwner:r=!1,computeBudgetConfig:i,txTipConfig:s,txVersion:u,feePayer:a}){let c=e.rewardDefaultInfos.find(g=>g.mint.address===n.toString());c||this.logAndCreateError("reward mint error","not found reward mint",n);let l=this.createTxBuilder(a),d=t.useSOLBalance&&n.equals(j),{account:p,instructionParams:f}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:new z(c.mint.programId),mint:n,notUseTokenAccount:d,owner:this.scope.ownerPubKey,skipCloseAccount:!d,createInfo:{payer:t.feePayer||this.scope.ownerPubKey,amount:0},associatedOnly:d?!1:o,checkCreateATAOwner:r});f&&l.addInstruction(f),p||this.logAndCreateError("no money","ownerRewardAccount",this.scope.account.tokenAccountRawInfos);let y=await this.getClmmPoolKeys(e.id),b=Ke.collectRewardInstructions({poolInfo:e,poolKeys:y,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccount:p},rewardMint:n});return l.addInstruction(b),l.addCustomComputeBudget(i),l.addTipInstruction(s),l.versionBuild({txVersion:u,extInfo:{address:b.address}})}async collectRewards({poolInfo:e,ownerInfo:t,rewardMints:n,associatedOnly:o=!0,checkCreateATAOwner:r=!1,computeBudgetConfig:i,txTipConfig:s,feePayer:u}){let a=this.createTxBuilder(u),c={};for(let l of n){let d=e.rewardDefaultInfos.find(P=>P.mint.address===l.toString());if(!d){this.logAndCreateError("reward mint error","not found reward mint",l);continue}let p=t.useSOLBalance&&l.equals(j),{account:f,instructionParams:y}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:new z(d.mint.programId),mint:l,notUseTokenAccount:p,owner:this.scope.ownerPubKey,skipCloseAccount:!p,createInfo:{payer:t.feePayer||this.scope.ownerPubKey,amount:0},associatedOnly:p?!1:o,checkCreateATAOwner:r});f||this.logAndCreateError("no money","ownerRewardAccount",this.scope.account.tokenAccountRawInfos),y&&a.addInstruction(y);let b=await this.getClmmPoolKeys(e.id),g=Ke.collectRewardInstructions({poolInfo:e,poolKeys:b,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccount:f},rewardMint:l});a.addInstruction(g),c=N(N({},c),g.address)}return a.addCustomComputeBudget(i),a.addTipInstruction(s),a.build({address:c})}async swap({poolInfo:e,poolKeys:t,inputMint:n,amountIn:o,amountOutMin:r,priceLimit:i,observationId:s,ownerInfo:u,remainingAccounts:a,associatedOnly:c=!0,checkCreateATAOwner:l=!1,txVersion:d,computeBudgetConfig:p,txTipConfig:f,feePayer:y}){let b=this.createTxBuilder(y),g=n.toString()===e.mintA.address,P=u.useSOLBalance&&e.mintA.address===j.toBase58(),h=u.useSOLBalance&&e.mintB.address===j.toBase58(),I;!i||i.equals(new jn(0))?I=g?_t.add(new bt(1)):Ft.sub(new bt(1)):I=ie.priceToSqrtPriceX64(i,e.mintA.decimals,e.mintB.decimals);let k;if(!k){let{account:x,instructionParams:K}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:e.mintA.programId,mint:new z(e.mintA.address),notUseTokenAccount:P,owner:this.scope.ownerPubKey,skipCloseAccount:!P,createInfo:P||!g?{payer:u.feePayer||this.scope.ownerPubKey,amount:g?o:0}:void 0,associatedOnly:P?!1:c,checkCreateATAOwner:l});k=x,K&&b.addInstruction(K)}let w;if(!w){let{account:x,instructionParams:K}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:e.mintB.programId,mint:new z(e.mintB.address),notUseTokenAccount:h,owner:this.scope.ownerPubKey,skipCloseAccount:!h,createInfo:h||g?{payer:u.feePayer||this.scope.ownerPubKey,amount:g?0:o}:void 0,associatedOnly:h?!1:c,checkCreateATAOwner:l});w=x,K&&b.addInstruction(K)}(!k||!w)&&this.logAndCreateError("user do not have token account",{tokenA:e.mintA.symbol||e.mintA.address,tokenB:e.mintB.symbol||e.mintB.address,ownerTokenAccountA:k,ownerTokenAccountB:w,mintAUseSOLBalance:P,mintBUseSOLBalance:h,associatedOnly:c});let S=t!=null?t:await this.getClmmPoolKeys(e.id);return b.addInstruction(Ke.makeSwapBaseInInstructions({poolInfo:e,poolKeys:S,observationId:s,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccountA:k,tokenAccountB:w},inputMint:new z(n),amountIn:o,amountOutMin:r,sqrtPriceLimitX64:I,remainingAccounts:a})),b.addCustomComputeBudget(p),b.addTipInstruction(f),b.versionBuild({txVersion:d})}async swapBaseOut({poolInfo:e,poolKeys:t,outputMint:n,amountOut:o,amountInMax:r,priceLimit:i,observationId:s,ownerInfo:u,remainingAccounts:a,associatedOnly:c=!0,checkCreateATAOwner:l=!1,txVersion:d,computeBudgetConfig:p,txTipConfig:f,feePayer:y}){let b=this.createTxBuilder(y),g=n.toString()===e.mintB.address,P=u.useSOLBalance&&e.mintA.address===j.toBase58(),h=u.useSOLBalance&&e.mintB.address===j.toBase58(),I;!i||i.equals(new jn(0))?I=n.toString()===e.mintB.address?_t.add(new bt(1)):Ft.sub(new bt(1)):I=ie.priceToSqrtPriceX64(i,e.mintA.decimals,e.mintB.decimals);let k;if(!k){let{account:x,instructionParams:K}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:e.mintA.programId,mint:new z(e.mintA.address),notUseTokenAccount:P,owner:this.scope.ownerPubKey,skipCloseAccount:!P,createInfo:P||!g?{payer:u.feePayer||this.scope.ownerPubKey,amount:g?r:0}:void 0,associatedOnly:P?!1:c,checkCreateATAOwner:l});k=x,K&&b.addInstruction(K)}let w;if(!w){let{account:x,instructionParams:K}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:e.mintB.programId,mint:new z(e.mintB.address),notUseTokenAccount:h,owner:this.scope.ownerPubKey,skipCloseAccount:!h,createInfo:h||g?{payer:u.feePayer||this.scope.ownerPubKey,amount:g?0:r}:void 0,associatedOnly:h?!1:c,checkCreateATAOwner:l});w=x,K&&b.addInstruction(K)}(!k||!w)&&this.logAndCreateError("user do not have token account",{tokenA:e.mintA.symbol||e.mintA.address,tokenB:e.mintB.symbol||e.mintB.address,ownerTokenAccountA:k,ownerTokenAccountB:w,mintAUseSOLBalance:P,mintBUseSOLBalance:h,associatedOnly:c});let S=t!=null?t:await this.getClmmPoolKeys(e.id);return b.addInstruction(Ke.makeSwapBaseOutInstructions({poolInfo:e,poolKeys:S,observationId:s,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccountA:k,tokenAccountB:w},outputMint:new z(n),amountOut:o,amountInMax:r,sqrtPriceLimitX64:I,remainingAccounts:a})),b.addCustomComputeBudget(p),b.addTipInstruction(f),b.versionBuild({txVersion:d})}async harvestAllRewards({allPoolInfo:e,allPositions:t,lockInfo:n,ownerInfo:o,associatedOnly:r=!0,checkCreateATAOwner:i=!1,programId:s,txVersion:u,computeBudgetConfig:a,feePayer:c,lockProgram:l=vo,lockAuth:d=Di,clmmProgram:p=Mn}){var h,I;let f={};for(let k of this.scope.account.tokenAccountRawInfos)r?J(this.scope.ownerPubKey,k.accountInfo.mint,s).publicKey.equals(k.pubkey)&&(f[k.accountInfo.mint.toString()]=k.pubkey):f[k.accountInfo.mint.toString()]=k.pubkey;let y=Object.values(t).flat().map(k=>k.nftMint),b=await Re(this.scope.connection,y.map(k=>({pubkey:k}))),g={};b.forEach(k=>{var w,S;g[k.pubkey.toBase58()]=(S=(w=k==null?void 0:k.accountInfo)==null?void 0:w.owner)!=null?S:null});let P=this.createTxBuilder(c);for(let k of Object.values(e)){if(t[k.id]===void 0||!t[k.id].find(R=>!R.liquidity.isZero()||R.rewardInfos.find(L=>!L.rewardAmountOwed.isZero())))continue;let w=k,S=o.useSOLBalance&&w.mintA.address===j.toString(),x=o.useSOLBalance&&w.mintB.address===j.toString(),K=f[w.mintA.address];if(!K)if(S){let{account:R,instructionParams:L}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:w.mintA.programId,mint:new z(w.mintA.address),notUseTokenAccount:S,owner:this.scope.ownerPubKey,skipCloseAccount:!S,createInfo:{payer:o.feePayer||this.scope.ownerPubKey,amount:0},associatedOnly:S?!1:r,checkCreateATAOwner:i});K=R,L&&P.addInstruction(L)}else{let R=new z(w.mintA.address);K=this.scope.account.getAssociatedTokenAccount(R,new z(w.mintA.programId)),P.addInstruction({instructions:[Pc(this.scope.ownerPubKey,K,this.scope.ownerPubKey,R,new z(w.mintA.programId))]})}let T=f[w.mintB.address];if(!T)if(x){let{account:R,instructionParams:L}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:w.mintB.programId,mint:new z(w.mintB.address),notUseTokenAccount:x,owner:this.scope.ownerPubKey,skipCloseAccount:!x,createInfo:{payer:o.feePayer||this.scope.ownerPubKey,amount:0},associatedOnly:x?!1:r,checkCreateATAOwner:i});T=R,L&&P.addInstruction(L)}else{let R=new z(w.mintB.address);T=this.scope.account.getAssociatedTokenAccount(R,new z(w.mintB.programId)),P.addInstruction({instructions:[Pc(this.scope.ownerPubKey,T,this.scope.ownerPubKey,R,new z(w.mintB.programId))]})}f[w.mintA.address]=K,f[w.mintB.address]=T;let C=[];for(let R of w.rewardDefaultInfos){let L=o.useSOLBalance&&R.mint.address===j.toString(),F=f[R.mint.address];if(!F){let{account:X,instructionParams:H}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:new z(R.mint.programId),mint:new z(R.mint.address),notUseTokenAccount:L,owner:this.scope.ownerPubKey,skipCloseAccount:!L,createInfo:{payer:o.feePayer||this.scope.ownerPubKey,amount:0},associatedOnly:L?!1:r});F=X,H&&P.addInstruction(H)}f[R.mint.address]=F,C.push(F)}let M=await this.getClmmPoolKeys(w.id),v=[];for(let R=0;R<M.rewardInfos.length;R++)v.push({poolRewardVault:new z(M.rewardInfos[R].vault),ownerRewardVault:C[R],rewardMint:new z(M.rewardInfos[R].mint.address)});for(let R of t[k.id]){let L=(h=n==null?void 0:n[k.id])==null?void 0:h[R.nftMint.toBase58()];if(L){let F=J(this.scope.ownerPubKey,L.lockNftMint,li).publicKey,X=Y.getTickArrayStartIndexByTick(R.tickLower,M.config.tickSpacing),H=Y.getTickArrayStartIndexByTick(R.tickUpper,M.config.tickSpacing),{publicKey:re}=be(new z(M.programId),L.poolId,X),{publicKey:ye}=be(new z(M.programId),L.poolId,H),{publicKey:ue}=Zt(new z(M.programId),L.poolId,R.tickLower,R.tickUpper),me=fo(l,L.lockNftMint).publicKey,pe=Ke.harvestLockPositionInstructionV2({programId:l,auth:d,lockPositionId:me,clmmProgram:p,lockOwner:this.scope.ownerPubKey,lockNftMint:L.lockNftMint,lockNftAccount:F,positionNftAccount:L.nftAccount,positionId:L.positionId,poolId:L.poolId,protocolPosition:ue,vaultA:new z(M.vault.A),vaultB:new z(M.vault.B),tickArrayLower:re,tickArrayUpper:ye,userVaultA:K,userVaultB:T,mintA:new z(M.mintA.address),mintB:new z(M.mintB.address),rewardAccounts:v,exTickArrayBitmap:Xe(p,L.poolId).publicKey});P.addInstruction({instructions:[pe],instructionTypes:[q.ClmmHarvestLockPosition],lookupTableAddress:M.lookupTableAccount?[M.lookupTableAccount]:[]})}else{let F=Ke.decreaseLiquidityInstructions({poolInfo:w,poolKeys:M,ownerPosition:R,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccountA:K,tokenAccountB:T,rewardAccounts:C},liquidity:new bt(0),amountMinA:new bt(0),amountMinB:new bt(0),nft2022:(I=g[R.nftMint.toBase58()])==null?void 0:I.equals(Sn)});P.addInstruction(F)}}}return u===0?P.sizeCheckBuildV0({computeBudgetConfig:a}):P.sizeCheckBuild({computeBudgetConfig:a})}async getWhiteListMint({programId:e}){let t=await this.scope.connection.getAccountInfo($o(e).publicKey);return t?Ju.decode(t.data).whitelistMints.filter(o=>!o.equals(z.default)):[]}async getOwnerPositionInfo({programId:e=Mn}){await this.scope.account.fetchWalletTokenAccounts();let n=this.scope.account.tokenAccountRawInfos.filter(i=>i.accountInfo.amount.eq(new bt(1))).map(i=>yt(new z(e),i.accountInfo.mint).publicKey),o=await this.scope.connection.getMultipleAccountsInfo(n),r=[];return o.forEach(i=>{if(!i)return;let s=yo.decode(i.data);r.push(s)}),r}async getOwnerLockedPositionInfo({programId:e=vo}){await this.scope.account.fetchWalletTokenAccounts();let n=this.scope.account.tokenAccountRawInfos.filter(u=>u.accountInfo.amount.eq(new bt(1))).map(u=>fo(new z(e),u.accountInfo.mint).publicKey),o=await this.scope.connection.getMultipleAccountsInfo(n),r=[];o.forEach(u=>{if(!u)return;let a=ec.decode(u.data);r.push(a)});let i=await this.scope.connection.getMultipleAccountsInfo(r.map(u=>u.positionId)),s=[];return i.forEach(u=>{if(!u)return;let a=yo.decode(u.data);s.push(a)}),r.map((u,a)=>({position:s[a],lockInfo:u}))}async getRpcClmmPoolInfo({poolId:e}){return(await this.getRpcClmmPoolInfos({poolIds:[e]}))[String(e)]}async getRpcClmmPoolInfos({poolIds:e,config:t}){let n=await Re(this.scope.connection,e.map(r=>({pubkey:new z(r)})),t),o={};for(let r=0;r<e.length;r++){let i=n[r];if(i===null||!i.accountInfo)throw Error("fetch pool info error: "+String(e[r]));let s=qn.decode(i.accountInfo.data),u=ie.sqrtPriceX64ToPrice(s.sqrtPriceX64,s.mintDecimalsA,s.mintDecimalsB).toNumber();o[String(e[r])]=W(N({},s),{currentPrice:u,programId:i.accountInfo.owner})}return o}async getComputeClmmPoolInfos({clmmPoolsRpcInfo:e,mintInfos:t}){let n=new Set(Object.keys(e).map(u=>e[u].ammConfig.toBase58())),o=await Re(this.scope.connection,Array.from(n).map(u=>({pubkey:new z(u)}))),r={};o.forEach(u=>{!u.accountInfo||(r[u.pubkey.toBase58()]=Zu.decode(u.accountInfo.data))});let i=await Le.fetchComputeMultipleClmmInfo({connection:this.scope.connection,rpcDataMap:e,poolList:Object.keys(e).map(u=>{var l,d,p,f;let[a,c]=[e[u].mintA.toBase58(),e[u].mintB.toBase58()];return{id:u,programId:e[u].programId.toBase58(),mintA:mt({address:a,decimals:e[u].mintDecimalsA,programId:t[a].programId.toBase58()||li.toBase58(),extensions:{feeConfig:(l=t[a])!=null&&l.feeConfig?Bn((d=t[a])==null?void 0:d.feeConfig):void 0}}),mintB:mt({address:c,decimals:e[u].mintDecimalsB,programId:t[c].programId.toBase58()||li.toBase58(),extensions:{feeConfig:(p=t[c])!=null&&p.feeConfig?Bn((f=t[c])==null?void 0:f.feeConfig):void 0}}),price:e[u].currentPrice,config:W(N({},r[e[u].ammConfig.toBase58()]),{id:e[u].ammConfig.toBase58(),fundFeeRate:0,description:"",defaultRange:0,defaultRangePoint:[]})}})}),s=await Le.fetchMultiplePoolTickArrays({connection:this.scope.connection,poolKeys:Object.values(i)});return{computeClmmPoolInfo:i,computePoolTickData:s}}async getPoolInfoFromRpc(e){var c;let t=await this.getRpcClmmPoolInfo({poolId:e}),n=new Set([t.mintA.toBase58(),t.mintB.toBase58()]),o=await io({connection:this.scope.connection,mints:Array.from(n).map(l=>new z(l))}),{computeClmmPoolInfo:r,computePoolTickData:i}=await this.scope.clmm.getComputeClmmPoolInfos({clmmPoolsRpcInfo:{[e]:t},mintInfos:o}),s=await Re(this.scope.connection,[{pubkey:t.vaultA},{pubkey:t.vaultB}]),u=Yu(r[e]);if(!s[0].accountInfo||!s[1].accountInfo)throw new Error("pool vault data not found");u.mintAmountA=Number(Ac.decode(s[0].accountInfo.data).amount.toString()),u.mintAmountB=Number(Ac.decode((c=s[1].accountInfo)==null?void 0:c.data).amount.toString());let a=W(N({},r[e]),{exBitmapAccount:r[e].exBitmapAccount.toBase58(),observationId:r[e].observationId.toBase58(),id:e,programId:t.programId.toBase58(),openTime:t.startTime.toString(),vault:{A:t.vaultA.toBase58(),B:t.vaultB.toBase58()},config:u.config,rewardInfos:r[e].rewardInfos.filter(l=>!l.tokenVault.equals(z.default)).map(l=>({mint:mt({address:l.tokenMint.toBase58(),programId:li.toBase58(),decimals:10}),vault:l.tokenVault.toBase58()}))});return{poolInfo:u,poolKeys:a,computePoolInfo:r[e],tickData:i}}};import{PublicKey as G}from"@solana/web3.js";import{AccountLayout as Ed,NATIVE_MINT as xr,TOKEN_PROGRAM_ID as Kt,createAssociatedTokenAccountIdempotentInstruction as Cc}from"@solana/spl-token";import oa from"bn.js";import hr from"decimal.js-light";import di from"bn.js";function Pr(m,e){if(e.isZero())throw Error("divisor is zero");return m.mod(e)}function Sd(m,e){if(e.isZero())throw Error("rhs is zero");let t=m.div(e);if(t.isZero())throw Error("quotient is zero");let n=Pr(m,e);return n.gt(Po)&&(t=t.add(new di(1)),e=m.div(t),n=Pr(m,t),n.gt(Po)&&(e=e.add(new di(1)))),[t,e]}var Po=new di(0),wr=class{static swapWithoutFees(e,t,n){let o=t.mul(n),r=t.add(e),[i]=Sd(o,r),s=n.sub(i);if(s.isZero())throw Error("destinationAmountSwapped is zero");return{destinationAmountSwapped:s}}static lpTokensToTradingTokens(e,t,n,o,r){let i=e.mul(n).div(t),s=e.mul(o).div(t);if(r===0)return{tokenAmount0:i,tokenAmount1:s};if(r===1)return Pr(e.mul(n),t).gt(Po)&&i.gt(Po)&&(i=i.add(new di(1))),Pr(e.mul(o),t).gt(Po)&&s.gt(Po)&&(s=s.add(new di(1))),{tokenAmount0:i,tokenAmount1:s};throw Error("roundDirection value error")}};var kr=class{static tradingFee(e,t){return _i(e,t,Yt)}static protocolFee(e,t){return es(e,t,Yt)}static fundFee(e,t){return es(e,t,Yt)}};var Tr=class{static validate_supply(e,t){if(e.isZero())throw Error("tokenAmount0 is zero");if(t.isZero())throw Error("tokenAmount1 is zero")}static swap(e,t,n,o){let r=kr.tradingFee(e,o),i=e.sub(r),{destinationAmountSwapped:s}=wr.swapWithoutFees(i,t,n);return{newSwapDestinationAmount:n.sub(s),sourceAmountSwapped:e,destinationAmountSwapped:s,tradeFee:r}}static swapBaseOut({poolMintA:e,poolMintB:t,tradeFeeRate:n,baseReserve:o,quoteReserve:r,outputMint:i,outputAmount:s}){let[u,a,c,l,d]=t.address===i.toString()?[o,r,e.decimals,t.decimals,e.address]:[r,o,t.decimals,e.decimals,t.address],p=new hr(a.toString()).div(10**l).div(new hr(u.toString()).div(10**c)),f=s.gte(a)?a.sub(new oa(1)):s,y=a.sub(f),b=Qt(u.mul(f),y),g=Qt(b.mul(new oa(1e6)),new oa(1e6).sub(n)),P=g.sub(b),h=new hr(f.toString()).div(10**l).div(new hr(g.toString()).div(10**c)),I=p.isZero()?0:h.sub(p).div(p).abs().toNumber();return{amountRealOut:f,amountIn:g,amountInWithoutFee:b,tradeFee:P,priceImpact:I}}};import ze from"bn.js";import Vt from"decimal.js";import{PublicKey as yi,TransactionInstruction as Yn,Keypair as vd,SystemProgram as _d}from"@solana/web3.js";import{ASSOCIATED_TOKEN_PROGRAM_ID as hc,TOKEN_2022_PROGRAM_ID as ra,TOKEN_PROGRAM_ID as Kn}from"@solana/spl-token";var Kd=Buffer.from("vault_and_lp_mint_auth_seed","utf8"),xB=Buffer.from("amm_config","utf8"),Cd=Buffer.from("pool","utf8"),Rd=Buffer.from("pool_lp_mint","utf8"),Ld=Buffer.from("pool_vault","utf8"),Od=Buffer.from("observation","utf8");function wo(m){return se([Kd],m)}function ia(m,e,t,n){return se([Cd,e.toBuffer(),t.toBuffer(),n.toBuffer()],m)}function Nd(m,e){return se([Rd,e.toBuffer()],m)}function wc(m,e,t){return se([Ld,e.toBuffer(),t.toBuffer()],m)}function pi(m,e){return se([Od,e.toBuffer()],m)}function kc({poolId:m,programId:e,configId:t,mintA:n,mintB:o}){let r=wo(e).publicKey,i=m||ia(e,t,n,o).publicKey,s=Nd(e,i).publicKey,u=wc(e,i,n).publicKey,a=wc(e,i,o).publicKey,c=pi(e,i).publicKey;return{poolId:i,configId:t,authority:r,lpMint:s,vaultA:u,vaultB:a,observationId:c}}var Md=Buffer.from("locked_liquidity","utf8");function fi(m,e){return se([Md,e.toBuffer()],m)}var Fd=fe("Raydium_cpmm"),Hn={initialize:[175,175,109,31,13,152,155,237],deposit:[242,35,198,137,82,225,242,182],withdraw:[183,18,70,156,148,109,161,34],swapBaseInput:[143,190,90,218,196,30,51,222],swapBaseOutput:[55,217,98,86,163,74,180,173],lockCpLiquidity:[216,157,29,78,38,51,31,26],collectCpFee:[8,30,51,199,209,184,247,133]};function Tc(m,e,t,n,o,r,i,s,u,a,c,l,d,p,f,y,b,g,P,h){let I=_([A("amountMaxA"),A("amountMaxB"),A("openTime")]),k=ia(m,t,r,i).publicKey,w=[{pubkey:e,isSigner:!0,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!o.equals(k),isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!1},{pubkey:i,isSigner:!1,isWritable:!1},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:d,isSigner:!1,isWritable:!0},{pubkey:p,isSigner:!1,isWritable:!0},{pubkey:b,isSigner:!1,isWritable:!0},{pubkey:Kn,isSigner:!1,isWritable:!1},{pubkey:f,isSigner:!1,isWritable:!1},{pubkey:y,isSigner:!1,isWritable:!1},{pubkey:hc,isSigner:!1,isWritable:!1},{pubkey:Yr,isSigner:!1,isWritable:!1},{pubkey:ot,isSigner:!1,isWritable:!1}],S=Buffer.alloc(I.span);return I.encode({amountMaxA:g,amountMaxB:P,openTime:h},S),new Yn({keys:w,programId:m,data:Buffer.from([...Hn.initialize,...S])})}function Ic(m,e,t,n,o,r,i,s,u,a,c,l,d,p,f){let y=_([A("lpAmount"),A("amountMaxA"),A("amountMaxB")]),b=[{pubkey:e,isSigner:!0,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:Kn,isSigner:!1,isWritable:!1},{pubkey:ra,isSigner:!1,isWritable:!1},{pubkey:a,isSigner:!1,isWritable:!1},{pubkey:c,isSigner:!1,isWritable:!1},{pubkey:l,isSigner:!1,isWritable:!0}],g=Buffer.alloc(y.span);return Fd.debug("cpmm deposit data",{lpAmount:d.toString(),amountMaxA:p.toString(),amountMaxB:f.toString()}),y.encode({lpAmount:d,amountMaxA:p,amountMaxB:f},g),new Yn({keys:b,programId:m,data:Buffer.from([...Hn.deposit,...g])})}function Bc(m,e,t,n,o,r,i,s,u,a,c,l,d,p,f){let y=_([A("lpAmount"),A("amountMinA"),A("amountMinB")]),b=[{pubkey:e,isSigner:!0,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:Kn,isSigner:!1,isWritable:!1},{pubkey:ra,isSigner:!1,isWritable:!1},{pubkey:a,isSigner:!1,isWritable:!1},{pubkey:c,isSigner:!1,isWritable:!1},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:Pn,isSigner:!1,isWritable:!1}],g=Buffer.alloc(y.span);return y.encode({lpAmount:d,amountMinA:p,amountMinB:f},g),new Yn({keys:b,programId:m,data:Buffer.from([...Hn.withdraw,...g])})}function Ir(m,e,t,n,o,r,i,s,u,a,c,l,d,p,f,y){let b=_([A("amountIn"),A("amounOutMin")]),g=[{pubkey:e,isSigner:!0,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!1},{pubkey:c,isSigner:!1,isWritable:!1},{pubkey:l,isSigner:!1,isWritable:!1},{pubkey:d,isSigner:!1,isWritable:!1},{pubkey:p,isSigner:!1,isWritable:!0}],P=Buffer.alloc(b.span);return b.encode({amountIn:f,amounOutMin:y},P),new Yn({keys:g,programId:m,data:Buffer.from([...Hn.swapBaseInput,...P])})}function xc(m,e,t,n,o,r,i,s,u,a,c,l,d,p,f,y){let b=_([A("amountInMax"),A("amountOut")]),g=[{pubkey:e,isSigner:!0,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!1},{pubkey:c,isSigner:!1,isWritable:!1},{pubkey:l,isSigner:!1,isWritable:!1},{pubkey:d,isSigner:!1,isWritable:!1},{pubkey:p,isSigner:!1,isWritable:!0}],P=Buffer.alloc(b.span);return b.encode({amountInMax:f,amountOut:y},P),new Yn({keys:g,programId:m,data:Buffer.from([...Hn.swapBaseOutput,...P])})}async function Sc(m){var b;let{ownerInfo:e,poolInfo:t,poolKeys:n,feeNftOwner:o,getEphemeralSigners:r}=m,i=[],[s,u]=[new yi(t.id),new yi(t.lpMint.address)],a;if(r)a=new yi((await r(1))[0]);else{let g=vd.generate();i.push(g),a=g.publicKey}let{publicKey:c}=J(o,a,Kn),{publicKey:l}=dn(a),{publicKey:d}=fi(m.lockProgram,a),{publicKey:p}=J(e.wallet,u,Kn),{publicKey:f}=J(m.lockAuthProgram,u,Kn),y=Vd({programId:m.lockProgram,auth:m.lockAuthProgram,payer:e.feePayer,liquidityOwner:e.wallet,nftOwner:o,nftMint:a,nftAccount:c,poolId:s,lockPda:d,mintLp:u,userLpVault:p,lockLpVault:f,poolVaultA:new yi(n.vault.A),poolVaultB:new yi(n.vault.B),metadataAccount:l,lpAmount:m.lpAmount,withMetadata:(b=m.withMetadata)!=null?b:!0});return{address:{nftMint:a,nftAccount:c,metadataAccount:l,lockPda:d,userLpVault:p,lockLpVault:f},instructions:[y],signers:i,instructionTypes:[q.CpmmLockLp],lookupTableAddress:[]}}function Vd({programId:m,auth:e,payer:t,liquidityOwner:n,nftOwner:o,nftMint:r,nftAccount:i,poolId:s,lockPda:u,mintLp:a,userLpVault:c,lockLpVault:l,poolVaultA:d,poolVaultB:p,metadataAccount:f,lpAmount:y,withMetadata:b}){let g=[{pubkey:e,isSigner:!1,isWritable:!1},{pubkey:t,isSigner:!0,isWritable:!0},{pubkey:n,isSigner:!0,isWritable:!1},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!0,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!1},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!1},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:d,isSigner:!1,isWritable:!0},{pubkey:p,isSigner:!1,isWritable:!0},{pubkey:f,isSigner:!1,isWritable:!0},{pubkey:ot,isSigner:!1,isWritable:!1},{pubkey:_d.programId,isSigner:!1,isWritable:!1},{pubkey:Kn,isSigner:!1,isWritable:!1},{pubkey:hc,isSigner:!1,isWritable:!1},{pubkey:Xt,isSigner:!1,isWritable:!1}],P=_([A("lpAmount"),De("withMetadata")]),h=Buffer.alloc(P.span);P.encode({lpAmount:y,withMetadata:b},h);let I=Buffer.from([...Hn.lockCpLiquidity,...h]);return new Yn({keys:g,programId:m,data:I})}function sa({programId:m,nftOwner:e,auth:t,nftAccount:n,lockPda:o,poolId:r,mintLp:i,userVaultA:s,userVaultB:u,poolVaultA:a,poolVaultB:c,mintA:l,mintB:d,lockLpVault:p,lpFeeAmount:f,cpmmProgram:y,cpmmAuthProgram:b}){let g=[{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:e,isSigner:!0,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:y!=null?y:Wi,isSigner:!1,isWritable:!1},{pubkey:b!=null?b:$a,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!1},{pubkey:d,isSigner:!1,isWritable:!1},{pubkey:p,isSigner:!1,isWritable:!0},{pubkey:Kn,isSigner:!1,isWritable:!1},{pubkey:ra,isSigner:!1,isWritable:!1},{pubkey:Pn,isSigner:!1,isWritable:!1}],P=_([A("lpFeeAmount")]),h=Buffer.alloc(P.span);P.encode({lpFeeAmount:f},h);let I=Buffer.from([...Hn.collectCpFee,...h]);return new Yn({keys:g,programId:m,data:I})}var Kc=_([he(8),D("bump"),De("disableCreatePool"),Tt("index"),A("tradeFeeRate"),A("protocolFeeRate"),A("fundFeeRate"),A("createPoolFee"),O("protocolOwner"),O("fundOwner"),Q(A(),16)]),Br=_([he(8),O("configId"),O("poolCreator"),O("vaultA"),O("vaultB"),O("mintLp"),O("mintA"),O("mintB"),O("mintProgramA"),O("mintProgramB"),O("observationId"),D("bump"),D("status"),D("lpDecimals"),D("mintDecimalA"),D("mintDecimalB"),A("lpAmount"),A("protocolFeesMintA"),A("protocolFeesMintB"),A("fundFeesMintA"),A("fundFeesMintB"),A("openTime"),Q(A(),32)]);var bi=class extends Ne{constructor(e){super(e)}async load(){this.checkDisabled()}async getCpmmPoolKeys(e){return(await this.scope.api.fetchPoolKeysById({idList:[e]}))[0]}async getRpcPoolInfo(e,t){return(await this.getRpcPoolInfos([e],t))[e]}async getRpcPoolInfos(e,t){let n=await Re(this.scope.connection,e.map(l=>({pubkey:new G(l)}))),o={},r=new Set,i=[];for(let l=0;l<e.length;l++){let d=n[l];if(d.accountInfo===null)throw Error("fetch pool info error: "+String(e[l]));let p=Br.decode(d.accountInfo.data);o[String(e[l])]=W(N({},p),{programId:d.accountInfo.owner}),r.add(String(p.configId)),i.push(p.vaultA,p.vaultB)}let s={};if(t){let l=[...r],d=await Re(this.scope.connection,l.map(p=>({pubkey:new G(p)})));for(let p=0;p<l.length;p++){let f=d[p].accountInfo;if(f===null)throw Error("fetch pool config error: "+l[p]);s[l[p]]=Kc.decode(f.data)}}let u={},a=await Re(this.scope.connection,i.map(l=>({pubkey:new G(l)})));for(let l=0;l<i.length;l++){let d=a[l].accountInfo;if(d===null)throw Error("fetch vault info error: "+i[l]);u[String(i[l])]=new ze(Ed.decode(d.data).amount.toString())}let c={};for(let[l,d]of Object.entries(o)){let p=u[d.vaultA.toString()].sub(d.protocolFeesMintA).sub(d.fundFeesMintA),f=u[d.vaultB.toString()].sub(d.protocolFeesMintB).sub(d.fundFeesMintB);c[l]=W(N({},d),{baseReserve:p,quoteReserve:f,vaultAAmount:u[d.vaultA.toString()],vaultBAmount:u[d.vaultB.toString()],configInfo:s[d.configId.toString()],poolPrice:new Vt(f.toString()).div(new Vt(10).pow(d.mintDecimalB)).div(new Vt(p.toString()).div(new Vt(10).pow(d.mintDecimalA)))})}return c}toComputePoolInfos({pools:e,mintInfos:t}){return Object.keys(e).reduce((n,o)=>{var u,a,c,l;let r=e[o],[i,s]=[r.mintA.toBase58(),r.mintB.toBase58()];return W(N({},n),{[o]:W(N({},r),{id:new G(o),configInfo:r.configInfo,version:7,authority:wo(r.programId).publicKey,mintA:mt({address:i,decimals:r.mintDecimalA,programId:r.mintProgramA.toBase58(),extensions:{feeConfig:(u=t[i])!=null&&u.feeConfig?Bn((a=t[i])==null?void 0:a.feeConfig):void 0}}),mintB:mt({address:s,decimals:r.mintDecimalB,programId:r.mintProgramB.toBase58(),extensions:{feeConfig:(c=t[s])!=null&&c.feeConfig?Bn((l=t[s])==null?void 0:l.feeConfig):void 0}})})})},{})}async getPoolInfoFromRpc(e){let t=await this.getRpcPoolInfo(e,!0),n=await io({connection:this.scope.connection,mints:[t.mintA,t.mintB]}),o=mt({address:t.mintA.toBase58(),decimals:t.mintDecimalA,programId:t.mintProgramA.toBase58(),extensions:{feeConfig:n[t.mintA.toBase58()].feeConfig?Bn(n[t.mintA.toBase58()].feeConfig):void 0}}),r=mt({address:t.mintB.toBase58(),decimals:t.mintDecimalB,programId:t.mintProgramB.toBase58(),extensions:{feeConfig:n[t.mintB.toBase58()].feeConfig?Bn(n[t.mintB.toBase58()].feeConfig):void 0}}),i=mt({address:t.mintLp.toBase58(),decimals:t.lpDecimals,programId:Kt.toBase58()}),s={id:t.configId.toBase58(),index:t.configInfo.index,protocolFeeRate:t.configInfo.protocolFeeRate.toNumber(),tradeFeeRate:t.configInfo.tradeFeeRate.toNumber(),fundFeeRate:t.configInfo.fundFeeRate.toNumber(),createPoolFee:t.configInfo.createPoolFee.toString()},u={volume:0,volumeQuote:0,volumeFee:0,apr:0,feeApr:0,priceMin:0,priceMax:0,rewardApr:[]};return{poolInfo:{programId:t.programId.toBase58(),id:e,type:"Standard",lpMint:i,lpPrice:0,lpAmount:t.lpAmount.toNumber(),config:s,mintA:o,mintB:r,rewardDefaultInfos:[],rewardDefaultPoolInfos:"Ecosystem",price:t.poolPrice.toNumber(),mintAmountA:new Vt(t.vaultAAmount.toString()).div(10**o.decimals).toNumber(),mintAmountB:new Vt(t.vaultBAmount.toString()).div(10**r.decimals).toNumber(),feeRate:t.configInfo.tradeFeeRate.toNumber(),openTime:t.openTime.toString(),tvl:0,burnPercent:0,day:u,week:u,month:u,pooltype:[],farmUpcomingCount:0,farmOngoingCount:0,farmFinishedCount:0},poolKeys:{programId:t.programId.toBase58(),id:e,mintA:o,mintB:r,openTime:t.openTime.toString(),vault:{A:t.vaultA.toBase58(),B:t.vaultB.toBase58()},authority:wo(t.programId).publicKey.toBase58(),mintLp:i,config:s,observationId:pi(t.programId,new G(e)).publicKey.toBase58()},rpcData:t}}async createPool(f){var y=f,{poolId:e,programId:t,poolFeeAccount:n,startTime:o,ownerInfo:r,associatedOnly:i=!1,checkCreateATAOwner:s=!1,txVersion:u,feeConfig:a,computeBudgetConfig:c,txTipConfig:l,feePayer:d}=y,p=Ee(y,["poolId","programId","poolFeeAccount","startTime","ownerInfo","associatedOnly","checkCreateATAOwner","txVersion","feeConfig","computeBudgetConfig","txTipConfig","feePayer"]);var F,X,H;let b=r.feePayer||((F=this.scope.owner)==null?void 0:F.publicKey),g=new ze(new G(p.mintA.address).toBuffer()).lte(new ze(new G(p.mintB.address).toBuffer())),[P,h]=g?[p.mintA,p.mintB]:[p.mintB,p.mintA],[I,k]=g?[p.mintAAmount,p.mintBAmount]:[p.mintBAmount,p.mintAAmount],w=r.useSOLBalance&&P.address===xr.toBase58(),S=r.useSOLBalance&&h.address===xr.toBase58(),[x,K]=[new G(P.address),new G(h.address)],T=this.createTxBuilder(d),{account:C,instructionParams:M}=await this.scope.account.getOrCreateTokenAccount({mint:x,tokenProgram:P.programId,owner:this.scope.ownerPubKey,createInfo:w?{payer:b,amount:I}:void 0,notUseTokenAccount:w,skipCloseAccount:!w,associatedOnly:w?!1:i,checkCreateATAOwner:s});T.addInstruction(M||{});let{account:v,instructionParams:R}=await this.scope.account.getOrCreateTokenAccount({mint:new G(h.address),tokenProgram:h.programId,owner:this.scope.ownerPubKey,createInfo:S?{payer:b,amount:k}:void 0,notUseTokenAccount:S,skipCloseAccount:!S,associatedOnly:S?!1:i,checkCreateATAOwner:s});if(T.addInstruction(R||{}),C===void 0||v===void 0)throw Error("you don't has some token account");let L=kc({poolId:e,programId:t,configId:new G(a.id),mintA:x,mintB:K});return T.addInstruction({instructions:[Tc(t,this.scope.ownerPubKey,new G(a.id),L.authority,L.poolId,x,K,L.lpMint,C,v,J(this.scope.ownerPubKey,L.lpMint).publicKey,L.vaultA,L.vaultB,n,new G((X=P.programId)!=null?X:Kt),new G((H=h.programId)!=null?H:Kt),L.observationId,I,k,o)],instructionTypes:[q.CpmmCreatePool]}),T.addCustomComputeBudget(c),T.addTipInstruction(l),T.versionBuild({txVersion:u,extInfo:{address:W(N({},L),{mintA:P,mintB:h,programId:t,poolFeeAccount:n,feeConfig:a})}})}async addLiquidity(e){let{poolInfo:t,poolKeys:n,inputAmount:o,baseIn:r,slippage:i,computeResult:s,computeBudgetConfig:u,txTipConfig:a,config:c,txVersion:l,feePayer:d}=e;this.scope.availability.addStandardPosition===!1&&this.logAndCreateError("add liquidity feature disabled in your region"),o.isZero()&&this.logAndCreateError("amounts must greater than zero","amountInA",{amountInA:o.toString()});let{account:p}=this.scope,{bypassAssociatedCheck:f,checkCreateATAOwner:y}=N({bypassAssociatedCheck:!1,checkCreateATAOwner:!1},c),b=s?void 0:await this.getRpcPoolInfo(t.id),{liquidity:g,inputAmountFee:P,anotherAmount:h}=s||this.computePairAmount({poolInfo:W(N({},t),{lpAmount:new Vt(b.lpAmount.toString()).div(10**t.lpMint.decimals).toNumber()}),baseReserve:b.baseReserve,quoteReserve:b.quoteReserve,slippage:new Je(0),baseIn:r,epochInfo:await this.scope.fetchEpochInfo(),amount:new Vt(o.toString()).div(10**(r?t.mintA.decimals:t.mintB.decimals))}),I=h.amount,k=t.mintA.address===xr.toString(),w=t.mintB.address===xr.toString(),S=this.createTxBuilder(d),[x,K]=[new G(t.mintA.address),new G(t.mintB.address)],{account:T,instructionParams:C}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:t.mintA.programId,mint:new G(t.mintA.address),owner:this.scope.ownerPubKey,createInfo:k||(r?o:I).isZero()?{payer:this.scope.ownerPubKey,amount:r?o:I}:void 0,skipCloseAccount:!k,notUseTokenAccount:k,associatedOnly:!1,checkCreateATAOwner:y});S.addInstruction(C||{});let{account:M,instructionParams:v}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:t.mintB.programId,mint:new G(t.mintB.address),owner:this.scope.ownerPubKey,createInfo:w||(r?I:o).isZero()?{payer:this.scope.ownerPubKey,amount:r?I:o}:void 0,skipCloseAccount:!w,notUseTokenAccount:w,associatedOnly:!1,checkCreateATAOwner:y});S.addInstruction(v||{}),!T&&!M&&this.logAndCreateError("cannot found target token accounts","tokenAccounts",p.tokenAccounts);let R=await p.getCreatedTokenAccount({mint:new G(t.lpMint.address)}),re=await p.handleTokenAccount({side:"out",amount:0,mint:new G(t.lpMint.address),tokenAccount:R,bypassAssociatedCheck:f,checkCreateATAOwner:y}),{tokenAccount:L}=re,F=Ee(re,["tokenAccount"]);S.addInstruction(F);let X=n!=null?n:await this.getCpmmPoolKeys(t.id),H=new Je(new ze(1)).sub(i);return S.addInstruction({instructions:[Ic(new G(t.programId),this.scope.ownerPubKey,new G(X.authority),new G(t.id),L,T,M,new G(X.vault.A),new G(X.vault.B),x,K,new G(t.lpMint.address),s?s==null?void 0:s.liquidity:H.mul(g).quotient,r?P.amount:I,r?I:P.amount)],instructionTypes:[q.CpmmAddLiquidity],lookupTableAddress:X.lookupTableAccount?[X.lookupTableAccount]:[]}),S.addCustomComputeBudget(u),S.addTipInstruction(a),S.versionBuild({txVersion:l})}async withdrawLiquidity(e){var F,X;let{poolInfo:t,poolKeys:n,lpAmount:o,slippage:r,computeBudgetConfig:i,txTipConfig:s,txVersion:u,feePayer:a,closeWsol:c=!0}=e;this.scope.availability.addStandardPosition===!1&&this.logAndCreateError("add liquidity feature disabled in your region");let l=new Je(new ze(1)).sub(r),d=await this.getRpcPoolInfo(t.id),[p,f]=[l.mul(o.mul(d.baseReserve).div(d.lpAmount)).quotient,l.mul(o.mul(d.quoteReserve).div(d.lpAmount)).quotient],y=await this.scope.fetchEpochInfo(),[b,g]=[xe(p,t.mintA.extensions.feeConfig,y,!1),xe(f,t.mintB.extensions.feeConfig,y,!1)],{account:P}=this.scope,h=this.createTxBuilder(a),[I,k]=[new G(t.mintA.address),new G(t.mintB.address)],w=I.equals(j),S=k.equals(j),x,K,{account:T,instructionParams:C}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:t.mintA.programId,mint:new G(t.mintA.address),notUseTokenAccount:w,owner:this.scope.ownerPubKey,createInfo:{payer:this.scope.ownerPubKey,amount:0},skipCloseAccount:!(w&&c),associatedOnly:!w,checkCreateATAOwner:!1});x=T,C&&h.addInstruction(C);let{account:M,instructionParams:v}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:t.mintB.programId,mint:new G(t.mintB.address),notUseTokenAccount:S,owner:this.scope.ownerPubKey,createInfo:{payer:this.scope.ownerPubKey,amount:0},skipCloseAccount:!(S&&c),associatedOnly:!S,checkCreateATAOwner:!1});K=M,v&&h.addInstruction(v),(!x||!K)&&this.logAndCreateError("cannot found target token accounts","tokenAccounts",P.tokenAccounts);let R=await P.getCreatedTokenAccount({mint:new G(t.lpMint.address)});R||this.logAndCreateError("cannot found lp token account","tokenAccounts",P.tokenAccounts);let L=n!=null?n:await this.getCpmmPoolKeys(t.id);return h.addInstruction({instructions:[Bc(new G(t.programId),this.scope.ownerPubKey,new G(L.authority),new G(t.id),R,x,K,new G(L.vault.A),new G(L.vault.B),I,k,new G(t.lpMint.address),o,p.sub((F=b.fee)!=null?F:new ze(0)),f.sub((X=g.fee)!=null?X:new ze(0)))],instructionTypes:[q.CpmmWithdrawLiquidity],lookupTableAddress:L.lookupTableAccount?[L.lookupTableAccount]:[]}),h.addCustomComputeBudget(i),h.addTipInstruction(s),h.versionBuild({txVersion:u})}async swap(e){var C,M,v,R,L,F;let{poolInfo:t,poolKeys:n,baseIn:o,fixedOut:r,inputAmount:i,swapResult:s,slippage:u=0,config:a,computeBudgetConfig:c,txTipConfig:l,txVersion:d,feePayer:p}=e,{bypassAssociatedCheck:f,checkCreateATAOwner:y,associatedOnly:b}=N({bypassAssociatedCheck:!1,checkCreateATAOwner:!1,associatedOnly:!0},a),g=this.createTxBuilder(p),[P,h]=[new G(t.mintA.address),new G(t.mintB.address)];r?s.sourceAmountSwapped=s.sourceAmountSwapped.mul(new ze((1+u)*1e4)).div(new ze(1e4)):s.destinationAmountSwapped=s.destinationAmountSwapped.mul(new ze((1-u)*1e4)).div(new ze(1e4));let I=t.mintA.address===j.toBase58(),k=t.mintB.address===j.toBase58(),{account:w,instructionParams:S}=await this.scope.account.getOrCreateTokenAccount({mint:P,tokenProgram:new G((C=t.mintA.programId)!=null?C:Kt),owner:this.scope.ownerPubKey,createInfo:I||!o?{payer:this.scope.ownerPubKey,amount:o?s.sourceAmountSwapped:0}:void 0,notUseTokenAccount:I,skipCloseAccount:!I,associatedOnly:I?!1:b,checkCreateATAOwner:y});S&&g.addInstruction(S);let{account:x,instructionParams:K}=await this.scope.account.getOrCreateTokenAccount({mint:h,tokenProgram:new G((M=t.mintB.programId)!=null?M:Kt),owner:this.scope.ownerPubKey,createInfo:k||o?{payer:this.scope.ownerPubKey,amount:o?0:s.sourceAmountSwapped}:void 0,notUseTokenAccount:k,skipCloseAccount:!k,associatedOnly:k?!1:b,checkCreateATAOwner:y});K&&g.addInstruction(K),(!w||!x)&&this.logAndCreateError("user do not have token account",{mintA:t.mintA.symbol||t.mintA.address,mintB:t.mintB.symbol||t.mintB.address,mintATokenAcc:w,mintBTokenAcc:x,mintAUseSOLBalance:I,mintBUseSOLBalance:k,associatedOnly:b});let T=n!=null?n:await this.getCpmmPoolKeys(t.id);return g.addInstruction({instructions:[r?xc(new G(t.programId),this.scope.ownerPubKey,new G(T.authority),new G(T.config.id),new G(t.id),o?w:x,o?x:w,new G(T.vault[o?"A":"B"]),new G(T.vault[o?"B":"A"]),new G((L=t[o?"mintA":"mintB"].programId)!=null?L:Kt),new G((F=t[o?"mintB":"mintA"].programId)!=null?F:Kt),o?P:h,o?h:P,pi(new G(t.programId),new G(t.id)).publicKey,s.sourceAmountSwapped,s.destinationAmountSwapped):Ir(new G(t.programId),this.scope.ownerPubKey,new G(T.authority),new G(T.config.id),new G(t.id),o?w:x,o?x:w,new G(T.vault[o?"A":"B"]),new G(T.vault[o?"B":"A"]),new G((v=t[o?"mintA":"mintB"].programId)!=null?v:Kt),new G((R=t[o?"mintB":"mintA"].programId)!=null?R:Kt),o?P:h,o?h:P,pi(new G(t.programId),new G(t.id)).publicKey,i,s.destinationAmountSwapped)],instructionTypes:[r?q.CpmmSwapBaseOut:q.ClmmSwapBaseIn]}),g.addCustomComputeBudget(c),g.addTipInstruction(l),g.versionBuild({txVersion:d})}async lockLp(e){var d,p,f,y,b;let{poolInfo:t,lpAmount:n,computeBudgetConfig:o,txTipConfig:r,txVersion:i,feePayer:s,feeNftOwner:u}=e;n.isZero()&&this.logAndCreateError("lpAmount must greater than zero",{lpAmount:n.toString()});let a=this.createTxBuilder(s),c=(d=e.poolKeys)!=null?d:await this.getCpmmPoolKeys(t.id),l=await Sc({poolInfo:t,poolKeys:c,ownerInfo:{wallet:this.scope.ownerPubKey,feePayer:(p=e.feePayer)!=null?p:this.scope.ownerPubKey},feeNftOwner:u!=null?u:this.scope.ownerPubKey,lockProgram:(f=e.programId)!=null?f:qi,lockAuthProgram:(y=e.authProgram)!=null?y:Ui,lpAmount:n,withMetadata:(b=e.withMetadata)!=null?b:!0,getEphemeralSigners:e.getEphemeralSigners});return a.addInstruction(l),a.addCustomComputeBudget(o),a.addTipInstruction(r),a.versionBuild({txVersion:i,extInfo:l.address})}async harvestLockLp(e){var M;let{poolInfo:t,lpFeeAmount:n,nftMint:o,programId:r=qi,authProgram:i=Ui,cpmmProgram:s,computeBudgetConfig:u,txTipConfig:a,txVersion:c,closeWsol:l=!0}=e;n.isZero()&&this.logAndCreateError("lpFeeAmount must greater than zero",{lpAmount:n.toString()});let d=e.feePayer||this.scope.ownerPubKey,p=this.createTxBuilder(d),[f,y]=[new G(t.mintA.address),new G(t.mintB.address)],b=f.equals(j),g=y.equals(j),P,h,{account:I,instructionParams:k}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:t.mintA.programId,mint:new G(t.mintA.address),notUseTokenAccount:b,owner:this.scope.ownerPubKey,createInfo:{payer:this.scope.ownerPubKey,amount:0},skipCloseAccount:!(b&&l),associatedOnly:!b,checkCreateATAOwner:!1});P=I,k&&p.addInstruction(k);let{account:w,instructionParams:S}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:t.mintB.programId,mint:new G(t.mintB.address),notUseTokenAccount:g,owner:this.scope.ownerPubKey,createInfo:{payer:this.scope.ownerPubKey,amount:0},skipCloseAccount:!(g&&l),associatedOnly:!g,checkCreateATAOwner:!1});h=w,S&&p.addInstruction(S),(!P||!h)&&this.logAndCreateError("cannot found target token accounts",{tokenAccountA:P,tokenAccountB:h});let x=(M=e.poolKeys)!=null?M:await this.getCpmmPoolKeys(t.id),{publicKey:K}=J(d,o,Kt),{publicKey:T}=fi(r,o),{publicKey:C}=J(i,new G(t.lpMint.address),Kt);return p.addInstruction({instructions:[sa({programId:r,nftOwner:this.scope.ownerPubKey,auth:i,nftMint:o,nftAccount:K,lockPda:T,poolId:new G(t.id),mintLp:new G(x.mintLp.address),userVaultA:P,userVaultB:h,poolVaultA:new G(x.vault.A),poolVaultB:new G(x.vault.B),mintA:f,mintB:y,lockLpVault:C,lpFeeAmount:n,cpmmProgram:s==null?void 0:s.programId,cpmmAuthProgram:s==null?void 0:s.authProgram})],instructionTypes:[q.CpmmCollectLockFee]}),p.addCustomComputeBudget(u),p.addTipInstruction(a),p.versionBuild({txVersion:c})}async harvestMultiLockLp(e){let{lockInfo:t,programId:n=qi,authProgram:o=Ui,cpmmProgram:r,computeBudgetConfig:i,txVersion:s,closeWsol:u=!0}=e,a=e.feePayer||this.scope.ownerPubKey,c=this.createTxBuilder(a),l={};return t.forEach(async d=>{var T;let{poolInfo:p,lpFeeAmount:f,nftMint:y}=d;if(f.isZero())return;let[b,g]=[new G(p.mintA.address),new G(p.mintB.address)],P=b.equals(j),h=g.equals(j),I=l[p.mintA.address],k=l[p.mintB.address];if(!I)if(P){let{account:C,instructionParams:M}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:p.mintA.programId,mint:new G(p.mintA.address),notUseTokenAccount:!0,owner:this.scope.ownerPubKey,createInfo:{payer:this.scope.ownerPubKey,amount:0},skipCloseAccount:!u,associatedOnly:!1,checkCreateATAOwner:!1});I=C,M&&c.addInstruction(M),l[p.mintA.address]=C}else{let C=new G(p.mintA.address);I=this.scope.account.getAssociatedTokenAccount(C,new G(p.mintA.programId)),c.addInstruction({instructions:[Cc(this.scope.ownerPubKey,I,this.scope.ownerPubKey,C)]}),l[p.mintA.address]=I}if(!k)if(h){let{account:C,instructionParams:M}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:p.mintB.programId,mint:new G(p.mintB.address),notUseTokenAccount:!0,owner:this.scope.ownerPubKey,createInfo:{payer:this.scope.ownerPubKey,amount:0},skipCloseAccount:!u,associatedOnly:!1,checkCreateATAOwner:!1});k=C,M&&c.addInstruction(M),l[p.mintB.address]=C}else{let C=new G(p.mintB.address);k=this.scope.account.getAssociatedTokenAccount(C,new G(p.mintB.programId)),c.addInstruction({instructions:[Cc(this.scope.ownerPubKey,k,this.scope.ownerPubKey,C)]}),l[p.mintB.address]=k}(!I||!k)&&this.logAndCreateError("cannot found target token accounts",{tokenAccountA:I,tokenAccountB:k});let w=(T=d.poolKeys)!=null?T:await this.getCpmmPoolKeys(p.id),{publicKey:S}=J(a,y,Kt),{publicKey:x}=fi(n,y),{publicKey:K}=J(o,new G(p.lpMint.address),Kt);c.addInstruction({instructions:[sa({programId:n,nftOwner:this.scope.ownerPubKey,auth:o,nftMint:y,nftAccount:S,lockPda:x,poolId:new G(p.id),mintLp:new G(w.mintLp.address),userVaultA:I,userVaultB:k,poolVaultA:new G(w.vault.A),poolVaultB:new G(w.vault.B),mintA:b,mintB:g,lockLpVault:K,lpFeeAmount:f,cpmmProgram:r==null?void 0:r.programId,cpmmAuthProgram:r==null?void 0:r.authProgram})],instructionTypes:[q.CpmmCollectLockFee]})}),s===0?c.sizeCheckBuildV0({computeBudgetConfig:i}):c.sizeCheckBuild({computeBudgetConfig:i})}computeSwapAmount({pool:e,amountIn:t,outputMint:n,slippage:o}){let r=n.toString()===e.mintB.address,i=Tr.swap(t,r?e.baseReserve:e.quoteReserve,r?e.quoteReserve:e.baseReserve,e.configInfo.tradeFeeRate),s=new Vt(i.destinationAmountSwapped.toString()).div(i.sourceAmountSwapped.toString()),u=i.destinationAmountSwapped.mul(new ze((1-o)*1e4)).div(new ze(1e4));return{allTrade:i.sourceAmountSwapped.eq(t),amountIn:t,amountOut:i.destinationAmountSwapped,minAmountOut:u,executionPrice:s,fee:i.tradeFee,priceImpact:e.poolPrice.sub(s).div(e.poolPrice)}}computePairAmount({poolInfo:e,baseReserve:t,quoteReserve:n,amount:o,slippage:r,epochInfo:i,baseIn:s}){var I,k,w,S,x,K,T,C,M;let u=1-Number(r.toSignificant())/100,a=new ze(new Vt(o).mul(10**e[s?"mintA":"mintB"].decimals).mul(u).toFixed(0)),c=xe(a,e[s?"mintA":"mintB"].extensions.feeConfig,i,!1),l=a.sub((I=c.fee)!=null?I:new ze(0)),d=new ze(new Vt(e.lpAmount).mul(10**e.lpMint.decimals).toFixed(0,Vt.ROUND_DOWN));this.logDebug("baseReserve:",t.toString(),"quoteReserve:",n.toString()),this.logDebug("tokenIn:",s?e.mintA.symbol:e.mintB.symbol,"amountIn:",a.toString(),"amountInFee:",(w=(k=c.fee)==null?void 0:k.toString())!=null?w:0,"anotherToken:",s?e.mintB.symbol:e.mintA.symbol,"slippage:",`${r.toSignificant()}%`);let p=s?"base":"quote";this.logDebug("input side:",p);let f=l.mul(d).div(p==="base"?t:n),y={amount:Pt,fee:void 0,expirationTime:void 0};if(!l.isZero()){let v=Dd(f,t,n,d);this.logDebug("lpAmountData:",{amountA:v.amountA.toString(),amountB:v.amountB.toString()}),y=xe(v[s?"amountB":"amountA"],e[s?"mintB":"mintA"].extensions.feeConfig,i,!0)}let b=new Je(new ze(1)).add(r),g=new Je(new ze(1)).sub(r),P=xe(b.mul(y.amount.sub((S=y.fee)!=null?S:new ze(0))).quotient,e[s?"mintB":"mintA"].extensions.feeConfig,i,!0),h=xe(g.mul(y.amount.sub((x=y.fee)!=null?x:new ze(0))).quotient,e[s?"mintB":"mintA"].extensions.feeConfig,i,!0);return this.logDebug("anotherAmount:",y.amount.toString(),"anotherAmountFee:",(T=(K=y.fee)==null?void 0:K.toString())!=null?T:0,"maxAnotherAmount:",P.amount.toString(),"maxAnotherAmountFee:",(M=(C=P.fee)==null?void 0:C.toString())!=null?M:0),{inputAmountFee:c,anotherAmount:y,maxAnotherAmount:P,minAnotherAmount:h,liquidity:f}}};function Dd(m,e,t,n){let o=m.mul(e).div(n);!o.isZero()&&!m.mul(e).mod(n).isZero()&&(o=o.add(new ze(1)));let r=m.mul(t).div(n);return!r.isZero()&&!m.mul(t).mod(n).isZero()&&(r=r.add(new ze(1))),{amountA:o,amountB:r}}import{PublicKey as $n}from"@solana/web3.js";import{createTransferInstruction as vc,TOKEN_PROGRAM_ID as Qe,TOKEN_2022_PROGRAM_ID as Cr}from"@solana/spl-token";import Rr from"bn.js";import gi from"decimal.js";var Rc={[ns.toBase58()]:3},Lc={3:ns};var aa=_([he(5),he(8),O("ownAddress"),A("vaultSignerNonce"),O("baseMint"),O("quoteMint"),O("baseVault"),A("baseDepositsTotal"),A("baseFeesAccrued"),O("quoteVault"),A("quoteDepositsTotal"),A("quoteFeesAccrued"),A("quoteDustThreshold"),O("requestQueue"),O("eventQueue"),O("bids"),O("asks"),A("baseLotSize"),A("quoteLotSize"),A("feeRateBps"),A("referrerRebatesAccrued"),he(7)]),Oc={3:aa};import{PublicKey as Nc}from"@solana/web3.js";var Sr=fe("Serum"),Kr=class{static getProgramId(e){let t=Lc[e];return t||Sr.logWithError("invalid version","version",e),t}static getVersion(e){let t=e.toBase58(),n=Rc[t];return n||Sr.logWithError("invalid program id","programId",t),n}static getStateLayout(e){let t=Oc[e];return t||Sr.logWithError(!!t,"invalid version","version",e),t}static getLayouts(e){return{state:this.getStateLayout(e)}}static getAssociatedAuthority({programId:e,marketId:t}){let n=[t.toBuffer()],o=0,r;for(;o<100;){try{let i=n.concat(Buffer.from([o]),Buffer.alloc(7));r=Nc.createProgramAddressSync(i,e)}catch(i){if(i instanceof TypeError)throw i;o++;continue}return{publicKey:r,nonce:o}}return Sr.logWithError("unable to find a viable program address nonce","params",{programId:e,marketId:t}),{publicKey:Nc.default,nonce:o}}};import{PublicKey as ne,SystemProgram as Wd,TransactionInstruction as qd}from"@solana/web3.js";import Zn from"bn.js";import{ASSOCIATED_TOKEN_PROGRAM_ID as Ud,TOKEN_2022_PROGRAM_ID as Gd,TOKEN_PROGRAM_ID as Xd}from"@solana/spl-token";function zd(m,e,t,n,o,r,i,s,u,a,c,l,d,p,f){var w;let y=[],b=[B({pubkey:Xd,isWritable:!1}),B({pubkey:Gd,isWritable:!1}),B({pubkey:Ud,isWritable:!1}),B({pubkey:Wd.programId,isWritable:!1}),B({pubkey:e,isSigner:!0})];b.push(B({pubkey:t})),b.push(B({pubkey:o}));let g=[u,a],P=[c,l],h=[r,i,s];for(let S=0;S<g.length;S++){let x=g[S],K=h[S]===x.mintA.address;if(b.push(B({pubkey:new ne(x.programId),isWritable:!1})),S===g.length-1?b.push(B({pubkey:o})):b.push(B({pubkey:n})),b.push(B({pubkey:new ne(h[S])})),b.push(B({pubkey:new ne(h[S+1])})),x.version===6){let T=P[S];b.push(B({pubkey:new ne(T.config.id)})),b.push(B({pubkey:new ne(T.id)})),b.push(B({pubkey:new ne(K?T.vault.A:T.vault.B)})),b.push(B({pubkey:new ne(K?T.vault.B:T.vault.A)})),b.push(B({pubkey:new ne(x.observationId)})),b.push(B({pubkey:Pn})),b.push(B({pubkey:Xe(new ne(x.programId),new ne(x.id)).publicKey})),y.push(Qd(x.sqrtPriceX64.toString(),K));for(let C of(w=f[S])!=null?w:[])b.push(B({pubkey:new ne(C)}))}else if(x.version===5){let T=P[S];b.push(B({pubkey:new ne(T.id)})),b.push(B({pubkey:new ne(T.authority),isWritable:!1})),b.push(B({pubkey:new ne(T.marketProgramId)})),b.push(B({pubkey:new ne(T.marketAuthority)})),b.push(B({pubkey:Ha,isWritable:!1})),b.push(B({pubkey:new ne(T.openOrders)})),b.push(B({pubkey:new ne(T.vault.A)})),b.push(B({pubkey:new ne(T.vault.B)})),b.push(B({pubkey:new ne(T.id)})),b.push(B({pubkey:new ne(T.id)})),b.push(B({pubkey:new ne(T.id)})),b.push(B({pubkey:new ne(T.id)})),b.push(B({pubkey:new ne(T.id)})),b.push(B({pubkey:new ne(T.id)})),b.push(B({pubkey:new ne(T.marketId)})),b.push(B({pubkey:new ne(T.marketBids)})),b.push(B({pubkey:new ne(T.marketAsks)})),b.push(B({pubkey:new ne(T.marketEventQueue)})),b.push(B({pubkey:new ne(T.marketBaseVault)})),b.push(B({pubkey:new ne(T.marketQuoteVault)}))}else if(x.version===4){let T=P[S],C=x.status!==1;b.push(B({pubkey:new ne(T.id)})),b.push(B({pubkey:new ne(T.authority),isWritable:!1})),b.push(B({pubkey:new ne(C?T.id:T.marketProgramId)})),b.push(B({pubkey:new ne(C?T.id:T.marketAuthority)})),b.push(B({pubkey:new ne(C?T.id:T.openOrders)})),b.push(B({pubkey:new ne(T.vault.A)})),b.push(B({pubkey:new ne(T.vault.B)})),b.push(B({pubkey:new ne(C?T.id:T.marketId)})),b.push(B({pubkey:new ne(C?T.id:T.marketBids)})),b.push(B({pubkey:new ne(C?T.id:T.marketAsks)})),b.push(B({pubkey:new ne(C?T.id:T.marketEventQueue)})),b.push(B({pubkey:new ne(C?T.id:T.marketBaseVault)})),b.push(B({pubkey:new ne(C?T.id:T.marketQuoteVault)}))}else if(x.version===7){let T=P[S];b.push(B({pubkey:new ne(T.authority)})),b.push(B({pubkey:new ne(T.config.id)})),b.push(B({pubkey:new ne(T.id)})),b.push(B({pubkey:new ne(K?T.vault.A:T.vault.B)})),b.push(B({pubkey:new ne(K?T.vault.B:T.vault.A)})),b.push(B({pubkey:new ne(x.observationId)}))}else throw Error("pool type error")}let I=_([D("insId"),A("amountIn"),A("amountOut"),Q(te(),y.length,"clmmPriceLimit")]),k=Buffer.alloc(I.span);return I.encode({insId:0,amountIn:d,amountOut:p,clmmPriceLimit:y},k),new qd({keys:b,programId:m,data:k})}function Qd(m,e){if(m)if(e){let t=new Zn(m).div(new Zn(25));return t.gt(sr)?t:sr}else{let t=new Zn(m).mul(new Zn(25));return t.lt(ar)?t:ar}else return e?sr:ar}function Mc({routeProgram:m,ownerInfo:e,inputMint:t,swapInfo:n}){var o,r,i,s,u,a,c;if(n.routeType==="amm")if(n.poolInfo[0].version===6){let l=n.poolKey[0],d=it(l),p=t.equals(d.mintA.address)?_t.add(Bt):Ft.sub(Bt);return Ke.makeSwapBaseInInstructions({poolInfo:l,poolKeys:l,observationId:n.poolInfo[0].observationId,ownerInfo:{wallet:e.wallet,tokenAccountA:d.mintA.address.equals(t)?e.sourceToken:e.destinationToken,tokenAccountB:d.mintA.address.equals(t)?e.destinationToken:e.sourceToken},inputMint:t,amountIn:n.amountIn.amount.raw,amountOutMin:n.minAmountOut.amount.raw.sub((r=(o=n.minAmountOut.fee)==null?void 0:o.raw)!=null?r:new Zn(0)),sqrtPriceLimitX64:p,remainingAccounts:(i=n.remainingAccounts[0])!=null?i:[]})}else if(n.poolInfo[0].version===7){let l=n.poolInfo[0],d=t.toString()===n.poolInfo[0].mintA.address;return{signers:[],instructions:[Ir(l.programId,e.wallet,l.authority,l.configId,l.id,e.sourceToken,e.destinationToken,d?l.vaultA:l.vaultB,d?l.vaultB:l.vaultA,d?l.mintProgramA:l.mintProgramB,d?l.mintProgramB:l.mintProgramA,new ne(l[d?"mintA":"mintB"].address),new ne(l[d?"mintB":"mintA"].address),l.observationId,n.amountIn.amount.raw,n.minAmountOut.amount.raw)],lookupTableAddress:[],instructionTypes:[d?q.CpmmSwapBaseIn:q.CpmmSwapBaseOut],address:{}}}else{let l=n.poolKey[0];return{signers:[],instructions:[pr({poolKeys:l,version:n.poolInfo[0].pooltype.includes("StablePool")?5:4,userKeys:{tokenAccountIn:e.sourceToken,tokenAccountOut:e.destinationToken,owner:e.wallet},amountIn:n.amountIn.amount.raw,amountOut:n.minAmountOut.amount.raw.sub((u=(s=n.minAmountOut.fee)==null?void 0:s.raw)!=null?u:new Zn(0)),fixedSide:"in"})],lookupTableAddress:l.lookupTableAccount?[l.lookupTableAccount]:[],instructionTypes:[n.poolInfo[0].pooltype.includes("StablePool")?q.AmmV5SwapBaseIn:q.AmmV4SwapBaseIn],address:{}}}else if(n.routeType==="route"){let l=n.poolInfo[0],d=n.poolInfo[1],p=n.poolKey[0],f=n.poolKey[1];if(e.routeToken===void 0)throw Error("owner route token account check error");return{signers:[],instructions:[zd(m,e.wallet,e.sourceToken,e.routeToken,e.destinationToken,t.toString(),n.middleToken.mint.toString(),n.outputMint.toString(),l,d,p,f,n.amountIn.amount.raw,n.minAmountOut.amount.raw.sub((c=(a=n.minAmountOut.fee)==null?void 0:a.raw)!=null?c:new Zn(0)),n.remainingAccounts)],instructionTypes:[q.RouteSwap],lookupTableAddress:[p.lookupTableAccount,f.lookupTableAccount].filter(y=>y!==void 0),address:{}}}else throw Error("route type error")}var yn=new Rr(0),Ai=class extends Ne{constructor(e){super(e)}async getWSolAccounts(){this.scope.checkOwner(),await this.scope.account.fetchWalletTokenAccounts();let e=this.scope.account.tokenAccounts.filter(t=>t.mint.equals(j));return e.sort((t,n)=>t.isAssociated?1:n.isAssociated||t.amount.lt(n.amount)?-1:1),e}async unWrapWSol(e){let{amount:t,tokenProgram:n,txVersion:o=1,feePayer:r}=e,i=await this.getWSolAccounts(),s=this.createTxBuilder(r);s.addCustomComputeBudget(e.computeBudgetConfig);let u=$(t);for(let a=0;a<i.length;a++)u.gte(i[a].amount)?(s.addInstruction({instructions:[cn({tokenAccount:i[a].publicKey,payer:this.scope.ownerPubKey,owner:this.scope.ownerPubKey,programId:n})]}),u.sub(i[a].amount)):s.addInstruction({instructions:[cn({tokenAccount:i[a].publicKey,payer:this.scope.ownerPubKey,owner:this.scope.ownerPubKey,programId:n})]});return s.versionBuild({txVersion:o})}async wrapWSol(e,t,n,o){let r=this.createTxBuilder(o),i=await hn({connection:this.scope.connection,owner:this.scope.ownerPubKey,payer:this.scope.ownerPubKey,amount:e,skipCloseAccount:!0});return r.addInstruction(i),r.versionBuild({txVersion:n!=null?n:1})}async swap({swapInfo:e,swapPoolKeys:t,ownerInfo:n,computeBudgetConfig:o,routeProgram:r,txVersion:i,feePayer:s}){let u=this.createTxBuilder(s),a=e.amountIn,c=e.amountOut,l=a.amount.token.mint.equals(j),d=c.amount.token.mint.equals(j),p=a.amount.token.mint,f=c.amount.token.mint,{account:y,instructionParams:b}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:a.amount.token.isToken2022?Cr:Qe,mint:p,notUseTokenAccount:l,owner:this.scope.ownerPubKey,skipCloseAccount:!l,createInfo:l?{payer:this.scope.ownerPubKey,amount:a.amount.raw}:void 0,associatedOnly:l?!1:n.associatedOnly,checkCreateATAOwner:n.checkCreateATAOwner});if(b&&u.addInstruction(b),y===void 0)throw Error("input account check error");let g;if(e.routeType==="route"&&!d)g=this.scope.account.getAssociatedTokenAccount(f,c.amount.token.isToken2022?Cr:Qe);else{let{account:k,instructionParams:w}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:c.amount.token.isToken2022?Cr:Qe,mint:f,notUseTokenAccount:d,owner:this.scope.ownerPubKey,skipCloseAccount:!0,createInfo:{payer:this.scope.ownerPubKey,amount:0},associatedOnly:d?!1:n.associatedOnly,checkCreateATAOwner:n.checkCreateATAOwner});g=k,w&&u.addInstruction(w)}d&&u.addInstruction({endInstructions:[cn({owner:this.scope.ownerPubKey,payer:this.scope.ownerPubKey,tokenAccount:g,programId:Qe})],endInstructionTypes:[q.CloseAccount]});let P;if(e.routeType==="route"){let k=e.middleToken;P=this.scope.account.getAssociatedTokenAccount(k.mint,k.isToken2022?Cr:Qe)}let h=t||await this.computePoolToPoolKeys({pools:e.poolInfoList}),I=Mc({routeProgram:r,inputMint:p,swapInfo:W(N({},e),{poolInfo:[...e.poolInfoList],poolKey:h,outputMint:f}),ownerInfo:{wallet:this.scope.ownerPubKey,sourceToken:y,routeToken:P,destinationToken:g}});if(e.feeConfig!==void 0){let k=this.createTxBuilder();k.addInstruction({instructions:[vc(y,e.feeConfig.feeAccount,this.scope.ownerPubKey,e.feeConfig.feeAmount.toNumber())],instructionTypes:[q.TransferAmount]}),k.addInstruction(I);let{transactions:w}=i===0?await k.sizeCheckBuildV0():await k.sizeCheckBuild();w.length<2&&u.addInstruction({instructions:[vc(y,e.feeConfig.feeAccount,this.scope.ownerPubKey,e.feeConfig.feeAmount.toNumber())],instructionTypes:[q.TransferAmount]})}return u.addInstruction(I),i===0?u.sizeCheckBuildV0({computeBudgetConfig:o,address:I.address}):u.sizeCheckBuild({computeBudgetConfig:o,address:I.address})}async fetchRoutePoolBasicInfo(e){let{amm:t=Ei,clmm:n=Mn,cpmm:o=Wi}=e||{},r=await this.scope.connection.getProgramAccounts(t,{dataSlice:{offset:ii.offsetOf("baseMint"),length:64}}),i=_([O("baseMint"),O("quoteMint")]),s=r.map(p=>({id:p.pubkey,version:4,mintA:i.decode(p.account.data).baseMint,mintB:i.decode(p.account.data).quoteMint})),u=_([O("mintA"),O("mintB")]),c=(await this.scope.connection.getProgramAccounts(n,{filters:[{dataSize:qn.span}],dataSlice:{offset:qn.offsetOf("mintA"),length:64}})).map(p=>{let f=u.decode(p.account.data);return{id:p.pubkey,version:6,mintA:f.mintA,mintB:f.mintB}}),d=(await this.scope.connection.getProgramAccounts(o,{dataSlice:{offset:Br.offsetOf("mintA"),length:64}})).map(p=>{let f=u.decode(p.account.data);return{id:p.pubkey,version:7,mintA:f.mintA,mintB:f.mintB}});return{clmmPools:c,ammPools:s,cpmmPools:d}}getAllRoute({inputMint:e,outputMint:t,clmmPools:n,ammPools:o,cpmmPools:r}){e=e.toString()===$n.default.toString()?j:e,t=t.toString()===$n.default.toString()?j:t;let i={},s={},u={},a=[],c={};for(let d of n!=null?n:[]){if((d.mintA.equals(e)&&d.mintB.equals(t)||d.mintA.equals(t)&&d.mintB.equals(e))&&(a.push(d),s[d.id.toString()]=d),d.mintA.equals(e)){let p=d.mintB.toString();c[p]===void 0&&(c[p]={mintProgram:Qe,in:[],out:[],mDecimals:0}),c[p].in.push(d)}if(d.mintB.equals(e)){let p=d.mintA.toString();c[p]===void 0&&(c[p]={mintProgram:Qe,in:[],out:[],mDecimals:0}),c[p].in.push(d)}if(d.mintA.equals(t)){let p=d.mintB.toString();c[p]===void 0&&(c[p]={mintProgram:Qe,in:[],out:[],mDecimals:0}),c[p].out.push(d)}if(d.mintB.equals(t)){let p=d.mintA.toString();c[p]===void 0&&(c[p]={mintProgram:Qe,in:[],out:[],mDecimals:0}),c[p].out.push(d)}}let l=[];for(let d of o)(d.mintA.equals(e)&&d.mintB.equals(t)||d.mintA.equals(t)&&d.mintB.equals(e))&&(a.push(d),i[d.id.toBase58()]=d,l.push(d)),d.mintA.equals(e)&&(c[d.mintB.toBase58()]===void 0&&(c[d.mintB.toBase58()]={mintProgram:Qe,in:[],out:[],mDecimals:0}),c[d.mintB.toBase58()].in.push(d)),d.mintB.equals(e)&&(c[d.mintA.toBase58()]===void 0&&(c[d.mintA.toBase58()]={mintProgram:Qe,in:[],out:[],mDecimals:0}),c[d.mintA.toBase58()].in.push(d)),d.mintA.equals(t)&&(c[d.mintB.toBase58()]===void 0&&(c[d.mintB.toBase58()]={mintProgram:Qe,in:[],out:[],mDecimals:0}),c[d.mintB.toBase58()].out.push(d)),d.mintB.equals(t)&&(c[d.mintA.toBase58()]===void 0&&(c[d.mintA.toBase58()]={mintProgram:Qe,in:[],out:[],mDecimals:0}),c[d.mintA.toBase58()].out.push(d));for(let d of r)(d.mintA.equals(e)&&d.mintB.equals(t)||d.mintA.equals(t)&&d.mintB.equals(e))&&(a.push(d),u[d.id.toBase58()]=d),d.mintA.equals(e)&&(c[d.mintB.toBase58()]===void 0&&(c[d.mintB.toBase58()]={mintProgram:Qe,in:[],out:[],mDecimals:0}),c[d.mintB.toBase58()].in.push(d)),d.mintB.equals(e)&&(c[d.mintA.toBase58()]===void 0&&(c[d.mintA.toBase58()]={mintProgram:Qe,in:[],out:[],mDecimals:0}),c[d.mintA.toBase58()].in.push(d)),d.mintA.equals(t)&&(c[d.mintB.toBase58()]===void 0&&(c[d.mintB.toBase58()]={mintProgram:Qe,in:[],out:[],mDecimals:0}),c[d.mintB.toBase58()].out.push(d)),d.mintB.equals(t)&&(c[d.mintA.toBase58()]===void 0&&(c[d.mintA.toBase58()]={mintProgram:Qe,in:[],out:[],mDecimals:0}),c[d.mintA.toBase58()].out.push(d));for(let d of Object.keys(c)){if(c[d].in.length===1&&c[d].out.length===1&&c[d].in[0].id.equals(c[d].out[0].id)){delete c[d];continue}if(c[d].in.length===0||c[d].out.length===0){delete c[d];continue}let p=c[d];for(let f of p.in)for(let y of p.out)f.version===6&&s[f.id.toString()]===void 0?s[f.id.toString()]=f:f.version===7&&u[f.id.toString()]===void 0?u[f.id.toString()]=f:(f.version===4||f.version===5)&&i[f.id.toString()]===void 0&&(i[f.id.toString()]=f),y.version===6&&s[y.id.toString()]===void 0?s[y.id.toString()]=y:y.version===7&&u[y.id.toString()]===void 0?u[y.id.toString()]=y:(y.version===4||y.version===5)&&i[y.id.toString()]===void 0&&(i[y.id.toString()]=y)}return{directPath:a,addLiquidityPools:l,routePathDict:c,needSimulate:Object.values(i),needTickArray:Object.values(s),cpmmPoolList:Object.values(u)}}async fetchSwapRoutesData({routes:e,inputMint:t,outputMint:n}){let o=new Set([...e.needTickArray.map(y=>[y.mintA.toBase58(),y.mintB.toBase58()]).flat(),t.toString(),n.toString()]);console.log("fetching amm pools info, total: ",e.needSimulate.length);let r=await this.scope.liquidity.getRpcPoolInfos(e.needSimulate.map(y=>y.id)),i=br(r),s={};Object.values(i).forEach(y=>{o.delete(y.mintA.address),s[y.mintA.address]={address:new $n(y.mintA.address),programId:Qe,mintAuthority:null,supply:BigInt(0),decimals:y.mintA.decimals,isInitialized:!0,freezeAuthority:null,tlvData:Buffer.from("0","hex"),feeConfig:void 0},o.delete(y.mintB.address),s[y.mintB.address]={address:new $n(y.mintB.address),programId:Qe,mintAuthority:null,supply:BigInt(0),decimals:y.mintB.decimals,isInitialized:!0,freezeAuthority:null,tlvData:Buffer.from("0","hex"),feeConfig:void 0}}),console.log("fetching cpmm pools info, total: ",e.cpmmPoolList.length);let u=await this.scope.cpmm.getRpcPoolInfos(e.cpmmPoolList.map(y=>y.id.toBase58()),!0);Object.values(u).forEach(y=>{let[b,g]=[y.mintA.toBase58(),y.mintB.toBase58()];y.mintProgramA.equals(Qe)?(o.delete(b),s[b]={address:y.mintA,programId:y.mintProgramA,mintAuthority:null,supply:BigInt(0),decimals:y.mintDecimalA,isInitialized:!0,freezeAuthority:null,tlvData:Buffer.from("0","hex"),feeConfig:void 0}):o.add(b),y.mintProgramB.equals(Qe)?(o.delete(g),s[g]={address:y.mintB,programId:y.mintProgramB,mintAuthority:null,supply:BigInt(0),decimals:y.mintDecimalB,isInitialized:!0,freezeAuthority:null,tlvData:Buffer.from("0","hex"),feeConfig:void 0}):o.add(g)}),console.log("fetching mints info, total: ",o.size);let a=await io({connection:this.scope.connection,mints:Array.from(o).map(y=>new $n(y))});s=N(N({},s),a);let c=this.scope.cpmm.toComputePoolInfos({pools:u,mintInfos:s});console.log("fetching clmm pools info, total:",e.needTickArray.length);let l=await this.scope.clmm.getRpcClmmPoolInfos({poolIds:e.needTickArray.map(y=>y.id)}),{computeClmmPoolInfo:d,computePoolTickData:p}=await this.scope.clmm.getComputeClmmPoolInfos({clmmPoolsRpcInfo:l,mintInfos:s}),f=Object.keys(e.routePathDict).reduce((y,b)=>W(N({},y),{[b]:W(N({},e.routePathDict[b]),{mintProgram:s[b].programId,mDecimals:s[b].decimals,in:e.routePathDict[b].in.map(g=>i[g.id.toBase58()]||d[g.id.toBase58()]||c[g.id.toBase58()]),out:e.routePathDict[b].out.map(g=>i[g.id.toBase58()]||d[g.id.toBase58()]||c[g.id.toBase58()])})}),{});return{mintInfos:s,ammPoolsRpcInfo:r,ammSimulateCache:i,clmmPoolsRpcInfo:l,computeClmmPoolInfo:d,computePoolTickData:p,computeCpmmData:c,routePathDict:f}}getAllRouteComputeAmountOut({inputTokenAmount:e,outputToken:t,directPath:n,routePathDict:o,simulateCache:r,tickCache:i,slippage:s,chainTime:u,epochInfo:a,feeConfig:c}){var g,P,h,I,k,w,S,x,K;let l=c===void 0?new Rr(0):e.raw.mul(new Rr(c.feeBps.toNumber())).div(new Rr(1e4)),d=e.raw.sub(l),p=new Be(e.token,d),f=c===void 0?void 0:{feeAmount:l,feeAccount:c.feeAccount},y=W(N({},t),{address:at(t.address).toString()}),b=[];for(let T of n)try{b.push(W(N({},this.computeAmountOut({itemPool:T,tickCache:i,simulateCache:r,chainTime:u,epochInfo:a,slippage:s,outputToken:y,amountIn:p})),{feeConfig:f}))}catch(C){this.logDebug("direct error",T.version,T.id.toString(),C.message)}this.logDebug("direct done");for(let[T,C]of Object.entries(o)){let M={chainId:101,address:T,programId:C.mintProgram.toBase58(),logoURI:"",symbol:"",name:"",decimals:C.mDecimals,tags:[],extensions:{}},v=C.in.map(L=>{try{return{pool:L,data:this.computeAmountOut({itemPool:L,tickCache:i,simulateCache:r,chainTime:u,epochInfo:a,slippage:s,outputToken:M,amountIn:p})}}catch(F){this.logDebug("route in error",L.version,L.id.toString(),F.message);return}}).sort((L,F)=>{var re,ye,ue,me;let X=L===void 0?yn:L.data.amountOut.amount.raw.sub((ye=(re=L.data.amountOut.fee)==null?void 0:re.raw)!=null?ye:yn),H=F===void 0?yn:F.data.amountOut.amount.raw.sub((me=(ue=F.data.amountOut.fee)==null?void 0:ue.raw)!=null?me:yn);return X.lt(H)?1:-1})[0];if(v===void 0)continue;let R=new Be(mr(M),v.data.amountOut.amount.raw.sub((P=(g=v.data.amountOut.fee)==null?void 0:g.raw)!=null?P:yn));for(let L of C.out)try{let F=this.computeAmountOut({itemPool:L,tickCache:i,simulateCache:r,chainTime:u,epochInfo:a,slippage:s,outputToken:y,amountIn:R});b.push(W(N({},F),{allTrade:!!(v.data.allTrade&&F.allTrade),amountIn:v.data.amountIn,amountOut:F.amountOut,minAmountOut:F.minAmountOut,currentPrice:void 0,executionPrice:new gi(new At({baseToken:v.data.amountIn.amount.token,denominator:v.data.amountIn.amount.raw,quoteToken:F.amountOut.amount.token,numerator:F.amountOut.amount.raw.sub((I=(h=F.amountOut.fee)==null?void 0:h.raw)!=null?I:yn)}).toFixed()),priceImpact:new gi(v.data.priceImpact.add(F.priceImpact).toFixed()),fee:[v.data.fee[0],F.fee[0]],routeType:"route",poolInfoList:[v.pool,L],remainingAccounts:[v.data.remainingAccounts[0],F.remainingAccounts[0]],minMiddleAmountFee:(k=F.amountOut.fee)!=null&&k.raw?new Be(v.data.amountOut.amount.token,((S=(w=v.data.amountOut.fee)==null?void 0:w.raw)!=null?S:yn).add((K=(x=F.amountOut.fee)==null?void 0:x.raw)!=null?K:yn)):void 0,middleToken:v.data.amountOut.amount.token,poolReady:v.data.poolReady&&F.poolReady,poolType:[v.data.poolType,F.poolType],feeConfig:f,expirationTime:jt(v.data.expirationTime,F.expirationTime)}))}catch(F){this.logDebug("route out error",L.version,L.id.toString(),F.message)}}return b.filter(T=>(T.allTrade||this.logDebug(`pool ${T.poolInfoList.map(C=>C.id.toString()).join(",")} filter out since not all trade`),T.allTrade)).sort((T,C)=>T.amountOut.amount.raw.sub(C.amountOut.amount.raw).gt(yn)?-1:1)}computeAmountOut({itemPool:e,tickCache:t,simulateCache:n,chainTime:o,epochInfo:r,slippage:i,outputToken:s,amountIn:u}){if(e.version===6){let{allTrade:a,realAmountIn:c,amountOut:l,minAmountOut:d,expirationTime:p,currentPrice:f,executionPrice:y,priceImpact:b,fee:g,remainingAccounts:P,executionPriceX64:h}=Le.computeAmountOutFormat({poolInfo:e,tickArrayCache:t[e.id.toString()],amountIn:u.raw,tokenOut:s,slippage:i,epochInfo:r,catchLiquidityInsufficient:!0});return{allTrade:a,amountIn:c,amountOut:l,minAmountOut:d,currentPrice:new gi(f.toFixed()),executionPrice:new gi(y.toFixed()),priceImpact:new gi(b.toFixed()),fee:[g],remainingAccounts:[P],routeType:"amm",poolInfoList:[e],poolReady:e.startTime<o,poolType:"CLMM",slippage:i,clmmExPriceX64:[h],expirationTime:jt(c.expirationTime,p)}}else if(e.version===7){let{allTrade:a,executionPrice:c,amountOut:l,minAmountOut:d,priceImpact:p,fee:f}=this.scope.cpmm.computeSwapAmount({pool:e,outputMint:s.address,amountIn:u.raw,slippage:i});return{allTrade:a,amountIn:{amount:u,fee:void 0,expirationTime:void 0},amountOut:{amount:oi(W(N({},s),{amount:l})),fee:void 0,expirationTime:void 0},minAmountOut:{amount:oi(W(N({},s),{amount:d})),fee:void 0,expirationTime:void 0},currentPrice:e.poolPrice,executionPrice:c,priceImpact:p,fee:[new Be(u.token,f)],remainingAccounts:[],routeType:"amm",poolInfoList:[e],poolReady:e.openTime.toNumber()<o,poolType:"CPMM",slippage:i,clmmExPriceX64:[void 0],expirationTime:void 0}}else{if(![1,6,7].includes(n[e.id.toString()].status))throw Error("swap error");let{amountOut:a,minAmountOut:c,currentPrice:l,executionPrice:d,priceImpact:p,fee:f}=this.scope.liquidity.computeAmountOut({poolInfo:n[e.id.toString()],amountIn:u.raw,mintIn:u.token.mint,mintOut:s.address,slippage:i});return{amountIn:{amount:u,fee:void 0,expirationTime:void 0},amountOut:{amount:oi(W(N({},s),{amount:a})),fee:void 0,expirationTime:void 0},minAmountOut:{amount:oi(W(N({},s),{amount:c})),fee:void 0,expirationTime:void 0},currentPrice:l,executionPrice:d,priceImpact:p,fee:[new Be(u.token,f)],routeType:"amm",poolInfoList:[e],remainingAccounts:[],poolReady:Number(n[e.id].openTime)<o,poolType:e.version===5?"STABLE":void 0,expirationTime:void 0,allTrade:!0,slippage:i,clmmExPriceX64:[void 0]}}}async computePoolToPoolKeys({pools:e,clmmRpcData:t={},ammRpcData:n={}}){let o=new Set(e.filter(a=>a.version===6&&!t[a.id.toString()]).map(a=>a.id.toString()));if(o.size>0){let a=await this.scope.clmm.getRpcClmmPoolInfos({poolIds:Array.from(o)});Object.keys(a).forEach(c=>{t[c]=a[c]})}let r=new Set(e.filter(a=>a.version===4&&!n[a.id.toString()]).map(a=>a.id.toString()));if(r.size>0){let a=await this.scope.liquidity.getRpcPoolInfos(Array.from(r));Object.keys(a).forEach(c=>{n[c]=a[c]})}let i=new Set(e.filter(a=>a.version===4).map(a=>a.marketId)),s={};i.size>0&&(await Re(this.scope.connection,Array.from(i).map(c=>({pubkey:new $n(c)})))).forEach(c=>{if(!c.accountInfo)return;let l=aa.decode(c.accountInfo.data);s[c.pubkey.toBase58()]={marketId:c.pubkey.toString(),marketProgramId:c.accountInfo.owner.toString(),marketAuthority:Kr.getAssociatedAuthority({programId:c.accountInfo.owner,marketId:c.pubkey}).publicKey.toString(),marketBaseVault:l.baseVault.toString(),marketQuoteVault:l.quoteVault.toString(),marketBids:l.bids.toString(),marketAsks:l.asks.toString(),marketEventQueue:l.eventQueue.toString()}});let u=[];return e.forEach(a=>{if(a.version===6){let c=t[a.id.toString()],l={programId:a.programId.toBase58(),id:a.id.toBase58(),mintA:a.mintA,mintB:a.mintB,openTime:String(a.startTime),vault:{A:c.vaultA.toBase58(),B:c.vaultB.toBase58()},config:W(N({},a.ammConfig),{id:a.ammConfig.id.toString(),defaultRange:0,defaultRangePoint:[]}),rewardInfos:[],observationId:a.observationId.toBase58(),exBitmapAccount:a.exBitmapAccount.toBase58()};u.push(l)}else if(a.version===4){let c=n[a.id.toString()],l=N({programId:a.programId,id:a.id,mintA:a.mintA,mintB:a.mintB,openTime:String(a.openTime),vault:{A:c.baseVault.toBase58(),B:c.quoteVault.toBase58()},authority:ea({programId:new $n(a.programId)}).publicKey.toString(),openOrders:c.openOrders.toBase58(),targetOrders:c.targetOrders.toBase58(),mintLp:a.lpMint},s[a.marketId]);u.push(l)}else a.version===7&&u.push({observationId:a.observationId.toBase58(),programId:a.programId.toBase58(),id:a.id.toBase58(),mintA:a.mintA,mintB:a.mintB,openTime:String(a.openTime),authority:wo(a.programId).publicKey.toBase58(),vault:{A:a.vaultA.toBase58(),B:a.vaultB.toBase58()},mintLp:mt({address:a.mintLp.toBase58(),programId:Qe.toBase58(),decimals:a.lpDecimals}),config:W(N({id:a.configId.toBase58()},a.configInfo),{protocolFeeRate:a.configInfo.protocolFeeRate.toNumber(),tradeFeeRate:a.configInfo.tradeFeeRate.toNumber(),fundFeeRate:a.configInfo.fundFeeRate.toNumber(),createPoolFee:a.configInfo.createPoolFee.toString()})})}),u}};import{PublicKey as jd,Transaction as ua,TransactionInstruction as Yd}from"@solana/web3.js";import{TOKEN_PROGRAM_ID as Hd}from"@solana/spl-token";import _c from"bn.js";var dt=class extends Ne{static getPdaPoolId(e,t){return se([dt.SEED_CONFIG.pool.id,t.toBuffer()],e)}static getPdaOwnerId(e,t,n,o){return se([dt.SEED_CONFIG.owner.id,t.toBuffer(),n.toBuffer(),Buffer.from(new _c(o).toArray())],e)}static async getAllInfo({connection:e,programId:t,poolIds:n,wallet:o,chainTime:r}){if(n.length===0)return[];let i=n.map(c=>dt.getPdaPoolId(t,c).publicKey),s=[];for(let c=0;c<dt.VERSION_PROJECT.length;c++)s.push(...i.map(l=>dt.getPdaOwnerId(t,l,o,c).publicKey));let u=await Gt(e,[...i,...s]),a=[];for(let c=0;c<u.length;c++){let l=Math.floor(c/n.length),d=c%n.length,p=i[d],f=s[c],y=u[d],b=u[n.length+c];if(!(y&&b)||y.data.length!==dt.POOL_LAYOUT.span||b.data.length!==dt.OWNER_LAYOUT.span)continue;let g=dt.POOL_LAYOUT.decode(y.data),P=dt.OWNER_LAYOUT.decode(b.data),h=g.openTime.toNumber(),I=g.endTime.toNumber(),k=P.tokenInfo.map(x=>x.debtAmount.gt(new _c(0))).filter(x=>!x).length!==3,w=r>h&&r<I&&g.status===1,S=k&&w;a.push({programId:t,poolId:p,ammId:g.ammId,ownerAccountId:f,snapshotLpAmount:P.lpAmount,project:dt.VERSION_PROJECT[l],openTime:h,endTime:I,canClaim:S,canClaimErrorType:k?w?void 0:"outOfOperationalTime":"alreadyClaimIt",tokenInfo:g.tokenInfo.map((x,K)=>({mintAddress:x.mintAddress,mintVault:x.mintVault,mintDecimals:x.mintDecimals,perLpLoss:x.perLpLoss,debtAmount:P.tokenInfo[K].debtAmount.add(P.tokenInfo[K].claimedAmount)}))})}return a}async makeClaimTransaction({poolInfo:e,ownerInfo:t,feePayer:n}){t.wallet||this.scope.checkOwner();let o=this.createTxBuilder(n),r=t.wallet||this.scope.ownerPubKey,i=[];for(let a of e.tokenInfo){let{account:c,instructionParams:l}=await this.scope.account.getOrCreateTokenAccount({mint:a.mintAddress,owner:this.scope.ownerPubKey,notUseTokenAccount:a.mintAddress.equals(Fe.WSOL.mint),createInfo:{payer:r,amount:0},skipCloseAccount:!a.mintAddress.equals(Fe.WSOL.mint),associatedOnly:a.mintAddress.equals(Fe.WSOL.mint)?!1:t.associatedOnly});l&&o.addInstruction(l),i.push(c)}o.addInstruction({instructions:[dt.makeClaimInstruction({programId:e.programId,poolInfo:e,ownerInfo:{wallet:r,ownerPda:e.ownerAccountId,claimAddress:i}})]});let{transaction:s,signers:u}=o.build();return[{transaction:s,signer:u}]}async makeClaimAllTransaction({poolInfos:e,ownerInfo:t,feePayer:n}){let o=this.createTxBuilder(n),r=t.wallet||this.scope.ownerPubKey,i={};for(let c of e){let l=[];for(let d of c.tokenInfo){let{account:p,instructionParams:f}=await this.scope.account.getOrCreateTokenAccount({mint:d.mintAddress,owner:this.scope.ownerPubKey,notUseTokenAccount:d.mintAddress.equals(Fe.WSOL.mint),createInfo:{payer:r,amount:0},skipCloseAccount:!d.mintAddress.equals(Fe.WSOL.mint),associatedOnly:d.mintAddress.equals(Fe.WSOL.mint)?!1:t.associatedOnly});f&&o.addInstruction(f),p&&(i[d.mintAddress.toString()]=p,l.push(p))}o.addInstruction({instructions:[dt.makeClaimInstruction({programId:c.programId,poolInfo:c,ownerInfo:{wallet:r,ownerPda:c.ownerAccountId,claimAddress:l}})]})}let{transaction:s,signers:u}=o.build(),a=o.allInstructions;return ts(a,[r,...u.map(c=>c.publicKey)])?[{transaction:s,signer:u}]:[{transaction:new ua().add(...a.slice(0,o.AllTxData.instructions.length-1)),signer:u},{transaction:new ua().add(...a.slice(o.AllTxData.instructions.length-1)),signer:[]},{transaction:new ua().add(...o.AllTxData.endInstructions),signer:[]}]}static makeClaimInstruction({programId:e,poolInfo:t,ownerInfo:n}){let o=_([]),r=[{pubkey:n.wallet,isSigner:!0,isWritable:!0},{pubkey:t.poolId,isSigner:!1,isWritable:!0},{pubkey:n.ownerPda,isSigner:!1,isWritable:!0},...n.claimAddress.map(u=>({pubkey:u,isSigner:!1,isWritable:!0})),...t.tokenInfo.map(({mintVault:u})=>({pubkey:u,isSigner:!1,isWritable:!0})),{pubkey:Hd,isSigner:!1,isWritable:!1}],i=Buffer.alloc(o.span);o.encode({},i);let s=Buffer.from([10,66,208,184,161,6,191,98,...i]);return new Yd({keys:r,programId:e,data:s})}},Et=dt;Et.CLAIMED_NUM=3,Et.POOL_LAYOUT=_([he(8),D("bump"),D("status"),A("openTime"),A("endTime"),O("ammId"),Q(_([D("mintDecimals"),O("mintAddress"),O("mintVault"),A("perLpLoss"),A("totalClaimedAmount")]),dt.CLAIMED_NUM,"tokenInfo"),Q(A(),10,"padding")]),Et.OWNER_LAYOUT=_([he(8),D("bump"),D("version"),O("poolId"),O("owner"),A("lpAmount"),Q(_([O("mintAddress"),A("debtAmount"),A("claimedAmount")]),dt.CLAIMED_NUM,"tokenInfo"),Q(A(),4,"padding")]),Et.DEFAULT_POOL_ID=["58oQChx4yWmvKdwLLZzBi4ChoCc2fqCUWBkwMihLYQo2","6UmmUiYoBjSrhakAobJw8BvkmJtDVxaeBtbt7rxWo1mg","AVs9TA4nWDzfPJE9gGVNJMVhcQy3V9PGazuz33BfG2RA","DVa7Qmb5ct9RCpaU7UTpSaf3GVMYz17vNVU67XpdCRut","7XawhbbxtsRcQA8KTkHT9f9nc6d69UwqCDh6U5EEbEmX","6a1CsrpeZubDjEJE9s1CMVheB6HWM5d7m1cj2jkhyXhj","EoNrn8iUhwgJySD1pHu8Qxm5gSQqLK3za4m8xzD2RuEb","AceAyRTWt4PyB2pHqf2qhDgNZDtKVNaxgL8Ru3V4aN1P","6tmFJbMk5yVHFcFy7X2K8RwHjKLr6KVFLYXpgpBNeAxB"].map(e=>new jd(e)),Et.SEED_CONFIG={pool:{id:Buffer.from("pool_seed","utf8")},owner:{id:Buffer.from("user_claim_seed","utf8")}},Et.VERSION_PROJECT=[void 0,"Francium","Tulip","Larix"];import{PublicKey as wi}from"@solana/web3.js";import Ec from"bn.js";import{SYSVAR_CLOCK_PUBKEY as $d,TransactionInstruction as Fc}from"@solana/web3.js";import{TOKEN_PROGRAM_ID as Vc}from"@solana/spl-token";var Zd=_([D("instruction"),cu("amount")]),Pi=_([D("instruction")]);function Lr({programId:m},e){let t=[{pubkey:Vc,isSigner:!1,isWritable:!1},{pubkey:_a,isSigner:!1,isWritable:!1},...Object.entries(e).map(([o,r])=>({pubkey:r,isSigner:o==="userOwner",isWritable:!["authority","userOwner"].includes(o)}))],n=Buffer.alloc(Pi.span);return Pi.encode({instruction:2},n),new Fc({keys:t,programId:m,data:n})}function ca(m){let{poolConfig:e,userKeys:t,side:n}=m,o=n==="base"?t.baseTokenAccount:t.quoteTokenAccount,r=n==="base"?e.baseVault:e.quoteVault,i=Buffer.alloc(Pi.span);Pi.encode({instruction:2},i);let s=[{pubkey:Vc,isWritable:!1,isSigner:!1},{pubkey:$d,isWritable:!1,isSigner:!1},{pubkey:e.id,isWritable:!0,isSigner:!1},{pubkey:e.authority,isWritable:!1,isSigner:!1},{pubkey:r,isWritable:!0,isSigner:!1},{pubkey:o,isWritable:!0,isSigner:!1},{pubkey:t.ledgerAccount,isWritable:!0,isSigner:!1},{pubkey:t.owner,isWritable:!1,isSigner:!0}];return new Fc({programId:e.programId,keys:s,data:i})}var Jd={[_o.IDO_PROGRAM_ID_V1.toString()]:1,[_o.IDO_PROGRAM_ID_V2.toString()]:2,[_o.IDO_PROGRAM_ID_V3.toString()]:3,[_o.IDO_PROGRAM_ID_V4.toString()]:4},ko=class extends Ne{async claim({ownerInfo:e,idoKeys:t,associatedOnly:n=!0,checkCreateATAOwner:o=!1,txVersion:r,feePayer:i}){let s=this.createTxBuilder(i),u=Jd[t.programId];u||this.logAndCreateError("invalid version",u);let a=it(t),[c,l]=[!new Ec(e.coin).isZero(),!new Ec(e.pc).isZero()],d=a.projectInfo.mint.address.equals(j),{account:p,instructionParams:f}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:a.projectInfo.mint.programId,mint:a.projectInfo.mint.address,owner:this.scope.ownerPubKey,createInfo:{payer:this.scope.ownerPubKey,amount:0},skipCloseAccount:!d,notUseTokenAccount:d,associatedOnly:d?!1:n,checkCreateATAOwner:o});!p&&c&&this.logAndCreateError("target token accounts not found","mint",t.projectInfo.mint.address),c&&f&&s.addInstruction(f);let y=a.buyInfo.mint.address.equals(j),{account:b,instructionParams:g}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:a.buyInfo.mint.programId,mint:a.buyInfo.mint.address,owner:this.scope.ownerPubKey,createInfo:{payer:this.scope.ownerPubKey,amount:0},skipCloseAccount:!y,notUseTokenAccount:y,associatedOnly:y?!1:n,checkCreateATAOwner:o});if(!p&&l&&this.logAndCreateError("target token accounts not found","mint",t.projectInfo.mint.address),l&&g&&s.addInstruction(g),(!p||!b)&&this.logAndCreateError("target token accounts not found","mint",t.projectInfo.mint.address,t.buyInfo.mint.address),u===3)return s.addInstruction({instructions:[...c?[Lr({programId:a.programId},{idoId:a.id,authority:a.authority,poolTokenAccount:a.projectInfo.vault,userTokenAccount:p,userIdoInfo:new wi(e.userIdoInfo),userOwner:this.scope.ownerPubKey})]:[],...l?[Lr({programId:new wi(t.programId)},{idoId:a.id,authority:a.authority,poolTokenAccount:a.buyInfo.vault,userTokenAccount:b,userIdoInfo:new wi(e.userIdoInfo),userOwner:this.scope.ownerPubKey})]:[]]}).versionBuild({txVersion:r});if(u<3)return!c&&!l&&this.logAndCreateError("no claimable rewards"),s.addInstruction({instructions:[Lr({programId:a.programId},{idoId:a.id,authority:a.authority,poolQuoteTokenAccount:a.buyInfo.vault,poolBaseTokenAccount:a.projectInfo.vault,userQuoteTokenAccount:b,userBaseTokenAccount:p,userIdoInfo:new wi(e.userIdoInfo),userOwner:this.scope.ownerPubKey})]}).versionBuild({txVersion:r});let P={poolConfig:{id:a.id,programId:a.programId,authority:a.authority,baseVault:a.projectInfo.vault,quoteVault:a.buyInfo.vault,baseToken:t.projectInfo.mint,quoteToken:t.buyInfo.mint},userKeys:{baseTokenAccount:p,quoteTokenAccount:b,ledgerAccount:new wi(e.userIdoInfo),owner:this.scope.ownerPubKey}};return s.addInstruction({instructions:[...c?[ca(W(N({},P),{side:"base"}))]:[],...l?[ca(W(N({},P),{side:"quote"}))]:[]]}).versionBuild({txVersion:r})}};var ep=Buffer.from("vault_auth_seed","utf8"),oK=Buffer.from("global_config","utf8"),tp=Buffer.from("pool_vesting","utf8"),np=Buffer.from("platform_config","utf8"),op=Buffer.from("platform_fee_vault_auth_seed","utf8"),ip=Buffer.from("creator_fee_vault_auth_seed","utf8");function sn(m){return se([ep],m)}function ho(m,e,t){return se([vs,e.toBuffer(),t.toBuffer()],m)}function la(m,e,t){return se([_s,e.toBuffer(),t.toBuffer()],m)}function Jn(m){return se([Buffer.from("__event_authority","utf8")],m)}function ma(m,e){return se([np,e.toBuffer()],m)}function ki(m,e,t){return se([tp,e.toBuffer(),t.toBuffer()],m)}function eo(m,e,t){return se([e.toBuffer(),t.toBuffer()],m)}function da(m){return se([op],m)}function To(m,e,t){return se([e.toBuffer(),t.toBuffer()],m)}function Dc(m){return se([ip],m)}import{SystemProgram as Dt,TransactionInstruction as Ct}from"@solana/web3.js";import{ASSOCIATED_TOKEN_PROGRAM_ID as Or,TOKEN_2022_PROGRAM_ID as rp,TOKEN_PROGRAM_ID as pa}from"@solana/spl-token";import hi from"bn.js";var Rt={initialize:Buffer.from([175,175,109,31,13,152,155,237]),buyExactIn:Buffer.from([250,234,13,123,213,156,19,236]),buyExactOut:Buffer.from([24,211,116,40,105,3,153,56]),sellExactIn:Buffer.from([149,39,222,155,211,124,152,26]),sellExactOut:Buffer.from([95,200,71,34,8,9,11,166]),createVestingAccount:Buffer.from([129,178,2,13,217,172,230,218]),claimVestedToken:Buffer.from([49,33,104,30,189,157,79,35]),createPlatformConfig:Buffer.from([176,90,196,175,253,113,220,20]),claimPlatformFee:Buffer.from([156,39,208,135,76,237,61,72]),updatePlaformConfig:Buffer.from([195,60,76,129,146,45,67,143]),initializeWithToken2022:Buffer.from([37,190,126,222,44,154,171,17]),claimPlatformFeeFromVault:Buffer.from([117,241,198,168,248,218,80,29]),claimCreatorFee:Buffer.from([26,97,138,203,132,171,141,252])};function Wc(m,e,t,n,o,r,i,s,u,a,c,l,d,p,f,y,b,g,P,h){let I=_([D("decimals"),wt("name"),wt("symbol"),wt("uri")]),k=_([A("totalLockedAmount"),A("cliffPeriod"),A("unlockPeriod")]),w=_([D("index"),A("supply"),A("totalFundRaisingB"),D("migrateType")]),S=_([D("index"),A("supply"),A("totalSellA"),A("totalFundRaisingB"),D("migrateType")]),x=[{pubkey:e,isSigner:!0,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!1,isWritable:!1},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!0,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!1},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:pa,isSigner:!1,isWritable:!1},{pubkey:pa,isSigner:!1,isWritable:!1},{pubkey:Xt,isSigner:!1,isWritable:!1},{pubkey:Dt.programId,isSigner:!1,isWritable:!1},{pubkey:ot,isSigner:!1,isWritable:!1},{pubkey:Jn(m).publicKey,isSigner:!1,isWritable:!1},{pubkey:m,isSigner:!1,isWritable:!1}],K=Buffer.alloc(Buffer.from(p,"utf-8").length+Buffer.from(f,"utf-8").length+Buffer.from(y,"utf-8").length+4*3+1),T=Buffer.alloc(k.span),C=Buffer.alloc(b.type==="ConstantCurve"?S.span:w.span);return I.encode({decimals:d,name:p,symbol:f,uri:y},K),b.type==="ConstantCurve"?S.encode(W(N({index:0},b),{migrateType:b.migrateType==="amm"?0:1}),C):b.type==="FixedCurve"?w.encode(W(N({index:1},b),{migrateType:b.migrateType==="amm"?0:1}),C):b.type==="LinearCurve"&&w.encode(W(N({index:2},b),{migrateType:b.migrateType==="amm"?0:1}),C),k.encode({totalLockedAmount:g,cliffPeriod:P,unlockPeriod:h},T),new Ct({keys:x,programId:m,data:Buffer.from([...Rt.initialize,...K,...C,...T])})}function qc(m,e,t,n,o,r,i,s,u,a,c,l,d,p,f,y,b,g,P,h){let I=_([D("decimals"),wt("name"),wt("symbol"),wt("uri")]),k=_([A("totalLockedAmount"),A("cliffPeriod"),A("unlockPeriod"),D("transferFeeExtensionParamsOption"),_([Tt("transferFeeBasePoints"),A("maxinumFee")]).replicate("transferFeeExtensionParams")]),w=_([D("index"),A("supply"),A("totalFundRaisingB"),D("migrateType")]),S=_([D("index"),A("supply"),A("totalSellA"),A("totalFundRaisingB"),D("migrateType")]),x=[{pubkey:e,isSigner:!0,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!1,isWritable:!1},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!0,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!1},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:rp,isSigner:!1,isWritable:!1},{pubkey:pa,isSigner:!1,isWritable:!1},{pubkey:Dt.programId,isSigner:!1,isWritable:!1},{pubkey:Jn(m).publicKey,isSigner:!1,isWritable:!1},{pubkey:m,isSigner:!1,isWritable:!1}],K=Buffer.alloc(Buffer.from(d,"utf-8").length+Buffer.from(p,"utf-8").length+Buffer.from(f,"utf-8").length+4*3+1),T=Buffer.alloc(k.span),C=Buffer.alloc(y.type==="ConstantCurve"?S.span:w.span);return I.encode({decimals:l,name:d,symbol:p,uri:f},K),y.type==="ConstantCurve"?S.encode(W(N({index:0},y),{migrateType:y.migrateType==="amm"?0:1}),C):y.type==="FixedCurve"?w.encode(W(N({index:1},y),{migrateType:y.migrateType==="amm"?0:1}),C):y.type==="LinearCurve"&&w.encode(W(N({index:2},y),{migrateType:y.migrateType==="amm"?0:1}),C),k.encode({totalLockedAmount:b,cliffPeriod:g,unlockPeriod:P,transferFeeExtensionParamsOption:h?1:0,transferFeeExtensionParams:h!=null?h:{transferFeeBasePoints:0,maxinumFee:new hi(0)}},T),new Ct({keys:x,programId:m,data:Buffer.from([...Rt.initializeWithToken2022,...K,...C,...T])})}function Uc(m,e,t,n,o,r,i,s,u,a,c,l,d,p,f,y,b,g,P,h){let I=_([A("amountB"),A("minAmountA"),A("shareFeeRate")]),k=[{pubkey:e,isSigner:!0,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!1},{pubkey:l,isSigner:!1,isWritable:!1},{pubkey:d,isSigner:!1,isWritable:!1},{pubkey:p,isSigner:!1,isWritable:!1},{pubkey:Jn(m).publicKey,isSigner:!1,isWritable:!1},{pubkey:m,isSigner:!1,isWritable:!1}];h&&k.push({pubkey:h,isSigner:!1,isWritable:!0}),k.push({pubkey:Dt.programId,isSigner:!1,isWritable:!1}),k.push({pubkey:f,isSigner:!1,isWritable:!0}),k.push({pubkey:y,isSigner:!1,isWritable:!0});let w=Buffer.alloc(I.span);return I.encode({amountB:b,minAmountA:g,shareFeeRate:P!=null?P:new hi(0)},w),new Ct({keys:k,programId:m,data:Buffer.from([...Rt.buyExactIn,...w])})}function Gc(m,e,t,n,o,r,i,s,u,a,c,l,d,p,f,y,b,g,P,h){let I=_([A("amountA"),A("maxAmountB"),A("shareFeeRate")]),k=[{pubkey:e,isSigner:!0,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!1},{pubkey:l,isSigner:!1,isWritable:!1},{pubkey:d,isSigner:!1,isWritable:!1},{pubkey:p,isSigner:!1,isWritable:!1},{pubkey:Jn(m).publicKey,isSigner:!1,isWritable:!1},{pubkey:m,isSigner:!1,isWritable:!1}];h&&k.push({pubkey:h,isSigner:!1,isWritable:!0}),k.push({pubkey:Dt.programId,isSigner:!1,isWritable:!1}),k.push({pubkey:f,isSigner:!1,isWritable:!0}),k.push({pubkey:y,isSigner:!1,isWritable:!0});let w=Buffer.alloc(I.span);return I.encode({amountA:b,maxAmountB:g,shareFeeRate:P!=null?P:new hi(0)},w),new Ct({keys:k,programId:m,data:Buffer.from([...Rt.buyExactOut,...w])})}function Xc(m,e,t,n,o,r,i,s,u,a,c,l,d,p,f,y,b,g,P,h){let I=_([A("amountA"),A("minAmountB"),A("shareFeeRate")]),k=[{pubkey:e,isSigner:!0,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!1},{pubkey:l,isSigner:!1,isWritable:!1},{pubkey:d,isSigner:!1,isWritable:!1},{pubkey:p,isSigner:!1,isWritable:!1},{pubkey:Jn(m).publicKey,isSigner:!1,isWritable:!1},{pubkey:m,isSigner:!1,isWritable:!1}];h&&k.push({pubkey:h,isSigner:!1,isWritable:!0}),k.push({pubkey:Dt.programId,isSigner:!1,isWritable:!1}),k.push({pubkey:f,isSigner:!1,isWritable:!0}),k.push({pubkey:y,isSigner:!1,isWritable:!0});let w=Buffer.alloc(I.span);return I.encode({amountA:b,minAmountB:g,shareFeeRate:P!=null?P:new hi(0)},w),new Ct({keys:k,programId:m,data:Buffer.from([...Rt.sellExactIn,...w])})}function zc(m,e,t,n,o,r,i,s,u,a,c,l,d,p,f,y,b,g,P,h){let I=_([A("amountB"),A("maxAmountA"),A("shareFeeRate")]),k=[{pubkey:e,isSigner:!0,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!1},{pubkey:l,isSigner:!1,isWritable:!1},{pubkey:d,isSigner:!1,isWritable:!1},{pubkey:p,isSigner:!1,isWritable:!1},{pubkey:Jn(m).publicKey,isSigner:!1,isWritable:!1},{pubkey:m,isSigner:!1,isWritable:!1}];h&&k.push({pubkey:h,isSigner:!1,isWritable:!0}),k.push({pubkey:Dt.programId,isSigner:!1,isWritable:!1}),k.push({pubkey:f,isSigner:!1,isWritable:!0}),k.push({pubkey:y,isSigner:!1,isWritable:!0});let w=Buffer.alloc(I.span);return I.encode({amountB:b,maxAmountA:g,shareFeeRate:P!=null?P:new hi(0)},w),new Ct({keys:k,programId:m,data:Buffer.from([...Rt.sellExactOut,...w])})}function fa(m,e,t,n,o,r,i,s,u){let a=_([]),c=[{pubkey:e,isSigner:!0,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!1},{pubkey:u,isSigner:!1,isWritable:!1},{pubkey:Dt.programId,isSigner:!1,isWritable:!1},{pubkey:Or,isSigner:!1,isWritable:!1}],l=Buffer.alloc(a.span);return a.encode({},l),new Ct({keys:c,programId:m,data:Buffer.from([...Rt.claimVestedToken,...l])})}function ya(m,e,t,n,o,r){let i=_([A("shareAmount")]),s=[{pubkey:e,isSigner:!0,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:Dt.programId,isSigner:!1,isWritable:!1}],u=Buffer.alloc(i.span);return i.encode({shareAmount:r},u),new Ct({keys:s,programId:m,data:Buffer.from([...Rt.createVestingAccount,...u])})}function ba(m,e,t,n,o,r,i,s,u){let a=[{pubkey:e,isSigner:!0,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:Dt.programId,isSigner:!1,isWritable:!0},{pubkey:Or,isSigner:!1,isWritable:!0}];return new Ct({keys:a,programId:m,data:Rt.claimPlatformFee})}function Qc(m,e,t,n,o,r,i,s,u,a,c,l,d){let p=_([A("platformScale"),A("creatorScale"),A("burnScale"),A("feeRate"),wt("name"),wt("web"),wt("img"),A("creatorFeeRate")]),f=[{pubkey:e,isSigner:!0,isWritable:!0},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:Dt.programId,isSigner:!1,isWritable:!1},{pubkey:i,isSigner:!1,isWritable:!1}],y=Buffer.alloc(8*5+Buffer.from(c,"utf-8").length+Buffer.from(l,"utf-8").length+Buffer.from(d,"utf-8").length+4*3);return p.encode({platformScale:s.platformScale,creatorScale:s.creatorScale,burnScale:s.burnScale,feeRate:u,name:c,web:l,img:d,creatorFeeRate:a},y),new Ct({keys:f,programId:m,data:Buffer.from([...Rt.createPlatformConfig,...y])})}function jc(m,e,t,n){let o=[{pubkey:e,isSigner:!0,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!0}],r;if(n.type==="updateClaimFeeWallet"){let i=_([D("index"),O("value")]);r=Buffer.alloc(i.span),i.encode({index:0,value:n.value},r)}else if(n.type==="updateLockNftWallet"){let i=_([D("index"),O("value")]);r=Buffer.alloc(i.span),i.encode({index:1,value:n.value},r)}else if(n.type==="migrateCpLockNftScale"){let i=_([D("index"),A("platformScale"),A("creatorScale"),A("burnScale")]);r=Buffer.alloc(i.span),i.encode(N({index:2},n.value),r)}else if(n.type==="updateFeeRate"){let i=_([D("index"),A("value")]);r=Buffer.alloc(i.span),i.encode({index:3,value:n.value},r)}else if(n.type==="updateImg"||n.type==="updateName"||n.type==="updateWeb"){let i=_([D("index"),wt("value")]);r=Buffer.alloc(Buffer.from(n.value,"utf-8").length+4+1*1),n.type==="updateName"?i.encode({index:4,value:n.value},r):n.type==="updateWeb"?i.encode({index:5,value:n.value},r):n.type==="updateImg"&&i.encode({index:6,value:n.value},r)}else if(n.type==="updateCpConfigId"){o.push({pubkey:n.value,isSigner:!1,isWritable:!1});let i=_([D("index")]);r=Buffer.alloc(i.span),i.encode({index:7},r)}else if(n.type==="updateAll"){o.push({pubkey:n.value.cpConfigId,isSigner:!1,isWritable:!1});let i=_([D("index"),O("platformClaimFeeWallet"),O("platformLockNftWallet"),A("platformScale"),A("creatorScale"),A("burnScale"),A("feeRate"),wt("name"),wt("web"),wt("img"),O("transferFeeExtensionAuth"),A("creatorFeeRate")]);r=Buffer.alloc(1+32+32+8*4+4*3+Buffer.from(n.value.name,"utf-8").length+Buffer.from(n.value.web,"utf-8").length+Buffer.from(n.value.img,"utf-8").length),i.encode({index:8,platformClaimFeeWallet:n.value.platformClaimFeeWallet,platformLockNftWallet:n.value.platformLockNftWallet,platformScale:n.value.migrateCpLockNftScale.platformScale,creatorScale:n.value.migrateCpLockNftScale.creatorScale,burnScale:n.value.migrateCpLockNftScale.burnScale,feeRate:n.value.feeRate,name:n.value.name,web:n.value.web,img:n.value.img,transferFeeExtensionAuth:n.value.transferFeeExtensionAuth,creatorFeeRate:n.value.creatorFeeRate},r)}else throw Error("updateInfo params type error");return new Ct({keys:o,programId:m,data:Buffer.from([...Rt.updatePlaformConfig,...r])})}function ga(m,e,t,n,o,r,i,s){let u=[{pubkey:t,isSigner:!0,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:e,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!1},{pubkey:s,isSigner:!1,isWritable:!1},{pubkey:Dt.programId,isSigner:!1,isWritable:!1},{pubkey:Or,isSigner:!1,isWritable:!1}];return new Ct({keys:u,programId:m,data:Rt.claimPlatformFeeFromVault})}function Yc(m,e,t,n,o,r,i){let s=[{pubkey:e,isSigner:!0,isWritable:!0},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!1},{pubkey:i,isSigner:!1,isWritable:!1},{pubkey:Dt.programId,isSigner:!1,isWritable:!1},{pubkey:Or,isSigner:!1,isWritable:!1}];return new Ct({keys:s,programId:m,data:Rt.claimCreatorFee})}import{NATIVE_MINT as bn,TOKEN_2022_PROGRAM_ID as gn,TOKEN_PROGRAM_ID as Ue,createAssociatedTokenAccountIdempotentInstruction as Ut,getTransferFeeConfig as Vr,unpackMint as Er}from"@solana/spl-token";import oe from"bn.js";import{PublicKey as $c}from"@solana/web3.js";var Cn=_([A(),A("epoch"),D("curveType"),Tt("index"),A("migrateFee"),A("tradeFeeRate"),A("maxShareFeeRate"),A("minSupplyA"),A("maxLockRate"),A("minSellRateA"),A("minMigrateRateA"),A("minFundRaisingB"),O("mintB"),O("protocolFeeOwner"),O("migrateFeeOwner"),O("migrateToAmmWallet"),O("migrateToCpmmWallet"),Q(A(),16)]),sp=_([A("totalLockedAmount"),A("cliffPeriod"),A("unlockPeriod"),A("startTime"),A("totalAllocatedShare")]),$t=_([A(),A("epoch"),D("bump"),D("status"),D("mintDecimalsA"),D("mintDecimalsB"),D("migrateType"),A("supply"),A("totalSellA"),A("virtualA"),A("virtualB"),A("realA"),A("realB"),A("totalFundRaisingB"),A("protocolFee"),A("platformFee"),A("migrateFee"),sp.replicate("vestingSchedule"),O("configId"),O("platformId"),O("mintA"),O("mintB"),O("vaultA"),O("vaultB"),O("creator"),D("mintProgramFlag"),Q(D(),63)]),yK=_([A(),A("epoch"),O("poolId"),O("beneficiary"),A("claimedAmount"),A("tokenShareAmount"),Q(A(),8)]),Io=_([A(),A("epoch"),O("platformClaimFeeWallet"),O("platformLockNftWallet"),A("platformScale"),A("creatorScale"),A("burnScale"),A("feeRate"),Q(D(),64,"name"),Q(D(),256,"web"),Q(D(),256,"img"),O("cpConfigId"),A("creatorFeeRate"),O("transferFeeExtensionAuth"),Q(D(),184)]);import Wt from"bn.js";import Zc from"decimal.js";import Nr from"bn.js";import Ti from"decimal.js";var Rn=class{static getPoolInitPriceByPool({poolInfo:e,decimalA:t,decimalB:n}){throw Error()}static getPoolInitPriceByInit({a:e,b:t,decimalA:n,decimalB:o}){throw Error()}static getPoolPrice({poolInfo:e,decimalA:t,decimalB:n}){throw Error()}static getPoolEndPrice({supply:e,totalSell:t,totalLockedAmount:n,totalFundRaising:o,migrateFee:r,decimalA:i,decimalB:s}){throw Error()}static getPoolEndPriceReal({poolInfo:e,decimalA:t,decimalB:n}){throw Error()}static getInitParam({supply:e,totalFundRaising:t,totalSell:n,totalLockedAmount:o,migrateFee:r}){throw Error()}static buyExactIn({poolInfo:e,amount:t}){throw Error()}static buyExactOut({poolInfo:e,amount:t}){throw Error()}static sellExactIn({poolInfo:e,amount:t}){throw Error()}static sellExactOut({poolInfo:e,amount:t}){throw Error()}};var Mr=class extends Rn{static getPoolInitPriceByPool({poolInfo:e,decimalA:t,decimalB:n}){return new Ti(e.virtualB.toString()).div(e.virtualA.toString()).mul(10**(t-n))}static getPoolInitPriceByInit({a:e,b:t,decimalA:n,decimalB:o}){return new Ti(t.toString()).div(e.toString()).mul(10**(n-o))}static getPoolPrice({poolInfo:e,decimalA:t,decimalB:n}){return new Ti(e.virtualB.add(e.realB).toString()).div(e.virtualA.sub(e.realA).toString()).mul(10**(t-n))}static getPoolEndPrice({supply:e,totalSell:t,totalLockedAmount:n,totalFundRaising:o,migrateFee:r,decimalA:i,decimalB:s}){return new Ti(o.sub(r).toString()).div(e.sub(t).sub(n).toString()).mul(10**(i-s))}static getPoolEndPriceReal({poolInfo:e,decimalA:t,decimalB:n}){let o=e.totalSellA.sub(e.realA),r=e.totalFundRaisingB.sub(e.realB);return new Ti(e.virtualB.add(e.realB.add(r)).toString()).div(e.virtualA.sub(e.realA.add(o)).toString()).mul(10**(t-n))}static getInitParam({supply:e,totalFundRaising:t,totalSell:n,totalLockedAmount:o,migrateFee:r}){if(e.lte(n))throw Error("supply need gt total sell");let i=e.sub(n).sub(o);if(i.lte(new Nr(0)))throw Error("supplyMinusSellLocked <= 0");let s=t.sub(r);if(s.lte(new Nr(0)))throw Error("tfMinusMf <= 0");let u=s.mul(n).mul(n).div(i),a=s.mul(n).div(i).sub(t),c=u.div(a),l=t.mul(t).div(a);if(c.lt(new Nr(0))||l.lt(new Nr(0)))throw Error("invalid input 0");return{a:c,b:l,c:n}}static buyExactIn({poolInfo:e,amount:t}){return this.getAmountOut({amountIn:t,inputReserve:e.virtualB.add(e.realB),outputReserve:e.virtualA.sub(e.realA)})}static buyExactOut({poolInfo:e,amount:t}){return this.getAmountIn({amountOut:t,inputReserve:e.virtualB.add(e.realB),outputReserve:e.virtualA.sub(e.realA)})}static sellExactIn({poolInfo:e,amount:t}){return this.getAmountOut({amountIn:t,inputReserve:e.virtualA.sub(e.realA),outputReserve:e.virtualB.add(e.realB)})}static sellExactOut({poolInfo:e,amount:t}){return this.getAmountIn({amountOut:t,inputReserve:e.virtualA.sub(e.realA),outputReserve:e.virtualB.add(e.realB)})}static getAmountOut({amountIn:e,inputReserve:t,outputReserve:n}){let o=e.mul(n),r=t.add(e);return o.div(r)}static getAmountIn({amountOut:e,inputReserve:t,outputReserve:n}){let o=t.mul(e),r=n.sub(e);return _n(o,r)}};import vr from"bn.js";import Ii from"decimal.js";var _r=class extends Rn{static getPoolInitPriceByPool({poolInfo:e,decimalA:t,decimalB:n}){return new Ii(e.virtualB.toString()).div(e.virtualA.toString()).mul(10**(t-n))}static getPoolInitPriceByInit({a:e,b:t,decimalA:n,decimalB:o}){return new Ii(t.toString()).div(e.toString()).mul(10**(n-o))}static getPoolPrice({poolInfo:e,decimalA:t,decimalB:n}){return new Ii(e.virtualB.toString()).div(e.virtualA.toString()).mul(10**(t-n))}static getPoolEndPrice({supply:e,totalSell:t,totalLockedAmount:n,totalFundRaising:o,migrateFee:r,decimalA:i,decimalB:s}){return new Ii(o.sub(r).toString()).div(e.sub(t).sub(n).toString()).mul(10**(i-s))}static getPoolEndPriceReal({poolInfo:e,decimalA:t,decimalB:n}){let o=e.totalSellA.sub(e.realA),r=e.totalFundRaisingB.sub(e.realB);return new Ii(e.virtualB.add(e.realB).add(r).toString()).div(e.virtualA.sub(e.realA).add(o).toString()).mul(10**(t-n))}static getInitParam({supply:e,totalFundRaising:t,totalSell:n,totalLockedAmount:o,migrateFee:r}){let i=e.sub(o);if(i.lte(new vr(0)))throw Error("invalid input 1");let s=new vr(2).mul(t).sub(r),a=t.mul(i).div(s);if(a.lt(new vr(0))||t.lt(new vr(0)))throw Error("invalid input 0");return{a,b:t,c:a}}static buyExactIn({poolInfo:e,amount:t}){return this.getAmountOut({amountIn:t,initInput:e.virtualB,initOutput:e.virtualA})}static buyExactOut({poolInfo:e,amount:t}){return this.getAmountIn({amountOut:t,initInput:e.virtualB,initOutput:e.virtualA})}static sellExactIn({poolInfo:e,amount:t}){return this.getAmountOut({amountIn:t,initInput:e.virtualA,initOutput:e.virtualB})}static sellExactOut({poolInfo:e,amount:t}){return this.getAmountIn({amountOut:t,initInput:e.virtualA,initOutput:e.virtualB})}static getAmountOut({amountIn:e,initInput:t,initOutput:n}){return n.mul(e).div(t)}static getAmountIn({amountOut:e,initInput:t,initOutput:n}){let o=t.mul(e);return _n(o,n)}};import kt from"bn.js";import to from"decimal.js";import Hc from"bn.js";import Aa from"decimal.js";var Bi=class{static _multipler(e){return new Aa(10).pow(e)}static getPrice({priceX64:e,decimalA:t,decimalB:n}){return new Aa(e.toString()).div(this._Q64).mul(this._multipler(t)).div(this._multipler(n))}static getPriceX64({price:e,decimalA:t,decimalB:n}){let o=e.mul(this._multipler(n)).div(this._multipler(t));return new Hc(o.mul(this._Q64).toFixed(0))}};Bi._Q64=new Aa(new Hc(1).shln(64).toString());var Fr=class extends Rn{static getPoolInitPriceByPool({poolInfo:e,decimalA:t,decimalB:n}){return new to(0)}static getPoolInitPriceByInit({a:e,b:t,decimalA:n,decimalB:o}){return new to(0)}static getPoolPrice({poolInfo:e,decimalA:t,decimalB:n}){return new to(e.virtualA.mul(e.realA).toString()).div(Bi._Q64).mul(10**(t-n))}static getPoolEndPrice({supply:e,totalSell:t,totalLockedAmount:n,totalFundRaising:o,migrateFee:r,decimalA:i,decimalB:s}){return new to(o.sub(r).toString()).div(e.sub(t).sub(n).toString()).mul(10**(i-s))}static getPoolEndPriceReal({poolInfo:e,decimalA:t,decimalB:n}){let o=e.totalSellA.sub(e.realA),r=e.totalFundRaisingB.sub(e.realB);return new to(e.virtualB.add(e.realB).add(r).toString()).div(e.virtualA.sub(e.realA).add(o).toString()).mul(10**(t-n))}static getInitParam({supply:e,totalFundRaising:t,totalSell:n,totalLockedAmount:o,migrateFee:r}){let i=e.sub(o);if(i.lte(new kt(0)))throw Error("supplyMinusLocked need gt 0");let s=t.mul(new kt(3)).sub(r),a=t.mul(new kt(2)).mul(i).div(s),c=a.mul(a),l=t.mul(new kt(2)).mul(Ye).div(c);if(!l.gt(new kt(0)))throw Error("a need gt 0");if(!Yo.gt(l))throw Error("a need lt u64 max");if(l.lt(new kt(0))||a.lt(new kt(0)))throw Error("invalid input 0");return{a:l,b:new kt(0),c:a}}static buyExactIn({poolInfo:e,amount:t}){let n=e.realB.add(t),o=new kt(2).mul(n).mul(Ye).div(e.virtualA);return new kt(new to(o.toString()).sqrt().toFixed(0)).sub(e.realA)}static buyExactOut({poolInfo:e,amount:t}){let n=e.realA.add(t),o=n.mul(n);return _n(e.virtualA.mul(o),new kt(2).mul(Ye)).sub(e.realB)}static sellExactIn({poolInfo:e,amount:t}){let n=e.realA.sub(t),o=n.mul(n),r=_n(e.virtualA.mul(o),new kt(2).mul(Ye));return e.realB.sub(r)}static sellExactOut({poolInfo:e,amount:t}){let n=e.realB.sub(t),o=new kt(2).mul(n).mul(Ye).div(e.virtualA),r=new kt(new to(o.toString()).sqrt().toFixed(0));return e.realA.sub(r)}};var qt=class{static getPoolCurvePointByPoolInfo({curveType:e,pointCount:t,poolInfo:n}){return this.getPoolCurvePointByInit({curveType:e,pointCount:t,supply:n.supply,totalFundRaising:n.totalFundRaisingB,totalSell:n.totalSellA,totalLockedAmount:n.vestingSchedule.totalLockedAmount,migrateFee:n.migrateFee,decimalA:n.mintDecimalsA,decimalB:n.mintDecimalsB})}static getPoolCurvePointByInit({curveType:e,pointCount:t,supply:n,totalFundRaising:o,totalSell:r,totalLockedAmount:i,migrateFee:s,decimalA:u,decimalB:a}){if(t<3)throw Error("point count < 3");let c=this.getCurve(e),l=c.getInitParam({supply:n,totalFundRaising:o,totalSell:r,totalLockedAmount:i,migrateFee:s}),d=c.getPoolInitPriceByInit(W(N({},l),{decimalA:u,decimalB:a})),p=o.div(new Wt(t-1)),f=new Wt(0),y=[{price:d,totalSellSupply:0}],{a:b,b:g}=l,P=f,h=f;for(let I=1;I<t;I++){let k=I!==t-1?p:o.sub(h),w=this.buyExactIn({poolInfo:{virtualA:b,virtualB:g,realA:P,realB:h,totalFundRaisingB:o,totalSellA:r},amountB:k,protocolFeeRate:f,platformFeeRate:f,curveType:e,shareFeeRate:f,creatorFeeRate:f,transferFeeConfigA:void 0,slot:0});P=P.add(w.amountA.amount),h=h.add(w.amountB);let S=this.getPrice({poolInfo:{virtualA:b,virtualB:g,realA:P,realB:h},decimalA:u,decimalB:a,curveType:e});y.push({price:S,totalSellSupply:new Zc(P.toString()).div(10**u).toNumber()})}return y}static getPoolInitPriceByPool({poolInfo:e,decimalA:t,decimalB:n,curveType:o}){return this.getCurve(o).getPoolInitPriceByPool({poolInfo:e,decimalA:t,decimalB:n})}static getPoolInitPriceByInit({a:e,b:t,decimalA:n,decimalB:o,curveType:r}){return this.getCurve(r).getPoolInitPriceByInit({a:e,b:t,decimalA:n,decimalB:o})}static getPrice({poolInfo:e,curveType:t,decimalA:n,decimalB:o}){return this.getCurve(t).getPoolPrice({poolInfo:e,decimalA:n,decimalB:o})}static getEndPrice({poolInfo:e,curveType:t,decimalA:n,decimalB:o}){return this.getCurve(t).getPoolPrice({poolInfo:e,decimalA:n,decimalB:o})}static getPoolEndPriceReal({poolInfo:e,curveType:t,decimalA:n,decimalB:o}){return this.getCurve(t).getPoolEndPriceReal({poolInfo:e,decimalA:n,decimalB:o})}static checkParam({supply:e,totalFundRaising:t,totalSell:n,totalLockedAmount:o,decimals:r,config:i,migrateType:s}){if(Number(r)!==6)throw Error("decimals = 6");if(e.mul(i.maxLockRate).div(Yt).lt(o))throw Error("total lock amount gte max lock amount");if(e.lt(i.minSupplyA.mul(new Wt(10**r))))throw Error("supply lt min supply");let a=e.mul(i.minSellRateA).div(Yt);if(n.lt(a))throw Error("invalid input");if(t.lt(i.minFundRaisingB))throw Error("total fund raising lt min fund raising");let c=e.sub(n).sub(o),l=e.mul(i.minMigrateRateA).div(Yt);if(c.lt(l))throw Error("migrate lt min migrate amoount");let d=e.sub(n).sub(o),p=new Wt(new Zc(d.mul(t).toString()).sqrt().toFixed(0));if(s==="amm"){let f=new Wt(10).pow(new Wt(r));if(p.lte(f))throw Error("check migrate lp error")}else if(s==="cpmm"){let f=new Wt(100);if(p.lte(f))throw Error("check migrate lp error")}else throw Error("migrate type error")}static buyExactIn({poolInfo:e,amountB:t,protocolFeeRate:n,platformFeeRate:o,curveType:r,shareFeeRate:i,creatorFeeRate:s,transferFeeConfigA:u,slot:a}){let c=this.totalFeeRate({protocolFeeRate:n,platformFeeRate:o,shareFeeRate:i,creatorFeeRate:s}),l=this.calculateFee({amount:t,feeRate:c}),d=t.sub(l),p=this.getCurve(r),f=p.buyExactIn({poolInfo:e,amount:d}),y=e.totalSellA.sub(e.realA),b,g,P;if(f.gt(y)){b=y;let I=p.buyExactOut({poolInfo:e,amount:b});g=this.calculatePreFee({postFeeAmount:I,feeRate:c}),P=g.sub(I)}else b=f,g=t,P=l;let h=this.splitFee({totalFee:P,protocolFeeRate:n,platformFeeRate:o,shareFeeRate:i,creatorFeeRate:s});return{amountA:os(b,u,a),amountB:g,splitFee:h}}static buyExactOut({poolInfo:e,amountA:t,protocolFeeRate:n,platformFeeRate:o,curveType:r,shareFeeRate:i,creatorFeeRate:s,transferFeeConfigA:u,slot:a}){let c=e.totalSellA.sub(e.realA),l=is(t,u,a),d=l.fee?l.amount.add(l.fee):l.amount;t.gt(c)&&(d=c);let f=this.getCurve(r).buyExactOut({poolInfo:e,amount:d}),y=this.totalFeeRate({protocolFeeRate:n,platformFeeRate:o,shareFeeRate:i,creatorFeeRate:s}),b=this.calculatePreFee({postFeeAmount:f,feeRate:y}),g=b.sub(f),P=this.splitFee({totalFee:g,protocolFeeRate:n,platformFeeRate:o,shareFeeRate:i,creatorFeeRate:s});return{amountA:l,amountB:b,splitFee:P}}static sellExactIn({poolInfo:e,amountA:t,protocolFeeRate:n,platformFeeRate:o,curveType:r,shareFeeRate:i,creatorFeeRate:s,transferFeeConfigA:u,slot:a}){let c=this.getCurve(r),l=os(t,u,a),d=l.fee?l.amount.sub(l.fee):l.amount,p=c.sellExactIn({poolInfo:e,amount:d}),f=this.calculateFee({amount:p,feeRate:this.totalFeeRate({protocolFeeRate:n,platformFeeRate:o,shareFeeRate:i,creatorFeeRate:s})}),y=this.splitFee({totalFee:f,protocolFeeRate:n,platformFeeRate:o,shareFeeRate:i,creatorFeeRate:s});return{amountA:l,amountB:p.sub(f),splitFee:y}}static sellExactOut({poolInfo:e,amountB:t,protocolFeeRate:n,platformFeeRate:o,curveType:r,shareFeeRate:i,creatorFeeRate:s,transferFeeConfigA:u,slot:a}){let c=this.totalFeeRate({protocolFeeRate:n,platformFeeRate:o,shareFeeRate:i,creatorFeeRate:s}),l=this.calculatePreFee({postFeeAmount:t,feeRate:c});if(e.realB.lt(l))throw Error("Insufficient liquidity");let d=l.sub(t),f=qt.getCurve(r).sellExactOut({poolInfo:e,amount:l});if(f.gt(e.realA))throw Error();let y=this.splitFee({totalFee:d,protocolFeeRate:n,platformFeeRate:o,shareFeeRate:i,creatorFeeRate:s});return{amountA:is(f,u,a),amountB:t,splitFee:y}}static splitFee({totalFee:e,protocolFeeRate:t,platformFeeRate:n,shareFeeRate:o,creatorFeeRate:r}){let i=this.totalFeeRate({protocolFeeRate:t,platformFeeRate:n,shareFeeRate:o,creatorFeeRate:r}),s=i.isZero()?new Wt(0):e.mul(n).div(i),u=i.isZero()?new Wt(0):e.mul(o).div(i),a=i.isZero()?new Wt(0):e.mul(r).div(i),c=e.sub(s).sub(u).sub(a);return{platformFee:s,shareFee:u,protocolFee:c,creatorFee:a}}static calculateFee({amount:e,feeRate:t}){return _i(e,t,Yt)}static calculatePreFee({postFeeAmount:e,feeRate:t}){if(t.isZero())return e;let n=e.mul(Yt),o=Yt.sub(t);return n.add(o).sub(new Wt(1)).div(o)}static totalFeeRate({protocolFeeRate:e,platformFeeRate:t,shareFeeRate:n,creatorFeeRate:o}){if(e.add(t).add(n).add(o).gt(new Wt(1e6)))throw Error("total fee rate gt 1_000_000");return e.add(t).add(n).add(o)}static getCurve(e){switch(e){case 0:return Mr;case 1:return _r;case 2:return Fr}throw Error("find curve error")}};import Lt from"decimal.js";var no={initPriceX64:new oe("515752397214619"),supply:new oe(1e15),totalSellA:new oe(7931e11),totalFundRaisingB:new oe(85e9),totalLockedAmount:new oe("0"),cliffPeriod:new oe("0"),unlockPeriod:new oe("0"),decimals:6,virtualA:new oe("1073471847374405"),virtualB:new oe("30050573465"),realA:new oe(0),realB:new oe(0),protocolFee:new oe(0),platformId:new $c("4Bu96XjU84XjPDSpveTVf6LYGCkfW5FK7SNkREWcEfV4"),vestingSchedule:{totalLockedAmount:new oe(0),cliffPeriod:new oe(0),unlockPeriod:new oe(0),startTime:new oe(0),totalAllocatedShare:new oe(0)}},Ln=new oe(1e4),xi=class extends Ne{constructor(e){super(e)}async createLaunchpad(M){var v=M,{programId:e=rt,authProgramId:t,platformId:n=no.platformId,mintA:o,decimals:r=6,mintBDecimals:i=9,name:s,symbol:u,uri:a,migrateType:c,configId:l,snipers:d,configInfo:p,platformFeeRate:f,txVersion:y,computeBudgetConfig:b,txTipConfig:g,feePayer:P,buyAmount:h,minMintAAmount:I,slippage:k,associatedOnly:w=!0,checkCreateATAOwner:S=!1,extraSigners:x,token2022:K,transferFeeExtensionParams:T}=v,C=Ee(v,["programId","authProgramId","platformId","mintA","decimals","mintBDecimals","name","symbol","uri","migrateType","configId","snipers","configInfo","platformFeeRate","txVersion","computeBudgetConfig","txTipConfig","feePayer","buyAmount","minMintAAmount","slippage","associatedOnly","checkCreateATAOwner","extraSigners","token2022","transferFeeExtensionParams"]);var xo,So,Ko,ht,Ki,ka,ha,Ta,Ia,Ba;let R=this.createTxBuilder(P);t=t!=null?t:sn(e).publicKey,console.log("snipers: ",d),K=!!T,K&&(c="cpmm");let L=p;if(!L&&l){let Jt=await this.scope.connection.getAccountInfo(l);Jt&&(L=Cn.decode(Jt.data))}L||this.logAndCreateError("config not found");let F=L.mintB,X=L.curveType,{publicKey:H}=ho(e,o,F),{publicKey:re}=la(e,H,o),{publicKey:ye}=la(e,H,F),{publicKey:ue}=dn(o);this.logDebug(`create token: ${o.toBase58()}, mintB: ${F.toBase58()}, decimals A:${r}/B:${i}, config:${l.toBase58()}`),u.length>10&&this.logAndCreateError("Symbol length should shorter than 11"),a||this.logAndCreateError("uri should not empty");let me=(xo=C==null?void 0:C.supply)!=null?xo:no.supply,pe=(So=C==null?void 0:C.totalSellA)!=null?So:no.totalSellA,ce=(Ko=C==null?void 0:C.totalFundRaisingB)!=null?Ko:no.totalFundRaisingB,Z=(ht=C==null?void 0:C.totalLockedAmount)!=null?ht:new oe(0),Ie=f;if(!f){let Jt=await this.scope.connection.getAccountInfo(n);Jt||this.logAndCreateError("platform id not found:",n.toString()),Ie=Io.decode(Jt.data).feeRate}let pt=qt.getCurve(L.curveType).getInitParam({supply:me,totalFundRaising:ce,totalSell:pe,totalLockedAmount:Z,migrateFee:L.migrateFee}),nt={epoch:new oe(896),bump:254,status:0,mintDecimalsA:r,mintDecimalsB:i,supply:me,totalSellA:pe,mintA:new $c(o),mintB:F,virtualA:pt.a,virtualB:pt.b,realA:no.realA,realB:no.realB,migrateFee:L.migrateFee,migrateType:c==="amm"?0:1,protocolFee:no.protocolFee,platformFee:Ie,platformId:n,configId:l,vaultA:re,vaultB:ye,creator:this.scope.ownerPubKey,totalFundRaisingB:ce,vestingSchedule:{totalLockedAmount:Z,cliffPeriod:new oe(0),unlockPeriod:new oe(0),startTime:new oe(0),totalAllocatedShare:new oe(0)},mintProgramFlag:K?1:0},an=qt.getCurve(L.curveType),{c:Ze}=an.getInitParam({supply:nt.supply,totalFundRaising:nt.totalFundRaisingB,totalLockedAmount:Z,totalSell:L.curveType===0?nt.totalSellA:new oe(0),migrateFee:L.migrateFee});try{qt.checkParam({supply:nt.supply,totalFundRaising:nt.totalFundRaisingB,totalSell:Ze,totalLockedAmount:Z,decimals:nt.mintDecimalsA,config:L,migrateType:c}),this.logDebug("check init params success")}catch(Jt){this.logAndCreateError(`check create mint params failed, ${Jt.message}`)}R.addInstruction({instructions:[K?qc(e,P!=null?P:this.scope.ownerPubKey,this.scope.ownerPubKey,l,n,t,H,o,F,re,ye,r,s,u,a||"https://",{type:X===0?"ConstantCurve":X===1?"FixedCurve":X===2?"LinearCurve":"ConstantCurve",totalSellA:pe,migrateType:c,supply:me,totalFundRaisingB:ce},Z,(Ki=C==null?void 0:C.cliffPeriod)!=null?Ki:new oe(0),(ka=C==null?void 0:C.unlockPeriod)!=null?ka:new oe(0),T):Wc(e,P!=null?P:this.scope.ownerPubKey,this.scope.ownerPubKey,l,n,t,H,o,F,re,ye,ue,r,s,u,a||"https://",{type:X===0?"ConstantCurve":X===1?"FixedCurve":X===2?"LinearCurve":"ConstantCurve",totalSellA:pe,migrateType:c,supply:me,totalFundRaisingB:ce},Z,(ha=C==null?void 0:C.cliffPeriod)!=null?ha:new oe(0),(Ta=C==null?void 0:C.unlockPeriod)!=null?Ta:new oe(0))]});let On=K?await this.scope.connection.getEpochInfo():void 0,gt=T?{epoch:BigInt((On==null?void 0:On.epoch)||0),maximumFee:BigInt((Ia=T==null?void 0:T.maxinumFee.toString())!=null?Ia:0),transferFeeBasisPoints:(Ba=T==null?void 0:T.transferFeeBasePoints)!=null?Ba:0}:void 0,Bo={amountA:{amount:new oe(0),fee:void 0,expirationTime:void 0},amountB:new oe(0),splitFee:{platformFee:new oe(0),shareFee:new oe(0),protocolFee:new oe(0),creatorFee:new oe(0)}},oo;if(x!=null&&x.length&&R.addInstruction({signers:x}),!C.createOnly){let{builder:Jt,extInfo:Jc}=await this.buyToken({programId:e,authProgramId:t,mintAProgram:K?gn:void 0,mintA:o,mintB:F,poolInfo:nt,buyAmount:h,minMintAAmount:I,shareFeeRate:C.shareFeeRate,shareFeeReceiver:C.shareFeeReceiver,configInfo:L,platformFeeRate:Ie,slippage:k,associatedOnly:w,checkCreateATAOwner:S,skipCheckMintA:!gt,transferFeeConfigA:gt?{transferFeeConfigAuthority:t,withdrawWithheldAuthority:t,withheldAmount:BigInt(0),olderTransferFee:gt,newerTransferFee:gt}:void 0}),{builder:lp,extInfo:mp}=await this.buyToken({programId:e,authProgramId:t,mintAProgram:K?gn:void 0,mintA:o,mintB:F,poolInfo:nt,buyAmount:h,minMintAAmount:I,shareFeeRate:C.shareFeeRate,shareFeeReceiver:C.shareFeeReceiver,configInfo:L,platformFeeRate:Ie,slippage:k,associatedOnly:w,checkCreateATAOwner:S,skipCheckMintA:!gt,transferFeeConfigA:gt?{transferFeeConfigAuthority:t,withdrawWithheldAuthority:t,withheldAmount:BigInt(0),olderTransferFee:gt,newerTransferFee:gt}:void 0}),{builder:dp,extInfo:pp}=await this.buyToken({programId:e,authProgramId:t,mintAProgram:K?gn:void 0,mintA:o,mintB:F,poolInfo:nt,buyAmount:h,minMintAAmount:I,shareFeeRate:C.shareFeeRate,shareFeeReceiver:C.shareFeeReceiver,configInfo:L,platformFeeRate:Ie,slippage:k,associatedOnly:w,checkCreateATAOwner:S,skipCheckMintA:!gt,transferFeeConfigA:gt?{transferFeeConfigAuthority:t,withdrawWithheldAuthority:t,withheldAmount:BigInt(0),olderTransferFee:gt,newerTransferFee:gt}:void 0});R.addInstruction(N({},Jt.AllTxData)),Bo=N({},Jc),oo=(this.scope.cluster==="devnet"||y===1)&&C.shareFeeReceiver?[Jt.allInstructions[0]]:void 0}return R.addTipInstruction(g),y===0?R.sizeCheckBuildV0({computeBudgetConfig:b,swapInfo:Bo,splitIns:oo,address:W(N({},nt),{poolId:H})}):R.sizeCheckBuild({computeBudgetConfig:b,swapInfo:Bo,splitIns:oo,address:W(N({},nt),{poolId:H})})}async buyToken({programId:e=rt,authProgramId:t,mintA:n,mintAProgram:o=Ue,mintB:r=bn,poolInfo:i,configInfo:s,platformFeeRate:u,txVersion:a,computeBudgetConfig:c,txTipConfig:l,feePayer:d,buyAmount:p,minMintAAmount:f,slippage:y,shareFeeRate:b=new oe(0),shareFeeReceiver:g,associatedOnly:P=!0,checkCreateATAOwner:h=!1,transferFeeConfigA:I,skipCheckMintA:k=!1}){var ce,Z,Ie;p.lte(new oe(0))&&this.logAndCreateError("buy amount should gt 0:",p.toString());let w=this.createTxBuilder(d),{publicKey:S}=ho(e,n,r);t=t!=null?t:sn(e).publicKey;let x=I;if(!k)if(x)o=gn;else{let we=await this.scope.connection.getAccountInfo(n);if(we&&we.owner.equals(gn)){o=we.owner;let pt=Er(n,we,o);x=Vr(pt)||void 0}}let K=this.scope.account.getAssociatedTokenAccount(n,o),T=null,C=r.equals(bn);w.addInstruction({instructions:[Ut(this.scope.ownerPubKey,K,this.scope.ownerPubKey,n,o)]});let{account:M,instructionParams:v}=await this.scope.account.getOrCreateTokenAccount({mint:r,owner:this.scope.ownerPubKey,createInfo:C?{payer:this.scope.ownerPubKey,amount:p}:void 0,skipCloseAccount:!C,notUseTokenAccount:C,associatedOnly:C?!1:P,checkCreateATAOwner:h});M&&(T=M),w.addInstruction(v||{}),T===void 0&&this.logAndCreateError(`cannot found mintB(${r.toBase58()}) token accounts`,"tokenAccounts",this.scope.account.tokenAccounts);let R=i;if(!R){let we=await this.scope.connection.getAccountInfo(S,{commitment:"processed"});we||this.logAndCreateError("cannot found pool:",S.toBase58()),R=$t.decode(we.data)}let L=s,F=await Re(this.scope.connection,[L?void 0:R.configId,R.platformId].filter(Boolean).map(we=>({pubkey:we})));if(!L){let we=F.find(pt=>pt.pubkey.equals(R.configId));(!we||!we.accountInfo)&&this.logAndCreateError("config not found: ",R.configId.toBase58()),L=Cn.decode(we.accountInfo.data)}let X=F.find(we=>we.pubkey.equals(R.platformId));(!X||!X.accountInfo)&&this.logAndCreateError("platform info not found: ",R.configId.toBase58());let H=Io.decode(X.accountInfo.data);u=u||H.feeRate;let re=qt.buyExactIn({poolInfo:R,amountB:p,protocolFeeRate:L.tradeFeeRate,platformFeeRate:u,curveType:L.curveType,shareFeeRate:b,creatorFeeRate:H.creatorFeeRate,transferFeeConfigA:x,slot:await this.scope.connection.getSlot()}),ye=new Lt(re.amountA.amount.toString()).sub((Z=(ce=re.amountA.fee)==null?void 0:ce.toString())!=null?Z:0),ue=y?new Lt(Ln.sub(y).toNumber()/Ln.toNumber()).clampedTo(0,1):new Lt(1),me=f!=null?f:y?new oe(ye.mul(ue).toFixed(0)):re.amountA.amount.sub((Ie=re.amountA.fee)!=null?Ie:new oe(0));re.amountB.lt(p)&&console.log(`maximum ${n.toBase58()} amount can buy is ${re.amountA.toString()}, input ${r.toBase58()} amount: ${re.amountB.toString()}`);let pe=g?J(g,r,Ue).publicKey:void 0;return pe&&w.addInstruction({instructions:[Ut(this.scope.ownerPubKey,pe,g,r)]}),w.addInstruction({instructions:[Uc(e,this.scope.ownerPubKey,t,R.configId,R.platformId,S,K,T,R.vaultA,R.vaultB,n,r,o,Ue,eo(e,R.platformId,r).publicKey,To(e,R.creator,r).publicKey,re.amountB.lt(p)?re.amountB:p,me,b,pe)]}),w.addCustomComputeBudget(c),w.addTipInstruction(l),w.versionBuild({txVersion:a,extInfo:W(N({},re),{decimalOutAmount:ye,minDecimalOutAmount:new Lt(me.toString())})})}async buyTokenExactOut({programId:e=rt,authProgramId:t,mintA:n,mintAProgram:o=Ue,mintB:r=bn,poolInfo:i,configInfo:s,transferFeeConfigA:u,platformFeeRate:a,txVersion:c,computeBudgetConfig:l,txTipConfig:d,feePayer:p,maxBuyAmount:f,outAmount:y,slippage:b,shareFeeRate:g=new oe(0),shareFeeReceiver:P,associatedOnly:h=!0,checkCreateATAOwner:I=!1,skipCheckMintA:k=!1}){y.lte(new oe(0))&&this.logAndCreateError("out amount should gt 0:",y.toString());let w=this.createTxBuilder(p),{publicKey:S}=ho(e,n,r);t=t!=null?t:sn(e).publicKey;let x=i;if(!x){let ce=await this.scope.connection.getAccountInfo(S,{commitment:"processed"});ce||this.logAndCreateError("cannot found pool:",S.toBase58()),x=$t.decode(ce.data)}let K=s,T=await Re(this.scope.connection,[K?void 0:x.configId,x.platformId].filter(Boolean).map(ce=>({pubkey:ce})));if(!K){let ce=T.find(Z=>Z.pubkey.equals(x.configId));(!ce||!ce.accountInfo)&&this.logAndCreateError("config not found: ",x.configId.toBase58()),K=Cn.decode(ce.accountInfo.data)}let C=T.find(ce=>ce.pubkey.equals(x.platformId));(!C||!C.accountInfo)&&this.logAndCreateError("platform info not found: ",x.configId.toBase58());let M=Io.decode(C.accountInfo.data);a=a||M.feeRate;let v=u;if(!k)if(v)o=gn;else{let ce=await this.scope.connection.getAccountInfo(n);if(ce&&ce.owner.equals(gn)){o=ce.owner;let Z=Er(n,ce,o);v=Vr(Z)||void 0}}let R=qt.buyExactOut({poolInfo:x,amountA:y,protocolFeeRate:K.tradeFeeRate,platformFeeRate:a,curveType:K.curveType,shareFeeRate:g,creatorFeeRate:M.creatorFeeRate,transferFeeConfigA:v,slot:await this.scope.connection.getSlot()}),L=new Lt(R.amountB.toString()),F=b?new Lt(Ln.add(b).toNumber()/Ln.toNumber()).clampedTo(0,Number.MIN_SAFE_INTEGER):new Lt(1),X=(f!=null?f:b)?new oe(L.mul(F).toFixed(0)):R.amountB,H=this.scope.account.getAssociatedTokenAccount(n,o),re=null,ye=r.equals(bn);w.addInstruction({instructions:[Ut(this.scope.ownerPubKey,H,this.scope.ownerPubKey,n,o)]});let{account:ue,instructionParams:me}=await this.scope.account.getOrCreateTokenAccount({mint:r,owner:this.scope.ownerPubKey,createInfo:ye?{payer:this.scope.ownerPubKey,amount:R.amountB}:void 0,skipCloseAccount:!ye,notUseTokenAccount:ye,associatedOnly:ye?!1:h,checkCreateATAOwner:I});ue&&(re=ue),w.addInstruction(me||{}),re===void 0&&this.logAndCreateError(`cannot found mintB(${r.toBase58()}) token accounts`,"tokenAccounts",this.scope.account.tokenAccounts);let pe=P?J(P,r,Ue).publicKey:void 0;return pe&&w.addInstruction({instructions:[Ut(this.scope.ownerPubKey,pe,P,r)]}),w.addInstruction({instructions:[Gc(e,this.scope.ownerPubKey,t,x.configId,x.platformId,S,H,re,x.vaultA,x.vaultB,n,r,o,Ue,eo(e,x.platformId,r).publicKey,To(e,x.creator,r).publicKey,y,X,g,pe)]}),w.addCustomComputeBudget(l),w.addTipInstruction(d),w.versionBuild({txVersion:c,extInfo:{maxSpentAmount:X,outAmount:y}})}async sellToken({programId:e=rt,authProgramId:t,mintAProgram:n=Ue,mintA:o,mintB:r=bn,poolInfo:i,configInfo:s,platformFeeRate:u,txVersion:a,computeBudgetConfig:c,txTipConfig:l,feePayer:d,sellAmount:p,minAmountB:f,slippage:y,shareFeeRate:b=new oe(0),shareFeeReceiver:g,associatedOnly:P=!0,checkCreateATAOwner:h=!1,skipCheckMintA:I=!1}){t=t!=null?t:sn(e).publicKey;let k=this.createTxBuilder(d);p.lte(new oe(0))&&this.logAndCreateError("sell amount should be gt 0");let{publicKey:w}=ho(e,o,r),S;if(!I){let Z=await this.scope.connection.getAccountInfo(o);if(Z&&Z.owner.equals(gn)){n=Z.owner;let Ie=Er(o,Z,n);S=Vr(Ie)||void 0}}let x=null,K=null,T=r.equals(bn),{account:C,instructionParams:M}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:n,mint:o,owner:this.scope.ownerPubKey,createInfo:void 0,skipCloseAccount:!0,notUseTokenAccount:!1,associatedOnly:P,checkCreateATAOwner:h});C&&(x=C),k.addInstruction(M||{}),x===void 0&&this.logAndCreateError("cannot found mintA token accounts","tokenAccounts",this.scope.account.tokenAccounts);let{account:v,instructionParams:R}=await this.scope.account.getOrCreateTokenAccount({mint:r,owner:this.scope.ownerPubKey,createInfo:T?{payer:this.scope.ownerPubKey,amount:0}:void 0,skipCloseAccount:!T,notUseTokenAccount:T,associatedOnly:T?!1:P,checkCreateATAOwner:h});v&&(K=v),k.addInstruction(R||{}),K===void 0&&this.logAndCreateError("cannot found mintB token accounts","tokenAccounts",this.scope.account.tokenAccounts);let L=i;if(!L){let Z=await this.scope.connection.getAccountInfo(w,{commitment:"processed"});Z||this.logAndCreateError("cannot found pool",w.toBase58()),L=$t.decode(Z.data)}let F=s,X=await Re(this.scope.connection,[F?void 0:L.configId,L.platformId].filter(Boolean).map(Z=>({pubkey:Z})));if(!F){let Z=X.find(Ie=>Ie.pubkey.equals(L.configId));(!Z||!Z.accountInfo)&&this.logAndCreateError("config not found: ",L.configId.toBase58()),F=Cn.decode(Z.accountInfo.data)}let H=X.find(Z=>Z.pubkey.equals(L.platformId));(!H||!H.accountInfo)&&this.logAndCreateError("platform info not found: ",L.configId.toBase58());let re=Io.decode(H.accountInfo.data);u=u||re.feeRate;let ye=qt.sellExactIn({poolInfo:L,amountA:p,protocolFeeRate:F.tradeFeeRate,platformFeeRate:u,curveType:F.curveType,shareFeeRate:b,creatorFeeRate:re.creatorFeeRate,transferFeeConfigA:S,slot:await this.scope.connection.getSlot()}),ue=new Lt(ye.amountB.toString()),me=y?new Lt(Ln.sub(y).toNumber()/Ln.toNumber()).clampedTo(0,1):new Lt(1),pe=f!=null?f:y?new oe(ue.mul(me).toFixed(0)):ye.amountB;pe.lte(new oe(0))&&this.logAndCreateError(`out ${r.toBase58()} amount should be gt 0`);let ce=g?J(g,r,Ue).publicKey:void 0;return ce&&k.addInstruction({instructions:[Ut(this.scope.ownerPubKey,ce,g,r)]}),k.addInstruction({instructions:[Xc(e,this.scope.ownerPubKey,t,L.configId,L.platformId,w,x,K,L.vaultA,L.vaultB,o,r,n,Ue,eo(e,L.platformId,r).publicKey,To(e,L.creator,r).publicKey,ye.amountA.amount.lt(p)?ye.amountA.amount:p,pe,b,ce)]}),k.addCustomComputeBudget(c),k.addTipInstruction(l),k.versionBuild({txVersion:a,extInfo:{outAmount:pe}})}async sellTokenExactOut({programId:e=rt,authProgramId:t,mintAProgram:n=Ue,mintA:o,mintB:r=bn,poolInfo:i,configInfo:s,platformFeeRate:u,txVersion:a,computeBudgetConfig:c,txTipConfig:l,feePayer:d,inAmount:p,maxSellAmount:f,slippage:y,shareFeeRate:b=new oe(0),shareFeeReceiver:g,associatedOnly:P=!0,checkCreateATAOwner:h=!1,skipCheckMintA:I=!1}){t=t!=null?t:sn(e).publicKey;let k=this.createTxBuilder(d);f!=null&&f.lte(new oe(0))&&this.logAndCreateError("max sell amount should be gt 0");let{publicKey:w}=ho(e,o,r),S;if(!I){let Z=await this.scope.connection.getAccountInfo(o);if(Z&&Z.owner.equals(gn)){n=Z.owner;let Ie=Er(o,Z,n);S=Vr(Ie)||void 0}}let x=null,K=null,T=r.equals(bn),{account:C,instructionParams:M}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:n,mint:o,owner:this.scope.ownerPubKey,createInfo:void 0,skipCloseAccount:!0,notUseTokenAccount:!1,associatedOnly:P,checkCreateATAOwner:h});C&&(x=C),k.addInstruction(M||{}),x===void 0&&this.logAndCreateError("cannot found mintA token accounts","tokenAccounts",this.scope.account.tokenAccounts);let{account:v,instructionParams:R}=await this.scope.account.getOrCreateTokenAccount({mint:r,owner:this.scope.ownerPubKey,createInfo:T?{payer:this.scope.ownerPubKey,amount:0}:void 0,skipCloseAccount:!T,notUseTokenAccount:T,associatedOnly:T?!1:P,checkCreateATAOwner:h});v&&(K=v),k.addInstruction(R||{}),K===void 0&&this.logAndCreateError("cannot found mintB token accounts","tokenAccounts",this.scope.account.tokenAccounts);let L=i;if(!L){let Z=await this.scope.connection.getAccountInfo(w,{commitment:"processed"});Z||this.logAndCreateError("cannot found pool",w.toBase58()),L=$t.decode(Z.data)}let F=s,X=await Re(this.scope.connection,[F?void 0:L.configId,L.platformId].filter(Boolean).map(Z=>({pubkey:Z})));if(!F){let Z=X.find(Ie=>Ie.pubkey.equals(L.configId));(!Z||!Z.accountInfo)&&this.logAndCreateError("config not found: ",L.configId.toBase58()),F=Cn.decode(Z.accountInfo.data)}let H=X.find(Z=>Z.pubkey.equals(L.platformId));(!H||!H.accountInfo)&&this.logAndCreateError("platform info not found: ",L.configId.toBase58());let re=Io.decode(H.accountInfo.data);u=u||re.feeRate;let ye=qt.sellExactOut({poolInfo:L,amountB:p,protocolFeeRate:F.tradeFeeRate,platformFeeRate:u,curveType:F.curveType,shareFeeRate:b,creatorFeeRate:re.creatorFeeRate,transferFeeConfigA:S,slot:await this.scope.connection.getSlot()}),ue=new Lt(ye.amountA.amount.toString()),me=y?new Lt(Ln.add(y).toNumber()/Ln.toNumber()).clampedTo(0,Number.MAX_SAFE_INTEGER):new Lt(1),pe=(f!=null?f:y)?new oe(ue.mul(me).toFixed(0)):ye.amountA.amount,ce=g?J(g,r,Ue).publicKey:void 0;return ce&&k.addInstruction({instructions:[Ut(this.scope.ownerPubKey,ce,g,r)]}),k.addInstruction({instructions:[zc(e,this.scope.ownerPubKey,t,L.configId,L.platformId,w,x,K,L.vaultA,L.vaultB,o,r,n,Ue,eo(e,L.platformId,r).publicKey,To(e,L.creator,r).publicKey,p,pe,b,ce)]}),k.addCustomComputeBudget(c),k.addTipInstruction(l),k.versionBuild({txVersion:a,extInfo:{maxSellAmount:pe}})}async createPlatformConfig({programId:e=rt,platformAdmin:t,platformClaimFeeWallet:n,platformLockNftWallet:o,cpConfigId:r,migrateCpLockNftScale:i,transferFeeExtensionAuth:s,creatorFeeRate:u,feeRate:a,name:c,web:l,img:d,txVersion:p,computeBudgetConfig:f,txTipConfig:y,feePayer:b}){let g=this.createTxBuilder(b),{publicKey:P}=ma(e,t);return g.addInstruction({instructions:[Qc(e,t,n,o,P,r,s,i,a,u,c,l,d)]}),g.addCustomComputeBudget(f),g.addTipInstruction(y),g.versionBuild({txVersion:p,extInfo:{platformId:P}})}async updatePlatformConfig({programId:e=rt,platformAdmin:t,platformId:n,updateInfo:o,txVersion:r,computeBudgetConfig:i,txTipConfig:s,feePayer:u}){let a=this.createTxBuilder(u),c=n!=null?n:ma(e,t).publicKey;return a.addInstruction({instructions:[jc(e,t,c,o)]}),a.addCustomComputeBudget(i),a.addTipInstruction(s),a.versionBuild({txVersion:r})}async claimPlatformFee({programId:e=rt,authProgramId:t,platformId:n,poolId:o,platformClaimFeeWallet:r,mintB:i,vaultB:s,mintBProgram:u=Ue,txVersion:a,computeBudgetConfig:c,txTipConfig:l,feePayer:d}){var g;let p=this.createTxBuilder(d);t=t!=null?t:sn(e).publicKey;let f=i,y=s;if(!f){let P=await this.scope.connection.getAccountInfo(o,{commitment:"processed"});P||this.logAndCreateError("cannot found pool:",o.toBase58());let h=$t.decode(P.data),I=await this.scope.connection.getAccountInfo(h.configId,{commitment:"processed"});I||this.logAndCreateError("cannot found config:",h.configId.toBase58()),f=Cn.decode(I.data).mintB,y=y!=null?y:h.vaultB}(!f||!y)&&this.logAndCreateError("cannot found mint info, mintB: ",f.toBase58(),", vaultB: ",(g=y==null?void 0:y.toBase58())!=null?g:"");let b=J(this.scope.ownerPubKey,f,Ue).publicKey;return p.addInstruction({instructions:[Ut(this.scope.ownerPubKey,b,this.scope.ownerPubKey,f)]}),p.addInstruction({instructions:[ba(e,r,t,o,n,y,b,f,u)]}),p.addCustomComputeBudget(c),p.addTipInstruction(l),p.versionBuild({txVersion:a})}async claimAllPlatformFee({programId:e=rt,authProgramId:t,platformId:n,platformClaimFeeWallet:o,txVersion:r,computeBudgetConfig:i,txTipConfig:s,feePayer:u}){let a=this.createTxBuilder(u);return t=t!=null?t:sn(e).publicKey,(await this.scope.connection.getProgramAccounts(e,{filters:[{dataSize:$t.span},{memcmp:{offset:$t.offsetOf("platformId"),bytes:n.toString()}}]})).forEach(l=>{let d=$t.decode(l.account.data);if(d.platformFee.lte(new oe(0)))return;let p=J(this.scope.ownerPubKey,d.mintB,Ue).publicKey;a.addInstruction({instructions:[Ut(this.scope.ownerPubKey,p,this.scope.ownerPubKey,d.mintB)]}),a.addInstruction({instructions:[ba(e,o,t,l.pubkey,n,d.vaultB,p,d.mintB,Ue)]})}),a.addTipInstruction(s),r===0?a.sizeCheckBuildV0({computeBudgetConfig:i}):a.sizeCheckBuild({computeBudgetConfig:i})}async createVesting({programId:e=rt,poolId:t,beneficiary:n,shareAmount:o,txVersion:r,computeBudgetConfig:i,txTipConfig:s,feePayer:u}){let a=this.createTxBuilder(u),c=await this.getRpcPoolInfo({poolId:t});o.add(c.vestingSchedule.totalAllocatedShare).gt(c.vestingSchedule.totalLockedAmount)&&this.logAndCreateError("share amount exceed total locked amount");let l=ki(e,t,n).publicKey;return a.addInstruction({instructions:[ya(e,this.scope.ownerPubKey,n,t,l,o)]}),a.addCustomComputeBudget(i),a.addTipInstruction(s),a.versionBuild({txVersion:r})}async createMultipleVesting({programId:e=rt,poolId:t,beneficiaryList:n,txVersion:o,computeBudgetConfig:r,feePayer:i}){let s=this.createTxBuilder(i);n.length===0&&this.logAndCreateError("beneficiaryList is null");let u=await this.getRpcPoolInfo({poolId:t});return n.reduce((c,l)=>c.add(l.shareAmount),u.vestingSchedule.totalAllocatedShare).gt(u.vestingSchedule.totalLockedAmount)&&this.logAndCreateError("share amount exceed total locked amount"),n.forEach(c=>{let l=ki(e,t,c.wallet).publicKey;s.addInstruction({instructions:[ya(e,this.scope.ownerPubKey,c.wallet,t,l,c.shareAmount)]})}),o===0?s.sizeCheckBuildV0({computeBudgetConfig:r}):s.sizeCheckBuild({computeBudgetConfig:r})}async claimVesting({programId:e=rt,poolId:t,poolInfo:n,vestingRecord:o,txVersion:r,computeBudgetConfig:i,txTipConfig:s,feePayer:u}){let a=this.createTxBuilder(u),c=sn(e).publicKey,l=o||ki(e,t,this.scope.ownerPubKey).publicKey,d=n;if(!d){let f=await this.scope.connection.getAccountInfo(t);f||this.logAndCreateError("pool not found"),d=$t.decode(f.data)}let p=J(this.scope.ownerPubKey,d.mintA,Ue).publicKey;return a.addInstruction({instructions:[Ut(this.scope.ownerPubKey,p,this.scope.ownerPubKey,d.mintA)]}),a.addInstruction({instructions:[fa(e,this.scope.ownerPubKey,c,t,l,p,d.vaultA,d.mintA,Ue)]}),a.addCustomComputeBudget(i),a.addTipInstruction(s),a.versionBuild({txVersion:r})}async claimMultiVesting({programId:e=rt,poolIdList:t,poolsInfo:n={},vestingRecords:o={},txVersion:r,computeBudgetConfig:i,feePayer:s}){let u=this.createTxBuilder(s),a=N({},n),c=sn(e).publicKey,l=t.filter(d=>!a[d.toBase58()]);if(l.length){let d=await this.getRpcPoolsInfo({poolIdList:l});a=N(N({},a),d.poolInfoMap)}return t.forEach(d=>{let p=d.toBase58(),f=a[p];f||this.logAndCreateError(`pool info not found: ${p}`);let y=o[p]||ki(e,d,this.scope.ownerPubKey).publicKey,b=J(this.scope.ownerPubKey,f.mintA,Ue).publicKey;u.addInstruction({instructions:[Ut(this.scope.ownerPubKey,b,this.scope.ownerPubKey,f.mintA)]}),u.addInstruction({instructions:[fa(e,this.scope.ownerPubKey,c,d,y,b,f.vaultA,f.mintA,Ue)]})}),r===0?u.sizeCheckBuildV0({computeBudgetConfig:i}):u.sizeCheckBuild({computeBudgetConfig:i})}async claimVaultPlatformFee({programId:e=rt,platformId:t,mintB:n,mintBProgram:o=Ue,claimFeeWallet:r,txVersion:i,computeBudgetConfig:s,txTipConfig:u,feePayer:a}){let c=this.createTxBuilder(a),l=eo(e,t,n).publicKey,d=da(e).publicKey,p=this.scope.account.getAssociatedTokenAccount(n,o);return c.addInstruction({instructions:[Ut(this.scope.ownerPubKey,p,this.scope.ownerPubKey,n,o),ga(e,t,r!=null?r:this.scope.ownerPubKey,d,l,p,n,o)]}),c.addCustomComputeBudget(s),c.addTipInstruction(u),c.versionBuild({txVersion:i})}async claimMultipleVaultPlatformFee({programId:e=rt,platformList:t,unwrapSol:n=!0,txVersion:o,computeBudgetConfig:r,feePayer:i,associatedOnly:s=!0,checkCreateATAOwner:u=!1}){let a=this.createTxBuilder(i),c={};return t.forEach(async l=>{var b,g;let d=da(e).publicKey,p=eo(e,l.id,l.mintB).publicKey,f=l.mintB.equals(bn)&&n,y=c[l.mintB.toBase58()];if(!y){let{account:P,instructionParams:h}=await this.scope.account.getOrCreateTokenAccount({mint:l.mintB,owner:this.scope.ownerPubKey,createInfo:f?{payer:this.scope.ownerPubKey,amount:0}:void 0,skipCloseAccount:!f,notUseTokenAccount:f,associatedOnly:f?!1:s,checkCreateATAOwner:u});P&&(y=P),a.addInstruction(h||{}),y===void 0&&this.logAndCreateError(`cannot found platform ${l.id.toBase58()} mintB(${l.mintB.toBase58()}) token accounts`,"tokenAccounts",this.scope.account.tokenAccounts)}a.addInstruction({instructions:[ga(e,l.id,(b=l.claimFeeWallet)!=null?b:this.scope.ownerPubKey,p,d,y,l.mintB,(g=l.mintBProgram)!=null?g:Ue)]})}),o===0?a.sizeCheckBuildV0({computeBudgetConfig:r}):a.sizeCheckBuild({computeBudgetConfig:r})}async claimCreatorFee({programId:e=rt,mintB:t,mintBProgram:n=Ue,txVersion:o,computeBudgetConfig:r,txTipConfig:i,feePayer:s}){let u=this.createTxBuilder(s),a=To(e,this.scope.ownerPubKey,t).publicKey,c=Dc(e).publicKey,l=this.scope.account.getAssociatedTokenAccount(t,n);return u.addInstruction({instructions:[Ut(this.scope.ownerPubKey,l,this.scope.ownerPubKey,t,n),Yc(e,this.scope.ownerPubKey,c,a,l,t,n)]}),u.addCustomComputeBudget(r),u.addTipInstruction(i),u.versionBuild({txVersion:o})}async getRpcPoolInfo({poolId:e}){return(await this.getRpcPoolsInfo({poolIdList:[e]})).poolInfoMap[e.toBase58()]}async getRpcPoolsInfo({poolIdList:e,config:t}){let n=await Re(this.scope.connection,e.map(u=>({pubkey:u})),t),o={},r=[];for(let u=0;u<e.length;u++){let a=n[u];if(a===null||!a.accountInfo)throw Error("fetch pool info error: "+e[u].toBase58());let c=$t.decode(a.accountInfo.data);o[e[u].toBase58()]=W(N({},c),{poolId:a.accountInfo.owner}),r.push(c.configId)}let i=await Re(this.scope.connection,r.map(u=>({pubkey:u})),t),s={};for(let u=0;u<r.length;u++){let a=i[u];if(a===null||!a.accountInfo)throw Error("fetch config info error: "+r[u].toBase58());let c=Cn.decode(a.accountInfo.data);s[r[u].toBase58()]=W(N({},c),{configId:a.accountInfo.owner})}return{poolInfoMap:Object.keys(o).reduce((u,a)=>W(N({},u),{[a]:W(N({},o[a]),{configInfo:s[o[a].configId.toBase58()]})}),{})}}};import{PublicKey as ap}from"@solana/web3.js";import{MintLayout as up,TOKEN_2022_PROGRAM_ID as Pa,TOKEN_PROGRAM_ID as wa}from"@solana/spl-token";var Si=class extends Ne{constructor(t){super(t);this._tokenList=[];this._tokenMap=new Map;this._blackTokenMap=new Set;this._mintGroup={official:new Set,jup:new Set,extra:new Set};this._whiteMap=new Set;this._extraTokenList=[]}async load(t){this.checkDisabled();let{forceUpdate:n=!1,type:o="strict"}=t||{},{mintList:r,blacklist:i,whiteList:s}=await this.scope.fetchV3TokenList(n),u=await this.scope.fetchJupTokenList(n);this._tokenList=[],this._tokenMap=new Map,this._blackTokenMap=new Set(i),this._mintGroup={official:new Set,jup:new Set,extra:new Set},this._whiteMap=new Set(s),this._tokenMap.set(An.address,An),this._mintGroup.official.add(An.address),r.forEach(a=>{var c;this._blackTokenMap.has(a.address)||(this._tokenMap.set(a.address,W(N({},a),{type:"raydium",priority:2,programId:(c=a.programId)!=null?c:a.tags.includes("token-2022")?Pa.toBase58():wa.toBase58()})),this._mintGroup.official.add(a.address))}),u.forEach(a=>{var c;this._blackTokenMap.has(a.address)||this._tokenMap.has(a.address)||(this._tokenMap.set(a.address,W(N({},a),{type:"jupiter",priority:1,programId:(c=a.programId)!=null?c:a.tags.includes("token-2022")?Pa.toBase58():wa.toBase58(),tags:a.freezeAuthority?[...a.tags||[],"hasFreeze"]:a.tags})),this._mintGroup.jup.add(a.address))}),this._extraTokenList.forEach(a=>{this._blackTokenMap.has(a.address)||this._tokenMap.has(a.address)||(this._tokenMap.set(a.address,W(N({},a),{type:"extra",priority:1,programId:a.programId||a.tags.includes("token-2022")?Pa.toBase58():wa.toBase58()})),this._mintGroup.extra.add(a.address))}),this._tokenList=Array.from(this._tokenMap).map(a=>a[1])}get tokenList(){return this._tokenList}get tokenMap(){return this._tokenMap}get blackTokenMap(){return this._blackTokenMap}get mintGroup(){return this._mintGroup}get whiteListMap(){return this._whiteMap}async getTokenInfo(t){if(!t)throw new Error("please input mint");let n=t.toString(),o=this._tokenMap.get(n);if(o)return o;if(n.toLocaleUpperCase()==="SOL")return An;let r=(await this.scope.api.getTokenInfo([n]))[0];if(r)return this._mintGroup.extra.add(n),this._tokenMap.set(n,W(N({},r),{priority:2})),r;let i=await this.scope.connection.getAccountInfo(new ap(n));if(!i)throw new Error(`mint address not found: ${n}`);let s=up.decode(i.data),u=n.toString().substring(0,6),a={chainId:101,address:n,programId:i.owner.toBase58(),logoURI:"",symbol:u,name:u,decimals:s.decimals,tags:[],extensions:{},priority:0,type:"unknown"};return this._mintGroup.extra.add(n),this._tokenMap.set(n,a),a}};var Dr=class{constructor(e){this.rawBalances=new Map;let{connection:t,cluster:n,owner:o,api:r,defaultChainTime:i,defaultChainTimeOffset:s,apiCacheTime:u,blockhashCommitment:a="confirmed",loopMultiTxStatus:c}=e;this._connection=t,this.cluster=n||"mainnet",this._owner=o?new zt(o):void 0,this._signAllTransactions=e.signAllTransactions,this.blockhashCommitment=a,this.loopMultiTxStatus=c,this.api=r,this._apiCacheTime=u||5*60*1e3,this.logger=fe("Raydium"),this.farm=new jo({scope:this,moduleName:"Raydium_Farm"}),this.account=new Do({scope:this,moduleName:"Raydium_Account",tokenAccounts:e.tokenAccounts,tokenAccountRawInfos:e.tokenAccountRawInfos}),this.liquidity=new ci({scope:this,moduleName:"Raydium_LiquidityV2"}),this.token=new Si({scope:this,moduleName:"Raydium_tokenV2"}),this.tradeV2=new Ai({scope:this,moduleName:"Raydium_tradeV2"}),this.clmm=new mi({scope:this,moduleName:"Raydium_clmm"}),this.cpmm=new bi({scope:this,moduleName:"Raydium_cpmm"}),this.utils1216=new Et({scope:this,moduleName:"Raydium_utils1216"}),this.marketV2=new Ao({scope:this,moduleName:"Raydium_marketV2"}),this.ido=new ko({scope:this,moduleName:"Raydium_ido"}),this.launchpad=new xi({scope:this,moduleName:"Raydium_lauchpad"}),this.availability={};let l=new Date().getTime();this.apiData={},s&&(this._chainTime={fetched:l,value:{chainTime:i||Date.now()-s,offset:s}})}static async load(e){var c;let t=cp({cluster:"mainnet",owner:null,apiRequestInterval:3e5,apiRequestTimeout:1e4},e),{cluster:n,apiRequestTimeout:o,logCount:r,logRequests:i,urlConfigs:s}=t,u=new Yi({cluster:n,timeout:o,urlConfigs:s,logCount:r,logRequests:i}),a=new Dr(W(N({},t),{api:u}));return await a.fetchAvailabilityStatus((c=e.disableFeatureCheck)!=null?c:!0),e.disableLoadToken||await a.token.load({type:e.jupTokenType}),a}get owner(){return this._owner}get ownerPubKey(){if(!this._owner)throw new Error(Hi);return this._owner.publicKey}setOwner(e){return this._owner=e?new zt(e):void 0,this.account.resetTokenAccounts(),this}get connection(){if(!this._connection)throw new Error(tu);return this._connection}setConnection(e){return this._connection=e,this}get signAllTransactions(){return this._signAllTransactions}setSignAllTransactions(e){return this._signAllTransactions=e,this}checkOwner(){if(!this.owner)throw console.error(Hi),new Error(Hi)}isCacheInvalidate(e){return new Date().getTime()-e>this._apiCacheTime}async fetchChainTime(){try{let e=await this.api.getChainTimeOffset();this._chainTime={fetched:Date.now(),value:{chainTime:Date.now()+e.offset*1e3,offset:e.offset*1e3}}}catch{this._chainTime=void 0}}async fetchV3TokenList(e){if(this.apiData.tokenList&&!this.isCacheInvalidate(this.apiData.tokenList.fetched)&&!e)return this.apiData.tokenList.data;try{let t=await this.api.getTokenList(),n={fetched:Date.now(),data:t};return this.apiData.tokenList=n,n.data}catch(t){return console.error(t),{mintList:[],blacklist:[],whiteList:[]}}}async fetchJupTokenList(e){if(this.cluster==="devnet")return[];let t=this.apiData.jupTokenList;if(t&&!this.isCacheInvalidate(t.fetched)&&!e)return t.data;try{let n=await this.api.getJupTokenList();return this.apiData.jupTokenList={fetched:Date.now(),data:n.map(o=>W(N({},o),{mintAuthority:o.mint_authority||void 0,freezeAuthority:o.freeze_authority||void 0}))},this.apiData.jupTokenList.data}catch(n){return console.error(n),[]}}get chainTimeData(){var e;return(e=this._chainTime)==null?void 0:e.value}async chainTimeOffset(){var e;return this._chainTime&&Date.now()-this._chainTime.fetched<=1e3*60*5?this._chainTime.value.offset:(await this.fetchChainTime(),((e=this._chainTime)==null?void 0:e.value.offset)||0)}async currentBlockChainTime(){var e;return this._chainTime&&Date.now()-this._chainTime.fetched<=1e3*60*5?this._chainTime.value.chainTime:(await this.fetchChainTime(),((e=this._chainTime)==null?void 0:e.value.chainTime)||Date.now())}async fetchEpochInfo(){return this._epochInfo&&Date.now()-this._epochInfo.fetched<=1e3*30?this._epochInfo.value:(this._epochInfo={fetched:Date.now(),value:await this.connection.getEpochInfo()},this._epochInfo.value)}async fetchAvailabilityStatus(e){if(e)return{};try{let t=await this.api.fetchAvailabilityStatus(),n=t.all===!1;return this.availability={all:t.all,swap:n?!1:t.swap,createConcentratedPosition:n?!1:t.createConcentratedPosition,addConcentratedPosition:n?!1:t.addConcentratedPosition,addStandardPosition:n?!1:t.addStandardPosition,removeConcentratedPosition:n?!1:t.removeConcentratedPosition,removeStandardPosition:n?!1:t.removeStandardPosition,addFarm:n?!1:t.addFarm,removeFarm:n?!1:t.removeFarm},t}catch{return{}}}};export{Dr as Raydium};
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
//# sourceMappingURL=raydium.mjs.map