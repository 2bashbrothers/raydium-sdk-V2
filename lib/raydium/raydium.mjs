var dl=Object.defineProperty,pl=Object.defineProperties;var fl=Object.getOwnPropertyDescriptors;var Di=Object.getOwnPropertySymbols;var Va=Object.prototype.hasOwnProperty,Ea=Object.prototype.propertyIsEnumerable;var _a=(d,e,t)=>e in d?dl(d,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):d[e]=t,v=(d,e)=>{for(var t in e||(e={}))Va.call(e,t)&&_a(d,t,e[t]);if(Di)for(var t of Di(e))Ea.call(e,t)&&_a(d,t,e[t]);return d},D=(d,e)=>pl(d,fl(e));var ve=(d,e)=>{var t={};for(var n in d)Va.call(d,n)&&e.indexOf(n)<0&&(t[n]=d[n]);if(d!=null&&Di)for(var n of Di(d))e.indexOf(n)<0&&Ea.call(d,n)&&(t[n]=d[n]);return t};import{merge as Ip}from"lodash";import lu from"axios";import{PublicKey as qa}from"@solana/web3.js";import{get as Wa,set as yl}from"lodash";var Gr=class{constructor(e){this.logLevel=e.logLevel!==void 0?e.logLevel:0,this.name=e.name}set level(e){this.logLevel=e}get time(){return Date.now().toString()}get moduleName(){return this.name}isLogLevel(e){return e<=this.logLevel}error(...e){return this.isLogLevel(0)?(console.error(this.time,this.name,"sdk logger error",...e),this):this}logWithError(...e){let t=e.map(n=>typeof n=="object"?JSON.stringify(n):n).join(", ");throw new Error(t)}warning(...e){return this.isLogLevel(1)?(console.warn(this.time,this.name,"sdk logger warning",...e),this):this}info(...e){return this.isLogLevel(2)?(console.info(this.time,this.name,"sdk logger info",...e),this):this}debug(...e){return this.isLogLevel(3)?(console.debug(this.time,this.name,"sdk logger debug",...e),this):this}},Da={},bl={};function ge(d){let e=Wa(Da,d);if(!e){let t=Wa(bl,d);e=new Gr({name:d,logLevel:t}),yl(Da,d,e)}return e}import{MINT_SIZE as gl,TOKEN_PROGRAM_ID as Pl,getTransferFeeConfig as Al,unpackMint as kl}from"@solana/spl-token";var Xr=ge("Raydium_accountInfo_util");async function jt(d,e,t){let{batchRequest:n,commitment:o="confirmed",chunkCount:r=100}=v({batchRequest:!1},t),i=zr(e,r),s=new Array(i.length).fill([]);if(n){let u=i.map(l=>{let m=d._buildArgs([l.map(p=>p.toBase58())],o,"base64");return{methodName:"getMultipleAccounts",args:m}}),a=zr(u,10);s=(await(await Promise.all(a.map(async l=>await d._rpcBatchRequest(l)))).flat()).map(l=>(l.error&&Xr.logWithError(`failed to get info for multiple accounts, RPC_ERROR, ${l.error.message}`),l.result.value.map(m=>{if(m){let{data:p,executable:f,lamports:y,owner:b,rentEpoch:g}=m;return p.length!==2&&p[1]!=="base64"&&Xr.logWithError("info must be base64 encoded, RPC_ERROR"),{data:Buffer.from(p[0],"base64"),executable:f,lamports:y,owner:new qa(b),rentEpoch:g}}return null})))}else try{s=await Promise.all(i.map(u=>d.getMultipleAccountsInfo(u,o)))}catch(u){u instanceof Error&&Xr.logWithError(`failed to get info for multiple accounts, RPC_ERROR, ${u.message}`)}return s.flat()}async function Ne(d,e,t){let n=await jt(d,e.map(o=>o.pubkey),t);return e.map((o,r)=>D(v({},o),{accountInfo:n[r]}))}async function go({connection:d,mints:e,config:t}){var r,i,s;if(e.length===0)return{};let n=await Ne(d,e.map(u=>({pubkey:ut(u)})),t),o={};for(let u of n){if(!u.accountInfo||u.accountInfo.data.length<gl){console.log("invalid mint account",u.pubkey.toBase58());continue}let a=kl(u.pubkey,u.accountInfo,(r=u.accountInfo)==null?void 0:r.owner);o[u.pubkey.toString()]=D(v({},a),{programId:((i=u.accountInfo)==null?void 0:i.owner)||Pl,feeConfig:(s=Al(a))!=null?s:void 0})}return o[qa.default.toBase58()]=o[H.toBase58()],o}import rn from"bn.js";import ry from"decimal.js";import Kl from"big.js";import Gi from"bn.js";import wl from"toformat";var Tl=wl,vo=Tl;import Ui from"big.js";import Il from"bn.js";import Bl from"decimal.js-light";import Fo from"bn.js";var Ua=9007199254740991;function ee(d){let e=ge("Raydium_parseBigNumberish");if(d instanceof Fo)return d;if(typeof d=="string"){if(d.match(/^-?[0-9]+$/))return new Fo(d);e.logWithError(`invalid BigNumberish string: ${d}`)}return typeof d=="number"?(d%1&&e.logWithError(`BigNumberish number underflow: ${d}`),(d>=Ua||d<=-Ua)&&e.logWithError(`BigNumberish number overflow: ${d}`),new Fo(String(d))):typeof d=="bigint"?new Fo(d.toString()):(e.error(`invalid BigNumberish value: ${d}`),new Fo(0))}var qi=ge("module/fraction"),Yr=vo(Ui),_o=vo(Bl),xl={[0]:_o.ROUND_DOWN,[1]:_o.ROUND_HALF_UP,[2]:_o.ROUND_UP},Sl={[0]:Ui.roundDown,[1]:Ui.roundHalfUp,[2]:Ui.roundUp},Ie=class{constructor(e,t=new Il(1)){this.numerator=ee(e),this.denominator=ee(t)}get quotient(){return this.numerator.div(this.denominator)}invert(){return new Ie(this.denominator,this.numerator)}add(e){let t=e instanceof Ie?e:new Ie(ee(e));return this.denominator.eq(t.denominator)?new Ie(this.numerator.add(t.numerator),this.denominator):new Ie(this.numerator.mul(t.denominator).add(t.numerator.mul(this.denominator)),this.denominator.mul(t.denominator))}sub(e){let t=e instanceof Ie?e:new Ie(ee(e));return this.denominator.eq(t.denominator)?new Ie(this.numerator.sub(t.numerator),this.denominator):new Ie(this.numerator.mul(t.denominator).sub(t.numerator.mul(this.denominator)),this.denominator.mul(t.denominator))}mul(e){let t=e instanceof Ie?e:new Ie(ee(e));return new Ie(this.numerator.mul(t.numerator),this.denominator.mul(t.denominator))}div(e){let t=e instanceof Ie?e:new Ie(ee(e));return new Ie(this.numerator.mul(t.denominator),this.denominator.mul(t.numerator))}toSignificant(e,t={groupSeparator:""},n=1){Number.isInteger(e)||qi.logWithError(`${e} is not an integer.`),e<=0&&qi.logWithError(`${e} is not positive.`),_o.set({precision:e+1,rounding:xl[n]});let o=new _o(this.numerator.toString()).div(this.denominator.toString()).toSignificantDigits(e);return o.toFormat(o.decimalPlaces(),t)}toFixed(e,t={groupSeparator:""},n=1){return Number.isInteger(e)||qi.logWithError(`${e} is not an integer.`),e<0&&qi.logWithError(`${e} is negative.`),Yr.DP=e,Yr.RM=Sl[n]||1,new Yr(this.numerator.toString()).div(this.denominator.toString()).toFormat(e,t)}isZero(){return this.numerator.isZero()}};var Cl=ge("Raydium_amount"),Ga=vo(Kl);function Rl(d,e){let t="0",n="0";if(d.includes(".")){let o=d.split(".");o.length===2?([t,n]=o,n=n.padEnd(e,"0")):Cl.logWithError(`invalid number string, num: ${d}`)}else t=d;return[t,n.slice(0,e)||n]}var Se=class extends Ie{constructor(t,n,o=!0,r){let i=new Gi(0),s=Qr.pow(new Gi(t.decimals));if(o)i=ee(n);else{let u=new Gi(0),a=new Gi(0);if(typeof n=="string"||typeof n=="number"||typeof n=="bigint"){let[c,l]=Rl(n.toString(),t.decimals);u=ee(c),a=ee(l)}u=u.mul(s),i=u.add(a)}super(i,s);this.logger=ge(r||"TokenAmount"),this.token=t}get raw(){return this.numerator}isZero(){return this.raw.isZero()}gt(t){return this.token.equals(t.token)||this.logger.logWithError("gt token not equals"),this.raw.gt(t.raw)}lt(t){return this.token.equals(t.token)||this.logger.logWithError("lt token not equals"),this.raw.lt(t.raw)}add(t){return this.token.equals(t.token)||this.logger.logWithError("add token not equals"),new Se(this.token,this.raw.add(t.raw))}subtract(t){return this.token.equals(t.token)||this.logger.logWithError("sub token not equals"),new Se(this.token,this.raw.sub(t.raw))}toSignificant(t=this.token.decimals,n,o=0){return super.toSignificant(t,n,o)}toFixed(t=this.token.decimals,n,o=0){return t>this.token.decimals&&this.logger.logWithError("decimals overflow"),super.toFixed(t,n,o)}toExact(t={groupSeparator:""}){return Ga.DP=this.token.decimals,new Ga(this.numerator.toString()).div(this.denominator.toString()).toFormat(t)}};import{PublicKey as Ll}from"@solana/web3.js";import{TOKEN_PROGRAM_ID as Xa}from"@solana/spl-token";var xn={chainId:101,address:Ll.default.toBase58(),programId:Xa.toBase58(),decimals:9,symbol:"SOL",name:"solana",logoURI:"https://img-v1.raydium.io/icon/So11111111111111111111111111111111111111112.png",tags:[],priority:2,type:"raydium",extensions:{coingeckoId:"solana"}},ct={chainId:101,address:"So11111111111111111111111111111111111111112",programId:Xa.toBase58(),decimals:9,symbol:"WSOL",name:"Wrapped SOL",logoURI:"https://img-v1.raydium.io/icon/So11111111111111111111111111111111111111112.png",tags:[],priority:2,type:"raydium",extensions:{coingeckoId:"solana"}};import{PublicKey as Jr}from"@solana/web3.js";import{PublicKey as We,SystemProgram as za,SYSVAR_RENT_PUBKEY as Ol}from"@solana/web3.js";import{TOKEN_PROGRAM_ID as Nl}from"@solana/spl-token";function S({pubkey:d,isSigner:e=!1,isWritable:t=!0}){return{pubkey:d,isWritable:t,isSigner:e}}var Hr=[S({pubkey:Nl,isWritable:!1}),S({pubkey:za.programId,isWritable:!1}),S({pubkey:Ol,isWritable:!1})];function jr({publicKey:d,transformSol:e}){let t=$r(d.toString());if(t instanceof We)return e&&t.equals(et)?H:t;if(e&&t.toString()===et.toBase58())return H;if(typeof t=="string"){if(t===We.default.toBase58())return We.default;try{return new We(t)}catch{throw new Error("invalid public key")}}throw new Error("invalid public key")}function $r(d){try{return new We(d)}catch{return d}}var Xi=new We("MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr"),Sn=new We("MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr"),it=new We("SysvarRent111111111111111111111111111111111"),Ya=new We("SysvarC1ock11111111111111111111111111111111"),$t=new We("metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s"),Ml=new We("Sysvar1nstructions1111111111111111111111111"),Zr=za.programId,ff=new We("4k3Dyjzvzp8eMZWUXbBCjEvwSkkk59S5iCNLY3QrkX6R"),yf=new We("Ea5SjE2Y6yvCeW5dYTn7PYMuW5ikXkvbGdcmSnXeaLjS"),bf=new We("SRMuApVNdxXokk5GT7XD5cUUgXMBCoAz2LHeuAoKWRt"),gf=new We("EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v"),Pf=new We("Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB"),Af=new We("mSoLzYCxHdYgdzU16g5QSh3i5K3z3KZK7ytfqcJm7So"),kf=new We("7dHbWXmci3dT8UFYWYZweBLXgycu7Y3iL6trKn1Y7ARj"),wf=new We("USDH1SM1ojwWUga67PGrgFWUHibbjqMvuMaDkRJTgkX"),Tf=new We("NRVwhjBQiUPYtfDT5zRBVJajzFQHaBUNtC7SNVvqRFa"),hf=new We("ANAxByE6G2WjFp7A4NqtWYXb3mgruyzZYg3spfxe6Lbo"),If=new We("7vfCXTUXx5WJV5JADk17DUJ4ksgau7utNKj4b963voxs"),H=new We("So11111111111111111111111111111111111111112"),et=We.default;function ut(d){return jr({publicKey:d,transformSol:!0})}var es=class{constructor({mint:e,decimals:t,symbol:n,name:o,skipMint:r=!1,isToken2022:i=!1}){if(e===et.toBase58()||e instanceof Jr&&et.equals(e)){this.decimals=ct.decimals,this.symbol=ct.symbol,this.name=ct.name,this.mint=new Jr(ct.address),this.isToken2022=!1;return}this.decimals=t,this.symbol=n||e.toString().substring(0,6),this.name=o||e.toString().substring(0,6),this.mint=r?Jr.default:jr({publicKey:e}),this.isToken2022=i}equals(e){return this===e?!0:this.mint.equals(e.mint)}},De=es;De.WSOL=new es(D(v({},ct),{mint:ct.address}));var ts=class{constructor({decimals:e,symbol:t="UNKNOWN",name:n="UNKNOWN"}){this.decimals=e,this.symbol=t,this.name=n}equals(e){return this===e}},zi=ts;zi.SOL=new ts(xn);import vl from"bn.js";var Qa=new Ie(new vl(100)),tt=class extends Ie{toSignificant(e=5,t,n){return this.mul(Qa).toSignificant(e,t,n)}toFixed(e=2,t,n){return this.mul(Qa).toFixed(e,t,n)}};var Fl=ge("Raydium_price"),At=class extends Ie{constructor(t){let{baseToken:n,quoteToken:o,numerator:r,denominator:i}=t;super(r,i);this.baseToken=n,this.quoteToken=o,this.scalar=new Ie(ns(n.decimals),ns(o.decimals))}get raw(){return new Ie(this.numerator,this.denominator)}get adjusted(){return super.mul(this.scalar)}invert(){return new At({baseToken:this.quoteToken,quoteToken:this.baseToken,denominator:this.numerator,numerator:this.denominator})}mul(t){this.quoteToken!==t.baseToken&&Fl.logWithError("mul token not equals");let n=super.mul(t);return new At({baseToken:this.baseToken,quoteToken:t.quoteToken,denominator:n.denominator,numerator:n.numerator})}toSignificant(t=this.quoteToken.decimals,n,o){return this.adjusted.toSignificant(t,n,o)}toFixed(t=this.quoteToken.decimals,n,o){return this.adjusted.toFixed(t,n,o)}};var kt=new rn(0),Ha=new rn(1),fy=new rn(2),yy=new rn(3),by=new rn(5),Qr=new rn(10),gy=new rn(100),Py=new rn(1e3),Ay=new rn(1e4);function ns(d){return Qr.pow(ee(d))}function Yi(d,e){let t=d.divmod(e);return t.mod.isZero()?t.div:t.div.isNeg()?t.div.isubn(1):t.div.iaddn(1)}function Vo(d,e,t){return d.mul(e).add(t).sub(new rn(1)).div(t)}function Qi(d,e,t){return d.mul(e).div(t)}function zr(d,e=1,t=[]){let n=[...d];if(e<=0)return t;for(;n.length;)t.push(n.splice(0,e));return t}var xt=class{constructor(e){this._owner=e}get publicKey(){return xt.isKeyPair(this._owner)?this._owner.publicKey:this._owner}get signer(){return xt.isKeyPair(this._owner)?this._owner:void 0}get isKeyPair(){return xt.isKeyPair(this._owner)}get isPublicKey(){return xt.isPublicKey(this._owner)}static isKeyPair(e){return e.secretKey!==void 0}static isPublicKey(e){return!xt.isKeyPair(e)}};import{PublicKey as ql}from"@solana/web3.js";import{TOKEN_PROGRAM_ID as Ul}from"@solana/spl-token";import{ComputeBudgetProgram as ja,Keypair as Za,PublicKey as _l,Transaction as Ja,TransactionMessage as Vl,VersionedTransaction as eu}from"@solana/web3.js";var U={CreateAccount:"CreateAccount",InitAccount:"InitAccount",CreateATA:"CreateATA",CloseAccount:"CloseAccount",TransferAmount:"TransferAmount",InitMint:"InitMint",MintTo:"MintTo",InitMarket:"InitMarket",Util1216OwnerClaim:"Util1216OwnerClaim",SetComputeUnitPrice:"SetComputeUnitPrice",SetComputeUnitLimit:"SetComputeUnitLimit",ClmmCreatePool:"ClmmCreatePool",ClmmOpenPosition:"ClmmOpenPosition",ClmmIncreasePosition:"ClmmIncreasePosition",ClmmDecreasePosition:"ClmmDecreasePosition",ClmmClosePosition:"ClmmClosePosition",ClmmSwapBaseIn:"ClmmSwapBaseIn",ClmmSwapBaseOut:"ClmmSwapBaseOut",ClmmInitReward:"ClmmInitReward",ClmmSetReward:"ClmmSetReward",ClmmCollectReward:"ClmmCollectReward",ClmmLockPosition:"ClmmLockPosition",ClmmHarvestLockPosition:"ClmmHarvestLockPosition",AmmV4Swap:"AmmV4Swap",AmmV4AddLiquidity:"AmmV4AddLiquidity",AmmV4RemoveLiquidity:"AmmV4RemoveLiquidity",AmmV4SimulatePoolInfo:"AmmV4SimulatePoolInfo",AmmV4SwapBaseIn:"AmmV4SwapBaseIn",AmmV4SwapBaseOut:"AmmV4SwapBaseOut",AmmV4CreatePool:"AmmV4CreatePool",AmmV4InitPool:"AmmV4InitPool",AmmV5AddLiquidity:"AmmV5AddLiquidity",AmmV5RemoveLiquidity:"AmmV5RemoveLiquidity",AmmV5SimulatePoolInfo:"AmmV5SimulatePoolInfo",AmmV5SwapBaseIn:"AmmV5SwapBaseIn",AmmV5SwapBaseOut:"AmmV5SwapBaseOut",RouteSwap:"RouteSwap",RouteSwap1:"RouteSwap1",RouteSwap2:"RouteSwap2",FarmV3Deposit:"FarmV3Deposit",FarmV3Withdraw:"FarmV3Withdraw",FarmV3CreateLedger:"FarmV3CreateLedger",FarmV4Withdraw:"FarmV4Withdraw",FarmV5Deposit:"FarmV5Deposit",FarmV5Withdraw:"FarmV5Withdraw",FarmV5CreateLedger:"FarmV5CreateLedger",FarmV6Deposit:"FarmV6Deposit",FarmV6Withdraw:"FarmV6Withdraw",FarmV6Create:"FarmV6Create",FarmV6Restart:"FarmV6Restart",FarmV6CreatorAddReward:"FarmV6CreatorAddReward",FarmV6CreatorWithdraw:"FarmV6CreatorWithdraw",CpmmCreatePool:"CpmmCreatePool",CpmmAddLiquidity:"CpmmAddLiquidity",CpmmWithdrawLiquidity:"CpmmWithdrawLiquidity",CpmmSwapBaseIn:"CpmmSwapBaseIn",CpmmSwapBaseOut:"CpmmSwapBaseOut",CpmmLockLp:"CpmmLockLp",CpmmCollectLockFee:"CpmmCollectLockFee",TransferTip:"TransferTip"};import{TOKEN_PROGRAM_ID as El}from"@solana/spl-token";var $a=ge("Raydium_txUtil"),tu=1644;function Eo(d){let e=[],t=[];return d.microLamports&&(e.push(ja.setComputeUnitPrice({microLamports:d.microLamports})),t.push(U.SetComputeUnitPrice)),d.units&&(e.push(ja.setComputeUnitLimit({units:d.units})),t.push(U.SetComputeUnitLimit)),{instructions:e,instructionTypes:t}}async function Wn(d,e){var n,o;let t=e!=null?e:"confirmed";return(o=await((n=d.getLatestBlockhash)==null?void 0:n.call(d,{commitment:t})))==null?void 0:o.blockhash}async function Wo(d,e){return d.getSignatureStatuses([e]),new Promise((t,n)=>{let o=setTimeout(n,6e4);d.onSignature(e,r=>{if(clearTimeout(o),!r.err){t("");return}n(Object.assign(r.err,{txId:e}))},"confirmed")})}function os(d,e){d.length<1&&$a.logWithError(`no instructions provided: ${d.toString()}`),e.length<1&&$a.logWithError(`no signers provided:, ${e.toString()}`);let t=new Ja;t.recentBlockhash="11111111111111111111111111111111",t.feePayer=e[0],t.add(...d);try{return Buffer.from(t.serialize({verifySignatures:!1})).toString("base64").length<tu}catch{return!1}}function ce(d,e){let[t,n]=_l.findProgramAddressSync(d,e);return{publicKey:t,nonce:n}}function Do({instructions:d,payer:e,signers:t}){return os(d,[e,...t])}function mn({instructions:d,payer:e,lookupTableAddressAccount:t,recentBlockhash:n=Za.generate().publicKey.toString()}){let r=new Vl({payerKey:e,recentBlockhash:n,instructions:d}).compileToV0Message(Object.values(t!=null?t:{}));try{return Buffer.from(new eu(r).serialize()).toString("base64").length<tu}catch{return!1}}var Wl=d=>Buffer.isBuffer(d)?d:d instanceof Uint8Array?Buffer.from(d.buffer,d.byteOffset,d.byteLength):Buffer.from(d),Dl=d=>{let e=d.serialize({requireAllSignatures:!1,verifySignatures:!1});d instanceof eu&&(e=Wl(e));try{return e instanceof Buffer?e.toString("base64"):Buffer.from(e).toString("base64")}catch{return e.toString("base64")}};function Kn(d){let e=[];return d.forEach(t=>{t instanceof Ja&&(t.recentBlockhash||(t.recentBlockhash=El.toBase58()),t.feePayer||(t.feePayer=Za.generate().publicKey)),e.push(Dl(t))}),console.log("simulate tx string:",e),e}function Z(d,e,t){return ce([d.toBuffer(),(t!=null?t:Ul).toBuffer(),e.toBuffer()],new ql("ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL"))}import{PublicKey as ne}from"@solana/web3.js";var nu=new ne("EhhTKczWMGQt46ynNeRX1WfeagwwJd7ufHvCDjRxjo5Q"),ou=new ne("CBuCnLe26faBpcBP2fktp4rp8abpcAnTWft6ZrP5Q4T"),iu=new ne("9KEPoZmtHUrBbhWN1v1KWLMkkvwY6WLtAVUCPRtRjP4z"),qo=new ne("FarmqiPv5eAj3j1GMdMCMUGXqPUvmquZtMy86QH6rzhG"),Wy=new ne("CLaimxFqjHzgTJtAGHU47NPhg6qrc5sCnpC4tBLyABQS"),ru=new ne("srmqPvymJeFKQ4zGQed1GFppgkRHL9kaELCbyksJtPX"),is=new ne("9xQeWvG816bUx9EPjHmaT23yvVM2ZWbrrpZb9PusVFin"),Hi=new ne("675kPX9MHTjS2zt1qfr1NYHuzeLXfQM9H24wFSUt1Mp8"),Dy=new ne("5quBtoiQqxF9Jv6KYKctB59NT3gtJD2Y65kdnB1Uev3h"),su=new ne("CDSr3ssLcRB6XYPJwAfFt18MZvEZp4LjHcvzBVZ45duo"),Dn=new ne("CAMMCzo5YL8w4VFF8KVHrK22GGUsp5VTaW7grrKgrWqK"),Uo=new ne("LockrWmn6K5twhz3y9w1dQERbmgSaRkfnTeTKbpofwE"),ji=new ne("kN1kEznaF5Xbd8LYuqtEFcxzWSBk5Fv6ygX6SqEGJVy"),qn=new ne("CDSr3ssLcRB6XYPJwAfFt18MZvEZp4LjHcvzBVZ45duo"),qy=new ne("routeUGWgWzqBWFcrCfv8tritsqukccJPu3q5GPP3xS"),au=new ne("7YttLkHDoNj9wyDur5pM1ejNaAvT9X4eqaYcHQqtj2G5"),Gl=new ne("6FJon3QE27qgPVggARueB22hLvoh22VzJpXv4rBEoSLF"),Xl=new ne("CC12se5To1CdEuw7fDS27B7Geo5jJyL7t5UK2B44NgiH"),zl=new ne("9HzJyW1qZsEiSfMUf6L2jo3CcTKAyBmSyKdwQeYisHrC"),Yl=new ne("DropEU8AvevN3UrXWXTMuz3rqnMczQVNjq3kcSdW2SQi"),Un=new ne("CPMMoo8L3F4NbTegBCKVNunggL7H1ZpdTHKxQB5qKP1C"),uu=new ne("GpMZbSM2GgvTKHJirzeGfMFoaZ8UR2X7F4v8vHTvxFbL"),Uy=new ne("DNXgeM9EiiaAbaWvwjHj9fQQLAX5ZsfHyvmYUNRAdNC8"),$i=new ne("LockrWmn6K5twhz3y9w1dQERbmgSaRkfnTeTKbpofwE"),Zi=new ne("3f7GcQFG397GAaEnv51zR6tsTVihYRydnydDD1cXekxH"),$e=new ne("LanMV9sAd7wArD4vJFi2qDdfnVhFxYSUg6eADduJ3uj"),Gy=new ne("WLHv2UAZm6z4KyaaELi5pjdbJh6RESMva1Rnn8pJVVh"),Xy=new ne("DRay6fNdQ5J82H7xV6uq2aV3mNrUZ1J4PgSKsWgptcm6"),zy=new ne("5xqNaZXX5eUi4p5HU4oz9i5QnwRNT2y6oN7yyn4qENeq"),Yy=new ne("4Bu96XjU84XjPDSpveTVf6LYGCkfW5FK7SNkREWcEfV4"),Qy=new ne("6s1xP3hpbAfFoNtUNF8mfHsjr2Bd97JxFJRWLbL6aHuX"),Go={IDO_PROGRAM_ID_V1:Gl,IDO_PROGRAM_ID_V2:Xl,IDO_PROGRAM_ID_V3:zl,IDO_PROGRAM_ID_V4:Yl};var dn={OPEN_BOOK_PROGRAM:new ne("EoTcMgcDRTJVZDMZWBoU6rhYHZfkNTVEAfz3uUJRcYGj"),SERUM_PROGRAM_ID_V3:new ne("Ray1111111111111111111111111111111111111111"),AMM_V4:new ne("DRaya7Kj3aMWQSy19kSjvmuwq9docCHofyP9kanQGaav"),AMM_STABLE:new ne("DRayDdXc1NZQ9C3hRWmoSf8zK4iapgMnjdNZWrfwsP8m"),CLMM_PROGRAM_ID:new ne("DRayAUgENGQBKVaX8owNhgzkEDyoHTGVEGHVJT1E9pfH"),CLMM_LOCK_PROGRAM_ID:new ne("DRay25Usp3YJAi7beckgpGUC7mGJ2cR1AVPxhYfwVCUX"),CLMM_LOCK_AUTH_ID:new ne("6Aoh8h2Lw2m5UGxYR8AdAL87jTWYeKoxM52mJRzfYwN"),CREATE_CPMM_POOL_PROGRAM:new ne("DRaycpLY18LhpbydsBWbVJtxpNv9oXPgjRSfpF2bWpYb"),CREATE_CPMM_POOL_AUTH:new ne("CXniRufdq5xL8t8jZAPxsPZDpuudwuJSPWnbcD5Y5Nxq"),CREATE_CPMM_POOL_FEE_ACC:new ne("3oE58BKVt8KuYkGxx8zBojugnymWmBiyafWgMrnb6eYy"),LOCK_CPMM_PROGRAM:new ne("DRay25Usp3YJAi7beckgpGUC7mGJ2cR1AVPxhYfwVCUX"),LOCK_CPMM_AUTH:new ne("7qWVV8UY2bRJfDLP4s37YzBPKUkVB46DStYJBpYbQzu3"),UTIL1216:ne.default,Router:new ne("DRaybByLpbUL57LJARs3j8BitTxVfzBg351EaMr5UTCd"),FARM_PROGRAM_ID_V3:new ne("DRayWyrLmEW5KEeqs8kdTMMaBabapqagaBC7KWpGtJeZ"),FARM_PROGRAM_ID_V4:new ne("Ray1111111111111111111111111111111111111111"),FARM_PROGRAM_ID_V5:new ne("DRayiCGSZgku1GTK6rXD6mVDdingXy6APAH1R6R5L2LC"),FARM_PROGRAM_ID_V6:new ne("DRayzbYakXs45ELHkzH6vC3fuhQqTAnv5A68gdFuvZyZ"),LAUNCHPAD_PROGRAM:new ne("DRay6fNdQ5J82H7xV6uq2aV3mNrUZ1J4PgSKsWgptcm6"),LAUNCHPAD_AUTH:new ne("5xqNaZXX5eUi4p5HU4oz9i5QnwRNT2y6oN7yyn4qENeq"),LAUNCHPAD_PLATFORM:new ne("2Jx4KTDrVSdWNazuGpcA8n3ZLTRGGBDxAWhuKe2Xcj2a"),LAUNCHPAD_CONFIG:new ne("7ZR4zD7PYfY2XxoG1Gxcy2EgEeGYrpxrwzPuwdUBssEt"),FEE_DESTINATION_ID:new ne("9y8ENuuZ3b19quffx9hQvRVygG5ky6snHfRvGpuSfeJy"),MODEL_DATA_PUBKEY:new ne("Ray1111111111111111111111111111111111111111")};import Fe from"bn.js";var sn=1e4;function Ke(d,e,t,n){if(e===void 0)return{amount:d,fee:void 0,expirationTime:void 0};let o=D(v({},e),{olderTransferFee:{epoch:BigInt(e.olderTransferFee.epoch),maximumFee:BigInt(e.olderTransferFee.maximumFee),transferFeeBasisPoints:e.olderTransferFee.transferFeeBasisPoints},newerTransferFee:{epoch:BigInt(e.newerTransferFee.epoch),maximumFee:BigInt(e.newerTransferFee.maximumFee),transferFeeBasisPoints:e.newerTransferFee.transferFeeBasisPoints}}),r=t.epoch<o.newerTransferFee.epoch?o.olderTransferFee:o.newerTransferFee,i=new Fe(r.maximumFee.toString()),s=t.epoch<o.newerTransferFee.epoch?(Number(o.newerTransferFee.epoch)*t.slotsInEpoch-t.absoluteSlot)*400/1e3:void 0;if(n)if(r.transferFeeBasisPoints===sn){let u=new Fe(r.maximumFee.toString());return{amount:d.add(u),fee:u,expirationTime:s}}else{let u=Cn(d.mul(new Fe(sn)),new Fe(sn-r.transferFeeBasisPoints)),a=new Fe(r.maximumFee.toString()),c=u.sub(d).gt(a)?d.add(a):u,l=Cn(c.mul(new Fe(r.transferFeeBasisPoints)),new Fe(sn)),m=l.gt(i)?i:l;return{amount:c,fee:m,expirationTime:s}}else{let u=Cn(d.mul(new Fe(r.transferFeeBasisPoints)),new Fe(sn)),a=u.gt(i)?i:u;return{amount:d,fee:a,expirationTime:s}}}function Zt(d,e){return d===void 0?e:e===void 0?d:Math.min(d,e)}function Cn(d,e){let{div:t,mod:n}=d.divmod(e);return n.gt(new Fe(0))?t.add(new Fe(1)):t}function Gn(d,e){if(d.isZero())return new Fe(0);let t=d.div(e);return t.isZero()?new Fe(1):d.mod(e).gt(new Fe(0))?t.add(new Fe(1)):t}function rs(d,e,t){if(e===void 0)return{amount:d,fee:void 0,expirationTime:void 0};let n=Math.floor(t/432e3),o=n<e.newerTransferFee.epoch?e.olderTransferFee:e.newerTransferFee,r=new Fe(o.maximumFee.toString()),i=n<e.newerTransferFee.epoch?(Number(e.newerTransferFee.epoch)*432e3-t)*400/1e3:void 0,s=Cn(d.mul(new Fe(o.transferFeeBasisPoints)),new Fe(sn)),u=s.gt(r)?r:s;return{amount:d,fee:u,expirationTime:i}}function ss(d,e,t){if(e===void 0)return{amount:d,fee:void 0,expirationTime:void 0};let n=Math.floor(t/432e3),o=n<e.newerTransferFee.epoch?e.olderTransferFee:e.newerTransferFee,r=new Fe(o.maximumFee.toString()),i=n<e.newerTransferFee.epoch?(Number(e.newerTransferFee.epoch)*432e3-t)*400/1e3:void 0;if(o.transferFeeBasisPoints===sn){let s=new Fe(o.maximumFee.toString());return{amount:d.add(s),fee:s,expirationTime:i}}else{let s=Cn(d.mul(new Fe(sn)),new Fe(sn-o.transferFeeBasisPoints)),u=new Fe(o.maximumFee.toString()),a=s.sub(d).gt(u)?d.add(u):s,c=Cn(a.mul(new Fe(o.transferFeeBasisPoints)),new Fe(sn)),l=c.gt(r)?r:c;return{amount:a,fee:l,expirationTime:i}}}import{PublicKey as as,AddressLookupTableAccount as Ao}from"@solana/web3.js";async function Ji({connection:d,address:e,cluster:t="mainnet"}){let n=await jt(d,[...new Set(e.map(r=>r.toString()))].map(r=>new as(r))),o={};for(let r=0;r<e.length;r++){let i=n[r],s=e[r];if(!i)continue;let u=new Ao({key:s,state:Ao.deserialize(i.data)});o[s.toString()]=u,t==="devnet"?Po[s.toString()]=u:Rn[s.toString()]=u}return o}var Rn={},us=async d=>{let e="AcL1Vo8oy1ULiavEcjSUcwfBSForXMudcZvDZy5nzJkU";if(Rn[e])return Rn;let t=new as(e),n=await d.getAccountInfo(t);return n&&(Rn[e]=new Ao({key:t,state:Ao.deserialize(n.data)})),Rn},Po={},er=async d=>{let e="EFhMuDw1PKEuckuFRW9PavNfTH4LKP5uKHgyXDmWpFCq";if(Po[e])return Po;let t=new as(e),n=await d.getAccountInfo(t);return n&&(Po[e]=new Ao({key:t,state:Ao.deserialize(n.data)})),Po};import{PublicKey as Xn,sendAndConfirmTransaction as cs,SystemProgram as Ql,Transaction as Xo,TransactionMessage as pn,VersionedTransaction as fn}from"@solana/web3.js";import Hl from"axios";var zo=2e3,Yo=class{constructor(e){this.instructions=[];this.endInstructions=[];this.lookupTableAddress=[];this.signers=[];this.instructionTypes=[];this.endInstructionTypes=[];this.connection=e.connection,this.feePayer=e.feePayer,this.signAllTransactions=e.signAllTransactions,this.owner=e.owner,this.cluster=e.cluster,this.blockhashCommitment=e.blockhashCommitment,this.loopMultiTxStatus=!!e.loopMultiTxStatus}get AllTxData(){return{instructions:this.instructions,endInstructions:this.endInstructions,signers:this.signers,instructionTypes:this.instructionTypes,endInstructionTypes:this.endInstructionTypes,lookupTableAddress:this.lookupTableAddress}}get allInstructions(){return[...this.instructions,...this.endInstructions]}async getComputeBudgetConfig(){var n;let e=(await Hl.get(`https://solanacompass.com/api/fees?cacheFreshTime=${3e5}`)).data,{avg:t}=(n=e==null?void 0:e[15])!=null?n:{};if(!!t)return{units:6e5,microLamports:Math.min(Math.ceil(t*1e6/6e5),25e3)}}addCustomComputeBudget(e){if(e){let{instructions:t,instructionTypes:n}=Eo(e);return this.instructions.unshift(...t),this.instructionTypes.unshift(...n),!0}return!1}addTipInstruction(e){var t;return e?(this.endInstructions.push(Ql.transfer({fromPubkey:(t=e.feePayer)!=null?t:this.feePayer,toPubkey:new Xn(e.address),lamports:BigInt(e.amount.toString())})),this.endInstructionTypes.push(U.TransferTip),!0):!1}async calComputeBudget({config:e,defaultIns:t}){try{let n=e||await this.getComputeBudgetConfig();if(this.addCustomComputeBudget(n))return;t&&this.instructions.unshift(...t)}catch{t&&this.instructions.unshift(...t)}}addInstruction({instructions:e=[],endInstructions:t=[],signers:n=[],instructionTypes:o=[],endInstructionTypes:r=[],lookupTableAddress:i=[]}){return this.instructions.push(...e),this.endInstructions.push(...t),this.signers.push(...n),this.instructionTypes.push(...o),this.endInstructionTypes.push(...r),this.lookupTableAddress.push(...i.filter(s=>s!==Xn.default.toString())),this}async versionBuild({txVersion:e,extInfo:t}){return e===0?await this.buildV0(v({},t||{})):this.build(t)}build(e){var n;let t=new Xo;return this.allInstructions.length&&t.add(...this.allInstructions),t.feePayer=this.feePayer,((n=this.owner)==null?void 0:n.signer)&&!this.signers.some(o=>o.publicKey.equals(this.owner.publicKey))&&this.signers.push(this.owner.signer),{builder:this,transaction:t,signers:this.signers,instructionTypes:[...this.instructionTypes,...this.endInstructionTypes],execute:async o=>{var c;let{recentBlockHash:r,skipPreflight:i=!0,sendAndConfirm:s,notSendToRpc:u}=o||{},a=r!=null?r:await Wn(this.connection,this.blockhashCommitment);if(t.recentBlockhash=a,this.signers.length&&t.sign(...this.signers),Kn([t]),(c=this.owner)!=null&&c.isKeyPair)return{txId:s?await cs(this.connection,t,this.signers.find(m=>m.publicKey.equals(this.owner.publicKey))?this.signers:[...this.signers,this.owner.signer],{skipPreflight:i}):await this.connection.sendRawTransaction(t.serialize(),{skipPreflight:i}),signedTx:t};if(this.signAllTransactions){let l=await this.signAllTransactions([t]);if(this.signers.length)for(let m of l)try{m.sign(...this.signers)}catch{}return{txId:u?"":await this.connection.sendRawTransaction(l[0].serialize(),{skipPreflight:i}),signedTx:l[0]}}throw new Error("please provide owner in keypair format or signAllTransactions function")},extInfo:e||{}}}buildMultiTx(e){var a;let{extraPreBuildData:t=[],extInfo:n}=e,{transaction:o}=this.build(n),r=t.filter(c=>c.transaction.instructions.length>0),i=[o,...r.map(c=>c.transaction)],s=[this.signers,...r.map(c=>c.signers)],u=[...this.instructionTypes,...r.map(c=>c.instructionTypes).flat()];return(a=this.owner)!=null&&a.signer&&s.forEach(c=>{c.some(l=>l.publicKey.equals(this.owner.publicKey))||this.signers.push(this.owner.signer)}),{builder:this,transactions:i,signers:s,instructionTypes:u,execute:async c=>{var g;let{sequentially:l,onTxUpdate:m,skipTxCount:p=0,recentBlockHash:f,skipPreflight:y=!0}=c||{},b=f!=null?f:await Wn(this.connection,this.blockhashCommitment);if((g=this.owner)!=null&&g.isKeyPair){if(l){let P=[],T=0;for(let h of i){if(++T,T<=p)continue;let w=await cs(this.connection,h,this.signers.find(k=>k.publicKey.equals(this.owner.publicKey))?this.signers:[...this.signers,this.owner.signer],{skipPreflight:y});P.push(w)}return{txIds:P,signedTxs:i}}return{txIds:await await Promise.all(i.map(async P=>(P.recentBlockhash=b,await this.connection.sendRawTransaction(P.serialize(),{skipPreflight:y})))),signedTxs:i}}if(this.signAllTransactions){let P=i.map((h,w)=>(h.recentBlockhash=b,s[w].length&&h.sign(...s[w]),h));Kn(P);let T=await this.signAllTransactions(P);if(l){let h=0,w=[],k=async()=>{if(!T[h])return;let x=await this.connection.sendRawTransaction(T[h].serialize(),{skipPreflight:y});w.push({txId:x,status:"sent",signedTx:T[h]}),m==null||m([...w]),h++;let B=!1,K=null,I=null,R=C=>{K!==null&&clearInterval(K),I!==null&&this.connection.removeSignatureListener(I);let N=w.findIndex(L=>L.txId===x);if(N>-1){if(w[N].status==="error"||w[N].status==="success")return;w[N].status=C.err?"error":"success"}m==null||m([...w]),C.err||k()};this.loopMultiTxStatus&&(K=setInterval(async()=>{var C;if(B){clearInterval(K);return}try{let N=await this.connection.getTransaction(x,{commitment:"confirmed",maxSupportedTransactionVersion:0});N&&(B=!0,clearInterval(K),R({err:((C=N.meta)==null?void 0:C.err)||null}),console.log("tx status from getTransaction:",x))}catch(N){B=!0,clearInterval(K),console.error("getTransaction timeout:",N,x)}},zo)),I=this.connection.onSignature(x,C=>{if(B){this.connection.removeSignatureListener(I);return}B=!0,R(C)},"confirmed"),this.connection.getSignatureStatus(x)};return await k(),{txIds:w.map(x=>x.txId),signedTxs:T}}else{let h=[];for(let w=0;w<T.length;w+=1){let k=await this.connection.sendRawTransaction(T[w].serialize(),{skipPreflight:y});h.push(k)}return{txIds:h,signedTxs:T}}}throw new Error("please provide owner in keypair format or signAllTransactions function")},extInfo:n||{}}}async versionMultiBuild({extraPreBuildData:e,txVersion:t,extInfo:n}){return t===0?await this.buildV0MultiTx({extraPreBuildData:e,buildProps:n||{}}):this.buildMultiTx({extraPreBuildData:e,extInfo:n})}async buildV0(e){var y;let f=e||{},{lookupTableCache:t={},lookupTableAddress:n=[],forerunCreate:o,recentBlockhash:r}=f,i=ve(f,["lookupTableCache","lookupTableAddress","forerunCreate","recentBlockhash"]),s=v(v({},this.cluster==="devnet"?await er(this.connection):await us(this.connection)),t),u=Array.from(new Set([...n,...this.lookupTableAddress])),a=[];for(let b of u)s[b]===void 0&&a.push(new Xn(b));let c=await Ji({connection:this.connection,address:a});for(let[b,g]of Object.entries(c))s[b]=g;let l=o?Xn.default.toBase58():r!=null?r:await Wn(this.connection,this.blockhashCommitment),m=new pn({payerKey:this.feePayer,recentBlockhash:l,instructions:[...this.allInstructions]}).compileToV0Message(Object.values(s));((y=this.owner)==null?void 0:y.signer)&&!this.signers.some(b=>b.publicKey.equals(this.owner.publicKey))&&this.signers.push(this.owner.signer);let p=new fn(m);return p.sign(this.signers),{builder:this,transaction:p,signers:this.signers,instructionTypes:[...this.instructionTypes,...this.endInstructionTypes],execute:async b=>{var h;let{skipPreflight:g=!0,sendAndConfirm:P,notSendToRpc:T}=b||{};if(Kn([p]),(h=this.owner)!=null&&h.isKeyPair){let w=await this.connection.sendTransaction(p,{skipPreflight:g});return P&&await Wo(this.connection,w),{txId:w,signedTx:p}}if(this.signAllTransactions){let w=await this.signAllTransactions([p]);if(this.signers.length)for(let k of w)try{k.sign(this.signers)}catch{}return{txId:T?"":await this.connection.sendTransaction(w[0],{skipPreflight:g}),signedTx:w[0]}}throw new Error("please provide owner in keypair format or signAllTransactions function")},extInfo:i||{}}}async buildV0MultiTx(e){var a;let{extraPreBuildData:t=[],buildProps:n}=e,{transaction:o}=await this.buildV0(n),r=t.filter(c=>c.builder.instructions.length>0),i=[o,...r.map(c=>c.transaction)],s=[this.signers,...r.map(c=>c.signers)],u=[...this.instructionTypes,...r.map(c=>c.instructionTypes).flat()];return(a=this.owner)!=null&&a.signer&&s.forEach(c=>{c.some(l=>l.publicKey.equals(this.owner.publicKey))||this.signers.push(this.owner.signer)}),i.forEach(async(c,l)=>{c.sign(s[l])}),{builder:this,transactions:i,signers:s,instructionTypes:u,buildProps:n,execute:async c=>{var y;let{sequentially:l,onTxUpdate:m,recentBlockHash:p,skipPreflight:f=!0}=c||{};if(p&&i.forEach(b=>b.message.recentBlockhash=p),Kn(i),(y=this.owner)!=null&&y.isKeyPair){if(l){let b=[];for(let g of i){let P=await this.connection.sendTransaction(g,{skipPreflight:f});await Wo(this.connection,P),b.push(P)}return{txIds:b,signedTxs:i}}return{txIds:await Promise.all(i.map(async b=>await this.connection.sendTransaction(b,{skipPreflight:f}))),signedTxs:i}}if(this.signAllTransactions){let b=await this.signAllTransactions(i);if(l){let g=0,P=[],T=async()=>{if(!b[g])return;let h=await this.connection.sendTransaction(b[g],{skipPreflight:f});P.push({txId:h,status:"sent",signedTx:b[g]}),m==null||m([...P]),g++;let w=!1,k=null,x=null,B=K=>{k!==null&&clearInterval(k),x!==null&&this.connection.removeSignatureListener(x);let I=P.findIndex(R=>R.txId===h);if(I>-1){if(P[I].status==="error"||P[I].status==="success")return;P[I].status=K.err?"error":"success"}m==null||m([...P]),K.err||T()};this.loopMultiTxStatus&&(k=setInterval(async()=>{var K;if(w){clearInterval(k);return}try{let I=await this.connection.getTransaction(h,{commitment:"confirmed",maxSupportedTransactionVersion:0});I&&(w=!0,clearInterval(k),B({err:((K=I.meta)==null?void 0:K.err)||null}),console.log("tx status from getTransaction:",h))}catch(I){w=!0,clearInterval(k),console.error("getTransaction timeout:",I,h)}},zo)),x=this.connection.onSignature(h,K=>{if(w){this.connection.removeSignatureListener(x);return}w=!0,B(K)},"confirmed"),this.connection.getSignatureStatus(h)};return T(),{txIds:[],signedTxs:b}}else{let g=[];for(let P=0;P<b.length;P+=1){let T=await this.connection.sendTransaction(b[P],{skipPreflight:f});g.push(T)}return{txIds:g,signedTxs:b}}}throw new Error("please provide owner in keypair format or signAllTransactions function")},extInfo:n||{}}}async sizeCheckBuild(e){var m;let l=e||{},{splitIns:t=[],computeBudgetConfig:n}=l,o=ve(l,["splitIns","computeBudgetConfig"]),r=n?Eo(n):{instructions:[],instructionTypes:[]},i=this.signers.reduce((p,f)=>D(v({},p),{[f.publicKey.toBase58()]:f}),{}),s=[],u=[],a=[],c=0;if(this.allInstructions.forEach(p=>{let f=[...a,p],y=n?[...r.instructions,...f]:f,g=[...new Set(f.map(P=>P.keys.filter(T=>T.isSigner).map(T=>T.pubkey.toString())).flat()).values()].map(P=>new Xn(P));if(p!==t[c]&&a.length<12&&(Do({instructions:y,payer:this.feePayer,signers:g})||Do({instructions:f,payer:this.feePayer,signers:g})))a.push(p);else{if(a.length===0)throw Error("item ins too big");c+=p===t[c]?1:0,Do({instructions:n?[...r.instructions,...a]:[...a],payer:this.feePayer,signers:g})?s.push(new Xo().add(...r.instructions,...a)):s.push(new Xo().add(...a)),u.push(Array.from(new Set(a.map(P=>P.keys.filter(T=>T.isSigner).map(T=>T.pubkey.toString())).flat())).map(P=>i[P]).filter(P=>P!==void 0)),a=[p]}}),a.length>0){let f=[...new Set(a.map(y=>y.keys.filter(b=>b.isSigner).map(b=>b.pubkey.toString())).flat()).values()].map(y=>i[y]).filter(y=>y!==void 0);Do({instructions:n?[...r.instructions,...a]:[...a],payer:this.feePayer,signers:f.map(y=>y.publicKey)})?s.push(new Xo().add(...r.instructions,...a)):s.push(new Xo().add(...a)),u.push(f)}return s.forEach(p=>p.feePayer=this.feePayer),(m=this.owner)!=null&&m.signer&&u.forEach(p=>{p.some(f=>f.publicKey.equals(this.owner.publicKey))||p.push(this.owner.signer)}),{builder:this,transactions:s,signers:u,instructionTypes:this.instructionTypes,execute:async p=>{var h;let{sequentially:f,onTxUpdate:y,skipTxCount:b=0,recentBlockHash:g,skipPreflight:P=!0}=p||{},T=g!=null?g:await Wn(this.connection,this.blockhashCommitment);if(s.forEach(async(w,k)=>{w.recentBlockhash=T,u[k].length&&w.sign(...u[k])}),Kn(s),(h=this.owner)!=null&&h.isKeyPair){if(f){let w=0,k=[];for(let x of s){if(++w,w<=b){k.push("tx skipped");continue}let B=await cs(this.connection,x,this.signers.find(K=>K.publicKey.equals(this.owner.publicKey))?this.signers:[...this.signers,this.owner.signer],{skipPreflight:P});k.push(B)}return{txIds:k,signedTxs:s}}return{txIds:await Promise.all(s.map(async w=>await this.connection.sendRawTransaction(w.serialize(),{skipPreflight:P}))),signedTxs:s}}if(this.signAllTransactions){let w=await this.signAllTransactions(s.slice(b,s.length)),k=[...s.slice(0,b),...w];if(f){let x=0,B=[],K=async()=>{if(!k[x])return;x<b&&(B.push({txId:"",status:"success",signedTx:k[x]}),y==null||y([...B]),x++,K());let I=await this.connection.sendRawTransaction(k[x].serialize(),{skipPreflight:P});B.push({txId:I,status:"sent",signedTx:k[x]}),y==null||y([...B]),x++;let R=!1,C=null,N=null,L=O=>{C!==null&&clearInterval(C),N!==null&&this.connection.removeSignatureListener(N);let F=B.findIndex(G=>G.txId===I);if(F>-1){if(B[F].status==="error"||B[F].status==="success")return;B[F].status=O.err?"error":"success"}y==null||y([...B]),O.err||K()};this.loopMultiTxStatus&&(C=setInterval(async()=>{var O;if(R){clearInterval(C);return}try{let F=await this.connection.getTransaction(I,{commitment:"confirmed",maxSupportedTransactionVersion:0});F&&(R=!0,clearInterval(C),L({err:((O=F.meta)==null?void 0:O.err)||null}),console.log("tx status from getTransaction:",I))}catch(F){R=!0,clearInterval(C),console.error("getTransaction timeout:",F,I)}},zo)),N=this.connection.onSignature(I,O=>{if(R){this.connection.removeSignatureListener(N);return}R=!0,L(O)},"confirmed"),this.connection.getSignatureStatus(I)};return await K(),{txIds:B.map(I=>I.txId),signedTxs:k}}else{let x=[];for(let B=0;B<k.length;B+=1){let K=await this.connection.sendRawTransaction(k[B].serialize(),{skipPreflight:P});x.push(K)}return{txIds:x,signedTxs:k}}}throw new Error("please provide owner in keypair format or signAllTransactions function")},extInfo:o||{}}}async sizeCheckBuildV0(e){var T;let P=e||{},{computeBudgetConfig:t,splitIns:n=[],lookupTableCache:o={},lookupTableAddress:r=[]}=P,i=ve(P,["computeBudgetConfig","splitIns","lookupTableCache","lookupTableAddress"]),s=v(v({},this.cluster==="devnet"?await er(this.connection):Rn),o),u=Array.from(new Set([...this.lookupTableAddress,...r])),a=[];for(let h of u)s[h]===void 0&&a.push(new Xn(h));let c=await Ji({connection:this.connection,address:a});for(let[h,w]of Object.entries(c))s[h]=w;let l=t?Eo(t):{instructions:[],instructionTypes:[]},m=await Wn(this.connection,this.blockhashCommitment),p=this.signers.reduce((h,w)=>D(v({},h),{[w.publicKey.toBase58()]:w}),{}),f=[],y=[],b=[],g=0;if(this.allInstructions.forEach(h=>{let w=[...b,h],k=t?[...l.instructions,...w]:w;if(h!==n[g]&&b.length<12&&(mn({instructions:k,payer:this.feePayer,lookupTableAddressAccount:s})||mn({instructions:w,payer:this.feePayer,lookupTableAddressAccount:s})))b.push(h);else{if(b.length===0)throw Error("item ins too big");g+=h===n[g]?1:0;let x={};for(let B of[...new Set(u)])s[B]!==void 0&&(x[B]=s[B]);if(t&&mn({instructions:[...l.instructions,...b],payer:this.feePayer,lookupTableAddressAccount:s,recentBlockhash:m})){let B=new pn({payerKey:this.feePayer,recentBlockhash:m,instructions:[...l.instructions,...b]}).compileToV0Message(Object.values(s));f.push(new fn(B))}else{let B=new pn({payerKey:this.feePayer,recentBlockhash:m,instructions:[...b]}).compileToV0Message(Object.values(s));f.push(new fn(B))}y.push(Array.from(new Set(b.map(B=>B.keys.filter(K=>K.isSigner).map(K=>K.pubkey.toString())).flat())).map(B=>p[B]).filter(B=>B!==void 0)),b=[h]}}),b.length>0){let w=[...new Set(b.map(k=>k.keys.filter(x=>x.isSigner).map(x=>x.pubkey.toString())).flat()).values()].map(k=>p[k]).filter(k=>k!==void 0);if(t&&mn({instructions:[...l.instructions,...b],payer:this.feePayer,lookupTableAddressAccount:s,recentBlockhash:m})){let k=new pn({payerKey:this.feePayer,recentBlockhash:m,instructions:[...l.instructions,...b]}).compileToV0Message(Object.values(s));f.push(new fn(k))}else{let k=new pn({payerKey:this.feePayer,recentBlockhash:m,instructions:[...b]}).compileToV0Message(Object.values(s));f.push(new fn(k))}y.push(w)}return(T=this.owner)!=null&&T.signer&&y.forEach(h=>{h.some(w=>w.publicKey.equals(this.owner.publicKey))||h.push(this.owner.signer)}),f.forEach((h,w)=>{h.sign(y[w])}),{builder:this,transactions:f,buildProps:e,signers:y,blockHash:m,instructionTypes:this.instructionTypes,execute:async h=>{var I;let{sequentially:w,onTxUpdate:k,skipTxCount:x=0,recentBlockHash:B,skipPreflight:K=!0}=h||{};if(f.map(async(R,C)=>{y[C].length&&R.sign(y[C]),B&&(R.message.recentBlockhash=B)}),Kn(f),(I=this.owner)!=null&&I.isKeyPair){if(w){let R=0,C=[];for(let N of f){if(++R,R<=x){console.log("skip tx: ",R),C.push("tx skipped");continue}let L=await this.connection.sendTransaction(N,{skipPreflight:K});await Wo(this.connection,L),C.push(L)}return{txIds:C,signedTxs:f}}return{txIds:await Promise.all(f.map(async R=>await this.connection.sendTransaction(R,{skipPreflight:K}))),signedTxs:f}}if(this.signAllTransactions){let R=await this.signAllTransactions(f.slice(x,f.length)),C=[...f.slice(0,x),...R];if(w){let N=0,L=[],O=async()=>{if(!C[N])return;if(N<x){L.push({txId:"",status:"success",signedTx:C[N]}),k==null||k([...L]),N++,O();return}let F=await this.connection.sendTransaction(C[N],{skipPreflight:K});L.push({txId:F,status:"sent",signedTx:C[N]}),k==null||k([...L]),N++;let G=!1,z=null,$=null,re=te=>{z!==null&&clearInterval(z),$!==null&&this.connection.removeSignatureListener($);let ae=L.findIndex(ye=>ye.txId===F);if(ae>-1){if(L[ae].status==="error"||L[ae].status==="success")return;L[ae].status=te.err?"error":"success"}k==null||k([...L]),te.err||O()};this.loopMultiTxStatus&&(z=setInterval(async()=>{var te;if(G){clearInterval(z);return}try{let ae=await this.connection.getTransaction(F,{commitment:"confirmed",maxSupportedTransactionVersion:0});ae&&(G=!0,clearInterval(z),re({err:((te=ae.meta)==null?void 0:te.err)||null}),console.log("tx status from getTransaction:",F))}catch(ae){G=!0,clearInterval(z),console.error("getTransaction timeout:",ae,F)}},zo)),$=this.connection.onSignature(F,te=>{if(G){this.connection.removeSignatureListener($);return}G=!0,re(te)},"confirmed"),this.connection.getSignatureStatus(F)};return O(),{txIds:[],signedTxs:C}}else{let N=[];for(let L=0;L<C.length;L+=1){let O=await this.connection.sendTransaction(C[L],{skipPreflight:K});N.push(O)}return{txIds:N,signedTxs:C}}}throw new Error("please provide owner in keypair format or signAllTransactions function")},extInfo:i||{}}}async buildSniperTransaction(e){var T;let P=e||{},{computeBudgetConfig:t,splitIns:n=[],lookupTableCache:o={},lookupTableAddress:r=[]}=P,i=ve(P,["computeBudgetConfig","splitIns","lookupTableCache","lookupTableAddress"]),s=v(v({},this.cluster==="devnet"?await er(this.connection):await us(this.connection)),o),u=Array.from(new Set([...this.lookupTableAddress,...r])),a=[];for(let h of u)s[h]===void 0&&a.push(new Xn(h));let c=await Ji({connection:this.connection,address:a});for(let[h,w]of Object.entries(c))s[h]=w;let l=t?Eo(t):{instructions:[],instructionTypes:[]},m=await Wn(this.connection,this.blockhashCommitment),p=this.signers.reduce((h,w)=>D(v({},h),{[w.publicKey.toBase58()]:w}),{}),f=[],y=[],b=[],g=0;if(this.allInstructions.forEach(h=>{let w=[...b,h],k=t?[...l.instructions,...w]:w;if(h!==n[g]&&b.length<12&&(mn({instructions:k,payer:this.feePayer,lookupTableAddressAccount:s})||mn({instructions:w,payer:this.feePayer,lookupTableAddressAccount:s})))b.push(h);else{if(b.length===0)throw Error("item ins too big");g+=h===n[g]?1:0;let x={};for(let B of[...new Set(u)])s[B]!==void 0&&(x[B]=s[B]);if(t&&mn({instructions:[...l.instructions,...b],payer:this.feePayer,lookupTableAddressAccount:s,recentBlockhash:m})){let B=new pn({payerKey:this.feePayer,recentBlockhash:m,instructions:[...l.instructions,...b]}).compileToV0Message(Object.values(s));f.push(new fn(B))}else{let B=new pn({payerKey:this.feePayer,recentBlockhash:m,instructions:[...b]}).compileToV0Message(Object.values(s));f.push(new fn(B))}y.push(Array.from(new Set(b.map(B=>B.keys.filter(K=>K.isSigner).map(K=>K.pubkey.toString())).flat())).map(B=>p[B]).filter(B=>B!==void 0)),b=[h]}}),b.length>0){let w=[...new Set(b.map(k=>k.keys.filter(x=>x.isSigner).map(x=>x.pubkey.toString())).flat()).values()].map(k=>p[k]).filter(k=>k!==void 0);if(t&&mn({instructions:[...l.instructions,...b],payer:this.feePayer,lookupTableAddressAccount:s,recentBlockhash:m})){let k=new pn({payerKey:this.feePayer,recentBlockhash:m,instructions:[...l.instructions,...b]}).compileToV0Message(Object.values(s));f.push(new fn(k))}else{let k=new pn({payerKey:this.feePayer,recentBlockhash:m,instructions:[...b]}).compileToV0Message(Object.values(s));f.push(new fn(k))}y.push(w)}return(T=this.owner)!=null&&T.signer&&y.forEach(h=>{h.some(w=>w.publicKey.equals(this.owner.publicKey))||h.push(this.owner.signer)}),f.forEach((h,w)=>{h.sign(y[w])}),{builder:this,transactions:f,buildProps:e,signers:y,instructionTypes:this.instructionTypes,execute:async h=>{var I;let{sequentially:w,onTxUpdate:k,skipTxCount:x=0,recentBlockHash:B,skipPreflight:K=!0}=h||{};if(f.map(async(R,C)=>{y[C].length&&R.sign(y[C]),B&&(R.message.recentBlockhash=B)}),Kn(f),(I=this.owner)!=null&&I.isKeyPair){if(w){let R=0,C=[];for(let N of f){if(++R,R<=x){console.log("skip tx: ",R),C.push("tx skipped");continue}let L=await this.connection.sendTransaction(N,{skipPreflight:K});await Wo(this.connection,L),C.push(L)}return{txIds:C,signedTxs:f}}return{txIds:await Promise.all(f.map(async R=>await this.connection.sendTransaction(R,{skipPreflight:K}))),signedTxs:f}}if(this.signAllTransactions){let R=await this.signAllTransactions(f.slice(x,f.length)),C=[...f.slice(0,x),...R];if(w){let N=0,L=[],O=async()=>{if(!C[N])return;if(N<x){L.push({txId:"",status:"success",signedTx:C[N]}),k==null||k([...L]),N++,O();return}let F=await this.connection.sendTransaction(C[N],{skipPreflight:K});L.push({txId:F,status:"sent",signedTx:C[N]}),k==null||k([...L]),N++;let G=!1,z=null,$=null,re=te=>{z!==null&&clearInterval(z),$!==null&&this.connection.removeSignatureListener($);let ae=L.findIndex(ye=>ye.txId===F);if(ae>-1){if(L[ae].status==="error"||L[ae].status==="success")return;L[ae].status=te.err?"error":"success"}k==null||k([...L]),te.err||O()};this.loopMultiTxStatus&&(z=setInterval(async()=>{var te;if(G){clearInterval(z);return}try{let ae=await this.connection.getTransaction(F,{commitment:"confirmed",maxSupportedTransactionVersion:0});ae&&(G=!0,clearInterval(z),re({err:((te=ae.meta)==null?void 0:te.err)||null}),console.log("tx status from getTransaction:",F))}catch(ae){G=!0,clearInterval(z),console.error("getTransaction timeout:",ae,F)}},zo)),$=this.connection.onSignature(F,te=>{if(G){this.connection.removeSignatureListener($);return}G=!0,re(te)},"confirmed"),this.connection.getSignatureStatus(F)};return O(),{txIds:[],signedTxs:C}}else{let N=[];for(let L=0;L<C.length;L+=1){let O=await this.connection.sendTransaction(C[L],{skipPreflight:K});N.push(O)}return{txIds:N,signedTxs:C}}}throw new Error("please provide owner in keypair format or signAllTransactions function")},extInfo:i||{}}}};import{PublicKey as jl}from"@solana/web3.js";import $l from"bn.js";function Zl(d){return typeof d=="object"&&d!==null&&![De,Se,jl,Ie,$l,At,tt].some(e=>typeof e=="object"&&d instanceof e)}function rt(d){return typeof d=="string"?$r(d):Array.isArray(d)?d.map(e=>rt(e)):Zl(d)?Object.fromEntries(Object.entries(d).map(([e,t])=>[e,rt(t)])):d}import Jl from"bn.js";var wt=new Jl(1e6);var nt={BASE_HOST:"https://api-v3.raydium.io",OWNER_BASE_HOST:"https://owner-v1.raydium.io",SERVICE_BASE_HOST:"https://service.raydium.io",MONITOR_BASE_HOST:"https://monitor.raydium.io",SERVICE_1_BASE_HOST:"https://service-v1.raydium.io",SEND_TRANSACTION:"/send-transaction",FARM_ARP:"/main/farm/info",FARM_ARP_LINE:"/main/farm-apr-tv",CLMM_CONFIG:"/main/clmm-config",CPMM_CONFIG:"/main/cpmm-config",VERSION:"/main/version",CHECK_AVAILABILITY:"/v3/main/AvailabilityCheckAPI",RPCS:"/main/rpcs",INFO:"/main/info",STAKE_POOLS:"/main/stake-pools",CHAIN_TIME:"/main/chain-time",TOKEN_LIST:"/mint/list",MINT_INFO_ID:"/mint/ids",JUP_TOKEN_LIST:"https://lite-api.jup.ag/tokens/v1/tagged/verified",POOL_LIST:"/pools/info/list",POOL_SEARCH_BY_ID:"/pools/info/ids",POOL_SEARCH_MINT:"/pools/info/mint",POOL_SEARCH_LP:"/pools/info/lps",POOL_KEY_BY_ID:"/pools/key/ids",POOL_LIQUIDITY_LINE:"/pools/line/liquidity",POOL_POSITION_LINE:"/pools/line/position",FARM_INFO:"/farms/info/ids",FARM_LP_INFO:"/farms/info/lp",FARM_KEYS:"/farms/key/ids",OWNER_CREATED_FARM:"/create-pool/{owner}",OWNER_IDO:"/main/ido/{owner}",OWNER_STAKE_FARMS:"/position/stake/{owner}",OWNER_LOCK_POSITION:"/position/clmm-lock/{owner}",IDO_KEYS:"/ido/key/ids",SWAP_HOST:"https://transaction-v1.raydium.io",SWAP_COMPUTE:"/compute/",SWAP_TX:"/transaction/",MINT_PRICE:"/mint/price",MIGRATE_CONFIG:"/main/migrate-lp",PRIORITY_FEE:"/main/auto-fee",CPMM_LOCK:"https://dynamic-ipfs.raydium.io/lock/cpmm/position"},qb=v({},nt);var cu="ray_tab_hash",ls="ray_req_hash",em=()=>{if(typeof window===void 0)return"";let d=sessionStorage.getItem(cu);return d||(d=`ray-${Date.now()}`,sessionStorage.setItem(cu,d)),d},tr=async n=>{var o=n,{logCount:d=1e3,removeLastLog:e}=o,t=ve(o,["logCount","removeLastLog"]);if(typeof window===void 0)return new Promise(i=>i());let r=JSON.parse(localStorage.getItem(ls)||"[]").slice(0,d-1);e&&r.pop(),new Blob([JSON.stringify(t.data)]).size>1024&&(t.data=JSON.stringify(t.data).substring(0,200)+"..."),r.unshift(D(v({},t),{time:Date.now(),session:em()}));try{localStorage.setItem(ls,JSON.stringify(r))}catch{if(e){let i=!1,s=JSON.stringify(t.data).substring(0,100);for(r[0].data=s+(s.length>100?"...":"");!i;){r.pop();let u=JSON.stringify(t.data).substring(0,100);r[0].data=u+(u.length>100?"...":"");try{localStorage.setItem(ls,JSON.stringify(r)),i=!0}catch{i=!1}}return new Promise(u=>u())}return tr(D(v({},t),{logCount:d,removeLastLog:!0}))}};import{TOKEN_2022_PROGRAM_ID as tm,TOKEN_PROGRAM_ID as nm}from"@solana/spl-token";var nr=ge("Raydium_Api"),ms=new Map;var or=class{constructor({cluster:e,timeout:t,logRequests:n,logCount:o,urlConfigs:r}){this.cluster=e,this.urlConfigs=r||{},this.logCount=o||1e3,this.api=lu.create({baseURL:this.urlConfigs.BASE_HOST||nt.BASE_HOST,timeout:t}),this.api.interceptors.request.use(i=>{let{method:s,baseURL:u,url:a}=i;return nr.debug(`${s==null?void 0:s.toUpperCase()} ${u}${a}`),i},i=>(nr.error("Request failed"),Promise.reject(i))),this.api.interceptors.response.use(i=>{let{config:s,data:u,status:a}=i,{method:c,baseURL:l,url:m}=s;return n&&tr({status:a,url:`${l}${m}`,params:s.params,data:u,logCount:this.logCount}),nr.debug(`${c==null?void 0:c.toUpperCase()} ${l}${m}  ${a}`),u},i=>{let{config:s,response:u={}}=i,{status:a}=u,{method:c,baseURL:l,url:m}=s;return n&&tr({status:a,url:`${l}${m}`,params:s.params,data:i.message,logCount:this.logCount}),nr.error(`${c.toUpperCase()} ${l}${m} ${a||i.message}`),Promise.reject(i)})}async getClmmConfigs(){return(await this.api.get(this.urlConfigs.CLMM_CONFIG||nt.CLMM_CONFIG)).data}async getCpmmConfigs(){return(await this.api.get(this.urlConfigs.CPMM_CONFIG||nt.CPMM_CONFIG)).data}async getClmmPoolLines(e){return(await this.api.get(`${this.urlConfigs.POOL_LIQUIDITY_LINE||nt.POOL_LIQUIDITY_LINE}?pool_id=${e}`)).data}async getBlockSlotCountForSecond(e){if(!e)return 2;let n=(await lu.post(e,{id:"getRecentPerformanceSamples",jsonrpc:"2.0",method:"getRecentPerformanceSamples",params:[4]})).result.map(o=>o.numSlots);return n.reduce((o,r)=>o+r,0)/n.length/60}async getChainTimeOffset(){return(await this.api.get(this.urlConfigs.CHAIN_TIME||nt.CHAIN_TIME)).data}async getRpcs(){return this.api.get(this.urlConfigs.RPCS||nt.RPCS)}async getTokenList(){return(await this.api.get(this.urlConfigs.TOKEN_LIST||nt.TOKEN_LIST)).data}async getJupTokenList(){return(await this.api.get("",{baseURL:this.urlConfigs.JUP_TOKEN_LIST||nt.JUP_TOKEN_LIST})).map(t=>D(v({},t),{chainId:101,programId:t.tags.includes("token-2022")?tm.toBase58():nm.toBase58()}))}async getTokenInfo(e){return(await this.api.get((this.urlConfigs.MINT_INFO_ID||nt.MINT_INFO_ID)+`?mints=${e.map(n=>n.toString()).join(",")}`)).data}async getPoolList(e={}){let{type:t="all",sort:n="liquidity",order:o="desc",page:r=0,pageSize:i=100}=e;return(await this.api.get((this.urlConfigs.POOL_LIST||nt.POOL_LIST)+`?poolType=${t}&poolSortField=${n}&sortType=${o}&page=${r}&pageSize=${i}`)).data}async fetchPoolById(e){let{ids:t}=e;return(await this.api.get((this.urlConfigs.POOL_SEARCH_BY_ID||nt.POOL_SEARCH_BY_ID)+`?ids=${t}`)).data}async fetchPoolKeysById(e){let{idList:t}=e,n=[],o=t.filter(i=>ms.has(i)?(n.push(ms.get(i)),!1):!0),r=[];return o.length&&(r=(await this.api.get((this.urlConfigs.POOL_KEY_BY_ID||nt.POOL_KEY_BY_ID)+`?ids=${o.join(",")}`)).data.filter(Boolean),r.forEach(s=>{ms.set(s.id,s)})),n.concat(r)}async fetchPoolByMints(e){let{mint1:t,mint2:n,type:o="all",sort:r="default",order:i="desc",page:s=1}=e,[u,a]=[t&&ut(t).toBase58(),n&&n!=="undefined"?ut(n).toBase58():""],[c,l]=a&&u>a?[a,u]:[u,a];return(await this.api.get((this.urlConfigs.POOL_SEARCH_MINT||nt.POOL_SEARCH_MINT)+`?mint1=${c}&mint2=${l}&poolType=${o}&poolSortField=${r}&sortType=${i}&pageSize=100&page=${s}`)).data}async fetchFarmInfoById(e){let{ids:t}=e;return(await this.api.get((this.urlConfigs.FARM_INFO||nt.FARM_INFO)+`?ids=${t}`)).data}async fetchFarmKeysById(e){let{ids:t}=e;return(await this.api.get((this.urlConfigs.FARM_KEYS||nt.FARM_KEYS)+`?ids=${t}`)).data}async fetchAvailabilityStatus(){return(await this.api.get(this.urlConfigs.CHECK_AVAILABILITY||nt.CHECK_AVAILABILITY)).data}};var ir="please provide owner in load() initialization or you can set by calling raydium.setOwner(owner)",mu="please provide connection in load() initialization or set it by raydium.setConnection(connection)";import{PublicKey as lr,SystemProgram as Nm}from"@solana/web3.js";import{AccountLayout as To,createAssociatedTokenAccountIdempotentInstruction as Ts,TOKEN_PROGRAM_ID as Mn,TOKEN_2022_PROGRAM_ID as Mm}from"@solana/spl-token";var ds=(...d)=>d.map(e=>{try{return typeof e=="object"?JSON.stringify(e):e}catch{return e}}).join(", "),_e=class{constructor({scope:e,moduleName:t}){this.disabled=!1;this.scope=e,this.logger=ge(t)}createTxBuilder(e){return this.scope.checkOwner(),new Yo({connection:this.scope.connection,feePayer:e||this.scope.ownerPubKey,cluster:this.scope.cluster,owner:this.scope.owner,blockhashCommitment:this.scope.blockhashCommitment,loopMultiTxStatus:this.scope.loopMultiTxStatus,api:this.scope.api,signAllTransactions:this.scope.signAllTransactions})}createSniperTxBuilder(e,t){let n=new xt(e);return new Yo({connection:this.scope.connection,feePayer:t,cluster:this.scope.cluster,owner:n,blockhashCommitment:this.scope.blockhashCommitment,loopMultiTxStatus:this.scope.loopMultiTxStatus,api:this.scope.api,signAllTransactions:this.scope.signAllTransactions})}logDebug(...e){this.logger.debug(ds(e))}logInfo(...e){this.logger.info(ds(e))}logAndCreateError(...e){let t=ds(e);throw new Error(t)}checkDisabled(){(this.disabled||!this.scope)&&this.logAndCreateError("module not working")}};import{PublicKey as Sm,SystemProgram as Km}from"@solana/web3.js";import Cm from"bn.js";import{createCloseAccountInstruction as Rm,createInitializeAccountInstruction as Lm,createTransferInstruction as Om,TOKEN_PROGRAM_ID as wo}from"@solana/spl-token";import{Keypair as hm,PublicKey as xu}from"@solana/web3.js";import Im from"bn.js";import{TOKEN_PROGRAM_ID as Bm}from"@solana/spl-token";function om(d){return d instanceof Uint8Array||d!=null&&typeof d=="object"&&d.constructor.name==="Uint8Array"}function ps(d,...e){if(!om(d))throw new Error("Uint8Array expected");if(e.length>0&&!e.includes(d.length))throw new Error(`Uint8Array expected of length ${e}, not of length=${d.length}`)}function fs(d,e=!0){if(d.destroyed)throw new Error("Hash instance has been destroyed");if(e&&d.finished)throw new Error("Hash#digest() has already been called")}function du(d,e){ps(d);let t=e.outputLen;if(d.length<t)throw new Error(`digestInto() expects output buffer of length at least ${t}`)}var sr=d=>new DataView(d.buffer,d.byteOffset,d.byteLength),Jt=(d,e)=>d<<32-e|d>>>e;var Sg=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;function im(d){if(typeof d!="string")throw new Error(`utf8ToBytes expected string, got ${typeof d}`);return new Uint8Array(new TextEncoder().encode(d))}function ys(d){return typeof d=="string"&&(d=im(d)),ps(d),d}var rr=class{clone(){return this._cloneInto()}},Kg={}.toString;function pu(d){let e=n=>d().update(ys(n)).digest(),t=d();return e.outputLen=t.outputLen,e.blockLen=t.blockLen,e.create=()=>d(),e}function rm(d,e,t,n){if(typeof d.setBigUint64=="function")return d.setBigUint64(e,t,n);let o=BigInt(32),r=BigInt(4294967295),i=Number(t>>o&r),s=Number(t&r),u=n?4:0,a=n?0:4;d.setUint32(e+u,i,n),d.setUint32(e+a,s,n)}var fu=(d,e,t)=>d&e^~d&t,yu=(d,e,t)=>d&e^d&t^e&t,ar=class extends rr{constructor(e,t,n,o){super(),this.blockLen=e,this.outputLen=t,this.padOffset=n,this.isLE=o,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(e),this.view=sr(this.buffer)}update(e){fs(this);let{view:t,buffer:n,blockLen:o}=this;e=ys(e);let r=e.length;for(let i=0;i<r;){let s=Math.min(o-this.pos,r-i);if(s===o){let u=sr(e);for(;o<=r-i;i+=o)this.process(u,i);continue}n.set(e.subarray(i,i+s),this.pos),this.pos+=s,i+=s,this.pos===o&&(this.process(t,0),this.pos=0)}return this.length+=e.length,this.roundClean(),this}digestInto(e){fs(this),du(e,this),this.finished=!0;let{buffer:t,view:n,blockLen:o,isLE:r}=this,{pos:i}=this;t[i++]=128,this.buffer.subarray(i).fill(0),this.padOffset>o-i&&(this.process(n,0),i=0);for(let l=i;l<o;l++)t[l]=0;rm(n,o-8,BigInt(this.length*8),r),this.process(n,0);let s=sr(e),u=this.outputLen;if(u%4)throw new Error("_sha2: outputLen should be aligned to 32bit");let a=u/4,c=this.get();if(a>c.length)throw new Error("_sha2: outputLen bigger than state");for(let l=0;l<a;l++)s.setUint32(4*l,c[l],r)}digest(){let{buffer:e,outputLen:t}=this;this.digestInto(e);let n=e.slice(0,t);return this.destroy(),n}_cloneInto(e){e||(e=new this.constructor),e.set(...this.get());let{blockLen:t,buffer:n,length:o,finished:r,destroyed:i,pos:s}=this;return e.length=o,e.pos=s,e.finished=r,e.destroyed=i,o%t&&e.buffer.set(n),e}};var sm=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),Ln=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),On=new Uint32Array(64),bs=class extends ar{constructor(){super(64,32,8,!1),this.A=Ln[0]|0,this.B=Ln[1]|0,this.C=Ln[2]|0,this.D=Ln[3]|0,this.E=Ln[4]|0,this.F=Ln[5]|0,this.G=Ln[6]|0,this.H=Ln[7]|0}get(){let{A:e,B:t,C:n,D:o,E:r,F:i,G:s,H:u}=this;return[e,t,n,o,r,i,s,u]}set(e,t,n,o,r,i,s,u){this.A=e|0,this.B=t|0,this.C=n|0,this.D=o|0,this.E=r|0,this.F=i|0,this.G=s|0,this.H=u|0}process(e,t){for(let l=0;l<16;l++,t+=4)On[l]=e.getUint32(t,!1);for(let l=16;l<64;l++){let m=On[l-15],p=On[l-2],f=Jt(m,7)^Jt(m,18)^m>>>3,y=Jt(p,17)^Jt(p,19)^p>>>10;On[l]=y+On[l-7]+f+On[l-16]|0}let{A:n,B:o,C:r,D:i,E:s,F:u,G:a,H:c}=this;for(let l=0;l<64;l++){let m=Jt(s,6)^Jt(s,11)^Jt(s,25),p=c+m+fu(s,u,a)+sm[l]+On[l]|0,y=(Jt(n,2)^Jt(n,13)^Jt(n,22))+yu(n,o,r)|0;c=a,a=u,u=s,s=i+p|0,i=r,r=o,o=n,n=p+y|0}n=n+this.A|0,o=o+this.B|0,r=r+this.C|0,i=i+this.D|0,s=s+this.E|0,u=u+this.F|0,a=a+this.G|0,c=c+this.H|0,this.set(n,o,r,i,s,u,a,c)}roundClean(){On.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}};var bu=pu(()=>new bs);import{PublicKey as Am}from"@solana/web3.js";import wu,{isBN as Tu}from"bn.js";import{bits as am,BitStructure as _g,blob as um,Blob as Vg,cstr as Eg,f32 as Wg,f32be as Dg,f64 as qg,f64be as Ug,greedy as Gg,Layout as cm,ns64 as Xg,ns64be as zg,nu64 as lm,nu64be as Yg,offset as mm,s16 as Qg,s16be as Hg,s24 as jg,s24be as $g,s32 as dm,s32be as Zg,s40 as Jg,s40be as eP,s48 as tP,s48be as nP,s8 as oP,seq as pm,struct as iP,Structure as fm,u16 as ym,u16be as rP,u24 as sP,u24be as aP,u32 as bm,u32be as uP,u40 as cP,u40be as lP,u48 as mP,u48be as dP,u8 as gm,UInt as Pm,union as pP,Union as fP,unionLayoutDiscriminator as yP,utf8 as bP}from"@solana/buffer-layout";var ur=cm,gu=fm;var gs=Pm;var Pu=gm,St=ym;var Qo=bm;var Au=lm;var Ve=dm;var ku=pm;var Te=um;var Ps=am,As=mm;var Yn=class extends ur{constructor(t,n,o){super(t,o);this.blob=Te(t),this.signed=n}decode(t,n=0){let o=new wu(this.blob.decode(t,n),10,"le");return this.signed?o.fromTwos(this.span*8).clone():o}encode(t,n,o=0){return typeof t=="number"&&(t=new wu(t)),this.signed&&(t=t.toTwos(this.span*8)),this.blob.encode(t.toArrayLike(Buffer,"le",this.span),n,o)}},cr=class extends ur{constructor(t){super(8,t);this._lower=Ps(Qo(),!1),this._upper=Ps(Qo(),!1)}addBoolean(t){this._lower.fields.length<32?this._lower.addBoolean(t):this._upper.addBoolean(t)}decode(t,n=0){let o=this._lower.decode(t,n),r=this._upper.decode(t,n+this._lower.span);return v(v({},o),r)}encode(t,n,o=0){return this._lower.encode(t,n,o)+this._upper.encode(t,n,o+this._lower.span)}};function V(d){return new gs(1,d)}function lt(d){return new gs(4,d)}function A(d){return new Yn(8,!1,d)}function oe(d){return new Yn(16,!1,d)}function hu(d){return new Yn(1,!0,d)}function ko(d){return new Yn(8,!0,d)}function Iu(d){return new Yn(16,!0,d)}var Qn=class extends ur{constructor(t,n,o,r){super(t.span,r);this.layout=t,this.decoder=n,this.encoder=o}decode(t,n){return this.decoder(this.layout.decode(t,n))}encode(t,n,o){return this.layout.encode(this.encoder(t),n,o)}getSpan(t,n){return this.layout.getSpan(t,n)}};function M(d){return new Qn(Te(32),e=>new Am(e),e=>e.toBuffer(),d)}function qe(d){return new Qn(Pu(),km,wm,d)}function km(d){if(d===0)return!1;if(d===1)return!0;throw new Error("Invalid bool: "+d)}function wm(d){return d?1:0}function Bu(d,e){let t=Qo("length"),n=_([t,Y(d,As(t,-t.span),"values")]);return new Qn(n,({values:o})=>o,o=>({values:o}),e)}function Tm(d){let e=Qo("length"),t=_([e,Te(As(e,-e.span),"data")]);return new Qn(t,({data:n})=>n,n=>({data:n}),d)}function Tt(d){return new Qn(Tm(),e=>e.toString("utf-8"),e=>Buffer.from(e,"utf-8"),d)}var ks=class extends gu{decode(e,t){return super.decode(e,t)}};function _(d,e,t){return new ks(d,e,t)}function Y(d,e,t){let n,o=typeof e=="number"?e:Tu(e)?e.toNumber():new Proxy(e,{get(r,i){if(!n){let s=Reflect.get(r,"count");n=Tu(s)?s.toNumber():s,Reflect.set(r,"count",n)}return Reflect.get(r,i)},set(r,i,s){return i==="count"&&(n=s),Reflect.set(r,i,s)}});return ku(d,o,t)}var Hn=_([M("mint"),M("owner"),A("amount"),lt("delegateOption"),M("delegate"),V("state"),lt("isNativeOption"),A("isNative"),A("delegatedAmount"),lt("closeAuthorityOption"),M("closeAuthority")]);var _P=ge("Raydium_Util");function Su({owner:d,solAccountResp:e,tokenAccountResp:t}){let n=[],o=[];for(let{pubkey:r,account:i}of t.value){let s=Hn.decode(i.data),{mint:u,amount:a}=s;n.push({publicKey:r,mint:u,amount:a,isAssociated:Z(d,u,i.owner).publicKey.equals(r),isNative:!1,programId:i.owner}),o.push({pubkey:r,accountInfo:s,programId:i.owner})}return e&&n.push({mint:xu.default,amount:new Im(String(e.lamports)),isNative:!0,programId:e.owner}),{tokenAccounts:n,tokenAccountRawInfos:o}}function Ye({fromPublicKey:d,programId:e=Bm,assignSeed:t}){let n=t?btoa(t).slice(0,32):hm.generate().publicKey.toBase58().slice(0,32);return{publicKey:xm(d,n,e),seed:n}}function xm(d,e,t){let n=Buffer.concat([d.toBuffer(),Buffer.from(e),t.toBuffer()]),o=bu(n);return new xu(o)}function ws(d){let{mint:e,tokenAccount:t,owner:n,programId:o=wo}=d;return Lm(t,e,n,o)}function yn(d){let{tokenAccount:e,payer:t,multiSigners:n=[],owner:o,programId:r=wo}=d;return Rm(e,t,o,n,r)}async function Nn(d){let{connection:e,amount:t,commitment:n,payer:o,owner:r,skipCloseAccount:i}=d,s=await e.getMinimumBalanceForRentExemption(Hn.span,n),u=ee(t).add(new Cm(s)),a=Ye({fromPublicKey:o,programId:wo});return{addresses:{newAccount:a.publicKey},signers:[],instructions:[Km.createAccountWithSeed({fromPubkey:o,basePubkey:o,seed:a.seed,newAccountPubkey:a.publicKey,lamports:u.toNumber(),space:Hn.span,programId:wo}),ws({mint:new Sm(ct.address),tokenAccount:a.publicKey,owner:r,programId:wo})],instructionTypes:[U.CreateAccount,U.InitAccount],endInstructionTypes:i?[]:[U.CloseAccount],endInstructions:i?[]:[yn({tokenAccount:a.publicKey,payer:o,owner:r})]}}function Ku({source:d,destination:e,owner:t,amount:n,multiSigners:o=[],tokenProgram:r=wo}){return Om(d,e,t,BigInt(String(n)),o,r)}var Ho=class extends _e{constructor(t){super(t);this._tokenAccounts=[];this._tokenAccountRawInfos=[];this._accountListener=[];this._clientOwnedToken=!1;this._notSubscribeAccountChange=!1;this._accountFetchTime=0;let{tokenAccounts:n,tokenAccountRawInfos:o,notSubscribeAccountChange:r}=t;this._tokenAccounts=n||[],this._tokenAccountRawInfos=o||[],this._notSubscribeAccountChange=r!=null?r:!0,this._clientOwnedToken=!!(n||o)}get tokenAccounts(){return this._tokenAccounts}get tokenAccountRawInfos(){return this._tokenAccountRawInfos}set notSubscribeAccountChange(t){this._notSubscribeAccountChange=t}updateTokenAccount({tokenAccounts:t,tokenAccountRawInfos:n}){return t&&(this._tokenAccounts=t),n&&(this._tokenAccountRawInfos=n),this._accountChangeListenerId&&this.scope.connection.removeAccountChangeListener(this._accountChangeListenerId),this._accountChangeListenerId=void 0,this._clientOwnedToken=!0,this}addAccountChangeListener(t){return this._accountListener.push(t),this}removeAccountChangeListener(t){return this._accountListener=this._accountListener.filter(n=>n!==t),this}getAssociatedTokenAccount(t,n){return Z(this.scope.ownerPubKey,t,n).publicKey}getAssociatedTokenAccountByOwner(t,n,o){return Z(t,n,o).publicKey}resetTokenAccounts(){this._clientOwnedToken||(this._tokenAccounts=[],this._tokenAccountRawInfos=[])}async fetchWalletTokenAccounts(t){if(this._clientOwnedToken||!(t!=null&&t.forceUpdate)&&this._tokenAccounts.length&&Date.now()-this._accountFetchTime<(this._notSubscribeAccountChange?1e3*5:1e3*60*3))return{tokenAccounts:this._tokenAccounts,tokenAccountRawInfos:this._tokenAccountRawInfos};this.scope.checkOwner();let o=v(v({},{}),t),[r,i,s]=await Promise.all([this.scope.connection.getAccountInfo(this.scope.ownerPubKey,o.commitment),this.scope.connection.getTokenAccountsByOwner(this.scope.ownerPubKey,{programId:Mn},o.commitment),this.scope.connection.getTokenAccountsByOwner(this.scope.ownerPubKey,{programId:Mm},o.commitment)]),{tokenAccounts:u,tokenAccountRawInfos:a}=Su({owner:this.scope.ownerPubKey,solAccountResp:r,tokenAccountResp:{context:i.context,value:[...i.value,...s.value]}});return this._tokenAccounts=u,this._tokenAccountRawInfos=a,this._accountFetchTime=Date.now(),this._notSubscribeAccountChange||(this._accountChangeListenerId&&this.scope.connection.removeAccountChangeListener(this._accountChangeListenerId),this._accountChangeListenerId=this.scope.connection.onAccountChange(this.scope.ownerPubKey,()=>{this.fetchWalletTokenAccounts({forceUpdate:!0}),this._accountListener.forEach(c=>c({tokenAccounts:this._tokenAccounts,tokenAccountRawInfos:this._tokenAccountRawInfos}))},{commitment:t==null?void 0:t.commitment})),{tokenAccounts:u,tokenAccountRawInfos:a}}clearAccountChangeCkb(){this._accountChangeListenerId!==void 0&&this.scope.connection.removeAccountChangeListener(this._accountChangeListenerId)}async getCreatedTokenAccount({mint:t,programId:n=Mn,associatedOnly:o=!0}){await this.fetchWalletTokenAccounts();let r=this._tokenAccounts.filter(({mint:s})=>s==null?void 0:s.equals(t)).sort((s,u)=>s.amount.lt(u.amount)?1:-1),i=this.getAssociatedTokenAccount(t,n);for(let s of r){let{publicKey:u}=s;if(u&&(!o||o&&i.equals(u)))return u}}async getOrCreateTokenAccount(t){var y,b,g,P;await this.fetchWalletTokenAccounts();let{mint:n,createInfo:o,associatedOnly:r,owner:i,notUseTokenAccount:s=!1,skipCloseAccount:u=!1,checkCreateATAOwner:a=!1,assignSeed:c}=t;console.log("******************associatedOnly: ",r);let l=new lr(t.tokenProgram||Mn),m=this.getAssociatedTokenAccount(n,new lr(l)),p=(s?[]:this.tokenAccountRawInfos).filter(T=>T.accountInfo.mint.equals(n)&&(!r||T.pubkey.equals(m))).sort((T,h)=>T.accountInfo.amount.lt(h.accountInfo.amount)?1:-1);if(o===void 0||p.length>0)return p.length>0?{account:p[0].pubkey}:{};let f={instructions:[],endInstructions:[],signers:[],instructionTypes:[],endInstructionTypes:[]};if(r){let T=Ts(i,m,i,n,l),h=this.tokenAccountRawInfos.find(w=>w.pubkey.equals(m));if(a){console.log("******************checkCreateATAOwner: ",a);let w=await this.scope.connection.getAccountInfo(m);if(w===null)console.log("******************ataInfo == null: ",a),(y=f.instructions)==null||y.push(T),f.instructionTypes.push(U.CreateATA);else if(w.owner.equals(l)&&To.decode(w.data).mint.equals(n)&&To.decode(w.data).owner.equals(i))console.log("******************else empty: ");else throw Error(`create ata check error -> mint: ${n.toString()}, ata: ${m.toString()}`)}else h===void 0&&(console.log("******************_ataInTokenAcc undefined"),f.instructions.push(T),f.instructionTypes.push(U.CreateATA));if(n.equals(H)&&o.amount){console.log("createWSolAccountInstructions*********************************");let w=await Nn({connection:this.scope.connection,owner:i||this.scope.ownerPubKey,payer:o.payer||this.scope.ownerPubKey,amount:(b=o.amount)!=null?b:0,skipCloseAccount:u});f.instructions.push(...w.instructions||[]),f.endInstructions.push(...w.endInstructions||[]),f.instructionTypes.push(...w.instructionTypes||[]),f.endInstructionTypes.push(...w.endInstructionTypes||[]),o.amount&&(console.log("******************createInfo.amount"),f.instructions.push(Ku({source:w.addresses.newAccount,destination:m,owner:i||this.scope.ownerPubKey,amount:o.amount,tokenProgram:Mn})),f.instructionTypes.push(U.TransferAmount))}return!u&&h===void 0&&(console.log("******************skipCloseAccount"),f.endInstructions.push(yn({owner:i,payer:o.payer||i,tokenAccount:m,programId:l})),f.endInstructionTypes.push(U.CloseAccount)),{account:m,instructionParams:f}}else{console.log("******************newTokenAccount");let T=Ye({fromPublicKey:i,programId:l,assignSeed:c}),h=await this.scope.connection.getMinimumBalanceForRentExemption(To.span),w=Nm.createAccountWithSeed({fromPubkey:i,basePubkey:i,seed:T.seed,newAccountPubkey:T.publicKey,lamports:h+Number((P=(g=o.amount)==null?void 0:g.toString())!=null?P:0),space:To.span,programId:l});return f.instructions.push(w,ws({mint:n,tokenAccount:T.publicKey,owner:i||this.scope.ownerPubKey,programId:l})),f.instructionTypes.push(U.CreateAccount),f.instructionTypes.push(U.InitAccount),u||(f.endInstructions.push(yn({owner:i,payer:o.payer||i,tokenAccount:T.publicKey,programId:l})),f.endInstructionTypes.push(U.CloseAccount)),{account:T.publicKey,instructionParams:f}}}async checkOrCreateAta({mint:t,programId:n=Mn,autoUnwrapWSOLToSOL:o}){var u;await this.fetchWalletTokenAccounts();let r=(u=this.scope.account.tokenAccounts.find(({mint:a})=>(a==null?void 0:a.toBase58())===t.toBase58()))==null?void 0:u.publicKey,i=this.scope.ownerPubKey,s={};if(!r){let a=this.getAssociatedTokenAccount(t,n),c=await Ts(i,a,i,t,n);s.instructions=[c],s.instructionTypes=[U.CreateATA],r=a}return o&&H.toBase58()===t.toBase58()&&(s.endInstructions=[yn({owner:i,payer:i,tokenAccount:r,programId:n})],s.endInstructionTypes=[U.CloseAccount]),{pubKey:r,newInstructions:s}}async handleTokenAccount(t){let{side:n,amount:o,mint:r,programId:i=Mn,tokenAccount:s,payer:u=this.scope.ownerPubKey,bypassAssociatedCheck:a,skipCloseAccount:c,checkCreateATAOwner:l}=t,m=this.getAssociatedTokenAccount(r,i);if(new lr(H).equals(r)){let p=await Nn({connection:this.scope.connection,owner:this.scope.ownerPubKey,payer:u,amount:o,skipCloseAccount:c});return v({tokenAccount:p.addresses.newAccount},p)}else if(!s||n==="out"&&!m.equals(s)&&!a){let p=[],f=Ts(this.scope.ownerPubKey,m,this.scope.ownerPubKey,r,i);if(l){let y=await this.scope.connection.getAccountInfo(m);if(y===null)p.push(f);else if(!(y.owner.equals(Mn)&&To.decode(y.data).mint.equals(r)&&To.decode(y.data).owner.equals(this.scope.ownerPubKey)))throw Error(`create ata check error -> mint: ${r.toString()}, ata: ${m.toString()}`)}else p.push(f);return{tokenAccount:m,instructions:p,instructionTypes:[U.CreateATA]}}return{tokenAccount:s}}async processTokenAccount(t){let{mint:n,programId:o=Mn,amount:r,useSOLBalance:i,handleTokenAccount:s,feePayer:u}=t,a,c=this.createTxBuilder(u);if(n.equals(new lr(H))&&i){let l=await this.handleTokenAccount({side:"in",amount:r||0,mint:n,bypassAssociatedCheck:!0,programId:o}),{tokenAccount:p}=l,f=ve(l,["tokenAccount"]);a=p,c.addInstruction(f)}else if(a=await this.getCreatedTokenAccount({mint:n,associatedOnly:!1,programId:o}),!a&&s){let m=await this.scope.account.handleTokenAccount({side:"in",amount:0,mint:n,bypassAssociatedCheck:!0,programId:o}),{tokenAccount:p}=m,f=ve(m,["tokenAccount"]);a=p,c.addInstruction(f)}return v({tokenAccount:a},c.AllTxData)}};import{PublicKey as xe,SystemProgram as $m}from"@solana/web3.js";import{createAssociatedTokenAccountIdempotentInstruction as Gu}from"@solana/spl-token";import Zm from"decimal.js";import{PublicKey as Cs}from"@solana/web3.js";var hs=_([V("instruction")]),Is=_([V("instruction")]),vm=_([A("rewardState"),A("rewardOpenTime"),A("rewardEndTime"),A("rewardLastUpdateTime"),A("totalReward"),A("totalRewardEmissioned"),A("rewardClaimed"),A("rewardPerSecond"),oe("accRewardPerShare"),M("rewardVault"),M("rewardMint"),M("rewardSender"),A("rewardType"),Y(A(),15,"padding")]),Fm=_([A("state"),A("nonce"),M("lpVault"),M("rewardVault"),M(),M(),A(),A(),A("totalReward"),oe("perShareReward"),A("lastSlot"),A("perSlotReward")]),_m=_([A("state"),A("nonce"),M("lpVault"),M("rewardVaultA"),A("totalRewardA"),oe("perShareRewardA"),A("perSlotRewardA"),V("option"),M("rewardVaultB"),Te(7),A("totalRewardB"),oe("perShareRewardB"),A("perSlotRewardB"),A("lastSlot"),M()]),Vm=_([A(),A("state"),A("nonce"),A("validRewardTokenNum"),oe("rewardMultiplier"),A("rewardPeriodMax"),A("rewardPeriodMin"),A("rewardPeriodExtend"),M("lpMint"),M("lpVault"),Y(vm,5,"rewardInfos"),M("creator"),M(),Y(A(),32,"padding")]),Em=new Proxy(Fm,{get(d,e,t){return e==="decode"?(...n)=>{let o=d.decode(...n);return D(v({},o),{version:3,rewardInfos:[{rewardVault:o.rewardVault,totalReward:o.totalReward,perSlotReward:o.perSlotReward,perShareReward:o.perShareReward}]})}:Reflect.get(d,e,t)}}),Wm=new Proxy(_m,{get(d,e,t){return e==="decode"?(...n)=>{let o=d.decode(...n);return D(v({},o),{version:5,rewardInfos:[{rewardVault:o.rewardVaultA,totalReward:o.totalRewardA,perSlotReward:o.perSlotRewardA,perShareReward:o.perShareRewardA},{rewardVault:o.rewardVaultB,totalReward:o.totalRewardB,perSlotReward:o.perSlotRewardB,perShareReward:o.perShareRewardB}]})}:Reflect.get(d,e,t)}}),mr=new Proxy(Vm,{get(d,e,t){return e==="decode"?(...n)=>{let o=d.decode(...n);return D(v({},o),{version:6,rewardInfos:o.rewardInfos.map(r=>{var i;return D(v({},r),{rewardType:((i=Object.entries(vn).find(s=>String(s[1])===r.rewardType.toString()))!=null?i:["Standard SPL"])[0]})})})}:Reflect.get(d,e,t)}}),Dm=_([A("isSet"),A("rewardPerSecond"),A("rewardOpenTime"),A("rewardEndTime"),A("rewardType")]),Bs=_([V("instruction"),A("nonce"),Y(Dm,5,"rewardTimeInfo")]),xs=_([V("instruction"),A("rewardReopenTime"),A("rewardEndTime"),A("rewardPerSecond")]),Ss=_([V("instruction"),A("isSet"),A("rewardPerSecond"),A("rewardOpenTime"),A("rewardEndTime"),A("rewardType")]),yA=_([A("state"),M("id"),M("owner"),A("deposited"),Y(A(),1,"rewardDebts")]),Ks=_([A("state"),M("id"),M("owner"),A("deposited"),Y(oe(),1,"rewardDebts"),A(""),A("voteLockedBalance"),Y(A(),15)]),bA=_([A("state"),M("id"),M("owner"),A("deposited"),Y(A(),2,"rewardDebts")]),Cu=_([A("state"),M("id"),M("owner"),A("deposited"),Y(oe(),2,"rewardDebts"),Y(A(),17)]),Ru=_([A(),A("state"),M("id"),M("owner"),A("deposited"),Y(oe(),5,"rewardDebts"),Y(A(),16)]),Kt=_([V("instruction"),A("amount")]),qm=_([M("mint"),M("grantAuthority"),A("baselineVoteWeightScaledFactor"),A("maxExtraLockupVoteWeightScaledFactor"),A("lockupSaturationSecs"),hu("digitShift"),Y(V(),7,"reserved1"),Y(A(),7,"reserved2")]),Um=_([Te(8),M("governanceProgramId"),M("realm"),M("realmGoverningTokenMint"),M("realmAuthority"),Y(V(),32,"reserved1"),Y(qm,4,"votingMints"),ko("timeOffset"),V("bump"),Y(V(),7,"reserved2"),Y(A(),11,"reserved3")]),Gm=_([ko("startTime"),ko("endTime"),V("kind"),Y(V(),15,"reserved")]),Xm=_([Y(Gm,1,"lockup"),A("amountDeposited_native"),A("amountInitiallyLockedNative"),qe("isUsed"),qe("allowClawback"),V("votingMintConfigIdx"),Y(V(),29,"reserved")]),zm=_([Te(8),M("voterAuthority"),M("registrar"),Y(Xm,32,"deposits"),V("voterBump"),V("voterWweightRecordBump"),Y(V(),94,"reserved")]);import{NATIVE_MINT as BA}from"@solana/spl-token";var xA=ge("Raydium_farm_config"),Lu=new Cs("4k3Dyjzvzp8eMZWUXbBCjEvwSkkk59S5iCNLY3QrkX6R"),Ou=new Cs("FrspKwj8i3pNmKwXreTveC4fu7KL5ZbGeXdZBe2XViu1");var SA=new Cs("3TRTX4dXUpp2eqxi3tvQDFYUV7SdDJjcPE3Y4mbtftaX");var Nu={3:Ks,5:Cu,6:Ru},Rs=d=>[3,4,5,6].indexOf(d)!==-1,Ls=d=>{var i;let{version:e,rewardInfos:t,rewardTokenAccountsPublicKeys:n}=d,o=`rewardInfo:${JSON.stringify(t)}, rewardAccount:${JSON.stringify(n)}`,r={3:()=>{if(t.length!==1||n.length!==1)return`rewardInfos or rewardTokenAccounts lengths not equal 1: ${o}`},5:()=>{if(t.length!==n.length)return`rewardInfos and rewardTokenAccounts lengths not equal: ${o}`},6:()=>{if(!n.length||t.length!==n.length)return`no rewardTokenAccounts or rewardInfos and rewardTokenAccounts lengths not equal: ${o}`}};return(i=r[e])==null?void 0:i.call(r)},vn={"Standard SPL":0,"Option tokens":1},Ft={[nu.toString()]:3,[ou.toString()]:4,[iu.toString()]:5,[qo.toString()]:6,[dn.FARM_PROGRAM_ID_V3.toString()]:3,[dn.FARM_PROGRAM_ID_V4.toString()]:4,[dn.FARM_PROGRAM_ID_V5.toString()]:5,[dn.FARM_PROGRAM_ID_V6.toString()]:6};import{PublicKey as be,SystemProgram as Fu,SYSVAR_CLOCK_PUBKEY as Zo,SYSVAR_RENT_PUBKEY as Hm,TransactionInstruction as Vt}from"@solana/web3.js";import _u from"bn.js";import{ASSOCIATED_TOKEN_PROGRAM_ID as rk,createAssociatedTokenAccountIdempotentInstruction as sk,TOKEN_PROGRAM_ID as bn}from"@solana/spl-token";import Ym from"bn.js";var Qm=ge("Raydium.farm.util");function jo({programId:d,poolId:e,mint:t,type:n}){let{publicKey:o}=ce([e.toBuffer(),t.toBuffer(),Buffer.from(n==="lpVault"?"lp_vault_associated_seed":n==="rewardVault"?"reward_vault_associated_seed":"","utf-8")],d);return o}function _t({programId:d,poolId:e,owner:t,version:n}){let{publicKey:o}=ce([e.toBuffer(),t.toBuffer(),Buffer.from(n===6?"farmer_info_associated_seed":"staker_info_v2_associated_seed","utf-8")],d);return o}var Mu=({programId:d,poolId:e})=>ce([e.toBuffer()],d);function vu(d){return{isSet:new Ym(1),rewardPerSecond:ee(d.perSecond),rewardOpenTime:ee(d.openTime),rewardEndTime:ee(d.endTime),rewardType:ee(vn[d.rewardType])}}function Os(d){return ee(d.endTime).sub(ee(d.openTime)).mul(ee(d.perSecond))}function $o(d){let e=Nu[d];return e||Qm.logWithError("invalid version",d),e}var jm=ge("Raydium_farm_instruction"),gk={voterStakeRegistryCreateVoter:Buffer.from([6,24,245,52,243,255,148,25]),voterStakeRegistryCreateDepositEntry:Buffer.from([185,131,167,186,159,125,19,67]),voterStakeRegistryDeposit:Buffer.from([242,35,198,137,82,225,242,182]),voterStakeRegistryWithdraw:Buffer.from([183,18,70,156,148,109,161,34]),voterStakeRegistryUpdateVoterWeightRecord:Buffer.from([45,185,3,36,109,190,115,169])};function Jo(d){let{version:e,id:t,ledger:n,programId:o,owner:r}=d,i={3:9,5:10}[e];i||jm.logWithError(`invalid farm pool version: ${e}`);let s=Buffer.alloc(hs.span);hs.encode({instruction:i},s);let u=[S({pubkey:t}),S({pubkey:n}),S({pubkey:r,isWritable:!1}),S({pubkey:Fu.programId,isWritable:!1}),S({pubkey:Hm,isWritable:!1})];return{instruction:new Vt({programId:o,keys:u,data:s}),instructionType:U.FarmV3CreateLedger}}function Vu(d){var n;let e=Buffer.alloc(Bs.span);Bs.encode({instruction:0,nonce:new _u(d.nonce),rewardTimeInfo:d.rewardInfoConfig},e);let t=[...Hr,S({pubkey:d.farmId}),S({pubkey:d.farmAuthority,isWritable:!1}),S({pubkey:d.lpVault}),S({pubkey:d.lpMint,isWritable:!1}),S({pubkey:d.lockVault}),S({pubkey:d.lockMint,isWritable:!1}),S({pubkey:(n=d.lockUserAccount)!=null?n:et}),S({pubkey:d.owner,isWritable:!1,isSigner:!0})];for(let o of d.rewardInfo)t.push(S({pubkey:o.rewardMint,isWritable:!1}),S({pubkey:o.rewardVault}),S({pubkey:o.userRewardToken}));return{instruction:new Vt({programId:d.programId,keys:t,data:e}),instructionType:U.FarmV6Create}}function Eu(d){let e=Buffer.alloc(Is.span);Is.encode({instruction:5},e);let t=[S({pubkey:bn,isWritable:!1}),S({pubkey:d.id}),S({pubkey:d.authority,isWritable:!1}),S({pubkey:d.lpVault,isWritable:!1}),S({pubkey:d.rewardVault}),S({pubkey:d.userRewardToken}),S({pubkey:d.owner,isWritable:!1,isSigner:!0})];return{instruction:new Vt({programId:d.programId,keys:t,data:e}),instructionType:U.FarmV6CreatorWithdraw}}function Ns({payer:d,rewardVault:e,userRewardTokenPub:t,farmKeys:n,rewardInfo:o}){let r=Buffer.alloc(xs.span);xs.encode({instruction:3,rewardReopenTime:ee(o.openTime),rewardEndTime:ee(o.endTime),rewardPerSecond:ee(o.perSecond)},r);let i=[S({pubkey:bn,isWritable:!1}),S({pubkey:n.id}),S({pubkey:n.lpVault,isWritable:!1}),S({pubkey:e}),S({pubkey:t}),S({pubkey:d,isWritable:!1,isSigner:!0})];return new Vt({programId:n.programId,keys:i,data:r})}function Ms({payer:d,userRewardTokenPub:e,farmKeys:t,rewardVault:n,rewardInfo:o}){let r=Buffer.alloc(Ss.span);Ss.encode({instruction:4,isSet:new _u(1),rewardPerSecond:ee(o.perSecond),rewardOpenTime:ee(o.openTime),rewardEndTime:ee(o.endTime),rewardType:ee(vn[o.rewardType])},r);let i=[...Hr,S({pubkey:t.id}),S({pubkey:t.authority,isWritable:!1}),S({pubkey:o.mint,isWritable:!1}),S({pubkey:n}),S({pubkey:e}),S({pubkey:d,isWritable:!1,isSigner:!0})];return new Vt({programId:t.programId,keys:i,data:r})}function ei(d){let{farmInfo:e,farmKeys:t,lpAccount:n,rewardAccounts:o,owner:r,amount:i}=d,[s,u]=[new be(e.programId),new be(e.id)],a=_t({programId:s,poolId:u,owner:r,version:6}),c=Buffer.alloc(Kt.span);Kt.encode({instruction:2,amount:ee(i)},c);let l=[S({pubkey:bn,isWritable:!1}),S({pubkey:u}),S({pubkey:new be(t.authority),isWritable:!1}),S({pubkey:new be(t.lpVault)}),S({pubkey:a}),S({pubkey:r,isWritable:!1,isSigner:!0}),S({pubkey:n})];for(let m=0;m<t.rewardInfos.length;m++)l.push(S({pubkey:new be(t.rewardInfos[m].vault)})),l.push(S({pubkey:o[m]}));return new Vt({programId:s,keys:l,data:c})}function ti(d){let{farmInfo:e,farmKeys:t,lpAccount:n,rewardAccounts:o,owner:r,amount:i,userAuxiliaryLedgers:s}=d,[u,a]=[new be(e.programId),new be(e.id)],c=_t({programId:u,poolId:a,owner:r,version:5}),l=Buffer.alloc(Kt.span);Kt.encode({instruction:12,amount:ee(i)},l);let m=[S({pubkey:a}),S({pubkey:new be(t.authority),isWritable:!1}),S({pubkey:c}),S({pubkey:r,isWritable:!1,isSigner:!0}),S({pubkey:n}),S({pubkey:new be(t.lpVault)}),S({pubkey:o[0]}),S({pubkey:new be(t.rewardInfos[0].vault)}),S({pubkey:Zo,isWritable:!1}),S({pubkey:bn,isWritable:!1})];for(let p=1;p<t.rewardInfos.length;p++)m.push(S({pubkey:o[p]})),m.push(S({pubkey:new be(t.rewardInfos[p].vault)}));if(s)for(let p of s)m.push(S({pubkey:p}));return new Vt({programId:u,keys:m,data:l})}function Wu(d){let{farmInfo:e,farmKeys:t,lpAccount:n,rewardAccounts:o,owner:r,amount:i,userAuxiliaryLedgers:s}=d,[u,a]=[new be(e.programId),new be(e.id)],c=_([V("instruction"),A("amount")]),l=[S({pubkey:a}),S({pubkey:new be(t.authority),isWritable:!1}),S({pubkey:s[0]}),S({pubkey:r,isSigner:!0,isWritable:!1}),S({pubkey:n}),S({pubkey:new be(t.lpVault)}),S({pubkey:o[0]}),S({pubkey:new be(t.rewardInfos[0].vault)}),S({pubkey:Zo,isWritable:!1}),S({pubkey:bn,isWritable:!1}),S({pubkey:o[1]}),S({pubkey:new be(t.rewardInfos[1].vault)})],m=Buffer.alloc(c.span);return c.encode({instruction:2,amount:i},m),new Vt({keys:l,programId:u,data:m})}function ni(d){let{farmInfo:e,farmKeys:t,lpAccount:n,rewardAccounts:o,owner:r,amount:i,userAuxiliaryLedgers:s}=d,[u,a]=[new be(e.programId),new be(e.id)],c=_t({programId:u,poolId:a,owner:r,version:3}),l=Buffer.alloc(Kt.span);Kt.encode({instruction:11,amount:ee(i)},l);let m=[S({pubkey:a}),S({pubkey:new be(t.authority),isWritable:!1}),S({pubkey:c}),S({pubkey:r,isWritable:!1,isSigner:!0}),S({pubkey:n}),S({pubkey:new be(t.lpVault)}),S({pubkey:o[0]}),S({pubkey:new be(t.rewardInfos[0].vault)}),S({pubkey:Zo,isWritable:!1}),S({pubkey:bn,isWritable:!1})];if(s)for(let p of s)m.push(S({pubkey:p}));return new Vt({programId:u,keys:m,data:l})}function Du(d){let{farmInfo:e,farmKeys:t,lpAccount:n,rewardAccounts:o,owner:r,amount:i,userAuxiliaryLedgers:s}=d,[u,a]=[new be(e.programId),new be(e.id)],c=_t({programId:u,poolId:a,owner:r,version:3}),l=Buffer.alloc(Kt.span);Kt.encode({instruction:10,amount:ee(i)},l);let m=[S({pubkey:a}),S({pubkey:new be(t.authority),isWritable:!1}),S({pubkey:c}),S({pubkey:r,isWritable:!1,isSigner:!0}),S({pubkey:n}),S({pubkey:new be(t.lpVault)}),S({pubkey:o[0]}),S({pubkey:new be(t.rewardInfos[0].vault)}),S({pubkey:Zo,isWritable:!1}),S({pubkey:bn,isWritable:!1})];if(s)for(let p of s)m.push(S({pubkey:p}));return new Vt({programId:u,keys:m,data:l})}function qu(d){let{farmInfo:e,farmKeys:t,lpAccount:n,rewardAccounts:o,owner:r,amount:i,userAuxiliaryLedgers:s}=d,[u,a]=[new be(e.programId),new be(e.id)],c=_t({programId:u,poolId:a,owner:r,version:5}),l=Buffer.alloc(Kt.span);Kt.encode({instruction:11,amount:ee(i)},l);let m=[S({pubkey:a}),S({pubkey:new be(t.authority),isWritable:!1}),S({pubkey:c}),S({pubkey:r,isWritable:!1,isSigner:!0}),S({pubkey:n}),S({pubkey:new be(t.lpVault)}),S({pubkey:o[0]}),S({pubkey:new be(t.rewardInfos[0].vault)}),S({pubkey:Zo,isWritable:!1}),S({pubkey:bn,isWritable:!1})];for(let p=1;p<t.rewardInfos.length;p++)m.push(S({pubkey:o[p]})),m.push(S({pubkey:new be(t.rewardInfos[p].vault)}));if(s)for(let p of s)m.push(S({pubkey:p}));return new Vt({programId:u,keys:m,data:l})}function Uu(d){let{farmInfo:e,farmKeys:t,lpAccount:n,rewardAccounts:o,owner:r,amount:i}=d,[s,u]=[new be(e.programId),new be(e.id)],a=_t({programId:s,poolId:u,owner:r,version:6}),c=Buffer.alloc(Kt.span);Kt.encode({instruction:1,amount:ee(i)},c);let l=[S({pubkey:bn,isWritable:!1}),S({pubkey:Fu.programId,isWritable:!1}),S({pubkey:u}),S({pubkey:new be(t.authority),isWritable:!1}),S({pubkey:new be(t.lpVault)}),S({pubkey:a}),S({pubkey:r,isWritable:!1,isSigner:!0}),S({pubkey:n})];for(let m=0;m<t.rewardInfos.length;m++)l.push(S({pubkey:new be(t.rewardInfos[m].vault)})),l.push(S({pubkey:o[m]}));return new Vt({programId:s,keys:l,data:c})}var oi=class extends _e{async _getUserRewardInfo({payer:e,rewardInfo:t}){if(t.mint.equals(et)){let n=await Nn({connection:this.scope.connection,owner:this.scope.ownerPubKey,payer:e,amount:Os(D(v({},t),{openTime:t.openTime.toString(),endTime:t.endTime.toString()}))});return{rewardPubKey:n.addresses.newAccount,newInstruction:n}}return{rewardPubKey:await this.scope.account.getCreatedTokenAccount({mint:t.mint,associatedOnly:!1})}}async create({poolInfo:e,rewardInfos:t,payer:n,programId:o=qo,txVersion:r,feePayer:i,lockProgram:s}){var x,B;this.checkDisabled(),this.scope.checkOwner();let a={lpMint:new xe(e.lpMint.address),lockInfo:{lockMint:(x=s==null?void 0:s.mint)!=null?x:Lu,lockVault:(B=s==null?void 0:s.vault)!=null?B:Ou},version:6,rewardInfos:t,programId:o},c=this.createTxBuilder(i),l=n!=null?n:this.scope.ownerPubKey,m=Ye({fromPublicKey:l,programId:a.programId}),p=await this.scope.connection.getMinimumBalanceForRentExemption(mr.span);c.addInstruction({instructions:[$m.createAccountWithSeed({fromPubkey:l,basePubkey:l,seed:m.seed,newAccountPubkey:m.publicKey,lamports:p,space:mr.span,programId:a.programId})]});let{publicKey:f,nonce:y}=Mu({programId:new xe(a.programId),poolId:m.publicKey}),b=jo({programId:a.programId,poolId:m.publicKey,mint:a.lpMint,type:"lpVault"}),g=[],P=[];for(let K of a.rewardInfos){K.openTime>=K.endTime&&this.logAndCreateError("start time error","rewardInfo.rewardOpenTime",K.openTime.toString()),isNaN(vn[K.rewardType])&&this.logAndCreateError("rewardType error",K.rewardType),Number(K.perSecond)<=0&&this.logAndCreateError("rewardPerSecond error",K.perSecond),g.push(vu(K));let{rewardPubKey:I,newInstruction:R}=await this._getUserRewardInfo({rewardInfo:K,payer:l});R&&c.addInstruction(R),I||this.logAndCreateError("cannot found target token accounts",this.scope.account.tokenAccounts);let C=K.mint.equals(et)?new xe(ct.address):K.mint;P.push({rewardMint:C,rewardVault:jo({programId:a.programId,poolId:m.publicKey,mint:C,type:"rewardVault"}),userRewardToken:I})}let{account:T,instructionParams:h}=await this.scope.account.getOrCreateTokenAccount({mint:new xe(a.lockInfo.lockMint),owner:this.scope.ownerPubKey,skipCloseAccount:!1,createInfo:{payer:this.scope.ownerPubKey,amount:0},associatedOnly:!1});h&&c.addInstruction(h),T||this.logAndCreateError("cannot found lock vault","tokenAccounts",this.scope.account.tokenAccounts);let{instruction:w,instructionType:k}=Vu({farmId:m.publicKey,owner:this.scope.ownerPubKey,farmAuthority:f,lpVault:b,lpMint:a.lpMint,lockVault:a.lockInfo.lockVault,lockMint:a.lockInfo.lockMint,lockUserAccount:T,programId:a.programId,rewardInfo:P,rewardInfoConfig:g,nonce:y});return c.addInstruction({instructions:[w],instructionTypes:[k]}).versionBuild({txVersion:r,extInfo:{farmId:m.publicKey,farmAuthority:f,lpVault:b,lockUserAccount:T,nonce:y}})}async restartReward({farmInfo:e,payer:t,newRewardInfo:n,txVersion:o,feePayer:r}){var g;let i=Ft[e.programId];i!==6&&this.logAndCreateError("invalid farm version ",i);let s=rt((await this.scope.api.fetchFarmKeysById({ids:e.id}))[0]),u={id:s.id,rewardInfos:e.rewardInfos,lpVault:s.lpVault,programId:s.programId};n.openTime>=n.endTime&&this.logAndCreateError("start time error","newRewardInfo",n);let a=t||this.scope.ownerPubKey,c=n.mint.equals(et)?new xe(ct.address):n.mint,l=u.rewardInfos.findIndex(P=>new xe(P.mint.address).equals(c)),m=s.rewardInfos[l];m||this.logAndCreateError("configuration does not exist","rewardMint",c);let p=(g=m.vault)!=null?g:et,f=this.createTxBuilder(r),{rewardPubKey:y,newInstruction:b}=await this._getUserRewardInfo({rewardInfo:n,payer:a});return b&&f.addInstruction(b),y||this.logAndCreateError("cannot found target token accounts",this.scope.account.tokenAccounts),f.addInstruction({instructions:[Ns({payer:this.scope.ownerPubKey,rewardVault:p,userRewardTokenPub:y,farmKeys:u,rewardInfo:n})],instructionTypes:[U.FarmV6Restart]}).versionBuild({txVersion:o})}async restartRewards({farmInfo:e,payer:t,newRewardInfos:n,txVersion:o,feePayer:r}){var l;let i=Ft[e.programId];i!==6&&this.logAndCreateError("invalid farm version ",i);let s=rt((await this.scope.api.fetchFarmKeysById({ids:e.id}))[0]),u={id:s.id,rewardInfos:e.rewardInfos,lpVault:s.lpVault,programId:s.programId};n.forEach(m=>{m.openTime>=m.endTime&&this.logAndCreateError("start time error","newRewardInfo",m)});let a=t||this.scope.ownerPubKey,c=this.createTxBuilder(r);for(let m of n){let p=m.mint.equals(et)?new xe(ct.address):m.mint,f=u.rewardInfos.findIndex(h=>new xe(h.mint.address).equals(p)),y=s.rewardInfos[f];y||this.logAndCreateError("configuration does not exist","rewardMint",p);let b=(l=y.vault)!=null?l:et,{rewardPubKey:g,newInstruction:P}=await this._getUserRewardInfo({rewardInfo:m,payer:a});P&&c.addInstruction(P),g||this.logAndCreateError("cannot found target token accounts",this.scope.account.tokenAccounts);let T=Ns({payer:this.scope.ownerPubKey,rewardVault:b,userRewardTokenPub:g,farmKeys:u,rewardInfo:m});c.addInstruction({instructions:[T],instructionTypes:[U.FarmV6Restart]})}return c.versionBuild({txVersion:o})}async addNewRewardToken(e){let{txVersion:t,farmInfo:n,newRewardInfo:o,payer:r,feePayer:i}=e,s=Ft[n.programId];s!==6&&this.logAndCreateError("invalid farm version ",s);let u=rt((await this.scope.api.fetchFarmKeysById({ids:n.id}))[0]),a=r!=null?r:this.scope.ownerPubKey,c=this.createTxBuilder(i),l=o.mint.equals(et)?new xe(ct.address):o.mint,m=jo({programId:new xe(n.programId),poolId:new xe(n.id),mint:l,type:"rewardVault"}),{rewardPubKey:p,newInstruction:f}=await this._getUserRewardInfo({rewardInfo:o,payer:a});return f&&c.addInstruction(f),p||this.logAndCreateError("annot found target token accounts",this.scope.account.tokenAccounts),o.mint=l,c.addInstruction({instructions:[Ms({payer:this.scope.ownerPubKey,userRewardTokenPub:p,farmKeys:u,rewardVault:m,rewardInfo:o})],instructionTypes:[U.FarmV6CreatorAddReward]}).versionBuild({txVersion:t})}async addNewRewardsToken(e){let{txVersion:t,farmInfo:n,newRewardInfos:o,payer:r,feePayer:i}=e,s=Ft[n.programId];s!==6&&this.logAndCreateError("invalid farm version ",s);let u=rt((await this.scope.api.fetchFarmKeysById({ids:n.id}))[0]),a=r!=null?r:this.scope.ownerPubKey,c=this.createTxBuilder(i);for(let l of o){let m=l.mint.equals(et)?new xe(ct.address):l.mint,p=jo({programId:new xe(n.programId),poolId:new xe(n.id),mint:m,type:"rewardVault"}),{rewardPubKey:f,newInstruction:y}=await this._getUserRewardInfo({rewardInfo:l,payer:a});y&&c.addInstruction(y),f||this.logAndCreateError("cannot found target token accounts",this.scope.account.tokenAccounts);let b=Ms({payer:this.scope.ownerPubKey,userRewardTokenPub:f,farmKeys:u,rewardVault:p,rewardInfo:D(v({},l),{mint:m})});c.addInstruction({instructions:[b],instructionTypes:[U.FarmV6CreatorAddReward]})}return c.versionBuild({txVersion:t})}async deposit(e){let{txVersion:t,farmInfo:n,amount:o,feePayer:r,useSOLBalance:i,associatedOnly:s=!0,checkCreateATAOwner:u=!1,userAuxiliaryLedgers:a,computeBudgetConfig:c,txTipConfig:l}=e;this.scope.availability.addFarm===!1&&this.logAndCreateError("farm deposit feature disabled in your region");let{rewardInfos:m,programId:p}=n,f=Ft[p];f===4&&this.logAndCreateError("V4 has suspended deposits:",n.programId),Rs(f)||this.logAndCreateError("invalid farm program:",n.programId);let[y,b]=[new xe(n.programId),new xe(n.id)],g=(await this.scope.api.fetchFarmKeysById({ids:n.id}))[0],P=_t({programId:y,poolId:b,owner:this.scope.ownerPubKey,version:f}),T=this.createTxBuilder(r);T.addCustomComputeBudget(c),T.addTipInstruction(l);let h={};for(let L of this.scope.account.tokenAccounts)if(s){let O=Z(this.scope.ownerPubKey,L.mint,L.programId).publicKey;L.publicKey&&O.equals(L.publicKey)&&(h[L.mint.toString()]=L.publicKey)}else h[L.mint.toString()]=L.publicKey;let w=g.lpMint,k=h[w.address];k||this.logAndCreateError("you don't have any lp","lp zero",h);let x=[];for(let L of m){let O=i&&L.mint.address===H.toString(),F=h[L.mint.address];if(!F){let{account:G,instructionParams:z}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:L.mint.programId,mint:new xe(L.mint.address),notUseTokenAccount:O,createInfo:{payer:r||this.scope.ownerPubKey,amount:0},owner:this.scope.ownerPubKey,skipCloseAccount:!O,associatedOnly:O?!1:s,checkCreateATAOwner:u});F=G,z&&T.addInstruction(z)}h[L.mint.address]=F,x.push(F)}let B,K=await this.scope.connection.getAccountInfo(P);if(K&&(B=$o(f).decode(K.data)),n.programId!==qo.toString()&&n.programId!==dn.FARM_PROGRAM_ID_V6.toString()&&!B){let{instruction:L,instructionType:O}=Jo({id:b,programId:y,version:f,ledger:P,owner:this.scope.ownerPubKey});T.addInstruction({instructions:[L],instructionTypes:[O]})}let I=Ls({version:f,rewardInfos:m,rewardTokenAccountsPublicKeys:x});I&&this.logAndCreateError(I);let R={amount:ee(o),owner:this.scope.ownerPubKey,farmInfo:n,farmKeys:g,lpAccount:k,rewardAccounts:x,userAuxiliaryLedgers:a==null?void 0:a.map(L=>new xe(L))},C=f===6?Uu(R):f===5?qu(R):Du(R),N={3:U.FarmV3Deposit,5:U.FarmV5Deposit,6:U.FarmV6Deposit};return T.addInstruction({instructions:[C],instructionTypes:[N[f]]}).versionBuild({txVersion:t})}async withdraw(e){let{txVersion:t,farmInfo:n,amount:o,deposited:r,useSOLBalance:i,feePayer:s,associatedOnly:u=!0,checkCreateATAOwner:a=!1,userAuxiliaryLedgers:c,computeBudgetConfig:l,txTipConfig:m}=e,{rewardInfos:p}=n;this.scope.availability.removeFarm===!1&&this.logAndCreateError("farm withdraw feature disabled in your region");let f=Ft[n.programId];Rs(f)||this.logAndCreateError("invalid farm program:",n.programId);let y=(await this.scope.api.fetchFarmKeysById({ids:n.id}))[0],b=this.createTxBuilder(s);b.addCustomComputeBudget(l),b.addTipInstruction(m);let g={};for(let I of this.scope.account.tokenAccounts)if(u){let R=Z(this.scope.ownerPubKey,I.mint).publicKey;I.publicKey&&R.equals(I.publicKey)&&(g[I.mint.toString()]=I.publicKey)}else g[I.mint.toString()]=I.publicKey;if(f!==4){let I=_t({programId:new xe(n.programId),poolId:new xe(n.id),owner:this.scope.ownerPubKey,version:f}),R=await this.scope.connection.getAccountInfo(I);if(R)$o(f).decode(R.data).deposited.isZero()&&this.logAndCreateError("no deposited lp",{farmId:n.id});else if(f!==6){let{instruction:C,instructionType:N}=Jo({id:new xe(y.id),programId:new xe(y.programId),version:f,ledger:I,owner:this.scope.ownerPubKey});b.addInstruction({instructions:[C],instructionTypes:[N]})}}r&&r.isZero()&&!(c||[]).length&&this.logAndCreateError("no deposited lp",{farmId:n.id});let P=y.lpMint.address,T=i&&P===H.toString(),h=g[P.toString()];if(!h){let{account:I,instructionParams:R}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:y.lpMint.programId,mint:new xe(P),notUseTokenAccount:T,createInfo:{payer:s||this.scope.ownerPubKey,amount:0},owner:this.scope.ownerPubKey,skipCloseAccount:!0,associatedOnly:T?!1:u,checkCreateATAOwner:a});h=I,R&&b.addInstruction(R)}g[P.toString()]=h;let w=[];for(let I of p){let R=i&&I.mint.address===H.toString(),C=g[I.mint.address];if(!C){let{account:N,instructionParams:L}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:I.mint.programId,mint:new xe(I.mint.address),notUseTokenAccount:R,createInfo:{payer:s||this.scope.ownerPubKey,amount:0},owner:this.scope.ownerPubKey,skipCloseAccount:!R,associatedOnly:R?!1:u,checkCreateATAOwner:a});C=N,L&&b.addInstruction(L)}g[I.mint.address]=C,w.push(C)}let k=Ls({version:f,rewardInfos:p,rewardTokenAccountsPublicKeys:w});k&&this.logAndCreateError(k);let x={amount:ee(o),owner:this.scope.ownerPubKey,farmInfo:n,farmKeys:y,lpAccount:h,rewardAccounts:w,userAuxiliaryLedgers:c==null?void 0:c.map(I=>new xe(I))},B=f===6?ei(x):f===5?ti(x):f===4?Wu(x):ni(x),K={3:U.FarmV3Withdraw,4:U.FarmV4Withdraw,5:U.FarmV5Withdraw,6:U.FarmV6Withdraw};return b.addInstruction({instructions:[B],instructionTypes:[K[f]]}).versionBuild({txVersion:t})}async withdrawFarmReward({farmInfo:e,withdrawMint:t,txVersion:n,computeBudgetConfig:o,txTipConfig:r,feePayer:i}){var y;this.scope.checkOwner();let s=rt((await this.scope.api.fetchFarmKeysById({ids:e.id}))[0]),u=Ft[e.programId];u!==6&&this.logAndCreateError("invalid farm version",u);let a=s.rewardInfos.find(b=>ut(b.mint.address).equals(ut(t)));a||this.logAndCreateError("withdraw mint error","rewardInfos",e);let c=(y=a==null?void 0:a.vault)!=null?y:et,l=this.createTxBuilder(i),m;if(t.equals(et)||t.equals(xe.default)){let b=await Nn({connection:this.scope.connection,owner:this.scope.ownerPubKey,payer:this.scope.ownerPubKey,amount:Os(D(v({},a),{openTime:a.openTime,endTime:a.endTime,perSecond:new Zm(a.perSecond).mul(10**a.mint.decimals).toString()}))});m=b.addresses.newAccount,l.addInstruction(b)}else{let b=await this.scope.account.getCreatedTokenAccount({mint:t});b===null?(m=await this.scope.account.getAssociatedTokenAccount(t),l.addInstruction({instructions:[Gu(this.scope.ownerPubKey,m,this.scope.ownerPubKey,t)],instructionTypes:[U.CreateATA]})):m=b}let{instruction:p,instructionType:f}=Eu({programId:s.programId,id:s.id,authority:s.authority,lpVault:s.lpVault,rewardVault:c,userRewardToken:m,owner:this.scope.ownerPubKey});return l.addCustomComputeBudget(o),l.addTipInstruction(r),l.addInstruction({instructions:[p],instructionTypes:[f]}).versionBuild({txVersion:n})}async harvestAllRewards(e){let{farmInfoList:t,useSOLBalance:n,feePayer:o,associatedOnly:r=!0,checkCreateATAOwner:i=!1,userAuxiliaryLedgers:s,txVersion:u,computeBudgetConfig:a}=e,c=this.createTxBuilder(o),l={};for(let f of this.scope.account.tokenAccounts)if(r){let y=Z(this.scope.ownerPubKey,f.mint).publicKey;f.publicKey&&y.equals(f.publicKey)&&(l[f.mint.toString()]=f.publicKey)}else l[f.mint.toString()]=f.publicKey;let p=(await this.scope.api.fetchFarmKeysById({ids:Object.values(t).map(f=>f.id).join(",")})).reduce((f,y)=>D(v({},f),{[y.id]:y}),{});for(let f of Object.values(t)){let{programId:y,lpMint:b,rewardInfos:g,id:P}=f,T=Ft[y],h=b.address,w=n&&h===H.toString(),k=l[h];if(!k){let{account:C,instructionParams:N}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:b.programId,mint:new xe(h),notUseTokenAccount:w,createInfo:{payer:o||this.scope.ownerPubKey,amount:0},owner:this.scope.ownerPubKey,skipCloseAccount:!0,associatedOnly:w?!1:r,checkCreateATAOwner:i});k=C,N&&c.addInstruction(N)}l[h.toString()]=k;let x=[];for(let C of g){let N=n&&C.mint.address===H.toString(),L=l[C.mint.address];if(!L)if(N){let{account:O,instructionParams:F}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:C.mint.programId,mint:new xe(C.mint.address),notUseTokenAccount:N,createInfo:{payer:o||this.scope.ownerPubKey,amount:0},owner:this.scope.ownerPubKey,skipCloseAccount:!N,associatedOnly:N?!1:r,checkCreateATAOwner:i});L=O,F&&c.addInstruction(F)}else{let O=new xe(C.mint.address);L=this.scope.account.getAssociatedTokenAccount(O),c.addInstruction({instructions:[Gu(this.scope.ownerPubKey,L,this.scope.ownerPubKey,O)]})}l[C.mint.address]=L,x.push(L)}let B=p[P],K={amount:kt,owner:this.scope.ownerPubKey,farmInfo:f,farmKeys:B,lpAccount:k,rewardAccounts:x,userAuxiliaryLedgers:s==null?void 0:s.map(C=>new xe(C))},I=T===6?ei(K):T===5?ti(K):ni(K),R={3:U.FarmV3Withdraw,5:U.FarmV5Withdraw,6:U.FarmV6Withdraw};c.addInstruction({instructions:[I],instructionTypes:[R[T]]})}return u===1?c.sizeCheckBuild({computeBudgetConfig:a}):c.sizeCheckBuildV0({computeBudgetConfig:a})}};import{PublicKey as je}from"@solana/web3.js";import{AccountLayout as Ed,NATIVE_MINT as Br,TOKEN_PROGRAM_ID as _n}from"@solana/spl-token";import{Keypair as gr,PublicKey as X,SystemProgram as kn,TransactionInstruction as st}from"@solana/web3.js";import zs from"bn.js";import{ASSOCIATED_TOKEN_PROGRAM_ID as mi,TOKEN_2022_PROGRAM_ID as Xe,TOKEN_PROGRAM_ID as Ce}from"@solana/spl-token";import ud from"bn.js";import Bo from"decimal.js";import Et from"bn.js";var Ue=new Et(0),Ct=new Et(1),gn=new Et(-1),Ze=new Et(1).shln(64),dr=new Et(1).shln(128),ii=Ze.sub(Ct),ri=64,Xu=dr.subn(1),mt=-443636,yt=-mt,Wt=new Et("4295048016"),Dt=new Et("79226673521066979257578248091"),pr=new Et("4295048017"),fr=new Et("79226673521066979257578248090"),zu=16,Yu="59543866431248",Qu="184467440737095516",Hu="15793534762490258745",yr=new Et(10).pow(new Et(6));var ju={tvl:0,volumeQuote:0,mintAmountA:0,mintAmountB:0,rewardDefaultInfos:[],farmUpcomingCount:0,farmOngoingCount:0,farmFinishedCount:0,day:{volume:0,volumeQuote:0,volumeFee:0,apr:0,feeApr:0,priceMin:0,priceMax:0,rewardApr:[0]},week:{volume:0,volumeQuote:0,volumeFee:0,apr:0,feeApr:0,priceMin:0,priceMax:0,rewardApr:[0]},month:{volume:0,volumeQuote:0,volumeFee:0,apr:0,feeApr:0,priceMin:0,priceMax:0,rewardApr:[0]},pooltype:[]},Qk=new Et("18446744073700000000");import pe from"bn.js";import un from"decimal.js";function br(d){let e=new ArrayBuffer(4);return new DataView(e).setInt32(0,d,!1),new Uint8Array(e)}function vs(d,e){let t=0;for(let n=d-1;n>=0&&!e.testn(n);n--)t++;return t}function Fs(d,e){let t=0;for(let n=0;n<d&&!e.testn(n);n++)t++;return t}function si(d,e){for(let t=0;t<d;t++)if(e.testn(t))return!1;return!0}function $u(d,e){return si(d,e)?null:vs(d,e)}function Zu(d,e){return si(d,e)?null:Fs(d,e)}var Jk=Buffer.from("amm_config","utf8"),_s=Buffer.from("pool","utf8"),Vs=Buffer.from("pool_vault","utf8"),ed=Buffer.from("pool_reward_vault","utf8"),Ju=Buffer.from("position","utf8"),td=Buffer.from("tick_array","utf8"),nd=Buffer.from("operation","utf8"),od=Buffer.from("pool_tick_array_bitmap_extension","utf8"),id=Buffer.from("observation","utf8");function ec(d,e,t,n){return ce([_s,e.toBuffer(),t.toBuffer(),n.toBuffer()],d)}function Es(d,e,t){return ce([Vs,e.toBuffer(),t.toBuffer()],d)}function tc(d,e,t){return ce([ed,e.toBuffer(),t.toBuffer()],d)}function Pe(d,e,t){return ce([td,e.toBuffer(),br(t)],d)}function en(d,e,t,n){return ce([Ju,e.toBuffer(),br(t),br(n)],d)}function bt(d,e){return ce([Ju,e.toBuffer()],d)}function Pn(d){return ce([Buffer.from("metadata","utf8"),$t.toBuffer(),d.toBuffer()],$t)}function ai(d){return ce([nd],d)}function Qe(d,e){return ce([od,e.toBuffer()],d)}function nc(d,e){return ce([id,e.toBuffer()],d)}var oc=Buffer.from("locked_position","utf8");function Ws(d,e){return ce([oc,e.toBuffer()],d)}function ho(d,e){return ce([oc,e.toBuffer()],d)}var rd=Buffer.from("support_mint","utf8");function Ds(d,e){return ce([rd,e.toBuffer()],d)}import{PublicKey as Rt}from"@solana/web3.js";import{TOKEN_2022_PROGRAM_ID as ic}from"@solana/spl-token";import Ee from"bn.js";import ke from"decimal.js";import an from"bn.js";import qs from"decimal.js";var ui=class{static getfeeGrowthInside(e,t,n){let o=new an(0),r=new an(0);e.tickCurrent>=t.tick?(o=t.feeGrowthOutsideX64A,r=t.feeGrowthOutsideX64B):(o=e.feeGrowthGlobalX64A.sub(t.feeGrowthOutsideX64A),r=e.feeGrowthGlobalX64B.sub(t.feeGrowthOutsideX64B));let i=new an(0),s=new an(0);e.tickCurrent<n.tick?(i=n.feeGrowthOutsideX64A,s=n.feeGrowthOutsideX64B):(i=e.feeGrowthGlobalX64A.sub(n.feeGrowthOutsideX64A),s=e.feeGrowthGlobalX64B.sub(n.feeGrowthOutsideX64B));let u=le.wrappingSubU128(le.wrappingSubU128(e.feeGrowthGlobalX64A,o),i),a=le.wrappingSubU128(le.wrappingSubU128(e.feeGrowthGlobalX64B,r),s);return{feeGrowthInsideX64A:u,feeGrowthInsideBX64:a}}static GetPositionFees(e,t,n,o){let{feeGrowthInsideX64A:r,feeGrowthInsideBX64:i}=this.getfeeGrowthInside(e,n,o),s=le.mulDivFloor(le.wrappingSubU128(r,t.feeGrowthInsideLastX64A),t.liquidity,Ze),u=t.tokenFeesOwedA.add(s),a=le.mulDivFloor(le.wrappingSubU128(i,t.feeGrowthInsideLastX64B),t.liquidity,Ze),c=t.tokenFeesOwedB.add(a);return{tokenFeeAmountA:u,tokenFeeAmountB:c}}static GetPositionFeesV2(e,t,n,o){let{feeGrowthInsideX64A:r,feeGrowthInsideBX64:i}=this.getfeeGrowthInside(e,n,o),s=le.mulDivFloor(le.wrappingSubU128(r,t.feeGrowthInsideLastX64A),t.liquidity,Ze),u=t.tokenFeesOwedA.add(s),a=le.mulDivFloor(le.wrappingSubU128(i,t.feeGrowthInsideLastX64B),t.liquidity,Ze),c=t.tokenFeesOwedB.add(a);return{tokenFeeAmountA:u,tokenFeeAmountB:c}}static GetPositionRewardsV2(e,t,n,o){let r=[],i=this.getRewardGrowthInsideV2(e.tickCurrent,n,o,e.rewardInfos);for(let s=0;s<i.length;s++){let u=i[s],a=t.rewardInfos[s],c=le.wrappingSubU128(u,a.growthInsideLastX64),l=le.mulDivFloor(c,t.liquidity,Ze),m=a.rewardAmountOwed.add(l);r.push(m)}return r}static GetPositionRewards(e,t,n,o){let r=[],i=this.getRewardGrowthInside(e.tickCurrent,n,o,e.rewardInfos);for(let s=0;s<i.length;s++){let u=i[s],a=t.rewardInfos[s],c=le.wrappingSubU128(u,a.growthInsideLastX64),l=le.mulDivFloor(c,t.liquidity,Ze),m=a.rewardAmountOwed.add(l);r.push(m)}return r}static getRewardGrowthInside(e,t,n,o){let r=[];for(let i=0;i<o.length;i++){let s=new an(0);t.liquidityGross.eqn(0)?s=o[i].rewardGrowthGlobalX64:e<t.tick?s=o[i].rewardGrowthGlobalX64.sub(t.rewardGrowthsOutsideX64[i]):s=t.rewardGrowthsOutsideX64[i];let u=new an(0);n.liquidityGross.eqn(0)||(e<n.tick?u=n.rewardGrowthsOutsideX64[i]:u=o[i].rewardGrowthGlobalX64.sub(n.rewardGrowthsOutsideX64[i])),r.push(le.wrappingSubU128(le.wrappingSubU128(o[i].rewardGrowthGlobalX64,s),u))}return r}static getRewardGrowthInsideV2(e,t,n,o){let r=[];for(let i=0;i<o.length;i++){let s=new an(0);t.liquidityGross.eqn(0)?s=o[i].rewardGrowthGlobalX64:e<t.tick?s=o[i].rewardGrowthGlobalX64.sub(t.rewardGrowthsOutsideX64[i]):s=t.rewardGrowthsOutsideX64[i];let u=new an(0);n.liquidityGross.eqn(0)||(e<n.tick?u=n.rewardGrowthsOutsideX64[i]:u=o[i].rewardGrowthGlobalX64.sub(n.rewardGrowthsOutsideX64[i])),r.push(le.wrappingSubU128(le.wrappingSubU128(o[i].rewardGrowthGlobalX64,s),u))}return r}static getAmountsFromLiquidity({poolInfo:e,ownerPosition:t,liquidity:n,slippage:o,add:r,epochInfo:i}){var b,g,P,T;let s=ue.priceToSqrtPriceX64(new qs(e.price),e.mintA.decimals,e.mintB.decimals),u=ue.getSqrtPriceX64FromTick(t.tickLower),a=ue.getSqrtPriceX64FromTick(t.tickUpper),c=r?1+o:1-o,l=we.getAmountsFromLiquidity(s,u,a,n,r),[m,p]=[Ke(l.amountA,(b=e.mintA.extensions)==null?void 0:b.feeConfig,i,!0),Ke(l.amountB,(g=e.mintB.extensions)==null?void 0:g.feeConfig,i,!0)],[f,y]=[Ke(new an(new qs(l.amountA.toString()).mul(c).toFixed(0)),(P=e.mintA.extensions)==null?void 0:P.feeConfig,i,!0),Ke(new an(new qs(l.amountB.toString()).mul(c).toFixed(0)),(T=e.mintB.extensions)==null?void 0:T.feeConfig,i,!0)];return{liquidity:n,amountA:m,amountB:p,amountSlippageA:f,amountSlippageB:y,expirationTime:Zt(m.expirationTime,p.expirationTime)}}};var sd=15,Ae=class{static async getTickArrays(e,t,n,o,r,i,s){let u=[],a=j.getTickArrayStartIndexByTick(o,r),c=j.getInitializedTickArrayInRange(i,s,r,a,Math.floor(sd/2));for(let p=0;p<c.length;p++){let{publicKey:f}=Pe(t,n,c[p]);u.push(f)}let l=(await jt(e,u)).map(p=>p!==null?ci.decode(p.data):null),m={};for(let p=0;p<u.length;p++){let f=l[p];f!==null&&(m[f.startTickIndex]=D(v({},f),{address:u[p]}))}return m}static nextInitializedTick(e,t,n,o,r,i){let{initializedTick:s,tickArrayAddress:u,tickArrayStartTickIndex:a}=this.nextInitializedTickInOneArray(e,t,n,o,r,i);for(;s==null||s.liquidityGross.lten(0);){if(a=j.getNextTickArrayStartIndex(a,r,i),this.checkIsValidStartIndex(a,r))throw new Error("No enough initialized tickArray");let c=n[a];if(c===void 0)continue;let{nextTick:l,tickArrayAddress:m,tickArrayStartTickIndex:p}=this.firstInitializedTickInOneArray(e,t,c,i);[s,u,a]=[l,m,p]}if(s==null)throw new Error("No invaild tickArray cache");return{nextTick:s,tickArrayAddress:u,tickArrayStartTickIndex:a}}static nextInitializedTickArray(e,t,n,o,r){let i=Math.floor(e/Ae.tickCount(t)),s=n?j.searchLowBitFromStart(o,r,i-1,1,t):j.searchHightBitFromStart(o,r,i+1,1,t);return s.length>0?{isExist:!0,nextStartIndex:s[0]}:{isExist:!1,nextStartIndex:0}}static firstInitializedTickInOneArray(e,t,n,o){let r;if(o){let s=Je-1;for(;s>=0;){let u=n.ticks[s];if(u.liquidityGross.gtn(0)){r=u;break}s=s-1}}else{let s=0;for(;s<Je;){let u=n.ticks[s];if(u.liquidityGross.gtn(0)){r=u;break}s=s+1}}let{publicKey:i}=Pe(e,t,n.startTickIndex);return{nextTick:r,tickArrayAddress:i,tickArrayStartTickIndex:n.startTickIndex}}static nextInitializedTickInOneArray(e,t,n,o,r,i){let s=j.getTickArrayStartIndexByTick(o,r),u=Math.floor((o-s)/r),a=n[s];if(a==null)return{initializedTick:void 0,tickArrayAddress:void 0,tickArrayStartTickIndex:s};let c;if(i)for(;u>=0;){let m=a.ticks[u];if(m.liquidityGross.gtn(0)){c=m;break}u=u-1}else for(u=u+1;u<Je;){let m=a.ticks[u];if(m.liquidityGross.gtn(0)){c=m;break}u=u+1}let{publicKey:l}=Pe(e,t,s);return{initializedTick:c,tickArrayAddress:l,tickArrayStartTickIndex:a.startTickIndex}}static getArrayStartIndex(e,t){let n=this.tickCount(t);return Math.floor(e/n)*n}static checkIsValidStartIndex(e,t){if(j.checkIsOutOfBoundary(e)){if(e>yt)return!1;let n=j.getTickArrayStartIndexByTick(mt,t);return e==n}return e%this.tickCount(t)==0}static tickCount(e){return Je*e}};var Us=14,An=class{static maxTickInTickarrayBitmap(e){return e*Je*jn}static getBitmapTickBoundary(e,t){let n=this.maxTickInTickarrayBitmap(t),o=Math.floor(Math.abs(e)/n);e<0&&Math.abs(e)%n!=0&&(o+=1);let r=n*o;return e<0?{minValue:-r,maxValue:-r+n}:{minValue:r,maxValue:r+n}}static nextInitializedTickArrayStartIndex(e,t,n,o){if(!Ae.checkIsValidStartIndex(t,n))throw Error("nextInitializedTickArrayStartIndex check error");let r=this.maxTickInTickarrayBitmap(n),i=o?t-Ae.tickCount(n):t+Ae.tickCount(n);if(i<-r||i>=r)return{isInit:!1,tickIndex:t};let s=n*Je,u=i/s+512;i<0&&i%s!=0&&u--;let a=Math.abs(u);if(o){let c=e.shln(1024-a-1),l=$u(1024,c);if(l!==null){let m=(a-l-512)*s;return{isInit:!0,tickIndex:m}}else return{isInit:!1,tickIndex:-r}}else{let c=e.shrn(a),l=Zu(1024,c);if(l!==null){let m=(a+l-512)*s;return{isInit:!0,tickIndex:m}}else return{isInit:!1,tickIndex:r-Ae.tickCount(n)}}}},li=class{static getBitmapOffset(e,t){if(!Ae.checkIsValidStartIndex(e,t))throw new Error("No enough initialized tickArray");this.checkExtensionBoundary(e,t);let n=An.maxTickInTickarrayBitmap(t),o=Math.floor(Math.abs(e)/n)-1;return e<0&&Math.abs(e)%n===0&&o--,o}static getBitmap(e,t,n){let o=this.getBitmapOffset(e,t);return e<0?{offset:o,tickarrayBitmap:n.negativeTickArrayBitmap[o]}:{offset:o,tickarrayBitmap:n.positiveTickArrayBitmap[o]}}static checkExtensionBoundary(e,t){let{positiveTickBoundary:n,negativeTickBoundary:o}=this.extensionTickBoundary(t);if(e>=o&&e<n)throw Error("checkExtensionBoundary -> InvalidTickArrayBoundary")}static extensionTickBoundary(e){let t=An.maxTickInTickarrayBitmap(e),n=-t;if(yt<=t)throw Error(`extensionTickBoundary check error: ${yt}, ${t}`);if(n<=mt)throw Error(`extensionTickBoundary check error: ${n}, ${mt}`);return{positiveTickBoundary:t,negativeTickBoundary:n}}static checkTickArrayIsInit(e,t,n){let{tickarrayBitmap:o}=this.getBitmap(e,t,n),r=this.tickArrayOffsetInBitmap(e,t);return{isInitialized:j.mergeTickArrayBitmap(o).testn(r),startIndex:e}}static nextInitializedTickArrayFromOneBitmap(e,t,n,o){let r=Ae.tickCount(t),i=n?e-r:e+r,{tickarrayBitmap:s}=this.getBitmap(i,t,o);return this.nextInitializedTickArrayInBitmap(s,i,t,n)}static nextInitializedTickArrayInBitmap(e,t,n,o){let{minValue:r,maxValue:i}=An.getBitmapTickBoundary(t,n),s=this.tickArrayOffsetInBitmap(t,n);if(o){let u=j.mergeTickArrayBitmap(e).shln(jn-1-s),a=si(512,u)?null:vs(512,u);if(a!==null){let c=t-a*Ae.tickCount(n);return{isInit:!0,tickIndex:c}}else return{isInit:!1,tickIndex:r}}else{let u=j.mergeTickArrayBitmap(e).shrn(s),a=si(512,u)?null:Fs(512,u);if(a!==null){let c=t+a*Ae.tickCount(n);return{isInit:!0,tickIndex:c}}else return{isInit:!1,tickIndex:i-Ae.tickCount(n)}}}static tickArrayOffsetInBitmap(e,t){let n=Math.abs(e)%An.maxTickInTickarrayBitmap(t),o=Math.floor(n/Ae.tickCount(t));return e<0&&n!=0&&(o=jn-o),o}};var Me=class{static getOutputAmountAndRemainAccounts(e,t,n,o,r,i=!1){let s=n.toBase58()===e.mintA.address,u=[],{isExist:a,startIndex:c,nextAccountMeta:l}=this.getFirstInitializedTickArray(e,s);if(!a||c===void 0||!l)throw new Error("Invalid tick array");u.push(l);let{allTrade:m,amountCalculated:p,accounts:f,sqrtPriceX64:y,feeAmount:b}=$n.swapCompute(e.programId,e.id,t,e.tickArrayBitmap,e.exBitmapInfo,s,e.ammConfig.tradeFeeRate,e.liquidity,e.tickCurrent,e.tickSpacing,e.sqrtPriceX64,o,c,r,i);return u.push(...f),{allTrade:m,expectedAmountOut:p.mul(gn),remainingAccounts:u,executionPrice:y,feeAmount:b}}static getInputAmountAndRemainAccounts(e,t,n,o,r){let i=n.toBase58()===e.mintB.address,s=[],{isExist:u,startIndex:a,nextAccountMeta:c}=this.getFirstInitializedTickArray(e,i);if(!u||a===void 0||!c)throw new Error("Invalid tick array");try{let y=this.preInitializedTickArrayStartIndex(e,i);if(y.isExist){let{publicKey:b}=Pe(e.programId,e.id,y.nextStartIndex);s.push(b)}}catch{}s.push(c);let{amountCalculated:l,accounts:m,sqrtPriceX64:p,feeAmount:f}=$n.swapCompute(e.programId,e.id,t,e.tickArrayBitmap,e.exBitmapInfo,i,e.ammConfig.tradeFeeRate,e.liquidity,e.tickCurrent,e.tickSpacing,e.sqrtPriceX64,o.mul(gn),a,r);return s.push(...m),{expectedAmountIn:l,remainingAccounts:s,executionPrice:p,feeAmount:f}}static getFirstInitializedTickArray(e,t){let{isInitialized:n,startIndex:o}=Me.isOverflowDefaultTickarrayBitmap(e.tickSpacing,[e.tickCurrent])?li.checkTickArrayIsInit(Ae.getArrayStartIndex(e.tickCurrent,e.tickSpacing),e.tickSpacing,e.exBitmapInfo):j.checkTickArrayIsInitialized(j.mergeTickArrayBitmap(e.tickArrayBitmap),e.tickCurrent,e.tickSpacing);if(n){let{publicKey:s}=Pe(e.programId,e.id,o);return{isExist:!0,startIndex:o,nextAccountMeta:s}}let{isExist:r,nextStartIndex:i}=this.nextInitializedTickArrayStartIndex(e,Ae.getArrayStartIndex(e.tickCurrent,e.tickSpacing),t);if(r){let{publicKey:s}=Pe(e.programId,e.id,i);return{isExist:!0,startIndex:i,nextAccountMeta:s}}return{isExist:!1,nextAccountMeta:void 0,startIndex:void 0}}static preInitializedTickArrayStartIndex(e,t){let n=Math.floor(e.tickCurrent/Ae.tickCount(e.tickSpacing)),o=t?j.searchHightBitFromStart(e.tickArrayBitmap,e.exBitmapInfo,n+1,1,e.tickSpacing):j.searchLowBitFromStart(e.tickArrayBitmap,e.exBitmapInfo,n-1,1,e.tickSpacing);return o.length>0?{isExist:!0,nextStartIndex:o[0]}:{isExist:!1,nextStartIndex:0}}static nextInitializedTickArrayStartIndex(e,t,n){for(t=Ae.getArrayStartIndex(e.tickCurrent,e.tickSpacing);;){let{isInit:o,tickIndex:r}=An.nextInitializedTickArrayStartIndex(j.mergeTickArrayBitmap(e.tickArrayBitmap),t,e.tickSpacing,n);if(o)return{isExist:!0,nextStartIndex:r};t=r;let{isInit:i,tickIndex:s}=li.nextInitializedTickArrayFromOneBitmap(t,e.tickSpacing,n,e.exBitmapInfo);if(i)return{isExist:!0,nextStartIndex:s};if(t=s,t<mt||t>yt)return{isExist:!1,nextStartIndex:0}}}static async updatePoolRewardInfos({connection:e,apiPoolInfo:t,chainTime:n,poolLiquidity:o,rewardInfos:r}){var s,u,a;let i=[];for(let c=0;c<r.length;c++){let l=r[c],m=(a=(s=t.rewardDefaultInfos[c])==null?void 0:s.mint.programId)!=null?a:(u=await e.getAccountInfo(l.tokenMint))==null?void 0:u.owner;if(m===void 0)throw Error("get new reward mint info error");let p=D(v({},l),{perSecond:le.x64ToDecimal(l.emissionsPerSecondX64),remainingRewards:void 0,tokenProgramId:new Rt(m)});if(p.tokenMint.equals(Rt.default))continue;if(n<=p.openTime.toNumber()||o.eq(Ue)){i.push(p);continue}let f=new Ee(Math.min(p.endTime.toNumber(),n)),y=f.sub(p.lastUpdateTime),b=le.mulDivFloor(y,p.emissionsPerSecondX64,o),g=p.rewardGrowthGlobalX64.add(b),P=le.mulDivFloor(y,p.emissionsPerSecondX64,Ze),T=p.rewardTotalEmissioned.add(P);i.push(D(v({},p),{rewardGrowthGlobalX64:g,rewardTotalEmissioned:T,lastUpdateTime:f}))}return i}static isOverflowDefaultTickarrayBitmap(e,t){let{maxTickBoundary:n,minTickBoundary:o}=this.tickRange(e);for(let r of t){let i=j.getTickArrayStartIndexByTick(r,e);if(i>=n||i<o)return!0}return!1}static tickRange(e){let t=An.maxTickInTickarrayBitmap(e),n=-t;return t>yt&&(t=Ae.getArrayStartIndex(yt,e)+Ae.tickCount(e)),n<mt&&(n=Ae.getArrayStartIndex(mt,e)),{maxTickBoundary:t,minTickBoundary:n}}static get_tick_array_offset(e,t){if(!Ae.checkIsValidStartIndex(e,t))throw new Error("No enough initialized tickArray");return e/Ae.tickCount(t)*jn}static async fetchExBitmaps({connection:e,exBitmapAddress:t,batchRequest:n}){let o=await Ne(e,t.map(i=>({pubkey:i})),{batchRequest:n}),r={};for(let i of o)i.accountInfo!==null&&(r[i.pubkey.toString()]=sc.decode(i.accountInfo.data));return r}static async fetchMultiplePoolTickArrays({connection:e,poolKeys:t,batchRequest:n}){let o={},r=[];for(let u of t){let a=j.getTickArrayStartIndexByTick(u.tickCurrent,u.tickSpacing),c=j.getInitializedTickArrayInRange(u.tickArrayBitmap,u.exBitmapInfo,u.tickSpacing,a,7);for(let l of c){let{publicKey:m}=Pe(u.programId,u.id,l);r.push({pubkey:m}),o[m.toString()]=u.id}}let i=await Ne(e,r,{batchRequest:n}),s={};for(let u of i){if(!u.accountInfo)continue;let a=o[u.pubkey.toString()];if(!a)continue;s[a.toString()]===void 0&&(s[a.toString()]={});let c=ci.decode(u.accountInfo.data);s[a.toString()][c.startTickIndex]=D(v({},c),{address:u.pubkey})}return s}static async fetchPoolsAccountPosition({pools:e,connection:t,ownerInfo:n,batchRequest:o=!1,updateOwnerRewardAndFee:r=!0}){var s;let i=[];for(let u=0;u<e.length;u++){let a=e[u];a!==null&&(i.find(c=>c.equals(a.state.programId))||i.push(a.state.programId))}if(n){let u=n.tokenAccounts.map(m=>m.accountInfo.mint),a=[];for(let m of u)for(let p of i)a.push(bt(p,m).publicKey);let c=await jt(t,a,{batchRequest:o}),l={};for(let m of c){if(m===null)continue;let p=Io.decode(m.data),f=p.poolId.toString(),y=e.find(B=>B.state.id.toBase58()===f);if(y===void 0)continue;let b=y.state,g=j._getTickPriceLegacy({poolInfo:b,tick:p.tickLower,baseIn:!0}),P=j._getTickPriceLegacy({poolInfo:b,tick:p.tickUpper,baseIn:!0}),{amountA:T,amountB:h}=we.getAmountsFromLiquidity(b.sqrtPriceX64,g.tickSqrtPriceX64,P.tickSqrtPriceX64,p.liquidity,!1),w=1/(1-Math.sqrt(Math.sqrt(g.price.div(P.price).toNumber())));y.positionAccount=[...(s=y.positionAccount)!=null?s:[],{poolId:p.poolId,nftMint:p.nftMint,priceLower:g.price,priceUpper:P.price,amountA:T,amountB:h,tickLower:p.tickLower,tickUpper:p.tickUpper,liquidity:p.liquidity,feeGrowthInsideLastX64A:p.feeGrowthInsideLastX64A,feeGrowthInsideLastX64B:p.feeGrowthInsideLastX64B,tokenFeesOwedA:p.tokenFeesOwedA,tokenFeesOwedB:p.tokenFeesOwedB,rewardInfos:p.rewardInfos.map(B=>D(v({},B),{pendingReward:new Ee(0)})),leverage:w,tokenFeeAmountA:new Ee(0),tokenFeeAmountB:new Ee(0)}];let k=await j.getTickArrayAddressByTick(y.state.programId,p.poolId,p.tickLower,y.state.tickSpacing),x=await j.getTickArrayAddressByTick(y.state.programId,p.poolId,p.tickUpper,y.state.tickSpacing);l[`${y.state.programId.toString()}-${p.poolId.toString()}-${p.tickLower}`]=k,l[`${y.state.programId.toString()}-${p.poolId.toString()}-${p.tickUpper}`]=x}if(r){let m=Object.values(l),p=await jt(t,m,{batchRequest:o}),f={};for(let y=0;y<m.length;y++){let b=p[y];if(b===null)continue;let g=m[y].toString();f[g]=ci.decode(b.data)}for(let{state:y,positionAccount:b}of e)if(!!b)for(let g of b){let P=`${y.programId.toString()}-${y.id.toString()}-${g.tickLower}`,T=`${y.programId.toString()}-${y.id.toString()}-${g.tickUpper}`,h=f[l[P].toString()],w=f[l[T].toString()],k=h.ticks[j.getTickOffsetInArray(g.tickLower,y.tickSpacing)],x=w.ticks[j.getTickOffsetInArray(g.tickUpper,y.tickSpacing)],{tokenFeeAmountA:B,tokenFeeAmountB:K}=await ui.GetPositionFees(y,g,k,x),I=await ui.GetPositionRewards(y,g,k,x);g.tokenFeeAmountA=B.gte(new Ee(0))?B:new Ee(0),g.tokenFeeAmountB=K.gte(new Ee(0))?K:new Ee(0);for(let R=0;R<I.length;R++)g.rewardInfos[R].pendingReward=I[R].gte(new Ee(0))?I[R]:new Ee(0)}}}return e}static computeAmountOut({poolInfo:e,tickArrayCache:t,baseMint:n,epochInfo:o,amountIn:r,slippage:i,priceLimit:s=new ke(0),catchLiquidityInsufficient:u=!1}){var C;let a,c=n.toBase58()===e.mintA.address,[l,m]=c?[e.mintA.extensions.feeConfig,e.mintB.extensions.feeConfig]:[e.mintB.extensions.feeConfig,e.mintA.extensions.feeConfig];s.equals(new ke(0))?a=c?Wt.add(new Ee(1)):Dt.sub(new Ee(1)):a=ue.priceToSqrtPriceX64(s,e.mintA.decimals,e.mintB.decimals);let p=Ke(r,l,o,!1),{allTrade:f,expectedAmountOut:y,remainingAccounts:b,executionPrice:g,feeAmount:P}=Me.getOutputAmountAndRemainAccounts(e,t,n,p.amount.sub((C=p.fee)!=null?C:Ue),a,u),T=Ke(y,m,o,!1),h=ue.sqrtPriceX64ToPrice(g,e.mintA.decimals,e.mintB.decimals),w=c?h:new ke(1).div(h),k=y.mul(new Ee(Math.floor((1-i)*1e10))).div(new Ee(1e10)),x=Ke(k,m,o,!1),B=c?e.currentPrice:new ke(1).div(e.currentPrice),K=new ke(w).sub(B).abs(),I=B,R=new tt(new ke(K).mul(10**15).toFixed(0),new ke(I).mul(10**15).toFixed(0));return{allTrade:f,realAmountIn:p,amountOut:T,minAmountOut:x,expirationTime:Zt(p.expirationTime,T.expirationTime),currentPrice:e.currentPrice,executionPrice:w,priceImpact:R,fee:P,remainingAccounts:b,executionPriceX64:g}}static computeAmountOutFormat({poolInfo:e,tickArrayCache:t,amountIn:n,tokenOut:o,slippage:r,epochInfo:i,catchLiquidityInsufficient:s=!1}){let u=o.address===e.mintB.address,[a,c]=u?[e.mintA,e.mintB]:[e.mintB,e.mintA],[l,m]=[new De(D(v({},a),{mint:a.address,isToken2022:a.programId===ic.toBase58()})),new De(D(v({},c),{mint:c.address,isToken2022:c.programId===ic.toBase58()}))],{allTrade:p,realAmountIn:f,amountOut:y,minAmountOut:b,expirationTime:g,currentPrice:P,executionPrice:T,priceImpact:h,fee:w,remainingAccounts:k,executionPriceX64:x}=Me.computeAmountOut({poolInfo:e,tickArrayCache:t,baseMint:new Rt(a.address),amountIn:n,slippage:r,epochInfo:i,catchLiquidityInsufficient:s}),B=D(v({},f),{amount:new Se(l,f.amount),fee:f.fee===void 0?void 0:new Se(l,f.fee)}),K=D(v({},y),{amount:new Se(m,y.amount),fee:y.fee===void 0?void 0:new Se(m,y.fee)}),I=D(v({},b),{amount:new Se(m,b.amount),fee:b.fee===void 0?void 0:new Se(m,b.fee)}),R=new At({baseToken:l,denominator:new Ee(10).pow(new Ee(20+l.decimals)),quoteToken:m,numerator:P.mul(new ke(10**(20+m.decimals))).toFixed(0)}),C=new At({baseToken:l,denominator:new Ee(10).pow(new Ee(20+l.decimals)),quoteToken:m,numerator:T.mul(new ke(10**(20+m.decimals))).toFixed(0)}),N=new Se(l,w);return{allTrade:p,realAmountIn:B,amountOut:K,minAmountOut:I,expirationTime:g,currentPrice:R,executionPrice:C,priceImpact:h,fee:N,remainingAccounts:k,executionPriceX64:x}}static computeAmountIn({poolInfo:e,tickArrayCache:t,baseMint:n,epochInfo:o,amountOut:r,slippage:i,priceLimit:s=new ke(0)}){var I;let u=n.toBase58()===e.mintA.address,a={[e.mintA.address]:e.mintA.extensions.feeConfig,[e.mintB.address]:e.mintB.extensions.feeConfig},c;s.equals(new ke(0))?c=u?Dt.sub(new Ee(1)):Wt.add(new Ee(1)):c=ue.priceToSqrtPriceX64(s,e.mintA.decimals,e.mintB.decimals);let l=Ke(r,a[n.toString()],o,!0),{expectedAmountIn:m,remainingAccounts:p,executionPrice:f,feeAmount:y}=Me.getInputAmountAndRemainAccounts(e,t,n,l.amount.sub((I=l.fee)!=null?I:Ue),c),b=u?e.mintB.address:e.mintA.address,g=Ke(m,a[b],o,!1),P=ue.sqrtPriceX64ToPrice(f,e.mintA.decimals,e.mintB.decimals),T=u?P:new ke(1).div(P),h=m.mul(new Ee(Math.floor((1+i)*1e10))).div(new Ee(1e10)),w=Ke(h,a[b],o,!0),k=u?e.currentPrice:new ke(1).div(e.currentPrice),x=new ke(T).sub(k).abs(),B=k,K=new tt(new ke(x).mul(10**15).toFixed(0),new ke(B).mul(10**15).toFixed(0));return{amountIn:g,maxAmountIn:w,realAmountOut:l,expirationTime:Zt(g.expirationTime,l.expirationTime),currentPrice:e.currentPrice,executionPrice:T,priceImpact:K,fee:y,remainingAccounts:p}}static estimateAprsForPriceRangeMultiplier({poolInfo:e,aprType:t,positionTickLowerIndex:n,positionTickUpperIndex:o}){var f,y,b;let r=e[t],i=j.getTickPrice({poolInfo:e,tick:n,baseIn:!0}).price.toNumber(),s=j.getTickPrice({poolInfo:e,tick:o,baseIn:!0}).price.toNumber(),u=Math.max(i,r.priceMin),c=Math.min(s,r.priceMax)-u,l=s-i,m=r.priceMax-r.priceMin,p;return c<=0?p=0:l===c?p=m/c:m===c?p=c/l:p=c/m*(c/l),{feeApr:r.feeApr*p,rewardsApr:[((f=r.rewardApr[0])!=null?f:0)*p,((y=r.rewardApr[1])!=null?y:0)*p,((b=r.rewardApr[2])!=null?b:0)*p],apr:r.apr*p}}static estimateAprsForPriceRangeDelta({poolInfo:e,poolLiquidity:t,aprType:n,mintPrice:o,liquidity:r,positionTickLowerIndex:i,positionTickUpperIndex:s,chainTime:u}){let a=n==="day"?1:n==="week"?7:n==="month"?30:0,c=e[n],l=o[ut(e.mintA.address).toString()],m=o[ut(e.mintB.address).toString()],p=e.mintA.decimals,f=e.mintB.decimals;if(!c||!l||!m)return{feeApr:0,rewardsApr:[0,0,0],apr:0};let y=ue.priceToSqrtPriceX64(new ke(e.price),e.mintA.decimals,e.mintB.decimals),b=ue.getSqrtPriceX64FromTick(i),g=ue.getSqrtPriceX64FromTick(s),{amountSlippageA:P,amountSlippageB:T}=we.getAmountsFromLiquidityWithSlippage(y,b,g,t,!1,!1,0),{amountSlippageA:h,amountSlippageB:w}=we.getAmountsFromLiquidityWithSlippage(y,b,g,r,!1,!1,0),k=new ke(P.toString()).div(new ke(10).pow(p)).mul(l.value).add(new ke(T.toString()).div(new ke(10).pow(f)).mul(m.value)),x=new ke(h.toString()).div(new ke(10).pow(p)).mul(l.value).add(new ke(w.toString()).div(new ke(10).pow(f)).mul(m.value)),B=new ke(1).div(k.add(x)),I=new ke(c.volumeFee).mul(365).div(a).mul(B).mul(100).toNumber(),R=3600*24*365,C=e.rewardDefaultInfos.map(N=>{var F,G;let L=N.mint.decimals,O=o[N.mint.address];return u<((F=N.startTime)!=null?F:0)||u>((G=N.endTime)!=null?G:0)||!N.perSecond||!O||L===void 0?0:new ke(O.value).mul(new ke(N.perSecond).mul(R)).div(new ke(10).pow(L)).mul(B).mul(100).toNumber()});return{feeApr:I,rewardsApr:C,apr:I+C.reduce((N,L)=>N+L,0)}}static async getLiquidityAmountOutFromAmountIn({poolInfo:e,inputA:t,tickLower:n,tickUpper:o,amount:r,slippage:i,add:s,epochInfo:u,amountHasFee:a}){var g,P;let c=ue.priceToSqrtPriceX64(new ke(e.price),e.mintA.decimals,e.mintB.decimals),l=ue.getSqrtPriceX64FromTick(n),m=ue.getSqrtPriceX64FromTick(o),p=Ke(r,(g=e[t?"mintA":"mintB"].extensions)==null?void 0:g.feeConfig,u,!a),f=new Ee(new ke(p.amount.sub((P=p.fee)!=null?P:Ue).toString()).toFixed(0)),y;if(c.lte(l))y=t?we.getLiquidityFromTokenAmountA(l,m,f,!s):new Ee(0);else if(c.lte(m)){let T=we.getLiquidityFromTokenAmountA(c,m,f,!s),h=we.getLiquidityFromTokenAmountB(l,c,f);y=t?T:h}else y=t?new Ee(0):we.getLiquidityFromTokenAmountB(l,m,f);let b=await Me.getAmountsFromLiquidity({epochInfo:u,poolInfo:e,tickLower:n,tickUpper:o,liquidity:y,slippage:i,add:s});return{liquidity:y,amountA:t?p:b.amountA,amountB:t?b.amountB:p,amountSlippageA:t?p:b.amountSlippageA,amountSlippageB:t?b.amountSlippageB:p,expirationTime:b.expirationTime}}static async getAmountsFromLiquidity({epochInfo:e,poolInfo:t,tickLower:n,tickUpper:o,liquidity:r,slippage:i,add:s}){var b,g,P,T;let u=ue.getSqrtPriceX64FromTick(n),a=ue.getSqrtPriceX64FromTick(o),c=s?1+i:1-i,l=we.getAmountsFromLiquidity(ue.priceToSqrtPriceX64(new ke(t.price),t.mintA.decimals,t.mintB.decimals),u,a,r,s),[m,p]=[Ke(l.amountA,(b=t.mintA.extensions)==null?void 0:b.feeConfig,e,!0),Ke(l.amountB,(g=t.mintB.extensions)==null?void 0:g.feeConfig,e,!0)],[f,y]=[Ke(l.amountA.muln(c),(P=t.mintA.extensions)==null?void 0:P.feeConfig,e,!0),Ke(l.amountB.muln(c),(T=t.mintB.extensions)==null?void 0:T.feeConfig,e,!0)];return{liquidity:r,amountA:m,amountB:p,amountSlippageA:f,amountSlippageB:y,expirationTime:Zt(m.expirationTime,p.expirationTime)}}static async fetchComputeMultipleClmmInfo({connection:e,poolList:t,rpcDataMap:n={}}){let o=t.filter(u=>!n[u.id]).map(u=>new Rt(u.id));(await jt(e,o)).forEach((u,a)=>{!u||(n[o[a].toBase58()]=Zn.decode(u.data))});let i=t.map(u=>Qe(new Rt(u.programId),new Rt(u.id)).publicKey),s=await Me.fetchExBitmaps({connection:e,exBitmapAddress:i,batchRequest:!1});return t.reduce((u,a)=>D(v({},u),{[a.id]:D(v({},n[a.id]),{id:new Rt(a.id),version:6,programId:new Rt(a.programId),mintA:a.mintA,mintB:a.mintB,ammConfig:D(v({},a.config),{id:new Rt(a.config.id),fundOwner:""}),currentPrice:new ke(a.price),exBitmapAccount:Qe(new Rt(a.programId),new Rt(a.id)).publicKey,exBitmapInfo:s[Qe(new Rt(a.programId),new Rt(a.id)).publicKey.toBase58()],startTime:n[a.id].startTime.toNumber(),rewardInfos:n[a.id].rewardInfos})}),{})}static async fetchComputeClmmInfo({connection:e,poolInfo:t,rpcData:n}){return(await this.fetchComputeMultipleClmmInfo({connection:e,rpcDataMap:n?{[t.id]:n}:void 0,poolList:[t]}))[t.id]}};var Gs={volume:0,volumeQuote:0,volumeFee:0,apr:0,feeApr:0,priceMin:0,priceMax:0,rewardApr:[]};function rc(d){return D(v({},d),{type:"Concentrated",programId:d.programId.toString(),id:d.id.toString(),rewardDefaultInfos:[],rewardDefaultPoolInfos:"Clmm",price:d.currentPrice.toNumber(),mintAmountA:0,mintAmountB:0,feeRate:d.ammConfig.tradeFeeRate,openTime:d.startTime.toString(),tvl:0,day:Gs,week:Gs,month:Gs,pooltype:[],farmUpcomingCount:0,farmOngoingCount:0,farmFinishedCount:0,burnPercent:0,config:D(v({},d.ammConfig),{id:d.ammConfig.id.toString(),defaultRange:0,defaultRangePoint:[]})})}var le=class{static mulDivRoundingUp(e,t,n){let o=e.mul(t),r=o.div(n);return o.mod(n).eq(Ue)||(r=r.add(Ct)),r}static mulDivFloor(e,t,n){if(n.eq(Ue))throw new Error("division by 0");return e.mul(t).div(n)}static mulDivCeil(e,t,n){if(n.eq(Ue))throw new Error("division by 0");return e.mul(t).add(n.sub(Ct)).div(n)}static x64ToDecimal(e,t){return new un(e.toString()).div(un.pow(2,64)).toDecimalPlaces(t)}static decimalToX64(e){return new pe(e.mul(un.pow(2,64)).floor().toFixed())}static wrappingSubU128(e,t){return e.add(dr).sub(t).mod(dr)}};function ot(d,e){return Xs(d.mul(e),64,256)}function ad(d,e,t){let n=d.toTwos(t).shln(e);return n.imaskn(t+1),n.fromTwos(t)}function Xs(d,e,t){let n=d.toTwos(t).shrn(e);return n.imaskn(t-e+1),n.fromTwos(t-e)}var ue=class{static sqrtPriceX64ToPrice(e,t,n){return le.x64ToDecimal(e).pow(2).mul(un.pow(10,t-n))}static priceToSqrtPriceX64(e,t,n){return le.decimalToX64(e.mul(un.pow(10,n-t)).sqrt())}static getNextSqrtPriceX64FromInput(e,t,n,o){if(!e.gt(Ue))throw new Error("sqrtPriceX64 must greater than 0");if(!t.gt(Ue))throw new Error("liquidity must greater than 0");return o?this.getNextSqrtPriceFromTokenAmountARoundingUp(e,t,n,!0):this.getNextSqrtPriceFromTokenAmountBRoundingDown(e,t,n,!0)}static getNextSqrtPriceX64FromOutput(e,t,n,o){if(!e.gt(Ue))throw new Error("sqrtPriceX64 must greater than 0");if(!t.gt(Ue))throw new Error("liquidity must greater than 0");return o?this.getNextSqrtPriceFromTokenAmountBRoundingDown(e,t,n,!1):this.getNextSqrtPriceFromTokenAmountARoundingUp(e,t,n,!1)}static getNextSqrtPriceFromTokenAmountARoundingUp(e,t,n,o){if(n.eq(Ue))return e;let r=t.shln(ri);if(o){let i=r,s=r.add(n.mul(e));return s.gte(i)?le.mulDivCeil(i,e,s):le.mulDivRoundingUp(i,Ct,i.div(e).add(n))}else{let i=n.mul(e);if(!r.gt(i))throw new Error("getNextSqrtPriceFromTokenAmountARoundingUp,liquidityLeftShift must gt amountMulSqrtPrice");let s=r.sub(i);return le.mulDivCeil(r,e,s)}}static getNextSqrtPriceFromTokenAmountBRoundingDown(e,t,n,o){let r=n.shln(ri);if(o)return e.add(r.div(t));{let i=le.mulDivRoundingUp(r,Ct,t);if(!e.gt(i))throw new Error("getNextSqrtPriceFromTokenAmountBRoundingDown sqrtPriceX64 must gt amountDivLiquidity");return e.sub(i)}}static getSqrtPriceX64FromTick(e){if(!Number.isInteger(e))throw new Error("tick must be integer");if(e<mt||e>yt)throw new Error("tick must be in MIN_TICK and MAX_TICK");let t=e<0?e*-1:e,n=(t&1)!=0?new pe("18445821805675395072"):new pe("18446744073709551616");return(t&2)!=0&&(n=ot(n,new pe("18444899583751176192"))),(t&4)!=0&&(n=ot(n,new pe("18443055278223355904"))),(t&8)!=0&&(n=ot(n,new pe("18439367220385607680"))),(t&16)!=0&&(n=ot(n,new pe("18431993317065453568"))),(t&32)!=0&&(n=ot(n,new pe("18417254355718170624"))),(t&64)!=0&&(n=ot(n,new pe("18387811781193609216"))),(t&128)!=0&&(n=ot(n,new pe("18329067761203558400"))),(t&256)!=0&&(n=ot(n,new pe("18212142134806163456"))),(t&512)!=0&&(n=ot(n,new pe("17980523815641700352"))),(t&1024)!=0&&(n=ot(n,new pe("17526086738831433728"))),(t&2048)!=0&&(n=ot(n,new pe("16651378430235570176"))),(t&4096)!=0&&(n=ot(n,new pe("15030750278694412288"))),(t&8192)!=0&&(n=ot(n,new pe("12247334978884435968"))),(t&16384)!=0&&(n=ot(n,new pe("8131365268886854656"))),(t&32768)!=0&&(n=ot(n,new pe("3584323654725218816"))),(t&65536)!=0&&(n=ot(n,new pe("696457651848324352"))),(t&131072)!=0&&(n=ot(n,new pe("26294789957507116"))),(t&262144)!=0&&(n=ot(n,new pe("37481735321082"))),e>0&&(n=Xu.div(n)),n}static getTickFromPrice(e,t,n){return ue.getTickFromSqrtPriceX64(ue.priceToSqrtPriceX64(e,t,n))}static getTickFromSqrtPriceX64(e){if(e.gt(Dt)||e.lt(Wt))throw new Error("Provided sqrtPrice is not within the supported sqrtPrice range.");let t=e.bitLength()-1,n=new pe(t-64),o=ad(n,32,128),r=new pe("8000000000000000","hex"),i=0,s=new pe(0),u=t>=64?e.shrn(t-63):e.shln(63-t);for(;r.gt(new pe(0))&&i<zu;){u=u.mul(u);let f=u.shrn(127);u=u.shrn(63+f.toNumber()),s=s.add(r.mul(f)),r=r.shrn(1),i+=1}let a=s.shrn(32),l=o.add(a).mul(new pe(Yu)),m=Xs(l.sub(new pe(Qu)),64,128).toNumber(),p=Xs(l.add(new pe(Hu)),64,128).toNumber();return m==p?m:ue.getSqrtPriceX64FromTick(p).lte(e)?p:m}},Jn=class{static getTickWithPriceAndTickspacing(e,t,n,o){let i=ue.getTickFromSqrtPriceX64(ue.priceToSqrtPriceX64(e,n,o))/t;return i<0?i=Math.floor(i):i=Math.ceil(i),i*t}static roundPriceWithTickspacing(e,t,n,o){let r=Jn.getTickWithPriceAndTickspacing(e,t,n,o),i=ue.getSqrtPriceX64FromTick(r);return ue.sqrtPriceX64ToPrice(i,n,o)}},we=class{static addDelta(e,t){return e.add(t)}static getTokenAmountAFromLiquidity(e,t,n,o){if(e.gt(t)&&([e,t]=[t,e]),!e.gt(Ue))throw new Error("sqrtPriceX64A must greater than 0");let r=n.ushln(ri),i=t.sub(e);return o?le.mulDivRoundingUp(le.mulDivCeil(r,i,t),Ct,e):le.mulDivFloor(r,i,t).div(e)}static getTokenAmountBFromLiquidity(e,t,n,o){if(e.gt(t)&&([e,t]=[t,e]),!e.gt(Ue))throw new Error("sqrtPriceX64A must greater than 0");return o?le.mulDivCeil(n,t.sub(e),Ze):le.mulDivFloor(n,t.sub(e),Ze)}static getLiquidityFromTokenAmountA(e,t,n,o){e.gt(t)&&([e,t]=[t,e]);let r=n.mul(e).mul(t),i=t.sub(e),s=r.div(i);return o?le.mulDivRoundingUp(s,Ct,ii):s.shrn(ri)}static getLiquidityFromTokenAmountB(e,t,n){return e.gt(t)&&([e,t]=[t,e]),le.mulDivFloor(n,ii,t.sub(e))}static getLiquidityFromTokenAmounts(e,t,n,o,r){if(t.gt(n)&&([t,n]=[n,t]),e.lte(t))return we.getLiquidityFromTokenAmountA(t,n,o,!1);if(e.lt(n)){let i=we.getLiquidityFromTokenAmountA(e,n,o,!1),s=we.getLiquidityFromTokenAmountB(t,e,r);return i.lt(s)?i:s}else return we.getLiquidityFromTokenAmountB(t,n,r)}static getAmountsFromLiquidity(e,t,n,o,r){if(t.gt(n)&&([t,n]=[n,t]),e.lte(t))return{amountA:we.getTokenAmountAFromLiquidity(t,n,o,r),amountB:new pe(0)};if(e.lt(n)){let i=we.getTokenAmountAFromLiquidity(e,n,o,r),s=we.getTokenAmountBFromLiquidity(t,e,o,r);return{amountA:i,amountB:s}}else return{amountA:new pe(0),amountB:we.getTokenAmountBFromLiquidity(t,n,o,r)}}static getAmountsFromLiquidityWithSlippage(e,t,n,o,r,i,s){let{amountA:u,amountB:a}=we.getAmountsFromLiquidity(e,t,n,o,i),c=r?1+s:1-s,l=new pe(new un(u.toString()).mul(c).toFixed(0)),m=new pe(new un(a.toString()).mul(c).toFixed(0));return{amountSlippageA:l,amountSlippageB:m}}static getAmountsOutFromLiquidity({poolInfo:e,tickLower:t,tickUpper:n,liquidity:o,slippage:r,add:i,epochInfo:s,amountAddFee:u}){var P,T,h,w;let a=ue.priceToSqrtPriceX64(new un(e.price),e.mintA.decimals,e.mintB.decimals),c=ue.getSqrtPriceX64FromTick(t),l=ue.getSqrtPriceX64FromTick(n),m=i?1+r:1-r,p=we.getAmountsFromLiquidity(a,c,l,o,i),[f,y]=[Ke(p.amountA,(P=e.mintA.extensions)==null?void 0:P.feeConfig,s,u),Ke(p.amountB,(T=e.mintB.extensions)==null?void 0:T.feeConfig,s,u)],[b,g]=[Ke(new pe(new un(p.amountA.toString()).mul(m).toFixed(0)),(h=e.mintA.extensions)==null?void 0:h.feeConfig,s,u),Ke(new pe(new un(p.amountB.toString()).mul(m).toFixed(0)),(w=e.mintB.extensions)==null?void 0:w.feeConfig,s,u)];return{liquidity:o,amountA:f,amountB:y,amountSlippageA:b,amountSlippageB:g,expirationTime:Zt(f.expirationTime,y.expirationTime)}}},$n=class{static swapCompute(e,t,n,o,r,i,s,u,a,c,l,m,p,f,y=!1){if(m.eq(Ue))throw new Error("amountSpecified must not be 0");if(f||(f=i?Wt.add(Ct):Dt.sub(Ct)),i){if(f.lt(Wt))throw new Error("sqrtPriceX64 must greater than MIN_SQRT_PRICE_X64");if(f.gte(l))throw new Error("sqrtPriceX64 must smaller than current")}else{if(f.gt(Dt))throw new Error("sqrtPriceX64 must smaller than MAX_SQRT_PRICE_X64");if(f.lte(l))throw new Error("sqrtPriceX64 must greater than current")}let b=m.gt(Ue),g={amountSpecifiedRemaining:m,amountCalculated:Ue,sqrtPriceX64:l,tick:a>p?Math.min(p+Ae.tickCount(c)-1,a):p,accounts:[],liquidity:u,feeAmount:new pe(0)},P=p,T=n[p],h=0,w=!i&&T.startTickIndex===g.tick;for(;!g.amountSpecifiedRemaining.eq(Ue)&&!g.sqrtPriceX64.eq(f);){h>10;let k={};k.sqrtPriceStartX64=g.sqrtPriceX64;let x=j.nextInitTick(T,g.tick,c,i,w),B=x||null,K=null;if(!(B!=null&&B.liquidityGross.gtn(0))){let R=Me.nextInitializedTickArrayStartIndex({tickCurrent:g.tick,tickSpacing:c,tickArrayBitmap:o,exBitmapInfo:r},P,i);if(!R.isExist){if(y)return{allTrade:!1,amountSpecifiedRemaining:g.amountSpecifiedRemaining,amountCalculated:g.amountCalculated,feeAmount:g.feeAmount,sqrtPriceX64:g.sqrtPriceX64,liquidity:g.liquidity,tickCurrent:g.tick,accounts:g.accounts};throw Error("swapCompute LiquidityInsufficient")}P=R.nextStartIndex;let{publicKey:C}=Pe(e,t,P);K=C,T=n[P];try{B=j.firstInitializedTick(T,i)}catch{throw Error("not found next tick info")}}k.tickNext=B.tick,k.initialized=B.liquidityGross.gtn(0),p!==P&&K&&(g.accounts.push(K),p=P),k.tickNext<mt?k.tickNext=mt:k.tickNext>yt&&(k.tickNext=yt),k.sqrtPriceNextX64=ue.getSqrtPriceX64FromTick(k.tickNext);let I;if(i&&k.sqrtPriceNextX64.lt(f)||!i&&k.sqrtPriceNextX64.gt(f)?I=f:I=k.sqrtPriceNextX64,[g.sqrtPriceX64,k.amountIn,k.amountOut,k.feeAmount]=$n.swapStepCompute(g.sqrtPriceX64,I,g.liquidity,g.amountSpecifiedRemaining,s,i),g.feeAmount=g.feeAmount.add(k.feeAmount),b?(g.amountSpecifiedRemaining=g.amountSpecifiedRemaining.sub(k.amountIn.add(k.feeAmount)),g.amountCalculated=g.amountCalculated.sub(k.amountOut)):(g.amountSpecifiedRemaining=g.amountSpecifiedRemaining.add(k.amountOut),g.amountCalculated=g.amountCalculated.add(k.amountIn.add(k.feeAmount))),g.sqrtPriceX64.eq(k.sqrtPriceNextX64)){if(k.initialized){let R=B.liquidityNet;i&&(R=R.mul(gn)),g.liquidity=we.addDelta(g.liquidity,R)}w=k.tickNext!=g.tick&&!i&&T.startTickIndex===k.tickNext,g.tick=i?k.tickNext-1:k.tickNext}else if(g.sqrtPriceX64!=k.sqrtPriceStartX64){let R=ue.getTickFromSqrtPriceX64(g.sqrtPriceX64);w=R!=g.tick&&!i&&T.startTickIndex===R,g.tick=R}++h}try{let{nextStartIndex:k,isExist:x}=Ae.nextInitializedTickArray(g.tick,c,i,o,r);x&&p!==k&&(g.accounts.push(Pe(e,t,k).publicKey),p=k)}catch{}return{allTrade:!0,amountSpecifiedRemaining:Ue,amountCalculated:g.amountCalculated,feeAmount:g.feeAmount,sqrtPriceX64:g.sqrtPriceX64,liquidity:g.liquidity,tickCurrent:g.tick,accounts:g.accounts}}static swapStepCompute(e,t,n,o,r,i){let s={sqrtPriceX64Next:new pe(0),amountIn:new pe(0),amountOut:new pe(0),feeAmount:new pe(0)},u=o.gte(Ue);if(u){let c=le.mulDivFloor(o,yr.sub(new pe(r.toString())),yr);s.amountIn=i?we.getTokenAmountAFromLiquidity(t,e,n,!0):we.getTokenAmountBFromLiquidity(e,t,n,!0),c.gte(s.amountIn)?s.sqrtPriceX64Next=t:s.sqrtPriceX64Next=ue.getNextSqrtPriceX64FromInput(e,n,c,i)}else s.amountOut=i?we.getTokenAmountBFromLiquidity(t,e,n,!1):we.getTokenAmountAFromLiquidity(e,t,n,!1),o.mul(gn).gte(s.amountOut)?s.sqrtPriceX64Next=t:s.sqrtPriceX64Next=ue.getNextSqrtPriceX64FromOutput(e,n,o.mul(gn),i);let a=t.eq(s.sqrtPriceX64Next);return i?(a&&u||(s.amountIn=we.getTokenAmountAFromLiquidity(s.sqrtPriceX64Next,e,n,!0)),a&&!u||(s.amountOut=we.getTokenAmountBFromLiquidity(s.sqrtPriceX64Next,e,n,!1))):(s.amountIn=a&&u?s.amountIn:we.getTokenAmountBFromLiquidity(e,s.sqrtPriceX64Next,n,!0),s.amountOut=a&&!u?s.amountOut:we.getTokenAmountAFromLiquidity(e,s.sqrtPriceX64Next,n,!1)),!u&&s.amountOut.gt(o.mul(gn))&&(s.amountOut=o.mul(gn)),u&&!s.sqrtPriceX64Next.eq(t)?s.feeAmount=o.sub(s.amountIn):s.feeAmount=le.mulDivCeil(s.amountIn,new pe(r),yr.sub(new pe(r))),[s.sqrtPriceX64Next,s.amountIn,s.amountOut,s.feeAmount]}};var Je=60,jn=512,j=class{static getTickArrayAddressByTick(e,t,n,o){let r=j.getTickArrayStartIndexByTick(n,o),{publicKey:i}=Pe(e,t,r);return i}static getTickOffsetInArray(e,t){if(e%t!=0)throw new Error("tickIndex % tickSpacing not equal 0");let n=j.getTickArrayStartIndexByTick(e,t),o=Math.floor((e-n)/t);if(o<0||o>=Je)throw new Error("tick offset in array overflow");return o}static getTickArrayBitIndex(e,t){let n=Ae.tickCount(t),o=e/n;return e<0&&e%n!=0?o=Math.ceil(o)-1:o=Math.floor(o),o}static getTickArrayStartIndexByTick(e,t){return this.getTickArrayBitIndex(e,t)*Ae.tickCount(t)}static getTickArrayOffsetInBitmapByTick(e,t){let n=t*Je,o=Math.floor(e/n)+512;return Math.abs(o)}static checkTickArrayIsInitialized(e,t,n){let o=n*Je,r=Math.floor(t/o)+512,i=Math.abs(r);return{isInitialized:e.testn(i),startIndex:(i-512)*o}}static getNextTickArrayStartIndex(e,t,n){return n?e-t*Je:e+t*Je}static mergeTickArrayBitmap(e){let t=new ud(0);for(let n=0;n<e.length;n++)t=t.add(e[n].shln(64*n));return t}static getInitializedTickArrayInRange(e,t,n,o,r){let i=Math.floor(o/(n*Je));return[...j.searchLowBitFromStart(e,t,i-1,r,n),...j.searchHightBitFromStart(e,t,i,r,n)]}static getAllInitializedTickArrayStartIndex(e,t,n){return j.searchHightBitFromStart(e,t,-7680,jn,n)}static getAllInitializedTickArrayInfo(e,t,n,o,r){let i=[],s=j.getAllInitializedTickArrayStartIndex(n,o,r);for(let u of s){let{publicKey:a}=Pe(e,t,u);i.push({tickArrayStartIndex:u,tickArrayAddress:a})}return i}static getAllInitializedTickInTickArray(e){return e.ticks.filter(t=>t.liquidityGross.gtn(0))}static searchLowBitFromStart(e,t,n,o,r){let i=[...[...t.negativeTickArrayBitmap].reverse(),e.slice(0,8),e.slice(8,16),...t.positiveTickArrayBitmap].map(a=>j.mergeTickArrayBitmap(a)),s=[];for(;n>=-7680;){let a=Math.floor((n+7680)/512),c=(n+7680)%512;if(i[a].testn(c)&&s.push(n),n--,s.length===o)break}let u=Ae.tickCount(r);return s.map(a=>a*u)}static searchHightBitFromStart(e,t,n,o,r){let i=[...[...t.negativeTickArrayBitmap].reverse(),e.slice(0,8),e.slice(8,16),...t.positiveTickArrayBitmap].map(a=>j.mergeTickArrayBitmap(a)),s=[];for(;n<7680;){let a=Math.floor((n+7680)/512),c=(n+7680)%512;if(i[a].testn(c)&&s.push(n),n++,s.length===o)break}let u=Ae.tickCount(r);return s.map(a=>a*u)}static checkIsOutOfBoundary(e){return e<mt||e>yt}static nextInitTick(e,t,n,o,r){if(Ae.getArrayStartIndex(t,n)!=e.startTickIndex)return null;let s=Math.floor((t-e.startTickIndex)/n);if(o)for(;s>=0;){if(e.ticks[s].liquidityGross.gtn(0))return e.ticks[s];s=s-1}else for(r||(s=s+1);s<Je;){if(e.ticks[s].liquidityGross.gtn(0))return e.ticks[s];s=s+1}return null}static firstInitializedTick(e,t){if(t){let n=Je-1;for(;n>=0;){if(e.ticks[n].liquidityGross.gtn(0))return e.ticks[n];n=n-1}}else{let n=0;for(;n<Je;){if(e.ticks[n].liquidityGross.gtn(0))return e.ticks[n];n=n+1}}throw Error(`firstInitializedTick check error: ${e} - ${t}`)}static _getTickPriceLegacy({poolInfo:e,tick:t,baseIn:n}){let o=ue.getSqrtPriceX64FromTick(t),r=ue.sqrtPriceX64ToPrice(o,e.mintA.decimals,e.mintB.decimals);return n?{tick:t,price:r,tickSqrtPriceX64:o}:{tick:t,price:new Bo(1).div(r),tickSqrtPriceX64:o}}static _getPriceAndTickLegacy({poolInfo:e,price:t,baseIn:n}){let o=n?t:new Bo(1).div(t),r=Jn.getTickWithPriceAndTickspacing(o,e.ammConfig.tickSpacing,e.mintA.decimals,e.mintB.decimals),i=ue.getSqrtPriceX64FromTick(r),s=ue.sqrtPriceX64ToPrice(i,e.mintA.decimals,e.mintB.decimals);return n?{tick:r,price:s}:{tick:r,price:new Bo(1).div(s)}}static getTickPrice({poolInfo:e,tick:t,baseIn:n}){let o=ue.getSqrtPriceX64FromTick(t),r=ue.sqrtPriceX64ToPrice(o,e.mintA.decimals,e.mintB.decimals);return n?{tick:t,price:r,tickSqrtPriceX64:o}:{tick:t,price:new Bo(1).div(r),tickSqrtPriceX64:o}}static getPriceAndTick({poolInfo:e,price:t,baseIn:n}){let o=n?t:new Bo(1).div(t),r=Jn.getTickWithPriceAndTickspacing(o,e.config.tickSpacing,e.mintA.decimals,e.mintB.decimals),i=ue.getSqrtPriceX64FromTick(r),s=ue.sqrtPriceX64ToPrice(i,e.mintA.decimals,e.mintB.decimals);return n?{tick:r,price:s}:{tick:r,price:new Bo(1).div(s)}}};var ac=_([Te(8),V("bump"),St("index"),M(""),lt("protocolFeeRate"),lt("tradeFeeRate"),St("tickSpacing"),Y(A(),8,"")]),cd=_([lt("blockTimestamp"),ko("tickCumulative"),Y(A(),4)]),uc=_([Te(8),qe("initialized"),A("recentEpoch"),St("observationIndex"),M("poolId"),Y(cd,100,"observations"),Y(A(),4)]),ld=_([V("rewardState"),A("openTime"),A("endTime"),A("lastUpdateTime"),oe("emissionsPerSecondX64"),A("rewardTotalEmissioned"),A("rewardClaimed"),M("tokenMint"),M("tokenVault"),M("creator"),oe("rewardGrowthGlobalX64")]),Zn=_([Te(8),V("bump"),M("ammConfig"),M("creator"),M("mintA"),M("mintB"),M("vaultA"),M("vaultB"),M("observationId"),V("mintDecimalsA"),V("mintDecimalsB"),St("tickSpacing"),oe("liquidity"),oe("sqrtPriceX64"),Ve("tickCurrent"),lt(),oe("feeGrowthGlobalX64A"),oe("feeGrowthGlobalX64B"),A("protocolFeesTokenA"),A("protocolFeesTokenB"),oe("swapInAmountTokenA"),oe("swapOutAmountTokenB"),oe("swapInAmountTokenB"),oe("swapOutAmountTokenA"),V("status"),Y(V(),7,""),Y(ld,3,"rewardInfos"),Y(A(),16,"tickArrayBitmap"),A("totalFeesTokenA"),A("totalFeesClaimedTokenA"),A("totalFeesTokenB"),A("totalFeesClaimedTokenB"),A("fundFeesTokenA"),A("fundFeesTokenB"),A("startTime"),Y(A(),15*4-3,"padding")]),md=_([oe("growthInsideLastX64"),A("rewardAmountOwed")]),Io=_([Te(8),V("bump"),M("nftMint"),M("poolId"),Ve("tickLower"),Ve("tickUpper"),oe("liquidity"),oe("feeGrowthInsideLastX64A"),oe("feeGrowthInsideLastX64B"),A("tokenFeesOwedA"),A("tokenFeesOwedB"),Y(md,3,"rewardInfos"),Y(A(),8,"")]),uT=_([Te(8),V("bump"),M("poolId"),Ve("tickLowerIndex"),Ve("tickUpperIndex"),oe("liquidity"),oe("feeGrowthInsideLastX64A"),oe("feeGrowthInsideLastX64B"),A("tokenFeesOwedA"),A("tokenFeesOwedB"),Y(oe(),3,"rewardGrowthInside"),Y(A(),8,"")]),dd=_([Ve("tick"),Iu("liquidityNet"),oe("liquidityGross"),oe("feeGrowthOutsideX64A"),oe("feeGrowthOutsideX64B"),Y(oe(),3,"rewardGrowthsOutsideX64"),Y(lt(),13,"")]),ci=_([Te(8),M("poolId"),Ve("startTickIndex"),Y(dd,Je,"ticks"),V("initializedTickCount"),Y(V(),115,"")]),cc=_([Te(329),Y(M(),100,"whitelistMints")]),sc=_([Te(8),M("poolId"),Y(Y(A(),8),Us,"positiveTickArrayBitmap"),Y(Y(A(),8),Us,"negativeTickArrayBitmap")]),cT=_([A(),V("bump"),M("owner"),M("poolId"),M("positionId"),M("nftAccount"),Y(A(),8)]),lc=_([Te(8),V("bump"),M("lockOwner"),M("poolId"),M("positionId"),M("nftAccount"),M("lockNftMint"),A("recentEpoch"),Y(A(),8)]);uc.span;var mc=ge("Raydium_Clmm"),Lt={createPool:[233,146,209,142,207,104,64,188],initReward:[95,135,192,196,242,129,230,68],setRewardEmissions:[112,52,167,75,32,201,211,137],openPosition:[77,184,74,214,112,86,241,199],openPositionWithTokenEx:[77,255,174,82,125,29,201,46],closePosition:[123,134,81,0,49,68,98,98],increaseLiquidity:[133,29,89,223,69,238,176,10],decreaseLiquidity:[58,127,188,62,79,82,196,96],swap:[43,4,237,11,26,201,30,98],collectReward:[18,237,166,197,34,16,213,144]},dc=[188,37,179,131,82,150,84,73],pc=[16,72,250,198,14,162,212,19],Re=class{static createPoolInstruction(e,t,n,o,r,i,s,u,a,c,l,m,p,f){let y=_([oe("sqrtPriceX64"),A("zero")]),b=[{pubkey:n,isSigner:!0,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!1},{pubkey:a,isSigner:!1,isWritable:!1},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:m,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!1},{pubkey:l,isSigner:!1,isWritable:!1},{pubkey:kn.programId,isSigner:!1,isWritable:!1},{pubkey:it,isSigner:!1,isWritable:!1},...(f==null?void 0:f.map(T=>({pubkey:T,isSigner:!1,isWritable:!1})))||[]],g=Buffer.alloc(y.span);y.encode({sqrtPriceX64:p,zero:Ue},g);let P=Buffer.from([...Lt.createPool,...g]);return new st({keys:b,programId:e,data:P})}static async createPoolInstructions(e){let{programId:t,owner:n,mintA:o,mintB:r,ammConfigId:i,initialPriceX64:s,extendMintAccount:u}=e,[a,c]=[new X(o.address),new X(r.address)],{publicKey:l}=ec(t,i,a,c),{publicKey:m}=nc(t,l),{publicKey:p}=Es(t,l,a),{publicKey:f}=Es(t,l,c),y=Qe(t,l).publicKey,b=[this.createPoolInstruction(t,l,n,i,m,a,p,new X(o.programId||Ce),c,f,new X(r.programId||Ce),y,s,u)];return{signers:[],instructions:b,instructionTypes:[U.CreateAccount,U.ClmmCreatePool],address:{poolId:l,observationId:m,exBitmapAccount:y,mintAVault:p,mintBVault:f},lookupTableAddress:[]}}static openPositionFromLiquidityInstruction(e,t,n,o,r,i,s,u,a,c,l,m,p,f,y,b,g,P,T,h,w,k,x,B,K,I){let R=_([Ve("tickLowerIndex"),Ve("tickUpperIndex"),Ve("tickArrayLowerStartIndex"),Ve("tickArrayUpperStartIndex"),oe("liquidity"),A("amountMaxA"),A("amountMaxB"),qe("withMetadata"),V("optionBaseFlag"),qe("baseFlag")]),C=[...I?[{pubkey:I,isSigner:!1,isWritable:!0}]:[]],N=[{pubkey:t,isSigner:!0,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!0,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:m,isSigner:!1,isWritable:!0},{pubkey:p,isSigner:!1,isWritable:!0},{pubkey:f,isSigner:!1,isWritable:!0},{pubkey:y,isSigner:!1,isWritable:!0},{pubkey:it,isSigner:!1,isWritable:!1},{pubkey:kn.programId,isSigner:!1,isWritable:!1},{pubkey:Ce,isSigner:!1,isWritable:!1},{pubkey:mi,isSigner:!1,isWritable:!1},{pubkey:$t,isSigner:!1,isWritable:!1},{pubkey:Xe,isSigner:!1,isWritable:!1},{pubkey:b,isSigner:!1,isWritable:!1},{pubkey:g,isSigner:!1,isWritable:!1},...C],L=Buffer.alloc(R.span);R.encode({tickLowerIndex:P,tickUpperIndex:T,tickArrayLowerStartIndex:h,tickArrayUpperStartIndex:w,liquidity:k,amountMaxA:x,amountMaxB:B,withMetadata:K==="create",baseFlag:!1,optionBaseFlag:0},L);let O=Buffer.from([...Lt.openPosition,...L]);return new st({keys:N,programId:e,data:O})}static openPositionFromLiquidityInstruction22(e,t,n,o,r,i,s,u,a,c,l,m,p,f,y,b,g,P,T,h,w,k,x,B,K){let I=_([Ve("tickLowerIndex"),Ve("tickUpperIndex"),Ve("tickArrayLowerStartIndex"),Ve("tickArrayUpperStartIndex"),oe("liquidity"),A("amountMaxA"),A("amountMaxB"),qe("withMetadata"),V("optionBaseFlag"),qe("baseFlag")]),R=[...K?[{pubkey:K,isSigner:!1,isWritable:!0}]:[]],C=[{pubkey:t,isSigner:!0,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!0,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:m,isSigner:!1,isWritable:!0},{pubkey:p,isSigner:!1,isWritable:!0},{pubkey:f,isSigner:!1,isWritable:!0},{pubkey:it,isSigner:!1,isWritable:!1},{pubkey:kn.programId,isSigner:!1,isWritable:!1},{pubkey:Ce,isSigner:!1,isWritable:!1},{pubkey:mi,isSigner:!1,isWritable:!1},{pubkey:Xe,isSigner:!1,isWritable:!1},{pubkey:y,isSigner:!1,isWritable:!1},{pubkey:b,isSigner:!1,isWritable:!1},...R],N=Buffer.alloc(I.span);I.encode({tickLowerIndex:g,tickUpperIndex:P,tickArrayLowerStartIndex:T,tickArrayUpperStartIndex:h,liquidity:w,amountMaxA:k,amountMaxB:x,withMetadata:B==="create",baseFlag:!1,optionBaseFlag:0},N);let L=Buffer.from([...Lt.openPositionWithTokenEx,...N]);return new st({keys:C,programId:e,data:L})}static async openPositionInstructions({poolInfo:e,poolKeys:t,ownerInfo:n,tickLower:o,tickUpper:r,liquidity:i,amountMaxA:s,amountMaxB:u,withMetadata:a,getEphemeralSigners:c,nft2022:l}){let m=[],[p,f]=[new X(e.programId),new X(e.id)],y;if(c)y=new X((await c(1))[0]);else{let K=gr.generate();m.push(K),y=K.publicKey}let b=j.getTickArrayStartIndexByTick(o,e.config.tickSpacing),g=j.getTickArrayStartIndexByTick(r,e.config.tickSpacing),{publicKey:P}=Pe(p,f,b),{publicKey:T}=Pe(p,f,g),{publicKey:h}=l?Z(n.wallet,y,Xe):Z(n.wallet,y,Ce),{publicKey:w}=Pn(y),{publicKey:k}=bt(p,y),{publicKey:x}=en(p,f,o,r),B=l?this.openPositionFromLiquidityInstruction22(p,n.feePayer,f,n.wallet,y,h,x,P,T,k,n.tokenAccountA,n.tokenAccountB,new X(t.vault.A),new X(t.vault.B),new X(e.mintA.address),new X(e.mintB.address),o,r,b,g,i,s,u,a,Me.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing,[b,g])?Qe(p,f).publicKey:void 0):this.openPositionFromLiquidityInstruction(p,n.feePayer,f,n.wallet,y,h,w,x,P,T,k,n.tokenAccountA,n.tokenAccountB,new X(t.vault.A),new X(t.vault.B),new X(e.mintA.address),new X(e.mintB.address),o,r,b,g,i,s,u,a,Me.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing,[b,g])?Qe(p,f).publicKey:void 0);return{signers:m,instructions:[B],instructionTypes:[U.ClmmOpenPosition],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[],address:{nftMint:y,tickArrayLower:P,tickArrayUpper:T,positionNftAccount:h,metadataAccount:w,personalPosition:k,protocolPosition:x}}}static async openPositionFromBaseInstructions({poolInfo:e,poolKeys:t,ownerInfo:n,tickLower:o,tickUpper:r,base:i,baseAmount:s,otherAmountMax:u,withMetadata:a,getEphemeralSigners:c,nft2022:l}){let m=[],[p,f]=[new X(e.programId),new X(e.id)],y;if(c)y=new X((await c(1))[0]);else{let K=gr.generate();m.push(K),y=K.publicKey}let b=j.getTickArrayStartIndexByTick(o,e.config.tickSpacing),g=j.getTickArrayStartIndexByTick(r,e.config.tickSpacing),{publicKey:P}=Pe(p,f,b),{publicKey:T}=Pe(p,f,g),{publicKey:h}=l?Z(n.wallet,y,Xe):Z(n.wallet,y,Ce),{publicKey:w}=Pn(y),{publicKey:k}=bt(p,y),{publicKey:x}=en(p,f,o,r),B=l?this.openPositionFromBaseInstruction22(p,n.feePayer,f,n.wallet,y,h,x,P,T,k,n.tokenAccountA,n.tokenAccountB,new X(t.vault.A),new X(t.vault.B),new X(e.mintA.address),new X(e.mintB.address),o,r,b,g,a,i,s,u,Me.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing,[b,g])?Qe(p,f).publicKey:void 0):this.openPositionFromBaseInstruction(p,n.feePayer,f,n.wallet,y,h,w,x,P,T,k,n.tokenAccountA,n.tokenAccountB,new X(t.vault.A),new X(t.vault.B),new X(e.mintA.address),new X(e.mintB.address),o,r,b,g,a,i,s,u,Me.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing,[b,g])?Qe(p,f).publicKey:void 0);return{address:{nftMint:y,tickArrayLower:P,tickArrayUpper:T,positionNftAccount:h,metadataAccount:w,personalPosition:k,protocolPosition:x},instructions:[B],signers:m,instructionTypes:[U.ClmmOpenPosition],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[]}}static openPositionFromBaseInstruction(e,t,n,o,r,i,s,u,a,c,l,m,p,f,y,b,g,P,T,h,w,k,x,B,K,I){let R=_([Ve("tickLowerIndex"),Ve("tickUpperIndex"),Ve("tickArrayLowerStartIndex"),Ve("tickArrayUpperStartIndex"),oe("liquidity"),A("amountMaxA"),A("amountMaxB"),qe("withMetadata"),V("optionBaseFlag"),qe("baseFlag")]),C=[...I?[{pubkey:I,isSigner:!1,isWritable:!0}]:[]],N=[{pubkey:t,isSigner:!0,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!0,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:m,isSigner:!1,isWritable:!0},{pubkey:p,isSigner:!1,isWritable:!0},{pubkey:f,isSigner:!1,isWritable:!0},{pubkey:y,isSigner:!1,isWritable:!0},{pubkey:it,isSigner:!1,isWritable:!1},{pubkey:kn.programId,isSigner:!1,isWritable:!1},{pubkey:Ce,isSigner:!1,isWritable:!1},{pubkey:mi,isSigner:!1,isWritable:!1},{pubkey:$t,isSigner:!1,isWritable:!1},{pubkey:Xe,isSigner:!1,isWritable:!1},{pubkey:b,isSigner:!1,isWritable:!1},{pubkey:g,isSigner:!1,isWritable:!1},...C],L=Buffer.alloc(R.span);R.encode({tickLowerIndex:P,tickUpperIndex:T,tickArrayLowerStartIndex:h,tickArrayUpperStartIndex:w,liquidity:new zs(0),amountMaxA:x==="MintA"?B:K,amountMaxB:x==="MintA"?K:B,withMetadata:k==="create",baseFlag:x==="MintA",optionBaseFlag:1},L);let O=Buffer.from([...Lt.openPosition,...L]);return new st({keys:N,programId:e,data:O})}static openPositionFromBaseInstruction22(e,t,n,o,r,i,s,u,a,c,l,m,p,f,y,b,g,P,T,h,w,k,x,B,K){let I=_([Ve("tickLowerIndex"),Ve("tickUpperIndex"),Ve("tickArrayLowerStartIndex"),Ve("tickArrayUpperStartIndex"),oe("liquidity"),A("amountMaxA"),A("amountMaxB"),qe("withMetadata"),V("optionBaseFlag"),qe("baseFlag")]),R=[...K?[{pubkey:K,isSigner:!1,isWritable:!0}]:[]],C=[{pubkey:t,isSigner:!0,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!0,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:m,isSigner:!1,isWritable:!0},{pubkey:p,isSigner:!1,isWritable:!0},{pubkey:f,isSigner:!1,isWritable:!0},{pubkey:it,isSigner:!1,isWritable:!1},{pubkey:kn.programId,isSigner:!1,isWritable:!1},{pubkey:Ce,isSigner:!1,isWritable:!1},{pubkey:mi,isSigner:!1,isWritable:!1},{pubkey:Xe,isSigner:!1,isWritable:!1},{pubkey:y,isSigner:!1,isWritable:!1},{pubkey:b,isSigner:!1,isWritable:!1},...R],N=Buffer.alloc(I.span);I.encode({tickLowerIndex:g,tickUpperIndex:P,tickArrayLowerStartIndex:T,tickArrayUpperStartIndex:h,liquidity:new zs(0),amountMaxA:k==="MintA"?x:B,amountMaxB:k==="MintA"?B:x,withMetadata:w==="create",baseFlag:k==="MintA",optionBaseFlag:1},N);let L=Buffer.from([...Lt.openPositionWithTokenEx,...N]);return new st({keys:C,programId:e,data:L})}static async openPositionFromLiquidityInstructions({poolInfo:e,poolKeys:t,ownerInfo:n,tickLower:o,tickUpper:r,liquidity:i,amountMaxA:s,amountMaxB:u,withMetadata:a,getEphemeralSigners:c,nft2022:l}){let m,p=[];if(c)m=new X((await c(1))[0]);else{let K=gr.generate();p.push(K),m=K.publicKey}let[f,y]=[new X(e.programId),new X(e.id)],b=j.getTickArrayStartIndexByTick(o,e.config.tickSpacing),g=j.getTickArrayStartIndexByTick(r,e.config.tickSpacing),{publicKey:P}=Pe(f,y,b),{publicKey:T}=Pe(f,y,g),{publicKey:h}=l?Z(n.wallet,m,Xe):Z(n.wallet,m,Ce),{publicKey:w}=Pn(m),{publicKey:k}=bt(f,m),{publicKey:x}=en(f,y,o,r),B=l?this.openPositionFromLiquidityInstruction22(f,n.wallet,y,n.wallet,m,h,x,P,T,k,n.tokenAccountA,n.tokenAccountB,new X(t.vault.A),new X(t.vault.B),new X(t.mintA.address),new X(t.mintB.address),o,r,b,g,i,s,u,a,Me.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing,[b,g])?Qe(f,y).publicKey:void 0):this.openPositionFromLiquidityInstruction(f,n.wallet,y,n.wallet,m,h,w,x,P,T,k,n.tokenAccountA,n.tokenAccountB,new X(t.vault.A),new X(t.vault.B),new X(t.mintA.address),new X(t.mintB.address),o,r,b,g,i,s,u,a,Me.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing,[b,g])?Qe(f,y).publicKey:void 0);return{address:{nftMint:m,tickArrayLower:P,tickArrayUpper:T,positionNftAccount:h,metadataAccount:w,personalPosition:k,protocolPosition:x},instructions:[B],signers:p,instructionTypes:[U.ClmmOpenPosition],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[]}}static closePositionInstruction(e,t,n,o,r,i){let s=_([]),u=[{pubkey:t,isSigner:!0,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:kn.programId,isSigner:!1,isWritable:!1},{pubkey:i?Xe:Ce,isSigner:!1,isWritable:!1}],a=Buffer.alloc(s.span);s.encode({},a);let c=Buffer.from([...Lt.closePosition,...a]);return new st({keys:u,programId:e,data:c})}static closePositionInstructions({poolInfo:e,poolKeys:t,ownerInfo:n,ownerPosition:o,nft2022:r}){let i=new X(e.programId),s=r?Z(n.wallet,o.nftMint,Xe).publicKey:Z(n.wallet,o.nftMint,Ce).publicKey,{publicKey:u}=bt(i,o.nftMint),a=[];return a.push(this.closePositionInstruction(i,n.wallet,o.nftMint,s,u,r)),{address:{positionNftAccount:s,personalPosition:u},signers:[],instructions:a,instructionTypes:[U.ClmmClosePosition],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[]}}static increasePositionFromLiquidityInstruction(e,t,n,o,r,i,s,u,a,c,l,m,p,f,y,b,g,P){let T=_([oe("liquidity"),A("amountMaxA"),A("amountMaxB"),V("optionBaseFlag"),qe("baseFlag")]),h=[...P?[{pubkey:P,isSigner:!1,isWritable:!0}]:[]],w=[{pubkey:t,isSigner:!0,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:m,isSigner:!1,isWritable:!0},{pubkey:Ce,isSigner:!1,isWritable:!1},{pubkey:Xe,isSigner:!1,isWritable:!1},{pubkey:p,isSigner:!1,isWritable:!1},{pubkey:f,isSigner:!1,isWritable:!1},...h],k=Buffer.alloc(T.span);T.encode({liquidity:y,amountMaxA:b,amountMaxB:g,optionBaseFlag:0,baseFlag:!1},k);let x=Buffer.from([...Lt.increaseLiquidity,...k]);return new st({keys:w,programId:e,data:x})}static increasePositionFromLiquidityInstructions({poolInfo:e,poolKeys:t,ownerPosition:n,ownerInfo:o,liquidity:r,amountMaxA:i,amountMaxB:s,nft2022:u}){let[a,c]=[new X(e.programId),new X(e.id)],l=j.getTickArrayStartIndexByTick(n.tickLower,e.config.tickSpacing),m=j.getTickArrayStartIndexByTick(n.tickUpper,e.config.tickSpacing),{publicKey:p}=Pe(a,c,l),{publicKey:f}=Pe(a,c,m),{publicKey:y}=u?Z(o.wallet,n.nftMint,Xe):Z(o.wallet,n.nftMint,Ce),{publicKey:b}=bt(a,n.nftMint),{publicKey:g}=en(a,c,n.tickLower,n.tickUpper),P=this.increasePositionFromLiquidityInstruction(a,o.wallet,y,b,c,g,p,f,o.tokenAccountA,o.tokenAccountB,new X(t.vault.A),new X(t.vault.B),new X(e.mintA.address),new X(e.mintB.address),r,i,s,Me.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing,[l,m])?Qe(a,c).publicKey:void 0);return{address:{tickArrayLower:p,tickArrayUpper:f,positionNftAccount:y,personalPosition:b,protocolPosition:g},signers:[],instructions:[P],instructionTypes:[U.ClmmIncreasePosition],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[]}}static increasePositionFromBaseInstructions({poolInfo:e,poolKeys:t,ownerPosition:n,ownerInfo:o,base:r,baseAmount:i,otherAmountMax:s,nft2022:u}){let[a,c]=[new X(e.programId),new X(e.id)],l=j.getTickArrayStartIndexByTick(n.tickLower,e.config.tickSpacing),m=j.getTickArrayStartIndexByTick(n.tickUpper,e.config.tickSpacing),{publicKey:p}=Pe(a,c,l),{publicKey:f}=Pe(a,c,m),{publicKey:y}=u?Z(o.wallet,n.nftMint,Xe):Z(o.wallet,n.nftMint,Ce),{publicKey:b}=bt(a,n.nftMint),{publicKey:g}=en(a,c,n.tickLower,n.tickUpper);return{address:{tickArrayLower:p,tickArrayUpper:f,positionNftAccount:y,personalPosition:b,protocolPosition:g},instructions:[this.increasePositionFromBaseInstruction(a,o.wallet,y,b,c,g,p,f,o.tokenAccountA,o.tokenAccountB,new X(t.vault.A),new X(t.vault.B),new X(e.mintA.address),new X(e.mintB.address),r,i,s,Me.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing,[l,m])?Qe(a,c).publicKey:void 0)],signers:[],instructionTypes:[U.ClmmIncreasePosition],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[]}}static increasePositionFromBaseInstruction(e,t,n,o,r,i,s,u,a,c,l,m,p,f,y,b,g,P){let T=_([oe("liquidity"),A("amountMaxA"),A("amountMaxB"),V("optionBaseFlag"),qe("baseFlag")]),h=[...P?[{pubkey:P,isSigner:!1,isWritable:!0}]:[]],w=[{pubkey:t,isSigner:!0,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:m,isSigner:!1,isWritable:!0},{pubkey:Ce,isSigner:!1,isWritable:!1},{pubkey:Xe,isSigner:!1,isWritable:!1},{pubkey:p,isSigner:!1,isWritable:!1},{pubkey:f,isSigner:!1,isWritable:!1},...h],k=Buffer.alloc(T.span);T.encode({liquidity:new zs(0),amountMaxA:y==="MintA"?b:g,amountMaxB:y==="MintA"?g:b,baseFlag:y==="MintA",optionBaseFlag:1},k);let x=Buffer.from([...Lt.increaseLiquidity,...k]);return new st({keys:w,programId:e,data:x})}static decreaseLiquidityInstruction(e,t,n,o,r,i,s,u,a,c,l,m,p,f,y,b,g,P,T){let h=_([oe("liquidity"),A("amountMinA"),A("amountMinB")]),w=[...T?[{pubkey:T,isSigner:!1,isWritable:!0}]:[],...y.map(K=>[{pubkey:K.poolRewardVault,isSigner:!1,isWritable:!0},{pubkey:K.ownerRewardVault,isSigner:!1,isWritable:!0},{pubkey:K.rewardMint,isSigner:!1,isWritable:!1}]).flat()],k=[{pubkey:t,isSigner:!0,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:m,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:Ce,isSigner:!1,isWritable:!1},{pubkey:Xe,isSigner:!1,isWritable:!1},{pubkey:Xi,isSigner:!1,isWritable:!1},{pubkey:p,isSigner:!1,isWritable:!1},{pubkey:f,isSigner:!1,isWritable:!1},...w],x=Buffer.alloc(h.span);h.encode({liquidity:b,amountMinA:g,amountMinB:P},x);let B=Buffer.from([...Lt.decreaseLiquidity,...x]);return new st({keys:k,programId:e,data:B})}static decreaseLiquidityInstructions({poolInfo:e,poolKeys:t,ownerPosition:n,ownerInfo:o,liquidity:r,amountMinA:i,amountMinB:s,programId:u,nft2022:a}){let[c,l]=[new X(e.programId),new X(e.id)],m=j.getTickArrayStartIndexByTick(n.tickLower,e.config.tickSpacing),p=j.getTickArrayStartIndexByTick(n.tickUpper,e.config.tickSpacing),{publicKey:f}=Pe(c,l,m),{publicKey:y}=Pe(c,l,p),{publicKey:b}=a?Z(o.wallet,n.nftMint,Xe):Z(o.wallet,n.nftMint,u),{publicKey:g}=bt(c,n.nftMint),{publicKey:P}=en(c,l,n.tickLower,n.tickUpper),T=[];for(let k=0;k<e.rewardDefaultInfos.length;k++)T.push({poolRewardVault:new X(t.rewardInfos[k].vault),ownerRewardVault:o.rewardAccounts[k],rewardMint:new X(e.rewardDefaultInfos[k].mint.address)});let h=[],w=this.decreaseLiquidityInstruction(c,o.wallet,b,g,l,P,f,y,o.tokenAccountA,o.tokenAccountB,new X(t.vault.A),new X(t.vault.B),new X(e.mintA.address),new X(e.mintB.address),T,r,i,s,Me.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing,[m,p])?Qe(c,l).publicKey:void 0);return h.push(w),{address:{tickArrayLower:f,tickArrayUpper:y,positionNftAccount:b,personalPosition:g,protocolPosition:P},signers:[],instructions:h,instructionTypes:[U.ClmmDecreasePosition],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[]}}static swapInstruction(e,t,n,o,r,i,s,u,a,c,l,m,p,f,y,b,g){let P=_([A("amount"),A("otherAmountThreshold"),oe("sqrtPriceLimitX64"),qe("isBaseInput")]),T=[...g?[{pubkey:g,isSigner:!1,isWritable:!0}]:[],...l.map(x=>({pubkey:x,isSigner:!1,isWritable:!0}))],h=[{pubkey:t,isSigner:!0,isWritable:!1},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:m,isSigner:!1,isWritable:!0},{pubkey:Ce,isSigner:!1,isWritable:!1},{pubkey:Xe,isSigner:!1,isWritable:!1},{pubkey:Xi,isSigner:!1,isWritable:!1},{pubkey:a,isSigner:!1,isWritable:!1},{pubkey:c,isSigner:!1,isWritable:!1},...T],w=Buffer.alloc(P.span);P.encode({amount:p,otherAmountThreshold:f,sqrtPriceLimitX64:y,isBaseInput:b},w);let k=Buffer.from([...Lt.swap,...w]);return new st({keys:h,programId:e,data:k})}static makeSwapBaseInInstructions({poolInfo:e,poolKeys:t,observationId:n,ownerInfo:o,inputMint:r,amountIn:i,amountOutMin:s,sqrtPriceLimitX64:u,remainingAccounts:a}){let[c,l]=[new X(e.programId),new X(e.id)],[m,p]=[new X(t.vault.A),new X(t.vault.B)],[f,y]=[new X(e.mintA.address),new X(e.mintB.address)],b=e.mintA.address===r.toString(),g=[this.swapInstruction(c,o.wallet,l,new X(e.config.id),b?o.tokenAccountA:o.tokenAccountB,b?o.tokenAccountB:o.tokenAccountA,b?m:p,b?p:m,b?f:y,b?y:f,a,n,i,s,u,!0,Qe(c,l).publicKey)];return{signers:[],instructions:g,instructionTypes:[U.ClmmSwapBaseIn],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[],address:{}}}static makeSwapBaseOutInstructions({poolInfo:e,poolKeys:t,observationId:n,ownerInfo:o,outputMint:r,amountOut:i,amountInMax:s,sqrtPriceLimitX64:u,remainingAccounts:a}){let[c,l]=[new X(e.programId),new X(e.id)],[m,p]=[new X(t.vault.A),new X(t.vault.B)],[f,y]=[new X(e.mintA.address),new X(e.mintB.address)],b=e.mintA.address===r.toBase58(),g=[this.swapInstruction(c,o.wallet,l,new X(e.config.id),b?o.tokenAccountB:o.tokenAccountA,b?o.tokenAccountA:o.tokenAccountB,b?p:m,b?m:p,b?y:f,b?f:y,a,n,i,s,u,!1,Qe(c,l).publicKey)];return{signers:[],instructions:g,instructionTypes:[U.ClmmSwapBaseOut],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[],address:{}}}static initRewardInstruction(e,t,n,o,r,i,s,u,a,c,l,m){let p=_([A("openTime"),A("endTime"),oe("emissionsPerSecondX64")]),f=[{pubkey:t,isSigner:!0,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!1},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!1},{pubkey:kn.programId,isSigner:!1,isWritable:!1},{pubkey:it,isSigner:!1,isWritable:!1}],y=Buffer.alloc(p.span);p.encode({openTime:ee(c),endTime:ee(l),emissionsPerSecondX64:m},y);let b=Buffer.from([...Lt.initReward,...y]);return new st({keys:f,programId:e,data:b})}static initRewardInstructions({poolInfo:e,poolKeys:t,ownerInfo:n,rewardInfo:o}){let[r,i]=[new X(e.programId),new X(e.id)],s=tc(r,i,o.mint).publicKey,u=ai(r).publicKey,a=[this.initRewardInstruction(r,n.wallet,i,u,new X(e.config.id),n.tokenAccount,o.programId,o.mint,s,o.openTime,o.endTime,o.emissionsPerSecondX64)];return{address:{poolRewardVault:s,operationId:u},signers:[],instructions:a,instructionTypes:[U.ClmmInitReward],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[]}}static setRewardInstruction(e,t,n,o,r,i,s,u,a,c,l,m){let p=_([V("rewardIndex"),oe("emissionsPerSecondX64"),A("openTime"),A("endTime")]),f=[{pubkey:t,isSigner:!0,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:Ce,isSigner:!1,isWritable:!1},{pubkey:Xe,isSigner:!1,isWritable:!1},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0}],y=Buffer.alloc(p.span);p.encode({rewardIndex:a,emissionsPerSecondX64:m,openTime:ee(c),endTime:ee(l)},y);let b=Buffer.from([...Lt.setRewardEmissions,...y]);return new st({keys:f,programId:e,data:b})}static setRewardInstructions({poolInfo:e,poolKeys:t,ownerInfo:n,rewardInfo:o}){let[r,i]=[new X(e.programId),new X(e.id)],s,u,a;for(let m=0;m<e.rewardDefaultInfos.length;m++)e.rewardDefaultInfos[m].mint.address===o.mint.toString()&&(s=m,u=new X(t.rewardInfos[m].vault),a=new X(t.rewardInfos[m].mint.address));(s===void 0||u===void 0)&&mc.logWithError("reward mint check error","no reward mint",e.rewardDefaultInfos);let c=ai(r).publicKey,l=[this.setRewardInstruction(r,n.wallet,i,c,new X(e.config.id),n.tokenAccount,u,a,s,o.openTime,o.endTime,o.emissionsPerSecondX64)];return{address:{rewardVault:u,operationId:c},signers:[],instructions:l,instructionTypes:[U.ClmmSetReward],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[]}}static collectRewardInstruction(e,t,n,o,r,i,s){let u=_([V("rewardIndex")]),a=[{pubkey:t,isSigner:!0,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!1},{pubkey:Ce,isSigner:!1,isWritable:!1},{pubkey:Xe,isSigner:!1,isWritable:!1},{pubkey:Xi,isSigner:!1,isWritable:!1}],c=Buffer.alloc(u.span);u.encode({rewardIndex:s},c);let l=Buffer.from([...Lt.collectReward,...c]);return new st({keys:a,programId:e,data:l})}static collectRewardInstructions({poolInfo:e,poolKeys:t,ownerInfo:n,rewardMint:o}){let[r,i]=[new X(e.programId),new X(e.id)],s,u;for(let c=0;c<e.rewardDefaultInfos.length;c++)e.rewardDefaultInfos[c].mint.address===o.toString()&&(s=c,u=new X(t.rewardInfos[c].vault));(s===void 0||u===void 0)&&mc.logWithError("reward mint check error","no reward mint",e.rewardDefaultInfos);let a=[this.collectRewardInstruction(r,n.wallet,i,n.tokenAccount,u,o,s)];return{address:{rewardVault:u},signers:[],instructions:a,instructionTypes:[U.ClmmCollectReward],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[]}}static async makeLockPositions({programId:e,authProgramId:t,poolProgramId:n,payer:o,wallet:r,nftMint:i,nft2022:s,getEphemeralSigners:u}){let a=[],c;if(u)c=new X((await u(1))[0]);else{let g=gr.generate();a.push(g),c=g.publicKey}let l=s?Z(r,i,Xe).publicKey:Z(r,i,Ce).publicKey,{publicKey:m}=bt(n,i),p=ho(e,c).publicKey,f=Z(r,c,Ce).publicKey,y=Pn(c).publicKey,b=Re.lockPositionInstructionV2({programId:e,auth:t,payer:o,positionOwner:r,lockOwner:r,positionNftAccount:l,positionId:m,lockPositionId:p,lockNftMint:c,lockNftAccount:f,metadataAccount:y,withMetadata:!0,nft2022:s,positionNftMint:i,authPositionNftAccount:Z(t,i,s?Xe:Ce).publicKey,positionNftProgram:s?Xe:Ce});return{address:{positionId:m,lockPositionId:p,lockNftAccount:f,lockNftMint:c,positionNftAccount:l,metadataAccount:y},instructions:[b],signers:a,instructionTypes:[U.ClmmLockPosition],lookupTableAddress:[]}}static lockPositionInstructionV2({programId:e,auth:t,payer:n,positionOwner:o,lockOwner:r,positionNftAccount:i,positionId:s,positionNftMint:u,authPositionNftAccount:a,positionNftProgram:c,lockPositionId:l,lockNftMint:m,lockNftAccount:p,metadataAccount:f,withMetadata:y}){let b=[{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!0,isWritable:!0},{pubkey:o,isSigner:!0,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!1},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!1},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:m,isSigner:!0,isWritable:!0},{pubkey:p,isSigner:!1,isWritable:!0},{pubkey:f,isSigner:!1,isWritable:!0},{pubkey:$t,isSigner:!1,isWritable:!1},{pubkey:mi,isSigner:!1,isWritable:!1},{pubkey:it,isSigner:!1,isWritable:!1},{pubkey:Ce,isSigner:!1,isWritable:!1},{pubkey:c,isSigner:!1,isWritable:!1},{pubkey:kn.programId,isSigner:!1,isWritable:!1}],g=_([qe("withMetadata")]),P=Buffer.alloc(g.span);g.encode({withMetadata:y},P);let T=Buffer.from([...dc,...P]);return new st({keys:b,programId:e,data:T})}static lockPositionInstruction({programId:e,authProgramId:t,poolProgramId:n,owner:o,positionNft:r}){let{publicKey:i}=Z(o,r,Ce),{publicKey:s}=bt(n,r),u=[{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!0,isWritable:!1},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!1},{pubkey:Ws(e,s).publicKey,isSigner:!1,isWritable:!0},{pubkey:Ce,isSigner:!1,isWritable:!1},{pubkey:kn.programId,isSigner:!1,isWritable:!1}];return new st({keys:u,programId:e,data:Buffer.from(dc)})}static harvestLockPositionInstruction(e){let[t,n]=[new X(e.poolKeys.programId),new X(e.poolKeys.id)],o=j.getTickArrayStartIndexByTick(e.ownerPosition.tickLower,e.poolKeys.config.tickSpacing),r=j.getTickArrayStartIndexByTick(e.ownerPosition.tickUpper,e.poolKeys.config.tickSpacing),{publicKey:i}=Pe(t,n,o),{publicKey:s}=Pe(t,n,r),{publicKey:u}=Z(e.owner,e.ownerPosition.nftMint,Ce),{publicKey:a}=bt(t,e.ownerPosition.nftMint),{publicKey:c}=en(t,n,e.ownerPosition.tickLower,e.ownerPosition.tickUpper),l=[];for(let f=0;f<e.poolKeys.rewardInfos.length;f++)l.push({poolRewardVault:new X(e.poolKeys.rewardInfos[f].vault),ownerRewardVault:e.ownerRewardAccounts[f],rewardMint:new X(e.poolKeys.rewardInfos[f].mint.address)});let m=[...l.map(f=>[{pubkey:f.poolRewardVault,isSigner:!1,isWritable:!0},{pubkey:f.ownerRewardVault,isSigner:!1,isWritable:!0},{pubkey:f.rewardMint,isSigner:!1,isWritable:!1}]).flat()],p=[{pubkey:e.authProgramId,isSigner:!1,isWritable:!1},{pubkey:Ws(e.programId,a).publicKey,isSigner:!1,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:e.owner,isSigner:!0,isWritable:!1},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:new X(e.poolKeys.vault.A),isSigner:!1,isWritable:!0},{pubkey:new X(e.poolKeys.vault.B),isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:e.userVaultA,isSigner:!1,isWritable:!0},{pubkey:e.userVaultB,isSigner:!1,isWritable:!0},{pubkey:Ce,isSigner:!1,isWritable:!1},{pubkey:Xe,isSigner:!1,isWritable:!1},{pubkey:Sn,isSigner:!1,isWritable:!1},{pubkey:new X(e.poolKeys.mintA.address),isSigner:!1,isWritable:!1},{pubkey:new X(e.poolKeys.mintB.address),isSigner:!1,isWritable:!1},...m];return new st({keys:p,programId:e.programId,data:Buffer.from(pc)})}static harvestLockPositionInstructionV2({programId:e,auth:t,lockPositionId:n,clmmProgram:o,lockOwner:r,lockNftMint:i,lockNftAccount:s,positionNftAccount:u,positionId:a,poolId:c,protocolPosition:l,vaultA:m,vaultB:p,tickArrayLower:f,tickArrayUpper:y,userVaultA:b,userVaultB:g,mintA:P,mintB:T,rewardAccounts:h,exTickArrayBitmap:w}){let k=[...w?[{pubkey:w,isSigner:!1,isWritable:!0}]:[],...h.map(B=>[{pubkey:B.poolRewardVault,isSigner:!1,isWritable:!0},{pubkey:B.ownerRewardVault,isSigner:!1,isWritable:!0},{pubkey:B.rewardMint,isSigner:!1,isWritable:!1}]).flat()],x=[{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!0,isWritable:!1},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:m,isSigner:!1,isWritable:!0},{pubkey:p,isSigner:!1,isWritable:!0},{pubkey:f,isSigner:!1,isWritable:!0},{pubkey:y,isSigner:!1,isWritable:!0},{pubkey:b,isSigner:!1,isWritable:!0},{pubkey:g,isSigner:!1,isWritable:!0},{pubkey:Ce,isSigner:!1,isWritable:!1},{pubkey:Xe,isSigner:!1,isWritable:!1},{pubkey:Sn,isSigner:!1,isWritable:!1},{pubkey:P,isSigner:!1,isWritable:!1},{pubkey:T,isSigner:!1,isWritable:!1},...k];return new st({keys:x,programId:e,data:Buffer.from(pc)})}};var pd=_([lt("mintAuthorityOption"),M("mintAuthority"),A("supply"),V("decimals"),V("isInitialized"),lt("freezeAuthorityOption"),M("freezeAuthority")]);import{PublicKey as RT}from"@solana/web3.js";import{MintLayout as OT,TOKEN_PROGRAM_ID as MT}from"@solana/spl-token";var Pr=d=>new De({mint:d.address,decimals:d.decimals,symbol:d.symbol,name:d.name}),di=o=>{var r=o,{amount:d,isRaw:e,name:t}=r,n=ve(r,["amount","isRaw","name"]);return new Se(new De({mint:ut(n.address).toBase58(),decimals:n.decimals,symbol:n.symbol,name:t}),d,e,t)};var dt=o=>{var r=o,{address:d,programId:e,decimals:t}=r,n=ve(r,["address","programId","decimals"]);return v({chainId:101,address:ut(d).toBase58(),programId:e,logoURI:"",symbol:"",name:"",decimals:t,tags:[],extensions:n.extensions||{}},n)},Fn=d=>d?D(v({},d),{transferFeeConfigAuthority:d.transferFeeConfigAuthority.toBase58(),withdrawWithheldAuthority:d.withdrawWithheldAuthority.toBase58(),withheldAmount:d.withheldAmount.toString(),olderTransferFee:D(v({},d.olderTransferFee),{epoch:d.olderTransferFee.epoch.toString(),maximumFee:d.olderTransferFee.maximumFee.toString()}),newerTransferFee:D(v({},d.newerTransferFee),{epoch:d.newerTransferFee.epoch.toString(),maximumFee:d.newerTransferFee.maximumFee.toString()})}):void 0;import fc from"bn.js";var Ys=new fc(25),Ar=new fc(1e4);import{PublicKey as cn,SystemProgram as yd,SYSVAR_RENT_PUBKEY as JT,TransactionInstruction as xo}from"@solana/web3.js";import{ASSOCIATED_TOKEN_PROGRAM_ID as bd,TOKEN_PROGRAM_ID as fi}from"@solana/spl-token";var Qs=_([V("instruction"),A("amountIn"),A("minAmountOut")]),Hs=_([V("instruction"),A("maxAmountIn"),A("amountOut")]),HT=_([V("instruction"),V("nonce")]),fd=_([V("instruction"),V("nonce"),A("startTime")]),pi=_([A("status"),A("nonce"),A("maxOrder"),A("depth"),A("baseDecimal"),A("quoteDecimal"),A("state"),A("resetFlag"),A("minSize"),A("volMaxCutRatio"),A("amountWaveRatio"),A("baseLotSize"),A("quoteLotSize"),A("minPriceMultiplier"),A("maxPriceMultiplier"),A("systemDecimalValue"),A("minSeparateNumerator"),A("minSeparateDenominator"),A("tradeFeeNumerator"),A("tradeFeeDenominator"),A("pnlNumerator"),A("pnlDenominator"),A("swapFeeNumerator"),A("swapFeeDenominator"),A("baseNeedTakePnl"),A("quoteNeedTakePnl"),A("quoteTotalPnl"),A("baseTotalPnl"),A("poolOpenTime"),A("punishPcAmount"),A("punishCoinAmount"),A("orderbookToInitTime"),oe("swapBaseInAmount"),oe("swapQuoteOutAmount"),A("swapBase2QuoteFee"),oe("swapQuoteInAmount"),oe("swapBaseOutAmount"),A("swapQuote2BaseFee"),M("baseVault"),M("quoteVault"),M("baseMint"),M("quoteMint"),M("lpMint"),M("openOrders"),M("marketId"),M("marketProgramId"),M("targetOrders"),M("withdrawQueue"),M("lpVault"),M("owner"),A("lpReserve"),Y(A(),3,"padding")]),jT=_([A("accountType"),A("status"),A("nonce"),A("maxOrder"),A("depth"),A("baseDecimal"),A("quoteDecimal"),A("state"),A("resetFlag"),A("minSize"),A("volMaxCutRatio"),A("amountWaveRatio"),A("baseLotSize"),A("quoteLotSize"),A("minPriceMultiplier"),A("maxPriceMultiplier"),A("systemDecimalsValue"),A("abortTradeFactor"),A("priceTickMultiplier"),A("priceTick"),A("minSeparateNumerator"),A("minSeparateDenominator"),A("tradeFeeNumerator"),A("tradeFeeDenominator"),A("pnlNumerator"),A("pnlDenominator"),A("swapFeeNumerator"),A("swapFeeDenominator"),A("baseNeedTakePnl"),A("quoteNeedTakePnl"),A("quoteTotalPnl"),A("baseTotalPnl"),A("poolOpenTime"),A("punishPcAmount"),A("punishCoinAmount"),A("orderbookToInitTime"),oe("swapBaseInAmount"),oe("swapQuoteOutAmount"),oe("swapQuoteInAmount"),oe("swapBaseOutAmount"),A("swapQuote2BaseFee"),A("swapBase2QuoteFee"),M("baseVault"),M("quoteVault"),M("baseMint"),M("quoteMint"),M("lpMint"),M("modelDataAccount"),M("openOrders"),M("marketId"),M("marketProgramId"),M("targetOrders"),M("owner"),Y(A(),64,"padding")]),js=_([V("instruction"),A("baseAmountIn"),A("quoteAmountIn"),A("fixedSide"),A("otherAmountMin")]),$s=_([V("instruction"),A("lpAmount"),A("baseAmountMin"),A("quoteAmountMin")]);var yc=_([A("fee")]);var bc=ge("Raydium_liquidity_instruction");function gc(d){let{poolInfo:e,poolKeys:t,userKeys:n,baseAmountIn:o,quoteAmountIn:r,fixedSide:i,otherAmountMin:s,modelDataPubKey:u=qn}=d,a=Buffer.alloc(js.span);js.encode({instruction:3,baseAmountIn:ee(o),quoteAmountIn:ee(r),otherAmountMin:ee(s),fixedSide:i==="base"?kt:Ha},a);let c=[S({pubkey:fi,isWritable:!1}),S({pubkey:new cn(e.id)}),S({pubkey:new cn(t.authority),isWritable:!1}),S({pubkey:new cn(t.openOrders),isWritable:!1}),S({pubkey:new cn(t.targetOrders)}),S({pubkey:new cn(e.lpMint.address)}),S({pubkey:new cn(t.vault.A)}),S({pubkey:new cn(t.vault.B)})];return e.pooltype.includes("StablePool")&&c.push(S({pubkey:u})),c.push(S({pubkey:new cn(e.marketId),isWritable:!1}),S({pubkey:n.baseTokenAccount}),S({pubkey:n.quoteTokenAccount}),S({pubkey:n.lpTokenAccount}),S({pubkey:n.owner,isWritable:!1,isSigner:!0}),S({pubkey:new cn(t.marketEventQueue),isWritable:!1})),new xo({programId:new cn(e.programId),keys:c,data:a})}function Zs(d){let{poolInfo:e,poolKeys:t,userKeys:n,lpAmount:o,baseAmountMin:r,quoteAmountMin:i,modelDataPubKey:s=qn}=d,u=rt(t),a=4;if(e.pooltype.includes("StablePool")&&(a=5),a===4||a===5){let c=Buffer.alloc($s.span);$s.encode({instruction:4,lpAmount:ee(o),baseAmountMin:ee(r),quoteAmountMin:ee(i)},c);let l=[S({pubkey:fi,isWritable:!1}),S({pubkey:u.id}),S({pubkey:u.authority,isWritable:!1}),S({pubkey:u.openOrders}),S({pubkey:u.targetOrders}),S({pubkey:u.mintLp.address}),S({pubkey:u.vault.A}),S({pubkey:u.vault.B})];return a===5?l.push(S({pubkey:s})):(l.push(S({pubkey:u.id})),l.push(S({pubkey:u.id}))),l.push(S({pubkey:u.marketProgramId,isWritable:!1}),S({pubkey:u.marketId}),S({pubkey:u.marketBaseVault}),S({pubkey:u.marketQuoteVault}),S({pubkey:u.marketAuthority,isWritable:!1}),S({pubkey:n.lpTokenAccount}),S({pubkey:n.baseTokenAccount}),S({pubkey:n.quoteTokenAccount}),S({pubkey:n.owner,isWritable:!1,isSigner:!0}),S({pubkey:u.marketEventQueue}),S({pubkey:u.marketBids}),S({pubkey:u.marketAsks})),new xo({programId:u.programId,keys:l,data:c})}return new xo({programId:u.programId,keys:[]})}function Js({programId:d,ammId:e,ammAuthority:t,ammOpenOrders:n,lpMint:o,coinMint:r,pcMint:i,coinVault:s,pcVault:u,withdrawQueue:a,ammTargetOrders:c,poolTempLp:l,marketProgramId:m,marketId:p,userWallet:f,userCoinVault:y,userPcVault:b,userLpVault:g,nonce:P,openTime:T,coinAmount:h,pcAmount:w,ammConfigId:k,feeDestinationId:x}){let B=_([V("instruction"),V("nonce"),A("openTime"),A("pcAmount"),A("coinAmount")]),K=[{pubkey:fi,isSigner:!1,isWritable:!1},{pubkey:bd,isSigner:!1,isWritable:!1},{pubkey:yd.programId,isSigner:!1,isWritable:!1},{pubkey:it,isSigner:!1,isWritable:!1},{pubkey:e,isSigner:!1,isWritable:!0},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!1},{pubkey:i,isSigner:!1,isWritable:!1},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:k,isSigner:!1,isWritable:!1},{pubkey:x,isSigner:!1,isWritable:!0},{pubkey:m,isSigner:!1,isWritable:!1},{pubkey:p,isSigner:!1,isWritable:!1},{pubkey:f,isSigner:!0,isWritable:!0},{pubkey:y,isSigner:!1,isWritable:!0},{pubkey:b,isSigner:!1,isWritable:!0},{pubkey:g,isSigner:!1,isWritable:!0}],I=Buffer.alloc(B.span);return B.encode({instruction:1,nonce:P,openTime:T,coinAmount:h,pcAmount:w},I),{instruction:new xo({keys:K,programId:d,data:I}),instructionType:U.AmmV4CreatePool}}function gd({poolKeys:d,userKeys:e,amountIn:t,minAmountOut:n,modelDataPubKey:o=qn},r){let i=rt(d),s=Buffer.alloc(Qs.span);Qs.encode({instruction:9,amountIn:ee(t),minAmountOut:ee(n)},s);let u=[S({pubkey:fi,isWritable:!1}),S({pubkey:i.id}),S({pubkey:i.authority,isWritable:!1}),S({pubkey:i.openOrders})];return r===4&&u.push(S({pubkey:i.targetOrders})),u.push(S({pubkey:i.vault.A}),S({pubkey:i.vault.B})),r===5&&u.push(S({pubkey:o})),u.push(S({pubkey:i.marketProgramId,isWritable:!1}),S({pubkey:i.marketId}),S({pubkey:i.marketBids}),S({pubkey:i.marketAsks}),S({pubkey:i.marketEventQueue}),S({pubkey:i.marketBaseVault}),S({pubkey:i.marketQuoteVault}),S({pubkey:i.marketAuthority,isWritable:!1}),S({pubkey:e.tokenAccountIn}),S({pubkey:e.tokenAccountOut}),S({pubkey:e.owner,isWritable:!1,isSigner:!0})),new xo({programId:i.programId,keys:u,data:s})}function Pd({poolKeys:d,userKeys:e,maxAmountIn:t,amountOut:n,modelDataPubKey:o=qn},r){let i=rt(d),s=Buffer.alloc(Hs.span);Hs.encode({instruction:11,maxAmountIn:ee(t),amountOut:ee(n)},s);let u=[S({pubkey:fi,isWritable:!1}),S({pubkey:i.id}),S({pubkey:i.authority,isWritable:!1}),S({pubkey:i.openOrders}),S({pubkey:i.targetOrders}),S({pubkey:i.vault.A}),S({pubkey:i.vault.B})];return r===5&&u.push(S({pubkey:o})),u.push(S({pubkey:i.marketProgramId,isWritable:!1}),S({pubkey:i.marketId}),S({pubkey:i.marketBids}),S({pubkey:i.marketAsks}),S({pubkey:i.marketEventQueue}),S({pubkey:i.marketBaseVault}),S({pubkey:i.marketQuoteVault}),S({pubkey:i.marketAuthority,isWritable:!1}),S({pubkey:e.tokenAccountIn}),S({pubkey:e.tokenAccountOut}),S({pubkey:e.owner,isWritable:!1,isSigner:!0})),new xo({programId:i.programId,keys:u,data:s})}function kr(d){let{poolKeys:e,version:t,userKeys:n,amountIn:o,amountOut:r,fixedSide:i}=d;if(t===4||t===5){let s={poolKeys:e,userKeys:n};if(i==="in")return gd(D(v({},s),{amountIn:o,minAmountOut:r}),t);if(i==="out")return Pd(D(v({},s),{maxAmountIn:o,amountOut:r}),t);bc.logWithError("invalid params","params",d)}throw bc.logWithError("invalid version","poolKeys.version",t),new Error("invalid version")}var to=5e4,Ad=_([A("x"),A("y"),A("price")]),kd=_([A("accountType"),A("status"),A("multiplier"),A("validDataCount"),Y(Ad,to,"DataElement")]);function wd(d,e){return[0,to-2]}function Td(d){return[0,to-2]}function hd(d){return[0,to-2]}function Id(d,e,t){let[n,o]=wd(e,t),r=n,i=o,s=0,u=e*d.multiplier/t;for(;r<=i;){if(s=Math.floor((i+r)/2),s===0||s>=to-2)return[s,s,!1];let a=d.DataElement[s].x*d.multiplier/d.DataElement[s].y,c=d.DataElement[s-1].x*d.multiplier/d.DataElement[s-1].y,l=d.DataElement[s+1].x*d.multiplier/d.DataElement[s+1].y;if(u===a)return[s,s,!0];if(u===c)return[s-1,s-1,!0];if(u===l)return[s+1,s+1,!0];if(u<c)i=s-1;else{if(u>c&&u<a)return[s-1,s,!0];if(u>a&&u<l)return[s,s+1,!0];r=s+1}}return[s,s,!1]}function ea(d,e,t){let[n,o,r]=Id(d,e,t);if(!r)return 0;if(n===o){let i=d.DataElement[n].x;return e*d.multiplier/i}else{let i=d.DataElement[n].x,s=d.DataElement[n].y,u=d.DataElement[o].x,a=d.DataElement[o].y,c=t*(u*s-i*a),l=i*c,m=(u-i)*(e*s-i*t)*a,p=l+m;return e*d.multiplier*c/p}}function eo(d,e,t){return e*d.multiplier/t}function Pc(d,e,t){return e*t/d.multiplier}function Bd(d,e){let[t,n]=Td(e),o=t,r=n,i=0,s=e;for(;o<r;){if(i=Math.floor((r+o)/2),i<=0||i>to-2)return[i,i,!1];let u=d.DataElement[i].x,a=d.DataElement[i-1].x,c=d.DataElement[i+1].x;if(s===u)return[i,i,!0];if(s===a)return[i-1,i-1,!0];if(s===c)return[i+1,i+1,!0];if(s<a)r=i-1;else{if(s>a&&s<u)return[i-1,i,!0];if(s>u&&s<c)return[i,i+1,!0];o=i+1}}return[i,i,!1]}function xd(d,e){let[t,n]=hd(e),o=t,r=n,i=0,s=e;for(;o<=r;){if(i=Math.floor((r+o)/2),i<=0||i>=to-2)return[i,i,!1];let u=d.DataElement[i].y,a=d.DataElement[i-1].y,c=d.DataElement[i+1].y;if(s===u)return[i,i,!0];if(s===a)return[i-1,i-1,!0];if(s===c)return[i+1,i+1,!0];if(s<c)o=i+1;else{if(s<a&&s>u)return[i-1,i,!0];if(s<u&&s>c)return[i,i+1,!0];r=i-1}}return[i,i,!1]}function Ac(d,e,t,n){let o=n?e+t:e-t,[r,i,s]=Bd(d,o);if(!s)return[0,0,!1,s];if(r===i)return[d.DataElement[i].price,d.DataElement[i].y,!1,s];{let u=d.DataElement[r].x,a=d.DataElement[i].x,c=d.DataElement[r].price,l=d.DataElement[i].price,m=d.DataElement[r].y,p=d.DataElement[i].y;if(e>=u&&e<=a)return n?[l,p,!0,s]:[c,m,!0,s];{let f,y;return n?(f=c+(l-c)*(e-u)/(a-u),y=m-(o-u)*d.multiplier/l):(f=c+(l-c)*(e-u)/(a-u),y=p+(a-o)*d.multiplier/c),[f,y,!1,s]}}}function Sd(d,e,t,n){let o=n?e-t:e+t,[r,i,s]=xd(d,o);if(!s)return[0,0,!1,s];if(r===i)return[d.DataElement[i].price,d.DataElement[i].x,!1,s];{let u=d.DataElement[r].x,a=d.DataElement[i].x,c=d.DataElement[r].price,l=d.DataElement[i].price,m=d.DataElement[r].y,p=d.DataElement[i].y;if(e>=p&&e<=m)return n?[l,a,!0,s]:[c,u,!0,s];{let f,y;return n?(f=c+(l-c)*(m-e)/(m-p),y=u+l*(m-o)/d.multiplier):(f=c+(l-c)*(m-e)/(m-p),y=a-c*(o-p)/d.multiplier),[f,y,!1,s]}}}function Kd(d,e){let t=Ac(d,e,0,!1);return t[3]?t[0]:0}function kc(d,e,t,n){let o=ea(d,e,t),r=eo(d,e,o),i=eo(d,t,o),s=eo(d,n,o),u=!0,[a,c,l,m]=Ac(d,r,s,u);if(!m)return 0;if(l)return n*d.multiplier/a;{let p=i-c;return Pc(d,p,o)}}function wc(d,e,t,n){let o=ea(d,e,t),r=eo(d,e,o),i=eo(d,t,o),s=eo(d,n,o),u=!1,[a,c,l,m]=Sd(d,i,s,u);if(!m)return 0;if(l)return n*a/d.multiplier;{let p=r-c;return Pc(d,p,o)}}function Cd(d){let e=kd.decode(d);return{accountType:e.accountType.toNumber(),status:e.status.toNumber(),multiplier:e.multiplier.toNumber(),validDataCount:e.validDataCount.toNumber(),DataElement:e.DataElement.map(t=>({x:t.x.toNumber(),y:t.y.toNumber(),price:t.price.toNumber()}))}}function Tc(d,e,t,n){let o=Kd(d,eo(d,e,ea(d,e,t)))/d.multiplier;return n?o:1/o}var yi=class{constructor({connection:e,modelDataPubKey:t=qn}){this._layoutData={accountType:0,status:0,multiplier:0,validDataCount:0,DataElement:[]};this.connection=e,this.modelDataPubKey=t}get stableModelData(){return this._layoutData}async initStableModelLayout(){if(this._layoutData.validDataCount===0&&this.connection){let e=await this.connection.getAccountInfo(this.modelDataPubKey);e&&(this._layoutData=Cd(e==null?void 0:e.data))}}};import{PublicKey as Od}from"@solana/web3.js";import Ch from"bn.js";import wr from"decimal.js";import{TOKEN_PROGRAM_ID as Nd}from"@solana/spl-token";import{PublicKey as Rd}from"@solana/web3.js";var Ld=ge("Raydium_liquidity_serum");function hc({programId:d,marketId:e}){let t=[e.toBuffer()],n=0,o;for(;n<100;){try{let r=t.concat(Buffer.from([n]),Buffer.alloc(7));o=Rd.createProgramAddressSync(r,d)}catch(r){if(r instanceof TypeError)throw r;n++;continue}return{publicKey:o,nonce:n}}throw Ld.logWithError("unable to find a viable program address nonce","params",{programId:d,marketId:e}),new Error("unable to find a viable program address nonce")}function Tr({programId:d}){let{publicKey:e}=ce([Buffer.from("amm_config_account_seed","utf-8")],d);return e}function no({name:d,programId:e,marketId:t}){let{publicKey:n}=ce([e.toBuffer(),t.toBuffer(),Buffer.from(d,"utf-8")],e);return n}function Md({programId:d,marketId:e}){let{publicKey:t}=ce([d.toBuffer(),e.toBuffer(),Buffer.from("open_order_associated_seed","utf-8")],d);return t}function na({programId:d}){return ce([Buffer.from([97,109,109,32,97,117,116,104,111,114,105,116,121])],d)}function oa({version:d,marketVersion:e,marketId:t,baseMint:n,quoteMint:o,baseDecimals:r,quoteDecimals:i,programId:s,marketProgramId:u}){let a=no({name:"amm_associated_seed",programId:s,marketId:t}),c=no({name:"lp_mint_associated_seed",programId:s,marketId:t}),{publicKey:l,nonce:m}=na({programId:s}),p=no({name:"coin_vault_associated_seed",programId:s,marketId:t}),f=no({name:"pc_vault_associated_seed",programId:s,marketId:t}),y=no({name:"temp_lp_token_associated_seed",programId:s,marketId:t}),b=Md({programId:s,marketId:t}),g=no({name:"target_associated_seed",programId:s,marketId:t}),P=no({name:"withdraw_associated_seed",programId:s,marketId:t}),{publicKey:T}=hc({programId:u,marketId:t});return{id:a,baseMint:n,quoteMint:o,lpMint:c,baseDecimals:r,quoteDecimals:i,lpDecimals:r,version:d,programId:s,authority:l,nonce:m,baseVault:p,quoteVault:f,lpVault:y,openOrders:b,targetOrders:g,withdrawQueue:P,marketVersion:e,marketProgramId:u,marketId:t,marketAuthority:T,lookupTableAccount:Od.default,configId:Tr({programId:s})}}var ta={volume:0,volumeQuote:0,volumeFee:0,apr:0,feeApr:0,priceMin:0,priceMax:0,rewardApr:[]},hr=d=>{let e={},t=Nd.toBase58();return Object.keys(d).map(n=>{let o=d[n],[r,i]=[o.baseMint.toBase58(),o.quoteMint.toBase58()];e[n]={id:n,version:4,status:o.status.toNumber(),programId:o.programId.toBase58(),mintA:dt({address:r,programId:t,decimals:o.baseDecimal.toNumber()}),mintB:dt({address:i,programId:t,decimals:o.quoteDecimal.toNumber()}),rewardDefaultInfos:[],rewardDefaultPoolInfos:"Ecosystem",price:o.poolPrice.toNumber(),mintAmountA:new wr(o.mintAAmount.toString()).div(10**o.baseDecimal.toNumber()).toNumber(),mintAmountB:new wr(o.mintBAmount.toString()).div(10**o.quoteDecimal.toNumber()).toNumber(),baseReserve:o.baseReserve,quoteReserve:o.quoteReserve,feeRate:new wr(o.tradeFeeNumerator.toString()).div(o.tradeFeeDenominator.toString()).toNumber(),openTime:o.poolOpenTime.toString(),tvl:0,day:ta,week:ta,month:ta,pooltype:[],farmUpcomingCount:0,farmOngoingCount:0,farmFinishedCount:0,type:"Standard",marketId:o.marketId.toBase58(),configId:Tr({programId:o.programId}).toBase58(),lpPrice:0,lpAmount:new wr(o.lpReserve.toString()).div(10**Math.min(o.baseDecimal.toNumber(),o.quoteDecimal.toNumber())).toNumber(),lpMint:dt({address:o.lpMint.toBase58(),programId:t,decimals:Math.min(o.baseDecimal.toNumber(),o.quoteDecimal.toNumber())}),burnPercent:0}}),e};import ze from"bn.js";import Le from"decimal.js";import{PublicKey as bi}from"@solana/web3.js";import gi from"bn.js";import{TOKEN_PROGRAM_ID as Sc}from"@solana/spl-token";import{SystemProgram as oo,SYSVAR_RENT_PUBKEY as Fd,Transaction as Ic,TransactionInstruction as _d}from"@solana/web3.js";import{createInitializeAccountInstruction as Bc,TOKEN_PROGRAM_ID as xc}from"@solana/spl-token";function vd(d="accountFlags"){let e=new cr(d);return e.addBoolean("initialized"),e.addBoolean("market"),e.addBoolean("openOrders"),e.addBoolean("requestQueue"),e.addBoolean("eventQueue"),e.addBoolean("bids"),e.addBoolean("asks"),e}var ia=_([Te(5),vd("accountFlags"),M("ownAddress"),A("vaultSignerNonce"),M("baseMint"),M("quoteMint"),M("baseVault"),A("baseDepositsTotal"),A("baseFeesAccrued"),M("quoteVault"),A("quoteDepositsTotal"),A("quoteFeesAccrued"),A("quoteDustThreshold"),M("requestQueue"),M("eventQueue"),M("bids"),M("asks"),A("baseLotSize"),A("quoteLotSize"),A("feeRateBps"),A("referrerRebatesAccrued"),Te(7)]);function Vd({programId:d,marketInfo:e}){let t=_([V("version"),lt("instruction"),A("baseLotSize"),A("quoteLotSize"),St("feeRateBps"),A("vaultSignerNonce"),A("quoteDustThreshold")]),n=[{pubkey:e.id,isSigner:!1,isWritable:!0},{pubkey:e.requestQueue,isSigner:!1,isWritable:!0},{pubkey:e.eventQueue,isSigner:!1,isWritable:!0},{pubkey:e.bids,isSigner:!1,isWritable:!0},{pubkey:e.asks,isSigner:!1,isWritable:!0},{pubkey:e.baseVault,isSigner:!1,isWritable:!0},{pubkey:e.quoteVault,isSigner:!1,isWritable:!0},{pubkey:e.baseMint,isSigner:!1,isWritable:!1},{pubkey:e.quoteMint,isSigner:!1,isWritable:!1},{pubkey:e.authority?e.quoteMint:Fd,isSigner:!1,isWritable:!1}].concat(e.authority?{pubkey:e.authority,isSigner:!1,isWritable:!1}:[]).concat(e.authority&&e.pruneAuthority?{pubkey:e.pruneAuthority,isSigner:!1,isWritable:!1}:[]),o=Buffer.alloc(t.span);return t.encode({version:0,instruction:0,baseLotSize:e.baseLotSize,quoteLotSize:e.quoteLotSize,feeRateBps:e.feeRateBps,vaultSignerNonce:e.vaultSignerNonce,quoteDustThreshold:e.quoteDustThreshold},o),new _d({keys:n,programId:d,data:o})}async function Ir({connection:d,wallet:e,marketInfo:t}){var i,s,u,a,c,l,m,p;let n=new Ic,o=await d.getMinimumBalanceForRentExemption(165);n.add(oo.createAccountWithSeed({fromPubkey:e,basePubkey:e,seed:t.baseVault.seed,newAccountPubkey:t.baseVault.publicKey,lamports:o,space:165,programId:xc}),oo.createAccountWithSeed({fromPubkey:e,basePubkey:e,seed:t.quoteVault.seed,newAccountPubkey:t.quoteVault.publicKey,lamports:o,space:165,programId:xc}),Bc(t.baseVault.publicKey,t.baseMint,t.vaultOwner),Bc(t.quoteVault.publicKey,t.quoteMint,t.vaultOwner),oo.createAccountWithSeed({fromPubkey:e,basePubkey:e,seed:t.id.seed,newAccountPubkey:t.id.publicKey,lamports:await d.getMinimumBalanceForRentExemption(ia.span),space:ia.span,programId:t.programId}));let r=new Ic;return r.add(oo.createAccountWithSeed({fromPubkey:e,basePubkey:e,seed:t.requestQueue.seed,newAccountPubkey:t.requestQueue.publicKey,lamports:t.lowestFeeMarket?6208320:await d.getMinimumBalanceForRentExemption((i=t.requestQueueSpace)!=null?i:5120+12),space:t.lowestFeeMarket?764:(s=t.requestQueueSpace)!=null?s:5120+12,programId:t.programId}),oo.createAccountWithSeed({fromPubkey:e,basePubkey:e,seed:t.eventQueue.seed,newAccountPubkey:t.eventQueue.publicKey,lamports:t.lowestFeeMarket?79594560:await d.getMinimumBalanceForRentExemption((u=t.eventQueueSpace)!=null?u:262144+12),space:t.lowestFeeMarket?11308:(a=t.eventQueueSpace)!=null?a:262144+12,programId:t.programId}),oo.createAccountWithSeed({fromPubkey:e,basePubkey:e,seed:t.bids.seed,newAccountPubkey:t.bids.publicKey,lamports:t.lowestFeeMarket?101977920:await d.getMinimumBalanceForRentExemption((c=t.orderbookQueueSpace)!=null?c:65536+12),space:t.lowestFeeMarket?14524:(l=t.orderbookQueueSpace)!=null?l:65536+12,programId:t.programId}),oo.createAccountWithSeed({fromPubkey:e,basePubkey:e,seed:t.asks.seed,newAccountPubkey:t.asks.publicKey,lamports:t.lowestFeeMarket?101977920:await d.getMinimumBalanceForRentExemption((m=t.orderbookQueueSpace)!=null?m:65536+12),space:t.lowestFeeMarket?14524:(p=t.orderbookQueueSpace)!=null?p:65536+12,programId:t.programId}),Vd({programId:t.programId,marketInfo:{id:t.id.publicKey,requestQueue:t.requestQueue.publicKey,eventQueue:t.eventQueue.publicKey,bids:t.bids.publicKey,asks:t.asks.publicKey,baseVault:t.baseVault.publicKey,quoteVault:t.quoteVault.publicKey,baseMint:t.baseMint,quoteMint:t.quoteMint,baseLotSize:t.baseLotSize,quoteLotSize:t.quoteLotSize,feeRateBps:t.feeRateBps,vaultSignerNonce:t.vaultSignerNonce,quoteDustThreshold:t.quoteDustThreshold}})),[{transaction:n,signer:[],instructionTypes:[U.CreateAccount,U.CreateAccount,U.InitAccount,U.InitAccount]},{transaction:r,signer:[],instructionTypes:[U.CreateAccount,U.CreateAccount,U.CreateAccount,U.CreateAccount,U.CreateAccount,U.InitMarket]}]}var So=class extends _e{async create({baseInfo:e,quoteInfo:t,lotSize:n,tickSize:o,dexProgramId:r,requestQueueSpace:i,eventQueueSpace:s,orderbookQueueSpace:u,lowestFeeMarket:a,assignSeed:c,txVersion:l,computeBudgetConfig:m,txTipConfig:p,feePayer:f}){let y=this.scope.ownerPubKey,b=c?`${e.mint.toBase58().slice(0,10)}-${t.mint.toBase58().slice(0,10)}-${c}`:void 0,g=Ye({fromPublicKey:y,programId:r,assignSeed:b&&`${b}-market`}),P=Ye({fromPublicKey:y,programId:r,assignSeed:b&&`${b}-request`}),T=Ye({fromPublicKey:y,programId:r,assignSeed:b&&`${b}-event`}),h=Ye({fromPublicKey:y,programId:r,assignSeed:b&&`${b}-bids`}),w=Ye({fromPublicKey:y,programId:r,assignSeed:b&&`${b}-asks`}),k=Ye({fromPublicKey:y,programId:Sc,assignSeed:b&&`${b}-baseVault`}),x=Ye({fromPublicKey:y,programId:Sc,assignSeed:b&&`${b}-quoteVault`}),B=0,K=new gi(100);function I(){let G=new gi(0);for(;;)try{return{vaultOwner:bi.createProgramAddressSync([g.publicKey.toBuffer(),G.toArrayLike(Buffer,"le",8)],r),vaultSignerNonce:G}}catch{if(G.iaddn(1),G.gt(new gi(25555)))throw Error("find vault owner error")}}let{vaultOwner:R,vaultSignerNonce:C}=I(),N=new gi(Math.round(10**e.decimals*n)),L=new gi(Math.round(n*10**t.decimals*o));if(N.eq(kt))throw Error("lot size is too small");if(L.eq(kt))throw Error("tick size or lot size is too small");let O=await Ir({connection:this.scope.connection,wallet:this.scope.ownerPubKey,marketInfo:{programId:r,id:g,baseMint:e.mint,quoteMint:t.mint,baseVault:k,quoteVault:x,vaultOwner:R,requestQueue:P,eventQueue:T,bids:h,asks:w,feeRateBps:B,quoteDustThreshold:K,vaultSignerNonce:C,baseLotSize:N,quoteLotSize:L,requestQueueSpace:i,eventQueueSpace:s,orderbookQueueSpace:u,lowestFeeMarket:a}}),F=this.createTxBuilder(f);F.addInstruction({instructions:O[0].transaction.instructions,signers:O[0].signer});for await(let G of O.slice(1,O.length))F.addInstruction({instructions:G.transaction.instructions,signers:G.signer,instructionTypes:G.instructionTypes});return l===0?F.sizeCheckBuildV0({computeBudgetConfig:m,address:{marketId:g.publicKey,requestQueue:P.publicKey,eventQueue:T.publicKey,bids:h.publicKey,asks:w.publicKey,baseVault:k.publicKey,quoteVault:x.publicKey,baseMint:new bi(e.mint),quoteMint:new bi(t.mint)}}):F.sizeCheckBuild({computeBudgetConfig:m,address:{marketId:g.publicKey,requestQueue:P.publicKey,eventQueue:T.publicKey,bids:h.publicKey,asks:w.publicKey,baseVault:k.publicKey,quoteVault:x.publicKey,baseMint:new bi(e.mint),quoteMint:new bi(t.mint)}})}};var Pi=class extends _e{constructor(t){super(t);this.stableLayout=new yi({connection:this.scope.connection,modelDataPubKey:this.scope.cluster==="mainnet"?void 0:dn.MODEL_DATA_PUBKEY})}async initLayout(){await this.stableLayout.initStableModelLayout()}async load(){this.checkDisabled()}computePairAmount({poolInfo:t,amount:n,slippage:o,baseIn:r}){let i=new ze(new Le(n).mul(10**t[r?"mintA":"mintB"].decimals).toFixed(0)),s=Pr(t[r?"mintB":"mintA"]),[u,a]=[new ze(new Le(t.mintAmountA).mul(10**t.mintA.decimals).toString()),new ze(new Le(t.mintAmountB).mul(10**t.mintB.decimals).toString())],c=new ze(new Le(t.lpAmount).mul(10**t.lpMint.decimals).toFixed(0,Le.ROUND_DOWN));this.logDebug("baseReserve:",u.toString(),"quoteReserve:",a.toString()),this.logDebug("tokenIn:",r?t.mintA.symbol:t.mintB.symbol,"amountIn:",i.toString(),"anotherToken:",r?t.mintB.symbol:t.mintA.symbol,"slippage:",`${o.toSignificant()}%`,"baseReserve",u.toString(),"quoteReserve",a.toString());let l=r?"base":"quote";this.logDebug("input side:",l);let m=kt;i.isZero()||(m=l==="base"?Yi(i.mul(a),u):Yi(i.mul(u),a)),this.logDebug("amountRaw:",m.toString(),"lpAmount:",c.toString());let p=Yi(i.mul(c),l==="base"?u:a);this.logDebug("liquidity:",p.toString());let f=new tt(new ze(1)).add(o),y=new tt(new ze(1)).sub(o),b=f.mul(m).quotient,g=y.mul(m).quotient,P=new Se(s,m),T=new Se(s,b),h=new Se(s,g);return this.logDebug("anotherAmount:",P.toFixed(),"maxAnotherAmount:",T.toFixed()),{anotherAmount:P,maxAnotherAmount:T,minAnotherAmount:h,liquidity:p}}async getAmmPoolKeys(t){return(await this.scope.api.fetchPoolKeysById({idList:[t]}))[0]}async addLiquidity(t){let{poolInfo:n,poolKeys:o,amountInA:r,amountInB:i,otherAmountMin:s,fixedSide:u,config:a,txVersion:c,computeBudgetConfig:l,txTipConfig:m,feePayer:p}=t;this.scope.availability.addStandardPosition===!1&&this.logAndCreateError("add liquidity feature disabled in your region"),this.logDebug("amountInA:",r,"amountInB:",i),(r.isZero()||i.isZero())&&this.logAndCreateError("amounts must greater than zero","amountInA & amountInB",{amountInA:r.toFixed(),amountInB:i.toFixed()});let{account:f}=this.scope,{bypassAssociatedCheck:y,checkCreateATAOwner:b}=v({bypassAssociatedCheck:!1,checkCreateATAOwner:!1},a),[g,P]=[r.token,i.token],T=await f.getCreatedTokenAccount({mint:g.mint,associatedOnly:!1}),h=await f.getCreatedTokenAccount({mint:P.mint,associatedOnly:!1});!T&&!h&&this.logAndCreateError("cannot found target token accounts","tokenAccounts",f.tokenAccounts);let w=await f.getCreatedTokenAccount({mint:new je(n.lpMint.address)}),k=[g,P],x=[T,h],B=[r.raw,i.raw],K=r.token.mint.toBase58()===n.mintA.address?"base":"quote",I="base";["quote","base"].includes(K)||this.logAndCreateError("invalid fixedSide","fixedSide",u),K==="quote"?(k.reverse(),x.reverse(),B.reverse(),I=u==="a"?"quote":"base"):K==="base"&&(I=u==="a"?"base":"quote");let[R,C]=k,[N,L]=x,[O,F]=B,G=o!=null?o:await this.getAmmPoolKeys(n.id),z=this.createTxBuilder(p),J=await f.handleTokenAccount({side:"in",amount:O,mint:R.mint,tokenAccount:N,bypassAssociatedCheck:y,checkCreateATAOwner:b}),{tokenAccount:$}=J,re=ve(J,["tokenAccount"]);z.addInstruction(re);let he=await f.handleTokenAccount({side:"in",amount:F,mint:C.mint,tokenAccount:L,bypassAssociatedCheck:y,checkCreateATAOwner:b}),{tokenAccount:te}=he,ae=ve(he,["tokenAccount"]);z.addInstruction(ae);let de=await f.handleTokenAccount({side:"out",amount:0,mint:new je(n.lpMint.address),tokenAccount:w,bypassAssociatedCheck:y,checkCreateATAOwner:b}),{tokenAccount:ye}=de,me=ve(de,["tokenAccount"]);return z.addInstruction(me),z.addInstruction({instructions:[gc({poolInfo:n,poolKeys:G,userKeys:{baseTokenAccount:$,quoteTokenAccount:te,lpTokenAccount:ye,owner:this.scope.ownerPubKey},baseAmountIn:O,quoteAmountIn:F,otherAmountMin:s.raw,fixedSide:I})],instructionTypes:[n.pooltype.includes("StablePool")?U.AmmV5AddLiquidity:U.AmmV4AddLiquidity],lookupTableAddress:G.lookupTableAccount?[G.lookupTableAccount]:[]}),z.addCustomComputeBudget(l),z.addTipInstruction(m),c===0?await z.buildV0():z.build()}async removeLiquidity(t){this.scope.availability.removeStandardPosition===!1&&this.logAndCreateError("remove liquidity feature disabled in your region");let{poolInfo:n,poolKeys:o,lpAmount:r,baseAmountMin:i,quoteAmountMin:s,config:u,txVersion:a,computeBudgetConfig:c,txTipConfig:l,feePayer:m}=t,p=o!=null?o:await this.getAmmPoolKeys(n.id),[f,y,b]=[new je(n.mintA.address),new je(n.mintB.address),new je(n.lpMint.address)];this.logDebug("lpAmount:",r),this.logDebug("baseAmountMin:",i),this.logDebug("quoteAmountMin:",s),r.isZero()&&this.logAndCreateError("amount must greater than zero","lpAmount",r.toString());let{account:g}=this.scope,P=await g.getCreatedTokenAccount({mint:b,associatedOnly:!1});P||this.logAndCreateError("cannot found lpTokenAccount","tokenAccounts",g.tokenAccounts);let T=await g.getCreatedTokenAccount({mint:f}),h=await g.getCreatedTokenAccount({mint:y}),w=this.createTxBuilder(m),{bypassAssociatedCheck:k,checkCreateATAOwner:x}=v({bypassAssociatedCheck:!1,checkCreateATAOwner:!1},u),C=await g.handleTokenAccount({side:"out",amount:0,mint:f,tokenAccount:T,bypassAssociatedCheck:k,checkCreateATAOwner:x}),{tokenAccount:B}=C,K=ve(C,["tokenAccount"]);w.addInstruction(K);let N=await g.handleTokenAccount({side:"out",amount:0,mint:y,tokenAccount:h,bypassAssociatedCheck:k,checkCreateATAOwner:x}),{tokenAccount:I}=N,R=ve(N,["tokenAccount"]);return w.addInstruction(R),w.addInstruction({instructions:[Zs({poolInfo:n,poolKeys:p,userKeys:{lpTokenAccount:P,baseTokenAccount:B,quoteTokenAccount:I,owner:this.scope.ownerPubKey},lpAmount:r,baseAmountMin:i,quoteAmountMin:s})],lookupTableAddress:p.lookupTableAccount?[p.lookupTableAccount]:[],instructionTypes:[n.pooltype.includes("StablePool")?U.AmmV5RemoveLiquidity:U.AmmV4RemoveLiquidity]}),w.addCustomComputeBudget(c),w.addTipInstruction(l),a===0?await w.buildV0():w.build()}async removeAllLpAndCreateClmmPosition({poolInfo:t,clmmPoolInfo:n,removeLpAmount:o,createPositionInfo:r,farmInfo:i,userFarmLpAmount:s,base:u,computeBudgetConfig:a,payer:c,userAuxiliaryLedgers:l,tokenProgram:m=_n,checkCreateATAOwner:p=!0,getEphemeralSigners:f,txVersion:y,feePayer:b}){if((this.scope.availability.removeStandardPosition===!1||this.scope.availability.createConcentratedPosition===!1)&&this.logAndCreateError("remove liquidity or create position feature disabled in your region"),!(t.mintA.address===n.mintA.address||t.mintA.address===n.mintB.address)||!(t.mintB.address===n.mintA.address||t.mintB.address===n.mintB.address))throw Error("mint check error");let g=this.createTxBuilder(b),P={};for(let G of this.scope.account.tokenAccountRawInfos)(P[G.accountInfo.mint.toString()]===void 0||Z(this.scope.ownerPubKey,G.accountInfo.mint,_n).publicKey.equals(G.pubkey))&&(P[G.accountInfo.mint.toString()]=G.pubkey);let T=P[t.lpMint.address];if(T===void 0)throw Error("find lp account error in trade accounts");let h=o.add(s!=null?s:new ze(0)),w=t.mintA.address===De.WSOL.mint.toString(),k=t.mintB.address===De.WSOL.mint.toString(),{account:x,instructionParams:B}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:_n,mint:new je(t.mintA.address),owner:this.scope.ownerPubKey,createInfo:w?{payer:this.scope.ownerPubKey}:void 0,skipCloseAccount:!w,notUseTokenAccount:w,associatedOnly:!0,checkCreateATAOwner:p});if(g.addInstruction(B||{}),x===void 0)throw new Error("base token account not found");let{account:K,instructionParams:I}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:_n,mint:new je(t.mintB.address),owner:this.scope.ownerPubKey,createInfo:k?{payer:this.scope.ownerPubKey,amount:0}:void 0,skipCloseAccount:!k,notUseTokenAccount:k,associatedOnly:!0,checkCreateATAOwner:p});if(g.addInstruction(I||{}),K===void 0)throw new Error("quote token account not found");if(P[t.mintA.address]=x,P[t.mintB.address]=K,i!==void 0&&!(s!=null&&s.isZero())){let G=Ft[i.programId],z=_t({programId:new je(i.programId),poolId:new je(i.id),owner:this.scope.ownerPubKey,version:G}),$,re=await this.scope.connection.getAccountInfo(z);if(re&&($=$o(G).decode(re.data)),G!==6&&!$){let{instruction:de,instructionType:fe}=Jo({id:new je(i.id),programId:new je(i.programId),version:G,ledger:z,owner:this.scope.ownerPubKey});g.addInstruction({instructions:[de],instructionTypes:[fe]})}let te=[];for(let de of i.rewardInfos){let fe=de.mint.address===De.WSOL.mint.toString();if(P[de.mint.address])te.push(P[de.mint.address]);else{let{account:Qt,instructionParams:on}=await this.scope.account.getOrCreateTokenAccount({mint:new je(de.mint.address),tokenProgram:m,owner:this.scope.ownerPubKey,skipCloseAccount:!fe,createInfo:{payer:c||this.scope.ownerPubKey},associatedOnly:!0,checkCreateATAOwner:p});Qt||this.logAndCreateError("farm reward account not found:",de.mint.address),on&&g.addInstruction(on),te.push(Qt)}}let ae=(await this.scope.api.fetchFarmKeysById({ids:i.id}))[0],ye={userAuxiliaryLedgers:l,amount:s,owner:this.scope.ownerPubKey,farmInfo:i,farmKeys:ae,lpAccount:T,rewardAccounts:te},me=Ft[i.programId],J=me===6?ei(ye):me===5?ti(ye):ni(ye),he={3:U.FarmV3Withdraw,5:U.FarmV5Withdraw,6:U.FarmV6Withdraw};g.addInstruction({instructions:[J],instructionTypes:[he[me]]})}let R=await this.getAmmPoolKeys(t.id),C=Zs({poolInfo:t,poolKeys:R,userKeys:{lpTokenAccount:T,baseTokenAccount:x,quoteTokenAccount:K,owner:this.scope.ownerPubKey},lpAmount:h,baseAmountMin:0,quoteAmountMin:0});g.addInstruction({instructions:[C],instructionTypes:[t.pooltype.includes("StablePool")?U.AmmV5RemoveLiquidity:U.AmmV4RemoveLiquidity],lookupTableAddress:R.lookupTableAccount?[R.lookupTableAccount]:[]});let[N,L]=t.mintA.address===n.mintA.address?[x,K]:[K,x],O=await this.scope.clmm.getClmmPoolKeys(n.id),F=await Re.openPositionFromBaseInstructions(D(v({poolInfo:n,poolKeys:O,ownerInfo:{feePayer:this.scope.ownerPubKey,wallet:this.scope.ownerPubKey,tokenAccountA:N,tokenAccountB:L},withMetadata:"create"},r),{base:u,getEphemeralSigners:f}));return g.addInstruction({instructions:[...F.instructions],signers:F.signers,instructionTypes:[...F.instructionTypes],lookupTableAddress:O.lookupTableAccount?[O.lookupTableAccount]:[]}),y===0?g.sizeCheckBuildV0({computeBudgetConfig:a}):g.sizeCheckBuild({computeBudgetConfig:a})}async createPoolV4({programId:t,marketInfo:n,baseMintInfo:o,quoteMintInfo:r,baseAmount:i,quoteAmount:s,startTime:u,ownerInfo:a,associatedOnly:c=!1,checkCreateATAOwner:l=!1,tokenProgram:m,txVersion:p,feeDestinationId:f,computeBudgetConfig:y,txTipConfig:b,feePayer:g}){var L;let P=a.feePayer||((L=this.scope.owner)==null?void 0:L.publicKey),T=a.useSOLBalance&&o.mint.equals(Br),h=a.useSOLBalance&&r.mint.equals(Br),w=this.createTxBuilder(g),{account:k,instructionParams:x}=await this.scope.account.getOrCreateTokenAccount({mint:o.mint,owner:this.scope.ownerPubKey,createInfo:T?{payer:P,amount:i}:void 0,notUseTokenAccount:T,skipCloseAccount:!T,associatedOnly:T?!1:c,checkCreateATAOwner:l});w.addInstruction(x||{});let{account:B,instructionParams:K}=await this.scope.account.getOrCreateTokenAccount({mint:r.mint,owner:this.scope.ownerPubKey,createInfo:h?{payer:P,amount:s}:void 0,notUseTokenAccount:h,skipCloseAccount:!h,associatedOnly:h?!1:c,checkCreateATAOwner:l});if(w.addInstruction(K||{}),k===void 0||B===void 0)throw Error("you don't has some token account");let I=oa({version:4,marketVersion:3,marketId:n.marketId,baseMint:o.mint,quoteMint:r.mint,baseDecimals:o.decimals,quoteDecimals:r.decimals,programId:t,marketProgramId:n.programId}),R={programId:t,ammId:I.id,ammAuthority:I.authority,ammOpenOrders:I.openOrders,lpMint:I.lpMint,coinMint:I.baseMint,pcMint:I.quoteMint,coinVault:I.baseVault,pcVault:I.quoteVault,withdrawQueue:I.withdrawQueue,ammTargetOrders:I.targetOrders,poolTempLp:I.lpVault,marketProgramId:I.marketProgramId,marketId:I.marketId,ammConfigId:I.configId,feeDestinationId:f},{instruction:C,instructionType:N}=Js(D(v({},R),{userWallet:this.scope.ownerPubKey,userCoinVault:k,userPcVault:B,userLpVault:Z(this.scope.ownerPubKey,I.lpMint,m).publicKey,nonce:I.nonce,openTime:u,coinAmount:i,pcAmount:s}));return w.addInstruction({instructions:[C],instructionTypes:[N]}),w.addCustomComputeBudget(y),w.addTipInstruction(b),w.versionBuild({txVersion:p,extInfo:{address:R}})}async createMarketAndPoolV4({programId:t=Hi,marketProgram:n=ru,feeDestinationId:o=au,tokenProgram:r,baseMintInfo:i,quoteMintInfo:s,baseAmount:u,quoteAmount:a,startTime:c,ownerInfo:l,lowestFeeMarket:m,assignSeed:p,associatedOnly:f=!1,checkCreateATAOwner:y=!1,lotSize:b=1,tickSize:g=.01,txVersion:P,computeBudgetConfig:T,txTipConfig:h,feePayer:w}){var yo,bo,Ur;let k=this.scope.ownerPubKey,x=l.feePayer||((yo=this.scope.owner)==null?void 0:yo.publicKey),B=l.useSOLBalance&&i.mint.equals(Br),K=l.useSOLBalance&&s.mint.equals(Br),I=p?`${i.mint.toBase58().slice(0,7)}-${s.mint.toBase58().slice(0,7)}-${p}`:void 0,R=Ye({fromPublicKey:k,programId:n,assignSeed:I&&`${I}-market`}),C=Ye({fromPublicKey:k,programId:n,assignSeed:I&&`${I}-request`}),N=Ye({fromPublicKey:k,programId:n,assignSeed:I&&`${I}-event`}),L=Ye({fromPublicKey:k,programId:n,assignSeed:I&&`${I}-bids`}),O=Ye({fromPublicKey:k,programId:n,assignSeed:I&&`${I}-asks`}),F=Ye({fromPublicKey:k,programId:_n,assignSeed:I&&`${I}-baseVault`}),G=Ye({fromPublicKey:k,programId:_n,assignSeed:I&&`${I}-quoteVault`}),z=0,$=new ze(100);function re(){let Bt=new ze(0);for(;;)try{return{vaultOwner:je.createProgramAddressSync([R.publicKey.toBuffer(),Bt.toArrayLike(Buffer,"le",8)],n),vaultSignerNonce:Bt}}catch{if(Bt.iaddn(1),Bt.gt(new ze(25555)))throw Error("find vault owner error")}}let{vaultOwner:te,vaultSignerNonce:ae}=re(),ye=new ze(Math.round(10**i.decimals*b)),me=new ze(Math.round(b*10**s.decimals*g));if(ye.eq(kt))throw Error("lot size is too small");if(me.eq(kt))throw Error("tick size or lot size is too small");let J=await Ir({connection:this.scope.connection,wallet:this.scope.ownerPubKey,marketInfo:{programId:n,vaultOwner:te,baseMint:i.mint,quoteMint:s.mint,id:R,baseVault:F,quoteVault:G,requestQueue:C,eventQueue:N,bids:L,asks:O,feeRateBps:z,quoteDustThreshold:$,vaultSignerNonce:ae,baseLotSize:ye,quoteLotSize:me,lowestFeeMarket:m}}),he=this.createTxBuilder(w);he.addInstruction({instructions:J[0].transaction.instructions,signers:J[0].signer});for await(let Bt of J.slice(1,J.length))he.addInstruction({instructions:Bt.transaction.instructions,signers:Bt.signer,instructionTypes:Bt.instructionTypes});let{account:de,instructionParams:fe}=await this.scope.account.getOrCreateTokenAccount({mint:i.mint,owner:this.scope.ownerPubKey,createInfo:B?{payer:x,amount:u}:void 0,notUseTokenAccount:B,skipCloseAccount:!B,associatedOnly:B?!1:f,checkCreateATAOwner:y,assignSeed:B&&I?`${I}-wsol`:void 0});he.addInstruction(fe||{});let{account:Qt,instructionParams:on}=await this.scope.account.getOrCreateTokenAccount({mint:s.mint,owner:this.scope.ownerPubKey,createInfo:K?{payer:x,amount:a}:void 0,notUseTokenAccount:K,skipCloseAccount:!K,associatedOnly:K?!1:f,checkCreateATAOwner:y,assignSeed:K&&I?`${I}-wsol`:void 0});if(he.addInstruction(on||{}),de===void 0)throw Error("you don't has base token account");if(Qt===void 0)throw Error("you don't has quote token account");let Oe=oa({version:4,marketVersion:3,marketId:R.publicKey,baseMint:i.mint,quoteMint:s.mint,baseDecimals:i.decimals,quoteDecimals:s.decimals,programId:t,marketProgramId:n}),No={programId:t,ammId:Oe.id,ammAuthority:Oe.authority,ammOpenOrders:Oe.openOrders,lpMint:Oe.lpMint,coinMint:Oe.baseMint,pcMint:Oe.quoteMint,coinVault:Oe.baseVault,pcVault:Oe.quoteVault,withdrawQueue:Oe.withdrawQueue,ammTargetOrders:Oe.targetOrders,poolTempLp:Oe.lpVault,marketProgramId:Oe.marketProgramId,marketId:Oe.marketId,ammConfigId:Oe.configId,feeDestinationId:o},{instruction:qr,instructionType:Mo}=Js(D(v({},No),{userWallet:this.scope.ownerPubKey,userCoinVault:de,userPcVault:Qt,userLpVault:Z(this.scope.ownerPubKey,Oe.lpMint,r).publicKey,nonce:Oe.nonce,openTime:c,coinAmount:u,pcAmount:a}));he.addInstruction({instructions:[qr],instructionTypes:[Mo]});let vt=B||K?[((bo=fe==null?void 0:fe.instructions)==null?void 0:bo[0])||((Ur=on==null?void 0:on.instructions)==null?void 0:Ur[0])].filter(Bt=>!!Bt):void 0;return P===0?he.sizeCheckBuildV0({computeBudgetConfig:T,splitIns:vt,address:v({requestQueue:C.publicKey,eventQueue:N.publicKey,bids:L.publicKey,asks:O.publicKey,baseVault:F.publicKey,quoteVault:G.publicKey,baseMint:new je(i.mint),quoteMint:new je(s.mint)},No)}):he.sizeCheckBuild({computeBudgetConfig:T,splitIns:vt,address:v({requestQueue:C.publicKey,eventQueue:N.publicKey,bids:L.publicKey,asks:O.publicKey,baseVault:F.publicKey,quoteVault:G.publicKey,baseMint:new je(i.mint),quoteMint:new je(s.mint)},No)})}async getCreatePoolFee({programId:t}){let n=Tr({programId:t}),o=await this.scope.connection.getAccountInfo(n,{dataSlice:{offset:536,length:8}});if(o===null)throw Error("get config account error");return yc.decode(o.data).fee}computeAmountOut({poolInfo:t,amountIn:n,mintIn:o,mintOut:r,slippage:i}){let[s,u]=[o.toString(),r.toString()];if(s!==t.mintA.address&&s!==t.mintB.address)throw new Error("toke not match");if(u!==t.mintA.address&&u!==t.mintB.address)throw new Error("toke not match");let{baseReserve:a,quoteReserve:c}=t,l=[a,c],m=[t.mintA.decimals,t.mintB.decimals],p=s==t.mintA.address?"base":"quote";p==="quote"&&(l.reverse(),m.reverse());let[f,y]=l,[b,g]=m,P=t.version===4,T;if(P)T=new Le(y.toString()).div(10**g).div(new Le(f.toString()).div(10**b));else{let N=Tc(this.stableLayout.stableModelData,a.toNumber(),c.toNumber(),!1);p==="quote"?T=new Le(1e6).div(N*1e6):T=new Le(N*1e6).div(1e6)}let h=n,w=new ze(0),k=new ze(0);if(!h.isZero())if(P){k=Cn(h.mul(Ys),Ar);let N=h.sub(k),L=f.add(N);w=y.mul(N).div(L)}else{k=h.mul(new ze(2)).div(new ze(1e4));let N=h.sub(k);p==="quote"?w=new ze(kc(this.stableLayout.stableModelData,c.toNumber(),a.toNumber(),N.toNumber())):w=new ze(wc(this.stableLayout.stableModelData,c.toNumber(),a.toNumber(),N.toNumber()))}let x=new ze(new Le(w.toString()).mul(1-i).toFixed(0)),B=w,K=x,I=new Le(w.toString()).div(new Le(h.sub(k).toString()).toFixed(0));!h.isZero()&&!w.isZero()&&(I=new Le(w.toString()).div(10**g).div(new Le(h.sub(k).toString()).div(10**b)));let R=T.sub(I).div(T).mul(100);return{amountOut:B,minAmountOut:K,currentPrice:T,executionPrice:I,priceImpact:R,fee:k}}computeAmountIn({poolInfo:t,amountOut:n,mintIn:o,mintOut:r,slippage:i}){let{baseReserve:s,quoteReserve:u}=t;o.toString()!==t.mintA.address&&o.toString()!==t.mintB.address&&this.logAndCreateError("mintIn does not match pool"),r.toString()!==t.mintA.address&&r.toString()!==t.mintB.address&&this.logAndCreateError("mintOut does not match pool"),this.logDebug("baseReserve:",s.toString()),this.logDebug("quoteReserve:",u.toString());let a=o.toString()===t.mintA.address,[c,l]=a?[t.mintA,t.mintB]:[t.mintB,t.mintA];this.logDebug("currencyOut:",l.symbol||l.address),this.logDebug("amountOut:",new Le(n.toString()).div(10**l.decimals).toDecimalPlaces(l.decimals).toString(),c.symbol||c.address),this.logDebug("slippage:",`${i*100}%`);let m=[s,u],p=a?"quote":"base";p==="base"&&m.reverse(),this.logDebug("output side:",p);let[f,y]=m,b=new Le(y.toString()).div(10**t[a?"mintB":"mintA"].decimals).div(new Le(f.toString()).div(10**t[a?"mintA":"mintB"].decimals));this.logDebug("currentPrice:",`1 ${c.symbol||c.address} \u2248 ${b.toString()} ${l.symbol||l.address}`),this.logDebug("currentPrice invert:",`1 ${l.symbol||l.address} \u2248 ${new Le(1).div(b).toString()} ${c.symbol||c.address}`);let g=new ze(0),P=n;if(!P.isZero()){P.gt(y)&&(P=y.sub(new ze(1)));let K=y.sub(P);g=f.mul(P).div(K).mul(Ar).div(Ar.sub(Ys))}let T=new ze(new Le(g.toString()).mul(1+i).toFixed(0)),h=g,w=T;this.logDebug("amountIn:",new Le(h.toString()).div(10**c.decimals).toDecimalPlaces(c.decimals).toString()),this.logDebug("maxAmountIn:",new Le(w.toString()).div(10**c.decimals).toDecimalPlaces(c.decimals).toString());let k=null;!g.isZero()&&!P.isZero()&&(k=new Le(P.toString()).div(10**l.decimals).div(new Le(g.toString()).div(10**c.decimals)),this.logDebug("executionPrice:",`1 ${l.symbol||l.address} \u2248 ${k.toDecimalPlaces(Math.max(t.mintA.decimals,t.mintB.decimals)).toString()} ${c.symbol||c.address}`),this.logDebug("executionPrice invert:",`1 ${l.symbol||l.address} \u2248 ${new Le(1).div(k).toDecimalPlaces(Math.max(t.mintA.decimals,t.mintB.decimals)).toString()} ${c.symbol||c.address}`));let x=b.mul(h.toString()),B=x.sub(n.toString()).abs().div(x);return this.logDebug("priceImpact:",`${B.toString()}%`),{amountIn:h,maxAmountIn:w,currentPrice:b,executionPrice:k,priceImpact:B}}async swap({poolInfo:t,poolKeys:n,amountIn:o,amountOut:r,inputMint:i,fixedSide:s,txVersion:u,config:a,computeBudgetConfig:c,txTipConfig:l,feePayer:m}){let p=this.createTxBuilder(m),{associatedOnly:f=!0,inputUseSolBalance:y=!0,outputUseSolBalance:b=!0}=a||{},[g,P]=i===t.mintA.address?[t.mintA,t.mintB]:[t.mintB,t.mintA],T=y&&g.address===H.toBase58(),h=b&&P.address===H.toBase58(),{account:w,instructionParams:k}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:_n,mint:new je(g.address),owner:this.scope.ownerPubKey,createInfo:T?{payer:this.scope.ownerPubKey,amount:o}:void 0,skipCloseAccount:!T,notUseTokenAccount:T,associatedOnly:f});p.addInstruction(k||{}),w||this.logAndCreateError("input token account not found",{token:g.symbol||g.address,tokenAccountIn:w,inputTokenUseSolBalance:T,associatedOnly:f});let{account:x,instructionParams:B}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:_n,mint:new je(P.address),owner:this.scope.ownerPubKey,createInfo:{payer:this.scope.ownerPubKey,amount:0},skipCloseAccount:!h,notUseTokenAccount:h,associatedOnly:h?!1:f});p.addInstruction(B||{}),x===void 0&&this.logAndCreateError("output token account not found",{token:P.symbol||P.address,tokenAccountOut:x,outputTokenUseSolBalance:h,associatedOnly:f});let K=n||await this.getAmmPoolKeys(t.id),I=4;return t.pooltype.includes("StablePool")&&(I=5),p.addInstruction({instructions:[kr({version:I,poolKeys:K,userKeys:{tokenAccountIn:w,tokenAccountOut:x,owner:this.scope.ownerPubKey},amountIn:o,amountOut:r,fixedSide:s})],instructionTypes:[I===4?U.AmmV4SwapBaseIn:U.AmmV5SwapBaseIn]}),p.addCustomComputeBudget(c),p.addTipInstruction(l),p.versionBuild({txVersion:u})}async getRpcPoolInfo(t){return(await this.getRpcPoolInfos([t]))[t]}async getRpcPoolInfos(t,n){let o=await Ne(this.scope.connection,t.map(c=>({pubkey:new je(c)})),n),r={},i=[];for(let c=0;c<t.length;c++){let l=o[c];if(l===null||!l.accountInfo)throw Error("fetch pool info error: "+String(t[c]));let m=pi.decode(l.accountInfo.data);r[String(t[c])]=D(v({},m),{programId:l.accountInfo.owner}),i.push(m.baseVault,m.quoteVault)}let s={},u=await Ne(this.scope.connection,i.map(c=>({pubkey:new je(c)})),n);for(let c=0;c<i.length;c++){let l=u[c].accountInfo;if(l===null)throw Error("fetch vault info error: "+i[c]);s[String(i[c])]=new ze(Ed.decode(l.data).amount.toString())}let a={};for(let[c,l]of Object.entries(r)){let m=s[l.baseVault.toString()].sub(l.baseNeedTakePnl),p=s[l.quoteVault.toString()].sub(l.quoteNeedTakePnl);a[c]=D(v({},l),{baseReserve:m,mintAAmount:s[l.baseVault.toString()],mintBAmount:s[l.quoteVault.toString()],quoteReserve:p,poolPrice:new Le(p.toString()).div(new Le(10).pow(l.quoteDecimal.toString())).div(new Le(m.toString()).div(new Le(10).pow(l.baseDecimal.toString())))})}return a}async getPoolInfoFromRpc({poolId:t}){let n=await this.getRpcPoolInfo(t),o=hr({[t]:n}),r=o[t],i=await this.scope.tradeV2.computePoolToPoolKeys({pools:[o[t]],ammRpcData:{[t]:n}});return{poolRpcData:n,poolInfo:r,poolKeys:i[0]}}};import{PublicKey as Q}from"@solana/web3.js";import gt from"bn.js";import io from"decimal.js";import{AccountLayout as Kc,createAssociatedTokenAccountIdempotentInstruction as Cc,TOKEN_2022_PROGRAM_ID as Vn,TOKEN_PROGRAM_ID as Ai}from"@solana/spl-token";var ki=class extends _e{constructor(e){super(e)}async getClmmPoolKeys(e){return(await this.scope.api.fetchPoolKeysById({idList:[e]}))[0]}async createPool(e){var x;let{programId:t,owner:n=((x=this.scope.owner)==null?void 0:x.publicKey)||Q.default,mint1:o,mint2:r,ammConfig:i,initialPrice:s,computeBudgetConfig:u,forerunCreate:a,getObserveState:c,txVersion:l,txTipConfig:m,feePayer:p}=e,f=this.createTxBuilder(p),[y,b,g]=new gt(new Q(o.address).toBuffer()).gt(new gt(new Q(r.address).toBuffer()))?[r,o,new io(1).div(s)]:[o,r,s],P=ue.priceToSqrtPriceX64(g,y.decimals,b.decimals),T=[],h=[];y.programId===Vn.toBase58()&&h.push(Ds(t,new Q(y.address)).publicKey),b.programId===Vn.toBase58()&&h.push(Ds(t,new Q(b.address)).publicKey),(await this.scope.connection.getMultipleAccountsInfo(h)).forEach((B,K)=>{B&&T.push(h[K])});let k=await Re.createPoolInstructions({connection:this.scope.connection,programId:t,owner:n,mintA:y,mintB:b,ammConfigId:i.id,initialPriceX64:P,forerunCreate:!c&&a,extendMintAccount:T});return f.addInstruction(k),f.addCustomComputeBudget(u),f.addTipInstruction(m),f.versionBuild({txVersion:l,extInfo:{address:D(v({},k.address),{observationId:k.address.observationId.toBase58(),exBitmapAccount:k.address.exBitmapAccount.toBase58(),programId:t.toString(),id:k.address.poolId.toString(),mintA:y,mintB:b,openTime:"0",vault:{A:k.address.mintAVault.toString(),B:k.address.mintBVault.toString()},rewardInfos:[],config:{id:i.id.toString(),index:i.index,protocolFeeRate:i.protocolFeeRate,tradeFeeRate:i.tradeFeeRate,tickSpacing:i.tickSpacing,fundFeeRate:i.fundFeeRate,description:i.description,defaultRange:0,defaultRangePoint:[]}}),mockPoolInfo:v({type:"Concentrated",rewardDefaultPoolInfos:"Clmm",id:k.address.poolId.toString(),mintA:y,mintB:b,feeRate:i.tradeFeeRate,openTime:"0",programId:t.toString(),price:g.toNumber(),config:{id:i.id.toString(),index:i.index,protocolFeeRate:i.protocolFeeRate,tradeFeeRate:i.tradeFeeRate,tickSpacing:i.tickSpacing,fundFeeRate:i.fundFeeRate,description:i.description,defaultRange:0,defaultRangePoint:[]},burnPercent:0},ju),forerunCreate:a}})}async openPositionFromBase({poolInfo:e,poolKeys:t,ownerInfo:n,tickLower:o,tickUpper:r,base:i,baseAmount:s,otherAmountMax:u,nft2022:a,associatedOnly:c=!0,checkCreateATAOwner:l=!1,withMetadata:m="create",getEphemeralSigners:p,computeBudgetConfig:f,txTipConfig:y,txVersion:b,feePayer:g}){this.scope.availability.addConcentratedPosition===!1&&this.logAndCreateError("add position feature disabled in your region"),this.scope.checkOwner();let P=this.createTxBuilder(g),T=null,h=null,w=n.useSOLBalance&&e.mintA.address===H.toString(),k=n.useSOLBalance&&e.mintB.address===H.toString(),[x,B]=i==="MintA"?[s,u]:[u,s],{account:K,instructionParams:I}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:e.mintA.programId,mint:new Q(e.mintA.address),owner:this.scope.ownerPubKey,createInfo:w||x.isZero()?{payer:this.scope.ownerPubKey,amount:x}:void 0,skipCloseAccount:!w,notUseTokenAccount:w,associatedOnly:w?!1:c,checkCreateATAOwner:l});K&&(T=K),P.addInstruction(I||{});let{account:R,instructionParams:C}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:e.mintB.programId,mint:new Q(e.mintB.address),owner:this.scope.ownerPubKey,createInfo:k||B.isZero()?{payer:this.scope.ownerPubKey,amount:B}:void 0,skipCloseAccount:!k,notUseTokenAccount:k,associatedOnly:k?!1:c,checkCreateATAOwner:l});R&&(h=R),P.addInstruction(C||{}),(!T||!h)&&this.logAndCreateError("cannot found target token accounts","tokenAccounts",{ownerTokenAccountA:T==null?void 0:T.toBase58(),ownerTokenAccountB:h==null?void 0:h.toBase58()});let N=t||await this.getClmmPoolKeys(e.id),L=await Re.openPositionFromBaseInstructions({poolInfo:e,poolKeys:N,ownerInfo:D(v({},n),{feePayer:this.scope.ownerPubKey,wallet:this.scope.ownerPubKey,tokenAccountA:T,tokenAccountB:h}),tickLower:o,tickUpper:r,base:i,baseAmount:s,otherAmountMax:u,withMetadata:m,getEphemeralSigners:p,nft2022:a});return P.addInstruction(L),P.addCustomComputeBudget(f),P.addTipInstruction(y),P.versionBuild({txVersion:b,extInfo:v({},L.address)})}async openPositionFromLiquidity({poolInfo:e,poolKeys:t,ownerInfo:n,amountMaxA:o,amountMaxB:r,tickLower:i,tickUpper:s,liquidity:u,associatedOnly:a=!0,checkCreateATAOwner:c=!1,withMetadata:l="create",txVersion:m,computeBudgetConfig:p,txTipConfig:f,getEphemeralSigners:y,nft2022:b,feePayer:g}){this.scope.availability.createConcentratedPosition===!1&&this.logAndCreateError("open position feature disabled in your region");let P=this.createTxBuilder(g),T=null,h=null,w=n.useSOLBalance&&e.mintA.address===H.toBase58(),k=n.useSOLBalance&&e.mintB.address===H.toBase58(),{account:x,instructionParams:B}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:e.mintA.programId,mint:new Q(e.mintA.address),owner:this.scope.ownerPubKey,createInfo:w||o.isZero()?{payer:this.scope.ownerPubKey,amount:o}:void 0,skipCloseAccount:!w,notUseTokenAccount:w,associatedOnly:w?!1:a,checkCreateATAOwner:c});x&&(T=x),P.addInstruction(B||{});let{account:K,instructionParams:I}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:e.mintB.programId,mint:new Q(e.mintB.address),owner:this.scope.ownerPubKey,createInfo:k||r.isZero()?{payer:this.scope.ownerPubKey,amount:r}:void 0,skipCloseAccount:!k,notUseTokenAccount:k,associatedOnly:k?!1:a,checkCreateATAOwner:c});K&&(h=K),P.addInstruction(I||{}),(T===void 0||h===void 0)&&this.logAndCreateError("cannot found target token accounts","tokenAccounts",this.scope.account.tokenAccounts);let R=t||await this.getClmmPoolKeys(e.id),C=await Re.openPositionFromLiquidityInstructions({poolInfo:e,poolKeys:R,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccountA:T,tokenAccountB:h},tickLower:i,tickUpper:s,liquidity:u,amountMaxA:o,amountMaxB:r,withMetadata:l,getEphemeralSigners:y,nft2022:b});return P.addInstruction(C),P.addCustomComputeBudget(p),P.addTipInstruction(f),P.versionBuild({txVersion:m,extInfo:{address:C.address}})}async increasePositionFromLiquidity(e){var I;let{poolInfo:t,poolKeys:n,ownerPosition:o,amountMaxA:r,amountMaxB:i,liquidity:s,ownerInfo:u,associatedOnly:a=!0,checkCreateATAOwner:c=!1,computeBudgetConfig:l,txTipConfig:m,txVersion:p,feePayer:f}=e,y=this.createTxBuilder(f),b,g,P=u.useSOLBalance&&t.mintA.address===H.toString(),T=u.useSOLBalance&&t.mintB.address===H.toString(),{account:h,instructionParams:w}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:t.mintA.programId,mint:new Q(t.mintA.address),notUseTokenAccount:P,owner:this.scope.ownerPubKey,createInfo:P||r.isZero()?{payer:this.scope.ownerPubKey,amount:r}:void 0,skipCloseAccount:!P,associatedOnly:P?!1:a,checkCreateATAOwner:c});h&&(b=h),y.addInstruction(w||{});let{account:k,instructionParams:x}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:t.mintB.programId,mint:new Q(t.mintB.address),owner:this.scope.ownerPubKey,createInfo:T||i.isZero()?{payer:this.scope.ownerPubKey,amount:i}:void 0,notUseTokenAccount:T,skipCloseAccount:!T,associatedOnly:T?!1:a,checkCreateATAOwner:c});k&&(g=k),y.addInstruction(x||{}),!b&&!g&&this.logAndCreateError("cannot found target token accounts","tokenAccounts",this.scope.account.tokenAccounts);let B=n!=null?n:await this.getClmmPoolKeys(t.id),K=Re.increasePositionFromLiquidityInstructions({poolInfo:t,poolKeys:B,ownerPosition:o,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccountA:b,tokenAccountB:g},liquidity:s,amountMaxA:r,amountMaxB:i,nft2022:(I=await this.scope.connection.getAccountInfo(o.nftMint))==null?void 0:I.owner.equals(Vn)});return y.addInstruction(K),y.addCustomComputeBudget(l),y.addTipInstruction(m),y.versionBuild({txVersion:p,extInfo:{address:K.address}})}async increasePositionFromBase(e){var K;let{poolInfo:t,ownerPosition:n,base:o,baseAmount:r,otherAmountMax:i,ownerInfo:s,associatedOnly:u=!0,checkCreateATAOwner:a=!1,computeBudgetConfig:c,txTipConfig:l,txVersion:m,feePayer:p}=e,f=this.createTxBuilder(p),y,b,g=s.useSOLBalance&&t.mintA.address===H.toString(),P=s.useSOLBalance&&t.mintB.address===H.toString(),{account:T,instructionParams:h}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:t.mintA.programId,mint:new Q(t.mintA.address),notUseTokenAccount:g,owner:this.scope.ownerPubKey,createInfo:g||(o==="MintA"?r:i).isZero()?{payer:this.scope.ownerPubKey,amount:o==="MintA"?r:i}:void 0,skipCloseAccount:!g,associatedOnly:g?!1:u,checkCreateATAOwner:a});T&&(y=T),f.addInstruction(h||{});let{account:w,instructionParams:k}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:t.mintB.programId,mint:new Q(t.mintB.address),owner:this.scope.ownerPubKey,createInfo:P||(o==="MintA"?i:r).isZero()?{payer:this.scope.ownerPubKey,amount:o==="MintA"?i:r}:void 0,notUseTokenAccount:P,skipCloseAccount:!P,associatedOnly:P?!1:u,checkCreateATAOwner:a});w&&(b=w),f.addInstruction(k||{}),!y&&!b&&this.logAndCreateError("cannot found target token accounts","tokenAccounts",this.scope.account.tokenAccounts);let x=await this.getClmmPoolKeys(t.id),B=Re.increasePositionFromBaseInstructions({poolInfo:t,poolKeys:x,ownerPosition:n,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccountA:y,tokenAccountB:b},base:o,baseAmount:r,otherAmountMax:i,nft2022:(K=await this.scope.connection.getAccountInfo(n.nftMint))==null?void 0:K.owner.equals(Vn)});return f.addInstruction(B),f.addCustomComputeBudget(c),f.addTipInstruction(l),f.versionBuild({txVersion:m,extInfo:{address:B.address}})}async decreaseLiquidity(e){var N;let{poolInfo:t,poolKeys:n,ownerPosition:o,ownerInfo:r,amountMinA:i,amountMinB:s,liquidity:u,associatedOnly:a=!0,checkCreateATAOwner:c=!1,computeBudgetConfig:l,txTipConfig:m,txVersion:p,feePayer:f}=e;this.scope.availability.removeConcentratedPosition===!1&&this.logAndCreateError("remove position feature disabled in your region");let y=this.createTxBuilder(f),b=r.useSOLBalance&&t.mintA.address===H.toString(),g=r.useSOLBalance&&t.mintB.address===H.toString(),P,T,{account:h,instructionParams:w}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:t.mintA.programId,mint:new Q(t.mintA.address),notUseTokenAccount:b,owner:this.scope.ownerPubKey,createInfo:{payer:this.scope.ownerPubKey,amount:0},skipCloseAccount:!b,associatedOnly:b?!1:a,checkCreateATAOwner:c});P=h,w&&y.addInstruction(w);let{account:k,instructionParams:x}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:t.mintB.programId,mint:new Q(t.mintB.address),notUseTokenAccount:g,owner:this.scope.ownerPubKey,createInfo:{payer:this.scope.ownerPubKey,amount:0},skipCloseAccount:!g,associatedOnly:g?!1:a,checkCreateATAOwner:c});T=k,x&&y.addInstruction(x);let B=[];for(let L of t.rewardDefaultInfos){let O=r.useSOLBalance&&L.mint.address===H.toString(),F;if(L.mint.address===t.mintA.address)F=P;else if(L.mint.address===t.mintB.address)F=T;else{let{account:G,instructionParams:z}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:new Q(L.mint.programId),mint:new Q(L.mint.address),notUseTokenAccount:O,owner:this.scope.ownerPubKey,createInfo:{payer:this.scope.ownerPubKey,amount:0},skipCloseAccount:!O,associatedOnly:O?!1:a,checkCreateATAOwner:c});F=G,z&&y.addInstruction(z)}B.push(F)}!P&&!T&&this.logAndCreateError("cannot found target token accounts","tokenAccounts",this.scope.account.tokenAccountRawInfos);let K=n!=null?n:await this.getClmmPoolKeys(t.id),I=(N=await this.scope.connection.getAccountInfo(o.nftMint))==null?void 0:N.owner.equals(Vn),R=await Re.decreaseLiquidityInstructions({poolInfo:t,poolKeys:K,ownerPosition:o,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccountA:P,tokenAccountB:T,rewardAccounts:B},liquidity:u,amountMinA:i,amountMinB:s,nft2022:I});y.addInstruction({instructions:R.instructions,instructionTypes:[U.ClmmDecreasePosition]});let C=v({},R.address);if(r.closePosition){let L=await Re.closePositionInstructions({poolInfo:t,poolKeys:K,ownerInfo:{wallet:this.scope.ownerPubKey},ownerPosition:o,nft2022:I});y.addInstruction({endInstructions:L.instructions,endInstructionTypes:L.instructionTypes}),C=v(v({},C),L.address)}return y.addCustomComputeBudget(l),y.addTipInstruction(m),y.versionBuild({txVersion:p,extInfo:{address:C}})}async lockPosition(e){var f;let{programId:t=Uo,authProgramId:n=ji,poolProgramId:o=Dn,ownerPosition:r,payer:i,computeBudgetConfig:s,txTipConfig:u,txVersion:a,getEphemeralSigners:c,feePayer:l}=e,m=this.createTxBuilder(l),p=await Re.makeLockPositions({programId:t,authProgramId:n,poolProgramId:o,wallet:this.scope.ownerPubKey,payer:i!=null?i:this.scope.ownerPubKey,nftMint:r.nftMint,getEphemeralSigners:c,nft2022:(f=await this.scope.connection.getAccountInfo(r.nftMint))==null?void 0:f.owner.equals(Vn)});return m.addInstruction(p),m.addCustomComputeBudget(s),m.addTipInstruction(u),m.versionBuild({txVersion:a,extInfo:p.address})}async harvestLockPosition(e){let{programId:t=Uo,authProgramId:n=ji,clmmProgram:o=Dn,poolKeys:r,lockData:i,ownerInfo:s={useSOLBalance:!0},associatedOnly:u=!0,checkCreateATAOwner:a=!1,computeBudgetConfig:c,txTipConfig:l,txVersion:m,feePayer:p}=e,f=r||await this.getClmmPoolKeys(i.poolId.toString()),y=this.createTxBuilder(p),b=await this.scope.connection.getAccountInfo(i.positionId);b||this.logger.logWithError("position not found",i.positionId);let g=Io.decode(b.data),P=s.useSOLBalance&&f.mintA.address===H.toString(),T=s.useSOLBalance&&f.mintB.address===H.toString(),h,w,{account:k,instructionParams:x}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:f.mintA.programId,mint:new Q(f.mintA.address),notUseTokenAccount:P,owner:this.scope.ownerPubKey,createInfo:{payer:this.scope.ownerPubKey,amount:0},skipCloseAccount:!P,associatedOnly:P?!1:u,checkCreateATAOwner:a});h=k,x&&y.addInstruction(x);let{account:B,instructionParams:K}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:f.mintB.programId,mint:new Q(f.mintB.address),notUseTokenAccount:T,owner:this.scope.ownerPubKey,createInfo:{payer:this.scope.ownerPubKey,amount:0},skipCloseAccount:!T,associatedOnly:T?!1:u,checkCreateATAOwner:a});w=B,K&&y.addInstruction(K);let I={},R=[];for(let te of f.rewardInfos){let ae=s.useSOLBalance&&te.mint.address===H.toString(),ye=I[te.mint.address];if(!ye){let{account:me,instructionParams:J}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:new Q(te.mint.programId),mint:new Q(te.mint.address),notUseTokenAccount:ae,owner:this.scope.ownerPubKey,skipCloseAccount:!ae,createInfo:{payer:this.scope.ownerPubKey,amount:0},associatedOnly:ae?!1:u});ye=me,J&&y.addInstruction(J)}I[te.mint.address]=ye,R.push(ye)}let C=ho(t,i.lockNftMint).publicKey,N=Z(this.scope.ownerPubKey,i.lockNftMint,Ai).publicKey,L=j.getTickArrayStartIndexByTick(g.tickLower,f.config.tickSpacing),O=j.getTickArrayStartIndexByTick(g.tickUpper,f.config.tickSpacing),{publicKey:F}=Pe(new Q(f.programId),i.poolId,L),{publicKey:G}=Pe(new Q(f.programId),i.poolId,O),{publicKey:z}=en(new Q(f.programId),i.poolId,g.tickLower,g.tickUpper),$=[];for(let te=0;te<f.rewardInfos.length;te++)$.push({poolRewardVault:new Q(f.rewardInfos[te].vault),ownerRewardVault:R[te],rewardMint:new Q(f.rewardInfos[te].mint.address)});let re=await Re.harvestLockPositionInstructionV2({programId:t,auth:n,lockPositionId:C,clmmProgram:o,lockOwner:this.scope.ownerPubKey,lockNftMint:i.lockNftMint,lockNftAccount:N,positionNftAccount:i.nftAccount,positionId:i.positionId,poolId:i.poolId,protocolPosition:z,vaultA:new Q(f.vault.A),vaultB:new Q(f.vault.B),tickArrayLower:F,tickArrayUpper:G,userVaultA:h,userVaultB:w,mintA:new Q(f.mintA.address),mintB:new Q(f.mintB.address),rewardAccounts:$,exTickArrayBitmap:Qe(o,i.poolId).publicKey});return y.addInstruction({instructions:[re],instructionTypes:[U.ClmmHarvestLockPosition]}),y.addCustomComputeBudget(c),y.addTipInstruction(l),y.versionBuild({txVersion:m})}async closePosition({poolInfo:e,poolKeys:t,ownerPosition:n,txVersion:o,computeBudgetConfig:r,txTipConfig:i,feePayer:s}){var l;this.scope.availability.removeConcentratedPosition===!1&&this.logAndCreateError("remove position feature disabled in your region");let u=this.createTxBuilder(s),a=t!=null?t:await this.getClmmPoolKeys(e.id),c=Re.closePositionInstructions({poolInfo:e,poolKeys:a,ownerInfo:{wallet:this.scope.ownerPubKey},ownerPosition:n,nft2022:(l=await this.scope.connection.getAccountInfo(n.nftMint))==null?void 0:l.owner.equals(Vn)});return u.addCustomComputeBudget(r),u.addTipInstruction(i),u.addInstruction(c).versionBuild({txVersion:o,extInfo:{address:c.address}})}async initReward({poolInfo:e,ownerInfo:t,rewardInfo:n,associatedOnly:o=!0,checkCreateATAOwner:r=!1,computeBudgetConfig:i,txVersion:s,feePayer:u}){n.endTime<=n.openTime&&this.logAndCreateError("reward time error","rewardInfo",n);let a=this.createTxBuilder(u),c=t.useSOLBalance&&n.mint.address.toString()===H.toString(),l=n.perSecond.mul(n.endTime-n.openTime),{account:m,instructionParams:p}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:new Q(n.mint.address),mint:new Q(n.mint.address),notUseTokenAccount:!!c,skipCloseAccount:!c,owner:this.scope.ownerPubKey,createInfo:c?{payer:t.feePayer||this.scope.ownerPubKey,amount:new gt(new io(l.toFixed(0)).gte(l)?l.toFixed(0):l.add(1).toFixed(0))}:void 0,associatedOnly:c?!1:o,checkCreateATAOwner:r});p&&a.addInstruction(p),m||this.logAndCreateError("no money","ownerRewardAccount",this.scope.account.tokenAccountRawInfos);let f=await this.getClmmPoolKeys(e.id),y=Re.initRewardInstructions({poolInfo:e,poolKeys:f,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccount:m},rewardInfo:{programId:new Q(n.mint.programId),mint:new Q(n.mint.address),openTime:n.openTime,endTime:n.endTime,emissionsPerSecondX64:le.decimalToX64(n.perSecond)}});return a.addInstruction(y),a.addCustomComputeBudget(i),a.versionBuild({txVersion:s,extInfo:{address:y.address}})}async initRewards({poolInfo:e,poolKeys:t,ownerInfo:n,rewardInfos:o,associatedOnly:r=!0,checkCreateATAOwner:i=!1,computeBudgetConfig:s,txTipConfig:u,txVersion:a,feePayer:c}){for(let p of o)p.endTime<=p.openTime&&this.logAndCreateError("reward time error","rewardInfo",p);let l=this.createTxBuilder(c),m={};for(let p of o){let f=n.useSOLBalance&&p.mint.address===H.toString(),y=p.perSecond.mul(p.endTime-p.openTime),{account:b,instructionParams:g}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:new Q(p.mint.programId),mint:new Q(p.mint.address),notUseTokenAccount:!!f,skipCloseAccount:!f,owner:this.scope.ownerPubKey,createInfo:f?{payer:n.feePayer||this.scope.ownerPubKey,amount:new gt(new io(y.toFixed(0)).gte(y)?y.toFixed(0):y.add(1).toFixed(0))}:void 0,associatedOnly:f?!1:r,checkCreateATAOwner:i});g&&l.addInstruction(g),b||this.logAndCreateError("no money","ownerRewardAccount",this.scope.account.tokenAccountRawInfos);let P=t!=null?t:await this.getClmmPoolKeys(e.id),T=Re.initRewardInstructions({poolInfo:e,poolKeys:P,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccount:b},rewardInfo:{programId:new Q(p.mint.programId),mint:new Q(p.mint.address),openTime:p.openTime,endTime:p.endTime,emissionsPerSecondX64:le.decimalToX64(p.perSecond)}});m=v(v({},m),T.address),l.addInstruction(T)}return l.addCustomComputeBudget(s),l.addTipInstruction(u),l.versionBuild({txVersion:a,extInfo:{address:m}})}async setReward({poolInfo:e,ownerInfo:t,rewardInfo:n,associatedOnly:o=!0,checkCreateATAOwner:r=!1,computeBudgetConfig:i,txTipConfig:s,txVersion:u,feePayer:a}){n.endTime<=n.openTime&&this.logAndCreateError("reward time error","rewardInfo",n);let c=this.createTxBuilder(a),l=t.useSOLBalance&&n.mint.equals(H),{account:m,instructionParams:p}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:n.programId,mint:n.mint,notUseTokenAccount:l,owner:this.scope.ownerPubKey,createInfo:l?{payer:t.feePayer||this.scope.ownerPubKey,amount:new gt(new io(n.perSecond.mul(n.endTime-n.openTime).toFixed(0)).gte(n.perSecond.mul(n.endTime-n.openTime))?n.perSecond.mul(n.endTime-n.openTime).toFixed(0):n.perSecond.mul(n.endTime-n.openTime).add(1).toFixed(0))}:void 0,associatedOnly:l?!1:o,checkCreateATAOwner:r});p&&c.addInstruction(p),m||this.logAndCreateError("no money","ownerRewardAccount",this.scope.account.tokenAccountRawInfos);let f=await this.getClmmPoolKeys(e.id),y=Re.setRewardInstructions({poolInfo:e,poolKeys:f,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccount:m},rewardInfo:{mint:n.mint,openTime:n.openTime,endTime:n.endTime,emissionsPerSecondX64:le.decimalToX64(n.perSecond)}});return c.addInstruction(y),c.addCustomComputeBudget(i),c.addTipInstruction(s),c.versionBuild({txVersion:u,extInfo:{address:y.address}})}async setRewards({poolInfo:e,poolKeys:t,ownerInfo:n,rewardInfos:o,associatedOnly:r=!0,checkCreateATAOwner:i=!1,computeBudgetConfig:s,txTipConfig:u,txVersion:a,feePayer:c}){let l=this.createTxBuilder(c),m={};for(let p of o){p.endTime<=p.openTime&&this.logAndCreateError("reward time error","rewardInfo",p);let f=n.useSOLBalance&&p.mint.address===H.toString(),{account:y,instructionParams:b}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:new Q(p.mint.programId),mint:new Q(p.mint.address),notUseTokenAccount:f,owner:this.scope.ownerPubKey,createInfo:f?{payer:n.feePayer||this.scope.ownerPubKey,amount:new gt(new io(p.perSecond.mul(p.endTime-p.openTime).toFixed(0)).gte(p.perSecond.mul(p.endTime-p.openTime))?p.perSecond.mul(p.endTime-p.openTime).toFixed(0):p.perSecond.mul(p.endTime-p.openTime).add(1).toFixed(0))}:void 0,associatedOnly:f?!1:r,checkCreateATAOwner:i});b&&l.addInstruction(b),y||this.logAndCreateError("no money","ownerRewardAccount",this.scope.account.tokenAccountRawInfos);let g=t!=null?t:await this.getClmmPoolKeys(e.id),P=Re.setRewardInstructions({poolInfo:e,poolKeys:g,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccount:y},rewardInfo:{mint:new Q(p.mint.address),openTime:p.openTime,endTime:p.endTime,emissionsPerSecondX64:le.decimalToX64(p.perSecond)}});l.addInstruction(P),m=v(v({},m),P.address)}return l.addCustomComputeBudget(s),l.addTipInstruction(u),l.versionBuild({txVersion:a,extInfo:{address:m}})}async collectReward({poolInfo:e,ownerInfo:t,rewardMint:n,associatedOnly:o=!0,checkCreateATAOwner:r=!1,computeBudgetConfig:i,txTipConfig:s,txVersion:u,feePayer:a}){let c=e.rewardDefaultInfos.find(g=>g.mint.address===n.toString());c||this.logAndCreateError("reward mint error","not found reward mint",n);let l=this.createTxBuilder(a),m=t.useSOLBalance&&n.equals(H),{account:p,instructionParams:f}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:new Q(c.mint.programId),mint:n,notUseTokenAccount:m,owner:this.scope.ownerPubKey,skipCloseAccount:!m,createInfo:{payer:t.feePayer||this.scope.ownerPubKey,amount:0},associatedOnly:m?!1:o,checkCreateATAOwner:r});f&&l.addInstruction(f),p||this.logAndCreateError("no money","ownerRewardAccount",this.scope.account.tokenAccountRawInfos);let y=await this.getClmmPoolKeys(e.id),b=Re.collectRewardInstructions({poolInfo:e,poolKeys:y,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccount:p},rewardMint:n});return l.addInstruction(b),l.addCustomComputeBudget(i),l.addTipInstruction(s),l.versionBuild({txVersion:u,extInfo:{address:b.address}})}async collectRewards({poolInfo:e,ownerInfo:t,rewardMints:n,associatedOnly:o=!0,checkCreateATAOwner:r=!1,computeBudgetConfig:i,txTipConfig:s,feePayer:u}){let a=this.createTxBuilder(u),c={};for(let l of n){let m=e.rewardDefaultInfos.find(P=>P.mint.address===l.toString());if(!m){this.logAndCreateError("reward mint error","not found reward mint",l);continue}let p=t.useSOLBalance&&l.equals(H),{account:f,instructionParams:y}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:new Q(m.mint.programId),mint:l,notUseTokenAccount:p,owner:this.scope.ownerPubKey,skipCloseAccount:!p,createInfo:{payer:t.feePayer||this.scope.ownerPubKey,amount:0},associatedOnly:p?!1:o,checkCreateATAOwner:r});f||this.logAndCreateError("no money","ownerRewardAccount",this.scope.account.tokenAccountRawInfos),y&&a.addInstruction(y);let b=await this.getClmmPoolKeys(e.id),g=Re.collectRewardInstructions({poolInfo:e,poolKeys:b,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccount:f},rewardMint:l});a.addInstruction(g),c=v(v({},c),g.address)}return a.addCustomComputeBudget(i),a.addTipInstruction(s),a.build({address:c})}async swap({poolInfo:e,poolKeys:t,inputMint:n,amountIn:o,amountOutMin:r,priceLimit:i,observationId:s,ownerInfo:u,remainingAccounts:a,associatedOnly:c=!0,checkCreateATAOwner:l=!1,txVersion:m,computeBudgetConfig:p,txTipConfig:f,feePayer:y}){let b=this.createTxBuilder(y),g=n.toString()===e.mintA.address,P=u.useSOLBalance&&e.mintA.address===H.toBase58(),T=u.useSOLBalance&&e.mintB.address===H.toBase58(),h;!i||i.equals(new io(0))?h=g?Wt.add(new gt(1)):Dt.sub(new gt(1)):h=ue.priceToSqrtPriceX64(i,e.mintA.decimals,e.mintB.decimals);let w;if(!w){let{account:B,instructionParams:K}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:e.mintA.programId,mint:new Q(e.mintA.address),notUseTokenAccount:P,owner:this.scope.ownerPubKey,skipCloseAccount:!P,createInfo:P||!g?{payer:u.feePayer||this.scope.ownerPubKey,amount:g?o:0}:void 0,associatedOnly:P?!1:c,checkCreateATAOwner:l});w=B,K&&b.addInstruction(K)}let k;if(!k){let{account:B,instructionParams:K}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:e.mintB.programId,mint:new Q(e.mintB.address),notUseTokenAccount:T,owner:this.scope.ownerPubKey,skipCloseAccount:!T,createInfo:T||g?{payer:u.feePayer||this.scope.ownerPubKey,amount:g?0:o}:void 0,associatedOnly:T?!1:c,checkCreateATAOwner:l});k=B,K&&b.addInstruction(K)}(!w||!k)&&this.logAndCreateError("user do not have token account",{tokenA:e.mintA.symbol||e.mintA.address,tokenB:e.mintB.symbol||e.mintB.address,ownerTokenAccountA:w,ownerTokenAccountB:k,mintAUseSOLBalance:P,mintBUseSOLBalance:T,associatedOnly:c});let x=t!=null?t:await this.getClmmPoolKeys(e.id);return b.addInstruction(Re.makeSwapBaseInInstructions({poolInfo:e,poolKeys:x,observationId:s,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccountA:w,tokenAccountB:k},inputMint:new Q(n),amountIn:o,amountOutMin:r,sqrtPriceLimitX64:h,remainingAccounts:a})),b.addCustomComputeBudget(p),b.addTipInstruction(f),b.versionBuild({txVersion:m})}async swapBaseOut({poolInfo:e,poolKeys:t,outputMint:n,amountOut:o,amountInMax:r,priceLimit:i,observationId:s,ownerInfo:u,remainingAccounts:a,associatedOnly:c=!0,checkCreateATAOwner:l=!1,txVersion:m,computeBudgetConfig:p,txTipConfig:f,feePayer:y}){let b=this.createTxBuilder(y),g=n.toString()===e.mintB.address,P=u.useSOLBalance&&e.mintA.address===H.toBase58(),T=u.useSOLBalance&&e.mintB.address===H.toBase58(),h;!i||i.equals(new io(0))?h=n.toString()===e.mintB.address?Wt.add(new gt(1)):Dt.sub(new gt(1)):h=ue.priceToSqrtPriceX64(i,e.mintA.decimals,e.mintB.decimals);let w;if(!w){let{account:B,instructionParams:K}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:e.mintA.programId,mint:new Q(e.mintA.address),notUseTokenAccount:P,owner:this.scope.ownerPubKey,skipCloseAccount:!P,createInfo:P||!g?{payer:u.feePayer||this.scope.ownerPubKey,amount:g?r:0}:void 0,associatedOnly:P?!1:c,checkCreateATAOwner:l});w=B,K&&b.addInstruction(K)}let k;if(!k){let{account:B,instructionParams:K}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:e.mintB.programId,mint:new Q(e.mintB.address),notUseTokenAccount:T,owner:this.scope.ownerPubKey,skipCloseAccount:!T,createInfo:T||g?{payer:u.feePayer||this.scope.ownerPubKey,amount:g?0:r}:void 0,associatedOnly:T?!1:c,checkCreateATAOwner:l});k=B,K&&b.addInstruction(K)}(!w||!k)&&this.logAndCreateError("user do not have token account",{tokenA:e.mintA.symbol||e.mintA.address,tokenB:e.mintB.symbol||e.mintB.address,ownerTokenAccountA:w,ownerTokenAccountB:k,mintAUseSOLBalance:P,mintBUseSOLBalance:T,associatedOnly:c});let x=t!=null?t:await this.getClmmPoolKeys(e.id);return b.addInstruction(Re.makeSwapBaseOutInstructions({poolInfo:e,poolKeys:x,observationId:s,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccountA:w,tokenAccountB:k},outputMint:new Q(n),amountOut:o,amountInMax:r,sqrtPriceLimitX64:h,remainingAccounts:a})),b.addCustomComputeBudget(p),b.addTipInstruction(f),b.versionBuild({txVersion:m})}async harvestAllRewards({allPoolInfo:e,allPositions:t,lockInfo:n,ownerInfo:o,associatedOnly:r=!0,checkCreateATAOwner:i=!1,programId:s,txVersion:u,computeBudgetConfig:a,feePayer:c,lockProgram:l=Uo,lockAuth:m=ji,clmmProgram:p=Dn}){var T,h;let f={};for(let w of this.scope.account.tokenAccountRawInfos)r?Z(this.scope.ownerPubKey,w.accountInfo.mint,s).publicKey.equals(w.pubkey)&&(f[w.accountInfo.mint.toString()]=w.pubkey):f[w.accountInfo.mint.toString()]=w.pubkey;let y=Object.values(t).flat().map(w=>w.nftMint),b=await Ne(this.scope.connection,y.map(w=>({pubkey:w}))),g={};b.forEach(w=>{var k,x;g[w.pubkey.toBase58()]=(x=(k=w==null?void 0:w.accountInfo)==null?void 0:k.owner)!=null?x:null});let P=this.createTxBuilder(c);for(let w of Object.values(e)){if(t[w.id]===void 0||!t[w.id].find(L=>!L.liquidity.isZero()||L.rewardInfos.find(O=>!O.rewardAmountOwed.isZero())))continue;let k=w,x=o.useSOLBalance&&k.mintA.address===H.toString(),B=o.useSOLBalance&&k.mintB.address===H.toString(),K=f[k.mintA.address];if(!K)if(x){let{account:L,instructionParams:O}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:k.mintA.programId,mint:new Q(k.mintA.address),notUseTokenAccount:x,owner:this.scope.ownerPubKey,skipCloseAccount:!x,createInfo:{payer:o.feePayer||this.scope.ownerPubKey,amount:0},associatedOnly:x?!1:r,checkCreateATAOwner:i});K=L,O&&P.addInstruction(O)}else{let L=new Q(k.mintA.address);K=this.scope.account.getAssociatedTokenAccount(L,new Q(k.mintA.programId)),P.addInstruction({instructions:[Cc(this.scope.ownerPubKey,K,this.scope.ownerPubKey,L,new Q(k.mintA.programId))]})}let I=f[k.mintB.address];if(!I)if(B){let{account:L,instructionParams:O}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:k.mintB.programId,mint:new Q(k.mintB.address),notUseTokenAccount:B,owner:this.scope.ownerPubKey,skipCloseAccount:!B,createInfo:{payer:o.feePayer||this.scope.ownerPubKey,amount:0},associatedOnly:B?!1:r,checkCreateATAOwner:i});I=L,O&&P.addInstruction(O)}else{let L=new Q(k.mintB.address);I=this.scope.account.getAssociatedTokenAccount(L,new Q(k.mintB.programId)),P.addInstruction({instructions:[Cc(this.scope.ownerPubKey,I,this.scope.ownerPubKey,L,new Q(k.mintB.programId))]})}f[k.mintA.address]=K,f[k.mintB.address]=I;let R=[];for(let L of k.rewardDefaultInfos){let O=o.useSOLBalance&&L.mint.address===H.toString(),F=f[L.mint.address];if(!F){let{account:G,instructionParams:z}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:new Q(L.mint.programId),mint:new Q(L.mint.address),notUseTokenAccount:O,owner:this.scope.ownerPubKey,skipCloseAccount:!O,createInfo:{payer:o.feePayer||this.scope.ownerPubKey,amount:0},associatedOnly:O?!1:r});F=G,z&&P.addInstruction(z)}f[L.mint.address]=F,R.push(F)}let C=await this.getClmmPoolKeys(k.id),N=[];for(let L=0;L<C.rewardInfos.length;L++)N.push({poolRewardVault:new Q(C.rewardInfos[L].vault),ownerRewardVault:R[L],rewardMint:new Q(C.rewardInfos[L].mint.address)});for(let L of t[w.id]){let O=(T=n==null?void 0:n[w.id])==null?void 0:T[L.nftMint.toBase58()];if(O){let F=Z(this.scope.ownerPubKey,O.lockNftMint,Ai).publicKey,G=j.getTickArrayStartIndexByTick(L.tickLower,C.config.tickSpacing),z=j.getTickArrayStartIndexByTick(L.tickUpper,C.config.tickSpacing),{publicKey:$}=Pe(new Q(C.programId),O.poolId,G),{publicKey:re}=Pe(new Q(C.programId),O.poolId,z),{publicKey:te}=en(new Q(C.programId),O.poolId,L.tickLower,L.tickUpper),ae=ho(l,O.lockNftMint).publicKey,ye=Re.harvestLockPositionInstructionV2({programId:l,auth:m,lockPositionId:ae,clmmProgram:p,lockOwner:this.scope.ownerPubKey,lockNftMint:O.lockNftMint,lockNftAccount:F,positionNftAccount:O.nftAccount,positionId:O.positionId,poolId:O.poolId,protocolPosition:te,vaultA:new Q(C.vault.A),vaultB:new Q(C.vault.B),tickArrayLower:$,tickArrayUpper:re,userVaultA:K,userVaultB:I,mintA:new Q(C.mintA.address),mintB:new Q(C.mintB.address),rewardAccounts:N,exTickArrayBitmap:Qe(p,O.poolId).publicKey});P.addInstruction({instructions:[ye],instructionTypes:[U.ClmmHarvestLockPosition],lookupTableAddress:C.lookupTableAccount?[C.lookupTableAccount]:[]})}else{let F=Re.decreaseLiquidityInstructions({poolInfo:k,poolKeys:C,ownerPosition:L,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccountA:K,tokenAccountB:I,rewardAccounts:R},liquidity:new gt(0),amountMinA:new gt(0),amountMinB:new gt(0),nft2022:(h=g[L.nftMint.toBase58()])==null?void 0:h.equals(Vn)});P.addInstruction(F)}}}return u===0?P.sizeCheckBuildV0({computeBudgetConfig:a}):P.sizeCheckBuild({computeBudgetConfig:a})}async getWhiteListMint({programId:e}){let t=await this.scope.connection.getAccountInfo(ai(e).publicKey);return t?cc.decode(t.data).whitelistMints.filter(o=>!o.equals(Q.default)):[]}async getOwnerPositionInfo({programId:e=Dn}){await this.scope.account.fetchWalletTokenAccounts();let n=this.scope.account.tokenAccountRawInfos.filter(i=>i.accountInfo.amount.eq(new gt(1))).map(i=>bt(new Q(e),i.accountInfo.mint).publicKey),o=await this.scope.connection.getMultipleAccountsInfo(n),r=[];return o.forEach(i=>{if(!i)return;let s=Io.decode(i.data);r.push(s)}),r}async getOwnerLockedPositionInfo({programId:e=Uo}){await this.scope.account.fetchWalletTokenAccounts();let n=this.scope.account.tokenAccountRawInfos.filter(u=>u.accountInfo.amount.eq(new gt(1))).map(u=>ho(new Q(e),u.accountInfo.mint).publicKey),o=await this.scope.connection.getMultipleAccountsInfo(n),r=[];o.forEach(u=>{if(!u)return;let a=lc.decode(u.data);r.push(a)});let i=await this.scope.connection.getMultipleAccountsInfo(r.map(u=>u.positionId)),s=[];return i.forEach(u=>{if(!u)return;let a=Io.decode(u.data);s.push(a)}),r.map((u,a)=>({position:s[a],lockInfo:u}))}async getRpcClmmPoolInfo({poolId:e}){return(await this.getRpcClmmPoolInfos({poolIds:[e]}))[String(e)]}async getRpcClmmPoolInfos({poolIds:e,config:t}){let n=await Ne(this.scope.connection,e.map(r=>({pubkey:new Q(r)})),t),o={};for(let r=0;r<e.length;r++){let i=n[r];if(i===null||!i.accountInfo)throw Error("fetch pool info error: "+String(e[r]));let s=Zn.decode(i.accountInfo.data),u=ue.sqrtPriceX64ToPrice(s.sqrtPriceX64,s.mintDecimalsA,s.mintDecimalsB).toNumber();o[String(e[r])]=D(v({},s),{currentPrice:u,programId:i.accountInfo.owner})}return o}async getComputeClmmPoolInfos({clmmPoolsRpcInfo:e,mintInfos:t}){let n=new Set(Object.keys(e).map(u=>e[u].ammConfig.toBase58())),o=await Ne(this.scope.connection,Array.from(n).map(u=>({pubkey:new Q(u)}))),r={};o.forEach(u=>{!u.accountInfo||(r[u.pubkey.toBase58()]=ac.decode(u.accountInfo.data))});let i=await Me.fetchComputeMultipleClmmInfo({connection:this.scope.connection,rpcDataMap:e,poolList:Object.keys(e).map(u=>{var l,m,p,f;let[a,c]=[e[u].mintA.toBase58(),e[u].mintB.toBase58()];return{id:u,programId:e[u].programId.toBase58(),mintA:dt({address:a,decimals:e[u].mintDecimalsA,programId:t[a].programId.toBase58()||Ai.toBase58(),extensions:{feeConfig:(l=t[a])!=null&&l.feeConfig?Fn((m=t[a])==null?void 0:m.feeConfig):void 0}}),mintB:dt({address:c,decimals:e[u].mintDecimalsB,programId:t[c].programId.toBase58()||Ai.toBase58(),extensions:{feeConfig:(p=t[c])!=null&&p.feeConfig?Fn((f=t[c])==null?void 0:f.feeConfig):void 0}}),price:e[u].currentPrice,config:D(v({},r[e[u].ammConfig.toBase58()]),{id:e[u].ammConfig.toBase58(),fundFeeRate:0,description:"",defaultRange:0,defaultRangePoint:[]})}})}),s=await Me.fetchMultiplePoolTickArrays({connection:this.scope.connection,poolKeys:Object.values(i)});return{computeClmmPoolInfo:i,computePoolTickData:s}}async getPoolInfoFromRpc(e){var c;let t=await this.getRpcClmmPoolInfo({poolId:e}),n=new Set([t.mintA.toBase58(),t.mintB.toBase58()]),o=await go({connection:this.scope.connection,mints:Array.from(n).map(l=>new Q(l))}),{computeClmmPoolInfo:r,computePoolTickData:i}=await this.scope.clmm.getComputeClmmPoolInfos({clmmPoolsRpcInfo:{[e]:t},mintInfos:o}),s=await Ne(this.scope.connection,[{pubkey:t.vaultA},{pubkey:t.vaultB}]),u=rc(r[e]);if(!s[0].accountInfo||!s[1].accountInfo)throw new Error("pool vault data not found");u.mintAmountA=Number(Kc.decode(s[0].accountInfo.data).amount.toString()),u.mintAmountB=Number(Kc.decode((c=s[1].accountInfo)==null?void 0:c.data).amount.toString());let a=D(v({},r[e]),{exBitmapAccount:r[e].exBitmapAccount.toBase58(),observationId:r[e].observationId.toBase58(),id:e,programId:t.programId.toBase58(),openTime:t.startTime.toString(),vault:{A:t.vaultA.toBase58(),B:t.vaultB.toBase58()},config:u.config,rewardInfos:r[e].rewardInfos.filter(l=>!l.tokenVault.equals(Q.default)).map(l=>({mint:dt({address:l.tokenMint.toBase58(),programId:Ai.toBase58(),decimals:10}),vault:l.tokenVault.toBase58()}))});return{poolInfo:u,poolKeys:a,computePoolInfo:r[e],tickData:i}}};import{PublicKey as q}from"@solana/web3.js";import{AccountLayout as Jd,NATIVE_MINT as Co,TOKEN_PROGRAM_ID as Pt,createAssociatedTokenAccountIdempotentInstruction as Ro}from"@solana/spl-token";import Rc from"bn.js";import xr from"bn.js";function ra(d,e){if(e.isZero())throw Error("divisor is zero");return d.mod(e)}function Wd(d,e){if(e.isZero())throw Error("rhs is zero");let t=d.div(e);return ra(d,e).gt(wi)&&(t=t.add(new xr(1))),[t,e]}var wi=new xr(0),Ti=class{static swapBaseInputWithoutFees(e,t,n){let o=e.mul(n),r=t.add(e);return o.div(r)}static swapBaseOutputWithoutFees(e,t,n){let o=t.mul(e),r=n.sub(e),[i]=Wd(o,r);return i}static lpTokensToTradingTokens(e,t,n,o,r){let i=e.mul(n).div(t),s=e.mul(o).div(t);if(r===0)return{tokenAmount0:i,tokenAmount1:s};if(r===1)return ra(e.mul(n),t).gt(wi)&&i.gt(wi)&&(i=i.add(new xr(1))),ra(e.mul(o),t).gt(wi)&&s.gt(wi)&&(s=s.add(new xr(1))),{tokenAmount0:i,tokenAmount1:s};throw Error("roundDirection value error")}};import Dd from"bn.js";var ht=class{static tradingFee(e,t){return Vo(e,t,wt)}static protocolFee(e,t){return Qi(e,t,wt)}static fundFee(e,t){return Qi(e,t,wt)}static creatorFee(e,t){return Vo(e,t,wt)}static splitCreatorFee(e,t,n){return Qi(e,n,t.add(n))}static calculatePreFeeAmount(e,t){if(t.isZero())return e;let n=e.mul(wt),o=wt.sub(t);return n.add(o).sub(new Dd(1)).div(o)}};var hi=class{static validate_supply(e,t){if(e.isZero())throw Error("tokenAmount0 is zero");if(t.isZero())throw Error("tokenAmount1 is zero")}static swapBaseInput(e,t,n,o,r,i,s,u){let a=new Rc(0),c=ht.tradingFee(e,o),l;u?(a=ht.creatorFee(e,r),l=e.sub(c).sub(a)):l=e.sub(c);let m=ht.protocolFee(c,i),p=ht.protocolFee(c,s),f=Ti.swapBaseInputWithoutFees(l,t,n),y;return u?y=f:(a=ht.creatorFee(f,r),y=f.sub(a)),{newInputVaultAmount:t.add(l),newOutputVaultAmount:n.sub(f),inputAmount:e,outputAmount:y,tradeFee:c,protocolFee:m,fundFee:p,creatorFee:a}}static swapBaseOutput(e,t,n,o,r,i,s,u){let a,c=new Rc(0),l;if(u)l=e;else{let b=ht.calculatePreFeeAmount(e,r);c=b.sub(e),l=b}let m=Ti.swapBaseOutputWithoutFees(l,t,n),p;if(u){let b=ht.calculatePreFeeAmount(m,o.add(r)),g=b.sub(m);c=ht.splitCreatorFee(g,o,r),a=g.sub(c),p=b}else{let b=ht.calculatePreFeeAmount(m,o);a=b.sub(m),p=b}let f=ht.protocolFee(a,i),y=ht.fundFee(a,s);return{newInputVaultAmount:t.add(m),newOutputVaultAmount:e.sub(l),inputAmount:p,outputAmount:e,tradeFee:a,protocolFee:f,fundFee:y,creatorFee:c}}};import Ge from"bn.js";import qt from"decimal.js";import{PublicKey as xi,TransactionInstruction as Tn,Keypair as jd,SystemProgram as ua}from"@solana/web3.js";import{ASSOCIATED_TOKEN_PROGRAM_ID as Sr,TOKEN_2022_PROGRAM_ID as ca,TOKEN_PROGRAM_ID as wn}from"@solana/spl-token";var qd=Buffer.from("vault_and_lp_mint_auth_seed","utf8"),_B=Buffer.from("amm_config","utf8"),Ud=Buffer.from("pool","utf8"),Gd=Buffer.from("pool_lp_mint","utf8"),Xd=Buffer.from("pool_vault","utf8"),zd=Buffer.from("observation","utf8"),Yd=Buffer.from("permission","utf8");function Ko(d){return ce([qd],d)}function sa(d,e,t,n){return ce([Ud,e.toBuffer(),t.toBuffer(),n.toBuffer()],d)}function Qd(d,e){return ce([Gd,e.toBuffer()],d)}function Lc(d,e,t){return ce([Xd,e.toBuffer(),t.toBuffer()],d)}function Ii(d,e){return ce([zd,e.toBuffer()],d)}function aa({poolId:d,programId:e,configId:t,mintA:n,mintB:o}){let r=Ko(e).publicKey,i=d||sa(e,t,n,o).publicKey,s=Qd(e,i).publicKey,u=Lc(e,i,n).publicKey,a=Lc(e,i,o).publicKey,c=Ii(e,i).publicKey;return{poolId:i,configId:t,authority:r,lpMint:s,vaultA:u,vaultB:a,observationId:c}}var Hd=Buffer.from("locked_liquidity","utf8");function Bi(d,e){return ce([Hd,e.toBuffer()],d)}function Oc(d,e){return ce([Yd,e.toBuffer()],d)}var $d=ge("Raydium_cpmm"),hn={initialize:[175,175,109,31,13,152,155,237],deposit:[242,35,198,137,82,225,242,182],withdraw:[183,18,70,156,148,109,161,34],swapBaseInput:[143,190,90,218,196,30,51,222],swapBaseOutput:[55,217,98,86,163,74,180,173],lockCpLiquidity:[216,157,29,78,38,51,31,26],collectCpFee:[8,30,51,199,209,184,247,133],createPermissionPda:Buffer.from([135,136,2,216,137,169,181,202]),closePermissionPda:Buffer.from([156,84,32,118,69,135,70,123]),initializeWithPermission:Buffer.from([63,55,254,65,49,178,89,121]),collectCreatorFee:Buffer.from([20,22,86,123,198,28,219,132])};function Nc(d,e,t,n,o,r,i,s,u,a,c,l,m,p,f,y,b,g,P,T){let h=_([A("amountMaxA"),A("amountMaxB"),A("openTime")]),w=sa(d,t,r,i).publicKey,k=[{pubkey:e,isSigner:!0,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!o.equals(w),isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!1},{pubkey:i,isSigner:!1,isWritable:!1},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:m,isSigner:!1,isWritable:!0},{pubkey:p,isSigner:!1,isWritable:!0},{pubkey:b,isSigner:!1,isWritable:!0},{pubkey:wn,isSigner:!1,isWritable:!1},{pubkey:f,isSigner:!1,isWritable:!1},{pubkey:y,isSigner:!1,isWritable:!1},{pubkey:Sr,isSigner:!1,isWritable:!1},{pubkey:Zr,isSigner:!1,isWritable:!1},{pubkey:it,isSigner:!1,isWritable:!1}],x=Buffer.alloc(h.span);return h.encode({amountMaxA:g,amountMaxB:P,openTime:T},x),new Tn({keys:k,programId:d,data:Buffer.from([...hn.initialize,...x])})}function Mc(d,e,t,n,o,r,i,s,u,a,c,l,m,p,f){let y=_([A("lpAmount"),A("amountMaxA"),A("amountMaxB")]),b=[{pubkey:e,isSigner:!0,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:wn,isSigner:!1,isWritable:!1},{pubkey:ca,isSigner:!1,isWritable:!1},{pubkey:a,isSigner:!1,isWritable:!1},{pubkey:c,isSigner:!1,isWritable:!1},{pubkey:l,isSigner:!1,isWritable:!0}],g=Buffer.alloc(y.span);return $d.debug("cpmm deposit data",{lpAmount:m.toString(),amountMaxA:p.toString(),amountMaxB:f.toString()}),y.encode({lpAmount:m,amountMaxA:p,amountMaxB:f},g),new Tn({keys:b,programId:d,data:Buffer.from([...hn.deposit,...g])})}function vc(d,e,t,n,o,r,i,s,u,a,c,l,m,p,f){let y=_([A("lpAmount"),A("amountMinA"),A("amountMinB")]),b=[{pubkey:e,isSigner:!0,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:wn,isSigner:!1,isWritable:!1},{pubkey:ca,isSigner:!1,isWritable:!1},{pubkey:a,isSigner:!1,isWritable:!1},{pubkey:c,isSigner:!1,isWritable:!1},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:Sn,isSigner:!1,isWritable:!1}],g=Buffer.alloc(y.span);return y.encode({lpAmount:m,amountMinA:p,amountMinB:f},g),new Tn({keys:b,programId:d,data:Buffer.from([...hn.withdraw,...g])})}function Kr(d,e,t,n,o,r,i,s,u,a,c,l,m,p,f,y){let b=_([A("amountIn"),A("amounOutMin")]),g=[{pubkey:e,isSigner:!0,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!1},{pubkey:c,isSigner:!1,isWritable:!1},{pubkey:l,isSigner:!1,isWritable:!1},{pubkey:m,isSigner:!1,isWritable:!1},{pubkey:p,isSigner:!1,isWritable:!0}],P=Buffer.alloc(b.span);return b.encode({amountIn:f,amounOutMin:y},P),new Tn({keys:g,programId:d,data:Buffer.from([...hn.swapBaseInput,...P])})}function Fc(d,e,t,n,o,r,i,s,u,a,c,l,m,p,f,y){let b=_([A("amountInMax"),A("amountOut")]),g=[{pubkey:e,isSigner:!0,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!1},{pubkey:c,isSigner:!1,isWritable:!1},{pubkey:l,isSigner:!1,isWritable:!1},{pubkey:m,isSigner:!1,isWritable:!1},{pubkey:p,isSigner:!1,isWritable:!0}],P=Buffer.alloc(b.span);return b.encode({amountInMax:f,amountOut:y},P),new Tn({keys:g,programId:d,data:Buffer.from([...hn.swapBaseOutput,...P])})}async function _c(d){var b;let{ownerInfo:e,poolInfo:t,poolKeys:n,feeNftOwner:o,getEphemeralSigners:r}=d,i=[],[s,u]=[new xi(t.id),new xi(t.lpMint.address)],a;if(r)a=new xi((await r(1))[0]);else{let g=jd.generate();i.push(g),a=g.publicKey}let{publicKey:c}=Z(o,a,wn),{publicKey:l}=Pn(a),{publicKey:m}=Bi(d.lockProgram,a),{publicKey:p}=Z(e.wallet,u,wn),{publicKey:f}=Z(d.lockAuthProgram,u,wn),y=Zd({programId:d.lockProgram,auth:d.lockAuthProgram,payer:e.feePayer,liquidityOwner:e.wallet,nftOwner:o,nftMint:a,nftAccount:c,poolId:s,lockPda:m,mintLp:u,userLpVault:p,lockLpVault:f,poolVaultA:new xi(n.vault.A),poolVaultB:new xi(n.vault.B),metadataAccount:l,lpAmount:d.lpAmount,withMetadata:(b=d.withMetadata)!=null?b:!0});return{address:{nftMint:a,nftAccount:c,metadataAccount:l,lockPda:m,userLpVault:p,lockLpVault:f},instructions:[y],signers:i,instructionTypes:[U.CpmmLockLp],lookupTableAddress:[]}}function Zd({programId:d,auth:e,payer:t,liquidityOwner:n,nftOwner:o,nftMint:r,nftAccount:i,poolId:s,lockPda:u,mintLp:a,userLpVault:c,lockLpVault:l,poolVaultA:m,poolVaultB:p,metadataAccount:f,lpAmount:y,withMetadata:b}){let g=[{pubkey:e,isSigner:!1,isWritable:!1},{pubkey:t,isSigner:!0,isWritable:!0},{pubkey:n,isSigner:!0,isWritable:!1},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!0,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!1},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!1},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:m,isSigner:!1,isWritable:!0},{pubkey:p,isSigner:!1,isWritable:!0},{pubkey:f,isSigner:!1,isWritable:!0},{pubkey:it,isSigner:!1,isWritable:!1},{pubkey:ua.programId,isSigner:!1,isWritable:!1},{pubkey:wn,isSigner:!1,isWritable:!1},{pubkey:Sr,isSigner:!1,isWritable:!1},{pubkey:$t,isSigner:!1,isWritable:!1}],P=_([A("lpAmount"),qe("withMetadata")]),T=Buffer.alloc(P.span);P.encode({lpAmount:y,withMetadata:b},T);let h=Buffer.from([...hn.lockCpLiquidity,...T]);return new Tn({keys:g,programId:d,data:h})}function la({programId:d,nftOwner:e,auth:t,nftAccount:n,lockPda:o,poolId:r,mintLp:i,userVaultA:s,userVaultB:u,poolVaultA:a,poolVaultB:c,mintA:l,mintB:m,lockLpVault:p,lpFeeAmount:f,cpmmProgram:y,cpmmAuthProgram:b}){let g=[{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:e,isSigner:!0,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:y!=null?y:Un,isSigner:!1,isWritable:!1},{pubkey:b!=null?b:uu,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!1},{pubkey:m,isSigner:!1,isWritable:!1},{pubkey:p,isSigner:!1,isWritable:!0},{pubkey:wn,isSigner:!1,isWritable:!1},{pubkey:ca,isSigner:!1,isWritable:!1},{pubkey:Sn,isSigner:!1,isWritable:!1}],P=_([A("lpFeeAmount")]),T=Buffer.alloc(P.span);P.encode({lpFeeAmount:f},T);let h=Buffer.from([...hn.collectCpFee,...T]);return new Tn({keys:g,programId:d,data:h})}function ma(d,e,t,n,o,r,i,s,u,a,c,l,m){let p=[{pubkey:e,isSigner:!0,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!1},{pubkey:u,isSigner:!1,isWritable:!1},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!1},{pubkey:m,isSigner:!1,isWritable:!1},{pubkey:Sr,isSigner:!1,isWritable:!1},{pubkey:ua.programId,isSigner:!1,isWritable:!1}];return new Tn({keys:p,programId:d,data:hn.collectCreatorFee})}function Vc(d,e,t,n,o,r,i,s,u,a,c,l,m,p,f,y,b,g,P,T,h,w,k){let x=_([A("amountA"),A("amountB"),A("openTime"),V("feeOn")]),B=[{pubkey:e,isSigner:!0,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!1},{pubkey:s,isSigner:!1,isWritable:!1},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:m,isSigner:!1,isWritable:!0},{pubkey:p,isSigner:!1,isWritable:!0},{pubkey:f,isSigner:!1,isWritable:!0},{pubkey:g,isSigner:!1,isWritable:!0},{pubkey:P,isSigner:!1,isWritable:!0},{pubkey:wn,isSigner:!1,isWritable:!1},{pubkey:y,isSigner:!1,isWritable:!1},{pubkey:b,isSigner:!1,isWritable:!1},{pubkey:Sr,isSigner:!1,isWritable:!1},{pubkey:ua.programId,isSigner:!1,isWritable:!1}],K=Buffer.alloc(x.span);return x.encode({amountA:T,amountB:h,openTime:w,feeOn:k},K),new Tn({keys:B,programId:d,data:Buffer.from([...hn.initializeWithPermission,...K])})}var Ec=_([Te(8),V("bump"),qe("disableCreatePool"),St("index"),A("tradeFeeRate"),A("protocolFeeRate"),A("fundFeeRate"),A("createPoolFee"),M("protocolOwner"),M("fundOwner"),A("creatorFeeRate"),Y(A(),15)]),Cr=_([Te(8),M("configId"),M("poolCreator"),M("vaultA"),M("vaultB"),M("mintLp"),M("mintA"),M("mintB"),M("mintProgramA"),M("mintProgramB"),M("observationId"),V("bump"),V("status"),V("lpDecimals"),V("mintDecimalA"),V("mintDecimalB"),A("lpAmount"),A("protocolFeesMintA"),A("protocolFeesMintB"),A("fundFeesMintA"),A("fundFeesMintB"),A("openTime"),A("epoch"),V("feeOn"),qe("enableCreatorFee"),Y(V(),6),A("creatorFeesMintA"),A("creatorFeesMintB"),Y(A(),28)]),jB=_([Te(8),M("configId"),Y(A(),30)]);var Si=class extends _e{constructor(e){super(e)}async load(){this.checkDisabled()}async getCpmmPoolKeys(e){return(await this.scope.api.fetchPoolKeysById({idList:[e]}))[0]}async getRpcPoolInfo(e,t){return(await this.getRpcPoolInfos([e],t))[e]}async getRpcPoolInfos(e,t){let n=await Ne(this.scope.connection,e.map(l=>({pubkey:new q(l)}))),o={},r=new Set,i=[];for(let l=0;l<e.length;l++){let m=n[l];if(m.accountInfo===null)throw Error("fetch pool info error: "+String(e[l]));let p=Cr.decode(m.accountInfo.data);o[String(e[l])]=D(v({},p),{programId:m.accountInfo.owner}),r.add(String(p.configId)),i.push(p.vaultA,p.vaultB)}let s={};if(t){let l=[...r],m=await Ne(this.scope.connection,l.map(p=>({pubkey:new q(p)})));for(let p=0;p<l.length;p++){let f=m[p].accountInfo;if(f===null)throw Error("fetch pool config error: "+l[p]);s[l[p]]=Ec.decode(f.data)}}let u={},a=await Ne(this.scope.connection,i.map(l=>({pubkey:new q(l)})));for(let l=0;l<i.length;l++){let m=a[l].accountInfo;if(m===null)throw Error("fetch vault info error: "+i[l]);u[String(i[l])]=new Ge(Jd.decode(m.data).amount.toString())}let c={};for(let[l,m]of Object.entries(o)){let p=u[m.vaultA.toString()].sub(m.protocolFeesMintA).sub(m.fundFeesMintA).sub(m.creatorFeesMintA),f=u[m.vaultB.toString()].sub(m.protocolFeesMintB).sub(m.fundFeesMintB).sub(m.creatorFeesMintB);c[l]=D(v({},m),{baseReserve:p,quoteReserve:f,vaultAAmount:u[m.vaultA.toString()],vaultBAmount:u[m.vaultB.toString()],configInfo:s[m.configId.toString()],poolPrice:new qt(f.toString()).div(new qt(10).pow(m.mintDecimalB)).div(new qt(p.toString()).div(new qt(10).pow(m.mintDecimalA)))})}return c}toComputePoolInfos({pools:e,mintInfos:t}){return Object.keys(e).reduce((n,o)=>{var u,a,c,l;let r=e[o],[i,s]=[r.mintA.toBase58(),r.mintB.toBase58()];return D(v({},n),{[o]:D(v({},r),{id:new q(o),configInfo:r.configInfo,version:7,authority:Ko(r.programId).publicKey,mintA:dt({address:i,decimals:r.mintDecimalA,programId:r.mintProgramA.toBase58(),extensions:{feeConfig:(u=t[i])!=null&&u.feeConfig?Fn((a=t[i])==null?void 0:a.feeConfig):void 0}}),mintB:dt({address:s,decimals:r.mintDecimalB,programId:r.mintProgramB.toBase58(),extensions:{feeConfig:(c=t[s])!=null&&c.feeConfig?Fn((l=t[s])==null?void 0:l.feeConfig):void 0}})})})},{})}async getPoolInfoFromRpc(e){let t=await this.getRpcPoolInfo(e,!0),n=await go({connection:this.scope.connection,mints:[t.mintA,t.mintB]}),o=dt({address:t.mintA.toBase58(),decimals:t.mintDecimalA,programId:t.mintProgramA.toBase58(),extensions:{feeConfig:n[t.mintA.toBase58()].feeConfig?Fn(n[t.mintA.toBase58()].feeConfig):void 0}}),r=dt({address:t.mintB.toBase58(),decimals:t.mintDecimalB,programId:t.mintProgramB.toBase58(),extensions:{feeConfig:n[t.mintB.toBase58()].feeConfig?Fn(n[t.mintB.toBase58()].feeConfig):void 0}}),i=dt({address:t.mintLp.toBase58(),decimals:t.lpDecimals,programId:Pt.toBase58()}),s={id:t.configId.toBase58(),index:t.configInfo.index,protocolFeeRate:t.configInfo.protocolFeeRate.toNumber(),tradeFeeRate:t.configInfo.tradeFeeRate.toNumber(),fundFeeRate:t.configInfo.fundFeeRate.toNumber(),createPoolFee:t.configInfo.createPoolFee.toString()},u={volume:0,volumeQuote:0,volumeFee:0,apr:0,feeApr:0,priceMin:0,priceMax:0,rewardApr:[]};return{poolInfo:{programId:t.programId.toBase58(),id:e,type:"Standard",lpMint:i,lpPrice:0,lpAmount:t.lpAmount.toNumber(),config:s,mintA:o,mintB:r,rewardDefaultInfos:[],rewardDefaultPoolInfos:"Ecosystem",price:t.poolPrice.toNumber(),mintAmountA:new qt(t.vaultAAmount.toString()).div(10**o.decimals).toNumber(),mintAmountB:new qt(t.vaultBAmount.toString()).div(10**r.decimals).toNumber(),feeRate:t.configInfo.tradeFeeRate.toNumber(),openTime:t.openTime.toString(),tvl:0,burnPercent:0,day:u,week:u,month:u,pooltype:[],farmUpcomingCount:0,farmOngoingCount:0,farmFinishedCount:0},poolKeys:{programId:t.programId.toBase58(),id:e,mintA:o,mintB:r,openTime:t.openTime.toString(),vault:{A:t.vaultA.toBase58(),B:t.vaultB.toBase58()},authority:Ko(t.programId).publicKey.toBase58(),mintLp:i,config:s,observationId:Ii(t.programId,new q(e)).publicKey.toBase58()},rpcData:t}}async createPool(f){var y=f,{poolId:e,programId:t,poolFeeAccount:n,startTime:o,ownerInfo:r,associatedOnly:i=!1,checkCreateATAOwner:s=!1,txVersion:u,feeConfig:a,computeBudgetConfig:c,txTipConfig:l,feePayer:m}=y,p=ve(y,["poolId","programId","poolFeeAccount","startTime","ownerInfo","associatedOnly","checkCreateATAOwner","txVersion","feeConfig","computeBudgetConfig","txTipConfig","feePayer"]);var F,G,z;let b=r.feePayer||((F=this.scope.owner)==null?void 0:F.publicKey),g=new Ge(new q(p.mintA.address).toBuffer()).lte(new Ge(new q(p.mintB.address).toBuffer())),[P,T]=g?[p.mintA,p.mintB]:[p.mintB,p.mintA],[h,w]=g?[p.mintAAmount,p.mintBAmount]:[p.mintBAmount,p.mintAAmount],k=r.useSOLBalance&&P.address===Co.toBase58(),x=r.useSOLBalance&&T.address===Co.toBase58(),[B,K]=[new q(P.address),new q(T.address)],I=this.createTxBuilder(m),{account:R,instructionParams:C}=await this.scope.account.getOrCreateTokenAccount({mint:B,tokenProgram:P.programId,owner:this.scope.ownerPubKey,createInfo:k?{payer:b,amount:h}:void 0,notUseTokenAccount:k,skipCloseAccount:!k,associatedOnly:k?!1:i,checkCreateATAOwner:s});I.addInstruction(C||{});let{account:N,instructionParams:L}=await this.scope.account.getOrCreateTokenAccount({mint:new q(T.address),tokenProgram:T.programId,owner:this.scope.ownerPubKey,createInfo:x?{payer:b,amount:w}:void 0,notUseTokenAccount:x,skipCloseAccount:!x,associatedOnly:x?!1:i,checkCreateATAOwner:s});if(I.addInstruction(L||{}),R===void 0||N===void 0)throw Error("you don't has some token account");let O=aa({poolId:e,programId:t,configId:new q(a.id),mintA:B,mintB:K});return I.addInstruction({instructions:[Nc(t,this.scope.ownerPubKey,new q(a.id),O.authority,O.poolId,B,K,O.lpMint,R,N,Z(this.scope.ownerPubKey,O.lpMint).publicKey,O.vaultA,O.vaultB,n,new q((G=P.programId)!=null?G:Pt),new q((z=T.programId)!=null?z:Pt),O.observationId,h,w,o)],instructionTypes:[U.CpmmCreatePool]}),I.addCustomComputeBudget(c),I.addTipInstruction(l),I.versionBuild({txVersion:u,extInfo:{address:D(v({},O),{mintA:P,mintB:T,programId:t,poolFeeAccount:n,feeConfig:a})}})}async addLiquidity(e){let{poolInfo:t,poolKeys:n,inputAmount:o,baseIn:r,slippage:i,computeResult:s,computeBudgetConfig:u,txTipConfig:a,config:c,txVersion:l,feePayer:m}=e;this.scope.availability.addStandardPosition===!1&&this.logAndCreateError("add liquidity feature disabled in your region"),o.isZero()&&this.logAndCreateError("amounts must greater than zero","amountInA",{amountInA:o.toString()});let{account:p}=this.scope,{bypassAssociatedCheck:f,checkCreateATAOwner:y}=v({bypassAssociatedCheck:!1,checkCreateATAOwner:!1},c),b=s?void 0:await this.getRpcPoolInfo(t.id),{liquidity:g,inputAmountFee:P,anotherAmount:T}=s||this.computePairAmount({poolInfo:D(v({},t),{lpAmount:new qt(b.lpAmount.toString()).div(10**t.lpMint.decimals).toNumber()}),baseReserve:b.baseReserve,quoteReserve:b.quoteReserve,slippage:new tt(0),baseIn:r,epochInfo:await this.scope.fetchEpochInfo(),amount:new qt(o.toString()).div(10**(r?t.mintA.decimals:t.mintB.decimals))}),h=T.amount,w=t.mintA.address===Co.toString(),k=t.mintB.address===Co.toString(),x=this.createTxBuilder(m),[B,K]=[new q(t.mintA.address),new q(t.mintB.address)],{account:I,instructionParams:R}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:t.mintA.programId,mint:new q(t.mintA.address),owner:this.scope.ownerPubKey,createInfo:w||(r?o:h).isZero()?{payer:this.scope.ownerPubKey,amount:r?o:h}:void 0,skipCloseAccount:!w,notUseTokenAccount:w,associatedOnly:!1,checkCreateATAOwner:y});x.addInstruction(R||{});let{account:C,instructionParams:N}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:t.mintB.programId,mint:new q(t.mintB.address),owner:this.scope.ownerPubKey,createInfo:k||(r?h:o).isZero()?{payer:this.scope.ownerPubKey,amount:r?h:o}:void 0,skipCloseAccount:!k,notUseTokenAccount:k,associatedOnly:!1,checkCreateATAOwner:y});x.addInstruction(N||{}),!I&&!C&&this.logAndCreateError("cannot found target token accounts","tokenAccounts",p.tokenAccounts);let L=await p.getCreatedTokenAccount({mint:new q(t.lpMint.address)}),$=await p.handleTokenAccount({side:"out",amount:0,mint:new q(t.lpMint.address),tokenAccount:L,bypassAssociatedCheck:f,checkCreateATAOwner:y}),{tokenAccount:O}=$,F=ve($,["tokenAccount"]);x.addInstruction(F);let G=n!=null?n:await this.getCpmmPoolKeys(t.id),z=new tt(new Ge(1)).sub(i);return x.addInstruction({instructions:[Mc(new q(t.programId),this.scope.ownerPubKey,new q(G.authority),new q(t.id),O,I,C,new q(G.vault.A),new q(G.vault.B),B,K,new q(t.lpMint.address),s?s==null?void 0:s.liquidity:z.mul(g).quotient,r?P.amount:h,r?h:P.amount)],instructionTypes:[U.CpmmAddLiquidity],lookupTableAddress:G.lookupTableAccount?[G.lookupTableAccount]:[]}),x.addCustomComputeBudget(u),x.addTipInstruction(a),x.versionBuild({txVersion:l})}async withdrawLiquidity(e){var F,G;let{poolInfo:t,poolKeys:n,lpAmount:o,slippage:r,computeBudgetConfig:i,txTipConfig:s,txVersion:u,feePayer:a,closeWsol:c=!0}=e;this.scope.availability.addStandardPosition===!1&&this.logAndCreateError("add liquidity feature disabled in your region");let l=new tt(new Ge(1)).sub(r),m=await this.getRpcPoolInfo(t.id),[p,f]=[l.mul(o.mul(m.baseReserve).div(m.lpAmount)).quotient,l.mul(o.mul(m.quoteReserve).div(m.lpAmount)).quotient],y=await this.scope.fetchEpochInfo(),[b,g]=[Ke(p,t.mintA.extensions.feeConfig,y,!1),Ke(f,t.mintB.extensions.feeConfig,y,!1)],{account:P}=this.scope,T=this.createTxBuilder(a),[h,w]=[new q(t.mintA.address),new q(t.mintB.address)],k=h.equals(H),x=w.equals(H),B,K,{account:I,instructionParams:R}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:t.mintA.programId,mint:new q(t.mintA.address),notUseTokenAccount:k,owner:this.scope.ownerPubKey,createInfo:{payer:this.scope.ownerPubKey,amount:0},skipCloseAccount:!(k&&c),associatedOnly:!k,checkCreateATAOwner:!1});B=I,R&&T.addInstruction(R);let{account:C,instructionParams:N}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:t.mintB.programId,mint:new q(t.mintB.address),notUseTokenAccount:x,owner:this.scope.ownerPubKey,createInfo:{payer:this.scope.ownerPubKey,amount:0},skipCloseAccount:!(x&&c),associatedOnly:!x,checkCreateATAOwner:!1});K=C,N&&T.addInstruction(N),(!B||!K)&&this.logAndCreateError("cannot found target token accounts","tokenAccounts",P.tokenAccounts);let L=await P.getCreatedTokenAccount({mint:new q(t.lpMint.address)});L||this.logAndCreateError("cannot found lp token account","tokenAccounts",P.tokenAccounts);let O=n!=null?n:await this.getCpmmPoolKeys(t.id);return T.addInstruction({instructions:[vc(new q(t.programId),this.scope.ownerPubKey,new q(O.authority),new q(t.id),L,B,K,new q(O.vault.A),new q(O.vault.B),h,w,new q(t.lpMint.address),o,p.sub((F=b.fee)!=null?F:new Ge(0)),f.sub((G=g.fee)!=null?G:new Ge(0)))],instructionTypes:[U.CpmmWithdrawLiquidity],lookupTableAddress:O.lookupTableAccount?[O.lookupTableAccount]:[]}),T.addCustomComputeBudget(i),T.addTipInstruction(s),T.versionBuild({txVersion:u})}async swap(e){var R,C,N,L,O,F;let{poolInfo:t,poolKeys:n,baseIn:o,fixedOut:r,inputAmount:i,swapResult:s,slippage:u=0,config:a,computeBudgetConfig:c,txTipConfig:l,txVersion:m,feePayer:p}=e,{bypassAssociatedCheck:f,checkCreateATAOwner:y,associatedOnly:b}=v({bypassAssociatedCheck:!1,checkCreateATAOwner:!1,associatedOnly:!0},a),g=this.createTxBuilder(p),[P,T]=[new q(t.mintA.address),new q(t.mintB.address)];r?s.inputAmount=s.inputAmount.mul(new Ge((1+u)*1e4)).div(new Ge(1e4)):s.outputAmount=s.outputAmount.mul(new Ge((1-u)*1e4)).div(new Ge(1e4));let h=t.mintA.address===H.toBase58(),w=t.mintB.address===H.toBase58(),{account:k,instructionParams:x}=await this.scope.account.getOrCreateTokenAccount({mint:P,tokenProgram:new q((R=t.mintA.programId)!=null?R:Pt),owner:this.scope.ownerPubKey,createInfo:h||!o?{payer:this.scope.ownerPubKey,amount:o?s.inputAmount:0}:void 0,notUseTokenAccount:h,skipCloseAccount:!h,associatedOnly:h?!1:b,checkCreateATAOwner:y});x&&g.addInstruction(x);let{account:B,instructionParams:K}=await this.scope.account.getOrCreateTokenAccount({mint:T,tokenProgram:new q((C=t.mintB.programId)!=null?C:Pt),owner:this.scope.ownerPubKey,createInfo:w||o?{payer:this.scope.ownerPubKey,amount:o?0:s.inputAmount}:void 0,notUseTokenAccount:w,skipCloseAccount:!w,associatedOnly:w?!1:b,checkCreateATAOwner:y});K&&g.addInstruction(K),(!k||!B)&&this.logAndCreateError("user do not have token account",{mintA:t.mintA.symbol||t.mintA.address,mintB:t.mintB.symbol||t.mintB.address,mintATokenAcc:k,mintBTokenAcc:B,mintAUseSOLBalance:h,mintBUseSOLBalance:w,associatedOnly:b});let I=n!=null?n:await this.getCpmmPoolKeys(t.id);return g.addInstruction({instructions:[r?Fc(new q(t.programId),this.scope.ownerPubKey,new q(I.authority),new q(I.config.id),new q(t.id),o?k:B,o?B:k,new q(I.vault[o?"A":"B"]),new q(I.vault[o?"B":"A"]),new q((O=t[o?"mintA":"mintB"].programId)!=null?O:Pt),new q((F=t[o?"mintB":"mintA"].programId)!=null?F:Pt),o?P:T,o?T:P,Ii(new q(t.programId),new q(t.id)).publicKey,s.inputAmount,s.outputAmount):Kr(new q(t.programId),this.scope.ownerPubKey,new q(I.authority),new q(I.config.id),new q(t.id),o?k:B,o?B:k,new q(I.vault[o?"A":"B"]),new q(I.vault[o?"B":"A"]),new q((N=t[o?"mintA":"mintB"].programId)!=null?N:Pt),new q((L=t[o?"mintB":"mintA"].programId)!=null?L:Pt),o?P:T,o?T:P,Ii(new q(t.programId),new q(t.id)).publicKey,i,s.outputAmount)],instructionTypes:[r?U.CpmmSwapBaseOut:U.ClmmSwapBaseIn]}),g.addCustomComputeBudget(c),g.addTipInstruction(l),g.versionBuild({txVersion:m})}async lockLp(e){var m,p,f,y,b;let{poolInfo:t,lpAmount:n,computeBudgetConfig:o,txTipConfig:r,txVersion:i,feePayer:s,feeNftOwner:u}=e;n.isZero()&&this.logAndCreateError("lpAmount must greater than zero",{lpAmount:n.toString()});let a=this.createTxBuilder(s),c=(m=e.poolKeys)!=null?m:await this.getCpmmPoolKeys(t.id),l=await _c({poolInfo:t,poolKeys:c,ownerInfo:{wallet:this.scope.ownerPubKey,feePayer:(p=e.feePayer)!=null?p:this.scope.ownerPubKey},feeNftOwner:u!=null?u:this.scope.ownerPubKey,lockProgram:(f=e.programId)!=null?f:$i,lockAuthProgram:(y=e.authProgram)!=null?y:Zi,lpAmount:n,withMetadata:(b=e.withMetadata)!=null?b:!0,getEphemeralSigners:e.getEphemeralSigners});return a.addInstruction(l),a.addCustomComputeBudget(o),a.addTipInstruction(r),a.versionBuild({txVersion:i,extInfo:l.address})}async harvestLockLp(e){var C;let{poolInfo:t,lpFeeAmount:n,nftMint:o,programId:r=$i,authProgram:i=Zi,cpmmProgram:s,computeBudgetConfig:u,txTipConfig:a,txVersion:c,closeWsol:l=!0}=e;n.isZero()&&this.logAndCreateError("lpFeeAmount must greater than zero",{lpAmount:n.toString()});let m=e.feePayer||this.scope.ownerPubKey,p=this.createTxBuilder(m),[f,y]=[new q(t.mintA.address),new q(t.mintB.address)],b=f.equals(H),g=y.equals(H),P,T,{account:h,instructionParams:w}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:t.mintA.programId,mint:new q(t.mintA.address),notUseTokenAccount:b,owner:this.scope.ownerPubKey,createInfo:{payer:this.scope.ownerPubKey,amount:0},skipCloseAccount:!(b&&l),associatedOnly:!b,checkCreateATAOwner:!1});P=h,w&&p.addInstruction(w);let{account:k,instructionParams:x}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:t.mintB.programId,mint:new q(t.mintB.address),notUseTokenAccount:g,owner:this.scope.ownerPubKey,createInfo:{payer:this.scope.ownerPubKey,amount:0},skipCloseAccount:!(g&&l),associatedOnly:!g,checkCreateATAOwner:!1});T=k,x&&p.addInstruction(x),(!P||!T)&&this.logAndCreateError("cannot found target token accounts",{tokenAccountA:P,tokenAccountB:T});let B=(C=e.poolKeys)!=null?C:await this.getCpmmPoolKeys(t.id),{publicKey:K}=Z(m,o,Pt),{publicKey:I}=Bi(r,o),{publicKey:R}=Z(i,new q(t.lpMint.address),Pt);return p.addInstruction({instructions:[la({programId:r,nftOwner:this.scope.ownerPubKey,auth:i,nftMint:o,nftAccount:K,lockPda:I,poolId:new q(t.id),mintLp:new q(B.mintLp.address),userVaultA:P,userVaultB:T,poolVaultA:new q(B.vault.A),poolVaultB:new q(B.vault.B),mintA:f,mintB:y,lockLpVault:R,lpFeeAmount:n,cpmmProgram:s==null?void 0:s.programId,cpmmAuthProgram:s==null?void 0:s.authProgram})],instructionTypes:[U.CpmmCollectLockFee]}),p.addCustomComputeBudget(u),p.addTipInstruction(a),p.versionBuild({txVersion:c})}async harvestMultiLockLp(e){var m;let{lockInfo:t,programId:n=$i,authProgram:o=Zi,cpmmProgram:r,computeBudgetConfig:i,txVersion:s,closeWsol:u=!0}=e,a=e.feePayer||this.scope.ownerPubKey,c=this.createTxBuilder(a),l={};for(let p of t){let{poolInfo:f,lpFeeAmount:y,nftMint:b}=p;if(y.isZero())continue;let[g,P]=[new q(f.mintA.address),new q(f.mintB.address)],T=g.equals(H),h=P.equals(H),w=l[f.mintA.address],k=l[f.mintB.address];if(!w)if(T){let{account:R,instructionParams:C}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:f.mintA.programId,mint:new q(f.mintA.address),notUseTokenAccount:!0,owner:this.scope.ownerPubKey,createInfo:{payer:this.scope.ownerPubKey,amount:0},skipCloseAccount:!u,associatedOnly:!1,checkCreateATAOwner:!1});w=R,C&&c.addInstruction(C),l[f.mintA.address]=R}else{let R=new q(f.mintA.address);w=this.scope.account.getAssociatedTokenAccount(R,new q(f.mintA.programId)),c.addInstruction({instructions:[Ro(this.scope.ownerPubKey,w,this.scope.ownerPubKey,R,new q(f.mintA.programId))]}),l[f.mintA.address]=w}if(!k)if(h){let{account:R,instructionParams:C}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:f.mintB.programId,mint:new q(f.mintB.address),notUseTokenAccount:!0,owner:this.scope.ownerPubKey,createInfo:{payer:this.scope.ownerPubKey,amount:0},skipCloseAccount:!u,associatedOnly:!1,checkCreateATAOwner:!1});k=R,C&&c.addInstruction(C),l[f.mintB.address]=R}else{let R=new q(f.mintB.address);k=this.scope.account.getAssociatedTokenAccount(R,new q(f.mintB.programId)),c.addInstruction({instructions:[Ro(this.scope.ownerPubKey,k,this.scope.ownerPubKey,R,new q(f.mintB.programId))]}),l[f.mintB.address]=k}(!w||!k)&&this.logAndCreateError("cannot found target token accounts",{tokenAccountA:w,tokenAccountB:k});let x=(m=p.poolKeys)!=null?m:await this.getCpmmPoolKeys(f.id),{publicKey:B}=Z(a,b,Pt),{publicKey:K}=Bi(n,b),{publicKey:I}=Z(o,new q(f.lpMint.address),Pt);c.addInstruction({instructions:[la({programId:n,nftOwner:this.scope.ownerPubKey,auth:o,nftMint:b,nftAccount:B,lockPda:K,poolId:new q(f.id),mintLp:new q(x.mintLp.address),userVaultA:w,userVaultB:k,poolVaultA:new q(x.vault.A),poolVaultB:new q(x.vault.B),mintA:g,mintB:P,lockLpVault:I,lpFeeAmount:y,cpmmProgram:r==null?void 0:r.programId,cpmmAuthProgram:r==null?void 0:r.authProgram})],instructionTypes:[U.CpmmCollectLockFee]})}return s===0?c.sizeCheckBuildV0({computeBudgetConfig:i}):c.sizeCheckBuild({computeBudgetConfig:i})}async createPoolWithPermission(y){var b=y,{poolId:e,programId:t,poolFeeAccount:n,startTime:o,ownerInfo:r,associatedOnly:i=!1,checkCreateATAOwner:s=!1,txVersion:u,feeConfig:a,computeBudgetConfig:c,txTipConfig:l,feePayer:m,feeOn:p}=b,f=ve(b,["poolId","programId","poolFeeAccount","startTime","ownerInfo","associatedOnly","checkCreateATAOwner","txVersion","feeConfig","computeBudgetConfig","txTipConfig","feePayer","feeOn"]);var G,z,$;console.log("***this method only available for wallet with permissions***");let g=r.feePayer||((G=this.scope.owner)==null?void 0:G.publicKey),P=new Ge(new q(f.mintA.address).toBuffer()).lte(new Ge(new q(f.mintB.address).toBuffer())),[T,h]=P?[f.mintA,f.mintB]:[f.mintB,f.mintA],[w,k]=P?[f.mintAAmount,f.mintBAmount]:[f.mintBAmount,f.mintAAmount],x=r.useSOLBalance&&T.address===Co.toBase58(),B=r.useSOLBalance&&h.address===Co.toBase58(),[K,I]=[new q(T.address),new q(h.address)],R=this.createTxBuilder(m),{account:C,instructionParams:N}=await this.scope.account.getOrCreateTokenAccount({mint:K,tokenProgram:T.programId,owner:this.scope.ownerPubKey,createInfo:x?{payer:g,amount:w}:void 0,notUseTokenAccount:x,skipCloseAccount:!x,associatedOnly:x?!1:i,checkCreateATAOwner:s});R.addInstruction(N||{});let{account:L,instructionParams:O}=await this.scope.account.getOrCreateTokenAccount({mint:new q(h.address),tokenProgram:h.programId,owner:this.scope.ownerPubKey,createInfo:B?{payer:g,amount:k}:void 0,notUseTokenAccount:B,skipCloseAccount:!B,associatedOnly:B?!1:i,checkCreateATAOwner:s});if(R.addInstruction(O||{}),C===void 0||L===void 0)throw Error("you don't has some token account");let F=aa({poolId:e,programId:t,configId:new q(a.id),mintA:K,mintB:I});return R.addInstruction({instructions:[Vc(t,this.scope.ownerPubKey,this.scope.ownerPubKey,new q(a.id),F.authority,F.poolId,K,I,F.lpMint,C,L,Z(this.scope.ownerPubKey,F.lpMint).publicKey,F.vaultA,F.vaultB,n,new q((z=T.programId)!=null?z:Pt),new q(($=h.programId)!=null?$:Pt),F.observationId,Oc(t,this.scope.ownerPubKey).publicKey,w,k,o,p)],instructionTypes:[U.CpmmCreatePool]}),R.addCustomComputeBudget(c),R.addTipInstruction(l),R.versionBuild({txVersion:u,extInfo:{address:D(v({},F),{mintA:T,mintB:h,programId:t,poolFeeAccount:n,feeConfig:a})}})}async collectCreatorFees({poolInfo:e,poolKeys:t,programId:n=Un,txVersion:o,computeBudgetConfig:r,txTipConfig:i,feePayer:s}){let u=s||this.scope.ownerPubKey,a=this.createTxBuilder(u),c=t!=null?t:await this.getCpmmPoolKeys(e.id),[l,m,p,f]=[new q(e.mintA.address),new q(e.mintB.address),new q(e.mintA.programId),new q(e.mintB.programId)],y=this.scope.account.getAssociatedTokenAccount(l,p),b=this.scope.account.getAssociatedTokenAccount(m,f);return a.addInstruction({instructions:[Ro(this.scope.ownerPubKey,y,this.scope.ownerPubKey,l,new q(e.mintA.programId)),Ro(this.scope.ownerPubKey,b,this.scope.ownerPubKey,m,new q(e.mintB.programId))]}),a.addInstruction({instructions:[ma(n,this.scope.ownerPubKey,new q(c.authority),new q(c.id),new q(c.config.id),new q(c.vault.A),new q(c.vault.B),l,m,y,b,p,f)],instructionTypes:[]}),a.addCustomComputeBudget(r),a.addTipInstruction(i),a.versionBuild({txVersion:o})}async collectMultiCreatorFees({poolInfoList:e,programId:t=Un,txVersion:n,computeBudgetConfig:o,feePayer:r}){let i=r||this.scope.ownerPubKey,s=this.createTxBuilder(i),u={},a=await this.scope.api.fetchPoolKeysById({idList:e.map(c=>c.id)});for(let c of e){let l=a.find(P=>P.id===c.id)||await this.getCpmmPoolKeys(c.id),[m,p,f,y]=[new q(c.mintA.address),new q(c.mintB.address),new q(c.mintA.programId),new q(c.mintB.programId)],b=u[c.mintA.address]||this.scope.account.getAssociatedTokenAccount(m,f),g=u[c.mintB.address]||this.scope.account.getAssociatedTokenAccount(p,y);u[c.mintA.address]||s.addInstruction({instructions:[Ro(this.scope.ownerPubKey,b,this.scope.ownerPubKey,m,f)]}),u[c.mintB.address]||s.addInstruction({instructions:[Ro(this.scope.ownerPubKey,g,this.scope.ownerPubKey,p,y)]}),u[c.mintA.address]=b,u[c.mintB.address]=g,s.addInstruction({instructions:[ma(t,this.scope.ownerPubKey,new q(l.authority),new q(l.id),new q(l.config.id),new q(l.vault.A),new q(l.vault.B),m,p,b,g,f,y)],instructionTypes:[]})}return n===0?s.sizeCheckBuildV0({computeBudgetConfig:o}):s.sizeCheckBuild({computeBudgetConfig:o})}computeSwapAmount({pool:e,amountIn:t,outputMint:n,slippage:o}){let r=n.toString()===e.mintB.address,i=e.feeOn===0||e.feeOn===2,s=r?hi.swapBaseInput(t,r?e.baseReserve:e.quoteReserve,r?e.quoteReserve:e.baseReserve,e.configInfo.tradeFeeRate,e.configInfo.creatorFeeRate,e.configInfo.protocolFeeRate,e.configInfo.fundFeeRate,i):hi.swapBaseOutput(t,r?e.baseReserve:e.quoteReserve,r?e.quoteReserve:e.baseReserve,e.configInfo.tradeFeeRate,e.configInfo.creatorFeeRate,e.configInfo.protocolFeeRate,e.configInfo.fundFeeRate,i),u=new qt(s.outputAmount.toString()).div(s.inputAmount.toString()),a=s.outputAmount.mul(new Ge((1-o)*1e4)).div(new Ge(1e4));return{allTrade:s.inputAmount.eq(t),amountIn:t,amountOut:s.outputAmount,minAmountOut:a,executionPrice:u,fee:s.tradeFee,priceImpact:e.poolPrice.sub(u).div(e.poolPrice)}}computePairAmount({poolInfo:e,baseReserve:t,quoteReserve:n,amount:o,slippage:r,epochInfo:i,baseIn:s}){var h,w,k,x,B,K,I,R,C;let u=1-Number(r.toSignificant())/100,a=new Ge(new qt(o).mul(10**e[s?"mintA":"mintB"].decimals).mul(u).toFixed(0)),c=Ke(a,e[s?"mintA":"mintB"].extensions.feeConfig,i,!1),l=a.sub((h=c.fee)!=null?h:new Ge(0)),m=new Ge(new qt(e.lpAmount).mul(10**e.lpMint.decimals).toFixed(0,qt.ROUND_DOWN));this.logDebug("baseReserve:",t.toString(),"quoteReserve:",n.toString()),this.logDebug("tokenIn:",s?e.mintA.symbol:e.mintB.symbol,"amountIn:",a.toString(),"amountInFee:",(k=(w=c.fee)==null?void 0:w.toString())!=null?k:0,"anotherToken:",s?e.mintB.symbol:e.mintA.symbol,"slippage:",`${r.toSignificant()}%`);let p=s?"base":"quote";this.logDebug("input side:",p);let f=l.mul(m).div(p==="base"?t:n),y={amount:kt,fee:void 0,expirationTime:void 0};if(!l.isZero()){let N=ep(f,t,n,m);this.logDebug("lpAmountData:",{amountA:N.amountA.toString(),amountB:N.amountB.toString()}),y=Ke(N[s?"amountB":"amountA"],e[s?"mintB":"mintA"].extensions.feeConfig,i,!0)}let b=new tt(new Ge(1)).add(r),g=new tt(new Ge(1)).sub(r),P=Ke(b.mul(y.amount.sub((x=y.fee)!=null?x:new Ge(0))).quotient,e[s?"mintB":"mintA"].extensions.feeConfig,i,!0),T=Ke(g.mul(y.amount.sub((B=y.fee)!=null?B:new Ge(0))).quotient,e[s?"mintB":"mintA"].extensions.feeConfig,i,!0);return this.logDebug("anotherAmount:",y.amount.toString(),"anotherAmountFee:",(I=(K=y.fee)==null?void 0:K.toString())!=null?I:0,"maxAnotherAmount:",P.amount.toString(),"maxAnotherAmountFee:",(C=(R=P.fee)==null?void 0:R.toString())!=null?C:0),{inputAmountFee:c,anotherAmount:y,maxAnotherAmount:P,minAnotherAmount:T,liquidity:f}}};function ep(d,e,t,n){let o=d.mul(e).div(n);!o.isZero()&&!d.mul(e).mod(n).isZero()&&(o=o.add(new Ge(1)));let r=d.mul(t).div(n);return!r.isZero()&&!d.mul(t).mod(n).isZero()&&(r=r.add(new Ge(1))),{amountA:o,amountB:r}}import{PublicKey as so}from"@solana/web3.js";import{createTransferInstruction as Xc,TOKEN_PROGRAM_ID as He,TOKEN_2022_PROGRAM_ID as Or}from"@solana/spl-token";import Nr from"bn.js";import Ki from"decimal.js";var Wc={[is.toBase58()]:3},Dc={3:is};var da=_([Te(5),Te(8),M("ownAddress"),A("vaultSignerNonce"),M("baseMint"),M("quoteMint"),M("baseVault"),A("baseDepositsTotal"),A("baseFeesAccrued"),M("quoteVault"),A("quoteDepositsTotal"),A("quoteFeesAccrued"),A("quoteDustThreshold"),M("requestQueue"),M("eventQueue"),M("bids"),M("asks"),A("baseLotSize"),A("quoteLotSize"),A("feeRateBps"),A("referrerRebatesAccrued"),Te(7)]),qc={3:da};import{PublicKey as Uc}from"@solana/web3.js";var Rr=ge("Serum"),Lr=class{static getProgramId(e){let t=Dc[e];return t||Rr.logWithError("invalid version","version",e),t}static getVersion(e){let t=e.toBase58(),n=Wc[t];return n||Rr.logWithError("invalid program id","programId",t),n}static getStateLayout(e){let t=qc[e];return t||Rr.logWithError(!!t,"invalid version","version",e),t}static getLayouts(e){return{state:this.getStateLayout(e)}}static getAssociatedAuthority({programId:e,marketId:t}){let n=[t.toBuffer()],o=0,r;for(;o<100;){try{let i=n.concat(Buffer.from([o]),Buffer.alloc(7));r=Uc.createProgramAddressSync(i,e)}catch(i){if(i instanceof TypeError)throw i;o++;continue}return{publicKey:r,nonce:o}}return Rr.logWithError("unable to find a viable program address nonce","params",{programId:e,marketId:t}),{publicKey:Uc.default,nonce:o}}};import{PublicKey as se,SystemProgram as tp,TransactionInstruction as np}from"@solana/web3.js";import ro from"bn.js";import{ASSOCIATED_TOKEN_PROGRAM_ID as op,TOKEN_2022_PROGRAM_ID as ip,TOKEN_PROGRAM_ID as rp}from"@solana/spl-token";function sp(d,e,t,n,o,r,i,s,u,a,c,l,m,p,f){var k;let y=[],b=[S({pubkey:rp,isWritable:!1}),S({pubkey:ip,isWritable:!1}),S({pubkey:op,isWritable:!1}),S({pubkey:tp.programId,isWritable:!1}),S({pubkey:e,isSigner:!0})];b.push(S({pubkey:t})),b.push(S({pubkey:o}));let g=[u,a],P=[c,l],T=[r,i,s];for(let x=0;x<g.length;x++){let B=g[x],K=T[x]===B.mintA.address;if(b.push(S({pubkey:new se(B.programId),isWritable:!1})),x===g.length-1?b.push(S({pubkey:o})):b.push(S({pubkey:n})),b.push(S({pubkey:new se(T[x])})),b.push(S({pubkey:new se(T[x+1])})),B.version===6){let I=P[x];b.push(S({pubkey:new se(I.config.id)})),b.push(S({pubkey:new se(I.id)})),b.push(S({pubkey:new se(K?I.vault.A:I.vault.B)})),b.push(S({pubkey:new se(K?I.vault.B:I.vault.A)})),b.push(S({pubkey:new se(B.observationId)})),b.push(S({pubkey:Sn})),b.push(S({pubkey:Qe(new se(B.programId),new se(B.id)).publicKey})),y.push(ap(B.sqrtPriceX64.toString(),K));for(let R of(k=f[x])!=null?k:[])b.push(S({pubkey:new se(R)}))}else if(B.version===5){let I=P[x];b.push(S({pubkey:new se(I.id)})),b.push(S({pubkey:new se(I.authority),isWritable:!1})),b.push(S({pubkey:new se(I.marketProgramId)})),b.push(S({pubkey:new se(I.marketAuthority)})),b.push(S({pubkey:su,isWritable:!1})),b.push(S({pubkey:new se(I.openOrders)})),b.push(S({pubkey:new se(I.vault.A)})),b.push(S({pubkey:new se(I.vault.B)})),b.push(S({pubkey:new se(I.id)})),b.push(S({pubkey:new se(I.id)})),b.push(S({pubkey:new se(I.id)})),b.push(S({pubkey:new se(I.id)})),b.push(S({pubkey:new se(I.id)})),b.push(S({pubkey:new se(I.id)})),b.push(S({pubkey:new se(I.marketId)})),b.push(S({pubkey:new se(I.marketBids)})),b.push(S({pubkey:new se(I.marketAsks)})),b.push(S({pubkey:new se(I.marketEventQueue)})),b.push(S({pubkey:new se(I.marketBaseVault)})),b.push(S({pubkey:new se(I.marketQuoteVault)}))}else if(B.version===4){let I=P[x],R=B.status!==1;b.push(S({pubkey:new se(I.id)})),b.push(S({pubkey:new se(I.authority),isWritable:!1})),b.push(S({pubkey:new se(R?I.id:I.marketProgramId)})),b.push(S({pubkey:new se(R?I.id:I.marketAuthority)})),b.push(S({pubkey:new se(R?I.id:I.openOrders)})),b.push(S({pubkey:new se(I.vault.A)})),b.push(S({pubkey:new se(I.vault.B)})),b.push(S({pubkey:new se(R?I.id:I.marketId)})),b.push(S({pubkey:new se(R?I.id:I.marketBids)})),b.push(S({pubkey:new se(R?I.id:I.marketAsks)})),b.push(S({pubkey:new se(R?I.id:I.marketEventQueue)})),b.push(S({pubkey:new se(R?I.id:I.marketBaseVault)})),b.push(S({pubkey:new se(R?I.id:I.marketQuoteVault)}))}else if(B.version===7){let I=P[x];b.push(S({pubkey:new se(I.authority)})),b.push(S({pubkey:new se(I.config.id)})),b.push(S({pubkey:new se(I.id)})),b.push(S({pubkey:new se(K?I.vault.A:I.vault.B)})),b.push(S({pubkey:new se(K?I.vault.B:I.vault.A)})),b.push(S({pubkey:new se(B.observationId)}))}else throw Error("pool type error")}let h=_([V("insId"),A("amountIn"),A("amountOut"),Y(oe(),y.length,"clmmPriceLimit")]),w=Buffer.alloc(h.span);return h.encode({insId:0,amountIn:m,amountOut:p,clmmPriceLimit:y},w),new np({keys:b,programId:d,data:w})}function ap(d,e){if(d)if(e){let t=new ro(d).div(new ro(25));return t.gt(pr)?t:pr}else{let t=new ro(d).mul(new ro(25));return t.lt(fr)?t:fr}else return e?pr:fr}function Gc({routeProgram:d,ownerInfo:e,inputMint:t,swapInfo:n}){var o,r,i,s,u,a,c;if(n.routeType==="amm")if(n.poolInfo[0].version===6){let l=n.poolKey[0],m=rt(l),p=t.equals(m.mintA.address)?Wt.add(Ct):Dt.sub(Ct);return Re.makeSwapBaseInInstructions({poolInfo:l,poolKeys:l,observationId:n.poolInfo[0].observationId,ownerInfo:{wallet:e.wallet,tokenAccountA:m.mintA.address.equals(t)?e.sourceToken:e.destinationToken,tokenAccountB:m.mintA.address.equals(t)?e.destinationToken:e.sourceToken},inputMint:t,amountIn:n.amountIn.amount.raw,amountOutMin:n.minAmountOut.amount.raw.sub((r=(o=n.minAmountOut.fee)==null?void 0:o.raw)!=null?r:new ro(0)),sqrtPriceLimitX64:p,remainingAccounts:(i=n.remainingAccounts[0])!=null?i:[]})}else if(n.poolInfo[0].version===7){let l=n.poolInfo[0],m=t.toString()===n.poolInfo[0].mintA.address;return{signers:[],instructions:[Kr(l.programId,e.wallet,l.authority,l.configId,l.id,e.sourceToken,e.destinationToken,m?l.vaultA:l.vaultB,m?l.vaultB:l.vaultA,m?l.mintProgramA:l.mintProgramB,m?l.mintProgramB:l.mintProgramA,new se(l[m?"mintA":"mintB"].address),new se(l[m?"mintB":"mintA"].address),l.observationId,n.amountIn.amount.raw,n.minAmountOut.amount.raw)],lookupTableAddress:[],instructionTypes:[m?U.CpmmSwapBaseIn:U.CpmmSwapBaseOut],address:{}}}else{let l=n.poolKey[0];return{signers:[],instructions:[kr({poolKeys:l,version:n.poolInfo[0].pooltype.includes("StablePool")?5:4,userKeys:{tokenAccountIn:e.sourceToken,tokenAccountOut:e.destinationToken,owner:e.wallet},amountIn:n.amountIn.amount.raw,amountOut:n.minAmountOut.amount.raw.sub((u=(s=n.minAmountOut.fee)==null?void 0:s.raw)!=null?u:new ro(0)),fixedSide:"in"})],lookupTableAddress:l.lookupTableAccount?[l.lookupTableAccount]:[],instructionTypes:[n.poolInfo[0].pooltype.includes("StablePool")?U.AmmV5SwapBaseIn:U.AmmV4SwapBaseIn],address:{}}}else if(n.routeType==="route"){let l=n.poolInfo[0],m=n.poolInfo[1],p=n.poolKey[0],f=n.poolKey[1];if(e.routeToken===void 0)throw Error("owner route token account check error");return{signers:[],instructions:[sp(d,e.wallet,e.sourceToken,e.routeToken,e.destinationToken,t.toString(),n.middleToken.mint.toString(),n.outputMint.toString(),l,m,p,f,n.amountIn.amount.raw,n.minAmountOut.amount.raw.sub((c=(a=n.minAmountOut.fee)==null?void 0:a.raw)!=null?c:new ro(0)),n.remainingAccounts)],instructionTypes:[U.RouteSwap],lookupTableAddress:[p.lookupTableAccount,f.lookupTableAccount].filter(y=>y!==void 0),address:{}}}else throw Error("route type error")}var In=new Nr(0),Ci=class extends _e{constructor(e){super(e)}async getWSolAccounts(){this.scope.checkOwner(),await this.scope.account.fetchWalletTokenAccounts();let e=this.scope.account.tokenAccounts.filter(t=>t.mint.equals(H));return e.sort((t,n)=>t.isAssociated?1:n.isAssociated||t.amount.lt(n.amount)?-1:1),e}async unWrapWSol(e){let{amount:t,tokenProgram:n,txVersion:o=1,feePayer:r}=e,i=await this.getWSolAccounts(),s=this.createTxBuilder(r);s.addCustomComputeBudget(e.computeBudgetConfig);let u=ee(t);for(let a=0;a<i.length;a++)u.gte(i[a].amount)?(s.addInstruction({instructions:[yn({tokenAccount:i[a].publicKey,payer:this.scope.ownerPubKey,owner:this.scope.ownerPubKey,programId:n})]}),u.sub(i[a].amount)):s.addInstruction({instructions:[yn({tokenAccount:i[a].publicKey,payer:this.scope.ownerPubKey,owner:this.scope.ownerPubKey,programId:n})]});return s.versionBuild({txVersion:o})}async wrapWSol(e,t,n,o){let r=this.createTxBuilder(o),i=await Nn({connection:this.scope.connection,owner:this.scope.ownerPubKey,payer:this.scope.ownerPubKey,amount:e,skipCloseAccount:!0});return r.addInstruction(i),r.versionBuild({txVersion:n!=null?n:1})}async swap({swapInfo:e,swapPoolKeys:t,ownerInfo:n,computeBudgetConfig:o,routeProgram:r,txVersion:i,feePayer:s}){let u=this.createTxBuilder(s),a=e.amountIn,c=e.amountOut,l=a.amount.token.mint.equals(H),m=c.amount.token.mint.equals(H),p=a.amount.token.mint,f=c.amount.token.mint,{account:y,instructionParams:b}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:a.amount.token.isToken2022?Or:He,mint:p,notUseTokenAccount:l,owner:this.scope.ownerPubKey,skipCloseAccount:!l,createInfo:l?{payer:this.scope.ownerPubKey,amount:a.amount.raw}:void 0,associatedOnly:l?!1:n.associatedOnly,checkCreateATAOwner:n.checkCreateATAOwner});if(b&&u.addInstruction(b),y===void 0)throw Error("input account check error");let g;if(e.routeType==="route"&&!m)g=this.scope.account.getAssociatedTokenAccount(f,c.amount.token.isToken2022?Or:He);else{let{account:w,instructionParams:k}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:c.amount.token.isToken2022?Or:He,mint:f,notUseTokenAccount:m,owner:this.scope.ownerPubKey,skipCloseAccount:!0,createInfo:{payer:this.scope.ownerPubKey,amount:0},associatedOnly:m?!1:n.associatedOnly,checkCreateATAOwner:n.checkCreateATAOwner});g=w,k&&u.addInstruction(k)}m&&u.addInstruction({endInstructions:[yn({owner:this.scope.ownerPubKey,payer:this.scope.ownerPubKey,tokenAccount:g,programId:He})],endInstructionTypes:[U.CloseAccount]});let P;if(e.routeType==="route"){let w=e.middleToken;P=this.scope.account.getAssociatedTokenAccount(w.mint,w.isToken2022?Or:He)}let T=t||await this.computePoolToPoolKeys({pools:e.poolInfoList}),h=Gc({routeProgram:r,inputMint:p,swapInfo:D(v({},e),{poolInfo:[...e.poolInfoList],poolKey:T,outputMint:f}),ownerInfo:{wallet:this.scope.ownerPubKey,sourceToken:y,routeToken:P,destinationToken:g}});if(e.feeConfig!==void 0){let w=this.createTxBuilder();w.addInstruction({instructions:[Xc(y,e.feeConfig.feeAccount,this.scope.ownerPubKey,e.feeConfig.feeAmount.toNumber())],instructionTypes:[U.TransferAmount]}),w.addInstruction(h);let{transactions:k}=i===0?await w.sizeCheckBuildV0():await w.sizeCheckBuild();k.length<2&&u.addInstruction({instructions:[Xc(y,e.feeConfig.feeAccount,this.scope.ownerPubKey,e.feeConfig.feeAmount.toNumber())],instructionTypes:[U.TransferAmount]})}return u.addInstruction(h),i===0?u.sizeCheckBuildV0({computeBudgetConfig:o,address:h.address}):u.sizeCheckBuild({computeBudgetConfig:o,address:h.address})}async fetchRoutePoolBasicInfo(e){let{amm:t=Hi,clmm:n=Dn,cpmm:o=Un}=e||{},r=await this.scope.connection.getProgramAccounts(t,{dataSlice:{offset:pi.offsetOf("baseMint"),length:64}}),i=_([M("baseMint"),M("quoteMint")]),s=r.map(p=>({id:p.pubkey,version:4,mintA:i.decode(p.account.data).baseMint,mintB:i.decode(p.account.data).quoteMint})),u=_([M("mintA"),M("mintB")]),c=(await this.scope.connection.getProgramAccounts(n,{filters:[{dataSize:Zn.span}],dataSlice:{offset:Zn.offsetOf("mintA"),length:64}})).map(p=>{let f=u.decode(p.account.data);return{id:p.pubkey,version:6,mintA:f.mintA,mintB:f.mintB}}),m=(await this.scope.connection.getProgramAccounts(o,{dataSlice:{offset:Cr.offsetOf("mintA"),length:64}})).map(p=>{let f=u.decode(p.account.data);return{id:p.pubkey,version:7,mintA:f.mintA,mintB:f.mintB}});return{clmmPools:c,ammPools:s,cpmmPools:m}}getAllRoute({inputMint:e,outputMint:t,clmmPools:n,ammPools:o,cpmmPools:r}){e=e.toString()===so.default.toString()?H:e,t=t.toString()===so.default.toString()?H:t;let i={},s={},u={},a=[],c={};for(let m of n!=null?n:[]){if((m.mintA.equals(e)&&m.mintB.equals(t)||m.mintA.equals(t)&&m.mintB.equals(e))&&(a.push(m),s[m.id.toString()]=m),m.mintA.equals(e)){let p=m.mintB.toString();c[p]===void 0&&(c[p]={mintProgram:He,in:[],out:[],mDecimals:0}),c[p].in.push(m)}if(m.mintB.equals(e)){let p=m.mintA.toString();c[p]===void 0&&(c[p]={mintProgram:He,in:[],out:[],mDecimals:0}),c[p].in.push(m)}if(m.mintA.equals(t)){let p=m.mintB.toString();c[p]===void 0&&(c[p]={mintProgram:He,in:[],out:[],mDecimals:0}),c[p].out.push(m)}if(m.mintB.equals(t)){let p=m.mintA.toString();c[p]===void 0&&(c[p]={mintProgram:He,in:[],out:[],mDecimals:0}),c[p].out.push(m)}}let l=[];for(let m of o)(m.mintA.equals(e)&&m.mintB.equals(t)||m.mintA.equals(t)&&m.mintB.equals(e))&&(a.push(m),i[m.id.toBase58()]=m,l.push(m)),m.mintA.equals(e)&&(c[m.mintB.toBase58()]===void 0&&(c[m.mintB.toBase58()]={mintProgram:He,in:[],out:[],mDecimals:0}),c[m.mintB.toBase58()].in.push(m)),m.mintB.equals(e)&&(c[m.mintA.toBase58()]===void 0&&(c[m.mintA.toBase58()]={mintProgram:He,in:[],out:[],mDecimals:0}),c[m.mintA.toBase58()].in.push(m)),m.mintA.equals(t)&&(c[m.mintB.toBase58()]===void 0&&(c[m.mintB.toBase58()]={mintProgram:He,in:[],out:[],mDecimals:0}),c[m.mintB.toBase58()].out.push(m)),m.mintB.equals(t)&&(c[m.mintA.toBase58()]===void 0&&(c[m.mintA.toBase58()]={mintProgram:He,in:[],out:[],mDecimals:0}),c[m.mintA.toBase58()].out.push(m));for(let m of r)(m.mintA.equals(e)&&m.mintB.equals(t)||m.mintA.equals(t)&&m.mintB.equals(e))&&(a.push(m),u[m.id.toBase58()]=m),m.mintA.equals(e)&&(c[m.mintB.toBase58()]===void 0&&(c[m.mintB.toBase58()]={mintProgram:He,in:[],out:[],mDecimals:0}),c[m.mintB.toBase58()].in.push(m)),m.mintB.equals(e)&&(c[m.mintA.toBase58()]===void 0&&(c[m.mintA.toBase58()]={mintProgram:He,in:[],out:[],mDecimals:0}),c[m.mintA.toBase58()].in.push(m)),m.mintA.equals(t)&&(c[m.mintB.toBase58()]===void 0&&(c[m.mintB.toBase58()]={mintProgram:He,in:[],out:[],mDecimals:0}),c[m.mintB.toBase58()].out.push(m)),m.mintB.equals(t)&&(c[m.mintA.toBase58()]===void 0&&(c[m.mintA.toBase58()]={mintProgram:He,in:[],out:[],mDecimals:0}),c[m.mintA.toBase58()].out.push(m));for(let m of Object.keys(c)){if(c[m].in.length===1&&c[m].out.length===1&&c[m].in[0].id.equals(c[m].out[0].id)){delete c[m];continue}if(c[m].in.length===0||c[m].out.length===0){delete c[m];continue}let p=c[m];for(let f of p.in)for(let y of p.out)f.version===6&&s[f.id.toString()]===void 0?s[f.id.toString()]=f:f.version===7&&u[f.id.toString()]===void 0?u[f.id.toString()]=f:(f.version===4||f.version===5)&&i[f.id.toString()]===void 0&&(i[f.id.toString()]=f),y.version===6&&s[y.id.toString()]===void 0?s[y.id.toString()]=y:y.version===7&&u[y.id.toString()]===void 0?u[y.id.toString()]=y:(y.version===4||y.version===5)&&i[y.id.toString()]===void 0&&(i[y.id.toString()]=y)}return{directPath:a,addLiquidityPools:l,routePathDict:c,needSimulate:Object.values(i),needTickArray:Object.values(s),cpmmPoolList:Object.values(u)}}async fetchSwapRoutesData({routes:e,inputMint:t,outputMint:n}){let o=new Set([...e.needTickArray.map(y=>[y.mintA.toBase58(),y.mintB.toBase58()]).flat(),t.toString(),n.toString()]);console.log("fetching amm pools info, total: ",e.needSimulate.length);let r=await this.scope.liquidity.getRpcPoolInfos(e.needSimulate.map(y=>y.id)),i=hr(r),s={};Object.values(i).forEach(y=>{o.delete(y.mintA.address),s[y.mintA.address]={address:new so(y.mintA.address),programId:He,mintAuthority:null,supply:BigInt(0),decimals:y.mintA.decimals,isInitialized:!0,freezeAuthority:null,tlvData:Buffer.from("0","hex"),feeConfig:void 0},o.delete(y.mintB.address),s[y.mintB.address]={address:new so(y.mintB.address),programId:He,mintAuthority:null,supply:BigInt(0),decimals:y.mintB.decimals,isInitialized:!0,freezeAuthority:null,tlvData:Buffer.from("0","hex"),feeConfig:void 0}}),console.log("fetching cpmm pools info, total: ",e.cpmmPoolList.length);let u=await this.scope.cpmm.getRpcPoolInfos(e.cpmmPoolList.map(y=>y.id.toBase58()),!0);Object.values(u).forEach(y=>{let[b,g]=[y.mintA.toBase58(),y.mintB.toBase58()];y.mintProgramA.equals(He)?(o.delete(b),s[b]={address:y.mintA,programId:y.mintProgramA,mintAuthority:null,supply:BigInt(0),decimals:y.mintDecimalA,isInitialized:!0,freezeAuthority:null,tlvData:Buffer.from("0","hex"),feeConfig:void 0}):o.add(b),y.mintProgramB.equals(He)?(o.delete(g),s[g]={address:y.mintB,programId:y.mintProgramB,mintAuthority:null,supply:BigInt(0),decimals:y.mintDecimalB,isInitialized:!0,freezeAuthority:null,tlvData:Buffer.from("0","hex"),feeConfig:void 0}):o.add(g)}),console.log("fetching mints info, total: ",o.size);let a=await go({connection:this.scope.connection,mints:Array.from(o).map(y=>new so(y))});s=v(v({},s),a);let c=this.scope.cpmm.toComputePoolInfos({pools:u,mintInfos:s});console.log("fetching clmm pools info, total:",e.needTickArray.length);let l=await this.scope.clmm.getRpcClmmPoolInfos({poolIds:e.needTickArray.map(y=>y.id)}),{computeClmmPoolInfo:m,computePoolTickData:p}=await this.scope.clmm.getComputeClmmPoolInfos({clmmPoolsRpcInfo:l,mintInfos:s}),f=Object.keys(e.routePathDict).reduce((y,b)=>D(v({},y),{[b]:D(v({},e.routePathDict[b]),{mintProgram:s[b].programId,mDecimals:s[b].decimals,in:e.routePathDict[b].in.map(g=>i[g.id.toBase58()]||m[g.id.toBase58()]||c[g.id.toBase58()]),out:e.routePathDict[b].out.map(g=>i[g.id.toBase58()]||m[g.id.toBase58()]||c[g.id.toBase58()])})}),{});return{mintInfos:s,ammPoolsRpcInfo:r,ammSimulateCache:i,clmmPoolsRpcInfo:l,computeClmmPoolInfo:m,computePoolTickData:p,computeCpmmData:c,routePathDict:f}}getAllRouteComputeAmountOut({inputTokenAmount:e,outputToken:t,directPath:n,routePathDict:o,simulateCache:r,tickCache:i,slippage:s,chainTime:u,epochInfo:a,feeConfig:c}){var g,P,T,h,w,k,x,B,K;let l=c===void 0?new Nr(0):e.raw.mul(new Nr(c.feeBps.toNumber())).div(new Nr(1e4)),m=e.raw.sub(l),p=new Se(e.token,m),f=c===void 0?void 0:{feeAmount:l,feeAccount:c.feeAccount},y=D(v({},t),{address:ut(t.address).toString()}),b=[];for(let I of n)try{b.push(D(v({},this.computeAmountOut({itemPool:I,tickCache:i,simulateCache:r,chainTime:u,epochInfo:a,slippage:s,outputToken:y,amountIn:p})),{feeConfig:f}))}catch(R){this.logDebug("direct error",I.version,I.id.toString(),R.message)}this.logDebug("direct done");for(let[I,R]of Object.entries(o)){let C={chainId:101,address:I,programId:R.mintProgram.toBase58(),logoURI:"",symbol:"",name:"",decimals:R.mDecimals,tags:[],extensions:{}},N=R.in.map(O=>{try{return{pool:O,data:this.computeAmountOut({itemPool:O,tickCache:i,simulateCache:r,chainTime:u,epochInfo:a,slippage:s,outputToken:C,amountIn:p})}}catch(F){this.logDebug("route in error",O.version,O.id.toString(),F.message);return}}).sort((O,F)=>{var $,re,te,ae;let G=O===void 0?In:O.data.amountOut.amount.raw.sub((re=($=O.data.amountOut.fee)==null?void 0:$.raw)!=null?re:In),z=F===void 0?In:F.data.amountOut.amount.raw.sub((ae=(te=F.data.amountOut.fee)==null?void 0:te.raw)!=null?ae:In);return G.lt(z)?1:-1})[0];if(N===void 0)continue;let L=new Se(Pr(C),N.data.amountOut.amount.raw.sub((P=(g=N.data.amountOut.fee)==null?void 0:g.raw)!=null?P:In));for(let O of R.out)try{let F=this.computeAmountOut({itemPool:O,tickCache:i,simulateCache:r,chainTime:u,epochInfo:a,slippage:s,outputToken:y,amountIn:L});b.push(D(v({},F),{allTrade:!!(N.data.allTrade&&F.allTrade),amountIn:N.data.amountIn,amountOut:F.amountOut,minAmountOut:F.minAmountOut,currentPrice:void 0,executionPrice:new Ki(new At({baseToken:N.data.amountIn.amount.token,denominator:N.data.amountIn.amount.raw,quoteToken:F.amountOut.amount.token,numerator:F.amountOut.amount.raw.sub((h=(T=F.amountOut.fee)==null?void 0:T.raw)!=null?h:In)}).toFixed()),priceImpact:new Ki(N.data.priceImpact.add(F.priceImpact).toFixed()),fee:[N.data.fee[0],F.fee[0]],routeType:"route",poolInfoList:[N.pool,O],remainingAccounts:[N.data.remainingAccounts[0],F.remainingAccounts[0]],minMiddleAmountFee:(w=F.amountOut.fee)!=null&&w.raw?new Se(N.data.amountOut.amount.token,((x=(k=N.data.amountOut.fee)==null?void 0:k.raw)!=null?x:In).add((K=(B=F.amountOut.fee)==null?void 0:B.raw)!=null?K:In)):void 0,middleToken:N.data.amountOut.amount.token,poolReady:N.data.poolReady&&F.poolReady,poolType:[N.data.poolType,F.poolType],feeConfig:f,expirationTime:Zt(N.data.expirationTime,F.expirationTime)}))}catch(F){this.logDebug("route out error",O.version,O.id.toString(),F.message)}}return b.filter(I=>(I.allTrade||this.logDebug(`pool ${I.poolInfoList.map(R=>R.id.toString()).join(",")} filter out since not all trade`),I.allTrade)).sort((I,R)=>I.amountOut.amount.raw.sub(R.amountOut.amount.raw).gt(In)?-1:1)}computeAmountOut({itemPool:e,tickCache:t,simulateCache:n,chainTime:o,epochInfo:r,slippage:i,outputToken:s,amountIn:u}){if(e.version===6){let{allTrade:a,realAmountIn:c,amountOut:l,minAmountOut:m,expirationTime:p,currentPrice:f,executionPrice:y,priceImpact:b,fee:g,remainingAccounts:P,executionPriceX64:T}=Me.computeAmountOutFormat({poolInfo:e,tickArrayCache:t[e.id.toString()],amountIn:u.raw,tokenOut:s,slippage:i,epochInfo:r,catchLiquidityInsufficient:!0});return{allTrade:a,amountIn:c,amountOut:l,minAmountOut:m,currentPrice:new Ki(f.toFixed()),executionPrice:new Ki(y.toFixed()),priceImpact:new Ki(b.toFixed()),fee:[g],remainingAccounts:[P],routeType:"amm",poolInfoList:[e],poolReady:e.startTime<o,poolType:"CLMM",slippage:i,clmmExPriceX64:[T],expirationTime:Zt(c.expirationTime,p)}}else if(e.version===7){let{allTrade:a,executionPrice:c,amountOut:l,minAmountOut:m,priceImpact:p,fee:f}=this.scope.cpmm.computeSwapAmount({pool:e,outputMint:s.address,amountIn:u.raw,slippage:i});return{allTrade:a,amountIn:{amount:u,fee:void 0,expirationTime:void 0},amountOut:{amount:di(D(v({},s),{amount:l})),fee:void 0,expirationTime:void 0},minAmountOut:{amount:di(D(v({},s),{amount:m})),fee:void 0,expirationTime:void 0},currentPrice:e.poolPrice,executionPrice:c,priceImpact:p,fee:[new Se(u.token,f)],remainingAccounts:[],routeType:"amm",poolInfoList:[e],poolReady:e.openTime.toNumber()<o,poolType:"CPMM",slippage:i,clmmExPriceX64:[void 0],expirationTime:void 0}}else{if(![1,6,7].includes(n[e.id.toString()].status))throw Error("swap error");let{amountOut:a,minAmountOut:c,currentPrice:l,executionPrice:m,priceImpact:p,fee:f}=this.scope.liquidity.computeAmountOut({poolInfo:n[e.id.toString()],amountIn:u.raw,mintIn:u.token.mint,mintOut:s.address,slippage:i});return{amountIn:{amount:u,fee:void 0,expirationTime:void 0},amountOut:{amount:di(D(v({},s),{amount:a})),fee:void 0,expirationTime:void 0},minAmountOut:{amount:di(D(v({},s),{amount:c})),fee:void 0,expirationTime:void 0},currentPrice:l,executionPrice:m,priceImpact:p,fee:[new Se(u.token,f)],routeType:"amm",poolInfoList:[e],remainingAccounts:[],poolReady:Number(n[e.id].openTime)<o,poolType:e.version===5?"STABLE":void 0,expirationTime:void 0,allTrade:!0,slippage:i,clmmExPriceX64:[void 0]}}}async computePoolToPoolKeys({pools:e,clmmRpcData:t={},ammRpcData:n={}}){let o=new Set(e.filter(a=>a.version===6&&!t[a.id.toString()]).map(a=>a.id.toString()));if(o.size>0){let a=await this.scope.clmm.getRpcClmmPoolInfos({poolIds:Array.from(o)});Object.keys(a).forEach(c=>{t[c]=a[c]})}let r=new Set(e.filter(a=>a.version===4&&!n[a.id.toString()]).map(a=>a.id.toString()));if(r.size>0){let a=await this.scope.liquidity.getRpcPoolInfos(Array.from(r));Object.keys(a).forEach(c=>{n[c]=a[c]})}let i=new Set(e.filter(a=>a.version===4).map(a=>a.marketId)),s={};i.size>0&&(await Ne(this.scope.connection,Array.from(i).map(c=>({pubkey:new so(c)})))).forEach(c=>{if(!c.accountInfo)return;let l=da.decode(c.accountInfo.data);s[c.pubkey.toBase58()]={marketId:c.pubkey.toString(),marketProgramId:c.accountInfo.owner.toString(),marketAuthority:Lr.getAssociatedAuthority({programId:c.accountInfo.owner,marketId:c.pubkey}).publicKey.toString(),marketBaseVault:l.baseVault.toString(),marketQuoteVault:l.quoteVault.toString(),marketBids:l.bids.toString(),marketAsks:l.asks.toString(),marketEventQueue:l.eventQueue.toString()}});let u=[];return e.forEach(a=>{if(a.version===6){let c=t[a.id.toString()],l={programId:a.programId.toBase58(),id:a.id.toBase58(),mintA:a.mintA,mintB:a.mintB,openTime:String(a.startTime),vault:{A:c.vaultA.toBase58(),B:c.vaultB.toBase58()},config:D(v({},a.ammConfig),{id:a.ammConfig.id.toString(),defaultRange:0,defaultRangePoint:[]}),rewardInfos:[],observationId:a.observationId.toBase58(),exBitmapAccount:a.exBitmapAccount.toBase58()};u.push(l)}else if(a.version===4){let c=n[a.id.toString()],l=v({programId:a.programId,id:a.id,mintA:a.mintA,mintB:a.mintB,openTime:String(a.openTime),vault:{A:c.baseVault.toBase58(),B:c.quoteVault.toBase58()},authority:na({programId:new so(a.programId)}).publicKey.toString(),openOrders:c.openOrders.toBase58(),targetOrders:c.targetOrders.toBase58(),mintLp:a.lpMint},s[a.marketId]);u.push(l)}else a.version===7&&u.push({observationId:a.observationId.toBase58(),programId:a.programId.toBase58(),id:a.id.toBase58(),mintA:a.mintA,mintB:a.mintB,openTime:String(a.openTime),authority:Ko(a.programId).publicKey.toBase58(),vault:{A:a.vaultA.toBase58(),B:a.vaultB.toBase58()},mintLp:dt({address:a.mintLp.toBase58(),programId:He.toBase58(),decimals:a.lpDecimals}),config:D(v({id:a.configId.toBase58()},a.configInfo),{protocolFeeRate:a.configInfo.protocolFeeRate.toNumber(),tradeFeeRate:a.configInfo.tradeFeeRate.toNumber(),fundFeeRate:a.configInfo.fundFeeRate.toNumber(),createPoolFee:a.configInfo.createPoolFee.toString()})})}),u}};import{PublicKey as up,Transaction as pa,TransactionInstruction as cp}from"@solana/web3.js";import{TOKEN_PROGRAM_ID as lp}from"@solana/spl-token";import zc from"bn.js";var pt=class extends _e{static getPdaPoolId(e,t){return ce([pt.SEED_CONFIG.pool.id,t.toBuffer()],e)}static getPdaOwnerId(e,t,n,o){return ce([pt.SEED_CONFIG.owner.id,t.toBuffer(),n.toBuffer(),Buffer.from(new zc(o).toArray())],e)}static async getAllInfo({connection:e,programId:t,poolIds:n,wallet:o,chainTime:r}){if(n.length===0)return[];let i=n.map(c=>pt.getPdaPoolId(t,c).publicKey),s=[];for(let c=0;c<pt.VERSION_PROJECT.length;c++)s.push(...i.map(l=>pt.getPdaOwnerId(t,l,o,c).publicKey));let u=await jt(e,[...i,...s]),a=[];for(let c=0;c<u.length;c++){let l=Math.floor(c/n.length),m=c%n.length,p=i[m],f=s[c],y=u[m],b=u[n.length+c];if(!(y&&b)||y.data.length!==pt.POOL_LAYOUT.span||b.data.length!==pt.OWNER_LAYOUT.span)continue;let g=pt.POOL_LAYOUT.decode(y.data),P=pt.OWNER_LAYOUT.decode(b.data),T=g.openTime.toNumber(),h=g.endTime.toNumber(),w=P.tokenInfo.map(B=>B.debtAmount.gt(new zc(0))).filter(B=>!B).length!==3,k=r>T&&r<h&&g.status===1,x=w&&k;a.push({programId:t,poolId:p,ammId:g.ammId,ownerAccountId:f,snapshotLpAmount:P.lpAmount,project:pt.VERSION_PROJECT[l],openTime:T,endTime:h,canClaim:x,canClaimErrorType:w?k?void 0:"outOfOperationalTime":"alreadyClaimIt",tokenInfo:g.tokenInfo.map((B,K)=>({mintAddress:B.mintAddress,mintVault:B.mintVault,mintDecimals:B.mintDecimals,perLpLoss:B.perLpLoss,debtAmount:P.tokenInfo[K].debtAmount.add(P.tokenInfo[K].claimedAmount)}))})}return a}async makeClaimTransaction({poolInfo:e,ownerInfo:t,feePayer:n}){t.wallet||this.scope.checkOwner();let o=this.createTxBuilder(n),r=t.wallet||this.scope.ownerPubKey,i=[];for(let a of e.tokenInfo){let{account:c,instructionParams:l}=await this.scope.account.getOrCreateTokenAccount({mint:a.mintAddress,owner:this.scope.ownerPubKey,notUseTokenAccount:a.mintAddress.equals(De.WSOL.mint),createInfo:{payer:r,amount:0},skipCloseAccount:!a.mintAddress.equals(De.WSOL.mint),associatedOnly:a.mintAddress.equals(De.WSOL.mint)?!1:t.associatedOnly});l&&o.addInstruction(l),i.push(c)}o.addInstruction({instructions:[pt.makeClaimInstruction({programId:e.programId,poolInfo:e,ownerInfo:{wallet:r,ownerPda:e.ownerAccountId,claimAddress:i}})]});let{transaction:s,signers:u}=o.build();return[{transaction:s,signer:u}]}async makeClaimAllTransaction({poolInfos:e,ownerInfo:t,feePayer:n}){let o=this.createTxBuilder(n),r=t.wallet||this.scope.ownerPubKey,i={};for(let c of e){let l=[];for(let m of c.tokenInfo){let{account:p,instructionParams:f}=await this.scope.account.getOrCreateTokenAccount({mint:m.mintAddress,owner:this.scope.ownerPubKey,notUseTokenAccount:m.mintAddress.equals(De.WSOL.mint),createInfo:{payer:r,amount:0},skipCloseAccount:!m.mintAddress.equals(De.WSOL.mint),associatedOnly:m.mintAddress.equals(De.WSOL.mint)?!1:t.associatedOnly});f&&o.addInstruction(f),p&&(i[m.mintAddress.toString()]=p,l.push(p))}o.addInstruction({instructions:[pt.makeClaimInstruction({programId:c.programId,poolInfo:c,ownerInfo:{wallet:r,ownerPda:c.ownerAccountId,claimAddress:l}})]})}let{transaction:s,signers:u}=o.build(),a=o.allInstructions;return os(a,[r,...u.map(c=>c.publicKey)])?[{transaction:s,signer:u}]:[{transaction:new pa().add(...a.slice(0,o.AllTxData.instructions.length-1)),signer:u},{transaction:new pa().add(...a.slice(o.AllTxData.instructions.length-1)),signer:[]},{transaction:new pa().add(...o.AllTxData.endInstructions),signer:[]}]}static makeClaimInstruction({programId:e,poolInfo:t,ownerInfo:n}){let o=_([]),r=[{pubkey:n.wallet,isSigner:!0,isWritable:!0},{pubkey:t.poolId,isSigner:!1,isWritable:!0},{pubkey:n.ownerPda,isSigner:!1,isWritable:!0},...n.claimAddress.map(u=>({pubkey:u,isSigner:!1,isWritable:!0})),...t.tokenInfo.map(({mintVault:u})=>({pubkey:u,isSigner:!1,isWritable:!0})),{pubkey:lp,isSigner:!1,isWritable:!1}],i=Buffer.alloc(o.span);o.encode({},i);let s=Buffer.from([10,66,208,184,161,6,191,98,...i]);return new cp({keys:r,programId:e,data:s})}},Ut=pt;Ut.CLAIMED_NUM=3,Ut.POOL_LAYOUT=_([Te(8),V("bump"),V("status"),A("openTime"),A("endTime"),M("ammId"),Y(_([V("mintDecimals"),M("mintAddress"),M("mintVault"),A("perLpLoss"),A("totalClaimedAmount")]),pt.CLAIMED_NUM,"tokenInfo"),Y(A(),10,"padding")]),Ut.OWNER_LAYOUT=_([Te(8),V("bump"),V("version"),M("poolId"),M("owner"),A("lpAmount"),Y(_([M("mintAddress"),A("debtAmount"),A("claimedAmount")]),pt.CLAIMED_NUM,"tokenInfo"),Y(A(),4,"padding")]),Ut.DEFAULT_POOL_ID=["58oQChx4yWmvKdwLLZzBi4ChoCc2fqCUWBkwMihLYQo2","6UmmUiYoBjSrhakAobJw8BvkmJtDVxaeBtbt7rxWo1mg","AVs9TA4nWDzfPJE9gGVNJMVhcQy3V9PGazuz33BfG2RA","DVa7Qmb5ct9RCpaU7UTpSaf3GVMYz17vNVU67XpdCRut","7XawhbbxtsRcQA8KTkHT9f9nc6d69UwqCDh6U5EEbEmX","6a1CsrpeZubDjEJE9s1CMVheB6HWM5d7m1cj2jkhyXhj","EoNrn8iUhwgJySD1pHu8Qxm5gSQqLK3za4m8xzD2RuEb","AceAyRTWt4PyB2pHqf2qhDgNZDtKVNaxgL8Ru3V4aN1P","6tmFJbMk5yVHFcFy7X2K8RwHjKLr6KVFLYXpgpBNeAxB"].map(e=>new up(e)),Ut.SEED_CONFIG={pool:{id:Buffer.from("pool_seed","utf8")},owner:{id:Buffer.from("user_claim_seed","utf8")}},Ut.VERSION_PROJECT=[void 0,"Francium","Tulip","Larix"];import{PublicKey as Li}from"@solana/web3.js";import Hc from"bn.js";import{SYSVAR_CLOCK_PUBKEY as dp,TransactionInstruction as Yc}from"@solana/web3.js";import{TOKEN_PROGRAM_ID as Qc}from"@solana/spl-token";var mp=_([V("instruction"),Au("amount")]),Ri=_([V("instruction")]);function Mr({programId:d},e){let t=[{pubkey:Qc,isSigner:!1,isWritable:!1},{pubkey:Ya,isSigner:!1,isWritable:!1},...Object.entries(e).map(([o,r])=>({pubkey:r,isSigner:o==="userOwner",isWritable:!["authority","userOwner"].includes(o)}))],n=Buffer.alloc(Ri.span);return Ri.encode({instruction:2},n),new Yc({keys:t,programId:d,data:n})}function fa(d){let{poolConfig:e,userKeys:t,side:n}=d,o=n==="base"?t.baseTokenAccount:t.quoteTokenAccount,r=n==="base"?e.baseVault:e.quoteVault,i=Buffer.alloc(Ri.span);Ri.encode({instruction:2},i);let s=[{pubkey:Qc,isWritable:!1,isSigner:!1},{pubkey:dp,isWritable:!1,isSigner:!1},{pubkey:e.id,isWritable:!0,isSigner:!1},{pubkey:e.authority,isWritable:!1,isSigner:!1},{pubkey:r,isWritable:!0,isSigner:!1},{pubkey:o,isWritable:!0,isSigner:!1},{pubkey:t.ledgerAccount,isWritable:!0,isSigner:!1},{pubkey:t.owner,isWritable:!1,isSigner:!0}];return new Yc({programId:e.programId,keys:s,data:i})}var pp={[Go.IDO_PROGRAM_ID_V1.toString()]:1,[Go.IDO_PROGRAM_ID_V2.toString()]:2,[Go.IDO_PROGRAM_ID_V3.toString()]:3,[Go.IDO_PROGRAM_ID_V4.toString()]:4},Lo=class extends _e{async claim({ownerInfo:e,idoKeys:t,associatedOnly:n=!0,checkCreateATAOwner:o=!1,txVersion:r,feePayer:i}){let s=this.createTxBuilder(i),u=pp[t.programId];u||this.logAndCreateError("invalid version",u);let a=rt(t),[c,l]=[!new Hc(e.coin).isZero(),!new Hc(e.pc).isZero()],m=a.projectInfo.mint.address.equals(H),{account:p,instructionParams:f}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:a.projectInfo.mint.programId,mint:a.projectInfo.mint.address,owner:this.scope.ownerPubKey,createInfo:{payer:this.scope.ownerPubKey,amount:0},skipCloseAccount:!m,notUseTokenAccount:m,associatedOnly:m?!1:n,checkCreateATAOwner:o});!p&&c&&this.logAndCreateError("target token accounts not found","mint",t.projectInfo.mint.address),c&&f&&s.addInstruction(f);let y=a.buyInfo.mint.address.equals(H),{account:b,instructionParams:g}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:a.buyInfo.mint.programId,mint:a.buyInfo.mint.address,owner:this.scope.ownerPubKey,createInfo:{payer:this.scope.ownerPubKey,amount:0},skipCloseAccount:!y,notUseTokenAccount:y,associatedOnly:y?!1:n,checkCreateATAOwner:o});if(!p&&l&&this.logAndCreateError("target token accounts not found","mint",t.projectInfo.mint.address),l&&g&&s.addInstruction(g),(!p||!b)&&this.logAndCreateError("target token accounts not found","mint",t.projectInfo.mint.address,t.buyInfo.mint.address),u===3)return s.addInstruction({instructions:[...c?[Mr({programId:a.programId},{idoId:a.id,authority:a.authority,poolTokenAccount:a.projectInfo.vault,userTokenAccount:p,userIdoInfo:new Li(e.userIdoInfo),userOwner:this.scope.ownerPubKey})]:[],...l?[Mr({programId:new Li(t.programId)},{idoId:a.id,authority:a.authority,poolTokenAccount:a.buyInfo.vault,userTokenAccount:b,userIdoInfo:new Li(e.userIdoInfo),userOwner:this.scope.ownerPubKey})]:[]]}).versionBuild({txVersion:r});if(u<3)return!c&&!l&&this.logAndCreateError("no claimable rewards"),s.addInstruction({instructions:[Mr({programId:a.programId},{idoId:a.id,authority:a.authority,poolQuoteTokenAccount:a.buyInfo.vault,poolBaseTokenAccount:a.projectInfo.vault,userQuoteTokenAccount:b,userBaseTokenAccount:p,userIdoInfo:new Li(e.userIdoInfo),userOwner:this.scope.ownerPubKey})]}).versionBuild({txVersion:r});let P={poolConfig:{id:a.id,programId:a.programId,authority:a.authority,baseVault:a.projectInfo.vault,quoteVault:a.buyInfo.vault,baseToken:t.projectInfo.mint,quoteToken:t.buyInfo.mint},userKeys:{baseTokenAccount:p,quoteTokenAccount:b,ledgerAccount:new Li(e.userIdoInfo),owner:this.scope.ownerPubKey}};return s.addInstruction({instructions:[...c?[fa(D(v({},P),{side:"base"}))]:[],...l?[fa(D(v({},P),{side:"quote"}))]:[]]}).versionBuild({txVersion:r})}};var fp=Buffer.from("vault_auth_seed","utf8"),NK=Buffer.from("global_config","utf8"),yp=Buffer.from("pool_vesting","utf8"),bp=Buffer.from("platform_config","utf8"),gp=Buffer.from("platform_fee_vault_auth_seed","utf8"),Pp=Buffer.from("creator_fee_vault_auth_seed","utf8");function tn(d){return ce([fp],d)}function ao(d,e,t){return ce([_s,e.toBuffer(),t.toBuffer()],d)}function ya(d,e,t){return ce([Vs,e.toBuffer(),t.toBuffer()],d)}function uo(d){return ce([Buffer.from("__event_authority","utf8")],d)}function ba(d,e){return ce([bp,e.toBuffer()],d)}function Oi(d,e,t){return ce([yp,e.toBuffer(),t.toBuffer()],d)}function co(d,e,t){return ce([e.toBuffer(),t.toBuffer()],d)}function ga(d){return ce([gp],d)}function lo(d,e,t){return ce([e.toBuffer(),t.toBuffer()],d)}function Pa(d){return ce([Pp],d)}import{ASSOCIATED_TOKEN_PROGRAM_ID as vr,TOKEN_2022_PROGRAM_ID as wp,TOKEN_PROGRAM_ID as Aa}from"@solana/spl-token";import{SystemProgram as Xt,TransactionInstruction as Ot}from"@solana/web3.js";import Oo from"bn.js";var Bn=_([A(),A("epoch"),V("curveType"),St("index"),A("migrateFee"),A("tradeFeeRate"),A("maxShareFeeRate"),A("minSupplyA"),A("maxLockRate"),A("minSellRateA"),A("minMigrateRateA"),A("minFundRaisingB"),M("mintB"),M("protocolFeeOwner"),M("migrateFeeOwner"),M("migrateToAmmWallet"),M("migrateToCpmmWallet"),Y(A(),16)]),Ap=_([A("totalLockedAmount"),A("cliffPeriod"),A("unlockPeriod"),A("startTime"),A("totalAllocatedShare")]),Gt=_([A(),A("epoch"),V("bump"),V("status"),V("mintDecimalsA"),V("mintDecimalsB"),V("migrateType"),A("supply"),A("totalSellA"),A("virtualA"),A("virtualB"),A("realA"),A("realB"),A("totalFundRaisingB"),A("protocolFee"),A("platformFee"),A("migrateFee"),Ap.replicate("vestingSchedule"),M("configId"),M("platformId"),M("mintA"),M("mintB"),M("vaultA"),M("vaultB"),M("creator"),V("mintProgramFlag"),V("cpmmCreatorFeeOn"),Y(V(),62)]),FK=_([A(),A("epoch"),M("poolId"),M("beneficiary"),A("claimedAmount"),A("tokenShareAmount"),Y(A(),8)]),jc=_([V("migrateType"),V("migrateCpmmFeeOn"),A("supply"),A("totalSellA"),A("totalFundRaisingB"),A("totalLockedAmount"),A("cliffPeriod"),A("unlockPeriod")]),kp=_([A("epoch"),V("index"),M("configId"),jc.replicate("bondingCurveParam"),Y(A(),50)]),mo=_([A(),A("epoch"),M("platformClaimFeeWallet"),M("platformLockNftWallet"),A("platformScale"),A("creatorScale"),A("burnScale"),A("feeRate"),Y(V(),64,"name"),Y(V(),256,"web"),Y(V(),256,"img"),M("cpConfigId"),A("creatorFeeRate"),M("transferFeeExtensionAuth"),Y(V(),180),Bu(kp,"platformCurve")]);var Nt={initialize:Buffer.from([175,175,109,31,13,152,155,237]),initializeV2:Buffer.from([67,153,175,39,218,16,38,32]),buyExactIn:Buffer.from([250,234,13,123,213,156,19,236]),buyExactOut:Buffer.from([24,211,116,40,105,3,153,56]),sellExactIn:Buffer.from([149,39,222,155,211,124,152,26]),sellExactOut:Buffer.from([95,200,71,34,8,9,11,166]),createVestingAccount:Buffer.from([129,178,2,13,217,172,230,218]),claimVestedToken:Buffer.from([49,33,104,30,189,157,79,35]),createPlatformConfig:Buffer.from([176,90,196,175,253,113,220,20]),claimPlatformFee:Buffer.from([156,39,208,135,76,237,61,72]),updatePlaformConfig:Buffer.from([195,60,76,129,146,45,67,143]),initializeWithToken2022:Buffer.from([37,190,126,222,44,154,171,17]),claimPlatformFeeFromVault:Buffer.from([117,241,198,168,248,218,80,29]),claimCreatorFee:Buffer.from([26,97,138,203,132,171,141,252]),updatePlatformCurveParam:Buffer.from([138,144,138,250,220,128,4,57]),removePlatformCurveParam:Buffer.from([27,30,62,169,93,224,24,145])};function $c(d,e,t,n,o,r,i,s,u,a,c,l,m,p,f,y,b,g,P,T,h){let w=_([V("decimals"),Tt("name"),Tt("symbol"),Tt("uri")]),k=_([A("totalLockedAmount"),A("cliffPeriod"),A("unlockPeriod"),V("cpmmCreatorFeeOn")]),x=_([V("index"),A("supply"),A("totalFundRaisingB"),V("migrateType")]),B=_([V("index"),A("supply"),A("totalSellA"),A("totalFundRaisingB"),V("migrateType")]),K=[{pubkey:e,isSigner:!0,isWritable:!0},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!1,isWritable:!1},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!0,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!1},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:Aa,isSigner:!1,isWritable:!1},{pubkey:Aa,isSigner:!1,isWritable:!1},{pubkey:$t,isSigner:!1,isWritable:!1},{pubkey:Xt.programId,isSigner:!1,isWritable:!1},{pubkey:it,isSigner:!1,isWritable:!1},{pubkey:uo(d).publicKey,isSigner:!1,isWritable:!1},{pubkey:d,isSigner:!1,isWritable:!1}],I=Buffer.alloc(Buffer.from(p,"utf-8").length+Buffer.from(f,"utf-8").length+Buffer.from(y,"utf-8").length+4*3+1),R=Buffer.alloc(k.span),C=Buffer.alloc(b.type==="ConstantCurve"?B.span:x.span);return w.encode({decimals:m,name:p,symbol:f,uri:y},I),b.type==="ConstantCurve"?B.encode(D(v({index:0},b),{migrateType:b.migrateType==="amm"?0:1}),C):b.type==="FixedCurve"?x.encode(D(v({index:1},b),{migrateType:b.migrateType==="amm"?0:1}),C):b.type==="LinearCurve"&&x.encode(D(v({index:2},b),{migrateType:b.migrateType==="amm"?0:1}),C),k.encode({totalLockedAmount:g,cliffPeriod:P,unlockPeriod:T,cpmmCreatorFeeOn:h},R),new Ot({keys:K,programId:d,data:Buffer.from([...Nt.initializeV2,...I,...C,...R])})}function Zc(d,e,t,n,o,r,i,s,u,a,c,l,m,p,f,y,b,g,P,T,h){let w=_([V("decimals"),Tt("name"),Tt("symbol"),Tt("uri")]),k=_([A("totalLockedAmount"),A("cliffPeriod"),A("unlockPeriod"),V("cpmmCreatorFeeOn"),V("transferFeeExtensionParamsOption"),_([St("transferFeeBasePoints"),A("maxinumFee")]).replicate("transferFeeExtensionParams")]),x=_([V("index"),A("supply"),A("totalFundRaisingB"),V("migrateType")]),B=_([V("index"),A("supply"),A("totalSellA"),A("totalFundRaisingB"),V("migrateType")]),K=[{pubkey:e,isSigner:!0,isWritable:!0},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!1,isWritable:!1},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!0,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!1},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:wp,isSigner:!1,isWritable:!1},{pubkey:Aa,isSigner:!1,isWritable:!1},{pubkey:Xt.programId,isSigner:!1,isWritable:!1},{pubkey:uo(d).publicKey,isSigner:!1,isWritable:!1},{pubkey:d,isSigner:!1,isWritable:!1}],I=Buffer.alloc(Buffer.from(m,"utf-8").length+Buffer.from(p,"utf-8").length+Buffer.from(f,"utf-8").length+4*3+1),R=Buffer.alloc(k.span),C=Buffer.alloc(y.type==="ConstantCurve"?B.span:x.span);return w.encode({decimals:l,name:m,symbol:p,uri:f},I),y.type==="ConstantCurve"?B.encode(D(v({index:0},y),{migrateType:y.migrateType==="amm"?0:1}),C):y.type==="FixedCurve"?x.encode(D(v({index:1},y),{migrateType:y.migrateType==="amm"?0:1}),C):y.type==="LinearCurve"&&x.encode(D(v({index:2},y),{migrateType:y.migrateType==="amm"?0:1}),C),k.encode({totalLockedAmount:b,cliffPeriod:g,unlockPeriod:P,cpmmCreatorFeeOn:T,transferFeeExtensionParamsOption:h?1:0,transferFeeExtensionParams:h!=null?h:{transferFeeBasePoints:0,maxinumFee:new Oo(0)}},R),new Ot({keys:K,programId:d,data:Buffer.from([...Nt.initializeWithToken2022,...I,...C,...R])})}function Jc(d,e,t,n,o,r,i,s,u,a,c,l,m,p,f,y,b,g,P,T){let h=_([A("amountB"),A("minAmountA"),A("shareFeeRate")]),w=[{pubkey:e,isSigner:!0,isWritable:!0},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!1},{pubkey:l,isSigner:!1,isWritable:!1},{pubkey:m,isSigner:!1,isWritable:!1},{pubkey:p,isSigner:!1,isWritable:!1},{pubkey:uo(d).publicKey,isSigner:!1,isWritable:!1},{pubkey:d,isSigner:!1,isWritable:!1}];T&&w.push({pubkey:T,isSigner:!1,isWritable:!0}),w.push({pubkey:Xt.programId,isSigner:!1,isWritable:!1}),w.push({pubkey:f,isSigner:!1,isWritable:!0}),w.push({pubkey:y,isSigner:!1,isWritable:!0});let k=Buffer.alloc(h.span);return h.encode({amountB:b,minAmountA:g,shareFeeRate:P!=null?P:new Oo(0)},k),new Ot({keys:w,programId:d,data:Buffer.from([...Nt.buyExactIn,...k])})}function el(d,e,t,n,o,r,i,s,u,a,c,l,m,p,f,y,b,g,P,T){let h=_([A("amountA"),A("maxAmountB"),A("shareFeeRate")]),w=[{pubkey:e,isSigner:!0,isWritable:!0},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!1},{pubkey:l,isSigner:!1,isWritable:!1},{pubkey:m,isSigner:!1,isWritable:!1},{pubkey:p,isSigner:!1,isWritable:!1},{pubkey:uo(d).publicKey,isSigner:!1,isWritable:!1},{pubkey:d,isSigner:!1,isWritable:!1}];T&&w.push({pubkey:T,isSigner:!1,isWritable:!0}),w.push({pubkey:Xt.programId,isSigner:!1,isWritable:!1}),w.push({pubkey:f,isSigner:!1,isWritable:!0}),w.push({pubkey:y,isSigner:!1,isWritable:!0});let k=Buffer.alloc(h.span);return h.encode({amountA:b,maxAmountB:g,shareFeeRate:P!=null?P:new Oo(0)},k),new Ot({keys:w,programId:d,data:Buffer.from([...Nt.buyExactOut,...k])})}function tl(d,e,t,n,o,r,i,s,u,a,c,l,m,p,f,y,b,g,P,T){let h=_([A("amountA"),A("minAmountB"),A("shareFeeRate")]),w=[{pubkey:e,isSigner:!0,isWritable:!0},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!1},{pubkey:l,isSigner:!1,isWritable:!1},{pubkey:m,isSigner:!1,isWritable:!1},{pubkey:p,isSigner:!1,isWritable:!1},{pubkey:uo(d).publicKey,isSigner:!1,isWritable:!1},{pubkey:d,isSigner:!1,isWritable:!1}];T&&w.push({pubkey:T,isSigner:!1,isWritable:!0}),w.push({pubkey:Xt.programId,isSigner:!1,isWritable:!1}),w.push({pubkey:f,isSigner:!1,isWritable:!0}),w.push({pubkey:y,isSigner:!1,isWritable:!0});let k=Buffer.alloc(h.span);return h.encode({amountA:b,minAmountB:g,shareFeeRate:P!=null?P:new Oo(0)},k),new Ot({keys:w,programId:d,data:Buffer.from([...Nt.sellExactIn,...k])})}function nl(d,e,t,n,o,r,i,s,u,a,c,l,m,p,f,y,b,g,P,T){let h=_([A("amountB"),A("maxAmountA"),A("shareFeeRate")]),w=[{pubkey:e,isSigner:!0,isWritable:!0},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!1},{pubkey:l,isSigner:!1,isWritable:!1},{pubkey:m,isSigner:!1,isWritable:!1},{pubkey:p,isSigner:!1,isWritable:!1},{pubkey:uo(d).publicKey,isSigner:!1,isWritable:!1},{pubkey:d,isSigner:!1,isWritable:!1}];T&&w.push({pubkey:T,isSigner:!1,isWritable:!0}),w.push({pubkey:Xt.programId,isSigner:!1,isWritable:!1}),w.push({pubkey:f,isSigner:!1,isWritable:!0}),w.push({pubkey:y,isSigner:!1,isWritable:!0});let k=Buffer.alloc(h.span);return h.encode({amountB:b,maxAmountA:g,shareFeeRate:P!=null?P:new Oo(0)},k),new Ot({keys:w,programId:d,data:Buffer.from([...Nt.sellExactOut,...k])})}function ka(d,e,t,n,o,r,i,s,u){let a=_([]),c=[{pubkey:e,isSigner:!0,isWritable:!0},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!1},{pubkey:u,isSigner:!1,isWritable:!1},{pubkey:Xt.programId,isSigner:!1,isWritable:!1},{pubkey:vr,isSigner:!1,isWritable:!1}],l=Buffer.alloc(a.span);return a.encode({},l),new Ot({keys:c,programId:d,data:Buffer.from([...Nt.claimVestedToken,...l])})}function wa(d,e,t,n,o,r){let i=_([A("shareAmount")]),s=[{pubkey:e,isSigner:!0,isWritable:!0},{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:Xt.programId,isSigner:!1,isWritable:!1}],u=Buffer.alloc(i.span);return i.encode({shareAmount:r},u),new Ot({keys:s,programId:d,data:Buffer.from([...Nt.createVestingAccount,...u])})}function Ta(d,e,t,n,o,r,i,s,u){let a=[{pubkey:e,isSigner:!0,isWritable:!0},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:Xt.programId,isSigner:!1,isWritable:!0},{pubkey:vr,isSigner:!1,isWritable:!0}];return new Ot({keys:a,programId:d,data:Nt.claimPlatformFee})}function ol(d,e,t,n,o,r,i,s,u,a,c,l,m){let p=_([A("platformScale"),A("creatorScale"),A("burnScale"),A("feeRate"),Tt("name"),Tt("web"),Tt("img"),A("creatorFeeRate")]),f=[{pubkey:e,isSigner:!0,isWritable:!0},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:Xt.programId,isSigner:!1,isWritable:!1},{pubkey:i,isSigner:!1,isWritable:!1}],y=Buffer.alloc(8*5+Buffer.from(c,"utf-8").length+Buffer.from(l,"utf-8").length+Buffer.from(m,"utf-8").length+4*3);return p.encode({platformScale:s.platformScale,creatorScale:s.creatorScale,burnScale:s.burnScale,feeRate:u,name:c,web:l,img:m,creatorFeeRate:a},y),new Ot({keys:f,programId:d,data:Buffer.from([...Nt.createPlatformConfig,...y])})}function il(d,e,t,n){let o=[{pubkey:e,isSigner:!0,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!0}],r;if(n.type==="updateClaimFeeWallet"){let i=_([V("index"),M("value")]);r=Buffer.alloc(i.span),i.encode({index:0,value:n.value},r)}else if(n.type==="updateLockNftWallet"){let i=_([V("index"),M("value")]);r=Buffer.alloc(i.span),i.encode({index:1,value:n.value},r)}else if(n.type==="migrateCpLockNftScale"){let i=_([V("index"),A("platformScale"),A("creatorScale"),A("burnScale")]);r=Buffer.alloc(i.span),i.encode(v({index:2},n.value),r)}else if(n.type==="updateFeeRate"){let i=_([V("index"),A("value")]);r=Buffer.alloc(i.span),i.encode({index:3,value:n.value},r)}else if(n.type==="updateImg"||n.type==="updateName"||n.type==="updateWeb"){let i=_([V("index"),Tt("value")]);r=Buffer.alloc(Buffer.from(n.value,"utf-8").length+4+1*1),n.type==="updateName"?i.encode({index:4,value:n.value},r):n.type==="updateWeb"?i.encode({index:5,value:n.value},r):n.type==="updateImg"&&i.encode({index:6,value:n.value},r)}else if(n.type==="updateCpConfigId"){o.push({pubkey:n.value,isSigner:!1,isWritable:!1});let i=_([V("index")]);r=Buffer.alloc(i.span),i.encode({index:7},r)}else if(n.type==="updateAll"){o.push({pubkey:n.value.cpConfigId,isSigner:!1,isWritable:!1});let i=_([V("index"),M("platformClaimFeeWallet"),M("platformLockNftWallet"),A("platformScale"),A("creatorScale"),A("burnScale"),A("feeRate"),Tt("name"),Tt("web"),Tt("img"),M("transferFeeExtensionAuth"),A("creatorFeeRate")]);r=Buffer.alloc(1+32+32+8*4+4*3+Buffer.from(n.value.name,"utf-8").length+Buffer.from(n.value.web,"utf-8").length+Buffer.from(n.value.img,"utf-8").length+32+8),i.encode({index:8,platformClaimFeeWallet:n.value.platformClaimFeeWallet,platformLockNftWallet:n.value.platformLockNftWallet,platformScale:n.value.migrateCpLockNftScale.platformScale,creatorScale:n.value.migrateCpLockNftScale.creatorScale,burnScale:n.value.migrateCpLockNftScale.burnScale,feeRate:n.value.feeRate,name:n.value.name,web:n.value.web,img:n.value.img,transferFeeExtensionAuth:n.value.transferFeeExtensionAuth,creatorFeeRate:n.value.creatorFeeRate},r)}else throw Error("updateInfo params type error");return new Ot({keys:o,programId:d,data:Buffer.from([...Nt.updatePlaformConfig,...r])})}function ha(d,e,t,n,o,r,i,s){let u=[{pubkey:t,isSigner:!0,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:e,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!1},{pubkey:s,isSigner:!1,isWritable:!1},{pubkey:Xt.programId,isSigner:!1,isWritable:!1},{pubkey:vr,isSigner:!1,isWritable:!1}];return new Ot({keys:u,programId:d,data:Nt.claimPlatformFeeFromVault})}function Ia(d,e,t,n,o,r,i){let s=[{pubkey:e,isSigner:!0,isWritable:!0},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!1},{pubkey:i,isSigner:!1,isWritable:!1},{pubkey:Xt.programId,isSigner:!1,isWritable:!1},{pubkey:vr,isSigner:!1,isWritable:!1}];return new Ot({keys:s,programId:d,data:Nt.claimCreatorFee})}var QK=new Oo("18446744073709551615");import{NATIVE_MINT as nn,TOKEN_2022_PROGRAM_ID as Yt,TOKEN_PROGRAM_ID as Be,createAssociatedTokenAccountIdempotentInstruction as ft,createSyncNativeInstruction as al,getTransferFeeConfig as Fi,unpackMint as _i}from"@solana/spl-token";import ie from"bn.js";import{PublicKey as cl,SystemProgram as ul}from"@solana/web3.js";import zt from"bn.js";import sl from"decimal.js";import Fr from"bn.js";import Ni from"decimal.js";var En=class{static getPoolInitPriceByPool({poolInfo:e,decimalA:t,decimalB:n}){throw Error()}static getPoolInitPriceByInit({a:e,b:t,decimalA:n,decimalB:o}){throw Error()}static getPoolPrice({poolInfo:e,decimalA:t,decimalB:n}){throw Error()}static getPoolEndPrice({supply:e,totalSell:t,totalLockedAmount:n,totalFundRaising:o,migrateFee:r,decimalA:i,decimalB:s}){throw Error()}static getPoolEndPriceReal({poolInfo:e,decimalA:t,decimalB:n}){throw Error()}static getInitParam({supply:e,totalFundRaising:t,totalSell:n,totalLockedAmount:o,migrateFee:r}){throw Error()}static buyExactIn({poolInfo:e,amount:t}){throw Error()}static buyExactOut({poolInfo:e,amount:t}){throw Error()}static sellExactIn({poolInfo:e,amount:t}){throw Error()}static sellExactOut({poolInfo:e,amount:t}){throw Error()}};var _r=class extends En{static getPoolInitPriceByPool({poolInfo:e,decimalA:t,decimalB:n}){return new Ni(e.virtualB.toString()).div(e.virtualA.toString()).mul(10**(t-n))}static getPoolInitPriceByInit({a:e,b:t,decimalA:n,decimalB:o}){return new Ni(t.toString()).div(e.toString()).mul(10**(n-o))}static getPoolPrice({poolInfo:e,decimalA:t,decimalB:n}){return new Ni(e.virtualB.add(e.realB).toString()).div(e.virtualA.sub(e.realA).toString()).mul(10**(t-n))}static getPoolEndPrice({supply:e,totalSell:t,totalLockedAmount:n,totalFundRaising:o,migrateFee:r,decimalA:i,decimalB:s}){return new Ni(o.sub(r).toString()).div(e.sub(t).sub(n).toString()).mul(10**(i-s))}static getPoolEndPriceReal({poolInfo:e,decimalA:t,decimalB:n}){let o=e.totalSellA.sub(e.realA),r=e.totalFundRaisingB.sub(e.realB);return new Ni(e.virtualB.add(e.realB.add(r)).toString()).div(e.virtualA.sub(e.realA.add(o)).toString()).mul(10**(t-n))}static getInitParam({supply:e,totalFundRaising:t,totalSell:n,totalLockedAmount:o,migrateFee:r}){if(e.lte(n))throw Error("supply need gt total sell");let i=e.sub(n).sub(o);if(i.lte(new Fr(0)))throw Error("supplyMinusSellLocked <= 0");let s=t.sub(r);if(s.lte(new Fr(0)))throw Error("tfMinusMf <= 0");let u=s.mul(n).mul(n).div(i),a=s.mul(n).div(i).sub(t),c=u.div(a),l=t.mul(t).div(a);if(c.lt(new Fr(0))||l.lt(new Fr(0)))throw Error("invalid input 0");return{a:c,b:l,c:n}}static buyExactIn({poolInfo:e,amount:t}){return this.getAmountOut({amountIn:t,inputReserve:e.virtualB.add(e.realB),outputReserve:e.virtualA.sub(e.realA)})}static buyExactOut({poolInfo:e,amount:t}){return this.getAmountIn({amountOut:t,inputReserve:e.virtualB.add(e.realB),outputReserve:e.virtualA.sub(e.realA)})}static sellExactIn({poolInfo:e,amount:t}){return this.getAmountOut({amountIn:t,inputReserve:e.virtualA.sub(e.realA),outputReserve:e.virtualB.add(e.realB)})}static sellExactOut({poolInfo:e,amount:t}){return this.getAmountIn({amountOut:t,inputReserve:e.virtualA.sub(e.realA),outputReserve:e.virtualB.add(e.realB)})}static getAmountOut({amountIn:e,inputReserve:t,outputReserve:n}){let o=e.mul(n),r=t.add(e);return o.div(r)}static getAmountIn({amountOut:e,inputReserve:t,outputReserve:n}){let o=t.mul(e),r=n.sub(e);return Gn(o,r)}};import Vr from"bn.js";import Mi from"decimal.js";var Er=class extends En{static getPoolInitPriceByPool({poolInfo:e,decimalA:t,decimalB:n}){return new Mi(e.virtualB.toString()).div(e.virtualA.toString()).mul(10**(t-n))}static getPoolInitPriceByInit({a:e,b:t,decimalA:n,decimalB:o}){return new Mi(t.toString()).div(e.toString()).mul(10**(n-o))}static getPoolPrice({poolInfo:e,decimalA:t,decimalB:n}){return new Mi(e.virtualB.toString()).div(e.virtualA.toString()).mul(10**(t-n))}static getPoolEndPrice({supply:e,totalSell:t,totalLockedAmount:n,totalFundRaising:o,migrateFee:r,decimalA:i,decimalB:s}){return new Mi(o.sub(r).toString()).div(e.sub(t).sub(n).toString()).mul(10**(i-s))}static getPoolEndPriceReal({poolInfo:e,decimalA:t,decimalB:n}){let o=e.totalSellA.sub(e.realA),r=e.totalFundRaisingB.sub(e.realB);return new Mi(e.virtualB.add(e.realB).add(r).toString()).div(e.virtualA.sub(e.realA).add(o).toString()).mul(10**(t-n))}static getInitParam({supply:e,totalFundRaising:t,totalSell:n,totalLockedAmount:o,migrateFee:r}){let i=e.sub(o);if(i.lte(new Vr(0)))throw Error("invalid input 1");let s=new Vr(2).mul(t).sub(r),a=t.mul(i).div(s);if(a.lt(new Vr(0))||t.lt(new Vr(0)))throw Error("invalid input 0");return{a,b:t,c:a}}static buyExactIn({poolInfo:e,amount:t}){return this.getAmountOut({amountIn:t,initInput:e.virtualB,initOutput:e.virtualA})}static buyExactOut({poolInfo:e,amount:t}){return this.getAmountIn({amountOut:t,initInput:e.virtualB,initOutput:e.virtualA})}static sellExactIn({poolInfo:e,amount:t}){return this.getAmountOut({amountIn:t,initInput:e.virtualA,initOutput:e.virtualB})}static sellExactOut({poolInfo:e,amount:t}){return this.getAmountIn({amountOut:t,initInput:e.virtualA,initOutput:e.virtualB})}static getAmountOut({amountIn:e,initInput:t,initOutput:n}){return n.mul(e).div(t)}static getAmountIn({amountOut:e,initInput:t,initOutput:n}){let o=t.mul(e);return Gn(o,n)}};import It from"bn.js";import po from"decimal.js";import rl from"bn.js";import Ba from"decimal.js";var vi=class{static _multipler(e){return new Ba(10).pow(e)}static getPrice({priceX64:e,decimalA:t,decimalB:n}){return new Ba(e.toString()).div(this._Q64).mul(this._multipler(t)).div(this._multipler(n))}static getPriceX64({price:e,decimalA:t,decimalB:n}){let o=e.mul(this._multipler(n)).div(this._multipler(t));return new rl(o.mul(this._Q64).toFixed(0))}};vi._Q64=new Ba(new rl(1).shln(64).toString());var Wr=class extends En{static getPoolInitPriceByPool({poolInfo:e,decimalA:t,decimalB:n}){return new po(0)}static getPoolInitPriceByInit({a:e,b:t,decimalA:n,decimalB:o}){return new po(0)}static getPoolPrice({poolInfo:e,decimalA:t,decimalB:n}){return new po(e.virtualA.mul(e.realA).toString()).div(vi._Q64).mul(10**(t-n))}static getPoolEndPrice({supply:e,totalSell:t,totalLockedAmount:n,totalFundRaising:o,migrateFee:r,decimalA:i,decimalB:s}){return new po(o.sub(r).toString()).div(e.sub(t).sub(n).toString()).mul(10**(i-s))}static getPoolEndPriceReal({poolInfo:e,decimalA:t,decimalB:n}){let o=e.totalSellA.sub(e.realA),r=e.totalFundRaisingB.sub(e.realB);return new po(e.virtualB.add(e.realB).add(r).toString()).div(e.virtualA.sub(e.realA).add(o).toString()).mul(10**(t-n))}static getInitParam({supply:e,totalFundRaising:t,totalSell:n,totalLockedAmount:o,migrateFee:r}){let i=e.sub(o);if(i.lte(new It(0)))throw Error("supplyMinusLocked need gt 0");let s=t.mul(new It(3)).sub(r),a=t.mul(new It(2)).mul(i).div(s),c=a.mul(a),l=t.mul(new It(2)).mul(Ze).div(c);if(!l.gt(new It(0)))throw Error("a need gt 0");if(!ii.gt(l))throw Error("a need lt u64 max");if(l.lt(new It(0))||a.lt(new It(0)))throw Error("invalid input 0");return{a:l,b:new It(0),c:a}}static buyExactIn({poolInfo:e,amount:t}){let n=e.realB.add(t),o=new It(2).mul(n).mul(Ze).div(e.virtualA);return new It(new po(o.toString()).sqrt().toFixed(0)).sub(e.realA)}static buyExactOut({poolInfo:e,amount:t}){let n=e.realA.add(t),o=n.mul(n);return Gn(e.virtualA.mul(o),new It(2).mul(Ze)).sub(e.realB)}static sellExactIn({poolInfo:e,amount:t}){let n=e.realA.sub(t),o=n.mul(n),r=Gn(e.virtualA.mul(o),new It(2).mul(Ze));return e.realB.sub(r)}static sellExactOut({poolInfo:e,amount:t}){let n=e.realB.sub(t),o=new It(2).mul(n).mul(Ze).div(e.virtualA),r=new It(new po(o.toString()).sqrt().toFixed(0));return e.realA.sub(r)}};var Mt=class{static getPoolCurvePointByPoolInfo({curveType:e,pointCount:t,poolInfo:n}){return this.getPoolCurvePointByInit({curveType:e,pointCount:t,supply:n.supply,totalFundRaising:n.totalFundRaisingB,totalSell:n.totalSellA,totalLockedAmount:n.vestingSchedule.totalLockedAmount,migrateFee:n.migrateFee,decimalA:n.mintDecimalsA,decimalB:n.mintDecimalsB})}static getPoolCurvePointByInit({curveType:e,pointCount:t,supply:n,totalFundRaising:o,totalSell:r,totalLockedAmount:i,migrateFee:s,decimalA:u,decimalB:a}){if(t<3)throw Error("point count < 3");let c=this.getCurve(e),l=c.getInitParam({supply:n,totalFundRaising:o,totalSell:r,totalLockedAmount:i,migrateFee:s}),m=c.getPoolInitPriceByInit(D(v({},l),{decimalA:u,decimalB:a})),p=o.div(new zt(t-1)),f=new zt(0),y=[{price:m,totalSellSupply:0}],{a:b,b:g}=l,P=f,T=f;for(let h=1;h<t;h++){let w=h!==t-1?p:o.sub(T),k=this.buyExactIn({poolInfo:{virtualA:b,virtualB:g,realA:P,realB:T,totalFundRaisingB:o,totalSellA:r},amountB:w,protocolFeeRate:f,platformFeeRate:f,curveType:e,shareFeeRate:f,creatorFeeRate:f,transferFeeConfigA:void 0,slot:0});P=P.add(k.amountA.amount),T=T.add(k.amountB);let x=this.getPrice({poolInfo:{virtualA:b,virtualB:g,realA:P,realB:T},decimalA:u,decimalB:a,curveType:e});y.push({price:x,totalSellSupply:new sl(P.toString()).div(10**u).toNumber()})}return y}static getPoolInitPriceByPool({poolInfo:e,decimalA:t,decimalB:n,curveType:o}){return this.getCurve(o).getPoolInitPriceByPool({poolInfo:e,decimalA:t,decimalB:n})}static getPoolInitPriceByInit({a:e,b:t,decimalA:n,decimalB:o,curveType:r}){return this.getCurve(r).getPoolInitPriceByInit({a:e,b:t,decimalA:n,decimalB:o})}static getPrice({poolInfo:e,curveType:t,decimalA:n,decimalB:o}){return this.getCurve(t).getPoolPrice({poolInfo:e,decimalA:n,decimalB:o})}static getEndPrice({poolInfo:e,curveType:t,decimalA:n,decimalB:o}){return this.getCurve(t).getPoolPrice({poolInfo:e,decimalA:n,decimalB:o})}static getPoolEndPriceReal({poolInfo:e,curveType:t,decimalA:n,decimalB:o}){return this.getCurve(t).getPoolEndPriceReal({poolInfo:e,decimalA:n,decimalB:o})}static checkParam({supply:e,totalFundRaising:t,totalSell:n,totalLockedAmount:o,decimals:r,config:i,migrateType:s}){if(Number(r)!==6)throw Error("decimals = 6");if(e.mul(i.maxLockRate).div(wt).lt(o))throw Error("total lock amount gte max lock amount");if(e.lt(i.minSupplyA.mul(new zt(10**r))))throw Error("supply lt min supply");let a=e.mul(i.minSellRateA).div(wt);if(n.lt(a))throw Error("invalid input");if(t.lt(i.minFundRaisingB))throw Error("total fund raising lt min fund raising");let c=e.sub(n).sub(o),l=e.mul(i.minMigrateRateA).div(wt);if(c.lt(l))throw Error("migrate lt min migrate amoount");let m=e.sub(n).sub(o),p=new zt(new sl(m.mul(t).toString()).sqrt().toFixed(0));if(s==="amm"){let f=new zt(10).pow(new zt(r));if(p.lte(f))throw Error("check migrate lp error")}else if(s==="cpmm"){let f=new zt(100);if(p.lte(f))throw Error("check migrate lp error")}else throw Error("migrate type error")}static buyExactIn({poolInfo:e,amountB:t,protocolFeeRate:n,platformFeeRate:o,curveType:r,shareFeeRate:i,creatorFeeRate:s,transferFeeConfigA:u,slot:a}){let c=this.totalFeeRate({protocolFeeRate:n,platformFeeRate:o,shareFeeRate:i,creatorFeeRate:s}),l=this.calculateFee({amount:t,feeRate:c}),m=t.sub(l),p=this.getCurve(r),f=p.buyExactIn({poolInfo:e,amount:m}),y=e.totalSellA.sub(e.realA),b,g,P;if(f.gt(y)){b=y;let h=p.buyExactOut({poolInfo:e,amount:b});g=this.calculatePreFee({postFeeAmount:h,feeRate:c}),P=g.sub(h)}else b=f,g=t,P=l;let T=this.splitFee({totalFee:P,protocolFeeRate:n,platformFeeRate:o,shareFeeRate:i,creatorFeeRate:s});return{amountA:rs(b,u,a),amountB:g,splitFee:T}}static buyExactOut({poolInfo:e,amountA:t,protocolFeeRate:n,platformFeeRate:o,curveType:r,shareFeeRate:i,creatorFeeRate:s,transferFeeConfigA:u,slot:a}){let c=e.totalSellA.sub(e.realA),l=ss(t,u,a),m=l.fee?l.amount.add(l.fee):l.amount;t.gt(c)&&(m=c);let f=this.getCurve(r).buyExactOut({poolInfo:e,amount:m}),y=this.totalFeeRate({protocolFeeRate:n,platformFeeRate:o,shareFeeRate:i,creatorFeeRate:s}),b=this.calculatePreFee({postFeeAmount:f,feeRate:y}),g=b.sub(f),P=this.splitFee({totalFee:g,protocolFeeRate:n,platformFeeRate:o,shareFeeRate:i,creatorFeeRate:s});return{amountA:l,amountB:b,splitFee:P}}static sellExactIn({poolInfo:e,amountA:t,protocolFeeRate:n,platformFeeRate:o,curveType:r,shareFeeRate:i,creatorFeeRate:s,transferFeeConfigA:u,slot:a}){let c=this.getCurve(r),l=rs(t,u,a),m=l.fee?l.amount.sub(l.fee):l.amount,p=c.sellExactIn({poolInfo:e,amount:m}),f=this.calculateFee({amount:p,feeRate:this.totalFeeRate({protocolFeeRate:n,platformFeeRate:o,shareFeeRate:i,creatorFeeRate:s})}),y=this.splitFee({totalFee:f,protocolFeeRate:n,platformFeeRate:o,shareFeeRate:i,creatorFeeRate:s});return{amountA:l,amountB:p.sub(f),splitFee:y}}static sellExactOut({poolInfo:e,amountB:t,protocolFeeRate:n,platformFeeRate:o,curveType:r,shareFeeRate:i,creatorFeeRate:s,transferFeeConfigA:u,slot:a}){let c=this.totalFeeRate({protocolFeeRate:n,platformFeeRate:o,shareFeeRate:i,creatorFeeRate:s}),l=this.calculatePreFee({postFeeAmount:t,feeRate:c});if(e.realB.lt(l))throw Error("Insufficient liquidity");let m=l.sub(t),f=Mt.getCurve(r).sellExactOut({poolInfo:e,amount:l});if(f.gt(e.realA))throw Error();let y=this.splitFee({totalFee:m,protocolFeeRate:n,platformFeeRate:o,shareFeeRate:i,creatorFeeRate:s});return{amountA:ss(f,u,a),amountB:t,splitFee:y}}static splitFee({totalFee:e,protocolFeeRate:t,platformFeeRate:n,shareFeeRate:o,creatorFeeRate:r}){let i=this.totalFeeRate({protocolFeeRate:t,platformFeeRate:n,shareFeeRate:o,creatorFeeRate:r}),s=i.isZero()?new zt(0):e.mul(n).div(i),u=i.isZero()?new zt(0):e.mul(o).div(i),a=i.isZero()?new zt(0):e.mul(r).div(i),c=e.sub(s).sub(u).sub(a);return{platformFee:s,shareFee:u,protocolFee:c,creatorFee:a}}static calculateFee({amount:e,feeRate:t}){return Vo(e,t,wt)}static calculatePreFee({postFeeAmount:e,feeRate:t}){if(t.isZero())return e;let n=e.mul(wt),o=wt.sub(t);return n.add(o).sub(new zt(1)).div(o)}static totalFeeRate({protocolFeeRate:e,platformFeeRate:t,shareFeeRate:n,creatorFeeRate:o}){if(e.add(t).add(n).add(o).gt(new zt(1e6)))throw Error("total fee rate gt 1_000_000");return e.add(t).add(n).add(o)}static getCurve(e){switch(e){case 0:return _r;case 1:return Er;case 2:return Wr}throw Error("find curve error")}};import at from"decimal.js";var fo={initPriceX64:new ie("515752397214619"),supply:new ie(1e15),totalSellA:new ie(7931e11),totalFundRaisingB:new ie(85e9),totalLockedAmount:new ie("0"),cliffPeriod:new ie("0"),unlockPeriod:new ie("0"),decimals:6,virtualA:new ie("1073471847374405"),virtualB:new ie("30050573465"),realA:new ie(0),realB:new ie(0),protocolFee:new ie(0),platformId:new cl("4Bu96XjU84XjPDSpveTVf6LYGCkfW5FK7SNkREWcEfV4"),vestingSchedule:{totalLockedAmount:new ie(0),cliffPeriod:new ie(0),unlockPeriod:new ie(0),startTime:new ie(0),totalAllocatedShare:new ie(0)}},ln=new ie(1e4),Vi=class extends _e{constructor(e){super(e)}async sayHello(){console.log("hello")}async createLaunchpad(N){var L=N,{programId:e=$e,authProgramId:t,platformId:n=fo.platformId,mintA:o,decimals:r=6,mintBDecimals:i=9,name:s,symbol:u,uri:a,migrateType:c,configId:l,snipers:m,configInfo:p,platformFeeRate:f,txVersion:y,computeBudgetConfig:b,txTipConfig:g,feePayer:P,buyAmount:T,minMintAAmount:h,slippage:w,associatedOnly:k=!0,checkCreateATAOwner:x=!1,extraSigners:B,token2022:K,transferFeeExtensionParams:I,creatorFeeOn:R=0}=L,C=ve(L,["programId","authProgramId","platformId","mintA","decimals","mintBDecimals","name","symbol","uri","migrateType","configId","snipers","configInfo","platformFeeRate","txVersion","computeBudgetConfig","txTipConfig","feePayer","buyAmount","minMintAAmount","slippage","associatedOnly","checkCreateATAOwner","extraSigners","token2022","transferFeeExtensionParams","creatorFeeOn"]);var Bt,Wi,Ka,Ca,Ra,La,Oa,Na,Ma,va;let O=[],F=this.createTxBuilder(P);t=t!=null?t:tn(e).publicKey,K=!!I,K&&(c="cpmm");let G=p;if(!G&&l){let Ht=await this.scope.connection.getAccountInfo(l);Ht&&(G=Bn.decode(Ht.data))}G||this.logAndCreateError("config not found");let z=G.mintB,$=G.curveType,{publicKey:re}=ao(e,o,z),{publicKey:te}=ya(e,re,o),{publicKey:ae}=ya(e,re,z),{publicKey:ye}=Pn(o);console.log(`create token: ${o.toBase58()}, mintB: ${z.toBase58()}, decimals A:${r}/B:${i}, config:${l.toBase58()}`),u.length>10&&this.logAndCreateError("Symbol length should shorter than 11"),a||this.logAndCreateError("uri should not empty");let me=(Bt=C==null?void 0:C.supply)!=null?Bt:fo.supply,J=(Wi=C==null?void 0:C.totalSellA)!=null?Wi:fo.totalSellA,he=(Ka=C==null?void 0:C.totalFundRaisingB)!=null?Ka:fo.totalFundRaisingB,de=(Ca=C==null?void 0:C.totalLockedAmount)!=null?Ca:new ie(0),fe=f;if(!f){let Ht=await this.scope.connection.getAccountInfo(n);Ht||this.logAndCreateError("platform id not found:",n.toString()),fe=mo.decode(Ht.data).feeRate}let on=Mt.getCurve(G.curveType).getInitParam({supply:me,totalFundRaising:he,totalSell:J,totalLockedAmount:de,migrateFee:G.migrateFee}),Oe={epoch:new ie(896),bump:254,status:0,mintDecimalsA:r,mintDecimalsB:i,supply:me,totalSellA:J,mintA:new cl(o),mintB:z,virtualA:on.a,virtualB:on.b,realA:fo.realA,realB:fo.realB,migrateFee:G.migrateFee,migrateType:c==="amm"?0:1,protocolFee:fo.protocolFee,platformFee:fe,platformId:n,configId:l,vaultA:te,vaultB:ae,creator:this.scope.ownerPubKey,totalFundRaisingB:he,vestingSchedule:{totalLockedAmount:de,cliffPeriod:new ie(0),unlockPeriod:new ie(0),startTime:new ie(0),totalAllocatedShare:new ie(0)},mintProgramFlag:K?1:0,cpmmCreatorFeeOn:R},No=Mt.getCurve(G.curveType),{c:qr}=No.getInitParam({supply:Oe.supply,totalFundRaising:Oe.totalFundRaisingB,totalLockedAmount:de,totalSell:G.curveType===0?Oe.totalSellA:new ie(0),migrateFee:G.migrateFee});try{Mt.checkParam({supply:Oe.supply,totalFundRaising:Oe.totalFundRaisingB,totalSell:qr,totalLockedAmount:de,decimals:Oe.mintDecimalsA,config:G,migrateType:c}),this.logDebug("check init params success")}catch(Ht){this.logAndCreateError(`check create mint params failed, ${Ht.message}`)}F.addInstruction({instructions:[K?Zc(e,P!=null?P:this.scope.ownerPubKey,this.scope.ownerPubKey,l,n,t,re,o,z,te,ae,r,s,u,a||"https://",{type:$===0?"ConstantCurve":$===1?"FixedCurve":$===2?"LinearCurve":"ConstantCurve",totalSellA:J,migrateType:c,supply:me,totalFundRaisingB:he},de,(Ra=C==null?void 0:C.cliffPeriod)!=null?Ra:new ie(0),(La=C==null?void 0:C.unlockPeriod)!=null?La:new ie(0),R,I):$c(e,P!=null?P:this.scope.ownerPubKey,this.scope.ownerPubKey,l,n,t,re,o,z,te,ae,ye,r,s,u,a||"https://",{type:$===0?"ConstantCurve":$===1?"FixedCurve":$===2?"LinearCurve":"ConstantCurve",totalSellA:J,migrateType:c,supply:me,totalFundRaisingB:he},de,(Oa=C==null?void 0:C.cliffPeriod)!=null?Oa:new ie(0),(Na=C==null?void 0:C.unlockPeriod)!=null?Na:new ie(0),R)]});let Mo=K?await this.scope.connection.getEpochInfo():void 0,vt=I?{epoch:BigInt((Mo==null?void 0:Mo.epoch)||0),maximumFee:BigInt((Ma=I==null?void 0:I.maxinumFee.toString())!=null?Ma:0),transferFeeBasisPoints:(va=I==null?void 0:I.transferFeeBasePoints)!=null?va:0}:void 0,yo={amountA:{amount:new ie(0),fee:void 0,expirationTime:void 0},amountB:new ie(0),splitFee:{platformFee:new ie(0),shareFee:new ie(0),protocolFee:new ie(0),creatorFee:new ie(0)}},bo;if(B!=null&&B.length&&F.addInstruction({signers:B}),!C.createOnly){let{builder:Ht,extInfo:ll}=await this.buyToken({programId:e,authProgramId:t,mintAProgram:K?Yt:void 0,mintA:o,mintB:z,poolInfo:Oe,buyAmount:T,minMintAAmount:h,shareFeeRate:C.shareFeeRate,shareFeeReceiver:C.shareFeeReceiver,configInfo:G,platformFeeRate:fe,slippage:w,associatedOnly:k,checkCreateATAOwner:x,skipCheckMintA:!vt,transferFeeConfigA:vt?{transferFeeConfigAuthority:t,withdrawWithheldAuthority:t,withheldAmount:BigInt(0),olderTransferFee:vt,newerTransferFee:vt}:void 0,fromCreate:!0});console.log("FEE: ",vt),console.log("PREPARING SNIPER TRANSACTIONS");for(let Fa of m){let{builder:ml,extInfo:Bp}=await this.buyToken({programId:e,authProgramId:t,mintAProgram:K?Yt:void 0,mintA:o,mintB:z,poolInfo:Oe,buyAmount:Fa.amount,minMintAAmount:h,shareFeeRate:C.shareFeeRate,shareFeeReceiver:C.shareFeeReceiver,configInfo:G,platformFeeRate:fe,slippage:w,sniper:Fa,associatedOnly:k,checkCreateATAOwner:x,skipCheckMintA:!vt,transferFeeConfigA:vt?{transferFeeConfigAuthority:t,withdrawWithheldAuthority:t,withheldAmount:BigInt(0),olderTransferFee:vt,newerTransferFee:vt}:void 0,fromCreate:!0});O.push(D(v({},ml.AllTxData),{blockHash:this.scope.blockhashCommitment}))}F.addInstruction(v({},Ht.AllTxData)),yo=v({},ll),bo=(this.scope.cluster==="devnet"||y===1)&&C.shareFeeReceiver?[Ht.allInstructions[0]]:void 0}return y===0?(console.log("VERSION V0"),{tx:await F.sizeCheckBuildV0({computeBudgetConfig:b,swapInfo:yo,splitIns:bo,address:D(v({},Oe),{poolId:re})}),txs:O}):(console.log("VERSION PLAIN"),{tx:await F.sizeCheckBuild({computeBudgetConfig:b,swapInfo:yo,splitIns:bo,address:D(v({},Oe),{poolId:re})}),txs:O})}async buyTokenOriginal({programId:e=$e,authProgramId:t,mintA:n,mintAProgram:o=Be,mintB:r=nn,poolInfo:i,configInfo:s,platformFeeRate:u,txVersion:a,computeBudgetConfig:c,txTipConfig:l,feePayer:m,buyAmount:p,minMintAAmount:f,slippage:y,sniper:b,shareFeeRate:g=new ie(0),shareFeeReceiver:P,associatedOnly:T=!0,checkCreateATAOwner:h=!1,fromCreate:w=!1,transferFeeConfigA:k,skipCheckMintA:x=!1}){var me,J,he;p.lte(new ie(0))&&this.logAndCreateError("buy amount should gt 0:",p.toString());let B=b?this.createSniperTxBuilder(b.owner,b.owner.publicKey):this.createTxBuilder(m),{publicKey:K}=ao(e,n,r);t=t!=null?t:tn(e).publicKey;let I=k;if(!x)if(console.log("!skipCheckMintA: ",x),I)console.log("TOKEN_2022_PROGRAM_ID: ",Yt),o=Yt;else{console.log("!transferFeeConfigA: ",I);let de=await this.scope.connection.getAccountInfo(n);if(de&&de.owner.equals(Yt)){console.log("TOKEN_2022_PROGRAM_ID: ",x),o=de.owner;let fe=_i(n,de,o);I=Fi(fe)||void 0}}let R=this.scope.account.getAssociatedTokenAccount(n,o),C=w?this.scope.account.getAssociatedTokenAccount(r,Be):null,N=r.equals(nn);if(B.addInstruction({instructions:[ft(this.scope.ownerPubKey,R,this.scope.ownerPubKey,n,o),...w?[ft(this.scope.ownerPubKey,C,this.scope.ownerPubKey,r,Be),ul.transfer({fromPubkey:this.scope.ownerPubKey,toPubkey:C,lamports:BigInt(p.toString())}),al(C)]:[]]}),!w){let{account:de,instructionParams:fe}=await this.scope.account.getOrCreateTokenAccount({mint:r,owner:this.scope.ownerPubKey,createInfo:N?{payer:this.scope.ownerPubKey,amount:p}:void 0,skipCloseAccount:!N,notUseTokenAccount:N,associatedOnly:N?!1:T,checkCreateATAOwner:h});de&&(C=de),B.addInstruction(fe||{})}C===void 0&&this.logAndCreateError(`cannot found mintB(${r.toBase58()}) token accounts`,"tokenAccounts",this.scope.account.tokenAccounts);let L=i;if(!L){let de=await this.scope.connection.getAccountInfo(K,{commitment:"processed"});de||this.logAndCreateError("cannot found pool:",K.toBase58()),L=Gt.decode(de.data)}let O=s,F=await Ne(this.scope.connection,[O?void 0:L.configId,L.platformId].filter(Boolean).map(de=>({pubkey:de})));if(!O){let de=F.find(fe=>fe.pubkey.equals(L.configId));(!de||!de.accountInfo)&&this.logAndCreateError("config not found: ",L.configId.toBase58()),O=Bn.decode(de.accountInfo.data)}let G=F.find(de=>de.pubkey.equals(L.platformId));(!G||!G.accountInfo)&&this.logAndCreateError("platform info not found: ",L.configId.toBase58());let z=mo.decode(G.accountInfo.data);u=u||z.feeRate;let $=Mt.buyExactIn({poolInfo:L,amountB:p,protocolFeeRate:O.tradeFeeRate,platformFeeRate:u,curveType:O.curveType,shareFeeRate:g,creatorFeeRate:z.creatorFeeRate,transferFeeConfigA:I,slot:await this.scope.connection.getSlot()}),re=new at($.amountA.amount.toString()).sub((J=(me=$.amountA.fee)==null?void 0:me.toString())!=null?J:0),te=y?new at(ln.sub(y).toNumber()/ln.toNumber()).clampedTo(0,1):new at(1),ae=f!=null?f:y?new ie(re.mul(te).toFixed(0)):$.amountA.amount.sub((he=$.amountA.fee)!=null?he:new ie(0));$.amountB.lt(p)&&console.log(`maximum ${n.toBase58()} amount can buy is ${$.amountA.toString()}, input ${r.toBase58()} amount: ${$.amountB.toString()}`);let ye=P?Z(P,r,Be).publicKey:void 0;return ye&&B.addInstruction({instructions:[ft(this.scope.ownerPubKey,ye,P,r)]}),B.addInstruction({instructions:[Jc(e,this.scope.ownerPubKey,t,L.configId,L.platformId,K,R,C,L.vaultA,L.vaultB,n,r,o,Be,co(e,L.platformId,r).publicKey,lo(e,L.creator,r).publicKey,$.amountB.lt(p)?$.amountB:p,ae,g,ye)]}),B.addCustomComputeBudget(c),B.addTipInstruction(l),B.versionBuild({txVersion:a,extInfo:D(v({},$),{decimalOutAmount:re,minDecimalOutAmount:new at(ae.toString())})})}async buyToken({programId:e=$e,authProgramId:t,mintA:n,mintAProgram:o=Be,mintB:r=nn,poolInfo:i,configInfo:s,platformFeeRate:u,txVersion:a,computeBudgetConfig:c,txTipConfig:l,feePayer:m,buyAmount:p,minMintAAmount:f,slippage:y,shareFeeRate:b=new ie(0),shareFeeReceiver:g,sniper:P,associatedOnly:T=!0,checkCreateATAOwner:h=!1,fromCreate:w=!1,transferFeeConfigA:k,skipCheckMintA:x=!1}){var J,he,de;p.lte(new ie(0))&&this.logAndCreateError("buy amount should gt 0:",p.toString());let B=P?this.createSniperTxBuilder(P.owner,P.owner.publicKey):this.createTxBuilder(m),{publicKey:K}=ao(e,n,r);t=t!=null?t:tn(e).publicKey;let I=k;if(!x)if(console.log("!skipCheckMintA: ",x),I)console.log("mintAProgram: ",Yt),o=Yt;else{console.log("!transferFeeConfigA: ",I);let fe=await this.scope.connection.getAccountInfo(n);if(fe&&fe.owner.equals(Yt)){console.log("!mintInfo: ",fe),o=fe.owner;let Qt=_i(n,fe,o);I=Fi(Qt)||void 0}}let R=P?this.scope.account.getAssociatedTokenAccountByOwner(P.owner.publicKey,n,o):this.scope.account.getAssociatedTokenAccount(n,o),C=w?P?this.scope.account.getAssociatedTokenAccountByOwner(P.owner.publicKey,r,Be):this.scope.account.getAssociatedTokenAccount(r,Be):null,N=r.equals(nn);console.log("userTokenAccountA: ",R),console.log("userTokenAccountB: ",C);let L=[ft((P==null?void 0:P.owner.publicKey)||this.scope.ownerPubKey,R,(P==null?void 0:P.owner.publicKey)||this.scope.ownerPubKey,n,o),...w?[ft((P==null?void 0:P.owner.publicKey)||this.scope.ownerPubKey,C,(P==null?void 0:P.owner.publicKey)||this.scope.ownerPubKey,r,Be),ul.transfer({fromPubkey:(P==null?void 0:P.owner.publicKey)||this.scope.ownerPubKey,toPubkey:C,lamports:BigInt(p.toString())}),al(C)]:[]];if(console.log("adding ixs: ",L),B.addInstruction({instructions:L}),!w){let{account:fe,instructionParams:Qt}=await this.scope.account.getOrCreateTokenAccount({mint:r,owner:this.scope.ownerPubKey,createInfo:N?{payer:this.scope.ownerPubKey,amount:p}:void 0,skipCloseAccount:!N,notUseTokenAccount:N,associatedOnly:N?!1:T,checkCreateATAOwner:h});fe&&(C=fe)}C===void 0&&this.logAndCreateError(`cannot found mintB(${r.toBase58()}) token accounts`,"tokenAccounts",this.scope.account.tokenAccounts);let O=i;if(!O){let fe=await this.scope.connection.getAccountInfo(K,{commitment:"processed"});fe||this.logAndCreateError("cannot found pool:",K.toBase58()),O=Gt.decode(fe.data)}let F=s,G=await Ne(this.scope.connection,[F?void 0:O.configId,O.platformId].filter(Boolean).map(fe=>({pubkey:fe})));if(!F){let fe=G.find(Qt=>Qt.pubkey.equals(O.configId));(!fe||!fe.accountInfo)&&this.logAndCreateError("config not found: ",O.configId.toBase58()),F=Bn.decode(fe.accountInfo.data)}let z=G.find(fe=>fe.pubkey.equals(O.platformId));(!z||!z.accountInfo)&&this.logAndCreateError("platform info not found: ",O.configId.toBase58());let $=mo.decode(z.accountInfo.data);u=u||$.feeRate;let re=Mt.buyExactIn({poolInfo:O,amountB:p,protocolFeeRate:F.tradeFeeRate,platformFeeRate:u,curveType:F.curveType,shareFeeRate:b,creatorFeeRate:$.creatorFeeRate,transferFeeConfigA:I,slot:await this.scope.connection.getSlot()}),te=new at(re.amountA.amount.toString()).sub((he=(J=re.amountA.fee)==null?void 0:J.toString())!=null?he:0),ae=y?new at(ln.sub(y).toNumber()/ln.toNumber()).clampedTo(0,1):new at(1),ye=f!=null?f:y?new ie(te.mul(ae).toFixed(0)):re.amountA.amount.sub((de=re.amountA.fee)!=null?de:new ie(0));re.amountB.lt(p)&&console.log(`maximum ${n.toBase58()} amount can buy is ${re.amountA.toString()}, input ${r.toBase58()} amount: ${re.amountB.toString()}`);let me=g?Z(g,r,Be).publicKey:void 0;return B.addCustomComputeBudget(c),B.addTipInstruction(l),B.versionBuild({txVersion:a,extInfo:D(v({},re),{decimalOutAmount:te,minDecimalOutAmount:new at(ye.toString())})})}async buyTokenExactOut({programId:e=$e,authProgramId:t,mintA:n,mintAProgram:o=Be,mintB:r=nn,poolInfo:i,configInfo:s,transferFeeConfigA:u,platformFeeRate:a,txVersion:c,computeBudgetConfig:l,txTipConfig:m,feePayer:p,maxBuyAmount:f,outAmount:y,slippage:b,shareFeeRate:g=new ie(0),shareFeeReceiver:P,associatedOnly:T=!0,checkCreateATAOwner:h=!1,skipCheckMintA:w=!1}){y.lte(new ie(0))&&this.logAndCreateError("out amount should gt 0:",y.toString());let k=this.createTxBuilder(p),{publicKey:x}=ao(e,n,r);t=t!=null?t:tn(e).publicKey;let B=i;if(!B){let me=await this.scope.connection.getAccountInfo(x,{commitment:"processed"});me||this.logAndCreateError("cannot found pool:",x.toBase58()),B=Gt.decode(me.data)}let K=s,I=await Ne(this.scope.connection,[K?void 0:B.configId,B.platformId].filter(Boolean).map(me=>({pubkey:me})));if(!K){let me=I.find(J=>J.pubkey.equals(B.configId));(!me||!me.accountInfo)&&this.logAndCreateError("config not found: ",B.configId.toBase58()),K=Bn.decode(me.accountInfo.data)}let R=I.find(me=>me.pubkey.equals(B.platformId));(!R||!R.accountInfo)&&this.logAndCreateError("platform info not found: ",B.configId.toBase58());let C=mo.decode(R.accountInfo.data);a=a||C.feeRate;let N=u;if(!w)if(N)o=Yt;else{let me=await this.scope.connection.getAccountInfo(n);if(me&&me.owner.equals(Yt)){o=me.owner;let J=_i(n,me,o);N=Fi(J)||void 0}}let L=Mt.buyExactOut({poolInfo:B,amountA:y,protocolFeeRate:K.tradeFeeRate,platformFeeRate:a,curveType:K.curveType,shareFeeRate:g,creatorFeeRate:C.creatorFeeRate,transferFeeConfigA:N,slot:await this.scope.connection.getSlot()}),O=new at(L.amountB.toString()),F=b?new at(ln.add(b).toNumber()/ln.toNumber()).clampedTo(0,Number.MIN_SAFE_INTEGER):new at(1),G=(f!=null?f:b)?new ie(O.mul(F).toFixed(0)):L.amountB,z=this.scope.account.getAssociatedTokenAccount(n,o),$=null,re=r.equals(nn);k.addInstruction({instructions:[ft(this.scope.ownerPubKey,z,this.scope.ownerPubKey,n,o)]});let{account:te,instructionParams:ae}=await this.scope.account.getOrCreateTokenAccount({mint:r,owner:this.scope.ownerPubKey,createInfo:re?{payer:this.scope.ownerPubKey,amount:L.amountB}:void 0,skipCloseAccount:!re,notUseTokenAccount:re,associatedOnly:re?!1:T,checkCreateATAOwner:h});te&&($=te),k.addInstruction(ae||{}),$===void 0&&this.logAndCreateError(`cannot found mintB(${r.toBase58()}) token accounts`,"tokenAccounts",this.scope.account.tokenAccounts);let ye=P?Z(P,r,Be).publicKey:void 0;return ye&&k.addInstruction({instructions:[ft(this.scope.ownerPubKey,ye,P,r)]}),k.addInstruction({instructions:[el(e,this.scope.ownerPubKey,t,B.configId,B.platformId,x,z,$,B.vaultA,B.vaultB,n,r,o,Be,co(e,B.platformId,r).publicKey,lo(e,B.creator,r).publicKey,y,G,g,ye)]}),k.addCustomComputeBudget(l),k.addTipInstruction(m),k.versionBuild({txVersion:c,extInfo:{maxSpentAmount:G,outAmount:y}})}async sellToken({programId:e=$e,authProgramId:t,mintAProgram:n=Be,mintA:o,mintB:r=nn,poolInfo:i,configInfo:s,platformFeeRate:u,txVersion:a,computeBudgetConfig:c,txTipConfig:l,feePayer:m,sellAmount:p,minAmountB:f,slippage:y,shareFeeRate:b=new ie(0),shareFeeReceiver:g,associatedOnly:P=!0,checkCreateATAOwner:T=!1,skipCheckMintA:h=!1}){t=t!=null?t:tn(e).publicKey;let w=this.createTxBuilder(m);p.lte(new ie(0))&&this.logAndCreateError("sell amount should be gt 0");let{publicKey:k}=ao(e,o,r),x;if(!h){let J=await this.scope.connection.getAccountInfo(o);if(J&&J.owner.equals(Yt)){n=J.owner;let he=_i(o,J,n);x=Fi(he)||void 0}}let B=null,K=null,I=r.equals(nn),{account:R,instructionParams:C}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:n,mint:o,owner:this.scope.ownerPubKey,createInfo:void 0,skipCloseAccount:!0,notUseTokenAccount:!1,associatedOnly:P,checkCreateATAOwner:T});R&&(B=R),w.addInstruction(C||{}),B===void 0&&this.logAndCreateError("cannot found mintA token accounts","tokenAccounts",this.scope.account.tokenAccounts);let{account:N,instructionParams:L}=await this.scope.account.getOrCreateTokenAccount({mint:r,owner:this.scope.ownerPubKey,createInfo:I?{payer:this.scope.ownerPubKey,amount:0}:void 0,skipCloseAccount:!I,notUseTokenAccount:I,associatedOnly:I?!1:P,checkCreateATAOwner:T});N&&(K=N),w.addInstruction(L||{}),K===void 0&&this.logAndCreateError("cannot found mintB token accounts","tokenAccounts",this.scope.account.tokenAccounts);let O=i;if(!O){let J=await this.scope.connection.getAccountInfo(k,{commitment:"processed"});J||this.logAndCreateError("cannot found pool",k.toBase58()),O=Gt.decode(J.data)}let F=s,G=await Ne(this.scope.connection,[F?void 0:O.configId,O.platformId].filter(Boolean).map(J=>({pubkey:J})));if(!F){let J=G.find(he=>he.pubkey.equals(O.configId));(!J||!J.accountInfo)&&this.logAndCreateError("config not found: ",O.configId.toBase58()),F=Bn.decode(J.accountInfo.data)}let z=G.find(J=>J.pubkey.equals(O.platformId));(!z||!z.accountInfo)&&this.logAndCreateError("platform info not found: ",O.configId.toBase58());let $=mo.decode(z.accountInfo.data);u=u||$.feeRate;let re=Mt.sellExactIn({poolInfo:O,amountA:p,protocolFeeRate:F.tradeFeeRate,platformFeeRate:u,curveType:F.curveType,shareFeeRate:b,creatorFeeRate:$.creatorFeeRate,transferFeeConfigA:x,slot:await this.scope.connection.getSlot()}),te=new at(re.amountB.toString()),ae=y?new at(ln.sub(y).toNumber()/ln.toNumber()).clampedTo(0,1):new at(1),ye=f!=null?f:y?new ie(te.mul(ae).toFixed(0)):re.amountB;ye.lte(new ie(0))&&this.logAndCreateError(`out ${r.toBase58()} amount should be gt 0`);let me=g?Z(g,r,Be).publicKey:void 0;return me&&w.addInstruction({instructions:[ft(this.scope.ownerPubKey,me,g,r)]}),w.addInstruction({instructions:[tl(e,this.scope.ownerPubKey,t,O.configId,O.platformId,k,B,K,O.vaultA,O.vaultB,o,r,n,Be,co(e,O.platformId,r).publicKey,lo(e,O.creator,r).publicKey,re.amountA.amount.lt(p)?re.amountA.amount:p,ye,b,me)]}),w.addCustomComputeBudget(c),w.addTipInstruction(l),w.versionBuild({txVersion:a,extInfo:{outAmount:ye}})}async sellTokenExactOut({programId:e=$e,authProgramId:t,mintAProgram:n=Be,mintA:o,mintB:r=nn,poolInfo:i,configInfo:s,platformFeeRate:u,txVersion:a,computeBudgetConfig:c,txTipConfig:l,feePayer:m,inAmount:p,maxSellAmount:f,slippage:y,shareFeeRate:b=new ie(0),shareFeeReceiver:g,associatedOnly:P=!0,checkCreateATAOwner:T=!1,skipCheckMintA:h=!1}){t=t!=null?t:tn(e).publicKey;let w=this.createTxBuilder(m);f!=null&&f.lte(new ie(0))&&this.logAndCreateError("max sell amount should be gt 0");let{publicKey:k}=ao(e,o,r),x;if(!h){let J=await this.scope.connection.getAccountInfo(o);if(J&&J.owner.equals(Yt)){n=J.owner;let he=_i(o,J,n);x=Fi(he)||void 0}}let B=null,K=null,I=r.equals(nn),{account:R,instructionParams:C}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:n,mint:o,owner:this.scope.ownerPubKey,createInfo:void 0,skipCloseAccount:!0,notUseTokenAccount:!1,associatedOnly:P,checkCreateATAOwner:T});R&&(B=R),w.addInstruction(C||{}),B===void 0&&this.logAndCreateError("cannot found mintA token accounts","tokenAccounts",this.scope.account.tokenAccounts);let{account:N,instructionParams:L}=await this.scope.account.getOrCreateTokenAccount({mint:r,owner:this.scope.ownerPubKey,createInfo:I?{payer:this.scope.ownerPubKey,amount:0}:void 0,skipCloseAccount:!I,notUseTokenAccount:I,associatedOnly:I?!1:P,checkCreateATAOwner:T});N&&(K=N),w.addInstruction(L||{}),K===void 0&&this.logAndCreateError("cannot found mintB token accounts","tokenAccounts",this.scope.account.tokenAccounts);let O=i;if(!O){let J=await this.scope.connection.getAccountInfo(k,{commitment:"processed"});J||this.logAndCreateError("cannot found pool",k.toBase58()),O=Gt.decode(J.data)}let F=s,G=await Ne(this.scope.connection,[F?void 0:O.configId,O.platformId].filter(Boolean).map(J=>({pubkey:J})));if(!F){let J=G.find(he=>he.pubkey.equals(O.configId));(!J||!J.accountInfo)&&this.logAndCreateError("config not found: ",O.configId.toBase58()),F=Bn.decode(J.accountInfo.data)}let z=G.find(J=>J.pubkey.equals(O.platformId));(!z||!z.accountInfo)&&this.logAndCreateError("platform info not found: ",O.configId.toBase58());let $=mo.decode(z.accountInfo.data);u=u||$.feeRate;let re=Mt.sellExactOut({poolInfo:O,amountB:p,protocolFeeRate:F.tradeFeeRate,platformFeeRate:u,curveType:F.curveType,shareFeeRate:b,creatorFeeRate:$.creatorFeeRate,transferFeeConfigA:x,slot:await this.scope.connection.getSlot()}),te=new at(re.amountA.amount.toString()),ae=y?new at(ln.add(y).toNumber()/ln.toNumber()).clampedTo(0,Number.MAX_SAFE_INTEGER):new at(1),ye=(f!=null?f:y)?new ie(te.mul(ae).toFixed(0)):re.amountA.amount,me=g?Z(g,r,Be).publicKey:void 0;return me&&w.addInstruction({instructions:[ft(this.scope.ownerPubKey,me,g,r)]}),w.addInstruction({instructions:[nl(e,this.scope.ownerPubKey,t,O.configId,O.platformId,k,B,K,O.vaultA,O.vaultB,o,r,n,Be,co(e,O.platformId,r).publicKey,lo(e,O.creator,r).publicKey,p,ye,b,me)]}),w.addCustomComputeBudget(c),w.addTipInstruction(l),w.versionBuild({txVersion:a,extInfo:{maxSellAmount:ye}})}async createPlatformConfig({programId:e=$e,platformAdmin:t,platformClaimFeeWallet:n,platformLockNftWallet:o,cpConfigId:r,migrateCpLockNftScale:i,transferFeeExtensionAuth:s,creatorFeeRate:u,feeRate:a,name:c,web:l,img:m,txVersion:p,computeBudgetConfig:f,txTipConfig:y,feePayer:b}){let g=this.createTxBuilder(b),{publicKey:P}=ba(e,t);return g.addInstruction({instructions:[ol(e,t,n,o,P,r,s,i,a,u,c,l,m)]}),g.addCustomComputeBudget(f),g.addTipInstruction(y),g.versionBuild({txVersion:p,extInfo:{platformId:P}})}async updatePlatformConfig({programId:e=$e,platformAdmin:t,platformId:n,updateInfo:o,txVersion:r,computeBudgetConfig:i,txTipConfig:s,feePayer:u}){let a=this.createTxBuilder(u),c=n!=null?n:ba(e,t).publicKey;return a.addInstruction({instructions:[il(e,t,c,o)]}),a.addCustomComputeBudget(i),a.addTipInstruction(s),a.versionBuild({txVersion:r})}async claimPlatformFee({programId:e=$e,authProgramId:t,platformId:n,poolId:o,platformClaimFeeWallet:r,mintB:i,vaultB:s,mintBProgram:u=Be,txVersion:a,computeBudgetConfig:c,txTipConfig:l,feePayer:m}){var g;let p=this.createTxBuilder(m);t=t!=null?t:tn(e).publicKey;let f=i,y=s;if(!f){let P=await this.scope.connection.getAccountInfo(o,{commitment:"processed"});P||this.logAndCreateError("cannot found pool:",o.toBase58());let T=Gt.decode(P.data),h=await this.scope.connection.getAccountInfo(T.configId,{commitment:"processed"});h||this.logAndCreateError("cannot found config:",T.configId.toBase58()),f=Bn.decode(h.data).mintB,y=y!=null?y:T.vaultB}(!f||!y)&&this.logAndCreateError("cannot found mint info, mintB: ",f.toBase58(),", vaultB: ",(g=y==null?void 0:y.toBase58())!=null?g:"");let b=Z(this.scope.ownerPubKey,f,Be).publicKey;return p.addInstruction({instructions:[ft(this.scope.ownerPubKey,b,this.scope.ownerPubKey,f)]}),p.addInstruction({instructions:[Ta(e,r,t,o,n,y,b,f,u)]}),p.addCustomComputeBudget(c),p.addTipInstruction(l),p.versionBuild({txVersion:a})}async claimAllPlatformFee({programId:e=$e,authProgramId:t,platformId:n,platformClaimFeeWallet:o,txVersion:r,computeBudgetConfig:i,txTipConfig:s,feePayer:u}){let a=this.createTxBuilder(u);return t=t!=null?t:tn(e).publicKey,(await this.scope.connection.getProgramAccounts(e,{filters:[{dataSize:Gt.span},{memcmp:{offset:Gt.offsetOf("platformId"),bytes:n.toString()}}]})).forEach(l=>{let m=Gt.decode(l.account.data);if(m.platformFee.lte(new ie(0)))return;let p=Z(this.scope.ownerPubKey,m.mintB,Be).publicKey;a.addInstruction({instructions:[ft(this.scope.ownerPubKey,p,this.scope.ownerPubKey,m.mintB)]}),a.addInstruction({instructions:[Ta(e,o,t,l.pubkey,n,m.vaultB,p,m.mintB,Be)]})}),a.addTipInstruction(s),r===0?a.sizeCheckBuildV0({computeBudgetConfig:i}):a.sizeCheckBuild({computeBudgetConfig:i})}async createVesting({programId:e=$e,poolId:t,beneficiary:n,shareAmount:o,txVersion:r,computeBudgetConfig:i,txTipConfig:s,feePayer:u}){let a=this.createTxBuilder(u),c=await this.getRpcPoolInfo({poolId:t});o.add(c.vestingSchedule.totalAllocatedShare).gt(c.vestingSchedule.totalLockedAmount)&&this.logAndCreateError("share amount exceed total locked amount");let l=Oi(e,t,n).publicKey;return a.addInstruction({instructions:[wa(e,this.scope.ownerPubKey,n,t,l,o)]}),a.addCustomComputeBudget(i),a.addTipInstruction(s),a.versionBuild({txVersion:r})}async createMultipleVesting({programId:e=$e,poolId:t,beneficiaryList:n,txVersion:o,computeBudgetConfig:r,feePayer:i}){let s=this.createTxBuilder(i);n.length===0&&this.logAndCreateError("beneficiaryList is null");let u=await this.getRpcPoolInfo({poolId:t});return n.reduce((c,l)=>c.add(l.shareAmount),u.vestingSchedule.totalAllocatedShare).gt(u.vestingSchedule.totalLockedAmount)&&this.logAndCreateError("share amount exceed total locked amount"),n.forEach(c=>{let l=Oi(e,t,c.wallet).publicKey;s.addInstruction({instructions:[wa(e,this.scope.ownerPubKey,c.wallet,t,l,c.shareAmount)]})}),o===0?s.sizeCheckBuildV0({computeBudgetConfig:r}):s.sizeCheckBuild({computeBudgetConfig:r})}async claimVesting({programId:e=$e,poolId:t,poolInfo:n,vestingRecord:o,txVersion:r,computeBudgetConfig:i,txTipConfig:s,feePayer:u}){let a=this.createTxBuilder(u),c=tn(e).publicKey,l=o||Oi(e,t,this.scope.ownerPubKey).publicKey,m=n;if(!m){let f=await this.scope.connection.getAccountInfo(t);f||this.logAndCreateError("pool not found"),m=Gt.decode(f.data)}let p=Z(this.scope.ownerPubKey,m.mintA,Be).publicKey;return a.addInstruction({instructions:[ft(this.scope.ownerPubKey,p,this.scope.ownerPubKey,m.mintA)]}),a.addInstruction({instructions:[ka(e,this.scope.ownerPubKey,c,t,l,p,m.vaultA,m.mintA,Be)]}),a.addCustomComputeBudget(i),a.addTipInstruction(s),a.versionBuild({txVersion:r})}async claimMultiVesting({programId:e=$e,poolIdList:t,poolsInfo:n={},vestingRecords:o={},txVersion:r,computeBudgetConfig:i,feePayer:s}){let u=this.createTxBuilder(s),a=v({},n),c=tn(e).publicKey,l=t.filter(m=>!a[m.toBase58()]);if(l.length){let m=await this.getRpcPoolsInfo({poolIdList:l});a=v(v({},a),m.poolInfoMap)}return t.forEach(m=>{let p=m.toBase58(),f=a[p];f||this.logAndCreateError(`pool info not found: ${p}`);let y=o[p]||Oi(e,m,this.scope.ownerPubKey).publicKey,b=Z(this.scope.ownerPubKey,f.mintA,Be).publicKey;u.addInstruction({instructions:[ft(this.scope.ownerPubKey,b,this.scope.ownerPubKey,f.mintA)]}),u.addInstruction({instructions:[ka(e,this.scope.ownerPubKey,c,m,y,b,f.vaultA,f.mintA,Be)]})}),r===0?u.sizeCheckBuildV0({computeBudgetConfig:i}):u.sizeCheckBuild({computeBudgetConfig:i})}async claimVaultPlatformFee({programId:e=$e,platformId:t,mintB:n,mintBProgram:o=Be,claimFeeWallet:r,txVersion:i,computeBudgetConfig:s,txTipConfig:u,feePayer:a}){let c=this.createTxBuilder(a),l=co(e,t,n).publicKey,m=ga(e).publicKey,p=this.scope.account.getAssociatedTokenAccount(n,o);return c.addInstruction({instructions:[ft(this.scope.ownerPubKey,p,this.scope.ownerPubKey,n,o),ha(e,t,r!=null?r:this.scope.ownerPubKey,m,l,p,n,o)]}),c.addCustomComputeBudget(s),c.addTipInstruction(u),c.versionBuild({txVersion:i})}async claimMultipleVaultPlatformFee({programId:e=$e,platformList:t,unwrapSol:n=!0,txVersion:o,computeBudgetConfig:r,feePayer:i,associatedOnly:s=!0,checkCreateATAOwner:u=!1}){let a=this.createTxBuilder(i),c={};return t.forEach(async l=>{var b,g;let m=ga(e).publicKey,p=co(e,l.id,l.mintB).publicKey,f=l.mintB.equals(nn)&&n,y=c[l.mintB.toBase58()];if(!y){let{account:P,instructionParams:T}=await this.scope.account.getOrCreateTokenAccount({mint:l.mintB,owner:this.scope.ownerPubKey,createInfo:f?{payer:this.scope.ownerPubKey,amount:0}:void 0,skipCloseAccount:!f,notUseTokenAccount:f,associatedOnly:f?!1:s,checkCreateATAOwner:u});P&&(y=P),a.addInstruction(T||{}),y===void 0&&this.logAndCreateError(`cannot found platform ${l.id.toBase58()} mintB(${l.mintB.toBase58()}) token accounts`,"tokenAccounts",this.scope.account.tokenAccounts)}a.addInstruction({instructions:[ha(e,l.id,(b=l.claimFeeWallet)!=null?b:this.scope.ownerPubKey,p,m,y,l.mintB,(g=l.mintBProgram)!=null?g:Be)]})}),o===0?a.sizeCheckBuildV0({computeBudgetConfig:r}):a.sizeCheckBuild({computeBudgetConfig:r})}async claimCreatorFee({programId:e=$e,mintB:t,mintBProgram:n=Be,txVersion:o,computeBudgetConfig:r,txTipConfig:i,feePayer:s}){let u=this.createTxBuilder(s),a=lo(e,this.scope.ownerPubKey,t).publicKey,c=Pa(e).publicKey,l=this.scope.account.getAssociatedTokenAccount(t,n);return u.addInstruction({instructions:[ft(this.scope.ownerPubKey,l,this.scope.ownerPubKey,t,n),Ia(e,this.scope.ownerPubKey,c,a,l,t,n)]}),u.addCustomComputeBudget(r),u.addTipInstruction(i),u.versionBuild({txVersion:o})}async claimMultipleCreatorFee({programId:e=$e,mintBList:t,txVersion:n,computeBudgetConfig:o,feePayer:r}){let i=this.createTxBuilder(r);return t.forEach(s=>{var p;let u=s.pubKey,a=(p=s.programId)!=null?p:Be,c=lo(e,this.scope.ownerPubKey,u).publicKey,l=Pa(e).publicKey,m=this.scope.account.getAssociatedTokenAccount(u,a);i.addInstruction({instructions:[ft(this.scope.ownerPubKey,m,this.scope.ownerPubKey,u,a),Ia(e,this.scope.ownerPubKey,l,c,m,u,a)]})}),n==0?i.sizeCheckBuildV0({computeBudgetConfig:o}):i.sizeCheckBuild({computeBudgetConfig:o})}async getRpcPoolInfo({poolId:e}){return(await this.getRpcPoolsInfo({poolIdList:[e]})).poolInfoMap[e.toBase58()]}async getRpcPoolsInfo({poolIdList:e,config:t}){let n=await Ne(this.scope.connection,e.map(u=>({pubkey:u})),t),o={},r=[];for(let u=0;u<e.length;u++){let a=n[u];if(a===null||!a.accountInfo)throw Error("fetch pool info error: "+e[u].toBase58());let c=Gt.decode(a.accountInfo.data);o[e[u].toBase58()]=D(v({},c),{poolId:a.accountInfo.owner}),r.push(c.configId)}let i=await Ne(this.scope.connection,r.map(u=>({pubkey:u})),t),s={};for(let u=0;u<r.length;u++){let a=i[u];if(a===null||!a.accountInfo)throw Error("fetch config info error: "+r[u].toBase58());let c=Bn.decode(a.accountInfo.data);s[r[u].toBase58()]=D(v({},c),{configId:a.accountInfo.owner})}return{poolInfoMap:Object.keys(o).reduce((u,a)=>D(v({},u),{[a]:D(v({},o[a]),{configInfo:s[o[a].configId.toBase58()]})}),{})}}};import{PublicKey as Tp}from"@solana/web3.js";import{MintLayout as hp,TOKEN_2022_PROGRAM_ID as xa,TOKEN_PROGRAM_ID as Sa}from"@solana/spl-token";var Ei=class extends _e{constructor(t){super(t);this._tokenList=[];this._tokenMap=new Map;this._blackTokenMap=new Set;this._mintGroup={official:new Set,jup:new Set,extra:new Set};this._whiteMap=new Set;this._extraTokenList=[]}async load(t){this.checkDisabled();let{forceUpdate:n=!1,type:o="strict"}=t||{},{mintList:r,blacklist:i,whiteList:s}=await this.scope.fetchV3TokenList(n),u=await this.scope.fetchJupTokenList(n);this._tokenList=[],this._tokenMap=new Map,this._blackTokenMap=new Set(i),this._mintGroup={official:new Set,jup:new Set,extra:new Set},this._whiteMap=new Set(s),this._tokenMap.set(xn.address,xn),this._mintGroup.official.add(xn.address),r.forEach(a=>{var c;this._blackTokenMap.has(a.address)||(this._tokenMap.set(a.address,D(v({},a),{type:"raydium",priority:2,programId:(c=a.programId)!=null?c:a.tags.includes("token-2022")?xa.toBase58():Sa.toBase58()})),this._mintGroup.official.add(a.address))}),u.forEach(a=>{var c;this._blackTokenMap.has(a.address)||this._tokenMap.has(a.address)||(this._tokenMap.set(a.address,D(v({},a),{type:"jupiter",priority:1,programId:(c=a.programId)!=null?c:a.tags.includes("token-2022")?xa.toBase58():Sa.toBase58(),tags:a.freezeAuthority?[...a.tags||[],"hasFreeze"]:a.tags})),this._mintGroup.jup.add(a.address))}),this._extraTokenList.forEach(a=>{this._blackTokenMap.has(a.address)||this._tokenMap.has(a.address)||(this._tokenMap.set(a.address,D(v({},a),{type:"extra",priority:1,programId:a.programId||a.tags.includes("token-2022")?xa.toBase58():Sa.toBase58()})),this._mintGroup.extra.add(a.address))}),this._tokenList=Array.from(this._tokenMap).map(a=>a[1])}get tokenList(){return this._tokenList}get tokenMap(){return this._tokenMap}get blackTokenMap(){return this._blackTokenMap}get mintGroup(){return this._mintGroup}get whiteListMap(){return this._whiteMap}async getTokenInfo(t){if(!t)throw new Error("please input mint");let n=t.toString(),o=this._tokenMap.get(n);if(o)return o;if(n.toLocaleUpperCase()==="SOL")return xn;let r=(await this.scope.api.getTokenInfo([n]))[0];if(r)return this._mintGroup.extra.add(n),this._tokenMap.set(n,D(v({},r),{priority:2})),r;let i=await this.scope.connection.getAccountInfo(new Tp(n));if(!i)throw new Error(`mint address not found: ${n}`);let s=hp.decode(i.data),u=n.toString().substring(0,6),a={chainId:101,address:n,programId:i.owner.toBase58(),logoURI:"",symbol:u,name:u,decimals:s.decimals,tags:[],extensions:{},priority:0,type:"unknown"};return this._mintGroup.extra.add(n),this._tokenMap.set(n,a),a}};var Dr=class{constructor(e){this.rawBalances=new Map;let{connection:t,cluster:n,owner:o,api:r,defaultChainTime:i,defaultChainTimeOffset:s,apiCacheTime:u,blockhashCommitment:a="confirmed",loopMultiTxStatus:c}=e;this._connection=t,this.cluster=n||"mainnet",this._owner=o?new xt(o):void 0,this._signAllTransactions=e.signAllTransactions,this.blockhashCommitment=a,this.loopMultiTxStatus=c,this.api=r,this._apiCacheTime=u||5*60*1e3,this.logger=ge("Raydium"),this.farm=new oi({scope:this,moduleName:"Raydium_Farm"}),this.account=new Ho({scope:this,moduleName:"Raydium_Account",tokenAccounts:e.tokenAccounts,tokenAccountRawInfos:e.tokenAccountRawInfos}),this.liquidity=new Pi({scope:this,moduleName:"Raydium_LiquidityV2"}),this.token=new Ei({scope:this,moduleName:"Raydium_tokenV2"}),this.tradeV2=new Ci({scope:this,moduleName:"Raydium_tradeV2"}),this.clmm=new ki({scope:this,moduleName:"Raydium_clmm"}),this.cpmm=new Si({scope:this,moduleName:"Raydium_cpmm"}),this.utils1216=new Ut({scope:this,moduleName:"Raydium_utils1216"}),this.marketV2=new So({scope:this,moduleName:"Raydium_marketV2"}),this.ido=new Lo({scope:this,moduleName:"Raydium_ido"}),this.launchpad=new Vi({scope:this,moduleName:"Raydium_lauchpad"}),this.availability={};let l=new Date().getTime();this.apiData={},s&&(this._chainTime={fetched:l,value:{chainTime:i||Date.now()-s,offset:s}})}static async load(e){var c;let t=Ip({cluster:"mainnet",owner:null,apiRequestInterval:3e5,apiRequestTimeout:1e4},e),{cluster:n,apiRequestTimeout:o,logCount:r,logRequests:i,urlConfigs:s}=t,u=new or({cluster:n,timeout:o,urlConfigs:s,logCount:r,logRequests:i}),a=new Dr(D(v({},t),{api:u}));return await a.fetchAvailabilityStatus((c=e.disableFeatureCheck)!=null?c:!0),e.disableLoadToken||await a.token.load({type:e.jupTokenType}),a}get owner(){return this._owner}get ownerPubKey(){if(!this._owner)throw new Error(ir);return this._owner.publicKey}setOwner(e){return this._owner=e?new xt(e):void 0,this.account.resetTokenAccounts(),this}get connection(){if(!this._connection)throw new Error(mu);return this._connection}setConnection(e){return this._connection=e,this}get signAllTransactions(){return this._signAllTransactions}setSignAllTransactions(e){return this._signAllTransactions=e,this}checkOwner(){if(!this.owner)throw console.error(ir),new Error(ir)}isCacheInvalidate(e){return new Date().getTime()-e>this._apiCacheTime}async fetchChainTime(){try{let e=await this.api.getChainTimeOffset();this._chainTime={fetched:Date.now(),value:{chainTime:Date.now()+e.offset*1e3,offset:e.offset*1e3}}}catch{this._chainTime=void 0}}async fetchV3TokenList(e){if(this.apiData.tokenList&&!this.isCacheInvalidate(this.apiData.tokenList.fetched)&&!e)return this.apiData.tokenList.data;try{let t=await this.api.getTokenList(),n={fetched:Date.now(),data:t};return this.apiData.tokenList=n,n.data}catch(t){return console.error(t),{mintList:[],blacklist:[],whiteList:[]}}}async fetchJupTokenList(e){if(this.cluster==="devnet")return[];let t=this.apiData.jupTokenList;if(t&&!this.isCacheInvalidate(t.fetched)&&!e)return t.data;try{let n=await this.api.getJupTokenList();return this.apiData.jupTokenList={fetched:Date.now(),data:n.map(o=>D(v({},o),{mintAuthority:o.mint_authority||void 0,freezeAuthority:o.freeze_authority||void 0}))},this.apiData.jupTokenList.data}catch(n){return console.error(n),[]}}get chainTimeData(){var e;return(e=this._chainTime)==null?void 0:e.value}async chainTimeOffset(){var e;return this._chainTime&&Date.now()-this._chainTime.fetched<=1e3*60*5?this._chainTime.value.offset:(await this.fetchChainTime(),((e=this._chainTime)==null?void 0:e.value.offset)||0)}async currentBlockChainTime(){var e;return this._chainTime&&Date.now()-this._chainTime.fetched<=1e3*60*5?this._chainTime.value.chainTime:(await this.fetchChainTime(),((e=this._chainTime)==null?void 0:e.value.chainTime)||Date.now())}async fetchEpochInfo(){return this._epochInfo&&Date.now()-this._epochInfo.fetched<=1e3*30?this._epochInfo.value:(this._epochInfo={fetched:Date.now(),value:await this.connection.getEpochInfo()},this._epochInfo.value)}async fetchAvailabilityStatus(e){if(e)return{};try{let t=await this.api.fetchAvailabilityStatus(),n=t.all===!1;return this.availability={all:t.all,swap:n?!1:t.swap,createConcentratedPosition:n?!1:t.createConcentratedPosition,addConcentratedPosition:n?!1:t.addConcentratedPosition,addStandardPosition:n?!1:t.addStandardPosition,removeConcentratedPosition:n?!1:t.removeConcentratedPosition,removeStandardPosition:n?!1:t.removeStandardPosition,addFarm:n?!1:t.addFarm,removeFarm:n?!1:t.removeFarm},t}catch{return{}}}};export{Dr as Raydium};
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
//# sourceMappingURL=raydium.mjs.map