var dl=Object.defineProperty,pl=Object.defineProperties;var fl=Object.getOwnPropertyDescriptors;var Di=Object.getOwnPropertySymbols;var Ea=Object.prototype.hasOwnProperty,Wa=Object.prototype.propertyIsEnumerable;var Va=(d,e,t)=>e in d?dl(d,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):d[e]=t,v=(d,e)=>{for(var t in e||(e={}))Ea.call(e,t)&&Va(d,t,e[t]);if(Di)for(var t of Di(e))Wa.call(e,t)&&Va(d,t,e[t]);return d},D=(d,e)=>pl(d,fl(e));var ve=(d,e)=>{var t={};for(var n in d)Ea.call(d,n)&&e.indexOf(n)<0&&(t[n]=d[n]);if(d!=null&&Di)for(var n of Di(d))e.indexOf(n)<0&&Wa.call(d,n)&&(t[n]=d[n]);return t};import{merge as Ip}from"lodash";import mu from"axios";import{PublicKey as Ua}from"@solana/web3.js";import{get as Da,set as yl}from"lodash";var Gr=class{constructor(e){this.logLevel=e.logLevel!==void 0?e.logLevel:0,this.name=e.name}set level(e){this.logLevel=e}get time(){return Date.now().toString()}get moduleName(){return this.name}isLogLevel(e){return e<=this.logLevel}error(...e){return this.isLogLevel(0)?(console.error(this.time,this.name,"sdk logger error",...e),this):this}logWithError(...e){let t=e.map(n=>typeof n=="object"?JSON.stringify(n):n).join(", ");throw new Error(t)}warning(...e){return this.isLogLevel(1)?(console.warn(this.time,this.name,"sdk logger warning",...e),this):this}info(...e){return this.isLogLevel(2)?(console.info(this.time,this.name,"sdk logger info",...e),this):this}debug(...e){return this.isLogLevel(3)?(console.debug(this.time,this.name,"sdk logger debug",...e),this):this}},qa={},bl={};function be(d){let e=Da(qa,d);if(!e){let t=Da(bl,d);e=new Gr({name:d,logLevel:t}),yl(qa,d,e)}return e}import{MINT_SIZE as gl,TOKEN_PROGRAM_ID as Pl,getTransferFeeConfig as Al,unpackMint as kl}from"@solana/spl-token";var Xr=be("Raydium_accountInfo_util");async function Ht(d,e,t){let{batchRequest:n,commitment:o="confirmed",chunkCount:r=100}=v({batchRequest:!1},t),i=zr(e,r),s=new Array(i.length).fill([]);if(n){let u=i.map(l=>{let m=d._buildArgs([l.map(p=>p.toBase58())],o,"base64");return{methodName:"getMultipleAccounts",args:m}}),a=zr(u,10);s=(await(await Promise.all(a.map(async l=>await d._rpcBatchRequest(l)))).flat()).map(l=>(l.error&&Xr.logWithError(`failed to get info for multiple accounts, RPC_ERROR, ${l.error.message}`),l.result.value.map(m=>{if(m){let{data:p,executable:f,lamports:y,owner:b,rentEpoch:g}=m;return p.length!==2&&p[1]!=="base64"&&Xr.logWithError("info must be base64 encoded, RPC_ERROR"),{data:Buffer.from(p[0],"base64"),executable:f,lamports:y,owner:new Ua(b),rentEpoch:g}}return null})))}else try{s=await Promise.all(i.map(u=>d.getMultipleAccountsInfo(u,o)))}catch(u){u instanceof Error&&Xr.logWithError(`failed to get info for multiple accounts, RPC_ERROR, ${u.message}`)}return s.flat()}async function Oe(d,e,t){let n=await Ht(d,e.map(o=>o.pubkey),t);return e.map((o,r)=>D(v({},o),{accountInfo:n[r]}))}async function go({connection:d,mints:e,config:t}){var r,i,s;if(e.length===0)return{};let n=await Oe(d,e.map(u=>({pubkey:ct(u)})),t),o={};for(let u of n){if(!u.accountInfo||u.accountInfo.data.length<gl){console.log("invalid mint account",u.pubkey.toBase58());continue}let a=kl(u.pubkey,u.accountInfo,(r=u.accountInfo)==null?void 0:r.owner);o[u.pubkey.toString()]=D(v({},a),{programId:((i=u.accountInfo)==null?void 0:i.owner)||Pl,feeConfig:(s=Al(a))!=null?s:void 0})}return o[Ua.default.toBase58()]=o[j.toBase58()],o}import on from"bn.js";import ry from"decimal.js";import Kl from"big.js";import Gi from"bn.js";import wl from"toformat";var Tl=wl,vo=Tl;import Ui from"big.js";import Il from"bn.js";import Bl from"decimal.js-light";import Fo from"bn.js";var Ga=9007199254740991;function te(d){let e=be("Raydium_parseBigNumberish");if(d instanceof Fo)return d;if(typeof d=="string"){if(d.match(/^-?[0-9]+$/))return new Fo(d);e.logWithError(`invalid BigNumberish string: ${d}`)}return typeof d=="number"?(d%1&&e.logWithError(`BigNumberish number underflow: ${d}`),(d>=Ga||d<=-Ga)&&e.logWithError(`BigNumberish number overflow: ${d}`),new Fo(String(d))):typeof d=="bigint"?new Fo(d.toString()):(e.error(`invalid BigNumberish value: ${d}`),new Fo(0))}var qi=be("module/fraction"),Yr=vo(Ui),_o=vo(Bl),xl={[0]:_o.ROUND_DOWN,[1]:_o.ROUND_HALF_UP,[2]:_o.ROUND_UP},Sl={[0]:Ui.roundDown,[1]:Ui.roundHalfUp,[2]:Ui.roundUp},Ie=class{constructor(e,t=new Il(1)){this.numerator=te(e),this.denominator=te(t)}get quotient(){return this.numerator.div(this.denominator)}invert(){return new Ie(this.denominator,this.numerator)}add(e){let t=e instanceof Ie?e:new Ie(te(e));return this.denominator.eq(t.denominator)?new Ie(this.numerator.add(t.numerator),this.denominator):new Ie(this.numerator.mul(t.denominator).add(t.numerator.mul(this.denominator)),this.denominator.mul(t.denominator))}sub(e){let t=e instanceof Ie?e:new Ie(te(e));return this.denominator.eq(t.denominator)?new Ie(this.numerator.sub(t.numerator),this.denominator):new Ie(this.numerator.mul(t.denominator).sub(t.numerator.mul(this.denominator)),this.denominator.mul(t.denominator))}mul(e){let t=e instanceof Ie?e:new Ie(te(e));return new Ie(this.numerator.mul(t.numerator),this.denominator.mul(t.denominator))}div(e){let t=e instanceof Ie?e:new Ie(te(e));return new Ie(this.numerator.mul(t.denominator),this.denominator.mul(t.numerator))}toSignificant(e,t={groupSeparator:""},n=1){Number.isInteger(e)||qi.logWithError(`${e} is not an integer.`),e<=0&&qi.logWithError(`${e} is not positive.`),_o.set({precision:e+1,rounding:xl[n]});let o=new _o(this.numerator.toString()).div(this.denominator.toString()).toSignificantDigits(e);return o.toFormat(o.decimalPlaces(),t)}toFixed(e,t={groupSeparator:""},n=1){return Number.isInteger(e)||qi.logWithError(`${e} is not an integer.`),e<0&&qi.logWithError(`${e} is negative.`),Yr.DP=e,Yr.RM=Sl[n]||1,new Yr(this.numerator.toString()).div(this.denominator.toString()).toFormat(e,t)}isZero(){return this.numerator.isZero()}};var Cl=be("Raydium_amount"),Xa=vo(Kl);function Rl(d,e){let t="0",n="0";if(d.includes(".")){let o=d.split(".");o.length===2?([t,n]=o,n=n.padEnd(e,"0")):Cl.logWithError(`invalid number string, num: ${d}`)}else t=d;return[t,n.slice(0,e)||n]}var xe=class extends Ie{constructor(t,n,o=!0,r){let i=new Gi(0),s=Qr.pow(new Gi(t.decimals));if(o)i=te(n);else{let u=new Gi(0),a=new Gi(0);if(typeof n=="string"||typeof n=="number"||typeof n=="bigint"){let[c,l]=Rl(n.toString(),t.decimals);u=te(c),a=te(l)}u=u.mul(s),i=u.add(a)}super(i,s);this.logger=be(r||"TokenAmount"),this.token=t}get raw(){return this.numerator}isZero(){return this.raw.isZero()}gt(t){return this.token.equals(t.token)||this.logger.logWithError("gt token not equals"),this.raw.gt(t.raw)}lt(t){return this.token.equals(t.token)||this.logger.logWithError("lt token not equals"),this.raw.lt(t.raw)}add(t){return this.token.equals(t.token)||this.logger.logWithError("add token not equals"),new xe(this.token,this.raw.add(t.raw))}subtract(t){return this.token.equals(t.token)||this.logger.logWithError("sub token not equals"),new xe(this.token,this.raw.sub(t.raw))}toSignificant(t=this.token.decimals,n,o=0){return super.toSignificant(t,n,o)}toFixed(t=this.token.decimals,n,o=0){return t>this.token.decimals&&this.logger.logWithError("decimals overflow"),super.toFixed(t,n,o)}toExact(t={groupSeparator:""}){return Xa.DP=this.token.decimals,new Xa(this.numerator.toString()).div(this.denominator.toString()).toFormat(t)}};import{PublicKey as Ll}from"@solana/web3.js";import{TOKEN_PROGRAM_ID as za}from"@solana/spl-token";var Bn={chainId:101,address:Ll.default.toBase58(),programId:za.toBase58(),decimals:9,symbol:"SOL",name:"solana",logoURI:"https://img-v1.raydium.io/icon/So11111111111111111111111111111111111111112.png",tags:[],priority:2,type:"raydium",extensions:{coingeckoId:"solana"}},lt={chainId:101,address:"So11111111111111111111111111111111111111112",programId:za.toBase58(),decimals:9,symbol:"WSOL",name:"Wrapped SOL",logoURI:"https://img-v1.raydium.io/icon/So11111111111111111111111111111111111111112.png",tags:[],priority:2,type:"raydium",extensions:{coingeckoId:"solana"}};import{PublicKey as Jr}from"@solana/web3.js";import{PublicKey as We,SystemProgram as Ya,SYSVAR_RENT_PUBKEY as Ol}from"@solana/web3.js";import{TOKEN_PROGRAM_ID as Nl}from"@solana/spl-token";function S({pubkey:d,isSigner:e=!1,isWritable:t=!0}){return{pubkey:d,isWritable:t,isSigner:e}}var Hr=[S({pubkey:Nl,isWritable:!1}),S({pubkey:Ya.programId,isWritable:!1}),S({pubkey:Ol,isWritable:!1})];function jr({publicKey:d,transformSol:e}){let t=$r(d.toString());if(t instanceof We)return e&&t.equals(et)?j:t;if(e&&t.toString()===et.toBase58())return j;if(typeof t=="string"){if(t===We.default.toBase58())return We.default;try{return new We(t)}catch{throw new Error("invalid public key")}}throw new Error("invalid public key")}function $r(d){try{return new We(d)}catch{return d}}var Xi=new We("MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr"),xn=new We("MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr"),it=new We("SysvarRent111111111111111111111111111111111"),Qa=new We("SysvarC1ock11111111111111111111111111111111"),jt=new We("metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s"),Ml=new We("Sysvar1nstructions1111111111111111111111111"),Zr=Ya.programId,ff=new We("4k3Dyjzvzp8eMZWUXbBCjEvwSkkk59S5iCNLY3QrkX6R"),yf=new We("Ea5SjE2Y6yvCeW5dYTn7PYMuW5ikXkvbGdcmSnXeaLjS"),bf=new We("SRMuApVNdxXokk5GT7XD5cUUgXMBCoAz2LHeuAoKWRt"),gf=new We("EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v"),Pf=new We("Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB"),Af=new We("mSoLzYCxHdYgdzU16g5QSh3i5K3z3KZK7ytfqcJm7So"),kf=new We("7dHbWXmci3dT8UFYWYZweBLXgycu7Y3iL6trKn1Y7ARj"),wf=new We("USDH1SM1ojwWUga67PGrgFWUHibbjqMvuMaDkRJTgkX"),Tf=new We("NRVwhjBQiUPYtfDT5zRBVJajzFQHaBUNtC7SNVvqRFa"),hf=new We("ANAxByE6G2WjFp7A4NqtWYXb3mgruyzZYg3spfxe6Lbo"),If=new We("7vfCXTUXx5WJV5JADk17DUJ4ksgau7utNKj4b963voxs"),j=new We("So11111111111111111111111111111111111111112"),et=We.default;function ct(d){return jr({publicKey:d,transformSol:!0})}var es=class{constructor({mint:e,decimals:t,symbol:n,name:o,skipMint:r=!1,isToken2022:i=!1}){if(e===et.toBase58()||e instanceof Jr&&et.equals(e)){this.decimals=lt.decimals,this.symbol=lt.symbol,this.name=lt.name,this.mint=new Jr(lt.address),this.isToken2022=!1;return}this.decimals=t,this.symbol=n||e.toString().substring(0,6),this.name=o||e.toString().substring(0,6),this.mint=r?Jr.default:jr({publicKey:e}),this.isToken2022=i}equals(e){return this===e?!0:this.mint.equals(e.mint)}},De=es;De.WSOL=new es(D(v({},lt),{mint:lt.address}));var ts=class{constructor({decimals:e,symbol:t="UNKNOWN",name:n="UNKNOWN"}){this.decimals=e,this.symbol=t,this.name=n}equals(e){return this===e}},zi=ts;zi.SOL=new ts(Bn);import vl from"bn.js";var Ha=new Ie(new vl(100)),tt=class extends Ie{toSignificant(e=5,t,n){return this.mul(Ha).toSignificant(e,t,n)}toFixed(e=2,t,n){return this.mul(Ha).toFixed(e,t,n)}};var Fl=be("Raydium_price"),At=class extends Ie{constructor(t){let{baseToken:n,quoteToken:o,numerator:r,denominator:i}=t;super(r,i);this.baseToken=n,this.quoteToken=o,this.scalar=new Ie(ns(n.decimals),ns(o.decimals))}get raw(){return new Ie(this.numerator,this.denominator)}get adjusted(){return super.mul(this.scalar)}invert(){return new At({baseToken:this.quoteToken,quoteToken:this.baseToken,denominator:this.numerator,numerator:this.denominator})}mul(t){this.quoteToken!==t.baseToken&&Fl.logWithError("mul token not equals");let n=super.mul(t);return new At({baseToken:this.baseToken,quoteToken:t.quoteToken,denominator:n.denominator,numerator:n.numerator})}toSignificant(t=this.quoteToken.decimals,n,o){return this.adjusted.toSignificant(t,n,o)}toFixed(t=this.quoteToken.decimals,n,o){return this.adjusted.toFixed(t,n,o)}};var kt=new on(0),ja=new on(1),fy=new on(2),yy=new on(3),by=new on(5),Qr=new on(10),gy=new on(100),Py=new on(1e3),Ay=new on(1e4);function ns(d){return Qr.pow(te(d))}function Yi(d,e){let t=d.divmod(e);return t.mod.isZero()?t.div:t.div.isNeg()?t.div.isubn(1):t.div.iaddn(1)}function Vo(d,e,t){return d.mul(e).add(t).sub(new on(1)).div(t)}function Qi(d,e,t){return d.mul(e).div(t)}function zr(d,e=1,t=[]){let n=[...d];if(e<=0)return t;for(;n.length;)t.push(n.splice(0,e));return t}var xt=class{constructor(e){this._owner=e}get publicKey(){return xt.isKeyPair(this._owner)?this._owner.publicKey:this._owner}get signer(){return xt.isKeyPair(this._owner)?this._owner:void 0}get isKeyPair(){return xt.isKeyPair(this._owner)}get isPublicKey(){return xt.isPublicKey(this._owner)}static isKeyPair(e){return e.secretKey!==void 0}static isPublicKey(e){return!xt.isKeyPair(e)}};import{PublicKey as ql}from"@solana/web3.js";import{TOKEN_PROGRAM_ID as Ul}from"@solana/spl-token";import{ComputeBudgetProgram as $a,Keypair as Ja,PublicKey as _l,Transaction as eu,TransactionMessage as Vl,VersionedTransaction as tu}from"@solana/web3.js";var U={CreateAccount:"CreateAccount",InitAccount:"InitAccount",CreateATA:"CreateATA",CloseAccount:"CloseAccount",TransferAmount:"TransferAmount",InitMint:"InitMint",MintTo:"MintTo",InitMarket:"InitMarket",Util1216OwnerClaim:"Util1216OwnerClaim",SetComputeUnitPrice:"SetComputeUnitPrice",SetComputeUnitLimit:"SetComputeUnitLimit",ClmmCreatePool:"ClmmCreatePool",ClmmOpenPosition:"ClmmOpenPosition",ClmmIncreasePosition:"ClmmIncreasePosition",ClmmDecreasePosition:"ClmmDecreasePosition",ClmmClosePosition:"ClmmClosePosition",ClmmSwapBaseIn:"ClmmSwapBaseIn",ClmmSwapBaseOut:"ClmmSwapBaseOut",ClmmInitReward:"ClmmInitReward",ClmmSetReward:"ClmmSetReward",ClmmCollectReward:"ClmmCollectReward",ClmmLockPosition:"ClmmLockPosition",ClmmHarvestLockPosition:"ClmmHarvestLockPosition",AmmV4Swap:"AmmV4Swap",AmmV4AddLiquidity:"AmmV4AddLiquidity",AmmV4RemoveLiquidity:"AmmV4RemoveLiquidity",AmmV4SimulatePoolInfo:"AmmV4SimulatePoolInfo",AmmV4SwapBaseIn:"AmmV4SwapBaseIn",AmmV4SwapBaseOut:"AmmV4SwapBaseOut",AmmV4CreatePool:"AmmV4CreatePool",AmmV4InitPool:"AmmV4InitPool",AmmV5AddLiquidity:"AmmV5AddLiquidity",AmmV5RemoveLiquidity:"AmmV5RemoveLiquidity",AmmV5SimulatePoolInfo:"AmmV5SimulatePoolInfo",AmmV5SwapBaseIn:"AmmV5SwapBaseIn",AmmV5SwapBaseOut:"AmmV5SwapBaseOut",RouteSwap:"RouteSwap",RouteSwap1:"RouteSwap1",RouteSwap2:"RouteSwap2",FarmV3Deposit:"FarmV3Deposit",FarmV3Withdraw:"FarmV3Withdraw",FarmV3CreateLedger:"FarmV3CreateLedger",FarmV4Withdraw:"FarmV4Withdraw",FarmV5Deposit:"FarmV5Deposit",FarmV5Withdraw:"FarmV5Withdraw",FarmV5CreateLedger:"FarmV5CreateLedger",FarmV6Deposit:"FarmV6Deposit",FarmV6Withdraw:"FarmV6Withdraw",FarmV6Create:"FarmV6Create",FarmV6Restart:"FarmV6Restart",FarmV6CreatorAddReward:"FarmV6CreatorAddReward",FarmV6CreatorWithdraw:"FarmV6CreatorWithdraw",CpmmCreatePool:"CpmmCreatePool",CpmmAddLiquidity:"CpmmAddLiquidity",CpmmWithdrawLiquidity:"CpmmWithdrawLiquidity",CpmmSwapBaseIn:"CpmmSwapBaseIn",CpmmSwapBaseOut:"CpmmSwapBaseOut",CpmmLockLp:"CpmmLockLp",CpmmCollectLockFee:"CpmmCollectLockFee",TransferTip:"TransferTip"};import{TOKEN_PROGRAM_ID as El}from"@solana/spl-token";var Za=be("Raydium_txUtil"),nu=1644;function Eo(d){let e=[],t=[];return d.microLamports&&(e.push($a.setComputeUnitPrice({microLamports:d.microLamports})),t.push(U.SetComputeUnitPrice)),d.units&&(e.push($a.setComputeUnitLimit({units:d.units})),t.push(U.SetComputeUnitLimit)),{instructions:e,instructionTypes:t}}async function Dn(d,e){var n,o;let t=e!=null?e:"confirmed";return(o=await((n=d.getLatestBlockhash)==null?void 0:n.call(d,{commitment:t})))==null?void 0:o.blockhash}async function Wo(d,e){return d.getSignatureStatuses([e]),new Promise((t,n)=>{let o=setTimeout(n,6e4);d.onSignature(e,r=>{if(clearTimeout(o),!r.err){t("");return}n(Object.assign(r.err,{txId:e}))},"confirmed")})}function os(d,e){d.length<1&&Za.logWithError(`no instructions provided: ${d.toString()}`),e.length<1&&Za.logWithError(`no signers provided:, ${e.toString()}`);let t=new eu;t.recentBlockhash="11111111111111111111111111111111",t.feePayer=e[0],t.add(...d);try{return Buffer.from(t.serialize({verifySignatures:!1})).toString("base64").length<nu}catch{return!1}}function ce(d,e){let[t,n]=_l.findProgramAddressSync(d,e);return{publicKey:t,nonce:n}}function Do({instructions:d,payer:e,signers:t}){return os(d,[e,...t])}function ln({instructions:d,payer:e,lookupTableAddressAccount:t,recentBlockhash:n=Ja.generate().publicKey.toString()}){let r=new Vl({payerKey:e,recentBlockhash:n,instructions:d}).compileToV0Message(Object.values(t!=null?t:{}));try{return Buffer.from(new tu(r).serialize()).toString("base64").length<nu}catch{return!1}}var Wl=d=>Buffer.isBuffer(d)?d:d instanceof Uint8Array?Buffer.from(d.buffer,d.byteOffset,d.byteLength):Buffer.from(d),Dl=d=>{let e=d.serialize({requireAllSignatures:!1,verifySignatures:!1});d instanceof tu&&(e=Wl(e));try{return e instanceof Buffer?e.toString("base64"):Buffer.from(e).toString("base64")}catch{return e.toString("base64")}};function Sn(d){let e=[];return d.forEach(t=>{t instanceof eu&&(t.recentBlockhash||(t.recentBlockhash=El.toBase58()),t.feePayer||(t.feePayer=Ja.generate().publicKey)),e.push(Dl(t))}),console.log("simulate tx string:",e),e}function Z(d,e,t){return ce([d.toBuffer(),(t!=null?t:Ul).toBuffer(),e.toBuffer()],new ql("ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL"))}import{PublicKey as oe}from"@solana/web3.js";var ou=new oe("EhhTKczWMGQt46ynNeRX1WfeagwwJd7ufHvCDjRxjo5Q"),iu=new oe("CBuCnLe26faBpcBP2fktp4rp8abpcAnTWft6ZrP5Q4T"),ru=new oe("9KEPoZmtHUrBbhWN1v1KWLMkkvwY6WLtAVUCPRtRjP4z"),qo=new oe("FarmqiPv5eAj3j1GMdMCMUGXqPUvmquZtMy86QH6rzhG"),Wy=new oe("CLaimxFqjHzgTJtAGHU47NPhg6qrc5sCnpC4tBLyABQS"),su=new oe("srmqPvymJeFKQ4zGQed1GFppgkRHL9kaELCbyksJtPX"),is=new oe("9xQeWvG816bUx9EPjHmaT23yvVM2ZWbrrpZb9PusVFin"),Hi=new oe("675kPX9MHTjS2zt1qfr1NYHuzeLXfQM9H24wFSUt1Mp8"),Dy=new oe("5quBtoiQqxF9Jv6KYKctB59NT3gtJD2Y65kdnB1Uev3h"),au=new oe("CDSr3ssLcRB6XYPJwAfFt18MZvEZp4LjHcvzBVZ45duo"),qn=new oe("CAMMCzo5YL8w4VFF8KVHrK22GGUsp5VTaW7grrKgrWqK"),Uo=new oe("LockrWmn6K5twhz3y9w1dQERbmgSaRkfnTeTKbpofwE"),ji=new oe("kN1kEznaF5Xbd8LYuqtEFcxzWSBk5Fv6ygX6SqEGJVy"),Un=new oe("CDSr3ssLcRB6XYPJwAfFt18MZvEZp4LjHcvzBVZ45duo"),qy=new oe("routeUGWgWzqBWFcrCfv8tritsqukccJPu3q5GPP3xS"),uu=new oe("7YttLkHDoNj9wyDur5pM1ejNaAvT9X4eqaYcHQqtj2G5"),Gl=new oe("6FJon3QE27qgPVggARueB22hLvoh22VzJpXv4rBEoSLF"),Xl=new oe("CC12se5To1CdEuw7fDS27B7Geo5jJyL7t5UK2B44NgiH"),zl=new oe("9HzJyW1qZsEiSfMUf6L2jo3CcTKAyBmSyKdwQeYisHrC"),Yl=new oe("DropEU8AvevN3UrXWXTMuz3rqnMczQVNjq3kcSdW2SQi"),Gn=new oe("CPMMoo8L3F4NbTegBCKVNunggL7H1ZpdTHKxQB5qKP1C"),cu=new oe("GpMZbSM2GgvTKHJirzeGfMFoaZ8UR2X7F4v8vHTvxFbL"),Uy=new oe("DNXgeM9EiiaAbaWvwjHj9fQQLAX5ZsfHyvmYUNRAdNC8"),$i=new oe("LockrWmn6K5twhz3y9w1dQERbmgSaRkfnTeTKbpofwE"),Zi=new oe("3f7GcQFG397GAaEnv51zR6tsTVihYRydnydDD1cXekxH"),$e=new oe("LanMV9sAd7wArD4vJFi2qDdfnVhFxYSUg6eADduJ3uj"),Gy=new oe("WLHv2UAZm6z4KyaaELi5pjdbJh6RESMva1Rnn8pJVVh"),Xy=new oe("DRay6fNdQ5J82H7xV6uq2aV3mNrUZ1J4PgSKsWgptcm6"),zy=new oe("5xqNaZXX5eUi4p5HU4oz9i5QnwRNT2y6oN7yyn4qENeq"),Yy=new oe("4Bu96XjU84XjPDSpveTVf6LYGCkfW5FK7SNkREWcEfV4"),Qy=new oe("6s1xP3hpbAfFoNtUNF8mfHsjr2Bd97JxFJRWLbL6aHuX"),Go={IDO_PROGRAM_ID_V1:Gl,IDO_PROGRAM_ID_V2:Xl,IDO_PROGRAM_ID_V3:zl,IDO_PROGRAM_ID_V4:Yl};var mn={OPEN_BOOK_PROGRAM:new oe("EoTcMgcDRTJVZDMZWBoU6rhYHZfkNTVEAfz3uUJRcYGj"),SERUM_PROGRAM_ID_V3:new oe("Ray1111111111111111111111111111111111111111"),AMM_V4:new oe("DRaya7Kj3aMWQSy19kSjvmuwq9docCHofyP9kanQGaav"),AMM_STABLE:new oe("DRayDdXc1NZQ9C3hRWmoSf8zK4iapgMnjdNZWrfwsP8m"),CLMM_PROGRAM_ID:new oe("DRayAUgENGQBKVaX8owNhgzkEDyoHTGVEGHVJT1E9pfH"),CLMM_LOCK_PROGRAM_ID:new oe("DRay25Usp3YJAi7beckgpGUC7mGJ2cR1AVPxhYfwVCUX"),CLMM_LOCK_AUTH_ID:new oe("6Aoh8h2Lw2m5UGxYR8AdAL87jTWYeKoxM52mJRzfYwN"),CREATE_CPMM_POOL_PROGRAM:new oe("DRaycpLY18LhpbydsBWbVJtxpNv9oXPgjRSfpF2bWpYb"),CREATE_CPMM_POOL_AUTH:new oe("CXniRufdq5xL8t8jZAPxsPZDpuudwuJSPWnbcD5Y5Nxq"),CREATE_CPMM_POOL_FEE_ACC:new oe("3oE58BKVt8KuYkGxx8zBojugnymWmBiyafWgMrnb6eYy"),LOCK_CPMM_PROGRAM:new oe("DRay25Usp3YJAi7beckgpGUC7mGJ2cR1AVPxhYfwVCUX"),LOCK_CPMM_AUTH:new oe("7qWVV8UY2bRJfDLP4s37YzBPKUkVB46DStYJBpYbQzu3"),UTIL1216:oe.default,Router:new oe("DRaybByLpbUL57LJARs3j8BitTxVfzBg351EaMr5UTCd"),FARM_PROGRAM_ID_V3:new oe("DRayWyrLmEW5KEeqs8kdTMMaBabapqagaBC7KWpGtJeZ"),FARM_PROGRAM_ID_V4:new oe("Ray1111111111111111111111111111111111111111"),FARM_PROGRAM_ID_V5:new oe("DRayiCGSZgku1GTK6rXD6mVDdingXy6APAH1R6R5L2LC"),FARM_PROGRAM_ID_V6:new oe("DRayzbYakXs45ELHkzH6vC3fuhQqTAnv5A68gdFuvZyZ"),LAUNCHPAD_PROGRAM:new oe("DRay6fNdQ5J82H7xV6uq2aV3mNrUZ1J4PgSKsWgptcm6"),LAUNCHPAD_AUTH:new oe("5xqNaZXX5eUi4p5HU4oz9i5QnwRNT2y6oN7yyn4qENeq"),LAUNCHPAD_PLATFORM:new oe("2Jx4KTDrVSdWNazuGpcA8n3ZLTRGGBDxAWhuKe2Xcj2a"),LAUNCHPAD_CONFIG:new oe("7ZR4zD7PYfY2XxoG1Gxcy2EgEeGYrpxrwzPuwdUBssEt"),FEE_DESTINATION_ID:new oe("9y8ENuuZ3b19quffx9hQvRVygG5ky6snHfRvGpuSfeJy"),MODEL_DATA_PUBKEY:new oe("Ray1111111111111111111111111111111111111111")};import Fe from"bn.js";var rn=1e4;function Se(d,e,t,n){if(e===void 0)return{amount:d,fee:void 0,expirationTime:void 0};let o=D(v({},e),{olderTransferFee:{epoch:BigInt(e.olderTransferFee.epoch),maximumFee:BigInt(e.olderTransferFee.maximumFee),transferFeeBasisPoints:e.olderTransferFee.transferFeeBasisPoints},newerTransferFee:{epoch:BigInt(e.newerTransferFee.epoch),maximumFee:BigInt(e.newerTransferFee.maximumFee),transferFeeBasisPoints:e.newerTransferFee.transferFeeBasisPoints}}),r=t.epoch<o.newerTransferFee.epoch?o.olderTransferFee:o.newerTransferFee,i=new Fe(r.maximumFee.toString()),s=t.epoch<o.newerTransferFee.epoch?(Number(o.newerTransferFee.epoch)*t.slotsInEpoch-t.absoluteSlot)*400/1e3:void 0;if(n)if(r.transferFeeBasisPoints===rn){let u=new Fe(r.maximumFee.toString());return{amount:d.add(u),fee:u,expirationTime:s}}else{let u=Kn(d.mul(new Fe(rn)),new Fe(rn-r.transferFeeBasisPoints)),a=new Fe(r.maximumFee.toString()),c=u.sub(d).gt(a)?d.add(a):u,l=Kn(c.mul(new Fe(r.transferFeeBasisPoints)),new Fe(rn)),m=l.gt(i)?i:l;return{amount:c,fee:m,expirationTime:s}}else{let u=Kn(d.mul(new Fe(r.transferFeeBasisPoints)),new Fe(rn)),a=u.gt(i)?i:u;return{amount:d,fee:a,expirationTime:s}}}function $t(d,e){return d===void 0?e:e===void 0?d:Math.min(d,e)}function Kn(d,e){let{div:t,mod:n}=d.divmod(e);return n.gt(new Fe(0))?t.add(new Fe(1)):t}function Xn(d,e){if(d.isZero())return new Fe(0);let t=d.div(e);return t.isZero()?new Fe(1):d.mod(e).gt(new Fe(0))?t.add(new Fe(1)):t}function rs(d,e,t){if(e===void 0)return{amount:d,fee:void 0,expirationTime:void 0};let n=Math.floor(t/432e3),o=n<e.newerTransferFee.epoch?e.olderTransferFee:e.newerTransferFee,r=new Fe(o.maximumFee.toString()),i=n<e.newerTransferFee.epoch?(Number(e.newerTransferFee.epoch)*432e3-t)*400/1e3:void 0,s=Kn(d.mul(new Fe(o.transferFeeBasisPoints)),new Fe(rn)),u=s.gt(r)?r:s;return{amount:d,fee:u,expirationTime:i}}function ss(d,e,t){if(e===void 0)return{amount:d,fee:void 0,expirationTime:void 0};let n=Math.floor(t/432e3),o=n<e.newerTransferFee.epoch?e.olderTransferFee:e.newerTransferFee,r=new Fe(o.maximumFee.toString()),i=n<e.newerTransferFee.epoch?(Number(e.newerTransferFee.epoch)*432e3-t)*400/1e3:void 0;if(o.transferFeeBasisPoints===rn){let s=new Fe(o.maximumFee.toString());return{amount:d.add(s),fee:s,expirationTime:i}}else{let s=Kn(d.mul(new Fe(rn)),new Fe(rn-o.transferFeeBasisPoints)),u=new Fe(o.maximumFee.toString()),a=s.sub(d).gt(u)?d.add(u):s,c=Kn(a.mul(new Fe(o.transferFeeBasisPoints)),new Fe(rn)),l=c.gt(r)?r:c;return{amount:a,fee:l,expirationTime:i}}}import{PublicKey as as,AddressLookupTableAccount as Ao}from"@solana/web3.js";async function Ji({connection:d,address:e,cluster:t="mainnet"}){let n=await Ht(d,[...new Set(e.map(r=>r.toString()))].map(r=>new as(r))),o={};for(let r=0;r<e.length;r++){let i=n[r],s=e[r];if(!i)continue;let u=new Ao({key:s,state:Ao.deserialize(i.data)});o[s.toString()]=u,t==="devnet"?Po[s.toString()]=u:Cn[s.toString()]=u}return o}var Cn={},us=async d=>{let e="AcL1Vo8oy1ULiavEcjSUcwfBSForXMudcZvDZy5nzJkU";if(Cn[e])return Cn;let t=new as(e),n=await d.getAccountInfo(t);return n&&(Cn[e]=new Ao({key:t,state:Ao.deserialize(n.data)})),Cn},Po={},er=async d=>{let e="EFhMuDw1PKEuckuFRW9PavNfTH4LKP5uKHgyXDmWpFCq";if(Po[e])return Po;let t=new as(e),n=await d.getAccountInfo(t);return n&&(Po[e]=new Ao({key:t,state:Ao.deserialize(n.data)})),Po};import{PublicKey as zn,sendAndConfirmTransaction as cs,SystemProgram as Ql,Transaction as Xo,TransactionMessage as dn,VersionedTransaction as pn}from"@solana/web3.js";import Hl from"axios";var zo=2e3,Yo=class{constructor(e){this.instructions=[];this.endInstructions=[];this.lookupTableAddress=[];this.signers=[];this.instructionTypes=[];this.endInstructionTypes=[];this.connection=e.connection,this.feePayer=e.feePayer,this.signAllTransactions=e.signAllTransactions,this.owner=e.owner,this.cluster=e.cluster,this.blockhashCommitment=e.blockhashCommitment,this.loopMultiTxStatus=!!e.loopMultiTxStatus}get AllTxData(){return{instructions:this.instructions,endInstructions:this.endInstructions,signers:this.signers,instructionTypes:this.instructionTypes,endInstructionTypes:this.endInstructionTypes,lookupTableAddress:this.lookupTableAddress}}get allInstructions(){return[...this.instructions,...this.endInstructions]}async getComputeBudgetConfig(){var n;let e=(await Hl.get(`https://solanacompass.com/api/fees?cacheFreshTime=${3e5}`)).data,{avg:t}=(n=e==null?void 0:e[15])!=null?n:{};if(!!t)return{units:6e5,microLamports:Math.min(Math.ceil(t*1e6/6e5),25e3)}}addCustomComputeBudget(e){if(e){let{instructions:t,instructionTypes:n}=Eo(e);return this.instructions.unshift(...t),this.instructionTypes.unshift(...n),!0}return!1}addTipInstruction(e){var t;return e?(this.endInstructions.push(Ql.transfer({fromPubkey:(t=e.feePayer)!=null?t:this.feePayer,toPubkey:new zn(e.address),lamports:BigInt(e.amount.toString())})),this.endInstructionTypes.push(U.TransferTip),!0):!1}async calComputeBudget({config:e,defaultIns:t}){try{let n=e||await this.getComputeBudgetConfig();if(this.addCustomComputeBudget(n))return;t&&this.instructions.unshift(...t)}catch{t&&this.instructions.unshift(...t)}}addInstruction({instructions:e=[],endInstructions:t=[],signers:n=[],instructionTypes:o=[],endInstructionTypes:r=[],lookupTableAddress:i=[]}){return this.instructions.push(...e),this.endInstructions.push(...t),this.signers.push(...n),this.instructionTypes.push(...o),this.endInstructionTypes.push(...r),this.lookupTableAddress.push(...i.filter(s=>s!==zn.default.toString())),this}async versionBuild({txVersion:e,extInfo:t}){return e===0?await this.buildV0(v({},t||{})):this.build(t)}build(e){var n;let t=new Xo;return this.allInstructions.length&&t.add(...this.allInstructions),t.feePayer=this.feePayer,((n=this.owner)==null?void 0:n.signer)&&!this.signers.some(o=>o.publicKey.equals(this.owner.publicKey))&&this.signers.push(this.owner.signer),{builder:this,transaction:t,signers:this.signers,instructionTypes:[...this.instructionTypes,...this.endInstructionTypes],execute:async o=>{var c;let{recentBlockHash:r,skipPreflight:i=!0,sendAndConfirm:s,notSendToRpc:u}=o||{},a=r!=null?r:await Dn(this.connection,this.blockhashCommitment);if(t.recentBlockhash=a,this.signers.length&&t.sign(...this.signers),Sn([t]),(c=this.owner)!=null&&c.isKeyPair)return{txId:s?await cs(this.connection,t,this.signers.find(m=>m.publicKey.equals(this.owner.publicKey))?this.signers:[...this.signers,this.owner.signer],{skipPreflight:i}):await this.connection.sendRawTransaction(t.serialize(),{skipPreflight:i}),signedTx:t};if(this.signAllTransactions){let l=await this.signAllTransactions([t]);if(this.signers.length)for(let m of l)try{m.sign(...this.signers)}catch{}return{txId:u?"":await this.connection.sendRawTransaction(l[0].serialize(),{skipPreflight:i}),signedTx:l[0]}}throw new Error("please provide owner in keypair format or signAllTransactions function")},extInfo:e||{}}}buildMultiTx(e){var a;let{extraPreBuildData:t=[],extInfo:n}=e,{transaction:o}=this.build(n),r=t.filter(c=>c.transaction.instructions.length>0),i=[o,...r.map(c=>c.transaction)],s=[this.signers,...r.map(c=>c.signers)],u=[...this.instructionTypes,...r.map(c=>c.instructionTypes).flat()];return(a=this.owner)!=null&&a.signer&&s.forEach(c=>{c.some(l=>l.publicKey.equals(this.owner.publicKey))||this.signers.push(this.owner.signer)}),{builder:this,transactions:i,signers:s,instructionTypes:u,execute:async c=>{var g;let{sequentially:l,onTxUpdate:m,skipTxCount:p=0,recentBlockHash:f,skipPreflight:y=!0}=c||{},b=f!=null?f:await Dn(this.connection,this.blockhashCommitment);if((g=this.owner)!=null&&g.isKeyPair){if(l){let P=[],T=0;for(let h of i){if(++T,T<=p)continue;let w=await cs(this.connection,h,this.signers.find(k=>k.publicKey.equals(this.owner.publicKey))?this.signers:[...this.signers,this.owner.signer],{skipPreflight:y});P.push(w)}return{txIds:P,signedTxs:i}}return{txIds:await await Promise.all(i.map(async P=>(P.recentBlockhash=b,await this.connection.sendRawTransaction(P.serialize(),{skipPreflight:y})))),signedTxs:i}}if(this.signAllTransactions){let P=i.map((h,w)=>(h.recentBlockhash=b,s[w].length&&h.sign(...s[w]),h));Sn(P);let T=await this.signAllTransactions(P);if(l){let h=0,w=[],k=async()=>{if(!T[h])return;let x=await this.connection.sendRawTransaction(T[h].serialize(),{skipPreflight:y});w.push({txId:x,status:"sent",signedTx:T[h]}),m==null||m([...w]),h++;let B=!1,K=null,I=null,R=C=>{K!==null&&clearInterval(K),I!==null&&this.connection.removeSignatureListener(I);let N=w.findIndex(L=>L.txId===x);if(N>-1){if(w[N].status==="error"||w[N].status==="success")return;w[N].status=C.err?"error":"success"}m==null||m([...w]),C.err||k()};this.loopMultiTxStatus&&(K=setInterval(async()=>{var C;if(B){clearInterval(K);return}try{let N=await this.connection.getTransaction(x,{commitment:"confirmed",maxSupportedTransactionVersion:0});N&&(B=!0,clearInterval(K),R({err:((C=N.meta)==null?void 0:C.err)||null}),console.log("tx status from getTransaction:",x))}catch(N){B=!0,clearInterval(K),console.error("getTransaction timeout:",N,x)}},zo)),I=this.connection.onSignature(x,C=>{if(B){this.connection.removeSignatureListener(I);return}B=!0,R(C)},"confirmed"),this.connection.getSignatureStatus(x)};return await k(),{txIds:w.map(x=>x.txId),signedTxs:T}}else{let h=[];for(let w=0;w<T.length;w+=1){let k=await this.connection.sendRawTransaction(T[w].serialize(),{skipPreflight:y});h.push(k)}return{txIds:h,signedTxs:T}}}throw new Error("please provide owner in keypair format or signAllTransactions function")},extInfo:n||{}}}async versionMultiBuild({extraPreBuildData:e,txVersion:t,extInfo:n}){return t===0?await this.buildV0MultiTx({extraPreBuildData:e,buildProps:n||{}}):this.buildMultiTx({extraPreBuildData:e,extInfo:n})}async buildV0(e){var y;let f=e||{},{lookupTableCache:t={},lookupTableAddress:n=[],forerunCreate:o,recentBlockhash:r}=f,i=ve(f,["lookupTableCache","lookupTableAddress","forerunCreate","recentBlockhash"]),s=v(v({},this.cluster==="devnet"?await er(this.connection):await us(this.connection)),t),u=Array.from(new Set([...n,...this.lookupTableAddress])),a=[];for(let b of u)s[b]===void 0&&a.push(new zn(b));let c=await Ji({connection:this.connection,address:a});for(let[b,g]of Object.entries(c))s[b]=g;let l=o?zn.default.toBase58():r!=null?r:await Dn(this.connection,this.blockhashCommitment),m=new dn({payerKey:this.feePayer,recentBlockhash:l,instructions:[...this.allInstructions]}).compileToV0Message(Object.values(s));((y=this.owner)==null?void 0:y.signer)&&!this.signers.some(b=>b.publicKey.equals(this.owner.publicKey))&&this.signers.push(this.owner.signer);let p=new pn(m);return p.sign(this.signers),{builder:this,transaction:p,signers:this.signers,instructionTypes:[...this.instructionTypes,...this.endInstructionTypes],execute:async b=>{var h;let{skipPreflight:g=!0,sendAndConfirm:P,notSendToRpc:T}=b||{};if(Sn([p]),(h=this.owner)!=null&&h.isKeyPair){let w=await this.connection.sendTransaction(p,{skipPreflight:g});return P&&await Wo(this.connection,w),{txId:w,signedTx:p}}if(this.signAllTransactions){let w=await this.signAllTransactions([p]);if(this.signers.length)for(let k of w)try{k.sign(this.signers)}catch{}return{txId:T?"":await this.connection.sendTransaction(w[0],{skipPreflight:g}),signedTx:w[0]}}throw new Error("please provide owner in keypair format or signAllTransactions function")},extInfo:i||{}}}async buildV0MultiTx(e){var a;let{extraPreBuildData:t=[],buildProps:n}=e,{transaction:o}=await this.buildV0(n),r=t.filter(c=>c.builder.instructions.length>0),i=[o,...r.map(c=>c.transaction)],s=[this.signers,...r.map(c=>c.signers)],u=[...this.instructionTypes,...r.map(c=>c.instructionTypes).flat()];return(a=this.owner)!=null&&a.signer&&s.forEach(c=>{c.some(l=>l.publicKey.equals(this.owner.publicKey))||this.signers.push(this.owner.signer)}),i.forEach(async(c,l)=>{c.sign(s[l])}),{builder:this,transactions:i,signers:s,instructionTypes:u,buildProps:n,execute:async c=>{var y;let{sequentially:l,onTxUpdate:m,recentBlockHash:p,skipPreflight:f=!0}=c||{};if(p&&i.forEach(b=>b.message.recentBlockhash=p),Sn(i),(y=this.owner)!=null&&y.isKeyPair){if(l){let b=[];for(let g of i){let P=await this.connection.sendTransaction(g,{skipPreflight:f});await Wo(this.connection,P),b.push(P)}return{txIds:b,signedTxs:i}}return{txIds:await Promise.all(i.map(async b=>await this.connection.sendTransaction(b,{skipPreflight:f}))),signedTxs:i}}if(this.signAllTransactions){let b=await this.signAllTransactions(i);if(l){let g=0,P=[],T=async()=>{if(!b[g])return;let h=await this.connection.sendTransaction(b[g],{skipPreflight:f});P.push({txId:h,status:"sent",signedTx:b[g]}),m==null||m([...P]),g++;let w=!1,k=null,x=null,B=K=>{k!==null&&clearInterval(k),x!==null&&this.connection.removeSignatureListener(x);let I=P.findIndex(R=>R.txId===h);if(I>-1){if(P[I].status==="error"||P[I].status==="success")return;P[I].status=K.err?"error":"success"}m==null||m([...P]),K.err||T()};this.loopMultiTxStatus&&(k=setInterval(async()=>{var K;if(w){clearInterval(k);return}try{let I=await this.connection.getTransaction(h,{commitment:"confirmed",maxSupportedTransactionVersion:0});I&&(w=!0,clearInterval(k),B({err:((K=I.meta)==null?void 0:K.err)||null}),console.log("tx status from getTransaction:",h))}catch(I){w=!0,clearInterval(k),console.error("getTransaction timeout:",I,h)}},zo)),x=this.connection.onSignature(h,K=>{if(w){this.connection.removeSignatureListener(x);return}w=!0,B(K)},"confirmed"),this.connection.getSignatureStatus(h)};return T(),{txIds:[],signedTxs:b}}else{let g=[];for(let P=0;P<b.length;P+=1){let T=await this.connection.sendTransaction(b[P],{skipPreflight:f});g.push(T)}return{txIds:g,signedTxs:b}}}throw new Error("please provide owner in keypair format or signAllTransactions function")},extInfo:n||{}}}async sizeCheckBuild(e){var m;let l=e||{},{splitIns:t=[],computeBudgetConfig:n}=l,o=ve(l,["splitIns","computeBudgetConfig"]),r=n?Eo(n):{instructions:[],instructionTypes:[]},i=this.signers.reduce((p,f)=>D(v({},p),{[f.publicKey.toBase58()]:f}),{}),s=[],u=[],a=[],c=0;if(this.allInstructions.forEach(p=>{let f=[...a,p],y=n?[...r.instructions,...f]:f,g=[...new Set(f.map(P=>P.keys.filter(T=>T.isSigner).map(T=>T.pubkey.toString())).flat()).values()].map(P=>new zn(P));if(p!==t[c]&&a.length<12&&(Do({instructions:y,payer:this.feePayer,signers:g})||Do({instructions:f,payer:this.feePayer,signers:g})))a.push(p);else{if(a.length===0)throw Error("item ins too big");c+=p===t[c]?1:0,Do({instructions:n?[...r.instructions,...a]:[...a],payer:this.feePayer,signers:g})?s.push(new Xo().add(...r.instructions,...a)):s.push(new Xo().add(...a)),u.push(Array.from(new Set(a.map(P=>P.keys.filter(T=>T.isSigner).map(T=>T.pubkey.toString())).flat())).map(P=>i[P]).filter(P=>P!==void 0)),a=[p]}}),a.length>0){let f=[...new Set(a.map(y=>y.keys.filter(b=>b.isSigner).map(b=>b.pubkey.toString())).flat()).values()].map(y=>i[y]).filter(y=>y!==void 0);Do({instructions:n?[...r.instructions,...a]:[...a],payer:this.feePayer,signers:f.map(y=>y.publicKey)})?s.push(new Xo().add(...r.instructions,...a)):s.push(new Xo().add(...a)),u.push(f)}return s.forEach(p=>p.feePayer=this.feePayer),(m=this.owner)!=null&&m.signer&&u.forEach(p=>{p.some(f=>f.publicKey.equals(this.owner.publicKey))||p.push(this.owner.signer)}),{builder:this,transactions:s,signers:u,instructionTypes:this.instructionTypes,execute:async p=>{var h;let{sequentially:f,onTxUpdate:y,skipTxCount:b=0,recentBlockHash:g,skipPreflight:P=!0}=p||{},T=g!=null?g:await Dn(this.connection,this.blockhashCommitment);if(s.forEach(async(w,k)=>{w.recentBlockhash=T,u[k].length&&w.sign(...u[k])}),Sn(s),(h=this.owner)!=null&&h.isKeyPair){if(f){let w=0,k=[];for(let x of s){if(++w,w<=b){k.push("tx skipped");continue}let B=await cs(this.connection,x,this.signers.find(K=>K.publicKey.equals(this.owner.publicKey))?this.signers:[...this.signers,this.owner.signer],{skipPreflight:P});k.push(B)}return{txIds:k,signedTxs:s}}return{txIds:await Promise.all(s.map(async w=>await this.connection.sendRawTransaction(w.serialize(),{skipPreflight:P}))),signedTxs:s}}if(this.signAllTransactions){let w=await this.signAllTransactions(s.slice(b,s.length)),k=[...s.slice(0,b),...w];if(f){let x=0,B=[],K=async()=>{if(!k[x])return;x<b&&(B.push({txId:"",status:"success",signedTx:k[x]}),y==null||y([...B]),x++,K());let I=await this.connection.sendRawTransaction(k[x].serialize(),{skipPreflight:P});B.push({txId:I,status:"sent",signedTx:k[x]}),y==null||y([...B]),x++;let R=!1,C=null,N=null,L=O=>{C!==null&&clearInterval(C),N!==null&&this.connection.removeSignatureListener(N);let _=B.findIndex(G=>G.txId===I);if(_>-1){if(B[_].status==="error"||B[_].status==="success")return;B[_].status=O.err?"error":"success"}y==null||y([...B]),O.err||K()};this.loopMultiTxStatus&&(C=setInterval(async()=>{var O;if(R){clearInterval(C);return}try{let _=await this.connection.getTransaction(I,{commitment:"confirmed",maxSupportedTransactionVersion:0});_&&(R=!0,clearInterval(C),L({err:((O=_.meta)==null?void 0:O.err)||null}),console.log("tx status from getTransaction:",I))}catch(_){R=!0,clearInterval(C),console.error("getTransaction timeout:",_,I)}},zo)),N=this.connection.onSignature(I,O=>{if(R){this.connection.removeSignatureListener(N);return}R=!0,L(O)},"confirmed"),this.connection.getSignatureStatus(I)};return await K(),{txIds:B.map(I=>I.txId),signedTxs:k}}else{let x=[];for(let B=0;B<k.length;B+=1){let K=await this.connection.sendRawTransaction(k[B].serialize(),{skipPreflight:P});x.push(K)}return{txIds:x,signedTxs:k}}}throw new Error("please provide owner in keypair format or signAllTransactions function")},extInfo:o||{}}}async sizeCheckBuildV0(e){var T;let P=e||{},{computeBudgetConfig:t,splitIns:n=[],lookupTableCache:o={},lookupTableAddress:r=[]}=P,i=ve(P,["computeBudgetConfig","splitIns","lookupTableCache","lookupTableAddress"]),s=v(v({},this.cluster==="devnet"?await er(this.connection):Cn),o),u=Array.from(new Set([...this.lookupTableAddress,...r])),a=[];for(let h of u)s[h]===void 0&&a.push(new zn(h));let c=await Ji({connection:this.connection,address:a});for(let[h,w]of Object.entries(c))s[h]=w;let l=t?Eo(t):{instructions:[],instructionTypes:[]},m=await Dn(this.connection,this.blockhashCommitment),p=this.signers.reduce((h,w)=>D(v({},h),{[w.publicKey.toBase58()]:w}),{}),f=[],y=[],b=[],g=0;if(this.allInstructions.forEach(h=>{let w=[...b,h],k=t?[...l.instructions,...w]:w;if(h!==n[g]&&b.length<12&&(ln({instructions:k,payer:this.feePayer,lookupTableAddressAccount:s})||ln({instructions:w,payer:this.feePayer,lookupTableAddressAccount:s})))b.push(h);else{if(b.length===0)throw Error("item ins too big");g+=h===n[g]?1:0;let x={};for(let B of[...new Set(u)])s[B]!==void 0&&(x[B]=s[B]);if(t&&ln({instructions:[...l.instructions,...b],payer:this.feePayer,lookupTableAddressAccount:s,recentBlockhash:m})){let B=new dn({payerKey:this.feePayer,recentBlockhash:m,instructions:[...l.instructions,...b]}).compileToV0Message(Object.values(s));f.push(new pn(B))}else{let B=new dn({payerKey:this.feePayer,recentBlockhash:m,instructions:[...b]}).compileToV0Message(Object.values(s));f.push(new pn(B))}y.push(Array.from(new Set(b.map(B=>B.keys.filter(K=>K.isSigner).map(K=>K.pubkey.toString())).flat())).map(B=>p[B]).filter(B=>B!==void 0)),b=[h]}}),b.length>0){let w=[...new Set(b.map(k=>k.keys.filter(x=>x.isSigner).map(x=>x.pubkey.toString())).flat()).values()].map(k=>p[k]).filter(k=>k!==void 0);if(t&&ln({instructions:[...l.instructions,...b],payer:this.feePayer,lookupTableAddressAccount:s,recentBlockhash:m})){let k=new dn({payerKey:this.feePayer,recentBlockhash:m,instructions:[...l.instructions,...b]}).compileToV0Message(Object.values(s));f.push(new pn(k))}else{let k=new dn({payerKey:this.feePayer,recentBlockhash:m,instructions:[...b]}).compileToV0Message(Object.values(s));f.push(new pn(k))}y.push(w)}return(T=this.owner)!=null&&T.signer&&y.forEach(h=>{h.some(w=>w.publicKey.equals(this.owner.publicKey))||h.push(this.owner.signer)}),f.forEach((h,w)=>{h.sign(y[w])}),{builder:this,transactions:f,buildProps:e,signers:y,blockHash:m,instructionTypes:this.instructionTypes,execute:async h=>{var I;let{sequentially:w,onTxUpdate:k,skipTxCount:x=0,recentBlockHash:B,skipPreflight:K=!0}=h||{};if(f.map(async(R,C)=>{y[C].length&&R.sign(y[C]),B&&(R.message.recentBlockhash=B)}),Sn(f),(I=this.owner)!=null&&I.isKeyPair){if(w){let R=0,C=[];for(let N of f){if(++R,R<=x){console.log("skip tx: ",R),C.push("tx skipped");continue}let L=await this.connection.sendTransaction(N,{skipPreflight:K});await Wo(this.connection,L),C.push(L)}return{txIds:C,signedTxs:f}}return{txIds:await Promise.all(f.map(async R=>await this.connection.sendTransaction(R,{skipPreflight:K}))),signedTxs:f}}if(this.signAllTransactions){let R=await this.signAllTransactions(f.slice(x,f.length)),C=[...f.slice(0,x),...R];if(w){let N=0,L=[],O=async()=>{if(!C[N])return;if(N<x){L.push({txId:"",status:"success",signedTx:C[N]}),k==null||k([...L]),N++,O();return}let _=await this.connection.sendTransaction(C[N],{skipPreflight:K});L.push({txId:_,status:"sent",signedTx:C[N]}),k==null||k([...L]),N++;let G=!1,z=null,H=null,me=ne=>{z!==null&&clearInterval(z),H!==null&&this.connection.removeSignatureListener(H);let ae=L.findIndex(fe=>fe.txId===_);if(ae>-1){if(L[ae].status==="error"||L[ae].status==="success")return;L[ae].status=ne.err?"error":"success"}k==null||k([...L]),ne.err||O()};this.loopMultiTxStatus&&(z=setInterval(async()=>{var ne;if(G){clearInterval(z);return}try{let ae=await this.connection.getTransaction(_,{commitment:"confirmed",maxSupportedTransactionVersion:0});ae&&(G=!0,clearInterval(z),me({err:((ne=ae.meta)==null?void 0:ne.err)||null}),console.log("tx status from getTransaction:",_))}catch(ae){G=!0,clearInterval(z),console.error("getTransaction timeout:",ae,_)}},zo)),H=this.connection.onSignature(_,ne=>{if(G){this.connection.removeSignatureListener(H);return}G=!0,me(ne)},"confirmed"),this.connection.getSignatureStatus(_)};return O(),{txIds:[],signedTxs:C}}else{let N=[];for(let L=0;L<C.length;L+=1){let O=await this.connection.sendTransaction(C[L],{skipPreflight:K});N.push(O)}return{txIds:N,signedTxs:C}}}throw new Error("please provide owner in keypair format or signAllTransactions function")},extInfo:i||{}}}async buildSniperTransaction(e){var T;let P=e||{},{computeBudgetConfig:t,splitIns:n=[],lookupTableCache:o={},lookupTableAddress:r=[]}=P,i=ve(P,["computeBudgetConfig","splitIns","lookupTableCache","lookupTableAddress"]),s=v(v({},this.cluster==="devnet"?await er(this.connection):await us(this.connection)),o),u=Array.from(new Set([...this.lookupTableAddress,...r])),a=[];for(let h of u)s[h]===void 0&&a.push(new zn(h));let c=await Ji({connection:this.connection,address:a});for(let[h,w]of Object.entries(c))s[h]=w;let l=t?Eo(t):{instructions:[],instructionTypes:[]},m=await Dn(this.connection,this.blockhashCommitment),p=this.signers.reduce((h,w)=>D(v({},h),{[w.publicKey.toBase58()]:w}),{}),f=[],y=[],b=[],g=0;if(this.allInstructions.forEach(h=>{let w=[...b,h],k=t?[...l.instructions,...w]:w;if(h!==n[g]&&b.length<12&&(ln({instructions:k,payer:this.feePayer,lookupTableAddressAccount:s})||ln({instructions:w,payer:this.feePayer,lookupTableAddressAccount:s})))b.push(h);else{if(b.length===0)throw Error("item ins too big");g+=h===n[g]?1:0;let x={};for(let B of[...new Set(u)])s[B]!==void 0&&(x[B]=s[B]);if(t&&ln({instructions:[...l.instructions,...b],payer:this.feePayer,lookupTableAddressAccount:s,recentBlockhash:m})){let B=new dn({payerKey:this.feePayer,recentBlockhash:m,instructions:[...l.instructions,...b]}).compileToV0Message(Object.values(s));f.push(new pn(B))}else{let B=new dn({payerKey:this.feePayer,recentBlockhash:m,instructions:[...b]}).compileToV0Message(Object.values(s));f.push(new pn(B))}y.push(Array.from(new Set(b.map(B=>B.keys.filter(K=>K.isSigner).map(K=>K.pubkey.toString())).flat())).map(B=>p[B]).filter(B=>B!==void 0)),b=[h]}}),b.length>0){let w=[...new Set(b.map(k=>k.keys.filter(x=>x.isSigner).map(x=>x.pubkey.toString())).flat()).values()].map(k=>p[k]).filter(k=>k!==void 0);if(t&&ln({instructions:[...l.instructions,...b],payer:this.feePayer,lookupTableAddressAccount:s,recentBlockhash:m})){let k=new dn({payerKey:this.feePayer,recentBlockhash:m,instructions:[...l.instructions,...b]}).compileToV0Message(Object.values(s));f.push(new pn(k))}else{let k=new dn({payerKey:this.feePayer,recentBlockhash:m,instructions:[...b]}).compileToV0Message(Object.values(s));f.push(new pn(k))}y.push(w)}return(T=this.owner)!=null&&T.signer&&y.forEach(h=>{h.some(w=>w.publicKey.equals(this.owner.publicKey))||h.push(this.owner.signer)}),f.forEach((h,w)=>{h.sign(y[w])}),{builder:this,transactions:f,buildProps:e,signers:y,instructionTypes:this.instructionTypes,execute:async h=>{var I;let{sequentially:w,onTxUpdate:k,skipTxCount:x=0,recentBlockHash:B,skipPreflight:K=!0}=h||{};if(f.map(async(R,C)=>{y[C].length&&R.sign(y[C]),B&&(R.message.recentBlockhash=B)}),Sn(f),(I=this.owner)!=null&&I.isKeyPair){if(w){let R=0,C=[];for(let N of f){if(++R,R<=x){console.log("skip tx: ",R),C.push("tx skipped");continue}let L=await this.connection.sendTransaction(N,{skipPreflight:K});await Wo(this.connection,L),C.push(L)}return{txIds:C,signedTxs:f}}return{txIds:await Promise.all(f.map(async R=>await this.connection.sendTransaction(R,{skipPreflight:K}))),signedTxs:f}}if(this.signAllTransactions){let R=await this.signAllTransactions(f.slice(x,f.length)),C=[...f.slice(0,x),...R];if(w){let N=0,L=[],O=async()=>{if(!C[N])return;if(N<x){L.push({txId:"",status:"success",signedTx:C[N]}),k==null||k([...L]),N++,O();return}let _=await this.connection.sendTransaction(C[N],{skipPreflight:K});L.push({txId:_,status:"sent",signedTx:C[N]}),k==null||k([...L]),N++;let G=!1,z=null,H=null,me=ne=>{z!==null&&clearInterval(z),H!==null&&this.connection.removeSignatureListener(H);let ae=L.findIndex(fe=>fe.txId===_);if(ae>-1){if(L[ae].status==="error"||L[ae].status==="success")return;L[ae].status=ne.err?"error":"success"}k==null||k([...L]),ne.err||O()};this.loopMultiTxStatus&&(z=setInterval(async()=>{var ne;if(G){clearInterval(z);return}try{let ae=await this.connection.getTransaction(_,{commitment:"confirmed",maxSupportedTransactionVersion:0});ae&&(G=!0,clearInterval(z),me({err:((ne=ae.meta)==null?void 0:ne.err)||null}),console.log("tx status from getTransaction:",_))}catch(ae){G=!0,clearInterval(z),console.error("getTransaction timeout:",ae,_)}},zo)),H=this.connection.onSignature(_,ne=>{if(G){this.connection.removeSignatureListener(H);return}G=!0,me(ne)},"confirmed"),this.connection.getSignatureStatus(_)};return O(),{txIds:[],signedTxs:C}}else{let N=[];for(let L=0;L<C.length;L+=1){let O=await this.connection.sendTransaction(C[L],{skipPreflight:K});N.push(O)}return{txIds:N,signedTxs:C}}}throw new Error("please provide owner in keypair format or signAllTransactions function")},extInfo:i||{}}}};import{PublicKey as jl}from"@solana/web3.js";import $l from"bn.js";function Zl(d){return typeof d=="object"&&d!==null&&![De,xe,jl,Ie,$l,At,tt].some(e=>typeof e=="object"&&d instanceof e)}function rt(d){return typeof d=="string"?$r(d):Array.isArray(d)?d.map(e=>rt(e)):Zl(d)?Object.fromEntries(Object.entries(d).map(([e,t])=>[e,rt(t)])):d}import Jl from"bn.js";var wt=new Jl(1e6);var nt={BASE_HOST:"https://api-v3.raydium.io",OWNER_BASE_HOST:"https://owner-v1.raydium.io",SERVICE_BASE_HOST:"https://service.raydium.io",MONITOR_BASE_HOST:"https://monitor.raydium.io",SERVICE_1_BASE_HOST:"https://service-v1.raydium.io",SEND_TRANSACTION:"/send-transaction",FARM_ARP:"/main/farm/info",FARM_ARP_LINE:"/main/farm-apr-tv",CLMM_CONFIG:"/main/clmm-config",CPMM_CONFIG:"/main/cpmm-config",VERSION:"/main/version",CHECK_AVAILABILITY:"/v3/main/AvailabilityCheckAPI",RPCS:"/main/rpcs",INFO:"/main/info",STAKE_POOLS:"/main/stake-pools",CHAIN_TIME:"/main/chain-time",TOKEN_LIST:"/mint/list",MINT_INFO_ID:"/mint/ids",JUP_TOKEN_LIST:"https://lite-api.jup.ag/tokens/v1/tagged/verified",POOL_LIST:"/pools/info/list",POOL_SEARCH_BY_ID:"/pools/info/ids",POOL_SEARCH_MINT:"/pools/info/mint",POOL_SEARCH_LP:"/pools/info/lps",POOL_KEY_BY_ID:"/pools/key/ids",POOL_LIQUIDITY_LINE:"/pools/line/liquidity",POOL_POSITION_LINE:"/pools/line/position",FARM_INFO:"/farms/info/ids",FARM_LP_INFO:"/farms/info/lp",FARM_KEYS:"/farms/key/ids",OWNER_CREATED_FARM:"/create-pool/{owner}",OWNER_IDO:"/main/ido/{owner}",OWNER_STAKE_FARMS:"/position/stake/{owner}",OWNER_LOCK_POSITION:"/position/clmm-lock/{owner}",IDO_KEYS:"/ido/key/ids",SWAP_HOST:"https://transaction-v1.raydium.io",SWAP_COMPUTE:"/compute/",SWAP_TX:"/transaction/",MINT_PRICE:"/mint/price",MIGRATE_CONFIG:"/main/migrate-lp",PRIORITY_FEE:"/main/auto-fee",CPMM_LOCK:"https://dynamic-ipfs.raydium.io/lock/cpmm/position"},qb=v({},nt);var lu="ray_tab_hash",ls="ray_req_hash",em=()=>{if(typeof window===void 0)return"";let d=sessionStorage.getItem(lu);return d||(d=`ray-${Date.now()}`,sessionStorage.setItem(lu,d)),d},tr=async n=>{var o=n,{logCount:d=1e3,removeLastLog:e}=o,t=ve(o,["logCount","removeLastLog"]);if(typeof window===void 0)return new Promise(i=>i());let r=JSON.parse(localStorage.getItem(ls)||"[]").slice(0,d-1);e&&r.pop(),new Blob([JSON.stringify(t.data)]).size>1024&&(t.data=JSON.stringify(t.data).substring(0,200)+"..."),r.unshift(D(v({},t),{time:Date.now(),session:em()}));try{localStorage.setItem(ls,JSON.stringify(r))}catch{if(e){let i=!1,s=JSON.stringify(t.data).substring(0,100);for(r[0].data=s+(s.length>100?"...":"");!i;){r.pop();let u=JSON.stringify(t.data).substring(0,100);r[0].data=u+(u.length>100?"...":"");try{localStorage.setItem(ls,JSON.stringify(r)),i=!0}catch{i=!1}}return new Promise(u=>u())}return tr(D(v({},t),{logCount:d,removeLastLog:!0}))}};import{TOKEN_2022_PROGRAM_ID as tm,TOKEN_PROGRAM_ID as nm}from"@solana/spl-token";var nr=be("Raydium_Api"),ms=new Map;var or=class{constructor({cluster:e,timeout:t,logRequests:n,logCount:o,urlConfigs:r}){this.cluster=e,this.urlConfigs=r||{},this.logCount=o||1e3,this.api=mu.create({baseURL:this.urlConfigs.BASE_HOST||nt.BASE_HOST,timeout:t}),this.api.interceptors.request.use(i=>{let{method:s,baseURL:u,url:a}=i;return nr.debug(`${s==null?void 0:s.toUpperCase()} ${u}${a}`),i},i=>(nr.error("Request failed"),Promise.reject(i))),this.api.interceptors.response.use(i=>{let{config:s,data:u,status:a}=i,{method:c,baseURL:l,url:m}=s;return n&&tr({status:a,url:`${l}${m}`,params:s.params,data:u,logCount:this.logCount}),nr.debug(`${c==null?void 0:c.toUpperCase()} ${l}${m}  ${a}`),u},i=>{let{config:s,response:u={}}=i,{status:a}=u,{method:c,baseURL:l,url:m}=s;return n&&tr({status:a,url:`${l}${m}`,params:s.params,data:i.message,logCount:this.logCount}),nr.error(`${c.toUpperCase()} ${l}${m} ${a||i.message}`),Promise.reject(i)})}async getClmmConfigs(){return(await this.api.get(this.urlConfigs.CLMM_CONFIG||nt.CLMM_CONFIG)).data}async getCpmmConfigs(){return(await this.api.get(this.urlConfigs.CPMM_CONFIG||nt.CPMM_CONFIG)).data}async getClmmPoolLines(e){return(await this.api.get(`${this.urlConfigs.POOL_LIQUIDITY_LINE||nt.POOL_LIQUIDITY_LINE}?pool_id=${e}`)).data}async getBlockSlotCountForSecond(e){if(!e)return 2;let n=(await mu.post(e,{id:"getRecentPerformanceSamples",jsonrpc:"2.0",method:"getRecentPerformanceSamples",params:[4]})).result.map(o=>o.numSlots);return n.reduce((o,r)=>o+r,0)/n.length/60}async getChainTimeOffset(){return(await this.api.get(this.urlConfigs.CHAIN_TIME||nt.CHAIN_TIME)).data}async getRpcs(){return this.api.get(this.urlConfigs.RPCS||nt.RPCS)}async getTokenList(){return(await this.api.get(this.urlConfigs.TOKEN_LIST||nt.TOKEN_LIST)).data}async getJupTokenList(){return(await this.api.get("",{baseURL:this.urlConfigs.JUP_TOKEN_LIST||nt.JUP_TOKEN_LIST})).map(t=>D(v({},t),{chainId:101,programId:t.tags.includes("token-2022")?tm.toBase58():nm.toBase58()}))}async getTokenInfo(e){return(await this.api.get((this.urlConfigs.MINT_INFO_ID||nt.MINT_INFO_ID)+`?mints=${e.map(n=>n.toString()).join(",")}`)).data}async getPoolList(e={}){let{type:t="all",sort:n="liquidity",order:o="desc",page:r=0,pageSize:i=100}=e;return(await this.api.get((this.urlConfigs.POOL_LIST||nt.POOL_LIST)+`?poolType=${t}&poolSortField=${n}&sortType=${o}&page=${r}&pageSize=${i}`)).data}async fetchPoolById(e){let{ids:t}=e;return(await this.api.get((this.urlConfigs.POOL_SEARCH_BY_ID||nt.POOL_SEARCH_BY_ID)+`?ids=${t}`)).data}async fetchPoolKeysById(e){let{idList:t}=e,n=[],o=t.filter(i=>ms.has(i)?(n.push(ms.get(i)),!1):!0),r=[];return o.length&&(r=(await this.api.get((this.urlConfigs.POOL_KEY_BY_ID||nt.POOL_KEY_BY_ID)+`?ids=${o.join(",")}`)).data.filter(Boolean),r.forEach(s=>{ms.set(s.id,s)})),n.concat(r)}async fetchPoolByMints(e){let{mint1:t,mint2:n,type:o="all",sort:r="default",order:i="desc",page:s=1}=e,[u,a]=[t&&ct(t).toBase58(),n&&n!=="undefined"?ct(n).toBase58():""],[c,l]=a&&u>a?[a,u]:[u,a];return(await this.api.get((this.urlConfigs.POOL_SEARCH_MINT||nt.POOL_SEARCH_MINT)+`?mint1=${c}&mint2=${l}&poolType=${o}&poolSortField=${r}&sortType=${i}&pageSize=100&page=${s}`)).data}async fetchFarmInfoById(e){let{ids:t}=e;return(await this.api.get((this.urlConfigs.FARM_INFO||nt.FARM_INFO)+`?ids=${t}`)).data}async fetchFarmKeysById(e){let{ids:t}=e;return(await this.api.get((this.urlConfigs.FARM_KEYS||nt.FARM_KEYS)+`?ids=${t}`)).data}async fetchAvailabilityStatus(){return(await this.api.get(this.urlConfigs.CHECK_AVAILABILITY||nt.CHECK_AVAILABILITY)).data}};var ir="please provide owner in load() initialization or you can set by calling raydium.setOwner(owner)",du="please provide connection in load() initialization or set it by raydium.setConnection(connection)";import{PublicKey as lr,SystemProgram as Nm}from"@solana/web3.js";import{AccountLayout as To,createAssociatedTokenAccountIdempotentInstruction as Ts,TOKEN_PROGRAM_ID as Nn,TOKEN_2022_PROGRAM_ID as Mm}from"@solana/spl-token";var ds=(...d)=>d.map(e=>{try{return typeof e=="object"?JSON.stringify(e):e}catch{return e}}).join(", "),_e=class{constructor({scope:e,moduleName:t}){this.disabled=!1;this.scope=e,this.logger=be(t)}createTxBuilder(e){return this.scope.checkOwner(),new Yo({connection:this.scope.connection,feePayer:e||this.scope.ownerPubKey,cluster:this.scope.cluster,owner:this.scope.owner,blockhashCommitment:this.scope.blockhashCommitment,loopMultiTxStatus:this.scope.loopMultiTxStatus,api:this.scope.api,signAllTransactions:this.scope.signAllTransactions})}createSniperTxBuilder(e,t){let n=new xt(e);return new Yo({connection:this.scope.connection,feePayer:t,cluster:this.scope.cluster,owner:n,blockhashCommitment:this.scope.blockhashCommitment,loopMultiTxStatus:this.scope.loopMultiTxStatus,api:this.scope.api,signAllTransactions:this.scope.signAllTransactions})}logDebug(...e){this.logger.debug(ds(e))}logInfo(...e){this.logger.info(ds(e))}logAndCreateError(...e){let t=ds(e);throw new Error(t)}checkDisabled(){(this.disabled||!this.scope)&&this.logAndCreateError("module not working")}};import{PublicKey as Sm,SystemProgram as Km}from"@solana/web3.js";import Cm from"bn.js";import{createCloseAccountInstruction as Rm,createInitializeAccountInstruction as Lm,createTransferInstruction as Om,TOKEN_PROGRAM_ID as wo}from"@solana/spl-token";import{Keypair as hm,PublicKey as Su}from"@solana/web3.js";import Im from"bn.js";import{TOKEN_PROGRAM_ID as Bm}from"@solana/spl-token";function om(d){return d instanceof Uint8Array||d!=null&&typeof d=="object"&&d.constructor.name==="Uint8Array"}function ps(d,...e){if(!om(d))throw new Error("Uint8Array expected");if(e.length>0&&!e.includes(d.length))throw new Error(`Uint8Array expected of length ${e}, not of length=${d.length}`)}function fs(d,e=!0){if(d.destroyed)throw new Error("Hash instance has been destroyed");if(e&&d.finished)throw new Error("Hash#digest() has already been called")}function pu(d,e){ps(d);let t=e.outputLen;if(d.length<t)throw new Error(`digestInto() expects output buffer of length at least ${t}`)}var sr=d=>new DataView(d.buffer,d.byteOffset,d.byteLength),Zt=(d,e)=>d<<32-e|d>>>e;var Sg=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;function im(d){if(typeof d!="string")throw new Error(`utf8ToBytes expected string, got ${typeof d}`);return new Uint8Array(new TextEncoder().encode(d))}function ys(d){return typeof d=="string"&&(d=im(d)),ps(d),d}var rr=class{clone(){return this._cloneInto()}},Kg={}.toString;function fu(d){let e=n=>d().update(ys(n)).digest(),t=d();return e.outputLen=t.outputLen,e.blockLen=t.blockLen,e.create=()=>d(),e}function rm(d,e,t,n){if(typeof d.setBigUint64=="function")return d.setBigUint64(e,t,n);let o=BigInt(32),r=BigInt(4294967295),i=Number(t>>o&r),s=Number(t&r),u=n?4:0,a=n?0:4;d.setUint32(e+u,i,n),d.setUint32(e+a,s,n)}var yu=(d,e,t)=>d&e^~d&t,bu=(d,e,t)=>d&e^d&t^e&t,ar=class extends rr{constructor(e,t,n,o){super(),this.blockLen=e,this.outputLen=t,this.padOffset=n,this.isLE=o,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(e),this.view=sr(this.buffer)}update(e){fs(this);let{view:t,buffer:n,blockLen:o}=this;e=ys(e);let r=e.length;for(let i=0;i<r;){let s=Math.min(o-this.pos,r-i);if(s===o){let u=sr(e);for(;o<=r-i;i+=o)this.process(u,i);continue}n.set(e.subarray(i,i+s),this.pos),this.pos+=s,i+=s,this.pos===o&&(this.process(t,0),this.pos=0)}return this.length+=e.length,this.roundClean(),this}digestInto(e){fs(this),pu(e,this),this.finished=!0;let{buffer:t,view:n,blockLen:o,isLE:r}=this,{pos:i}=this;t[i++]=128,this.buffer.subarray(i).fill(0),this.padOffset>o-i&&(this.process(n,0),i=0);for(let l=i;l<o;l++)t[l]=0;rm(n,o-8,BigInt(this.length*8),r),this.process(n,0);let s=sr(e),u=this.outputLen;if(u%4)throw new Error("_sha2: outputLen should be aligned to 32bit");let a=u/4,c=this.get();if(a>c.length)throw new Error("_sha2: outputLen bigger than state");for(let l=0;l<a;l++)s.setUint32(4*l,c[l],r)}digest(){let{buffer:e,outputLen:t}=this;this.digestInto(e);let n=e.slice(0,t);return this.destroy(),n}_cloneInto(e){e||(e=new this.constructor),e.set(...this.get());let{blockLen:t,buffer:n,length:o,finished:r,destroyed:i,pos:s}=this;return e.length=o,e.pos=s,e.finished=r,e.destroyed=i,o%t&&e.buffer.set(n),e}};var sm=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),Rn=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),Ln=new Uint32Array(64),bs=class extends ar{constructor(){super(64,32,8,!1),this.A=Rn[0]|0,this.B=Rn[1]|0,this.C=Rn[2]|0,this.D=Rn[3]|0,this.E=Rn[4]|0,this.F=Rn[5]|0,this.G=Rn[6]|0,this.H=Rn[7]|0}get(){let{A:e,B:t,C:n,D:o,E:r,F:i,G:s,H:u}=this;return[e,t,n,o,r,i,s,u]}set(e,t,n,o,r,i,s,u){this.A=e|0,this.B=t|0,this.C=n|0,this.D=o|0,this.E=r|0,this.F=i|0,this.G=s|0,this.H=u|0}process(e,t){for(let l=0;l<16;l++,t+=4)Ln[l]=e.getUint32(t,!1);for(let l=16;l<64;l++){let m=Ln[l-15],p=Ln[l-2],f=Zt(m,7)^Zt(m,18)^m>>>3,y=Zt(p,17)^Zt(p,19)^p>>>10;Ln[l]=y+Ln[l-7]+f+Ln[l-16]|0}let{A:n,B:o,C:r,D:i,E:s,F:u,G:a,H:c}=this;for(let l=0;l<64;l++){let m=Zt(s,6)^Zt(s,11)^Zt(s,25),p=c+m+yu(s,u,a)+sm[l]+Ln[l]|0,y=(Zt(n,2)^Zt(n,13)^Zt(n,22))+bu(n,o,r)|0;c=a,a=u,u=s,s=i+p|0,i=r,r=o,o=n,n=p+y|0}n=n+this.A|0,o=o+this.B|0,r=r+this.C|0,i=i+this.D|0,s=s+this.E|0,u=u+this.F|0,a=a+this.G|0,c=c+this.H|0,this.set(n,o,r,i,s,u,a,c)}roundClean(){Ln.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}};var gu=fu(()=>new bs);import{PublicKey as Am}from"@solana/web3.js";import Tu,{isBN as hu}from"bn.js";import{bits as am,BitStructure as _g,blob as um,Blob as Vg,cstr as Eg,f32 as Wg,f32be as Dg,f64 as qg,f64be as Ug,greedy as Gg,Layout as cm,ns64 as Xg,ns64be as zg,nu64 as lm,nu64be as Yg,offset as mm,s16 as Qg,s16be as Hg,s24 as jg,s24be as $g,s32 as dm,s32be as Zg,s40 as Jg,s40be as eP,s48 as tP,s48be as nP,s8 as oP,seq as pm,struct as iP,Structure as fm,u16 as ym,u16be as rP,u24 as sP,u24be as aP,u32 as bm,u32be as uP,u40 as cP,u40be as lP,u48 as mP,u48be as dP,u8 as gm,UInt as Pm,union as pP,Union as fP,unionLayoutDiscriminator as yP,utf8 as bP}from"@solana/buffer-layout";var ur=cm,Pu=fm;var gs=Pm;var Au=gm,St=ym;var Qo=bm;var ku=lm;var Ve=dm;var wu=pm;var we=um;var Ps=am,As=mm;var Qn=class extends ur{constructor(t,n,o){super(t,o);this.blob=we(t),this.signed=n}decode(t,n=0){let o=new Tu(this.blob.decode(t,n),10,"le");return this.signed?o.fromTwos(this.span*8).clone():o}encode(t,n,o=0){return typeof t=="number"&&(t=new Tu(t)),this.signed&&(t=t.toTwos(this.span*8)),this.blob.encode(t.toArrayLike(Buffer,"le",this.span),n,o)}},cr=class extends ur{constructor(t){super(8,t);this._lower=Ps(Qo(),!1),this._upper=Ps(Qo(),!1)}addBoolean(t){this._lower.fields.length<32?this._lower.addBoolean(t):this._upper.addBoolean(t)}decode(t,n=0){let o=this._lower.decode(t,n),r=this._upper.decode(t,n+this._lower.span);return v(v({},o),r)}encode(t,n,o=0){return this._lower.encode(t,n,o)+this._upper.encode(t,n,o+this._lower.span)}};function V(d){return new gs(1,d)}function mt(d){return new gs(4,d)}function A(d){return new Qn(8,!1,d)}function ie(d){return new Qn(16,!1,d)}function Iu(d){return new Qn(1,!0,d)}function ko(d){return new Qn(8,!0,d)}function Bu(d){return new Qn(16,!0,d)}var Hn=class extends ur{constructor(t,n,o,r){super(t.span,r);this.layout=t,this.decoder=n,this.encoder=o}decode(t,n){return this.decoder(this.layout.decode(t,n))}encode(t,n,o){return this.layout.encode(this.encoder(t),n,o)}getSpan(t,n){return this.layout.getSpan(t,n)}};function M(d){return new Hn(we(32),e=>new Am(e),e=>e.toBuffer(),d)}function qe(d){return new Hn(Au(),km,wm,d)}function km(d){if(d===0)return!1;if(d===1)return!0;throw new Error("Invalid bool: "+d)}function wm(d){return d?1:0}function xu(d,e){let t=Qo("length"),n=F([t,Y(d,As(t,-t.span),"values")]);return new Hn(n,({values:o})=>o,o=>({values:o}),e)}function Tm(d){let e=Qo("length"),t=F([e,we(As(e,-e.span),"data")]);return new Hn(t,({data:n})=>n,n=>({data:n}),d)}function Tt(d){return new Hn(Tm(),e=>e.toString("utf-8"),e=>Buffer.from(e,"utf-8"),d)}var ks=class extends Pu{decode(e,t){return super.decode(e,t)}};function F(d,e,t){return new ks(d,e,t)}function Y(d,e,t){let n,o=typeof e=="number"?e:hu(e)?e.toNumber():new Proxy(e,{get(r,i){if(!n){let s=Reflect.get(r,"count");n=hu(s)?s.toNumber():s,Reflect.set(r,"count",n)}return Reflect.get(r,i)},set(r,i,s){return i==="count"&&(n=s),Reflect.set(r,i,s)}});return wu(d,o,t)}var jn=F([M("mint"),M("owner"),A("amount"),mt("delegateOption"),M("delegate"),V("state"),mt("isNativeOption"),A("isNative"),A("delegatedAmount"),mt("closeAuthorityOption"),M("closeAuthority")]);var _P=be("Raydium_Util");function Ku({owner:d,solAccountResp:e,tokenAccountResp:t}){let n=[],o=[];for(let{pubkey:r,account:i}of t.value){let s=jn.decode(i.data),{mint:u,amount:a}=s;n.push({publicKey:r,mint:u,amount:a,isAssociated:Z(d,u,i.owner).publicKey.equals(r),isNative:!1,programId:i.owner}),o.push({pubkey:r,accountInfo:s,programId:i.owner})}return e&&n.push({mint:Su.default,amount:new Im(String(e.lamports)),isNative:!0,programId:e.owner}),{tokenAccounts:n,tokenAccountRawInfos:o}}function Ye({fromPublicKey:d,programId:e=Bm,assignSeed:t}){let n=t?btoa(t).slice(0,32):hm.generate().publicKey.toBase58().slice(0,32);return{publicKey:xm(d,n,e),seed:n}}function xm(d,e,t){let n=Buffer.concat([d.toBuffer(),Buffer.from(e),t.toBuffer()]),o=gu(n);return new Su(o)}function ws(d){let{mint:e,tokenAccount:t,owner:n,programId:o=wo}=d;return Lm(t,e,n,o)}function fn(d){let{tokenAccount:e,payer:t,multiSigners:n=[],owner:o,programId:r=wo}=d;return Rm(e,t,o,n,r)}async function On(d){let{connection:e,amount:t,commitment:n,payer:o,owner:r,skipCloseAccount:i}=d,s=await e.getMinimumBalanceForRentExemption(jn.span,n),u=te(t).add(new Cm(s)),a=Ye({fromPublicKey:o,programId:wo});return{addresses:{newAccount:a.publicKey},signers:[],instructions:[Km.createAccountWithSeed({fromPubkey:o,basePubkey:o,seed:a.seed,newAccountPubkey:a.publicKey,lamports:u.toNumber(),space:jn.span,programId:wo}),ws({mint:new Sm(lt.address),tokenAccount:a.publicKey,owner:r,programId:wo})],instructionTypes:[U.CreateAccount,U.InitAccount],endInstructionTypes:i?[]:[U.CloseAccount],endInstructions:i?[]:[fn({tokenAccount:a.publicKey,payer:o,owner:r})]}}function Cu({source:d,destination:e,owner:t,amount:n,multiSigners:o=[],tokenProgram:r=wo}){return Om(d,e,t,BigInt(String(n)),o,r)}var Ho=class extends _e{constructor(t){super(t);this._tokenAccounts=[];this._tokenAccountRawInfos=[];this._accountListener=[];this._clientOwnedToken=!1;this._notSubscribeAccountChange=!1;this._accountFetchTime=0;let{tokenAccounts:n,tokenAccountRawInfos:o,notSubscribeAccountChange:r}=t;this._tokenAccounts=n||[],this._tokenAccountRawInfos=o||[],this._notSubscribeAccountChange=r!=null?r:!0,this._clientOwnedToken=!!(n||o)}get tokenAccounts(){return this._tokenAccounts}get tokenAccountRawInfos(){return this._tokenAccountRawInfos}set notSubscribeAccountChange(t){this._notSubscribeAccountChange=t}updateTokenAccount({tokenAccounts:t,tokenAccountRawInfos:n}){return t&&(this._tokenAccounts=t),n&&(this._tokenAccountRawInfos=n),this._accountChangeListenerId&&this.scope.connection.removeAccountChangeListener(this._accountChangeListenerId),this._accountChangeListenerId=void 0,this._clientOwnedToken=!0,this}addAccountChangeListener(t){return this._accountListener.push(t),this}removeAccountChangeListener(t){return this._accountListener=this._accountListener.filter(n=>n!==t),this}getAssociatedTokenAccount(t,n){return Z(this.scope.ownerPubKey,t,n).publicKey}getAssociatedTokenAccountByOwner(t,n,o){return Z(t,n,o).publicKey}resetTokenAccounts(){this._clientOwnedToken||(this._tokenAccounts=[],this._tokenAccountRawInfos=[])}async fetchWalletTokenAccounts(t){if(this._clientOwnedToken||!(t!=null&&t.forceUpdate)&&this._tokenAccounts.length&&Date.now()-this._accountFetchTime<(this._notSubscribeAccountChange?1e3*5:1e3*60*3))return{tokenAccounts:this._tokenAccounts,tokenAccountRawInfos:this._tokenAccountRawInfos};this.scope.checkOwner();let o=v(v({},{}),t),[r,i,s]=await Promise.all([this.scope.connection.getAccountInfo(this.scope.ownerPubKey,o.commitment),this.scope.connection.getTokenAccountsByOwner(this.scope.ownerPubKey,{programId:Nn},o.commitment),this.scope.connection.getTokenAccountsByOwner(this.scope.ownerPubKey,{programId:Mm},o.commitment)]),{tokenAccounts:u,tokenAccountRawInfos:a}=Ku({owner:this.scope.ownerPubKey,solAccountResp:r,tokenAccountResp:{context:i.context,value:[...i.value,...s.value]}});return this._tokenAccounts=u,this._tokenAccountRawInfos=a,this._accountFetchTime=Date.now(),this._notSubscribeAccountChange||(this._accountChangeListenerId&&this.scope.connection.removeAccountChangeListener(this._accountChangeListenerId),this._accountChangeListenerId=this.scope.connection.onAccountChange(this.scope.ownerPubKey,()=>{this.fetchWalletTokenAccounts({forceUpdate:!0}),this._accountListener.forEach(c=>c({tokenAccounts:this._tokenAccounts,tokenAccountRawInfos:this._tokenAccountRawInfos}))},{commitment:t==null?void 0:t.commitment})),{tokenAccounts:u,tokenAccountRawInfos:a}}clearAccountChangeCkb(){this._accountChangeListenerId!==void 0&&this.scope.connection.removeAccountChangeListener(this._accountChangeListenerId)}async getCreatedTokenAccount({mint:t,programId:n=Nn,associatedOnly:o=!0}){await this.fetchWalletTokenAccounts();let r=this._tokenAccounts.filter(({mint:s})=>s==null?void 0:s.equals(t)).sort((s,u)=>s.amount.lt(u.amount)?1:-1),i=this.getAssociatedTokenAccount(t,n);for(let s of r){let{publicKey:u}=s;if(u&&(!o||o&&i.equals(u)))return u}}async getOrCreateTokenAccount(t){var y,b,g,P;await this.fetchWalletTokenAccounts();let{mint:n,createInfo:o,associatedOnly:r,owner:i,notUseTokenAccount:s=!1,skipCloseAccount:u=!1,checkCreateATAOwner:a=!1,assignSeed:c}=t;console.log("******************associatedOnly: ",r);let l=new lr(t.tokenProgram||Nn),m=this.getAssociatedTokenAccount(n,new lr(l)),p=(s?[]:this.tokenAccountRawInfos).filter(T=>T.accountInfo.mint.equals(n)&&(!r||T.pubkey.equals(m))).sort((T,h)=>T.accountInfo.amount.lt(h.accountInfo.amount)?1:-1);if(o===void 0||p.length>0)return p.length>0?{account:p[0].pubkey}:{};let f={instructions:[],endInstructions:[],signers:[],instructionTypes:[],endInstructionTypes:[]};if(r){let T=Ts(i,m,i,n,l),h=this.tokenAccountRawInfos.find(w=>w.pubkey.equals(m));if(a){console.log("******************checkCreateATAOwner: ",a);let w=await this.scope.connection.getAccountInfo(m);if(w===null)console.log("******************ataInfo == null: ",a),(y=f.instructions)==null||y.push(T),f.instructionTypes.push(U.CreateATA);else if(w.owner.equals(l)&&To.decode(w.data).mint.equals(n)&&To.decode(w.data).owner.equals(i))console.log("******************else empty: ");else throw Error(`create ata check error -> mint: ${n.toString()}, ata: ${m.toString()}`)}else h===void 0&&(console.log("******************_ataInTokenAcc undefined"),f.instructions.push(T),f.instructionTypes.push(U.CreateATA));if(n.equals(j)&&o.amount){console.log("createWSolAccountInstructions*********************************");let w=await On({connection:this.scope.connection,owner:i||this.scope.ownerPubKey,payer:o.payer||this.scope.ownerPubKey,amount:(b=o.amount)!=null?b:0,skipCloseAccount:u});f.instructions.push(...w.instructions||[]),f.endInstructions.push(...w.endInstructions||[]),f.instructionTypes.push(...w.instructionTypes||[]),f.endInstructionTypes.push(...w.endInstructionTypes||[]),o.amount&&(console.log("******************createInfo.amount"),f.instructions.push(Cu({source:w.addresses.newAccount,destination:m,owner:i||this.scope.ownerPubKey,amount:o.amount,tokenProgram:Nn})),f.instructionTypes.push(U.TransferAmount))}return!u&&h===void 0&&(console.log("******************skipCloseAccount"),f.endInstructions.push(fn({owner:i,payer:o.payer||i,tokenAccount:m,programId:l})),f.endInstructionTypes.push(U.CloseAccount)),{account:m,instructionParams:f}}else{console.log("******************newTokenAccount");let T=Ye({fromPublicKey:i,programId:l,assignSeed:c}),h=await this.scope.connection.getMinimumBalanceForRentExemption(To.span),w=Nm.createAccountWithSeed({fromPubkey:i,basePubkey:i,seed:T.seed,newAccountPubkey:T.publicKey,lamports:h+Number((P=(g=o.amount)==null?void 0:g.toString())!=null?P:0),space:To.span,programId:l});return f.instructions.push(w,ws({mint:n,tokenAccount:T.publicKey,owner:i||this.scope.ownerPubKey,programId:l})),f.instructionTypes.push(U.CreateAccount),f.instructionTypes.push(U.InitAccount),u||(f.endInstructions.push(fn({owner:i,payer:o.payer||i,tokenAccount:T.publicKey,programId:l})),f.endInstructionTypes.push(U.CloseAccount)),{account:T.publicKey,instructionParams:f}}}async checkOrCreateAta({mint:t,programId:n=Nn,autoUnwrapWSOLToSOL:o}){var u;await this.fetchWalletTokenAccounts();let r=(u=this.scope.account.tokenAccounts.find(({mint:a})=>(a==null?void 0:a.toBase58())===t.toBase58()))==null?void 0:u.publicKey,i=this.scope.ownerPubKey,s={};if(!r){let a=this.getAssociatedTokenAccount(t,n),c=await Ts(i,a,i,t,n);s.instructions=[c],s.instructionTypes=[U.CreateATA],r=a}return o&&j.toBase58()===t.toBase58()&&(s.endInstructions=[fn({owner:i,payer:i,tokenAccount:r,programId:n})],s.endInstructionTypes=[U.CloseAccount]),{pubKey:r,newInstructions:s}}async handleTokenAccount(t){let{side:n,amount:o,mint:r,programId:i=Nn,tokenAccount:s,payer:u=this.scope.ownerPubKey,bypassAssociatedCheck:a,skipCloseAccount:c,checkCreateATAOwner:l}=t,m=this.getAssociatedTokenAccount(r,i);if(new lr(j).equals(r)){let p=await On({connection:this.scope.connection,owner:this.scope.ownerPubKey,payer:u,amount:o,skipCloseAccount:c});return v({tokenAccount:p.addresses.newAccount},p)}else if(!s||n==="out"&&!m.equals(s)&&!a){let p=[],f=Ts(this.scope.ownerPubKey,m,this.scope.ownerPubKey,r,i);if(l){let y=await this.scope.connection.getAccountInfo(m);if(y===null)p.push(f);else if(!(y.owner.equals(Nn)&&To.decode(y.data).mint.equals(r)&&To.decode(y.data).owner.equals(this.scope.ownerPubKey)))throw Error(`create ata check error -> mint: ${r.toString()}, ata: ${m.toString()}`)}else p.push(f);return{tokenAccount:m,instructions:p,instructionTypes:[U.CreateATA]}}return{tokenAccount:s}}async processTokenAccount(t){let{mint:n,programId:o=Nn,amount:r,useSOLBalance:i,handleTokenAccount:s,feePayer:u}=t,a,c=this.createTxBuilder(u);if(n.equals(new lr(j))&&i){let l=await this.handleTokenAccount({side:"in",amount:r||0,mint:n,bypassAssociatedCheck:!0,programId:o}),{tokenAccount:p}=l,f=ve(l,["tokenAccount"]);a=p,c.addInstruction(f)}else if(a=await this.getCreatedTokenAccount({mint:n,associatedOnly:!1,programId:o}),!a&&s){let m=await this.scope.account.handleTokenAccount({side:"in",amount:0,mint:n,bypassAssociatedCheck:!0,programId:o}),{tokenAccount:p}=m,f=ve(m,["tokenAccount"]);a=p,c.addInstruction(f)}return v({tokenAccount:a},c.AllTxData)}};import{PublicKey as Be,SystemProgram as $m}from"@solana/web3.js";import{createAssociatedTokenAccountIdempotentInstruction as Xu}from"@solana/spl-token";import Zm from"decimal.js";import{PublicKey as Cs}from"@solana/web3.js";var hs=F([V("instruction")]),Is=F([V("instruction")]),vm=F([A("rewardState"),A("rewardOpenTime"),A("rewardEndTime"),A("rewardLastUpdateTime"),A("totalReward"),A("totalRewardEmissioned"),A("rewardClaimed"),A("rewardPerSecond"),ie("accRewardPerShare"),M("rewardVault"),M("rewardMint"),M("rewardSender"),A("rewardType"),Y(A(),15,"padding")]),Fm=F([A("state"),A("nonce"),M("lpVault"),M("rewardVault"),M(),M(),A(),A(),A("totalReward"),ie("perShareReward"),A("lastSlot"),A("perSlotReward")]),_m=F([A("state"),A("nonce"),M("lpVault"),M("rewardVaultA"),A("totalRewardA"),ie("perShareRewardA"),A("perSlotRewardA"),V("option"),M("rewardVaultB"),we(7),A("totalRewardB"),ie("perShareRewardB"),A("perSlotRewardB"),A("lastSlot"),M()]),Vm=F([A(),A("state"),A("nonce"),A("validRewardTokenNum"),ie("rewardMultiplier"),A("rewardPeriodMax"),A("rewardPeriodMin"),A("rewardPeriodExtend"),M("lpMint"),M("lpVault"),Y(vm,5,"rewardInfos"),M("creator"),M(),Y(A(),32,"padding")]),Em=new Proxy(Fm,{get(d,e,t){return e==="decode"?(...n)=>{let o=d.decode(...n);return D(v({},o),{version:3,rewardInfos:[{rewardVault:o.rewardVault,totalReward:o.totalReward,perSlotReward:o.perSlotReward,perShareReward:o.perShareReward}]})}:Reflect.get(d,e,t)}}),Wm=new Proxy(_m,{get(d,e,t){return e==="decode"?(...n)=>{let o=d.decode(...n);return D(v({},o),{version:5,rewardInfos:[{rewardVault:o.rewardVaultA,totalReward:o.totalRewardA,perSlotReward:o.perSlotRewardA,perShareReward:o.perShareRewardA},{rewardVault:o.rewardVaultB,totalReward:o.totalRewardB,perSlotReward:o.perSlotRewardB,perShareReward:o.perShareRewardB}]})}:Reflect.get(d,e,t)}}),mr=new Proxy(Vm,{get(d,e,t){return e==="decode"?(...n)=>{let o=d.decode(...n);return D(v({},o),{version:6,rewardInfos:o.rewardInfos.map(r=>{var i;return D(v({},r),{rewardType:((i=Object.entries(Mn).find(s=>String(s[1])===r.rewardType.toString()))!=null?i:["Standard SPL"])[0]})})})}:Reflect.get(d,e,t)}}),Dm=F([A("isSet"),A("rewardPerSecond"),A("rewardOpenTime"),A("rewardEndTime"),A("rewardType")]),Bs=F([V("instruction"),A("nonce"),Y(Dm,5,"rewardTimeInfo")]),xs=F([V("instruction"),A("rewardReopenTime"),A("rewardEndTime"),A("rewardPerSecond")]),Ss=F([V("instruction"),A("isSet"),A("rewardPerSecond"),A("rewardOpenTime"),A("rewardEndTime"),A("rewardType")]),yA=F([A("state"),M("id"),M("owner"),A("deposited"),Y(A(),1,"rewardDebts")]),Ks=F([A("state"),M("id"),M("owner"),A("deposited"),Y(ie(),1,"rewardDebts"),A(""),A("voteLockedBalance"),Y(A(),15)]),bA=F([A("state"),M("id"),M("owner"),A("deposited"),Y(A(),2,"rewardDebts")]),Ru=F([A("state"),M("id"),M("owner"),A("deposited"),Y(ie(),2,"rewardDebts"),Y(A(),17)]),Lu=F([A(),A("state"),M("id"),M("owner"),A("deposited"),Y(ie(),5,"rewardDebts"),Y(A(),16)]),Kt=F([V("instruction"),A("amount")]),qm=F([M("mint"),M("grantAuthority"),A("baselineVoteWeightScaledFactor"),A("maxExtraLockupVoteWeightScaledFactor"),A("lockupSaturationSecs"),Iu("digitShift"),Y(V(),7,"reserved1"),Y(A(),7,"reserved2")]),Um=F([we(8),M("governanceProgramId"),M("realm"),M("realmGoverningTokenMint"),M("realmAuthority"),Y(V(),32,"reserved1"),Y(qm,4,"votingMints"),ko("timeOffset"),V("bump"),Y(V(),7,"reserved2"),Y(A(),11,"reserved3")]),Gm=F([ko("startTime"),ko("endTime"),V("kind"),Y(V(),15,"reserved")]),Xm=F([Y(Gm,1,"lockup"),A("amountDeposited_native"),A("amountInitiallyLockedNative"),qe("isUsed"),qe("allowClawback"),V("votingMintConfigIdx"),Y(V(),29,"reserved")]),zm=F([we(8),M("voterAuthority"),M("registrar"),Y(Xm,32,"deposits"),V("voterBump"),V("voterWweightRecordBump"),Y(V(),94,"reserved")]);import{NATIVE_MINT as BA}from"@solana/spl-token";var xA=be("Raydium_farm_config"),Ou=new Cs("4k3Dyjzvzp8eMZWUXbBCjEvwSkkk59S5iCNLY3QrkX6R"),Nu=new Cs("FrspKwj8i3pNmKwXreTveC4fu7KL5ZbGeXdZBe2XViu1");var SA=new Cs("3TRTX4dXUpp2eqxi3tvQDFYUV7SdDJjcPE3Y4mbtftaX");var Mu={3:Ks,5:Ru,6:Lu},Rs=d=>[3,4,5,6].indexOf(d)!==-1,Ls=d=>{var i;let{version:e,rewardInfos:t,rewardTokenAccountsPublicKeys:n}=d,o=`rewardInfo:${JSON.stringify(t)}, rewardAccount:${JSON.stringify(n)}`,r={3:()=>{if(t.length!==1||n.length!==1)return`rewardInfos or rewardTokenAccounts lengths not equal 1: ${o}`},5:()=>{if(t.length!==n.length)return`rewardInfos and rewardTokenAccounts lengths not equal: ${o}`},6:()=>{if(!n.length||t.length!==n.length)return`no rewardTokenAccounts or rewardInfos and rewardTokenAccounts lengths not equal: ${o}`}};return(i=r[e])==null?void 0:i.call(r)},Mn={"Standard SPL":0,"Option tokens":1},Ft={[ou.toString()]:3,[iu.toString()]:4,[ru.toString()]:5,[qo.toString()]:6,[mn.FARM_PROGRAM_ID_V3.toString()]:3,[mn.FARM_PROGRAM_ID_V4.toString()]:4,[mn.FARM_PROGRAM_ID_V5.toString()]:5,[mn.FARM_PROGRAM_ID_V6.toString()]:6};import{PublicKey as ye,SystemProgram as _u,SYSVAR_CLOCK_PUBKEY as Zo,SYSVAR_RENT_PUBKEY as Hm,TransactionInstruction as Vt}from"@solana/web3.js";import Vu from"bn.js";import{ASSOCIATED_TOKEN_PROGRAM_ID as rk,createAssociatedTokenAccountIdempotentInstruction as sk,TOKEN_PROGRAM_ID as yn}from"@solana/spl-token";import Ym from"bn.js";var Qm=be("Raydium.farm.util");function jo({programId:d,poolId:e,mint:t,type:n}){let{publicKey:o}=ce([e.toBuffer(),t.toBuffer(),Buffer.from(n==="lpVault"?"lp_vault_associated_seed":n==="rewardVault"?"reward_vault_associated_seed":"","utf-8")],d);return o}function _t({programId:d,poolId:e,owner:t,version:n}){let{publicKey:o}=ce([e.toBuffer(),t.toBuffer(),Buffer.from(n===6?"farmer_info_associated_seed":"staker_info_v2_associated_seed","utf-8")],d);return o}var vu=({programId:d,poolId:e})=>ce([e.toBuffer()],d);function Fu(d){return{isSet:new Ym(1),rewardPerSecond:te(d.perSecond),rewardOpenTime:te(d.openTime),rewardEndTime:te(d.endTime),rewardType:te(Mn[d.rewardType])}}function Os(d){return te(d.endTime).sub(te(d.openTime)).mul(te(d.perSecond))}function $o(d){let e=Mu[d];return e||Qm.logWithError("invalid version",d),e}var jm=be("Raydium_farm_instruction"),gk={voterStakeRegistryCreateVoter:Buffer.from([6,24,245,52,243,255,148,25]),voterStakeRegistryCreateDepositEntry:Buffer.from([185,131,167,186,159,125,19,67]),voterStakeRegistryDeposit:Buffer.from([242,35,198,137,82,225,242,182]),voterStakeRegistryWithdraw:Buffer.from([183,18,70,156,148,109,161,34]),voterStakeRegistryUpdateVoterWeightRecord:Buffer.from([45,185,3,36,109,190,115,169])};function Jo(d){let{version:e,id:t,ledger:n,programId:o,owner:r}=d,i={3:9,5:10}[e];i||jm.logWithError(`invalid farm pool version: ${e}`);let s=Buffer.alloc(hs.span);hs.encode({instruction:i},s);let u=[S({pubkey:t}),S({pubkey:n}),S({pubkey:r,isWritable:!1}),S({pubkey:_u.programId,isWritable:!1}),S({pubkey:Hm,isWritable:!1})];return{instruction:new Vt({programId:o,keys:u,data:s}),instructionType:U.FarmV3CreateLedger}}function Eu(d){var n;let e=Buffer.alloc(Bs.span);Bs.encode({instruction:0,nonce:new Vu(d.nonce),rewardTimeInfo:d.rewardInfoConfig},e);let t=[...Hr,S({pubkey:d.farmId}),S({pubkey:d.farmAuthority,isWritable:!1}),S({pubkey:d.lpVault}),S({pubkey:d.lpMint,isWritable:!1}),S({pubkey:d.lockVault}),S({pubkey:d.lockMint,isWritable:!1}),S({pubkey:(n=d.lockUserAccount)!=null?n:et}),S({pubkey:d.owner,isWritable:!1,isSigner:!0})];for(let o of d.rewardInfo)t.push(S({pubkey:o.rewardMint,isWritable:!1}),S({pubkey:o.rewardVault}),S({pubkey:o.userRewardToken}));return{instruction:new Vt({programId:d.programId,keys:t,data:e}),instructionType:U.FarmV6Create}}function Wu(d){let e=Buffer.alloc(Is.span);Is.encode({instruction:5},e);let t=[S({pubkey:yn,isWritable:!1}),S({pubkey:d.id}),S({pubkey:d.authority,isWritable:!1}),S({pubkey:d.lpVault,isWritable:!1}),S({pubkey:d.rewardVault}),S({pubkey:d.userRewardToken}),S({pubkey:d.owner,isWritable:!1,isSigner:!0})];return{instruction:new Vt({programId:d.programId,keys:t,data:e}),instructionType:U.FarmV6CreatorWithdraw}}function Ns({payer:d,rewardVault:e,userRewardTokenPub:t,farmKeys:n,rewardInfo:o}){let r=Buffer.alloc(xs.span);xs.encode({instruction:3,rewardReopenTime:te(o.openTime),rewardEndTime:te(o.endTime),rewardPerSecond:te(o.perSecond)},r);let i=[S({pubkey:yn,isWritable:!1}),S({pubkey:n.id}),S({pubkey:n.lpVault,isWritable:!1}),S({pubkey:e}),S({pubkey:t}),S({pubkey:d,isWritable:!1,isSigner:!0})];return new Vt({programId:n.programId,keys:i,data:r})}function Ms({payer:d,userRewardTokenPub:e,farmKeys:t,rewardVault:n,rewardInfo:o}){let r=Buffer.alloc(Ss.span);Ss.encode({instruction:4,isSet:new Vu(1),rewardPerSecond:te(o.perSecond),rewardOpenTime:te(o.openTime),rewardEndTime:te(o.endTime),rewardType:te(Mn[o.rewardType])},r);let i=[...Hr,S({pubkey:t.id}),S({pubkey:t.authority,isWritable:!1}),S({pubkey:o.mint,isWritable:!1}),S({pubkey:n}),S({pubkey:e}),S({pubkey:d,isWritable:!1,isSigner:!0})];return new Vt({programId:t.programId,keys:i,data:r})}function ei(d){let{farmInfo:e,farmKeys:t,lpAccount:n,rewardAccounts:o,owner:r,amount:i}=d,[s,u]=[new ye(e.programId),new ye(e.id)],a=_t({programId:s,poolId:u,owner:r,version:6}),c=Buffer.alloc(Kt.span);Kt.encode({instruction:2,amount:te(i)},c);let l=[S({pubkey:yn,isWritable:!1}),S({pubkey:u}),S({pubkey:new ye(t.authority),isWritable:!1}),S({pubkey:new ye(t.lpVault)}),S({pubkey:a}),S({pubkey:r,isWritable:!1,isSigner:!0}),S({pubkey:n})];for(let m=0;m<t.rewardInfos.length;m++)l.push(S({pubkey:new ye(t.rewardInfos[m].vault)})),l.push(S({pubkey:o[m]}));return new Vt({programId:s,keys:l,data:c})}function ti(d){let{farmInfo:e,farmKeys:t,lpAccount:n,rewardAccounts:o,owner:r,amount:i,userAuxiliaryLedgers:s}=d,[u,a]=[new ye(e.programId),new ye(e.id)],c=_t({programId:u,poolId:a,owner:r,version:5}),l=Buffer.alloc(Kt.span);Kt.encode({instruction:12,amount:te(i)},l);let m=[S({pubkey:a}),S({pubkey:new ye(t.authority),isWritable:!1}),S({pubkey:c}),S({pubkey:r,isWritable:!1,isSigner:!0}),S({pubkey:n}),S({pubkey:new ye(t.lpVault)}),S({pubkey:o[0]}),S({pubkey:new ye(t.rewardInfos[0].vault)}),S({pubkey:Zo,isWritable:!1}),S({pubkey:yn,isWritable:!1})];for(let p=1;p<t.rewardInfos.length;p++)m.push(S({pubkey:o[p]})),m.push(S({pubkey:new ye(t.rewardInfos[p].vault)}));if(s)for(let p of s)m.push(S({pubkey:p}));return new Vt({programId:u,keys:m,data:l})}function Du(d){let{farmInfo:e,farmKeys:t,lpAccount:n,rewardAccounts:o,owner:r,amount:i,userAuxiliaryLedgers:s}=d,[u,a]=[new ye(e.programId),new ye(e.id)],c=F([V("instruction"),A("amount")]),l=[S({pubkey:a}),S({pubkey:new ye(t.authority),isWritable:!1}),S({pubkey:s[0]}),S({pubkey:r,isSigner:!0,isWritable:!1}),S({pubkey:n}),S({pubkey:new ye(t.lpVault)}),S({pubkey:o[0]}),S({pubkey:new ye(t.rewardInfos[0].vault)}),S({pubkey:Zo,isWritable:!1}),S({pubkey:yn,isWritable:!1}),S({pubkey:o[1]}),S({pubkey:new ye(t.rewardInfos[1].vault)})],m=Buffer.alloc(c.span);return c.encode({instruction:2,amount:i},m),new Vt({keys:l,programId:u,data:m})}function ni(d){let{farmInfo:e,farmKeys:t,lpAccount:n,rewardAccounts:o,owner:r,amount:i,userAuxiliaryLedgers:s}=d,[u,a]=[new ye(e.programId),new ye(e.id)],c=_t({programId:u,poolId:a,owner:r,version:3}),l=Buffer.alloc(Kt.span);Kt.encode({instruction:11,amount:te(i)},l);let m=[S({pubkey:a}),S({pubkey:new ye(t.authority),isWritable:!1}),S({pubkey:c}),S({pubkey:r,isWritable:!1,isSigner:!0}),S({pubkey:n}),S({pubkey:new ye(t.lpVault)}),S({pubkey:o[0]}),S({pubkey:new ye(t.rewardInfos[0].vault)}),S({pubkey:Zo,isWritable:!1}),S({pubkey:yn,isWritable:!1})];if(s)for(let p of s)m.push(S({pubkey:p}));return new Vt({programId:u,keys:m,data:l})}function qu(d){let{farmInfo:e,farmKeys:t,lpAccount:n,rewardAccounts:o,owner:r,amount:i,userAuxiliaryLedgers:s}=d,[u,a]=[new ye(e.programId),new ye(e.id)],c=_t({programId:u,poolId:a,owner:r,version:3}),l=Buffer.alloc(Kt.span);Kt.encode({instruction:10,amount:te(i)},l);let m=[S({pubkey:a}),S({pubkey:new ye(t.authority),isWritable:!1}),S({pubkey:c}),S({pubkey:r,isWritable:!1,isSigner:!0}),S({pubkey:n}),S({pubkey:new ye(t.lpVault)}),S({pubkey:o[0]}),S({pubkey:new ye(t.rewardInfos[0].vault)}),S({pubkey:Zo,isWritable:!1}),S({pubkey:yn,isWritable:!1})];if(s)for(let p of s)m.push(S({pubkey:p}));return new Vt({programId:u,keys:m,data:l})}function Uu(d){let{farmInfo:e,farmKeys:t,lpAccount:n,rewardAccounts:o,owner:r,amount:i,userAuxiliaryLedgers:s}=d,[u,a]=[new ye(e.programId),new ye(e.id)],c=_t({programId:u,poolId:a,owner:r,version:5}),l=Buffer.alloc(Kt.span);Kt.encode({instruction:11,amount:te(i)},l);let m=[S({pubkey:a}),S({pubkey:new ye(t.authority),isWritable:!1}),S({pubkey:c}),S({pubkey:r,isWritable:!1,isSigner:!0}),S({pubkey:n}),S({pubkey:new ye(t.lpVault)}),S({pubkey:o[0]}),S({pubkey:new ye(t.rewardInfos[0].vault)}),S({pubkey:Zo,isWritable:!1}),S({pubkey:yn,isWritable:!1})];for(let p=1;p<t.rewardInfos.length;p++)m.push(S({pubkey:o[p]})),m.push(S({pubkey:new ye(t.rewardInfos[p].vault)}));if(s)for(let p of s)m.push(S({pubkey:p}));return new Vt({programId:u,keys:m,data:l})}function Gu(d){let{farmInfo:e,farmKeys:t,lpAccount:n,rewardAccounts:o,owner:r,amount:i}=d,[s,u]=[new ye(e.programId),new ye(e.id)],a=_t({programId:s,poolId:u,owner:r,version:6}),c=Buffer.alloc(Kt.span);Kt.encode({instruction:1,amount:te(i)},c);let l=[S({pubkey:yn,isWritable:!1}),S({pubkey:_u.programId,isWritable:!1}),S({pubkey:u}),S({pubkey:new ye(t.authority),isWritable:!1}),S({pubkey:new ye(t.lpVault)}),S({pubkey:a}),S({pubkey:r,isWritable:!1,isSigner:!0}),S({pubkey:n})];for(let m=0;m<t.rewardInfos.length;m++)l.push(S({pubkey:new ye(t.rewardInfos[m].vault)})),l.push(S({pubkey:o[m]}));return new Vt({programId:s,keys:l,data:c})}var oi=class extends _e{async _getUserRewardInfo({payer:e,rewardInfo:t}){if(t.mint.equals(et)){let n=await On({connection:this.scope.connection,owner:this.scope.ownerPubKey,payer:e,amount:Os(D(v({},t),{openTime:t.openTime.toString(),endTime:t.endTime.toString()}))});return{rewardPubKey:n.addresses.newAccount,newInstruction:n}}return{rewardPubKey:await this.scope.account.getCreatedTokenAccount({mint:t.mint,associatedOnly:!1})}}async create({poolInfo:e,rewardInfos:t,payer:n,programId:o=qo,txVersion:r,feePayer:i,lockProgram:s}){var x,B;this.checkDisabled(),this.scope.checkOwner();let a={lpMint:new Be(e.lpMint.address),lockInfo:{lockMint:(x=s==null?void 0:s.mint)!=null?x:Ou,lockVault:(B=s==null?void 0:s.vault)!=null?B:Nu},version:6,rewardInfos:t,programId:o},c=this.createTxBuilder(i),l=n!=null?n:this.scope.ownerPubKey,m=Ye({fromPublicKey:l,programId:a.programId}),p=await this.scope.connection.getMinimumBalanceForRentExemption(mr.span);c.addInstruction({instructions:[$m.createAccountWithSeed({fromPubkey:l,basePubkey:l,seed:m.seed,newAccountPubkey:m.publicKey,lamports:p,space:mr.span,programId:a.programId})]});let{publicKey:f,nonce:y}=vu({programId:new Be(a.programId),poolId:m.publicKey}),b=jo({programId:a.programId,poolId:m.publicKey,mint:a.lpMint,type:"lpVault"}),g=[],P=[];for(let K of a.rewardInfos){K.openTime>=K.endTime&&this.logAndCreateError("start time error","rewardInfo.rewardOpenTime",K.openTime.toString()),isNaN(Mn[K.rewardType])&&this.logAndCreateError("rewardType error",K.rewardType),Number(K.perSecond)<=0&&this.logAndCreateError("rewardPerSecond error",K.perSecond),g.push(Fu(K));let{rewardPubKey:I,newInstruction:R}=await this._getUserRewardInfo({rewardInfo:K,payer:l});R&&c.addInstruction(R),I||this.logAndCreateError("cannot found target token accounts",this.scope.account.tokenAccounts);let C=K.mint.equals(et)?new Be(lt.address):K.mint;P.push({rewardMint:C,rewardVault:jo({programId:a.programId,poolId:m.publicKey,mint:C,type:"rewardVault"}),userRewardToken:I})}let{account:T,instructionParams:h}=await this.scope.account.getOrCreateTokenAccount({mint:new Be(a.lockInfo.lockMint),owner:this.scope.ownerPubKey,skipCloseAccount:!1,createInfo:{payer:this.scope.ownerPubKey,amount:0},associatedOnly:!1});h&&c.addInstruction(h),T||this.logAndCreateError("cannot found lock vault","tokenAccounts",this.scope.account.tokenAccounts);let{instruction:w,instructionType:k}=Eu({farmId:m.publicKey,owner:this.scope.ownerPubKey,farmAuthority:f,lpVault:b,lpMint:a.lpMint,lockVault:a.lockInfo.lockVault,lockMint:a.lockInfo.lockMint,lockUserAccount:T,programId:a.programId,rewardInfo:P,rewardInfoConfig:g,nonce:y});return c.addInstruction({instructions:[w],instructionTypes:[k]}).versionBuild({txVersion:r,extInfo:{farmId:m.publicKey,farmAuthority:f,lpVault:b,lockUserAccount:T,nonce:y}})}async restartReward({farmInfo:e,payer:t,newRewardInfo:n,txVersion:o,feePayer:r}){var g;let i=Ft[e.programId];i!==6&&this.logAndCreateError("invalid farm version ",i);let s=rt((await this.scope.api.fetchFarmKeysById({ids:e.id}))[0]),u={id:s.id,rewardInfos:e.rewardInfos,lpVault:s.lpVault,programId:s.programId};n.openTime>=n.endTime&&this.logAndCreateError("start time error","newRewardInfo",n);let a=t||this.scope.ownerPubKey,c=n.mint.equals(et)?new Be(lt.address):n.mint,l=u.rewardInfos.findIndex(P=>new Be(P.mint.address).equals(c)),m=s.rewardInfos[l];m||this.logAndCreateError("configuration does not exist","rewardMint",c);let p=(g=m.vault)!=null?g:et,f=this.createTxBuilder(r),{rewardPubKey:y,newInstruction:b}=await this._getUserRewardInfo({rewardInfo:n,payer:a});return b&&f.addInstruction(b),y||this.logAndCreateError("cannot found target token accounts",this.scope.account.tokenAccounts),f.addInstruction({instructions:[Ns({payer:this.scope.ownerPubKey,rewardVault:p,userRewardTokenPub:y,farmKeys:u,rewardInfo:n})],instructionTypes:[U.FarmV6Restart]}).versionBuild({txVersion:o})}async restartRewards({farmInfo:e,payer:t,newRewardInfos:n,txVersion:o,feePayer:r}){var l;let i=Ft[e.programId];i!==6&&this.logAndCreateError("invalid farm version ",i);let s=rt((await this.scope.api.fetchFarmKeysById({ids:e.id}))[0]),u={id:s.id,rewardInfos:e.rewardInfos,lpVault:s.lpVault,programId:s.programId};n.forEach(m=>{m.openTime>=m.endTime&&this.logAndCreateError("start time error","newRewardInfo",m)});let a=t||this.scope.ownerPubKey,c=this.createTxBuilder(r);for(let m of n){let p=m.mint.equals(et)?new Be(lt.address):m.mint,f=u.rewardInfos.findIndex(h=>new Be(h.mint.address).equals(p)),y=s.rewardInfos[f];y||this.logAndCreateError("configuration does not exist","rewardMint",p);let b=(l=y.vault)!=null?l:et,{rewardPubKey:g,newInstruction:P}=await this._getUserRewardInfo({rewardInfo:m,payer:a});P&&c.addInstruction(P),g||this.logAndCreateError("cannot found target token accounts",this.scope.account.tokenAccounts);let T=Ns({payer:this.scope.ownerPubKey,rewardVault:b,userRewardTokenPub:g,farmKeys:u,rewardInfo:m});c.addInstruction({instructions:[T],instructionTypes:[U.FarmV6Restart]})}return c.versionBuild({txVersion:o})}async addNewRewardToken(e){let{txVersion:t,farmInfo:n,newRewardInfo:o,payer:r,feePayer:i}=e,s=Ft[n.programId];s!==6&&this.logAndCreateError("invalid farm version ",s);let u=rt((await this.scope.api.fetchFarmKeysById({ids:n.id}))[0]),a=r!=null?r:this.scope.ownerPubKey,c=this.createTxBuilder(i),l=o.mint.equals(et)?new Be(lt.address):o.mint,m=jo({programId:new Be(n.programId),poolId:new Be(n.id),mint:l,type:"rewardVault"}),{rewardPubKey:p,newInstruction:f}=await this._getUserRewardInfo({rewardInfo:o,payer:a});return f&&c.addInstruction(f),p||this.logAndCreateError("annot found target token accounts",this.scope.account.tokenAccounts),o.mint=l,c.addInstruction({instructions:[Ms({payer:this.scope.ownerPubKey,userRewardTokenPub:p,farmKeys:u,rewardVault:m,rewardInfo:o})],instructionTypes:[U.FarmV6CreatorAddReward]}).versionBuild({txVersion:t})}async addNewRewardsToken(e){let{txVersion:t,farmInfo:n,newRewardInfos:o,payer:r,feePayer:i}=e,s=Ft[n.programId];s!==6&&this.logAndCreateError("invalid farm version ",s);let u=rt((await this.scope.api.fetchFarmKeysById({ids:n.id}))[0]),a=r!=null?r:this.scope.ownerPubKey,c=this.createTxBuilder(i);for(let l of o){let m=l.mint.equals(et)?new Be(lt.address):l.mint,p=jo({programId:new Be(n.programId),poolId:new Be(n.id),mint:m,type:"rewardVault"}),{rewardPubKey:f,newInstruction:y}=await this._getUserRewardInfo({rewardInfo:l,payer:a});y&&c.addInstruction(y),f||this.logAndCreateError("cannot found target token accounts",this.scope.account.tokenAccounts);let b=Ms({payer:this.scope.ownerPubKey,userRewardTokenPub:f,farmKeys:u,rewardVault:p,rewardInfo:D(v({},l),{mint:m})});c.addInstruction({instructions:[b],instructionTypes:[U.FarmV6CreatorAddReward]})}return c.versionBuild({txVersion:t})}async deposit(e){let{txVersion:t,farmInfo:n,amount:o,feePayer:r,useSOLBalance:i,associatedOnly:s=!0,checkCreateATAOwner:u=!1,userAuxiliaryLedgers:a,computeBudgetConfig:c,txTipConfig:l}=e;this.scope.availability.addFarm===!1&&this.logAndCreateError("farm deposit feature disabled in your region");let{rewardInfos:m,programId:p}=n,f=Ft[p];f===4&&this.logAndCreateError("V4 has suspended deposits:",n.programId),Rs(f)||this.logAndCreateError("invalid farm program:",n.programId);let[y,b]=[new Be(n.programId),new Be(n.id)],g=(await this.scope.api.fetchFarmKeysById({ids:n.id}))[0],P=_t({programId:y,poolId:b,owner:this.scope.ownerPubKey,version:f}),T=this.createTxBuilder(r);T.addCustomComputeBudget(c),T.addTipInstruction(l);let h={};for(let L of this.scope.account.tokenAccounts)if(s){let O=Z(this.scope.ownerPubKey,L.mint,L.programId).publicKey;L.publicKey&&O.equals(L.publicKey)&&(h[L.mint.toString()]=L.publicKey)}else h[L.mint.toString()]=L.publicKey;let w=g.lpMint,k=h[w.address];k||this.logAndCreateError("you don't have any lp","lp zero",h);let x=[];for(let L of m){let O=i&&L.mint.address===j.toString(),_=h[L.mint.address];if(!_){let{account:G,instructionParams:z}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:L.mint.programId,mint:new Be(L.mint.address),notUseTokenAccount:O,createInfo:{payer:r||this.scope.ownerPubKey,amount:0},owner:this.scope.ownerPubKey,skipCloseAccount:!O,associatedOnly:O?!1:s,checkCreateATAOwner:u});_=G,z&&T.addInstruction(z)}h[L.mint.address]=_,x.push(_)}let B,K=await this.scope.connection.getAccountInfo(P);if(K&&(B=$o(f).decode(K.data)),n.programId!==qo.toString()&&n.programId!==mn.FARM_PROGRAM_ID_V6.toString()&&!B){let{instruction:L,instructionType:O}=Jo({id:b,programId:y,version:f,ledger:P,owner:this.scope.ownerPubKey});T.addInstruction({instructions:[L],instructionTypes:[O]})}let I=Ls({version:f,rewardInfos:m,rewardTokenAccountsPublicKeys:x});I&&this.logAndCreateError(I);let R={amount:te(o),owner:this.scope.ownerPubKey,farmInfo:n,farmKeys:g,lpAccount:k,rewardAccounts:x,userAuxiliaryLedgers:a==null?void 0:a.map(L=>new Be(L))},C=f===6?Gu(R):f===5?Uu(R):qu(R),N={3:U.FarmV3Deposit,5:U.FarmV5Deposit,6:U.FarmV6Deposit};return T.addInstruction({instructions:[C],instructionTypes:[N[f]]}).versionBuild({txVersion:t})}async withdraw(e){let{txVersion:t,farmInfo:n,amount:o,deposited:r,useSOLBalance:i,feePayer:s,associatedOnly:u=!0,checkCreateATAOwner:a=!1,userAuxiliaryLedgers:c,computeBudgetConfig:l,txTipConfig:m}=e,{rewardInfos:p}=n;this.scope.availability.removeFarm===!1&&this.logAndCreateError("farm withdraw feature disabled in your region");let f=Ft[n.programId];Rs(f)||this.logAndCreateError("invalid farm program:",n.programId);let y=(await this.scope.api.fetchFarmKeysById({ids:n.id}))[0],b=this.createTxBuilder(s);b.addCustomComputeBudget(l),b.addTipInstruction(m);let g={};for(let I of this.scope.account.tokenAccounts)if(u){let R=Z(this.scope.ownerPubKey,I.mint).publicKey;I.publicKey&&R.equals(I.publicKey)&&(g[I.mint.toString()]=I.publicKey)}else g[I.mint.toString()]=I.publicKey;if(f!==4){let I=_t({programId:new Be(n.programId),poolId:new Be(n.id),owner:this.scope.ownerPubKey,version:f}),R=await this.scope.connection.getAccountInfo(I);if(R)$o(f).decode(R.data).deposited.isZero()&&this.logAndCreateError("no deposited lp",{farmId:n.id});else if(f!==6){let{instruction:C,instructionType:N}=Jo({id:new Be(y.id),programId:new Be(y.programId),version:f,ledger:I,owner:this.scope.ownerPubKey});b.addInstruction({instructions:[C],instructionTypes:[N]})}}r&&r.isZero()&&!(c||[]).length&&this.logAndCreateError("no deposited lp",{farmId:n.id});let P=y.lpMint.address,T=i&&P===j.toString(),h=g[P.toString()];if(!h){let{account:I,instructionParams:R}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:y.lpMint.programId,mint:new Be(P),notUseTokenAccount:T,createInfo:{payer:s||this.scope.ownerPubKey,amount:0},owner:this.scope.ownerPubKey,skipCloseAccount:!0,associatedOnly:T?!1:u,checkCreateATAOwner:a});h=I,R&&b.addInstruction(R)}g[P.toString()]=h;let w=[];for(let I of p){let R=i&&I.mint.address===j.toString(),C=g[I.mint.address];if(!C){let{account:N,instructionParams:L}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:I.mint.programId,mint:new Be(I.mint.address),notUseTokenAccount:R,createInfo:{payer:s||this.scope.ownerPubKey,amount:0},owner:this.scope.ownerPubKey,skipCloseAccount:!R,associatedOnly:R?!1:u,checkCreateATAOwner:a});C=N,L&&b.addInstruction(L)}g[I.mint.address]=C,w.push(C)}let k=Ls({version:f,rewardInfos:p,rewardTokenAccountsPublicKeys:w});k&&this.logAndCreateError(k);let x={amount:te(o),owner:this.scope.ownerPubKey,farmInfo:n,farmKeys:y,lpAccount:h,rewardAccounts:w,userAuxiliaryLedgers:c==null?void 0:c.map(I=>new Be(I))},B=f===6?ei(x):f===5?ti(x):f===4?Du(x):ni(x),K={3:U.FarmV3Withdraw,4:U.FarmV4Withdraw,5:U.FarmV5Withdraw,6:U.FarmV6Withdraw};return b.addInstruction({instructions:[B],instructionTypes:[K[f]]}).versionBuild({txVersion:t})}async withdrawFarmReward({farmInfo:e,withdrawMint:t,txVersion:n,computeBudgetConfig:o,txTipConfig:r,feePayer:i}){var y;this.scope.checkOwner();let s=rt((await this.scope.api.fetchFarmKeysById({ids:e.id}))[0]),u=Ft[e.programId];u!==6&&this.logAndCreateError("invalid farm version",u);let a=s.rewardInfos.find(b=>ct(b.mint.address).equals(ct(t)));a||this.logAndCreateError("withdraw mint error","rewardInfos",e);let c=(y=a==null?void 0:a.vault)!=null?y:et,l=this.createTxBuilder(i),m;if(t.equals(et)||t.equals(Be.default)){let b=await On({connection:this.scope.connection,owner:this.scope.ownerPubKey,payer:this.scope.ownerPubKey,amount:Os(D(v({},a),{openTime:a.openTime,endTime:a.endTime,perSecond:new Zm(a.perSecond).mul(10**a.mint.decimals).toString()}))});m=b.addresses.newAccount,l.addInstruction(b)}else{let b=await this.scope.account.getCreatedTokenAccount({mint:t});b===null?(m=await this.scope.account.getAssociatedTokenAccount(t),l.addInstruction({instructions:[Xu(this.scope.ownerPubKey,m,this.scope.ownerPubKey,t)],instructionTypes:[U.CreateATA]})):m=b}let{instruction:p,instructionType:f}=Wu({programId:s.programId,id:s.id,authority:s.authority,lpVault:s.lpVault,rewardVault:c,userRewardToken:m,owner:this.scope.ownerPubKey});return l.addCustomComputeBudget(o),l.addTipInstruction(r),l.addInstruction({instructions:[p],instructionTypes:[f]}).versionBuild({txVersion:n})}async harvestAllRewards(e){let{farmInfoList:t,useSOLBalance:n,feePayer:o,associatedOnly:r=!0,checkCreateATAOwner:i=!1,userAuxiliaryLedgers:s,txVersion:u,computeBudgetConfig:a}=e,c=this.createTxBuilder(o),l={};for(let f of this.scope.account.tokenAccounts)if(r){let y=Z(this.scope.ownerPubKey,f.mint).publicKey;f.publicKey&&y.equals(f.publicKey)&&(l[f.mint.toString()]=f.publicKey)}else l[f.mint.toString()]=f.publicKey;let p=(await this.scope.api.fetchFarmKeysById({ids:Object.values(t).map(f=>f.id).join(",")})).reduce((f,y)=>D(v({},f),{[y.id]:y}),{});for(let f of Object.values(t)){let{programId:y,lpMint:b,rewardInfos:g,id:P}=f,T=Ft[y],h=b.address,w=n&&h===j.toString(),k=l[h];if(!k){let{account:C,instructionParams:N}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:b.programId,mint:new Be(h),notUseTokenAccount:w,createInfo:{payer:o||this.scope.ownerPubKey,amount:0},owner:this.scope.ownerPubKey,skipCloseAccount:!0,associatedOnly:w?!1:r,checkCreateATAOwner:i});k=C,N&&c.addInstruction(N)}l[h.toString()]=k;let x=[];for(let C of g){let N=n&&C.mint.address===j.toString(),L=l[C.mint.address];if(!L)if(N){let{account:O,instructionParams:_}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:C.mint.programId,mint:new Be(C.mint.address),notUseTokenAccount:N,createInfo:{payer:o||this.scope.ownerPubKey,amount:0},owner:this.scope.ownerPubKey,skipCloseAccount:!N,associatedOnly:N?!1:r,checkCreateATAOwner:i});L=O,_&&c.addInstruction(_)}else{let O=new Be(C.mint.address);L=this.scope.account.getAssociatedTokenAccount(O),c.addInstruction({instructions:[Xu(this.scope.ownerPubKey,L,this.scope.ownerPubKey,O)]})}l[C.mint.address]=L,x.push(L)}let B=p[P],K={amount:kt,owner:this.scope.ownerPubKey,farmInfo:f,farmKeys:B,lpAccount:k,rewardAccounts:x,userAuxiliaryLedgers:s==null?void 0:s.map(C=>new Be(C))},I=T===6?ei(K):T===5?ti(K):ni(K),R={3:U.FarmV3Withdraw,5:U.FarmV5Withdraw,6:U.FarmV6Withdraw};c.addInstruction({instructions:[I],instructionTypes:[R[T]]})}return u===1?c.sizeCheckBuild({computeBudgetConfig:a}):c.sizeCheckBuildV0({computeBudgetConfig:a})}};import{PublicKey as je}from"@solana/web3.js";import{AccountLayout as Ed,NATIVE_MINT as Br,TOKEN_PROGRAM_ID as Fn}from"@solana/spl-token";import{Keypair as gr,PublicKey as X,SystemProgram as An,TransactionInstruction as st}from"@solana/web3.js";import zs from"bn.js";import{ASSOCIATED_TOKEN_PROGRAM_ID as mi,TOKEN_2022_PROGRAM_ID as Xe,TOKEN_PROGRAM_ID as Ke}from"@solana/spl-token";import ud from"bn.js";import Bo from"decimal.js";import Et from"bn.js";var Ue=new Et(0),Ct=new Et(1),bn=new Et(-1),Ze=new Et(1).shln(64),dr=new Et(1).shln(128),ii=Ze.sub(Ct),ri=64,zu=dr.subn(1),dt=-443636,yt=-dt,Wt=new Et("4295048016"),Dt=new Et("79226673521066979257578248091"),pr=new Et("4295048017"),fr=new Et("79226673521066979257578248090"),Yu=16,Qu="59543866431248",Hu="184467440737095516",ju="15793534762490258745",yr=new Et(10).pow(new Et(6));var $u={tvl:0,volumeQuote:0,mintAmountA:0,mintAmountB:0,rewardDefaultInfos:[],farmUpcomingCount:0,farmOngoingCount:0,farmFinishedCount:0,day:{volume:0,volumeQuote:0,volumeFee:0,apr:0,feeApr:0,priceMin:0,priceMax:0,rewardApr:[0]},week:{volume:0,volumeQuote:0,volumeFee:0,apr:0,feeApr:0,priceMin:0,priceMax:0,rewardApr:[0]},month:{volume:0,volumeQuote:0,volumeFee:0,apr:0,feeApr:0,priceMin:0,priceMax:0,rewardApr:[0]},pooltype:[]},Qk=new Et("18446744073700000000");import pe from"bn.js";import an from"decimal.js";function br(d){let e=new ArrayBuffer(4);return new DataView(e).setInt32(0,d,!1),new Uint8Array(e)}function vs(d,e){let t=0;for(let n=d-1;n>=0&&!e.testn(n);n--)t++;return t}function Fs(d,e){let t=0;for(let n=0;n<d&&!e.testn(n);n++)t++;return t}function si(d,e){for(let t=0;t<d;t++)if(e.testn(t))return!1;return!0}function Zu(d,e){return si(d,e)?null:vs(d,e)}function Ju(d,e){return si(d,e)?null:Fs(d,e)}var Jk=Buffer.from("amm_config","utf8"),_s=Buffer.from("pool","utf8"),Vs=Buffer.from("pool_vault","utf8"),ed=Buffer.from("pool_reward_vault","utf8"),ec=Buffer.from("position","utf8"),td=Buffer.from("tick_array","utf8"),nd=Buffer.from("operation","utf8"),od=Buffer.from("pool_tick_array_bitmap_extension","utf8"),id=Buffer.from("observation","utf8");function tc(d,e,t,n){return ce([_s,e.toBuffer(),t.toBuffer(),n.toBuffer()],d)}function Es(d,e,t){return ce([Vs,e.toBuffer(),t.toBuffer()],d)}function nc(d,e,t){return ce([ed,e.toBuffer(),t.toBuffer()],d)}function ge(d,e,t){return ce([td,e.toBuffer(),br(t)],d)}function Jt(d,e,t,n){return ce([ec,e.toBuffer(),br(t),br(n)],d)}function bt(d,e){return ce([ec,e.toBuffer()],d)}function gn(d){return ce([Buffer.from("metadata","utf8"),jt.toBuffer(),d.toBuffer()],jt)}function ai(d){return ce([nd],d)}function Qe(d,e){return ce([od,e.toBuffer()],d)}function oc(d,e){return ce([id,e.toBuffer()],d)}var ic=Buffer.from("locked_position","utf8");function Ws(d,e){return ce([ic,e.toBuffer()],d)}function ho(d,e){return ce([ic,e.toBuffer()],d)}var rd=Buffer.from("support_mint","utf8");function Ds(d,e){return ce([rd,e.toBuffer()],d)}import{PublicKey as Rt}from"@solana/web3.js";import{TOKEN_2022_PROGRAM_ID as rc}from"@solana/spl-token";import Ee from"bn.js";import Ae from"decimal.js";import sn from"bn.js";import qs from"decimal.js";var ui=class{static getfeeGrowthInside(e,t,n){let o=new sn(0),r=new sn(0);e.tickCurrent>=t.tick?(o=t.feeGrowthOutsideX64A,r=t.feeGrowthOutsideX64B):(o=e.feeGrowthGlobalX64A.sub(t.feeGrowthOutsideX64A),r=e.feeGrowthGlobalX64B.sub(t.feeGrowthOutsideX64B));let i=new sn(0),s=new sn(0);e.tickCurrent<n.tick?(i=n.feeGrowthOutsideX64A,s=n.feeGrowthOutsideX64B):(i=e.feeGrowthGlobalX64A.sub(n.feeGrowthOutsideX64A),s=e.feeGrowthGlobalX64B.sub(n.feeGrowthOutsideX64B));let u=le.wrappingSubU128(le.wrappingSubU128(e.feeGrowthGlobalX64A,o),i),a=le.wrappingSubU128(le.wrappingSubU128(e.feeGrowthGlobalX64B,r),s);return{feeGrowthInsideX64A:u,feeGrowthInsideBX64:a}}static GetPositionFees(e,t,n,o){let{feeGrowthInsideX64A:r,feeGrowthInsideBX64:i}=this.getfeeGrowthInside(e,n,o),s=le.mulDivFloor(le.wrappingSubU128(r,t.feeGrowthInsideLastX64A),t.liquidity,Ze),u=t.tokenFeesOwedA.add(s),a=le.mulDivFloor(le.wrappingSubU128(i,t.feeGrowthInsideLastX64B),t.liquidity,Ze),c=t.tokenFeesOwedB.add(a);return{tokenFeeAmountA:u,tokenFeeAmountB:c}}static GetPositionFeesV2(e,t,n,o){let{feeGrowthInsideX64A:r,feeGrowthInsideBX64:i}=this.getfeeGrowthInside(e,n,o),s=le.mulDivFloor(le.wrappingSubU128(r,t.feeGrowthInsideLastX64A),t.liquidity,Ze),u=t.tokenFeesOwedA.add(s),a=le.mulDivFloor(le.wrappingSubU128(i,t.feeGrowthInsideLastX64B),t.liquidity,Ze),c=t.tokenFeesOwedB.add(a);return{tokenFeeAmountA:u,tokenFeeAmountB:c}}static GetPositionRewardsV2(e,t,n,o){let r=[],i=this.getRewardGrowthInsideV2(e.tickCurrent,n,o,e.rewardInfos);for(let s=0;s<i.length;s++){let u=i[s],a=t.rewardInfos[s],c=le.wrappingSubU128(u,a.growthInsideLastX64),l=le.mulDivFloor(c,t.liquidity,Ze),m=a.rewardAmountOwed.add(l);r.push(m)}return r}static GetPositionRewards(e,t,n,o){let r=[],i=this.getRewardGrowthInside(e.tickCurrent,n,o,e.rewardInfos);for(let s=0;s<i.length;s++){let u=i[s],a=t.rewardInfos[s],c=le.wrappingSubU128(u,a.growthInsideLastX64),l=le.mulDivFloor(c,t.liquidity,Ze),m=a.rewardAmountOwed.add(l);r.push(m)}return r}static getRewardGrowthInside(e,t,n,o){let r=[];for(let i=0;i<o.length;i++){let s=new sn(0);t.liquidityGross.eqn(0)?s=o[i].rewardGrowthGlobalX64:e<t.tick?s=o[i].rewardGrowthGlobalX64.sub(t.rewardGrowthsOutsideX64[i]):s=t.rewardGrowthsOutsideX64[i];let u=new sn(0);n.liquidityGross.eqn(0)||(e<n.tick?u=n.rewardGrowthsOutsideX64[i]:u=o[i].rewardGrowthGlobalX64.sub(n.rewardGrowthsOutsideX64[i])),r.push(le.wrappingSubU128(le.wrappingSubU128(o[i].rewardGrowthGlobalX64,s),u))}return r}static getRewardGrowthInsideV2(e,t,n,o){let r=[];for(let i=0;i<o.length;i++){let s=new sn(0);t.liquidityGross.eqn(0)?s=o[i].rewardGrowthGlobalX64:e<t.tick?s=o[i].rewardGrowthGlobalX64.sub(t.rewardGrowthsOutsideX64[i]):s=t.rewardGrowthsOutsideX64[i];let u=new sn(0);n.liquidityGross.eqn(0)||(e<n.tick?u=n.rewardGrowthsOutsideX64[i]:u=o[i].rewardGrowthGlobalX64.sub(n.rewardGrowthsOutsideX64[i])),r.push(le.wrappingSubU128(le.wrappingSubU128(o[i].rewardGrowthGlobalX64,s),u))}return r}static getAmountsFromLiquidity({poolInfo:e,ownerPosition:t,liquidity:n,slippage:o,add:r,epochInfo:i}){var b,g,P,T;let s=ue.priceToSqrtPriceX64(new qs(e.price),e.mintA.decimals,e.mintB.decimals),u=ue.getSqrtPriceX64FromTick(t.tickLower),a=ue.getSqrtPriceX64FromTick(t.tickUpper),c=r?1+o:1-o,l=ke.getAmountsFromLiquidity(s,u,a,n,r),[m,p]=[Se(l.amountA,(b=e.mintA.extensions)==null?void 0:b.feeConfig,i,!0),Se(l.amountB,(g=e.mintB.extensions)==null?void 0:g.feeConfig,i,!0)],[f,y]=[Se(new sn(new qs(l.amountA.toString()).mul(c).toFixed(0)),(P=e.mintA.extensions)==null?void 0:P.feeConfig,i,!0),Se(new sn(new qs(l.amountB.toString()).mul(c).toFixed(0)),(T=e.mintB.extensions)==null?void 0:T.feeConfig,i,!0)];return{liquidity:n,amountA:m,amountB:p,amountSlippageA:f,amountSlippageB:y,expirationTime:$t(m.expirationTime,p.expirationTime)}}};var sd=15,Pe=class{static async getTickArrays(e,t,n,o,r,i,s){let u=[],a=$.getTickArrayStartIndexByTick(o,r),c=$.getInitializedTickArrayInRange(i,s,r,a,Math.floor(sd/2));for(let p=0;p<c.length;p++){let{publicKey:f}=ge(t,n,c[p]);u.push(f)}let l=(await Ht(e,u)).map(p=>p!==null?ci.decode(p.data):null),m={};for(let p=0;p<u.length;p++){let f=l[p];f!==null&&(m[f.startTickIndex]=D(v({},f),{address:u[p]}))}return m}static nextInitializedTick(e,t,n,o,r,i){let{initializedTick:s,tickArrayAddress:u,tickArrayStartTickIndex:a}=this.nextInitializedTickInOneArray(e,t,n,o,r,i);for(;s==null||s.liquidityGross.lten(0);){if(a=$.getNextTickArrayStartIndex(a,r,i),this.checkIsValidStartIndex(a,r))throw new Error("No enough initialized tickArray");let c=n[a];if(c===void 0)continue;let{nextTick:l,tickArrayAddress:m,tickArrayStartTickIndex:p}=this.firstInitializedTickInOneArray(e,t,c,i);[s,u,a]=[l,m,p]}if(s==null)throw new Error("No invaild tickArray cache");return{nextTick:s,tickArrayAddress:u,tickArrayStartTickIndex:a}}static nextInitializedTickArray(e,t,n,o,r){let i=Math.floor(e/Pe.tickCount(t)),s=n?$.searchLowBitFromStart(o,r,i-1,1,t):$.searchHightBitFromStart(o,r,i+1,1,t);return s.length>0?{isExist:!0,nextStartIndex:s[0]}:{isExist:!1,nextStartIndex:0}}static firstInitializedTickInOneArray(e,t,n,o){let r;if(o){let s=Je-1;for(;s>=0;){let u=n.ticks[s];if(u.liquidityGross.gtn(0)){r=u;break}s=s-1}}else{let s=0;for(;s<Je;){let u=n.ticks[s];if(u.liquidityGross.gtn(0)){r=u;break}s=s+1}}let{publicKey:i}=ge(e,t,n.startTickIndex);return{nextTick:r,tickArrayAddress:i,tickArrayStartTickIndex:n.startTickIndex}}static nextInitializedTickInOneArray(e,t,n,o,r,i){let s=$.getTickArrayStartIndexByTick(o,r),u=Math.floor((o-s)/r),a=n[s];if(a==null)return{initializedTick:void 0,tickArrayAddress:void 0,tickArrayStartTickIndex:s};let c;if(i)for(;u>=0;){let m=a.ticks[u];if(m.liquidityGross.gtn(0)){c=m;break}u=u-1}else for(u=u+1;u<Je;){let m=a.ticks[u];if(m.liquidityGross.gtn(0)){c=m;break}u=u+1}let{publicKey:l}=ge(e,t,s);return{initializedTick:c,tickArrayAddress:l,tickArrayStartTickIndex:a.startTickIndex}}static getArrayStartIndex(e,t){let n=this.tickCount(t);return Math.floor(e/n)*n}static checkIsValidStartIndex(e,t){if($.checkIsOutOfBoundary(e)){if(e>yt)return!1;let n=$.getTickArrayStartIndexByTick(dt,t);return e==n}return e%this.tickCount(t)==0}static tickCount(e){return Je*e}};var Us=14,Pn=class{static maxTickInTickarrayBitmap(e){return e*Je*$n}static getBitmapTickBoundary(e,t){let n=this.maxTickInTickarrayBitmap(t),o=Math.floor(Math.abs(e)/n);e<0&&Math.abs(e)%n!=0&&(o+=1);let r=n*o;return e<0?{minValue:-r,maxValue:-r+n}:{minValue:r,maxValue:r+n}}static nextInitializedTickArrayStartIndex(e,t,n,o){if(!Pe.checkIsValidStartIndex(t,n))throw Error("nextInitializedTickArrayStartIndex check error");let r=this.maxTickInTickarrayBitmap(n),i=o?t-Pe.tickCount(n):t+Pe.tickCount(n);if(i<-r||i>=r)return{isInit:!1,tickIndex:t};let s=n*Je,u=i/s+512;i<0&&i%s!=0&&u--;let a=Math.abs(u);if(o){let c=e.shln(1024-a-1),l=Zu(1024,c);if(l!==null){let m=(a-l-512)*s;return{isInit:!0,tickIndex:m}}else return{isInit:!1,tickIndex:-r}}else{let c=e.shrn(a),l=Ju(1024,c);if(l!==null){let m=(a+l-512)*s;return{isInit:!0,tickIndex:m}}else return{isInit:!1,tickIndex:r-Pe.tickCount(n)}}}},li=class{static getBitmapOffset(e,t){if(!Pe.checkIsValidStartIndex(e,t))throw new Error("No enough initialized tickArray");this.checkExtensionBoundary(e,t);let n=Pn.maxTickInTickarrayBitmap(t),o=Math.floor(Math.abs(e)/n)-1;return e<0&&Math.abs(e)%n===0&&o--,o}static getBitmap(e,t,n){let o=this.getBitmapOffset(e,t);return e<0?{offset:o,tickarrayBitmap:n.negativeTickArrayBitmap[o]}:{offset:o,tickarrayBitmap:n.positiveTickArrayBitmap[o]}}static checkExtensionBoundary(e,t){let{positiveTickBoundary:n,negativeTickBoundary:o}=this.extensionTickBoundary(t);if(e>=o&&e<n)throw Error("checkExtensionBoundary -> InvalidTickArrayBoundary")}static extensionTickBoundary(e){let t=Pn.maxTickInTickarrayBitmap(e),n=-t;if(yt<=t)throw Error(`extensionTickBoundary check error: ${yt}, ${t}`);if(n<=dt)throw Error(`extensionTickBoundary check error: ${n}, ${dt}`);return{positiveTickBoundary:t,negativeTickBoundary:n}}static checkTickArrayIsInit(e,t,n){let{tickarrayBitmap:o}=this.getBitmap(e,t,n),r=this.tickArrayOffsetInBitmap(e,t);return{isInitialized:$.mergeTickArrayBitmap(o).testn(r),startIndex:e}}static nextInitializedTickArrayFromOneBitmap(e,t,n,o){let r=Pe.tickCount(t),i=n?e-r:e+r,{tickarrayBitmap:s}=this.getBitmap(i,t,o);return this.nextInitializedTickArrayInBitmap(s,i,t,n)}static nextInitializedTickArrayInBitmap(e,t,n,o){let{minValue:r,maxValue:i}=Pn.getBitmapTickBoundary(t,n),s=this.tickArrayOffsetInBitmap(t,n);if(o){let u=$.mergeTickArrayBitmap(e).shln($n-1-s),a=si(512,u)?null:vs(512,u);if(a!==null){let c=t-a*Pe.tickCount(n);return{isInit:!0,tickIndex:c}}else return{isInit:!1,tickIndex:r}}else{let u=$.mergeTickArrayBitmap(e).shrn(s),a=si(512,u)?null:Fs(512,u);if(a!==null){let c=t+a*Pe.tickCount(n);return{isInit:!0,tickIndex:c}}else return{isInit:!1,tickIndex:i-Pe.tickCount(n)}}}static tickArrayOffsetInBitmap(e,t){let n=Math.abs(e)%Pn.maxTickInTickarrayBitmap(t),o=Math.floor(n/Pe.tickCount(t));return e<0&&n!=0&&(o=$n-o),o}};var Ne=class{static getOutputAmountAndRemainAccounts(e,t,n,o,r,i=!1){let s=n.toBase58()===e.mintA.address,u=[],{isExist:a,startIndex:c,nextAccountMeta:l}=this.getFirstInitializedTickArray(e,s);if(!a||c===void 0||!l)throw new Error("Invalid tick array");u.push(l);let{allTrade:m,amountCalculated:p,accounts:f,sqrtPriceX64:y,feeAmount:b}=Zn.swapCompute(e.programId,e.id,t,e.tickArrayBitmap,e.exBitmapInfo,s,e.ammConfig.tradeFeeRate,e.liquidity,e.tickCurrent,e.tickSpacing,e.sqrtPriceX64,o,c,r,i);return u.push(...f),{allTrade:m,expectedAmountOut:p.mul(bn),remainingAccounts:u,executionPrice:y,feeAmount:b}}static getInputAmountAndRemainAccounts(e,t,n,o,r){let i=n.toBase58()===e.mintB.address,s=[],{isExist:u,startIndex:a,nextAccountMeta:c}=this.getFirstInitializedTickArray(e,i);if(!u||a===void 0||!c)throw new Error("Invalid tick array");try{let y=this.preInitializedTickArrayStartIndex(e,i);if(y.isExist){let{publicKey:b}=ge(e.programId,e.id,y.nextStartIndex);s.push(b)}}catch{}s.push(c);let{amountCalculated:l,accounts:m,sqrtPriceX64:p,feeAmount:f}=Zn.swapCompute(e.programId,e.id,t,e.tickArrayBitmap,e.exBitmapInfo,i,e.ammConfig.tradeFeeRate,e.liquidity,e.tickCurrent,e.tickSpacing,e.sqrtPriceX64,o.mul(bn),a,r);return s.push(...m),{expectedAmountIn:l,remainingAccounts:s,executionPrice:p,feeAmount:f}}static getFirstInitializedTickArray(e,t){let{isInitialized:n,startIndex:o}=Ne.isOverflowDefaultTickarrayBitmap(e.tickSpacing,[e.tickCurrent])?li.checkTickArrayIsInit(Pe.getArrayStartIndex(e.tickCurrent,e.tickSpacing),e.tickSpacing,e.exBitmapInfo):$.checkTickArrayIsInitialized($.mergeTickArrayBitmap(e.tickArrayBitmap),e.tickCurrent,e.tickSpacing);if(n){let{publicKey:s}=ge(e.programId,e.id,o);return{isExist:!0,startIndex:o,nextAccountMeta:s}}let{isExist:r,nextStartIndex:i}=this.nextInitializedTickArrayStartIndex(e,Pe.getArrayStartIndex(e.tickCurrent,e.tickSpacing),t);if(r){let{publicKey:s}=ge(e.programId,e.id,i);return{isExist:!0,startIndex:i,nextAccountMeta:s}}return{isExist:!1,nextAccountMeta:void 0,startIndex:void 0}}static preInitializedTickArrayStartIndex(e,t){let n=Math.floor(e.tickCurrent/Pe.tickCount(e.tickSpacing)),o=t?$.searchHightBitFromStart(e.tickArrayBitmap,e.exBitmapInfo,n+1,1,e.tickSpacing):$.searchLowBitFromStart(e.tickArrayBitmap,e.exBitmapInfo,n-1,1,e.tickSpacing);return o.length>0?{isExist:!0,nextStartIndex:o[0]}:{isExist:!1,nextStartIndex:0}}static nextInitializedTickArrayStartIndex(e,t,n){for(t=Pe.getArrayStartIndex(e.tickCurrent,e.tickSpacing);;){let{isInit:o,tickIndex:r}=Pn.nextInitializedTickArrayStartIndex($.mergeTickArrayBitmap(e.tickArrayBitmap),t,e.tickSpacing,n);if(o)return{isExist:!0,nextStartIndex:r};t=r;let{isInit:i,tickIndex:s}=li.nextInitializedTickArrayFromOneBitmap(t,e.tickSpacing,n,e.exBitmapInfo);if(i)return{isExist:!0,nextStartIndex:s};if(t=s,t<dt||t>yt)return{isExist:!1,nextStartIndex:0}}}static async updatePoolRewardInfos({connection:e,apiPoolInfo:t,chainTime:n,poolLiquidity:o,rewardInfos:r}){var s,u,a;let i=[];for(let c=0;c<r.length;c++){let l=r[c],m=(a=(s=t.rewardDefaultInfos[c])==null?void 0:s.mint.programId)!=null?a:(u=await e.getAccountInfo(l.tokenMint))==null?void 0:u.owner;if(m===void 0)throw Error("get new reward mint info error");let p=D(v({},l),{perSecond:le.x64ToDecimal(l.emissionsPerSecondX64),remainingRewards:void 0,tokenProgramId:new Rt(m)});if(p.tokenMint.equals(Rt.default))continue;if(n<=p.openTime.toNumber()||o.eq(Ue)){i.push(p);continue}let f=new Ee(Math.min(p.endTime.toNumber(),n)),y=f.sub(p.lastUpdateTime),b=le.mulDivFloor(y,p.emissionsPerSecondX64,o),g=p.rewardGrowthGlobalX64.add(b),P=le.mulDivFloor(y,p.emissionsPerSecondX64,Ze),T=p.rewardTotalEmissioned.add(P);i.push(D(v({},p),{rewardGrowthGlobalX64:g,rewardTotalEmissioned:T,lastUpdateTime:f}))}return i}static isOverflowDefaultTickarrayBitmap(e,t){let{maxTickBoundary:n,minTickBoundary:o}=this.tickRange(e);for(let r of t){let i=$.getTickArrayStartIndexByTick(r,e);if(i>=n||i<o)return!0}return!1}static tickRange(e){let t=Pn.maxTickInTickarrayBitmap(e),n=-t;return t>yt&&(t=Pe.getArrayStartIndex(yt,e)+Pe.tickCount(e)),n<dt&&(n=Pe.getArrayStartIndex(dt,e)),{maxTickBoundary:t,minTickBoundary:n}}static get_tick_array_offset(e,t){if(!Pe.checkIsValidStartIndex(e,t))throw new Error("No enough initialized tickArray");return e/Pe.tickCount(t)*$n}static async fetchExBitmaps({connection:e,exBitmapAddress:t,batchRequest:n}){let o=await Oe(e,t.map(i=>({pubkey:i})),{batchRequest:n}),r={};for(let i of o)i.accountInfo!==null&&(r[i.pubkey.toString()]=ac.decode(i.accountInfo.data));return r}static async fetchMultiplePoolTickArrays({connection:e,poolKeys:t,batchRequest:n}){let o={},r=[];for(let u of t){let a=$.getTickArrayStartIndexByTick(u.tickCurrent,u.tickSpacing),c=$.getInitializedTickArrayInRange(u.tickArrayBitmap,u.exBitmapInfo,u.tickSpacing,a,7);for(let l of c){let{publicKey:m}=ge(u.programId,u.id,l);r.push({pubkey:m}),o[m.toString()]=u.id}}let i=await Oe(e,r,{batchRequest:n}),s={};for(let u of i){if(!u.accountInfo)continue;let a=o[u.pubkey.toString()];if(!a)continue;s[a.toString()]===void 0&&(s[a.toString()]={});let c=ci.decode(u.accountInfo.data);s[a.toString()][c.startTickIndex]=D(v({},c),{address:u.pubkey})}return s}static async fetchPoolsAccountPosition({pools:e,connection:t,ownerInfo:n,batchRequest:o=!1,updateOwnerRewardAndFee:r=!0}){var s;let i=[];for(let u=0;u<e.length;u++){let a=e[u];a!==null&&(i.find(c=>c.equals(a.state.programId))||i.push(a.state.programId))}if(n){let u=n.tokenAccounts.map(m=>m.accountInfo.mint),a=[];for(let m of u)for(let p of i)a.push(bt(p,m).publicKey);let c=await Ht(t,a,{batchRequest:o}),l={};for(let m of c){if(m===null)continue;let p=Io.decode(m.data),f=p.poolId.toString(),y=e.find(B=>B.state.id.toBase58()===f);if(y===void 0)continue;let b=y.state,g=$._getTickPriceLegacy({poolInfo:b,tick:p.tickLower,baseIn:!0}),P=$._getTickPriceLegacy({poolInfo:b,tick:p.tickUpper,baseIn:!0}),{amountA:T,amountB:h}=ke.getAmountsFromLiquidity(b.sqrtPriceX64,g.tickSqrtPriceX64,P.tickSqrtPriceX64,p.liquidity,!1),w=1/(1-Math.sqrt(Math.sqrt(g.price.div(P.price).toNumber())));y.positionAccount=[...(s=y.positionAccount)!=null?s:[],{poolId:p.poolId,nftMint:p.nftMint,priceLower:g.price,priceUpper:P.price,amountA:T,amountB:h,tickLower:p.tickLower,tickUpper:p.tickUpper,liquidity:p.liquidity,feeGrowthInsideLastX64A:p.feeGrowthInsideLastX64A,feeGrowthInsideLastX64B:p.feeGrowthInsideLastX64B,tokenFeesOwedA:p.tokenFeesOwedA,tokenFeesOwedB:p.tokenFeesOwedB,rewardInfos:p.rewardInfos.map(B=>D(v({},B),{pendingReward:new Ee(0)})),leverage:w,tokenFeeAmountA:new Ee(0),tokenFeeAmountB:new Ee(0)}];let k=await $.getTickArrayAddressByTick(y.state.programId,p.poolId,p.tickLower,y.state.tickSpacing),x=await $.getTickArrayAddressByTick(y.state.programId,p.poolId,p.tickUpper,y.state.tickSpacing);l[`${y.state.programId.toString()}-${p.poolId.toString()}-${p.tickLower}`]=k,l[`${y.state.programId.toString()}-${p.poolId.toString()}-${p.tickUpper}`]=x}if(r){let m=Object.values(l),p=await Ht(t,m,{batchRequest:o}),f={};for(let y=0;y<m.length;y++){let b=p[y];if(b===null)continue;let g=m[y].toString();f[g]=ci.decode(b.data)}for(let{state:y,positionAccount:b}of e)if(!!b)for(let g of b){let P=`${y.programId.toString()}-${y.id.toString()}-${g.tickLower}`,T=`${y.programId.toString()}-${y.id.toString()}-${g.tickUpper}`,h=f[l[P].toString()],w=f[l[T].toString()],k=h.ticks[$.getTickOffsetInArray(g.tickLower,y.tickSpacing)],x=w.ticks[$.getTickOffsetInArray(g.tickUpper,y.tickSpacing)],{tokenFeeAmountA:B,tokenFeeAmountB:K}=await ui.GetPositionFees(y,g,k,x),I=await ui.GetPositionRewards(y,g,k,x);g.tokenFeeAmountA=B.gte(new Ee(0))?B:new Ee(0),g.tokenFeeAmountB=K.gte(new Ee(0))?K:new Ee(0);for(let R=0;R<I.length;R++)g.rewardInfos[R].pendingReward=I[R].gte(new Ee(0))?I[R]:new Ee(0)}}}return e}static computeAmountOut({poolInfo:e,tickArrayCache:t,baseMint:n,epochInfo:o,amountIn:r,slippage:i,priceLimit:s=new Ae(0),catchLiquidityInsufficient:u=!1}){var C;let a,c=n.toBase58()===e.mintA.address,[l,m]=c?[e.mintA.extensions.feeConfig,e.mintB.extensions.feeConfig]:[e.mintB.extensions.feeConfig,e.mintA.extensions.feeConfig];s.equals(new Ae(0))?a=c?Wt.add(new Ee(1)):Dt.sub(new Ee(1)):a=ue.priceToSqrtPriceX64(s,e.mintA.decimals,e.mintB.decimals);let p=Se(r,l,o,!1),{allTrade:f,expectedAmountOut:y,remainingAccounts:b,executionPrice:g,feeAmount:P}=Ne.getOutputAmountAndRemainAccounts(e,t,n,p.amount.sub((C=p.fee)!=null?C:Ue),a,u),T=Se(y,m,o,!1),h=ue.sqrtPriceX64ToPrice(g,e.mintA.decimals,e.mintB.decimals),w=c?h:new Ae(1).div(h),k=y.mul(new Ee(Math.floor((1-i)*1e10))).div(new Ee(1e10)),x=Se(k,m,o,!1),B=c?e.currentPrice:new Ae(1).div(e.currentPrice),K=new Ae(w).sub(B).abs(),I=B,R=new tt(new Ae(K).mul(10**15).toFixed(0),new Ae(I).mul(10**15).toFixed(0));return{allTrade:f,realAmountIn:p,amountOut:T,minAmountOut:x,expirationTime:$t(p.expirationTime,T.expirationTime),currentPrice:e.currentPrice,executionPrice:w,priceImpact:R,fee:P,remainingAccounts:b,executionPriceX64:g}}static computeAmountOutFormat({poolInfo:e,tickArrayCache:t,amountIn:n,tokenOut:o,slippage:r,epochInfo:i,catchLiquidityInsufficient:s=!1}){let u=o.address===e.mintB.address,[a,c]=u?[e.mintA,e.mintB]:[e.mintB,e.mintA],[l,m]=[new De(D(v({},a),{mint:a.address,isToken2022:a.programId===rc.toBase58()})),new De(D(v({},c),{mint:c.address,isToken2022:c.programId===rc.toBase58()}))],{allTrade:p,realAmountIn:f,amountOut:y,minAmountOut:b,expirationTime:g,currentPrice:P,executionPrice:T,priceImpact:h,fee:w,remainingAccounts:k,executionPriceX64:x}=Ne.computeAmountOut({poolInfo:e,tickArrayCache:t,baseMint:new Rt(a.address),amountIn:n,slippage:r,epochInfo:i,catchLiquidityInsufficient:s}),B=D(v({},f),{amount:new xe(l,f.amount),fee:f.fee===void 0?void 0:new xe(l,f.fee)}),K=D(v({},y),{amount:new xe(m,y.amount),fee:y.fee===void 0?void 0:new xe(m,y.fee)}),I=D(v({},b),{amount:new xe(m,b.amount),fee:b.fee===void 0?void 0:new xe(m,b.fee)}),R=new At({baseToken:l,denominator:new Ee(10).pow(new Ee(20+l.decimals)),quoteToken:m,numerator:P.mul(new Ae(10**(20+m.decimals))).toFixed(0)}),C=new At({baseToken:l,denominator:new Ee(10).pow(new Ee(20+l.decimals)),quoteToken:m,numerator:T.mul(new Ae(10**(20+m.decimals))).toFixed(0)}),N=new xe(l,w);return{allTrade:p,realAmountIn:B,amountOut:K,minAmountOut:I,expirationTime:g,currentPrice:R,executionPrice:C,priceImpact:h,fee:N,remainingAccounts:k,executionPriceX64:x}}static computeAmountIn({poolInfo:e,tickArrayCache:t,baseMint:n,epochInfo:o,amountOut:r,slippage:i,priceLimit:s=new Ae(0)}){var I;let u=n.toBase58()===e.mintA.address,a={[e.mintA.address]:e.mintA.extensions.feeConfig,[e.mintB.address]:e.mintB.extensions.feeConfig},c;s.equals(new Ae(0))?c=u?Dt.sub(new Ee(1)):Wt.add(new Ee(1)):c=ue.priceToSqrtPriceX64(s,e.mintA.decimals,e.mintB.decimals);let l=Se(r,a[n.toString()],o,!0),{expectedAmountIn:m,remainingAccounts:p,executionPrice:f,feeAmount:y}=Ne.getInputAmountAndRemainAccounts(e,t,n,l.amount.sub((I=l.fee)!=null?I:Ue),c),b=u?e.mintB.address:e.mintA.address,g=Se(m,a[b],o,!1),P=ue.sqrtPriceX64ToPrice(f,e.mintA.decimals,e.mintB.decimals),T=u?P:new Ae(1).div(P),h=m.mul(new Ee(Math.floor((1+i)*1e10))).div(new Ee(1e10)),w=Se(h,a[b],o,!0),k=u?e.currentPrice:new Ae(1).div(e.currentPrice),x=new Ae(T).sub(k).abs(),B=k,K=new tt(new Ae(x).mul(10**15).toFixed(0),new Ae(B).mul(10**15).toFixed(0));return{amountIn:g,maxAmountIn:w,realAmountOut:l,expirationTime:$t(g.expirationTime,l.expirationTime),currentPrice:e.currentPrice,executionPrice:T,priceImpact:K,fee:y,remainingAccounts:p}}static estimateAprsForPriceRangeMultiplier({poolInfo:e,aprType:t,positionTickLowerIndex:n,positionTickUpperIndex:o}){var f,y,b;let r=e[t],i=$.getTickPrice({poolInfo:e,tick:n,baseIn:!0}).price.toNumber(),s=$.getTickPrice({poolInfo:e,tick:o,baseIn:!0}).price.toNumber(),u=Math.max(i,r.priceMin),c=Math.min(s,r.priceMax)-u,l=s-i,m=r.priceMax-r.priceMin,p;return c<=0?p=0:l===c?p=m/c:m===c?p=c/l:p=c/m*(c/l),{feeApr:r.feeApr*p,rewardsApr:[((f=r.rewardApr[0])!=null?f:0)*p,((y=r.rewardApr[1])!=null?y:0)*p,((b=r.rewardApr[2])!=null?b:0)*p],apr:r.apr*p}}static estimateAprsForPriceRangeDelta({poolInfo:e,poolLiquidity:t,aprType:n,mintPrice:o,liquidity:r,positionTickLowerIndex:i,positionTickUpperIndex:s,chainTime:u}){let a=n==="day"?1:n==="week"?7:n==="month"?30:0,c=e[n],l=o[ct(e.mintA.address).toString()],m=o[ct(e.mintB.address).toString()],p=e.mintA.decimals,f=e.mintB.decimals;if(!c||!l||!m)return{feeApr:0,rewardsApr:[0,0,0],apr:0};let y=ue.priceToSqrtPriceX64(new Ae(e.price),e.mintA.decimals,e.mintB.decimals),b=ue.getSqrtPriceX64FromTick(i),g=ue.getSqrtPriceX64FromTick(s),{amountSlippageA:P,amountSlippageB:T}=ke.getAmountsFromLiquidityWithSlippage(y,b,g,t,!1,!1,0),{amountSlippageA:h,amountSlippageB:w}=ke.getAmountsFromLiquidityWithSlippage(y,b,g,r,!1,!1,0),k=new Ae(P.toString()).div(new Ae(10).pow(p)).mul(l.value).add(new Ae(T.toString()).div(new Ae(10).pow(f)).mul(m.value)),x=new Ae(h.toString()).div(new Ae(10).pow(p)).mul(l.value).add(new Ae(w.toString()).div(new Ae(10).pow(f)).mul(m.value)),B=new Ae(1).div(k.add(x)),I=new Ae(c.volumeFee).mul(365).div(a).mul(B).mul(100).toNumber(),R=3600*24*365,C=e.rewardDefaultInfos.map(N=>{var _,G;let L=N.mint.decimals,O=o[N.mint.address];return u<((_=N.startTime)!=null?_:0)||u>((G=N.endTime)!=null?G:0)||!N.perSecond||!O||L===void 0?0:new Ae(O.value).mul(new Ae(N.perSecond).mul(R)).div(new Ae(10).pow(L)).mul(B).mul(100).toNumber()});return{feeApr:I,rewardsApr:C,apr:I+C.reduce((N,L)=>N+L,0)}}static async getLiquidityAmountOutFromAmountIn({poolInfo:e,inputA:t,tickLower:n,tickUpper:o,amount:r,slippage:i,add:s,epochInfo:u,amountHasFee:a}){var g,P;let c=ue.priceToSqrtPriceX64(new Ae(e.price),e.mintA.decimals,e.mintB.decimals),l=ue.getSqrtPriceX64FromTick(n),m=ue.getSqrtPriceX64FromTick(o),p=Se(r,(g=e[t?"mintA":"mintB"].extensions)==null?void 0:g.feeConfig,u,!a),f=new Ee(new Ae(p.amount.sub((P=p.fee)!=null?P:Ue).toString()).toFixed(0)),y;if(c.lte(l))y=t?ke.getLiquidityFromTokenAmountA(l,m,f,!s):new Ee(0);else if(c.lte(m)){let T=ke.getLiquidityFromTokenAmountA(c,m,f,!s),h=ke.getLiquidityFromTokenAmountB(l,c,f);y=t?T:h}else y=t?new Ee(0):ke.getLiquidityFromTokenAmountB(l,m,f);let b=await Ne.getAmountsFromLiquidity({epochInfo:u,poolInfo:e,tickLower:n,tickUpper:o,liquidity:y,slippage:i,add:s});return{liquidity:y,amountA:t?p:b.amountA,amountB:t?b.amountB:p,amountSlippageA:t?p:b.amountSlippageA,amountSlippageB:t?b.amountSlippageB:p,expirationTime:b.expirationTime}}static async getAmountsFromLiquidity({epochInfo:e,poolInfo:t,tickLower:n,tickUpper:o,liquidity:r,slippage:i,add:s}){var b,g,P,T;let u=ue.getSqrtPriceX64FromTick(n),a=ue.getSqrtPriceX64FromTick(o),c=s?1+i:1-i,l=ke.getAmountsFromLiquidity(ue.priceToSqrtPriceX64(new Ae(t.price),t.mintA.decimals,t.mintB.decimals),u,a,r,s),[m,p]=[Se(l.amountA,(b=t.mintA.extensions)==null?void 0:b.feeConfig,e,!0),Se(l.amountB,(g=t.mintB.extensions)==null?void 0:g.feeConfig,e,!0)],[f,y]=[Se(l.amountA.muln(c),(P=t.mintA.extensions)==null?void 0:P.feeConfig,e,!0),Se(l.amountB.muln(c),(T=t.mintB.extensions)==null?void 0:T.feeConfig,e,!0)];return{liquidity:r,amountA:m,amountB:p,amountSlippageA:f,amountSlippageB:y,expirationTime:$t(m.expirationTime,p.expirationTime)}}static async fetchComputeMultipleClmmInfo({connection:e,poolList:t,rpcDataMap:n={}}){let o=t.filter(u=>!n[u.id]).map(u=>new Rt(u.id));(await Ht(e,o)).forEach((u,a)=>{!u||(n[o[a].toBase58()]=Jn.decode(u.data))});let i=t.map(u=>Qe(new Rt(u.programId),new Rt(u.id)).publicKey),s=await Ne.fetchExBitmaps({connection:e,exBitmapAddress:i,batchRequest:!1});return t.reduce((u,a)=>D(v({},u),{[a.id]:D(v({},n[a.id]),{id:new Rt(a.id),version:6,programId:new Rt(a.programId),mintA:a.mintA,mintB:a.mintB,ammConfig:D(v({},a.config),{id:new Rt(a.config.id),fundOwner:""}),currentPrice:new Ae(a.price),exBitmapAccount:Qe(new Rt(a.programId),new Rt(a.id)).publicKey,exBitmapInfo:s[Qe(new Rt(a.programId),new Rt(a.id)).publicKey.toBase58()],startTime:n[a.id].startTime.toNumber(),rewardInfos:n[a.id].rewardInfos})}),{})}static async fetchComputeClmmInfo({connection:e,poolInfo:t,rpcData:n}){return(await this.fetchComputeMultipleClmmInfo({connection:e,rpcDataMap:n?{[t.id]:n}:void 0,poolList:[t]}))[t.id]}};var Gs={volume:0,volumeQuote:0,volumeFee:0,apr:0,feeApr:0,priceMin:0,priceMax:0,rewardApr:[]};function sc(d){return D(v({},d),{type:"Concentrated",programId:d.programId.toString(),id:d.id.toString(),rewardDefaultInfos:[],rewardDefaultPoolInfos:"Clmm",price:d.currentPrice.toNumber(),mintAmountA:0,mintAmountB:0,feeRate:d.ammConfig.tradeFeeRate,openTime:d.startTime.toString(),tvl:0,day:Gs,week:Gs,month:Gs,pooltype:[],farmUpcomingCount:0,farmOngoingCount:0,farmFinishedCount:0,burnPercent:0,config:D(v({},d.ammConfig),{id:d.ammConfig.id.toString(),defaultRange:0,defaultRangePoint:[]})})}var le=class{static mulDivRoundingUp(e,t,n){let o=e.mul(t),r=o.div(n);return o.mod(n).eq(Ue)||(r=r.add(Ct)),r}static mulDivFloor(e,t,n){if(n.eq(Ue))throw new Error("division by 0");return e.mul(t).div(n)}static mulDivCeil(e,t,n){if(n.eq(Ue))throw new Error("division by 0");return e.mul(t).add(n.sub(Ct)).div(n)}static x64ToDecimal(e,t){return new an(e.toString()).div(an.pow(2,64)).toDecimalPlaces(t)}static decimalToX64(e){return new pe(e.mul(an.pow(2,64)).floor().toFixed())}static wrappingSubU128(e,t){return e.add(dr).sub(t).mod(dr)}};function ot(d,e){return Xs(d.mul(e),64,256)}function ad(d,e,t){let n=d.toTwos(t).shln(e);return n.imaskn(t+1),n.fromTwos(t)}function Xs(d,e,t){let n=d.toTwos(t).shrn(e);return n.imaskn(t-e+1),n.fromTwos(t-e)}var ue=class{static sqrtPriceX64ToPrice(e,t,n){return le.x64ToDecimal(e).pow(2).mul(an.pow(10,t-n))}static priceToSqrtPriceX64(e,t,n){return le.decimalToX64(e.mul(an.pow(10,n-t)).sqrt())}static getNextSqrtPriceX64FromInput(e,t,n,o){if(!e.gt(Ue))throw new Error("sqrtPriceX64 must greater than 0");if(!t.gt(Ue))throw new Error("liquidity must greater than 0");return o?this.getNextSqrtPriceFromTokenAmountARoundingUp(e,t,n,!0):this.getNextSqrtPriceFromTokenAmountBRoundingDown(e,t,n,!0)}static getNextSqrtPriceX64FromOutput(e,t,n,o){if(!e.gt(Ue))throw new Error("sqrtPriceX64 must greater than 0");if(!t.gt(Ue))throw new Error("liquidity must greater than 0");return o?this.getNextSqrtPriceFromTokenAmountBRoundingDown(e,t,n,!1):this.getNextSqrtPriceFromTokenAmountARoundingUp(e,t,n,!1)}static getNextSqrtPriceFromTokenAmountARoundingUp(e,t,n,o){if(n.eq(Ue))return e;let r=t.shln(ri);if(o){let i=r,s=r.add(n.mul(e));return s.gte(i)?le.mulDivCeil(i,e,s):le.mulDivRoundingUp(i,Ct,i.div(e).add(n))}else{let i=n.mul(e);if(!r.gt(i))throw new Error("getNextSqrtPriceFromTokenAmountARoundingUp,liquidityLeftShift must gt amountMulSqrtPrice");let s=r.sub(i);return le.mulDivCeil(r,e,s)}}static getNextSqrtPriceFromTokenAmountBRoundingDown(e,t,n,o){let r=n.shln(ri);if(o)return e.add(r.div(t));{let i=le.mulDivRoundingUp(r,Ct,t);if(!e.gt(i))throw new Error("getNextSqrtPriceFromTokenAmountBRoundingDown sqrtPriceX64 must gt amountDivLiquidity");return e.sub(i)}}static getSqrtPriceX64FromTick(e){if(!Number.isInteger(e))throw new Error("tick must be integer");if(e<dt||e>yt)throw new Error("tick must be in MIN_TICK and MAX_TICK");let t=e<0?e*-1:e,n=(t&1)!=0?new pe("18445821805675395072"):new pe("18446744073709551616");return(t&2)!=0&&(n=ot(n,new pe("18444899583751176192"))),(t&4)!=0&&(n=ot(n,new pe("18443055278223355904"))),(t&8)!=0&&(n=ot(n,new pe("18439367220385607680"))),(t&16)!=0&&(n=ot(n,new pe("18431993317065453568"))),(t&32)!=0&&(n=ot(n,new pe("18417254355718170624"))),(t&64)!=0&&(n=ot(n,new pe("18387811781193609216"))),(t&128)!=0&&(n=ot(n,new pe("18329067761203558400"))),(t&256)!=0&&(n=ot(n,new pe("18212142134806163456"))),(t&512)!=0&&(n=ot(n,new pe("17980523815641700352"))),(t&1024)!=0&&(n=ot(n,new pe("17526086738831433728"))),(t&2048)!=0&&(n=ot(n,new pe("16651378430235570176"))),(t&4096)!=0&&(n=ot(n,new pe("15030750278694412288"))),(t&8192)!=0&&(n=ot(n,new pe("12247334978884435968"))),(t&16384)!=0&&(n=ot(n,new pe("8131365268886854656"))),(t&32768)!=0&&(n=ot(n,new pe("3584323654725218816"))),(t&65536)!=0&&(n=ot(n,new pe("696457651848324352"))),(t&131072)!=0&&(n=ot(n,new pe("26294789957507116"))),(t&262144)!=0&&(n=ot(n,new pe("37481735321082"))),e>0&&(n=zu.div(n)),n}static getTickFromPrice(e,t,n){return ue.getTickFromSqrtPriceX64(ue.priceToSqrtPriceX64(e,t,n))}static getTickFromSqrtPriceX64(e){if(e.gt(Dt)||e.lt(Wt))throw new Error("Provided sqrtPrice is not within the supported sqrtPrice range.");let t=e.bitLength()-1,n=new pe(t-64),o=ad(n,32,128),r=new pe("8000000000000000","hex"),i=0,s=new pe(0),u=t>=64?e.shrn(t-63):e.shln(63-t);for(;r.gt(new pe(0))&&i<Yu;){u=u.mul(u);let f=u.shrn(127);u=u.shrn(63+f.toNumber()),s=s.add(r.mul(f)),r=r.shrn(1),i+=1}let a=s.shrn(32),l=o.add(a).mul(new pe(Qu)),m=Xs(l.sub(new pe(Hu)),64,128).toNumber(),p=Xs(l.add(new pe(ju)),64,128).toNumber();return m==p?m:ue.getSqrtPriceX64FromTick(p).lte(e)?p:m}},eo=class{static getTickWithPriceAndTickspacing(e,t,n,o){let i=ue.getTickFromSqrtPriceX64(ue.priceToSqrtPriceX64(e,n,o))/t;return i<0?i=Math.floor(i):i=Math.ceil(i),i*t}static roundPriceWithTickspacing(e,t,n,o){let r=eo.getTickWithPriceAndTickspacing(e,t,n,o),i=ue.getSqrtPriceX64FromTick(r);return ue.sqrtPriceX64ToPrice(i,n,o)}},ke=class{static addDelta(e,t){return e.add(t)}static getTokenAmountAFromLiquidity(e,t,n,o){if(e.gt(t)&&([e,t]=[t,e]),!e.gt(Ue))throw new Error("sqrtPriceX64A must greater than 0");let r=n.ushln(ri),i=t.sub(e);return o?le.mulDivRoundingUp(le.mulDivCeil(r,i,t),Ct,e):le.mulDivFloor(r,i,t).div(e)}static getTokenAmountBFromLiquidity(e,t,n,o){if(e.gt(t)&&([e,t]=[t,e]),!e.gt(Ue))throw new Error("sqrtPriceX64A must greater than 0");return o?le.mulDivCeil(n,t.sub(e),Ze):le.mulDivFloor(n,t.sub(e),Ze)}static getLiquidityFromTokenAmountA(e,t,n,o){e.gt(t)&&([e,t]=[t,e]);let r=n.mul(e).mul(t),i=t.sub(e),s=r.div(i);return o?le.mulDivRoundingUp(s,Ct,ii):s.shrn(ri)}static getLiquidityFromTokenAmountB(e,t,n){return e.gt(t)&&([e,t]=[t,e]),le.mulDivFloor(n,ii,t.sub(e))}static getLiquidityFromTokenAmounts(e,t,n,o,r){if(t.gt(n)&&([t,n]=[n,t]),e.lte(t))return ke.getLiquidityFromTokenAmountA(t,n,o,!1);if(e.lt(n)){let i=ke.getLiquidityFromTokenAmountA(e,n,o,!1),s=ke.getLiquidityFromTokenAmountB(t,e,r);return i.lt(s)?i:s}else return ke.getLiquidityFromTokenAmountB(t,n,r)}static getAmountsFromLiquidity(e,t,n,o,r){if(t.gt(n)&&([t,n]=[n,t]),e.lte(t))return{amountA:ke.getTokenAmountAFromLiquidity(t,n,o,r),amountB:new pe(0)};if(e.lt(n)){let i=ke.getTokenAmountAFromLiquidity(e,n,o,r),s=ke.getTokenAmountBFromLiquidity(t,e,o,r);return{amountA:i,amountB:s}}else return{amountA:new pe(0),amountB:ke.getTokenAmountBFromLiquidity(t,n,o,r)}}static getAmountsFromLiquidityWithSlippage(e,t,n,o,r,i,s){let{amountA:u,amountB:a}=ke.getAmountsFromLiquidity(e,t,n,o,i),c=r?1+s:1-s,l=new pe(new an(u.toString()).mul(c).toFixed(0)),m=new pe(new an(a.toString()).mul(c).toFixed(0));return{amountSlippageA:l,amountSlippageB:m}}static getAmountsOutFromLiquidity({poolInfo:e,tickLower:t,tickUpper:n,liquidity:o,slippage:r,add:i,epochInfo:s,amountAddFee:u}){var P,T,h,w;let a=ue.priceToSqrtPriceX64(new an(e.price),e.mintA.decimals,e.mintB.decimals),c=ue.getSqrtPriceX64FromTick(t),l=ue.getSqrtPriceX64FromTick(n),m=i?1+r:1-r,p=ke.getAmountsFromLiquidity(a,c,l,o,i),[f,y]=[Se(p.amountA,(P=e.mintA.extensions)==null?void 0:P.feeConfig,s,u),Se(p.amountB,(T=e.mintB.extensions)==null?void 0:T.feeConfig,s,u)],[b,g]=[Se(new pe(new an(p.amountA.toString()).mul(m).toFixed(0)),(h=e.mintA.extensions)==null?void 0:h.feeConfig,s,u),Se(new pe(new an(p.amountB.toString()).mul(m).toFixed(0)),(w=e.mintB.extensions)==null?void 0:w.feeConfig,s,u)];return{liquidity:o,amountA:f,amountB:y,amountSlippageA:b,amountSlippageB:g,expirationTime:$t(f.expirationTime,y.expirationTime)}}},Zn=class{static swapCompute(e,t,n,o,r,i,s,u,a,c,l,m,p,f,y=!1){if(m.eq(Ue))throw new Error("amountSpecified must not be 0");if(f||(f=i?Wt.add(Ct):Dt.sub(Ct)),i){if(f.lt(Wt))throw new Error("sqrtPriceX64 must greater than MIN_SQRT_PRICE_X64");if(f.gte(l))throw new Error("sqrtPriceX64 must smaller than current")}else{if(f.gt(Dt))throw new Error("sqrtPriceX64 must smaller than MAX_SQRT_PRICE_X64");if(f.lte(l))throw new Error("sqrtPriceX64 must greater than current")}let b=m.gt(Ue),g={amountSpecifiedRemaining:m,amountCalculated:Ue,sqrtPriceX64:l,tick:a>p?Math.min(p+Pe.tickCount(c)-1,a):p,accounts:[],liquidity:u,feeAmount:new pe(0)},P=p,T=n[p],h=0,w=!i&&T.startTickIndex===g.tick;for(;!g.amountSpecifiedRemaining.eq(Ue)&&!g.sqrtPriceX64.eq(f);){h>10;let k={};k.sqrtPriceStartX64=g.sqrtPriceX64;let x=$.nextInitTick(T,g.tick,c,i,w),B=x||null,K=null;if(!(B!=null&&B.liquidityGross.gtn(0))){let R=Ne.nextInitializedTickArrayStartIndex({tickCurrent:g.tick,tickSpacing:c,tickArrayBitmap:o,exBitmapInfo:r},P,i);if(!R.isExist){if(y)return{allTrade:!1,amountSpecifiedRemaining:g.amountSpecifiedRemaining,amountCalculated:g.amountCalculated,feeAmount:g.feeAmount,sqrtPriceX64:g.sqrtPriceX64,liquidity:g.liquidity,tickCurrent:g.tick,accounts:g.accounts};throw Error("swapCompute LiquidityInsufficient")}P=R.nextStartIndex;let{publicKey:C}=ge(e,t,P);K=C,T=n[P];try{B=$.firstInitializedTick(T,i)}catch{throw Error("not found next tick info")}}k.tickNext=B.tick,k.initialized=B.liquidityGross.gtn(0),p!==P&&K&&(g.accounts.push(K),p=P),k.tickNext<dt?k.tickNext=dt:k.tickNext>yt&&(k.tickNext=yt),k.sqrtPriceNextX64=ue.getSqrtPriceX64FromTick(k.tickNext);let I;if(i&&k.sqrtPriceNextX64.lt(f)||!i&&k.sqrtPriceNextX64.gt(f)?I=f:I=k.sqrtPriceNextX64,[g.sqrtPriceX64,k.amountIn,k.amountOut,k.feeAmount]=Zn.swapStepCompute(g.sqrtPriceX64,I,g.liquidity,g.amountSpecifiedRemaining,s,i),g.feeAmount=g.feeAmount.add(k.feeAmount),b?(g.amountSpecifiedRemaining=g.amountSpecifiedRemaining.sub(k.amountIn.add(k.feeAmount)),g.amountCalculated=g.amountCalculated.sub(k.amountOut)):(g.amountSpecifiedRemaining=g.amountSpecifiedRemaining.add(k.amountOut),g.amountCalculated=g.amountCalculated.add(k.amountIn.add(k.feeAmount))),g.sqrtPriceX64.eq(k.sqrtPriceNextX64)){if(k.initialized){let R=B.liquidityNet;i&&(R=R.mul(bn)),g.liquidity=ke.addDelta(g.liquidity,R)}w=k.tickNext!=g.tick&&!i&&T.startTickIndex===k.tickNext,g.tick=i?k.tickNext-1:k.tickNext}else if(g.sqrtPriceX64!=k.sqrtPriceStartX64){let R=ue.getTickFromSqrtPriceX64(g.sqrtPriceX64);w=R!=g.tick&&!i&&T.startTickIndex===R,g.tick=R}++h}try{let{nextStartIndex:k,isExist:x}=Pe.nextInitializedTickArray(g.tick,c,i,o,r);x&&p!==k&&(g.accounts.push(ge(e,t,k).publicKey),p=k)}catch{}return{allTrade:!0,amountSpecifiedRemaining:Ue,amountCalculated:g.amountCalculated,feeAmount:g.feeAmount,sqrtPriceX64:g.sqrtPriceX64,liquidity:g.liquidity,tickCurrent:g.tick,accounts:g.accounts}}static swapStepCompute(e,t,n,o,r,i){let s={sqrtPriceX64Next:new pe(0),amountIn:new pe(0),amountOut:new pe(0),feeAmount:new pe(0)},u=o.gte(Ue);if(u){let c=le.mulDivFloor(o,yr.sub(new pe(r.toString())),yr);s.amountIn=i?ke.getTokenAmountAFromLiquidity(t,e,n,!0):ke.getTokenAmountBFromLiquidity(e,t,n,!0),c.gte(s.amountIn)?s.sqrtPriceX64Next=t:s.sqrtPriceX64Next=ue.getNextSqrtPriceX64FromInput(e,n,c,i)}else s.amountOut=i?ke.getTokenAmountBFromLiquidity(t,e,n,!1):ke.getTokenAmountAFromLiquidity(e,t,n,!1),o.mul(bn).gte(s.amountOut)?s.sqrtPriceX64Next=t:s.sqrtPriceX64Next=ue.getNextSqrtPriceX64FromOutput(e,n,o.mul(bn),i);let a=t.eq(s.sqrtPriceX64Next);return i?(a&&u||(s.amountIn=ke.getTokenAmountAFromLiquidity(s.sqrtPriceX64Next,e,n,!0)),a&&!u||(s.amountOut=ke.getTokenAmountBFromLiquidity(s.sqrtPriceX64Next,e,n,!1))):(s.amountIn=a&&u?s.amountIn:ke.getTokenAmountBFromLiquidity(e,s.sqrtPriceX64Next,n,!0),s.amountOut=a&&!u?s.amountOut:ke.getTokenAmountAFromLiquidity(e,s.sqrtPriceX64Next,n,!1)),!u&&s.amountOut.gt(o.mul(bn))&&(s.amountOut=o.mul(bn)),u&&!s.sqrtPriceX64Next.eq(t)?s.feeAmount=o.sub(s.amountIn):s.feeAmount=le.mulDivCeil(s.amountIn,new pe(r),yr.sub(new pe(r))),[s.sqrtPriceX64Next,s.amountIn,s.amountOut,s.feeAmount]}};var Je=60,$n=512,$=class{static getTickArrayAddressByTick(e,t,n,o){let r=$.getTickArrayStartIndexByTick(n,o),{publicKey:i}=ge(e,t,r);return i}static getTickOffsetInArray(e,t){if(e%t!=0)throw new Error("tickIndex % tickSpacing not equal 0");let n=$.getTickArrayStartIndexByTick(e,t),o=Math.floor((e-n)/t);if(o<0||o>=Je)throw new Error("tick offset in array overflow");return o}static getTickArrayBitIndex(e,t){let n=Pe.tickCount(t),o=e/n;return e<0&&e%n!=0?o=Math.ceil(o)-1:o=Math.floor(o),o}static getTickArrayStartIndexByTick(e,t){return this.getTickArrayBitIndex(e,t)*Pe.tickCount(t)}static getTickArrayOffsetInBitmapByTick(e,t){let n=t*Je,o=Math.floor(e/n)+512;return Math.abs(o)}static checkTickArrayIsInitialized(e,t,n){let o=n*Je,r=Math.floor(t/o)+512,i=Math.abs(r);return{isInitialized:e.testn(i),startIndex:(i-512)*o}}static getNextTickArrayStartIndex(e,t,n){return n?e-t*Je:e+t*Je}static mergeTickArrayBitmap(e){let t=new ud(0);for(let n=0;n<e.length;n++)t=t.add(e[n].shln(64*n));return t}static getInitializedTickArrayInRange(e,t,n,o,r){let i=Math.floor(o/(n*Je));return[...$.searchLowBitFromStart(e,t,i-1,r,n),...$.searchHightBitFromStart(e,t,i,r,n)]}static getAllInitializedTickArrayStartIndex(e,t,n){return $.searchHightBitFromStart(e,t,-7680,$n,n)}static getAllInitializedTickArrayInfo(e,t,n,o,r){let i=[],s=$.getAllInitializedTickArrayStartIndex(n,o,r);for(let u of s){let{publicKey:a}=ge(e,t,u);i.push({tickArrayStartIndex:u,tickArrayAddress:a})}return i}static getAllInitializedTickInTickArray(e){return e.ticks.filter(t=>t.liquidityGross.gtn(0))}static searchLowBitFromStart(e,t,n,o,r){let i=[...[...t.negativeTickArrayBitmap].reverse(),e.slice(0,8),e.slice(8,16),...t.positiveTickArrayBitmap].map(a=>$.mergeTickArrayBitmap(a)),s=[];for(;n>=-7680;){let a=Math.floor((n+7680)/512),c=(n+7680)%512;if(i[a].testn(c)&&s.push(n),n--,s.length===o)break}let u=Pe.tickCount(r);return s.map(a=>a*u)}static searchHightBitFromStart(e,t,n,o,r){let i=[...[...t.negativeTickArrayBitmap].reverse(),e.slice(0,8),e.slice(8,16),...t.positiveTickArrayBitmap].map(a=>$.mergeTickArrayBitmap(a)),s=[];for(;n<7680;){let a=Math.floor((n+7680)/512),c=(n+7680)%512;if(i[a].testn(c)&&s.push(n),n++,s.length===o)break}let u=Pe.tickCount(r);return s.map(a=>a*u)}static checkIsOutOfBoundary(e){return e<dt||e>yt}static nextInitTick(e,t,n,o,r){if(Pe.getArrayStartIndex(t,n)!=e.startTickIndex)return null;let s=Math.floor((t-e.startTickIndex)/n);if(o)for(;s>=0;){if(e.ticks[s].liquidityGross.gtn(0))return e.ticks[s];s=s-1}else for(r||(s=s+1);s<Je;){if(e.ticks[s].liquidityGross.gtn(0))return e.ticks[s];s=s+1}return null}static firstInitializedTick(e,t){if(t){let n=Je-1;for(;n>=0;){if(e.ticks[n].liquidityGross.gtn(0))return e.ticks[n];n=n-1}}else{let n=0;for(;n<Je;){if(e.ticks[n].liquidityGross.gtn(0))return e.ticks[n];n=n+1}}throw Error(`firstInitializedTick check error: ${e} - ${t}`)}static _getTickPriceLegacy({poolInfo:e,tick:t,baseIn:n}){let o=ue.getSqrtPriceX64FromTick(t),r=ue.sqrtPriceX64ToPrice(o,e.mintA.decimals,e.mintB.decimals);return n?{tick:t,price:r,tickSqrtPriceX64:o}:{tick:t,price:new Bo(1).div(r),tickSqrtPriceX64:o}}static _getPriceAndTickLegacy({poolInfo:e,price:t,baseIn:n}){let o=n?t:new Bo(1).div(t),r=eo.getTickWithPriceAndTickspacing(o,e.ammConfig.tickSpacing,e.mintA.decimals,e.mintB.decimals),i=ue.getSqrtPriceX64FromTick(r),s=ue.sqrtPriceX64ToPrice(i,e.mintA.decimals,e.mintB.decimals);return n?{tick:r,price:s}:{tick:r,price:new Bo(1).div(s)}}static getTickPrice({poolInfo:e,tick:t,baseIn:n}){let o=ue.getSqrtPriceX64FromTick(t),r=ue.sqrtPriceX64ToPrice(o,e.mintA.decimals,e.mintB.decimals);return n?{tick:t,price:r,tickSqrtPriceX64:o}:{tick:t,price:new Bo(1).div(r),tickSqrtPriceX64:o}}static getPriceAndTick({poolInfo:e,price:t,baseIn:n}){let o=n?t:new Bo(1).div(t),r=eo.getTickWithPriceAndTickspacing(o,e.config.tickSpacing,e.mintA.decimals,e.mintB.decimals),i=ue.getSqrtPriceX64FromTick(r),s=ue.sqrtPriceX64ToPrice(i,e.mintA.decimals,e.mintB.decimals);return n?{tick:r,price:s}:{tick:r,price:new Bo(1).div(s)}}};var uc=F([we(8),V("bump"),St("index"),M(""),mt("protocolFeeRate"),mt("tradeFeeRate"),St("tickSpacing"),Y(A(),8,"")]),cd=F([mt("blockTimestamp"),ko("tickCumulative"),Y(A(),4)]),cc=F([we(8),qe("initialized"),A("recentEpoch"),St("observationIndex"),M("poolId"),Y(cd,100,"observations"),Y(A(),4)]),ld=F([V("rewardState"),A("openTime"),A("endTime"),A("lastUpdateTime"),ie("emissionsPerSecondX64"),A("rewardTotalEmissioned"),A("rewardClaimed"),M("tokenMint"),M("tokenVault"),M("creator"),ie("rewardGrowthGlobalX64")]),Jn=F([we(8),V("bump"),M("ammConfig"),M("creator"),M("mintA"),M("mintB"),M("vaultA"),M("vaultB"),M("observationId"),V("mintDecimalsA"),V("mintDecimalsB"),St("tickSpacing"),ie("liquidity"),ie("sqrtPriceX64"),Ve("tickCurrent"),mt(),ie("feeGrowthGlobalX64A"),ie("feeGrowthGlobalX64B"),A("protocolFeesTokenA"),A("protocolFeesTokenB"),ie("swapInAmountTokenA"),ie("swapOutAmountTokenB"),ie("swapInAmountTokenB"),ie("swapOutAmountTokenA"),V("status"),Y(V(),7,""),Y(ld,3,"rewardInfos"),Y(A(),16,"tickArrayBitmap"),A("totalFeesTokenA"),A("totalFeesClaimedTokenA"),A("totalFeesTokenB"),A("totalFeesClaimedTokenB"),A("fundFeesTokenA"),A("fundFeesTokenB"),A("startTime"),Y(A(),15*4-3,"padding")]),md=F([ie("growthInsideLastX64"),A("rewardAmountOwed")]),Io=F([we(8),V("bump"),M("nftMint"),M("poolId"),Ve("tickLower"),Ve("tickUpper"),ie("liquidity"),ie("feeGrowthInsideLastX64A"),ie("feeGrowthInsideLastX64B"),A("tokenFeesOwedA"),A("tokenFeesOwedB"),Y(md,3,"rewardInfos"),Y(A(),8,"")]),uT=F([we(8),V("bump"),M("poolId"),Ve("tickLowerIndex"),Ve("tickUpperIndex"),ie("liquidity"),ie("feeGrowthInsideLastX64A"),ie("feeGrowthInsideLastX64B"),A("tokenFeesOwedA"),A("tokenFeesOwedB"),Y(ie(),3,"rewardGrowthInside"),Y(A(),8,"")]),dd=F([Ve("tick"),Bu("liquidityNet"),ie("liquidityGross"),ie("feeGrowthOutsideX64A"),ie("feeGrowthOutsideX64B"),Y(ie(),3,"rewardGrowthsOutsideX64"),Y(mt(),13,"")]),ci=F([we(8),M("poolId"),Ve("startTickIndex"),Y(dd,Je,"ticks"),V("initializedTickCount"),Y(V(),115,"")]),lc=F([we(329),Y(M(),100,"whitelistMints")]),ac=F([we(8),M("poolId"),Y(Y(A(),8),Us,"positiveTickArrayBitmap"),Y(Y(A(),8),Us,"negativeTickArrayBitmap")]),cT=F([A(),V("bump"),M("owner"),M("poolId"),M("positionId"),M("nftAccount"),Y(A(),8)]),mc=F([we(8),V("bump"),M("lockOwner"),M("poolId"),M("positionId"),M("nftAccount"),M("lockNftMint"),A("recentEpoch"),Y(A(),8)]);cc.span;var dc=be("Raydium_Clmm"),Lt={createPool:[233,146,209,142,207,104,64,188],initReward:[95,135,192,196,242,129,230,68],setRewardEmissions:[112,52,167,75,32,201,211,137],openPosition:[77,184,74,214,112,86,241,199],openPositionWithTokenEx:[77,255,174,82,125,29,201,46],closePosition:[123,134,81,0,49,68,98,98],increaseLiquidity:[133,29,89,223,69,238,176,10],decreaseLiquidity:[58,127,188,62,79,82,196,96],swap:[43,4,237,11,26,201,30,98],collectReward:[18,237,166,197,34,16,213,144]},pc=[188,37,179,131,82,150,84,73],fc=[16,72,250,198,14,162,212,19],Ce=class{static createPoolInstruction(e,t,n,o,r,i,s,u,a,c,l,m,p,f){let y=F([ie("sqrtPriceX64"),A("zero")]),b=[{pubkey:n,isSigner:!0,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!1},{pubkey:a,isSigner:!1,isWritable:!1},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:m,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!1},{pubkey:l,isSigner:!1,isWritable:!1},{pubkey:An.programId,isSigner:!1,isWritable:!1},{pubkey:it,isSigner:!1,isWritable:!1},...(f==null?void 0:f.map(T=>({pubkey:T,isSigner:!1,isWritable:!1})))||[]],g=Buffer.alloc(y.span);y.encode({sqrtPriceX64:p,zero:Ue},g);let P=Buffer.from([...Lt.createPool,...g]);return new st({keys:b,programId:e,data:P})}static async createPoolInstructions(e){let{programId:t,owner:n,mintA:o,mintB:r,ammConfigId:i,initialPriceX64:s,extendMintAccount:u}=e,[a,c]=[new X(o.address),new X(r.address)],{publicKey:l}=tc(t,i,a,c),{publicKey:m}=oc(t,l),{publicKey:p}=Es(t,l,a),{publicKey:f}=Es(t,l,c),y=Qe(t,l).publicKey,b=[this.createPoolInstruction(t,l,n,i,m,a,p,new X(o.programId||Ke),c,f,new X(r.programId||Ke),y,s,u)];return{signers:[],instructions:b,instructionTypes:[U.CreateAccount,U.ClmmCreatePool],address:{poolId:l,observationId:m,exBitmapAccount:y,mintAVault:p,mintBVault:f},lookupTableAddress:[]}}static openPositionFromLiquidityInstruction(e,t,n,o,r,i,s,u,a,c,l,m,p,f,y,b,g,P,T,h,w,k,x,B,K,I){let R=F([Ve("tickLowerIndex"),Ve("tickUpperIndex"),Ve("tickArrayLowerStartIndex"),Ve("tickArrayUpperStartIndex"),ie("liquidity"),A("amountMaxA"),A("amountMaxB"),qe("withMetadata"),V("optionBaseFlag"),qe("baseFlag")]),C=[...I?[{pubkey:I,isSigner:!1,isWritable:!0}]:[]],N=[{pubkey:t,isSigner:!0,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!0,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:m,isSigner:!1,isWritable:!0},{pubkey:p,isSigner:!1,isWritable:!0},{pubkey:f,isSigner:!1,isWritable:!0},{pubkey:y,isSigner:!1,isWritable:!0},{pubkey:it,isSigner:!1,isWritable:!1},{pubkey:An.programId,isSigner:!1,isWritable:!1},{pubkey:Ke,isSigner:!1,isWritable:!1},{pubkey:mi,isSigner:!1,isWritable:!1},{pubkey:jt,isSigner:!1,isWritable:!1},{pubkey:Xe,isSigner:!1,isWritable:!1},{pubkey:b,isSigner:!1,isWritable:!1},{pubkey:g,isSigner:!1,isWritable:!1},...C],L=Buffer.alloc(R.span);R.encode({tickLowerIndex:P,tickUpperIndex:T,tickArrayLowerStartIndex:h,tickArrayUpperStartIndex:w,liquidity:k,amountMaxA:x,amountMaxB:B,withMetadata:K==="create",baseFlag:!1,optionBaseFlag:0},L);let O=Buffer.from([...Lt.openPosition,...L]);return new st({keys:N,programId:e,data:O})}static openPositionFromLiquidityInstruction22(e,t,n,o,r,i,s,u,a,c,l,m,p,f,y,b,g,P,T,h,w,k,x,B,K){let I=F([Ve("tickLowerIndex"),Ve("tickUpperIndex"),Ve("tickArrayLowerStartIndex"),Ve("tickArrayUpperStartIndex"),ie("liquidity"),A("amountMaxA"),A("amountMaxB"),qe("withMetadata"),V("optionBaseFlag"),qe("baseFlag")]),R=[...K?[{pubkey:K,isSigner:!1,isWritable:!0}]:[]],C=[{pubkey:t,isSigner:!0,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!0,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:m,isSigner:!1,isWritable:!0},{pubkey:p,isSigner:!1,isWritable:!0},{pubkey:f,isSigner:!1,isWritable:!0},{pubkey:it,isSigner:!1,isWritable:!1},{pubkey:An.programId,isSigner:!1,isWritable:!1},{pubkey:Ke,isSigner:!1,isWritable:!1},{pubkey:mi,isSigner:!1,isWritable:!1},{pubkey:Xe,isSigner:!1,isWritable:!1},{pubkey:y,isSigner:!1,isWritable:!1},{pubkey:b,isSigner:!1,isWritable:!1},...R],N=Buffer.alloc(I.span);I.encode({tickLowerIndex:g,tickUpperIndex:P,tickArrayLowerStartIndex:T,tickArrayUpperStartIndex:h,liquidity:w,amountMaxA:k,amountMaxB:x,withMetadata:B==="create",baseFlag:!1,optionBaseFlag:0},N);let L=Buffer.from([...Lt.openPositionWithTokenEx,...N]);return new st({keys:C,programId:e,data:L})}static async openPositionInstructions({poolInfo:e,poolKeys:t,ownerInfo:n,tickLower:o,tickUpper:r,liquidity:i,amountMaxA:s,amountMaxB:u,withMetadata:a,getEphemeralSigners:c,nft2022:l}){let m=[],[p,f]=[new X(e.programId),new X(e.id)],y;if(c)y=new X((await c(1))[0]);else{let K=gr.generate();m.push(K),y=K.publicKey}let b=$.getTickArrayStartIndexByTick(o,e.config.tickSpacing),g=$.getTickArrayStartIndexByTick(r,e.config.tickSpacing),{publicKey:P}=ge(p,f,b),{publicKey:T}=ge(p,f,g),{publicKey:h}=l?Z(n.wallet,y,Xe):Z(n.wallet,y,Ke),{publicKey:w}=gn(y),{publicKey:k}=bt(p,y),{publicKey:x}=Jt(p,f,o,r),B=l?this.openPositionFromLiquidityInstruction22(p,n.feePayer,f,n.wallet,y,h,x,P,T,k,n.tokenAccountA,n.tokenAccountB,new X(t.vault.A),new X(t.vault.B),new X(e.mintA.address),new X(e.mintB.address),o,r,b,g,i,s,u,a,Ne.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing,[b,g])?Qe(p,f).publicKey:void 0):this.openPositionFromLiquidityInstruction(p,n.feePayer,f,n.wallet,y,h,w,x,P,T,k,n.tokenAccountA,n.tokenAccountB,new X(t.vault.A),new X(t.vault.B),new X(e.mintA.address),new X(e.mintB.address),o,r,b,g,i,s,u,a,Ne.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing,[b,g])?Qe(p,f).publicKey:void 0);return{signers:m,instructions:[B],instructionTypes:[U.ClmmOpenPosition],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[],address:{nftMint:y,tickArrayLower:P,tickArrayUpper:T,positionNftAccount:h,metadataAccount:w,personalPosition:k,protocolPosition:x}}}static async openPositionFromBaseInstructions({poolInfo:e,poolKeys:t,ownerInfo:n,tickLower:o,tickUpper:r,base:i,baseAmount:s,otherAmountMax:u,withMetadata:a,getEphemeralSigners:c,nft2022:l}){let m=[],[p,f]=[new X(e.programId),new X(e.id)],y;if(c)y=new X((await c(1))[0]);else{let K=gr.generate();m.push(K),y=K.publicKey}let b=$.getTickArrayStartIndexByTick(o,e.config.tickSpacing),g=$.getTickArrayStartIndexByTick(r,e.config.tickSpacing),{publicKey:P}=ge(p,f,b),{publicKey:T}=ge(p,f,g),{publicKey:h}=l?Z(n.wallet,y,Xe):Z(n.wallet,y,Ke),{publicKey:w}=gn(y),{publicKey:k}=bt(p,y),{publicKey:x}=Jt(p,f,o,r),B=l?this.openPositionFromBaseInstruction22(p,n.feePayer,f,n.wallet,y,h,x,P,T,k,n.tokenAccountA,n.tokenAccountB,new X(t.vault.A),new X(t.vault.B),new X(e.mintA.address),new X(e.mintB.address),o,r,b,g,a,i,s,u,Ne.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing,[b,g])?Qe(p,f).publicKey:void 0):this.openPositionFromBaseInstruction(p,n.feePayer,f,n.wallet,y,h,w,x,P,T,k,n.tokenAccountA,n.tokenAccountB,new X(t.vault.A),new X(t.vault.B),new X(e.mintA.address),new X(e.mintB.address),o,r,b,g,a,i,s,u,Ne.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing,[b,g])?Qe(p,f).publicKey:void 0);return{address:{nftMint:y,tickArrayLower:P,tickArrayUpper:T,positionNftAccount:h,metadataAccount:w,personalPosition:k,protocolPosition:x},instructions:[B],signers:m,instructionTypes:[U.ClmmOpenPosition],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[]}}static openPositionFromBaseInstruction(e,t,n,o,r,i,s,u,a,c,l,m,p,f,y,b,g,P,T,h,w,k,x,B,K,I){let R=F([Ve("tickLowerIndex"),Ve("tickUpperIndex"),Ve("tickArrayLowerStartIndex"),Ve("tickArrayUpperStartIndex"),ie("liquidity"),A("amountMaxA"),A("amountMaxB"),qe("withMetadata"),V("optionBaseFlag"),qe("baseFlag")]),C=[...I?[{pubkey:I,isSigner:!1,isWritable:!0}]:[]],N=[{pubkey:t,isSigner:!0,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!0,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:m,isSigner:!1,isWritable:!0},{pubkey:p,isSigner:!1,isWritable:!0},{pubkey:f,isSigner:!1,isWritable:!0},{pubkey:y,isSigner:!1,isWritable:!0},{pubkey:it,isSigner:!1,isWritable:!1},{pubkey:An.programId,isSigner:!1,isWritable:!1},{pubkey:Ke,isSigner:!1,isWritable:!1},{pubkey:mi,isSigner:!1,isWritable:!1},{pubkey:jt,isSigner:!1,isWritable:!1},{pubkey:Xe,isSigner:!1,isWritable:!1},{pubkey:b,isSigner:!1,isWritable:!1},{pubkey:g,isSigner:!1,isWritable:!1},...C],L=Buffer.alloc(R.span);R.encode({tickLowerIndex:P,tickUpperIndex:T,tickArrayLowerStartIndex:h,tickArrayUpperStartIndex:w,liquidity:new zs(0),amountMaxA:x==="MintA"?B:K,amountMaxB:x==="MintA"?K:B,withMetadata:k==="create",baseFlag:x==="MintA",optionBaseFlag:1},L);let O=Buffer.from([...Lt.openPosition,...L]);return new st({keys:N,programId:e,data:O})}static openPositionFromBaseInstruction22(e,t,n,o,r,i,s,u,a,c,l,m,p,f,y,b,g,P,T,h,w,k,x,B,K){let I=F([Ve("tickLowerIndex"),Ve("tickUpperIndex"),Ve("tickArrayLowerStartIndex"),Ve("tickArrayUpperStartIndex"),ie("liquidity"),A("amountMaxA"),A("amountMaxB"),qe("withMetadata"),V("optionBaseFlag"),qe("baseFlag")]),R=[...K?[{pubkey:K,isSigner:!1,isWritable:!0}]:[]],C=[{pubkey:t,isSigner:!0,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!0,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:m,isSigner:!1,isWritable:!0},{pubkey:p,isSigner:!1,isWritable:!0},{pubkey:f,isSigner:!1,isWritable:!0},{pubkey:it,isSigner:!1,isWritable:!1},{pubkey:An.programId,isSigner:!1,isWritable:!1},{pubkey:Ke,isSigner:!1,isWritable:!1},{pubkey:mi,isSigner:!1,isWritable:!1},{pubkey:Xe,isSigner:!1,isWritable:!1},{pubkey:y,isSigner:!1,isWritable:!1},{pubkey:b,isSigner:!1,isWritable:!1},...R],N=Buffer.alloc(I.span);I.encode({tickLowerIndex:g,tickUpperIndex:P,tickArrayLowerStartIndex:T,tickArrayUpperStartIndex:h,liquidity:new zs(0),amountMaxA:k==="MintA"?x:B,amountMaxB:k==="MintA"?B:x,withMetadata:w==="create",baseFlag:k==="MintA",optionBaseFlag:1},N);let L=Buffer.from([...Lt.openPositionWithTokenEx,...N]);return new st({keys:C,programId:e,data:L})}static async openPositionFromLiquidityInstructions({poolInfo:e,poolKeys:t,ownerInfo:n,tickLower:o,tickUpper:r,liquidity:i,amountMaxA:s,amountMaxB:u,withMetadata:a,getEphemeralSigners:c,nft2022:l}){let m,p=[];if(c)m=new X((await c(1))[0]);else{let K=gr.generate();p.push(K),m=K.publicKey}let[f,y]=[new X(e.programId),new X(e.id)],b=$.getTickArrayStartIndexByTick(o,e.config.tickSpacing),g=$.getTickArrayStartIndexByTick(r,e.config.tickSpacing),{publicKey:P}=ge(f,y,b),{publicKey:T}=ge(f,y,g),{publicKey:h}=l?Z(n.wallet,m,Xe):Z(n.wallet,m,Ke),{publicKey:w}=gn(m),{publicKey:k}=bt(f,m),{publicKey:x}=Jt(f,y,o,r),B=l?this.openPositionFromLiquidityInstruction22(f,n.wallet,y,n.wallet,m,h,x,P,T,k,n.tokenAccountA,n.tokenAccountB,new X(t.vault.A),new X(t.vault.B),new X(t.mintA.address),new X(t.mintB.address),o,r,b,g,i,s,u,a,Ne.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing,[b,g])?Qe(f,y).publicKey:void 0):this.openPositionFromLiquidityInstruction(f,n.wallet,y,n.wallet,m,h,w,x,P,T,k,n.tokenAccountA,n.tokenAccountB,new X(t.vault.A),new X(t.vault.B),new X(t.mintA.address),new X(t.mintB.address),o,r,b,g,i,s,u,a,Ne.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing,[b,g])?Qe(f,y).publicKey:void 0);return{address:{nftMint:m,tickArrayLower:P,tickArrayUpper:T,positionNftAccount:h,metadataAccount:w,personalPosition:k,protocolPosition:x},instructions:[B],signers:p,instructionTypes:[U.ClmmOpenPosition],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[]}}static closePositionInstruction(e,t,n,o,r,i){let s=F([]),u=[{pubkey:t,isSigner:!0,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:An.programId,isSigner:!1,isWritable:!1},{pubkey:i?Xe:Ke,isSigner:!1,isWritable:!1}],a=Buffer.alloc(s.span);s.encode({},a);let c=Buffer.from([...Lt.closePosition,...a]);return new st({keys:u,programId:e,data:c})}static closePositionInstructions({poolInfo:e,poolKeys:t,ownerInfo:n,ownerPosition:o,nft2022:r}){let i=new X(e.programId),s=r?Z(n.wallet,o.nftMint,Xe).publicKey:Z(n.wallet,o.nftMint,Ke).publicKey,{publicKey:u}=bt(i,o.nftMint),a=[];return a.push(this.closePositionInstruction(i,n.wallet,o.nftMint,s,u,r)),{address:{positionNftAccount:s,personalPosition:u},signers:[],instructions:a,instructionTypes:[U.ClmmClosePosition],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[]}}static increasePositionFromLiquidityInstruction(e,t,n,o,r,i,s,u,a,c,l,m,p,f,y,b,g,P){let T=F([ie("liquidity"),A("amountMaxA"),A("amountMaxB"),V("optionBaseFlag"),qe("baseFlag")]),h=[...P?[{pubkey:P,isSigner:!1,isWritable:!0}]:[]],w=[{pubkey:t,isSigner:!0,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:m,isSigner:!1,isWritable:!0},{pubkey:Ke,isSigner:!1,isWritable:!1},{pubkey:Xe,isSigner:!1,isWritable:!1},{pubkey:p,isSigner:!1,isWritable:!1},{pubkey:f,isSigner:!1,isWritable:!1},...h],k=Buffer.alloc(T.span);T.encode({liquidity:y,amountMaxA:b,amountMaxB:g,optionBaseFlag:0,baseFlag:!1},k);let x=Buffer.from([...Lt.increaseLiquidity,...k]);return new st({keys:w,programId:e,data:x})}static increasePositionFromLiquidityInstructions({poolInfo:e,poolKeys:t,ownerPosition:n,ownerInfo:o,liquidity:r,amountMaxA:i,amountMaxB:s,nft2022:u}){let[a,c]=[new X(e.programId),new X(e.id)],l=$.getTickArrayStartIndexByTick(n.tickLower,e.config.tickSpacing),m=$.getTickArrayStartIndexByTick(n.tickUpper,e.config.tickSpacing),{publicKey:p}=ge(a,c,l),{publicKey:f}=ge(a,c,m),{publicKey:y}=u?Z(o.wallet,n.nftMint,Xe):Z(o.wallet,n.nftMint,Ke),{publicKey:b}=bt(a,n.nftMint),{publicKey:g}=Jt(a,c,n.tickLower,n.tickUpper),P=this.increasePositionFromLiquidityInstruction(a,o.wallet,y,b,c,g,p,f,o.tokenAccountA,o.tokenAccountB,new X(t.vault.A),new X(t.vault.B),new X(e.mintA.address),new X(e.mintB.address),r,i,s,Ne.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing,[l,m])?Qe(a,c).publicKey:void 0);return{address:{tickArrayLower:p,tickArrayUpper:f,positionNftAccount:y,personalPosition:b,protocolPosition:g},signers:[],instructions:[P],instructionTypes:[U.ClmmIncreasePosition],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[]}}static increasePositionFromBaseInstructions({poolInfo:e,poolKeys:t,ownerPosition:n,ownerInfo:o,base:r,baseAmount:i,otherAmountMax:s,nft2022:u}){let[a,c]=[new X(e.programId),new X(e.id)],l=$.getTickArrayStartIndexByTick(n.tickLower,e.config.tickSpacing),m=$.getTickArrayStartIndexByTick(n.tickUpper,e.config.tickSpacing),{publicKey:p}=ge(a,c,l),{publicKey:f}=ge(a,c,m),{publicKey:y}=u?Z(o.wallet,n.nftMint,Xe):Z(o.wallet,n.nftMint,Ke),{publicKey:b}=bt(a,n.nftMint),{publicKey:g}=Jt(a,c,n.tickLower,n.tickUpper);return{address:{tickArrayLower:p,tickArrayUpper:f,positionNftAccount:y,personalPosition:b,protocolPosition:g},instructions:[this.increasePositionFromBaseInstruction(a,o.wallet,y,b,c,g,p,f,o.tokenAccountA,o.tokenAccountB,new X(t.vault.A),new X(t.vault.B),new X(e.mintA.address),new X(e.mintB.address),r,i,s,Ne.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing,[l,m])?Qe(a,c).publicKey:void 0)],signers:[],instructionTypes:[U.ClmmIncreasePosition],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[]}}static increasePositionFromBaseInstruction(e,t,n,o,r,i,s,u,a,c,l,m,p,f,y,b,g,P){let T=F([ie("liquidity"),A("amountMaxA"),A("amountMaxB"),V("optionBaseFlag"),qe("baseFlag")]),h=[...P?[{pubkey:P,isSigner:!1,isWritable:!0}]:[]],w=[{pubkey:t,isSigner:!0,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:m,isSigner:!1,isWritable:!0},{pubkey:Ke,isSigner:!1,isWritable:!1},{pubkey:Xe,isSigner:!1,isWritable:!1},{pubkey:p,isSigner:!1,isWritable:!1},{pubkey:f,isSigner:!1,isWritable:!1},...h],k=Buffer.alloc(T.span);T.encode({liquidity:new zs(0),amountMaxA:y==="MintA"?b:g,amountMaxB:y==="MintA"?g:b,baseFlag:y==="MintA",optionBaseFlag:1},k);let x=Buffer.from([...Lt.increaseLiquidity,...k]);return new st({keys:w,programId:e,data:x})}static decreaseLiquidityInstruction(e,t,n,o,r,i,s,u,a,c,l,m,p,f,y,b,g,P,T){let h=F([ie("liquidity"),A("amountMinA"),A("amountMinB")]),w=[...T?[{pubkey:T,isSigner:!1,isWritable:!0}]:[],...y.map(K=>[{pubkey:K.poolRewardVault,isSigner:!1,isWritable:!0},{pubkey:K.ownerRewardVault,isSigner:!1,isWritable:!0},{pubkey:K.rewardMint,isSigner:!1,isWritable:!1}]).flat()],k=[{pubkey:t,isSigner:!0,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:m,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:Ke,isSigner:!1,isWritable:!1},{pubkey:Xe,isSigner:!1,isWritable:!1},{pubkey:Xi,isSigner:!1,isWritable:!1},{pubkey:p,isSigner:!1,isWritable:!1},{pubkey:f,isSigner:!1,isWritable:!1},...w],x=Buffer.alloc(h.span);h.encode({liquidity:b,amountMinA:g,amountMinB:P},x);let B=Buffer.from([...Lt.decreaseLiquidity,...x]);return new st({keys:k,programId:e,data:B})}static decreaseLiquidityInstructions({poolInfo:e,poolKeys:t,ownerPosition:n,ownerInfo:o,liquidity:r,amountMinA:i,amountMinB:s,programId:u,nft2022:a}){let[c,l]=[new X(e.programId),new X(e.id)],m=$.getTickArrayStartIndexByTick(n.tickLower,e.config.tickSpacing),p=$.getTickArrayStartIndexByTick(n.tickUpper,e.config.tickSpacing),{publicKey:f}=ge(c,l,m),{publicKey:y}=ge(c,l,p),{publicKey:b}=a?Z(o.wallet,n.nftMint,Xe):Z(o.wallet,n.nftMint,u),{publicKey:g}=bt(c,n.nftMint),{publicKey:P}=Jt(c,l,n.tickLower,n.tickUpper),T=[];for(let k=0;k<e.rewardDefaultInfos.length;k++)T.push({poolRewardVault:new X(t.rewardInfos[k].vault),ownerRewardVault:o.rewardAccounts[k],rewardMint:new X(e.rewardDefaultInfos[k].mint.address)});let h=[],w=this.decreaseLiquidityInstruction(c,o.wallet,b,g,l,P,f,y,o.tokenAccountA,o.tokenAccountB,new X(t.vault.A),new X(t.vault.B),new X(e.mintA.address),new X(e.mintB.address),T,r,i,s,Ne.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing,[m,p])?Qe(c,l).publicKey:void 0);return h.push(w),{address:{tickArrayLower:f,tickArrayUpper:y,positionNftAccount:b,personalPosition:g,protocolPosition:P},signers:[],instructions:h,instructionTypes:[U.ClmmDecreasePosition],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[]}}static swapInstruction(e,t,n,o,r,i,s,u,a,c,l,m,p,f,y,b,g){let P=F([A("amount"),A("otherAmountThreshold"),ie("sqrtPriceLimitX64"),qe("isBaseInput")]),T=[...g?[{pubkey:g,isSigner:!1,isWritable:!0}]:[],...l.map(x=>({pubkey:x,isSigner:!1,isWritable:!0}))],h=[{pubkey:t,isSigner:!0,isWritable:!1},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:m,isSigner:!1,isWritable:!0},{pubkey:Ke,isSigner:!1,isWritable:!1},{pubkey:Xe,isSigner:!1,isWritable:!1},{pubkey:Xi,isSigner:!1,isWritable:!1},{pubkey:a,isSigner:!1,isWritable:!1},{pubkey:c,isSigner:!1,isWritable:!1},...T],w=Buffer.alloc(P.span);P.encode({amount:p,otherAmountThreshold:f,sqrtPriceLimitX64:y,isBaseInput:b},w);let k=Buffer.from([...Lt.swap,...w]);return new st({keys:h,programId:e,data:k})}static makeSwapBaseInInstructions({poolInfo:e,poolKeys:t,observationId:n,ownerInfo:o,inputMint:r,amountIn:i,amountOutMin:s,sqrtPriceLimitX64:u,remainingAccounts:a}){let[c,l]=[new X(e.programId),new X(e.id)],[m,p]=[new X(t.vault.A),new X(t.vault.B)],[f,y]=[new X(e.mintA.address),new X(e.mintB.address)],b=e.mintA.address===r.toString(),g=[this.swapInstruction(c,o.wallet,l,new X(e.config.id),b?o.tokenAccountA:o.tokenAccountB,b?o.tokenAccountB:o.tokenAccountA,b?m:p,b?p:m,b?f:y,b?y:f,a,n,i,s,u,!0,Qe(c,l).publicKey)];return{signers:[],instructions:g,instructionTypes:[U.ClmmSwapBaseIn],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[],address:{}}}static makeSwapBaseOutInstructions({poolInfo:e,poolKeys:t,observationId:n,ownerInfo:o,outputMint:r,amountOut:i,amountInMax:s,sqrtPriceLimitX64:u,remainingAccounts:a}){let[c,l]=[new X(e.programId),new X(e.id)],[m,p]=[new X(t.vault.A),new X(t.vault.B)],[f,y]=[new X(e.mintA.address),new X(e.mintB.address)],b=e.mintA.address===r.toBase58(),g=[this.swapInstruction(c,o.wallet,l,new X(e.config.id),b?o.tokenAccountB:o.tokenAccountA,b?o.tokenAccountA:o.tokenAccountB,b?p:m,b?m:p,b?y:f,b?f:y,a,n,i,s,u,!1,Qe(c,l).publicKey)];return{signers:[],instructions:g,instructionTypes:[U.ClmmSwapBaseOut],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[],address:{}}}static initRewardInstruction(e,t,n,o,r,i,s,u,a,c,l,m){let p=F([A("openTime"),A("endTime"),ie("emissionsPerSecondX64")]),f=[{pubkey:t,isSigner:!0,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!1},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!1},{pubkey:An.programId,isSigner:!1,isWritable:!1},{pubkey:it,isSigner:!1,isWritable:!1}],y=Buffer.alloc(p.span);p.encode({openTime:te(c),endTime:te(l),emissionsPerSecondX64:m},y);let b=Buffer.from([...Lt.initReward,...y]);return new st({keys:f,programId:e,data:b})}static initRewardInstructions({poolInfo:e,poolKeys:t,ownerInfo:n,rewardInfo:o}){let[r,i]=[new X(e.programId),new X(e.id)],s=nc(r,i,o.mint).publicKey,u=ai(r).publicKey,a=[this.initRewardInstruction(r,n.wallet,i,u,new X(e.config.id),n.tokenAccount,o.programId,o.mint,s,o.openTime,o.endTime,o.emissionsPerSecondX64)];return{address:{poolRewardVault:s,operationId:u},signers:[],instructions:a,instructionTypes:[U.ClmmInitReward],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[]}}static setRewardInstruction(e,t,n,o,r,i,s,u,a,c,l,m){let p=F([V("rewardIndex"),ie("emissionsPerSecondX64"),A("openTime"),A("endTime")]),f=[{pubkey:t,isSigner:!0,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:Ke,isSigner:!1,isWritable:!1},{pubkey:Xe,isSigner:!1,isWritable:!1},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0}],y=Buffer.alloc(p.span);p.encode({rewardIndex:a,emissionsPerSecondX64:m,openTime:te(c),endTime:te(l)},y);let b=Buffer.from([...Lt.setRewardEmissions,...y]);return new st({keys:f,programId:e,data:b})}static setRewardInstructions({poolInfo:e,poolKeys:t,ownerInfo:n,rewardInfo:o}){let[r,i]=[new X(e.programId),new X(e.id)],s,u,a;for(let m=0;m<e.rewardDefaultInfos.length;m++)e.rewardDefaultInfos[m].mint.address===o.mint.toString()&&(s=m,u=new X(t.rewardInfos[m].vault),a=new X(t.rewardInfos[m].mint.address));(s===void 0||u===void 0)&&dc.logWithError("reward mint check error","no reward mint",e.rewardDefaultInfos);let c=ai(r).publicKey,l=[this.setRewardInstruction(r,n.wallet,i,c,new X(e.config.id),n.tokenAccount,u,a,s,o.openTime,o.endTime,o.emissionsPerSecondX64)];return{address:{rewardVault:u,operationId:c},signers:[],instructions:l,instructionTypes:[U.ClmmSetReward],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[]}}static collectRewardInstruction(e,t,n,o,r,i,s){let u=F([V("rewardIndex")]),a=[{pubkey:t,isSigner:!0,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!1},{pubkey:Ke,isSigner:!1,isWritable:!1},{pubkey:Xe,isSigner:!1,isWritable:!1},{pubkey:Xi,isSigner:!1,isWritable:!1}],c=Buffer.alloc(u.span);u.encode({rewardIndex:s},c);let l=Buffer.from([...Lt.collectReward,...c]);return new st({keys:a,programId:e,data:l})}static collectRewardInstructions({poolInfo:e,poolKeys:t,ownerInfo:n,rewardMint:o}){let[r,i]=[new X(e.programId),new X(e.id)],s,u;for(let c=0;c<e.rewardDefaultInfos.length;c++)e.rewardDefaultInfos[c].mint.address===o.toString()&&(s=c,u=new X(t.rewardInfos[c].vault));(s===void 0||u===void 0)&&dc.logWithError("reward mint check error","no reward mint",e.rewardDefaultInfos);let a=[this.collectRewardInstruction(r,n.wallet,i,n.tokenAccount,u,o,s)];return{address:{rewardVault:u},signers:[],instructions:a,instructionTypes:[U.ClmmCollectReward],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[]}}static async makeLockPositions({programId:e,authProgramId:t,poolProgramId:n,payer:o,wallet:r,nftMint:i,nft2022:s,getEphemeralSigners:u}){let a=[],c;if(u)c=new X((await u(1))[0]);else{let g=gr.generate();a.push(g),c=g.publicKey}let l=s?Z(r,i,Xe).publicKey:Z(r,i,Ke).publicKey,{publicKey:m}=bt(n,i),p=ho(e,c).publicKey,f=Z(r,c,Ke).publicKey,y=gn(c).publicKey,b=Ce.lockPositionInstructionV2({programId:e,auth:t,payer:o,positionOwner:r,lockOwner:r,positionNftAccount:l,positionId:m,lockPositionId:p,lockNftMint:c,lockNftAccount:f,metadataAccount:y,withMetadata:!0,nft2022:s,positionNftMint:i,authPositionNftAccount:Z(t,i,s?Xe:Ke).publicKey,positionNftProgram:s?Xe:Ke});return{address:{positionId:m,lockPositionId:p,lockNftAccount:f,lockNftMint:c,positionNftAccount:l,metadataAccount:y},instructions:[b],signers:a,instructionTypes:[U.ClmmLockPosition],lookupTableAddress:[]}}static lockPositionInstructionV2({programId:e,auth:t,payer:n,positionOwner:o,lockOwner:r,positionNftAccount:i,positionId:s,positionNftMint:u,authPositionNftAccount:a,positionNftProgram:c,lockPositionId:l,lockNftMint:m,lockNftAccount:p,metadataAccount:f,withMetadata:y}){let b=[{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!0,isWritable:!0},{pubkey:o,isSigner:!0,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!1},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!1},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:m,isSigner:!0,isWritable:!0},{pubkey:p,isSigner:!1,isWritable:!0},{pubkey:f,isSigner:!1,isWritable:!0},{pubkey:jt,isSigner:!1,isWritable:!1},{pubkey:mi,isSigner:!1,isWritable:!1},{pubkey:it,isSigner:!1,isWritable:!1},{pubkey:Ke,isSigner:!1,isWritable:!1},{pubkey:c,isSigner:!1,isWritable:!1},{pubkey:An.programId,isSigner:!1,isWritable:!1}],g=F([qe("withMetadata")]),P=Buffer.alloc(g.span);g.encode({withMetadata:y},P);let T=Buffer.from([...pc,...P]);return new st({keys:b,programId:e,data:T})}static lockPositionInstruction({programId:e,authProgramId:t,poolProgramId:n,owner:o,positionNft:r}){let{publicKey:i}=Z(o,r,Ke),{publicKey:s}=bt(n,r),u=[{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!0,isWritable:!1},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!1},{pubkey:Ws(e,s).publicKey,isSigner:!1,isWritable:!0},{pubkey:Ke,isSigner:!1,isWritable:!1},{pubkey:An.programId,isSigner:!1,isWritable:!1}];return new st({keys:u,programId:e,data:Buffer.from(pc)})}static harvestLockPositionInstruction(e){let[t,n]=[new X(e.poolKeys.programId),new X(e.poolKeys.id)],o=$.getTickArrayStartIndexByTick(e.ownerPosition.tickLower,e.poolKeys.config.tickSpacing),r=$.getTickArrayStartIndexByTick(e.ownerPosition.tickUpper,e.poolKeys.config.tickSpacing),{publicKey:i}=ge(t,n,o),{publicKey:s}=ge(t,n,r),{publicKey:u}=Z(e.owner,e.ownerPosition.nftMint,Ke),{publicKey:a}=bt(t,e.ownerPosition.nftMint),{publicKey:c}=Jt(t,n,e.ownerPosition.tickLower,e.ownerPosition.tickUpper),l=[];for(let f=0;f<e.poolKeys.rewardInfos.length;f++)l.push({poolRewardVault:new X(e.poolKeys.rewardInfos[f].vault),ownerRewardVault:e.ownerRewardAccounts[f],rewardMint:new X(e.poolKeys.rewardInfos[f].mint.address)});let m=[...l.map(f=>[{pubkey:f.poolRewardVault,isSigner:!1,isWritable:!0},{pubkey:f.ownerRewardVault,isSigner:!1,isWritable:!0},{pubkey:f.rewardMint,isSigner:!1,isWritable:!1}]).flat()],p=[{pubkey:e.authProgramId,isSigner:!1,isWritable:!1},{pubkey:Ws(e.programId,a).publicKey,isSigner:!1,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:e.owner,isSigner:!0,isWritable:!1},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:new X(e.poolKeys.vault.A),isSigner:!1,isWritable:!0},{pubkey:new X(e.poolKeys.vault.B),isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:e.userVaultA,isSigner:!1,isWritable:!0},{pubkey:e.userVaultB,isSigner:!1,isWritable:!0},{pubkey:Ke,isSigner:!1,isWritable:!1},{pubkey:Xe,isSigner:!1,isWritable:!1},{pubkey:xn,isSigner:!1,isWritable:!1},{pubkey:new X(e.poolKeys.mintA.address),isSigner:!1,isWritable:!1},{pubkey:new X(e.poolKeys.mintB.address),isSigner:!1,isWritable:!1},...m];return new st({keys:p,programId:e.programId,data:Buffer.from(fc)})}static harvestLockPositionInstructionV2({programId:e,auth:t,lockPositionId:n,clmmProgram:o,lockOwner:r,lockNftMint:i,lockNftAccount:s,positionNftAccount:u,positionId:a,poolId:c,protocolPosition:l,vaultA:m,vaultB:p,tickArrayLower:f,tickArrayUpper:y,userVaultA:b,userVaultB:g,mintA:P,mintB:T,rewardAccounts:h,exTickArrayBitmap:w}){let k=[...w?[{pubkey:w,isSigner:!1,isWritable:!0}]:[],...h.map(B=>[{pubkey:B.poolRewardVault,isSigner:!1,isWritable:!0},{pubkey:B.ownerRewardVault,isSigner:!1,isWritable:!0},{pubkey:B.rewardMint,isSigner:!1,isWritable:!1}]).flat()],x=[{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!0,isWritable:!1},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:m,isSigner:!1,isWritable:!0},{pubkey:p,isSigner:!1,isWritable:!0},{pubkey:f,isSigner:!1,isWritable:!0},{pubkey:y,isSigner:!1,isWritable:!0},{pubkey:b,isSigner:!1,isWritable:!0},{pubkey:g,isSigner:!1,isWritable:!0},{pubkey:Ke,isSigner:!1,isWritable:!1},{pubkey:Xe,isSigner:!1,isWritable:!1},{pubkey:xn,isSigner:!1,isWritable:!1},{pubkey:P,isSigner:!1,isWritable:!1},{pubkey:T,isSigner:!1,isWritable:!1},...k];return new st({keys:x,programId:e,data:Buffer.from(fc)})}};var pd=F([mt("mintAuthorityOption"),M("mintAuthority"),A("supply"),V("decimals"),V("isInitialized"),mt("freezeAuthorityOption"),M("freezeAuthority")]);import{PublicKey as RT}from"@solana/web3.js";import{MintLayout as OT,TOKEN_PROGRAM_ID as MT}from"@solana/spl-token";var Pr=d=>new De({mint:d.address,decimals:d.decimals,symbol:d.symbol,name:d.name}),di=o=>{var r=o,{amount:d,isRaw:e,name:t}=r,n=ve(r,["amount","isRaw","name"]);return new xe(new De({mint:ct(n.address).toBase58(),decimals:n.decimals,symbol:n.symbol,name:t}),d,e,t)};var pt=o=>{var r=o,{address:d,programId:e,decimals:t}=r,n=ve(r,["address","programId","decimals"]);return v({chainId:101,address:ct(d).toBase58(),programId:e,logoURI:"",symbol:"",name:"",decimals:t,tags:[],extensions:n.extensions||{}},n)},vn=d=>d?D(v({},d),{transferFeeConfigAuthority:d.transferFeeConfigAuthority.toBase58(),withdrawWithheldAuthority:d.withdrawWithheldAuthority.toBase58(),withheldAmount:d.withheldAmount.toString(),olderTransferFee:D(v({},d.olderTransferFee),{epoch:d.olderTransferFee.epoch.toString(),maximumFee:d.olderTransferFee.maximumFee.toString()}),newerTransferFee:D(v({},d.newerTransferFee),{epoch:d.newerTransferFee.epoch.toString(),maximumFee:d.newerTransferFee.maximumFee.toString()})}):void 0;import yc from"bn.js";var Ys=new yc(25),Ar=new yc(1e4);import{PublicKey as un,SystemProgram as yd,SYSVAR_RENT_PUBKEY as JT,TransactionInstruction as xo}from"@solana/web3.js";import{ASSOCIATED_TOKEN_PROGRAM_ID as bd,TOKEN_PROGRAM_ID as fi}from"@solana/spl-token";var Qs=F([V("instruction"),A("amountIn"),A("minAmountOut")]),Hs=F([V("instruction"),A("maxAmountIn"),A("amountOut")]),HT=F([V("instruction"),V("nonce")]),fd=F([V("instruction"),V("nonce"),A("startTime")]),pi=F([A("status"),A("nonce"),A("maxOrder"),A("depth"),A("baseDecimal"),A("quoteDecimal"),A("state"),A("resetFlag"),A("minSize"),A("volMaxCutRatio"),A("amountWaveRatio"),A("baseLotSize"),A("quoteLotSize"),A("minPriceMultiplier"),A("maxPriceMultiplier"),A("systemDecimalValue"),A("minSeparateNumerator"),A("minSeparateDenominator"),A("tradeFeeNumerator"),A("tradeFeeDenominator"),A("pnlNumerator"),A("pnlDenominator"),A("swapFeeNumerator"),A("swapFeeDenominator"),A("baseNeedTakePnl"),A("quoteNeedTakePnl"),A("quoteTotalPnl"),A("baseTotalPnl"),A("poolOpenTime"),A("punishPcAmount"),A("punishCoinAmount"),A("orderbookToInitTime"),ie("swapBaseInAmount"),ie("swapQuoteOutAmount"),A("swapBase2QuoteFee"),ie("swapQuoteInAmount"),ie("swapBaseOutAmount"),A("swapQuote2BaseFee"),M("baseVault"),M("quoteVault"),M("baseMint"),M("quoteMint"),M("lpMint"),M("openOrders"),M("marketId"),M("marketProgramId"),M("targetOrders"),M("withdrawQueue"),M("lpVault"),M("owner"),A("lpReserve"),Y(A(),3,"padding")]),jT=F([A("accountType"),A("status"),A("nonce"),A("maxOrder"),A("depth"),A("baseDecimal"),A("quoteDecimal"),A("state"),A("resetFlag"),A("minSize"),A("volMaxCutRatio"),A("amountWaveRatio"),A("baseLotSize"),A("quoteLotSize"),A("minPriceMultiplier"),A("maxPriceMultiplier"),A("systemDecimalsValue"),A("abortTradeFactor"),A("priceTickMultiplier"),A("priceTick"),A("minSeparateNumerator"),A("minSeparateDenominator"),A("tradeFeeNumerator"),A("tradeFeeDenominator"),A("pnlNumerator"),A("pnlDenominator"),A("swapFeeNumerator"),A("swapFeeDenominator"),A("baseNeedTakePnl"),A("quoteNeedTakePnl"),A("quoteTotalPnl"),A("baseTotalPnl"),A("poolOpenTime"),A("punishPcAmount"),A("punishCoinAmount"),A("orderbookToInitTime"),ie("swapBaseInAmount"),ie("swapQuoteOutAmount"),ie("swapQuoteInAmount"),ie("swapBaseOutAmount"),A("swapQuote2BaseFee"),A("swapBase2QuoteFee"),M("baseVault"),M("quoteVault"),M("baseMint"),M("quoteMint"),M("lpMint"),M("modelDataAccount"),M("openOrders"),M("marketId"),M("marketProgramId"),M("targetOrders"),M("owner"),Y(A(),64,"padding")]),js=F([V("instruction"),A("baseAmountIn"),A("quoteAmountIn"),A("fixedSide"),A("otherAmountMin")]),$s=F([V("instruction"),A("lpAmount"),A("baseAmountMin"),A("quoteAmountMin")]);var bc=F([A("fee")]);var gc=be("Raydium_liquidity_instruction");function Pc(d){let{poolInfo:e,poolKeys:t,userKeys:n,baseAmountIn:o,quoteAmountIn:r,fixedSide:i,otherAmountMin:s,modelDataPubKey:u=Un}=d,a=Buffer.alloc(js.span);js.encode({instruction:3,baseAmountIn:te(o),quoteAmountIn:te(r),otherAmountMin:te(s),fixedSide:i==="base"?kt:ja},a);let c=[S({pubkey:fi,isWritable:!1}),S({pubkey:new un(e.id)}),S({pubkey:new un(t.authority),isWritable:!1}),S({pubkey:new un(t.openOrders),isWritable:!1}),S({pubkey:new un(t.targetOrders)}),S({pubkey:new un(e.lpMint.address)}),S({pubkey:new un(t.vault.A)}),S({pubkey:new un(t.vault.B)})];return e.pooltype.includes("StablePool")&&c.push(S({pubkey:u})),c.push(S({pubkey:new un(e.marketId),isWritable:!1}),S({pubkey:n.baseTokenAccount}),S({pubkey:n.quoteTokenAccount}),S({pubkey:n.lpTokenAccount}),S({pubkey:n.owner,isWritable:!1,isSigner:!0}),S({pubkey:new un(t.marketEventQueue),isWritable:!1})),new xo({programId:new un(e.programId),keys:c,data:a})}function Zs(d){let{poolInfo:e,poolKeys:t,userKeys:n,lpAmount:o,baseAmountMin:r,quoteAmountMin:i,modelDataPubKey:s=Un}=d,u=rt(t),a=4;if(e.pooltype.includes("StablePool")&&(a=5),a===4||a===5){let c=Buffer.alloc($s.span);$s.encode({instruction:4,lpAmount:te(o),baseAmountMin:te(r),quoteAmountMin:te(i)},c);let l=[S({pubkey:fi,isWritable:!1}),S({pubkey:u.id}),S({pubkey:u.authority,isWritable:!1}),S({pubkey:u.openOrders}),S({pubkey:u.targetOrders}),S({pubkey:u.mintLp.address}),S({pubkey:u.vault.A}),S({pubkey:u.vault.B})];return a===5?l.push(S({pubkey:s})):(l.push(S({pubkey:u.id})),l.push(S({pubkey:u.id}))),l.push(S({pubkey:u.marketProgramId,isWritable:!1}),S({pubkey:u.marketId}),S({pubkey:u.marketBaseVault}),S({pubkey:u.marketQuoteVault}),S({pubkey:u.marketAuthority,isWritable:!1}),S({pubkey:n.lpTokenAccount}),S({pubkey:n.baseTokenAccount}),S({pubkey:n.quoteTokenAccount}),S({pubkey:n.owner,isWritable:!1,isSigner:!0}),S({pubkey:u.marketEventQueue}),S({pubkey:u.marketBids}),S({pubkey:u.marketAsks})),new xo({programId:u.programId,keys:l,data:c})}return new xo({programId:u.programId,keys:[]})}function Js({programId:d,ammId:e,ammAuthority:t,ammOpenOrders:n,lpMint:o,coinMint:r,pcMint:i,coinVault:s,pcVault:u,withdrawQueue:a,ammTargetOrders:c,poolTempLp:l,marketProgramId:m,marketId:p,userWallet:f,userCoinVault:y,userPcVault:b,userLpVault:g,nonce:P,openTime:T,coinAmount:h,pcAmount:w,ammConfigId:k,feeDestinationId:x}){let B=F([V("instruction"),V("nonce"),A("openTime"),A("pcAmount"),A("coinAmount")]),K=[{pubkey:fi,isSigner:!1,isWritable:!1},{pubkey:bd,isSigner:!1,isWritable:!1},{pubkey:yd.programId,isSigner:!1,isWritable:!1},{pubkey:it,isSigner:!1,isWritable:!1},{pubkey:e,isSigner:!1,isWritable:!0},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!1},{pubkey:i,isSigner:!1,isWritable:!1},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:k,isSigner:!1,isWritable:!1},{pubkey:x,isSigner:!1,isWritable:!0},{pubkey:m,isSigner:!1,isWritable:!1},{pubkey:p,isSigner:!1,isWritable:!1},{pubkey:f,isSigner:!0,isWritable:!0},{pubkey:y,isSigner:!1,isWritable:!0},{pubkey:b,isSigner:!1,isWritable:!0},{pubkey:g,isSigner:!1,isWritable:!0}],I=Buffer.alloc(B.span);return B.encode({instruction:1,nonce:P,openTime:T,coinAmount:h,pcAmount:w},I),{instruction:new xo({keys:K,programId:d,data:I}),instructionType:U.AmmV4CreatePool}}function gd({poolKeys:d,userKeys:e,amountIn:t,minAmountOut:n,modelDataPubKey:o=Un},r){let i=rt(d),s=Buffer.alloc(Qs.span);Qs.encode({instruction:9,amountIn:te(t),minAmountOut:te(n)},s);let u=[S({pubkey:fi,isWritable:!1}),S({pubkey:i.id}),S({pubkey:i.authority,isWritable:!1}),S({pubkey:i.openOrders})];return r===4&&u.push(S({pubkey:i.targetOrders})),u.push(S({pubkey:i.vault.A}),S({pubkey:i.vault.B})),r===5&&u.push(S({pubkey:o})),u.push(S({pubkey:i.marketProgramId,isWritable:!1}),S({pubkey:i.marketId}),S({pubkey:i.marketBids}),S({pubkey:i.marketAsks}),S({pubkey:i.marketEventQueue}),S({pubkey:i.marketBaseVault}),S({pubkey:i.marketQuoteVault}),S({pubkey:i.marketAuthority,isWritable:!1}),S({pubkey:e.tokenAccountIn}),S({pubkey:e.tokenAccountOut}),S({pubkey:e.owner,isWritable:!1,isSigner:!0})),new xo({programId:i.programId,keys:u,data:s})}function Pd({poolKeys:d,userKeys:e,maxAmountIn:t,amountOut:n,modelDataPubKey:o=Un},r){let i=rt(d),s=Buffer.alloc(Hs.span);Hs.encode({instruction:11,maxAmountIn:te(t),amountOut:te(n)},s);let u=[S({pubkey:fi,isWritable:!1}),S({pubkey:i.id}),S({pubkey:i.authority,isWritable:!1}),S({pubkey:i.openOrders}),S({pubkey:i.targetOrders}),S({pubkey:i.vault.A}),S({pubkey:i.vault.B})];return r===5&&u.push(S({pubkey:o})),u.push(S({pubkey:i.marketProgramId,isWritable:!1}),S({pubkey:i.marketId}),S({pubkey:i.marketBids}),S({pubkey:i.marketAsks}),S({pubkey:i.marketEventQueue}),S({pubkey:i.marketBaseVault}),S({pubkey:i.marketQuoteVault}),S({pubkey:i.marketAuthority,isWritable:!1}),S({pubkey:e.tokenAccountIn}),S({pubkey:e.tokenAccountOut}),S({pubkey:e.owner,isWritable:!1,isSigner:!0})),new xo({programId:i.programId,keys:u,data:s})}function kr(d){let{poolKeys:e,version:t,userKeys:n,amountIn:o,amountOut:r,fixedSide:i}=d;if(t===4||t===5){let s={poolKeys:e,userKeys:n};if(i==="in")return gd(D(v({},s),{amountIn:o,minAmountOut:r}),t);if(i==="out")return Pd(D(v({},s),{maxAmountIn:o,amountOut:r}),t);gc.logWithError("invalid params","params",d)}throw gc.logWithError("invalid version","poolKeys.version",t),new Error("invalid version")}var no=5e4,Ad=F([A("x"),A("y"),A("price")]),kd=F([A("accountType"),A("status"),A("multiplier"),A("validDataCount"),Y(Ad,no,"DataElement")]);function wd(d,e){return[0,no-2]}function Td(d){return[0,no-2]}function hd(d){return[0,no-2]}function Id(d,e,t){let[n,o]=wd(e,t),r=n,i=o,s=0,u=e*d.multiplier/t;for(;r<=i;){if(s=Math.floor((i+r)/2),s===0||s>=no-2)return[s,s,!1];let a=d.DataElement[s].x*d.multiplier/d.DataElement[s].y,c=d.DataElement[s-1].x*d.multiplier/d.DataElement[s-1].y,l=d.DataElement[s+1].x*d.multiplier/d.DataElement[s+1].y;if(u===a)return[s,s,!0];if(u===c)return[s-1,s-1,!0];if(u===l)return[s+1,s+1,!0];if(u<c)i=s-1;else{if(u>c&&u<a)return[s-1,s,!0];if(u>a&&u<l)return[s,s+1,!0];r=s+1}}return[s,s,!1]}function ea(d,e,t){let[n,o,r]=Id(d,e,t);if(!r)return 0;if(n===o){let i=d.DataElement[n].x;return e*d.multiplier/i}else{let i=d.DataElement[n].x,s=d.DataElement[n].y,u=d.DataElement[o].x,a=d.DataElement[o].y,c=t*(u*s-i*a),l=i*c,m=(u-i)*(e*s-i*t)*a,p=l+m;return e*d.multiplier*c/p}}function to(d,e,t){return e*d.multiplier/t}function Ac(d,e,t){return e*t/d.multiplier}function Bd(d,e){let[t,n]=Td(e),o=t,r=n,i=0,s=e;for(;o<r;){if(i=Math.floor((r+o)/2),i<=0||i>no-2)return[i,i,!1];let u=d.DataElement[i].x,a=d.DataElement[i-1].x,c=d.DataElement[i+1].x;if(s===u)return[i,i,!0];if(s===a)return[i-1,i-1,!0];if(s===c)return[i+1,i+1,!0];if(s<a)r=i-1;else{if(s>a&&s<u)return[i-1,i,!0];if(s>u&&s<c)return[i,i+1,!0];o=i+1}}return[i,i,!1]}function xd(d,e){let[t,n]=hd(e),o=t,r=n,i=0,s=e;for(;o<=r;){if(i=Math.floor((r+o)/2),i<=0||i>=no-2)return[i,i,!1];let u=d.DataElement[i].y,a=d.DataElement[i-1].y,c=d.DataElement[i+1].y;if(s===u)return[i,i,!0];if(s===a)return[i-1,i-1,!0];if(s===c)return[i+1,i+1,!0];if(s<c)o=i+1;else{if(s<a&&s>u)return[i-1,i,!0];if(s<u&&s>c)return[i,i+1,!0];r=i-1}}return[i,i,!1]}function kc(d,e,t,n){let o=n?e+t:e-t,[r,i,s]=Bd(d,o);if(!s)return[0,0,!1,s];if(r===i)return[d.DataElement[i].price,d.DataElement[i].y,!1,s];{let u=d.DataElement[r].x,a=d.DataElement[i].x,c=d.DataElement[r].price,l=d.DataElement[i].price,m=d.DataElement[r].y,p=d.DataElement[i].y;if(e>=u&&e<=a)return n?[l,p,!0,s]:[c,m,!0,s];{let f,y;return n?(f=c+(l-c)*(e-u)/(a-u),y=m-(o-u)*d.multiplier/l):(f=c+(l-c)*(e-u)/(a-u),y=p+(a-o)*d.multiplier/c),[f,y,!1,s]}}}function Sd(d,e,t,n){let o=n?e-t:e+t,[r,i,s]=xd(d,o);if(!s)return[0,0,!1,s];if(r===i)return[d.DataElement[i].price,d.DataElement[i].x,!1,s];{let u=d.DataElement[r].x,a=d.DataElement[i].x,c=d.DataElement[r].price,l=d.DataElement[i].price,m=d.DataElement[r].y,p=d.DataElement[i].y;if(e>=p&&e<=m)return n?[l,a,!0,s]:[c,u,!0,s];{let f,y;return n?(f=c+(l-c)*(m-e)/(m-p),y=u+l*(m-o)/d.multiplier):(f=c+(l-c)*(m-e)/(m-p),y=a-c*(o-p)/d.multiplier),[f,y,!1,s]}}}function Kd(d,e){let t=kc(d,e,0,!1);return t[3]?t[0]:0}function wc(d,e,t,n){let o=ea(d,e,t),r=to(d,e,o),i=to(d,t,o),s=to(d,n,o),u=!0,[a,c,l,m]=kc(d,r,s,u);if(!m)return 0;if(l)return n*d.multiplier/a;{let p=i-c;return Ac(d,p,o)}}function Tc(d,e,t,n){let o=ea(d,e,t),r=to(d,e,o),i=to(d,t,o),s=to(d,n,o),u=!1,[a,c,l,m]=Sd(d,i,s,u);if(!m)return 0;if(l)return n*a/d.multiplier;{let p=r-c;return Ac(d,p,o)}}function Cd(d){let e=kd.decode(d);return{accountType:e.accountType.toNumber(),status:e.status.toNumber(),multiplier:e.multiplier.toNumber(),validDataCount:e.validDataCount.toNumber(),DataElement:e.DataElement.map(t=>({x:t.x.toNumber(),y:t.y.toNumber(),price:t.price.toNumber()}))}}function hc(d,e,t,n){let o=Kd(d,to(d,e,ea(d,e,t)))/d.multiplier;return n?o:1/o}var yi=class{constructor({connection:e,modelDataPubKey:t=Un}){this._layoutData={accountType:0,status:0,multiplier:0,validDataCount:0,DataElement:[]};this.connection=e,this.modelDataPubKey=t}get stableModelData(){return this._layoutData}async initStableModelLayout(){if(this._layoutData.validDataCount===0&&this.connection){let e=await this.connection.getAccountInfo(this.modelDataPubKey);e&&(this._layoutData=Cd(e==null?void 0:e.data))}}};import{PublicKey as Od}from"@solana/web3.js";import Ch from"bn.js";import wr from"decimal.js";import{TOKEN_PROGRAM_ID as Nd}from"@solana/spl-token";import{PublicKey as Rd}from"@solana/web3.js";var Ld=be("Raydium_liquidity_serum");function Ic({programId:d,marketId:e}){let t=[e.toBuffer()],n=0,o;for(;n<100;){try{let r=t.concat(Buffer.from([n]),Buffer.alloc(7));o=Rd.createProgramAddressSync(r,d)}catch(r){if(r instanceof TypeError)throw r;n++;continue}return{publicKey:o,nonce:n}}throw Ld.logWithError("unable to find a viable program address nonce","params",{programId:d,marketId:e}),new Error("unable to find a viable program address nonce")}function Tr({programId:d}){let{publicKey:e}=ce([Buffer.from("amm_config_account_seed","utf-8")],d);return e}function oo({name:d,programId:e,marketId:t}){let{publicKey:n}=ce([e.toBuffer(),t.toBuffer(),Buffer.from(d,"utf-8")],e);return n}function Md({programId:d,marketId:e}){let{publicKey:t}=ce([d.toBuffer(),e.toBuffer(),Buffer.from("open_order_associated_seed","utf-8")],d);return t}function na({programId:d}){return ce([Buffer.from([97,109,109,32,97,117,116,104,111,114,105,116,121])],d)}function oa({version:d,marketVersion:e,marketId:t,baseMint:n,quoteMint:o,baseDecimals:r,quoteDecimals:i,programId:s,marketProgramId:u}){let a=oo({name:"amm_associated_seed",programId:s,marketId:t}),c=oo({name:"lp_mint_associated_seed",programId:s,marketId:t}),{publicKey:l,nonce:m}=na({programId:s}),p=oo({name:"coin_vault_associated_seed",programId:s,marketId:t}),f=oo({name:"pc_vault_associated_seed",programId:s,marketId:t}),y=oo({name:"temp_lp_token_associated_seed",programId:s,marketId:t}),b=Md({programId:s,marketId:t}),g=oo({name:"target_associated_seed",programId:s,marketId:t}),P=oo({name:"withdraw_associated_seed",programId:s,marketId:t}),{publicKey:T}=Ic({programId:u,marketId:t});return{id:a,baseMint:n,quoteMint:o,lpMint:c,baseDecimals:r,quoteDecimals:i,lpDecimals:r,version:d,programId:s,authority:l,nonce:m,baseVault:p,quoteVault:f,lpVault:y,openOrders:b,targetOrders:g,withdrawQueue:P,marketVersion:e,marketProgramId:u,marketId:t,marketAuthority:T,lookupTableAccount:Od.default,configId:Tr({programId:s})}}var ta={volume:0,volumeQuote:0,volumeFee:0,apr:0,feeApr:0,priceMin:0,priceMax:0,rewardApr:[]},hr=d=>{let e={},t=Nd.toBase58();return Object.keys(d).map(n=>{let o=d[n],[r,i]=[o.baseMint.toBase58(),o.quoteMint.toBase58()];e[n]={id:n,version:4,status:o.status.toNumber(),programId:o.programId.toBase58(),mintA:pt({address:r,programId:t,decimals:o.baseDecimal.toNumber()}),mintB:pt({address:i,programId:t,decimals:o.quoteDecimal.toNumber()}),rewardDefaultInfos:[],rewardDefaultPoolInfos:"Ecosystem",price:o.poolPrice.toNumber(),mintAmountA:new wr(o.mintAAmount.toString()).div(10**o.baseDecimal.toNumber()).toNumber(),mintAmountB:new wr(o.mintBAmount.toString()).div(10**o.quoteDecimal.toNumber()).toNumber(),baseReserve:o.baseReserve,quoteReserve:o.quoteReserve,feeRate:new wr(o.tradeFeeNumerator.toString()).div(o.tradeFeeDenominator.toString()).toNumber(),openTime:o.poolOpenTime.toString(),tvl:0,day:ta,week:ta,month:ta,pooltype:[],farmUpcomingCount:0,farmOngoingCount:0,farmFinishedCount:0,type:"Standard",marketId:o.marketId.toBase58(),configId:Tr({programId:o.programId}).toBase58(),lpPrice:0,lpAmount:new wr(o.lpReserve.toString()).div(10**Math.min(o.baseDecimal.toNumber(),o.quoteDecimal.toNumber())).toNumber(),lpMint:pt({address:o.lpMint.toBase58(),programId:t,decimals:Math.min(o.baseDecimal.toNumber(),o.quoteDecimal.toNumber())}),burnPercent:0}}),e};import ze from"bn.js";import Re from"decimal.js";import{PublicKey as bi}from"@solana/web3.js";import gi from"bn.js";import{TOKEN_PROGRAM_ID as Kc}from"@solana/spl-token";import{SystemProgram as io,SYSVAR_RENT_PUBKEY as Fd,Transaction as Bc,TransactionInstruction as _d}from"@solana/web3.js";import{createInitializeAccountInstruction as xc,TOKEN_PROGRAM_ID as Sc}from"@solana/spl-token";function vd(d="accountFlags"){let e=new cr(d);return e.addBoolean("initialized"),e.addBoolean("market"),e.addBoolean("openOrders"),e.addBoolean("requestQueue"),e.addBoolean("eventQueue"),e.addBoolean("bids"),e.addBoolean("asks"),e}var ia=F([we(5),vd("accountFlags"),M("ownAddress"),A("vaultSignerNonce"),M("baseMint"),M("quoteMint"),M("baseVault"),A("baseDepositsTotal"),A("baseFeesAccrued"),M("quoteVault"),A("quoteDepositsTotal"),A("quoteFeesAccrued"),A("quoteDustThreshold"),M("requestQueue"),M("eventQueue"),M("bids"),M("asks"),A("baseLotSize"),A("quoteLotSize"),A("feeRateBps"),A("referrerRebatesAccrued"),we(7)]);function Vd({programId:d,marketInfo:e}){let t=F([V("version"),mt("instruction"),A("baseLotSize"),A("quoteLotSize"),St("feeRateBps"),A("vaultSignerNonce"),A("quoteDustThreshold")]),n=[{pubkey:e.id,isSigner:!1,isWritable:!0},{pubkey:e.requestQueue,isSigner:!1,isWritable:!0},{pubkey:e.eventQueue,isSigner:!1,isWritable:!0},{pubkey:e.bids,isSigner:!1,isWritable:!0},{pubkey:e.asks,isSigner:!1,isWritable:!0},{pubkey:e.baseVault,isSigner:!1,isWritable:!0},{pubkey:e.quoteVault,isSigner:!1,isWritable:!0},{pubkey:e.baseMint,isSigner:!1,isWritable:!1},{pubkey:e.quoteMint,isSigner:!1,isWritable:!1},{pubkey:e.authority?e.quoteMint:Fd,isSigner:!1,isWritable:!1}].concat(e.authority?{pubkey:e.authority,isSigner:!1,isWritable:!1}:[]).concat(e.authority&&e.pruneAuthority?{pubkey:e.pruneAuthority,isSigner:!1,isWritable:!1}:[]),o=Buffer.alloc(t.span);return t.encode({version:0,instruction:0,baseLotSize:e.baseLotSize,quoteLotSize:e.quoteLotSize,feeRateBps:e.feeRateBps,vaultSignerNonce:e.vaultSignerNonce,quoteDustThreshold:e.quoteDustThreshold},o),new _d({keys:n,programId:d,data:o})}async function Ir({connection:d,wallet:e,marketInfo:t}){var i,s,u,a,c,l,m,p;let n=new Bc,o=await d.getMinimumBalanceForRentExemption(165);n.add(io.createAccountWithSeed({fromPubkey:e,basePubkey:e,seed:t.baseVault.seed,newAccountPubkey:t.baseVault.publicKey,lamports:o,space:165,programId:Sc}),io.createAccountWithSeed({fromPubkey:e,basePubkey:e,seed:t.quoteVault.seed,newAccountPubkey:t.quoteVault.publicKey,lamports:o,space:165,programId:Sc}),xc(t.baseVault.publicKey,t.baseMint,t.vaultOwner),xc(t.quoteVault.publicKey,t.quoteMint,t.vaultOwner),io.createAccountWithSeed({fromPubkey:e,basePubkey:e,seed:t.id.seed,newAccountPubkey:t.id.publicKey,lamports:await d.getMinimumBalanceForRentExemption(ia.span),space:ia.span,programId:t.programId}));let r=new Bc;return r.add(io.createAccountWithSeed({fromPubkey:e,basePubkey:e,seed:t.requestQueue.seed,newAccountPubkey:t.requestQueue.publicKey,lamports:t.lowestFeeMarket?6208320:await d.getMinimumBalanceForRentExemption((i=t.requestQueueSpace)!=null?i:5120+12),space:t.lowestFeeMarket?764:(s=t.requestQueueSpace)!=null?s:5120+12,programId:t.programId}),io.createAccountWithSeed({fromPubkey:e,basePubkey:e,seed:t.eventQueue.seed,newAccountPubkey:t.eventQueue.publicKey,lamports:t.lowestFeeMarket?79594560:await d.getMinimumBalanceForRentExemption((u=t.eventQueueSpace)!=null?u:262144+12),space:t.lowestFeeMarket?11308:(a=t.eventQueueSpace)!=null?a:262144+12,programId:t.programId}),io.createAccountWithSeed({fromPubkey:e,basePubkey:e,seed:t.bids.seed,newAccountPubkey:t.bids.publicKey,lamports:t.lowestFeeMarket?101977920:await d.getMinimumBalanceForRentExemption((c=t.orderbookQueueSpace)!=null?c:65536+12),space:t.lowestFeeMarket?14524:(l=t.orderbookQueueSpace)!=null?l:65536+12,programId:t.programId}),io.createAccountWithSeed({fromPubkey:e,basePubkey:e,seed:t.asks.seed,newAccountPubkey:t.asks.publicKey,lamports:t.lowestFeeMarket?101977920:await d.getMinimumBalanceForRentExemption((m=t.orderbookQueueSpace)!=null?m:65536+12),space:t.lowestFeeMarket?14524:(p=t.orderbookQueueSpace)!=null?p:65536+12,programId:t.programId}),Vd({programId:t.programId,marketInfo:{id:t.id.publicKey,requestQueue:t.requestQueue.publicKey,eventQueue:t.eventQueue.publicKey,bids:t.bids.publicKey,asks:t.asks.publicKey,baseVault:t.baseVault.publicKey,quoteVault:t.quoteVault.publicKey,baseMint:t.baseMint,quoteMint:t.quoteMint,baseLotSize:t.baseLotSize,quoteLotSize:t.quoteLotSize,feeRateBps:t.feeRateBps,vaultSignerNonce:t.vaultSignerNonce,quoteDustThreshold:t.quoteDustThreshold}})),[{transaction:n,signer:[],instructionTypes:[U.CreateAccount,U.CreateAccount,U.InitAccount,U.InitAccount]},{transaction:r,signer:[],instructionTypes:[U.CreateAccount,U.CreateAccount,U.CreateAccount,U.CreateAccount,U.CreateAccount,U.InitMarket]}]}var So=class extends _e{async create({baseInfo:e,quoteInfo:t,lotSize:n,tickSize:o,dexProgramId:r,requestQueueSpace:i,eventQueueSpace:s,orderbookQueueSpace:u,lowestFeeMarket:a,assignSeed:c,txVersion:l,computeBudgetConfig:m,txTipConfig:p,feePayer:f}){let y=this.scope.ownerPubKey,b=c?`${e.mint.toBase58().slice(0,10)}-${t.mint.toBase58().slice(0,10)}-${c}`:void 0,g=Ye({fromPublicKey:y,programId:r,assignSeed:b&&`${b}-market`}),P=Ye({fromPublicKey:y,programId:r,assignSeed:b&&`${b}-request`}),T=Ye({fromPublicKey:y,programId:r,assignSeed:b&&`${b}-event`}),h=Ye({fromPublicKey:y,programId:r,assignSeed:b&&`${b}-bids`}),w=Ye({fromPublicKey:y,programId:r,assignSeed:b&&`${b}-asks`}),k=Ye({fromPublicKey:y,programId:Kc,assignSeed:b&&`${b}-baseVault`}),x=Ye({fromPublicKey:y,programId:Kc,assignSeed:b&&`${b}-quoteVault`}),B=0,K=new gi(100);function I(){let G=new gi(0);for(;;)try{return{vaultOwner:bi.createProgramAddressSync([g.publicKey.toBuffer(),G.toArrayLike(Buffer,"le",8)],r),vaultSignerNonce:G}}catch{if(G.iaddn(1),G.gt(new gi(25555)))throw Error("find vault owner error")}}let{vaultOwner:R,vaultSignerNonce:C}=I(),N=new gi(Math.round(10**e.decimals*n)),L=new gi(Math.round(n*10**t.decimals*o));if(N.eq(kt))throw Error("lot size is too small");if(L.eq(kt))throw Error("tick size or lot size is too small");let O=await Ir({connection:this.scope.connection,wallet:this.scope.ownerPubKey,marketInfo:{programId:r,id:g,baseMint:e.mint,quoteMint:t.mint,baseVault:k,quoteVault:x,vaultOwner:R,requestQueue:P,eventQueue:T,bids:h,asks:w,feeRateBps:B,quoteDustThreshold:K,vaultSignerNonce:C,baseLotSize:N,quoteLotSize:L,requestQueueSpace:i,eventQueueSpace:s,orderbookQueueSpace:u,lowestFeeMarket:a}}),_=this.createTxBuilder(f);_.addInstruction({instructions:O[0].transaction.instructions,signers:O[0].signer});for await(let G of O.slice(1,O.length))_.addInstruction({instructions:G.transaction.instructions,signers:G.signer,instructionTypes:G.instructionTypes});return l===0?_.sizeCheckBuildV0({computeBudgetConfig:m,address:{marketId:g.publicKey,requestQueue:P.publicKey,eventQueue:T.publicKey,bids:h.publicKey,asks:w.publicKey,baseVault:k.publicKey,quoteVault:x.publicKey,baseMint:new bi(e.mint),quoteMint:new bi(t.mint)}}):_.sizeCheckBuild({computeBudgetConfig:m,address:{marketId:g.publicKey,requestQueue:P.publicKey,eventQueue:T.publicKey,bids:h.publicKey,asks:w.publicKey,baseVault:k.publicKey,quoteVault:x.publicKey,baseMint:new bi(e.mint),quoteMint:new bi(t.mint)}})}};var Pi=class extends _e{constructor(t){super(t);this.stableLayout=new yi({connection:this.scope.connection,modelDataPubKey:this.scope.cluster==="mainnet"?void 0:mn.MODEL_DATA_PUBKEY})}async initLayout(){await this.stableLayout.initStableModelLayout()}async load(){this.checkDisabled()}computePairAmount({poolInfo:t,amount:n,slippage:o,baseIn:r}){let i=new ze(new Re(n).mul(10**t[r?"mintA":"mintB"].decimals).toFixed(0)),s=Pr(t[r?"mintB":"mintA"]),[u,a]=[new ze(new Re(t.mintAmountA).mul(10**t.mintA.decimals).toString()),new ze(new Re(t.mintAmountB).mul(10**t.mintB.decimals).toString())],c=new ze(new Re(t.lpAmount).mul(10**t.lpMint.decimals).toFixed(0,Re.ROUND_DOWN));this.logDebug("baseReserve:",u.toString(),"quoteReserve:",a.toString()),this.logDebug("tokenIn:",r?t.mintA.symbol:t.mintB.symbol,"amountIn:",i.toString(),"anotherToken:",r?t.mintB.symbol:t.mintA.symbol,"slippage:",`${o.toSignificant()}%`,"baseReserve",u.toString(),"quoteReserve",a.toString());let l=r?"base":"quote";this.logDebug("input side:",l);let m=kt;i.isZero()||(m=l==="base"?Yi(i.mul(a),u):Yi(i.mul(u),a)),this.logDebug("amountRaw:",m.toString(),"lpAmount:",c.toString());let p=Yi(i.mul(c),l==="base"?u:a);this.logDebug("liquidity:",p.toString());let f=new tt(new ze(1)).add(o),y=new tt(new ze(1)).sub(o),b=f.mul(m).quotient,g=y.mul(m).quotient,P=new xe(s,m),T=new xe(s,b),h=new xe(s,g);return this.logDebug("anotherAmount:",P.toFixed(),"maxAnotherAmount:",T.toFixed()),{anotherAmount:P,maxAnotherAmount:T,minAnotherAmount:h,liquidity:p}}async getAmmPoolKeys(t){return(await this.scope.api.fetchPoolKeysById({idList:[t]}))[0]}async addLiquidity(t){let{poolInfo:n,poolKeys:o,amountInA:r,amountInB:i,otherAmountMin:s,fixedSide:u,config:a,txVersion:c,computeBudgetConfig:l,txTipConfig:m,feePayer:p}=t;this.scope.availability.addStandardPosition===!1&&this.logAndCreateError("add liquidity feature disabled in your region"),this.logDebug("amountInA:",r,"amountInB:",i),(r.isZero()||i.isZero())&&this.logAndCreateError("amounts must greater than zero","amountInA & amountInB",{amountInA:r.toFixed(),amountInB:i.toFixed()});let{account:f}=this.scope,{bypassAssociatedCheck:y,checkCreateATAOwner:b}=v({bypassAssociatedCheck:!1,checkCreateATAOwner:!1},a),[g,P]=[r.token,i.token],T=await f.getCreatedTokenAccount({mint:g.mint,associatedOnly:!1}),h=await f.getCreatedTokenAccount({mint:P.mint,associatedOnly:!1});!T&&!h&&this.logAndCreateError("cannot found target token accounts","tokenAccounts",f.tokenAccounts);let w=await f.getCreatedTokenAccount({mint:new je(n.lpMint.address)}),k=[g,P],x=[T,h],B=[r.raw,i.raw],K=r.token.mint.toBase58()===n.mintA.address?"base":"quote",I="base";["quote","base"].includes(K)||this.logAndCreateError("invalid fixedSide","fixedSide",u),K==="quote"?(k.reverse(),x.reverse(),B.reverse(),I=u==="a"?"quote":"base"):K==="base"&&(I=u==="a"?"base":"quote");let[R,C]=k,[N,L]=x,[O,_]=B,G=o!=null?o:await this.getAmmPoolKeys(n.id),z=this.createTxBuilder(p),ee=await f.handleTokenAccount({side:"in",amount:O,mint:R.mint,tokenAccount:N,bypassAssociatedCheck:y,checkCreateATAOwner:b}),{tokenAccount:H}=ee,me=ve(ee,["tokenAccount"]);z.addInstruction(me);let he=await f.handleTokenAccount({side:"in",amount:_,mint:C.mint,tokenAccount:L,bypassAssociatedCheck:y,checkCreateATAOwner:b}),{tokenAccount:ne}=he,ae=ve(he,["tokenAccount"]);z.addInstruction(ae);let J=await f.handleTokenAccount({side:"out",amount:0,mint:new je(n.lpMint.address),tokenAccount:w,bypassAssociatedCheck:y,checkCreateATAOwner:b}),{tokenAccount:fe}=J,de=ve(J,["tokenAccount"]);return z.addInstruction(de),z.addInstruction({instructions:[Pc({poolInfo:n,poolKeys:G,userKeys:{baseTokenAccount:H,quoteTokenAccount:ne,lpTokenAccount:fe,owner:this.scope.ownerPubKey},baseAmountIn:O,quoteAmountIn:_,otherAmountMin:s.raw,fixedSide:I})],instructionTypes:[n.pooltype.includes("StablePool")?U.AmmV5AddLiquidity:U.AmmV4AddLiquidity],lookupTableAddress:G.lookupTableAccount?[G.lookupTableAccount]:[]}),z.addCustomComputeBudget(l),z.addTipInstruction(m),c===0?await z.buildV0():z.build()}async removeLiquidity(t){this.scope.availability.removeStandardPosition===!1&&this.logAndCreateError("remove liquidity feature disabled in your region");let{poolInfo:n,poolKeys:o,lpAmount:r,baseAmountMin:i,quoteAmountMin:s,config:u,txVersion:a,computeBudgetConfig:c,txTipConfig:l,feePayer:m}=t,p=o!=null?o:await this.getAmmPoolKeys(n.id),[f,y,b]=[new je(n.mintA.address),new je(n.mintB.address),new je(n.lpMint.address)];this.logDebug("lpAmount:",r),this.logDebug("baseAmountMin:",i),this.logDebug("quoteAmountMin:",s),r.isZero()&&this.logAndCreateError("amount must greater than zero","lpAmount",r.toString());let{account:g}=this.scope,P=await g.getCreatedTokenAccount({mint:b,associatedOnly:!1});P||this.logAndCreateError("cannot found lpTokenAccount","tokenAccounts",g.tokenAccounts);let T=await g.getCreatedTokenAccount({mint:f}),h=await g.getCreatedTokenAccount({mint:y}),w=this.createTxBuilder(m),{bypassAssociatedCheck:k,checkCreateATAOwner:x}=v({bypassAssociatedCheck:!1,checkCreateATAOwner:!1},u),C=await g.handleTokenAccount({side:"out",amount:0,mint:f,tokenAccount:T,bypassAssociatedCheck:k,checkCreateATAOwner:x}),{tokenAccount:B}=C,K=ve(C,["tokenAccount"]);w.addInstruction(K);let N=await g.handleTokenAccount({side:"out",amount:0,mint:y,tokenAccount:h,bypassAssociatedCheck:k,checkCreateATAOwner:x}),{tokenAccount:I}=N,R=ve(N,["tokenAccount"]);return w.addInstruction(R),w.addInstruction({instructions:[Zs({poolInfo:n,poolKeys:p,userKeys:{lpTokenAccount:P,baseTokenAccount:B,quoteTokenAccount:I,owner:this.scope.ownerPubKey},lpAmount:r,baseAmountMin:i,quoteAmountMin:s})],lookupTableAddress:p.lookupTableAccount?[p.lookupTableAccount]:[],instructionTypes:[n.pooltype.includes("StablePool")?U.AmmV5RemoveLiquidity:U.AmmV4RemoveLiquidity]}),w.addCustomComputeBudget(c),w.addTipInstruction(l),a===0?await w.buildV0():w.build()}async removeAllLpAndCreateClmmPosition({poolInfo:t,clmmPoolInfo:n,removeLpAmount:o,createPositionInfo:r,farmInfo:i,userFarmLpAmount:s,base:u,computeBudgetConfig:a,payer:c,userAuxiliaryLedgers:l,tokenProgram:m=Fn,checkCreateATAOwner:p=!0,getEphemeralSigners:f,txVersion:y,feePayer:b}){if((this.scope.availability.removeStandardPosition===!1||this.scope.availability.createConcentratedPosition===!1)&&this.logAndCreateError("remove liquidity or create position feature disabled in your region"),!(t.mintA.address===n.mintA.address||t.mintA.address===n.mintB.address)||!(t.mintB.address===n.mintA.address||t.mintB.address===n.mintB.address))throw Error("mint check error");let g=this.createTxBuilder(b),P={};for(let G of this.scope.account.tokenAccountRawInfos)(P[G.accountInfo.mint.toString()]===void 0||Z(this.scope.ownerPubKey,G.accountInfo.mint,Fn).publicKey.equals(G.pubkey))&&(P[G.accountInfo.mint.toString()]=G.pubkey);let T=P[t.lpMint.address];if(T===void 0)throw Error("find lp account error in trade accounts");let h=o.add(s!=null?s:new ze(0)),w=t.mintA.address===De.WSOL.mint.toString(),k=t.mintB.address===De.WSOL.mint.toString(),{account:x,instructionParams:B}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:Fn,mint:new je(t.mintA.address),owner:this.scope.ownerPubKey,createInfo:w?{payer:this.scope.ownerPubKey}:void 0,skipCloseAccount:!w,notUseTokenAccount:w,associatedOnly:!0,checkCreateATAOwner:p});if(g.addInstruction(B||{}),x===void 0)throw new Error("base token account not found");let{account:K,instructionParams:I}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:Fn,mint:new je(t.mintB.address),owner:this.scope.ownerPubKey,createInfo:k?{payer:this.scope.ownerPubKey,amount:0}:void 0,skipCloseAccount:!k,notUseTokenAccount:k,associatedOnly:!0,checkCreateATAOwner:p});if(g.addInstruction(I||{}),K===void 0)throw new Error("quote token account not found");if(P[t.mintA.address]=x,P[t.mintB.address]=K,i!==void 0&&!(s!=null&&s.isZero())){let G=Ft[i.programId],z=_t({programId:new je(i.programId),poolId:new je(i.id),owner:this.scope.ownerPubKey,version:G}),H,me=await this.scope.connection.getAccountInfo(z);if(me&&(H=$o(G).decode(me.data)),G!==6&&!H){let{instruction:J,instructionType:Me}=Jo({id:new je(i.id),programId:new je(i.programId),version:G,ledger:z,owner:this.scope.ownerPubKey});g.addInstruction({instructions:[J],instructionTypes:[Me]})}let ne=[];for(let J of i.rewardInfos){let Me=J.mint.address===De.WSOL.mint.toString();if(P[J.mint.address])ne.push(P[J.mint.address]);else{let{account:fo,instructionParams:nn}=await this.scope.account.getOrCreateTokenAccount({mint:new je(J.mint.address),tokenProgram:m,owner:this.scope.ownerPubKey,skipCloseAccount:!Me,createInfo:{payer:c||this.scope.ownerPubKey},associatedOnly:!0,checkCreateATAOwner:p});fo||this.logAndCreateError("farm reward account not found:",J.mint.address),nn&&g.addInstruction(nn),ne.push(fo)}}let ae=(await this.scope.api.fetchFarmKeysById({ids:i.id}))[0],fe={userAuxiliaryLedgers:l,amount:s,owner:this.scope.ownerPubKey,farmInfo:i,farmKeys:ae,lpAccount:T,rewardAccounts:ne},de=Ft[i.programId],ee=de===6?ei(fe):de===5?ti(fe):ni(fe),he={3:U.FarmV3Withdraw,5:U.FarmV5Withdraw,6:U.FarmV6Withdraw};g.addInstruction({instructions:[ee],instructionTypes:[he[de]]})}let R=await this.getAmmPoolKeys(t.id),C=Zs({poolInfo:t,poolKeys:R,userKeys:{lpTokenAccount:T,baseTokenAccount:x,quoteTokenAccount:K,owner:this.scope.ownerPubKey},lpAmount:h,baseAmountMin:0,quoteAmountMin:0});g.addInstruction({instructions:[C],instructionTypes:[t.pooltype.includes("StablePool")?U.AmmV5RemoveLiquidity:U.AmmV4RemoveLiquidity],lookupTableAddress:R.lookupTableAccount?[R.lookupTableAccount]:[]});let[N,L]=t.mintA.address===n.mintA.address?[x,K]:[K,x],O=await this.scope.clmm.getClmmPoolKeys(n.id),_=await Ce.openPositionFromBaseInstructions(D(v({poolInfo:n,poolKeys:O,ownerInfo:{feePayer:this.scope.ownerPubKey,wallet:this.scope.ownerPubKey,tokenAccountA:N,tokenAccountB:L},withMetadata:"create"},r),{base:u,getEphemeralSigners:f}));return g.addInstruction({instructions:[..._.instructions],signers:_.signers,instructionTypes:[..._.instructionTypes],lookupTableAddress:O.lookupTableAccount?[O.lookupTableAccount]:[]}),y===0?g.sizeCheckBuildV0({computeBudgetConfig:a}):g.sizeCheckBuild({computeBudgetConfig:a})}async createPoolV4({programId:t,marketInfo:n,baseMintInfo:o,quoteMintInfo:r,baseAmount:i,quoteAmount:s,startTime:u,ownerInfo:a,associatedOnly:c=!1,checkCreateATAOwner:l=!1,tokenProgram:m,txVersion:p,feeDestinationId:f,computeBudgetConfig:y,txTipConfig:b,feePayer:g}){var L;let P=a.feePayer||((L=this.scope.owner)==null?void 0:L.publicKey),T=a.useSOLBalance&&o.mint.equals(Br),h=a.useSOLBalance&&r.mint.equals(Br),w=this.createTxBuilder(g),{account:k,instructionParams:x}=await this.scope.account.getOrCreateTokenAccount({mint:o.mint,owner:this.scope.ownerPubKey,createInfo:T?{payer:P,amount:i}:void 0,notUseTokenAccount:T,skipCloseAccount:!T,associatedOnly:T?!1:c,checkCreateATAOwner:l});w.addInstruction(x||{});let{account:B,instructionParams:K}=await this.scope.account.getOrCreateTokenAccount({mint:r.mint,owner:this.scope.ownerPubKey,createInfo:h?{payer:P,amount:s}:void 0,notUseTokenAccount:h,skipCloseAccount:!h,associatedOnly:h?!1:c,checkCreateATAOwner:l});if(w.addInstruction(K||{}),k===void 0||B===void 0)throw Error("you don't has some token account");let I=oa({version:4,marketVersion:3,marketId:n.marketId,baseMint:o.mint,quoteMint:r.mint,baseDecimals:o.decimals,quoteDecimals:r.decimals,programId:t,marketProgramId:n.programId}),R={programId:t,ammId:I.id,ammAuthority:I.authority,ammOpenOrders:I.openOrders,lpMint:I.lpMint,coinMint:I.baseMint,pcMint:I.quoteMint,coinVault:I.baseVault,pcVault:I.quoteVault,withdrawQueue:I.withdrawQueue,ammTargetOrders:I.targetOrders,poolTempLp:I.lpVault,marketProgramId:I.marketProgramId,marketId:I.marketId,ammConfigId:I.configId,feeDestinationId:f},{instruction:C,instructionType:N}=Js(D(v({},R),{userWallet:this.scope.ownerPubKey,userCoinVault:k,userPcVault:B,userLpVault:Z(this.scope.ownerPubKey,I.lpMint,m).publicKey,nonce:I.nonce,openTime:u,coinAmount:i,pcAmount:s}));return w.addInstruction({instructions:[C],instructionTypes:[N]}),w.addCustomComputeBudget(y),w.addTipInstruction(b),w.versionBuild({txVersion:p,extInfo:{address:R}})}async createMarketAndPoolV4({programId:t=Hi,marketProgram:n=su,feeDestinationId:o=uu,tokenProgram:r,baseMintInfo:i,quoteMintInfo:s,baseAmount:u,quoteAmount:a,startTime:c,ownerInfo:l,lowestFeeMarket:m,assignSeed:p,associatedOnly:f=!1,checkCreateATAOwner:y=!1,lotSize:b=1,tickSize:g=.01,txVersion:P,computeBudgetConfig:T,txTipConfig:h,feePayer:w}){var yo,bo,Ur;let k=this.scope.ownerPubKey,x=l.feePayer||((yo=this.scope.owner)==null?void 0:yo.publicKey),B=l.useSOLBalance&&i.mint.equals(Br),K=l.useSOLBalance&&s.mint.equals(Br),I=p?`${i.mint.toBase58().slice(0,7)}-${s.mint.toBase58().slice(0,7)}-${p}`:void 0,R=Ye({fromPublicKey:k,programId:n,assignSeed:I&&`${I}-market`}),C=Ye({fromPublicKey:k,programId:n,assignSeed:I&&`${I}-request`}),N=Ye({fromPublicKey:k,programId:n,assignSeed:I&&`${I}-event`}),L=Ye({fromPublicKey:k,programId:n,assignSeed:I&&`${I}-bids`}),O=Ye({fromPublicKey:k,programId:n,assignSeed:I&&`${I}-asks`}),_=Ye({fromPublicKey:k,programId:Fn,assignSeed:I&&`${I}-baseVault`}),G=Ye({fromPublicKey:k,programId:Fn,assignSeed:I&&`${I}-quoteVault`}),z=0,H=new ze(100);function me(){let Bt=new ze(0);for(;;)try{return{vaultOwner:je.createProgramAddressSync([R.publicKey.toBuffer(),Bt.toArrayLike(Buffer,"le",8)],n),vaultSignerNonce:Bt}}catch{if(Bt.iaddn(1),Bt.gt(new ze(25555)))throw Error("find vault owner error")}}let{vaultOwner:ne,vaultSignerNonce:ae}=me(),fe=new ze(Math.round(10**i.decimals*b)),de=new ze(Math.round(b*10**s.decimals*g));if(fe.eq(kt))throw Error("lot size is too small");if(de.eq(kt))throw Error("tick size or lot size is too small");let ee=await Ir({connection:this.scope.connection,wallet:this.scope.ownerPubKey,marketInfo:{programId:n,vaultOwner:ne,baseMint:i.mint,quoteMint:s.mint,id:R,baseVault:_,quoteVault:G,requestQueue:C,eventQueue:N,bids:L,asks:O,feeRateBps:z,quoteDustThreshold:H,vaultSignerNonce:ae,baseLotSize:fe,quoteLotSize:de,lowestFeeMarket:m}}),he=this.createTxBuilder(w);he.addInstruction({instructions:ee[0].transaction.instructions,signers:ee[0].signer});for await(let Bt of ee.slice(1,ee.length))he.addInstruction({instructions:Bt.transaction.instructions,signers:Bt.signer,instructionTypes:Bt.instructionTypes});let{account:J,instructionParams:Me}=await this.scope.account.getOrCreateTokenAccount({mint:i.mint,owner:this.scope.ownerPubKey,createInfo:B?{payer:x,amount:u}:void 0,notUseTokenAccount:B,skipCloseAccount:!B,associatedOnly:B?!1:f,checkCreateATAOwner:y,assignSeed:B&&I?`${I}-wsol`:void 0});he.addInstruction(Me||{});let{account:fo,instructionParams:nn}=await this.scope.account.getOrCreateTokenAccount({mint:s.mint,owner:this.scope.ownerPubKey,createInfo:K?{payer:x,amount:a}:void 0,notUseTokenAccount:K,skipCloseAccount:!K,associatedOnly:K?!1:f,checkCreateATAOwner:y,assignSeed:K&&I?`${I}-wsol`:void 0});if(he.addInstruction(nn||{}),J===void 0)throw Error("you don't has base token account");if(fo===void 0)throw Error("you don't has quote token account");let Le=oa({version:4,marketVersion:3,marketId:R.publicKey,baseMint:i.mint,quoteMint:s.mint,baseDecimals:i.decimals,quoteDecimals:s.decimals,programId:t,marketProgramId:n}),No={programId:t,ammId:Le.id,ammAuthority:Le.authority,ammOpenOrders:Le.openOrders,lpMint:Le.lpMint,coinMint:Le.baseMint,pcMint:Le.quoteMint,coinVault:Le.baseVault,pcVault:Le.quoteVault,withdrawQueue:Le.withdrawQueue,ammTargetOrders:Le.targetOrders,poolTempLp:Le.lpVault,marketProgramId:Le.marketProgramId,marketId:Le.marketId,ammConfigId:Le.configId,feeDestinationId:o},{instruction:qr,instructionType:Mo}=Js(D(v({},No),{userWallet:this.scope.ownerPubKey,userCoinVault:J,userPcVault:fo,userLpVault:Z(this.scope.ownerPubKey,Le.lpMint,r).publicKey,nonce:Le.nonce,openTime:c,coinAmount:u,pcAmount:a}));he.addInstruction({instructions:[qr],instructionTypes:[Mo]});let vt=B||K?[((bo=Me==null?void 0:Me.instructions)==null?void 0:bo[0])||((Ur=nn==null?void 0:nn.instructions)==null?void 0:Ur[0])].filter(Bt=>!!Bt):void 0;return P===0?he.sizeCheckBuildV0({computeBudgetConfig:T,splitIns:vt,address:v({requestQueue:C.publicKey,eventQueue:N.publicKey,bids:L.publicKey,asks:O.publicKey,baseVault:_.publicKey,quoteVault:G.publicKey,baseMint:new je(i.mint),quoteMint:new je(s.mint)},No)}):he.sizeCheckBuild({computeBudgetConfig:T,splitIns:vt,address:v({requestQueue:C.publicKey,eventQueue:N.publicKey,bids:L.publicKey,asks:O.publicKey,baseVault:_.publicKey,quoteVault:G.publicKey,baseMint:new je(i.mint),quoteMint:new je(s.mint)},No)})}async getCreatePoolFee({programId:t}){let n=Tr({programId:t}),o=await this.scope.connection.getAccountInfo(n,{dataSlice:{offset:536,length:8}});if(o===null)throw Error("get config account error");return bc.decode(o.data).fee}computeAmountOut({poolInfo:t,amountIn:n,mintIn:o,mintOut:r,slippage:i}){let[s,u]=[o.toString(),r.toString()];if(s!==t.mintA.address&&s!==t.mintB.address)throw new Error("toke not match");if(u!==t.mintA.address&&u!==t.mintB.address)throw new Error("toke not match");let{baseReserve:a,quoteReserve:c}=t,l=[a,c],m=[t.mintA.decimals,t.mintB.decimals],p=s==t.mintA.address?"base":"quote";p==="quote"&&(l.reverse(),m.reverse());let[f,y]=l,[b,g]=m,P=t.version===4,T;if(P)T=new Re(y.toString()).div(10**g).div(new Re(f.toString()).div(10**b));else{let N=hc(this.stableLayout.stableModelData,a.toNumber(),c.toNumber(),!1);p==="quote"?T=new Re(1e6).div(N*1e6):T=new Re(N*1e6).div(1e6)}let h=n,w=new ze(0),k=new ze(0);if(!h.isZero())if(P){k=Kn(h.mul(Ys),Ar);let N=h.sub(k),L=f.add(N);w=y.mul(N).div(L)}else{k=h.mul(new ze(2)).div(new ze(1e4));let N=h.sub(k);p==="quote"?w=new ze(wc(this.stableLayout.stableModelData,c.toNumber(),a.toNumber(),N.toNumber())):w=new ze(Tc(this.stableLayout.stableModelData,c.toNumber(),a.toNumber(),N.toNumber()))}let x=new ze(new Re(w.toString()).mul(1-i).toFixed(0)),B=w,K=x,I=new Re(w.toString()).div(new Re(h.sub(k).toString()).toFixed(0));!h.isZero()&&!w.isZero()&&(I=new Re(w.toString()).div(10**g).div(new Re(h.sub(k).toString()).div(10**b)));let R=T.sub(I).div(T).mul(100);return{amountOut:B,minAmountOut:K,currentPrice:T,executionPrice:I,priceImpact:R,fee:k}}computeAmountIn({poolInfo:t,amountOut:n,mintIn:o,mintOut:r,slippage:i}){let{baseReserve:s,quoteReserve:u}=t;o.toString()!==t.mintA.address&&o.toString()!==t.mintB.address&&this.logAndCreateError("mintIn does not match pool"),r.toString()!==t.mintA.address&&r.toString()!==t.mintB.address&&this.logAndCreateError("mintOut does not match pool"),this.logDebug("baseReserve:",s.toString()),this.logDebug("quoteReserve:",u.toString());let a=o.toString()===t.mintA.address,[c,l]=a?[t.mintA,t.mintB]:[t.mintB,t.mintA];this.logDebug("currencyOut:",l.symbol||l.address),this.logDebug("amountOut:",new Re(n.toString()).div(10**l.decimals).toDecimalPlaces(l.decimals).toString(),c.symbol||c.address),this.logDebug("slippage:",`${i*100}%`);let m=[s,u],p=a?"quote":"base";p==="base"&&m.reverse(),this.logDebug("output side:",p);let[f,y]=m,b=new Re(y.toString()).div(10**t[a?"mintB":"mintA"].decimals).div(new Re(f.toString()).div(10**t[a?"mintA":"mintB"].decimals));this.logDebug("currentPrice:",`1 ${c.symbol||c.address} \u2248 ${b.toString()} ${l.symbol||l.address}`),this.logDebug("currentPrice invert:",`1 ${l.symbol||l.address} \u2248 ${new Re(1).div(b).toString()} ${c.symbol||c.address}`);let g=new ze(0),P=n;if(!P.isZero()){P.gt(y)&&(P=y.sub(new ze(1)));let K=y.sub(P);g=f.mul(P).div(K).mul(Ar).div(Ar.sub(Ys))}let T=new ze(new Re(g.toString()).mul(1+i).toFixed(0)),h=g,w=T;this.logDebug("amountIn:",new Re(h.toString()).div(10**c.decimals).toDecimalPlaces(c.decimals).toString()),this.logDebug("maxAmountIn:",new Re(w.toString()).div(10**c.decimals).toDecimalPlaces(c.decimals).toString());let k=null;!g.isZero()&&!P.isZero()&&(k=new Re(P.toString()).div(10**l.decimals).div(new Re(g.toString()).div(10**c.decimals)),this.logDebug("executionPrice:",`1 ${l.symbol||l.address} \u2248 ${k.toDecimalPlaces(Math.max(t.mintA.decimals,t.mintB.decimals)).toString()} ${c.symbol||c.address}`),this.logDebug("executionPrice invert:",`1 ${l.symbol||l.address} \u2248 ${new Re(1).div(k).toDecimalPlaces(Math.max(t.mintA.decimals,t.mintB.decimals)).toString()} ${c.symbol||c.address}`));let x=b.mul(h.toString()),B=x.sub(n.toString()).abs().div(x);return this.logDebug("priceImpact:",`${B.toString()}%`),{amountIn:h,maxAmountIn:w,currentPrice:b,executionPrice:k,priceImpact:B}}async swap({poolInfo:t,poolKeys:n,amountIn:o,amountOut:r,inputMint:i,fixedSide:s,txVersion:u,config:a,computeBudgetConfig:c,txTipConfig:l,feePayer:m}){let p=this.createTxBuilder(m),{associatedOnly:f=!0,inputUseSolBalance:y=!0,outputUseSolBalance:b=!0}=a||{},[g,P]=i===t.mintA.address?[t.mintA,t.mintB]:[t.mintB,t.mintA],T=y&&g.address===j.toBase58(),h=b&&P.address===j.toBase58(),{account:w,instructionParams:k}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:Fn,mint:new je(g.address),owner:this.scope.ownerPubKey,createInfo:T?{payer:this.scope.ownerPubKey,amount:o}:void 0,skipCloseAccount:!T,notUseTokenAccount:T,associatedOnly:f});p.addInstruction(k||{}),w||this.logAndCreateError("input token account not found",{token:g.symbol||g.address,tokenAccountIn:w,inputTokenUseSolBalance:T,associatedOnly:f});let{account:x,instructionParams:B}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:Fn,mint:new je(P.address),owner:this.scope.ownerPubKey,createInfo:{payer:this.scope.ownerPubKey,amount:0},skipCloseAccount:!h,notUseTokenAccount:h,associatedOnly:h?!1:f});p.addInstruction(B||{}),x===void 0&&this.logAndCreateError("output token account not found",{token:P.symbol||P.address,tokenAccountOut:x,outputTokenUseSolBalance:h,associatedOnly:f});let K=n||await this.getAmmPoolKeys(t.id),I=4;return t.pooltype.includes("StablePool")&&(I=5),p.addInstruction({instructions:[kr({version:I,poolKeys:K,userKeys:{tokenAccountIn:w,tokenAccountOut:x,owner:this.scope.ownerPubKey},amountIn:o,amountOut:r,fixedSide:s})],instructionTypes:[I===4?U.AmmV4SwapBaseIn:U.AmmV5SwapBaseIn]}),p.addCustomComputeBudget(c),p.addTipInstruction(l),p.versionBuild({txVersion:u})}async getRpcPoolInfo(t){return(await this.getRpcPoolInfos([t]))[t]}async getRpcPoolInfos(t,n){let o=await Oe(this.scope.connection,t.map(c=>({pubkey:new je(c)})),n),r={},i=[];for(let c=0;c<t.length;c++){let l=o[c];if(l===null||!l.accountInfo)throw Error("fetch pool info error: "+String(t[c]));let m=pi.decode(l.accountInfo.data);r[String(t[c])]=D(v({},m),{programId:l.accountInfo.owner}),i.push(m.baseVault,m.quoteVault)}let s={},u=await Oe(this.scope.connection,i.map(c=>({pubkey:new je(c)})),n);for(let c=0;c<i.length;c++){let l=u[c].accountInfo;if(l===null)throw Error("fetch vault info error: "+i[c]);s[String(i[c])]=new ze(Ed.decode(l.data).amount.toString())}let a={};for(let[c,l]of Object.entries(r)){let m=s[l.baseVault.toString()].sub(l.baseNeedTakePnl),p=s[l.quoteVault.toString()].sub(l.quoteNeedTakePnl);a[c]=D(v({},l),{baseReserve:m,mintAAmount:s[l.baseVault.toString()],mintBAmount:s[l.quoteVault.toString()],quoteReserve:p,poolPrice:new Re(p.toString()).div(new Re(10).pow(l.quoteDecimal.toString())).div(new Re(m.toString()).div(new Re(10).pow(l.baseDecimal.toString())))})}return a}async getPoolInfoFromRpc({poolId:t}){let n=await this.getRpcPoolInfo(t),o=hr({[t]:n}),r=o[t],i=await this.scope.tradeV2.computePoolToPoolKeys({pools:[o[t]],ammRpcData:{[t]:n}});return{poolRpcData:n,poolInfo:r,poolKeys:i[0]}}};import{PublicKey as Q}from"@solana/web3.js";import gt from"bn.js";import ro from"decimal.js";import{AccountLayout as Cc,createAssociatedTokenAccountIdempotentInstruction as Rc,TOKEN_2022_PROGRAM_ID as _n,TOKEN_PROGRAM_ID as Ai}from"@solana/spl-token";var ki=class extends _e{constructor(e){super(e)}async getClmmPoolKeys(e){return(await this.scope.api.fetchPoolKeysById({idList:[e]}))[0]}async createPool(e){var x;let{programId:t,owner:n=((x=this.scope.owner)==null?void 0:x.publicKey)||Q.default,mint1:o,mint2:r,ammConfig:i,initialPrice:s,computeBudgetConfig:u,forerunCreate:a,getObserveState:c,txVersion:l,txTipConfig:m,feePayer:p}=e,f=this.createTxBuilder(p),[y,b,g]=new gt(new Q(o.address).toBuffer()).gt(new gt(new Q(r.address).toBuffer()))?[r,o,new ro(1).div(s)]:[o,r,s],P=ue.priceToSqrtPriceX64(g,y.decimals,b.decimals),T=[],h=[];y.programId===_n.toBase58()&&h.push(Ds(t,new Q(y.address)).publicKey),b.programId===_n.toBase58()&&h.push(Ds(t,new Q(b.address)).publicKey),(await this.scope.connection.getMultipleAccountsInfo(h)).forEach((B,K)=>{B&&T.push(h[K])});let k=await Ce.createPoolInstructions({connection:this.scope.connection,programId:t,owner:n,mintA:y,mintB:b,ammConfigId:i.id,initialPriceX64:P,forerunCreate:!c&&a,extendMintAccount:T});return f.addInstruction(k),f.addCustomComputeBudget(u),f.addTipInstruction(m),f.versionBuild({txVersion:l,extInfo:{address:D(v({},k.address),{observationId:k.address.observationId.toBase58(),exBitmapAccount:k.address.exBitmapAccount.toBase58(),programId:t.toString(),id:k.address.poolId.toString(),mintA:y,mintB:b,openTime:"0",vault:{A:k.address.mintAVault.toString(),B:k.address.mintBVault.toString()},rewardInfos:[],config:{id:i.id.toString(),index:i.index,protocolFeeRate:i.protocolFeeRate,tradeFeeRate:i.tradeFeeRate,tickSpacing:i.tickSpacing,fundFeeRate:i.fundFeeRate,description:i.description,defaultRange:0,defaultRangePoint:[]}}),mockPoolInfo:v({type:"Concentrated",rewardDefaultPoolInfos:"Clmm",id:k.address.poolId.toString(),mintA:y,mintB:b,feeRate:i.tradeFeeRate,openTime:"0",programId:t.toString(),price:g.toNumber(),config:{id:i.id.toString(),index:i.index,protocolFeeRate:i.protocolFeeRate,tradeFeeRate:i.tradeFeeRate,tickSpacing:i.tickSpacing,fundFeeRate:i.fundFeeRate,description:i.description,defaultRange:0,defaultRangePoint:[]},burnPercent:0},$u),forerunCreate:a}})}async openPositionFromBase({poolInfo:e,poolKeys:t,ownerInfo:n,tickLower:o,tickUpper:r,base:i,baseAmount:s,otherAmountMax:u,nft2022:a,associatedOnly:c=!0,checkCreateATAOwner:l=!1,withMetadata:m="create",getEphemeralSigners:p,computeBudgetConfig:f,txTipConfig:y,txVersion:b,feePayer:g}){this.scope.availability.addConcentratedPosition===!1&&this.logAndCreateError("add position feature disabled in your region"),this.scope.checkOwner();let P=this.createTxBuilder(g),T=null,h=null,w=n.useSOLBalance&&e.mintA.address===j.toString(),k=n.useSOLBalance&&e.mintB.address===j.toString(),[x,B]=i==="MintA"?[s,u]:[u,s],{account:K,instructionParams:I}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:e.mintA.programId,mint:new Q(e.mintA.address),owner:this.scope.ownerPubKey,createInfo:w||x.isZero()?{payer:this.scope.ownerPubKey,amount:x}:void 0,skipCloseAccount:!w,notUseTokenAccount:w,associatedOnly:w?!1:c,checkCreateATAOwner:l});K&&(T=K),P.addInstruction(I||{});let{account:R,instructionParams:C}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:e.mintB.programId,mint:new Q(e.mintB.address),owner:this.scope.ownerPubKey,createInfo:k||B.isZero()?{payer:this.scope.ownerPubKey,amount:B}:void 0,skipCloseAccount:!k,notUseTokenAccount:k,associatedOnly:k?!1:c,checkCreateATAOwner:l});R&&(h=R),P.addInstruction(C||{}),(!T||!h)&&this.logAndCreateError("cannot found target token accounts","tokenAccounts",{ownerTokenAccountA:T==null?void 0:T.toBase58(),ownerTokenAccountB:h==null?void 0:h.toBase58()});let N=t||await this.getClmmPoolKeys(e.id),L=await Ce.openPositionFromBaseInstructions({poolInfo:e,poolKeys:N,ownerInfo:D(v({},n),{feePayer:this.scope.ownerPubKey,wallet:this.scope.ownerPubKey,tokenAccountA:T,tokenAccountB:h}),tickLower:o,tickUpper:r,base:i,baseAmount:s,otherAmountMax:u,withMetadata:m,getEphemeralSigners:p,nft2022:a});return P.addInstruction(L),P.addCustomComputeBudget(f),P.addTipInstruction(y),P.versionBuild({txVersion:b,extInfo:v({},L.address)})}async openPositionFromLiquidity({poolInfo:e,poolKeys:t,ownerInfo:n,amountMaxA:o,amountMaxB:r,tickLower:i,tickUpper:s,liquidity:u,associatedOnly:a=!0,checkCreateATAOwner:c=!1,withMetadata:l="create",txVersion:m,computeBudgetConfig:p,txTipConfig:f,getEphemeralSigners:y,nft2022:b,feePayer:g}){this.scope.availability.createConcentratedPosition===!1&&this.logAndCreateError("open position feature disabled in your region");let P=this.createTxBuilder(g),T=null,h=null,w=n.useSOLBalance&&e.mintA.address===j.toBase58(),k=n.useSOLBalance&&e.mintB.address===j.toBase58(),{account:x,instructionParams:B}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:e.mintA.programId,mint:new Q(e.mintA.address),owner:this.scope.ownerPubKey,createInfo:w||o.isZero()?{payer:this.scope.ownerPubKey,amount:o}:void 0,skipCloseAccount:!w,notUseTokenAccount:w,associatedOnly:w?!1:a,checkCreateATAOwner:c});x&&(T=x),P.addInstruction(B||{});let{account:K,instructionParams:I}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:e.mintB.programId,mint:new Q(e.mintB.address),owner:this.scope.ownerPubKey,createInfo:k||r.isZero()?{payer:this.scope.ownerPubKey,amount:r}:void 0,skipCloseAccount:!k,notUseTokenAccount:k,associatedOnly:k?!1:a,checkCreateATAOwner:c});K&&(h=K),P.addInstruction(I||{}),(T===void 0||h===void 0)&&this.logAndCreateError("cannot found target token accounts","tokenAccounts",this.scope.account.tokenAccounts);let R=t||await this.getClmmPoolKeys(e.id),C=await Ce.openPositionFromLiquidityInstructions({poolInfo:e,poolKeys:R,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccountA:T,tokenAccountB:h},tickLower:i,tickUpper:s,liquidity:u,amountMaxA:o,amountMaxB:r,withMetadata:l,getEphemeralSigners:y,nft2022:b});return P.addInstruction(C),P.addCustomComputeBudget(p),P.addTipInstruction(f),P.versionBuild({txVersion:m,extInfo:{address:C.address}})}async increasePositionFromLiquidity(e){var I;let{poolInfo:t,poolKeys:n,ownerPosition:o,amountMaxA:r,amountMaxB:i,liquidity:s,ownerInfo:u,associatedOnly:a=!0,checkCreateATAOwner:c=!1,computeBudgetConfig:l,txTipConfig:m,txVersion:p,feePayer:f}=e,y=this.createTxBuilder(f),b,g,P=u.useSOLBalance&&t.mintA.address===j.toString(),T=u.useSOLBalance&&t.mintB.address===j.toString(),{account:h,instructionParams:w}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:t.mintA.programId,mint:new Q(t.mintA.address),notUseTokenAccount:P,owner:this.scope.ownerPubKey,createInfo:P||r.isZero()?{payer:this.scope.ownerPubKey,amount:r}:void 0,skipCloseAccount:!P,associatedOnly:P?!1:a,checkCreateATAOwner:c});h&&(b=h),y.addInstruction(w||{});let{account:k,instructionParams:x}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:t.mintB.programId,mint:new Q(t.mintB.address),owner:this.scope.ownerPubKey,createInfo:T||i.isZero()?{payer:this.scope.ownerPubKey,amount:i}:void 0,notUseTokenAccount:T,skipCloseAccount:!T,associatedOnly:T?!1:a,checkCreateATAOwner:c});k&&(g=k),y.addInstruction(x||{}),!b&&!g&&this.logAndCreateError("cannot found target token accounts","tokenAccounts",this.scope.account.tokenAccounts);let B=n!=null?n:await this.getClmmPoolKeys(t.id),K=Ce.increasePositionFromLiquidityInstructions({poolInfo:t,poolKeys:B,ownerPosition:o,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccountA:b,tokenAccountB:g},liquidity:s,amountMaxA:r,amountMaxB:i,nft2022:(I=await this.scope.connection.getAccountInfo(o.nftMint))==null?void 0:I.owner.equals(_n)});return y.addInstruction(K),y.addCustomComputeBudget(l),y.addTipInstruction(m),y.versionBuild({txVersion:p,extInfo:{address:K.address}})}async increasePositionFromBase(e){var K;let{poolInfo:t,ownerPosition:n,base:o,baseAmount:r,otherAmountMax:i,ownerInfo:s,associatedOnly:u=!0,checkCreateATAOwner:a=!1,computeBudgetConfig:c,txTipConfig:l,txVersion:m,feePayer:p}=e,f=this.createTxBuilder(p),y,b,g=s.useSOLBalance&&t.mintA.address===j.toString(),P=s.useSOLBalance&&t.mintB.address===j.toString(),{account:T,instructionParams:h}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:t.mintA.programId,mint:new Q(t.mintA.address),notUseTokenAccount:g,owner:this.scope.ownerPubKey,createInfo:g||(o==="MintA"?r:i).isZero()?{payer:this.scope.ownerPubKey,amount:o==="MintA"?r:i}:void 0,skipCloseAccount:!g,associatedOnly:g?!1:u,checkCreateATAOwner:a});T&&(y=T),f.addInstruction(h||{});let{account:w,instructionParams:k}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:t.mintB.programId,mint:new Q(t.mintB.address),owner:this.scope.ownerPubKey,createInfo:P||(o==="MintA"?i:r).isZero()?{payer:this.scope.ownerPubKey,amount:o==="MintA"?i:r}:void 0,notUseTokenAccount:P,skipCloseAccount:!P,associatedOnly:P?!1:u,checkCreateATAOwner:a});w&&(b=w),f.addInstruction(k||{}),!y&&!b&&this.logAndCreateError("cannot found target token accounts","tokenAccounts",this.scope.account.tokenAccounts);let x=await this.getClmmPoolKeys(t.id),B=Ce.increasePositionFromBaseInstructions({poolInfo:t,poolKeys:x,ownerPosition:n,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccountA:y,tokenAccountB:b},base:o,baseAmount:r,otherAmountMax:i,nft2022:(K=await this.scope.connection.getAccountInfo(n.nftMint))==null?void 0:K.owner.equals(_n)});return f.addInstruction(B),f.addCustomComputeBudget(c),f.addTipInstruction(l),f.versionBuild({txVersion:m,extInfo:{address:B.address}})}async decreaseLiquidity(e){var N;let{poolInfo:t,poolKeys:n,ownerPosition:o,ownerInfo:r,amountMinA:i,amountMinB:s,liquidity:u,associatedOnly:a=!0,checkCreateATAOwner:c=!1,computeBudgetConfig:l,txTipConfig:m,txVersion:p,feePayer:f}=e;this.scope.availability.removeConcentratedPosition===!1&&this.logAndCreateError("remove position feature disabled in your region");let y=this.createTxBuilder(f),b=r.useSOLBalance&&t.mintA.address===j.toString(),g=r.useSOLBalance&&t.mintB.address===j.toString(),P,T,{account:h,instructionParams:w}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:t.mintA.programId,mint:new Q(t.mintA.address),notUseTokenAccount:b,owner:this.scope.ownerPubKey,createInfo:{payer:this.scope.ownerPubKey,amount:0},skipCloseAccount:!b,associatedOnly:b?!1:a,checkCreateATAOwner:c});P=h,w&&y.addInstruction(w);let{account:k,instructionParams:x}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:t.mintB.programId,mint:new Q(t.mintB.address),notUseTokenAccount:g,owner:this.scope.ownerPubKey,createInfo:{payer:this.scope.ownerPubKey,amount:0},skipCloseAccount:!g,associatedOnly:g?!1:a,checkCreateATAOwner:c});T=k,x&&y.addInstruction(x);let B=[];for(let L of t.rewardDefaultInfos){let O=r.useSOLBalance&&L.mint.address===j.toString(),_;if(L.mint.address===t.mintA.address)_=P;else if(L.mint.address===t.mintB.address)_=T;else{let{account:G,instructionParams:z}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:new Q(L.mint.programId),mint:new Q(L.mint.address),notUseTokenAccount:O,owner:this.scope.ownerPubKey,createInfo:{payer:this.scope.ownerPubKey,amount:0},skipCloseAccount:!O,associatedOnly:O?!1:a,checkCreateATAOwner:c});_=G,z&&y.addInstruction(z)}B.push(_)}!P&&!T&&this.logAndCreateError("cannot found target token accounts","tokenAccounts",this.scope.account.tokenAccountRawInfos);let K=n!=null?n:await this.getClmmPoolKeys(t.id),I=(N=await this.scope.connection.getAccountInfo(o.nftMint))==null?void 0:N.owner.equals(_n),R=await Ce.decreaseLiquidityInstructions({poolInfo:t,poolKeys:K,ownerPosition:o,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccountA:P,tokenAccountB:T,rewardAccounts:B},liquidity:u,amountMinA:i,amountMinB:s,nft2022:I});y.addInstruction({instructions:R.instructions,instructionTypes:[U.ClmmDecreasePosition]});let C=v({},R.address);if(r.closePosition){let L=await Ce.closePositionInstructions({poolInfo:t,poolKeys:K,ownerInfo:{wallet:this.scope.ownerPubKey},ownerPosition:o,nft2022:I});y.addInstruction({endInstructions:L.instructions,endInstructionTypes:L.instructionTypes}),C=v(v({},C),L.address)}return y.addCustomComputeBudget(l),y.addTipInstruction(m),y.versionBuild({txVersion:p,extInfo:{address:C}})}async lockPosition(e){var f;let{programId:t=Uo,authProgramId:n=ji,poolProgramId:o=qn,ownerPosition:r,payer:i,computeBudgetConfig:s,txTipConfig:u,txVersion:a,getEphemeralSigners:c,feePayer:l}=e,m=this.createTxBuilder(l),p=await Ce.makeLockPositions({programId:t,authProgramId:n,poolProgramId:o,wallet:this.scope.ownerPubKey,payer:i!=null?i:this.scope.ownerPubKey,nftMint:r.nftMint,getEphemeralSigners:c,nft2022:(f=await this.scope.connection.getAccountInfo(r.nftMint))==null?void 0:f.owner.equals(_n)});return m.addInstruction(p),m.addCustomComputeBudget(s),m.addTipInstruction(u),m.versionBuild({txVersion:a,extInfo:p.address})}async harvestLockPosition(e){let{programId:t=Uo,authProgramId:n=ji,clmmProgram:o=qn,poolKeys:r,lockData:i,ownerInfo:s={useSOLBalance:!0},associatedOnly:u=!0,checkCreateATAOwner:a=!1,computeBudgetConfig:c,txTipConfig:l,txVersion:m,feePayer:p}=e,f=r||await this.getClmmPoolKeys(i.poolId.toString()),y=this.createTxBuilder(p),b=await this.scope.connection.getAccountInfo(i.positionId);b||this.logger.logWithError("position not found",i.positionId);let g=Io.decode(b.data),P=s.useSOLBalance&&f.mintA.address===j.toString(),T=s.useSOLBalance&&f.mintB.address===j.toString(),h,w,{account:k,instructionParams:x}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:f.mintA.programId,mint:new Q(f.mintA.address),notUseTokenAccount:P,owner:this.scope.ownerPubKey,createInfo:{payer:this.scope.ownerPubKey,amount:0},skipCloseAccount:!P,associatedOnly:P?!1:u,checkCreateATAOwner:a});h=k,x&&y.addInstruction(x);let{account:B,instructionParams:K}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:f.mintB.programId,mint:new Q(f.mintB.address),notUseTokenAccount:T,owner:this.scope.ownerPubKey,createInfo:{payer:this.scope.ownerPubKey,amount:0},skipCloseAccount:!T,associatedOnly:T?!1:u,checkCreateATAOwner:a});w=B,K&&y.addInstruction(K);let I={},R=[];for(let ne of f.rewardInfos){let ae=s.useSOLBalance&&ne.mint.address===j.toString(),fe=I[ne.mint.address];if(!fe){let{account:de,instructionParams:ee}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:new Q(ne.mint.programId),mint:new Q(ne.mint.address),notUseTokenAccount:ae,owner:this.scope.ownerPubKey,skipCloseAccount:!ae,createInfo:{payer:this.scope.ownerPubKey,amount:0},associatedOnly:ae?!1:u});fe=de,ee&&y.addInstruction(ee)}I[ne.mint.address]=fe,R.push(fe)}let C=ho(t,i.lockNftMint).publicKey,N=Z(this.scope.ownerPubKey,i.lockNftMint,Ai).publicKey,L=$.getTickArrayStartIndexByTick(g.tickLower,f.config.tickSpacing),O=$.getTickArrayStartIndexByTick(g.tickUpper,f.config.tickSpacing),{publicKey:_}=ge(new Q(f.programId),i.poolId,L),{publicKey:G}=ge(new Q(f.programId),i.poolId,O),{publicKey:z}=Jt(new Q(f.programId),i.poolId,g.tickLower,g.tickUpper),H=[];for(let ne=0;ne<f.rewardInfos.length;ne++)H.push({poolRewardVault:new Q(f.rewardInfos[ne].vault),ownerRewardVault:R[ne],rewardMint:new Q(f.rewardInfos[ne].mint.address)});let me=await Ce.harvestLockPositionInstructionV2({programId:t,auth:n,lockPositionId:C,clmmProgram:o,lockOwner:this.scope.ownerPubKey,lockNftMint:i.lockNftMint,lockNftAccount:N,positionNftAccount:i.nftAccount,positionId:i.positionId,poolId:i.poolId,protocolPosition:z,vaultA:new Q(f.vault.A),vaultB:new Q(f.vault.B),tickArrayLower:_,tickArrayUpper:G,userVaultA:h,userVaultB:w,mintA:new Q(f.mintA.address),mintB:new Q(f.mintB.address),rewardAccounts:H,exTickArrayBitmap:Qe(o,i.poolId).publicKey});return y.addInstruction({instructions:[me],instructionTypes:[U.ClmmHarvestLockPosition]}),y.addCustomComputeBudget(c),y.addTipInstruction(l),y.versionBuild({txVersion:m})}async closePosition({poolInfo:e,poolKeys:t,ownerPosition:n,txVersion:o,computeBudgetConfig:r,txTipConfig:i,feePayer:s}){var l;this.scope.availability.removeConcentratedPosition===!1&&this.logAndCreateError("remove position feature disabled in your region");let u=this.createTxBuilder(s),a=t!=null?t:await this.getClmmPoolKeys(e.id),c=Ce.closePositionInstructions({poolInfo:e,poolKeys:a,ownerInfo:{wallet:this.scope.ownerPubKey},ownerPosition:n,nft2022:(l=await this.scope.connection.getAccountInfo(n.nftMint))==null?void 0:l.owner.equals(_n)});return u.addCustomComputeBudget(r),u.addTipInstruction(i),u.addInstruction(c).versionBuild({txVersion:o,extInfo:{address:c.address}})}async initReward({poolInfo:e,ownerInfo:t,rewardInfo:n,associatedOnly:o=!0,checkCreateATAOwner:r=!1,computeBudgetConfig:i,txVersion:s,feePayer:u}){n.endTime<=n.openTime&&this.logAndCreateError("reward time error","rewardInfo",n);let a=this.createTxBuilder(u),c=t.useSOLBalance&&n.mint.address.toString()===j.toString(),l=n.perSecond.mul(n.endTime-n.openTime),{account:m,instructionParams:p}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:new Q(n.mint.address),mint:new Q(n.mint.address),notUseTokenAccount:!!c,skipCloseAccount:!c,owner:this.scope.ownerPubKey,createInfo:c?{payer:t.feePayer||this.scope.ownerPubKey,amount:new gt(new ro(l.toFixed(0)).gte(l)?l.toFixed(0):l.add(1).toFixed(0))}:void 0,associatedOnly:c?!1:o,checkCreateATAOwner:r});p&&a.addInstruction(p),m||this.logAndCreateError("no money","ownerRewardAccount",this.scope.account.tokenAccountRawInfos);let f=await this.getClmmPoolKeys(e.id),y=Ce.initRewardInstructions({poolInfo:e,poolKeys:f,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccount:m},rewardInfo:{programId:new Q(n.mint.programId),mint:new Q(n.mint.address),openTime:n.openTime,endTime:n.endTime,emissionsPerSecondX64:le.decimalToX64(n.perSecond)}});return a.addInstruction(y),a.addCustomComputeBudget(i),a.versionBuild({txVersion:s,extInfo:{address:y.address}})}async initRewards({poolInfo:e,poolKeys:t,ownerInfo:n,rewardInfos:o,associatedOnly:r=!0,checkCreateATAOwner:i=!1,computeBudgetConfig:s,txTipConfig:u,txVersion:a,feePayer:c}){for(let p of o)p.endTime<=p.openTime&&this.logAndCreateError("reward time error","rewardInfo",p);let l=this.createTxBuilder(c),m={};for(let p of o){let f=n.useSOLBalance&&p.mint.address===j.toString(),y=p.perSecond.mul(p.endTime-p.openTime),{account:b,instructionParams:g}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:new Q(p.mint.programId),mint:new Q(p.mint.address),notUseTokenAccount:!!f,skipCloseAccount:!f,owner:this.scope.ownerPubKey,createInfo:f?{payer:n.feePayer||this.scope.ownerPubKey,amount:new gt(new ro(y.toFixed(0)).gte(y)?y.toFixed(0):y.add(1).toFixed(0))}:void 0,associatedOnly:f?!1:r,checkCreateATAOwner:i});g&&l.addInstruction(g),b||this.logAndCreateError("no money","ownerRewardAccount",this.scope.account.tokenAccountRawInfos);let P=t!=null?t:await this.getClmmPoolKeys(e.id),T=Ce.initRewardInstructions({poolInfo:e,poolKeys:P,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccount:b},rewardInfo:{programId:new Q(p.mint.programId),mint:new Q(p.mint.address),openTime:p.openTime,endTime:p.endTime,emissionsPerSecondX64:le.decimalToX64(p.perSecond)}});m=v(v({},m),T.address),l.addInstruction(T)}return l.addCustomComputeBudget(s),l.addTipInstruction(u),l.versionBuild({txVersion:a,extInfo:{address:m}})}async setReward({poolInfo:e,ownerInfo:t,rewardInfo:n,associatedOnly:o=!0,checkCreateATAOwner:r=!1,computeBudgetConfig:i,txTipConfig:s,txVersion:u,feePayer:a}){n.endTime<=n.openTime&&this.logAndCreateError("reward time error","rewardInfo",n);let c=this.createTxBuilder(a),l=t.useSOLBalance&&n.mint.equals(j),{account:m,instructionParams:p}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:n.programId,mint:n.mint,notUseTokenAccount:l,owner:this.scope.ownerPubKey,createInfo:l?{payer:t.feePayer||this.scope.ownerPubKey,amount:new gt(new ro(n.perSecond.mul(n.endTime-n.openTime).toFixed(0)).gte(n.perSecond.mul(n.endTime-n.openTime))?n.perSecond.mul(n.endTime-n.openTime).toFixed(0):n.perSecond.mul(n.endTime-n.openTime).add(1).toFixed(0))}:void 0,associatedOnly:l?!1:o,checkCreateATAOwner:r});p&&c.addInstruction(p),m||this.logAndCreateError("no money","ownerRewardAccount",this.scope.account.tokenAccountRawInfos);let f=await this.getClmmPoolKeys(e.id),y=Ce.setRewardInstructions({poolInfo:e,poolKeys:f,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccount:m},rewardInfo:{mint:n.mint,openTime:n.openTime,endTime:n.endTime,emissionsPerSecondX64:le.decimalToX64(n.perSecond)}});return c.addInstruction(y),c.addCustomComputeBudget(i),c.addTipInstruction(s),c.versionBuild({txVersion:u,extInfo:{address:y.address}})}async setRewards({poolInfo:e,poolKeys:t,ownerInfo:n,rewardInfos:o,associatedOnly:r=!0,checkCreateATAOwner:i=!1,computeBudgetConfig:s,txTipConfig:u,txVersion:a,feePayer:c}){let l=this.createTxBuilder(c),m={};for(let p of o){p.endTime<=p.openTime&&this.logAndCreateError("reward time error","rewardInfo",p);let f=n.useSOLBalance&&p.mint.address===j.toString(),{account:y,instructionParams:b}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:new Q(p.mint.programId),mint:new Q(p.mint.address),notUseTokenAccount:f,owner:this.scope.ownerPubKey,createInfo:f?{payer:n.feePayer||this.scope.ownerPubKey,amount:new gt(new ro(p.perSecond.mul(p.endTime-p.openTime).toFixed(0)).gte(p.perSecond.mul(p.endTime-p.openTime))?p.perSecond.mul(p.endTime-p.openTime).toFixed(0):p.perSecond.mul(p.endTime-p.openTime).add(1).toFixed(0))}:void 0,associatedOnly:f?!1:r,checkCreateATAOwner:i});b&&l.addInstruction(b),y||this.logAndCreateError("no money","ownerRewardAccount",this.scope.account.tokenAccountRawInfos);let g=t!=null?t:await this.getClmmPoolKeys(e.id),P=Ce.setRewardInstructions({poolInfo:e,poolKeys:g,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccount:y},rewardInfo:{mint:new Q(p.mint.address),openTime:p.openTime,endTime:p.endTime,emissionsPerSecondX64:le.decimalToX64(p.perSecond)}});l.addInstruction(P),m=v(v({},m),P.address)}return l.addCustomComputeBudget(s),l.addTipInstruction(u),l.versionBuild({txVersion:a,extInfo:{address:m}})}async collectReward({poolInfo:e,ownerInfo:t,rewardMint:n,associatedOnly:o=!0,checkCreateATAOwner:r=!1,computeBudgetConfig:i,txTipConfig:s,txVersion:u,feePayer:a}){let c=e.rewardDefaultInfos.find(g=>g.mint.address===n.toString());c||this.logAndCreateError("reward mint error","not found reward mint",n);let l=this.createTxBuilder(a),m=t.useSOLBalance&&n.equals(j),{account:p,instructionParams:f}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:new Q(c.mint.programId),mint:n,notUseTokenAccount:m,owner:this.scope.ownerPubKey,skipCloseAccount:!m,createInfo:{payer:t.feePayer||this.scope.ownerPubKey,amount:0},associatedOnly:m?!1:o,checkCreateATAOwner:r});f&&l.addInstruction(f),p||this.logAndCreateError("no money","ownerRewardAccount",this.scope.account.tokenAccountRawInfos);let y=await this.getClmmPoolKeys(e.id),b=Ce.collectRewardInstructions({poolInfo:e,poolKeys:y,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccount:p},rewardMint:n});return l.addInstruction(b),l.addCustomComputeBudget(i),l.addTipInstruction(s),l.versionBuild({txVersion:u,extInfo:{address:b.address}})}async collectRewards({poolInfo:e,ownerInfo:t,rewardMints:n,associatedOnly:o=!0,checkCreateATAOwner:r=!1,computeBudgetConfig:i,txTipConfig:s,feePayer:u}){let a=this.createTxBuilder(u),c={};for(let l of n){let m=e.rewardDefaultInfos.find(P=>P.mint.address===l.toString());if(!m){this.logAndCreateError("reward mint error","not found reward mint",l);continue}let p=t.useSOLBalance&&l.equals(j),{account:f,instructionParams:y}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:new Q(m.mint.programId),mint:l,notUseTokenAccount:p,owner:this.scope.ownerPubKey,skipCloseAccount:!p,createInfo:{payer:t.feePayer||this.scope.ownerPubKey,amount:0},associatedOnly:p?!1:o,checkCreateATAOwner:r});f||this.logAndCreateError("no money","ownerRewardAccount",this.scope.account.tokenAccountRawInfos),y&&a.addInstruction(y);let b=await this.getClmmPoolKeys(e.id),g=Ce.collectRewardInstructions({poolInfo:e,poolKeys:b,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccount:f},rewardMint:l});a.addInstruction(g),c=v(v({},c),g.address)}return a.addCustomComputeBudget(i),a.addTipInstruction(s),a.build({address:c})}async swap({poolInfo:e,poolKeys:t,inputMint:n,amountIn:o,amountOutMin:r,priceLimit:i,observationId:s,ownerInfo:u,remainingAccounts:a,associatedOnly:c=!0,checkCreateATAOwner:l=!1,txVersion:m,computeBudgetConfig:p,txTipConfig:f,feePayer:y}){let b=this.createTxBuilder(y),g=n.toString()===e.mintA.address,P=u.useSOLBalance&&e.mintA.address===j.toBase58(),T=u.useSOLBalance&&e.mintB.address===j.toBase58(),h;!i||i.equals(new ro(0))?h=g?Wt.add(new gt(1)):Dt.sub(new gt(1)):h=ue.priceToSqrtPriceX64(i,e.mintA.decimals,e.mintB.decimals);let w;if(!w){let{account:B,instructionParams:K}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:e.mintA.programId,mint:new Q(e.mintA.address),notUseTokenAccount:P,owner:this.scope.ownerPubKey,skipCloseAccount:!P,createInfo:P||!g?{payer:u.feePayer||this.scope.ownerPubKey,amount:g?o:0}:void 0,associatedOnly:P?!1:c,checkCreateATAOwner:l});w=B,K&&b.addInstruction(K)}let k;if(!k){let{account:B,instructionParams:K}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:e.mintB.programId,mint:new Q(e.mintB.address),notUseTokenAccount:T,owner:this.scope.ownerPubKey,skipCloseAccount:!T,createInfo:T||g?{payer:u.feePayer||this.scope.ownerPubKey,amount:g?0:o}:void 0,associatedOnly:T?!1:c,checkCreateATAOwner:l});k=B,K&&b.addInstruction(K)}(!w||!k)&&this.logAndCreateError("user do not have token account",{tokenA:e.mintA.symbol||e.mintA.address,tokenB:e.mintB.symbol||e.mintB.address,ownerTokenAccountA:w,ownerTokenAccountB:k,mintAUseSOLBalance:P,mintBUseSOLBalance:T,associatedOnly:c});let x=t!=null?t:await this.getClmmPoolKeys(e.id);return b.addInstruction(Ce.makeSwapBaseInInstructions({poolInfo:e,poolKeys:x,observationId:s,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccountA:w,tokenAccountB:k},inputMint:new Q(n),amountIn:o,amountOutMin:r,sqrtPriceLimitX64:h,remainingAccounts:a})),b.addCustomComputeBudget(p),b.addTipInstruction(f),b.versionBuild({txVersion:m})}async swapBaseOut({poolInfo:e,poolKeys:t,outputMint:n,amountOut:o,amountInMax:r,priceLimit:i,observationId:s,ownerInfo:u,remainingAccounts:a,associatedOnly:c=!0,checkCreateATAOwner:l=!1,txVersion:m,computeBudgetConfig:p,txTipConfig:f,feePayer:y}){let b=this.createTxBuilder(y),g=n.toString()===e.mintB.address,P=u.useSOLBalance&&e.mintA.address===j.toBase58(),T=u.useSOLBalance&&e.mintB.address===j.toBase58(),h;!i||i.equals(new ro(0))?h=n.toString()===e.mintB.address?Wt.add(new gt(1)):Dt.sub(new gt(1)):h=ue.priceToSqrtPriceX64(i,e.mintA.decimals,e.mintB.decimals);let w;if(!w){let{account:B,instructionParams:K}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:e.mintA.programId,mint:new Q(e.mintA.address),notUseTokenAccount:P,owner:this.scope.ownerPubKey,skipCloseAccount:!P,createInfo:P||!g?{payer:u.feePayer||this.scope.ownerPubKey,amount:g?r:0}:void 0,associatedOnly:P?!1:c,checkCreateATAOwner:l});w=B,K&&b.addInstruction(K)}let k;if(!k){let{account:B,instructionParams:K}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:e.mintB.programId,mint:new Q(e.mintB.address),notUseTokenAccount:T,owner:this.scope.ownerPubKey,skipCloseAccount:!T,createInfo:T||g?{payer:u.feePayer||this.scope.ownerPubKey,amount:g?0:r}:void 0,associatedOnly:T?!1:c,checkCreateATAOwner:l});k=B,K&&b.addInstruction(K)}(!w||!k)&&this.logAndCreateError("user do not have token account",{tokenA:e.mintA.symbol||e.mintA.address,tokenB:e.mintB.symbol||e.mintB.address,ownerTokenAccountA:w,ownerTokenAccountB:k,mintAUseSOLBalance:P,mintBUseSOLBalance:T,associatedOnly:c});let x=t!=null?t:await this.getClmmPoolKeys(e.id);return b.addInstruction(Ce.makeSwapBaseOutInstructions({poolInfo:e,poolKeys:x,observationId:s,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccountA:w,tokenAccountB:k},outputMint:new Q(n),amountOut:o,amountInMax:r,sqrtPriceLimitX64:h,remainingAccounts:a})),b.addCustomComputeBudget(p),b.addTipInstruction(f),b.versionBuild({txVersion:m})}async harvestAllRewards({allPoolInfo:e,allPositions:t,lockInfo:n,ownerInfo:o,associatedOnly:r=!0,checkCreateATAOwner:i=!1,programId:s,txVersion:u,computeBudgetConfig:a,feePayer:c,lockProgram:l=Uo,lockAuth:m=ji,clmmProgram:p=qn}){var T,h;let f={};for(let w of this.scope.account.tokenAccountRawInfos)r?Z(this.scope.ownerPubKey,w.accountInfo.mint,s).publicKey.equals(w.pubkey)&&(f[w.accountInfo.mint.toString()]=w.pubkey):f[w.accountInfo.mint.toString()]=w.pubkey;let y=Object.values(t).flat().map(w=>w.nftMint),b=await Oe(this.scope.connection,y.map(w=>({pubkey:w}))),g={};b.forEach(w=>{var k,x;g[w.pubkey.toBase58()]=(x=(k=w==null?void 0:w.accountInfo)==null?void 0:k.owner)!=null?x:null});let P=this.createTxBuilder(c);for(let w of Object.values(e)){if(t[w.id]===void 0||!t[w.id].find(L=>!L.liquidity.isZero()||L.rewardInfos.find(O=>!O.rewardAmountOwed.isZero())))continue;let k=w,x=o.useSOLBalance&&k.mintA.address===j.toString(),B=o.useSOLBalance&&k.mintB.address===j.toString(),K=f[k.mintA.address];if(!K)if(x){let{account:L,instructionParams:O}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:k.mintA.programId,mint:new Q(k.mintA.address),notUseTokenAccount:x,owner:this.scope.ownerPubKey,skipCloseAccount:!x,createInfo:{payer:o.feePayer||this.scope.ownerPubKey,amount:0},associatedOnly:x?!1:r,checkCreateATAOwner:i});K=L,O&&P.addInstruction(O)}else{let L=new Q(k.mintA.address);K=this.scope.account.getAssociatedTokenAccount(L,new Q(k.mintA.programId)),P.addInstruction({instructions:[Rc(this.scope.ownerPubKey,K,this.scope.ownerPubKey,L,new Q(k.mintA.programId))]})}let I=f[k.mintB.address];if(!I)if(B){let{account:L,instructionParams:O}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:k.mintB.programId,mint:new Q(k.mintB.address),notUseTokenAccount:B,owner:this.scope.ownerPubKey,skipCloseAccount:!B,createInfo:{payer:o.feePayer||this.scope.ownerPubKey,amount:0},associatedOnly:B?!1:r,checkCreateATAOwner:i});I=L,O&&P.addInstruction(O)}else{let L=new Q(k.mintB.address);I=this.scope.account.getAssociatedTokenAccount(L,new Q(k.mintB.programId)),P.addInstruction({instructions:[Rc(this.scope.ownerPubKey,I,this.scope.ownerPubKey,L,new Q(k.mintB.programId))]})}f[k.mintA.address]=K,f[k.mintB.address]=I;let R=[];for(let L of k.rewardDefaultInfos){let O=o.useSOLBalance&&L.mint.address===j.toString(),_=f[L.mint.address];if(!_){let{account:G,instructionParams:z}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:new Q(L.mint.programId),mint:new Q(L.mint.address),notUseTokenAccount:O,owner:this.scope.ownerPubKey,skipCloseAccount:!O,createInfo:{payer:o.feePayer||this.scope.ownerPubKey,amount:0},associatedOnly:O?!1:r});_=G,z&&P.addInstruction(z)}f[L.mint.address]=_,R.push(_)}let C=await this.getClmmPoolKeys(k.id),N=[];for(let L=0;L<C.rewardInfos.length;L++)N.push({poolRewardVault:new Q(C.rewardInfos[L].vault),ownerRewardVault:R[L],rewardMint:new Q(C.rewardInfos[L].mint.address)});for(let L of t[w.id]){let O=(T=n==null?void 0:n[w.id])==null?void 0:T[L.nftMint.toBase58()];if(O){let _=Z(this.scope.ownerPubKey,O.lockNftMint,Ai).publicKey,G=$.getTickArrayStartIndexByTick(L.tickLower,C.config.tickSpacing),z=$.getTickArrayStartIndexByTick(L.tickUpper,C.config.tickSpacing),{publicKey:H}=ge(new Q(C.programId),O.poolId,G),{publicKey:me}=ge(new Q(C.programId),O.poolId,z),{publicKey:ne}=Jt(new Q(C.programId),O.poolId,L.tickLower,L.tickUpper),ae=ho(l,O.lockNftMint).publicKey,fe=Ce.harvestLockPositionInstructionV2({programId:l,auth:m,lockPositionId:ae,clmmProgram:p,lockOwner:this.scope.ownerPubKey,lockNftMint:O.lockNftMint,lockNftAccount:_,positionNftAccount:O.nftAccount,positionId:O.positionId,poolId:O.poolId,protocolPosition:ne,vaultA:new Q(C.vault.A),vaultB:new Q(C.vault.B),tickArrayLower:H,tickArrayUpper:me,userVaultA:K,userVaultB:I,mintA:new Q(C.mintA.address),mintB:new Q(C.mintB.address),rewardAccounts:N,exTickArrayBitmap:Qe(p,O.poolId).publicKey});P.addInstruction({instructions:[fe],instructionTypes:[U.ClmmHarvestLockPosition],lookupTableAddress:C.lookupTableAccount?[C.lookupTableAccount]:[]})}else{let _=Ce.decreaseLiquidityInstructions({poolInfo:k,poolKeys:C,ownerPosition:L,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccountA:K,tokenAccountB:I,rewardAccounts:R},liquidity:new gt(0),amountMinA:new gt(0),amountMinB:new gt(0),nft2022:(h=g[L.nftMint.toBase58()])==null?void 0:h.equals(_n)});P.addInstruction(_)}}}return u===0?P.sizeCheckBuildV0({computeBudgetConfig:a}):P.sizeCheckBuild({computeBudgetConfig:a})}async getWhiteListMint({programId:e}){let t=await this.scope.connection.getAccountInfo(ai(e).publicKey);return t?lc.decode(t.data).whitelistMints.filter(o=>!o.equals(Q.default)):[]}async getOwnerPositionInfo({programId:e=qn}){await this.scope.account.fetchWalletTokenAccounts();let n=this.scope.account.tokenAccountRawInfos.filter(i=>i.accountInfo.amount.eq(new gt(1))).map(i=>bt(new Q(e),i.accountInfo.mint).publicKey),o=await this.scope.connection.getMultipleAccountsInfo(n),r=[];return o.forEach(i=>{if(!i)return;let s=Io.decode(i.data);r.push(s)}),r}async getOwnerLockedPositionInfo({programId:e=Uo}){await this.scope.account.fetchWalletTokenAccounts();let n=this.scope.account.tokenAccountRawInfos.filter(u=>u.accountInfo.amount.eq(new gt(1))).map(u=>ho(new Q(e),u.accountInfo.mint).publicKey),o=await this.scope.connection.getMultipleAccountsInfo(n),r=[];o.forEach(u=>{if(!u)return;let a=mc.decode(u.data);r.push(a)});let i=await this.scope.connection.getMultipleAccountsInfo(r.map(u=>u.positionId)),s=[];return i.forEach(u=>{if(!u)return;let a=Io.decode(u.data);s.push(a)}),r.map((u,a)=>({position:s[a],lockInfo:u}))}async getRpcClmmPoolInfo({poolId:e}){return(await this.getRpcClmmPoolInfos({poolIds:[e]}))[String(e)]}async getRpcClmmPoolInfos({poolIds:e,config:t}){let n=await Oe(this.scope.connection,e.map(r=>({pubkey:new Q(r)})),t),o={};for(let r=0;r<e.length;r++){let i=n[r];if(i===null||!i.accountInfo)throw Error("fetch pool info error: "+String(e[r]));let s=Jn.decode(i.accountInfo.data),u=ue.sqrtPriceX64ToPrice(s.sqrtPriceX64,s.mintDecimalsA,s.mintDecimalsB).toNumber();o[String(e[r])]=D(v({},s),{currentPrice:u,programId:i.accountInfo.owner})}return o}async getComputeClmmPoolInfos({clmmPoolsRpcInfo:e,mintInfos:t}){let n=new Set(Object.keys(e).map(u=>e[u].ammConfig.toBase58())),o=await Oe(this.scope.connection,Array.from(n).map(u=>({pubkey:new Q(u)}))),r={};o.forEach(u=>{!u.accountInfo||(r[u.pubkey.toBase58()]=uc.decode(u.accountInfo.data))});let i=await Ne.fetchComputeMultipleClmmInfo({connection:this.scope.connection,rpcDataMap:e,poolList:Object.keys(e).map(u=>{var l,m,p,f;let[a,c]=[e[u].mintA.toBase58(),e[u].mintB.toBase58()];return{id:u,programId:e[u].programId.toBase58(),mintA:pt({address:a,decimals:e[u].mintDecimalsA,programId:t[a].programId.toBase58()||Ai.toBase58(),extensions:{feeConfig:(l=t[a])!=null&&l.feeConfig?vn((m=t[a])==null?void 0:m.feeConfig):void 0}}),mintB:pt({address:c,decimals:e[u].mintDecimalsB,programId:t[c].programId.toBase58()||Ai.toBase58(),extensions:{feeConfig:(p=t[c])!=null&&p.feeConfig?vn((f=t[c])==null?void 0:f.feeConfig):void 0}}),price:e[u].currentPrice,config:D(v({},r[e[u].ammConfig.toBase58()]),{id:e[u].ammConfig.toBase58(),fundFeeRate:0,description:"",defaultRange:0,defaultRangePoint:[]})}})}),s=await Ne.fetchMultiplePoolTickArrays({connection:this.scope.connection,poolKeys:Object.values(i)});return{computeClmmPoolInfo:i,computePoolTickData:s}}async getPoolInfoFromRpc(e){var c;let t=await this.getRpcClmmPoolInfo({poolId:e}),n=new Set([t.mintA.toBase58(),t.mintB.toBase58()]),o=await go({connection:this.scope.connection,mints:Array.from(n).map(l=>new Q(l))}),{computeClmmPoolInfo:r,computePoolTickData:i}=await this.scope.clmm.getComputeClmmPoolInfos({clmmPoolsRpcInfo:{[e]:t},mintInfos:o}),s=await Oe(this.scope.connection,[{pubkey:t.vaultA},{pubkey:t.vaultB}]),u=sc(r[e]);if(!s[0].accountInfo||!s[1].accountInfo)throw new Error("pool vault data not found");u.mintAmountA=Number(Cc.decode(s[0].accountInfo.data).amount.toString()),u.mintAmountB=Number(Cc.decode((c=s[1].accountInfo)==null?void 0:c.data).amount.toString());let a=D(v({},r[e]),{exBitmapAccount:r[e].exBitmapAccount.toBase58(),observationId:r[e].observationId.toBase58(),id:e,programId:t.programId.toBase58(),openTime:t.startTime.toString(),vault:{A:t.vaultA.toBase58(),B:t.vaultB.toBase58()},config:u.config,rewardInfos:r[e].rewardInfos.filter(l=>!l.tokenVault.equals(Q.default)).map(l=>({mint:pt({address:l.tokenMint.toBase58(),programId:Ai.toBase58(),decimals:10}),vault:l.tokenVault.toBase58()}))});return{poolInfo:u,poolKeys:a,computePoolInfo:r[e],tickData:i}}};import{PublicKey as q}from"@solana/web3.js";import{AccountLayout as Jd,NATIVE_MINT as Co,TOKEN_PROGRAM_ID as Pt,createAssociatedTokenAccountIdempotentInstruction as Ro}from"@solana/spl-token";import Lc from"bn.js";import xr from"bn.js";function ra(d,e){if(e.isZero())throw Error("divisor is zero");return d.mod(e)}function Wd(d,e){if(e.isZero())throw Error("rhs is zero");let t=d.div(e);return ra(d,e).gt(wi)&&(t=t.add(new xr(1))),[t,e]}var wi=new xr(0),Ti=class{static swapBaseInputWithoutFees(e,t,n){let o=e.mul(n),r=t.add(e);return o.div(r)}static swapBaseOutputWithoutFees(e,t,n){let o=t.mul(e),r=n.sub(e),[i]=Wd(o,r);return i}static lpTokensToTradingTokens(e,t,n,o,r){let i=e.mul(n).div(t),s=e.mul(o).div(t);if(r===0)return{tokenAmount0:i,tokenAmount1:s};if(r===1)return ra(e.mul(n),t).gt(wi)&&i.gt(wi)&&(i=i.add(new xr(1))),ra(e.mul(o),t).gt(wi)&&s.gt(wi)&&(s=s.add(new xr(1))),{tokenAmount0:i,tokenAmount1:s};throw Error("roundDirection value error")}};import Dd from"bn.js";var ht=class{static tradingFee(e,t){return Vo(e,t,wt)}static protocolFee(e,t){return Qi(e,t,wt)}static fundFee(e,t){return Qi(e,t,wt)}static creatorFee(e,t){return Vo(e,t,wt)}static splitCreatorFee(e,t,n){return Qi(e,n,t.add(n))}static calculatePreFeeAmount(e,t){if(t.isZero())return e;let n=e.mul(wt),o=wt.sub(t);return n.add(o).sub(new Dd(1)).div(o)}};var hi=class{static validate_supply(e,t){if(e.isZero())throw Error("tokenAmount0 is zero");if(t.isZero())throw Error("tokenAmount1 is zero")}static swapBaseInput(e,t,n,o,r,i,s,u){let a=new Lc(0),c=ht.tradingFee(e,o),l;u?(a=ht.creatorFee(e,r),l=e.sub(c).sub(a)):l=e.sub(c);let m=ht.protocolFee(c,i),p=ht.protocolFee(c,s),f=Ti.swapBaseInputWithoutFees(l,t,n),y;return u?y=f:(a=ht.creatorFee(f,r),y=f.sub(a)),{newInputVaultAmount:t.add(l),newOutputVaultAmount:n.sub(f),inputAmount:e,outputAmount:y,tradeFee:c,protocolFee:m,fundFee:p,creatorFee:a}}static swapBaseOutput(e,t,n,o,r,i,s,u){let a,c=new Lc(0),l;if(u)l=e;else{let b=ht.calculatePreFeeAmount(e,r);c=b.sub(e),l=b}let m=Ti.swapBaseOutputWithoutFees(l,t,n),p;if(u){let b=ht.calculatePreFeeAmount(m,o.add(r)),g=b.sub(m);c=ht.splitCreatorFee(g,o,r),a=g.sub(c),p=b}else{let b=ht.calculatePreFeeAmount(m,o);a=b.sub(m),p=b}let f=ht.protocolFee(a,i),y=ht.fundFee(a,s);return{newInputVaultAmount:t.add(m),newOutputVaultAmount:e.sub(l),inputAmount:p,outputAmount:e,tradeFee:a,protocolFee:f,fundFee:y,creatorFee:c}}};import Ge from"bn.js";import qt from"decimal.js";import{PublicKey as xi,TransactionInstruction as wn,Keypair as jd,SystemProgram as ua}from"@solana/web3.js";import{ASSOCIATED_TOKEN_PROGRAM_ID as Sr,TOKEN_2022_PROGRAM_ID as ca,TOKEN_PROGRAM_ID as kn}from"@solana/spl-token";var qd=Buffer.from("vault_and_lp_mint_auth_seed","utf8"),_B=Buffer.from("amm_config","utf8"),Ud=Buffer.from("pool","utf8"),Gd=Buffer.from("pool_lp_mint","utf8"),Xd=Buffer.from("pool_vault","utf8"),zd=Buffer.from("observation","utf8"),Yd=Buffer.from("permission","utf8");function Ko(d){return ce([qd],d)}function sa(d,e,t,n){return ce([Ud,e.toBuffer(),t.toBuffer(),n.toBuffer()],d)}function Qd(d,e){return ce([Gd,e.toBuffer()],d)}function Oc(d,e,t){return ce([Xd,e.toBuffer(),t.toBuffer()],d)}function Ii(d,e){return ce([zd,e.toBuffer()],d)}function aa({poolId:d,programId:e,configId:t,mintA:n,mintB:o}){let r=Ko(e).publicKey,i=d||sa(e,t,n,o).publicKey,s=Qd(e,i).publicKey,u=Oc(e,i,n).publicKey,a=Oc(e,i,o).publicKey,c=Ii(e,i).publicKey;return{poolId:i,configId:t,authority:r,lpMint:s,vaultA:u,vaultB:a,observationId:c}}var Hd=Buffer.from("locked_liquidity","utf8");function Bi(d,e){return ce([Hd,e.toBuffer()],d)}function Nc(d,e){return ce([Yd,e.toBuffer()],d)}var $d=be("Raydium_cpmm"),Tn={initialize:[175,175,109,31,13,152,155,237],deposit:[242,35,198,137,82,225,242,182],withdraw:[183,18,70,156,148,109,161,34],swapBaseInput:[143,190,90,218,196,30,51,222],swapBaseOutput:[55,217,98,86,163,74,180,173],lockCpLiquidity:[216,157,29,78,38,51,31,26],collectCpFee:[8,30,51,199,209,184,247,133],createPermissionPda:Buffer.from([135,136,2,216,137,169,181,202]),closePermissionPda:Buffer.from([156,84,32,118,69,135,70,123]),initializeWithPermission:Buffer.from([63,55,254,65,49,178,89,121]),collectCreatorFee:Buffer.from([20,22,86,123,198,28,219,132])};function Mc(d,e,t,n,o,r,i,s,u,a,c,l,m,p,f,y,b,g,P,T){let h=F([A("amountMaxA"),A("amountMaxB"),A("openTime")]),w=sa(d,t,r,i).publicKey,k=[{pubkey:e,isSigner:!0,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!o.equals(w),isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!1},{pubkey:i,isSigner:!1,isWritable:!1},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:m,isSigner:!1,isWritable:!0},{pubkey:p,isSigner:!1,isWritable:!0},{pubkey:b,isSigner:!1,isWritable:!0},{pubkey:kn,isSigner:!1,isWritable:!1},{pubkey:f,isSigner:!1,isWritable:!1},{pubkey:y,isSigner:!1,isWritable:!1},{pubkey:Sr,isSigner:!1,isWritable:!1},{pubkey:Zr,isSigner:!1,isWritable:!1},{pubkey:it,isSigner:!1,isWritable:!1}],x=Buffer.alloc(h.span);return h.encode({amountMaxA:g,amountMaxB:P,openTime:T},x),new wn({keys:k,programId:d,data:Buffer.from([...Tn.initialize,...x])})}function vc(d,e,t,n,o,r,i,s,u,a,c,l,m,p,f){let y=F([A("lpAmount"),A("amountMaxA"),A("amountMaxB")]),b=[{pubkey:e,isSigner:!0,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:kn,isSigner:!1,isWritable:!1},{pubkey:ca,isSigner:!1,isWritable:!1},{pubkey:a,isSigner:!1,isWritable:!1},{pubkey:c,isSigner:!1,isWritable:!1},{pubkey:l,isSigner:!1,isWritable:!0}],g=Buffer.alloc(y.span);return $d.debug("cpmm deposit data",{lpAmount:m.toString(),amountMaxA:p.toString(),amountMaxB:f.toString()}),y.encode({lpAmount:m,amountMaxA:p,amountMaxB:f},g),new wn({keys:b,programId:d,data:Buffer.from([...Tn.deposit,...g])})}function Fc(d,e,t,n,o,r,i,s,u,a,c,l,m,p,f){let y=F([A("lpAmount"),A("amountMinA"),A("amountMinB")]),b=[{pubkey:e,isSigner:!0,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:kn,isSigner:!1,isWritable:!1},{pubkey:ca,isSigner:!1,isWritable:!1},{pubkey:a,isSigner:!1,isWritable:!1},{pubkey:c,isSigner:!1,isWritable:!1},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:xn,isSigner:!1,isWritable:!1}],g=Buffer.alloc(y.span);return y.encode({lpAmount:m,amountMinA:p,amountMinB:f},g),new wn({keys:b,programId:d,data:Buffer.from([...Tn.withdraw,...g])})}function Kr(d,e,t,n,o,r,i,s,u,a,c,l,m,p,f,y){let b=F([A("amountIn"),A("amounOutMin")]),g=[{pubkey:e,isSigner:!0,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!1},{pubkey:c,isSigner:!1,isWritable:!1},{pubkey:l,isSigner:!1,isWritable:!1},{pubkey:m,isSigner:!1,isWritable:!1},{pubkey:p,isSigner:!1,isWritable:!0}],P=Buffer.alloc(b.span);return b.encode({amountIn:f,amounOutMin:y},P),new wn({keys:g,programId:d,data:Buffer.from([...Tn.swapBaseInput,...P])})}function _c(d,e,t,n,o,r,i,s,u,a,c,l,m,p,f,y){let b=F([A("amountInMax"),A("amountOut")]),g=[{pubkey:e,isSigner:!0,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!1},{pubkey:c,isSigner:!1,isWritable:!1},{pubkey:l,isSigner:!1,isWritable:!1},{pubkey:m,isSigner:!1,isWritable:!1},{pubkey:p,isSigner:!1,isWritable:!0}],P=Buffer.alloc(b.span);return b.encode({amountInMax:f,amountOut:y},P),new wn({keys:g,programId:d,data:Buffer.from([...Tn.swapBaseOutput,...P])})}async function Vc(d){var b;let{ownerInfo:e,poolInfo:t,poolKeys:n,feeNftOwner:o,getEphemeralSigners:r}=d,i=[],[s,u]=[new xi(t.id),new xi(t.lpMint.address)],a;if(r)a=new xi((await r(1))[0]);else{let g=jd.generate();i.push(g),a=g.publicKey}let{publicKey:c}=Z(o,a,kn),{publicKey:l}=gn(a),{publicKey:m}=Bi(d.lockProgram,a),{publicKey:p}=Z(e.wallet,u,kn),{publicKey:f}=Z(d.lockAuthProgram,u,kn),y=Zd({programId:d.lockProgram,auth:d.lockAuthProgram,payer:e.feePayer,liquidityOwner:e.wallet,nftOwner:o,nftMint:a,nftAccount:c,poolId:s,lockPda:m,mintLp:u,userLpVault:p,lockLpVault:f,poolVaultA:new xi(n.vault.A),poolVaultB:new xi(n.vault.B),metadataAccount:l,lpAmount:d.lpAmount,withMetadata:(b=d.withMetadata)!=null?b:!0});return{address:{nftMint:a,nftAccount:c,metadataAccount:l,lockPda:m,userLpVault:p,lockLpVault:f},instructions:[y],signers:i,instructionTypes:[U.CpmmLockLp],lookupTableAddress:[]}}function Zd({programId:d,auth:e,payer:t,liquidityOwner:n,nftOwner:o,nftMint:r,nftAccount:i,poolId:s,lockPda:u,mintLp:a,userLpVault:c,lockLpVault:l,poolVaultA:m,poolVaultB:p,metadataAccount:f,lpAmount:y,withMetadata:b}){let g=[{pubkey:e,isSigner:!1,isWritable:!1},{pubkey:t,isSigner:!0,isWritable:!0},{pubkey:n,isSigner:!0,isWritable:!1},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!0,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!1},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!1},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:m,isSigner:!1,isWritable:!0},{pubkey:p,isSigner:!1,isWritable:!0},{pubkey:f,isSigner:!1,isWritable:!0},{pubkey:it,isSigner:!1,isWritable:!1},{pubkey:ua.programId,isSigner:!1,isWritable:!1},{pubkey:kn,isSigner:!1,isWritable:!1},{pubkey:Sr,isSigner:!1,isWritable:!1},{pubkey:jt,isSigner:!1,isWritable:!1}],P=F([A("lpAmount"),qe("withMetadata")]),T=Buffer.alloc(P.span);P.encode({lpAmount:y,withMetadata:b},T);let h=Buffer.from([...Tn.lockCpLiquidity,...T]);return new wn({keys:g,programId:d,data:h})}function la({programId:d,nftOwner:e,auth:t,nftAccount:n,lockPda:o,poolId:r,mintLp:i,userVaultA:s,userVaultB:u,poolVaultA:a,poolVaultB:c,mintA:l,mintB:m,lockLpVault:p,lpFeeAmount:f,cpmmProgram:y,cpmmAuthProgram:b}){let g=[{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:e,isSigner:!0,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:y!=null?y:Gn,isSigner:!1,isWritable:!1},{pubkey:b!=null?b:cu,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!1},{pubkey:m,isSigner:!1,isWritable:!1},{pubkey:p,isSigner:!1,isWritable:!0},{pubkey:kn,isSigner:!1,isWritable:!1},{pubkey:ca,isSigner:!1,isWritable:!1},{pubkey:xn,isSigner:!1,isWritable:!1}],P=F([A("lpFeeAmount")]),T=Buffer.alloc(P.span);P.encode({lpFeeAmount:f},T);let h=Buffer.from([...Tn.collectCpFee,...T]);return new wn({keys:g,programId:d,data:h})}function ma(d,e,t,n,o,r,i,s,u,a,c,l,m){let p=[{pubkey:e,isSigner:!0,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!1},{pubkey:u,isSigner:!1,isWritable:!1},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!1},{pubkey:m,isSigner:!1,isWritable:!1},{pubkey:Sr,isSigner:!1,isWritable:!1},{pubkey:ua.programId,isSigner:!1,isWritable:!1}];return new wn({keys:p,programId:d,data:Tn.collectCreatorFee})}function Ec(d,e,t,n,o,r,i,s,u,a,c,l,m,p,f,y,b,g,P,T,h,w,k){let x=F([A("amountA"),A("amountB"),A("openTime"),V("feeOn")]),B=[{pubkey:e,isSigner:!0,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!1},{pubkey:s,isSigner:!1,isWritable:!1},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:m,isSigner:!1,isWritable:!0},{pubkey:p,isSigner:!1,isWritable:!0},{pubkey:f,isSigner:!1,isWritable:!0},{pubkey:g,isSigner:!1,isWritable:!0},{pubkey:P,isSigner:!1,isWritable:!0},{pubkey:kn,isSigner:!1,isWritable:!1},{pubkey:y,isSigner:!1,isWritable:!1},{pubkey:b,isSigner:!1,isWritable:!1},{pubkey:Sr,isSigner:!1,isWritable:!1},{pubkey:ua.programId,isSigner:!1,isWritable:!1}],K=Buffer.alloc(x.span);return x.encode({amountA:T,amountB:h,openTime:w,feeOn:k},K),new wn({keys:B,programId:d,data:Buffer.from([...Tn.initializeWithPermission,...K])})}var Wc=F([we(8),V("bump"),qe("disableCreatePool"),St("index"),A("tradeFeeRate"),A("protocolFeeRate"),A("fundFeeRate"),A("createPoolFee"),M("protocolOwner"),M("fundOwner"),A("creatorFeeRate"),Y(A(),15)]),Cr=F([we(8),M("configId"),M("poolCreator"),M("vaultA"),M("vaultB"),M("mintLp"),M("mintA"),M("mintB"),M("mintProgramA"),M("mintProgramB"),M("observationId"),V("bump"),V("status"),V("lpDecimals"),V("mintDecimalA"),V("mintDecimalB"),A("lpAmount"),A("protocolFeesMintA"),A("protocolFeesMintB"),A("fundFeesMintA"),A("fundFeesMintB"),A("openTime"),A("epoch"),V("feeOn"),qe("enableCreatorFee"),Y(V(),6),A("creatorFeesMintA"),A("creatorFeesMintB"),Y(A(),28)]),jB=F([we(8),M("configId"),Y(A(),30)]);var Si=class extends _e{constructor(e){super(e)}async load(){this.checkDisabled()}async getCpmmPoolKeys(e){return(await this.scope.api.fetchPoolKeysById({idList:[e]}))[0]}async getRpcPoolInfo(e,t){return(await this.getRpcPoolInfos([e],t))[e]}async getRpcPoolInfos(e,t){let n=await Oe(this.scope.connection,e.map(l=>({pubkey:new q(l)}))),o={},r=new Set,i=[];for(let l=0;l<e.length;l++){let m=n[l];if(m.accountInfo===null)throw Error("fetch pool info error: "+String(e[l]));let p=Cr.decode(m.accountInfo.data);o[String(e[l])]=D(v({},p),{programId:m.accountInfo.owner}),r.add(String(p.configId)),i.push(p.vaultA,p.vaultB)}let s={};if(t){let l=[...r],m=await Oe(this.scope.connection,l.map(p=>({pubkey:new q(p)})));for(let p=0;p<l.length;p++){let f=m[p].accountInfo;if(f===null)throw Error("fetch pool config error: "+l[p]);s[l[p]]=Wc.decode(f.data)}}let u={},a=await Oe(this.scope.connection,i.map(l=>({pubkey:new q(l)})));for(let l=0;l<i.length;l++){let m=a[l].accountInfo;if(m===null)throw Error("fetch vault info error: "+i[l]);u[String(i[l])]=new Ge(Jd.decode(m.data).amount.toString())}let c={};for(let[l,m]of Object.entries(o)){let p=u[m.vaultA.toString()].sub(m.protocolFeesMintA).sub(m.fundFeesMintA).sub(m.creatorFeesMintA),f=u[m.vaultB.toString()].sub(m.protocolFeesMintB).sub(m.fundFeesMintB).sub(m.creatorFeesMintB);c[l]=D(v({},m),{baseReserve:p,quoteReserve:f,vaultAAmount:u[m.vaultA.toString()],vaultBAmount:u[m.vaultB.toString()],configInfo:s[m.configId.toString()],poolPrice:new qt(f.toString()).div(new qt(10).pow(m.mintDecimalB)).div(new qt(p.toString()).div(new qt(10).pow(m.mintDecimalA)))})}return c}toComputePoolInfos({pools:e,mintInfos:t}){return Object.keys(e).reduce((n,o)=>{var u,a,c,l;let r=e[o],[i,s]=[r.mintA.toBase58(),r.mintB.toBase58()];return D(v({},n),{[o]:D(v({},r),{id:new q(o),configInfo:r.configInfo,version:7,authority:Ko(r.programId).publicKey,mintA:pt({address:i,decimals:r.mintDecimalA,programId:r.mintProgramA.toBase58(),extensions:{feeConfig:(u=t[i])!=null&&u.feeConfig?vn((a=t[i])==null?void 0:a.feeConfig):void 0}}),mintB:pt({address:s,decimals:r.mintDecimalB,programId:r.mintProgramB.toBase58(),extensions:{feeConfig:(c=t[s])!=null&&c.feeConfig?vn((l=t[s])==null?void 0:l.feeConfig):void 0}})})})},{})}async getPoolInfoFromRpc(e){let t=await this.getRpcPoolInfo(e,!0),n=await go({connection:this.scope.connection,mints:[t.mintA,t.mintB]}),o=pt({address:t.mintA.toBase58(),decimals:t.mintDecimalA,programId:t.mintProgramA.toBase58(),extensions:{feeConfig:n[t.mintA.toBase58()].feeConfig?vn(n[t.mintA.toBase58()].feeConfig):void 0}}),r=pt({address:t.mintB.toBase58(),decimals:t.mintDecimalB,programId:t.mintProgramB.toBase58(),extensions:{feeConfig:n[t.mintB.toBase58()].feeConfig?vn(n[t.mintB.toBase58()].feeConfig):void 0}}),i=pt({address:t.mintLp.toBase58(),decimals:t.lpDecimals,programId:Pt.toBase58()}),s={id:t.configId.toBase58(),index:t.configInfo.index,protocolFeeRate:t.configInfo.protocolFeeRate.toNumber(),tradeFeeRate:t.configInfo.tradeFeeRate.toNumber(),fundFeeRate:t.configInfo.fundFeeRate.toNumber(),createPoolFee:t.configInfo.createPoolFee.toString()},u={volume:0,volumeQuote:0,volumeFee:0,apr:0,feeApr:0,priceMin:0,priceMax:0,rewardApr:[]};return{poolInfo:{programId:t.programId.toBase58(),id:e,type:"Standard",lpMint:i,lpPrice:0,lpAmount:t.lpAmount.toNumber(),config:s,mintA:o,mintB:r,rewardDefaultInfos:[],rewardDefaultPoolInfos:"Ecosystem",price:t.poolPrice.toNumber(),mintAmountA:new qt(t.vaultAAmount.toString()).div(10**o.decimals).toNumber(),mintAmountB:new qt(t.vaultBAmount.toString()).div(10**r.decimals).toNumber(),feeRate:t.configInfo.tradeFeeRate.toNumber(),openTime:t.openTime.toString(),tvl:0,burnPercent:0,day:u,week:u,month:u,pooltype:[],farmUpcomingCount:0,farmOngoingCount:0,farmFinishedCount:0},poolKeys:{programId:t.programId.toBase58(),id:e,mintA:o,mintB:r,openTime:t.openTime.toString(),vault:{A:t.vaultA.toBase58(),B:t.vaultB.toBase58()},authority:Ko(t.programId).publicKey.toBase58(),mintLp:i,config:s,observationId:Ii(t.programId,new q(e)).publicKey.toBase58()},rpcData:t}}async createPool(f){var y=f,{poolId:e,programId:t,poolFeeAccount:n,startTime:o,ownerInfo:r,associatedOnly:i=!1,checkCreateATAOwner:s=!1,txVersion:u,feeConfig:a,computeBudgetConfig:c,txTipConfig:l,feePayer:m}=y,p=ve(y,["poolId","programId","poolFeeAccount","startTime","ownerInfo","associatedOnly","checkCreateATAOwner","txVersion","feeConfig","computeBudgetConfig","txTipConfig","feePayer"]);var _,G,z;let b=r.feePayer||((_=this.scope.owner)==null?void 0:_.publicKey),g=new Ge(new q(p.mintA.address).toBuffer()).lte(new Ge(new q(p.mintB.address).toBuffer())),[P,T]=g?[p.mintA,p.mintB]:[p.mintB,p.mintA],[h,w]=g?[p.mintAAmount,p.mintBAmount]:[p.mintBAmount,p.mintAAmount],k=r.useSOLBalance&&P.address===Co.toBase58(),x=r.useSOLBalance&&T.address===Co.toBase58(),[B,K]=[new q(P.address),new q(T.address)],I=this.createTxBuilder(m),{account:R,instructionParams:C}=await this.scope.account.getOrCreateTokenAccount({mint:B,tokenProgram:P.programId,owner:this.scope.ownerPubKey,createInfo:k?{payer:b,amount:h}:void 0,notUseTokenAccount:k,skipCloseAccount:!k,associatedOnly:k?!1:i,checkCreateATAOwner:s});I.addInstruction(C||{});let{account:N,instructionParams:L}=await this.scope.account.getOrCreateTokenAccount({mint:new q(T.address),tokenProgram:T.programId,owner:this.scope.ownerPubKey,createInfo:x?{payer:b,amount:w}:void 0,notUseTokenAccount:x,skipCloseAccount:!x,associatedOnly:x?!1:i,checkCreateATAOwner:s});if(I.addInstruction(L||{}),R===void 0||N===void 0)throw Error("you don't has some token account");let O=aa({poolId:e,programId:t,configId:new q(a.id),mintA:B,mintB:K});return I.addInstruction({instructions:[Mc(t,this.scope.ownerPubKey,new q(a.id),O.authority,O.poolId,B,K,O.lpMint,R,N,Z(this.scope.ownerPubKey,O.lpMint).publicKey,O.vaultA,O.vaultB,n,new q((G=P.programId)!=null?G:Pt),new q((z=T.programId)!=null?z:Pt),O.observationId,h,w,o)],instructionTypes:[U.CpmmCreatePool]}),I.addCustomComputeBudget(c),I.addTipInstruction(l),I.versionBuild({txVersion:u,extInfo:{address:D(v({},O),{mintA:P,mintB:T,programId:t,poolFeeAccount:n,feeConfig:a})}})}async addLiquidity(e){let{poolInfo:t,poolKeys:n,inputAmount:o,baseIn:r,slippage:i,computeResult:s,computeBudgetConfig:u,txTipConfig:a,config:c,txVersion:l,feePayer:m}=e;this.scope.availability.addStandardPosition===!1&&this.logAndCreateError("add liquidity feature disabled in your region"),o.isZero()&&this.logAndCreateError("amounts must greater than zero","amountInA",{amountInA:o.toString()});let{account:p}=this.scope,{bypassAssociatedCheck:f,checkCreateATAOwner:y}=v({bypassAssociatedCheck:!1,checkCreateATAOwner:!1},c),b=s?void 0:await this.getRpcPoolInfo(t.id),{liquidity:g,inputAmountFee:P,anotherAmount:T}=s||this.computePairAmount({poolInfo:D(v({},t),{lpAmount:new qt(b.lpAmount.toString()).div(10**t.lpMint.decimals).toNumber()}),baseReserve:b.baseReserve,quoteReserve:b.quoteReserve,slippage:new tt(0),baseIn:r,epochInfo:await this.scope.fetchEpochInfo(),amount:new qt(o.toString()).div(10**(r?t.mintA.decimals:t.mintB.decimals))}),h=T.amount,w=t.mintA.address===Co.toString(),k=t.mintB.address===Co.toString(),x=this.createTxBuilder(m),[B,K]=[new q(t.mintA.address),new q(t.mintB.address)],{account:I,instructionParams:R}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:t.mintA.programId,mint:new q(t.mintA.address),owner:this.scope.ownerPubKey,createInfo:w||(r?o:h).isZero()?{payer:this.scope.ownerPubKey,amount:r?o:h}:void 0,skipCloseAccount:!w,notUseTokenAccount:w,associatedOnly:!1,checkCreateATAOwner:y});x.addInstruction(R||{});let{account:C,instructionParams:N}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:t.mintB.programId,mint:new q(t.mintB.address),owner:this.scope.ownerPubKey,createInfo:k||(r?h:o).isZero()?{payer:this.scope.ownerPubKey,amount:r?h:o}:void 0,skipCloseAccount:!k,notUseTokenAccount:k,associatedOnly:!1,checkCreateATAOwner:y});x.addInstruction(N||{}),!I&&!C&&this.logAndCreateError("cannot found target token accounts","tokenAccounts",p.tokenAccounts);let L=await p.getCreatedTokenAccount({mint:new q(t.lpMint.address)}),H=await p.handleTokenAccount({side:"out",amount:0,mint:new q(t.lpMint.address),tokenAccount:L,bypassAssociatedCheck:f,checkCreateATAOwner:y}),{tokenAccount:O}=H,_=ve(H,["tokenAccount"]);x.addInstruction(_);let G=n!=null?n:await this.getCpmmPoolKeys(t.id),z=new tt(new Ge(1)).sub(i);return x.addInstruction({instructions:[vc(new q(t.programId),this.scope.ownerPubKey,new q(G.authority),new q(t.id),O,I,C,new q(G.vault.A),new q(G.vault.B),B,K,new q(t.lpMint.address),s?s==null?void 0:s.liquidity:z.mul(g).quotient,r?P.amount:h,r?h:P.amount)],instructionTypes:[U.CpmmAddLiquidity],lookupTableAddress:G.lookupTableAccount?[G.lookupTableAccount]:[]}),x.addCustomComputeBudget(u),x.addTipInstruction(a),x.versionBuild({txVersion:l})}async withdrawLiquidity(e){var _,G;let{poolInfo:t,poolKeys:n,lpAmount:o,slippage:r,computeBudgetConfig:i,txTipConfig:s,txVersion:u,feePayer:a,closeWsol:c=!0}=e;this.scope.availability.addStandardPosition===!1&&this.logAndCreateError("add liquidity feature disabled in your region");let l=new tt(new Ge(1)).sub(r),m=await this.getRpcPoolInfo(t.id),[p,f]=[l.mul(o.mul(m.baseReserve).div(m.lpAmount)).quotient,l.mul(o.mul(m.quoteReserve).div(m.lpAmount)).quotient],y=await this.scope.fetchEpochInfo(),[b,g]=[Se(p,t.mintA.extensions.feeConfig,y,!1),Se(f,t.mintB.extensions.feeConfig,y,!1)],{account:P}=this.scope,T=this.createTxBuilder(a),[h,w]=[new q(t.mintA.address),new q(t.mintB.address)],k=h.equals(j),x=w.equals(j),B,K,{account:I,instructionParams:R}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:t.mintA.programId,mint:new q(t.mintA.address),notUseTokenAccount:k,owner:this.scope.ownerPubKey,createInfo:{payer:this.scope.ownerPubKey,amount:0},skipCloseAccount:!(k&&c),associatedOnly:!k,checkCreateATAOwner:!1});B=I,R&&T.addInstruction(R);let{account:C,instructionParams:N}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:t.mintB.programId,mint:new q(t.mintB.address),notUseTokenAccount:x,owner:this.scope.ownerPubKey,createInfo:{payer:this.scope.ownerPubKey,amount:0},skipCloseAccount:!(x&&c),associatedOnly:!x,checkCreateATAOwner:!1});K=C,N&&T.addInstruction(N),(!B||!K)&&this.logAndCreateError("cannot found target token accounts","tokenAccounts",P.tokenAccounts);let L=await P.getCreatedTokenAccount({mint:new q(t.lpMint.address)});L||this.logAndCreateError("cannot found lp token account","tokenAccounts",P.tokenAccounts);let O=n!=null?n:await this.getCpmmPoolKeys(t.id);return T.addInstruction({instructions:[Fc(new q(t.programId),this.scope.ownerPubKey,new q(O.authority),new q(t.id),L,B,K,new q(O.vault.A),new q(O.vault.B),h,w,new q(t.lpMint.address),o,p.sub((_=b.fee)!=null?_:new Ge(0)),f.sub((G=g.fee)!=null?G:new Ge(0)))],instructionTypes:[U.CpmmWithdrawLiquidity],lookupTableAddress:O.lookupTableAccount?[O.lookupTableAccount]:[]}),T.addCustomComputeBudget(i),T.addTipInstruction(s),T.versionBuild({txVersion:u})}async swap(e){var R,C,N,L,O,_;let{poolInfo:t,poolKeys:n,baseIn:o,fixedOut:r,inputAmount:i,swapResult:s,slippage:u=0,config:a,computeBudgetConfig:c,txTipConfig:l,txVersion:m,feePayer:p}=e,{bypassAssociatedCheck:f,checkCreateATAOwner:y,associatedOnly:b}=v({bypassAssociatedCheck:!1,checkCreateATAOwner:!1,associatedOnly:!0},a),g=this.createTxBuilder(p),[P,T]=[new q(t.mintA.address),new q(t.mintB.address)];r?s.inputAmount=s.inputAmount.mul(new Ge((1+u)*1e4)).div(new Ge(1e4)):s.outputAmount=s.outputAmount.mul(new Ge((1-u)*1e4)).div(new Ge(1e4));let h=t.mintA.address===j.toBase58(),w=t.mintB.address===j.toBase58(),{account:k,instructionParams:x}=await this.scope.account.getOrCreateTokenAccount({mint:P,tokenProgram:new q((R=t.mintA.programId)!=null?R:Pt),owner:this.scope.ownerPubKey,createInfo:h||!o?{payer:this.scope.ownerPubKey,amount:o?s.inputAmount:0}:void 0,notUseTokenAccount:h,skipCloseAccount:!h,associatedOnly:h?!1:b,checkCreateATAOwner:y});x&&g.addInstruction(x);let{account:B,instructionParams:K}=await this.scope.account.getOrCreateTokenAccount({mint:T,tokenProgram:new q((C=t.mintB.programId)!=null?C:Pt),owner:this.scope.ownerPubKey,createInfo:w||o?{payer:this.scope.ownerPubKey,amount:o?0:s.inputAmount}:void 0,notUseTokenAccount:w,skipCloseAccount:!w,associatedOnly:w?!1:b,checkCreateATAOwner:y});K&&g.addInstruction(K),(!k||!B)&&this.logAndCreateError("user do not have token account",{mintA:t.mintA.symbol||t.mintA.address,mintB:t.mintB.symbol||t.mintB.address,mintATokenAcc:k,mintBTokenAcc:B,mintAUseSOLBalance:h,mintBUseSOLBalance:w,associatedOnly:b});let I=n!=null?n:await this.getCpmmPoolKeys(t.id);return g.addInstruction({instructions:[r?_c(new q(t.programId),this.scope.ownerPubKey,new q(I.authority),new q(I.config.id),new q(t.id),o?k:B,o?B:k,new q(I.vault[o?"A":"B"]),new q(I.vault[o?"B":"A"]),new q((O=t[o?"mintA":"mintB"].programId)!=null?O:Pt),new q((_=t[o?"mintB":"mintA"].programId)!=null?_:Pt),o?P:T,o?T:P,Ii(new q(t.programId),new q(t.id)).publicKey,s.inputAmount,s.outputAmount):Kr(new q(t.programId),this.scope.ownerPubKey,new q(I.authority),new q(I.config.id),new q(t.id),o?k:B,o?B:k,new q(I.vault[o?"A":"B"]),new q(I.vault[o?"B":"A"]),new q((N=t[o?"mintA":"mintB"].programId)!=null?N:Pt),new q((L=t[o?"mintB":"mintA"].programId)!=null?L:Pt),o?P:T,o?T:P,Ii(new q(t.programId),new q(t.id)).publicKey,i,s.outputAmount)],instructionTypes:[r?U.CpmmSwapBaseOut:U.ClmmSwapBaseIn]}),g.addCustomComputeBudget(c),g.addTipInstruction(l),g.versionBuild({txVersion:m})}async lockLp(e){var m,p,f,y,b;let{poolInfo:t,lpAmount:n,computeBudgetConfig:o,txTipConfig:r,txVersion:i,feePayer:s,feeNftOwner:u}=e;n.isZero()&&this.logAndCreateError("lpAmount must greater than zero",{lpAmount:n.toString()});let a=this.createTxBuilder(s),c=(m=e.poolKeys)!=null?m:await this.getCpmmPoolKeys(t.id),l=await Vc({poolInfo:t,poolKeys:c,ownerInfo:{wallet:this.scope.ownerPubKey,feePayer:(p=e.feePayer)!=null?p:this.scope.ownerPubKey},feeNftOwner:u!=null?u:this.scope.ownerPubKey,lockProgram:(f=e.programId)!=null?f:$i,lockAuthProgram:(y=e.authProgram)!=null?y:Zi,lpAmount:n,withMetadata:(b=e.withMetadata)!=null?b:!0,getEphemeralSigners:e.getEphemeralSigners});return a.addInstruction(l),a.addCustomComputeBudget(o),a.addTipInstruction(r),a.versionBuild({txVersion:i,extInfo:l.address})}async harvestLockLp(e){var C;let{poolInfo:t,lpFeeAmount:n,nftMint:o,programId:r=$i,authProgram:i=Zi,cpmmProgram:s,computeBudgetConfig:u,txTipConfig:a,txVersion:c,closeWsol:l=!0}=e;n.isZero()&&this.logAndCreateError("lpFeeAmount must greater than zero",{lpAmount:n.toString()});let m=e.feePayer||this.scope.ownerPubKey,p=this.createTxBuilder(m),[f,y]=[new q(t.mintA.address),new q(t.mintB.address)],b=f.equals(j),g=y.equals(j),P,T,{account:h,instructionParams:w}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:t.mintA.programId,mint:new q(t.mintA.address),notUseTokenAccount:b,owner:this.scope.ownerPubKey,createInfo:{payer:this.scope.ownerPubKey,amount:0},skipCloseAccount:!(b&&l),associatedOnly:!b,checkCreateATAOwner:!1});P=h,w&&p.addInstruction(w);let{account:k,instructionParams:x}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:t.mintB.programId,mint:new q(t.mintB.address),notUseTokenAccount:g,owner:this.scope.ownerPubKey,createInfo:{payer:this.scope.ownerPubKey,amount:0},skipCloseAccount:!(g&&l),associatedOnly:!g,checkCreateATAOwner:!1});T=k,x&&p.addInstruction(x),(!P||!T)&&this.logAndCreateError("cannot found target token accounts",{tokenAccountA:P,tokenAccountB:T});let B=(C=e.poolKeys)!=null?C:await this.getCpmmPoolKeys(t.id),{publicKey:K}=Z(m,o,Pt),{publicKey:I}=Bi(r,o),{publicKey:R}=Z(i,new q(t.lpMint.address),Pt);return p.addInstruction({instructions:[la({programId:r,nftOwner:this.scope.ownerPubKey,auth:i,nftMint:o,nftAccount:K,lockPda:I,poolId:new q(t.id),mintLp:new q(B.mintLp.address),userVaultA:P,userVaultB:T,poolVaultA:new q(B.vault.A),poolVaultB:new q(B.vault.B),mintA:f,mintB:y,lockLpVault:R,lpFeeAmount:n,cpmmProgram:s==null?void 0:s.programId,cpmmAuthProgram:s==null?void 0:s.authProgram})],instructionTypes:[U.CpmmCollectLockFee]}),p.addCustomComputeBudget(u),p.addTipInstruction(a),p.versionBuild({txVersion:c})}async harvestMultiLockLp(e){var m;let{lockInfo:t,programId:n=$i,authProgram:o=Zi,cpmmProgram:r,computeBudgetConfig:i,txVersion:s,closeWsol:u=!0}=e,a=e.feePayer||this.scope.ownerPubKey,c=this.createTxBuilder(a),l={};for(let p of t){let{poolInfo:f,lpFeeAmount:y,nftMint:b}=p;if(y.isZero())continue;let[g,P]=[new q(f.mintA.address),new q(f.mintB.address)],T=g.equals(j),h=P.equals(j),w=l[f.mintA.address],k=l[f.mintB.address];if(!w)if(T){let{account:R,instructionParams:C}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:f.mintA.programId,mint:new q(f.mintA.address),notUseTokenAccount:!0,owner:this.scope.ownerPubKey,createInfo:{payer:this.scope.ownerPubKey,amount:0},skipCloseAccount:!u,associatedOnly:!1,checkCreateATAOwner:!1});w=R,C&&c.addInstruction(C),l[f.mintA.address]=R}else{let R=new q(f.mintA.address);w=this.scope.account.getAssociatedTokenAccount(R,new q(f.mintA.programId)),c.addInstruction({instructions:[Ro(this.scope.ownerPubKey,w,this.scope.ownerPubKey,R,new q(f.mintA.programId))]}),l[f.mintA.address]=w}if(!k)if(h){let{account:R,instructionParams:C}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:f.mintB.programId,mint:new q(f.mintB.address),notUseTokenAccount:!0,owner:this.scope.ownerPubKey,createInfo:{payer:this.scope.ownerPubKey,amount:0},skipCloseAccount:!u,associatedOnly:!1,checkCreateATAOwner:!1});k=R,C&&c.addInstruction(C),l[f.mintB.address]=R}else{let R=new q(f.mintB.address);k=this.scope.account.getAssociatedTokenAccount(R,new q(f.mintB.programId)),c.addInstruction({instructions:[Ro(this.scope.ownerPubKey,k,this.scope.ownerPubKey,R,new q(f.mintB.programId))]}),l[f.mintB.address]=k}(!w||!k)&&this.logAndCreateError("cannot found target token accounts",{tokenAccountA:w,tokenAccountB:k});let x=(m=p.poolKeys)!=null?m:await this.getCpmmPoolKeys(f.id),{publicKey:B}=Z(a,b,Pt),{publicKey:K}=Bi(n,b),{publicKey:I}=Z(o,new q(f.lpMint.address),Pt);c.addInstruction({instructions:[la({programId:n,nftOwner:this.scope.ownerPubKey,auth:o,nftMint:b,nftAccount:B,lockPda:K,poolId:new q(f.id),mintLp:new q(x.mintLp.address),userVaultA:w,userVaultB:k,poolVaultA:new q(x.vault.A),poolVaultB:new q(x.vault.B),mintA:g,mintB:P,lockLpVault:I,lpFeeAmount:y,cpmmProgram:r==null?void 0:r.programId,cpmmAuthProgram:r==null?void 0:r.authProgram})],instructionTypes:[U.CpmmCollectLockFee]})}return s===0?c.sizeCheckBuildV0({computeBudgetConfig:i}):c.sizeCheckBuild({computeBudgetConfig:i})}async createPoolWithPermission(y){var b=y,{poolId:e,programId:t,poolFeeAccount:n,startTime:o,ownerInfo:r,associatedOnly:i=!1,checkCreateATAOwner:s=!1,txVersion:u,feeConfig:a,computeBudgetConfig:c,txTipConfig:l,feePayer:m,feeOn:p}=b,f=ve(b,["poolId","programId","poolFeeAccount","startTime","ownerInfo","associatedOnly","checkCreateATAOwner","txVersion","feeConfig","computeBudgetConfig","txTipConfig","feePayer","feeOn"]);var G,z,H;console.log("***this method only available for wallet with permissions***");let g=r.feePayer||((G=this.scope.owner)==null?void 0:G.publicKey),P=new Ge(new q(f.mintA.address).toBuffer()).lte(new Ge(new q(f.mintB.address).toBuffer())),[T,h]=P?[f.mintA,f.mintB]:[f.mintB,f.mintA],[w,k]=P?[f.mintAAmount,f.mintBAmount]:[f.mintBAmount,f.mintAAmount],x=r.useSOLBalance&&T.address===Co.toBase58(),B=r.useSOLBalance&&h.address===Co.toBase58(),[K,I]=[new q(T.address),new q(h.address)],R=this.createTxBuilder(m),{account:C,instructionParams:N}=await this.scope.account.getOrCreateTokenAccount({mint:K,tokenProgram:T.programId,owner:this.scope.ownerPubKey,createInfo:x?{payer:g,amount:w}:void 0,notUseTokenAccount:x,skipCloseAccount:!x,associatedOnly:x?!1:i,checkCreateATAOwner:s});R.addInstruction(N||{});let{account:L,instructionParams:O}=await this.scope.account.getOrCreateTokenAccount({mint:new q(h.address),tokenProgram:h.programId,owner:this.scope.ownerPubKey,createInfo:B?{payer:g,amount:k}:void 0,notUseTokenAccount:B,skipCloseAccount:!B,associatedOnly:B?!1:i,checkCreateATAOwner:s});if(R.addInstruction(O||{}),C===void 0||L===void 0)throw Error("you don't has some token account");let _=aa({poolId:e,programId:t,configId:new q(a.id),mintA:K,mintB:I});return R.addInstruction({instructions:[Ec(t,this.scope.ownerPubKey,this.scope.ownerPubKey,new q(a.id),_.authority,_.poolId,K,I,_.lpMint,C,L,Z(this.scope.ownerPubKey,_.lpMint).publicKey,_.vaultA,_.vaultB,n,new q((z=T.programId)!=null?z:Pt),new q((H=h.programId)!=null?H:Pt),_.observationId,Nc(t,this.scope.ownerPubKey).publicKey,w,k,o,p)],instructionTypes:[U.CpmmCreatePool]}),R.addCustomComputeBudget(c),R.addTipInstruction(l),R.versionBuild({txVersion:u,extInfo:{address:D(v({},_),{mintA:T,mintB:h,programId:t,poolFeeAccount:n,feeConfig:a})}})}async collectCreatorFees({poolInfo:e,poolKeys:t,programId:n=Gn,txVersion:o,computeBudgetConfig:r,txTipConfig:i,feePayer:s}){let u=s||this.scope.ownerPubKey,a=this.createTxBuilder(u),c=t!=null?t:await this.getCpmmPoolKeys(e.id),[l,m,p,f]=[new q(e.mintA.address),new q(e.mintB.address),new q(e.mintA.programId),new q(e.mintB.programId)],y=this.scope.account.getAssociatedTokenAccount(l,p),b=this.scope.account.getAssociatedTokenAccount(m,f);return a.addInstruction({instructions:[Ro(this.scope.ownerPubKey,y,this.scope.ownerPubKey,l,new q(e.mintA.programId)),Ro(this.scope.ownerPubKey,b,this.scope.ownerPubKey,m,new q(e.mintB.programId))]}),a.addInstruction({instructions:[ma(n,this.scope.ownerPubKey,new q(c.authority),new q(c.id),new q(c.config.id),new q(c.vault.A),new q(c.vault.B),l,m,y,b,p,f)],instructionTypes:[]}),a.addCustomComputeBudget(r),a.addTipInstruction(i),a.versionBuild({txVersion:o})}async collectMultiCreatorFees({poolInfoList:e,programId:t=Gn,txVersion:n,computeBudgetConfig:o,feePayer:r}){let i=r||this.scope.ownerPubKey,s=this.createTxBuilder(i),u={},a=await this.scope.api.fetchPoolKeysById({idList:e.map(c=>c.id)});for(let c of e){let l=a.find(P=>P.id===c.id)||await this.getCpmmPoolKeys(c.id),[m,p,f,y]=[new q(c.mintA.address),new q(c.mintB.address),new q(c.mintA.programId),new q(c.mintB.programId)],b=u[c.mintA.address]||this.scope.account.getAssociatedTokenAccount(m,f),g=u[c.mintB.address]||this.scope.account.getAssociatedTokenAccount(p,y);u[c.mintA.address]||s.addInstruction({instructions:[Ro(this.scope.ownerPubKey,b,this.scope.ownerPubKey,m,f)]}),u[c.mintB.address]||s.addInstruction({instructions:[Ro(this.scope.ownerPubKey,g,this.scope.ownerPubKey,p,y)]}),u[c.mintA.address]=b,u[c.mintB.address]=g,s.addInstruction({instructions:[ma(t,this.scope.ownerPubKey,new q(l.authority),new q(l.id),new q(l.config.id),new q(l.vault.A),new q(l.vault.B),m,p,b,g,f,y)],instructionTypes:[]})}return n===0?s.sizeCheckBuildV0({computeBudgetConfig:o}):s.sizeCheckBuild({computeBudgetConfig:o})}computeSwapAmount({pool:e,amountIn:t,outputMint:n,slippage:o}){let r=n.toString()===e.mintB.address,i=e.feeOn===0||e.feeOn===2,s=r?hi.swapBaseInput(t,r?e.baseReserve:e.quoteReserve,r?e.quoteReserve:e.baseReserve,e.configInfo.tradeFeeRate,e.configInfo.creatorFeeRate,e.configInfo.protocolFeeRate,e.configInfo.fundFeeRate,i):hi.swapBaseOutput(t,r?e.baseReserve:e.quoteReserve,r?e.quoteReserve:e.baseReserve,e.configInfo.tradeFeeRate,e.configInfo.creatorFeeRate,e.configInfo.protocolFeeRate,e.configInfo.fundFeeRate,i),u=new qt(s.outputAmount.toString()).div(s.inputAmount.toString()),a=s.outputAmount.mul(new Ge((1-o)*1e4)).div(new Ge(1e4));return{allTrade:s.inputAmount.eq(t),amountIn:t,amountOut:s.outputAmount,minAmountOut:a,executionPrice:u,fee:s.tradeFee,priceImpact:e.poolPrice.sub(u).div(e.poolPrice)}}computePairAmount({poolInfo:e,baseReserve:t,quoteReserve:n,amount:o,slippage:r,epochInfo:i,baseIn:s}){var h,w,k,x,B,K,I,R,C;let u=1-Number(r.toSignificant())/100,a=new Ge(new qt(o).mul(10**e[s?"mintA":"mintB"].decimals).mul(u).toFixed(0)),c=Se(a,e[s?"mintA":"mintB"].extensions.feeConfig,i,!1),l=a.sub((h=c.fee)!=null?h:new Ge(0)),m=new Ge(new qt(e.lpAmount).mul(10**e.lpMint.decimals).toFixed(0,qt.ROUND_DOWN));this.logDebug("baseReserve:",t.toString(),"quoteReserve:",n.toString()),this.logDebug("tokenIn:",s?e.mintA.symbol:e.mintB.symbol,"amountIn:",a.toString(),"amountInFee:",(k=(w=c.fee)==null?void 0:w.toString())!=null?k:0,"anotherToken:",s?e.mintB.symbol:e.mintA.symbol,"slippage:",`${r.toSignificant()}%`);let p=s?"base":"quote";this.logDebug("input side:",p);let f=l.mul(m).div(p==="base"?t:n),y={amount:kt,fee:void 0,expirationTime:void 0};if(!l.isZero()){let N=ep(f,t,n,m);this.logDebug("lpAmountData:",{amountA:N.amountA.toString(),amountB:N.amountB.toString()}),y=Se(N[s?"amountB":"amountA"],e[s?"mintB":"mintA"].extensions.feeConfig,i,!0)}let b=new tt(new Ge(1)).add(r),g=new tt(new Ge(1)).sub(r),P=Se(b.mul(y.amount.sub((x=y.fee)!=null?x:new Ge(0))).quotient,e[s?"mintB":"mintA"].extensions.feeConfig,i,!0),T=Se(g.mul(y.amount.sub((B=y.fee)!=null?B:new Ge(0))).quotient,e[s?"mintB":"mintA"].extensions.feeConfig,i,!0);return this.logDebug("anotherAmount:",y.amount.toString(),"anotherAmountFee:",(I=(K=y.fee)==null?void 0:K.toString())!=null?I:0,"maxAnotherAmount:",P.amount.toString(),"maxAnotherAmountFee:",(C=(R=P.fee)==null?void 0:R.toString())!=null?C:0),{inputAmountFee:c,anotherAmount:y,maxAnotherAmount:P,minAnotherAmount:T,liquidity:f}}};function ep(d,e,t,n){let o=d.mul(e).div(n);!o.isZero()&&!d.mul(e).mod(n).isZero()&&(o=o.add(new Ge(1)));let r=d.mul(t).div(n);return!r.isZero()&&!d.mul(t).mod(n).isZero()&&(r=r.add(new Ge(1))),{amountA:o,amountB:r}}import{PublicKey as ao}from"@solana/web3.js";import{createTransferInstruction as zc,TOKEN_PROGRAM_ID as He,TOKEN_2022_PROGRAM_ID as Or}from"@solana/spl-token";import Nr from"bn.js";import Ki from"decimal.js";var Dc={[is.toBase58()]:3},qc={3:is};var da=F([we(5),we(8),M("ownAddress"),A("vaultSignerNonce"),M("baseMint"),M("quoteMint"),M("baseVault"),A("baseDepositsTotal"),A("baseFeesAccrued"),M("quoteVault"),A("quoteDepositsTotal"),A("quoteFeesAccrued"),A("quoteDustThreshold"),M("requestQueue"),M("eventQueue"),M("bids"),M("asks"),A("baseLotSize"),A("quoteLotSize"),A("feeRateBps"),A("referrerRebatesAccrued"),we(7)]),Uc={3:da};import{PublicKey as Gc}from"@solana/web3.js";var Rr=be("Serum"),Lr=class{static getProgramId(e){let t=qc[e];return t||Rr.logWithError("invalid version","version",e),t}static getVersion(e){let t=e.toBase58(),n=Dc[t];return n||Rr.logWithError("invalid program id","programId",t),n}static getStateLayout(e){let t=Uc[e];return t||Rr.logWithError(!!t,"invalid version","version",e),t}static getLayouts(e){return{state:this.getStateLayout(e)}}static getAssociatedAuthority({programId:e,marketId:t}){let n=[t.toBuffer()],o=0,r;for(;o<100;){try{let i=n.concat(Buffer.from([o]),Buffer.alloc(7));r=Gc.createProgramAddressSync(i,e)}catch(i){if(i instanceof TypeError)throw i;o++;continue}return{publicKey:r,nonce:o}}return Rr.logWithError("unable to find a viable program address nonce","params",{programId:e,marketId:t}),{publicKey:Gc.default,nonce:o}}};import{PublicKey as se,SystemProgram as tp,TransactionInstruction as np}from"@solana/web3.js";import so from"bn.js";import{ASSOCIATED_TOKEN_PROGRAM_ID as op,TOKEN_2022_PROGRAM_ID as ip,TOKEN_PROGRAM_ID as rp}from"@solana/spl-token";function sp(d,e,t,n,o,r,i,s,u,a,c,l,m,p,f){var k;let y=[],b=[S({pubkey:rp,isWritable:!1}),S({pubkey:ip,isWritable:!1}),S({pubkey:op,isWritable:!1}),S({pubkey:tp.programId,isWritable:!1}),S({pubkey:e,isSigner:!0})];b.push(S({pubkey:t})),b.push(S({pubkey:o}));let g=[u,a],P=[c,l],T=[r,i,s];for(let x=0;x<g.length;x++){let B=g[x],K=T[x]===B.mintA.address;if(b.push(S({pubkey:new se(B.programId),isWritable:!1})),x===g.length-1?b.push(S({pubkey:o})):b.push(S({pubkey:n})),b.push(S({pubkey:new se(T[x])})),b.push(S({pubkey:new se(T[x+1])})),B.version===6){let I=P[x];b.push(S({pubkey:new se(I.config.id)})),b.push(S({pubkey:new se(I.id)})),b.push(S({pubkey:new se(K?I.vault.A:I.vault.B)})),b.push(S({pubkey:new se(K?I.vault.B:I.vault.A)})),b.push(S({pubkey:new se(B.observationId)})),b.push(S({pubkey:xn})),b.push(S({pubkey:Qe(new se(B.programId),new se(B.id)).publicKey})),y.push(ap(B.sqrtPriceX64.toString(),K));for(let R of(k=f[x])!=null?k:[])b.push(S({pubkey:new se(R)}))}else if(B.version===5){let I=P[x];b.push(S({pubkey:new se(I.id)})),b.push(S({pubkey:new se(I.authority),isWritable:!1})),b.push(S({pubkey:new se(I.marketProgramId)})),b.push(S({pubkey:new se(I.marketAuthority)})),b.push(S({pubkey:au,isWritable:!1})),b.push(S({pubkey:new se(I.openOrders)})),b.push(S({pubkey:new se(I.vault.A)})),b.push(S({pubkey:new se(I.vault.B)})),b.push(S({pubkey:new se(I.id)})),b.push(S({pubkey:new se(I.id)})),b.push(S({pubkey:new se(I.id)})),b.push(S({pubkey:new se(I.id)})),b.push(S({pubkey:new se(I.id)})),b.push(S({pubkey:new se(I.id)})),b.push(S({pubkey:new se(I.marketId)})),b.push(S({pubkey:new se(I.marketBids)})),b.push(S({pubkey:new se(I.marketAsks)})),b.push(S({pubkey:new se(I.marketEventQueue)})),b.push(S({pubkey:new se(I.marketBaseVault)})),b.push(S({pubkey:new se(I.marketQuoteVault)}))}else if(B.version===4){let I=P[x],R=B.status!==1;b.push(S({pubkey:new se(I.id)})),b.push(S({pubkey:new se(I.authority),isWritable:!1})),b.push(S({pubkey:new se(R?I.id:I.marketProgramId)})),b.push(S({pubkey:new se(R?I.id:I.marketAuthority)})),b.push(S({pubkey:new se(R?I.id:I.openOrders)})),b.push(S({pubkey:new se(I.vault.A)})),b.push(S({pubkey:new se(I.vault.B)})),b.push(S({pubkey:new se(R?I.id:I.marketId)})),b.push(S({pubkey:new se(R?I.id:I.marketBids)})),b.push(S({pubkey:new se(R?I.id:I.marketAsks)})),b.push(S({pubkey:new se(R?I.id:I.marketEventQueue)})),b.push(S({pubkey:new se(R?I.id:I.marketBaseVault)})),b.push(S({pubkey:new se(R?I.id:I.marketQuoteVault)}))}else if(B.version===7){let I=P[x];b.push(S({pubkey:new se(I.authority)})),b.push(S({pubkey:new se(I.config.id)})),b.push(S({pubkey:new se(I.id)})),b.push(S({pubkey:new se(K?I.vault.A:I.vault.B)})),b.push(S({pubkey:new se(K?I.vault.B:I.vault.A)})),b.push(S({pubkey:new se(B.observationId)}))}else throw Error("pool type error")}let h=F([V("insId"),A("amountIn"),A("amountOut"),Y(ie(),y.length,"clmmPriceLimit")]),w=Buffer.alloc(h.span);return h.encode({insId:0,amountIn:m,amountOut:p,clmmPriceLimit:y},w),new np({keys:b,programId:d,data:w})}function ap(d,e){if(d)if(e){let t=new so(d).div(new so(25));return t.gt(pr)?t:pr}else{let t=new so(d).mul(new so(25));return t.lt(fr)?t:fr}else return e?pr:fr}function Xc({routeProgram:d,ownerInfo:e,inputMint:t,swapInfo:n}){var o,r,i,s,u,a,c;if(n.routeType==="amm")if(n.poolInfo[0].version===6){let l=n.poolKey[0],m=rt(l),p=t.equals(m.mintA.address)?Wt.add(Ct):Dt.sub(Ct);return Ce.makeSwapBaseInInstructions({poolInfo:l,poolKeys:l,observationId:n.poolInfo[0].observationId,ownerInfo:{wallet:e.wallet,tokenAccountA:m.mintA.address.equals(t)?e.sourceToken:e.destinationToken,tokenAccountB:m.mintA.address.equals(t)?e.destinationToken:e.sourceToken},inputMint:t,amountIn:n.amountIn.amount.raw,amountOutMin:n.minAmountOut.amount.raw.sub((r=(o=n.minAmountOut.fee)==null?void 0:o.raw)!=null?r:new so(0)),sqrtPriceLimitX64:p,remainingAccounts:(i=n.remainingAccounts[0])!=null?i:[]})}else if(n.poolInfo[0].version===7){let l=n.poolInfo[0],m=t.toString()===n.poolInfo[0].mintA.address;return{signers:[],instructions:[Kr(l.programId,e.wallet,l.authority,l.configId,l.id,e.sourceToken,e.destinationToken,m?l.vaultA:l.vaultB,m?l.vaultB:l.vaultA,m?l.mintProgramA:l.mintProgramB,m?l.mintProgramB:l.mintProgramA,new se(l[m?"mintA":"mintB"].address),new se(l[m?"mintB":"mintA"].address),l.observationId,n.amountIn.amount.raw,n.minAmountOut.amount.raw)],lookupTableAddress:[],instructionTypes:[m?U.CpmmSwapBaseIn:U.CpmmSwapBaseOut],address:{}}}else{let l=n.poolKey[0];return{signers:[],instructions:[kr({poolKeys:l,version:n.poolInfo[0].pooltype.includes("StablePool")?5:4,userKeys:{tokenAccountIn:e.sourceToken,tokenAccountOut:e.destinationToken,owner:e.wallet},amountIn:n.amountIn.amount.raw,amountOut:n.minAmountOut.amount.raw.sub((u=(s=n.minAmountOut.fee)==null?void 0:s.raw)!=null?u:new so(0)),fixedSide:"in"})],lookupTableAddress:l.lookupTableAccount?[l.lookupTableAccount]:[],instructionTypes:[n.poolInfo[0].pooltype.includes("StablePool")?U.AmmV5SwapBaseIn:U.AmmV4SwapBaseIn],address:{}}}else if(n.routeType==="route"){let l=n.poolInfo[0],m=n.poolInfo[1],p=n.poolKey[0],f=n.poolKey[1];if(e.routeToken===void 0)throw Error("owner route token account check error");return{signers:[],instructions:[sp(d,e.wallet,e.sourceToken,e.routeToken,e.destinationToken,t.toString(),n.middleToken.mint.toString(),n.outputMint.toString(),l,m,p,f,n.amountIn.amount.raw,n.minAmountOut.amount.raw.sub((c=(a=n.minAmountOut.fee)==null?void 0:a.raw)!=null?c:new so(0)),n.remainingAccounts)],instructionTypes:[U.RouteSwap],lookupTableAddress:[p.lookupTableAccount,f.lookupTableAccount].filter(y=>y!==void 0),address:{}}}else throw Error("route type error")}var hn=new Nr(0),Ci=class extends _e{constructor(e){super(e)}async getWSolAccounts(){this.scope.checkOwner(),await this.scope.account.fetchWalletTokenAccounts();let e=this.scope.account.tokenAccounts.filter(t=>t.mint.equals(j));return e.sort((t,n)=>t.isAssociated?1:n.isAssociated||t.amount.lt(n.amount)?-1:1),e}async unWrapWSol(e){let{amount:t,tokenProgram:n,txVersion:o=1,feePayer:r}=e,i=await this.getWSolAccounts(),s=this.createTxBuilder(r);s.addCustomComputeBudget(e.computeBudgetConfig);let u=te(t);for(let a=0;a<i.length;a++)u.gte(i[a].amount)?(s.addInstruction({instructions:[fn({tokenAccount:i[a].publicKey,payer:this.scope.ownerPubKey,owner:this.scope.ownerPubKey,programId:n})]}),u.sub(i[a].amount)):s.addInstruction({instructions:[fn({tokenAccount:i[a].publicKey,payer:this.scope.ownerPubKey,owner:this.scope.ownerPubKey,programId:n})]});return s.versionBuild({txVersion:o})}async wrapWSol(e,t,n,o){let r=this.createTxBuilder(o),i=await On({connection:this.scope.connection,owner:this.scope.ownerPubKey,payer:this.scope.ownerPubKey,amount:e,skipCloseAccount:!0});return r.addInstruction(i),r.versionBuild({txVersion:n!=null?n:1})}async swap({swapInfo:e,swapPoolKeys:t,ownerInfo:n,computeBudgetConfig:o,routeProgram:r,txVersion:i,feePayer:s}){let u=this.createTxBuilder(s),a=e.amountIn,c=e.amountOut,l=a.amount.token.mint.equals(j),m=c.amount.token.mint.equals(j),p=a.amount.token.mint,f=c.amount.token.mint,{account:y,instructionParams:b}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:a.amount.token.isToken2022?Or:He,mint:p,notUseTokenAccount:l,owner:this.scope.ownerPubKey,skipCloseAccount:!l,createInfo:l?{payer:this.scope.ownerPubKey,amount:a.amount.raw}:void 0,associatedOnly:l?!1:n.associatedOnly,checkCreateATAOwner:n.checkCreateATAOwner});if(b&&u.addInstruction(b),y===void 0)throw Error("input account check error");let g;if(e.routeType==="route"&&!m)g=this.scope.account.getAssociatedTokenAccount(f,c.amount.token.isToken2022?Or:He);else{let{account:w,instructionParams:k}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:c.amount.token.isToken2022?Or:He,mint:f,notUseTokenAccount:m,owner:this.scope.ownerPubKey,skipCloseAccount:!0,createInfo:{payer:this.scope.ownerPubKey,amount:0},associatedOnly:m?!1:n.associatedOnly,checkCreateATAOwner:n.checkCreateATAOwner});g=w,k&&u.addInstruction(k)}m&&u.addInstruction({endInstructions:[fn({owner:this.scope.ownerPubKey,payer:this.scope.ownerPubKey,tokenAccount:g,programId:He})],endInstructionTypes:[U.CloseAccount]});let P;if(e.routeType==="route"){let w=e.middleToken;P=this.scope.account.getAssociatedTokenAccount(w.mint,w.isToken2022?Or:He)}let T=t||await this.computePoolToPoolKeys({pools:e.poolInfoList}),h=Xc({routeProgram:r,inputMint:p,swapInfo:D(v({},e),{poolInfo:[...e.poolInfoList],poolKey:T,outputMint:f}),ownerInfo:{wallet:this.scope.ownerPubKey,sourceToken:y,routeToken:P,destinationToken:g}});if(e.feeConfig!==void 0){let w=this.createTxBuilder();w.addInstruction({instructions:[zc(y,e.feeConfig.feeAccount,this.scope.ownerPubKey,e.feeConfig.feeAmount.toNumber())],instructionTypes:[U.TransferAmount]}),w.addInstruction(h);let{transactions:k}=i===0?await w.sizeCheckBuildV0():await w.sizeCheckBuild();k.length<2&&u.addInstruction({instructions:[zc(y,e.feeConfig.feeAccount,this.scope.ownerPubKey,e.feeConfig.feeAmount.toNumber())],instructionTypes:[U.TransferAmount]})}return u.addInstruction(h),i===0?u.sizeCheckBuildV0({computeBudgetConfig:o,address:h.address}):u.sizeCheckBuild({computeBudgetConfig:o,address:h.address})}async fetchRoutePoolBasicInfo(e){let{amm:t=Hi,clmm:n=qn,cpmm:o=Gn}=e||{},r=await this.scope.connection.getProgramAccounts(t,{dataSlice:{offset:pi.offsetOf("baseMint"),length:64}}),i=F([M("baseMint"),M("quoteMint")]),s=r.map(p=>({id:p.pubkey,version:4,mintA:i.decode(p.account.data).baseMint,mintB:i.decode(p.account.data).quoteMint})),u=F([M("mintA"),M("mintB")]),c=(await this.scope.connection.getProgramAccounts(n,{filters:[{dataSize:Jn.span}],dataSlice:{offset:Jn.offsetOf("mintA"),length:64}})).map(p=>{let f=u.decode(p.account.data);return{id:p.pubkey,version:6,mintA:f.mintA,mintB:f.mintB}}),m=(await this.scope.connection.getProgramAccounts(o,{dataSlice:{offset:Cr.offsetOf("mintA"),length:64}})).map(p=>{let f=u.decode(p.account.data);return{id:p.pubkey,version:7,mintA:f.mintA,mintB:f.mintB}});return{clmmPools:c,ammPools:s,cpmmPools:m}}getAllRoute({inputMint:e,outputMint:t,clmmPools:n,ammPools:o,cpmmPools:r}){e=e.toString()===ao.default.toString()?j:e,t=t.toString()===ao.default.toString()?j:t;let i={},s={},u={},a=[],c={};for(let m of n!=null?n:[]){if((m.mintA.equals(e)&&m.mintB.equals(t)||m.mintA.equals(t)&&m.mintB.equals(e))&&(a.push(m),s[m.id.toString()]=m),m.mintA.equals(e)){let p=m.mintB.toString();c[p]===void 0&&(c[p]={mintProgram:He,in:[],out:[],mDecimals:0}),c[p].in.push(m)}if(m.mintB.equals(e)){let p=m.mintA.toString();c[p]===void 0&&(c[p]={mintProgram:He,in:[],out:[],mDecimals:0}),c[p].in.push(m)}if(m.mintA.equals(t)){let p=m.mintB.toString();c[p]===void 0&&(c[p]={mintProgram:He,in:[],out:[],mDecimals:0}),c[p].out.push(m)}if(m.mintB.equals(t)){let p=m.mintA.toString();c[p]===void 0&&(c[p]={mintProgram:He,in:[],out:[],mDecimals:0}),c[p].out.push(m)}}let l=[];for(let m of o)(m.mintA.equals(e)&&m.mintB.equals(t)||m.mintA.equals(t)&&m.mintB.equals(e))&&(a.push(m),i[m.id.toBase58()]=m,l.push(m)),m.mintA.equals(e)&&(c[m.mintB.toBase58()]===void 0&&(c[m.mintB.toBase58()]={mintProgram:He,in:[],out:[],mDecimals:0}),c[m.mintB.toBase58()].in.push(m)),m.mintB.equals(e)&&(c[m.mintA.toBase58()]===void 0&&(c[m.mintA.toBase58()]={mintProgram:He,in:[],out:[],mDecimals:0}),c[m.mintA.toBase58()].in.push(m)),m.mintA.equals(t)&&(c[m.mintB.toBase58()]===void 0&&(c[m.mintB.toBase58()]={mintProgram:He,in:[],out:[],mDecimals:0}),c[m.mintB.toBase58()].out.push(m)),m.mintB.equals(t)&&(c[m.mintA.toBase58()]===void 0&&(c[m.mintA.toBase58()]={mintProgram:He,in:[],out:[],mDecimals:0}),c[m.mintA.toBase58()].out.push(m));for(let m of r)(m.mintA.equals(e)&&m.mintB.equals(t)||m.mintA.equals(t)&&m.mintB.equals(e))&&(a.push(m),u[m.id.toBase58()]=m),m.mintA.equals(e)&&(c[m.mintB.toBase58()]===void 0&&(c[m.mintB.toBase58()]={mintProgram:He,in:[],out:[],mDecimals:0}),c[m.mintB.toBase58()].in.push(m)),m.mintB.equals(e)&&(c[m.mintA.toBase58()]===void 0&&(c[m.mintA.toBase58()]={mintProgram:He,in:[],out:[],mDecimals:0}),c[m.mintA.toBase58()].in.push(m)),m.mintA.equals(t)&&(c[m.mintB.toBase58()]===void 0&&(c[m.mintB.toBase58()]={mintProgram:He,in:[],out:[],mDecimals:0}),c[m.mintB.toBase58()].out.push(m)),m.mintB.equals(t)&&(c[m.mintA.toBase58()]===void 0&&(c[m.mintA.toBase58()]={mintProgram:He,in:[],out:[],mDecimals:0}),c[m.mintA.toBase58()].out.push(m));for(let m of Object.keys(c)){if(c[m].in.length===1&&c[m].out.length===1&&c[m].in[0].id.equals(c[m].out[0].id)){delete c[m];continue}if(c[m].in.length===0||c[m].out.length===0){delete c[m];continue}let p=c[m];for(let f of p.in)for(let y of p.out)f.version===6&&s[f.id.toString()]===void 0?s[f.id.toString()]=f:f.version===7&&u[f.id.toString()]===void 0?u[f.id.toString()]=f:(f.version===4||f.version===5)&&i[f.id.toString()]===void 0&&(i[f.id.toString()]=f),y.version===6&&s[y.id.toString()]===void 0?s[y.id.toString()]=y:y.version===7&&u[y.id.toString()]===void 0?u[y.id.toString()]=y:(y.version===4||y.version===5)&&i[y.id.toString()]===void 0&&(i[y.id.toString()]=y)}return{directPath:a,addLiquidityPools:l,routePathDict:c,needSimulate:Object.values(i),needTickArray:Object.values(s),cpmmPoolList:Object.values(u)}}async fetchSwapRoutesData({routes:e,inputMint:t,outputMint:n}){let o=new Set([...e.needTickArray.map(y=>[y.mintA.toBase58(),y.mintB.toBase58()]).flat(),t.toString(),n.toString()]);console.log("fetching amm pools info, total: ",e.needSimulate.length);let r=await this.scope.liquidity.getRpcPoolInfos(e.needSimulate.map(y=>y.id)),i=hr(r),s={};Object.values(i).forEach(y=>{o.delete(y.mintA.address),s[y.mintA.address]={address:new ao(y.mintA.address),programId:He,mintAuthority:null,supply:BigInt(0),decimals:y.mintA.decimals,isInitialized:!0,freezeAuthority:null,tlvData:Buffer.from("0","hex"),feeConfig:void 0},o.delete(y.mintB.address),s[y.mintB.address]={address:new ao(y.mintB.address),programId:He,mintAuthority:null,supply:BigInt(0),decimals:y.mintB.decimals,isInitialized:!0,freezeAuthority:null,tlvData:Buffer.from("0","hex"),feeConfig:void 0}}),console.log("fetching cpmm pools info, total: ",e.cpmmPoolList.length);let u=await this.scope.cpmm.getRpcPoolInfos(e.cpmmPoolList.map(y=>y.id.toBase58()),!0);Object.values(u).forEach(y=>{let[b,g]=[y.mintA.toBase58(),y.mintB.toBase58()];y.mintProgramA.equals(He)?(o.delete(b),s[b]={address:y.mintA,programId:y.mintProgramA,mintAuthority:null,supply:BigInt(0),decimals:y.mintDecimalA,isInitialized:!0,freezeAuthority:null,tlvData:Buffer.from("0","hex"),feeConfig:void 0}):o.add(b),y.mintProgramB.equals(He)?(o.delete(g),s[g]={address:y.mintB,programId:y.mintProgramB,mintAuthority:null,supply:BigInt(0),decimals:y.mintDecimalB,isInitialized:!0,freezeAuthority:null,tlvData:Buffer.from("0","hex"),feeConfig:void 0}):o.add(g)}),console.log("fetching mints info, total: ",o.size);let a=await go({connection:this.scope.connection,mints:Array.from(o).map(y=>new ao(y))});s=v(v({},s),a);let c=this.scope.cpmm.toComputePoolInfos({pools:u,mintInfos:s});console.log("fetching clmm pools info, total:",e.needTickArray.length);let l=await this.scope.clmm.getRpcClmmPoolInfos({poolIds:e.needTickArray.map(y=>y.id)}),{computeClmmPoolInfo:m,computePoolTickData:p}=await this.scope.clmm.getComputeClmmPoolInfos({clmmPoolsRpcInfo:l,mintInfos:s}),f=Object.keys(e.routePathDict).reduce((y,b)=>D(v({},y),{[b]:D(v({},e.routePathDict[b]),{mintProgram:s[b].programId,mDecimals:s[b].decimals,in:e.routePathDict[b].in.map(g=>i[g.id.toBase58()]||m[g.id.toBase58()]||c[g.id.toBase58()]),out:e.routePathDict[b].out.map(g=>i[g.id.toBase58()]||m[g.id.toBase58()]||c[g.id.toBase58()])})}),{});return{mintInfos:s,ammPoolsRpcInfo:r,ammSimulateCache:i,clmmPoolsRpcInfo:l,computeClmmPoolInfo:m,computePoolTickData:p,computeCpmmData:c,routePathDict:f}}getAllRouteComputeAmountOut({inputTokenAmount:e,outputToken:t,directPath:n,routePathDict:o,simulateCache:r,tickCache:i,slippage:s,chainTime:u,epochInfo:a,feeConfig:c}){var g,P,T,h,w,k,x,B,K;let l=c===void 0?new Nr(0):e.raw.mul(new Nr(c.feeBps.toNumber())).div(new Nr(1e4)),m=e.raw.sub(l),p=new xe(e.token,m),f=c===void 0?void 0:{feeAmount:l,feeAccount:c.feeAccount},y=D(v({},t),{address:ct(t.address).toString()}),b=[];for(let I of n)try{b.push(D(v({},this.computeAmountOut({itemPool:I,tickCache:i,simulateCache:r,chainTime:u,epochInfo:a,slippage:s,outputToken:y,amountIn:p})),{feeConfig:f}))}catch(R){this.logDebug("direct error",I.version,I.id.toString(),R.message)}this.logDebug("direct done");for(let[I,R]of Object.entries(o)){let C={chainId:101,address:I,programId:R.mintProgram.toBase58(),logoURI:"",symbol:"",name:"",decimals:R.mDecimals,tags:[],extensions:{}},N=R.in.map(O=>{try{return{pool:O,data:this.computeAmountOut({itemPool:O,tickCache:i,simulateCache:r,chainTime:u,epochInfo:a,slippage:s,outputToken:C,amountIn:p})}}catch(_){this.logDebug("route in error",O.version,O.id.toString(),_.message);return}}).sort((O,_)=>{var H,me,ne,ae;let G=O===void 0?hn:O.data.amountOut.amount.raw.sub((me=(H=O.data.amountOut.fee)==null?void 0:H.raw)!=null?me:hn),z=_===void 0?hn:_.data.amountOut.amount.raw.sub((ae=(ne=_.data.amountOut.fee)==null?void 0:ne.raw)!=null?ae:hn);return G.lt(z)?1:-1})[0];if(N===void 0)continue;let L=new xe(Pr(C),N.data.amountOut.amount.raw.sub((P=(g=N.data.amountOut.fee)==null?void 0:g.raw)!=null?P:hn));for(let O of R.out)try{let _=this.computeAmountOut({itemPool:O,tickCache:i,simulateCache:r,chainTime:u,epochInfo:a,slippage:s,outputToken:y,amountIn:L});b.push(D(v({},_),{allTrade:!!(N.data.allTrade&&_.allTrade),amountIn:N.data.amountIn,amountOut:_.amountOut,minAmountOut:_.minAmountOut,currentPrice:void 0,executionPrice:new Ki(new At({baseToken:N.data.amountIn.amount.token,denominator:N.data.amountIn.amount.raw,quoteToken:_.amountOut.amount.token,numerator:_.amountOut.amount.raw.sub((h=(T=_.amountOut.fee)==null?void 0:T.raw)!=null?h:hn)}).toFixed()),priceImpact:new Ki(N.data.priceImpact.add(_.priceImpact).toFixed()),fee:[N.data.fee[0],_.fee[0]],routeType:"route",poolInfoList:[N.pool,O],remainingAccounts:[N.data.remainingAccounts[0],_.remainingAccounts[0]],minMiddleAmountFee:(w=_.amountOut.fee)!=null&&w.raw?new xe(N.data.amountOut.amount.token,((x=(k=N.data.amountOut.fee)==null?void 0:k.raw)!=null?x:hn).add((K=(B=_.amountOut.fee)==null?void 0:B.raw)!=null?K:hn)):void 0,middleToken:N.data.amountOut.amount.token,poolReady:N.data.poolReady&&_.poolReady,poolType:[N.data.poolType,_.poolType],feeConfig:f,expirationTime:$t(N.data.expirationTime,_.expirationTime)}))}catch(_){this.logDebug("route out error",O.version,O.id.toString(),_.message)}}return b.filter(I=>(I.allTrade||this.logDebug(`pool ${I.poolInfoList.map(R=>R.id.toString()).join(",")} filter out since not all trade`),I.allTrade)).sort((I,R)=>I.amountOut.amount.raw.sub(R.amountOut.amount.raw).gt(hn)?-1:1)}computeAmountOut({itemPool:e,tickCache:t,simulateCache:n,chainTime:o,epochInfo:r,slippage:i,outputToken:s,amountIn:u}){if(e.version===6){let{allTrade:a,realAmountIn:c,amountOut:l,minAmountOut:m,expirationTime:p,currentPrice:f,executionPrice:y,priceImpact:b,fee:g,remainingAccounts:P,executionPriceX64:T}=Ne.computeAmountOutFormat({poolInfo:e,tickArrayCache:t[e.id.toString()],amountIn:u.raw,tokenOut:s,slippage:i,epochInfo:r,catchLiquidityInsufficient:!0});return{allTrade:a,amountIn:c,amountOut:l,minAmountOut:m,currentPrice:new Ki(f.toFixed()),executionPrice:new Ki(y.toFixed()),priceImpact:new Ki(b.toFixed()),fee:[g],remainingAccounts:[P],routeType:"amm",poolInfoList:[e],poolReady:e.startTime<o,poolType:"CLMM",slippage:i,clmmExPriceX64:[T],expirationTime:$t(c.expirationTime,p)}}else if(e.version===7){let{allTrade:a,executionPrice:c,amountOut:l,minAmountOut:m,priceImpact:p,fee:f}=this.scope.cpmm.computeSwapAmount({pool:e,outputMint:s.address,amountIn:u.raw,slippage:i});return{allTrade:a,amountIn:{amount:u,fee:void 0,expirationTime:void 0},amountOut:{amount:di(D(v({},s),{amount:l})),fee:void 0,expirationTime:void 0},minAmountOut:{amount:di(D(v({},s),{amount:m})),fee:void 0,expirationTime:void 0},currentPrice:e.poolPrice,executionPrice:c,priceImpact:p,fee:[new xe(u.token,f)],remainingAccounts:[],routeType:"amm",poolInfoList:[e],poolReady:e.openTime.toNumber()<o,poolType:"CPMM",slippage:i,clmmExPriceX64:[void 0],expirationTime:void 0}}else{if(![1,6,7].includes(n[e.id.toString()].status))throw Error("swap error");let{amountOut:a,minAmountOut:c,currentPrice:l,executionPrice:m,priceImpact:p,fee:f}=this.scope.liquidity.computeAmountOut({poolInfo:n[e.id.toString()],amountIn:u.raw,mintIn:u.token.mint,mintOut:s.address,slippage:i});return{amountIn:{amount:u,fee:void 0,expirationTime:void 0},amountOut:{amount:di(D(v({},s),{amount:a})),fee:void 0,expirationTime:void 0},minAmountOut:{amount:di(D(v({},s),{amount:c})),fee:void 0,expirationTime:void 0},currentPrice:l,executionPrice:m,priceImpact:p,fee:[new xe(u.token,f)],routeType:"amm",poolInfoList:[e],remainingAccounts:[],poolReady:Number(n[e.id].openTime)<o,poolType:e.version===5?"STABLE":void 0,expirationTime:void 0,allTrade:!0,slippage:i,clmmExPriceX64:[void 0]}}}async computePoolToPoolKeys({pools:e,clmmRpcData:t={},ammRpcData:n={}}){let o=new Set(e.filter(a=>a.version===6&&!t[a.id.toString()]).map(a=>a.id.toString()));if(o.size>0){let a=await this.scope.clmm.getRpcClmmPoolInfos({poolIds:Array.from(o)});Object.keys(a).forEach(c=>{t[c]=a[c]})}let r=new Set(e.filter(a=>a.version===4&&!n[a.id.toString()]).map(a=>a.id.toString()));if(r.size>0){let a=await this.scope.liquidity.getRpcPoolInfos(Array.from(r));Object.keys(a).forEach(c=>{n[c]=a[c]})}let i=new Set(e.filter(a=>a.version===4).map(a=>a.marketId)),s={};i.size>0&&(await Oe(this.scope.connection,Array.from(i).map(c=>({pubkey:new ao(c)})))).forEach(c=>{if(!c.accountInfo)return;let l=da.decode(c.accountInfo.data);s[c.pubkey.toBase58()]={marketId:c.pubkey.toString(),marketProgramId:c.accountInfo.owner.toString(),marketAuthority:Lr.getAssociatedAuthority({programId:c.accountInfo.owner,marketId:c.pubkey}).publicKey.toString(),marketBaseVault:l.baseVault.toString(),marketQuoteVault:l.quoteVault.toString(),marketBids:l.bids.toString(),marketAsks:l.asks.toString(),marketEventQueue:l.eventQueue.toString()}});let u=[];return e.forEach(a=>{if(a.version===6){let c=t[a.id.toString()],l={programId:a.programId.toBase58(),id:a.id.toBase58(),mintA:a.mintA,mintB:a.mintB,openTime:String(a.startTime),vault:{A:c.vaultA.toBase58(),B:c.vaultB.toBase58()},config:D(v({},a.ammConfig),{id:a.ammConfig.id.toString(),defaultRange:0,defaultRangePoint:[]}),rewardInfos:[],observationId:a.observationId.toBase58(),exBitmapAccount:a.exBitmapAccount.toBase58()};u.push(l)}else if(a.version===4){let c=n[a.id.toString()],l=v({programId:a.programId,id:a.id,mintA:a.mintA,mintB:a.mintB,openTime:String(a.openTime),vault:{A:c.baseVault.toBase58(),B:c.quoteVault.toBase58()},authority:na({programId:new ao(a.programId)}).publicKey.toString(),openOrders:c.openOrders.toBase58(),targetOrders:c.targetOrders.toBase58(),mintLp:a.lpMint},s[a.marketId]);u.push(l)}else a.version===7&&u.push({observationId:a.observationId.toBase58(),programId:a.programId.toBase58(),id:a.id.toBase58(),mintA:a.mintA,mintB:a.mintB,openTime:String(a.openTime),authority:Ko(a.programId).publicKey.toBase58(),vault:{A:a.vaultA.toBase58(),B:a.vaultB.toBase58()},mintLp:pt({address:a.mintLp.toBase58(),programId:He.toBase58(),decimals:a.lpDecimals}),config:D(v({id:a.configId.toBase58()},a.configInfo),{protocolFeeRate:a.configInfo.protocolFeeRate.toNumber(),tradeFeeRate:a.configInfo.tradeFeeRate.toNumber(),fundFeeRate:a.configInfo.fundFeeRate.toNumber(),createPoolFee:a.configInfo.createPoolFee.toString()})})}),u}};import{PublicKey as up,Transaction as pa,TransactionInstruction as cp}from"@solana/web3.js";import{TOKEN_PROGRAM_ID as lp}from"@solana/spl-token";import Yc from"bn.js";var ft=class extends _e{static getPdaPoolId(e,t){return ce([ft.SEED_CONFIG.pool.id,t.toBuffer()],e)}static getPdaOwnerId(e,t,n,o){return ce([ft.SEED_CONFIG.owner.id,t.toBuffer(),n.toBuffer(),Buffer.from(new Yc(o).toArray())],e)}static async getAllInfo({connection:e,programId:t,poolIds:n,wallet:o,chainTime:r}){if(n.length===0)return[];let i=n.map(c=>ft.getPdaPoolId(t,c).publicKey),s=[];for(let c=0;c<ft.VERSION_PROJECT.length;c++)s.push(...i.map(l=>ft.getPdaOwnerId(t,l,o,c).publicKey));let u=await Ht(e,[...i,...s]),a=[];for(let c=0;c<u.length;c++){let l=Math.floor(c/n.length),m=c%n.length,p=i[m],f=s[c],y=u[m],b=u[n.length+c];if(!(y&&b)||y.data.length!==ft.POOL_LAYOUT.span||b.data.length!==ft.OWNER_LAYOUT.span)continue;let g=ft.POOL_LAYOUT.decode(y.data),P=ft.OWNER_LAYOUT.decode(b.data),T=g.openTime.toNumber(),h=g.endTime.toNumber(),w=P.tokenInfo.map(B=>B.debtAmount.gt(new Yc(0))).filter(B=>!B).length!==3,k=r>T&&r<h&&g.status===1,x=w&&k;a.push({programId:t,poolId:p,ammId:g.ammId,ownerAccountId:f,snapshotLpAmount:P.lpAmount,project:ft.VERSION_PROJECT[l],openTime:T,endTime:h,canClaim:x,canClaimErrorType:w?k?void 0:"outOfOperationalTime":"alreadyClaimIt",tokenInfo:g.tokenInfo.map((B,K)=>({mintAddress:B.mintAddress,mintVault:B.mintVault,mintDecimals:B.mintDecimals,perLpLoss:B.perLpLoss,debtAmount:P.tokenInfo[K].debtAmount.add(P.tokenInfo[K].claimedAmount)}))})}return a}async makeClaimTransaction({poolInfo:e,ownerInfo:t,feePayer:n}){t.wallet||this.scope.checkOwner();let o=this.createTxBuilder(n),r=t.wallet||this.scope.ownerPubKey,i=[];for(let a of e.tokenInfo){let{account:c,instructionParams:l}=await this.scope.account.getOrCreateTokenAccount({mint:a.mintAddress,owner:this.scope.ownerPubKey,notUseTokenAccount:a.mintAddress.equals(De.WSOL.mint),createInfo:{payer:r,amount:0},skipCloseAccount:!a.mintAddress.equals(De.WSOL.mint),associatedOnly:a.mintAddress.equals(De.WSOL.mint)?!1:t.associatedOnly});l&&o.addInstruction(l),i.push(c)}o.addInstruction({instructions:[ft.makeClaimInstruction({programId:e.programId,poolInfo:e,ownerInfo:{wallet:r,ownerPda:e.ownerAccountId,claimAddress:i}})]});let{transaction:s,signers:u}=o.build();return[{transaction:s,signer:u}]}async makeClaimAllTransaction({poolInfos:e,ownerInfo:t,feePayer:n}){let o=this.createTxBuilder(n),r=t.wallet||this.scope.ownerPubKey,i={};for(let c of e){let l=[];for(let m of c.tokenInfo){let{account:p,instructionParams:f}=await this.scope.account.getOrCreateTokenAccount({mint:m.mintAddress,owner:this.scope.ownerPubKey,notUseTokenAccount:m.mintAddress.equals(De.WSOL.mint),createInfo:{payer:r,amount:0},skipCloseAccount:!m.mintAddress.equals(De.WSOL.mint),associatedOnly:m.mintAddress.equals(De.WSOL.mint)?!1:t.associatedOnly});f&&o.addInstruction(f),p&&(i[m.mintAddress.toString()]=p,l.push(p))}o.addInstruction({instructions:[ft.makeClaimInstruction({programId:c.programId,poolInfo:c,ownerInfo:{wallet:r,ownerPda:c.ownerAccountId,claimAddress:l}})]})}let{transaction:s,signers:u}=o.build(),a=o.allInstructions;return os(a,[r,...u.map(c=>c.publicKey)])?[{transaction:s,signer:u}]:[{transaction:new pa().add(...a.slice(0,o.AllTxData.instructions.length-1)),signer:u},{transaction:new pa().add(...a.slice(o.AllTxData.instructions.length-1)),signer:[]},{transaction:new pa().add(...o.AllTxData.endInstructions),signer:[]}]}static makeClaimInstruction({programId:e,poolInfo:t,ownerInfo:n}){let o=F([]),r=[{pubkey:n.wallet,isSigner:!0,isWritable:!0},{pubkey:t.poolId,isSigner:!1,isWritable:!0},{pubkey:n.ownerPda,isSigner:!1,isWritable:!0},...n.claimAddress.map(u=>({pubkey:u,isSigner:!1,isWritable:!0})),...t.tokenInfo.map(({mintVault:u})=>({pubkey:u,isSigner:!1,isWritable:!0})),{pubkey:lp,isSigner:!1,isWritable:!1}],i=Buffer.alloc(o.span);o.encode({},i);let s=Buffer.from([10,66,208,184,161,6,191,98,...i]);return new cp({keys:r,programId:e,data:s})}},Ut=ft;Ut.CLAIMED_NUM=3,Ut.POOL_LAYOUT=F([we(8),V("bump"),V("status"),A("openTime"),A("endTime"),M("ammId"),Y(F([V("mintDecimals"),M("mintAddress"),M("mintVault"),A("perLpLoss"),A("totalClaimedAmount")]),ft.CLAIMED_NUM,"tokenInfo"),Y(A(),10,"padding")]),Ut.OWNER_LAYOUT=F([we(8),V("bump"),V("version"),M("poolId"),M("owner"),A("lpAmount"),Y(F([M("mintAddress"),A("debtAmount"),A("claimedAmount")]),ft.CLAIMED_NUM,"tokenInfo"),Y(A(),4,"padding")]),Ut.DEFAULT_POOL_ID=["58oQChx4yWmvKdwLLZzBi4ChoCc2fqCUWBkwMihLYQo2","6UmmUiYoBjSrhakAobJw8BvkmJtDVxaeBtbt7rxWo1mg","AVs9TA4nWDzfPJE9gGVNJMVhcQy3V9PGazuz33BfG2RA","DVa7Qmb5ct9RCpaU7UTpSaf3GVMYz17vNVU67XpdCRut","7XawhbbxtsRcQA8KTkHT9f9nc6d69UwqCDh6U5EEbEmX","6a1CsrpeZubDjEJE9s1CMVheB6HWM5d7m1cj2jkhyXhj","EoNrn8iUhwgJySD1pHu8Qxm5gSQqLK3za4m8xzD2RuEb","AceAyRTWt4PyB2pHqf2qhDgNZDtKVNaxgL8Ru3V4aN1P","6tmFJbMk5yVHFcFy7X2K8RwHjKLr6KVFLYXpgpBNeAxB"].map(e=>new up(e)),Ut.SEED_CONFIG={pool:{id:Buffer.from("pool_seed","utf8")},owner:{id:Buffer.from("user_claim_seed","utf8")}},Ut.VERSION_PROJECT=[void 0,"Francium","Tulip","Larix"];import{PublicKey as Li}from"@solana/web3.js";import jc from"bn.js";import{SYSVAR_CLOCK_PUBKEY as dp,TransactionInstruction as Qc}from"@solana/web3.js";import{TOKEN_PROGRAM_ID as Hc}from"@solana/spl-token";var mp=F([V("instruction"),ku("amount")]),Ri=F([V("instruction")]);function Mr({programId:d},e){let t=[{pubkey:Hc,isSigner:!1,isWritable:!1},{pubkey:Qa,isSigner:!1,isWritable:!1},...Object.entries(e).map(([o,r])=>({pubkey:r,isSigner:o==="userOwner",isWritable:!["authority","userOwner"].includes(o)}))],n=Buffer.alloc(Ri.span);return Ri.encode({instruction:2},n),new Qc({keys:t,programId:d,data:n})}function fa(d){let{poolConfig:e,userKeys:t,side:n}=d,o=n==="base"?t.baseTokenAccount:t.quoteTokenAccount,r=n==="base"?e.baseVault:e.quoteVault,i=Buffer.alloc(Ri.span);Ri.encode({instruction:2},i);let s=[{pubkey:Hc,isWritable:!1,isSigner:!1},{pubkey:dp,isWritable:!1,isSigner:!1},{pubkey:e.id,isWritable:!0,isSigner:!1},{pubkey:e.authority,isWritable:!1,isSigner:!1},{pubkey:r,isWritable:!0,isSigner:!1},{pubkey:o,isWritable:!0,isSigner:!1},{pubkey:t.ledgerAccount,isWritable:!0,isSigner:!1},{pubkey:t.owner,isWritable:!1,isSigner:!0}];return new Qc({programId:e.programId,keys:s,data:i})}var pp={[Go.IDO_PROGRAM_ID_V1.toString()]:1,[Go.IDO_PROGRAM_ID_V2.toString()]:2,[Go.IDO_PROGRAM_ID_V3.toString()]:3,[Go.IDO_PROGRAM_ID_V4.toString()]:4},Lo=class extends _e{async claim({ownerInfo:e,idoKeys:t,associatedOnly:n=!0,checkCreateATAOwner:o=!1,txVersion:r,feePayer:i}){let s=this.createTxBuilder(i),u=pp[t.programId];u||this.logAndCreateError("invalid version",u);let a=rt(t),[c,l]=[!new jc(e.coin).isZero(),!new jc(e.pc).isZero()],m=a.projectInfo.mint.address.equals(j),{account:p,instructionParams:f}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:a.projectInfo.mint.programId,mint:a.projectInfo.mint.address,owner:this.scope.ownerPubKey,createInfo:{payer:this.scope.ownerPubKey,amount:0},skipCloseAccount:!m,notUseTokenAccount:m,associatedOnly:m?!1:n,checkCreateATAOwner:o});!p&&c&&this.logAndCreateError("target token accounts not found","mint",t.projectInfo.mint.address),c&&f&&s.addInstruction(f);let y=a.buyInfo.mint.address.equals(j),{account:b,instructionParams:g}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:a.buyInfo.mint.programId,mint:a.buyInfo.mint.address,owner:this.scope.ownerPubKey,createInfo:{payer:this.scope.ownerPubKey,amount:0},skipCloseAccount:!y,notUseTokenAccount:y,associatedOnly:y?!1:n,checkCreateATAOwner:o});if(!p&&l&&this.logAndCreateError("target token accounts not found","mint",t.projectInfo.mint.address),l&&g&&s.addInstruction(g),(!p||!b)&&this.logAndCreateError("target token accounts not found","mint",t.projectInfo.mint.address,t.buyInfo.mint.address),u===3)return s.addInstruction({instructions:[...c?[Mr({programId:a.programId},{idoId:a.id,authority:a.authority,poolTokenAccount:a.projectInfo.vault,userTokenAccount:p,userIdoInfo:new Li(e.userIdoInfo),userOwner:this.scope.ownerPubKey})]:[],...l?[Mr({programId:new Li(t.programId)},{idoId:a.id,authority:a.authority,poolTokenAccount:a.buyInfo.vault,userTokenAccount:b,userIdoInfo:new Li(e.userIdoInfo),userOwner:this.scope.ownerPubKey})]:[]]}).versionBuild({txVersion:r});if(u<3)return!c&&!l&&this.logAndCreateError("no claimable rewards"),s.addInstruction({instructions:[Mr({programId:a.programId},{idoId:a.id,authority:a.authority,poolQuoteTokenAccount:a.buyInfo.vault,poolBaseTokenAccount:a.projectInfo.vault,userQuoteTokenAccount:b,userBaseTokenAccount:p,userIdoInfo:new Li(e.userIdoInfo),userOwner:this.scope.ownerPubKey})]}).versionBuild({txVersion:r});let P={poolConfig:{id:a.id,programId:a.programId,authority:a.authority,baseVault:a.projectInfo.vault,quoteVault:a.buyInfo.vault,baseToken:t.projectInfo.mint,quoteToken:t.buyInfo.mint},userKeys:{baseTokenAccount:p,quoteTokenAccount:b,ledgerAccount:new Li(e.userIdoInfo),owner:this.scope.ownerPubKey}};return s.addInstruction({instructions:[...c?[fa(D(v({},P),{side:"base"}))]:[],...l?[fa(D(v({},P),{side:"quote"}))]:[]]}).versionBuild({txVersion:r})}};var fp=Buffer.from("vault_auth_seed","utf8"),NK=Buffer.from("global_config","utf8"),yp=Buffer.from("pool_vesting","utf8"),bp=Buffer.from("platform_config","utf8"),gp=Buffer.from("platform_fee_vault_auth_seed","utf8"),Pp=Buffer.from("creator_fee_vault_auth_seed","utf8");function en(d){return ce([fp],d)}function uo(d,e,t){return ce([_s,e.toBuffer(),t.toBuffer()],d)}function ya(d,e,t){return ce([Vs,e.toBuffer(),t.toBuffer()],d)}function co(d){return ce([Buffer.from("__event_authority","utf8")],d)}function ba(d,e){return ce([bp,e.toBuffer()],d)}function Oi(d,e,t){return ce([yp,e.toBuffer(),t.toBuffer()],d)}function Vn(d,e,t){return ce([e.toBuffer(),t.toBuffer()],d)}function ga(d){return ce([gp],d)}function En(d,e,t){return ce([e.toBuffer(),t.toBuffer()],d)}function Pa(d){return ce([Pp],d)}import{ASSOCIATED_TOKEN_PROGRAM_ID as vr,TOKEN_2022_PROGRAM_ID as wp,TOKEN_PROGRAM_ID as Aa}from"@solana/spl-token";import{SystemProgram as Xt,TransactionInstruction as Ot}from"@solana/web3.js";import Oo from"bn.js";var In=F([A(),A("epoch"),V("curveType"),St("index"),A("migrateFee"),A("tradeFeeRate"),A("maxShareFeeRate"),A("minSupplyA"),A("maxLockRate"),A("minSellRateA"),A("minMigrateRateA"),A("minFundRaisingB"),M("mintB"),M("protocolFeeOwner"),M("migrateFeeOwner"),M("migrateToAmmWallet"),M("migrateToCpmmWallet"),Y(A(),16)]),Ap=F([A("totalLockedAmount"),A("cliffPeriod"),A("unlockPeriod"),A("startTime"),A("totalAllocatedShare")]),Gt=F([A(),A("epoch"),V("bump"),V("status"),V("mintDecimalsA"),V("mintDecimalsB"),V("migrateType"),A("supply"),A("totalSellA"),A("virtualA"),A("virtualB"),A("realA"),A("realB"),A("totalFundRaisingB"),A("protocolFee"),A("platformFee"),A("migrateFee"),Ap.replicate("vestingSchedule"),M("configId"),M("platformId"),M("mintA"),M("mintB"),M("vaultA"),M("vaultB"),M("creator"),V("mintProgramFlag"),V("cpmmCreatorFeeOn"),Y(V(),62)]),FK=F([A(),A("epoch"),M("poolId"),M("beneficiary"),A("claimedAmount"),A("tokenShareAmount"),Y(A(),8)]),$c=F([V("migrateType"),V("migrateCpmmFeeOn"),A("supply"),A("totalSellA"),A("totalFundRaisingB"),A("totalLockedAmount"),A("cliffPeriod"),A("unlockPeriod")]),kp=F([A("epoch"),V("index"),M("configId"),$c.replicate("bondingCurveParam"),Y(A(),50)]),lo=F([A(),A("epoch"),M("platformClaimFeeWallet"),M("platformLockNftWallet"),A("platformScale"),A("creatorScale"),A("burnScale"),A("feeRate"),Y(V(),64,"name"),Y(V(),256,"web"),Y(V(),256,"img"),M("cpConfigId"),A("creatorFeeRate"),M("transferFeeExtensionAuth"),Y(V(),180),xu(kp,"platformCurve")]);var Nt={initialize:Buffer.from([175,175,109,31,13,152,155,237]),initializeV2:Buffer.from([67,153,175,39,218,16,38,32]),buyExactIn:Buffer.from([250,234,13,123,213,156,19,236]),buyExactOut:Buffer.from([24,211,116,40,105,3,153,56]),sellExactIn:Buffer.from([149,39,222,155,211,124,152,26]),sellExactOut:Buffer.from([95,200,71,34,8,9,11,166]),createVestingAccount:Buffer.from([129,178,2,13,217,172,230,218]),claimVestedToken:Buffer.from([49,33,104,30,189,157,79,35]),createPlatformConfig:Buffer.from([176,90,196,175,253,113,220,20]),claimPlatformFee:Buffer.from([156,39,208,135,76,237,61,72]),updatePlaformConfig:Buffer.from([195,60,76,129,146,45,67,143]),initializeWithToken2022:Buffer.from([37,190,126,222,44,154,171,17]),claimPlatformFeeFromVault:Buffer.from([117,241,198,168,248,218,80,29]),claimCreatorFee:Buffer.from([26,97,138,203,132,171,141,252]),updatePlatformCurveParam:Buffer.from([138,144,138,250,220,128,4,57]),removePlatformCurveParam:Buffer.from([27,30,62,169,93,224,24,145])};function Zc(d,e,t,n,o,r,i,s,u,a,c,l,m,p,f,y,b,g,P,T,h){let w=F([V("decimals"),Tt("name"),Tt("symbol"),Tt("uri")]),k=F([A("totalLockedAmount"),A("cliffPeriod"),A("unlockPeriod"),V("cpmmCreatorFeeOn")]),x=F([V("index"),A("supply"),A("totalFundRaisingB"),V("migrateType")]),B=F([V("index"),A("supply"),A("totalSellA"),A("totalFundRaisingB"),V("migrateType")]),K=[{pubkey:e,isSigner:!0,isWritable:!0},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!1,isWritable:!1},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!0,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!1},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:Aa,isSigner:!1,isWritable:!1},{pubkey:Aa,isSigner:!1,isWritable:!1},{pubkey:jt,isSigner:!1,isWritable:!1},{pubkey:Xt.programId,isSigner:!1,isWritable:!1},{pubkey:it,isSigner:!1,isWritable:!1},{pubkey:co(d).publicKey,isSigner:!1,isWritable:!1},{pubkey:d,isSigner:!1,isWritable:!1}],I=Buffer.alloc(Buffer.from(p,"utf-8").length+Buffer.from(f,"utf-8").length+Buffer.from(y,"utf-8").length+4*3+1),R=Buffer.alloc(k.span),C=Buffer.alloc(b.type==="ConstantCurve"?B.span:x.span);return w.encode({decimals:m,name:p,symbol:f,uri:y},I),b.type==="ConstantCurve"?B.encode(D(v({index:0},b),{migrateType:b.migrateType==="amm"?0:1}),C):b.type==="FixedCurve"?x.encode(D(v({index:1},b),{migrateType:b.migrateType==="amm"?0:1}),C):b.type==="LinearCurve"&&x.encode(D(v({index:2},b),{migrateType:b.migrateType==="amm"?0:1}),C),k.encode({totalLockedAmount:g,cliffPeriod:P,unlockPeriod:T,cpmmCreatorFeeOn:h},R),new Ot({keys:K,programId:d,data:Buffer.from([...Nt.initializeV2,...I,...C,...R])})}function Jc(d,e,t,n,o,r,i,s,u,a,c,l,m,p,f,y,b,g,P,T,h){let w=F([V("decimals"),Tt("name"),Tt("symbol"),Tt("uri")]),k=F([A("totalLockedAmount"),A("cliffPeriod"),A("unlockPeriod"),V("cpmmCreatorFeeOn"),V("transferFeeExtensionParamsOption"),F([St("transferFeeBasePoints"),A("maxinumFee")]).replicate("transferFeeExtensionParams")]),x=F([V("index"),A("supply"),A("totalFundRaisingB"),V("migrateType")]),B=F([V("index"),A("supply"),A("totalSellA"),A("totalFundRaisingB"),V("migrateType")]),K=[{pubkey:e,isSigner:!0,isWritable:!0},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!1,isWritable:!1},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!0,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!1},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:wp,isSigner:!1,isWritable:!1},{pubkey:Aa,isSigner:!1,isWritable:!1},{pubkey:Xt.programId,isSigner:!1,isWritable:!1},{pubkey:co(d).publicKey,isSigner:!1,isWritable:!1},{pubkey:d,isSigner:!1,isWritable:!1}],I=Buffer.alloc(Buffer.from(m,"utf-8").length+Buffer.from(p,"utf-8").length+Buffer.from(f,"utf-8").length+4*3+1),R=Buffer.alloc(k.span),C=Buffer.alloc(y.type==="ConstantCurve"?B.span:x.span);return w.encode({decimals:l,name:m,symbol:p,uri:f},I),y.type==="ConstantCurve"?B.encode(D(v({index:0},y),{migrateType:y.migrateType==="amm"?0:1}),C):y.type==="FixedCurve"?x.encode(D(v({index:1},y),{migrateType:y.migrateType==="amm"?0:1}),C):y.type==="LinearCurve"&&x.encode(D(v({index:2},y),{migrateType:y.migrateType==="amm"?0:1}),C),k.encode({totalLockedAmount:b,cliffPeriod:g,unlockPeriod:P,cpmmCreatorFeeOn:T,transferFeeExtensionParamsOption:h?1:0,transferFeeExtensionParams:h!=null?h:{transferFeeBasePoints:0,maxinumFee:new Oo(0)}},R),new Ot({keys:K,programId:d,data:Buffer.from([...Nt.initializeWithToken2022,...I,...C,...R])})}function ka(d,e,t,n,o,r,i,s,u,a,c,l,m,p,f,y,b,g,P,T){let h=F([A("amountB"),A("minAmountA"),A("shareFeeRate")]),w=[{pubkey:e,isSigner:!0,isWritable:!0},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!1},{pubkey:l,isSigner:!1,isWritable:!1},{pubkey:m,isSigner:!1,isWritable:!1},{pubkey:p,isSigner:!1,isWritable:!1},{pubkey:co(d).publicKey,isSigner:!1,isWritable:!1},{pubkey:d,isSigner:!1,isWritable:!1}];T&&w.push({pubkey:T,isSigner:!1,isWritable:!0}),w.push({pubkey:Xt.programId,isSigner:!1,isWritable:!1}),w.push({pubkey:f,isSigner:!1,isWritable:!0}),w.push({pubkey:y,isSigner:!1,isWritable:!0});let k=Buffer.alloc(h.span);return h.encode({amountB:b,minAmountA:g,shareFeeRate:P!=null?P:new Oo(0)},k),new Ot({keys:w,programId:d,data:Buffer.from([...Nt.buyExactIn,...k])})}function el(d,e,t,n,o,r,i,s,u,a,c,l,m,p,f,y,b,g,P,T){let h=F([A("amountA"),A("maxAmountB"),A("shareFeeRate")]),w=[{pubkey:e,isSigner:!0,isWritable:!0},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!1},{pubkey:l,isSigner:!1,isWritable:!1},{pubkey:m,isSigner:!1,isWritable:!1},{pubkey:p,isSigner:!1,isWritable:!1},{pubkey:co(d).publicKey,isSigner:!1,isWritable:!1},{pubkey:d,isSigner:!1,isWritable:!1}];T&&w.push({pubkey:T,isSigner:!1,isWritable:!0}),w.push({pubkey:Xt.programId,isSigner:!1,isWritable:!1}),w.push({pubkey:f,isSigner:!1,isWritable:!0}),w.push({pubkey:y,isSigner:!1,isWritable:!0});let k=Buffer.alloc(h.span);return h.encode({amountA:b,maxAmountB:g,shareFeeRate:P!=null?P:new Oo(0)},k),new Ot({keys:w,programId:d,data:Buffer.from([...Nt.buyExactOut,...k])})}function tl(d,e,t,n,o,r,i,s,u,a,c,l,m,p,f,y,b,g,P,T){let h=F([A("amountA"),A("minAmountB"),A("shareFeeRate")]),w=[{pubkey:e,isSigner:!0,isWritable:!0},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!1},{pubkey:l,isSigner:!1,isWritable:!1},{pubkey:m,isSigner:!1,isWritable:!1},{pubkey:p,isSigner:!1,isWritable:!1},{pubkey:co(d).publicKey,isSigner:!1,isWritable:!1},{pubkey:d,isSigner:!1,isWritable:!1}];T&&w.push({pubkey:T,isSigner:!1,isWritable:!0}),w.push({pubkey:Xt.programId,isSigner:!1,isWritable:!1}),w.push({pubkey:f,isSigner:!1,isWritable:!0}),w.push({pubkey:y,isSigner:!1,isWritable:!0});let k=Buffer.alloc(h.span);return h.encode({amountA:b,minAmountB:g,shareFeeRate:P!=null?P:new Oo(0)},k),new Ot({keys:w,programId:d,data:Buffer.from([...Nt.sellExactIn,...k])})}function nl(d,e,t,n,o,r,i,s,u,a,c,l,m,p,f,y,b,g,P,T){let h=F([A("amountB"),A("maxAmountA"),A("shareFeeRate")]),w=[{pubkey:e,isSigner:!0,isWritable:!0},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!1},{pubkey:l,isSigner:!1,isWritable:!1},{pubkey:m,isSigner:!1,isWritable:!1},{pubkey:p,isSigner:!1,isWritable:!1},{pubkey:co(d).publicKey,isSigner:!1,isWritable:!1},{pubkey:d,isSigner:!1,isWritable:!1}];T&&w.push({pubkey:T,isSigner:!1,isWritable:!0}),w.push({pubkey:Xt.programId,isSigner:!1,isWritable:!1}),w.push({pubkey:f,isSigner:!1,isWritable:!0}),w.push({pubkey:y,isSigner:!1,isWritable:!0});let k=Buffer.alloc(h.span);return h.encode({amountB:b,maxAmountA:g,shareFeeRate:P!=null?P:new Oo(0)},k),new Ot({keys:w,programId:d,data:Buffer.from([...Nt.sellExactOut,...k])})}function wa(d,e,t,n,o,r,i,s,u){let a=F([]),c=[{pubkey:e,isSigner:!0,isWritable:!0},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!1},{pubkey:u,isSigner:!1,isWritable:!1},{pubkey:Xt.programId,isSigner:!1,isWritable:!1},{pubkey:vr,isSigner:!1,isWritable:!1}],l=Buffer.alloc(a.span);return a.encode({},l),new Ot({keys:c,programId:d,data:Buffer.from([...Nt.claimVestedToken,...l])})}function Ta(d,e,t,n,o,r){let i=F([A("shareAmount")]),s=[{pubkey:e,isSigner:!0,isWritable:!0},{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:Xt.programId,isSigner:!1,isWritable:!1}],u=Buffer.alloc(i.span);return i.encode({shareAmount:r},u),new Ot({keys:s,programId:d,data:Buffer.from([...Nt.createVestingAccount,...u])})}function ha(d,e,t,n,o,r,i,s,u){let a=[{pubkey:e,isSigner:!0,isWritable:!0},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:Xt.programId,isSigner:!1,isWritable:!0},{pubkey:vr,isSigner:!1,isWritable:!0}];return new Ot({keys:a,programId:d,data:Nt.claimPlatformFee})}function ol(d,e,t,n,o,r,i,s,u,a,c,l,m){let p=F([A("platformScale"),A("creatorScale"),A("burnScale"),A("feeRate"),Tt("name"),Tt("web"),Tt("img"),A("creatorFeeRate")]),f=[{pubkey:e,isSigner:!0,isWritable:!0},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:Xt.programId,isSigner:!1,isWritable:!1},{pubkey:i,isSigner:!1,isWritable:!1}],y=Buffer.alloc(8*5+Buffer.from(c,"utf-8").length+Buffer.from(l,"utf-8").length+Buffer.from(m,"utf-8").length+4*3);return p.encode({platformScale:s.platformScale,creatorScale:s.creatorScale,burnScale:s.burnScale,feeRate:u,name:c,web:l,img:m,creatorFeeRate:a},y),new Ot({keys:f,programId:d,data:Buffer.from([...Nt.createPlatformConfig,...y])})}function il(d,e,t,n){let o=[{pubkey:e,isSigner:!0,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!0}],r;if(n.type==="updateClaimFeeWallet"){let i=F([V("index"),M("value")]);r=Buffer.alloc(i.span),i.encode({index:0,value:n.value},r)}else if(n.type==="updateLockNftWallet"){let i=F([V("index"),M("value")]);r=Buffer.alloc(i.span),i.encode({index:1,value:n.value},r)}else if(n.type==="migrateCpLockNftScale"){let i=F([V("index"),A("platformScale"),A("creatorScale"),A("burnScale")]);r=Buffer.alloc(i.span),i.encode(v({index:2},n.value),r)}else if(n.type==="updateFeeRate"){let i=F([V("index"),A("value")]);r=Buffer.alloc(i.span),i.encode({index:3,value:n.value},r)}else if(n.type==="updateImg"||n.type==="updateName"||n.type==="updateWeb"){let i=F([V("index"),Tt("value")]);r=Buffer.alloc(Buffer.from(n.value,"utf-8").length+4+1*1),n.type==="updateName"?i.encode({index:4,value:n.value},r):n.type==="updateWeb"?i.encode({index:5,value:n.value},r):n.type==="updateImg"&&i.encode({index:6,value:n.value},r)}else if(n.type==="updateCpConfigId"){o.push({pubkey:n.value,isSigner:!1,isWritable:!1});let i=F([V("index")]);r=Buffer.alloc(i.span),i.encode({index:7},r)}else if(n.type==="updateAll"){o.push({pubkey:n.value.cpConfigId,isSigner:!1,isWritable:!1});let i=F([V("index"),M("platformClaimFeeWallet"),M("platformLockNftWallet"),A("platformScale"),A("creatorScale"),A("burnScale"),A("feeRate"),Tt("name"),Tt("web"),Tt("img"),M("transferFeeExtensionAuth"),A("creatorFeeRate")]);r=Buffer.alloc(1+32+32+8*4+4*3+Buffer.from(n.value.name,"utf-8").length+Buffer.from(n.value.web,"utf-8").length+Buffer.from(n.value.img,"utf-8").length+32+8),i.encode({index:8,platformClaimFeeWallet:n.value.platformClaimFeeWallet,platformLockNftWallet:n.value.platformLockNftWallet,platformScale:n.value.migrateCpLockNftScale.platformScale,creatorScale:n.value.migrateCpLockNftScale.creatorScale,burnScale:n.value.migrateCpLockNftScale.burnScale,feeRate:n.value.feeRate,name:n.value.name,web:n.value.web,img:n.value.img,transferFeeExtensionAuth:n.value.transferFeeExtensionAuth,creatorFeeRate:n.value.creatorFeeRate},r)}else throw Error("updateInfo params type error");return new Ot({keys:o,programId:d,data:Buffer.from([...Nt.updatePlaformConfig,...r])})}function Ia(d,e,t,n,o,r,i,s){let u=[{pubkey:t,isSigner:!0,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:e,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!1},{pubkey:s,isSigner:!1,isWritable:!1},{pubkey:Xt.programId,isSigner:!1,isWritable:!1},{pubkey:vr,isSigner:!1,isWritable:!1}];return new Ot({keys:u,programId:d,data:Nt.claimPlatformFeeFromVault})}function Ba(d,e,t,n,o,r,i){let s=[{pubkey:e,isSigner:!0,isWritable:!0},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!1},{pubkey:i,isSigner:!1,isWritable:!1},{pubkey:Xt.programId,isSigner:!1,isWritable:!1},{pubkey:vr,isSigner:!1,isWritable:!1}];return new Ot({keys:s,programId:d,data:Nt.claimCreatorFee})}var QK=new Oo("18446744073709551615");import{NATIVE_MINT as tn,TOKEN_2022_PROGRAM_ID as Yt,TOKEN_PROGRAM_ID as Te,createAssociatedTokenAccountIdempotentInstruction as at,createSyncNativeInstruction as al,getTransferFeeConfig as Fi,unpackMint as _i}from"@solana/spl-token";import re from"bn.js";import{PublicKey as cl,SystemProgram as ul}from"@solana/web3.js";import zt from"bn.js";import sl from"decimal.js";import Fr from"bn.js";import Ni from"decimal.js";var Wn=class{static getPoolInitPriceByPool({poolInfo:e,decimalA:t,decimalB:n}){throw Error()}static getPoolInitPriceByInit({a:e,b:t,decimalA:n,decimalB:o}){throw Error()}static getPoolPrice({poolInfo:e,decimalA:t,decimalB:n}){throw Error()}static getPoolEndPrice({supply:e,totalSell:t,totalLockedAmount:n,totalFundRaising:o,migrateFee:r,decimalA:i,decimalB:s}){throw Error()}static getPoolEndPriceReal({poolInfo:e,decimalA:t,decimalB:n}){throw Error()}static getInitParam({supply:e,totalFundRaising:t,totalSell:n,totalLockedAmount:o,migrateFee:r}){throw Error()}static buyExactIn({poolInfo:e,amount:t}){throw Error()}static buyExactOut({poolInfo:e,amount:t}){throw Error()}static sellExactIn({poolInfo:e,amount:t}){throw Error()}static sellExactOut({poolInfo:e,amount:t}){throw Error()}};var _r=class extends Wn{static getPoolInitPriceByPool({poolInfo:e,decimalA:t,decimalB:n}){return new Ni(e.virtualB.toString()).div(e.virtualA.toString()).mul(10**(t-n))}static getPoolInitPriceByInit({a:e,b:t,decimalA:n,decimalB:o}){return new Ni(t.toString()).div(e.toString()).mul(10**(n-o))}static getPoolPrice({poolInfo:e,decimalA:t,decimalB:n}){return new Ni(e.virtualB.add(e.realB).toString()).div(e.virtualA.sub(e.realA).toString()).mul(10**(t-n))}static getPoolEndPrice({supply:e,totalSell:t,totalLockedAmount:n,totalFundRaising:o,migrateFee:r,decimalA:i,decimalB:s}){return new Ni(o.sub(r).toString()).div(e.sub(t).sub(n).toString()).mul(10**(i-s))}static getPoolEndPriceReal({poolInfo:e,decimalA:t,decimalB:n}){let o=e.totalSellA.sub(e.realA),r=e.totalFundRaisingB.sub(e.realB);return new Ni(e.virtualB.add(e.realB.add(r)).toString()).div(e.virtualA.sub(e.realA.add(o)).toString()).mul(10**(t-n))}static getInitParam({supply:e,totalFundRaising:t,totalSell:n,totalLockedAmount:o,migrateFee:r}){if(e.lte(n))throw Error("supply need gt total sell");let i=e.sub(n).sub(o);if(i.lte(new Fr(0)))throw Error("supplyMinusSellLocked <= 0");let s=t.sub(r);if(s.lte(new Fr(0)))throw Error("tfMinusMf <= 0");let u=s.mul(n).mul(n).div(i),a=s.mul(n).div(i).sub(t),c=u.div(a),l=t.mul(t).div(a);if(c.lt(new Fr(0))||l.lt(new Fr(0)))throw Error("invalid input 0");return{a:c,b:l,c:n}}static buyExactIn({poolInfo:e,amount:t}){return this.getAmountOut({amountIn:t,inputReserve:e.virtualB.add(e.realB),outputReserve:e.virtualA.sub(e.realA)})}static buyExactOut({poolInfo:e,amount:t}){return this.getAmountIn({amountOut:t,inputReserve:e.virtualB.add(e.realB),outputReserve:e.virtualA.sub(e.realA)})}static sellExactIn({poolInfo:e,amount:t}){return this.getAmountOut({amountIn:t,inputReserve:e.virtualA.sub(e.realA),outputReserve:e.virtualB.add(e.realB)})}static sellExactOut({poolInfo:e,amount:t}){return this.getAmountIn({amountOut:t,inputReserve:e.virtualA.sub(e.realA),outputReserve:e.virtualB.add(e.realB)})}static getAmountOut({amountIn:e,inputReserve:t,outputReserve:n}){let o=e.mul(n),r=t.add(e);return o.div(r)}static getAmountIn({amountOut:e,inputReserve:t,outputReserve:n}){let o=t.mul(e),r=n.sub(e);return Xn(o,r)}};import Vr from"bn.js";import Mi from"decimal.js";var Er=class extends Wn{static getPoolInitPriceByPool({poolInfo:e,decimalA:t,decimalB:n}){return new Mi(e.virtualB.toString()).div(e.virtualA.toString()).mul(10**(t-n))}static getPoolInitPriceByInit({a:e,b:t,decimalA:n,decimalB:o}){return new Mi(t.toString()).div(e.toString()).mul(10**(n-o))}static getPoolPrice({poolInfo:e,decimalA:t,decimalB:n}){return new Mi(e.virtualB.toString()).div(e.virtualA.toString()).mul(10**(t-n))}static getPoolEndPrice({supply:e,totalSell:t,totalLockedAmount:n,totalFundRaising:o,migrateFee:r,decimalA:i,decimalB:s}){return new Mi(o.sub(r).toString()).div(e.sub(t).sub(n).toString()).mul(10**(i-s))}static getPoolEndPriceReal({poolInfo:e,decimalA:t,decimalB:n}){let o=e.totalSellA.sub(e.realA),r=e.totalFundRaisingB.sub(e.realB);return new Mi(e.virtualB.add(e.realB).add(r).toString()).div(e.virtualA.sub(e.realA).add(o).toString()).mul(10**(t-n))}static getInitParam({supply:e,totalFundRaising:t,totalSell:n,totalLockedAmount:o,migrateFee:r}){let i=e.sub(o);if(i.lte(new Vr(0)))throw Error("invalid input 1");let s=new Vr(2).mul(t).sub(r),a=t.mul(i).div(s);if(a.lt(new Vr(0))||t.lt(new Vr(0)))throw Error("invalid input 0");return{a,b:t,c:a}}static buyExactIn({poolInfo:e,amount:t}){return this.getAmountOut({amountIn:t,initInput:e.virtualB,initOutput:e.virtualA})}static buyExactOut({poolInfo:e,amount:t}){return this.getAmountIn({amountOut:t,initInput:e.virtualB,initOutput:e.virtualA})}static sellExactIn({poolInfo:e,amount:t}){return this.getAmountOut({amountIn:t,initInput:e.virtualA,initOutput:e.virtualB})}static sellExactOut({poolInfo:e,amount:t}){return this.getAmountIn({amountOut:t,initInput:e.virtualA,initOutput:e.virtualB})}static getAmountOut({amountIn:e,initInput:t,initOutput:n}){return n.mul(e).div(t)}static getAmountIn({amountOut:e,initInput:t,initOutput:n}){let o=t.mul(e);return Xn(o,n)}};import It from"bn.js";import mo from"decimal.js";import rl from"bn.js";import xa from"decimal.js";var vi=class{static _multipler(e){return new xa(10).pow(e)}static getPrice({priceX64:e,decimalA:t,decimalB:n}){return new xa(e.toString()).div(this._Q64).mul(this._multipler(t)).div(this._multipler(n))}static getPriceX64({price:e,decimalA:t,decimalB:n}){let o=e.mul(this._multipler(n)).div(this._multipler(t));return new rl(o.mul(this._Q64).toFixed(0))}};vi._Q64=new xa(new rl(1).shln(64).toString());var Wr=class extends Wn{static getPoolInitPriceByPool({poolInfo:e,decimalA:t,decimalB:n}){return new mo(0)}static getPoolInitPriceByInit({a:e,b:t,decimalA:n,decimalB:o}){return new mo(0)}static getPoolPrice({poolInfo:e,decimalA:t,decimalB:n}){return new mo(e.virtualA.mul(e.realA).toString()).div(vi._Q64).mul(10**(t-n))}static getPoolEndPrice({supply:e,totalSell:t,totalLockedAmount:n,totalFundRaising:o,migrateFee:r,decimalA:i,decimalB:s}){return new mo(o.sub(r).toString()).div(e.sub(t).sub(n).toString()).mul(10**(i-s))}static getPoolEndPriceReal({poolInfo:e,decimalA:t,decimalB:n}){let o=e.totalSellA.sub(e.realA),r=e.totalFundRaisingB.sub(e.realB);return new mo(e.virtualB.add(e.realB).add(r).toString()).div(e.virtualA.sub(e.realA).add(o).toString()).mul(10**(t-n))}static getInitParam({supply:e,totalFundRaising:t,totalSell:n,totalLockedAmount:o,migrateFee:r}){let i=e.sub(o);if(i.lte(new It(0)))throw Error("supplyMinusLocked need gt 0");let s=t.mul(new It(3)).sub(r),a=t.mul(new It(2)).mul(i).div(s),c=a.mul(a),l=t.mul(new It(2)).mul(Ze).div(c);if(!l.gt(new It(0)))throw Error("a need gt 0");if(!ii.gt(l))throw Error("a need lt u64 max");if(l.lt(new It(0))||a.lt(new It(0)))throw Error("invalid input 0");return{a:l,b:new It(0),c:a}}static buyExactIn({poolInfo:e,amount:t}){let n=e.realB.add(t),o=new It(2).mul(n).mul(Ze).div(e.virtualA);return new It(new mo(o.toString()).sqrt().toFixed(0)).sub(e.realA)}static buyExactOut({poolInfo:e,amount:t}){let n=e.realA.add(t),o=n.mul(n);return Xn(e.virtualA.mul(o),new It(2).mul(Ze)).sub(e.realB)}static sellExactIn({poolInfo:e,amount:t}){let n=e.realA.sub(t),o=n.mul(n),r=Xn(e.virtualA.mul(o),new It(2).mul(Ze));return e.realB.sub(r)}static sellExactOut({poolInfo:e,amount:t}){let n=e.realB.sub(t),o=new It(2).mul(n).mul(Ze).div(e.virtualA),r=new It(new mo(o.toString()).sqrt().toFixed(0));return e.realA.sub(r)}};var Mt=class{static getPoolCurvePointByPoolInfo({curveType:e,pointCount:t,poolInfo:n}){return this.getPoolCurvePointByInit({curveType:e,pointCount:t,supply:n.supply,totalFundRaising:n.totalFundRaisingB,totalSell:n.totalSellA,totalLockedAmount:n.vestingSchedule.totalLockedAmount,migrateFee:n.migrateFee,decimalA:n.mintDecimalsA,decimalB:n.mintDecimalsB})}static getPoolCurvePointByInit({curveType:e,pointCount:t,supply:n,totalFundRaising:o,totalSell:r,totalLockedAmount:i,migrateFee:s,decimalA:u,decimalB:a}){if(t<3)throw Error("point count < 3");let c=this.getCurve(e),l=c.getInitParam({supply:n,totalFundRaising:o,totalSell:r,totalLockedAmount:i,migrateFee:s}),m=c.getPoolInitPriceByInit(D(v({},l),{decimalA:u,decimalB:a})),p=o.div(new zt(t-1)),f=new zt(0),y=[{price:m,totalSellSupply:0}],{a:b,b:g}=l,P=f,T=f;for(let h=1;h<t;h++){let w=h!==t-1?p:o.sub(T),k=this.buyExactIn({poolInfo:{virtualA:b,virtualB:g,realA:P,realB:T,totalFundRaisingB:o,totalSellA:r},amountB:w,protocolFeeRate:f,platformFeeRate:f,curveType:e,shareFeeRate:f,creatorFeeRate:f,transferFeeConfigA:void 0,slot:0});P=P.add(k.amountA.amount),T=T.add(k.amountB);let x=this.getPrice({poolInfo:{virtualA:b,virtualB:g,realA:P,realB:T},decimalA:u,decimalB:a,curveType:e});y.push({price:x,totalSellSupply:new sl(P.toString()).div(10**u).toNumber()})}return y}static getPoolInitPriceByPool({poolInfo:e,decimalA:t,decimalB:n,curveType:o}){return this.getCurve(o).getPoolInitPriceByPool({poolInfo:e,decimalA:t,decimalB:n})}static getPoolInitPriceByInit({a:e,b:t,decimalA:n,decimalB:o,curveType:r}){return this.getCurve(r).getPoolInitPriceByInit({a:e,b:t,decimalA:n,decimalB:o})}static getPrice({poolInfo:e,curveType:t,decimalA:n,decimalB:o}){return this.getCurve(t).getPoolPrice({poolInfo:e,decimalA:n,decimalB:o})}static getEndPrice({poolInfo:e,curveType:t,decimalA:n,decimalB:o}){return this.getCurve(t).getPoolPrice({poolInfo:e,decimalA:n,decimalB:o})}static getPoolEndPriceReal({poolInfo:e,curveType:t,decimalA:n,decimalB:o}){return this.getCurve(t).getPoolEndPriceReal({poolInfo:e,decimalA:n,decimalB:o})}static checkParam({supply:e,totalFundRaising:t,totalSell:n,totalLockedAmount:o,decimals:r,config:i,migrateType:s}){if(Number(r)!==6)throw Error("decimals = 6");if(e.mul(i.maxLockRate).div(wt).lt(o))throw Error("total lock amount gte max lock amount");if(e.lt(i.minSupplyA.mul(new zt(10**r))))throw Error("supply lt min supply");let a=e.mul(i.minSellRateA).div(wt);if(n.lt(a))throw Error("invalid input");if(t.lt(i.minFundRaisingB))throw Error("total fund raising lt min fund raising");let c=e.sub(n).sub(o),l=e.mul(i.minMigrateRateA).div(wt);if(c.lt(l))throw Error("migrate lt min migrate amoount");let m=e.sub(n).sub(o),p=new zt(new sl(m.mul(t).toString()).sqrt().toFixed(0));if(s==="amm"){let f=new zt(10).pow(new zt(r));if(p.lte(f))throw Error("check migrate lp error")}else if(s==="cpmm"){let f=new zt(100);if(p.lte(f))throw Error("check migrate lp error")}else throw Error("migrate type error")}static buyExactIn({poolInfo:e,amountB:t,protocolFeeRate:n,platformFeeRate:o,curveType:r,shareFeeRate:i,creatorFeeRate:s,transferFeeConfigA:u,slot:a}){let c=this.totalFeeRate({protocolFeeRate:n,platformFeeRate:o,shareFeeRate:i,creatorFeeRate:s}),l=this.calculateFee({amount:t,feeRate:c}),m=t.sub(l),p=this.getCurve(r),f=p.buyExactIn({poolInfo:e,amount:m}),y=e.totalSellA.sub(e.realA),b,g,P;if(f.gt(y)){b=y;let h=p.buyExactOut({poolInfo:e,amount:b});g=this.calculatePreFee({postFeeAmount:h,feeRate:c}),P=g.sub(h)}else b=f,g=t,P=l;let T=this.splitFee({totalFee:P,protocolFeeRate:n,platformFeeRate:o,shareFeeRate:i,creatorFeeRate:s});return{amountA:rs(b,u,a),amountB:g,splitFee:T}}static buyExactOut({poolInfo:e,amountA:t,protocolFeeRate:n,platformFeeRate:o,curveType:r,shareFeeRate:i,creatorFeeRate:s,transferFeeConfigA:u,slot:a}){let c=e.totalSellA.sub(e.realA),l=ss(t,u,a),m=l.fee?l.amount.add(l.fee):l.amount;t.gt(c)&&(m=c);let f=this.getCurve(r).buyExactOut({poolInfo:e,amount:m}),y=this.totalFeeRate({protocolFeeRate:n,platformFeeRate:o,shareFeeRate:i,creatorFeeRate:s}),b=this.calculatePreFee({postFeeAmount:f,feeRate:y}),g=b.sub(f),P=this.splitFee({totalFee:g,protocolFeeRate:n,platformFeeRate:o,shareFeeRate:i,creatorFeeRate:s});return{amountA:l,amountB:b,splitFee:P}}static sellExactIn({poolInfo:e,amountA:t,protocolFeeRate:n,platformFeeRate:o,curveType:r,shareFeeRate:i,creatorFeeRate:s,transferFeeConfigA:u,slot:a}){let c=this.getCurve(r),l=rs(t,u,a),m=l.fee?l.amount.sub(l.fee):l.amount,p=c.sellExactIn({poolInfo:e,amount:m}),f=this.calculateFee({amount:p,feeRate:this.totalFeeRate({protocolFeeRate:n,platformFeeRate:o,shareFeeRate:i,creatorFeeRate:s})}),y=this.splitFee({totalFee:f,protocolFeeRate:n,platformFeeRate:o,shareFeeRate:i,creatorFeeRate:s});return{amountA:l,amountB:p.sub(f),splitFee:y}}static sellExactOut({poolInfo:e,amountB:t,protocolFeeRate:n,platformFeeRate:o,curveType:r,shareFeeRate:i,creatorFeeRate:s,transferFeeConfigA:u,slot:a}){let c=this.totalFeeRate({protocolFeeRate:n,platformFeeRate:o,shareFeeRate:i,creatorFeeRate:s}),l=this.calculatePreFee({postFeeAmount:t,feeRate:c});if(e.realB.lt(l))throw Error("Insufficient liquidity");let m=l.sub(t),f=Mt.getCurve(r).sellExactOut({poolInfo:e,amount:l});if(f.gt(e.realA))throw Error();let y=this.splitFee({totalFee:m,protocolFeeRate:n,platformFeeRate:o,shareFeeRate:i,creatorFeeRate:s});return{amountA:ss(f,u,a),amountB:t,splitFee:y}}static splitFee({totalFee:e,protocolFeeRate:t,platformFeeRate:n,shareFeeRate:o,creatorFeeRate:r}){let i=this.totalFeeRate({protocolFeeRate:t,platformFeeRate:n,shareFeeRate:o,creatorFeeRate:r}),s=i.isZero()?new zt(0):e.mul(n).div(i),u=i.isZero()?new zt(0):e.mul(o).div(i),a=i.isZero()?new zt(0):e.mul(r).div(i),c=e.sub(s).sub(u).sub(a);return{platformFee:s,shareFee:u,protocolFee:c,creatorFee:a}}static calculateFee({amount:e,feeRate:t}){return Vo(e,t,wt)}static calculatePreFee({postFeeAmount:e,feeRate:t}){if(t.isZero())return e;let n=e.mul(wt),o=wt.sub(t);return n.add(o).sub(new zt(1)).div(o)}static totalFeeRate({protocolFeeRate:e,platformFeeRate:t,shareFeeRate:n,creatorFeeRate:o}){if(e.add(t).add(n).add(o).gt(new zt(1e6)))throw Error("total fee rate gt 1_000_000");return e.add(t).add(n).add(o)}static getCurve(e){switch(e){case 0:return _r;case 1:return Er;case 2:return Wr}throw Error("find curve error")}};import ut from"decimal.js";var po={initPriceX64:new re("515752397214619"),supply:new re(1e15),totalSellA:new re(7931e11),totalFundRaisingB:new re(85e9),totalLockedAmount:new re("0"),cliffPeriod:new re("0"),unlockPeriod:new re("0"),decimals:6,virtualA:new re("1073471847374405"),virtualB:new re("30050573465"),realA:new re(0),realB:new re(0),protocolFee:new re(0),platformId:new cl("4Bu96XjU84XjPDSpveTVf6LYGCkfW5FK7SNkREWcEfV4"),vestingSchedule:{totalLockedAmount:new re(0),cliffPeriod:new re(0),unlockPeriod:new re(0),startTime:new re(0),totalAllocatedShare:new re(0)}},cn=new re(1e4),Vi=class extends _e{constructor(e){super(e)}async sayHello(){console.log("hello")}async createLaunchpad(N){var L=N,{programId:e=$e,authProgramId:t,platformId:n=po.platformId,mintA:o,decimals:r=6,mintBDecimals:i=9,name:s,symbol:u,uri:a,migrateType:c,configId:l,snipers:m,configInfo:p,platformFeeRate:f,txVersion:y,computeBudgetConfig:b,txTipConfig:g,feePayer:P,buyAmount:T,minMintAAmount:h,slippage:w,associatedOnly:k=!0,checkCreateATAOwner:x=!1,extraSigners:B,token2022:K,transferFeeExtensionParams:I,creatorFeeOn:R=0}=L,C=ve(L,["programId","authProgramId","platformId","mintA","decimals","mintBDecimals","name","symbol","uri","migrateType","configId","snipers","configInfo","platformFeeRate","txVersion","computeBudgetConfig","txTipConfig","feePayer","buyAmount","minMintAAmount","slippage","associatedOnly","checkCreateATAOwner","extraSigners","token2022","transferFeeExtensionParams","creatorFeeOn"]);var Bt,Wi,Ca,Ra,La,Oa,Na,Ma,va,Fa;let O=[],_=this.createTxBuilder(P);t=t!=null?t:en(e).publicKey,K=!!I,K&&(c="cpmm");let G=p;if(!G&&l){let Qt=await this.scope.connection.getAccountInfo(l);Qt&&(G=In.decode(Qt.data))}G||this.logAndCreateError("config not found");let z=G.mintB,H=G.curveType,{publicKey:me}=uo(e,o,z),{publicKey:ne}=ya(e,me,o),{publicKey:ae}=ya(e,me,z),{publicKey:fe}=gn(o);console.log(`create token: ${o.toBase58()}, mintB: ${z.toBase58()}, decimals A:${r}/B:${i}, config:${l.toBase58()}`),u.length>10&&this.logAndCreateError("Symbol length should shorter than 11"),a||this.logAndCreateError("uri should not empty");let de=(Bt=C==null?void 0:C.supply)!=null?Bt:po.supply,ee=(Wi=C==null?void 0:C.totalSellA)!=null?Wi:po.totalSellA,he=(Ca=C==null?void 0:C.totalFundRaisingB)!=null?Ca:po.totalFundRaisingB,J=(Ra=C==null?void 0:C.totalLockedAmount)!=null?Ra:new re(0),Me=f;if(!f){let Qt=await this.scope.connection.getAccountInfo(n);Qt||this.logAndCreateError("platform id not found:",n.toString()),Me=lo.decode(Qt.data).feeRate}let nn=Mt.getCurve(G.curveType).getInitParam({supply:de,totalFundRaising:he,totalSell:ee,totalLockedAmount:J,migrateFee:G.migrateFee}),Le={epoch:new re(896),bump:254,status:0,mintDecimalsA:r,mintDecimalsB:i,supply:de,totalSellA:ee,mintA:new cl(o),mintB:z,virtualA:nn.a,virtualB:nn.b,realA:po.realA,realB:po.realB,migrateFee:G.migrateFee,migrateType:c==="amm"?0:1,protocolFee:po.protocolFee,platformFee:Me,platformId:n,configId:l,vaultA:ne,vaultB:ae,creator:this.scope.ownerPubKey,totalFundRaisingB:he,vestingSchedule:{totalLockedAmount:J,cliffPeriod:new re(0),unlockPeriod:new re(0),startTime:new re(0),totalAllocatedShare:new re(0)},mintProgramFlag:K?1:0,cpmmCreatorFeeOn:R},No=Mt.getCurve(G.curveType),{c:qr}=No.getInitParam({supply:Le.supply,totalFundRaising:Le.totalFundRaisingB,totalLockedAmount:J,totalSell:G.curveType===0?Le.totalSellA:new re(0),migrateFee:G.migrateFee});try{Mt.checkParam({supply:Le.supply,totalFundRaising:Le.totalFundRaisingB,totalSell:qr,totalLockedAmount:J,decimals:Le.mintDecimalsA,config:G,migrateType:c}),this.logDebug("check init params success")}catch(Qt){this.logAndCreateError(`check create mint params failed, ${Qt.message}`)}_.addInstruction({instructions:[K?Jc(e,P!=null?P:this.scope.ownerPubKey,this.scope.ownerPubKey,l,n,t,me,o,z,ne,ae,r,s,u,a||"https://",{type:H===0?"ConstantCurve":H===1?"FixedCurve":H===2?"LinearCurve":"ConstantCurve",totalSellA:ee,migrateType:c,supply:de,totalFundRaisingB:he},J,(La=C==null?void 0:C.cliffPeriod)!=null?La:new re(0),(Oa=C==null?void 0:C.unlockPeriod)!=null?Oa:new re(0),R,I):Zc(e,P!=null?P:this.scope.ownerPubKey,this.scope.ownerPubKey,l,n,t,me,o,z,ne,ae,fe,r,s,u,a||"https://",{type:H===0?"ConstantCurve":H===1?"FixedCurve":H===2?"LinearCurve":"ConstantCurve",totalSellA:ee,migrateType:c,supply:de,totalFundRaisingB:he},J,(Na=C==null?void 0:C.cliffPeriod)!=null?Na:new re(0),(Ma=C==null?void 0:C.unlockPeriod)!=null?Ma:new re(0),R)]});let Mo=K?await this.scope.connection.getEpochInfo():void 0,vt=I?{epoch:BigInt((Mo==null?void 0:Mo.epoch)||0),maximumFee:BigInt((va=I==null?void 0:I.maxinumFee.toString())!=null?va:0),transferFeeBasisPoints:(Fa=I==null?void 0:I.transferFeeBasePoints)!=null?Fa:0}:void 0,yo={amountA:{amount:new re(0),fee:void 0,expirationTime:void 0},amountB:new re(0),splitFee:{platformFee:new re(0),shareFee:new re(0),protocolFee:new re(0),creatorFee:new re(0)}},bo;if(B!=null&&B.length&&_.addInstruction({signers:B}),!C.createOnly){let{builder:Qt,extInfo:ll}=await this.buyToken({programId:e,authProgramId:t,mintAProgram:K?Yt:void 0,mintA:o,mintB:z,poolInfo:Le,buyAmount:T,minMintAAmount:h,shareFeeRate:C.shareFeeRate,shareFeeReceiver:C.shareFeeReceiver,configInfo:G,platformFeeRate:Me,slippage:w,associatedOnly:k,checkCreateATAOwner:x,skipCheckMintA:!vt,transferFeeConfigA:vt?{transferFeeConfigAuthority:t,withdrawWithheldAuthority:t,withheldAmount:BigInt(0),olderTransferFee:vt,newerTransferFee:vt}:void 0,fromCreate:!0});console.log("FEE: ",vt),console.log("PREPARING SNIPER TRANSACTIONS");for(let _a of m){let{builder:ml,extInfo:Bp}=await this.buyToken({programId:e,authProgramId:t,mintAProgram:K?Yt:void 0,mintA:o,mintB:z,poolInfo:Le,buyAmount:_a.amount,minMintAAmount:h,shareFeeRate:C.shareFeeRate,shareFeeReceiver:C.shareFeeReceiver,configInfo:G,platformFeeRate:Me,slippage:w,sniper:_a,associatedOnly:k,checkCreateATAOwner:x,skipCheckMintA:!vt,transferFeeConfigA:vt?{transferFeeConfigAuthority:t,withdrawWithheldAuthority:t,withheldAmount:BigInt(0),olderTransferFee:vt,newerTransferFee:vt}:void 0,fromCreate:!1});O.push(D(v({},ml.AllTxData),{blockHash:this.scope.blockhashCommitment}))}_.addInstruction(v({},Qt.AllTxData)),yo=v({},ll),bo=(this.scope.cluster==="devnet"||y===1)&&C.shareFeeReceiver?[Qt.allInstructions[0]]:void 0}return y===0?(console.log("VERSION V0"),{tx:await _.sizeCheckBuildV0({computeBudgetConfig:b,swapInfo:yo,splitIns:bo,address:D(v({},Le),{poolId:me})}),txs:O}):(console.log("VERSION PLAIN"),{tx:await _.sizeCheckBuild({computeBudgetConfig:b,swapInfo:yo,splitIns:bo,address:D(v({},Le),{poolId:me})}),txs:O})}async buyTokenOriginal({programId:e=$e,authProgramId:t,mintA:n,mintAProgram:o=Te,mintB:r=tn,poolInfo:i,configInfo:s,platformFeeRate:u,txVersion:a,computeBudgetConfig:c,txTipConfig:l,feePayer:m,buyAmount:p,minMintAAmount:f,slippage:y,sniper:b,shareFeeRate:g=new re(0),shareFeeReceiver:P,associatedOnly:T=!0,checkCreateATAOwner:h=!1,fromCreate:w=!1,transferFeeConfigA:k,skipCheckMintA:x=!1}){var de,ee,he;p.lte(new re(0))&&this.logAndCreateError("buy amount should gt 0:",p.toString());let B=b?this.createSniperTxBuilder(b.owner,b.owner.publicKey):this.createTxBuilder(m),{publicKey:K}=uo(e,n,r);t=t!=null?t:en(e).publicKey;let I=k;if(!x)if(console.log("!skipCheckMintA: ",x),I)console.log("TOKEN_2022_PROGRAM_ID: ",Yt),o=Yt;else{console.log("!transferFeeConfigA: ",I);let J=await this.scope.connection.getAccountInfo(n);if(J&&J.owner.equals(Yt)){console.log("TOKEN_2022_PROGRAM_ID: ",x),o=J.owner;let Me=_i(n,J,o);I=Fi(Me)||void 0}}let R=this.scope.account.getAssociatedTokenAccount(n,o),C=w?this.scope.account.getAssociatedTokenAccount(r,Te):null,N=r.equals(tn);if(B.addInstruction({instructions:[at(this.scope.ownerPubKey,R,this.scope.ownerPubKey,n,o),...w?[at(this.scope.ownerPubKey,C,this.scope.ownerPubKey,r,Te),ul.transfer({fromPubkey:this.scope.ownerPubKey,toPubkey:C,lamports:BigInt(p.toString())}),al(C)]:[]]}),!w){let{account:J,instructionParams:Me}=await this.scope.account.getOrCreateTokenAccount({mint:r,owner:this.scope.ownerPubKey,createInfo:N?{payer:this.scope.ownerPubKey,amount:p}:void 0,skipCloseAccount:!N,notUseTokenAccount:N,associatedOnly:N?!1:T,checkCreateATAOwner:h});J&&(C=J),B.addInstruction(Me||{})}C===void 0&&this.logAndCreateError(`cannot found mintB(${r.toBase58()}) token accounts`,"tokenAccounts",this.scope.account.tokenAccounts);let L=i;if(!L){let J=await this.scope.connection.getAccountInfo(K,{commitment:"processed"});J||this.logAndCreateError("cannot found pool:",K.toBase58()),L=Gt.decode(J.data)}let O=s,_=await Oe(this.scope.connection,[O?void 0:L.configId,L.platformId].filter(Boolean).map(J=>({pubkey:J})));if(!O){let J=_.find(Me=>Me.pubkey.equals(L.configId));(!J||!J.accountInfo)&&this.logAndCreateError("config not found: ",L.configId.toBase58()),O=In.decode(J.accountInfo.data)}let G=_.find(J=>J.pubkey.equals(L.platformId));(!G||!G.accountInfo)&&this.logAndCreateError("platform info not found: ",L.configId.toBase58());let z=lo.decode(G.accountInfo.data);u=u||z.feeRate;let H=Mt.buyExactIn({poolInfo:L,amountB:p,protocolFeeRate:O.tradeFeeRate,platformFeeRate:u,curveType:O.curveType,shareFeeRate:g,creatorFeeRate:z.creatorFeeRate,transferFeeConfigA:I,slot:await this.scope.connection.getSlot()}),me=new ut(H.amountA.amount.toString()).sub((ee=(de=H.amountA.fee)==null?void 0:de.toString())!=null?ee:0),ne=y?new ut(cn.sub(y).toNumber()/cn.toNumber()).clampedTo(0,1):new ut(1),ae=f!=null?f:y?new re(me.mul(ne).toFixed(0)):H.amountA.amount.sub((he=H.amountA.fee)!=null?he:new re(0));H.amountB.lt(p)&&console.log(`maximum ${n.toBase58()} amount can buy is ${H.amountA.toString()}, input ${r.toBase58()} amount: ${H.amountB.toString()}`);let fe=P?Z(P,r,Te).publicKey:void 0;return fe&&B.addInstruction({instructions:[at(this.scope.ownerPubKey,fe,P,r)]}),B.addInstruction({instructions:[ka(e,this.scope.ownerPubKey,t,L.configId,L.platformId,K,R,C,L.vaultA,L.vaultB,n,r,o,Te,Vn(e,L.platformId,r).publicKey,En(e,L.creator,r).publicKey,H.amountB.lt(p)?H.amountB:p,ae,g,fe)]}),B.addCustomComputeBudget(c),B.addTipInstruction(l),B.versionBuild({txVersion:a,extInfo:D(v({},H),{decimalOutAmount:me,minDecimalOutAmount:new ut(ae.toString())})})}async buyToken({programId:e=$e,authProgramId:t,mintA:n,mintAProgram:o=Te,mintB:r=tn,poolInfo:i,configInfo:s,platformFeeRate:u,txVersion:a,computeBudgetConfig:c,txTipConfig:l,feePayer:m,buyAmount:p,minMintAAmount:f,slippage:y,shareFeeRate:b=new re(0),shareFeeReceiver:g,sniper:P,associatedOnly:T=!0,checkCreateATAOwner:h=!1,fromCreate:w=!1,transferFeeConfigA:k,skipCheckMintA:x=!1}){var de,ee,he;p.lte(new re(0))&&this.logAndCreateError("buy amount should gt 0:",p.toString());let B=P?this.createSniperTxBuilder(P.owner,P.owner.publicKey):this.createTxBuilder(m),{publicKey:K}=uo(e,n,r);t=t!=null?t:en(e).publicKey;let I=k;if(!x)if(console.log("!skipCheckMintA: ",x),I)console.log("mintAProgram: ",Yt),o=Yt;else{console.log("!transferFeeConfigA: ",I);let J=await this.scope.connection.getAccountInfo(n);if(J&&J.owner.equals(Yt)){console.log("!mintInfo: ",J),o=J.owner;let Me=_i(n,J,o);I=Fi(Me)||void 0}}let R=P?this.scope.account.getAssociatedTokenAccountByOwner(P.owner.publicKey,n,o):this.scope.account.getAssociatedTokenAccount(n,o),C=w?P?this.scope.account.getAssociatedTokenAccountByOwner(P.owner.publicKey,r,Te):this.scope.account.getAssociatedTokenAccount(r,Te):null,N=r.equals(tn);if(console.log("userTokenAccountA: ",R),console.log("userTokenAccountB: ",C),B.addInstruction({instructions:[at((P==null?void 0:P.owner.publicKey)||this.scope.ownerPubKey,R,(P==null?void 0:P.owner.publicKey)||this.scope.ownerPubKey,n,o),...w?[at((P==null?void 0:P.owner.publicKey)||this.scope.ownerPubKey,C,(P==null?void 0:P.owner.publicKey)||this.scope.ownerPubKey,r,Te),ul.transfer({fromPubkey:(P==null?void 0:P.owner.publicKey)||this.scope.ownerPubKey,toPubkey:C,lamports:BigInt(p.toString())}),al(C)]:[]]}),!w){let{account:J,instructionParams:Me}=await this.scope.account.getOrCreateTokenAccount({mint:r,owner:this.scope.ownerPubKey,createInfo:N?{payer:this.scope.ownerPubKey,amount:p}:void 0,skipCloseAccount:!N,notUseTokenAccount:N,associatedOnly:N?!1:T,checkCreateATAOwner:h});J&&(C=J),B.addInstruction(Me||{})}C===void 0&&this.logAndCreateError(`cannot found mintB(${r.toBase58()}) token accounts`,"tokenAccounts",this.scope.account.tokenAccounts);let L=i;if(!L){let J=await this.scope.connection.getAccountInfo(K,{commitment:"processed"});J||this.logAndCreateError("cannot found pool:",K.toBase58()),L=Gt.decode(J.data)}let O=s,_=await Oe(this.scope.connection,[O?void 0:L.configId,L.platformId].filter(Boolean).map(J=>({pubkey:J})));if(!O){let J=_.find(Me=>Me.pubkey.equals(L.configId));(!J||!J.accountInfo)&&this.logAndCreateError("config not found: ",L.configId.toBase58()),O=In.decode(J.accountInfo.data)}let G=_.find(J=>J.pubkey.equals(L.platformId));(!G||!G.accountInfo)&&this.logAndCreateError("platform info not found: ",L.configId.toBase58());let z=lo.decode(G.accountInfo.data);u=u||z.feeRate;let H=Mt.buyExactIn({poolInfo:L,amountB:p,protocolFeeRate:O.tradeFeeRate,platformFeeRate:u,curveType:O.curveType,shareFeeRate:b,creatorFeeRate:z.creatorFeeRate,transferFeeConfigA:I,slot:await this.scope.connection.getSlot()}),me=new ut(H.amountA.amount.toString()).sub((ee=(de=H.amountA.fee)==null?void 0:de.toString())!=null?ee:0),ne=y?new ut(cn.sub(y).toNumber()/cn.toNumber()).clampedTo(0,1):new ut(1),ae=f!=null?f:y?new re(me.mul(ne).toFixed(0)):H.amountA.amount.sub((he=H.amountA.fee)!=null?he:new re(0));H.amountB.lt(p)&&console.log(`maximum ${n.toBase58()} amount can buy is ${H.amountA.toString()}, input ${r.toBase58()} amount: ${H.amountB.toString()}`);let fe=g?Z(g,r,Te).publicKey:void 0;return fe&&B.addInstruction({instructions:[at((P==null?void 0:P.owner.publicKey)||this.scope.ownerPubKey,fe,g,r)]}),B.addInstruction({instructions:[ka(e,(P==null?void 0:P.owner.publicKey)||this.scope.ownerPubKey,t,L.configId,L.platformId,K,R,C,L.vaultA,L.vaultB,n,r,o,Te,Vn(e,L.platformId,r).publicKey,En(e,L.creator,r).publicKey,H.amountB.lt(p)?H.amountB:p,ae,b,fe)]}),B.addCustomComputeBudget(c),B.addTipInstruction(l),B.versionBuild({txVersion:a,extInfo:D(v({},H),{decimalOutAmount:me,minDecimalOutAmount:new ut(ae.toString())})})}async buyTokenExactOut({programId:e=$e,authProgramId:t,mintA:n,mintAProgram:o=Te,mintB:r=tn,poolInfo:i,configInfo:s,transferFeeConfigA:u,platformFeeRate:a,txVersion:c,computeBudgetConfig:l,txTipConfig:m,feePayer:p,maxBuyAmount:f,outAmount:y,slippage:b,shareFeeRate:g=new re(0),shareFeeReceiver:P,associatedOnly:T=!0,checkCreateATAOwner:h=!1,skipCheckMintA:w=!1}){y.lte(new re(0))&&this.logAndCreateError("out amount should gt 0:",y.toString());let k=this.createTxBuilder(p),{publicKey:x}=uo(e,n,r);t=t!=null?t:en(e).publicKey;let B=i;if(!B){let de=await this.scope.connection.getAccountInfo(x,{commitment:"processed"});de||this.logAndCreateError("cannot found pool:",x.toBase58()),B=Gt.decode(de.data)}let K=s,I=await Oe(this.scope.connection,[K?void 0:B.configId,B.platformId].filter(Boolean).map(de=>({pubkey:de})));if(!K){let de=I.find(ee=>ee.pubkey.equals(B.configId));(!de||!de.accountInfo)&&this.logAndCreateError("config not found: ",B.configId.toBase58()),K=In.decode(de.accountInfo.data)}let R=I.find(de=>de.pubkey.equals(B.platformId));(!R||!R.accountInfo)&&this.logAndCreateError("platform info not found: ",B.configId.toBase58());let C=lo.decode(R.accountInfo.data);a=a||C.feeRate;let N=u;if(!w)if(N)o=Yt;else{let de=await this.scope.connection.getAccountInfo(n);if(de&&de.owner.equals(Yt)){o=de.owner;let ee=_i(n,de,o);N=Fi(ee)||void 0}}let L=Mt.buyExactOut({poolInfo:B,amountA:y,protocolFeeRate:K.tradeFeeRate,platformFeeRate:a,curveType:K.curveType,shareFeeRate:g,creatorFeeRate:C.creatorFeeRate,transferFeeConfigA:N,slot:await this.scope.connection.getSlot()}),O=new ut(L.amountB.toString()),_=b?new ut(cn.add(b).toNumber()/cn.toNumber()).clampedTo(0,Number.MIN_SAFE_INTEGER):new ut(1),G=(f!=null?f:b)?new re(O.mul(_).toFixed(0)):L.amountB,z=this.scope.account.getAssociatedTokenAccount(n,o),H=null,me=r.equals(tn);k.addInstruction({instructions:[at(this.scope.ownerPubKey,z,this.scope.ownerPubKey,n,o)]});let{account:ne,instructionParams:ae}=await this.scope.account.getOrCreateTokenAccount({mint:r,owner:this.scope.ownerPubKey,createInfo:me?{payer:this.scope.ownerPubKey,amount:L.amountB}:void 0,skipCloseAccount:!me,notUseTokenAccount:me,associatedOnly:me?!1:T,checkCreateATAOwner:h});ne&&(H=ne),k.addInstruction(ae||{}),H===void 0&&this.logAndCreateError(`cannot found mintB(${r.toBase58()}) token accounts`,"tokenAccounts",this.scope.account.tokenAccounts);let fe=P?Z(P,r,Te).publicKey:void 0;return fe&&k.addInstruction({instructions:[at(this.scope.ownerPubKey,fe,P,r)]}),k.addInstruction({instructions:[el(e,this.scope.ownerPubKey,t,B.configId,B.platformId,x,z,H,B.vaultA,B.vaultB,n,r,o,Te,Vn(e,B.platformId,r).publicKey,En(e,B.creator,r).publicKey,y,G,g,fe)]}),k.addCustomComputeBudget(l),k.addTipInstruction(m),k.versionBuild({txVersion:c,extInfo:{maxSpentAmount:G,outAmount:y}})}async sellToken({programId:e=$e,authProgramId:t,mintAProgram:n=Te,mintA:o,mintB:r=tn,poolInfo:i,configInfo:s,platformFeeRate:u,txVersion:a,computeBudgetConfig:c,txTipConfig:l,feePayer:m,sellAmount:p,minAmountB:f,slippage:y,shareFeeRate:b=new re(0),shareFeeReceiver:g,associatedOnly:P=!0,checkCreateATAOwner:T=!1,skipCheckMintA:h=!1}){t=t!=null?t:en(e).publicKey;let w=this.createTxBuilder(m);p.lte(new re(0))&&this.logAndCreateError("sell amount should be gt 0");let{publicKey:k}=uo(e,o,r),x;if(!h){let ee=await this.scope.connection.getAccountInfo(o);if(ee&&ee.owner.equals(Yt)){n=ee.owner;let he=_i(o,ee,n);x=Fi(he)||void 0}}let B=null,K=null,I=r.equals(tn),{account:R,instructionParams:C}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:n,mint:o,owner:this.scope.ownerPubKey,createInfo:void 0,skipCloseAccount:!0,notUseTokenAccount:!1,associatedOnly:P,checkCreateATAOwner:T});R&&(B=R),w.addInstruction(C||{}),B===void 0&&this.logAndCreateError("cannot found mintA token accounts","tokenAccounts",this.scope.account.tokenAccounts);let{account:N,instructionParams:L}=await this.scope.account.getOrCreateTokenAccount({mint:r,owner:this.scope.ownerPubKey,createInfo:I?{payer:this.scope.ownerPubKey,amount:0}:void 0,skipCloseAccount:!I,notUseTokenAccount:I,associatedOnly:I?!1:P,checkCreateATAOwner:T});N&&(K=N),w.addInstruction(L||{}),K===void 0&&this.logAndCreateError("cannot found mintB token accounts","tokenAccounts",this.scope.account.tokenAccounts);let O=i;if(!O){let ee=await this.scope.connection.getAccountInfo(k,{commitment:"processed"});ee||this.logAndCreateError("cannot found pool",k.toBase58()),O=Gt.decode(ee.data)}let _=s,G=await Oe(this.scope.connection,[_?void 0:O.configId,O.platformId].filter(Boolean).map(ee=>({pubkey:ee})));if(!_){let ee=G.find(he=>he.pubkey.equals(O.configId));(!ee||!ee.accountInfo)&&this.logAndCreateError("config not found: ",O.configId.toBase58()),_=In.decode(ee.accountInfo.data)}let z=G.find(ee=>ee.pubkey.equals(O.platformId));(!z||!z.accountInfo)&&this.logAndCreateError("platform info not found: ",O.configId.toBase58());let H=lo.decode(z.accountInfo.data);u=u||H.feeRate;let me=Mt.sellExactIn({poolInfo:O,amountA:p,protocolFeeRate:_.tradeFeeRate,platformFeeRate:u,curveType:_.curveType,shareFeeRate:b,creatorFeeRate:H.creatorFeeRate,transferFeeConfigA:x,slot:await this.scope.connection.getSlot()}),ne=new ut(me.amountB.toString()),ae=y?new ut(cn.sub(y).toNumber()/cn.toNumber()).clampedTo(0,1):new ut(1),fe=f!=null?f:y?new re(ne.mul(ae).toFixed(0)):me.amountB;fe.lte(new re(0))&&this.logAndCreateError(`out ${r.toBase58()} amount should be gt 0`);let de=g?Z(g,r,Te).publicKey:void 0;return de&&w.addInstruction({instructions:[at(this.scope.ownerPubKey,de,g,r)]}),w.addInstruction({instructions:[tl(e,this.scope.ownerPubKey,t,O.configId,O.platformId,k,B,K,O.vaultA,O.vaultB,o,r,n,Te,Vn(e,O.platformId,r).publicKey,En(e,O.creator,r).publicKey,me.amountA.amount.lt(p)?me.amountA.amount:p,fe,b,de)]}),w.addCustomComputeBudget(c),w.addTipInstruction(l),w.versionBuild({txVersion:a,extInfo:{outAmount:fe}})}async sellTokenExactOut({programId:e=$e,authProgramId:t,mintAProgram:n=Te,mintA:o,mintB:r=tn,poolInfo:i,configInfo:s,platformFeeRate:u,txVersion:a,computeBudgetConfig:c,txTipConfig:l,feePayer:m,inAmount:p,maxSellAmount:f,slippage:y,shareFeeRate:b=new re(0),shareFeeReceiver:g,associatedOnly:P=!0,checkCreateATAOwner:T=!1,skipCheckMintA:h=!1}){t=t!=null?t:en(e).publicKey;let w=this.createTxBuilder(m);f!=null&&f.lte(new re(0))&&this.logAndCreateError("max sell amount should be gt 0");let{publicKey:k}=uo(e,o,r),x;if(!h){let ee=await this.scope.connection.getAccountInfo(o);if(ee&&ee.owner.equals(Yt)){n=ee.owner;let he=_i(o,ee,n);x=Fi(he)||void 0}}let B=null,K=null,I=r.equals(tn),{account:R,instructionParams:C}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:n,mint:o,owner:this.scope.ownerPubKey,createInfo:void 0,skipCloseAccount:!0,notUseTokenAccount:!1,associatedOnly:P,checkCreateATAOwner:T});R&&(B=R),w.addInstruction(C||{}),B===void 0&&this.logAndCreateError("cannot found mintA token accounts","tokenAccounts",this.scope.account.tokenAccounts);let{account:N,instructionParams:L}=await this.scope.account.getOrCreateTokenAccount({mint:r,owner:this.scope.ownerPubKey,createInfo:I?{payer:this.scope.ownerPubKey,amount:0}:void 0,skipCloseAccount:!I,notUseTokenAccount:I,associatedOnly:I?!1:P,checkCreateATAOwner:T});N&&(K=N),w.addInstruction(L||{}),K===void 0&&this.logAndCreateError("cannot found mintB token accounts","tokenAccounts",this.scope.account.tokenAccounts);let O=i;if(!O){let ee=await this.scope.connection.getAccountInfo(k,{commitment:"processed"});ee||this.logAndCreateError("cannot found pool",k.toBase58()),O=Gt.decode(ee.data)}let _=s,G=await Oe(this.scope.connection,[_?void 0:O.configId,O.platformId].filter(Boolean).map(ee=>({pubkey:ee})));if(!_){let ee=G.find(he=>he.pubkey.equals(O.configId));(!ee||!ee.accountInfo)&&this.logAndCreateError("config not found: ",O.configId.toBase58()),_=In.decode(ee.accountInfo.data)}let z=G.find(ee=>ee.pubkey.equals(O.platformId));(!z||!z.accountInfo)&&this.logAndCreateError("platform info not found: ",O.configId.toBase58());let H=lo.decode(z.accountInfo.data);u=u||H.feeRate;let me=Mt.sellExactOut({poolInfo:O,amountB:p,protocolFeeRate:_.tradeFeeRate,platformFeeRate:u,curveType:_.curveType,shareFeeRate:b,creatorFeeRate:H.creatorFeeRate,transferFeeConfigA:x,slot:await this.scope.connection.getSlot()}),ne=new ut(me.amountA.amount.toString()),ae=y?new ut(cn.add(y).toNumber()/cn.toNumber()).clampedTo(0,Number.MAX_SAFE_INTEGER):new ut(1),fe=(f!=null?f:y)?new re(ne.mul(ae).toFixed(0)):me.amountA.amount,de=g?Z(g,r,Te).publicKey:void 0;return de&&w.addInstruction({instructions:[at(this.scope.ownerPubKey,de,g,r)]}),w.addInstruction({instructions:[nl(e,this.scope.ownerPubKey,t,O.configId,O.platformId,k,B,K,O.vaultA,O.vaultB,o,r,n,Te,Vn(e,O.platformId,r).publicKey,En(e,O.creator,r).publicKey,p,fe,b,de)]}),w.addCustomComputeBudget(c),w.addTipInstruction(l),w.versionBuild({txVersion:a,extInfo:{maxSellAmount:fe}})}async createPlatformConfig({programId:e=$e,platformAdmin:t,platformClaimFeeWallet:n,platformLockNftWallet:o,cpConfigId:r,migrateCpLockNftScale:i,transferFeeExtensionAuth:s,creatorFeeRate:u,feeRate:a,name:c,web:l,img:m,txVersion:p,computeBudgetConfig:f,txTipConfig:y,feePayer:b}){let g=this.createTxBuilder(b),{publicKey:P}=ba(e,t);return g.addInstruction({instructions:[ol(e,t,n,o,P,r,s,i,a,u,c,l,m)]}),g.addCustomComputeBudget(f),g.addTipInstruction(y),g.versionBuild({txVersion:p,extInfo:{platformId:P}})}async updatePlatformConfig({programId:e=$e,platformAdmin:t,platformId:n,updateInfo:o,txVersion:r,computeBudgetConfig:i,txTipConfig:s,feePayer:u}){let a=this.createTxBuilder(u),c=n!=null?n:ba(e,t).publicKey;return a.addInstruction({instructions:[il(e,t,c,o)]}),a.addCustomComputeBudget(i),a.addTipInstruction(s),a.versionBuild({txVersion:r})}async claimPlatformFee({programId:e=$e,authProgramId:t,platformId:n,poolId:o,platformClaimFeeWallet:r,mintB:i,vaultB:s,mintBProgram:u=Te,txVersion:a,computeBudgetConfig:c,txTipConfig:l,feePayer:m}){var g;let p=this.createTxBuilder(m);t=t!=null?t:en(e).publicKey;let f=i,y=s;if(!f){let P=await this.scope.connection.getAccountInfo(o,{commitment:"processed"});P||this.logAndCreateError("cannot found pool:",o.toBase58());let T=Gt.decode(P.data),h=await this.scope.connection.getAccountInfo(T.configId,{commitment:"processed"});h||this.logAndCreateError("cannot found config:",T.configId.toBase58()),f=In.decode(h.data).mintB,y=y!=null?y:T.vaultB}(!f||!y)&&this.logAndCreateError("cannot found mint info, mintB: ",f.toBase58(),", vaultB: ",(g=y==null?void 0:y.toBase58())!=null?g:"");let b=Z(this.scope.ownerPubKey,f,Te).publicKey;return p.addInstruction({instructions:[at(this.scope.ownerPubKey,b,this.scope.ownerPubKey,f)]}),p.addInstruction({instructions:[ha(e,r,t,o,n,y,b,f,u)]}),p.addCustomComputeBudget(c),p.addTipInstruction(l),p.versionBuild({txVersion:a})}async claimAllPlatformFee({programId:e=$e,authProgramId:t,platformId:n,platformClaimFeeWallet:o,txVersion:r,computeBudgetConfig:i,txTipConfig:s,feePayer:u}){let a=this.createTxBuilder(u);return t=t!=null?t:en(e).publicKey,(await this.scope.connection.getProgramAccounts(e,{filters:[{dataSize:Gt.span},{memcmp:{offset:Gt.offsetOf("platformId"),bytes:n.toString()}}]})).forEach(l=>{let m=Gt.decode(l.account.data);if(m.platformFee.lte(new re(0)))return;let p=Z(this.scope.ownerPubKey,m.mintB,Te).publicKey;a.addInstruction({instructions:[at(this.scope.ownerPubKey,p,this.scope.ownerPubKey,m.mintB)]}),a.addInstruction({instructions:[ha(e,o,t,l.pubkey,n,m.vaultB,p,m.mintB,Te)]})}),a.addTipInstruction(s),r===0?a.sizeCheckBuildV0({computeBudgetConfig:i}):a.sizeCheckBuild({computeBudgetConfig:i})}async createVesting({programId:e=$e,poolId:t,beneficiary:n,shareAmount:o,txVersion:r,computeBudgetConfig:i,txTipConfig:s,feePayer:u}){let a=this.createTxBuilder(u),c=await this.getRpcPoolInfo({poolId:t});o.add(c.vestingSchedule.totalAllocatedShare).gt(c.vestingSchedule.totalLockedAmount)&&this.logAndCreateError("share amount exceed total locked amount");let l=Oi(e,t,n).publicKey;return a.addInstruction({instructions:[Ta(e,this.scope.ownerPubKey,n,t,l,o)]}),a.addCustomComputeBudget(i),a.addTipInstruction(s),a.versionBuild({txVersion:r})}async createMultipleVesting({programId:e=$e,poolId:t,beneficiaryList:n,txVersion:o,computeBudgetConfig:r,feePayer:i}){let s=this.createTxBuilder(i);n.length===0&&this.logAndCreateError("beneficiaryList is null");let u=await this.getRpcPoolInfo({poolId:t});return n.reduce((c,l)=>c.add(l.shareAmount),u.vestingSchedule.totalAllocatedShare).gt(u.vestingSchedule.totalLockedAmount)&&this.logAndCreateError("share amount exceed total locked amount"),n.forEach(c=>{let l=Oi(e,t,c.wallet).publicKey;s.addInstruction({instructions:[Ta(e,this.scope.ownerPubKey,c.wallet,t,l,c.shareAmount)]})}),o===0?s.sizeCheckBuildV0({computeBudgetConfig:r}):s.sizeCheckBuild({computeBudgetConfig:r})}async claimVesting({programId:e=$e,poolId:t,poolInfo:n,vestingRecord:o,txVersion:r,computeBudgetConfig:i,txTipConfig:s,feePayer:u}){let a=this.createTxBuilder(u),c=en(e).publicKey,l=o||Oi(e,t,this.scope.ownerPubKey).publicKey,m=n;if(!m){let f=await this.scope.connection.getAccountInfo(t);f||this.logAndCreateError("pool not found"),m=Gt.decode(f.data)}let p=Z(this.scope.ownerPubKey,m.mintA,Te).publicKey;return a.addInstruction({instructions:[at(this.scope.ownerPubKey,p,this.scope.ownerPubKey,m.mintA)]}),a.addInstruction({instructions:[wa(e,this.scope.ownerPubKey,c,t,l,p,m.vaultA,m.mintA,Te)]}),a.addCustomComputeBudget(i),a.addTipInstruction(s),a.versionBuild({txVersion:r})}async claimMultiVesting({programId:e=$e,poolIdList:t,poolsInfo:n={},vestingRecords:o={},txVersion:r,computeBudgetConfig:i,feePayer:s}){let u=this.createTxBuilder(s),a=v({},n),c=en(e).publicKey,l=t.filter(m=>!a[m.toBase58()]);if(l.length){let m=await this.getRpcPoolsInfo({poolIdList:l});a=v(v({},a),m.poolInfoMap)}return t.forEach(m=>{let p=m.toBase58(),f=a[p];f||this.logAndCreateError(`pool info not found: ${p}`);let y=o[p]||Oi(e,m,this.scope.ownerPubKey).publicKey,b=Z(this.scope.ownerPubKey,f.mintA,Te).publicKey;u.addInstruction({instructions:[at(this.scope.ownerPubKey,b,this.scope.ownerPubKey,f.mintA)]}),u.addInstruction({instructions:[wa(e,this.scope.ownerPubKey,c,m,y,b,f.vaultA,f.mintA,Te)]})}),r===0?u.sizeCheckBuildV0({computeBudgetConfig:i}):u.sizeCheckBuild({computeBudgetConfig:i})}async claimVaultPlatformFee({programId:e=$e,platformId:t,mintB:n,mintBProgram:o=Te,claimFeeWallet:r,txVersion:i,computeBudgetConfig:s,txTipConfig:u,feePayer:a}){let c=this.createTxBuilder(a),l=Vn(e,t,n).publicKey,m=ga(e).publicKey,p=this.scope.account.getAssociatedTokenAccount(n,o);return c.addInstruction({instructions:[at(this.scope.ownerPubKey,p,this.scope.ownerPubKey,n,o),Ia(e,t,r!=null?r:this.scope.ownerPubKey,m,l,p,n,o)]}),c.addCustomComputeBudget(s),c.addTipInstruction(u),c.versionBuild({txVersion:i})}async claimMultipleVaultPlatformFee({programId:e=$e,platformList:t,unwrapSol:n=!0,txVersion:o,computeBudgetConfig:r,feePayer:i,associatedOnly:s=!0,checkCreateATAOwner:u=!1}){let a=this.createTxBuilder(i),c={};return t.forEach(async l=>{var b,g;let m=ga(e).publicKey,p=Vn(e,l.id,l.mintB).publicKey,f=l.mintB.equals(tn)&&n,y=c[l.mintB.toBase58()];if(!y){let{account:P,instructionParams:T}=await this.scope.account.getOrCreateTokenAccount({mint:l.mintB,owner:this.scope.ownerPubKey,createInfo:f?{payer:this.scope.ownerPubKey,amount:0}:void 0,skipCloseAccount:!f,notUseTokenAccount:f,associatedOnly:f?!1:s,checkCreateATAOwner:u});P&&(y=P),a.addInstruction(T||{}),y===void 0&&this.logAndCreateError(`cannot found platform ${l.id.toBase58()} mintB(${l.mintB.toBase58()}) token accounts`,"tokenAccounts",this.scope.account.tokenAccounts)}a.addInstruction({instructions:[Ia(e,l.id,(b=l.claimFeeWallet)!=null?b:this.scope.ownerPubKey,p,m,y,l.mintB,(g=l.mintBProgram)!=null?g:Te)]})}),o===0?a.sizeCheckBuildV0({computeBudgetConfig:r}):a.sizeCheckBuild({computeBudgetConfig:r})}async claimCreatorFee({programId:e=$e,mintB:t,mintBProgram:n=Te,txVersion:o,computeBudgetConfig:r,txTipConfig:i,feePayer:s}){let u=this.createTxBuilder(s),a=En(e,this.scope.ownerPubKey,t).publicKey,c=Pa(e).publicKey,l=this.scope.account.getAssociatedTokenAccount(t,n);return u.addInstruction({instructions:[at(this.scope.ownerPubKey,l,this.scope.ownerPubKey,t,n),Ba(e,this.scope.ownerPubKey,c,a,l,t,n)]}),u.addCustomComputeBudget(r),u.addTipInstruction(i),u.versionBuild({txVersion:o})}async claimMultipleCreatorFee({programId:e=$e,mintBList:t,txVersion:n,computeBudgetConfig:o,feePayer:r}){let i=this.createTxBuilder(r);return t.forEach(s=>{var p;let u=s.pubKey,a=(p=s.programId)!=null?p:Te,c=En(e,this.scope.ownerPubKey,u).publicKey,l=Pa(e).publicKey,m=this.scope.account.getAssociatedTokenAccount(u,a);i.addInstruction({instructions:[at(this.scope.ownerPubKey,m,this.scope.ownerPubKey,u,a),Ba(e,this.scope.ownerPubKey,l,c,m,u,a)]})}),n==0?i.sizeCheckBuildV0({computeBudgetConfig:o}):i.sizeCheckBuild({computeBudgetConfig:o})}async getRpcPoolInfo({poolId:e}){return(await this.getRpcPoolsInfo({poolIdList:[e]})).poolInfoMap[e.toBase58()]}async getRpcPoolsInfo({poolIdList:e,config:t}){let n=await Oe(this.scope.connection,e.map(u=>({pubkey:u})),t),o={},r=[];for(let u=0;u<e.length;u++){let a=n[u];if(a===null||!a.accountInfo)throw Error("fetch pool info error: "+e[u].toBase58());let c=Gt.decode(a.accountInfo.data);o[e[u].toBase58()]=D(v({},c),{poolId:a.accountInfo.owner}),r.push(c.configId)}let i=await Oe(this.scope.connection,r.map(u=>({pubkey:u})),t),s={};for(let u=0;u<r.length;u++){let a=i[u];if(a===null||!a.accountInfo)throw Error("fetch config info error: "+r[u].toBase58());let c=In.decode(a.accountInfo.data);s[r[u].toBase58()]=D(v({},c),{configId:a.accountInfo.owner})}return{poolInfoMap:Object.keys(o).reduce((u,a)=>D(v({},u),{[a]:D(v({},o[a]),{configInfo:s[o[a].configId.toBase58()]})}),{})}}};import{PublicKey as Tp}from"@solana/web3.js";import{MintLayout as hp,TOKEN_2022_PROGRAM_ID as Sa,TOKEN_PROGRAM_ID as Ka}from"@solana/spl-token";var Ei=class extends _e{constructor(t){super(t);this._tokenList=[];this._tokenMap=new Map;this._blackTokenMap=new Set;this._mintGroup={official:new Set,jup:new Set,extra:new Set};this._whiteMap=new Set;this._extraTokenList=[]}async load(t){this.checkDisabled();let{forceUpdate:n=!1,type:o="strict"}=t||{},{mintList:r,blacklist:i,whiteList:s}=await this.scope.fetchV3TokenList(n),u=await this.scope.fetchJupTokenList(n);this._tokenList=[],this._tokenMap=new Map,this._blackTokenMap=new Set(i),this._mintGroup={official:new Set,jup:new Set,extra:new Set},this._whiteMap=new Set(s),this._tokenMap.set(Bn.address,Bn),this._mintGroup.official.add(Bn.address),r.forEach(a=>{var c;this._blackTokenMap.has(a.address)||(this._tokenMap.set(a.address,D(v({},a),{type:"raydium",priority:2,programId:(c=a.programId)!=null?c:a.tags.includes("token-2022")?Sa.toBase58():Ka.toBase58()})),this._mintGroup.official.add(a.address))}),u.forEach(a=>{var c;this._blackTokenMap.has(a.address)||this._tokenMap.has(a.address)||(this._tokenMap.set(a.address,D(v({},a),{type:"jupiter",priority:1,programId:(c=a.programId)!=null?c:a.tags.includes("token-2022")?Sa.toBase58():Ka.toBase58(),tags:a.freezeAuthority?[...a.tags||[],"hasFreeze"]:a.tags})),this._mintGroup.jup.add(a.address))}),this._extraTokenList.forEach(a=>{this._blackTokenMap.has(a.address)||this._tokenMap.has(a.address)||(this._tokenMap.set(a.address,D(v({},a),{type:"extra",priority:1,programId:a.programId||a.tags.includes("token-2022")?Sa.toBase58():Ka.toBase58()})),this._mintGroup.extra.add(a.address))}),this._tokenList=Array.from(this._tokenMap).map(a=>a[1])}get tokenList(){return this._tokenList}get tokenMap(){return this._tokenMap}get blackTokenMap(){return this._blackTokenMap}get mintGroup(){return this._mintGroup}get whiteListMap(){return this._whiteMap}async getTokenInfo(t){if(!t)throw new Error("please input mint");let n=t.toString(),o=this._tokenMap.get(n);if(o)return o;if(n.toLocaleUpperCase()==="SOL")return Bn;let r=(await this.scope.api.getTokenInfo([n]))[0];if(r)return this._mintGroup.extra.add(n),this._tokenMap.set(n,D(v({},r),{priority:2})),r;let i=await this.scope.connection.getAccountInfo(new Tp(n));if(!i)throw new Error(`mint address not found: ${n}`);let s=hp.decode(i.data),u=n.toString().substring(0,6),a={chainId:101,address:n,programId:i.owner.toBase58(),logoURI:"",symbol:u,name:u,decimals:s.decimals,tags:[],extensions:{},priority:0,type:"unknown"};return this._mintGroup.extra.add(n),this._tokenMap.set(n,a),a}};var Dr=class{constructor(e){this.rawBalances=new Map;let{connection:t,cluster:n,owner:o,api:r,defaultChainTime:i,defaultChainTimeOffset:s,apiCacheTime:u,blockhashCommitment:a="confirmed",loopMultiTxStatus:c}=e;this._connection=t,this.cluster=n||"mainnet",this._owner=o?new xt(o):void 0,this._signAllTransactions=e.signAllTransactions,this.blockhashCommitment=a,this.loopMultiTxStatus=c,this.api=r,this._apiCacheTime=u||5*60*1e3,this.logger=be("Raydium"),this.farm=new oi({scope:this,moduleName:"Raydium_Farm"}),this.account=new Ho({scope:this,moduleName:"Raydium_Account",tokenAccounts:e.tokenAccounts,tokenAccountRawInfos:e.tokenAccountRawInfos}),this.liquidity=new Pi({scope:this,moduleName:"Raydium_LiquidityV2"}),this.token=new Ei({scope:this,moduleName:"Raydium_tokenV2"}),this.tradeV2=new Ci({scope:this,moduleName:"Raydium_tradeV2"}),this.clmm=new ki({scope:this,moduleName:"Raydium_clmm"}),this.cpmm=new Si({scope:this,moduleName:"Raydium_cpmm"}),this.utils1216=new Ut({scope:this,moduleName:"Raydium_utils1216"}),this.marketV2=new So({scope:this,moduleName:"Raydium_marketV2"}),this.ido=new Lo({scope:this,moduleName:"Raydium_ido"}),this.launchpad=new Vi({scope:this,moduleName:"Raydium_lauchpad"}),this.availability={};let l=new Date().getTime();this.apiData={},s&&(this._chainTime={fetched:l,value:{chainTime:i||Date.now()-s,offset:s}})}static async load(e){var c;let t=Ip({cluster:"mainnet",owner:null,apiRequestInterval:3e5,apiRequestTimeout:1e4},e),{cluster:n,apiRequestTimeout:o,logCount:r,logRequests:i,urlConfigs:s}=t,u=new or({cluster:n,timeout:o,urlConfigs:s,logCount:r,logRequests:i}),a=new Dr(D(v({},t),{api:u}));return await a.fetchAvailabilityStatus((c=e.disableFeatureCheck)!=null?c:!0),e.disableLoadToken||await a.token.load({type:e.jupTokenType}),a}get owner(){return this._owner}get ownerPubKey(){if(!this._owner)throw new Error(ir);return this._owner.publicKey}setOwner(e){return this._owner=e?new xt(e):void 0,this.account.resetTokenAccounts(),this}get connection(){if(!this._connection)throw new Error(du);return this._connection}setConnection(e){return this._connection=e,this}get signAllTransactions(){return this._signAllTransactions}setSignAllTransactions(e){return this._signAllTransactions=e,this}checkOwner(){if(!this.owner)throw console.error(ir),new Error(ir)}isCacheInvalidate(e){return new Date().getTime()-e>this._apiCacheTime}async fetchChainTime(){try{let e=await this.api.getChainTimeOffset();this._chainTime={fetched:Date.now(),value:{chainTime:Date.now()+e.offset*1e3,offset:e.offset*1e3}}}catch{this._chainTime=void 0}}async fetchV3TokenList(e){if(this.apiData.tokenList&&!this.isCacheInvalidate(this.apiData.tokenList.fetched)&&!e)return this.apiData.tokenList.data;try{let t=await this.api.getTokenList(),n={fetched:Date.now(),data:t};return this.apiData.tokenList=n,n.data}catch(t){return console.error(t),{mintList:[],blacklist:[],whiteList:[]}}}async fetchJupTokenList(e){if(this.cluster==="devnet")return[];let t=this.apiData.jupTokenList;if(t&&!this.isCacheInvalidate(t.fetched)&&!e)return t.data;try{let n=await this.api.getJupTokenList();return this.apiData.jupTokenList={fetched:Date.now(),data:n.map(o=>D(v({},o),{mintAuthority:o.mint_authority||void 0,freezeAuthority:o.freeze_authority||void 0}))},this.apiData.jupTokenList.data}catch(n){return console.error(n),[]}}get chainTimeData(){var e;return(e=this._chainTime)==null?void 0:e.value}async chainTimeOffset(){var e;return this._chainTime&&Date.now()-this._chainTime.fetched<=1e3*60*5?this._chainTime.value.offset:(await this.fetchChainTime(),((e=this._chainTime)==null?void 0:e.value.offset)||0)}async currentBlockChainTime(){var e;return this._chainTime&&Date.now()-this._chainTime.fetched<=1e3*60*5?this._chainTime.value.chainTime:(await this.fetchChainTime(),((e=this._chainTime)==null?void 0:e.value.chainTime)||Date.now())}async fetchEpochInfo(){return this._epochInfo&&Date.now()-this._epochInfo.fetched<=1e3*30?this._epochInfo.value:(this._epochInfo={fetched:Date.now(),value:await this.connection.getEpochInfo()},this._epochInfo.value)}async fetchAvailabilityStatus(e){if(e)return{};try{let t=await this.api.fetchAvailabilityStatus(),n=t.all===!1;return this.availability={all:t.all,swap:n?!1:t.swap,createConcentratedPosition:n?!1:t.createConcentratedPosition,addConcentratedPosition:n?!1:t.addConcentratedPosition,addStandardPosition:n?!1:t.addStandardPosition,removeConcentratedPosition:n?!1:t.removeConcentratedPosition,removeStandardPosition:n?!1:t.removeStandardPosition,addFarm:n?!1:t.addFarm,removeFarm:n?!1:t.removeFarm},t}catch{return{}}}};export{Dr as Raydium};
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
//# sourceMappingURL=raydium.mjs.map