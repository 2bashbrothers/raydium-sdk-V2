var ol=Object.defineProperty,il=Object.defineProperties;var rl=Object.getOwnPropertyDescriptors;var Oi=Object.getOwnPropertySymbols;var Ra=Object.prototype.hasOwnProperty,La=Object.prototype.propertyIsEnumerable;var Ca=(m,e,t)=>e in m?ol(m,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):m[e]=t,v=(m,e)=>{for(var t in e||(e={}))Ra.call(e,t)&&Ca(m,t,e[t]);if(Oi)for(var t of Oi(e))La.call(e,t)&&Ca(m,t,e[t]);return m},W=(m,e)=>il(m,rl(e));var _e=(m,e)=>{var t={};for(var n in m)Ra.call(m,n)&&e.indexOf(n)<0&&(t[n]=m[n]);if(m!=null&&Oi)for(var n of Oi(m))e.indexOf(n)<0&&La.call(m,n)&&(t[n]=m[n]);return t};import{merge as dp}from"lodash";import ou from"axios";import{PublicKey as Ma}from"@solana/web3.js";import{get as Oa,set as sl}from"lodash";var Ur=class{constructor(e){this.logLevel=e.logLevel!==void 0?e.logLevel:0,this.name=e.name}set level(e){this.logLevel=e}get time(){return Date.now().toString()}get moduleName(){return this.name}isLogLevel(e){return e<=this.logLevel}error(...e){return this.isLogLevel(0)?(console.error(this.time,this.name,"sdk logger error",...e),this):this}logWithError(...e){let t=e.map(n=>typeof n=="object"?JSON.stringify(n):n).join(", ");throw new Error(t)}warning(...e){return this.isLogLevel(1)?(console.warn(this.time,this.name,"sdk logger warning",...e),this):this}info(...e){return this.isLogLevel(2)?(console.info(this.time,this.name,"sdk logger info",...e),this):this}debug(...e){return this.isLogLevel(3)?(console.debug(this.time,this.name,"sdk logger debug",...e),this):this}},Na={},al={};function ye(m){let e=Oa(Na,m);if(!e){let t=Oa(al,m);e=new Ur({name:m,logLevel:t}),sl(Na,m,e)}return e}import{MINT_SIZE as ul,TOKEN_PROGRAM_ID as cl,getTransferFeeConfig as ll,unpackMint as ml}from"@solana/spl-token";var Gr=ye("Raydium_accountInfo_util");async function Gt(m,e,t){let{batchRequest:n,commitment:o="confirmed",chunkCount:r=100}=v({batchRequest:!1},t),i=Xr(e,r),s=new Array(i.length).fill([]);if(n){let u=i.map(l=>{let d=m._buildArgs([l.map(p=>p.toBase58())],o,"base64");return{methodName:"getMultipleAccounts",args:d}}),a=Xr(u,10);s=(await(await Promise.all(a.map(async l=>await m._rpcBatchRequest(l)))).flat()).map(l=>(l.error&&Gr.logWithError(`failed to get info for multiple accounts, RPC_ERROR, ${l.error.message}`),l.result.value.map(d=>{if(d){let{data:p,executable:f,lamports:y,owner:b,rentEpoch:g}=d;return p.length!==2&&p[1]!=="base64"&&Gr.logWithError("info must be base64 encoded, RPC_ERROR"),{data:Buffer.from(p[0],"base64"),executable:f,lamports:y,owner:new Ma(b),rentEpoch:g}}return null})))}else try{s=await Promise.all(i.map(u=>m.getMultipleAccountsInfo(u,o)))}catch(u){u instanceof Error&&Gr.logWithError(`failed to get info for multiple accounts, RPC_ERROR, ${u.message}`)}return s.flat()}async function Ce(m,e,t){let n=await Gt(m,e.map(o=>o.pubkey),t);return e.map((o,r)=>W(v({},o),{accountInfo:n[r]}))}async function ao({connection:m,mints:e,config:t}){var r,i,s;if(e.length===0)return{};let n=await Ce(m,e.map(u=>({pubkey:ut(u)})),t),o={};for(let u of n){if(!u.accountInfo||u.accountInfo.data.length<ul){console.log("invalid mint account",u.pubkey.toBase58());continue}let a=ml(u.pubkey,u.accountInfo,(r=u.accountInfo)==null?void 0:r.owner);o[u.pubkey.toString()]=W(v({},a),{programId:((i=u.accountInfo)==null?void 0:i.owner)||cl,feeConfig:(s=ll(a))!=null?s:void 0})}return o[Ma.default.toBase58()]=o[Y.toBase58()],o}import tn from"bn.js";import Jf from"decimal.js";import Pl from"big.js";import vi from"bn.js";import dl from"toformat";var pl=dl,Ro=pl;import Mi from"big.js";import yl from"bn.js";import bl from"decimal.js-light";import Lo from"bn.js";var va=9007199254740991;function $(m){let e=ye("Raydium_parseBigNumberish");if(m instanceof Lo)return m;if(typeof m=="string"){if(m.match(/^-?[0-9]+$/))return new Lo(m);e.logWithError(`invalid BigNumberish string: ${m}`)}return typeof m=="number"?(m%1&&e.logWithError(`BigNumberish number underflow: ${m}`),(m>=va||m<=-va)&&e.logWithError(`BigNumberish number overflow: ${m}`),new Lo(String(m))):typeof m=="bigint"?new Lo(m.toString()):(e.error(`invalid BigNumberish value: ${m}`),new Lo(0))}var Ni=ye("module/fraction"),zr=Ro(Mi),Oo=Ro(bl),gl={[0]:Oo.ROUND_DOWN,[1]:Oo.ROUND_HALF_UP,[2]:Oo.ROUND_UP},Al={[0]:Mi.roundDown,[1]:Mi.roundHalfUp,[2]:Mi.roundUp},we=class{constructor(e,t=new yl(1)){this.numerator=$(e),this.denominator=$(t)}get quotient(){return this.numerator.div(this.denominator)}invert(){return new we(this.denominator,this.numerator)}add(e){let t=e instanceof we?e:new we($(e));return this.denominator.eq(t.denominator)?new we(this.numerator.add(t.numerator),this.denominator):new we(this.numerator.mul(t.denominator).add(t.numerator.mul(this.denominator)),this.denominator.mul(t.denominator))}sub(e){let t=e instanceof we?e:new we($(e));return this.denominator.eq(t.denominator)?new we(this.numerator.sub(t.numerator),this.denominator):new we(this.numerator.mul(t.denominator).sub(t.numerator.mul(this.denominator)),this.denominator.mul(t.denominator))}mul(e){let t=e instanceof we?e:new we($(e));return new we(this.numerator.mul(t.numerator),this.denominator.mul(t.denominator))}div(e){let t=e instanceof we?e:new we($(e));return new we(this.numerator.mul(t.denominator),this.denominator.mul(t.numerator))}toSignificant(e,t={groupSeparator:""},n=1){Number.isInteger(e)||Ni.logWithError(`${e} is not an integer.`),e<=0&&Ni.logWithError(`${e} is not positive.`),Oo.set({precision:e+1,rounding:gl[n]});let o=new Oo(this.numerator.toString()).div(this.denominator.toString()).toSignificantDigits(e);return o.toFormat(o.decimalPlaces(),t)}toFixed(e,t={groupSeparator:""},n=1){return Number.isInteger(e)||Ni.logWithError(`${e} is not an integer.`),e<0&&Ni.logWithError(`${e} is negative.`),zr.DP=e,zr.RM=Al[n]||1,new zr(this.numerator.toString()).div(this.denominator.toString()).toFormat(e,t)}isZero(){return this.numerator.isZero()}};var wl=ye("Raydium_amount"),_a=Ro(Pl);function kl(m,e){let t="0",n="0";if(m.includes(".")){let o=m.split(".");o.length===2?([t,n]=o,n=n.padEnd(e,"0")):wl.logWithError(`invalid number string, num: ${m}`)}else t=m;return[t,n.slice(0,e)||n]}var Ie=class extends we{constructor(t,n,o=!0,r){let i=new vi(0),s=Qr.pow(new vi(t.decimals));if(o)i=$(n);else{let u=new vi(0),a=new vi(0);if(typeof n=="string"||typeof n=="number"||typeof n=="bigint"){let[c,l]=kl(n.toString(),t.decimals);u=$(c),a=$(l)}u=u.mul(s),i=u.add(a)}super(i,s);this.logger=ye(r||"TokenAmount"),this.token=t}get raw(){return this.numerator}isZero(){return this.raw.isZero()}gt(t){return this.token.equals(t.token)||this.logger.logWithError("gt token not equals"),this.raw.gt(t.raw)}lt(t){return this.token.equals(t.token)||this.logger.logWithError("lt token not equals"),this.raw.lt(t.raw)}add(t){return this.token.equals(t.token)||this.logger.logWithError("add token not equals"),new Ie(this.token,this.raw.add(t.raw))}subtract(t){return this.token.equals(t.token)||this.logger.logWithError("sub token not equals"),new Ie(this.token,this.raw.sub(t.raw))}toSignificant(t=this.token.decimals,n,o=0){return super.toSignificant(t,n,o)}toFixed(t=this.token.decimals,n,o=0){return t>this.token.decimals&&this.logger.logWithError("decimals overflow"),super.toFixed(t,n,o)}toExact(t={groupSeparator:""}){return _a.DP=this.token.decimals,new _a(this.numerator.toString()).div(this.denominator.toString()).toFormat(t)}};import{PublicKey as hl}from"@solana/web3.js";import{TOKEN_PROGRAM_ID as Fa}from"@solana/spl-token";var wn={chainId:101,address:hl.default.toBase58(),programId:Fa.toBase58(),decimals:9,symbol:"SOL",name:"solana",logoURI:"https://img-v1.raydium.io/icon/So11111111111111111111111111111111111111112.png",tags:[],priority:2,type:"raydium",extensions:{coingeckoId:"solana"}},ct={chainId:101,address:"So11111111111111111111111111111111111111112",programId:Fa.toBase58(),decimals:9,symbol:"WSOL",name:"Wrapped SOL",logoURI:"https://img-v1.raydium.io/icon/So11111111111111111111111111111111111111112.png",tags:[],priority:2,type:"raydium",extensions:{coingeckoId:"solana"}};import{PublicKey as $r}from"@solana/web3.js";import{PublicKey as Fe,SystemProgram as Va,SYSVAR_RENT_PUBKEY as Tl}from"@solana/web3.js";import{TOKEN_PROGRAM_ID as Il}from"@solana/spl-token";function x({pubkey:m,isSigner:e=!1,isWritable:t=!0}){return{pubkey:m,isWritable:t,isSigner:e}}var jr=[x({pubkey:Il,isWritable:!1}),x({pubkey:Va.programId,isWritable:!1}),x({pubkey:Tl,isWritable:!1})];function Yr({publicKey:m,transformSol:e}){let t=Hr(m.toString());if(t instanceof Fe)return e&&t.equals(et)?Y:t;if(e&&t.toString()===et.toBase58())return Y;if(typeof t=="string"){if(t===Fe.default.toBase58())return Fe.default;try{return new Fe(t)}catch{throw new Error("invalid public key")}}throw new Error("invalid public key")}function Hr(m){try{return new Fe(m)}catch{return m}}var _i=new Fe("MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr"),kn=new Fe("MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr"),it=new Fe("SysvarRent111111111111111111111111111111111"),Ea=new Fe("SysvarC1ock11111111111111111111111111111111"),Xt=new Fe("metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s"),Bl=new Fe("Sysvar1nstructions1111111111111111111111111"),Zr=Va.programId,nf=new Fe("4k3Dyjzvzp8eMZWUXbBCjEvwSkkk59S5iCNLY3QrkX6R"),of=new Fe("Ea5SjE2Y6yvCeW5dYTn7PYMuW5ikXkvbGdcmSnXeaLjS"),rf=new Fe("SRMuApVNdxXokk5GT7XD5cUUgXMBCoAz2LHeuAoKWRt"),sf=new Fe("EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v"),af=new Fe("Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB"),uf=new Fe("mSoLzYCxHdYgdzU16g5QSh3i5K3z3KZK7ytfqcJm7So"),cf=new Fe("7dHbWXmci3dT8UFYWYZweBLXgycu7Y3iL6trKn1Y7ARj"),lf=new Fe("USDH1SM1ojwWUga67PGrgFWUHibbjqMvuMaDkRJTgkX"),mf=new Fe("NRVwhjBQiUPYtfDT5zRBVJajzFQHaBUNtC7SNVvqRFa"),df=new Fe("ANAxByE6G2WjFp7A4NqtWYXb3mgruyzZYg3spfxe6Lbo"),pf=new Fe("7vfCXTUXx5WJV5JADk17DUJ4ksgau7utNKj4b963voxs"),Y=new Fe("So11111111111111111111111111111111111111112"),et=Fe.default;function ut(m){return Yr({publicKey:m,transformSol:!0})}var Jr=class{constructor({mint:e,decimals:t,symbol:n,name:o,skipMint:r=!1,isToken2022:i=!1}){if(e===et.toBase58()||e instanceof $r&&et.equals(e)){this.decimals=ct.decimals,this.symbol=ct.symbol,this.name=ct.name,this.mint=new $r(ct.address),this.isToken2022=!1;return}this.decimals=t,this.symbol=n||e.toString().substring(0,6),this.name=o||e.toString().substring(0,6),this.mint=r?$r.default:Yr({publicKey:e}),this.isToken2022=i}equals(e){return this===e?!0:this.mint.equals(e.mint)}},Ve=Jr;Ve.WSOL=new Jr(W(v({},ct),{mint:ct.address}));var es=class{constructor({decimals:e,symbol:t="UNKNOWN",name:n="UNKNOWN"}){this.decimals=e,this.symbol=t,this.name=n}equals(e){return this===e}},Fi=es;Fi.SOL=new es(wn);import xl from"bn.js";var Da=new we(new xl(100)),tt=class extends we{toSignificant(e=5,t,n){return this.mul(Da).toSignificant(e,t,n)}toFixed(e=2,t,n){return this.mul(Da).toFixed(e,t,n)}};var Sl=ye("Raydium_price"),gt=class extends we{constructor(t){let{baseToken:n,quoteToken:o,numerator:r,denominator:i}=t;super(r,i);this.baseToken=n,this.quoteToken=o,this.scalar=new we(ts(n.decimals),ts(o.decimals))}get raw(){return new we(this.numerator,this.denominator)}get adjusted(){return super.mul(this.scalar)}invert(){return new gt({baseToken:this.quoteToken,quoteToken:this.baseToken,denominator:this.numerator,numerator:this.denominator})}mul(t){this.quoteToken!==t.baseToken&&Sl.logWithError("mul token not equals");let n=super.mul(t);return new gt({baseToken:this.baseToken,quoteToken:t.quoteToken,denominator:n.denominator,numerator:n.numerator})}toSignificant(t=this.quoteToken.decimals,n,o){return this.adjusted.toSignificant(t,n,o)}toFixed(t=this.quoteToken.decimals,n,o){return this.adjusted.toFixed(t,n,o)}};import{PublicKey as Kl}from"@solana/web3.js";import Cl from"bn.js";function Wa(m){return typeof m=="object"&&m!==null&&![Ve,Ie,Kl,we,Cl,gt,tt].some(e=>typeof e=="object"&&m instanceof e)}function rt(m){return typeof m=="string"?Hr(m):Array.isArray(m)?m.map(e=>rt(e)):Wa(m)?Object.fromEntries(Object.entries(m).map(([e,t])=>[e,rt(t)])):m}var At=new tn(0),qa=new tn(1),cy=new tn(2),ly=new tn(3),my=new tn(5),Qr=new tn(10),dy=new tn(100),py=new tn(1e3),fy=new tn(1e4);function ts(m){return Qr.pow($(m))}function Vi(m,e){let t=m.divmod(e);return t.mod.isZero()?t.div:t.div.isNeg()?t.div.isubn(1):t.div.iaddn(1)}function Ei(m,e,t){return m.mul(e).add(t).sub(new tn(1)).div(t)}function ns(m,e,t){return m.mul(e).div(t)}function Xr(m,e=1,t=[]){let n=[...m];if(e<=0)return t;for(;n.length;)t.push(n.splice(0,e));return t}var ht=class{constructor(e){this._owner=e}get publicKey(){return ht.isKeyPair(this._owner)?this._owner.publicKey:this._owner}get signer(){return ht.isKeyPair(this._owner)?this._owner:void 0}get isKeyPair(){return ht.isKeyPair(this._owner)}get isPublicKey(){return ht.isPublicKey(this._owner)}static isKeyPair(e){return e.secretKey!==void 0}static isPublicKey(e){return!ht.isKeyPair(e)}};import{PublicKey as vl}from"@solana/web3.js";import{TOKEN_PROGRAM_ID as _l}from"@solana/spl-token";import{ComputeBudgetProgram as Ua,Keypair as Xa,PublicKey as Rl,Transaction as za,TransactionMessage as Ll,VersionedTransaction as Qa}from"@solana/web3.js";var q={CreateAccount:"CreateAccount",InitAccount:"InitAccount",CreateATA:"CreateATA",CloseAccount:"CloseAccount",TransferAmount:"TransferAmount",InitMint:"InitMint",MintTo:"MintTo",InitMarket:"InitMarket",Util1216OwnerClaim:"Util1216OwnerClaim",SetComputeUnitPrice:"SetComputeUnitPrice",SetComputeUnitLimit:"SetComputeUnitLimit",ClmmCreatePool:"ClmmCreatePool",ClmmOpenPosition:"ClmmOpenPosition",ClmmIncreasePosition:"ClmmIncreasePosition",ClmmDecreasePosition:"ClmmDecreasePosition",ClmmClosePosition:"ClmmClosePosition",ClmmSwapBaseIn:"ClmmSwapBaseIn",ClmmSwapBaseOut:"ClmmSwapBaseOut",ClmmInitReward:"ClmmInitReward",ClmmSetReward:"ClmmSetReward",ClmmCollectReward:"ClmmCollectReward",ClmmLockPosition:"ClmmLockPosition",ClmmHarvestLockPosition:"ClmmHarvestLockPosition",AmmV4Swap:"AmmV4Swap",AmmV4AddLiquidity:"AmmV4AddLiquidity",AmmV4RemoveLiquidity:"AmmV4RemoveLiquidity",AmmV4SimulatePoolInfo:"AmmV4SimulatePoolInfo",AmmV4SwapBaseIn:"AmmV4SwapBaseIn",AmmV4SwapBaseOut:"AmmV4SwapBaseOut",AmmV4CreatePool:"AmmV4CreatePool",AmmV4InitPool:"AmmV4InitPool",AmmV5AddLiquidity:"AmmV5AddLiquidity",AmmV5RemoveLiquidity:"AmmV5RemoveLiquidity",AmmV5SimulatePoolInfo:"AmmV5SimulatePoolInfo",AmmV5SwapBaseIn:"AmmV5SwapBaseIn",AmmV5SwapBaseOut:"AmmV5SwapBaseOut",RouteSwap:"RouteSwap",RouteSwap1:"RouteSwap1",RouteSwap2:"RouteSwap2",FarmV3Deposit:"FarmV3Deposit",FarmV3Withdraw:"FarmV3Withdraw",FarmV3CreateLedger:"FarmV3CreateLedger",FarmV4Withdraw:"FarmV4Withdraw",FarmV5Deposit:"FarmV5Deposit",FarmV5Withdraw:"FarmV5Withdraw",FarmV5CreateLedger:"FarmV5CreateLedger",FarmV6Deposit:"FarmV6Deposit",FarmV6Withdraw:"FarmV6Withdraw",FarmV6Create:"FarmV6Create",FarmV6Restart:"FarmV6Restart",FarmV6CreatorAddReward:"FarmV6CreatorAddReward",FarmV6CreatorWithdraw:"FarmV6CreatorWithdraw",CpmmCreatePool:"CpmmCreatePool",CpmmAddLiquidity:"CpmmAddLiquidity",CpmmWithdrawLiquidity:"CpmmWithdrawLiquidity",CpmmSwapBaseIn:"CpmmSwapBaseIn",CpmmSwapBaseOut:"CpmmSwapBaseOut",CpmmLockLp:"CpmmLockLp",CpmmCollectLockFee:"CpmmCollectLockFee",TransferTip:"TransferTip"};import{TOKEN_PROGRAM_ID as Ol}from"@solana/spl-token";var Ga=ye("Raydium_txUtil"),ja=1644;function No(m){let e=[],t=[];return m.microLamports&&(e.push(Ua.setComputeUnitPrice({microLamports:m.microLamports})),t.push(q.SetComputeUnitPrice)),m.units&&(e.push(Ua.setComputeUnitLimit({units:m.units})),t.push(q.SetComputeUnitLimit)),{instructions:e,instructionTypes:t}}async function _n(m,e){var n,o;let t=e!=null?e:"confirmed";return(o=await((n=m.getLatestBlockhash)==null?void 0:n.call(m,{commitment:t})))==null?void 0:o.blockhash}async function Mo(m,e){return m.getSignatureStatuses([e]),new Promise((t,n)=>{let o=setTimeout(n,6e4);m.onSignature(e,r=>{if(clearTimeout(o),!r.err){t("");return}n(Object.assign(r.err,{txId:e}))},"confirmed")})}function os(m,e){m.length<1&&Ga.logWithError(`no instructions provided: ${m.toString()}`),e.length<1&&Ga.logWithError(`no signers provided:, ${e.toString()}`);let t=new za;t.recentBlockhash="11111111111111111111111111111111",t.feePayer=e[0],t.add(...m);try{return Buffer.from(t.serialize({verifySignatures:!1})).toString("base64").length<ja}catch{return!1}}function ae(m,e){let[t,n]=Rl.findProgramAddressSync(m,e);return{publicKey:t,nonce:n}}function vo({instructions:m,payer:e,signers:t}){return os(m,[e,...t])}function un({instructions:m,payer:e,lookupTableAddressAccount:t,recentBlockhash:n=Xa.generate().publicKey.toString()}){let r=new Ll({payerKey:e,recentBlockhash:n,instructions:m}).compileToV0Message(Object.values(t!=null?t:{}));try{return Buffer.from(new Qa(r).serialize()).toString("base64").length<ja}catch{return!1}}var Nl=m=>Buffer.isBuffer(m)?m:m instanceof Uint8Array?Buffer.from(m.buffer,m.byteOffset,m.byteLength):Buffer.from(m),Ml=m=>{let e=m.serialize({requireAllSignatures:!1,verifySignatures:!1});m instanceof Qa&&(e=Nl(e));try{return e instanceof Buffer?e.toString("base64"):Buffer.from(e).toString("base64")}catch{return e.toString("base64")}};function hn(m){let e=[];return m.forEach(t=>{t instanceof za&&(t.recentBlockhash||(t.recentBlockhash=Ol.toBase58()),t.feePayer||(t.feePayer=Xa.generate().publicKey)),e.push(Ml(t))}),console.log("simulate tx string:",e),e}function Z(m,e,t){return ae([m.toBuffer(),(t!=null?t:_l).toBuffer(),e.toBuffer()],new vl("ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL"))}import{PublicKey as ee}from"@solana/web3.js";var Ya=new ee("EhhTKczWMGQt46ynNeRX1WfeagwwJd7ufHvCDjRxjo5Q"),Ha=new ee("CBuCnLe26faBpcBP2fktp4rp8abpcAnTWft6ZrP5Q4T"),Za=new ee("9KEPoZmtHUrBbhWN1v1KWLMkkvwY6WLtAVUCPRtRjP4z"),_o=new ee("FarmqiPv5eAj3j1GMdMCMUGXqPUvmquZtMy86QH6rzhG"),vy=new ee("CLaimxFqjHzgTJtAGHU47NPhg6qrc5sCnpC4tBLyABQS"),$a=new ee("srmqPvymJeFKQ4zGQed1GFppgkRHL9kaELCbyksJtPX"),is=new ee("9xQeWvG816bUx9EPjHmaT23yvVM2ZWbrrpZb9PusVFin"),Di=new ee("675kPX9MHTjS2zt1qfr1NYHuzeLXfQM9H24wFSUt1Mp8"),_y=new ee("5quBtoiQqxF9Jv6KYKctB59NT3gtJD2Y65kdnB1Uev3h"),Ja=new ee("CDSr3ssLcRB6XYPJwAfFt18MZvEZp4LjHcvzBVZ45duo"),Fn=new ee("CAMMCzo5YL8w4VFF8KVHrK22GGUsp5VTaW7grrKgrWqK"),Fo=new ee("LockrWmn6K5twhz3y9w1dQERbmgSaRkfnTeTKbpofwE"),Wi=new ee("kN1kEznaF5Xbd8LYuqtEFcxzWSBk5Fv6ygX6SqEGJVy"),Vn=new ee("CDSr3ssLcRB6XYPJwAfFt18MZvEZp4LjHcvzBVZ45duo"),Fy=new ee("routeUGWgWzqBWFcrCfv8tritsqukccJPu3q5GPP3xS"),eu=new ee("7YttLkHDoNj9wyDur5pM1ejNaAvT9X4eqaYcHQqtj2G5"),Fl=new ee("6FJon3QE27qgPVggARueB22hLvoh22VzJpXv4rBEoSLF"),Vl=new ee("CC12se5To1CdEuw7fDS27B7Geo5jJyL7t5UK2B44NgiH"),El=new ee("9HzJyW1qZsEiSfMUf6L2jo3CcTKAyBmSyKdwQeYisHrC"),Dl=new ee("DropEU8AvevN3UrXWXTMuz3rqnMczQVNjq3kcSdW2SQi"),qi=new ee("CPMMoo8L3F4NbTegBCKVNunggL7H1ZpdTHKxQB5qKP1C"),tu=new ee("GpMZbSM2GgvTKHJirzeGfMFoaZ8UR2X7F4v8vHTvxFbL"),Vy=new ee("DNXgeM9EiiaAbaWvwjHj9fQQLAX5ZsfHyvmYUNRAdNC8"),Ui=new ee("LockrWmn6K5twhz3y9w1dQERbmgSaRkfnTeTKbpofwE"),Gi=new ee("3f7GcQFG397GAaEnv51zR6tsTVihYRydnydDD1cXekxH"),st=new ee("LanMV9sAd7wArD4vJFi2qDdfnVhFxYSUg6eADduJ3uj"),Ey=new ee("WLHv2UAZm6z4KyaaELi5pjdbJh6RESMva1Rnn8pJVVh"),Dy=new ee("DRay6fNdQ5J82H7xV6uq2aV3mNrUZ1J4PgSKsWgptcm6"),Wy=new ee("5xqNaZXX5eUi4p5HU4oz9i5QnwRNT2y6oN7yyn4qENeq"),qy=new ee("4Bu96XjU84XjPDSpveTVf6LYGCkfW5FK7SNkREWcEfV4"),Uy=new ee("6s1xP3hpbAfFoNtUNF8mfHsjr2Bd97JxFJRWLbL6aHuX"),Vo={IDO_PROGRAM_ID_V1:Fl,IDO_PROGRAM_ID_V2:Vl,IDO_PROGRAM_ID_V3:El,IDO_PROGRAM_ID_V4:Dl};var cn={OPEN_BOOK_PROGRAM:new ee("EoTcMgcDRTJVZDMZWBoU6rhYHZfkNTVEAfz3uUJRcYGj"),SERUM_PROGRAM_ID_V3:new ee("Ray1111111111111111111111111111111111111111"),AMM_V4:new ee("DRaya7Kj3aMWQSy19kSjvmuwq9docCHofyP9kanQGaav"),AMM_STABLE:new ee("DRayDdXc1NZQ9C3hRWmoSf8zK4iapgMnjdNZWrfwsP8m"),CLMM_PROGRAM_ID:new ee("DRayAUgENGQBKVaX8owNhgzkEDyoHTGVEGHVJT1E9pfH"),CLMM_LOCK_PROGRAM_ID:new ee("DRay25Usp3YJAi7beckgpGUC7mGJ2cR1AVPxhYfwVCUX"),CLMM_LOCK_AUTH_ID:new ee("6Aoh8h2Lw2m5UGxYR8AdAL87jTWYeKoxM52mJRzfYwN"),CREATE_CPMM_POOL_PROGRAM:new ee("DRaycpLY18LhpbydsBWbVJtxpNv9oXPgjRSfpF2bWpYb"),CREATE_CPMM_POOL_AUTH:new ee("CXniRufdq5xL8t8jZAPxsPZDpuudwuJSPWnbcD5Y5Nxq"),CREATE_CPMM_POOL_FEE_ACC:new ee("3oE58BKVt8KuYkGxx8zBojugnymWmBiyafWgMrnb6eYy"),LOCK_CPMM_PROGRAM:new ee("DRay25Usp3YJAi7beckgpGUC7mGJ2cR1AVPxhYfwVCUX"),LOCK_CPMM_AUTH:new ee("7qWVV8UY2bRJfDLP4s37YzBPKUkVB46DStYJBpYbQzu3"),UTIL1216:ee.default,Router:new ee("DRaybByLpbUL57LJARs3j8BitTxVfzBg351EaMr5UTCd"),FARM_PROGRAM_ID_V3:new ee("DRayWyrLmEW5KEeqs8kdTMMaBabapqagaBC7KWpGtJeZ"),FARM_PROGRAM_ID_V4:new ee("Ray1111111111111111111111111111111111111111"),FARM_PROGRAM_ID_V5:new ee("DRayiCGSZgku1GTK6rXD6mVDdingXy6APAH1R6R5L2LC"),FARM_PROGRAM_ID_V6:new ee("DRayzbYakXs45ELHkzH6vC3fuhQqTAnv5A68gdFuvZyZ"),LAUNCHPAD_PROGRAM:new ee("DRay6fNdQ5J82H7xV6uq2aV3mNrUZ1J4PgSKsWgptcm6"),LAUNCHPAD_AUTH:new ee("5xqNaZXX5eUi4p5HU4oz9i5QnwRNT2y6oN7yyn4qENeq"),LAUNCHPAD_PLATFORM:new ee("2Jx4KTDrVSdWNazuGpcA8n3ZLTRGGBDxAWhuKe2Xcj2a"),LAUNCHPAD_CONFIG:new ee("7ZR4zD7PYfY2XxoG1Gxcy2EgEeGYrpxrwzPuwdUBssEt"),FEE_DESTINATION_ID:new ee("9y8ENuuZ3b19quffx9hQvRVygG5ky6snHfRvGpuSfeJy"),MODEL_DATA_PUBKEY:new ee("Ray1111111111111111111111111111111111111111")};import Oe from"bn.js";var nn=1e4;function Be(m,e,t,n){if(e===void 0)return{amount:m,fee:void 0,expirationTime:void 0};let o=W(v({},e),{olderTransferFee:{epoch:BigInt(e.olderTransferFee.epoch),maximumFee:BigInt(e.olderTransferFee.maximumFee),transferFeeBasisPoints:e.olderTransferFee.transferFeeBasisPoints},newerTransferFee:{epoch:BigInt(e.newerTransferFee.epoch),maximumFee:BigInt(e.newerTransferFee.maximumFee),transferFeeBasisPoints:e.newerTransferFee.transferFeeBasisPoints}}),r=t.epoch<o.newerTransferFee.epoch?o.olderTransferFee:o.newerTransferFee,i=new Oe(r.maximumFee.toString()),s=t.epoch<o.newerTransferFee.epoch?(Number(o.newerTransferFee.epoch)*t.slotsInEpoch-t.absoluteSlot)*400/1e3:void 0;if(n)if(r.transferFeeBasisPoints===nn){let u=new Oe(r.maximumFee.toString());return{amount:m.add(u),fee:u,expirationTime:s}}else{let u=zt(m.mul(new Oe(nn)),new Oe(nn-r.transferFeeBasisPoints)),a=new Oe(r.maximumFee.toString()),c=u.sub(m).gt(a)?m.add(a):u,l=zt(c.mul(new Oe(r.transferFeeBasisPoints)),new Oe(nn)),d=l.gt(i)?i:l;return{amount:c,fee:d,expirationTime:s}}else{let u=zt(m.mul(new Oe(r.transferFeeBasisPoints)),new Oe(nn)),a=u.gt(i)?i:u;return{amount:m,fee:a,expirationTime:s}}}function Qt(m,e){return m===void 0?e:e===void 0?m:Math.min(m,e)}function zt(m,e){let{div:t,mod:n}=m.divmod(e);return n.gt(new Oe(0))?t.add(new Oe(1)):t}function En(m,e){if(m.isZero())return new Oe(0);let t=m.div(e);return t.isZero()?new Oe(1):m.mod(e).gt(new Oe(0))?t.add(new Oe(1)):t}function rs(m,e,t){if(e===void 0)return{amount:m,fee:void 0,expirationTime:void 0};let n=Math.floor(t/432e3),o=n<e.newerTransferFee.epoch?e.olderTransferFee:e.newerTransferFee,r=new Oe(o.maximumFee.toString()),i=n<e.newerTransferFee.epoch?(Number(e.newerTransferFee.epoch)*432e3-t)*400/1e3:void 0,s=zt(m.mul(new Oe(o.transferFeeBasisPoints)),new Oe(nn)),u=s.gt(r)?r:s;return{amount:m,fee:u,expirationTime:i}}function ss(m,e,t){if(e===void 0)return{amount:m,fee:void 0,expirationTime:void 0};let n=Math.floor(t/432e3),o=n<e.newerTransferFee.epoch?e.olderTransferFee:e.newerTransferFee,r=new Oe(o.maximumFee.toString()),i=n<e.newerTransferFee.epoch?(Number(e.newerTransferFee.epoch)*432e3-t)*400/1e3:void 0;if(o.transferFeeBasisPoints===nn){let s=new Oe(o.maximumFee.toString());return{amount:m.add(s),fee:s,expirationTime:i}}else{let s=zt(m.mul(new Oe(nn)),new Oe(nn-o.transferFeeBasisPoints)),u=new Oe(o.maximumFee.toString()),a=s.sub(m).gt(u)?m.add(u):s,c=zt(a.mul(new Oe(o.transferFeeBasisPoints)),new Oe(nn)),l=c.gt(r)?r:c;return{amount:a,fee:l,expirationTime:i}}}import{PublicKey as as,AddressLookupTableAccount as co}from"@solana/web3.js";async function Xi({connection:m,address:e,cluster:t="mainnet"}){let n=await Gt(m,[...new Set(e.map(r=>r.toString()))].map(r=>new as(r))),o={};for(let r=0;r<e.length;r++){let i=n[r],s=e[r];if(!i)continue;let u=new co({key:s,state:co.deserialize(i.data)});o[s.toString()]=u,t==="devnet"?uo[s.toString()]=u:Eo[s.toString()]=u}return o}var Eo={AcL1Vo8oy1ULiavEcjSUcwfBSForXMudcZvDZy5nzJkU:new co({key:new as("AcL1Vo8oy1ULiavEcjSUcwfBSForXMudcZvDZy5nzJkU"),state:co.deserialize(Buffer.from("AQAAAP//////////I1rcEwAAAAAvAQYwun9CU6c5Ikm2pAj+D9IEnCOR45nK+SFTGSdpd6J6AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAbd9uHXZaGT2cvhRs7reawctIXtX1s3kTqM9YV+/wCpBt324e51j94YQl285GzN2rYa/E2DuQ0n/r35KNihi/wFSlNQ+F3IgtYUpVZyeIopbd8eq6vQpgZ4iEky9O72oAVKU1qZKSEGTSTocWDaOHx8NbXdvJK7geQfqEBBBUSNBqfVFxksXFEhjMlMPUrxf1ja7gibof1E49vZigAAAAAGp9UXGMd0yShWY5hpHV62i164o5tLbVxzVVshAAAAAIyXJY9OJInxuz0QKRSODYMLWhOZ2v8QhASOe9jb6fhZC3BlsePRfEU4nVJ/awTDzVi4bHMaoP21SbbRvAP4KUbIScv+6Yw2LHF/6K0ZjUPibbSWXCirYPGuuVl7zT789IUPLW4CpHr4JNCatp3ELXDLKMv6JJ+37le50lbBJ2LvBkX2T9y7AHdNGviJAqQNtlDUDCnauQRWybsLji6nPM8Qkw5asQRvCdB3MbX6IEBwytOrpM32l4jQygKG9TKgR0vZScQ2AsM/IHeQ7RajUkyhuZdc8SGiqQz/7H34torNR/Wir3sl0ruUrVxJWEZfUg+QLNAxxODdBi53/OP7Ioil1cqeBM9dtZC3FLov4yyxWRM/wcGStyJX/QfTnLBAHqkqWotPKVlShCVQqpP9W5W1rOao65IMk5QuQ2kMIOxzDMKAy2vjGSxQODgBz0QwGA+eP4ZjIjrIAQaXENv31QfLlOdXSRCkaybRniDHF4C8YcwhcvsqrOVuTP4B2Na+9wLdtrB31uz2rtlFI5kahdsnp/d1SrASDInYCtTYtdoke4kX+hoKWcEWM4Tle8pTUkUVv4BxS6fje/EzKBE4Qu/YsA/yfEEFGcr8Z57VKDw8uQzpiru7g4lvjnfapW62W030syevD8k07SGoxUHiuT/ai7gAHWWhDsVmg/C63ajgpkH7Sn3GdutArDTfyqOkdqv4/IPC/EFFy7mGkfDd2C57N5a/4jC+BbmJy7wQaSEZr0CQU88lPtUxIVvzGjC95b8Ooss2TqmkrayGKofkPMGQn7Ux+9lfwBSNfxwH8NgbpqC/7LNlV4I7nCvsXf3p+ohQk9NrAJb2KAFpUqEIJ9ZBV7BYDzHF/ORKYlgtvPnXjudZQ6CEo5OzUDaNIomTCCsvhD16TxJjsbgne1kGnQPCFSoaxUbq2V1bPMFQ3VYP6wDZ9bKStCFKx9A3tNbwZFC5ZGAN83MFK7XoTy+OmmcFEr6rLOjfSuTfPvHJkSVxW6Qllwkl67XcBi5v00u2gQsbu+38sp+rd5pA/LvyWj4P94ZGZwc1tE2P88xekCLcAwZGb+UhFzL/7K26csOb57yM5bvF9xJrLEObOkAAAAAn+HWRkdcPKyFFMnVwEoD7vnD0jCKFIU1sImubYCxNTSVzsKpaQX+fzNxrLAI3L14JQnJx/D6Uk2LADIHGqnGELzjEbkBDAlaM77NkXMPfqXNLSveCkWI7UEgNs31WEWB6XHSYI/v5DklHOb4QTtDOR804PVbi3fjloZeLR2F8d4FuZmMMO7ck3Fnkn2zEMG5gOmqsygb6PjTitArVl52NhcSznTxVnguaIJxiZkAnurDmn3MWR0PC2GLghp2KJqHCc6QQ85odeIjFHKOlRlJyeSXVJmL8vb1UgOzsbJPVP8p6zM4M3C1Sd7uWIHP33G42AP2Zg8ucn/n6meQjjD266JgCWdxZD6PXs9CsnIeL7SSG0/6lGb9xfP0ZcWkCXB/3hjxHYVXjra/GPOeXGk0fLLKjCbk+mgs2w6d2oCwimBipTzuoZ30GiI8ij8VRzD5CzMWtu2m21eDBIfjGAEo4pQeNNonKcqzV/cleX8ySZLOHsz8PtBCrLqF+VkLm9hOzIT+6i/nIf6keR4GWKMOD4AvqfpjHoD4DuhBpz8P28+DxkGrDXXr/nr20x291VPvcTU/b+b+o2kC9G0kcXeTlLjU6a2TQXWlZ4gBUdBl1jgT7mObSTpLblNiXZsLkbmVXZwvFKXua5cUKlWed/w30skmEUraTuQqtqr5fHZPW9n57EmeTif6LjHL2YJFZkQU+TrJmFzqzmF4/b8OwrPQAprl8mX3q4LUIdAS/a+11B6DWD1Xk2++Sn94dLC4xjkO4Wtlw8c4XuzciVbepHOmnoWzVu/0y3KCrLCSfQxQ3br8DJCoVzhgtPsS2nZZjsBGIZgnU0QpMv+2MnRsnKwdp1VsrCX84j/qvaZn4WhKunippgTbN2EUs0tPTP55Qfgj+nKmjtWW5IYs72FrEwJKYoNfsmqaF4o5pf4v9zgPwVwY/5I4XJKUL2L25m9kAQcW/K+H1RTFEUoj8Z4ajpOmAB/dG0COmCphVMW2CCMvnxhcGiSgPnpDuWu6qiJ7NG7ye5kvHgefgqPLeicspNJ5EpL3XiRNLM2tmJLI1awAwOyd6iHv0dCkMYRKaa6rcaZeYwmKCkckm0kM2JNmnmmAaBQQ7mwmIM0IMxX4f5W6j9PqZWcJxF7r17T/lQBAmcjoupRiJifbnXCNUv9GhpRF19WcBdeKbivRJVlGop6I2RS6lGImJ9udcI1S/0aGlEXX1ZwF14puK9ElWUainojZFYVHLHD6dIP2ESjqBzg3ol1/wB7+/ylGwd9LS7wSZ2A630CJSVKwH47K9P4bB8PEQP8BwjMFa7xQHOqZFP1XqaQ==","base64"))})},uo={},zi=async m=>{let e="EFhMuDw1PKEuckuFRW9PavNfTH4LKP5uKHgyXDmWpFCq";if(uo[e])return uo;let t=new as(e),n=await m.getAccountInfo(t);return n&&(uo[e]=new co({key:t,state:co.deserialize(n.data)})),uo};import{PublicKey as Dn,sendAndConfirmTransaction as us,SystemProgram as Wl,Transaction as Do,TransactionMessage as ln,VersionedTransaction as mn}from"@solana/web3.js";import ql from"axios";var Wo=2e3,qo=class{constructor(e){this.instructions=[];this.endInstructions=[];this.lookupTableAddress=[];this.signers=[];this.instructionTypes=[];this.endInstructionTypes=[];this.connection=e.connection,this.feePayer=e.feePayer,this.signAllTransactions=e.signAllTransactions,this.owner=e.owner,this.cluster=e.cluster,this.blockhashCommitment=e.blockhashCommitment,this.loopMultiTxStatus=!!e.loopMultiTxStatus}get AllTxData(){return{instructions:this.instructions,endInstructions:this.endInstructions,signers:this.signers,instructionTypes:this.instructionTypes,endInstructionTypes:this.endInstructionTypes,lookupTableAddress:this.lookupTableAddress}}get allInstructions(){return[...this.instructions,...this.endInstructions]}async getComputeBudgetConfig(){var n;let e=(await ql.get(`https://solanacompass.com/api/fees?cacheFreshTime=${3e5}`)).data,{avg:t}=(n=e==null?void 0:e[15])!=null?n:{};if(!!t)return{units:6e5,microLamports:Math.min(Math.ceil(t*1e6/6e5),25e3)}}addCustomComputeBudget(e){if(e){let{instructions:t,instructionTypes:n}=No(e);return this.instructions.unshift(...t),this.instructionTypes.unshift(...n),!0}return!1}addTipInstruction(e){var t;return e?(this.endInstructions.push(Wl.transfer({fromPubkey:(t=e.feePayer)!=null?t:this.feePayer,toPubkey:new Dn(e.address),lamports:BigInt(e.amount.toString())})),this.endInstructionTypes.push(q.TransferTip),!0):!1}async calComputeBudget({config:e,defaultIns:t}){try{let n=e||await this.getComputeBudgetConfig();if(this.addCustomComputeBudget(n))return;t&&this.instructions.unshift(...t)}catch{t&&this.instructions.unshift(...t)}}addInstruction({instructions:e=[],endInstructions:t=[],signers:n=[],instructionTypes:o=[],endInstructionTypes:r=[],lookupTableAddress:i=[]}){return this.instructions.push(...e),this.endInstructions.push(...t),this.signers.push(...n),this.instructionTypes.push(...o),this.endInstructionTypes.push(...r),this.lookupTableAddress.push(...i.filter(s=>s!==Dn.default.toString())),this}async versionBuild({txVersion:e,extInfo:t}){return e===0?await this.buildV0(v({},t||{})):this.build(t)}build(e){var n;let t=new Do;return this.allInstructions.length&&t.add(...this.allInstructions),t.feePayer=this.feePayer,((n=this.owner)==null?void 0:n.signer)&&!this.signers.some(o=>o.publicKey.equals(this.owner.publicKey))&&this.signers.push(this.owner.signer),{builder:this,transaction:t,signers:this.signers,instructionTypes:[...this.instructionTypes,...this.endInstructionTypes],execute:async o=>{var c;let{recentBlockHash:r,skipPreflight:i=!0,sendAndConfirm:s,notSendToRpc:u}=o||{},a=r!=null?r:await _n(this.connection,this.blockhashCommitment);if(t.recentBlockhash=a,this.signers.length&&t.sign(...this.signers),hn([t]),(c=this.owner)!=null&&c.isKeyPair)return{txId:s?await us(this.connection,t,this.signers.find(d=>d.publicKey.equals(this.owner.publicKey))?this.signers:[...this.signers,this.owner.signer],{skipPreflight:i}):await this.connection.sendRawTransaction(t.serialize(),{skipPreflight:i}),signedTx:t};if(this.signAllTransactions){let l=await this.signAllTransactions([t]);if(this.signers.length)for(let d of l)try{d.sign(...this.signers)}catch{}return{txId:u?"":await this.connection.sendRawTransaction(l[0].serialize(),{skipPreflight:i}),signedTx:l[0]}}throw new Error("please provide owner in keypair format or signAllTransactions function")},extInfo:e||{}}}buildMultiTx(e){var a;let{extraPreBuildData:t=[],extInfo:n}=e,{transaction:o}=this.build(n),r=t.filter(c=>c.transaction.instructions.length>0),i=[o,...r.map(c=>c.transaction)],s=[this.signers,...r.map(c=>c.signers)],u=[...this.instructionTypes,...r.map(c=>c.instructionTypes).flat()];return(a=this.owner)!=null&&a.signer&&s.forEach(c=>{c.some(l=>l.publicKey.equals(this.owner.publicKey))||this.signers.push(this.owner.signer)}),{builder:this,transactions:i,signers:s,instructionTypes:u,execute:async c=>{var g;let{sequentially:l,onTxUpdate:d,skipTxCount:p=0,recentBlockHash:f,skipPreflight:y=!0}=c||{},b=f!=null?f:await _n(this.connection,this.blockhashCommitment);if((g=this.owner)!=null&&g.isKeyPair){if(l){let A=[],h=0;for(let T of i){if(++h,h<=p)continue;let k=await us(this.connection,T,this.signers.find(w=>w.publicKey.equals(this.owner.publicKey))?this.signers:[...this.signers,this.owner.signer],{skipPreflight:y});A.push(k)}return{txIds:A,signedTxs:i}}return{txIds:await await Promise.all(i.map(async A=>(A.recentBlockhash=b,await this.connection.sendRawTransaction(A.serialize(),{skipPreflight:y})))),signedTxs:i}}if(this.signAllTransactions){let A=i.map((T,k)=>(T.recentBlockhash=b,s[k].length&&T.sign(...s[k]),T));hn(A);let h=await this.signAllTransactions(A);if(l){let T=0,k=[],w=async()=>{if(!h[T])return;let S=await this.connection.sendRawTransaction(h[T].serialize(),{skipPreflight:y});k.push({txId:S,status:"sent",signedTx:h[T]}),d==null||d([...k]),T++;let B=!1,K=null,I=null,C=O=>{K!==null&&clearInterval(K),I!==null&&this.connection.removeSignatureListener(I);let M=k.findIndex(R=>R.txId===S);if(M>-1){if(k[M].status==="error"||k[M].status==="success")return;k[M].status=O.err?"error":"success"}d==null||d([...k]),O.err||w()};this.loopMultiTxStatus&&(K=setInterval(async()=>{var O;if(B){clearInterval(K);return}try{let M=await this.connection.getTransaction(S,{commitment:"confirmed",maxSupportedTransactionVersion:0});M&&(B=!0,clearInterval(K),C({err:((O=M.meta)==null?void 0:O.err)||null}),console.log("tx status from getTransaction:",S))}catch(M){B=!0,clearInterval(K),console.error("getTransaction timeout:",M,S)}},Wo)),I=this.connection.onSignature(S,O=>{if(B){this.connection.removeSignatureListener(I);return}B=!0,C(O)},"confirmed"),this.connection.getSignatureStatus(S)};return await w(),{txIds:k.map(S=>S.txId),signedTxs:h}}else{let T=[];for(let k=0;k<h.length;k+=1){let w=await this.connection.sendRawTransaction(h[k].serialize(),{skipPreflight:y});T.push(w)}return{txIds:T,signedTxs:h}}}throw new Error("please provide owner in keypair format or signAllTransactions function")},extInfo:n||{}}}async versionMultiBuild({extraPreBuildData:e,txVersion:t,extInfo:n}){return t===0?await this.buildV0MultiTx({extraPreBuildData:e,buildProps:n||{}}):this.buildMultiTx({extraPreBuildData:e,extInfo:n})}async buildV0(e){var y;let f=e||{},{lookupTableCache:t={},lookupTableAddress:n=[],forerunCreate:o,recentBlockhash:r}=f,i=_e(f,["lookupTableCache","lookupTableAddress","forerunCreate","recentBlockhash"]),s=v(v({},this.cluster==="devnet"?await zi(this.connection):Eo),t),u=Array.from(new Set([...n,...this.lookupTableAddress])),a=[];for(let b of u)s[b]===void 0&&a.push(new Dn(b));let c=await Xi({connection:this.connection,address:a});for(let[b,g]of Object.entries(c))s[b]=g;let l=o?Dn.default.toBase58():r!=null?r:await _n(this.connection,this.blockhashCommitment),d=new ln({payerKey:this.feePayer,recentBlockhash:l,instructions:[...this.allInstructions]}).compileToV0Message(Object.values(s));((y=this.owner)==null?void 0:y.signer)&&!this.signers.some(b=>b.publicKey.equals(this.owner.publicKey))&&this.signers.push(this.owner.signer);let p=new mn(d);return p.sign(this.signers),{builder:this,transaction:p,signers:this.signers,instructionTypes:[...this.instructionTypes,...this.endInstructionTypes],execute:async b=>{var T;let{skipPreflight:g=!0,sendAndConfirm:A,notSendToRpc:h}=b||{};if(hn([p]),(T=this.owner)!=null&&T.isKeyPair){let k=await this.connection.sendTransaction(p,{skipPreflight:g});return A&&await Mo(this.connection,k),{txId:k,signedTx:p}}if(this.signAllTransactions){let k=await this.signAllTransactions([p]);if(this.signers.length)for(let w of k)try{w.sign(this.signers)}catch{}return{txId:h?"":await this.connection.sendTransaction(k[0],{skipPreflight:g}),signedTx:k[0]}}throw new Error("please provide owner in keypair format or signAllTransactions function")},extInfo:i||{}}}async buildV0MultiTx(e){var a;let{extraPreBuildData:t=[],buildProps:n}=e,{transaction:o}=await this.buildV0(n),r=t.filter(c=>c.builder.instructions.length>0),i=[o,...r.map(c=>c.transaction)],s=[this.signers,...r.map(c=>c.signers)],u=[...this.instructionTypes,...r.map(c=>c.instructionTypes).flat()];return(a=this.owner)!=null&&a.signer&&s.forEach(c=>{c.some(l=>l.publicKey.equals(this.owner.publicKey))||this.signers.push(this.owner.signer)}),i.forEach(async(c,l)=>{c.sign(s[l])}),{builder:this,transactions:i,signers:s,instructionTypes:u,buildProps:n,execute:async c=>{var y;let{sequentially:l,onTxUpdate:d,recentBlockHash:p,skipPreflight:f=!0}=c||{};if(p&&i.forEach(b=>b.message.recentBlockhash=p),hn(i),(y=this.owner)!=null&&y.isKeyPair){if(l){let b=[];for(let g of i){let A=await this.connection.sendTransaction(g,{skipPreflight:f});await Mo(this.connection,A),b.push(A)}return{txIds:b,signedTxs:i}}return{txIds:await Promise.all(i.map(async b=>await this.connection.sendTransaction(b,{skipPreflight:f}))),signedTxs:i}}if(this.signAllTransactions){let b=await this.signAllTransactions(i);if(l){let g=0,A=[],h=async()=>{if(!b[g])return;let T=await this.connection.sendTransaction(b[g],{skipPreflight:f});A.push({txId:T,status:"sent",signedTx:b[g]}),d==null||d([...A]),g++;let k=!1,w=null,S=null,B=K=>{w!==null&&clearInterval(w),S!==null&&this.connection.removeSignatureListener(S);let I=A.findIndex(C=>C.txId===T);if(I>-1){if(A[I].status==="error"||A[I].status==="success")return;A[I].status=K.err?"error":"success"}d==null||d([...A]),K.err||h()};this.loopMultiTxStatus&&(w=setInterval(async()=>{var K;if(k){clearInterval(w);return}try{let I=await this.connection.getTransaction(T,{commitment:"confirmed",maxSupportedTransactionVersion:0});I&&(k=!0,clearInterval(w),B({err:((K=I.meta)==null?void 0:K.err)||null}),console.log("tx status from getTransaction:",T))}catch(I){k=!0,clearInterval(w),console.error("getTransaction timeout:",I,T)}},Wo)),S=this.connection.onSignature(T,K=>{if(k){this.connection.removeSignatureListener(S);return}k=!0,B(K)},"confirmed"),this.connection.getSignatureStatus(T)};return h(),{txIds:[],signedTxs:b}}else{let g=[];for(let A=0;A<b.length;A+=1){let h=await this.connection.sendTransaction(b[A],{skipPreflight:f});g.push(h)}return{txIds:g,signedTxs:b}}}throw new Error("please provide owner in keypair format or signAllTransactions function")},extInfo:n||{}}}async sizeCheckBuild(e){var d;let l=e||{},{splitIns:t=[],computeBudgetConfig:n}=l,o=_e(l,["splitIns","computeBudgetConfig"]),r=n?No(n):{instructions:[],instructionTypes:[]},i=this.signers.reduce((p,f)=>W(v({},p),{[f.publicKey.toBase58()]:f}),{}),s=[],u=[],a=[],c=0;if(this.allInstructions.forEach(p=>{let f=[...a,p],y=n?[...r.instructions,...f]:f,g=[...new Set(f.map(A=>A.keys.filter(h=>h.isSigner).map(h=>h.pubkey.toString())).flat()).values()].map(A=>new Dn(A));if(p!==t[c]&&a.length<12&&(vo({instructions:y,payer:this.feePayer,signers:g})||vo({instructions:f,payer:this.feePayer,signers:g})))a.push(p);else{if(a.length===0)throw Error("item ins too big");c+=p===t[c]?1:0,vo({instructions:n?[...r.instructions,...a]:[...a],payer:this.feePayer,signers:g})?s.push(new Do().add(...r.instructions,...a)):s.push(new Do().add(...a)),u.push(Array.from(new Set(a.map(A=>A.keys.filter(h=>h.isSigner).map(h=>h.pubkey.toString())).flat())).map(A=>i[A]).filter(A=>A!==void 0)),a=[p]}}),a.length>0){let f=[...new Set(a.map(y=>y.keys.filter(b=>b.isSigner).map(b=>b.pubkey.toString())).flat()).values()].map(y=>i[y]).filter(y=>y!==void 0);vo({instructions:n?[...r.instructions,...a]:[...a],payer:this.feePayer,signers:f.map(y=>y.publicKey)})?s.push(new Do().add(...r.instructions,...a)):s.push(new Do().add(...a)),u.push(f)}return s.forEach(p=>p.feePayer=this.feePayer),(d=this.owner)!=null&&d.signer&&u.forEach(p=>{p.some(f=>f.publicKey.equals(this.owner.publicKey))||p.push(this.owner.signer)}),{builder:this,transactions:s,signers:u,instructionTypes:this.instructionTypes,execute:async p=>{var T;let{sequentially:f,onTxUpdate:y,skipTxCount:b=0,recentBlockHash:g,skipPreflight:A=!0}=p||{},h=g!=null?g:await _n(this.connection,this.blockhashCommitment);if(s.forEach(async(k,w)=>{k.recentBlockhash=h,u[w].length&&k.sign(...u[w])}),hn(s),(T=this.owner)!=null&&T.isKeyPair){if(f){let k=0,w=[];for(let S of s){if(++k,k<=b){w.push("tx skipped");continue}let B=await us(this.connection,S,this.signers.find(K=>K.publicKey.equals(this.owner.publicKey))?this.signers:[...this.signers,this.owner.signer],{skipPreflight:A});w.push(B)}return{txIds:w,signedTxs:s}}return{txIds:await Promise.all(s.map(async k=>await this.connection.sendRawTransaction(k.serialize(),{skipPreflight:A}))),signedTxs:s}}if(this.signAllTransactions){let k=await this.signAllTransactions(s.slice(b,s.length)),w=[...s.slice(0,b),...k];if(f){let S=0,B=[],K=async()=>{if(!w[S])return;S<b&&(B.push({txId:"",status:"success",signedTx:w[S]}),y==null||y([...B]),S++,K());let I=await this.connection.sendRawTransaction(w[S].serialize(),{skipPreflight:A});B.push({txId:I,status:"sent",signedTx:w[S]}),y==null||y([...B]),S++;let C=!1,O=null,M=null,R=L=>{O!==null&&clearInterval(O),M!==null&&this.connection.removeSignatureListener(M);let _=B.findIndex(G=>G.txId===I);if(_>-1){if(B[_].status==="error"||B[_].status==="success")return;B[_].status=L.err?"error":"success"}y==null||y([...B]),L.err||K()};this.loopMultiTxStatus&&(O=setInterval(async()=>{var L;if(C){clearInterval(O);return}try{let _=await this.connection.getTransaction(I,{commitment:"confirmed",maxSupportedTransactionVersion:0});_&&(C=!0,clearInterval(O),R({err:((L=_.meta)==null?void 0:L.err)||null}),console.log("tx status from getTransaction:",I))}catch(_){C=!0,clearInterval(O),console.error("getTransaction timeout:",_,I)}},Wo)),M=this.connection.onSignature(I,L=>{if(C){this.connection.removeSignatureListener(M);return}C=!0,R(L)},"confirmed"),this.connection.getSignatureStatus(I)};return await K(),{txIds:B.map(I=>I.txId),signedTxs:w}}else{let S=[];for(let B=0;B<w.length;B+=1){let K=await this.connection.sendRawTransaction(w[B].serialize(),{skipPreflight:A});S.push(K)}return{txIds:S,signedTxs:w}}}throw new Error("please provide owner in keypair format or signAllTransactions function")},extInfo:o||{}}}async sizeCheckBuildV0(e){var h;let A=e||{},{computeBudgetConfig:t,splitIns:n=[],lookupTableCache:o={},lookupTableAddress:r=[]}=A,i=_e(A,["computeBudgetConfig","splitIns","lookupTableCache","lookupTableAddress"]),s=v(v({},this.cluster==="devnet"?await zi(this.connection):Eo),o),u=Array.from(new Set([...this.lookupTableAddress,...r])),a=[];for(let T of u)s[T]===void 0&&a.push(new Dn(T));let c=await Xi({connection:this.connection,address:a});for(let[T,k]of Object.entries(c))s[T]=k;let l=t?No(t):{instructions:[],instructionTypes:[]},d=await _n(this.connection,this.blockhashCommitment),p=this.signers.reduce((T,k)=>W(v({},T),{[k.publicKey.toBase58()]:k}),{}),f=[],y=[],b=[],g=0;if(this.allInstructions.forEach(T=>{let k=[...b,T],w=t?[...l.instructions,...k]:k;if(T!==n[g]&&b.length<12&&(un({instructions:w,payer:this.feePayer,lookupTableAddressAccount:s})||un({instructions:k,payer:this.feePayer,lookupTableAddressAccount:s})))b.push(T);else{if(b.length===0)throw Error("item ins too big");g+=T===n[g]?1:0;let S={};for(let B of[...new Set(u)])s[B]!==void 0&&(S[B]=s[B]);if(t&&un({instructions:[...l.instructions,...b],payer:this.feePayer,lookupTableAddressAccount:s,recentBlockhash:d})){let B=new ln({payerKey:this.feePayer,recentBlockhash:d,instructions:[...l.instructions,...b]}).compileToV0Message(Object.values(s));f.push(new mn(B))}else{let B=new ln({payerKey:this.feePayer,recentBlockhash:d,instructions:[...b]}).compileToV0Message(Object.values(s));f.push(new mn(B))}y.push(Array.from(new Set(b.map(B=>B.keys.filter(K=>K.isSigner).map(K=>K.pubkey.toString())).flat())).map(B=>p[B]).filter(B=>B!==void 0)),b=[T]}}),b.length>0){let k=[...new Set(b.map(w=>w.keys.filter(S=>S.isSigner).map(S=>S.pubkey.toString())).flat()).values()].map(w=>p[w]).filter(w=>w!==void 0);if(t&&un({instructions:[...l.instructions,...b],payer:this.feePayer,lookupTableAddressAccount:s,recentBlockhash:d})){let w=new ln({payerKey:this.feePayer,recentBlockhash:d,instructions:[...l.instructions,...b]}).compileToV0Message(Object.values(s));f.push(new mn(w))}else{let w=new ln({payerKey:this.feePayer,recentBlockhash:d,instructions:[...b]}).compileToV0Message(Object.values(s));f.push(new mn(w))}y.push(k)}return(h=this.owner)!=null&&h.signer&&y.forEach(T=>{T.some(k=>k.publicKey.equals(this.owner.publicKey))||T.push(this.owner.signer)}),f.forEach((T,k)=>{T.sign(y[k])}),{builder:this,transactions:f,buildProps:e,signers:y,instructionTypes:this.instructionTypes,execute:async T=>{var I;let{sequentially:k,onTxUpdate:w,skipTxCount:S=0,recentBlockHash:B,skipPreflight:K=!0}=T||{};if(f.map(async(C,O)=>{y[O].length&&C.sign(y[O]),B&&(C.message.recentBlockhash=B)}),hn(f),(I=this.owner)!=null&&I.isKeyPair){if(k){let C=0,O=[];for(let M of f){if(++C,C<=S){console.log("skip tx: ",C),O.push("tx skipped");continue}let R=await this.connection.sendTransaction(M,{skipPreflight:K});await Mo(this.connection,R),O.push(R)}return{txIds:O,signedTxs:f}}return{txIds:await Promise.all(f.map(async C=>await this.connection.sendTransaction(C,{skipPreflight:K}))),signedTxs:f}}if(this.signAllTransactions){let C=await this.signAllTransactions(f.slice(S,f.length)),O=[...f.slice(0,S),...C];if(k){let M=0,R=[],L=async()=>{if(!O[M])return;if(M<S){R.push({txId:"",status:"success",signedTx:O[M]}),w==null||w([...R]),M++,L();return}let _=await this.connection.sendTransaction(O[M],{skipPreflight:K});R.push({txId:_,status:"sent",signedTx:O[M]}),w==null||w([...R]),M++;let G=!1,Q=null,se=null,ce=ne=>{Q!==null&&clearInterval(Q),se!==null&&this.connection.removeSignatureListener(se);let le=R.findIndex(fe=>fe.txId===_);if(le>-1){if(R[le].status==="error"||R[le].status==="success")return;R[le].status=ne.err?"error":"success"}w==null||w([...R]),ne.err||L()};this.loopMultiTxStatus&&(Q=setInterval(async()=>{var ne;if(G){clearInterval(Q);return}try{let le=await this.connection.getTransaction(_,{commitment:"confirmed",maxSupportedTransactionVersion:0});le&&(G=!0,clearInterval(Q),ce({err:((ne=le.meta)==null?void 0:ne.err)||null}),console.log("tx status from getTransaction:",_))}catch(le){G=!0,clearInterval(Q),console.error("getTransaction timeout:",le,_)}},Wo)),se=this.connection.onSignature(_,ne=>{if(G){this.connection.removeSignatureListener(se);return}G=!0,ce(ne)},"confirmed"),this.connection.getSignatureStatus(_)};return L(),{txIds:[],signedTxs:O}}else{let M=[];for(let R=0;R<O.length;R+=1){let L=await this.connection.sendTransaction(O[R],{skipPreflight:K});M.push(L)}return{txIds:M,signedTxs:O}}}throw new Error("please provide owner in keypair format or signAllTransactions function")},extInfo:i||{}}}async buildSniperTransaction(e){var h;let A=e||{},{computeBudgetConfig:t,splitIns:n=[],lookupTableCache:o={},lookupTableAddress:r=[]}=A,i=_e(A,["computeBudgetConfig","splitIns","lookupTableCache","lookupTableAddress"]),s=v(v({},this.cluster==="devnet"?await zi(this.connection):Eo),o),u=Array.from(new Set([...this.lookupTableAddress,...r])),a=[];for(let T of u)s[T]===void 0&&a.push(new Dn(T));let c=await Xi({connection:this.connection,address:a});for(let[T,k]of Object.entries(c))s[T]=k;let l=t?No(t):{instructions:[],instructionTypes:[]},d=await _n(this.connection,this.blockhashCommitment),p=this.signers.reduce((T,k)=>W(v({},T),{[k.publicKey.toBase58()]:k}),{}),f=[],y=[],b=[],g=0;if(this.allInstructions.forEach(T=>{let k=[...b,T],w=t?[...l.instructions,...k]:k;if(T!==n[g]&&b.length<12&&(un({instructions:w,payer:this.feePayer,lookupTableAddressAccount:s})||un({instructions:k,payer:this.feePayer,lookupTableAddressAccount:s})))b.push(T);else{if(b.length===0)throw Error("item ins too big");g+=T===n[g]?1:0;let S={};for(let B of[...new Set(u)])s[B]!==void 0&&(S[B]=s[B]);if(t&&un({instructions:[...l.instructions,...b],payer:this.feePayer,lookupTableAddressAccount:s,recentBlockhash:d})){let B=new ln({payerKey:this.feePayer,recentBlockhash:d,instructions:[...l.instructions,...b]}).compileToV0Message(Object.values(s));f.push(new mn(B))}else{let B=new ln({payerKey:this.feePayer,recentBlockhash:d,instructions:[...b]}).compileToV0Message(Object.values(s));f.push(new mn(B))}y.push(Array.from(new Set(b.map(B=>B.keys.filter(K=>K.isSigner).map(K=>K.pubkey.toString())).flat())).map(B=>p[B]).filter(B=>B!==void 0)),b=[T]}}),b.length>0){let k=[...new Set(b.map(w=>w.keys.filter(S=>S.isSigner).map(S=>S.pubkey.toString())).flat()).values()].map(w=>p[w]).filter(w=>w!==void 0);if(t&&un({instructions:[...l.instructions,...b],payer:this.feePayer,lookupTableAddressAccount:s,recentBlockhash:d})){let w=new ln({payerKey:this.feePayer,recentBlockhash:d,instructions:[...l.instructions,...b]}).compileToV0Message(Object.values(s));f.push(new mn(w))}else{let w=new ln({payerKey:this.feePayer,recentBlockhash:d,instructions:[...b]}).compileToV0Message(Object.values(s));f.push(new mn(w))}y.push(k)}return(h=this.owner)!=null&&h.signer&&y.forEach(T=>{T.some(k=>k.publicKey.equals(this.owner.publicKey))||T.push(this.owner.signer)}),f.forEach((T,k)=>{T.sign(y[k])}),{builder:this,transactions:f,buildProps:e,signers:y,instructionTypes:this.instructionTypes,execute:async T=>{var I;let{sequentially:k,onTxUpdate:w,skipTxCount:S=0,recentBlockHash:B,skipPreflight:K=!0}=T||{};if(f.map(async(C,O)=>{y[O].length&&C.sign(y[O]),B&&(C.message.recentBlockhash=B)}),hn(f),(I=this.owner)!=null&&I.isKeyPair){if(k){let C=0,O=[];for(let M of f){if(++C,C<=S){console.log("skip tx: ",C),O.push("tx skipped");continue}let R=await this.connection.sendTransaction(M,{skipPreflight:K});await Mo(this.connection,R),O.push(R)}return{txIds:O,signedTxs:f}}return{txIds:await Promise.all(f.map(async C=>await this.connection.sendTransaction(C,{skipPreflight:K}))),signedTxs:f}}if(this.signAllTransactions){let C=await this.signAllTransactions(f.slice(S,f.length)),O=[...f.slice(0,S),...C];if(k){let M=0,R=[],L=async()=>{if(!O[M])return;if(M<S){R.push({txId:"",status:"success",signedTx:O[M]}),w==null||w([...R]),M++,L();return}let _=await this.connection.sendTransaction(O[M],{skipPreflight:K});R.push({txId:_,status:"sent",signedTx:O[M]}),w==null||w([...R]),M++;let G=!1,Q=null,se=null,ce=ne=>{Q!==null&&clearInterval(Q),se!==null&&this.connection.removeSignatureListener(se);let le=R.findIndex(fe=>fe.txId===_);if(le>-1){if(R[le].status==="error"||R[le].status==="success")return;R[le].status=ne.err?"error":"success"}w==null||w([...R]),ne.err||L()};this.loopMultiTxStatus&&(Q=setInterval(async()=>{var ne;if(G){clearInterval(Q);return}try{let le=await this.connection.getTransaction(_,{commitment:"confirmed",maxSupportedTransactionVersion:0});le&&(G=!0,clearInterval(Q),ce({err:((ne=le.meta)==null?void 0:ne.err)||null}),console.log("tx status from getTransaction:",_))}catch(le){G=!0,clearInterval(Q),console.error("getTransaction timeout:",le,_)}},Wo)),se=this.connection.onSignature(_,ne=>{if(G){this.connection.removeSignatureListener(se);return}G=!0,ce(ne)},"confirmed"),this.connection.getSignatureStatus(_)};return L(),{txIds:[],signedTxs:O}}else{let M=[];for(let R=0;R<O.length;R+=1){let L=await this.connection.sendTransaction(O[R],{skipPreflight:K});M.push(L)}return{txIds:M,signedTxs:O}}}throw new Error("please provide owner in keypair format or signAllTransactions function")},extInfo:i||{}}}};import Ul from"bn.js";var jt=new Ul(1e6);var nt={BASE_HOST:"https://api-v3.raydium.io",OWNER_BASE_HOST:"https://owner-v1.raydium.io",SERVICE_BASE_HOST:"https://service.raydium.io",MONITOR_BASE_HOST:"https://monitor.raydium.io",SERVICE_1_BASE_HOST:"https://service-v1.raydium.io",SEND_TRANSACTION:"/send-transaction",FARM_ARP:"/main/farm/info",FARM_ARP_LINE:"/main/farm-apr-tv",CLMM_CONFIG:"/main/clmm-config",CPMM_CONFIG:"/main/cpmm-config",VERSION:"/main/version",CHECK_AVAILABILITY:"/v3/main/AvailabilityCheckAPI",RPCS:"/main/rpcs",INFO:"/main/info",STAKE_POOLS:"/main/stake-pools",CHAIN_TIME:"/main/chain-time",TOKEN_LIST:"/mint/list",MINT_INFO_ID:"/mint/ids",JUP_TOKEN_LIST:"https://lite-api.jup.ag/tokens/v1/tagged/verified",POOL_LIST:"/pools/info/list",POOL_SEARCH_BY_ID:"/pools/info/ids",POOL_SEARCH_MINT:"/pools/info/mint",POOL_SEARCH_LP:"/pools/info/lps",POOL_KEY_BY_ID:"/pools/key/ids",POOL_LIQUIDITY_LINE:"/pools/line/liquidity",POOL_POSITION_LINE:"/pools/line/position",FARM_INFO:"/farms/info/ids",FARM_LP_INFO:"/farms/info/lp",FARM_KEYS:"/farms/key/ids",OWNER_CREATED_FARM:"/create-pool/{owner}",OWNER_IDO:"/main/ido/{owner}",OWNER_STAKE_FARMS:"/position/stake/{owner}",OWNER_LOCK_POSITION:"/position/clmm-lock/{owner}",IDO_KEYS:"/ido/key/ids",SWAP_HOST:"https://transaction-v1.raydium.io",SWAP_COMPUTE:"/compute/",SWAP_TX:"/transaction/",MINT_PRICE:"/mint/price",MIGRATE_CONFIG:"/main/migrate-lp",PRIORITY_FEE:"/main/auto-fee",CPMM_LOCK:"https://dynamic-ipfs.raydium.io/lock/cpmm/position"},Lb=v({},nt);var nu="ray_tab_hash",cs="ray_req_hash",Gl=()=>{if(typeof window===void 0)return"";let m=sessionStorage.getItem(nu);return m||(m=`ray-${Date.now()}`,sessionStorage.setItem(nu,m)),m},Qi=async n=>{var o=n,{logCount:m=1e3,removeLastLog:e}=o,t=_e(o,["logCount","removeLastLog"]);if(typeof window===void 0)return new Promise(i=>i());let r=JSON.parse(localStorage.getItem(cs)||"[]").slice(0,m-1);e&&r.pop(),new Blob([JSON.stringify(t.data)]).size>1024&&(t.data=JSON.stringify(t.data).substring(0,200)+"..."),r.unshift(W(v({},t),{time:Date.now(),session:Gl()}));try{localStorage.setItem(cs,JSON.stringify(r))}catch{if(e){let i=!1,s=JSON.stringify(t.data).substring(0,100);for(r[0].data=s+(s.length>100?"...":"");!i;){r.pop();let u=JSON.stringify(t.data).substring(0,100);r[0].data=u+(u.length>100?"...":"");try{localStorage.setItem(cs,JSON.stringify(r)),i=!0}catch{i=!1}}return new Promise(u=>u())}return Qi(W(v({},t),{logCount:m,removeLastLog:!0}))}};import{TOKEN_2022_PROGRAM_ID as Xl,TOKEN_PROGRAM_ID as zl}from"@solana/spl-token";var ji=ye("Raydium_Api"),ls=new Map;var Yi=class{constructor({cluster:e,timeout:t,logRequests:n,logCount:o,urlConfigs:r}){this.cluster=e,this.urlConfigs=r||{},this.logCount=o||1e3,this.api=ou.create({baseURL:this.urlConfigs.BASE_HOST||nt.BASE_HOST,timeout:t}),this.api.interceptors.request.use(i=>{let{method:s,baseURL:u,url:a}=i;return ji.debug(`${s==null?void 0:s.toUpperCase()} ${u}${a}`),i},i=>(ji.error("Request failed"),Promise.reject(i))),this.api.interceptors.response.use(i=>{let{config:s,data:u,status:a}=i,{method:c,baseURL:l,url:d}=s;return n&&Qi({status:a,url:`${l}${d}`,params:s.params,data:u,logCount:this.logCount}),ji.debug(`${c==null?void 0:c.toUpperCase()} ${l}${d}  ${a}`),u},i=>{let{config:s,response:u={}}=i,{status:a}=u,{method:c,baseURL:l,url:d}=s;return n&&Qi({status:a,url:`${l}${d}`,params:s.params,data:i.message,logCount:this.logCount}),ji.error(`${c.toUpperCase()} ${l}${d} ${a||i.message}`),Promise.reject(i)})}async getClmmConfigs(){return(await this.api.get(this.urlConfigs.CLMM_CONFIG||nt.CLMM_CONFIG)).data}async getCpmmConfigs(){return(await this.api.get(this.urlConfigs.CPMM_CONFIG||nt.CPMM_CONFIG)).data}async getClmmPoolLines(e){return(await this.api.get(`${this.urlConfigs.POOL_LIQUIDITY_LINE||nt.POOL_LIQUIDITY_LINE}?pool_id=${e}`)).data}async getBlockSlotCountForSecond(e){if(!e)return 2;let n=(await ou.post(e,{id:"getRecentPerformanceSamples",jsonrpc:"2.0",method:"getRecentPerformanceSamples",params:[4]})).result.map(o=>o.numSlots);return n.reduce((o,r)=>o+r,0)/n.length/60}async getChainTimeOffset(){return(await this.api.get(this.urlConfigs.CHAIN_TIME||nt.CHAIN_TIME)).data}async getRpcs(){return this.api.get(this.urlConfigs.RPCS||nt.RPCS)}async getTokenList(){return(await this.api.get(this.urlConfigs.TOKEN_LIST||nt.TOKEN_LIST)).data}async getJupTokenList(){return(await this.api.get("",{baseURL:this.urlConfigs.JUP_TOKEN_LIST||nt.JUP_TOKEN_LIST})).map(t=>W(v({},t),{chainId:101,programId:t.tags.includes("token-2022")?Xl.toBase58():zl.toBase58()}))}async getTokenInfo(e){return(await this.api.get((this.urlConfigs.MINT_INFO_ID||nt.MINT_INFO_ID)+`?mints=${e.map(n=>n.toString()).join(",")}`)).data}async getPoolList(e={}){let{type:t="all",sort:n="liquidity",order:o="desc",page:r=0,pageSize:i=100}=e;return(await this.api.get((this.urlConfigs.POOL_LIST||nt.POOL_LIST)+`?poolType=${t}&poolSortField=${n}&sortType=${o}&page=${r}&pageSize=${i}`)).data}async fetchPoolById(e){let{ids:t}=e;return(await this.api.get((this.urlConfigs.POOL_SEARCH_BY_ID||nt.POOL_SEARCH_BY_ID)+`?ids=${t}`)).data}async fetchPoolKeysById(e){let{idList:t}=e,n=[],o=t.filter(i=>ls.has(i)?(n.push(ls.get(i)),!1):!0),r=[];return o.length&&(r=(await this.api.get((this.urlConfigs.POOL_KEY_BY_ID||nt.POOL_KEY_BY_ID)+`?ids=${o.join(",")}`)).data.filter(Boolean),r.forEach(s=>{ls.set(s.id,s)})),n.concat(r)}async fetchPoolByMints(e){let{mint1:t,mint2:n,type:o="all",sort:r="default",order:i="desc",page:s=1}=e,[u,a]=[t&&ut(t).toBase58(),n&&n!=="undefined"?ut(n).toBase58():""],[c,l]=a&&u>a?[a,u]:[u,a];return(await this.api.get((this.urlConfigs.POOL_SEARCH_MINT||nt.POOL_SEARCH_MINT)+`?mint1=${c}&mint2=${l}&poolType=${o}&poolSortField=${r}&sortType=${i}&pageSize=100&page=${s}`)).data}async fetchFarmInfoById(e){let{ids:t}=e;return(await this.api.get((this.urlConfigs.FARM_INFO||nt.FARM_INFO)+`?ids=${t}`)).data}async fetchFarmKeysById(e){let{ids:t}=e;return(await this.api.get((this.urlConfigs.FARM_KEYS||nt.FARM_KEYS)+`?ids=${t}`)).data}async fetchAvailabilityStatus(){return(await this.api.get(this.urlConfigs.CHECK_AVAILABILITY||nt.CHECK_AVAILABILITY)).data}};var Hi="please provide owner in load() initialization or you can set by calling raydium.setOwner(owner)",iu="please provide connection in load() initialization or set it by raydium.setConnection(connection)";import{PublicKey as or,SystemProgram as Tm}from"@solana/web3.js";import{AccountLayout as fo,createAssociatedTokenAccountIdempotentInstruction as ws,TOKEN_PROGRAM_ID as xn,TOKEN_2022_PROGRAM_ID as Im}from"@solana/spl-token";var ms=(...m)=>m.map(e=>{try{return typeof e=="object"?JSON.stringify(e):e}catch{return e}}).join(", "),Ne=class{constructor({scope:e,moduleName:t}){this.disabled=!1;this.scope=e,this.logger=ye(t)}createTxBuilder(e){return this.scope.checkOwner(),new qo({connection:this.scope.connection,feePayer:e||this.scope.ownerPubKey,cluster:this.scope.cluster,owner:this.scope.owner,blockhashCommitment:this.scope.blockhashCommitment,loopMultiTxStatus:this.scope.loopMultiTxStatus,api:this.scope.api,signAllTransactions:this.scope.signAllTransactions})}createSniperTxBuilder(e,t){let n=new ht(e);return new qo({connection:this.scope.connection,feePayer:t,cluster:this.scope.cluster,owner:n,blockhashCommitment:this.scope.blockhashCommitment,loopMultiTxStatus:this.scope.loopMultiTxStatus,api:this.scope.api,signAllTransactions:this.scope.signAllTransactions})}logDebug(...e){this.logger.debug(ms(e))}logInfo(...e){this.logger.info(ms(e))}logAndCreateError(...e){let t=ms(e);throw new Error(t)}checkDisabled(){(this.disabled||!this.scope)&&this.logAndCreateError("module not working")}};import{PublicKey as gm,SystemProgram as Am}from"@solana/web3.js";import Pm from"bn.js";import{createCloseAccountInstruction as wm,createInitializeAccountInstruction as km,createTransferInstruction as hm,TOKEN_PROGRAM_ID as po}from"@solana/spl-token";import{Keypair as pm,PublicKey as Pu}from"@solana/web3.js";import fm from"bn.js";import{TOKEN_PROGRAM_ID as ym}from"@solana/spl-token";function Ql(m){return m instanceof Uint8Array||m!=null&&typeof m=="object"&&m.constructor.name==="Uint8Array"}function ds(m,...e){if(!Ql(m))throw new Error("Uint8Array expected");if(e.length>0&&!e.includes(m.length))throw new Error(`Uint8Array expected of length ${e}, not of length=${m.length}`)}function ps(m,e=!0){if(m.destroyed)throw new Error("Hash instance has been destroyed");if(e&&m.finished)throw new Error("Hash#digest() has already been called")}function ru(m,e){ds(m);let t=e.outputLen;if(m.length<t)throw new Error(`digestInto() expects output buffer of length at least ${t}`)}var $i=m=>new DataView(m.buffer,m.byteOffset,m.byteLength),Yt=(m,e)=>m<<32-e|m>>>e;var gg=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;function jl(m){if(typeof m!="string")throw new Error(`utf8ToBytes expected string, got ${typeof m}`);return new Uint8Array(new TextEncoder().encode(m))}function fs(m){return typeof m=="string"&&(m=jl(m)),ds(m),m}var Zi=class{clone(){return this._cloneInto()}},Ag={}.toString;function su(m){let e=n=>m().update(fs(n)).digest(),t=m();return e.outputLen=t.outputLen,e.blockLen=t.blockLen,e.create=()=>m(),e}function Yl(m,e,t,n){if(typeof m.setBigUint64=="function")return m.setBigUint64(e,t,n);let o=BigInt(32),r=BigInt(4294967295),i=Number(t>>o&r),s=Number(t&r),u=n?4:0,a=n?0:4;m.setUint32(e+u,i,n),m.setUint32(e+a,s,n)}var au=(m,e,t)=>m&e^~m&t,uu=(m,e,t)=>m&e^m&t^e&t,Ji=class extends Zi{constructor(e,t,n,o){super(),this.blockLen=e,this.outputLen=t,this.padOffset=n,this.isLE=o,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(e),this.view=$i(this.buffer)}update(e){ps(this);let{view:t,buffer:n,blockLen:o}=this;e=fs(e);let r=e.length;for(let i=0;i<r;){let s=Math.min(o-this.pos,r-i);if(s===o){let u=$i(e);for(;o<=r-i;i+=o)this.process(u,i);continue}n.set(e.subarray(i,i+s),this.pos),this.pos+=s,i+=s,this.pos===o&&(this.process(t,0),this.pos=0)}return this.length+=e.length,this.roundClean(),this}digestInto(e){ps(this),ru(e,this),this.finished=!0;let{buffer:t,view:n,blockLen:o,isLE:r}=this,{pos:i}=this;t[i++]=128,this.buffer.subarray(i).fill(0),this.padOffset>o-i&&(this.process(n,0),i=0);for(let l=i;l<o;l++)t[l]=0;Yl(n,o-8,BigInt(this.length*8),r),this.process(n,0);let s=$i(e),u=this.outputLen;if(u%4)throw new Error("_sha2: outputLen should be aligned to 32bit");let a=u/4,c=this.get();if(a>c.length)throw new Error("_sha2: outputLen bigger than state");for(let l=0;l<a;l++)s.setUint32(4*l,c[l],r)}digest(){let{buffer:e,outputLen:t}=this;this.digestInto(e);let n=e.slice(0,t);return this.destroy(),n}_cloneInto(e){e||(e=new this.constructor),e.set(...this.get());let{blockLen:t,buffer:n,length:o,finished:r,destroyed:i,pos:s}=this;return e.length=o,e.pos=s,e.finished=r,e.destroyed=i,o%t&&e.buffer.set(n),e}};var Hl=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),Tn=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),In=new Uint32Array(64),ys=class extends Ji{constructor(){super(64,32,8,!1),this.A=Tn[0]|0,this.B=Tn[1]|0,this.C=Tn[2]|0,this.D=Tn[3]|0,this.E=Tn[4]|0,this.F=Tn[5]|0,this.G=Tn[6]|0,this.H=Tn[7]|0}get(){let{A:e,B:t,C:n,D:o,E:r,F:i,G:s,H:u}=this;return[e,t,n,o,r,i,s,u]}set(e,t,n,o,r,i,s,u){this.A=e|0,this.B=t|0,this.C=n|0,this.D=o|0,this.E=r|0,this.F=i|0,this.G=s|0,this.H=u|0}process(e,t){for(let l=0;l<16;l++,t+=4)In[l]=e.getUint32(t,!1);for(let l=16;l<64;l++){let d=In[l-15],p=In[l-2],f=Yt(d,7)^Yt(d,18)^d>>>3,y=Yt(p,17)^Yt(p,19)^p>>>10;In[l]=y+In[l-7]+f+In[l-16]|0}let{A:n,B:o,C:r,D:i,E:s,F:u,G:a,H:c}=this;for(let l=0;l<64;l++){let d=Yt(s,6)^Yt(s,11)^Yt(s,25),p=c+d+au(s,u,a)+Hl[l]+In[l]|0,y=(Yt(n,2)^Yt(n,13)^Yt(n,22))+uu(n,o,r)|0;c=a,a=u,u=s,s=i+p|0,i=r,r=o,o=n,n=p+y|0}n=n+this.A|0,o=o+this.B|0,r=r+this.C|0,i=i+this.D|0,s=s+this.E|0,u=u+this.F|0,a=a+this.G|0,c=c+this.H|0,this.set(n,o,r,i,s,u,a,c)}roundClean(){In.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}};var cu=su(()=>new ys);import{PublicKey as cm}from"@solana/web3.js";import yu,{isBN as bu}from"bn.js";import{bits as Zl,BitStructure as Sg,blob as $l,Blob as Kg,cstr as Cg,f32 as Rg,f32be as Lg,f64 as Og,f64be as Ng,greedy as Mg,Layout as Jl,ns64 as vg,ns64be as _g,nu64 as em,nu64be as Fg,offset as tm,s16 as Vg,s16be as Eg,s24 as Dg,s24be as Wg,s32 as nm,s32be as qg,s40 as Ug,s40be as Gg,s48 as Xg,s48be as zg,s8 as Qg,seq as om,struct as jg,Structure as im,u16 as rm,u16be as Yg,u24 as Hg,u24be as Zg,u32 as sm,u32be as $g,u40 as Jg,u40be as eA,u48 as tA,u48be as nA,u8 as am,UInt as um,union as oA,Union as iA,unionLayoutDiscriminator as rA,utf8 as sA}from"@solana/buffer-layout";var er=Jl,lu=im;var bs=um;var mu=am,Tt=rm;var tr=sm;var du=em;var Me=nm;var pu=om;var ke=$l;var gs=Zl,fu=tm;var qn=class extends er{constructor(t,n,o){super(t,o);this.blob=ke(t),this.signed=n}decode(t,n=0){let o=new yu(this.blob.decode(t,n),10,"le");return this.signed?o.fromTwos(this.span*8).clone():o}encode(t,n,o=0){return typeof t=="number"&&(t=new yu(t)),this.signed&&(t=t.toTwos(this.span*8)),this.blob.encode(t.toArrayLike(Buffer,"le",this.span),n,o)}},nr=class extends er{constructor(t){super(8,t);this._lower=gs(tr(),!1),this._upper=gs(tr(),!1)}addBoolean(t){this._lower.fields.length<32?this._lower.addBoolean(t):this._upper.addBoolean(t)}decode(t,n=0){let o=this._lower.decode(t,n),r=this._upper.decode(t,n+this._lower.span);return v(v({},o),r)}encode(t,n,o=0){return this._lower.encode(t,n,o)+this._upper.encode(t,n,o+this._lower.span)}};function D(m){return new bs(1,m)}function lt(m){return new bs(4,m)}function P(m){return new qn(8,!1,m)}function te(m){return new qn(16,!1,m)}function gu(m){return new qn(1,!0,m)}function mo(m){return new qn(8,!0,m)}function Au(m){return new qn(16,!0,m)}var lo=class extends er{constructor(t,n,o,r){super(t.span,r);this.layout=t,this.decoder=n,this.encoder=o}decode(t,n){return this.decoder(this.layout.decode(t,n))}encode(t,n,o){return this.layout.encode(this.encoder(t),n,o)}getSpan(t,n){return this.layout.getSpan(t,n)}};function N(m){return new lo(ke(32),e=>new cm(e),e=>e.toBuffer(),m)}function De(m){return new lo(mu(),lm,mm,m)}function lm(m){if(m===0)return!1;if(m===1)return!0;throw new Error("Invalid bool: "+m)}function mm(m){return m?1:0}function dm(m){let e=tr("length"),t=F([e,ke(fu(e,-e.span),"data")]);return new lo(t,({data:n})=>n,n=>({data:n}),m)}function Pt(m){return new lo(dm(),e=>e.toString("utf-8"),e=>Buffer.from(e,"utf-8"),m)}var As=class extends lu{decode(e,t){return super.decode(e,t)}};function F(m,e,t){return new As(m,e,t)}function j(m,e,t){let n,o=typeof e=="number"?e:bu(e)?e.toNumber():new Proxy(e,{get(r,i){if(!n){let s=Reflect.get(r,"count");n=bu(s)?s.toNumber():s,Reflect.set(r,"count",n)}return Reflect.get(r,i)},set(r,i,s){return i==="count"&&(n=s),Reflect.set(r,i,s)}});return pu(m,o,t)}var Un=F([N("mint"),N("owner"),P("amount"),lt("delegateOption"),N("delegate"),D("state"),lt("isNativeOption"),P("isNative"),P("delegatedAmount"),lt("closeAuthorityOption"),N("closeAuthority")]);var SA=ye("Raydium_Util");function wu({owner:m,solAccountResp:e,tokenAccountResp:t}){let n=[],o=[];for(let{pubkey:r,account:i}of t.value){let s=Un.decode(i.data),{mint:u,amount:a}=s;n.push({publicKey:r,mint:u,amount:a,isAssociated:Z(m,u,i.owner).publicKey.equals(r),isNative:!1,programId:i.owner}),o.push({pubkey:r,accountInfo:s,programId:i.owner})}return e&&n.push({mint:Pu.default,amount:new fm(String(e.lamports)),isNative:!0,programId:e.owner}),{tokenAccounts:n,tokenAccountRawInfos:o}}function Ge({fromPublicKey:m,programId:e=ym,assignSeed:t}){let n=t?btoa(t).slice(0,32):pm.generate().publicKey.toBase58().slice(0,32);return{publicKey:bm(m,n,e),seed:n}}function bm(m,e,t){let n=Buffer.concat([m.toBuffer(),Buffer.from(e),t.toBuffer()]),o=cu(n);return new Pu(o)}function Ps(m){let{mint:e,tokenAccount:t,owner:n,programId:o=po}=m;return km(t,e,n,o)}function dn(m){let{tokenAccount:e,payer:t,multiSigners:n=[],owner:o,programId:r=po}=m;return wm(e,t,o,n,r)}async function Bn(m){let{connection:e,amount:t,commitment:n,payer:o,owner:r,skipCloseAccount:i}=m,s=await e.getMinimumBalanceForRentExemption(Un.span,n),u=$(t).add(new Pm(s)),a=Ge({fromPublicKey:o,programId:po});return{addresses:{newAccount:a.publicKey},signers:[],instructions:[Am.createAccountWithSeed({fromPubkey:o,basePubkey:o,seed:a.seed,newAccountPubkey:a.publicKey,lamports:u.toNumber(),space:Un.span,programId:po}),Ps({mint:new gm(ct.address),tokenAccount:a.publicKey,owner:r,programId:po})],instructionTypes:[q.CreateAccount,q.InitAccount],endInstructionTypes:i?[]:[q.CloseAccount],endInstructions:i?[]:[dn({tokenAccount:a.publicKey,payer:o,owner:r})]}}function ku({source:m,destination:e,owner:t,amount:n,multiSigners:o=[],tokenProgram:r=po}){return hm(m,e,t,BigInt(String(n)),o,r)}var Uo=class extends Ne{constructor(t){super(t);this._tokenAccounts=[];this._tokenAccountRawInfos=[];this._accountListener=[];this._clientOwnedToken=!1;this._notSubscribeAccountChange=!1;this._accountFetchTime=0;let{tokenAccounts:n,tokenAccountRawInfos:o,notSubscribeAccountChange:r}=t;this._tokenAccounts=n||[],this._tokenAccountRawInfos=o||[],this._notSubscribeAccountChange=r!=null?r:!0,this._clientOwnedToken=!!(n||o)}get tokenAccounts(){return this._tokenAccounts}get tokenAccountRawInfos(){return this._tokenAccountRawInfos}set notSubscribeAccountChange(t){this._notSubscribeAccountChange=t}updateTokenAccount({tokenAccounts:t,tokenAccountRawInfos:n}){return t&&(this._tokenAccounts=t),n&&(this._tokenAccountRawInfos=n),this._accountChangeListenerId&&this.scope.connection.removeAccountChangeListener(this._accountChangeListenerId),this._accountChangeListenerId=void 0,this._clientOwnedToken=!0,this}addAccountChangeListener(t){return this._accountListener.push(t),this}removeAccountChangeListener(t){return this._accountListener=this._accountListener.filter(n=>n!==t),this}getAssociatedTokenAccount(t,n){return Z(this.scope.ownerPubKey,t,n).publicKey}getAssociatedTokenAccountByOwner(t,n,o){return Z(t,n,o).publicKey}resetTokenAccounts(){this._clientOwnedToken||(this._tokenAccounts=[],this._tokenAccountRawInfos=[])}async fetchWalletTokenAccounts(t){if(this._clientOwnedToken||!(t!=null&&t.forceUpdate)&&this._tokenAccounts.length&&Date.now()-this._accountFetchTime<(this._notSubscribeAccountChange?1e3*5:1e3*60*3))return{tokenAccounts:this._tokenAccounts,tokenAccountRawInfos:this._tokenAccountRawInfos};this.scope.checkOwner();let o=v(v({},{}),t),[r,i,s]=await Promise.all([this.scope.connection.getAccountInfo(this.scope.ownerPubKey,o.commitment),this.scope.connection.getTokenAccountsByOwner(this.scope.ownerPubKey,{programId:xn},o.commitment),this.scope.connection.getTokenAccountsByOwner(this.scope.ownerPubKey,{programId:Im},o.commitment)]),{tokenAccounts:u,tokenAccountRawInfos:a}=wu({owner:this.scope.ownerPubKey,solAccountResp:r,tokenAccountResp:{context:i.context,value:[...i.value,...s.value]}});return this._tokenAccounts=u,this._tokenAccountRawInfos=a,this._accountFetchTime=Date.now(),this._notSubscribeAccountChange||(this._accountChangeListenerId&&this.scope.connection.removeAccountChangeListener(this._accountChangeListenerId),this._accountChangeListenerId=this.scope.connection.onAccountChange(this.scope.ownerPubKey,()=>{this.fetchWalletTokenAccounts({forceUpdate:!0}),this._accountListener.forEach(c=>c({tokenAccounts:this._tokenAccounts,tokenAccountRawInfos:this._tokenAccountRawInfos}))},{commitment:t==null?void 0:t.commitment})),{tokenAccounts:u,tokenAccountRawInfos:a}}clearAccountChangeCkb(){this._accountChangeListenerId!==void 0&&this.scope.connection.removeAccountChangeListener(this._accountChangeListenerId)}async getCreatedTokenAccount({mint:t,programId:n=xn,associatedOnly:o=!0}){await this.fetchWalletTokenAccounts();let r=this._tokenAccounts.filter(({mint:s})=>s==null?void 0:s.equals(t)).sort((s,u)=>s.amount.lt(u.amount)?1:-1),i=this.getAssociatedTokenAccount(t,n);for(let s of r){let{publicKey:u}=s;if(u&&(!o||o&&i.equals(u)))return u}}async getOrCreateTokenAccount(t){var y,b,g,A;await this.fetchWalletTokenAccounts();let{mint:n,createInfo:o,associatedOnly:r,owner:i,notUseTokenAccount:s=!1,skipCloseAccount:u=!1,checkCreateATAOwner:a=!1,assignSeed:c}=t,l=new or(t.tokenProgram||xn),d=this.getAssociatedTokenAccount(n,new or(l)),p=(s?[]:this.tokenAccountRawInfos).filter(h=>h.accountInfo.mint.equals(n)&&(!r||h.pubkey.equals(d))).sort((h,T)=>h.accountInfo.amount.lt(T.accountInfo.amount)?1:-1);if(o===void 0||p.length>0)return p.length>0?{account:p[0].pubkey}:{};let f={instructions:[],endInstructions:[],signers:[],instructionTypes:[],endInstructionTypes:[]};if(r){let h=ws(i,d,i,n,l),T=this.tokenAccountRawInfos.find(k=>k.pubkey.equals(d));if(a){let k=await this.scope.connection.getAccountInfo(d);if(k===null)(y=f.instructions)==null||y.push(h),f.instructionTypes.push(q.CreateATA);else if(!(k.owner.equals(l)&&fo.decode(k.data).mint.equals(n)&&fo.decode(k.data).owner.equals(i)))throw Error(`create ata check error -> mint: ${n.toString()}, ata: ${d.toString()}`)}else T===void 0&&(f.instructions.push(h),f.instructionTypes.push(q.CreateATA));if(n.equals(Y)&&o.amount){let k=await Bn({connection:this.scope.connection,owner:this.scope.ownerPubKey,payer:o.payer||this.scope.ownerPubKey,amount:(b=o.amount)!=null?b:0,skipCloseAccount:u});f.instructions.push(...k.instructions||[]),f.endInstructions.push(...k.endInstructions||[]),f.instructionTypes.push(...k.instructionTypes||[]),f.endInstructionTypes.push(...k.endInstructionTypes||[]),o.amount&&(f.instructions.push(ku({source:k.addresses.newAccount,destination:d,owner:this.scope.ownerPubKey,amount:o.amount,tokenProgram:xn})),f.instructionTypes.push(q.TransferAmount))}return!u&&T===void 0&&(f.endInstructions.push(dn({owner:i,payer:o.payer||i,tokenAccount:d,programId:l})),f.endInstructionTypes.push(q.CloseAccount)),{account:d,instructionParams:f}}else{let h=Ge({fromPublicKey:i,programId:l,assignSeed:c}),T=await this.scope.connection.getMinimumBalanceForRentExemption(fo.span),k=Tm.createAccountWithSeed({fromPubkey:i,basePubkey:i,seed:h.seed,newAccountPubkey:h.publicKey,lamports:T+Number((A=(g=o.amount)==null?void 0:g.toString())!=null?A:0),space:fo.span,programId:l});return f.instructions.push(k,Ps({mint:n,tokenAccount:h.publicKey,owner:this.scope.ownerPubKey,programId:l})),f.instructionTypes.push(q.CreateAccount),f.instructionTypes.push(q.InitAccount),u||(f.endInstructions.push(dn({owner:i,payer:o.payer||i,tokenAccount:h.publicKey,programId:l})),f.endInstructionTypes.push(q.CloseAccount)),{account:h.publicKey,instructionParams:f}}}async checkOrCreateAta({mint:t,programId:n=xn,autoUnwrapWSOLToSOL:o}){var u;await this.fetchWalletTokenAccounts();let r=(u=this.scope.account.tokenAccounts.find(({mint:a})=>(a==null?void 0:a.toBase58())===t.toBase58()))==null?void 0:u.publicKey,i=this.scope.ownerPubKey,s={};if(!r){let a=this.getAssociatedTokenAccount(t,n),c=await ws(i,a,i,t,n);s.instructions=[c],s.instructionTypes=[q.CreateATA],r=a}return o&&Y.toBase58()===t.toBase58()&&(s.endInstructions=[dn({owner:i,payer:i,tokenAccount:r,programId:n})],s.endInstructionTypes=[q.CloseAccount]),{pubKey:r,newInstructions:s}}async handleTokenAccount(t){let{side:n,amount:o,mint:r,programId:i=xn,tokenAccount:s,payer:u=this.scope.ownerPubKey,bypassAssociatedCheck:a,skipCloseAccount:c,checkCreateATAOwner:l}=t,d=this.getAssociatedTokenAccount(r,i);if(new or(Y).equals(r)){let p=await Bn({connection:this.scope.connection,owner:this.scope.ownerPubKey,payer:u,amount:o,skipCloseAccount:c});return v({tokenAccount:p.addresses.newAccount},p)}else if(!s||n==="out"&&!d.equals(s)&&!a){let p=[],f=ws(this.scope.ownerPubKey,d,this.scope.ownerPubKey,r,i);if(l){let y=await this.scope.connection.getAccountInfo(d);if(y===null)p.push(f);else if(!(y.owner.equals(xn)&&fo.decode(y.data).mint.equals(r)&&fo.decode(y.data).owner.equals(this.scope.ownerPubKey)))throw Error(`create ata check error -> mint: ${r.toString()}, ata: ${d.toString()}`)}else p.push(f);return{tokenAccount:d,instructions:p,instructionTypes:[q.CreateATA]}}return{tokenAccount:s}}async processTokenAccount(t){let{mint:n,programId:o=xn,amount:r,useSOLBalance:i,handleTokenAccount:s,feePayer:u}=t,a,c=this.createTxBuilder(u);if(n.equals(new or(Y))&&i){let l=await this.handleTokenAccount({side:"in",amount:r||0,mint:n,bypassAssociatedCheck:!0,programId:o}),{tokenAccount:p}=l,f=_e(l,["tokenAccount"]);a=p,c.addInstruction(f)}else if(a=await this.getCreatedTokenAccount({mint:n,associatedOnly:!1,programId:o}),!a&&s){let d=await this.scope.account.handleTokenAccount({side:"in",amount:0,mint:n,bypassAssociatedCheck:!0,programId:o}),{tokenAccount:p}=d,f=_e(d,["tokenAccount"]);a=p,c.addInstruction(f)}return v({tokenAccount:a},c.AllTxData)}};import{PublicKey as Te,SystemProgram as Wm}from"@solana/web3.js";import{createAssociatedTokenAccountIdempotentInstruction as Fu}from"@solana/spl-token";import qm from"decimal.js";import{PublicKey as Ss}from"@solana/web3.js";var ks=F([D("instruction")]),hs=F([D("instruction")]),Bm=F([P("rewardState"),P("rewardOpenTime"),P("rewardEndTime"),P("rewardLastUpdateTime"),P("totalReward"),P("totalRewardEmissioned"),P("rewardClaimed"),P("rewardPerSecond"),te("accRewardPerShare"),N("rewardVault"),N("rewardMint"),N("rewardSender"),P("rewardType"),j(P(),15,"padding")]),xm=F([P("state"),P("nonce"),N("lpVault"),N("rewardVault"),N(),N(),P(),P(),P("totalReward"),te("perShareReward"),P("lastSlot"),P("perSlotReward")]),Sm=F([P("state"),P("nonce"),N("lpVault"),N("rewardVaultA"),P("totalRewardA"),te("perShareRewardA"),P("perSlotRewardA"),D("option"),N("rewardVaultB"),ke(7),P("totalRewardB"),te("perShareRewardB"),P("perSlotRewardB"),P("lastSlot"),N()]),Km=F([P(),P("state"),P("nonce"),P("validRewardTokenNum"),te("rewardMultiplier"),P("rewardPeriodMax"),P("rewardPeriodMin"),P("rewardPeriodExtend"),N("lpMint"),N("lpVault"),j(Bm,5,"rewardInfos"),N("creator"),N(),j(P(),32,"padding")]),Cm=new Proxy(xm,{get(m,e,t){return e==="decode"?(...n)=>{let o=m.decode(...n);return W(v({},o),{version:3,rewardInfos:[{rewardVault:o.rewardVault,totalReward:o.totalReward,perSlotReward:o.perSlotReward,perShareReward:o.perShareReward}]})}:Reflect.get(m,e,t)}}),Rm=new Proxy(Sm,{get(m,e,t){return e==="decode"?(...n)=>{let o=m.decode(...n);return W(v({},o),{version:5,rewardInfos:[{rewardVault:o.rewardVaultA,totalReward:o.totalRewardA,perSlotReward:o.perSlotRewardA,perShareReward:o.perShareRewardA},{rewardVault:o.rewardVaultB,totalReward:o.totalRewardB,perSlotReward:o.perSlotRewardB,perShareReward:o.perShareRewardB}]})}:Reflect.get(m,e,t)}}),ir=new Proxy(Km,{get(m,e,t){return e==="decode"?(...n)=>{let o=m.decode(...n);return W(v({},o),{version:6,rewardInfos:o.rewardInfos.map(r=>{var i;return W(v({},r),{rewardType:((i=Object.entries(Sn).find(s=>String(s[1])===r.rewardType.toString()))!=null?i:["Standard SPL"])[0]})})})}:Reflect.get(m,e,t)}}),Lm=F([P("isSet"),P("rewardPerSecond"),P("rewardOpenTime"),P("rewardEndTime"),P("rewardType")]),Ts=F([D("instruction"),P("nonce"),j(Lm,5,"rewardTimeInfo")]),Is=F([D("instruction"),P("rewardReopenTime"),P("rewardEndTime"),P("rewardPerSecond")]),Bs=F([D("instruction"),P("isSet"),P("rewardPerSecond"),P("rewardOpenTime"),P("rewardEndTime"),P("rewardType")]),rP=F([P("state"),N("id"),N("owner"),P("deposited"),j(P(),1,"rewardDebts")]),xs=F([P("state"),N("id"),N("owner"),P("deposited"),j(te(),1,"rewardDebts"),P(""),P("voteLockedBalance"),j(P(),15)]),sP=F([P("state"),N("id"),N("owner"),P("deposited"),j(P(),2,"rewardDebts")]),hu=F([P("state"),N("id"),N("owner"),P("deposited"),j(te(),2,"rewardDebts"),j(P(),17)]),Tu=F([P(),P("state"),N("id"),N("owner"),P("deposited"),j(te(),5,"rewardDebts"),j(P(),16)]),It=F([D("instruction"),P("amount")]),Om=F([N("mint"),N("grantAuthority"),P("baselineVoteWeightScaledFactor"),P("maxExtraLockupVoteWeightScaledFactor"),P("lockupSaturationSecs"),gu("digitShift"),j(D(),7,"reserved1"),j(P(),7,"reserved2")]),Nm=F([ke(8),N("governanceProgramId"),N("realm"),N("realmGoverningTokenMint"),N("realmAuthority"),j(D(),32,"reserved1"),j(Om,4,"votingMints"),mo("timeOffset"),D("bump"),j(D(),7,"reserved2"),j(P(),11,"reserved3")]),Mm=F([mo("startTime"),mo("endTime"),D("kind"),j(D(),15,"reserved")]),vm=F([j(Mm,1,"lockup"),P("amountDeposited_native"),P("amountInitiallyLockedNative"),De("isUsed"),De("allowClawback"),D("votingMintConfigIdx"),j(D(),29,"reserved")]),_m=F([ke(8),N("voterAuthority"),N("registrar"),j(vm,32,"deposits"),D("voterBump"),D("voterWweightRecordBump"),j(D(),94,"reserved")]);import{NATIVE_MINT as yP}from"@solana/spl-token";var bP=ye("Raydium_farm_config"),Iu=new Ss("4k3Dyjzvzp8eMZWUXbBCjEvwSkkk59S5iCNLY3QrkX6R"),Bu=new Ss("FrspKwj8i3pNmKwXreTveC4fu7KL5ZbGeXdZBe2XViu1");var gP=new Ss("3TRTX4dXUpp2eqxi3tvQDFYUV7SdDJjcPE3Y4mbtftaX");var xu={3:xs,5:hu,6:Tu},Ks=m=>[3,4,5,6].indexOf(m)!==-1,Cs=m=>{var i;let{version:e,rewardInfos:t,rewardTokenAccountsPublicKeys:n}=m,o=`rewardInfo:${JSON.stringify(t)}, rewardAccount:${JSON.stringify(n)}`,r={3:()=>{if(t.length!==1||n.length!==1)return`rewardInfos or rewardTokenAccounts lengths not equal 1: ${o}`},5:()=>{if(t.length!==n.length)return`rewardInfos and rewardTokenAccounts lengths not equal: ${o}`},6:()=>{if(!n.length||t.length!==n.length)return`no rewardTokenAccounts or rewardInfos and rewardTokenAccounts lengths not equal: ${o}`}};return(i=r[e])==null?void 0:i.call(r)},Sn={"Standard SPL":0,"Option tokens":1},Lt={[Ya.toString()]:3,[Ha.toString()]:4,[Za.toString()]:5,[_o.toString()]:6,[cn.FARM_PROGRAM_ID_V3.toString()]:3,[cn.FARM_PROGRAM_ID_V4.toString()]:4,[cn.FARM_PROGRAM_ID_V5.toString()]:5,[cn.FARM_PROGRAM_ID_V6.toString()]:6};import{PublicKey as pe,SystemProgram as Cu,SYSVAR_CLOCK_PUBKEY as zo,SYSVAR_RENT_PUBKEY as Em,TransactionInstruction as Nt}from"@solana/web3.js";import Ru from"bn.js";import{ASSOCIATED_TOKEN_PROGRAM_ID as YP,createAssociatedTokenAccountIdempotentInstruction as HP,TOKEN_PROGRAM_ID as pn}from"@solana/spl-token";import Fm from"bn.js";var Vm=ye("Raydium.farm.util");function Go({programId:m,poolId:e,mint:t,type:n}){let{publicKey:o}=ae([e.toBuffer(),t.toBuffer(),Buffer.from(n==="lpVault"?"lp_vault_associated_seed":n==="rewardVault"?"reward_vault_associated_seed":"","utf-8")],m);return o}function Ot({programId:m,poolId:e,owner:t,version:n}){let{publicKey:o}=ae([e.toBuffer(),t.toBuffer(),Buffer.from(n===6?"farmer_info_associated_seed":"staker_info_v2_associated_seed","utf-8")],m);return o}var Su=({programId:m,poolId:e})=>ae([e.toBuffer()],m);function Ku(m){return{isSet:new Fm(1),rewardPerSecond:$(m.perSecond),rewardOpenTime:$(m.openTime),rewardEndTime:$(m.endTime),rewardType:$(Sn[m.rewardType])}}function Rs(m){return $(m.endTime).sub($(m.openTime)).mul($(m.perSecond))}function Xo(m){let e=xu[m];return e||Vm.logWithError("invalid version",m),e}var Dm=ye("Raydium_farm_instruction"),aw={voterStakeRegistryCreateVoter:Buffer.from([6,24,245,52,243,255,148,25]),voterStakeRegistryCreateDepositEntry:Buffer.from([185,131,167,186,159,125,19,67]),voterStakeRegistryDeposit:Buffer.from([242,35,198,137,82,225,242,182]),voterStakeRegistryWithdraw:Buffer.from([183,18,70,156,148,109,161,34]),voterStakeRegistryUpdateVoterWeightRecord:Buffer.from([45,185,3,36,109,190,115,169])};function Qo(m){let{version:e,id:t,ledger:n,programId:o,owner:r}=m,i={3:9,5:10}[e];i||Dm.logWithError(`invalid farm pool version: ${e}`);let s=Buffer.alloc(ks.span);ks.encode({instruction:i},s);let u=[x({pubkey:t}),x({pubkey:n}),x({pubkey:r,isWritable:!1}),x({pubkey:Cu.programId,isWritable:!1}),x({pubkey:Em,isWritable:!1})];return{instruction:new Nt({programId:o,keys:u,data:s}),instructionType:q.FarmV3CreateLedger}}function Lu(m){var n;let e=Buffer.alloc(Ts.span);Ts.encode({instruction:0,nonce:new Ru(m.nonce),rewardTimeInfo:m.rewardInfoConfig},e);let t=[...jr,x({pubkey:m.farmId}),x({pubkey:m.farmAuthority,isWritable:!1}),x({pubkey:m.lpVault}),x({pubkey:m.lpMint,isWritable:!1}),x({pubkey:m.lockVault}),x({pubkey:m.lockMint,isWritable:!1}),x({pubkey:(n=m.lockUserAccount)!=null?n:et}),x({pubkey:m.owner,isWritable:!1,isSigner:!0})];for(let o of m.rewardInfo)t.push(x({pubkey:o.rewardMint,isWritable:!1}),x({pubkey:o.rewardVault}),x({pubkey:o.userRewardToken}));return{instruction:new Nt({programId:m.programId,keys:t,data:e}),instructionType:q.FarmV6Create}}function Ou(m){let e=Buffer.alloc(hs.span);hs.encode({instruction:5},e);let t=[x({pubkey:pn,isWritable:!1}),x({pubkey:m.id}),x({pubkey:m.authority,isWritable:!1}),x({pubkey:m.lpVault,isWritable:!1}),x({pubkey:m.rewardVault}),x({pubkey:m.userRewardToken}),x({pubkey:m.owner,isWritable:!1,isSigner:!0})];return{instruction:new Nt({programId:m.programId,keys:t,data:e}),instructionType:q.FarmV6CreatorWithdraw}}function Ls({payer:m,rewardVault:e,userRewardTokenPub:t,farmKeys:n,rewardInfo:o}){let r=Buffer.alloc(Is.span);Is.encode({instruction:3,rewardReopenTime:$(o.openTime),rewardEndTime:$(o.endTime),rewardPerSecond:$(o.perSecond)},r);let i=[x({pubkey:pn,isWritable:!1}),x({pubkey:n.id}),x({pubkey:n.lpVault,isWritable:!1}),x({pubkey:e}),x({pubkey:t}),x({pubkey:m,isWritable:!1,isSigner:!0})];return new Nt({programId:n.programId,keys:i,data:r})}function Os({payer:m,userRewardTokenPub:e,farmKeys:t,rewardVault:n,rewardInfo:o}){let r=Buffer.alloc(Bs.span);Bs.encode({instruction:4,isSet:new Ru(1),rewardPerSecond:$(o.perSecond),rewardOpenTime:$(o.openTime),rewardEndTime:$(o.endTime),rewardType:$(Sn[o.rewardType])},r);let i=[...jr,x({pubkey:t.id}),x({pubkey:t.authority,isWritable:!1}),x({pubkey:o.mint,isWritable:!1}),x({pubkey:n}),x({pubkey:e}),x({pubkey:m,isWritable:!1,isSigner:!0})];return new Nt({programId:t.programId,keys:i,data:r})}function jo(m){let{farmInfo:e,farmKeys:t,lpAccount:n,rewardAccounts:o,owner:r,amount:i}=m,[s,u]=[new pe(e.programId),new pe(e.id)],a=Ot({programId:s,poolId:u,owner:r,version:6}),c=Buffer.alloc(It.span);It.encode({instruction:2,amount:$(i)},c);let l=[x({pubkey:pn,isWritable:!1}),x({pubkey:u}),x({pubkey:new pe(t.authority),isWritable:!1}),x({pubkey:new pe(t.lpVault)}),x({pubkey:a}),x({pubkey:r,isWritable:!1,isSigner:!0}),x({pubkey:n})];for(let d=0;d<t.rewardInfos.length;d++)l.push(x({pubkey:new pe(t.rewardInfos[d].vault)})),l.push(x({pubkey:o[d]}));return new Nt({programId:s,keys:l,data:c})}function Yo(m){let{farmInfo:e,farmKeys:t,lpAccount:n,rewardAccounts:o,owner:r,amount:i,userAuxiliaryLedgers:s}=m,[u,a]=[new pe(e.programId),new pe(e.id)],c=Ot({programId:u,poolId:a,owner:r,version:5}),l=Buffer.alloc(It.span);It.encode({instruction:12,amount:$(i)},l);let d=[x({pubkey:a}),x({pubkey:new pe(t.authority),isWritable:!1}),x({pubkey:c}),x({pubkey:r,isWritable:!1,isSigner:!0}),x({pubkey:n}),x({pubkey:new pe(t.lpVault)}),x({pubkey:o[0]}),x({pubkey:new pe(t.rewardInfos[0].vault)}),x({pubkey:zo,isWritable:!1}),x({pubkey:pn,isWritable:!1})];for(let p=1;p<t.rewardInfos.length;p++)d.push(x({pubkey:o[p]})),d.push(x({pubkey:new pe(t.rewardInfos[p].vault)}));if(s)for(let p of s)d.push(x({pubkey:p}));return new Nt({programId:u,keys:d,data:l})}function Nu(m){let{farmInfo:e,farmKeys:t,lpAccount:n,rewardAccounts:o,owner:r,amount:i,userAuxiliaryLedgers:s}=m,[u,a]=[new pe(e.programId),new pe(e.id)],c=F([D("instruction"),P("amount")]),l=[x({pubkey:a}),x({pubkey:new pe(t.authority),isWritable:!1}),x({pubkey:s[0]}),x({pubkey:r,isSigner:!0,isWritable:!1}),x({pubkey:n}),x({pubkey:new pe(t.lpVault)}),x({pubkey:o[0]}),x({pubkey:new pe(t.rewardInfos[0].vault)}),x({pubkey:zo,isWritable:!1}),x({pubkey:pn,isWritable:!1}),x({pubkey:o[1]}),x({pubkey:new pe(t.rewardInfos[1].vault)})],d=Buffer.alloc(c.span);return c.encode({instruction:2,amount:i},d),new Nt({keys:l,programId:u,data:d})}function Ho(m){let{farmInfo:e,farmKeys:t,lpAccount:n,rewardAccounts:o,owner:r,amount:i,userAuxiliaryLedgers:s}=m,[u,a]=[new pe(e.programId),new pe(e.id)],c=Ot({programId:u,poolId:a,owner:r,version:3}),l=Buffer.alloc(It.span);It.encode({instruction:11,amount:$(i)},l);let d=[x({pubkey:a}),x({pubkey:new pe(t.authority),isWritable:!1}),x({pubkey:c}),x({pubkey:r,isWritable:!1,isSigner:!0}),x({pubkey:n}),x({pubkey:new pe(t.lpVault)}),x({pubkey:o[0]}),x({pubkey:new pe(t.rewardInfos[0].vault)}),x({pubkey:zo,isWritable:!1}),x({pubkey:pn,isWritable:!1})];if(s)for(let p of s)d.push(x({pubkey:p}));return new Nt({programId:u,keys:d,data:l})}function Mu(m){let{farmInfo:e,farmKeys:t,lpAccount:n,rewardAccounts:o,owner:r,amount:i,userAuxiliaryLedgers:s}=m,[u,a]=[new pe(e.programId),new pe(e.id)],c=Ot({programId:u,poolId:a,owner:r,version:3}),l=Buffer.alloc(It.span);It.encode({instruction:10,amount:$(i)},l);let d=[x({pubkey:a}),x({pubkey:new pe(t.authority),isWritable:!1}),x({pubkey:c}),x({pubkey:r,isWritable:!1,isSigner:!0}),x({pubkey:n}),x({pubkey:new pe(t.lpVault)}),x({pubkey:o[0]}),x({pubkey:new pe(t.rewardInfos[0].vault)}),x({pubkey:zo,isWritable:!1}),x({pubkey:pn,isWritable:!1})];if(s)for(let p of s)d.push(x({pubkey:p}));return new Nt({programId:u,keys:d,data:l})}function vu(m){let{farmInfo:e,farmKeys:t,lpAccount:n,rewardAccounts:o,owner:r,amount:i,userAuxiliaryLedgers:s}=m,[u,a]=[new pe(e.programId),new pe(e.id)],c=Ot({programId:u,poolId:a,owner:r,version:5}),l=Buffer.alloc(It.span);It.encode({instruction:11,amount:$(i)},l);let d=[x({pubkey:a}),x({pubkey:new pe(t.authority),isWritable:!1}),x({pubkey:c}),x({pubkey:r,isWritable:!1,isSigner:!0}),x({pubkey:n}),x({pubkey:new pe(t.lpVault)}),x({pubkey:o[0]}),x({pubkey:new pe(t.rewardInfos[0].vault)}),x({pubkey:zo,isWritable:!1}),x({pubkey:pn,isWritable:!1})];for(let p=1;p<t.rewardInfos.length;p++)d.push(x({pubkey:o[p]})),d.push(x({pubkey:new pe(t.rewardInfos[p].vault)}));if(s)for(let p of s)d.push(x({pubkey:p}));return new Nt({programId:u,keys:d,data:l})}function _u(m){let{farmInfo:e,farmKeys:t,lpAccount:n,rewardAccounts:o,owner:r,amount:i}=m,[s,u]=[new pe(e.programId),new pe(e.id)],a=Ot({programId:s,poolId:u,owner:r,version:6}),c=Buffer.alloc(It.span);It.encode({instruction:1,amount:$(i)},c);let l=[x({pubkey:pn,isWritable:!1}),x({pubkey:Cu.programId,isWritable:!1}),x({pubkey:u}),x({pubkey:new pe(t.authority),isWritable:!1}),x({pubkey:new pe(t.lpVault)}),x({pubkey:a}),x({pubkey:r,isWritable:!1,isSigner:!0}),x({pubkey:n})];for(let d=0;d<t.rewardInfos.length;d++)l.push(x({pubkey:new pe(t.rewardInfos[d].vault)})),l.push(x({pubkey:o[d]}));return new Nt({programId:s,keys:l,data:c})}var Zo=class extends Ne{async _getUserRewardInfo({payer:e,rewardInfo:t}){if(t.mint.equals(et)){let n=await Bn({connection:this.scope.connection,owner:this.scope.ownerPubKey,payer:e,amount:Rs(W(v({},t),{openTime:t.openTime.toString(),endTime:t.endTime.toString()}))});return{rewardPubKey:n.addresses.newAccount,newInstruction:n}}return{rewardPubKey:await this.scope.account.getCreatedTokenAccount({mint:t.mint,associatedOnly:!1})}}async create({poolInfo:e,rewardInfos:t,payer:n,programId:o=_o,txVersion:r,feePayer:i,lockProgram:s}){var S,B;this.checkDisabled(),this.scope.checkOwner();let a={lpMint:new Te(e.lpMint.address),lockInfo:{lockMint:(S=s==null?void 0:s.mint)!=null?S:Iu,lockVault:(B=s==null?void 0:s.vault)!=null?B:Bu},version:6,rewardInfos:t,programId:o},c=this.createTxBuilder(i),l=n!=null?n:this.scope.ownerPubKey,d=Ge({fromPublicKey:l,programId:a.programId}),p=await this.scope.connection.getMinimumBalanceForRentExemption(ir.span);c.addInstruction({instructions:[Wm.createAccountWithSeed({fromPubkey:l,basePubkey:l,seed:d.seed,newAccountPubkey:d.publicKey,lamports:p,space:ir.span,programId:a.programId})]});let{publicKey:f,nonce:y}=Su({programId:new Te(a.programId),poolId:d.publicKey}),b=Go({programId:a.programId,poolId:d.publicKey,mint:a.lpMint,type:"lpVault"}),g=[],A=[];for(let K of a.rewardInfos){K.openTime>=K.endTime&&this.logAndCreateError("start time error","rewardInfo.rewardOpenTime",K.openTime.toString()),isNaN(Sn[K.rewardType])&&this.logAndCreateError("rewardType error",K.rewardType),Number(K.perSecond)<=0&&this.logAndCreateError("rewardPerSecond error",K.perSecond),g.push(Ku(K));let{rewardPubKey:I,newInstruction:C}=await this._getUserRewardInfo({rewardInfo:K,payer:l});C&&c.addInstruction(C),I||this.logAndCreateError("cannot found target token accounts",this.scope.account.tokenAccounts);let O=K.mint.equals(et)?new Te(ct.address):K.mint;A.push({rewardMint:O,rewardVault:Go({programId:a.programId,poolId:d.publicKey,mint:O,type:"rewardVault"}),userRewardToken:I})}let{account:h,instructionParams:T}=await this.scope.account.getOrCreateTokenAccount({mint:new Te(a.lockInfo.lockMint),owner:this.scope.ownerPubKey,skipCloseAccount:!1,createInfo:{payer:this.scope.ownerPubKey,amount:0},associatedOnly:!1});T&&c.addInstruction(T),h||this.logAndCreateError("cannot found lock vault","tokenAccounts",this.scope.account.tokenAccounts);let{instruction:k,instructionType:w}=Lu({farmId:d.publicKey,owner:this.scope.ownerPubKey,farmAuthority:f,lpVault:b,lpMint:a.lpMint,lockVault:a.lockInfo.lockVault,lockMint:a.lockInfo.lockMint,lockUserAccount:h,programId:a.programId,rewardInfo:A,rewardInfoConfig:g,nonce:y});return c.addInstruction({instructions:[k],instructionTypes:[w]}).versionBuild({txVersion:r,extInfo:{farmId:d.publicKey,farmAuthority:f,lpVault:b,lockUserAccount:h,nonce:y}})}async restartReward({farmInfo:e,payer:t,newRewardInfo:n,txVersion:o,feePayer:r}){var g;let i=Lt[e.programId];i!==6&&this.logAndCreateError("invalid farm version ",i);let s=rt((await this.scope.api.fetchFarmKeysById({ids:e.id}))[0]),u={id:s.id,rewardInfos:e.rewardInfos,lpVault:s.lpVault,programId:s.programId};n.openTime>=n.endTime&&this.logAndCreateError("start time error","newRewardInfo",n);let a=t||this.scope.ownerPubKey,c=n.mint.equals(et)?new Te(ct.address):n.mint,l=u.rewardInfos.findIndex(A=>new Te(A.mint.address).equals(c)),d=s.rewardInfos[l];d||this.logAndCreateError("configuration does not exist","rewardMint",c);let p=(g=d.vault)!=null?g:et,f=this.createTxBuilder(r),{rewardPubKey:y,newInstruction:b}=await this._getUserRewardInfo({rewardInfo:n,payer:a});return b&&f.addInstruction(b),y||this.logAndCreateError("cannot found target token accounts",this.scope.account.tokenAccounts),f.addInstruction({instructions:[Ls({payer:this.scope.ownerPubKey,rewardVault:p,userRewardTokenPub:y,farmKeys:u,rewardInfo:n})],instructionTypes:[q.FarmV6Restart]}).versionBuild({txVersion:o})}async restartRewards({farmInfo:e,payer:t,newRewardInfos:n,txVersion:o,feePayer:r}){var l;let i=Lt[e.programId];i!==6&&this.logAndCreateError("invalid farm version ",i);let s=rt((await this.scope.api.fetchFarmKeysById({ids:e.id}))[0]),u={id:s.id,rewardInfos:e.rewardInfos,lpVault:s.lpVault,programId:s.programId};n.forEach(d=>{d.openTime>=d.endTime&&this.logAndCreateError("start time error","newRewardInfo",d)});let a=t||this.scope.ownerPubKey,c=this.createTxBuilder(r);for(let d of n){let p=d.mint.equals(et)?new Te(ct.address):d.mint,f=u.rewardInfos.findIndex(T=>new Te(T.mint.address).equals(p)),y=s.rewardInfos[f];y||this.logAndCreateError("configuration does not exist","rewardMint",p);let b=(l=y.vault)!=null?l:et,{rewardPubKey:g,newInstruction:A}=await this._getUserRewardInfo({rewardInfo:d,payer:a});A&&c.addInstruction(A),g||this.logAndCreateError("cannot found target token accounts",this.scope.account.tokenAccounts);let h=Ls({payer:this.scope.ownerPubKey,rewardVault:b,userRewardTokenPub:g,farmKeys:u,rewardInfo:d});c.addInstruction({instructions:[h],instructionTypes:[q.FarmV6Restart]})}return c.versionBuild({txVersion:o})}async addNewRewardToken(e){let{txVersion:t,farmInfo:n,newRewardInfo:o,payer:r,feePayer:i}=e,s=Lt[n.programId];s!==6&&this.logAndCreateError("invalid farm version ",s);let u=rt((await this.scope.api.fetchFarmKeysById({ids:n.id}))[0]),a=r!=null?r:this.scope.ownerPubKey,c=this.createTxBuilder(i),l=o.mint.equals(et)?new Te(ct.address):o.mint,d=Go({programId:new Te(n.programId),poolId:new Te(n.id),mint:l,type:"rewardVault"}),{rewardPubKey:p,newInstruction:f}=await this._getUserRewardInfo({rewardInfo:o,payer:a});return f&&c.addInstruction(f),p||this.logAndCreateError("annot found target token accounts",this.scope.account.tokenAccounts),o.mint=l,c.addInstruction({instructions:[Os({payer:this.scope.ownerPubKey,userRewardTokenPub:p,farmKeys:u,rewardVault:d,rewardInfo:o})],instructionTypes:[q.FarmV6CreatorAddReward]}).versionBuild({txVersion:t})}async addNewRewardsToken(e){let{txVersion:t,farmInfo:n,newRewardInfos:o,payer:r,feePayer:i}=e,s=Lt[n.programId];s!==6&&this.logAndCreateError("invalid farm version ",s);let u=rt((await this.scope.api.fetchFarmKeysById({ids:n.id}))[0]),a=r!=null?r:this.scope.ownerPubKey,c=this.createTxBuilder(i);for(let l of o){let d=l.mint.equals(et)?new Te(ct.address):l.mint,p=Go({programId:new Te(n.programId),poolId:new Te(n.id),mint:d,type:"rewardVault"}),{rewardPubKey:f,newInstruction:y}=await this._getUserRewardInfo({rewardInfo:l,payer:a});y&&c.addInstruction(y),f||this.logAndCreateError("cannot found target token accounts",this.scope.account.tokenAccounts);let b=Os({payer:this.scope.ownerPubKey,userRewardTokenPub:f,farmKeys:u,rewardVault:p,rewardInfo:W(v({},l),{mint:d})});c.addInstruction({instructions:[b],instructionTypes:[q.FarmV6CreatorAddReward]})}return c.versionBuild({txVersion:t})}async deposit(e){let{txVersion:t,farmInfo:n,amount:o,feePayer:r,useSOLBalance:i,associatedOnly:s=!0,checkCreateATAOwner:u=!1,userAuxiliaryLedgers:a,computeBudgetConfig:c,txTipConfig:l}=e;this.scope.availability.addFarm===!1&&this.logAndCreateError("farm deposit feature disabled in your region");let{rewardInfos:d,programId:p}=n,f=Lt[p];f===4&&this.logAndCreateError("V4 has suspended deposits:",n.programId),Ks(f)||this.logAndCreateError("invalid farm program:",n.programId);let[y,b]=[new Te(n.programId),new Te(n.id)],g=(await this.scope.api.fetchFarmKeysById({ids:n.id}))[0],A=Ot({programId:y,poolId:b,owner:this.scope.ownerPubKey,version:f}),h=this.createTxBuilder(r);h.addCustomComputeBudget(c),h.addTipInstruction(l);let T={};for(let R of this.scope.account.tokenAccounts)if(s){let L=Z(this.scope.ownerPubKey,R.mint,R.programId).publicKey;R.publicKey&&L.equals(R.publicKey)&&(T[R.mint.toString()]=R.publicKey)}else T[R.mint.toString()]=R.publicKey;let k=g.lpMint,w=T[k.address];w||this.logAndCreateError("you don't have any lp","lp zero",T);let S=[];for(let R of d){let L=i&&R.mint.address===Y.toString(),_=T[R.mint.address];if(!_){let{account:G,instructionParams:Q}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:R.mint.programId,mint:new Te(R.mint.address),notUseTokenAccount:L,createInfo:{payer:r||this.scope.ownerPubKey,amount:0},owner:this.scope.ownerPubKey,skipCloseAccount:!L,associatedOnly:L?!1:s,checkCreateATAOwner:u});_=G,Q&&h.addInstruction(Q)}T[R.mint.address]=_,S.push(_)}let B,K=await this.scope.connection.getAccountInfo(A);if(K&&(B=Xo(f).decode(K.data)),n.programId!==_o.toString()&&n.programId!==cn.FARM_PROGRAM_ID_V6.toString()&&!B){let{instruction:R,instructionType:L}=Qo({id:b,programId:y,version:f,ledger:A,owner:this.scope.ownerPubKey});h.addInstruction({instructions:[R],instructionTypes:[L]})}let I=Cs({version:f,rewardInfos:d,rewardTokenAccountsPublicKeys:S});I&&this.logAndCreateError(I);let C={amount:$(o),owner:this.scope.ownerPubKey,farmInfo:n,farmKeys:g,lpAccount:w,rewardAccounts:S,userAuxiliaryLedgers:a==null?void 0:a.map(R=>new Te(R))},O=f===6?_u(C):f===5?vu(C):Mu(C),M={3:q.FarmV3Deposit,5:q.FarmV5Deposit,6:q.FarmV6Deposit};return h.addInstruction({instructions:[O],instructionTypes:[M[f]]}).versionBuild({txVersion:t})}async withdraw(e){let{txVersion:t,farmInfo:n,amount:o,deposited:r,useSOLBalance:i,feePayer:s,associatedOnly:u=!0,checkCreateATAOwner:a=!1,userAuxiliaryLedgers:c,computeBudgetConfig:l,txTipConfig:d}=e,{rewardInfos:p}=n;this.scope.availability.removeFarm===!1&&this.logAndCreateError("farm withdraw feature disabled in your region");let f=Lt[n.programId];Ks(f)||this.logAndCreateError("invalid farm program:",n.programId);let y=(await this.scope.api.fetchFarmKeysById({ids:n.id}))[0],b=this.createTxBuilder(s);b.addCustomComputeBudget(l),b.addTipInstruction(d);let g={};for(let I of this.scope.account.tokenAccounts)if(u){let C=Z(this.scope.ownerPubKey,I.mint).publicKey;I.publicKey&&C.equals(I.publicKey)&&(g[I.mint.toString()]=I.publicKey)}else g[I.mint.toString()]=I.publicKey;if(f!==4){let I=Ot({programId:new Te(n.programId),poolId:new Te(n.id),owner:this.scope.ownerPubKey,version:f}),C=await this.scope.connection.getAccountInfo(I);if(C)Xo(f).decode(C.data).deposited.isZero()&&this.logAndCreateError("no deposited lp",{farmId:n.id});else if(f!==6){let{instruction:O,instructionType:M}=Qo({id:new Te(y.id),programId:new Te(y.programId),version:f,ledger:I,owner:this.scope.ownerPubKey});b.addInstruction({instructions:[O],instructionTypes:[M]})}}r&&r.isZero()&&!(c||[]).length&&this.logAndCreateError("no deposited lp",{farmId:n.id});let A=y.lpMint.address,h=i&&A===Y.toString(),T=g[A.toString()];if(!T){let{account:I,instructionParams:C}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:y.lpMint.programId,mint:new Te(A),notUseTokenAccount:h,createInfo:{payer:s||this.scope.ownerPubKey,amount:0},owner:this.scope.ownerPubKey,skipCloseAccount:!0,associatedOnly:h?!1:u,checkCreateATAOwner:a});T=I,C&&b.addInstruction(C)}g[A.toString()]=T;let k=[];for(let I of p){let C=i&&I.mint.address===Y.toString(),O=g[I.mint.address];if(!O){let{account:M,instructionParams:R}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:I.mint.programId,mint:new Te(I.mint.address),notUseTokenAccount:C,createInfo:{payer:s||this.scope.ownerPubKey,amount:0},owner:this.scope.ownerPubKey,skipCloseAccount:!C,associatedOnly:C?!1:u,checkCreateATAOwner:a});O=M,R&&b.addInstruction(R)}g[I.mint.address]=O,k.push(O)}let w=Cs({version:f,rewardInfos:p,rewardTokenAccountsPublicKeys:k});w&&this.logAndCreateError(w);let S={amount:$(o),owner:this.scope.ownerPubKey,farmInfo:n,farmKeys:y,lpAccount:T,rewardAccounts:k,userAuxiliaryLedgers:c==null?void 0:c.map(I=>new Te(I))},B=f===6?jo(S):f===5?Yo(S):f===4?Nu(S):Ho(S),K={3:q.FarmV3Withdraw,4:q.FarmV4Withdraw,5:q.FarmV5Withdraw,6:q.FarmV6Withdraw};return b.addInstruction({instructions:[B],instructionTypes:[K[f]]}).versionBuild({txVersion:t})}async withdrawFarmReward({farmInfo:e,withdrawMint:t,txVersion:n,computeBudgetConfig:o,txTipConfig:r,feePayer:i}){var y;this.scope.checkOwner();let s=rt((await this.scope.api.fetchFarmKeysById({ids:e.id}))[0]),u=Lt[e.programId];u!==6&&this.logAndCreateError("invalid farm version",u);let a=s.rewardInfos.find(b=>ut(b.mint.address).equals(ut(t)));a||this.logAndCreateError("withdraw mint error","rewardInfos",e);let c=(y=a==null?void 0:a.vault)!=null?y:et,l=this.createTxBuilder(i),d;if(t.equals(et)||t.equals(Te.default)){let b=await Bn({connection:this.scope.connection,owner:this.scope.ownerPubKey,payer:this.scope.ownerPubKey,amount:Rs(W(v({},a),{openTime:a.openTime,endTime:a.endTime,perSecond:new qm(a.perSecond).mul(10**a.mint.decimals).toString()}))});d=b.addresses.newAccount,l.addInstruction(b)}else{let b=await this.scope.account.getCreatedTokenAccount({mint:t});b===null?(d=await this.scope.account.getAssociatedTokenAccount(t),l.addInstruction({instructions:[Fu(this.scope.ownerPubKey,d,this.scope.ownerPubKey,t)],instructionTypes:[q.CreateATA]})):d=b}let{instruction:p,instructionType:f}=Ou({programId:s.programId,id:s.id,authority:s.authority,lpVault:s.lpVault,rewardVault:c,userRewardToken:d,owner:this.scope.ownerPubKey});return l.addCustomComputeBudget(o),l.addTipInstruction(r),l.addInstruction({instructions:[p],instructionTypes:[f]}).versionBuild({txVersion:n})}async harvestAllRewards(e){let{farmInfoList:t,useSOLBalance:n,feePayer:o,associatedOnly:r=!0,checkCreateATAOwner:i=!1,userAuxiliaryLedgers:s,txVersion:u,computeBudgetConfig:a}=e,c=this.createTxBuilder(o),l={};for(let f of this.scope.account.tokenAccounts)if(r){let y=Z(this.scope.ownerPubKey,f.mint).publicKey;f.publicKey&&y.equals(f.publicKey)&&(l[f.mint.toString()]=f.publicKey)}else l[f.mint.toString()]=f.publicKey;let p=(await this.scope.api.fetchFarmKeysById({ids:Object.values(t).map(f=>f.id).join(",")})).reduce((f,y)=>W(v({},f),{[y.id]:y}),{});for(let f of Object.values(t)){let{programId:y,lpMint:b,rewardInfos:g,id:A}=f,h=Lt[y],T=b.address,k=n&&T===Y.toString(),w=l[T];if(!w){let{account:O,instructionParams:M}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:b.programId,mint:new Te(T),notUseTokenAccount:k,createInfo:{payer:o||this.scope.ownerPubKey,amount:0},owner:this.scope.ownerPubKey,skipCloseAccount:!0,associatedOnly:k?!1:r,checkCreateATAOwner:i});w=O,M&&c.addInstruction(M)}l[T.toString()]=w;let S=[];for(let O of g){let M=n&&O.mint.address===Y.toString(),R=l[O.mint.address];if(!R)if(M){let{account:L,instructionParams:_}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:O.mint.programId,mint:new Te(O.mint.address),notUseTokenAccount:M,createInfo:{payer:o||this.scope.ownerPubKey,amount:0},owner:this.scope.ownerPubKey,skipCloseAccount:!M,associatedOnly:M?!1:r,checkCreateATAOwner:i});R=L,_&&c.addInstruction(_)}else{let L=new Te(O.mint.address);R=this.scope.account.getAssociatedTokenAccount(L),c.addInstruction({instructions:[Fu(this.scope.ownerPubKey,R,this.scope.ownerPubKey,L)]})}l[O.mint.address]=R,S.push(R)}let B=p[A],K={amount:At,owner:this.scope.ownerPubKey,farmInfo:f,farmKeys:B,lpAccount:w,rewardAccounts:S,userAuxiliaryLedgers:s==null?void 0:s.map(O=>new Te(O))},I=h===6?jo(K):h===5?Yo(K):Ho(K),C={3:q.FarmV3Withdraw,5:q.FarmV5Withdraw,6:q.FarmV6Withdraw};c.addInstruction({instructions:[I],instructionTypes:[C[h]]})}return u===1?c.sizeCheckBuild({computeBudgetConfig:a}):c.sizeCheckBuildV0({computeBudgetConfig:a})}};import{PublicKey as Ye}from"@solana/web3.js";import{AccountLayout as Cd,NATIVE_MINT as Ar,TOKEN_PROGRAM_ID as Cn}from"@solana/spl-token";import{Keypair as lr,PublicKey as U,SystemProgram as gn,TransactionInstruction as at}from"@solana/web3.js";import Gs from"bn.js";import{ASSOCIATED_TOKEN_PROGRAM_ID as ri,TOKEN_2022_PROGRAM_ID as We,TOKEN_PROGRAM_ID as xe}from"@solana/spl-token";import $m from"bn.js";import go from"decimal.js";import Mt from"bn.js";var Ee=new Mt(0),Bt=new Mt(1),fn=new Mt(-1),He=new Mt(1).shln(64),rr=new Mt(1).shln(128),$o=He.sub(Bt),Jo=64,Vu=rr.subn(1),mt=-443636,ft=-mt,vt=new Mt("4295048016"),_t=new Mt("79226673521066979257578248091"),sr=new Mt("4295048017"),ar=new Mt("79226673521066979257578248090"),Eu=16,Du="59543866431248",Wu="184467440737095516",qu="15793534762490258745",ur=new Mt(10).pow(new Mt(6));var Uu={tvl:0,volumeQuote:0,mintAmountA:0,mintAmountB:0,rewardDefaultInfos:[],farmUpcomingCount:0,farmOngoingCount:0,farmFinishedCount:0,day:{volume:0,volumeQuote:0,volumeFee:0,apr:0,feeApr:0,priceMin:0,priceMax:0,rewardApr:[0]},week:{volume:0,volumeQuote:0,volumeFee:0,apr:0,feeApr:0,priceMin:0,priceMax:0,rewardApr:[0]},month:{volume:0,volumeQuote:0,volumeFee:0,apr:0,feeApr:0,priceMin:0,priceMax:0,rewardApr:[0]},pooltype:[]},Vw=new Mt("18446744073700000000");import me from"bn.js";import rn from"decimal.js";function cr(m){let e=new ArrayBuffer(4);return new DataView(e).setInt32(0,m,!1),new Uint8Array(e)}function Ns(m,e){let t=0;for(let n=m-1;n>=0&&!e.testn(n);n--)t++;return t}function Ms(m,e){let t=0;for(let n=0;n<m&&!e.testn(n);n++)t++;return t}function ei(m,e){for(let t=0;t<m;t++)if(e.testn(t))return!1;return!0}function Gu(m,e){return ei(m,e)?null:Ns(m,e)}function Xu(m,e){return ei(m,e)?null:Ms(m,e)}var Uw=Buffer.from("amm_config","utf8"),vs=Buffer.from("pool","utf8"),_s=Buffer.from("pool_vault","utf8"),Gm=Buffer.from("pool_reward_vault","utf8"),zu=Buffer.from("position","utf8"),Xm=Buffer.from("tick_array","utf8"),zm=Buffer.from("operation","utf8"),Qm=Buffer.from("pool_tick_array_bitmap_extension","utf8"),jm=Buffer.from("observation","utf8");function Qu(m,e,t,n){return ae([vs,e.toBuffer(),t.toBuffer(),n.toBuffer()],m)}function Fs(m,e,t){return ae([_s,e.toBuffer(),t.toBuffer()],m)}function ju(m,e,t){return ae([Gm,e.toBuffer(),t.toBuffer()],m)}function be(m,e,t){return ae([Xm,e.toBuffer(),cr(t)],m)}function Ht(m,e,t,n){return ae([zu,e.toBuffer(),cr(t),cr(n)],m)}function yt(m,e){return ae([zu,e.toBuffer()],m)}function yn(m){return ae([Buffer.from("metadata","utf8"),Xt.toBuffer(),m.toBuffer()],Xt)}function ti(m){return ae([zm],m)}function Xe(m,e){return ae([Qm,e.toBuffer()],m)}function Yu(m,e){return ae([jm,e.toBuffer()],m)}var Hu=Buffer.from("locked_position","utf8");function Vs(m,e){return ae([Hu,e.toBuffer()],m)}function yo(m,e){return ae([Hu,e.toBuffer()],m)}var Ym=Buffer.from("support_mint","utf8");function Es(m,e){return ae([Ym,e.toBuffer()],m)}import{PublicKey as xt}from"@solana/web3.js";import{TOKEN_2022_PROGRAM_ID as Zu}from"@solana/spl-token";import ve from"bn.js";import Ae from"decimal.js";import on from"bn.js";import Ds from"decimal.js";var ni=class{static getfeeGrowthInside(e,t,n){let o=new on(0),r=new on(0);e.tickCurrent>=t.tick?(o=t.feeGrowthOutsideX64A,r=t.feeGrowthOutsideX64B):(o=e.feeGrowthGlobalX64A.sub(t.feeGrowthOutsideX64A),r=e.feeGrowthGlobalX64B.sub(t.feeGrowthOutsideX64B));let i=new on(0),s=new on(0);e.tickCurrent<n.tick?(i=n.feeGrowthOutsideX64A,s=n.feeGrowthOutsideX64B):(i=e.feeGrowthGlobalX64A.sub(n.feeGrowthOutsideX64A),s=e.feeGrowthGlobalX64B.sub(n.feeGrowthOutsideX64B));let u=ue.wrappingSubU128(ue.wrappingSubU128(e.feeGrowthGlobalX64A,o),i),a=ue.wrappingSubU128(ue.wrappingSubU128(e.feeGrowthGlobalX64B,r),s);return{feeGrowthInsideX64A:u,feeGrowthInsideBX64:a}}static GetPositionFees(e,t,n,o){let{feeGrowthInsideX64A:r,feeGrowthInsideBX64:i}=this.getfeeGrowthInside(e,n,o),s=ue.mulDivFloor(ue.wrappingSubU128(r,t.feeGrowthInsideLastX64A),t.liquidity,He),u=t.tokenFeesOwedA.add(s),a=ue.mulDivFloor(ue.wrappingSubU128(i,t.feeGrowthInsideLastX64B),t.liquidity,He),c=t.tokenFeesOwedB.add(a);return{tokenFeeAmountA:u,tokenFeeAmountB:c}}static GetPositionFeesV2(e,t,n,o){let{feeGrowthInsideX64A:r,feeGrowthInsideBX64:i}=this.getfeeGrowthInside(e,n,o),s=ue.mulDivFloor(ue.wrappingSubU128(r,t.feeGrowthInsideLastX64A),t.liquidity,He),u=t.tokenFeesOwedA.add(s),a=ue.mulDivFloor(ue.wrappingSubU128(i,t.feeGrowthInsideLastX64B),t.liquidity,He),c=t.tokenFeesOwedB.add(a);return{tokenFeeAmountA:u,tokenFeeAmountB:c}}static GetPositionRewardsV2(e,t,n,o){let r=[],i=this.getRewardGrowthInsideV2(e.tickCurrent,n,o,e.rewardInfos);for(let s=0;s<i.length;s++){let u=i[s],a=t.rewardInfos[s],c=ue.wrappingSubU128(u,a.growthInsideLastX64),l=ue.mulDivFloor(c,t.liquidity,He),d=a.rewardAmountOwed.add(l);r.push(d)}return r}static GetPositionRewards(e,t,n,o){let r=[],i=this.getRewardGrowthInside(e.tickCurrent,n,o,e.rewardInfos);for(let s=0;s<i.length;s++){let u=i[s],a=t.rewardInfos[s],c=ue.wrappingSubU128(u,a.growthInsideLastX64),l=ue.mulDivFloor(c,t.liquidity,He),d=a.rewardAmountOwed.add(l);r.push(d)}return r}static getRewardGrowthInside(e,t,n,o){let r=[];for(let i=0;i<o.length;i++){let s=new on(0);t.liquidityGross.eqn(0)?s=o[i].rewardGrowthGlobalX64:e<t.tick?s=o[i].rewardGrowthGlobalX64.sub(t.rewardGrowthsOutsideX64[i]):s=t.rewardGrowthsOutsideX64[i];let u=new on(0);n.liquidityGross.eqn(0)||(e<n.tick?u=n.rewardGrowthsOutsideX64[i]:u=o[i].rewardGrowthGlobalX64.sub(n.rewardGrowthsOutsideX64[i])),r.push(ue.wrappingSubU128(ue.wrappingSubU128(o[i].rewardGrowthGlobalX64,s),u))}return r}static getRewardGrowthInsideV2(e,t,n,o){let r=[];for(let i=0;i<o.length;i++){let s=new on(0);t.liquidityGross.eqn(0)?s=o[i].rewardGrowthGlobalX64:e<t.tick?s=o[i].rewardGrowthGlobalX64.sub(t.rewardGrowthsOutsideX64[i]):s=t.rewardGrowthsOutsideX64[i];let u=new on(0);n.liquidityGross.eqn(0)||(e<n.tick?u=n.rewardGrowthsOutsideX64[i]:u=o[i].rewardGrowthGlobalX64.sub(n.rewardGrowthsOutsideX64[i])),r.push(ue.wrappingSubU128(ue.wrappingSubU128(o[i].rewardGrowthGlobalX64,s),u))}return r}static getAmountsFromLiquidity({poolInfo:e,ownerPosition:t,liquidity:n,slippage:o,add:r,epochInfo:i}){var b,g,A,h;let s=re.priceToSqrtPriceX64(new Ds(e.price),e.mintA.decimals,e.mintB.decimals),u=re.getSqrtPriceX64FromTick(t.tickLower),a=re.getSqrtPriceX64FromTick(t.tickUpper),c=r?1+o:1-o,l=Pe.getAmountsFromLiquidity(s,u,a,n,r),[d,p]=[Be(l.amountA,(b=e.mintA.extensions)==null?void 0:b.feeConfig,i,!0),Be(l.amountB,(g=e.mintB.extensions)==null?void 0:g.feeConfig,i,!0)],[f,y]=[Be(new on(new Ds(l.amountA.toString()).mul(c).toFixed(0)),(A=e.mintA.extensions)==null?void 0:A.feeConfig,i,!0),Be(new on(new Ds(l.amountB.toString()).mul(c).toFixed(0)),(h=e.mintB.extensions)==null?void 0:h.feeConfig,i,!0)];return{liquidity:n,amountA:d,amountB:p,amountSlippageA:f,amountSlippageB:y,expirationTime:Qt(d.expirationTime,p.expirationTime)}}};var Hm=15,ge=class{static async getTickArrays(e,t,n,o,r,i,s){let u=[],a=H.getTickArrayStartIndexByTick(o,r),c=H.getInitializedTickArrayInRange(i,s,r,a,Math.floor(Hm/2));for(let p=0;p<c.length;p++){let{publicKey:f}=be(t,n,c[p]);u.push(f)}let l=(await Gt(e,u)).map(p=>p!==null?oi.decode(p.data):null),d={};for(let p=0;p<u.length;p++){let f=l[p];f!==null&&(d[f.startTickIndex]=W(v({},f),{address:u[p]}))}return d}static nextInitializedTick(e,t,n,o,r,i){let{initializedTick:s,tickArrayAddress:u,tickArrayStartTickIndex:a}=this.nextInitializedTickInOneArray(e,t,n,o,r,i);for(;s==null||s.liquidityGross.lten(0);){if(a=H.getNextTickArrayStartIndex(a,r,i),this.checkIsValidStartIndex(a,r))throw new Error("No enough initialized tickArray");let c=n[a];if(c===void 0)continue;let{nextTick:l,tickArrayAddress:d,tickArrayStartTickIndex:p}=this.firstInitializedTickInOneArray(e,t,c,i);[s,u,a]=[l,d,p]}if(s==null)throw new Error("No invaild tickArray cache");return{nextTick:s,tickArrayAddress:u,tickArrayStartTickIndex:a}}static nextInitializedTickArray(e,t,n,o,r){let i=Math.floor(e/ge.tickCount(t)),s=n?H.searchLowBitFromStart(o,r,i-1,1,t):H.searchHightBitFromStart(o,r,i+1,1,t);return s.length>0?{isExist:!0,nextStartIndex:s[0]}:{isExist:!1,nextStartIndex:0}}static firstInitializedTickInOneArray(e,t,n,o){let r;if(o){let s=Ze-1;for(;s>=0;){let u=n.ticks[s];if(u.liquidityGross.gtn(0)){r=u;break}s=s-1}}else{let s=0;for(;s<Ze;){let u=n.ticks[s];if(u.liquidityGross.gtn(0)){r=u;break}s=s+1}}let{publicKey:i}=be(e,t,n.startTickIndex);return{nextTick:r,tickArrayAddress:i,tickArrayStartTickIndex:n.startTickIndex}}static nextInitializedTickInOneArray(e,t,n,o,r,i){let s=H.getTickArrayStartIndexByTick(o,r),u=Math.floor((o-s)/r),a=n[s];if(a==null)return{initializedTick:void 0,tickArrayAddress:void 0,tickArrayStartTickIndex:s};let c;if(i)for(;u>=0;){let d=a.ticks[u];if(d.liquidityGross.gtn(0)){c=d;break}u=u-1}else for(u=u+1;u<Ze;){let d=a.ticks[u];if(d.liquidityGross.gtn(0)){c=d;break}u=u+1}let{publicKey:l}=be(e,t,s);return{initializedTick:c,tickArrayAddress:l,tickArrayStartTickIndex:a.startTickIndex}}static getArrayStartIndex(e,t){let n=this.tickCount(t);return Math.floor(e/n)*n}static checkIsValidStartIndex(e,t){if(H.checkIsOutOfBoundary(e)){if(e>ft)return!1;let n=H.getTickArrayStartIndexByTick(mt,t);return e==n}return e%this.tickCount(t)==0}static tickCount(e){return Ze*e}};var Ws=14,bn=class{static maxTickInTickarrayBitmap(e){return e*Ze*Gn}static getBitmapTickBoundary(e,t){let n=this.maxTickInTickarrayBitmap(t),o=Math.floor(Math.abs(e)/n);e<0&&Math.abs(e)%n!=0&&(o+=1);let r=n*o;return e<0?{minValue:-r,maxValue:-r+n}:{minValue:r,maxValue:r+n}}static nextInitializedTickArrayStartIndex(e,t,n,o){if(!ge.checkIsValidStartIndex(t,n))throw Error("nextInitializedTickArrayStartIndex check error");let r=this.maxTickInTickarrayBitmap(n),i=o?t-ge.tickCount(n):t+ge.tickCount(n);if(i<-r||i>=r)return{isInit:!1,tickIndex:t};let s=n*Ze,u=i/s+512;i<0&&i%s!=0&&u--;let a=Math.abs(u);if(o){let c=e.shln(1024-a-1),l=Gu(1024,c);if(l!==null){let d=(a-l-512)*s;return{isInit:!0,tickIndex:d}}else return{isInit:!1,tickIndex:-r}}else{let c=e.shrn(a),l=Xu(1024,c);if(l!==null){let d=(a+l-512)*s;return{isInit:!0,tickIndex:d}}else return{isInit:!1,tickIndex:r-ge.tickCount(n)}}}},ii=class{static getBitmapOffset(e,t){if(!ge.checkIsValidStartIndex(e,t))throw new Error("No enough initialized tickArray");this.checkExtensionBoundary(e,t);let n=bn.maxTickInTickarrayBitmap(t),o=Math.floor(Math.abs(e)/n)-1;return e<0&&Math.abs(e)%n===0&&o--,o}static getBitmap(e,t,n){let o=this.getBitmapOffset(e,t);return e<0?{offset:o,tickarrayBitmap:n.negativeTickArrayBitmap[o]}:{offset:o,tickarrayBitmap:n.positiveTickArrayBitmap[o]}}static checkExtensionBoundary(e,t){let{positiveTickBoundary:n,negativeTickBoundary:o}=this.extensionTickBoundary(t);if(e>=o&&e<n)throw Error("checkExtensionBoundary -> InvalidTickArrayBoundary")}static extensionTickBoundary(e){let t=bn.maxTickInTickarrayBitmap(e),n=-t;if(ft<=t)throw Error(`extensionTickBoundary check error: ${ft}, ${t}`);if(n<=mt)throw Error(`extensionTickBoundary check error: ${n}, ${mt}`);return{positiveTickBoundary:t,negativeTickBoundary:n}}static checkTickArrayIsInit(e,t,n){let{tickarrayBitmap:o}=this.getBitmap(e,t,n),r=this.tickArrayOffsetInBitmap(e,t);return{isInitialized:H.mergeTickArrayBitmap(o).testn(r),startIndex:e}}static nextInitializedTickArrayFromOneBitmap(e,t,n,o){let r=ge.tickCount(t),i=n?e-r:e+r,{tickarrayBitmap:s}=this.getBitmap(i,t,o);return this.nextInitializedTickArrayInBitmap(s,i,t,n)}static nextInitializedTickArrayInBitmap(e,t,n,o){let{minValue:r,maxValue:i}=bn.getBitmapTickBoundary(t,n),s=this.tickArrayOffsetInBitmap(t,n);if(o){let u=H.mergeTickArrayBitmap(e).shln(Gn-1-s),a=ei(512,u)?null:Ns(512,u);if(a!==null){let c=t-a*ge.tickCount(n);return{isInit:!0,tickIndex:c}}else return{isInit:!1,tickIndex:r}}else{let u=H.mergeTickArrayBitmap(e).shrn(s),a=ei(512,u)?null:Ms(512,u);if(a!==null){let c=t+a*ge.tickCount(n);return{isInit:!0,tickIndex:c}}else return{isInit:!1,tickIndex:i-ge.tickCount(n)}}}static tickArrayOffsetInBitmap(e,t){let n=Math.abs(e)%bn.maxTickInTickarrayBitmap(t),o=Math.floor(n/ge.tickCount(t));return e<0&&n!=0&&(o=Gn-o),o}};var Re=class{static getOutputAmountAndRemainAccounts(e,t,n,o,r,i=!1){let s=n.toBase58()===e.mintA.address,u=[],{isExist:a,startIndex:c,nextAccountMeta:l}=this.getFirstInitializedTickArray(e,s);if(!a||c===void 0||!l)throw new Error("Invalid tick array");u.push(l);let{allTrade:d,amountCalculated:p,accounts:f,sqrtPriceX64:y,feeAmount:b}=Xn.swapCompute(e.programId,e.id,t,e.tickArrayBitmap,e.exBitmapInfo,s,e.ammConfig.tradeFeeRate,e.liquidity,e.tickCurrent,e.tickSpacing,e.sqrtPriceX64,o,c,r,i);return u.push(...f),{allTrade:d,expectedAmountOut:p.mul(fn),remainingAccounts:u,executionPrice:y,feeAmount:b}}static getInputAmountAndRemainAccounts(e,t,n,o,r){let i=n.toBase58()===e.mintB.address,s=[],{isExist:u,startIndex:a,nextAccountMeta:c}=this.getFirstInitializedTickArray(e,i);if(!u||a===void 0||!c)throw new Error("Invalid tick array");try{let y=this.preInitializedTickArrayStartIndex(e,i);if(y.isExist){let{publicKey:b}=be(e.programId,e.id,y.nextStartIndex);s.push(b)}}catch{}s.push(c);let{amountCalculated:l,accounts:d,sqrtPriceX64:p,feeAmount:f}=Xn.swapCompute(e.programId,e.id,t,e.tickArrayBitmap,e.exBitmapInfo,i,e.ammConfig.tradeFeeRate,e.liquidity,e.tickCurrent,e.tickSpacing,e.sqrtPriceX64,o.mul(fn),a,r);return s.push(...d),{expectedAmountIn:l,remainingAccounts:s,executionPrice:p,feeAmount:f}}static getFirstInitializedTickArray(e,t){let{isInitialized:n,startIndex:o}=Re.isOverflowDefaultTickarrayBitmap(e.tickSpacing,[e.tickCurrent])?ii.checkTickArrayIsInit(ge.getArrayStartIndex(e.tickCurrent,e.tickSpacing),e.tickSpacing,e.exBitmapInfo):H.checkTickArrayIsInitialized(H.mergeTickArrayBitmap(e.tickArrayBitmap),e.tickCurrent,e.tickSpacing);if(n){let{publicKey:s}=be(e.programId,e.id,o);return{isExist:!0,startIndex:o,nextAccountMeta:s}}let{isExist:r,nextStartIndex:i}=this.nextInitializedTickArrayStartIndex(e,ge.getArrayStartIndex(e.tickCurrent,e.tickSpacing),t);if(r){let{publicKey:s}=be(e.programId,e.id,i);return{isExist:!0,startIndex:i,nextAccountMeta:s}}return{isExist:!1,nextAccountMeta:void 0,startIndex:void 0}}static preInitializedTickArrayStartIndex(e,t){let n=Math.floor(e.tickCurrent/ge.tickCount(e.tickSpacing)),o=t?H.searchHightBitFromStart(e.tickArrayBitmap,e.exBitmapInfo,n+1,1,e.tickSpacing):H.searchLowBitFromStart(e.tickArrayBitmap,e.exBitmapInfo,n-1,1,e.tickSpacing);return o.length>0?{isExist:!0,nextStartIndex:o[0]}:{isExist:!1,nextStartIndex:0}}static nextInitializedTickArrayStartIndex(e,t,n){for(t=ge.getArrayStartIndex(e.tickCurrent,e.tickSpacing);;){let{isInit:o,tickIndex:r}=bn.nextInitializedTickArrayStartIndex(H.mergeTickArrayBitmap(e.tickArrayBitmap),t,e.tickSpacing,n);if(o)return{isExist:!0,nextStartIndex:r};t=r;let{isInit:i,tickIndex:s}=ii.nextInitializedTickArrayFromOneBitmap(t,e.tickSpacing,n,e.exBitmapInfo);if(i)return{isExist:!0,nextStartIndex:s};if(t=s,t<mt||t>ft)return{isExist:!1,nextStartIndex:0}}}static async updatePoolRewardInfos({connection:e,apiPoolInfo:t,chainTime:n,poolLiquidity:o,rewardInfos:r}){var s,u,a;let i=[];for(let c=0;c<r.length;c++){let l=r[c],d=(a=(s=t.rewardDefaultInfos[c])==null?void 0:s.mint.programId)!=null?a:(u=await e.getAccountInfo(l.tokenMint))==null?void 0:u.owner;if(d===void 0)throw Error("get new reward mint info error");let p=W(v({},l),{perSecond:ue.x64ToDecimal(l.emissionsPerSecondX64),remainingRewards:void 0,tokenProgramId:new xt(d)});if(p.tokenMint.equals(xt.default))continue;if(n<=p.openTime.toNumber()||o.eq(Ee)){i.push(p);continue}let f=new ve(Math.min(p.endTime.toNumber(),n)),y=f.sub(p.lastUpdateTime),b=ue.mulDivFloor(y,p.emissionsPerSecondX64,o),g=p.rewardGrowthGlobalX64.add(b),A=ue.mulDivFloor(y,p.emissionsPerSecondX64,He),h=p.rewardTotalEmissioned.add(A);i.push(W(v({},p),{rewardGrowthGlobalX64:g,rewardTotalEmissioned:h,lastUpdateTime:f}))}return i}static isOverflowDefaultTickarrayBitmap(e,t){let{maxTickBoundary:n,minTickBoundary:o}=this.tickRange(e);for(let r of t){let i=H.getTickArrayStartIndexByTick(r,e);if(i>=n||i<o)return!0}return!1}static tickRange(e){let t=bn.maxTickInTickarrayBitmap(e),n=-t;return t>ft&&(t=ge.getArrayStartIndex(ft,e)+ge.tickCount(e)),n<mt&&(n=ge.getArrayStartIndex(mt,e)),{maxTickBoundary:t,minTickBoundary:n}}static get_tick_array_offset(e,t){if(!ge.checkIsValidStartIndex(e,t))throw new Error("No enough initialized tickArray");return e/ge.tickCount(t)*Gn}static async fetchExBitmaps({connection:e,exBitmapAddress:t,batchRequest:n}){let o=await Ce(e,t.map(i=>({pubkey:i})),{batchRequest:n}),r={};for(let i of o)i.accountInfo!==null&&(r[i.pubkey.toString()]=Ju.decode(i.accountInfo.data));return r}static async fetchMultiplePoolTickArrays({connection:e,poolKeys:t,batchRequest:n}){let o={},r=[];for(let u of t){let a=H.getTickArrayStartIndexByTick(u.tickCurrent,u.tickSpacing),c=H.getInitializedTickArrayInRange(u.tickArrayBitmap,u.exBitmapInfo,u.tickSpacing,a,7);for(let l of c){let{publicKey:d}=be(u.programId,u.id,l);r.push({pubkey:d}),o[d.toString()]=u.id}}let i=await Ce(e,r,{batchRequest:n}),s={};for(let u of i){if(!u.accountInfo)continue;let a=o[u.pubkey.toString()];if(!a)continue;s[a.toString()]===void 0&&(s[a.toString()]={});let c=oi.decode(u.accountInfo.data);s[a.toString()][c.startTickIndex]=W(v({},c),{address:u.pubkey})}return s}static async fetchPoolsAccountPosition({pools:e,connection:t,ownerInfo:n,batchRequest:o=!1,updateOwnerRewardAndFee:r=!0}){var s;let i=[];for(let u=0;u<e.length;u++){let a=e[u];a!==null&&(i.find(c=>c.equals(a.state.programId))||i.push(a.state.programId))}if(n){let u=n.tokenAccounts.map(d=>d.accountInfo.mint),a=[];for(let d of u)for(let p of i)a.push(yt(p,d).publicKey);let c=await Gt(t,a,{batchRequest:o}),l={};for(let d of c){if(d===null)continue;let p=bo.decode(d.data),f=p.poolId.toString(),y=e.find(B=>B.state.id.toBase58()===f);if(y===void 0)continue;let b=y.state,g=H._getTickPriceLegacy({poolInfo:b,tick:p.tickLower,baseIn:!0}),A=H._getTickPriceLegacy({poolInfo:b,tick:p.tickUpper,baseIn:!0}),{amountA:h,amountB:T}=Pe.getAmountsFromLiquidity(b.sqrtPriceX64,g.tickSqrtPriceX64,A.tickSqrtPriceX64,p.liquidity,!1),k=1/(1-Math.sqrt(Math.sqrt(g.price.div(A.price).toNumber())));y.positionAccount=[...(s=y.positionAccount)!=null?s:[],{poolId:p.poolId,nftMint:p.nftMint,priceLower:g.price,priceUpper:A.price,amountA:h,amountB:T,tickLower:p.tickLower,tickUpper:p.tickUpper,liquidity:p.liquidity,feeGrowthInsideLastX64A:p.feeGrowthInsideLastX64A,feeGrowthInsideLastX64B:p.feeGrowthInsideLastX64B,tokenFeesOwedA:p.tokenFeesOwedA,tokenFeesOwedB:p.tokenFeesOwedB,rewardInfos:p.rewardInfos.map(B=>W(v({},B),{pendingReward:new ve(0)})),leverage:k,tokenFeeAmountA:new ve(0),tokenFeeAmountB:new ve(0)}];let w=await H.getTickArrayAddressByTick(y.state.programId,p.poolId,p.tickLower,y.state.tickSpacing),S=await H.getTickArrayAddressByTick(y.state.programId,p.poolId,p.tickUpper,y.state.tickSpacing);l[`${y.state.programId.toString()}-${p.poolId.toString()}-${p.tickLower}`]=w,l[`${y.state.programId.toString()}-${p.poolId.toString()}-${p.tickUpper}`]=S}if(r){let d=Object.values(l),p=await Gt(t,d,{batchRequest:o}),f={};for(let y=0;y<d.length;y++){let b=p[y];if(b===null)continue;let g=d[y].toString();f[g]=oi.decode(b.data)}for(let{state:y,positionAccount:b}of e)if(!!b)for(let g of b){let A=`${y.programId.toString()}-${y.id.toString()}-${g.tickLower}`,h=`${y.programId.toString()}-${y.id.toString()}-${g.tickUpper}`,T=f[l[A].toString()],k=f[l[h].toString()],w=T.ticks[H.getTickOffsetInArray(g.tickLower,y.tickSpacing)],S=k.ticks[H.getTickOffsetInArray(g.tickUpper,y.tickSpacing)],{tokenFeeAmountA:B,tokenFeeAmountB:K}=await ni.GetPositionFees(y,g,w,S),I=await ni.GetPositionRewards(y,g,w,S);g.tokenFeeAmountA=B.gte(new ve(0))?B:new ve(0),g.tokenFeeAmountB=K.gte(new ve(0))?K:new ve(0);for(let C=0;C<I.length;C++)g.rewardInfos[C].pendingReward=I[C].gte(new ve(0))?I[C]:new ve(0)}}}return e}static computeAmountOut({poolInfo:e,tickArrayCache:t,baseMint:n,epochInfo:o,amountIn:r,slippage:i,priceLimit:s=new Ae(0),catchLiquidityInsufficient:u=!1}){var O;let a,c=n.toBase58()===e.mintA.address,[l,d]=c?[e.mintA.extensions.feeConfig,e.mintB.extensions.feeConfig]:[e.mintB.extensions.feeConfig,e.mintA.extensions.feeConfig];s.equals(new Ae(0))?a=c?vt.add(new ve(1)):_t.sub(new ve(1)):a=re.priceToSqrtPriceX64(s,e.mintA.decimals,e.mintB.decimals);let p=Be(r,l,o,!1),{allTrade:f,expectedAmountOut:y,remainingAccounts:b,executionPrice:g,feeAmount:A}=Re.getOutputAmountAndRemainAccounts(e,t,n,p.amount.sub((O=p.fee)!=null?O:Ee),a,u),h=Be(y,d,o,!1),T=re.sqrtPriceX64ToPrice(g,e.mintA.decimals,e.mintB.decimals),k=c?T:new Ae(1).div(T),w=y.mul(new ve(Math.floor((1-i)*1e10))).div(new ve(1e10)),S=Be(w,d,o,!1),B=c?e.currentPrice:new Ae(1).div(e.currentPrice),K=new Ae(k).sub(B).abs(),I=B,C=new tt(new Ae(K).mul(10**15).toFixed(0),new Ae(I).mul(10**15).toFixed(0));return{allTrade:f,realAmountIn:p,amountOut:h,minAmountOut:S,expirationTime:Qt(p.expirationTime,h.expirationTime),currentPrice:e.currentPrice,executionPrice:k,priceImpact:C,fee:A,remainingAccounts:b,executionPriceX64:g}}static computeAmountOutFormat({poolInfo:e,tickArrayCache:t,amountIn:n,tokenOut:o,slippage:r,epochInfo:i,catchLiquidityInsufficient:s=!1}){let u=o.address===e.mintB.address,[a,c]=u?[e.mintA,e.mintB]:[e.mintB,e.mintA],[l,d]=[new Ve(W(v({},a),{mint:a.address,isToken2022:a.programId===Zu.toBase58()})),new Ve(W(v({},c),{mint:c.address,isToken2022:c.programId===Zu.toBase58()}))],{allTrade:p,realAmountIn:f,amountOut:y,minAmountOut:b,expirationTime:g,currentPrice:A,executionPrice:h,priceImpact:T,fee:k,remainingAccounts:w,executionPriceX64:S}=Re.computeAmountOut({poolInfo:e,tickArrayCache:t,baseMint:new xt(a.address),amountIn:n,slippage:r,epochInfo:i,catchLiquidityInsufficient:s}),B=W(v({},f),{amount:new Ie(l,f.amount),fee:f.fee===void 0?void 0:new Ie(l,f.fee)}),K=W(v({},y),{amount:new Ie(d,y.amount),fee:y.fee===void 0?void 0:new Ie(d,y.fee)}),I=W(v({},b),{amount:new Ie(d,b.amount),fee:b.fee===void 0?void 0:new Ie(d,b.fee)}),C=new gt({baseToken:l,denominator:new ve(10).pow(new ve(20+l.decimals)),quoteToken:d,numerator:A.mul(new Ae(10**(20+d.decimals))).toFixed(0)}),O=new gt({baseToken:l,denominator:new ve(10).pow(new ve(20+l.decimals)),quoteToken:d,numerator:h.mul(new Ae(10**(20+d.decimals))).toFixed(0)}),M=new Ie(l,k);return{allTrade:p,realAmountIn:B,amountOut:K,minAmountOut:I,expirationTime:g,currentPrice:C,executionPrice:O,priceImpact:T,fee:M,remainingAccounts:w,executionPriceX64:S}}static computeAmountIn({poolInfo:e,tickArrayCache:t,baseMint:n,epochInfo:o,amountOut:r,slippage:i,priceLimit:s=new Ae(0)}){var I;let u=n.toBase58()===e.mintA.address,a={[e.mintA.address]:e.mintA.extensions.feeConfig,[e.mintB.address]:e.mintB.extensions.feeConfig},c;s.equals(new Ae(0))?c=u?_t.sub(new ve(1)):vt.add(new ve(1)):c=re.priceToSqrtPriceX64(s,e.mintA.decimals,e.mintB.decimals);let l=Be(r,a[n.toString()],o,!0),{expectedAmountIn:d,remainingAccounts:p,executionPrice:f,feeAmount:y}=Re.getInputAmountAndRemainAccounts(e,t,n,l.amount.sub((I=l.fee)!=null?I:Ee),c),b=u?e.mintB.address:e.mintA.address,g=Be(d,a[b],o,!1),A=re.sqrtPriceX64ToPrice(f,e.mintA.decimals,e.mintB.decimals),h=u?A:new Ae(1).div(A),T=d.mul(new ve(Math.floor((1+i)*1e10))).div(new ve(1e10)),k=Be(T,a[b],o,!0),w=u?e.currentPrice:new Ae(1).div(e.currentPrice),S=new Ae(h).sub(w).abs(),B=w,K=new tt(new Ae(S).mul(10**15).toFixed(0),new Ae(B).mul(10**15).toFixed(0));return{amountIn:g,maxAmountIn:k,realAmountOut:l,expirationTime:Qt(g.expirationTime,l.expirationTime),currentPrice:e.currentPrice,executionPrice:h,priceImpact:K,fee:y,remainingAccounts:p}}static estimateAprsForPriceRangeMultiplier({poolInfo:e,aprType:t,positionTickLowerIndex:n,positionTickUpperIndex:o}){var f,y,b;let r=e[t],i=H.getTickPrice({poolInfo:e,tick:n,baseIn:!0}).price.toNumber(),s=H.getTickPrice({poolInfo:e,tick:o,baseIn:!0}).price.toNumber(),u=Math.max(i,r.priceMin),c=Math.min(s,r.priceMax)-u,l=s-i,d=r.priceMax-r.priceMin,p;return c<=0?p=0:l===c?p=d/c:d===c?p=c/l:p=c/d*(c/l),{feeApr:r.feeApr*p,rewardsApr:[((f=r.rewardApr[0])!=null?f:0)*p,((y=r.rewardApr[1])!=null?y:0)*p,((b=r.rewardApr[2])!=null?b:0)*p],apr:r.apr*p}}static estimateAprsForPriceRangeDelta({poolInfo:e,poolLiquidity:t,aprType:n,mintPrice:o,liquidity:r,positionTickLowerIndex:i,positionTickUpperIndex:s,chainTime:u}){let a=n==="day"?1:n==="week"?7:n==="month"?30:0,c=e[n],l=o[ut(e.mintA.address).toString()],d=o[ut(e.mintB.address).toString()],p=e.mintA.decimals,f=e.mintB.decimals;if(!c||!l||!d)return{feeApr:0,rewardsApr:[0,0,0],apr:0};let y=re.priceToSqrtPriceX64(new Ae(e.price),e.mintA.decimals,e.mintB.decimals),b=re.getSqrtPriceX64FromTick(i),g=re.getSqrtPriceX64FromTick(s),{amountSlippageA:A,amountSlippageB:h}=Pe.getAmountsFromLiquidityWithSlippage(y,b,g,t,!1,!1,0),{amountSlippageA:T,amountSlippageB:k}=Pe.getAmountsFromLiquidityWithSlippage(y,b,g,r,!1,!1,0),w=new Ae(A.toString()).div(new Ae(10).pow(p)).mul(l.value).add(new Ae(h.toString()).div(new Ae(10).pow(f)).mul(d.value)),S=new Ae(T.toString()).div(new Ae(10).pow(p)).mul(l.value).add(new Ae(k.toString()).div(new Ae(10).pow(f)).mul(d.value)),B=new Ae(1).div(w.add(S)),I=new Ae(c.volumeFee).mul(365).div(a).mul(B).mul(100).toNumber(),C=3600*24*365,O=e.rewardDefaultInfos.map(M=>{var _,G;let R=M.mint.decimals,L=o[M.mint.address];return u<((_=M.startTime)!=null?_:0)||u>((G=M.endTime)!=null?G:0)||!M.perSecond||!L||R===void 0?0:new Ae(L.value).mul(new Ae(M.perSecond).mul(C)).div(new Ae(10).pow(R)).mul(B).mul(100).toNumber()});return{feeApr:I,rewardsApr:O,apr:I+O.reduce((M,R)=>M+R,0)}}static async getLiquidityAmountOutFromAmountIn({poolInfo:e,inputA:t,tickLower:n,tickUpper:o,amount:r,slippage:i,add:s,epochInfo:u,amountHasFee:a}){var g,A;let c=re.priceToSqrtPriceX64(new Ae(e.price),e.mintA.decimals,e.mintB.decimals),l=re.getSqrtPriceX64FromTick(n),d=re.getSqrtPriceX64FromTick(o),p=Be(r,(g=e[t?"mintA":"mintB"].extensions)==null?void 0:g.feeConfig,u,!a),f=new ve(new Ae(p.amount.sub((A=p.fee)!=null?A:Ee).toString()).toFixed(0)),y;if(c.lte(l))y=t?Pe.getLiquidityFromTokenAmountA(l,d,f,!s):new ve(0);else if(c.lte(d)){let h=Pe.getLiquidityFromTokenAmountA(c,d,f,!s),T=Pe.getLiquidityFromTokenAmountB(l,c,f);y=t?h:T}else y=t?new ve(0):Pe.getLiquidityFromTokenAmountB(l,d,f);let b=await Re.getAmountsFromLiquidity({epochInfo:u,poolInfo:e,tickLower:n,tickUpper:o,liquidity:y,slippage:i,add:s});return{liquidity:y,amountA:t?p:b.amountA,amountB:t?b.amountB:p,amountSlippageA:t?p:b.amountSlippageA,amountSlippageB:t?b.amountSlippageB:p,expirationTime:b.expirationTime}}static async getAmountsFromLiquidity({epochInfo:e,poolInfo:t,tickLower:n,tickUpper:o,liquidity:r,slippage:i,add:s}){var b,g,A,h;let u=re.getSqrtPriceX64FromTick(n),a=re.getSqrtPriceX64FromTick(o),c=s?1+i:1-i,l=Pe.getAmountsFromLiquidity(re.priceToSqrtPriceX64(new Ae(t.price),t.mintA.decimals,t.mintB.decimals),u,a,r,s),[d,p]=[Be(l.amountA,(b=t.mintA.extensions)==null?void 0:b.feeConfig,e,!0),Be(l.amountB,(g=t.mintB.extensions)==null?void 0:g.feeConfig,e,!0)],[f,y]=[Be(l.amountA.muln(c),(A=t.mintA.extensions)==null?void 0:A.feeConfig,e,!0),Be(l.amountB.muln(c),(h=t.mintB.extensions)==null?void 0:h.feeConfig,e,!0)];return{liquidity:r,amountA:d,amountB:p,amountSlippageA:f,amountSlippageB:y,expirationTime:Qt(d.expirationTime,p.expirationTime)}}static async fetchComputeMultipleClmmInfo({connection:e,poolList:t,rpcDataMap:n={}}){let o=t.filter(u=>!n[u.id]).map(u=>new xt(u.id));(await Gt(e,o)).forEach((u,a)=>{!u||(n[o[a].toBase58()]=zn.decode(u.data))});let i=t.map(u=>Xe(new xt(u.programId),new xt(u.id)).publicKey),s=await Re.fetchExBitmaps({connection:e,exBitmapAddress:i,batchRequest:!1});return t.reduce((u,a)=>W(v({},u),{[a.id]:W(v({},n[a.id]),{id:new xt(a.id),version:6,programId:new xt(a.programId),mintA:a.mintA,mintB:a.mintB,ammConfig:W(v({},a.config),{id:new xt(a.config.id),fundOwner:""}),currentPrice:new Ae(a.price),exBitmapAccount:Xe(new xt(a.programId),new xt(a.id)).publicKey,exBitmapInfo:s[Xe(new xt(a.programId),new xt(a.id)).publicKey.toBase58()],startTime:n[a.id].startTime.toNumber(),rewardInfos:n[a.id].rewardInfos})}),{})}static async fetchComputeClmmInfo({connection:e,poolInfo:t,rpcData:n}){return(await this.fetchComputeMultipleClmmInfo({connection:e,rpcDataMap:n?{[t.id]:n}:void 0,poolList:[t]}))[t.id]}};var qs={volume:0,volumeQuote:0,volumeFee:0,apr:0,feeApr:0,priceMin:0,priceMax:0,rewardApr:[]};function $u(m){return W(v({},m),{type:"Concentrated",programId:m.programId.toString(),id:m.id.toString(),rewardDefaultInfos:[],rewardDefaultPoolInfos:"Clmm",price:m.currentPrice.toNumber(),mintAmountA:0,mintAmountB:0,feeRate:m.ammConfig.tradeFeeRate,openTime:m.startTime.toString(),tvl:0,day:qs,week:qs,month:qs,pooltype:[],farmUpcomingCount:0,farmOngoingCount:0,farmFinishedCount:0,burnPercent:0,config:W(v({},m.ammConfig),{id:m.ammConfig.id.toString(),defaultRange:0,defaultRangePoint:[]})})}var ue=class{static mulDivRoundingUp(e,t,n){let o=e.mul(t),r=o.div(n);return o.mod(n).eq(Ee)||(r=r.add(Bt)),r}static mulDivFloor(e,t,n){if(n.eq(Ee))throw new Error("division by 0");return e.mul(t).div(n)}static mulDivCeil(e,t,n){if(n.eq(Ee))throw new Error("division by 0");return e.mul(t).add(n.sub(Bt)).div(n)}static x64ToDecimal(e,t){return new rn(e.toString()).div(rn.pow(2,64)).toDecimalPlaces(t)}static decimalToX64(e){return new me(e.mul(rn.pow(2,64)).floor().toFixed())}static wrappingSubU128(e,t){return e.add(rr).sub(t).mod(rr)}};function ot(m,e){return Us(m.mul(e),64,256)}function Zm(m,e,t){let n=m.toTwos(t).shln(e);return n.imaskn(t+1),n.fromTwos(t)}function Us(m,e,t){let n=m.toTwos(t).shrn(e);return n.imaskn(t-e+1),n.fromTwos(t-e)}var re=class{static sqrtPriceX64ToPrice(e,t,n){return ue.x64ToDecimal(e).pow(2).mul(rn.pow(10,t-n))}static priceToSqrtPriceX64(e,t,n){return ue.decimalToX64(e.mul(rn.pow(10,n-t)).sqrt())}static getNextSqrtPriceX64FromInput(e,t,n,o){if(!e.gt(Ee))throw new Error("sqrtPriceX64 must greater than 0");if(!t.gt(Ee))throw new Error("liquidity must greater than 0");return o?this.getNextSqrtPriceFromTokenAmountARoundingUp(e,t,n,!0):this.getNextSqrtPriceFromTokenAmountBRoundingDown(e,t,n,!0)}static getNextSqrtPriceX64FromOutput(e,t,n,o){if(!e.gt(Ee))throw new Error("sqrtPriceX64 must greater than 0");if(!t.gt(Ee))throw new Error("liquidity must greater than 0");return o?this.getNextSqrtPriceFromTokenAmountBRoundingDown(e,t,n,!1):this.getNextSqrtPriceFromTokenAmountARoundingUp(e,t,n,!1)}static getNextSqrtPriceFromTokenAmountARoundingUp(e,t,n,o){if(n.eq(Ee))return e;let r=t.shln(Jo);if(o){let i=r,s=r.add(n.mul(e));return s.gte(i)?ue.mulDivCeil(i,e,s):ue.mulDivRoundingUp(i,Bt,i.div(e).add(n))}else{let i=n.mul(e);if(!r.gt(i))throw new Error("getNextSqrtPriceFromTokenAmountARoundingUp,liquidityLeftShift must gt amountMulSqrtPrice");let s=r.sub(i);return ue.mulDivCeil(r,e,s)}}static getNextSqrtPriceFromTokenAmountBRoundingDown(e,t,n,o){let r=n.shln(Jo);if(o)return e.add(r.div(t));{let i=ue.mulDivRoundingUp(r,Bt,t);if(!e.gt(i))throw new Error("getNextSqrtPriceFromTokenAmountBRoundingDown sqrtPriceX64 must gt amountDivLiquidity");return e.sub(i)}}static getSqrtPriceX64FromTick(e){if(!Number.isInteger(e))throw new Error("tick must be integer");if(e<mt||e>ft)throw new Error("tick must be in MIN_TICK and MAX_TICK");let t=e<0?e*-1:e,n=(t&1)!=0?new me("18445821805675395072"):new me("18446744073709551616");return(t&2)!=0&&(n=ot(n,new me("18444899583751176192"))),(t&4)!=0&&(n=ot(n,new me("18443055278223355904"))),(t&8)!=0&&(n=ot(n,new me("18439367220385607680"))),(t&16)!=0&&(n=ot(n,new me("18431993317065453568"))),(t&32)!=0&&(n=ot(n,new me("18417254355718170624"))),(t&64)!=0&&(n=ot(n,new me("18387811781193609216"))),(t&128)!=0&&(n=ot(n,new me("18329067761203558400"))),(t&256)!=0&&(n=ot(n,new me("18212142134806163456"))),(t&512)!=0&&(n=ot(n,new me("17980523815641700352"))),(t&1024)!=0&&(n=ot(n,new me("17526086738831433728"))),(t&2048)!=0&&(n=ot(n,new me("16651378430235570176"))),(t&4096)!=0&&(n=ot(n,new me("15030750278694412288"))),(t&8192)!=0&&(n=ot(n,new me("12247334978884435968"))),(t&16384)!=0&&(n=ot(n,new me("8131365268886854656"))),(t&32768)!=0&&(n=ot(n,new me("3584323654725218816"))),(t&65536)!=0&&(n=ot(n,new me("696457651848324352"))),(t&131072)!=0&&(n=ot(n,new me("26294789957507116"))),(t&262144)!=0&&(n=ot(n,new me("37481735321082"))),e>0&&(n=Vu.div(n)),n}static getTickFromPrice(e,t,n){return re.getTickFromSqrtPriceX64(re.priceToSqrtPriceX64(e,t,n))}static getTickFromSqrtPriceX64(e){if(e.gt(_t)||e.lt(vt))throw new Error("Provided sqrtPrice is not within the supported sqrtPrice range.");let t=e.bitLength()-1,n=new me(t-64),o=Zm(n,32,128),r=new me("8000000000000000","hex"),i=0,s=new me(0),u=t>=64?e.shrn(t-63):e.shln(63-t);for(;r.gt(new me(0))&&i<Eu;){u=u.mul(u);let f=u.shrn(127);u=u.shrn(63+f.toNumber()),s=s.add(r.mul(f)),r=r.shrn(1),i+=1}let a=s.shrn(32),l=o.add(a).mul(new me(Du)),d=Us(l.sub(new me(Wu)),64,128).toNumber(),p=Us(l.add(new me(qu)),64,128).toNumber();return d==p?d:re.getSqrtPriceX64FromTick(p).lte(e)?p:d}},Qn=class{static getTickWithPriceAndTickspacing(e,t,n,o){let i=re.getTickFromSqrtPriceX64(re.priceToSqrtPriceX64(e,n,o))/t;return i<0?i=Math.floor(i):i=Math.ceil(i),i*t}static roundPriceWithTickspacing(e,t,n,o){let r=Qn.getTickWithPriceAndTickspacing(e,t,n,o),i=re.getSqrtPriceX64FromTick(r);return re.sqrtPriceX64ToPrice(i,n,o)}},Pe=class{static addDelta(e,t){return e.add(t)}static getTokenAmountAFromLiquidity(e,t,n,o){if(e.gt(t)&&([e,t]=[t,e]),!e.gt(Ee))throw new Error("sqrtPriceX64A must greater than 0");let r=n.ushln(Jo),i=t.sub(e);return o?ue.mulDivRoundingUp(ue.mulDivCeil(r,i,t),Bt,e):ue.mulDivFloor(r,i,t).div(e)}static getTokenAmountBFromLiquidity(e,t,n,o){if(e.gt(t)&&([e,t]=[t,e]),!e.gt(Ee))throw new Error("sqrtPriceX64A must greater than 0");return o?ue.mulDivCeil(n,t.sub(e),He):ue.mulDivFloor(n,t.sub(e),He)}static getLiquidityFromTokenAmountA(e,t,n,o){e.gt(t)&&([e,t]=[t,e]);let r=n.mul(e).mul(t),i=t.sub(e),s=r.div(i);return o?ue.mulDivRoundingUp(s,Bt,$o):s.shrn(Jo)}static getLiquidityFromTokenAmountB(e,t,n){return e.gt(t)&&([e,t]=[t,e]),ue.mulDivFloor(n,$o,t.sub(e))}static getLiquidityFromTokenAmounts(e,t,n,o,r){if(t.gt(n)&&([t,n]=[n,t]),e.lte(t))return Pe.getLiquidityFromTokenAmountA(t,n,o,!1);if(e.lt(n)){let i=Pe.getLiquidityFromTokenAmountA(e,n,o,!1),s=Pe.getLiquidityFromTokenAmountB(t,e,r);return i.lt(s)?i:s}else return Pe.getLiquidityFromTokenAmountB(t,n,r)}static getAmountsFromLiquidity(e,t,n,o,r){if(t.gt(n)&&([t,n]=[n,t]),e.lte(t))return{amountA:Pe.getTokenAmountAFromLiquidity(t,n,o,r),amountB:new me(0)};if(e.lt(n)){let i=Pe.getTokenAmountAFromLiquidity(e,n,o,r),s=Pe.getTokenAmountBFromLiquidity(t,e,o,r);return{amountA:i,amountB:s}}else return{amountA:new me(0),amountB:Pe.getTokenAmountBFromLiquidity(t,n,o,r)}}static getAmountsFromLiquidityWithSlippage(e,t,n,o,r,i,s){let{amountA:u,amountB:a}=Pe.getAmountsFromLiquidity(e,t,n,o,i),c=r?1+s:1-s,l=new me(new rn(u.toString()).mul(c).toFixed(0)),d=new me(new rn(a.toString()).mul(c).toFixed(0));return{amountSlippageA:l,amountSlippageB:d}}static getAmountsOutFromLiquidity({poolInfo:e,tickLower:t,tickUpper:n,liquidity:o,slippage:r,add:i,epochInfo:s,amountAddFee:u}){var A,h,T,k;let a=re.priceToSqrtPriceX64(new rn(e.price),e.mintA.decimals,e.mintB.decimals),c=re.getSqrtPriceX64FromTick(t),l=re.getSqrtPriceX64FromTick(n),d=i?1+r:1-r,p=Pe.getAmountsFromLiquidity(a,c,l,o,i),[f,y]=[Be(p.amountA,(A=e.mintA.extensions)==null?void 0:A.feeConfig,s,u),Be(p.amountB,(h=e.mintB.extensions)==null?void 0:h.feeConfig,s,u)],[b,g]=[Be(new me(new rn(p.amountA.toString()).mul(d).toFixed(0)),(T=e.mintA.extensions)==null?void 0:T.feeConfig,s,u),Be(new me(new rn(p.amountB.toString()).mul(d).toFixed(0)),(k=e.mintB.extensions)==null?void 0:k.feeConfig,s,u)];return{liquidity:o,amountA:f,amountB:y,amountSlippageA:b,amountSlippageB:g,expirationTime:Qt(f.expirationTime,y.expirationTime)}}},Xn=class{static swapCompute(e,t,n,o,r,i,s,u,a,c,l,d,p,f,y=!1){if(d.eq(Ee))throw new Error("amountSpecified must not be 0");if(f||(f=i?vt.add(Bt):_t.sub(Bt)),i){if(f.lt(vt))throw new Error("sqrtPriceX64 must greater than MIN_SQRT_PRICE_X64");if(f.gte(l))throw new Error("sqrtPriceX64 must smaller than current")}else{if(f.gt(_t))throw new Error("sqrtPriceX64 must smaller than MAX_SQRT_PRICE_X64");if(f.lte(l))throw new Error("sqrtPriceX64 must greater than current")}let b=d.gt(Ee),g={amountSpecifiedRemaining:d,amountCalculated:Ee,sqrtPriceX64:l,tick:a>p?Math.min(p+ge.tickCount(c)-1,a):p,accounts:[],liquidity:u,feeAmount:new me(0)},A=p,h=n[p],T=0,k=!i&&h.startTickIndex===g.tick;for(;!g.amountSpecifiedRemaining.eq(Ee)&&!g.sqrtPriceX64.eq(f);){T>10;let w={};w.sqrtPriceStartX64=g.sqrtPriceX64;let S=H.nextInitTick(h,g.tick,c,i,k),B=S||null,K=null;if(!(B!=null&&B.liquidityGross.gtn(0))){let C=Re.nextInitializedTickArrayStartIndex({tickCurrent:g.tick,tickSpacing:c,tickArrayBitmap:o,exBitmapInfo:r},A,i);if(!C.isExist){if(y)return{allTrade:!1,amountSpecifiedRemaining:g.amountSpecifiedRemaining,amountCalculated:g.amountCalculated,feeAmount:g.feeAmount,sqrtPriceX64:g.sqrtPriceX64,liquidity:g.liquidity,tickCurrent:g.tick,accounts:g.accounts};throw Error("swapCompute LiquidityInsufficient")}A=C.nextStartIndex;let{publicKey:O}=be(e,t,A);K=O,h=n[A];try{B=H.firstInitializedTick(h,i)}catch{throw Error("not found next tick info")}}w.tickNext=B.tick,w.initialized=B.liquidityGross.gtn(0),p!==A&&K&&(g.accounts.push(K),p=A),w.tickNext<mt?w.tickNext=mt:w.tickNext>ft&&(w.tickNext=ft),w.sqrtPriceNextX64=re.getSqrtPriceX64FromTick(w.tickNext);let I;if(i&&w.sqrtPriceNextX64.lt(f)||!i&&w.sqrtPriceNextX64.gt(f)?I=f:I=w.sqrtPriceNextX64,[g.sqrtPriceX64,w.amountIn,w.amountOut,w.feeAmount]=Xn.swapStepCompute(g.sqrtPriceX64,I,g.liquidity,g.amountSpecifiedRemaining,s,i),g.feeAmount=g.feeAmount.add(w.feeAmount),b?(g.amountSpecifiedRemaining=g.amountSpecifiedRemaining.sub(w.amountIn.add(w.feeAmount)),g.amountCalculated=g.amountCalculated.sub(w.amountOut)):(g.amountSpecifiedRemaining=g.amountSpecifiedRemaining.add(w.amountOut),g.amountCalculated=g.amountCalculated.add(w.amountIn.add(w.feeAmount))),g.sqrtPriceX64.eq(w.sqrtPriceNextX64)){if(w.initialized){let C=B.liquidityNet;i&&(C=C.mul(fn)),g.liquidity=Pe.addDelta(g.liquidity,C)}k=w.tickNext!=g.tick&&!i&&h.startTickIndex===w.tickNext,g.tick=i?w.tickNext-1:w.tickNext}else if(g.sqrtPriceX64!=w.sqrtPriceStartX64){let C=re.getTickFromSqrtPriceX64(g.sqrtPriceX64);k=C!=g.tick&&!i&&h.startTickIndex===C,g.tick=C}++T}try{let{nextStartIndex:w,isExist:S}=ge.nextInitializedTickArray(g.tick,c,i,o,r);S&&p!==w&&(g.accounts.push(be(e,t,w).publicKey),p=w)}catch{}return{allTrade:!0,amountSpecifiedRemaining:Ee,amountCalculated:g.amountCalculated,feeAmount:g.feeAmount,sqrtPriceX64:g.sqrtPriceX64,liquidity:g.liquidity,tickCurrent:g.tick,accounts:g.accounts}}static swapStepCompute(e,t,n,o,r,i){let s={sqrtPriceX64Next:new me(0),amountIn:new me(0),amountOut:new me(0),feeAmount:new me(0)},u=o.gte(Ee);if(u){let c=ue.mulDivFloor(o,ur.sub(new me(r.toString())),ur);s.amountIn=i?Pe.getTokenAmountAFromLiquidity(t,e,n,!0):Pe.getTokenAmountBFromLiquidity(e,t,n,!0),c.gte(s.amountIn)?s.sqrtPriceX64Next=t:s.sqrtPriceX64Next=re.getNextSqrtPriceX64FromInput(e,n,c,i)}else s.amountOut=i?Pe.getTokenAmountBFromLiquidity(t,e,n,!1):Pe.getTokenAmountAFromLiquidity(e,t,n,!1),o.mul(fn).gte(s.amountOut)?s.sqrtPriceX64Next=t:s.sqrtPriceX64Next=re.getNextSqrtPriceX64FromOutput(e,n,o.mul(fn),i);let a=t.eq(s.sqrtPriceX64Next);return i?(a&&u||(s.amountIn=Pe.getTokenAmountAFromLiquidity(s.sqrtPriceX64Next,e,n,!0)),a&&!u||(s.amountOut=Pe.getTokenAmountBFromLiquidity(s.sqrtPriceX64Next,e,n,!1))):(s.amountIn=a&&u?s.amountIn:Pe.getTokenAmountBFromLiquidity(e,s.sqrtPriceX64Next,n,!0),s.amountOut=a&&!u?s.amountOut:Pe.getTokenAmountAFromLiquidity(e,s.sqrtPriceX64Next,n,!1)),!u&&s.amountOut.gt(o.mul(fn))&&(s.amountOut=o.mul(fn)),u&&!s.sqrtPriceX64Next.eq(t)?s.feeAmount=o.sub(s.amountIn):s.feeAmount=ue.mulDivCeil(s.amountIn,new me(r),ur.sub(new me(r))),[s.sqrtPriceX64Next,s.amountIn,s.amountOut,s.feeAmount]}};var Ze=60,Gn=512,H=class{static getTickArrayAddressByTick(e,t,n,o){let r=H.getTickArrayStartIndexByTick(n,o),{publicKey:i}=be(e,t,r);return i}static getTickOffsetInArray(e,t){if(e%t!=0)throw new Error("tickIndex % tickSpacing not equal 0");let n=H.getTickArrayStartIndexByTick(e,t),o=Math.floor((e-n)/t);if(o<0||o>=Ze)throw new Error("tick offset in array overflow");return o}static getTickArrayBitIndex(e,t){let n=ge.tickCount(t),o=e/n;return e<0&&e%n!=0?o=Math.ceil(o)-1:o=Math.floor(o),o}static getTickArrayStartIndexByTick(e,t){return this.getTickArrayBitIndex(e,t)*ge.tickCount(t)}static getTickArrayOffsetInBitmapByTick(e,t){let n=t*Ze,o=Math.floor(e/n)+512;return Math.abs(o)}static checkTickArrayIsInitialized(e,t,n){let o=n*Ze,r=Math.floor(t/o)+512,i=Math.abs(r);return{isInitialized:e.testn(i),startIndex:(i-512)*o}}static getNextTickArrayStartIndex(e,t,n){return n?e-t*Ze:e+t*Ze}static mergeTickArrayBitmap(e){let t=new $m(0);for(let n=0;n<e.length;n++)t=t.add(e[n].shln(64*n));return t}static getInitializedTickArrayInRange(e,t,n,o,r){let i=Math.floor(o/(n*Ze));return[...H.searchLowBitFromStart(e,t,i-1,r,n),...H.searchHightBitFromStart(e,t,i,r,n)]}static getAllInitializedTickArrayStartIndex(e,t,n){return H.searchHightBitFromStart(e,t,-7680,Gn,n)}static getAllInitializedTickArrayInfo(e,t,n,o,r){let i=[],s=H.getAllInitializedTickArrayStartIndex(n,o,r);for(let u of s){let{publicKey:a}=be(e,t,u);i.push({tickArrayStartIndex:u,tickArrayAddress:a})}return i}static getAllInitializedTickInTickArray(e){return e.ticks.filter(t=>t.liquidityGross.gtn(0))}static searchLowBitFromStart(e,t,n,o,r){let i=[...[...t.negativeTickArrayBitmap].reverse(),e.slice(0,8),e.slice(8,16),...t.positiveTickArrayBitmap].map(a=>H.mergeTickArrayBitmap(a)),s=[];for(;n>=-7680;){let a=Math.floor((n+7680)/512),c=(n+7680)%512;if(i[a].testn(c)&&s.push(n),n--,s.length===o)break}let u=ge.tickCount(r);return s.map(a=>a*u)}static searchHightBitFromStart(e,t,n,o,r){let i=[...[...t.negativeTickArrayBitmap].reverse(),e.slice(0,8),e.slice(8,16),...t.positiveTickArrayBitmap].map(a=>H.mergeTickArrayBitmap(a)),s=[];for(;n<7680;){let a=Math.floor((n+7680)/512),c=(n+7680)%512;if(i[a].testn(c)&&s.push(n),n++,s.length===o)break}let u=ge.tickCount(r);return s.map(a=>a*u)}static checkIsOutOfBoundary(e){return e<mt||e>ft}static nextInitTick(e,t,n,o,r){if(ge.getArrayStartIndex(t,n)!=e.startTickIndex)return null;let s=Math.floor((t-e.startTickIndex)/n);if(o)for(;s>=0;){if(e.ticks[s].liquidityGross.gtn(0))return e.ticks[s];s=s-1}else for(r||(s=s+1);s<Ze;){if(e.ticks[s].liquidityGross.gtn(0))return e.ticks[s];s=s+1}return null}static firstInitializedTick(e,t){if(t){let n=Ze-1;for(;n>=0;){if(e.ticks[n].liquidityGross.gtn(0))return e.ticks[n];n=n-1}}else{let n=0;for(;n<Ze;){if(e.ticks[n].liquidityGross.gtn(0))return e.ticks[n];n=n+1}}throw Error(`firstInitializedTick check error: ${e} - ${t}`)}static _getTickPriceLegacy({poolInfo:e,tick:t,baseIn:n}){let o=re.getSqrtPriceX64FromTick(t),r=re.sqrtPriceX64ToPrice(o,e.mintA.decimals,e.mintB.decimals);return n?{tick:t,price:r,tickSqrtPriceX64:o}:{tick:t,price:new go(1).div(r),tickSqrtPriceX64:o}}static _getPriceAndTickLegacy({poolInfo:e,price:t,baseIn:n}){let o=n?t:new go(1).div(t),r=Qn.getTickWithPriceAndTickspacing(o,e.ammConfig.tickSpacing,e.mintA.decimals,e.mintB.decimals),i=re.getSqrtPriceX64FromTick(r),s=re.sqrtPriceX64ToPrice(i,e.mintA.decimals,e.mintB.decimals);return n?{tick:r,price:s}:{tick:r,price:new go(1).div(s)}}static getTickPrice({poolInfo:e,tick:t,baseIn:n}){let o=re.getSqrtPriceX64FromTick(t),r=re.sqrtPriceX64ToPrice(o,e.mintA.decimals,e.mintB.decimals);return n?{tick:t,price:r,tickSqrtPriceX64:o}:{tick:t,price:new go(1).div(r),tickSqrtPriceX64:o}}static getPriceAndTick({poolInfo:e,price:t,baseIn:n}){let o=n?t:new go(1).div(t),r=Qn.getTickWithPriceAndTickspacing(o,e.config.tickSpacing,e.mintA.decimals,e.mintB.decimals),i=re.getSqrtPriceX64FromTick(r),s=re.sqrtPriceX64ToPrice(i,e.mintA.decimals,e.mintB.decimals);return n?{tick:r,price:s}:{tick:r,price:new go(1).div(s)}}};var ec=F([ke(8),D("bump"),Tt("index"),N(""),lt("protocolFeeRate"),lt("tradeFeeRate"),Tt("tickSpacing"),j(P(),8,"")]),Jm=F([lt("blockTimestamp"),mo("tickCumulative"),j(P(),4)]),tc=F([ke(8),De("initialized"),P("recentEpoch"),Tt("observationIndex"),N("poolId"),j(Jm,100,"observations"),j(P(),4)]),ed=F([D("rewardState"),P("openTime"),P("endTime"),P("lastUpdateTime"),te("emissionsPerSecondX64"),P("rewardTotalEmissioned"),P("rewardClaimed"),N("tokenMint"),N("tokenVault"),N("creator"),te("rewardGrowthGlobalX64")]),zn=F([ke(8),D("bump"),N("ammConfig"),N("creator"),N("mintA"),N("mintB"),N("vaultA"),N("vaultB"),N("observationId"),D("mintDecimalsA"),D("mintDecimalsB"),Tt("tickSpacing"),te("liquidity"),te("sqrtPriceX64"),Me("tickCurrent"),lt(),te("feeGrowthGlobalX64A"),te("feeGrowthGlobalX64B"),P("protocolFeesTokenA"),P("protocolFeesTokenB"),te("swapInAmountTokenA"),te("swapOutAmountTokenB"),te("swapInAmountTokenB"),te("swapOutAmountTokenA"),D("status"),j(D(),7,""),j(ed,3,"rewardInfos"),j(P(),16,"tickArrayBitmap"),P("totalFeesTokenA"),P("totalFeesClaimedTokenA"),P("totalFeesTokenB"),P("totalFeesClaimedTokenB"),P("fundFeesTokenA"),P("fundFeesTokenB"),P("startTime"),j(P(),15*4-3,"padding")]),td=F([te("growthInsideLastX64"),P("rewardAmountOwed")]),bo=F([ke(8),D("bump"),N("nftMint"),N("poolId"),Me("tickLower"),Me("tickUpper"),te("liquidity"),te("feeGrowthInsideLastX64A"),te("feeGrowthInsideLastX64B"),P("tokenFeesOwedA"),P("tokenFeesOwedB"),j(td,3,"rewardInfos"),j(P(),8,"")]),Zk=F([ke(8),D("bump"),N("poolId"),Me("tickLowerIndex"),Me("tickUpperIndex"),te("liquidity"),te("feeGrowthInsideLastX64A"),te("feeGrowthInsideLastX64B"),P("tokenFeesOwedA"),P("tokenFeesOwedB"),j(te(),3,"rewardGrowthInside"),j(P(),8,"")]),nd=F([Me("tick"),Au("liquidityNet"),te("liquidityGross"),te("feeGrowthOutsideX64A"),te("feeGrowthOutsideX64B"),j(te(),3,"rewardGrowthsOutsideX64"),j(lt(),13,"")]),oi=F([ke(8),N("poolId"),Me("startTickIndex"),j(nd,Ze,"ticks"),D("initializedTickCount"),j(D(),115,"")]),nc=F([ke(329),j(N(),100,"whitelistMints")]),Ju=F([ke(8),N("poolId"),j(j(P(),8),Ws,"positiveTickArrayBitmap"),j(j(P(),8),Ws,"negativeTickArrayBitmap")]),$k=F([P(),D("bump"),N("owner"),N("poolId"),N("positionId"),N("nftAccount"),j(P(),8)]),oc=F([ke(8),D("bump"),N("lockOwner"),N("poolId"),N("positionId"),N("nftAccount"),N("lockNftMint"),P("recentEpoch"),j(P(),8)]);tc.span;var ic=ye("Raydium_Clmm"),St={createPool:[233,146,209,142,207,104,64,188],initReward:[95,135,192,196,242,129,230,68],setRewardEmissions:[112,52,167,75,32,201,211,137],openPosition:[77,184,74,214,112,86,241,199],openPositionWithTokenEx:[77,255,174,82,125,29,201,46],closePosition:[123,134,81,0,49,68,98,98],increaseLiquidity:[133,29,89,223,69,238,176,10],decreaseLiquidity:[58,127,188,62,79,82,196,96],swap:[43,4,237,11,26,201,30,98],collectReward:[18,237,166,197,34,16,213,144]},rc=[188,37,179,131,82,150,84,73],sc=[16,72,250,198,14,162,212,19],Se=class{static createPoolInstruction(e,t,n,o,r,i,s,u,a,c,l,d,p,f){let y=F([te("sqrtPriceX64"),P("zero")]),b=[{pubkey:n,isSigner:!0,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!1},{pubkey:a,isSigner:!1,isWritable:!1},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:d,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!1},{pubkey:l,isSigner:!1,isWritable:!1},{pubkey:gn.programId,isSigner:!1,isWritable:!1},{pubkey:it,isSigner:!1,isWritable:!1},...(f==null?void 0:f.map(h=>({pubkey:h,isSigner:!1,isWritable:!1})))||[]],g=Buffer.alloc(y.span);y.encode({sqrtPriceX64:p,zero:Ee},g);let A=Buffer.from([...St.createPool,...g]);return new at({keys:b,programId:e,data:A})}static async createPoolInstructions(e){let{programId:t,owner:n,mintA:o,mintB:r,ammConfigId:i,initialPriceX64:s,extendMintAccount:u}=e,[a,c]=[new U(o.address),new U(r.address)],{publicKey:l}=Qu(t,i,a,c),{publicKey:d}=Yu(t,l),{publicKey:p}=Fs(t,l,a),{publicKey:f}=Fs(t,l,c),y=Xe(t,l).publicKey,b=[this.createPoolInstruction(t,l,n,i,d,a,p,new U(o.programId||xe),c,f,new U(r.programId||xe),y,s,u)];return{signers:[],instructions:b,instructionTypes:[q.CreateAccount,q.ClmmCreatePool],address:{poolId:l,observationId:d,exBitmapAccount:y,mintAVault:p,mintBVault:f},lookupTableAddress:[]}}static openPositionFromLiquidityInstruction(e,t,n,o,r,i,s,u,a,c,l,d,p,f,y,b,g,A,h,T,k,w,S,B,K,I){let C=F([Me("tickLowerIndex"),Me("tickUpperIndex"),Me("tickArrayLowerStartIndex"),Me("tickArrayUpperStartIndex"),te("liquidity"),P("amountMaxA"),P("amountMaxB"),De("withMetadata"),D("optionBaseFlag"),De("baseFlag")]),O=[...I?[{pubkey:I,isSigner:!1,isWritable:!0}]:[]],M=[{pubkey:t,isSigner:!0,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!0,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:d,isSigner:!1,isWritable:!0},{pubkey:p,isSigner:!1,isWritable:!0},{pubkey:f,isSigner:!1,isWritable:!0},{pubkey:y,isSigner:!1,isWritable:!0},{pubkey:it,isSigner:!1,isWritable:!1},{pubkey:gn.programId,isSigner:!1,isWritable:!1},{pubkey:xe,isSigner:!1,isWritable:!1},{pubkey:ri,isSigner:!1,isWritable:!1},{pubkey:Xt,isSigner:!1,isWritable:!1},{pubkey:We,isSigner:!1,isWritable:!1},{pubkey:b,isSigner:!1,isWritable:!1},{pubkey:g,isSigner:!1,isWritable:!1},...O],R=Buffer.alloc(C.span);C.encode({tickLowerIndex:A,tickUpperIndex:h,tickArrayLowerStartIndex:T,tickArrayUpperStartIndex:k,liquidity:w,amountMaxA:S,amountMaxB:B,withMetadata:K==="create",baseFlag:!1,optionBaseFlag:0},R);let L=Buffer.from([...St.openPosition,...R]);return new at({keys:M,programId:e,data:L})}static openPositionFromLiquidityInstruction22(e,t,n,o,r,i,s,u,a,c,l,d,p,f,y,b,g,A,h,T,k,w,S,B,K){let I=F([Me("tickLowerIndex"),Me("tickUpperIndex"),Me("tickArrayLowerStartIndex"),Me("tickArrayUpperStartIndex"),te("liquidity"),P("amountMaxA"),P("amountMaxB"),De("withMetadata"),D("optionBaseFlag"),De("baseFlag")]),C=[...K?[{pubkey:K,isSigner:!1,isWritable:!0}]:[]],O=[{pubkey:t,isSigner:!0,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!0,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:d,isSigner:!1,isWritable:!0},{pubkey:p,isSigner:!1,isWritable:!0},{pubkey:f,isSigner:!1,isWritable:!0},{pubkey:it,isSigner:!1,isWritable:!1},{pubkey:gn.programId,isSigner:!1,isWritable:!1},{pubkey:xe,isSigner:!1,isWritable:!1},{pubkey:ri,isSigner:!1,isWritable:!1},{pubkey:We,isSigner:!1,isWritable:!1},{pubkey:y,isSigner:!1,isWritable:!1},{pubkey:b,isSigner:!1,isWritable:!1},...C],M=Buffer.alloc(I.span);I.encode({tickLowerIndex:g,tickUpperIndex:A,tickArrayLowerStartIndex:h,tickArrayUpperStartIndex:T,liquidity:k,amountMaxA:w,amountMaxB:S,withMetadata:B==="create",baseFlag:!1,optionBaseFlag:0},M);let R=Buffer.from([...St.openPositionWithTokenEx,...M]);return new at({keys:O,programId:e,data:R})}static async openPositionInstructions({poolInfo:e,poolKeys:t,ownerInfo:n,tickLower:o,tickUpper:r,liquidity:i,amountMaxA:s,amountMaxB:u,withMetadata:a,getEphemeralSigners:c,nft2022:l}){let d=[],[p,f]=[new U(e.programId),new U(e.id)],y;if(c)y=new U((await c(1))[0]);else{let K=lr.generate();d.push(K),y=K.publicKey}let b=H.getTickArrayStartIndexByTick(o,e.config.tickSpacing),g=H.getTickArrayStartIndexByTick(r,e.config.tickSpacing),{publicKey:A}=be(p,f,b),{publicKey:h}=be(p,f,g),{publicKey:T}=l?Z(n.wallet,y,We):Z(n.wallet,y,xe),{publicKey:k}=yn(y),{publicKey:w}=yt(p,y),{publicKey:S}=Ht(p,f,o,r),B=l?this.openPositionFromLiquidityInstruction22(p,n.feePayer,f,n.wallet,y,T,S,A,h,w,n.tokenAccountA,n.tokenAccountB,new U(t.vault.A),new U(t.vault.B),new U(e.mintA.address),new U(e.mintB.address),o,r,b,g,i,s,u,a,Re.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing,[b,g])?Xe(p,f).publicKey:void 0):this.openPositionFromLiquidityInstruction(p,n.feePayer,f,n.wallet,y,T,k,S,A,h,w,n.tokenAccountA,n.tokenAccountB,new U(t.vault.A),new U(t.vault.B),new U(e.mintA.address),new U(e.mintB.address),o,r,b,g,i,s,u,a,Re.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing,[b,g])?Xe(p,f).publicKey:void 0);return{signers:d,instructions:[B],instructionTypes:[q.ClmmOpenPosition],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[],address:{nftMint:y,tickArrayLower:A,tickArrayUpper:h,positionNftAccount:T,metadataAccount:k,personalPosition:w,protocolPosition:S}}}static async openPositionFromBaseInstructions({poolInfo:e,poolKeys:t,ownerInfo:n,tickLower:o,tickUpper:r,base:i,baseAmount:s,otherAmountMax:u,withMetadata:a,getEphemeralSigners:c,nft2022:l}){let d=[],[p,f]=[new U(e.programId),new U(e.id)],y;if(c)y=new U((await c(1))[0]);else{let K=lr.generate();d.push(K),y=K.publicKey}let b=H.getTickArrayStartIndexByTick(o,e.config.tickSpacing),g=H.getTickArrayStartIndexByTick(r,e.config.tickSpacing),{publicKey:A}=be(p,f,b),{publicKey:h}=be(p,f,g),{publicKey:T}=l?Z(n.wallet,y,We):Z(n.wallet,y,xe),{publicKey:k}=yn(y),{publicKey:w}=yt(p,y),{publicKey:S}=Ht(p,f,o,r),B=l?this.openPositionFromBaseInstruction22(p,n.feePayer,f,n.wallet,y,T,S,A,h,w,n.tokenAccountA,n.tokenAccountB,new U(t.vault.A),new U(t.vault.B),new U(e.mintA.address),new U(e.mintB.address),o,r,b,g,a,i,s,u,Re.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing,[b,g])?Xe(p,f).publicKey:void 0):this.openPositionFromBaseInstruction(p,n.feePayer,f,n.wallet,y,T,k,S,A,h,w,n.tokenAccountA,n.tokenAccountB,new U(t.vault.A),new U(t.vault.B),new U(e.mintA.address),new U(e.mintB.address),o,r,b,g,a,i,s,u,Re.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing,[b,g])?Xe(p,f).publicKey:void 0);return{address:{nftMint:y,tickArrayLower:A,tickArrayUpper:h,positionNftAccount:T,metadataAccount:k,personalPosition:w,protocolPosition:S},instructions:[B],signers:d,instructionTypes:[q.ClmmOpenPosition],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[]}}static openPositionFromBaseInstruction(e,t,n,o,r,i,s,u,a,c,l,d,p,f,y,b,g,A,h,T,k,w,S,B,K,I){let C=F([Me("tickLowerIndex"),Me("tickUpperIndex"),Me("tickArrayLowerStartIndex"),Me("tickArrayUpperStartIndex"),te("liquidity"),P("amountMaxA"),P("amountMaxB"),De("withMetadata"),D("optionBaseFlag"),De("baseFlag")]),O=[...I?[{pubkey:I,isSigner:!1,isWritable:!0}]:[]],M=[{pubkey:t,isSigner:!0,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!0,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:d,isSigner:!1,isWritable:!0},{pubkey:p,isSigner:!1,isWritable:!0},{pubkey:f,isSigner:!1,isWritable:!0},{pubkey:y,isSigner:!1,isWritable:!0},{pubkey:it,isSigner:!1,isWritable:!1},{pubkey:gn.programId,isSigner:!1,isWritable:!1},{pubkey:xe,isSigner:!1,isWritable:!1},{pubkey:ri,isSigner:!1,isWritable:!1},{pubkey:Xt,isSigner:!1,isWritable:!1},{pubkey:We,isSigner:!1,isWritable:!1},{pubkey:b,isSigner:!1,isWritable:!1},{pubkey:g,isSigner:!1,isWritable:!1},...O],R=Buffer.alloc(C.span);C.encode({tickLowerIndex:A,tickUpperIndex:h,tickArrayLowerStartIndex:T,tickArrayUpperStartIndex:k,liquidity:new Gs(0),amountMaxA:S==="MintA"?B:K,amountMaxB:S==="MintA"?K:B,withMetadata:w==="create",baseFlag:S==="MintA",optionBaseFlag:1},R);let L=Buffer.from([...St.openPosition,...R]);return new at({keys:M,programId:e,data:L})}static openPositionFromBaseInstruction22(e,t,n,o,r,i,s,u,a,c,l,d,p,f,y,b,g,A,h,T,k,w,S,B,K){let I=F([Me("tickLowerIndex"),Me("tickUpperIndex"),Me("tickArrayLowerStartIndex"),Me("tickArrayUpperStartIndex"),te("liquidity"),P("amountMaxA"),P("amountMaxB"),De("withMetadata"),D("optionBaseFlag"),De("baseFlag")]),C=[...K?[{pubkey:K,isSigner:!1,isWritable:!0}]:[]],O=[{pubkey:t,isSigner:!0,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!0,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:d,isSigner:!1,isWritable:!0},{pubkey:p,isSigner:!1,isWritable:!0},{pubkey:f,isSigner:!1,isWritable:!0},{pubkey:it,isSigner:!1,isWritable:!1},{pubkey:gn.programId,isSigner:!1,isWritable:!1},{pubkey:xe,isSigner:!1,isWritable:!1},{pubkey:ri,isSigner:!1,isWritable:!1},{pubkey:We,isSigner:!1,isWritable:!1},{pubkey:y,isSigner:!1,isWritable:!1},{pubkey:b,isSigner:!1,isWritable:!1},...C],M=Buffer.alloc(I.span);I.encode({tickLowerIndex:g,tickUpperIndex:A,tickArrayLowerStartIndex:h,tickArrayUpperStartIndex:T,liquidity:new Gs(0),amountMaxA:w==="MintA"?S:B,amountMaxB:w==="MintA"?B:S,withMetadata:k==="create",baseFlag:w==="MintA",optionBaseFlag:1},M);let R=Buffer.from([...St.openPositionWithTokenEx,...M]);return new at({keys:O,programId:e,data:R})}static async openPositionFromLiquidityInstructions({poolInfo:e,poolKeys:t,ownerInfo:n,tickLower:o,tickUpper:r,liquidity:i,amountMaxA:s,amountMaxB:u,withMetadata:a,getEphemeralSigners:c,nft2022:l}){let d,p=[];if(c)d=new U((await c(1))[0]);else{let K=lr.generate();p.push(K),d=K.publicKey}let[f,y]=[new U(e.programId),new U(e.id)],b=H.getTickArrayStartIndexByTick(o,e.config.tickSpacing),g=H.getTickArrayStartIndexByTick(r,e.config.tickSpacing),{publicKey:A}=be(f,y,b),{publicKey:h}=be(f,y,g),{publicKey:T}=l?Z(n.wallet,d,We):Z(n.wallet,d,xe),{publicKey:k}=yn(d),{publicKey:w}=yt(f,d),{publicKey:S}=Ht(f,y,o,r),B=l?this.openPositionFromLiquidityInstruction22(f,n.wallet,y,n.wallet,d,T,S,A,h,w,n.tokenAccountA,n.tokenAccountB,new U(t.vault.A),new U(t.vault.B),new U(t.mintA.address),new U(t.mintB.address),o,r,b,g,i,s,u,a,Re.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing,[b,g])?Xe(f,y).publicKey:void 0):this.openPositionFromLiquidityInstruction(f,n.wallet,y,n.wallet,d,T,k,S,A,h,w,n.tokenAccountA,n.tokenAccountB,new U(t.vault.A),new U(t.vault.B),new U(t.mintA.address),new U(t.mintB.address),o,r,b,g,i,s,u,a,Re.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing,[b,g])?Xe(f,y).publicKey:void 0);return{address:{nftMint:d,tickArrayLower:A,tickArrayUpper:h,positionNftAccount:T,metadataAccount:k,personalPosition:w,protocolPosition:S},instructions:[B],signers:p,instructionTypes:[q.ClmmOpenPosition],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[]}}static closePositionInstruction(e,t,n,o,r,i){let s=F([]),u=[{pubkey:t,isSigner:!0,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:gn.programId,isSigner:!1,isWritable:!1},{pubkey:i?We:xe,isSigner:!1,isWritable:!1}],a=Buffer.alloc(s.span);s.encode({},a);let c=Buffer.from([...St.closePosition,...a]);return new at({keys:u,programId:e,data:c})}static closePositionInstructions({poolInfo:e,poolKeys:t,ownerInfo:n,ownerPosition:o,nft2022:r}){let i=new U(e.programId),s=r?Z(n.wallet,o.nftMint,We).publicKey:Z(n.wallet,o.nftMint,xe).publicKey,{publicKey:u}=yt(i,o.nftMint),a=[];return a.push(this.closePositionInstruction(i,n.wallet,o.nftMint,s,u,r)),{address:{positionNftAccount:s,personalPosition:u},signers:[],instructions:a,instructionTypes:[q.ClmmClosePosition],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[]}}static increasePositionFromLiquidityInstruction(e,t,n,o,r,i,s,u,a,c,l,d,p,f,y,b,g,A){let h=F([te("liquidity"),P("amountMaxA"),P("amountMaxB"),D("optionBaseFlag"),De("baseFlag")]),T=[...A?[{pubkey:A,isSigner:!1,isWritable:!0}]:[]],k=[{pubkey:t,isSigner:!0,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:d,isSigner:!1,isWritable:!0},{pubkey:xe,isSigner:!1,isWritable:!1},{pubkey:We,isSigner:!1,isWritable:!1},{pubkey:p,isSigner:!1,isWritable:!1},{pubkey:f,isSigner:!1,isWritable:!1},...T],w=Buffer.alloc(h.span);h.encode({liquidity:y,amountMaxA:b,amountMaxB:g,optionBaseFlag:0,baseFlag:!1},w);let S=Buffer.from([...St.increaseLiquidity,...w]);return new at({keys:k,programId:e,data:S})}static increasePositionFromLiquidityInstructions({poolInfo:e,poolKeys:t,ownerPosition:n,ownerInfo:o,liquidity:r,amountMaxA:i,amountMaxB:s,nft2022:u}){let[a,c]=[new U(e.programId),new U(e.id)],l=H.getTickArrayStartIndexByTick(n.tickLower,e.config.tickSpacing),d=H.getTickArrayStartIndexByTick(n.tickUpper,e.config.tickSpacing),{publicKey:p}=be(a,c,l),{publicKey:f}=be(a,c,d),{publicKey:y}=u?Z(o.wallet,n.nftMint,We):Z(o.wallet,n.nftMint,xe),{publicKey:b}=yt(a,n.nftMint),{publicKey:g}=Ht(a,c,n.tickLower,n.tickUpper),A=this.increasePositionFromLiquidityInstruction(a,o.wallet,y,b,c,g,p,f,o.tokenAccountA,o.tokenAccountB,new U(t.vault.A),new U(t.vault.B),new U(e.mintA.address),new U(e.mintB.address),r,i,s,Re.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing,[l,d])?Xe(a,c).publicKey:void 0);return{address:{tickArrayLower:p,tickArrayUpper:f,positionNftAccount:y,personalPosition:b,protocolPosition:g},signers:[],instructions:[A],instructionTypes:[q.ClmmIncreasePosition],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[]}}static increasePositionFromBaseInstructions({poolInfo:e,poolKeys:t,ownerPosition:n,ownerInfo:o,base:r,baseAmount:i,otherAmountMax:s,nft2022:u}){let[a,c]=[new U(e.programId),new U(e.id)],l=H.getTickArrayStartIndexByTick(n.tickLower,e.config.tickSpacing),d=H.getTickArrayStartIndexByTick(n.tickUpper,e.config.tickSpacing),{publicKey:p}=be(a,c,l),{publicKey:f}=be(a,c,d),{publicKey:y}=u?Z(o.wallet,n.nftMint,We):Z(o.wallet,n.nftMint,xe),{publicKey:b}=yt(a,n.nftMint),{publicKey:g}=Ht(a,c,n.tickLower,n.tickUpper);return{address:{tickArrayLower:p,tickArrayUpper:f,positionNftAccount:y,personalPosition:b,protocolPosition:g},instructions:[this.increasePositionFromBaseInstruction(a,o.wallet,y,b,c,g,p,f,o.tokenAccountA,o.tokenAccountB,new U(t.vault.A),new U(t.vault.B),new U(e.mintA.address),new U(e.mintB.address),r,i,s,Re.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing,[l,d])?Xe(a,c).publicKey:void 0)],signers:[],instructionTypes:[q.ClmmIncreasePosition],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[]}}static increasePositionFromBaseInstruction(e,t,n,o,r,i,s,u,a,c,l,d,p,f,y,b,g,A){let h=F([te("liquidity"),P("amountMaxA"),P("amountMaxB"),D("optionBaseFlag"),De("baseFlag")]),T=[...A?[{pubkey:A,isSigner:!1,isWritable:!0}]:[]],k=[{pubkey:t,isSigner:!0,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:d,isSigner:!1,isWritable:!0},{pubkey:xe,isSigner:!1,isWritable:!1},{pubkey:We,isSigner:!1,isWritable:!1},{pubkey:p,isSigner:!1,isWritable:!1},{pubkey:f,isSigner:!1,isWritable:!1},...T],w=Buffer.alloc(h.span);h.encode({liquidity:new Gs(0),amountMaxA:y==="MintA"?b:g,amountMaxB:y==="MintA"?g:b,baseFlag:y==="MintA",optionBaseFlag:1},w);let S=Buffer.from([...St.increaseLiquidity,...w]);return new at({keys:k,programId:e,data:S})}static decreaseLiquidityInstruction(e,t,n,o,r,i,s,u,a,c,l,d,p,f,y,b,g,A,h){let T=F([te("liquidity"),P("amountMinA"),P("amountMinB")]),k=[...h?[{pubkey:h,isSigner:!1,isWritable:!0}]:[],...y.map(K=>[{pubkey:K.poolRewardVault,isSigner:!1,isWritable:!0},{pubkey:K.ownerRewardVault,isSigner:!1,isWritable:!0},{pubkey:K.rewardMint,isSigner:!1,isWritable:!1}]).flat()],w=[{pubkey:t,isSigner:!0,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:d,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:xe,isSigner:!1,isWritable:!1},{pubkey:We,isSigner:!1,isWritable:!1},{pubkey:_i,isSigner:!1,isWritable:!1},{pubkey:p,isSigner:!1,isWritable:!1},{pubkey:f,isSigner:!1,isWritable:!1},...k],S=Buffer.alloc(T.span);T.encode({liquidity:b,amountMinA:g,amountMinB:A},S);let B=Buffer.from([...St.decreaseLiquidity,...S]);return new at({keys:w,programId:e,data:B})}static decreaseLiquidityInstructions({poolInfo:e,poolKeys:t,ownerPosition:n,ownerInfo:o,liquidity:r,amountMinA:i,amountMinB:s,programId:u,nft2022:a}){let[c,l]=[new U(e.programId),new U(e.id)],d=H.getTickArrayStartIndexByTick(n.tickLower,e.config.tickSpacing),p=H.getTickArrayStartIndexByTick(n.tickUpper,e.config.tickSpacing),{publicKey:f}=be(c,l,d),{publicKey:y}=be(c,l,p),{publicKey:b}=a?Z(o.wallet,n.nftMint,We):Z(o.wallet,n.nftMint,u),{publicKey:g}=yt(c,n.nftMint),{publicKey:A}=Ht(c,l,n.tickLower,n.tickUpper),h=[];for(let w=0;w<e.rewardDefaultInfos.length;w++)h.push({poolRewardVault:new U(t.rewardInfos[w].vault),ownerRewardVault:o.rewardAccounts[w],rewardMint:new U(e.rewardDefaultInfos[w].mint.address)});let T=[],k=this.decreaseLiquidityInstruction(c,o.wallet,b,g,l,A,f,y,o.tokenAccountA,o.tokenAccountB,new U(t.vault.A),new U(t.vault.B),new U(e.mintA.address),new U(e.mintB.address),h,r,i,s,Re.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing,[d,p])?Xe(c,l).publicKey:void 0);return T.push(k),{address:{tickArrayLower:f,tickArrayUpper:y,positionNftAccount:b,personalPosition:g,protocolPosition:A},signers:[],instructions:T,instructionTypes:[q.ClmmDecreasePosition],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[]}}static swapInstruction(e,t,n,o,r,i,s,u,a,c,l,d,p,f,y,b,g){let A=F([P("amount"),P("otherAmountThreshold"),te("sqrtPriceLimitX64"),De("isBaseInput")]),h=[...g?[{pubkey:g,isSigner:!1,isWritable:!0}]:[],...l.map(S=>({pubkey:S,isSigner:!1,isWritable:!0}))],T=[{pubkey:t,isSigner:!0,isWritable:!1},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:d,isSigner:!1,isWritable:!0},{pubkey:xe,isSigner:!1,isWritable:!1},{pubkey:We,isSigner:!1,isWritable:!1},{pubkey:_i,isSigner:!1,isWritable:!1},{pubkey:a,isSigner:!1,isWritable:!1},{pubkey:c,isSigner:!1,isWritable:!1},...h],k=Buffer.alloc(A.span);A.encode({amount:p,otherAmountThreshold:f,sqrtPriceLimitX64:y,isBaseInput:b},k);let w=Buffer.from([...St.swap,...k]);return new at({keys:T,programId:e,data:w})}static makeSwapBaseInInstructions({poolInfo:e,poolKeys:t,observationId:n,ownerInfo:o,inputMint:r,amountIn:i,amountOutMin:s,sqrtPriceLimitX64:u,remainingAccounts:a}){let[c,l]=[new U(e.programId),new U(e.id)],[d,p]=[new U(t.vault.A),new U(t.vault.B)],[f,y]=[new U(e.mintA.address),new U(e.mintB.address)],b=e.mintA.address===r.toString(),g=[this.swapInstruction(c,o.wallet,l,new U(e.config.id),b?o.tokenAccountA:o.tokenAccountB,b?o.tokenAccountB:o.tokenAccountA,b?d:p,b?p:d,b?f:y,b?y:f,a,n,i,s,u,!0,Xe(c,l).publicKey)];return{signers:[],instructions:g,instructionTypes:[q.ClmmSwapBaseIn],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[],address:{}}}static makeSwapBaseOutInstructions({poolInfo:e,poolKeys:t,observationId:n,ownerInfo:o,outputMint:r,amountOut:i,amountInMax:s,sqrtPriceLimitX64:u,remainingAccounts:a}){let[c,l]=[new U(e.programId),new U(e.id)],[d,p]=[new U(t.vault.A),new U(t.vault.B)],[f,y]=[new U(e.mintA.address),new U(e.mintB.address)],b=e.mintA.address===r.toBase58(),g=[this.swapInstruction(c,o.wallet,l,new U(e.config.id),b?o.tokenAccountB:o.tokenAccountA,b?o.tokenAccountA:o.tokenAccountB,b?p:d,b?d:p,b?y:f,b?f:y,a,n,i,s,u,!1,Xe(c,l).publicKey)];return{signers:[],instructions:g,instructionTypes:[q.ClmmSwapBaseOut],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[],address:{}}}static initRewardInstruction(e,t,n,o,r,i,s,u,a,c,l,d){let p=F([P("openTime"),P("endTime"),te("emissionsPerSecondX64")]),f=[{pubkey:t,isSigner:!0,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!1},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!1},{pubkey:gn.programId,isSigner:!1,isWritable:!1},{pubkey:it,isSigner:!1,isWritable:!1}],y=Buffer.alloc(p.span);p.encode({openTime:$(c),endTime:$(l),emissionsPerSecondX64:d},y);let b=Buffer.from([...St.initReward,...y]);return new at({keys:f,programId:e,data:b})}static initRewardInstructions({poolInfo:e,poolKeys:t,ownerInfo:n,rewardInfo:o}){let[r,i]=[new U(e.programId),new U(e.id)],s=ju(r,i,o.mint).publicKey,u=ti(r).publicKey,a=[this.initRewardInstruction(r,n.wallet,i,u,new U(e.config.id),n.tokenAccount,o.programId,o.mint,s,o.openTime,o.endTime,o.emissionsPerSecondX64)];return{address:{poolRewardVault:s,operationId:u},signers:[],instructions:a,instructionTypes:[q.ClmmInitReward],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[]}}static setRewardInstruction(e,t,n,o,r,i,s,u,a,c,l,d){let p=F([D("rewardIndex"),te("emissionsPerSecondX64"),P("openTime"),P("endTime")]),f=[{pubkey:t,isSigner:!0,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:xe,isSigner:!1,isWritable:!1},{pubkey:We,isSigner:!1,isWritable:!1},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0}],y=Buffer.alloc(p.span);p.encode({rewardIndex:a,emissionsPerSecondX64:d,openTime:$(c),endTime:$(l)},y);let b=Buffer.from([...St.setRewardEmissions,...y]);return new at({keys:f,programId:e,data:b})}static setRewardInstructions({poolInfo:e,poolKeys:t,ownerInfo:n,rewardInfo:o}){let[r,i]=[new U(e.programId),new U(e.id)],s,u,a;for(let d=0;d<e.rewardDefaultInfos.length;d++)e.rewardDefaultInfos[d].mint.address===o.mint.toString()&&(s=d,u=new U(t.rewardInfos[d].vault),a=new U(t.rewardInfos[d].mint.address));(s===void 0||u===void 0)&&ic.logWithError("reward mint check error","no reward mint",e.rewardDefaultInfos);let c=ti(r).publicKey,l=[this.setRewardInstruction(r,n.wallet,i,c,new U(e.config.id),n.tokenAccount,u,a,s,o.openTime,o.endTime,o.emissionsPerSecondX64)];return{address:{rewardVault:u,operationId:c},signers:[],instructions:l,instructionTypes:[q.ClmmSetReward],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[]}}static collectRewardInstruction(e,t,n,o,r,i,s){let u=F([D("rewardIndex")]),a=[{pubkey:t,isSigner:!0,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!1},{pubkey:xe,isSigner:!1,isWritable:!1},{pubkey:We,isSigner:!1,isWritable:!1},{pubkey:_i,isSigner:!1,isWritable:!1}],c=Buffer.alloc(u.span);u.encode({rewardIndex:s},c);let l=Buffer.from([...St.collectReward,...c]);return new at({keys:a,programId:e,data:l})}static collectRewardInstructions({poolInfo:e,poolKeys:t,ownerInfo:n,rewardMint:o}){let[r,i]=[new U(e.programId),new U(e.id)],s,u;for(let c=0;c<e.rewardDefaultInfos.length;c++)e.rewardDefaultInfos[c].mint.address===o.toString()&&(s=c,u=new U(t.rewardInfos[c].vault));(s===void 0||u===void 0)&&ic.logWithError("reward mint check error","no reward mint",e.rewardDefaultInfos);let a=[this.collectRewardInstruction(r,n.wallet,i,n.tokenAccount,u,o,s)];return{address:{rewardVault:u},signers:[],instructions:a,instructionTypes:[q.ClmmCollectReward],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[]}}static async makeLockPositions({programId:e,authProgramId:t,poolProgramId:n,payer:o,wallet:r,nftMint:i,nft2022:s,getEphemeralSigners:u}){let a=[],c;if(u)c=new U((await u(1))[0]);else{let g=lr.generate();a.push(g),c=g.publicKey}let l=s?Z(r,i,We).publicKey:Z(r,i,xe).publicKey,{publicKey:d}=yt(n,i),p=yo(e,c).publicKey,f=Z(r,c,xe).publicKey,y=yn(c).publicKey,b=Se.lockPositionInstructionV2({programId:e,auth:t,payer:o,positionOwner:r,lockOwner:r,positionNftAccount:l,positionId:d,lockPositionId:p,lockNftMint:c,lockNftAccount:f,metadataAccount:y,withMetadata:!0,nft2022:s,positionNftMint:i,authPositionNftAccount:Z(t,i,s?We:xe).publicKey,positionNftProgram:s?We:xe});return{address:{positionId:d,lockPositionId:p,lockNftAccount:f,lockNftMint:c,positionNftAccount:l,metadataAccount:y},instructions:[b],signers:a,instructionTypes:[q.ClmmLockPosition],lookupTableAddress:[]}}static lockPositionInstructionV2({programId:e,auth:t,payer:n,positionOwner:o,lockOwner:r,positionNftAccount:i,positionId:s,positionNftMint:u,authPositionNftAccount:a,positionNftProgram:c,lockPositionId:l,lockNftMint:d,lockNftAccount:p,metadataAccount:f,withMetadata:y}){let b=[{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!0,isWritable:!0},{pubkey:o,isSigner:!0,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!1},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!1},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:d,isSigner:!0,isWritable:!0},{pubkey:p,isSigner:!1,isWritable:!0},{pubkey:f,isSigner:!1,isWritable:!0},{pubkey:Xt,isSigner:!1,isWritable:!1},{pubkey:ri,isSigner:!1,isWritable:!1},{pubkey:it,isSigner:!1,isWritable:!1},{pubkey:xe,isSigner:!1,isWritable:!1},{pubkey:c,isSigner:!1,isWritable:!1},{pubkey:gn.programId,isSigner:!1,isWritable:!1}],g=F([De("withMetadata")]),A=Buffer.alloc(g.span);g.encode({withMetadata:y},A);let h=Buffer.from([...rc,...A]);return new at({keys:b,programId:e,data:h})}static lockPositionInstruction({programId:e,authProgramId:t,poolProgramId:n,owner:o,positionNft:r}){let{publicKey:i}=Z(o,r,xe),{publicKey:s}=yt(n,r),u=[{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!0,isWritable:!1},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!1},{pubkey:Vs(e,s).publicKey,isSigner:!1,isWritable:!0},{pubkey:xe,isSigner:!1,isWritable:!1},{pubkey:gn.programId,isSigner:!1,isWritable:!1}];return new at({keys:u,programId:e,data:Buffer.from(rc)})}static harvestLockPositionInstruction(e){let[t,n]=[new U(e.poolKeys.programId),new U(e.poolKeys.id)],o=H.getTickArrayStartIndexByTick(e.ownerPosition.tickLower,e.poolKeys.config.tickSpacing),r=H.getTickArrayStartIndexByTick(e.ownerPosition.tickUpper,e.poolKeys.config.tickSpacing),{publicKey:i}=be(t,n,o),{publicKey:s}=be(t,n,r),{publicKey:u}=Z(e.owner,e.ownerPosition.nftMint,xe),{publicKey:a}=yt(t,e.ownerPosition.nftMint),{publicKey:c}=Ht(t,n,e.ownerPosition.tickLower,e.ownerPosition.tickUpper),l=[];for(let f=0;f<e.poolKeys.rewardInfos.length;f++)l.push({poolRewardVault:new U(e.poolKeys.rewardInfos[f].vault),ownerRewardVault:e.ownerRewardAccounts[f],rewardMint:new U(e.poolKeys.rewardInfos[f].mint.address)});let d=[...l.map(f=>[{pubkey:f.poolRewardVault,isSigner:!1,isWritable:!0},{pubkey:f.ownerRewardVault,isSigner:!1,isWritable:!0},{pubkey:f.rewardMint,isSigner:!1,isWritable:!1}]).flat()],p=[{pubkey:e.authProgramId,isSigner:!1,isWritable:!1},{pubkey:Vs(e.programId,a).publicKey,isSigner:!1,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:e.owner,isSigner:!0,isWritable:!1},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:new U(e.poolKeys.vault.A),isSigner:!1,isWritable:!0},{pubkey:new U(e.poolKeys.vault.B),isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:e.userVaultA,isSigner:!1,isWritable:!0},{pubkey:e.userVaultB,isSigner:!1,isWritable:!0},{pubkey:xe,isSigner:!1,isWritable:!1},{pubkey:We,isSigner:!1,isWritable:!1},{pubkey:kn,isSigner:!1,isWritable:!1},{pubkey:new U(e.poolKeys.mintA.address),isSigner:!1,isWritable:!1},{pubkey:new U(e.poolKeys.mintB.address),isSigner:!1,isWritable:!1},...d];return new at({keys:p,programId:e.programId,data:Buffer.from(sc)})}static harvestLockPositionInstructionV2({programId:e,auth:t,lockPositionId:n,clmmProgram:o,lockOwner:r,lockNftMint:i,lockNftAccount:s,positionNftAccount:u,positionId:a,poolId:c,protocolPosition:l,vaultA:d,vaultB:p,tickArrayLower:f,tickArrayUpper:y,userVaultA:b,userVaultB:g,mintA:A,mintB:h,rewardAccounts:T,exTickArrayBitmap:k}){let w=[...k?[{pubkey:k,isSigner:!1,isWritable:!0}]:[],...T.map(B=>[{pubkey:B.poolRewardVault,isSigner:!1,isWritable:!0},{pubkey:B.ownerRewardVault,isSigner:!1,isWritable:!0},{pubkey:B.rewardMint,isSigner:!1,isWritable:!1}]).flat()],S=[{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!0,isWritable:!1},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:d,isSigner:!1,isWritable:!0},{pubkey:p,isSigner:!1,isWritable:!0},{pubkey:f,isSigner:!1,isWritable:!0},{pubkey:y,isSigner:!1,isWritable:!0},{pubkey:b,isSigner:!1,isWritable:!0},{pubkey:g,isSigner:!1,isWritable:!0},{pubkey:xe,isSigner:!1,isWritable:!1},{pubkey:We,isSigner:!1,isWritable:!1},{pubkey:kn,isSigner:!1,isWritable:!1},{pubkey:A,isSigner:!1,isWritable:!1},{pubkey:h,isSigner:!1,isWritable:!1},...w];return new at({keys:S,programId:e,data:Buffer.from(sc)})}};var od=F([lt("mintAuthorityOption"),N("mintAuthority"),P("supply"),D("decimals"),D("isInitialized"),lt("freezeAuthorityOption"),N("freezeAuthority")]);import{PublicKey as Ph}from"@solana/web3.js";import{MintLayout as kh,TOKEN_PROGRAM_ID as Th}from"@solana/spl-token";var mr=m=>new Ve({mint:m.address,decimals:m.decimals,symbol:m.symbol,name:m.name}),si=o=>{var r=o,{amount:m,isRaw:e,name:t}=r,n=_e(r,["amount","isRaw","name"]);return new Ie(new Ve({mint:ut(n.address).toBase58(),decimals:n.decimals,symbol:n.symbol,name:t}),m,e,t)};var dt=o=>{var r=o,{address:m,programId:e,decimals:t}=r,n=_e(r,["address","programId","decimals"]);return v({chainId:101,address:ut(m).toBase58(),programId:e,logoURI:"",symbol:"",name:"",decimals:t,tags:[],extensions:n.extensions||{}},n)},Kn=m=>m?W(v({},m),{transferFeeConfigAuthority:m.transferFeeConfigAuthority.toBase58(),withdrawWithheldAuthority:m.withdrawWithheldAuthority.toBase58(),withheldAmount:m.withheldAmount.toString(),olderTransferFee:W(v({},m.olderTransferFee),{epoch:m.olderTransferFee.epoch.toString(),maximumFee:m.olderTransferFee.maximumFee.toString()}),newerTransferFee:W(v({},m.newerTransferFee),{epoch:m.newerTransferFee.epoch.toString(),maximumFee:m.newerTransferFee.maximumFee.toString()})}):void 0;import ac from"bn.js";var Xs=new ac(25),dr=new ac(1e4);import{PublicKey as sn,SystemProgram as rd,SYSVAR_RENT_PUBKEY as qh,TransactionInstruction as Ao}from"@solana/web3.js";import{ASSOCIATED_TOKEN_PROGRAM_ID as sd,TOKEN_PROGRAM_ID as ui}from"@solana/spl-token";var zs=F([D("instruction"),P("amountIn"),P("minAmountOut")]),Qs=F([D("instruction"),P("maxAmountIn"),P("amountOut")]),Vh=F([D("instruction"),D("nonce")]),id=F([D("instruction"),D("nonce"),P("startTime")]),ai=F([P("status"),P("nonce"),P("maxOrder"),P("depth"),P("baseDecimal"),P("quoteDecimal"),P("state"),P("resetFlag"),P("minSize"),P("volMaxCutRatio"),P("amountWaveRatio"),P("baseLotSize"),P("quoteLotSize"),P("minPriceMultiplier"),P("maxPriceMultiplier"),P("systemDecimalValue"),P("minSeparateNumerator"),P("minSeparateDenominator"),P("tradeFeeNumerator"),P("tradeFeeDenominator"),P("pnlNumerator"),P("pnlDenominator"),P("swapFeeNumerator"),P("swapFeeDenominator"),P("baseNeedTakePnl"),P("quoteNeedTakePnl"),P("quoteTotalPnl"),P("baseTotalPnl"),P("poolOpenTime"),P("punishPcAmount"),P("punishCoinAmount"),P("orderbookToInitTime"),te("swapBaseInAmount"),te("swapQuoteOutAmount"),P("swapBase2QuoteFee"),te("swapQuoteInAmount"),te("swapBaseOutAmount"),P("swapQuote2BaseFee"),N("baseVault"),N("quoteVault"),N("baseMint"),N("quoteMint"),N("lpMint"),N("openOrders"),N("marketId"),N("marketProgramId"),N("targetOrders"),N("withdrawQueue"),N("lpVault"),N("owner"),P("lpReserve"),j(P(),3,"padding")]),Eh=F([P("accountType"),P("status"),P("nonce"),P("maxOrder"),P("depth"),P("baseDecimal"),P("quoteDecimal"),P("state"),P("resetFlag"),P("minSize"),P("volMaxCutRatio"),P("amountWaveRatio"),P("baseLotSize"),P("quoteLotSize"),P("minPriceMultiplier"),P("maxPriceMultiplier"),P("systemDecimalsValue"),P("abortTradeFactor"),P("priceTickMultiplier"),P("priceTick"),P("minSeparateNumerator"),P("minSeparateDenominator"),P("tradeFeeNumerator"),P("tradeFeeDenominator"),P("pnlNumerator"),P("pnlDenominator"),P("swapFeeNumerator"),P("swapFeeDenominator"),P("baseNeedTakePnl"),P("quoteNeedTakePnl"),P("quoteTotalPnl"),P("baseTotalPnl"),P("poolOpenTime"),P("punishPcAmount"),P("punishCoinAmount"),P("orderbookToInitTime"),te("swapBaseInAmount"),te("swapQuoteOutAmount"),te("swapQuoteInAmount"),te("swapBaseOutAmount"),P("swapQuote2BaseFee"),P("swapBase2QuoteFee"),N("baseVault"),N("quoteVault"),N("baseMint"),N("quoteMint"),N("lpMint"),N("modelDataAccount"),N("openOrders"),N("marketId"),N("marketProgramId"),N("targetOrders"),N("owner"),j(P(),64,"padding")]),js=F([D("instruction"),P("baseAmountIn"),P("quoteAmountIn"),P("fixedSide"),P("otherAmountMin")]),Ys=F([D("instruction"),P("lpAmount"),P("baseAmountMin"),P("quoteAmountMin")]);var uc=F([P("fee")]);var cc=ye("Raydium_liquidity_instruction");function lc(m){let{poolInfo:e,poolKeys:t,userKeys:n,baseAmountIn:o,quoteAmountIn:r,fixedSide:i,otherAmountMin:s,modelDataPubKey:u=Vn}=m,a=Buffer.alloc(js.span);js.encode({instruction:3,baseAmountIn:$(o),quoteAmountIn:$(r),otherAmountMin:$(s),fixedSide:i==="base"?At:qa},a);let c=[x({pubkey:ui,isWritable:!1}),x({pubkey:new sn(e.id)}),x({pubkey:new sn(t.authority),isWritable:!1}),x({pubkey:new sn(t.openOrders),isWritable:!1}),x({pubkey:new sn(t.targetOrders)}),x({pubkey:new sn(e.lpMint.address)}),x({pubkey:new sn(t.vault.A)}),x({pubkey:new sn(t.vault.B)})];return e.pooltype.includes("StablePool")&&c.push(x({pubkey:u})),c.push(x({pubkey:new sn(e.marketId),isWritable:!1}),x({pubkey:n.baseTokenAccount}),x({pubkey:n.quoteTokenAccount}),x({pubkey:n.lpTokenAccount}),x({pubkey:n.owner,isWritable:!1,isSigner:!0}),x({pubkey:new sn(t.marketEventQueue),isWritable:!1})),new Ao({programId:new sn(e.programId),keys:c,data:a})}function Hs(m){let{poolInfo:e,poolKeys:t,userKeys:n,lpAmount:o,baseAmountMin:r,quoteAmountMin:i,modelDataPubKey:s=Vn}=m,u=rt(t),a=4;if(e.pooltype.includes("StablePool")&&(a=5),a===4||a===5){let c=Buffer.alloc(Ys.span);Ys.encode({instruction:4,lpAmount:$(o),baseAmountMin:$(r),quoteAmountMin:$(i)},c);let l=[x({pubkey:ui,isWritable:!1}),x({pubkey:u.id}),x({pubkey:u.authority,isWritable:!1}),x({pubkey:u.openOrders}),x({pubkey:u.targetOrders}),x({pubkey:u.mintLp.address}),x({pubkey:u.vault.A}),x({pubkey:u.vault.B})];return a===5?l.push(x({pubkey:s})):(l.push(x({pubkey:u.id})),l.push(x({pubkey:u.id}))),l.push(x({pubkey:u.marketProgramId,isWritable:!1}),x({pubkey:u.marketId}),x({pubkey:u.marketBaseVault}),x({pubkey:u.marketQuoteVault}),x({pubkey:u.marketAuthority,isWritable:!1}),x({pubkey:n.lpTokenAccount}),x({pubkey:n.baseTokenAccount}),x({pubkey:n.quoteTokenAccount}),x({pubkey:n.owner,isWritable:!1,isSigner:!0}),x({pubkey:u.marketEventQueue}),x({pubkey:u.marketBids}),x({pubkey:u.marketAsks})),new Ao({programId:u.programId,keys:l,data:c})}return new Ao({programId:u.programId,keys:[]})}function Zs({programId:m,ammId:e,ammAuthority:t,ammOpenOrders:n,lpMint:o,coinMint:r,pcMint:i,coinVault:s,pcVault:u,withdrawQueue:a,ammTargetOrders:c,poolTempLp:l,marketProgramId:d,marketId:p,userWallet:f,userCoinVault:y,userPcVault:b,userLpVault:g,nonce:A,openTime:h,coinAmount:T,pcAmount:k,ammConfigId:w,feeDestinationId:S}){let B=F([D("instruction"),D("nonce"),P("openTime"),P("pcAmount"),P("coinAmount")]),K=[{pubkey:ui,isSigner:!1,isWritable:!1},{pubkey:sd,isSigner:!1,isWritable:!1},{pubkey:rd.programId,isSigner:!1,isWritable:!1},{pubkey:it,isSigner:!1,isWritable:!1},{pubkey:e,isSigner:!1,isWritable:!0},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!1},{pubkey:i,isSigner:!1,isWritable:!1},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:w,isSigner:!1,isWritable:!1},{pubkey:S,isSigner:!1,isWritable:!0},{pubkey:d,isSigner:!1,isWritable:!1},{pubkey:p,isSigner:!1,isWritable:!1},{pubkey:f,isSigner:!0,isWritable:!0},{pubkey:y,isSigner:!1,isWritable:!0},{pubkey:b,isSigner:!1,isWritable:!0},{pubkey:g,isSigner:!1,isWritable:!0}],I=Buffer.alloc(B.span);return B.encode({instruction:1,nonce:A,openTime:h,coinAmount:T,pcAmount:k},I),{instruction:new Ao({keys:K,programId:m,data:I}),instructionType:q.AmmV4CreatePool}}function ad({poolKeys:m,userKeys:e,amountIn:t,minAmountOut:n,modelDataPubKey:o=Vn},r){let i=rt(m),s=Buffer.alloc(zs.span);zs.encode({instruction:9,amountIn:$(t),minAmountOut:$(n)},s);let u=[x({pubkey:ui,isWritable:!1}),x({pubkey:i.id}),x({pubkey:i.authority,isWritable:!1}),x({pubkey:i.openOrders})];return r===4&&u.push(x({pubkey:i.targetOrders})),u.push(x({pubkey:i.vault.A}),x({pubkey:i.vault.B})),r===5&&u.push(x({pubkey:o})),u.push(x({pubkey:i.marketProgramId,isWritable:!1}),x({pubkey:i.marketId}),x({pubkey:i.marketBids}),x({pubkey:i.marketAsks}),x({pubkey:i.marketEventQueue}),x({pubkey:i.marketBaseVault}),x({pubkey:i.marketQuoteVault}),x({pubkey:i.marketAuthority,isWritable:!1}),x({pubkey:e.tokenAccountIn}),x({pubkey:e.tokenAccountOut}),x({pubkey:e.owner,isWritable:!1,isSigner:!0})),new Ao({programId:i.programId,keys:u,data:s})}function ud({poolKeys:m,userKeys:e,maxAmountIn:t,amountOut:n,modelDataPubKey:o=Vn},r){let i=rt(m),s=Buffer.alloc(Qs.span);Qs.encode({instruction:11,maxAmountIn:$(t),amountOut:$(n)},s);let u=[x({pubkey:ui,isWritable:!1}),x({pubkey:i.id}),x({pubkey:i.authority,isWritable:!1}),x({pubkey:i.openOrders}),x({pubkey:i.targetOrders}),x({pubkey:i.vault.A}),x({pubkey:i.vault.B})];return r===5&&u.push(x({pubkey:o})),u.push(x({pubkey:i.marketProgramId,isWritable:!1}),x({pubkey:i.marketId}),x({pubkey:i.marketBids}),x({pubkey:i.marketAsks}),x({pubkey:i.marketEventQueue}),x({pubkey:i.marketBaseVault}),x({pubkey:i.marketQuoteVault}),x({pubkey:i.marketAuthority,isWritable:!1}),x({pubkey:e.tokenAccountIn}),x({pubkey:e.tokenAccountOut}),x({pubkey:e.owner,isWritable:!1,isSigner:!0})),new Ao({programId:i.programId,keys:u,data:s})}function pr(m){let{poolKeys:e,version:t,userKeys:n,amountIn:o,amountOut:r,fixedSide:i}=m;if(t===4||t===5){let s={poolKeys:e,userKeys:n};if(i==="in")return ad(W(v({},s),{amountIn:o,minAmountOut:r}),t);if(i==="out")return ud(W(v({},s),{maxAmountIn:o,amountOut:r}),t);cc.logWithError("invalid params","params",m)}throw cc.logWithError("invalid version","poolKeys.version",t),new Error("invalid version")}var Yn=5e4,cd=F([P("x"),P("y"),P("price")]),ld=F([P("accountType"),P("status"),P("multiplier"),P("validDataCount"),j(cd,Yn,"DataElement")]);function md(m,e){return[0,Yn-2]}function dd(m){return[0,Yn-2]}function pd(m){return[0,Yn-2]}function fd(m,e,t){let[n,o]=md(e,t),r=n,i=o,s=0,u=e*m.multiplier/t;for(;r<=i;){if(s=Math.floor((i+r)/2),s===0||s>=Yn-2)return[s,s,!1];let a=m.DataElement[s].x*m.multiplier/m.DataElement[s].y,c=m.DataElement[s-1].x*m.multiplier/m.DataElement[s-1].y,l=m.DataElement[s+1].x*m.multiplier/m.DataElement[s+1].y;if(u===a)return[s,s,!0];if(u===c)return[s-1,s-1,!0];if(u===l)return[s+1,s+1,!0];if(u<c)i=s-1;else{if(u>c&&u<a)return[s-1,s,!0];if(u>a&&u<l)return[s,s+1,!0];r=s+1}}return[s,s,!1]}function $s(m,e,t){let[n,o,r]=fd(m,e,t);if(!r)return 0;if(n===o){let i=m.DataElement[n].x;return e*m.multiplier/i}else{let i=m.DataElement[n].x,s=m.DataElement[n].y,u=m.DataElement[o].x,a=m.DataElement[o].y,c=t*(u*s-i*a),l=i*c,d=(u-i)*(e*s-i*t)*a,p=l+d;return e*m.multiplier*c/p}}function jn(m,e,t){return e*m.multiplier/t}function mc(m,e,t){return e*t/m.multiplier}function yd(m,e){let[t,n]=dd(e),o=t,r=n,i=0,s=e;for(;o<r;){if(i=Math.floor((r+o)/2),i<=0||i>Yn-2)return[i,i,!1];let u=m.DataElement[i].x,a=m.DataElement[i-1].x,c=m.DataElement[i+1].x;if(s===u)return[i,i,!0];if(s===a)return[i-1,i-1,!0];if(s===c)return[i+1,i+1,!0];if(s<a)r=i-1;else{if(s>a&&s<u)return[i-1,i,!0];if(s>u&&s<c)return[i,i+1,!0];o=i+1}}return[i,i,!1]}function bd(m,e){let[t,n]=pd(e),o=t,r=n,i=0,s=e;for(;o<=r;){if(i=Math.floor((r+o)/2),i<=0||i>=Yn-2)return[i,i,!1];let u=m.DataElement[i].y,a=m.DataElement[i-1].y,c=m.DataElement[i+1].y;if(s===u)return[i,i,!0];if(s===a)return[i-1,i-1,!0];if(s===c)return[i+1,i+1,!0];if(s<c)o=i+1;else{if(s<a&&s>u)return[i-1,i,!0];if(s<u&&s>c)return[i,i+1,!0];r=i-1}}return[i,i,!1]}function dc(m,e,t,n){let o=n?e+t:e-t,[r,i,s]=yd(m,o);if(!s)return[0,0,!1,s];if(r===i)return[m.DataElement[i].price,m.DataElement[i].y,!1,s];{let u=m.DataElement[r].x,a=m.DataElement[i].x,c=m.DataElement[r].price,l=m.DataElement[i].price,d=m.DataElement[r].y,p=m.DataElement[i].y;if(e>=u&&e<=a)return n?[l,p,!0,s]:[c,d,!0,s];{let f,y;return n?(f=c+(l-c)*(e-u)/(a-u),y=d-(o-u)*m.multiplier/l):(f=c+(l-c)*(e-u)/(a-u),y=p+(a-o)*m.multiplier/c),[f,y,!1,s]}}}function gd(m,e,t,n){let o=n?e-t:e+t,[r,i,s]=bd(m,o);if(!s)return[0,0,!1,s];if(r===i)return[m.DataElement[i].price,m.DataElement[i].x,!1,s];{let u=m.DataElement[r].x,a=m.DataElement[i].x,c=m.DataElement[r].price,l=m.DataElement[i].price,d=m.DataElement[r].y,p=m.DataElement[i].y;if(e>=p&&e<=d)return n?[l,a,!0,s]:[c,u,!0,s];{let f,y;return n?(f=c+(l-c)*(d-e)/(d-p),y=u+l*(d-o)/m.multiplier):(f=c+(l-c)*(d-e)/(d-p),y=a-c*(o-p)/m.multiplier),[f,y,!1,s]}}}function Ad(m,e){let t=dc(m,e,0,!1);return t[3]?t[0]:0}function pc(m,e,t,n){let o=$s(m,e,t),r=jn(m,e,o),i=jn(m,t,o),s=jn(m,n,o),u=!0,[a,c,l,d]=dc(m,r,s,u);if(!d)return 0;if(l)return n*m.multiplier/a;{let p=i-c;return mc(m,p,o)}}function fc(m,e,t,n){let o=$s(m,e,t),r=jn(m,e,o),i=jn(m,t,o),s=jn(m,n,o),u=!1,[a,c,l,d]=gd(m,i,s,u);if(!d)return 0;if(l)return n*a/m.multiplier;{let p=r-c;return mc(m,p,o)}}function Pd(m){let e=ld.decode(m);return{accountType:e.accountType.toNumber(),status:e.status.toNumber(),multiplier:e.multiplier.toNumber(),validDataCount:e.validDataCount.toNumber(),DataElement:e.DataElement.map(t=>({x:t.x.toNumber(),y:t.y.toNumber(),price:t.price.toNumber()}))}}function yc(m,e,t,n){let o=Ad(m,jn(m,e,$s(m,e,t)))/m.multiplier;return n?o:1/o}var ci=class{constructor({connection:e,modelDataPubKey:t=Vn}){this._layoutData={accountType:0,status:0,multiplier:0,validDataCount:0,DataElement:[]};this.connection=e,this.modelDataPubKey=t}get stableModelData(){return this._layoutData}async initStableModelLayout(){if(this._layoutData.validDataCount===0&&this.connection){let e=await this.connection.getAccountInfo(this.modelDataPubKey);e&&(this._layoutData=Pd(e==null?void 0:e.data))}}};import{PublicKey as hd}from"@solana/web3.js";import AT from"bn.js";import fr from"decimal.js";import{TOKEN_PROGRAM_ID as Td}from"@solana/spl-token";import{PublicKey as wd}from"@solana/web3.js";var kd=ye("Raydium_liquidity_serum");function bc({programId:m,marketId:e}){let t=[e.toBuffer()],n=0,o;for(;n<100;){try{let r=t.concat(Buffer.from([n]),Buffer.alloc(7));o=wd.createProgramAddressSync(r,m)}catch(r){if(r instanceof TypeError)throw r;n++;continue}return{publicKey:o,nonce:n}}throw kd.logWithError("unable to find a viable program address nonce","params",{programId:m,marketId:e}),new Error("unable to find a viable program address nonce")}function yr({programId:m}){let{publicKey:e}=ae([Buffer.from("amm_config_account_seed","utf-8")],m);return e}function Hn({name:m,programId:e,marketId:t}){let{publicKey:n}=ae([e.toBuffer(),t.toBuffer(),Buffer.from(m,"utf-8")],e);return n}function Id({programId:m,marketId:e}){let{publicKey:t}=ae([m.toBuffer(),e.toBuffer(),Buffer.from("open_order_associated_seed","utf-8")],m);return t}function ea({programId:m}){return ae([Buffer.from([97,109,109,32,97,117,116,104,111,114,105,116,121])],m)}function ta({version:m,marketVersion:e,marketId:t,baseMint:n,quoteMint:o,baseDecimals:r,quoteDecimals:i,programId:s,marketProgramId:u}){let a=Hn({name:"amm_associated_seed",programId:s,marketId:t}),c=Hn({name:"lp_mint_associated_seed",programId:s,marketId:t}),{publicKey:l,nonce:d}=ea({programId:s}),p=Hn({name:"coin_vault_associated_seed",programId:s,marketId:t}),f=Hn({name:"pc_vault_associated_seed",programId:s,marketId:t}),y=Hn({name:"temp_lp_token_associated_seed",programId:s,marketId:t}),b=Id({programId:s,marketId:t}),g=Hn({name:"target_associated_seed",programId:s,marketId:t}),A=Hn({name:"withdraw_associated_seed",programId:s,marketId:t}),{publicKey:h}=bc({programId:u,marketId:t});return{id:a,baseMint:n,quoteMint:o,lpMint:c,baseDecimals:r,quoteDecimals:i,lpDecimals:r,version:m,programId:s,authority:l,nonce:d,baseVault:p,quoteVault:f,lpVault:y,openOrders:b,targetOrders:g,withdrawQueue:A,marketVersion:e,marketProgramId:u,marketId:t,marketAuthority:h,lookupTableAccount:hd.default,configId:yr({programId:s})}}var Js={volume:0,volumeQuote:0,volumeFee:0,apr:0,feeApr:0,priceMin:0,priceMax:0,rewardApr:[]},br=m=>{let e={},t=Td.toBase58();return Object.keys(m).map(n=>{let o=m[n],[r,i]=[o.baseMint.toBase58(),o.quoteMint.toBase58()];e[n]={id:n,version:4,status:o.status.toNumber(),programId:o.programId.toBase58(),mintA:dt({address:r,programId:t,decimals:o.baseDecimal.toNumber()}),mintB:dt({address:i,programId:t,decimals:o.quoteDecimal.toNumber()}),rewardDefaultInfos:[],rewardDefaultPoolInfos:"Ecosystem",price:o.poolPrice.toNumber(),mintAmountA:new fr(o.mintAAmount.toString()).div(10**o.baseDecimal.toNumber()).toNumber(),mintAmountB:new fr(o.mintBAmount.toString()).div(10**o.quoteDecimal.toNumber()).toNumber(),baseReserve:o.baseReserve,quoteReserve:o.quoteReserve,feeRate:new fr(o.tradeFeeNumerator.toString()).div(o.tradeFeeDenominator.toString()).toNumber(),openTime:o.poolOpenTime.toString(),tvl:0,day:Js,week:Js,month:Js,pooltype:[],farmUpcomingCount:0,farmOngoingCount:0,farmFinishedCount:0,type:"Standard",marketId:o.marketId.toBase58(),configId:yr({programId:o.programId}).toBase58(),lpPrice:0,lpAmount:new fr(o.lpReserve.toString()).div(10**Math.min(o.baseDecimal.toNumber(),o.quoteDecimal.toNumber())).toNumber(),lpMint:dt({address:o.lpMint.toBase58(),programId:t,decimals:Math.min(o.baseDecimal.toNumber(),o.quoteDecimal.toNumber())}),burnPercent:0}}),e};import qe from"bn.js";import Ke from"decimal.js";import{PublicKey as li}from"@solana/web3.js";import mi from"bn.js";import{TOKEN_PROGRAM_ID as wc}from"@solana/spl-token";import{SystemProgram as Zn,SYSVAR_RENT_PUBKEY as xd,Transaction as gc,TransactionInstruction as Sd}from"@solana/web3.js";import{createInitializeAccountInstruction as Ac,TOKEN_PROGRAM_ID as Pc}from"@solana/spl-token";function Bd(m="accountFlags"){let e=new nr(m);return e.addBoolean("initialized"),e.addBoolean("market"),e.addBoolean("openOrders"),e.addBoolean("requestQueue"),e.addBoolean("eventQueue"),e.addBoolean("bids"),e.addBoolean("asks"),e}var na=F([ke(5),Bd("accountFlags"),N("ownAddress"),P("vaultSignerNonce"),N("baseMint"),N("quoteMint"),N("baseVault"),P("baseDepositsTotal"),P("baseFeesAccrued"),N("quoteVault"),P("quoteDepositsTotal"),P("quoteFeesAccrued"),P("quoteDustThreshold"),N("requestQueue"),N("eventQueue"),N("bids"),N("asks"),P("baseLotSize"),P("quoteLotSize"),P("feeRateBps"),P("referrerRebatesAccrued"),ke(7)]);function Kd({programId:m,marketInfo:e}){let t=F([D("version"),lt("instruction"),P("baseLotSize"),P("quoteLotSize"),Tt("feeRateBps"),P("vaultSignerNonce"),P("quoteDustThreshold")]),n=[{pubkey:e.id,isSigner:!1,isWritable:!0},{pubkey:e.requestQueue,isSigner:!1,isWritable:!0},{pubkey:e.eventQueue,isSigner:!1,isWritable:!0},{pubkey:e.bids,isSigner:!1,isWritable:!0},{pubkey:e.asks,isSigner:!1,isWritable:!0},{pubkey:e.baseVault,isSigner:!1,isWritable:!0},{pubkey:e.quoteVault,isSigner:!1,isWritable:!0},{pubkey:e.baseMint,isSigner:!1,isWritable:!1},{pubkey:e.quoteMint,isSigner:!1,isWritable:!1},{pubkey:e.authority?e.quoteMint:xd,isSigner:!1,isWritable:!1}].concat(e.authority?{pubkey:e.authority,isSigner:!1,isWritable:!1}:[]).concat(e.authority&&e.pruneAuthority?{pubkey:e.pruneAuthority,isSigner:!1,isWritable:!1}:[]),o=Buffer.alloc(t.span);return t.encode({version:0,instruction:0,baseLotSize:e.baseLotSize,quoteLotSize:e.quoteLotSize,feeRateBps:e.feeRateBps,vaultSignerNonce:e.vaultSignerNonce,quoteDustThreshold:e.quoteDustThreshold},o),new Sd({keys:n,programId:m,data:o})}async function gr({connection:m,wallet:e,marketInfo:t}){var i,s,u,a,c,l,d,p;let n=new gc,o=await m.getMinimumBalanceForRentExemption(165);n.add(Zn.createAccountWithSeed({fromPubkey:e,basePubkey:e,seed:t.baseVault.seed,newAccountPubkey:t.baseVault.publicKey,lamports:o,space:165,programId:Pc}),Zn.createAccountWithSeed({fromPubkey:e,basePubkey:e,seed:t.quoteVault.seed,newAccountPubkey:t.quoteVault.publicKey,lamports:o,space:165,programId:Pc}),Ac(t.baseVault.publicKey,t.baseMint,t.vaultOwner),Ac(t.quoteVault.publicKey,t.quoteMint,t.vaultOwner),Zn.createAccountWithSeed({fromPubkey:e,basePubkey:e,seed:t.id.seed,newAccountPubkey:t.id.publicKey,lamports:await m.getMinimumBalanceForRentExemption(na.span),space:na.span,programId:t.programId}));let r=new gc;return r.add(Zn.createAccountWithSeed({fromPubkey:e,basePubkey:e,seed:t.requestQueue.seed,newAccountPubkey:t.requestQueue.publicKey,lamports:t.lowestFeeMarket?6208320:await m.getMinimumBalanceForRentExemption((i=t.requestQueueSpace)!=null?i:5120+12),space:t.lowestFeeMarket?764:(s=t.requestQueueSpace)!=null?s:5120+12,programId:t.programId}),Zn.createAccountWithSeed({fromPubkey:e,basePubkey:e,seed:t.eventQueue.seed,newAccountPubkey:t.eventQueue.publicKey,lamports:t.lowestFeeMarket?79594560:await m.getMinimumBalanceForRentExemption((u=t.eventQueueSpace)!=null?u:262144+12),space:t.lowestFeeMarket?11308:(a=t.eventQueueSpace)!=null?a:262144+12,programId:t.programId}),Zn.createAccountWithSeed({fromPubkey:e,basePubkey:e,seed:t.bids.seed,newAccountPubkey:t.bids.publicKey,lamports:t.lowestFeeMarket?101977920:await m.getMinimumBalanceForRentExemption((c=t.orderbookQueueSpace)!=null?c:65536+12),space:t.lowestFeeMarket?14524:(l=t.orderbookQueueSpace)!=null?l:65536+12,programId:t.programId}),Zn.createAccountWithSeed({fromPubkey:e,basePubkey:e,seed:t.asks.seed,newAccountPubkey:t.asks.publicKey,lamports:t.lowestFeeMarket?101977920:await m.getMinimumBalanceForRentExemption((d=t.orderbookQueueSpace)!=null?d:65536+12),space:t.lowestFeeMarket?14524:(p=t.orderbookQueueSpace)!=null?p:65536+12,programId:t.programId}),Kd({programId:t.programId,marketInfo:{id:t.id.publicKey,requestQueue:t.requestQueue.publicKey,eventQueue:t.eventQueue.publicKey,bids:t.bids.publicKey,asks:t.asks.publicKey,baseVault:t.baseVault.publicKey,quoteVault:t.quoteVault.publicKey,baseMint:t.baseMint,quoteMint:t.quoteMint,baseLotSize:t.baseLotSize,quoteLotSize:t.quoteLotSize,feeRateBps:t.feeRateBps,vaultSignerNonce:t.vaultSignerNonce,quoteDustThreshold:t.quoteDustThreshold}})),[{transaction:n,signer:[],instructionTypes:[q.CreateAccount,q.CreateAccount,q.InitAccount,q.InitAccount]},{transaction:r,signer:[],instructionTypes:[q.CreateAccount,q.CreateAccount,q.CreateAccount,q.CreateAccount,q.CreateAccount,q.InitMarket]}]}var Po=class extends Ne{async create({baseInfo:e,quoteInfo:t,lotSize:n,tickSize:o,dexProgramId:r,requestQueueSpace:i,eventQueueSpace:s,orderbookQueueSpace:u,lowestFeeMarket:a,assignSeed:c,txVersion:l,computeBudgetConfig:d,txTipConfig:p,feePayer:f}){let y=this.scope.ownerPubKey,b=c?`${e.mint.toBase58().slice(0,10)}-${t.mint.toBase58().slice(0,10)}-${c}`:void 0,g=Ge({fromPublicKey:y,programId:r,assignSeed:b&&`${b}-market`}),A=Ge({fromPublicKey:y,programId:r,assignSeed:b&&`${b}-request`}),h=Ge({fromPublicKey:y,programId:r,assignSeed:b&&`${b}-event`}),T=Ge({fromPublicKey:y,programId:r,assignSeed:b&&`${b}-bids`}),k=Ge({fromPublicKey:y,programId:r,assignSeed:b&&`${b}-asks`}),w=Ge({fromPublicKey:y,programId:wc,assignSeed:b&&`${b}-baseVault`}),S=Ge({fromPublicKey:y,programId:wc,assignSeed:b&&`${b}-quoteVault`}),B=0,K=new mi(100);function I(){let G=new mi(0);for(;;)try{return{vaultOwner:li.createProgramAddressSync([g.publicKey.toBuffer(),G.toArrayLike(Buffer,"le",8)],r),vaultSignerNonce:G}}catch{if(G.iaddn(1),G.gt(new mi(25555)))throw Error("find vault owner error")}}let{vaultOwner:C,vaultSignerNonce:O}=I(),M=new mi(Math.round(10**e.decimals*n)),R=new mi(Math.round(n*10**t.decimals*o));if(M.eq(At))throw Error("lot size is too small");if(R.eq(At))throw Error("tick size or lot size is too small");let L=await gr({connection:this.scope.connection,wallet:this.scope.ownerPubKey,marketInfo:{programId:r,id:g,baseMint:e.mint,quoteMint:t.mint,baseVault:w,quoteVault:S,vaultOwner:C,requestQueue:A,eventQueue:h,bids:T,asks:k,feeRateBps:B,quoteDustThreshold:K,vaultSignerNonce:O,baseLotSize:M,quoteLotSize:R,requestQueueSpace:i,eventQueueSpace:s,orderbookQueueSpace:u,lowestFeeMarket:a}}),_=this.createTxBuilder(f);_.addInstruction({instructions:L[0].transaction.instructions,signers:L[0].signer});for await(let G of L.slice(1,L.length))_.addInstruction({instructions:G.transaction.instructions,signers:G.signer,instructionTypes:G.instructionTypes});return l===0?_.sizeCheckBuildV0({computeBudgetConfig:d,address:{marketId:g.publicKey,requestQueue:A.publicKey,eventQueue:h.publicKey,bids:T.publicKey,asks:k.publicKey,baseVault:w.publicKey,quoteVault:S.publicKey,baseMint:new li(e.mint),quoteMint:new li(t.mint)}}):_.sizeCheckBuild({computeBudgetConfig:d,address:{marketId:g.publicKey,requestQueue:A.publicKey,eventQueue:h.publicKey,bids:T.publicKey,asks:k.publicKey,baseVault:w.publicKey,quoteVault:S.publicKey,baseMint:new li(e.mint),quoteMint:new li(t.mint)}})}};var di=class extends Ne{constructor(t){super(t);this.stableLayout=new ci({connection:this.scope.connection,modelDataPubKey:this.scope.cluster==="mainnet"?void 0:cn.MODEL_DATA_PUBKEY})}async initLayout(){await this.stableLayout.initStableModelLayout()}async load(){this.checkDisabled()}computePairAmount({poolInfo:t,amount:n,slippage:o,baseIn:r}){let i=new qe(new Ke(n).mul(10**t[r?"mintA":"mintB"].decimals).toFixed(0)),s=mr(t[r?"mintB":"mintA"]),[u,a]=[new qe(new Ke(t.mintAmountA).mul(10**t.mintA.decimals).toString()),new qe(new Ke(t.mintAmountB).mul(10**t.mintB.decimals).toString())],c=new qe(new Ke(t.lpAmount).mul(10**t.lpMint.decimals).toFixed(0,Ke.ROUND_DOWN));this.logDebug("baseReserve:",u.toString(),"quoteReserve:",a.toString()),this.logDebug("tokenIn:",r?t.mintA.symbol:t.mintB.symbol,"amountIn:",i.toString(),"anotherToken:",r?t.mintB.symbol:t.mintA.symbol,"slippage:",`${o.toSignificant()}%`,"baseReserve",u.toString(),"quoteReserve",a.toString());let l=r?"base":"quote";this.logDebug("input side:",l);let d=At;i.isZero()||(d=l==="base"?Vi(i.mul(a),u):Vi(i.mul(u),a)),this.logDebug("amountRaw:",d.toString(),"lpAmount:",c.toString());let p=Vi(i.mul(c),l==="base"?u:a);this.logDebug("liquidity:",p.toString());let f=new tt(new qe(1)).add(o),y=new tt(new qe(1)).sub(o),b=f.mul(d).quotient,g=y.mul(d).quotient,A=new Ie(s,d),h=new Ie(s,b),T=new Ie(s,g);return this.logDebug("anotherAmount:",A.toFixed(),"maxAnotherAmount:",h.toFixed()),{anotherAmount:A,maxAnotherAmount:h,minAnotherAmount:T,liquidity:p}}async getAmmPoolKeys(t){return(await this.scope.api.fetchPoolKeysById({idList:[t]}))[0]}async addLiquidity(t){let{poolInfo:n,poolKeys:o,amountInA:r,amountInB:i,otherAmountMin:s,fixedSide:u,config:a,txVersion:c,computeBudgetConfig:l,txTipConfig:d,feePayer:p}=t;this.scope.availability.addStandardPosition===!1&&this.logAndCreateError("add liquidity feature disabled in your region"),this.logDebug("amountInA:",r,"amountInB:",i),(r.isZero()||i.isZero())&&this.logAndCreateError("amounts must greater than zero","amountInA & amountInB",{amountInA:r.toFixed(),amountInB:i.toFixed()});let{account:f}=this.scope,{bypassAssociatedCheck:y,checkCreateATAOwner:b}=v({bypassAssociatedCheck:!1,checkCreateATAOwner:!1},a),[g,A]=[r.token,i.token],h=await f.getCreatedTokenAccount({mint:g.mint,associatedOnly:!1}),T=await f.getCreatedTokenAccount({mint:A.mint,associatedOnly:!1});!h&&!T&&this.logAndCreateError("cannot found target token accounts","tokenAccounts",f.tokenAccounts);let k=await f.getCreatedTokenAccount({mint:new Ye(n.lpMint.address)}),w=[g,A],S=[h,T],B=[r.raw,i.raw],K=r.token.mint.toBase58()===n.mintA.address?"base":"quote",I="base";["quote","base"].includes(K)||this.logAndCreateError("invalid fixedSide","fixedSide",u),K==="quote"?(w.reverse(),S.reverse(),B.reverse(),I=u==="a"?"quote":"base"):K==="base"&&(I=u==="a"?"base":"quote");let[C,O]=w,[M,R]=S,[L,_]=B,G=o!=null?o:await this.getAmmPoolKeys(n.id),Q=this.createTxBuilder(p),J=await f.handleTokenAccount({side:"in",amount:L,mint:C.mint,tokenAccount:M,bypassAssociatedCheck:y,checkCreateATAOwner:b}),{tokenAccount:se}=J,ce=_e(J,["tokenAccount"]);Q.addInstruction(ce);let he=await f.handleTokenAccount({side:"in",amount:_,mint:O.mint,tokenAccount:R,bypassAssociatedCheck:y,checkCreateATAOwner:b}),{tokenAccount:ne}=he,le=_e(he,["tokenAccount"]);Q.addInstruction(le);let Ue=await f.handleTokenAccount({side:"out",amount:0,mint:new Ye(n.lpMint.address),tokenAccount:k,bypassAssociatedCheck:y,checkCreateATAOwner:b}),{tokenAccount:fe}=Ue,de=_e(Ue,["tokenAccount"]);return Q.addInstruction(de),Q.addInstruction({instructions:[lc({poolInfo:n,poolKeys:G,userKeys:{baseTokenAccount:se,quoteTokenAccount:ne,lpTokenAccount:fe,owner:this.scope.ownerPubKey},baseAmountIn:L,quoteAmountIn:_,otherAmountMin:s.raw,fixedSide:I})],instructionTypes:[n.pooltype.includes("StablePool")?q.AmmV5AddLiquidity:q.AmmV4AddLiquidity],lookupTableAddress:G.lookupTableAccount?[G.lookupTableAccount]:[]}),Q.addCustomComputeBudget(l),Q.addTipInstruction(d),c===0?await Q.buildV0():Q.build()}async removeLiquidity(t){this.scope.availability.removeStandardPosition===!1&&this.logAndCreateError("remove liquidity feature disabled in your region");let{poolInfo:n,poolKeys:o,lpAmount:r,baseAmountMin:i,quoteAmountMin:s,config:u,txVersion:a,computeBudgetConfig:c,txTipConfig:l,feePayer:d}=t,p=o!=null?o:await this.getAmmPoolKeys(n.id),[f,y,b]=[new Ye(n.mintA.address),new Ye(n.mintB.address),new Ye(n.lpMint.address)];this.logDebug("lpAmount:",r),this.logDebug("baseAmountMin:",i),this.logDebug("quoteAmountMin:",s),r.isZero()&&this.logAndCreateError("amount must greater than zero","lpAmount",r.toString());let{account:g}=this.scope,A=await g.getCreatedTokenAccount({mint:b,associatedOnly:!1});A||this.logAndCreateError("cannot found lpTokenAccount","tokenAccounts",g.tokenAccounts);let h=await g.getCreatedTokenAccount({mint:f}),T=await g.getCreatedTokenAccount({mint:y}),k=this.createTxBuilder(d),{bypassAssociatedCheck:w,checkCreateATAOwner:S}=v({bypassAssociatedCheck:!1,checkCreateATAOwner:!1},u),O=await g.handleTokenAccount({side:"out",amount:0,mint:f,tokenAccount:h,bypassAssociatedCheck:w,checkCreateATAOwner:S}),{tokenAccount:B}=O,K=_e(O,["tokenAccount"]);k.addInstruction(K);let M=await g.handleTokenAccount({side:"out",amount:0,mint:y,tokenAccount:T,bypassAssociatedCheck:w,checkCreateATAOwner:S}),{tokenAccount:I}=M,C=_e(M,["tokenAccount"]);return k.addInstruction(C),k.addInstruction({instructions:[Hs({poolInfo:n,poolKeys:p,userKeys:{lpTokenAccount:A,baseTokenAccount:B,quoteTokenAccount:I,owner:this.scope.ownerPubKey},lpAmount:r,baseAmountMin:i,quoteAmountMin:s})],lookupTableAddress:p.lookupTableAccount?[p.lookupTableAccount]:[],instructionTypes:[n.pooltype.includes("StablePool")?q.AmmV5RemoveLiquidity:q.AmmV4RemoveLiquidity]}),k.addCustomComputeBudget(c),k.addTipInstruction(l),a===0?await k.buildV0():k.build()}async removeAllLpAndCreateClmmPosition({poolInfo:t,clmmPoolInfo:n,removeLpAmount:o,createPositionInfo:r,farmInfo:i,userFarmLpAmount:s,base:u,computeBudgetConfig:a,payer:c,userAuxiliaryLedgers:l,tokenProgram:d=Cn,checkCreateATAOwner:p=!0,getEphemeralSigners:f,txVersion:y,feePayer:b}){if((this.scope.availability.removeStandardPosition===!1||this.scope.availability.createConcentratedPosition===!1)&&this.logAndCreateError("remove liquidity or create position feature disabled in your region"),!(t.mintA.address===n.mintA.address||t.mintA.address===n.mintB.address)||!(t.mintB.address===n.mintA.address||t.mintB.address===n.mintB.address))throw Error("mint check error");let g=this.createTxBuilder(b),A={};for(let G of this.scope.account.tokenAccountRawInfos)(A[G.accountInfo.mint.toString()]===void 0||Z(this.scope.ownerPubKey,G.accountInfo.mint,Cn).publicKey.equals(G.pubkey))&&(A[G.accountInfo.mint.toString()]=G.pubkey);let h=A[t.lpMint.address];if(h===void 0)throw Error("find lp account error in trade accounts");let T=o.add(s!=null?s:new qe(0)),k=t.mintA.address===Ve.WSOL.mint.toString(),w=t.mintB.address===Ve.WSOL.mint.toString(),{account:S,instructionParams:B}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:Cn,mint:new Ye(t.mintA.address),owner:this.scope.ownerPubKey,createInfo:k?{payer:this.scope.ownerPubKey}:void 0,skipCloseAccount:!k,notUseTokenAccount:k,associatedOnly:!0,checkCreateATAOwner:p});if(g.addInstruction(B||{}),S===void 0)throw new Error("base token account not found");let{account:K,instructionParams:I}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:Cn,mint:new Ye(t.mintB.address),owner:this.scope.ownerPubKey,createInfo:w?{payer:this.scope.ownerPubKey,amount:0}:void 0,skipCloseAccount:!w,notUseTokenAccount:w,associatedOnly:!0,checkCreateATAOwner:p});if(g.addInstruction(I||{}),K===void 0)throw new Error("quote token account not found");if(A[t.mintA.address]=S,A[t.mintB.address]=K,i!==void 0&&!(s!=null&&s.isZero())){let G=Lt[i.programId],Q=Ot({programId:new Ye(i.programId),poolId:new Ye(i.id),owner:this.scope.ownerPubKey,version:G}),se,ce=await this.scope.connection.getAccountInfo(Q);if(ce&&(se=Xo(G).decode(ce.data)),G!==6&&!se){let{instruction:Ue,instructionType:Le}=Qo({id:new Ye(i.id),programId:new Ye(i.programId),version:G,ledger:Q,owner:this.scope.ownerPubKey});g.addInstruction({instructions:[Ue],instructionTypes:[Le]})}let ne=[];for(let Ue of i.rewardInfos){let Le=Ue.mint.address===Ve.WSOL.mint.toString();if(A[Ue.mint.address])ne.push(A[Ue.mint.address]);else{let{account:Rt,instructionParams:$e}=await this.scope.account.getOrCreateTokenAccount({mint:new Ye(Ue.mint.address),tokenProgram:d,owner:this.scope.ownerPubKey,skipCloseAccount:!Le,createInfo:{payer:c||this.scope.ownerPubKey},associatedOnly:!0,checkCreateATAOwner:p});Rt||this.logAndCreateError("farm reward account not found:",Ue.mint.address),$e&&g.addInstruction($e),ne.push(Rt)}}let le=(await this.scope.api.fetchFarmKeysById({ids:i.id}))[0],fe={userAuxiliaryLedgers:l,amount:s,owner:this.scope.ownerPubKey,farmInfo:i,farmKeys:le,lpAccount:h,rewardAccounts:ne},de=Lt[i.programId],J=de===6?jo(fe):de===5?Yo(fe):Ho(fe),he={3:q.FarmV3Withdraw,5:q.FarmV5Withdraw,6:q.FarmV6Withdraw};g.addInstruction({instructions:[J],instructionTypes:[he[de]]})}let C=await this.getAmmPoolKeys(t.id),O=Hs({poolInfo:t,poolKeys:C,userKeys:{lpTokenAccount:h,baseTokenAccount:S,quoteTokenAccount:K,owner:this.scope.ownerPubKey},lpAmount:T,baseAmountMin:0,quoteAmountMin:0});g.addInstruction({instructions:[O],instructionTypes:[t.pooltype.includes("StablePool")?q.AmmV5RemoveLiquidity:q.AmmV4RemoveLiquidity],lookupTableAddress:C.lookupTableAccount?[C.lookupTableAccount]:[]});let[M,R]=t.mintA.address===n.mintA.address?[S,K]:[K,S],L=await this.scope.clmm.getClmmPoolKeys(n.id),_=await Se.openPositionFromBaseInstructions(W(v({poolInfo:n,poolKeys:L,ownerInfo:{feePayer:this.scope.ownerPubKey,wallet:this.scope.ownerPubKey,tokenAccountA:M,tokenAccountB:R},withMetadata:"create"},r),{base:u,getEphemeralSigners:f}));return g.addInstruction({instructions:[..._.instructions],signers:_.signers,instructionTypes:[..._.instructionTypes],lookupTableAddress:L.lookupTableAccount?[L.lookupTableAccount]:[]}),y===0?g.sizeCheckBuildV0({computeBudgetConfig:a}):g.sizeCheckBuild({computeBudgetConfig:a})}async createPoolV4({programId:t,marketInfo:n,baseMintInfo:o,quoteMintInfo:r,baseAmount:i,quoteAmount:s,startTime:u,ownerInfo:a,associatedOnly:c=!1,checkCreateATAOwner:l=!1,tokenProgram:d,txVersion:p,feeDestinationId:f,computeBudgetConfig:y,txTipConfig:b,feePayer:g}){var R;let A=a.feePayer||((R=this.scope.owner)==null?void 0:R.publicKey),h=a.useSOLBalance&&o.mint.equals(Ar),T=a.useSOLBalance&&r.mint.equals(Ar),k=this.createTxBuilder(g),{account:w,instructionParams:S}=await this.scope.account.getOrCreateTokenAccount({mint:o.mint,owner:this.scope.ownerPubKey,createInfo:h?{payer:A,amount:i}:void 0,notUseTokenAccount:h,skipCloseAccount:!h,associatedOnly:h?!1:c,checkCreateATAOwner:l});k.addInstruction(S||{});let{account:B,instructionParams:K}=await this.scope.account.getOrCreateTokenAccount({mint:r.mint,owner:this.scope.ownerPubKey,createInfo:T?{payer:A,amount:s}:void 0,notUseTokenAccount:T,skipCloseAccount:!T,associatedOnly:T?!1:c,checkCreateATAOwner:l});if(k.addInstruction(K||{}),w===void 0||B===void 0)throw Error("you don't has some token account");let I=ta({version:4,marketVersion:3,marketId:n.marketId,baseMint:o.mint,quoteMint:r.mint,baseDecimals:o.decimals,quoteDecimals:r.decimals,programId:t,marketProgramId:n.programId}),C={programId:t,ammId:I.id,ammAuthority:I.authority,ammOpenOrders:I.openOrders,lpMint:I.lpMint,coinMint:I.baseMint,pcMint:I.quoteMint,coinVault:I.baseVault,pcVault:I.quoteVault,withdrawQueue:I.withdrawQueue,ammTargetOrders:I.targetOrders,poolTempLp:I.lpVault,marketProgramId:I.marketProgramId,marketId:I.marketId,ammConfigId:I.configId,feeDestinationId:f},{instruction:O,instructionType:M}=Zs(W(v({},C),{userWallet:this.scope.ownerPubKey,userCoinVault:w,userPcVault:B,userLpVault:Z(this.scope.ownerPubKey,I.lpMint,d).publicKey,nonce:I.nonce,openTime:u,coinAmount:i,pcAmount:s}));return k.addInstruction({instructions:[O],instructionTypes:[M]}),k.addCustomComputeBudget(y),k.addTipInstruction(b),k.versionBuild({txVersion:p,extInfo:{address:C}})}async createMarketAndPoolV4({programId:t=Di,marketProgram:n=$a,feeDestinationId:o=eu,tokenProgram:r,baseMintInfo:i,quoteMintInfo:s,baseAmount:u,quoteAmount:a,startTime:c,ownerInfo:l,lowestFeeMarket:d,assignSeed:p,associatedOnly:f=!1,checkCreateATAOwner:y=!1,lotSize:b=1,tickSize:g=.01,txVersion:A,computeBudgetConfig:h,txTipConfig:T,feePayer:k}){var so,qr,Co;let w=this.scope.ownerPubKey,S=l.feePayer||((so=this.scope.owner)==null?void 0:so.publicKey),B=l.useSOLBalance&&i.mint.equals(Ar),K=l.useSOLBalance&&s.mint.equals(Ar),I=p?`${i.mint.toBase58().slice(0,7)}-${s.mint.toBase58().slice(0,7)}-${p}`:void 0,C=Ge({fromPublicKey:w,programId:n,assignSeed:I&&`${I}-market`}),O=Ge({fromPublicKey:w,programId:n,assignSeed:I&&`${I}-request`}),M=Ge({fromPublicKey:w,programId:n,assignSeed:I&&`${I}-event`}),R=Ge({fromPublicKey:w,programId:n,assignSeed:I&&`${I}-bids`}),L=Ge({fromPublicKey:w,programId:n,assignSeed:I&&`${I}-asks`}),_=Ge({fromPublicKey:w,programId:Cn,assignSeed:I&&`${I}-baseVault`}),G=Ge({fromPublicKey:w,programId:Cn,assignSeed:I&&`${I}-quoteVault`}),Q=0,se=new qe(100);function ce(){let kt=new qe(0);for(;;)try{return{vaultOwner:Ye.createProgramAddressSync([C.publicKey.toBuffer(),kt.toArrayLike(Buffer,"le",8)],n),vaultSignerNonce:kt}}catch{if(kt.iaddn(1),kt.gt(new qe(25555)))throw Error("find vault owner error")}}let{vaultOwner:ne,vaultSignerNonce:le}=ce(),fe=new qe(Math.round(10**i.decimals*b)),de=new qe(Math.round(b*10**s.decimals*g));if(fe.eq(At))throw Error("lot size is too small");if(de.eq(At))throw Error("tick size or lot size is too small");let J=await gr({connection:this.scope.connection,wallet:this.scope.ownerPubKey,marketInfo:{programId:n,vaultOwner:ne,baseMint:i.mint,quoteMint:s.mint,id:C,baseVault:_,quoteVault:G,requestQueue:O,eventQueue:M,bids:R,asks:L,feeRateBps:Q,quoteDustThreshold:se,vaultSignerNonce:le,baseLotSize:fe,quoteLotSize:de,lowestFeeMarket:d}}),he=this.createTxBuilder(k);he.addInstruction({instructions:J[0].transaction.instructions,signers:J[0].signer});for await(let kt of J.slice(1,J.length))he.addInstruction({instructions:kt.transaction.instructions,signers:kt.signer,instructionTypes:kt.instructionTypes});let{account:Ue,instructionParams:Le}=await this.scope.account.getOrCreateTokenAccount({mint:i.mint,owner:this.scope.ownerPubKey,createInfo:B?{payer:S,amount:u}:void 0,notUseTokenAccount:B,skipCloseAccount:!B,associatedOnly:B?!1:f,checkCreateATAOwner:y,assignSeed:B&&I?`${I}-wsol`:void 0});he.addInstruction(Le||{});let{account:Rt,instructionParams:$e}=await this.scope.account.getOrCreateTokenAccount({mint:s.mint,owner:this.scope.ownerPubKey,createInfo:K?{payer:S,amount:a}:void 0,notUseTokenAccount:K,skipCloseAccount:!K,associatedOnly:K?!1:f,checkCreateATAOwner:y,assignSeed:K&&I?`${I}-wsol`:void 0});if(he.addInstruction($e||{}),Ue===void 0)throw Error("you don't has base token account");if(Rt===void 0)throw Error("you don't has quote token account");let Je=ta({version:4,marketVersion:3,marketId:C.publicKey,baseMint:i.mint,quoteMint:s.mint,baseDecimals:i.decimals,quoteDecimals:s.decimals,programId:t,marketProgramId:n}),So={programId:t,ammId:Je.id,ammAuthority:Je.authority,ammOpenOrders:Je.openOrders,lpMint:Je.lpMint,coinMint:Je.baseMint,pcMint:Je.quoteMint,coinVault:Je.baseVault,pcVault:Je.quoteVault,withdrawQueue:Je.withdrawQueue,ammTargetOrders:Je.targetOrders,poolTempLp:Je.lpVault,marketProgramId:Je.marketProgramId,marketId:Je.marketId,ammConfigId:Je.configId,feeDestinationId:o},{instruction:Ko,instructionType:en}=Zs(W(v({},So),{userWallet:this.scope.ownerPubKey,userCoinVault:Ue,userPcVault:Rt,userLpVault:Z(this.scope.ownerPubKey,Je.lpMint,r).publicKey,nonce:Je.nonce,openTime:c,coinAmount:u,pcAmount:a}));he.addInstruction({instructions:[Ko],instructionTypes:[en]});let ro=B||K?[((qr=Le==null?void 0:Le.instructions)==null?void 0:qr[0])||((Co=$e==null?void 0:$e.instructions)==null?void 0:Co[0])].filter(kt=>!!kt):void 0;return A===0?he.sizeCheckBuildV0({computeBudgetConfig:h,splitIns:ro,address:v({requestQueue:O.publicKey,eventQueue:M.publicKey,bids:R.publicKey,asks:L.publicKey,baseVault:_.publicKey,quoteVault:G.publicKey,baseMint:new Ye(i.mint),quoteMint:new Ye(s.mint)},So)}):he.sizeCheckBuild({computeBudgetConfig:h,splitIns:ro,address:v({requestQueue:O.publicKey,eventQueue:M.publicKey,bids:R.publicKey,asks:L.publicKey,baseVault:_.publicKey,quoteVault:G.publicKey,baseMint:new Ye(i.mint),quoteMint:new Ye(s.mint)},So)})}async getCreatePoolFee({programId:t}){let n=yr({programId:t}),o=await this.scope.connection.getAccountInfo(n,{dataSlice:{offset:536,length:8}});if(o===null)throw Error("get config account error");return uc.decode(o.data).fee}computeAmountOut({poolInfo:t,amountIn:n,mintIn:o,mintOut:r,slippage:i}){let[s,u]=[o.toString(),r.toString()];if(s!==t.mintA.address&&s!==t.mintB.address)throw new Error("toke not match");if(u!==t.mintA.address&&u!==t.mintB.address)throw new Error("toke not match");let{baseReserve:a,quoteReserve:c}=t,l=[a,c],d=[t.mintA.decimals,t.mintB.decimals],p=s==t.mintA.address?"base":"quote";p==="quote"&&(l.reverse(),d.reverse());let[f,y]=l,[b,g]=d,A=t.version===4,h;if(A)h=new Ke(y.toString()).div(10**g).div(new Ke(f.toString()).div(10**b));else{let M=yc(this.stableLayout.stableModelData,a.toNumber(),c.toNumber(),!1);p==="quote"?h=new Ke(1e6).div(M*1e6):h=new Ke(M*1e6).div(1e6)}let T=n,k=new qe(0),w=new qe(0);if(!T.isZero())if(A){w=zt(T.mul(Xs),dr);let M=T.sub(w),R=f.add(M);k=y.mul(M).div(R)}else{w=T.mul(new qe(2)).div(new qe(1e4));let M=T.sub(w);p==="quote"?k=new qe(pc(this.stableLayout.stableModelData,c.toNumber(),a.toNumber(),M.toNumber())):k=new qe(fc(this.stableLayout.stableModelData,c.toNumber(),a.toNumber(),M.toNumber()))}let S=new qe(new Ke(k.toString()).mul(1-i).toFixed(0)),B=k,K=S,I=new Ke(k.toString()).div(new Ke(T.sub(w).toString()).toFixed(0));!T.isZero()&&!k.isZero()&&(I=new Ke(k.toString()).div(10**g).div(new Ke(T.sub(w).toString()).div(10**b)));let C=h.sub(I).div(h).mul(100);return{amountOut:B,minAmountOut:K,currentPrice:h,executionPrice:I,priceImpact:C,fee:w}}computeAmountIn({poolInfo:t,amountOut:n,mintIn:o,mintOut:r,slippage:i}){let{baseReserve:s,quoteReserve:u}=t;o.toString()!==t.mintA.address&&o.toString()!==t.mintB.address&&this.logAndCreateError("mintIn does not match pool"),r.toString()!==t.mintA.address&&r.toString()!==t.mintB.address&&this.logAndCreateError("mintOut does not match pool"),this.logDebug("baseReserve:",s.toString()),this.logDebug("quoteReserve:",u.toString());let a=o.toString()===t.mintA.address,[c,l]=a?[t.mintA,t.mintB]:[t.mintB,t.mintA];this.logDebug("currencyOut:",l.symbol||l.address),this.logDebug("amountOut:",new Ke(n.toString()).div(10**l.decimals).toDecimalPlaces(l.decimals).toString(),c.symbol||c.address),this.logDebug("slippage:",`${i*100}%`);let d=[s,u],p=a?"quote":"base";p==="base"&&d.reverse(),this.logDebug("output side:",p);let[f,y]=d,b=new Ke(y.toString()).div(10**t[a?"mintB":"mintA"].decimals).div(new Ke(f.toString()).div(10**t[a?"mintA":"mintB"].decimals));this.logDebug("currentPrice:",`1 ${c.symbol||c.address} \u2248 ${b.toString()} ${l.symbol||l.address}`),this.logDebug("currentPrice invert:",`1 ${l.symbol||l.address} \u2248 ${new Ke(1).div(b).toString()} ${c.symbol||c.address}`);let g=new qe(0),A=n;if(!A.isZero()){A.gt(y)&&(A=y.sub(new qe(1)));let K=y.sub(A);g=f.mul(A).div(K).mul(dr).div(dr.sub(Xs))}let h=new qe(new Ke(g.toString()).mul(1+i).toFixed(0)),T=g,k=h;this.logDebug("amountIn:",new Ke(T.toString()).div(10**c.decimals).toDecimalPlaces(c.decimals).toString()),this.logDebug("maxAmountIn:",new Ke(k.toString()).div(10**c.decimals).toDecimalPlaces(c.decimals).toString());let w=null;!g.isZero()&&!A.isZero()&&(w=new Ke(A.toString()).div(10**l.decimals).div(new Ke(g.toString()).div(10**c.decimals)),this.logDebug("executionPrice:",`1 ${l.symbol||l.address} \u2248 ${w.toDecimalPlaces(Math.max(t.mintA.decimals,t.mintB.decimals)).toString()} ${c.symbol||c.address}`),this.logDebug("executionPrice invert:",`1 ${l.symbol||l.address} \u2248 ${new Ke(1).div(w).toDecimalPlaces(Math.max(t.mintA.decimals,t.mintB.decimals)).toString()} ${c.symbol||c.address}`));let S=b.mul(T.toString()),B=S.sub(n.toString()).abs().div(S);return this.logDebug("priceImpact:",`${B.toString()}%`),{amountIn:T,maxAmountIn:k,currentPrice:b,executionPrice:w,priceImpact:B}}async swap({poolInfo:t,poolKeys:n,amountIn:o,amountOut:r,inputMint:i,fixedSide:s,txVersion:u,config:a,computeBudgetConfig:c,txTipConfig:l,feePayer:d}){let p=this.createTxBuilder(d),{associatedOnly:f=!0,inputUseSolBalance:y=!0,outputUseSolBalance:b=!0}=a||{},[g,A]=i===t.mintA.address?[t.mintA,t.mintB]:[t.mintB,t.mintA],h=y&&g.address===Y.toBase58(),T=b&&A.address===Y.toBase58(),{account:k,instructionParams:w}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:Cn,mint:new Ye(g.address),owner:this.scope.ownerPubKey,createInfo:h?{payer:this.scope.ownerPubKey,amount:o}:void 0,skipCloseAccount:!h,notUseTokenAccount:h,associatedOnly:f});p.addInstruction(w||{}),k||this.logAndCreateError("input token account not found",{token:g.symbol||g.address,tokenAccountIn:k,inputTokenUseSolBalance:h,associatedOnly:f});let{account:S,instructionParams:B}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:Cn,mint:new Ye(A.address),owner:this.scope.ownerPubKey,createInfo:{payer:this.scope.ownerPubKey,amount:0},skipCloseAccount:!T,notUseTokenAccount:T,associatedOnly:T?!1:f});p.addInstruction(B||{}),S===void 0&&this.logAndCreateError("output token account not found",{token:A.symbol||A.address,tokenAccountOut:S,outputTokenUseSolBalance:T,associatedOnly:f});let K=n||await this.getAmmPoolKeys(t.id),I=4;return t.pooltype.includes("StablePool")&&(I=5),p.addInstruction({instructions:[pr({version:I,poolKeys:K,userKeys:{tokenAccountIn:k,tokenAccountOut:S,owner:this.scope.ownerPubKey},amountIn:o,amountOut:r,fixedSide:s})],instructionTypes:[I===4?q.AmmV4SwapBaseIn:q.AmmV5SwapBaseIn]}),p.addCustomComputeBudget(c),p.addTipInstruction(l),p.versionBuild({txVersion:u})}async getRpcPoolInfo(t){return(await this.getRpcPoolInfos([t]))[t]}async getRpcPoolInfos(t,n){let o=await Ce(this.scope.connection,t.map(c=>({pubkey:new Ye(c)})),n),r={},i=[];for(let c=0;c<t.length;c++){let l=o[c];if(l===null||!l.accountInfo)throw Error("fetch pool info error: "+String(t[c]));let d=ai.decode(l.accountInfo.data);r[String(t[c])]=W(v({},d),{programId:l.accountInfo.owner}),i.push(d.baseVault,d.quoteVault)}let s={},u=await Ce(this.scope.connection,i.map(c=>({pubkey:new Ye(c)})),n);for(let c=0;c<i.length;c++){let l=u[c].accountInfo;if(l===null)throw Error("fetch vault info error: "+i[c]);s[String(i[c])]=new qe(Cd.decode(l.data).amount.toString())}let a={};for(let[c,l]of Object.entries(r)){let d=s[l.baseVault.toString()].sub(l.baseNeedTakePnl),p=s[l.quoteVault.toString()].sub(l.quoteNeedTakePnl);a[c]=W(v({},l),{baseReserve:d,mintAAmount:s[l.baseVault.toString()],mintBAmount:s[l.quoteVault.toString()],quoteReserve:p,poolPrice:new Ke(p.toString()).div(new Ke(10).pow(l.quoteDecimal.toString())).div(new Ke(d.toString()).div(new Ke(10).pow(l.baseDecimal.toString())))})}return a}async getPoolInfoFromRpc({poolId:t}){let n=await this.getRpcPoolInfo(t),o=br({[t]:n}),r=o[t],i=await this.scope.tradeV2.computePoolToPoolKeys({pools:[o[t]],ammRpcData:{[t]:n}});return{poolRpcData:n,poolInfo:r,poolKeys:i[0]}}};import{PublicKey as z}from"@solana/web3.js";import bt from"bn.js";import $n from"decimal.js";import{AccountLayout as kc,createAssociatedTokenAccountIdempotentInstruction as hc,TOKEN_2022_PROGRAM_ID as Rn,TOKEN_PROGRAM_ID as pi}from"@solana/spl-token";var fi=class extends Ne{constructor(e){super(e)}async getClmmPoolKeys(e){return(await this.scope.api.fetchPoolKeysById({idList:[e]}))[0]}async createPool(e){var S;let{programId:t,owner:n=((S=this.scope.owner)==null?void 0:S.publicKey)||z.default,mint1:o,mint2:r,ammConfig:i,initialPrice:s,computeBudgetConfig:u,forerunCreate:a,getObserveState:c,txVersion:l,txTipConfig:d,feePayer:p}=e,f=this.createTxBuilder(p),[y,b,g]=new bt(new z(o.address).toBuffer()).gt(new bt(new z(r.address).toBuffer()))?[r,o,new $n(1).div(s)]:[o,r,s],A=re.priceToSqrtPriceX64(g,y.decimals,b.decimals),h=[],T=[];y.programId===Rn.toBase58()&&T.push(Es(t,new z(y.address)).publicKey),b.programId===Rn.toBase58()&&T.push(Es(t,new z(b.address)).publicKey),(await this.scope.connection.getMultipleAccountsInfo(T)).forEach((B,K)=>{B&&h.push(T[K])});let w=await Se.createPoolInstructions({connection:this.scope.connection,programId:t,owner:n,mintA:y,mintB:b,ammConfigId:i.id,initialPriceX64:A,forerunCreate:!c&&a,extendMintAccount:h});return f.addInstruction(w),f.addCustomComputeBudget(u),f.addTipInstruction(d),f.versionBuild({txVersion:l,extInfo:{address:W(v({},w.address),{observationId:w.address.observationId.toBase58(),exBitmapAccount:w.address.exBitmapAccount.toBase58(),programId:t.toString(),id:w.address.poolId.toString(),mintA:y,mintB:b,openTime:"0",vault:{A:w.address.mintAVault.toString(),B:w.address.mintBVault.toString()},rewardInfos:[],config:{id:i.id.toString(),index:i.index,protocolFeeRate:i.protocolFeeRate,tradeFeeRate:i.tradeFeeRate,tickSpacing:i.tickSpacing,fundFeeRate:i.fundFeeRate,description:i.description,defaultRange:0,defaultRangePoint:[]}}),mockPoolInfo:v({type:"Concentrated",rewardDefaultPoolInfos:"Clmm",id:w.address.poolId.toString(),mintA:y,mintB:b,feeRate:i.tradeFeeRate,openTime:"0",programId:t.toString(),price:g.toNumber(),config:{id:i.id.toString(),index:i.index,protocolFeeRate:i.protocolFeeRate,tradeFeeRate:i.tradeFeeRate,tickSpacing:i.tickSpacing,fundFeeRate:i.fundFeeRate,description:i.description,defaultRange:0,defaultRangePoint:[]},burnPercent:0},Uu),forerunCreate:a}})}async openPositionFromBase({poolInfo:e,poolKeys:t,ownerInfo:n,tickLower:o,tickUpper:r,base:i,baseAmount:s,otherAmountMax:u,nft2022:a,associatedOnly:c=!0,checkCreateATAOwner:l=!1,withMetadata:d="create",getEphemeralSigners:p,computeBudgetConfig:f,txTipConfig:y,txVersion:b,feePayer:g}){this.scope.availability.addConcentratedPosition===!1&&this.logAndCreateError("add position feature disabled in your region"),this.scope.checkOwner();let A=this.createTxBuilder(g),h=null,T=null,k=n.useSOLBalance&&e.mintA.address===Y.toString(),w=n.useSOLBalance&&e.mintB.address===Y.toString(),[S,B]=i==="MintA"?[s,u]:[u,s],{account:K,instructionParams:I}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:e.mintA.programId,mint:new z(e.mintA.address),owner:this.scope.ownerPubKey,createInfo:k||S.isZero()?{payer:this.scope.ownerPubKey,amount:S}:void 0,skipCloseAccount:!k,notUseTokenAccount:k,associatedOnly:k?!1:c,checkCreateATAOwner:l});K&&(h=K),A.addInstruction(I||{});let{account:C,instructionParams:O}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:e.mintB.programId,mint:new z(e.mintB.address),owner:this.scope.ownerPubKey,createInfo:w||B.isZero()?{payer:this.scope.ownerPubKey,amount:B}:void 0,skipCloseAccount:!w,notUseTokenAccount:w,associatedOnly:w?!1:c,checkCreateATAOwner:l});C&&(T=C),A.addInstruction(O||{}),(!h||!T)&&this.logAndCreateError("cannot found target token accounts","tokenAccounts",{ownerTokenAccountA:h==null?void 0:h.toBase58(),ownerTokenAccountB:T==null?void 0:T.toBase58()});let M=t||await this.getClmmPoolKeys(e.id),R=await Se.openPositionFromBaseInstructions({poolInfo:e,poolKeys:M,ownerInfo:W(v({},n),{feePayer:this.scope.ownerPubKey,wallet:this.scope.ownerPubKey,tokenAccountA:h,tokenAccountB:T}),tickLower:o,tickUpper:r,base:i,baseAmount:s,otherAmountMax:u,withMetadata:d,getEphemeralSigners:p,nft2022:a});return A.addInstruction(R),A.addCustomComputeBudget(f),A.addTipInstruction(y),A.versionBuild({txVersion:b,extInfo:v({},R.address)})}async openPositionFromLiquidity({poolInfo:e,poolKeys:t,ownerInfo:n,amountMaxA:o,amountMaxB:r,tickLower:i,tickUpper:s,liquidity:u,associatedOnly:a=!0,checkCreateATAOwner:c=!1,withMetadata:l="create",txVersion:d,computeBudgetConfig:p,txTipConfig:f,getEphemeralSigners:y,nft2022:b,feePayer:g}){this.scope.availability.createConcentratedPosition===!1&&this.logAndCreateError("open position feature disabled in your region");let A=this.createTxBuilder(g),h=null,T=null,k=n.useSOLBalance&&e.mintA.address===Y.toBase58(),w=n.useSOLBalance&&e.mintB.address===Y.toBase58(),{account:S,instructionParams:B}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:e.mintA.programId,mint:new z(e.mintA.address),owner:this.scope.ownerPubKey,createInfo:k||o.isZero()?{payer:this.scope.ownerPubKey,amount:o}:void 0,skipCloseAccount:!k,notUseTokenAccount:k,associatedOnly:k?!1:a,checkCreateATAOwner:c});S&&(h=S),A.addInstruction(B||{});let{account:K,instructionParams:I}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:e.mintB.programId,mint:new z(e.mintB.address),owner:this.scope.ownerPubKey,createInfo:w||r.isZero()?{payer:this.scope.ownerPubKey,amount:r}:void 0,skipCloseAccount:!w,notUseTokenAccount:w,associatedOnly:w?!1:a,checkCreateATAOwner:c});K&&(T=K),A.addInstruction(I||{}),(h===void 0||T===void 0)&&this.logAndCreateError("cannot found target token accounts","tokenAccounts",this.scope.account.tokenAccounts);let C=t||await this.getClmmPoolKeys(e.id),O=await Se.openPositionFromLiquidityInstructions({poolInfo:e,poolKeys:C,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccountA:h,tokenAccountB:T},tickLower:i,tickUpper:s,liquidity:u,amountMaxA:o,amountMaxB:r,withMetadata:l,getEphemeralSigners:y,nft2022:b});return A.addInstruction(O),A.addCustomComputeBudget(p),A.addTipInstruction(f),A.versionBuild({txVersion:d,extInfo:{address:O.address}})}async increasePositionFromLiquidity(e){var I;let{poolInfo:t,poolKeys:n,ownerPosition:o,amountMaxA:r,amountMaxB:i,liquidity:s,ownerInfo:u,associatedOnly:a=!0,checkCreateATAOwner:c=!1,computeBudgetConfig:l,txTipConfig:d,txVersion:p,feePayer:f}=e,y=this.createTxBuilder(f),b,g,A=u.useSOLBalance&&t.mintA.address===Y.toString(),h=u.useSOLBalance&&t.mintB.address===Y.toString(),{account:T,instructionParams:k}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:t.mintA.programId,mint:new z(t.mintA.address),notUseTokenAccount:A,owner:this.scope.ownerPubKey,createInfo:A||r.isZero()?{payer:this.scope.ownerPubKey,amount:r}:void 0,skipCloseAccount:!A,associatedOnly:A?!1:a,checkCreateATAOwner:c});T&&(b=T),y.addInstruction(k||{});let{account:w,instructionParams:S}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:t.mintB.programId,mint:new z(t.mintB.address),owner:this.scope.ownerPubKey,createInfo:h||i.isZero()?{payer:this.scope.ownerPubKey,amount:i}:void 0,notUseTokenAccount:h,skipCloseAccount:!h,associatedOnly:h?!1:a,checkCreateATAOwner:c});w&&(g=w),y.addInstruction(S||{}),!b&&!g&&this.logAndCreateError("cannot found target token accounts","tokenAccounts",this.scope.account.tokenAccounts);let B=n!=null?n:await this.getClmmPoolKeys(t.id),K=Se.increasePositionFromLiquidityInstructions({poolInfo:t,poolKeys:B,ownerPosition:o,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccountA:b,tokenAccountB:g},liquidity:s,amountMaxA:r,amountMaxB:i,nft2022:(I=await this.scope.connection.getAccountInfo(o.nftMint))==null?void 0:I.owner.equals(Rn)});return y.addInstruction(K),y.addCustomComputeBudget(l),y.addTipInstruction(d),y.versionBuild({txVersion:p,extInfo:{address:K.address}})}async increasePositionFromBase(e){var K;let{poolInfo:t,ownerPosition:n,base:o,baseAmount:r,otherAmountMax:i,ownerInfo:s,associatedOnly:u=!0,checkCreateATAOwner:a=!1,computeBudgetConfig:c,txTipConfig:l,txVersion:d,feePayer:p}=e,f=this.createTxBuilder(p),y,b,g=s.useSOLBalance&&t.mintA.address===Y.toString(),A=s.useSOLBalance&&t.mintB.address===Y.toString(),{account:h,instructionParams:T}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:t.mintA.programId,mint:new z(t.mintA.address),notUseTokenAccount:g,owner:this.scope.ownerPubKey,createInfo:g||(o==="MintA"?r:i).isZero()?{payer:this.scope.ownerPubKey,amount:o==="MintA"?r:i}:void 0,skipCloseAccount:!g,associatedOnly:g?!1:u,checkCreateATAOwner:a});h&&(y=h),f.addInstruction(T||{});let{account:k,instructionParams:w}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:t.mintB.programId,mint:new z(t.mintB.address),owner:this.scope.ownerPubKey,createInfo:A||(o==="MintA"?i:r).isZero()?{payer:this.scope.ownerPubKey,amount:o==="MintA"?i:r}:void 0,notUseTokenAccount:A,skipCloseAccount:!A,associatedOnly:A?!1:u,checkCreateATAOwner:a});k&&(b=k),f.addInstruction(w||{}),!y&&!b&&this.logAndCreateError("cannot found target token accounts","tokenAccounts",this.scope.account.tokenAccounts);let S=await this.getClmmPoolKeys(t.id),B=Se.increasePositionFromBaseInstructions({poolInfo:t,poolKeys:S,ownerPosition:n,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccountA:y,tokenAccountB:b},base:o,baseAmount:r,otherAmountMax:i,nft2022:(K=await this.scope.connection.getAccountInfo(n.nftMint))==null?void 0:K.owner.equals(Rn)});return f.addInstruction(B),f.addCustomComputeBudget(c),f.addTipInstruction(l),f.versionBuild({txVersion:d,extInfo:{address:B.address}})}async decreaseLiquidity(e){var M;let{poolInfo:t,poolKeys:n,ownerPosition:o,ownerInfo:r,amountMinA:i,amountMinB:s,liquidity:u,associatedOnly:a=!0,checkCreateATAOwner:c=!1,computeBudgetConfig:l,txTipConfig:d,txVersion:p,feePayer:f}=e;this.scope.availability.removeConcentratedPosition===!1&&this.logAndCreateError("remove position feature disabled in your region");let y=this.createTxBuilder(f),b=r.useSOLBalance&&t.mintA.address===Y.toString(),g=r.useSOLBalance&&t.mintB.address===Y.toString(),A,h,{account:T,instructionParams:k}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:t.mintA.programId,mint:new z(t.mintA.address),notUseTokenAccount:b,owner:this.scope.ownerPubKey,createInfo:{payer:this.scope.ownerPubKey,amount:0},skipCloseAccount:!b,associatedOnly:b?!1:a,checkCreateATAOwner:c});A=T,k&&y.addInstruction(k);let{account:w,instructionParams:S}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:t.mintB.programId,mint:new z(t.mintB.address),notUseTokenAccount:g,owner:this.scope.ownerPubKey,createInfo:{payer:this.scope.ownerPubKey,amount:0},skipCloseAccount:!g,associatedOnly:g?!1:a,checkCreateATAOwner:c});h=w,S&&y.addInstruction(S);let B=[];for(let R of t.rewardDefaultInfos){let L=r.useSOLBalance&&R.mint.address===Y.toString(),_;if(R.mint.address===t.mintA.address)_=A;else if(R.mint.address===t.mintB.address)_=h;else{let{account:G,instructionParams:Q}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:new z(R.mint.programId),mint:new z(R.mint.address),notUseTokenAccount:L,owner:this.scope.ownerPubKey,createInfo:{payer:this.scope.ownerPubKey,amount:0},skipCloseAccount:!L,associatedOnly:L?!1:a,checkCreateATAOwner:c});_=G,Q&&y.addInstruction(Q)}B.push(_)}!A&&!h&&this.logAndCreateError("cannot found target token accounts","tokenAccounts",this.scope.account.tokenAccountRawInfos);let K=n!=null?n:await this.getClmmPoolKeys(t.id),I=(M=await this.scope.connection.getAccountInfo(o.nftMint))==null?void 0:M.owner.equals(Rn),C=await Se.decreaseLiquidityInstructions({poolInfo:t,poolKeys:K,ownerPosition:o,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccountA:A,tokenAccountB:h,rewardAccounts:B},liquidity:u,amountMinA:i,amountMinB:s,nft2022:I});y.addInstruction({instructions:C.instructions,instructionTypes:[q.ClmmDecreasePosition]});let O=v({},C.address);if(r.closePosition){let R=await Se.closePositionInstructions({poolInfo:t,poolKeys:K,ownerInfo:{wallet:this.scope.ownerPubKey},ownerPosition:o,nft2022:I});y.addInstruction({endInstructions:R.instructions,endInstructionTypes:R.instructionTypes}),O=v(v({},O),R.address)}return y.addCustomComputeBudget(l),y.addTipInstruction(d),y.versionBuild({txVersion:p,extInfo:{address:O}})}async lockPosition(e){var f;let{programId:t=Fo,authProgramId:n=Wi,poolProgramId:o=Fn,ownerPosition:r,payer:i,computeBudgetConfig:s,txTipConfig:u,txVersion:a,getEphemeralSigners:c,feePayer:l}=e,d=this.createTxBuilder(l),p=await Se.makeLockPositions({programId:t,authProgramId:n,poolProgramId:o,wallet:this.scope.ownerPubKey,payer:i!=null?i:this.scope.ownerPubKey,nftMint:r.nftMint,getEphemeralSigners:c,nft2022:(f=await this.scope.connection.getAccountInfo(r.nftMint))==null?void 0:f.owner.equals(Rn)});return d.addInstruction(p),d.addCustomComputeBudget(s),d.addTipInstruction(u),d.versionBuild({txVersion:a,extInfo:p.address})}async harvestLockPosition(e){let{programId:t=Fo,authProgramId:n=Wi,clmmProgram:o=Fn,poolKeys:r,lockData:i,ownerInfo:s={useSOLBalance:!0},associatedOnly:u=!0,checkCreateATAOwner:a=!1,computeBudgetConfig:c,txTipConfig:l,txVersion:d,feePayer:p}=e,f=r||await this.getClmmPoolKeys(i.poolId.toString()),y=this.createTxBuilder(p),b=await this.scope.connection.getAccountInfo(i.positionId);b||this.logger.logWithError("position not found",i.positionId);let g=bo.decode(b.data),A=s.useSOLBalance&&f.mintA.address===Y.toString(),h=s.useSOLBalance&&f.mintB.address===Y.toString(),T,k,{account:w,instructionParams:S}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:f.mintA.programId,mint:new z(f.mintA.address),notUseTokenAccount:A,owner:this.scope.ownerPubKey,createInfo:{payer:this.scope.ownerPubKey,amount:0},skipCloseAccount:!A,associatedOnly:A?!1:u,checkCreateATAOwner:a});T=w,S&&y.addInstruction(S);let{account:B,instructionParams:K}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:f.mintB.programId,mint:new z(f.mintB.address),notUseTokenAccount:h,owner:this.scope.ownerPubKey,createInfo:{payer:this.scope.ownerPubKey,amount:0},skipCloseAccount:!h,associatedOnly:h?!1:u,checkCreateATAOwner:a});k=B,K&&y.addInstruction(K);let I={},C=[];for(let ne of f.rewardInfos){let le=s.useSOLBalance&&ne.mint.address===Y.toString(),fe=I[ne.mint.address];if(!fe){let{account:de,instructionParams:J}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:new z(ne.mint.programId),mint:new z(ne.mint.address),notUseTokenAccount:le,owner:this.scope.ownerPubKey,skipCloseAccount:!le,createInfo:{payer:this.scope.ownerPubKey,amount:0},associatedOnly:le?!1:u});fe=de,J&&y.addInstruction(J)}I[ne.mint.address]=fe,C.push(fe)}let O=yo(t,i.lockNftMint).publicKey,M=Z(this.scope.ownerPubKey,i.lockNftMint,pi).publicKey,R=H.getTickArrayStartIndexByTick(g.tickLower,f.config.tickSpacing),L=H.getTickArrayStartIndexByTick(g.tickUpper,f.config.tickSpacing),{publicKey:_}=be(new z(f.programId),i.poolId,R),{publicKey:G}=be(new z(f.programId),i.poolId,L),{publicKey:Q}=Ht(new z(f.programId),i.poolId,g.tickLower,g.tickUpper),se=[];for(let ne=0;ne<f.rewardInfos.length;ne++)se.push({poolRewardVault:new z(f.rewardInfos[ne].vault),ownerRewardVault:C[ne],rewardMint:new z(f.rewardInfos[ne].mint.address)});let ce=await Se.harvestLockPositionInstructionV2({programId:t,auth:n,lockPositionId:O,clmmProgram:o,lockOwner:this.scope.ownerPubKey,lockNftMint:i.lockNftMint,lockNftAccount:M,positionNftAccount:i.nftAccount,positionId:i.positionId,poolId:i.poolId,protocolPosition:Q,vaultA:new z(f.vault.A),vaultB:new z(f.vault.B),tickArrayLower:_,tickArrayUpper:G,userVaultA:T,userVaultB:k,mintA:new z(f.mintA.address),mintB:new z(f.mintB.address),rewardAccounts:se,exTickArrayBitmap:Xe(o,i.poolId).publicKey});return y.addInstruction({instructions:[ce],instructionTypes:[q.ClmmHarvestLockPosition]}),y.addCustomComputeBudget(c),y.addTipInstruction(l),y.versionBuild({txVersion:d})}async closePosition({poolInfo:e,poolKeys:t,ownerPosition:n,txVersion:o,computeBudgetConfig:r,txTipConfig:i,feePayer:s}){var l;this.scope.availability.removeConcentratedPosition===!1&&this.logAndCreateError("remove position feature disabled in your region");let u=this.createTxBuilder(s),a=t!=null?t:await this.getClmmPoolKeys(e.id),c=Se.closePositionInstructions({poolInfo:e,poolKeys:a,ownerInfo:{wallet:this.scope.ownerPubKey},ownerPosition:n,nft2022:(l=await this.scope.connection.getAccountInfo(n.nftMint))==null?void 0:l.owner.equals(Rn)});return u.addCustomComputeBudget(r),u.addTipInstruction(i),u.addInstruction(c).versionBuild({txVersion:o,extInfo:{address:c.address}})}async initReward({poolInfo:e,ownerInfo:t,rewardInfo:n,associatedOnly:o=!0,checkCreateATAOwner:r=!1,computeBudgetConfig:i,txVersion:s,feePayer:u}){n.endTime<=n.openTime&&this.logAndCreateError("reward time error","rewardInfo",n);let a=this.createTxBuilder(u),c=t.useSOLBalance&&n.mint.address.toString()===Y.toString(),l=n.perSecond.mul(n.endTime-n.openTime),{account:d,instructionParams:p}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:new z(n.mint.address),mint:new z(n.mint.address),notUseTokenAccount:!!c,skipCloseAccount:!c,owner:this.scope.ownerPubKey,createInfo:c?{payer:t.feePayer||this.scope.ownerPubKey,amount:new bt(new $n(l.toFixed(0)).gte(l)?l.toFixed(0):l.add(1).toFixed(0))}:void 0,associatedOnly:c?!1:o,checkCreateATAOwner:r});p&&a.addInstruction(p),d||this.logAndCreateError("no money","ownerRewardAccount",this.scope.account.tokenAccountRawInfos);let f=await this.getClmmPoolKeys(e.id),y=Se.initRewardInstructions({poolInfo:e,poolKeys:f,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccount:d},rewardInfo:{programId:new z(n.mint.programId),mint:new z(n.mint.address),openTime:n.openTime,endTime:n.endTime,emissionsPerSecondX64:ue.decimalToX64(n.perSecond)}});return a.addInstruction(y),a.addCustomComputeBudget(i),a.versionBuild({txVersion:s,extInfo:{address:y.address}})}async initRewards({poolInfo:e,poolKeys:t,ownerInfo:n,rewardInfos:o,associatedOnly:r=!0,checkCreateATAOwner:i=!1,computeBudgetConfig:s,txTipConfig:u,txVersion:a,feePayer:c}){for(let p of o)p.endTime<=p.openTime&&this.logAndCreateError("reward time error","rewardInfo",p);let l=this.createTxBuilder(c),d={};for(let p of o){let f=n.useSOLBalance&&p.mint.address===Y.toString(),y=p.perSecond.mul(p.endTime-p.openTime),{account:b,instructionParams:g}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:new z(p.mint.programId),mint:new z(p.mint.address),notUseTokenAccount:!!f,skipCloseAccount:!f,owner:this.scope.ownerPubKey,createInfo:f?{payer:n.feePayer||this.scope.ownerPubKey,amount:new bt(new $n(y.toFixed(0)).gte(y)?y.toFixed(0):y.add(1).toFixed(0))}:void 0,associatedOnly:f?!1:r,checkCreateATAOwner:i});g&&l.addInstruction(g),b||this.logAndCreateError("no money","ownerRewardAccount",this.scope.account.tokenAccountRawInfos);let A=t!=null?t:await this.getClmmPoolKeys(e.id),h=Se.initRewardInstructions({poolInfo:e,poolKeys:A,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccount:b},rewardInfo:{programId:new z(p.mint.programId),mint:new z(p.mint.address),openTime:p.openTime,endTime:p.endTime,emissionsPerSecondX64:ue.decimalToX64(p.perSecond)}});d=v(v({},d),h.address),l.addInstruction(h)}return l.addCustomComputeBudget(s),l.addTipInstruction(u),l.versionBuild({txVersion:a,extInfo:{address:d}})}async setReward({poolInfo:e,ownerInfo:t,rewardInfo:n,associatedOnly:o=!0,checkCreateATAOwner:r=!1,computeBudgetConfig:i,txTipConfig:s,txVersion:u,feePayer:a}){n.endTime<=n.openTime&&this.logAndCreateError("reward time error","rewardInfo",n);let c=this.createTxBuilder(a),l=t.useSOLBalance&&n.mint.equals(Y),{account:d,instructionParams:p}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:n.programId,mint:n.mint,notUseTokenAccount:l,owner:this.scope.ownerPubKey,createInfo:l?{payer:t.feePayer||this.scope.ownerPubKey,amount:new bt(new $n(n.perSecond.mul(n.endTime-n.openTime).toFixed(0)).gte(n.perSecond.mul(n.endTime-n.openTime))?n.perSecond.mul(n.endTime-n.openTime).toFixed(0):n.perSecond.mul(n.endTime-n.openTime).add(1).toFixed(0))}:void 0,associatedOnly:l?!1:o,checkCreateATAOwner:r});p&&c.addInstruction(p),d||this.logAndCreateError("no money","ownerRewardAccount",this.scope.account.tokenAccountRawInfos);let f=await this.getClmmPoolKeys(e.id),y=Se.setRewardInstructions({poolInfo:e,poolKeys:f,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccount:d},rewardInfo:{mint:n.mint,openTime:n.openTime,endTime:n.endTime,emissionsPerSecondX64:ue.decimalToX64(n.perSecond)}});return c.addInstruction(y),c.addCustomComputeBudget(i),c.addTipInstruction(s),c.versionBuild({txVersion:u,extInfo:{address:y.address}})}async setRewards({poolInfo:e,poolKeys:t,ownerInfo:n,rewardInfos:o,associatedOnly:r=!0,checkCreateATAOwner:i=!1,computeBudgetConfig:s,txTipConfig:u,txVersion:a,feePayer:c}){let l=this.createTxBuilder(c),d={};for(let p of o){p.endTime<=p.openTime&&this.logAndCreateError("reward time error","rewardInfo",p);let f=n.useSOLBalance&&p.mint.address===Y.toString(),{account:y,instructionParams:b}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:new z(p.mint.programId),mint:new z(p.mint.address),notUseTokenAccount:f,owner:this.scope.ownerPubKey,createInfo:f?{payer:n.feePayer||this.scope.ownerPubKey,amount:new bt(new $n(p.perSecond.mul(p.endTime-p.openTime).toFixed(0)).gte(p.perSecond.mul(p.endTime-p.openTime))?p.perSecond.mul(p.endTime-p.openTime).toFixed(0):p.perSecond.mul(p.endTime-p.openTime).add(1).toFixed(0))}:void 0,associatedOnly:f?!1:r,checkCreateATAOwner:i});b&&l.addInstruction(b),y||this.logAndCreateError("no money","ownerRewardAccount",this.scope.account.tokenAccountRawInfos);let g=t!=null?t:await this.getClmmPoolKeys(e.id),A=Se.setRewardInstructions({poolInfo:e,poolKeys:g,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccount:y},rewardInfo:{mint:new z(p.mint.address),openTime:p.openTime,endTime:p.endTime,emissionsPerSecondX64:ue.decimalToX64(p.perSecond)}});l.addInstruction(A),d=v(v({},d),A.address)}return l.addCustomComputeBudget(s),l.addTipInstruction(u),l.versionBuild({txVersion:a,extInfo:{address:d}})}async collectReward({poolInfo:e,ownerInfo:t,rewardMint:n,associatedOnly:o=!0,checkCreateATAOwner:r=!1,computeBudgetConfig:i,txTipConfig:s,txVersion:u,feePayer:a}){let c=e.rewardDefaultInfos.find(g=>g.mint.address===n.toString());c||this.logAndCreateError("reward mint error","not found reward mint",n);let l=this.createTxBuilder(a),d=t.useSOLBalance&&n.equals(Y),{account:p,instructionParams:f}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:new z(c.mint.programId),mint:n,notUseTokenAccount:d,owner:this.scope.ownerPubKey,skipCloseAccount:!d,createInfo:{payer:t.feePayer||this.scope.ownerPubKey,amount:0},associatedOnly:d?!1:o,checkCreateATAOwner:r});f&&l.addInstruction(f),p||this.logAndCreateError("no money","ownerRewardAccount",this.scope.account.tokenAccountRawInfos);let y=await this.getClmmPoolKeys(e.id),b=Se.collectRewardInstructions({poolInfo:e,poolKeys:y,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccount:p},rewardMint:n});return l.addInstruction(b),l.addCustomComputeBudget(i),l.addTipInstruction(s),l.versionBuild({txVersion:u,extInfo:{address:b.address}})}async collectRewards({poolInfo:e,ownerInfo:t,rewardMints:n,associatedOnly:o=!0,checkCreateATAOwner:r=!1,computeBudgetConfig:i,txTipConfig:s,feePayer:u}){let a=this.createTxBuilder(u),c={};for(let l of n){let d=e.rewardDefaultInfos.find(A=>A.mint.address===l.toString());if(!d){this.logAndCreateError("reward mint error","not found reward mint",l);continue}let p=t.useSOLBalance&&l.equals(Y),{account:f,instructionParams:y}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:new z(d.mint.programId),mint:l,notUseTokenAccount:p,owner:this.scope.ownerPubKey,skipCloseAccount:!p,createInfo:{payer:t.feePayer||this.scope.ownerPubKey,amount:0},associatedOnly:p?!1:o,checkCreateATAOwner:r});f||this.logAndCreateError("no money","ownerRewardAccount",this.scope.account.tokenAccountRawInfos),y&&a.addInstruction(y);let b=await this.getClmmPoolKeys(e.id),g=Se.collectRewardInstructions({poolInfo:e,poolKeys:b,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccount:f},rewardMint:l});a.addInstruction(g),c=v(v({},c),g.address)}return a.addCustomComputeBudget(i),a.addTipInstruction(s),a.build({address:c})}async swap({poolInfo:e,poolKeys:t,inputMint:n,amountIn:o,amountOutMin:r,priceLimit:i,observationId:s,ownerInfo:u,remainingAccounts:a,associatedOnly:c=!0,checkCreateATAOwner:l=!1,txVersion:d,computeBudgetConfig:p,txTipConfig:f,feePayer:y}){let b=this.createTxBuilder(y),g=n.toString()===e.mintA.address,A=u.useSOLBalance&&e.mintA.address===Y.toBase58(),h=u.useSOLBalance&&e.mintB.address===Y.toBase58(),T;!i||i.equals(new $n(0))?T=g?vt.add(new bt(1)):_t.sub(new bt(1)):T=re.priceToSqrtPriceX64(i,e.mintA.decimals,e.mintB.decimals);let k;if(!k){let{account:B,instructionParams:K}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:e.mintA.programId,mint:new z(e.mintA.address),notUseTokenAccount:A,owner:this.scope.ownerPubKey,skipCloseAccount:!A,createInfo:A||!g?{payer:u.feePayer||this.scope.ownerPubKey,amount:g?o:0}:void 0,associatedOnly:A?!1:c,checkCreateATAOwner:l});k=B,K&&b.addInstruction(K)}let w;if(!w){let{account:B,instructionParams:K}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:e.mintB.programId,mint:new z(e.mintB.address),notUseTokenAccount:h,owner:this.scope.ownerPubKey,skipCloseAccount:!h,createInfo:h||g?{payer:u.feePayer||this.scope.ownerPubKey,amount:g?0:o}:void 0,associatedOnly:h?!1:c,checkCreateATAOwner:l});w=B,K&&b.addInstruction(K)}(!k||!w)&&this.logAndCreateError("user do not have token account",{tokenA:e.mintA.symbol||e.mintA.address,tokenB:e.mintB.symbol||e.mintB.address,ownerTokenAccountA:k,ownerTokenAccountB:w,mintAUseSOLBalance:A,mintBUseSOLBalance:h,associatedOnly:c});let S=t!=null?t:await this.getClmmPoolKeys(e.id);return b.addInstruction(Se.makeSwapBaseInInstructions({poolInfo:e,poolKeys:S,observationId:s,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccountA:k,tokenAccountB:w},inputMint:new z(n),amountIn:o,amountOutMin:r,sqrtPriceLimitX64:T,remainingAccounts:a})),b.addCustomComputeBudget(p),b.addTipInstruction(f),b.versionBuild({txVersion:d})}async swapBaseOut({poolInfo:e,poolKeys:t,outputMint:n,amountOut:o,amountInMax:r,priceLimit:i,observationId:s,ownerInfo:u,remainingAccounts:a,associatedOnly:c=!0,checkCreateATAOwner:l=!1,txVersion:d,computeBudgetConfig:p,txTipConfig:f,feePayer:y}){let b=this.createTxBuilder(y),g=n.toString()===e.mintB.address,A=u.useSOLBalance&&e.mintA.address===Y.toBase58(),h=u.useSOLBalance&&e.mintB.address===Y.toBase58(),T;!i||i.equals(new $n(0))?T=n.toString()===e.mintB.address?vt.add(new bt(1)):_t.sub(new bt(1)):T=re.priceToSqrtPriceX64(i,e.mintA.decimals,e.mintB.decimals);let k;if(!k){let{account:B,instructionParams:K}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:e.mintA.programId,mint:new z(e.mintA.address),notUseTokenAccount:A,owner:this.scope.ownerPubKey,skipCloseAccount:!A,createInfo:A||!g?{payer:u.feePayer||this.scope.ownerPubKey,amount:g?r:0}:void 0,associatedOnly:A?!1:c,checkCreateATAOwner:l});k=B,K&&b.addInstruction(K)}let w;if(!w){let{account:B,instructionParams:K}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:e.mintB.programId,mint:new z(e.mintB.address),notUseTokenAccount:h,owner:this.scope.ownerPubKey,skipCloseAccount:!h,createInfo:h||g?{payer:u.feePayer||this.scope.ownerPubKey,amount:g?0:r}:void 0,associatedOnly:h?!1:c,checkCreateATAOwner:l});w=B,K&&b.addInstruction(K)}(!k||!w)&&this.logAndCreateError("user do not have token account",{tokenA:e.mintA.symbol||e.mintA.address,tokenB:e.mintB.symbol||e.mintB.address,ownerTokenAccountA:k,ownerTokenAccountB:w,mintAUseSOLBalance:A,mintBUseSOLBalance:h,associatedOnly:c});let S=t!=null?t:await this.getClmmPoolKeys(e.id);return b.addInstruction(Se.makeSwapBaseOutInstructions({poolInfo:e,poolKeys:S,observationId:s,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccountA:k,tokenAccountB:w},outputMint:new z(n),amountOut:o,amountInMax:r,sqrtPriceLimitX64:T,remainingAccounts:a})),b.addCustomComputeBudget(p),b.addTipInstruction(f),b.versionBuild({txVersion:d})}async harvestAllRewards({allPoolInfo:e,allPositions:t,lockInfo:n,ownerInfo:o,associatedOnly:r=!0,checkCreateATAOwner:i=!1,programId:s,txVersion:u,computeBudgetConfig:a,feePayer:c,lockProgram:l=Fo,lockAuth:d=Wi,clmmProgram:p=Fn}){var h,T;let f={};for(let k of this.scope.account.tokenAccountRawInfos)r?Z(this.scope.ownerPubKey,k.accountInfo.mint,s).publicKey.equals(k.pubkey)&&(f[k.accountInfo.mint.toString()]=k.pubkey):f[k.accountInfo.mint.toString()]=k.pubkey;let y=Object.values(t).flat().map(k=>k.nftMint),b=await Ce(this.scope.connection,y.map(k=>({pubkey:k}))),g={};b.forEach(k=>{var w,S;g[k.pubkey.toBase58()]=(S=(w=k==null?void 0:k.accountInfo)==null?void 0:w.owner)!=null?S:null});let A=this.createTxBuilder(c);for(let k of Object.values(e)){if(t[k.id]===void 0||!t[k.id].find(R=>!R.liquidity.isZero()||R.rewardInfos.find(L=>!L.rewardAmountOwed.isZero())))continue;let w=k,S=o.useSOLBalance&&w.mintA.address===Y.toString(),B=o.useSOLBalance&&w.mintB.address===Y.toString(),K=f[w.mintA.address];if(!K)if(S){let{account:R,instructionParams:L}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:w.mintA.programId,mint:new z(w.mintA.address),notUseTokenAccount:S,owner:this.scope.ownerPubKey,skipCloseAccount:!S,createInfo:{payer:o.feePayer||this.scope.ownerPubKey,amount:0},associatedOnly:S?!1:r,checkCreateATAOwner:i});K=R,L&&A.addInstruction(L)}else{let R=new z(w.mintA.address);K=this.scope.account.getAssociatedTokenAccount(R,new z(w.mintA.programId)),A.addInstruction({instructions:[hc(this.scope.ownerPubKey,K,this.scope.ownerPubKey,R,new z(w.mintA.programId))]})}let I=f[w.mintB.address];if(!I)if(B){let{account:R,instructionParams:L}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:w.mintB.programId,mint:new z(w.mintB.address),notUseTokenAccount:B,owner:this.scope.ownerPubKey,skipCloseAccount:!B,createInfo:{payer:o.feePayer||this.scope.ownerPubKey,amount:0},associatedOnly:B?!1:r,checkCreateATAOwner:i});I=R,L&&A.addInstruction(L)}else{let R=new z(w.mintB.address);I=this.scope.account.getAssociatedTokenAccount(R,new z(w.mintB.programId)),A.addInstruction({instructions:[hc(this.scope.ownerPubKey,I,this.scope.ownerPubKey,R,new z(w.mintB.programId))]})}f[w.mintA.address]=K,f[w.mintB.address]=I;let C=[];for(let R of w.rewardDefaultInfos){let L=o.useSOLBalance&&R.mint.address===Y.toString(),_=f[R.mint.address];if(!_){let{account:G,instructionParams:Q}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:new z(R.mint.programId),mint:new z(R.mint.address),notUseTokenAccount:L,owner:this.scope.ownerPubKey,skipCloseAccount:!L,createInfo:{payer:o.feePayer||this.scope.ownerPubKey,amount:0},associatedOnly:L?!1:r});_=G,Q&&A.addInstruction(Q)}f[R.mint.address]=_,C.push(_)}let O=await this.getClmmPoolKeys(w.id),M=[];for(let R=0;R<O.rewardInfos.length;R++)M.push({poolRewardVault:new z(O.rewardInfos[R].vault),ownerRewardVault:C[R],rewardMint:new z(O.rewardInfos[R].mint.address)});for(let R of t[k.id]){let L=(h=n==null?void 0:n[k.id])==null?void 0:h[R.nftMint.toBase58()];if(L){let _=Z(this.scope.ownerPubKey,L.lockNftMint,pi).publicKey,G=H.getTickArrayStartIndexByTick(R.tickLower,O.config.tickSpacing),Q=H.getTickArrayStartIndexByTick(R.tickUpper,O.config.tickSpacing),{publicKey:se}=be(new z(O.programId),L.poolId,G),{publicKey:ce}=be(new z(O.programId),L.poolId,Q),{publicKey:ne}=Ht(new z(O.programId),L.poolId,R.tickLower,R.tickUpper),le=yo(l,L.lockNftMint).publicKey,fe=Se.harvestLockPositionInstructionV2({programId:l,auth:d,lockPositionId:le,clmmProgram:p,lockOwner:this.scope.ownerPubKey,lockNftMint:L.lockNftMint,lockNftAccount:_,positionNftAccount:L.nftAccount,positionId:L.positionId,poolId:L.poolId,protocolPosition:ne,vaultA:new z(O.vault.A),vaultB:new z(O.vault.B),tickArrayLower:se,tickArrayUpper:ce,userVaultA:K,userVaultB:I,mintA:new z(O.mintA.address),mintB:new z(O.mintB.address),rewardAccounts:M,exTickArrayBitmap:Xe(p,L.poolId).publicKey});A.addInstruction({instructions:[fe],instructionTypes:[q.ClmmHarvestLockPosition],lookupTableAddress:O.lookupTableAccount?[O.lookupTableAccount]:[]})}else{let _=Se.decreaseLiquidityInstructions({poolInfo:w,poolKeys:O,ownerPosition:R,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccountA:K,tokenAccountB:I,rewardAccounts:C},liquidity:new bt(0),amountMinA:new bt(0),amountMinB:new bt(0),nft2022:(T=g[R.nftMint.toBase58()])==null?void 0:T.equals(Rn)});A.addInstruction(_)}}}return u===0?A.sizeCheckBuildV0({computeBudgetConfig:a}):A.sizeCheckBuild({computeBudgetConfig:a})}async getWhiteListMint({programId:e}){let t=await this.scope.connection.getAccountInfo(ti(e).publicKey);return t?nc.decode(t.data).whitelistMints.filter(o=>!o.equals(z.default)):[]}async getOwnerPositionInfo({programId:e=Fn}){await this.scope.account.fetchWalletTokenAccounts();let n=this.scope.account.tokenAccountRawInfos.filter(i=>i.accountInfo.amount.eq(new bt(1))).map(i=>yt(new z(e),i.accountInfo.mint).publicKey),o=await this.scope.connection.getMultipleAccountsInfo(n),r=[];return o.forEach(i=>{if(!i)return;let s=bo.decode(i.data);r.push(s)}),r}async getOwnerLockedPositionInfo({programId:e=Fo}){await this.scope.account.fetchWalletTokenAccounts();let n=this.scope.account.tokenAccountRawInfos.filter(u=>u.accountInfo.amount.eq(new bt(1))).map(u=>yo(new z(e),u.accountInfo.mint).publicKey),o=await this.scope.connection.getMultipleAccountsInfo(n),r=[];o.forEach(u=>{if(!u)return;let a=oc.decode(u.data);r.push(a)});let i=await this.scope.connection.getMultipleAccountsInfo(r.map(u=>u.positionId)),s=[];return i.forEach(u=>{if(!u)return;let a=bo.decode(u.data);s.push(a)}),r.map((u,a)=>({position:s[a],lockInfo:u}))}async getRpcClmmPoolInfo({poolId:e}){return(await this.getRpcClmmPoolInfos({poolIds:[e]}))[String(e)]}async getRpcClmmPoolInfos({poolIds:e,config:t}){let n=await Ce(this.scope.connection,e.map(r=>({pubkey:new z(r)})),t),o={};for(let r=0;r<e.length;r++){let i=n[r];if(i===null||!i.accountInfo)throw Error("fetch pool info error: "+String(e[r]));let s=zn.decode(i.accountInfo.data),u=re.sqrtPriceX64ToPrice(s.sqrtPriceX64,s.mintDecimalsA,s.mintDecimalsB).toNumber();o[String(e[r])]=W(v({},s),{currentPrice:u,programId:i.accountInfo.owner})}return o}async getComputeClmmPoolInfos({clmmPoolsRpcInfo:e,mintInfos:t}){let n=new Set(Object.keys(e).map(u=>e[u].ammConfig.toBase58())),o=await Ce(this.scope.connection,Array.from(n).map(u=>({pubkey:new z(u)}))),r={};o.forEach(u=>{!u.accountInfo||(r[u.pubkey.toBase58()]=ec.decode(u.accountInfo.data))});let i=await Re.fetchComputeMultipleClmmInfo({connection:this.scope.connection,rpcDataMap:e,poolList:Object.keys(e).map(u=>{var l,d,p,f;let[a,c]=[e[u].mintA.toBase58(),e[u].mintB.toBase58()];return{id:u,programId:e[u].programId.toBase58(),mintA:dt({address:a,decimals:e[u].mintDecimalsA,programId:t[a].programId.toBase58()||pi.toBase58(),extensions:{feeConfig:(l=t[a])!=null&&l.feeConfig?Kn((d=t[a])==null?void 0:d.feeConfig):void 0}}),mintB:dt({address:c,decimals:e[u].mintDecimalsB,programId:t[c].programId.toBase58()||pi.toBase58(),extensions:{feeConfig:(p=t[c])!=null&&p.feeConfig?Kn((f=t[c])==null?void 0:f.feeConfig):void 0}}),price:e[u].currentPrice,config:W(v({},r[e[u].ammConfig.toBase58()]),{id:e[u].ammConfig.toBase58(),fundFeeRate:0,description:"",defaultRange:0,defaultRangePoint:[]})}})}),s=await Re.fetchMultiplePoolTickArrays({connection:this.scope.connection,poolKeys:Object.values(i)});return{computeClmmPoolInfo:i,computePoolTickData:s}}async getPoolInfoFromRpc(e){var c;let t=await this.getRpcClmmPoolInfo({poolId:e}),n=new Set([t.mintA.toBase58(),t.mintB.toBase58()]),o=await ao({connection:this.scope.connection,mints:Array.from(n).map(l=>new z(l))}),{computeClmmPoolInfo:r,computePoolTickData:i}=await this.scope.clmm.getComputeClmmPoolInfos({clmmPoolsRpcInfo:{[e]:t},mintInfos:o}),s=await Ce(this.scope.connection,[{pubkey:t.vaultA},{pubkey:t.vaultB}]),u=$u(r[e]);if(!s[0].accountInfo||!s[1].accountInfo)throw new Error("pool vault data not found");u.mintAmountA=Number(kc.decode(s[0].accountInfo.data).amount.toString()),u.mintAmountB=Number(kc.decode((c=s[1].accountInfo)==null?void 0:c.data).amount.toString());let a=W(v({},r[e]),{exBitmapAccount:r[e].exBitmapAccount.toBase58(),observationId:r[e].observationId.toBase58(),id:e,programId:t.programId.toBase58(),openTime:t.startTime.toString(),vault:{A:t.vaultA.toBase58(),B:t.vaultB.toBase58()},config:u.config,rewardInfos:r[e].rewardInfos.filter(l=>!l.tokenVault.equals(z.default)).map(l=>({mint:dt({address:l.tokenMint.toBase58(),programId:pi.toBase58(),decimals:10}),vault:l.tokenVault.toBase58()}))});return{poolInfo:u,poolKeys:a,computePoolInfo:r[e],tickData:i}}};import{PublicKey as X}from"@solana/web3.js";import{AccountLayout as qd,NATIVE_MINT as xr,TOKEN_PROGRAM_ID as Kt,createAssociatedTokenAccountIdempotentInstruction as Oc}from"@solana/spl-token";import oa from"bn.js";import hr from"decimal.js-light";import yi from"bn.js";function Pr(m,e){if(e.isZero())throw Error("divisor is zero");return m.mod(e)}function Rd(m,e){if(e.isZero())throw Error("rhs is zero");let t=m.div(e);if(t.isZero())throw Error("quotient is zero");let n=Pr(m,e);return n.gt(wo)&&(t=t.add(new yi(1)),e=m.div(t),n=Pr(m,t),n.gt(wo)&&(e=e.add(new yi(1)))),[t,e]}var wo=new yi(0),wr=class{static swapWithoutFees(e,t,n){let o=t.mul(n),r=t.add(e),[i]=Rd(o,r),s=n.sub(i);if(s.isZero())throw Error("destinationAmountSwapped is zero");return{destinationAmountSwapped:s}}static lpTokensToTradingTokens(e,t,n,o,r){let i=e.mul(n).div(t),s=e.mul(o).div(t);if(r===0)return{tokenAmount0:i,tokenAmount1:s};if(r===1)return Pr(e.mul(n),t).gt(wo)&&i.gt(wo)&&(i=i.add(new yi(1))),Pr(e.mul(o),t).gt(wo)&&s.gt(wo)&&(s=s.add(new yi(1))),{tokenAmount0:i,tokenAmount1:s};throw Error("roundDirection value error")}};var kr=class{static tradingFee(e,t){return Ei(e,t,jt)}static protocolFee(e,t){return ns(e,t,jt)}static fundFee(e,t){return ns(e,t,jt)}};var Tr=class{static validate_supply(e,t){if(e.isZero())throw Error("tokenAmount0 is zero");if(t.isZero())throw Error("tokenAmount1 is zero")}static swap(e,t,n,o){let r=kr.tradingFee(e,o),i=e.sub(r),{destinationAmountSwapped:s}=wr.swapWithoutFees(i,t,n);return{newSwapDestinationAmount:n.sub(s),sourceAmountSwapped:e,destinationAmountSwapped:s,tradeFee:r}}static swapBaseOut({poolMintA:e,poolMintB:t,tradeFeeRate:n,baseReserve:o,quoteReserve:r,outputMint:i,outputAmount:s}){let[u,a,c,l,d]=t.address===i.toString()?[o,r,e.decimals,t.decimals,e.address]:[r,o,t.decimals,e.decimals,t.address],p=new hr(a.toString()).div(10**l).div(new hr(u.toString()).div(10**c)),f=s.gte(a)?a.sub(new oa(1)):s,y=a.sub(f),b=zt(u.mul(f),y),g=zt(b.mul(new oa(1e6)),new oa(1e6).sub(n)),A=g.sub(b),h=new hr(f.toString()).div(10**l).div(new hr(g.toString()).div(10**c)),T=p.isZero()?0:h.sub(p).div(p).abs().toNumber();return{amountRealOut:f,amountIn:g,amountInWithoutFee:b,tradeFee:A,priceImpact:T}}};import ze from"bn.js";import Ft from"decimal.js";import{PublicKey as Ai,TransactionInstruction as Jn,Keypair as Vd,SystemProgram as Ed}from"@solana/web3.js";import{ASSOCIATED_TOKEN_PROGRAM_ID as Bc,TOKEN_2022_PROGRAM_ID as ra,TOKEN_PROGRAM_ID as Ln}from"@solana/spl-token";var Ld=Buffer.from("vault_and_lp_mint_auth_seed","utf8"),KB=Buffer.from("amm_config","utf8"),Od=Buffer.from("pool","utf8"),Nd=Buffer.from("pool_lp_mint","utf8"),Md=Buffer.from("pool_vault","utf8"),vd=Buffer.from("observation","utf8");function ko(m){return ae([Ld],m)}function ia(m,e,t,n){return ae([Od,e.toBuffer(),t.toBuffer(),n.toBuffer()],m)}function _d(m,e){return ae([Nd,e.toBuffer()],m)}function Tc(m,e,t){return ae([Md,e.toBuffer(),t.toBuffer()],m)}function bi(m,e){return ae([vd,e.toBuffer()],m)}function Ic({poolId:m,programId:e,configId:t,mintA:n,mintB:o}){let r=ko(e).publicKey,i=m||ia(e,t,n,o).publicKey,s=_d(e,i).publicKey,u=Tc(e,i,n).publicKey,a=Tc(e,i,o).publicKey,c=bi(e,i).publicKey;return{poolId:i,configId:t,authority:r,lpMint:s,vaultA:u,vaultB:a,observationId:c}}var Fd=Buffer.from("locked_liquidity","utf8");function gi(m,e){return ae([Fd,e.toBuffer()],m)}var Dd=ye("Raydium_cpmm"),eo={initialize:[175,175,109,31,13,152,155,237],deposit:[242,35,198,137,82,225,242,182],withdraw:[183,18,70,156,148,109,161,34],swapBaseInput:[143,190,90,218,196,30,51,222],swapBaseOutput:[55,217,98,86,163,74,180,173],lockCpLiquidity:[216,157,29,78,38,51,31,26],collectCpFee:[8,30,51,199,209,184,247,133]};function xc(m,e,t,n,o,r,i,s,u,a,c,l,d,p,f,y,b,g,A,h){let T=F([P("amountMaxA"),P("amountMaxB"),P("openTime")]),k=ia(m,t,r,i).publicKey,w=[{pubkey:e,isSigner:!0,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!o.equals(k),isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!1},{pubkey:i,isSigner:!1,isWritable:!1},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:d,isSigner:!1,isWritable:!0},{pubkey:p,isSigner:!1,isWritable:!0},{pubkey:b,isSigner:!1,isWritable:!0},{pubkey:Ln,isSigner:!1,isWritable:!1},{pubkey:f,isSigner:!1,isWritable:!1},{pubkey:y,isSigner:!1,isWritable:!1},{pubkey:Bc,isSigner:!1,isWritable:!1},{pubkey:Zr,isSigner:!1,isWritable:!1},{pubkey:it,isSigner:!1,isWritable:!1}],S=Buffer.alloc(T.span);return T.encode({amountMaxA:g,amountMaxB:A,openTime:h},S),new Jn({keys:w,programId:m,data:Buffer.from([...eo.initialize,...S])})}function Sc(m,e,t,n,o,r,i,s,u,a,c,l,d,p,f){let y=F([P("lpAmount"),P("amountMaxA"),P("amountMaxB")]),b=[{pubkey:e,isSigner:!0,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:Ln,isSigner:!1,isWritable:!1},{pubkey:ra,isSigner:!1,isWritable:!1},{pubkey:a,isSigner:!1,isWritable:!1},{pubkey:c,isSigner:!1,isWritable:!1},{pubkey:l,isSigner:!1,isWritable:!0}],g=Buffer.alloc(y.span);return Dd.debug("cpmm deposit data",{lpAmount:d.toString(),amountMaxA:p.toString(),amountMaxB:f.toString()}),y.encode({lpAmount:d,amountMaxA:p,amountMaxB:f},g),new Jn({keys:b,programId:m,data:Buffer.from([...eo.deposit,...g])})}function Kc(m,e,t,n,o,r,i,s,u,a,c,l,d,p,f){let y=F([P("lpAmount"),P("amountMinA"),P("amountMinB")]),b=[{pubkey:e,isSigner:!0,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:Ln,isSigner:!1,isWritable:!1},{pubkey:ra,isSigner:!1,isWritable:!1},{pubkey:a,isSigner:!1,isWritable:!1},{pubkey:c,isSigner:!1,isWritable:!1},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:kn,isSigner:!1,isWritable:!1}],g=Buffer.alloc(y.span);return y.encode({lpAmount:d,amountMinA:p,amountMinB:f},g),new Jn({keys:b,programId:m,data:Buffer.from([...eo.withdraw,...g])})}function Ir(m,e,t,n,o,r,i,s,u,a,c,l,d,p,f,y){let b=F([P("amountIn"),P("amounOutMin")]),g=[{pubkey:e,isSigner:!0,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!1},{pubkey:c,isSigner:!1,isWritable:!1},{pubkey:l,isSigner:!1,isWritable:!1},{pubkey:d,isSigner:!1,isWritable:!1},{pubkey:p,isSigner:!1,isWritable:!0}],A=Buffer.alloc(b.span);return b.encode({amountIn:f,amounOutMin:y},A),new Jn({keys:g,programId:m,data:Buffer.from([...eo.swapBaseInput,...A])})}function Cc(m,e,t,n,o,r,i,s,u,a,c,l,d,p,f,y){let b=F([P("amountInMax"),P("amountOut")]),g=[{pubkey:e,isSigner:!0,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!1},{pubkey:c,isSigner:!1,isWritable:!1},{pubkey:l,isSigner:!1,isWritable:!1},{pubkey:d,isSigner:!1,isWritable:!1},{pubkey:p,isSigner:!1,isWritable:!0}],A=Buffer.alloc(b.span);return b.encode({amountInMax:f,amountOut:y},A),new Jn({keys:g,programId:m,data:Buffer.from([...eo.swapBaseOutput,...A])})}async function Rc(m){var b;let{ownerInfo:e,poolInfo:t,poolKeys:n,feeNftOwner:o,getEphemeralSigners:r}=m,i=[],[s,u]=[new Ai(t.id),new Ai(t.lpMint.address)],a;if(r)a=new Ai((await r(1))[0]);else{let g=Vd.generate();i.push(g),a=g.publicKey}let{publicKey:c}=Z(o,a,Ln),{publicKey:l}=yn(a),{publicKey:d}=gi(m.lockProgram,a),{publicKey:p}=Z(e.wallet,u,Ln),{publicKey:f}=Z(m.lockAuthProgram,u,Ln),y=Wd({programId:m.lockProgram,auth:m.lockAuthProgram,payer:e.feePayer,liquidityOwner:e.wallet,nftOwner:o,nftMint:a,nftAccount:c,poolId:s,lockPda:d,mintLp:u,userLpVault:p,lockLpVault:f,poolVaultA:new Ai(n.vault.A),poolVaultB:new Ai(n.vault.B),metadataAccount:l,lpAmount:m.lpAmount,withMetadata:(b=m.withMetadata)!=null?b:!0});return{address:{nftMint:a,nftAccount:c,metadataAccount:l,lockPda:d,userLpVault:p,lockLpVault:f},instructions:[y],signers:i,instructionTypes:[q.CpmmLockLp],lookupTableAddress:[]}}function Wd({programId:m,auth:e,payer:t,liquidityOwner:n,nftOwner:o,nftMint:r,nftAccount:i,poolId:s,lockPda:u,mintLp:a,userLpVault:c,lockLpVault:l,poolVaultA:d,poolVaultB:p,metadataAccount:f,lpAmount:y,withMetadata:b}){let g=[{pubkey:e,isSigner:!1,isWritable:!1},{pubkey:t,isSigner:!0,isWritable:!0},{pubkey:n,isSigner:!0,isWritable:!1},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!0,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!1},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!1},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:d,isSigner:!1,isWritable:!0},{pubkey:p,isSigner:!1,isWritable:!0},{pubkey:f,isSigner:!1,isWritable:!0},{pubkey:it,isSigner:!1,isWritable:!1},{pubkey:Ed.programId,isSigner:!1,isWritable:!1},{pubkey:Ln,isSigner:!1,isWritable:!1},{pubkey:Bc,isSigner:!1,isWritable:!1},{pubkey:Xt,isSigner:!1,isWritable:!1}],A=F([P("lpAmount"),De("withMetadata")]),h=Buffer.alloc(A.span);A.encode({lpAmount:y,withMetadata:b},h);let T=Buffer.from([...eo.lockCpLiquidity,...h]);return new Jn({keys:g,programId:m,data:T})}function sa({programId:m,nftOwner:e,auth:t,nftAccount:n,lockPda:o,poolId:r,mintLp:i,userVaultA:s,userVaultB:u,poolVaultA:a,poolVaultB:c,mintA:l,mintB:d,lockLpVault:p,lpFeeAmount:f,cpmmProgram:y,cpmmAuthProgram:b}){let g=[{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:e,isSigner:!0,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:y!=null?y:qi,isSigner:!1,isWritable:!1},{pubkey:b!=null?b:tu,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!1},{pubkey:d,isSigner:!1,isWritable:!1},{pubkey:p,isSigner:!1,isWritable:!0},{pubkey:Ln,isSigner:!1,isWritable:!1},{pubkey:ra,isSigner:!1,isWritable:!1},{pubkey:kn,isSigner:!1,isWritable:!1}],A=F([P("lpFeeAmount")]),h=Buffer.alloc(A.span);A.encode({lpFeeAmount:f},h);let T=Buffer.from([...eo.collectCpFee,...h]);return new Jn({keys:g,programId:m,data:T})}var Lc=F([ke(8),D("bump"),De("disableCreatePool"),Tt("index"),P("tradeFeeRate"),P("protocolFeeRate"),P("fundFeeRate"),P("createPoolFee"),N("protocolOwner"),N("fundOwner"),j(P(),16)]),Br=F([ke(8),N("configId"),N("poolCreator"),N("vaultA"),N("vaultB"),N("mintLp"),N("mintA"),N("mintB"),N("mintProgramA"),N("mintProgramB"),N("observationId"),D("bump"),D("status"),D("lpDecimals"),D("mintDecimalA"),D("mintDecimalB"),P("lpAmount"),P("protocolFeesMintA"),P("protocolFeesMintB"),P("fundFeesMintA"),P("fundFeesMintB"),P("openTime"),j(P(),32)]);var Pi=class extends Ne{constructor(e){super(e)}async load(){this.checkDisabled()}async getCpmmPoolKeys(e){return(await this.scope.api.fetchPoolKeysById({idList:[e]}))[0]}async getRpcPoolInfo(e,t){return(await this.getRpcPoolInfos([e],t))[e]}async getRpcPoolInfos(e,t){let n=await Ce(this.scope.connection,e.map(l=>({pubkey:new X(l)}))),o={},r=new Set,i=[];for(let l=0;l<e.length;l++){let d=n[l];if(d.accountInfo===null)throw Error("fetch pool info error: "+String(e[l]));let p=Br.decode(d.accountInfo.data);o[String(e[l])]=W(v({},p),{programId:d.accountInfo.owner}),r.add(String(p.configId)),i.push(p.vaultA,p.vaultB)}let s={};if(t){let l=[...r],d=await Ce(this.scope.connection,l.map(p=>({pubkey:new X(p)})));for(let p=0;p<l.length;p++){let f=d[p].accountInfo;if(f===null)throw Error("fetch pool config error: "+l[p]);s[l[p]]=Lc.decode(f.data)}}let u={},a=await Ce(this.scope.connection,i.map(l=>({pubkey:new X(l)})));for(let l=0;l<i.length;l++){let d=a[l].accountInfo;if(d===null)throw Error("fetch vault info error: "+i[l]);u[String(i[l])]=new ze(qd.decode(d.data).amount.toString())}let c={};for(let[l,d]of Object.entries(o)){let p=u[d.vaultA.toString()].sub(d.protocolFeesMintA).sub(d.fundFeesMintA),f=u[d.vaultB.toString()].sub(d.protocolFeesMintB).sub(d.fundFeesMintB);c[l]=W(v({},d),{baseReserve:p,quoteReserve:f,vaultAAmount:u[d.vaultA.toString()],vaultBAmount:u[d.vaultB.toString()],configInfo:s[d.configId.toString()],poolPrice:new Ft(f.toString()).div(new Ft(10).pow(d.mintDecimalB)).div(new Ft(p.toString()).div(new Ft(10).pow(d.mintDecimalA)))})}return c}toComputePoolInfos({pools:e,mintInfos:t}){return Object.keys(e).reduce((n,o)=>{var u,a,c,l;let r=e[o],[i,s]=[r.mintA.toBase58(),r.mintB.toBase58()];return W(v({},n),{[o]:W(v({},r),{id:new X(o),configInfo:r.configInfo,version:7,authority:ko(r.programId).publicKey,mintA:dt({address:i,decimals:r.mintDecimalA,programId:r.mintProgramA.toBase58(),extensions:{feeConfig:(u=t[i])!=null&&u.feeConfig?Kn((a=t[i])==null?void 0:a.feeConfig):void 0}}),mintB:dt({address:s,decimals:r.mintDecimalB,programId:r.mintProgramB.toBase58(),extensions:{feeConfig:(c=t[s])!=null&&c.feeConfig?Kn((l=t[s])==null?void 0:l.feeConfig):void 0}})})})},{})}async getPoolInfoFromRpc(e){let t=await this.getRpcPoolInfo(e,!0),n=await ao({connection:this.scope.connection,mints:[t.mintA,t.mintB]}),o=dt({address:t.mintA.toBase58(),decimals:t.mintDecimalA,programId:t.mintProgramA.toBase58(),extensions:{feeConfig:n[t.mintA.toBase58()].feeConfig?Kn(n[t.mintA.toBase58()].feeConfig):void 0}}),r=dt({address:t.mintB.toBase58(),decimals:t.mintDecimalB,programId:t.mintProgramB.toBase58(),extensions:{feeConfig:n[t.mintB.toBase58()].feeConfig?Kn(n[t.mintB.toBase58()].feeConfig):void 0}}),i=dt({address:t.mintLp.toBase58(),decimals:t.lpDecimals,programId:Kt.toBase58()}),s={id:t.configId.toBase58(),index:t.configInfo.index,protocolFeeRate:t.configInfo.protocolFeeRate.toNumber(),tradeFeeRate:t.configInfo.tradeFeeRate.toNumber(),fundFeeRate:t.configInfo.fundFeeRate.toNumber(),createPoolFee:t.configInfo.createPoolFee.toString()},u={volume:0,volumeQuote:0,volumeFee:0,apr:0,feeApr:0,priceMin:0,priceMax:0,rewardApr:[]};return{poolInfo:{programId:t.programId.toBase58(),id:e,type:"Standard",lpMint:i,lpPrice:0,lpAmount:t.lpAmount.toNumber(),config:s,mintA:o,mintB:r,rewardDefaultInfos:[],rewardDefaultPoolInfos:"Ecosystem",price:t.poolPrice.toNumber(),mintAmountA:new Ft(t.vaultAAmount.toString()).div(10**o.decimals).toNumber(),mintAmountB:new Ft(t.vaultBAmount.toString()).div(10**r.decimals).toNumber(),feeRate:t.configInfo.tradeFeeRate.toNumber(),openTime:t.openTime.toString(),tvl:0,burnPercent:0,day:u,week:u,month:u,pooltype:[],farmUpcomingCount:0,farmOngoingCount:0,farmFinishedCount:0},poolKeys:{programId:t.programId.toBase58(),id:e,mintA:o,mintB:r,openTime:t.openTime.toString(),vault:{A:t.vaultA.toBase58(),B:t.vaultB.toBase58()},authority:ko(t.programId).publicKey.toBase58(),mintLp:i,config:s,observationId:bi(t.programId,new X(e)).publicKey.toBase58()},rpcData:t}}async createPool(f){var y=f,{poolId:e,programId:t,poolFeeAccount:n,startTime:o,ownerInfo:r,associatedOnly:i=!1,checkCreateATAOwner:s=!1,txVersion:u,feeConfig:a,computeBudgetConfig:c,txTipConfig:l,feePayer:d}=y,p=_e(y,["poolId","programId","poolFeeAccount","startTime","ownerInfo","associatedOnly","checkCreateATAOwner","txVersion","feeConfig","computeBudgetConfig","txTipConfig","feePayer"]);var _,G,Q;let b=r.feePayer||((_=this.scope.owner)==null?void 0:_.publicKey),g=new ze(new X(p.mintA.address).toBuffer()).lte(new ze(new X(p.mintB.address).toBuffer())),[A,h]=g?[p.mintA,p.mintB]:[p.mintB,p.mintA],[T,k]=g?[p.mintAAmount,p.mintBAmount]:[p.mintBAmount,p.mintAAmount],w=r.useSOLBalance&&A.address===xr.toBase58(),S=r.useSOLBalance&&h.address===xr.toBase58(),[B,K]=[new X(A.address),new X(h.address)],I=this.createTxBuilder(d),{account:C,instructionParams:O}=await this.scope.account.getOrCreateTokenAccount({mint:B,tokenProgram:A.programId,owner:this.scope.ownerPubKey,createInfo:w?{payer:b,amount:T}:void 0,notUseTokenAccount:w,skipCloseAccount:!w,associatedOnly:w?!1:i,checkCreateATAOwner:s});I.addInstruction(O||{});let{account:M,instructionParams:R}=await this.scope.account.getOrCreateTokenAccount({mint:new X(h.address),tokenProgram:h.programId,owner:this.scope.ownerPubKey,createInfo:S?{payer:b,amount:k}:void 0,notUseTokenAccount:S,skipCloseAccount:!S,associatedOnly:S?!1:i,checkCreateATAOwner:s});if(I.addInstruction(R||{}),C===void 0||M===void 0)throw Error("you don't has some token account");let L=Ic({poolId:e,programId:t,configId:new X(a.id),mintA:B,mintB:K});return I.addInstruction({instructions:[xc(t,this.scope.ownerPubKey,new X(a.id),L.authority,L.poolId,B,K,L.lpMint,C,M,Z(this.scope.ownerPubKey,L.lpMint).publicKey,L.vaultA,L.vaultB,n,new X((G=A.programId)!=null?G:Kt),new X((Q=h.programId)!=null?Q:Kt),L.observationId,T,k,o)],instructionTypes:[q.CpmmCreatePool]}),I.addCustomComputeBudget(c),I.addTipInstruction(l),I.versionBuild({txVersion:u,extInfo:{address:W(v({},L),{mintA:A,mintB:h,programId:t,poolFeeAccount:n,feeConfig:a})}})}async addLiquidity(e){let{poolInfo:t,poolKeys:n,inputAmount:o,baseIn:r,slippage:i,computeResult:s,computeBudgetConfig:u,txTipConfig:a,config:c,txVersion:l,feePayer:d}=e;this.scope.availability.addStandardPosition===!1&&this.logAndCreateError("add liquidity feature disabled in your region"),o.isZero()&&this.logAndCreateError("amounts must greater than zero","amountInA",{amountInA:o.toString()});let{account:p}=this.scope,{bypassAssociatedCheck:f,checkCreateATAOwner:y}=v({bypassAssociatedCheck:!1,checkCreateATAOwner:!1},c),b=s?void 0:await this.getRpcPoolInfo(t.id),{liquidity:g,inputAmountFee:A,anotherAmount:h}=s||this.computePairAmount({poolInfo:W(v({},t),{lpAmount:new Ft(b.lpAmount.toString()).div(10**t.lpMint.decimals).toNumber()}),baseReserve:b.baseReserve,quoteReserve:b.quoteReserve,slippage:new tt(0),baseIn:r,epochInfo:await this.scope.fetchEpochInfo(),amount:new Ft(o.toString()).div(10**(r?t.mintA.decimals:t.mintB.decimals))}),T=h.amount,k=t.mintA.address===xr.toString(),w=t.mintB.address===xr.toString(),S=this.createTxBuilder(d),[B,K]=[new X(t.mintA.address),new X(t.mintB.address)],{account:I,instructionParams:C}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:t.mintA.programId,mint:new X(t.mintA.address),owner:this.scope.ownerPubKey,createInfo:k||(r?o:T).isZero()?{payer:this.scope.ownerPubKey,amount:r?o:T}:void 0,skipCloseAccount:!k,notUseTokenAccount:k,associatedOnly:!1,checkCreateATAOwner:y});S.addInstruction(C||{});let{account:O,instructionParams:M}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:t.mintB.programId,mint:new X(t.mintB.address),owner:this.scope.ownerPubKey,createInfo:w||(r?T:o).isZero()?{payer:this.scope.ownerPubKey,amount:r?T:o}:void 0,skipCloseAccount:!w,notUseTokenAccount:w,associatedOnly:!1,checkCreateATAOwner:y});S.addInstruction(M||{}),!I&&!O&&this.logAndCreateError("cannot found target token accounts","tokenAccounts",p.tokenAccounts);let R=await p.getCreatedTokenAccount({mint:new X(t.lpMint.address)}),se=await p.handleTokenAccount({side:"out",amount:0,mint:new X(t.lpMint.address),tokenAccount:R,bypassAssociatedCheck:f,checkCreateATAOwner:y}),{tokenAccount:L}=se,_=_e(se,["tokenAccount"]);S.addInstruction(_);let G=n!=null?n:await this.getCpmmPoolKeys(t.id),Q=new tt(new ze(1)).sub(i);return S.addInstruction({instructions:[Sc(new X(t.programId),this.scope.ownerPubKey,new X(G.authority),new X(t.id),L,I,O,new X(G.vault.A),new X(G.vault.B),B,K,new X(t.lpMint.address),s?s==null?void 0:s.liquidity:Q.mul(g).quotient,r?A.amount:T,r?T:A.amount)],instructionTypes:[q.CpmmAddLiquidity],lookupTableAddress:G.lookupTableAccount?[G.lookupTableAccount]:[]}),S.addCustomComputeBudget(u),S.addTipInstruction(a),S.versionBuild({txVersion:l})}async withdrawLiquidity(e){var _,G;let{poolInfo:t,poolKeys:n,lpAmount:o,slippage:r,computeBudgetConfig:i,txTipConfig:s,txVersion:u,feePayer:a,closeWsol:c=!0}=e;this.scope.availability.addStandardPosition===!1&&this.logAndCreateError("add liquidity feature disabled in your region");let l=new tt(new ze(1)).sub(r),d=await this.getRpcPoolInfo(t.id),[p,f]=[l.mul(o.mul(d.baseReserve).div(d.lpAmount)).quotient,l.mul(o.mul(d.quoteReserve).div(d.lpAmount)).quotient],y=await this.scope.fetchEpochInfo(),[b,g]=[Be(p,t.mintA.extensions.feeConfig,y,!1),Be(f,t.mintB.extensions.feeConfig,y,!1)],{account:A}=this.scope,h=this.createTxBuilder(a),[T,k]=[new X(t.mintA.address),new X(t.mintB.address)],w=T.equals(Y),S=k.equals(Y),B,K,{account:I,instructionParams:C}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:t.mintA.programId,mint:new X(t.mintA.address),notUseTokenAccount:w,owner:this.scope.ownerPubKey,createInfo:{payer:this.scope.ownerPubKey,amount:0},skipCloseAccount:!(w&&c),associatedOnly:!w,checkCreateATAOwner:!1});B=I,C&&h.addInstruction(C);let{account:O,instructionParams:M}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:t.mintB.programId,mint:new X(t.mintB.address),notUseTokenAccount:S,owner:this.scope.ownerPubKey,createInfo:{payer:this.scope.ownerPubKey,amount:0},skipCloseAccount:!(S&&c),associatedOnly:!S,checkCreateATAOwner:!1});K=O,M&&h.addInstruction(M),(!B||!K)&&this.logAndCreateError("cannot found target token accounts","tokenAccounts",A.tokenAccounts);let R=await A.getCreatedTokenAccount({mint:new X(t.lpMint.address)});R||this.logAndCreateError("cannot found lp token account","tokenAccounts",A.tokenAccounts);let L=n!=null?n:await this.getCpmmPoolKeys(t.id);return h.addInstruction({instructions:[Kc(new X(t.programId),this.scope.ownerPubKey,new X(L.authority),new X(t.id),R,B,K,new X(L.vault.A),new X(L.vault.B),T,k,new X(t.lpMint.address),o,p.sub((_=b.fee)!=null?_:new ze(0)),f.sub((G=g.fee)!=null?G:new ze(0)))],instructionTypes:[q.CpmmWithdrawLiquidity],lookupTableAddress:L.lookupTableAccount?[L.lookupTableAccount]:[]}),h.addCustomComputeBudget(i),h.addTipInstruction(s),h.versionBuild({txVersion:u})}async swap(e){var C,O,M,R,L,_;let{poolInfo:t,poolKeys:n,baseIn:o,fixedOut:r,inputAmount:i,swapResult:s,slippage:u=0,config:a,computeBudgetConfig:c,txTipConfig:l,txVersion:d,feePayer:p}=e,{bypassAssociatedCheck:f,checkCreateATAOwner:y,associatedOnly:b}=v({bypassAssociatedCheck:!1,checkCreateATAOwner:!1,associatedOnly:!0},a),g=this.createTxBuilder(p),[A,h]=[new X(t.mintA.address),new X(t.mintB.address)];r?s.sourceAmountSwapped=s.sourceAmountSwapped.mul(new ze((1+u)*1e4)).div(new ze(1e4)):s.destinationAmountSwapped=s.destinationAmountSwapped.mul(new ze((1-u)*1e4)).div(new ze(1e4));let T=t.mintA.address===Y.toBase58(),k=t.mintB.address===Y.toBase58(),{account:w,instructionParams:S}=await this.scope.account.getOrCreateTokenAccount({mint:A,tokenProgram:new X((C=t.mintA.programId)!=null?C:Kt),owner:this.scope.ownerPubKey,createInfo:T||!o?{payer:this.scope.ownerPubKey,amount:o?s.sourceAmountSwapped:0}:void 0,notUseTokenAccount:T,skipCloseAccount:!T,associatedOnly:T?!1:b,checkCreateATAOwner:y});S&&g.addInstruction(S);let{account:B,instructionParams:K}=await this.scope.account.getOrCreateTokenAccount({mint:h,tokenProgram:new X((O=t.mintB.programId)!=null?O:Kt),owner:this.scope.ownerPubKey,createInfo:k||o?{payer:this.scope.ownerPubKey,amount:o?0:s.sourceAmountSwapped}:void 0,notUseTokenAccount:k,skipCloseAccount:!k,associatedOnly:k?!1:b,checkCreateATAOwner:y});K&&g.addInstruction(K),(!w||!B)&&this.logAndCreateError("user do not have token account",{mintA:t.mintA.symbol||t.mintA.address,mintB:t.mintB.symbol||t.mintB.address,mintATokenAcc:w,mintBTokenAcc:B,mintAUseSOLBalance:T,mintBUseSOLBalance:k,associatedOnly:b});let I=n!=null?n:await this.getCpmmPoolKeys(t.id);return g.addInstruction({instructions:[r?Cc(new X(t.programId),this.scope.ownerPubKey,new X(I.authority),new X(I.config.id),new X(t.id),o?w:B,o?B:w,new X(I.vault[o?"A":"B"]),new X(I.vault[o?"B":"A"]),new X((L=t[o?"mintA":"mintB"].programId)!=null?L:Kt),new X((_=t[o?"mintB":"mintA"].programId)!=null?_:Kt),o?A:h,o?h:A,bi(new X(t.programId),new X(t.id)).publicKey,s.sourceAmountSwapped,s.destinationAmountSwapped):Ir(new X(t.programId),this.scope.ownerPubKey,new X(I.authority),new X(I.config.id),new X(t.id),o?w:B,o?B:w,new X(I.vault[o?"A":"B"]),new X(I.vault[o?"B":"A"]),new X((M=t[o?"mintA":"mintB"].programId)!=null?M:Kt),new X((R=t[o?"mintB":"mintA"].programId)!=null?R:Kt),o?A:h,o?h:A,bi(new X(t.programId),new X(t.id)).publicKey,i,s.destinationAmountSwapped)],instructionTypes:[r?q.CpmmSwapBaseOut:q.ClmmSwapBaseIn]}),g.addCustomComputeBudget(c),g.addTipInstruction(l),g.versionBuild({txVersion:d})}async lockLp(e){var d,p,f,y,b;let{poolInfo:t,lpAmount:n,computeBudgetConfig:o,txTipConfig:r,txVersion:i,feePayer:s,feeNftOwner:u}=e;n.isZero()&&this.logAndCreateError("lpAmount must greater than zero",{lpAmount:n.toString()});let a=this.createTxBuilder(s),c=(d=e.poolKeys)!=null?d:await this.getCpmmPoolKeys(t.id),l=await Rc({poolInfo:t,poolKeys:c,ownerInfo:{wallet:this.scope.ownerPubKey,feePayer:(p=e.feePayer)!=null?p:this.scope.ownerPubKey},feeNftOwner:u!=null?u:this.scope.ownerPubKey,lockProgram:(f=e.programId)!=null?f:Ui,lockAuthProgram:(y=e.authProgram)!=null?y:Gi,lpAmount:n,withMetadata:(b=e.withMetadata)!=null?b:!0,getEphemeralSigners:e.getEphemeralSigners});return a.addInstruction(l),a.addCustomComputeBudget(o),a.addTipInstruction(r),a.versionBuild({txVersion:i,extInfo:l.address})}async harvestLockLp(e){var O;let{poolInfo:t,lpFeeAmount:n,nftMint:o,programId:r=Ui,authProgram:i=Gi,cpmmProgram:s,computeBudgetConfig:u,txTipConfig:a,txVersion:c,closeWsol:l=!0}=e;n.isZero()&&this.logAndCreateError("lpFeeAmount must greater than zero",{lpAmount:n.toString()});let d=e.feePayer||this.scope.ownerPubKey,p=this.createTxBuilder(d),[f,y]=[new X(t.mintA.address),new X(t.mintB.address)],b=f.equals(Y),g=y.equals(Y),A,h,{account:T,instructionParams:k}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:t.mintA.programId,mint:new X(t.mintA.address),notUseTokenAccount:b,owner:this.scope.ownerPubKey,createInfo:{payer:this.scope.ownerPubKey,amount:0},skipCloseAccount:!(b&&l),associatedOnly:!b,checkCreateATAOwner:!1});A=T,k&&p.addInstruction(k);let{account:w,instructionParams:S}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:t.mintB.programId,mint:new X(t.mintB.address),notUseTokenAccount:g,owner:this.scope.ownerPubKey,createInfo:{payer:this.scope.ownerPubKey,amount:0},skipCloseAccount:!(g&&l),associatedOnly:!g,checkCreateATAOwner:!1});h=w,S&&p.addInstruction(S),(!A||!h)&&this.logAndCreateError("cannot found target token accounts",{tokenAccountA:A,tokenAccountB:h});let B=(O=e.poolKeys)!=null?O:await this.getCpmmPoolKeys(t.id),{publicKey:K}=Z(d,o,Kt),{publicKey:I}=gi(r,o),{publicKey:C}=Z(i,new X(t.lpMint.address),Kt);return p.addInstruction({instructions:[sa({programId:r,nftOwner:this.scope.ownerPubKey,auth:i,nftMint:o,nftAccount:K,lockPda:I,poolId:new X(t.id),mintLp:new X(B.mintLp.address),userVaultA:A,userVaultB:h,poolVaultA:new X(B.vault.A),poolVaultB:new X(B.vault.B),mintA:f,mintB:y,lockLpVault:C,lpFeeAmount:n,cpmmProgram:s==null?void 0:s.programId,cpmmAuthProgram:s==null?void 0:s.authProgram})],instructionTypes:[q.CpmmCollectLockFee]}),p.addCustomComputeBudget(u),p.addTipInstruction(a),p.versionBuild({txVersion:c})}async harvestMultiLockLp(e){let{lockInfo:t,programId:n=Ui,authProgram:o=Gi,cpmmProgram:r,computeBudgetConfig:i,txVersion:s,closeWsol:u=!0}=e,a=e.feePayer||this.scope.ownerPubKey,c=this.createTxBuilder(a),l={};return t.forEach(async d=>{var I;let{poolInfo:p,lpFeeAmount:f,nftMint:y}=d;if(f.isZero())return;let[b,g]=[new X(p.mintA.address),new X(p.mintB.address)],A=b.equals(Y),h=g.equals(Y),T=l[p.mintA.address],k=l[p.mintB.address];if(!T)if(A){let{account:C,instructionParams:O}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:p.mintA.programId,mint:new X(p.mintA.address),notUseTokenAccount:!0,owner:this.scope.ownerPubKey,createInfo:{payer:this.scope.ownerPubKey,amount:0},skipCloseAccount:!u,associatedOnly:!1,checkCreateATAOwner:!1});T=C,O&&c.addInstruction(O),l[p.mintA.address]=C}else{let C=new X(p.mintA.address);T=this.scope.account.getAssociatedTokenAccount(C,new X(p.mintA.programId)),c.addInstruction({instructions:[Oc(this.scope.ownerPubKey,T,this.scope.ownerPubKey,C)]}),l[p.mintA.address]=T}if(!k)if(h){let{account:C,instructionParams:O}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:p.mintB.programId,mint:new X(p.mintB.address),notUseTokenAccount:!0,owner:this.scope.ownerPubKey,createInfo:{payer:this.scope.ownerPubKey,amount:0},skipCloseAccount:!u,associatedOnly:!1,checkCreateATAOwner:!1});k=C,O&&c.addInstruction(O),l[p.mintB.address]=C}else{let C=new X(p.mintB.address);k=this.scope.account.getAssociatedTokenAccount(C,new X(p.mintB.programId)),c.addInstruction({instructions:[Oc(this.scope.ownerPubKey,k,this.scope.ownerPubKey,C)]}),l[p.mintB.address]=k}(!T||!k)&&this.logAndCreateError("cannot found target token accounts",{tokenAccountA:T,tokenAccountB:k});let w=(I=d.poolKeys)!=null?I:await this.getCpmmPoolKeys(p.id),{publicKey:S}=Z(a,y,Kt),{publicKey:B}=gi(n,y),{publicKey:K}=Z(o,new X(p.lpMint.address),Kt);c.addInstruction({instructions:[sa({programId:n,nftOwner:this.scope.ownerPubKey,auth:o,nftMint:y,nftAccount:S,lockPda:B,poolId:new X(p.id),mintLp:new X(w.mintLp.address),userVaultA:T,userVaultB:k,poolVaultA:new X(w.vault.A),poolVaultB:new X(w.vault.B),mintA:b,mintB:g,lockLpVault:K,lpFeeAmount:f,cpmmProgram:r==null?void 0:r.programId,cpmmAuthProgram:r==null?void 0:r.authProgram})],instructionTypes:[q.CpmmCollectLockFee]})}),s===0?c.sizeCheckBuildV0({computeBudgetConfig:i}):c.sizeCheckBuild({computeBudgetConfig:i})}computeSwapAmount({pool:e,amountIn:t,outputMint:n,slippage:o}){let r=n.toString()===e.mintB.address,i=Tr.swap(t,r?e.baseReserve:e.quoteReserve,r?e.quoteReserve:e.baseReserve,e.configInfo.tradeFeeRate),s=new Ft(i.destinationAmountSwapped.toString()).div(i.sourceAmountSwapped.toString()),u=i.destinationAmountSwapped.mul(new ze((1-o)*1e4)).div(new ze(1e4));return{allTrade:i.sourceAmountSwapped.eq(t),amountIn:t,amountOut:i.destinationAmountSwapped,minAmountOut:u,executionPrice:s,fee:i.tradeFee,priceImpact:e.poolPrice.sub(s).div(e.poolPrice)}}computePairAmount({poolInfo:e,baseReserve:t,quoteReserve:n,amount:o,slippage:r,epochInfo:i,baseIn:s}){var T,k,w,S,B,K,I,C,O;let u=1-Number(r.toSignificant())/100,a=new ze(new Ft(o).mul(10**e[s?"mintA":"mintB"].decimals).mul(u).toFixed(0)),c=Be(a,e[s?"mintA":"mintB"].extensions.feeConfig,i,!1),l=a.sub((T=c.fee)!=null?T:new ze(0)),d=new ze(new Ft(e.lpAmount).mul(10**e.lpMint.decimals).toFixed(0,Ft.ROUND_DOWN));this.logDebug("baseReserve:",t.toString(),"quoteReserve:",n.toString()),this.logDebug("tokenIn:",s?e.mintA.symbol:e.mintB.symbol,"amountIn:",a.toString(),"amountInFee:",(w=(k=c.fee)==null?void 0:k.toString())!=null?w:0,"anotherToken:",s?e.mintB.symbol:e.mintA.symbol,"slippage:",`${r.toSignificant()}%`);let p=s?"base":"quote";this.logDebug("input side:",p);let f=l.mul(d).div(p==="base"?t:n),y={amount:At,fee:void 0,expirationTime:void 0};if(!l.isZero()){let M=Ud(f,t,n,d);this.logDebug("lpAmountData:",{amountA:M.amountA.toString(),amountB:M.amountB.toString()}),y=Be(M[s?"amountB":"amountA"],e[s?"mintB":"mintA"].extensions.feeConfig,i,!0)}let b=new tt(new ze(1)).add(r),g=new tt(new ze(1)).sub(r),A=Be(b.mul(y.amount.sub((S=y.fee)!=null?S:new ze(0))).quotient,e[s?"mintB":"mintA"].extensions.feeConfig,i,!0),h=Be(g.mul(y.amount.sub((B=y.fee)!=null?B:new ze(0))).quotient,e[s?"mintB":"mintA"].extensions.feeConfig,i,!0);return this.logDebug("anotherAmount:",y.amount.toString(),"anotherAmountFee:",(I=(K=y.fee)==null?void 0:K.toString())!=null?I:0,"maxAnotherAmount:",A.amount.toString(),"maxAnotherAmountFee:",(O=(C=A.fee)==null?void 0:C.toString())!=null?O:0),{inputAmountFee:c,anotherAmount:y,maxAnotherAmount:A,minAnotherAmount:h,liquidity:f}}};function Ud(m,e,t,n){let o=m.mul(e).div(n);!o.isZero()&&!m.mul(e).mod(n).isZero()&&(o=o.add(new ze(1)));let r=m.mul(t).div(n);return!r.isZero()&&!m.mul(t).mod(n).isZero()&&(r=r.add(new ze(1))),{amountA:o,amountB:r}}import{PublicKey as no}from"@solana/web3.js";import{createTransferInstruction as Vc,TOKEN_PROGRAM_ID as Qe,TOKEN_2022_PROGRAM_ID as Cr}from"@solana/spl-token";import Rr from"bn.js";import wi from"decimal.js";var Nc={[is.toBase58()]:3},Mc={3:is};var aa=F([ke(5),ke(8),N("ownAddress"),P("vaultSignerNonce"),N("baseMint"),N("quoteMint"),N("baseVault"),P("baseDepositsTotal"),P("baseFeesAccrued"),N("quoteVault"),P("quoteDepositsTotal"),P("quoteFeesAccrued"),P("quoteDustThreshold"),N("requestQueue"),N("eventQueue"),N("bids"),N("asks"),P("baseLotSize"),P("quoteLotSize"),P("feeRateBps"),P("referrerRebatesAccrued"),ke(7)]),vc={3:aa};import{PublicKey as _c}from"@solana/web3.js";var Sr=ye("Serum"),Kr=class{static getProgramId(e){let t=Mc[e];return t||Sr.logWithError("invalid version","version",e),t}static getVersion(e){let t=e.toBase58(),n=Nc[t];return n||Sr.logWithError("invalid program id","programId",t),n}static getStateLayout(e){let t=vc[e];return t||Sr.logWithError(!!t,"invalid version","version",e),t}static getLayouts(e){return{state:this.getStateLayout(e)}}static getAssociatedAuthority({programId:e,marketId:t}){let n=[t.toBuffer()],o=0,r;for(;o<100;){try{let i=n.concat(Buffer.from([o]),Buffer.alloc(7));r=_c.createProgramAddressSync(i,e)}catch(i){if(i instanceof TypeError)throw i;o++;continue}return{publicKey:r,nonce:o}}return Sr.logWithError("unable to find a viable program address nonce","params",{programId:e,marketId:t}),{publicKey:_c.default,nonce:o}}};import{PublicKey as oe,SystemProgram as Gd,TransactionInstruction as Xd}from"@solana/web3.js";import to from"bn.js";import{ASSOCIATED_TOKEN_PROGRAM_ID as zd,TOKEN_2022_PROGRAM_ID as Qd,TOKEN_PROGRAM_ID as jd}from"@solana/spl-token";function Yd(m,e,t,n,o,r,i,s,u,a,c,l,d,p,f){var w;let y=[],b=[x({pubkey:jd,isWritable:!1}),x({pubkey:Qd,isWritable:!1}),x({pubkey:zd,isWritable:!1}),x({pubkey:Gd.programId,isWritable:!1}),x({pubkey:e,isSigner:!0})];b.push(x({pubkey:t})),b.push(x({pubkey:o}));let g=[u,a],A=[c,l],h=[r,i,s];for(let S=0;S<g.length;S++){let B=g[S],K=h[S]===B.mintA.address;if(b.push(x({pubkey:new oe(B.programId),isWritable:!1})),S===g.length-1?b.push(x({pubkey:o})):b.push(x({pubkey:n})),b.push(x({pubkey:new oe(h[S])})),b.push(x({pubkey:new oe(h[S+1])})),B.version===6){let I=A[S];b.push(x({pubkey:new oe(I.config.id)})),b.push(x({pubkey:new oe(I.id)})),b.push(x({pubkey:new oe(K?I.vault.A:I.vault.B)})),b.push(x({pubkey:new oe(K?I.vault.B:I.vault.A)})),b.push(x({pubkey:new oe(B.observationId)})),b.push(x({pubkey:kn})),b.push(x({pubkey:Xe(new oe(B.programId),new oe(B.id)).publicKey})),y.push(Hd(B.sqrtPriceX64.toString(),K));for(let C of(w=f[S])!=null?w:[])b.push(x({pubkey:new oe(C)}))}else if(B.version===5){let I=A[S];b.push(x({pubkey:new oe(I.id)})),b.push(x({pubkey:new oe(I.authority),isWritable:!1})),b.push(x({pubkey:new oe(I.marketProgramId)})),b.push(x({pubkey:new oe(I.marketAuthority)})),b.push(x({pubkey:Ja,isWritable:!1})),b.push(x({pubkey:new oe(I.openOrders)})),b.push(x({pubkey:new oe(I.vault.A)})),b.push(x({pubkey:new oe(I.vault.B)})),b.push(x({pubkey:new oe(I.id)})),b.push(x({pubkey:new oe(I.id)})),b.push(x({pubkey:new oe(I.id)})),b.push(x({pubkey:new oe(I.id)})),b.push(x({pubkey:new oe(I.id)})),b.push(x({pubkey:new oe(I.id)})),b.push(x({pubkey:new oe(I.marketId)})),b.push(x({pubkey:new oe(I.marketBids)})),b.push(x({pubkey:new oe(I.marketAsks)})),b.push(x({pubkey:new oe(I.marketEventQueue)})),b.push(x({pubkey:new oe(I.marketBaseVault)})),b.push(x({pubkey:new oe(I.marketQuoteVault)}))}else if(B.version===4){let I=A[S],C=B.status!==1;b.push(x({pubkey:new oe(I.id)})),b.push(x({pubkey:new oe(I.authority),isWritable:!1})),b.push(x({pubkey:new oe(C?I.id:I.marketProgramId)})),b.push(x({pubkey:new oe(C?I.id:I.marketAuthority)})),b.push(x({pubkey:new oe(C?I.id:I.openOrders)})),b.push(x({pubkey:new oe(I.vault.A)})),b.push(x({pubkey:new oe(I.vault.B)})),b.push(x({pubkey:new oe(C?I.id:I.marketId)})),b.push(x({pubkey:new oe(C?I.id:I.marketBids)})),b.push(x({pubkey:new oe(C?I.id:I.marketAsks)})),b.push(x({pubkey:new oe(C?I.id:I.marketEventQueue)})),b.push(x({pubkey:new oe(C?I.id:I.marketBaseVault)})),b.push(x({pubkey:new oe(C?I.id:I.marketQuoteVault)}))}else if(B.version===7){let I=A[S];b.push(x({pubkey:new oe(I.authority)})),b.push(x({pubkey:new oe(I.config.id)})),b.push(x({pubkey:new oe(I.id)})),b.push(x({pubkey:new oe(K?I.vault.A:I.vault.B)})),b.push(x({pubkey:new oe(K?I.vault.B:I.vault.A)})),b.push(x({pubkey:new oe(B.observationId)}))}else throw Error("pool type error")}let T=F([D("insId"),P("amountIn"),P("amountOut"),j(te(),y.length,"clmmPriceLimit")]),k=Buffer.alloc(T.span);return T.encode({insId:0,amountIn:d,amountOut:p,clmmPriceLimit:y},k),new Xd({keys:b,programId:m,data:k})}function Hd(m,e){if(m)if(e){let t=new to(m).div(new to(25));return t.gt(sr)?t:sr}else{let t=new to(m).mul(new to(25));return t.lt(ar)?t:ar}else return e?sr:ar}function Fc({routeProgram:m,ownerInfo:e,inputMint:t,swapInfo:n}){var o,r,i,s,u,a,c;if(n.routeType==="amm")if(n.poolInfo[0].version===6){let l=n.poolKey[0],d=rt(l),p=t.equals(d.mintA.address)?vt.add(Bt):_t.sub(Bt);return Se.makeSwapBaseInInstructions({poolInfo:l,poolKeys:l,observationId:n.poolInfo[0].observationId,ownerInfo:{wallet:e.wallet,tokenAccountA:d.mintA.address.equals(t)?e.sourceToken:e.destinationToken,tokenAccountB:d.mintA.address.equals(t)?e.destinationToken:e.sourceToken},inputMint:t,amountIn:n.amountIn.amount.raw,amountOutMin:n.minAmountOut.amount.raw.sub((r=(o=n.minAmountOut.fee)==null?void 0:o.raw)!=null?r:new to(0)),sqrtPriceLimitX64:p,remainingAccounts:(i=n.remainingAccounts[0])!=null?i:[]})}else if(n.poolInfo[0].version===7){let l=n.poolInfo[0],d=t.toString()===n.poolInfo[0].mintA.address;return{signers:[],instructions:[Ir(l.programId,e.wallet,l.authority,l.configId,l.id,e.sourceToken,e.destinationToken,d?l.vaultA:l.vaultB,d?l.vaultB:l.vaultA,d?l.mintProgramA:l.mintProgramB,d?l.mintProgramB:l.mintProgramA,new oe(l[d?"mintA":"mintB"].address),new oe(l[d?"mintB":"mintA"].address),l.observationId,n.amountIn.amount.raw,n.minAmountOut.amount.raw)],lookupTableAddress:[],instructionTypes:[d?q.CpmmSwapBaseIn:q.CpmmSwapBaseOut],address:{}}}else{let l=n.poolKey[0];return{signers:[],instructions:[pr({poolKeys:l,version:n.poolInfo[0].pooltype.includes("StablePool")?5:4,userKeys:{tokenAccountIn:e.sourceToken,tokenAccountOut:e.destinationToken,owner:e.wallet},amountIn:n.amountIn.amount.raw,amountOut:n.minAmountOut.amount.raw.sub((u=(s=n.minAmountOut.fee)==null?void 0:s.raw)!=null?u:new to(0)),fixedSide:"in"})],lookupTableAddress:l.lookupTableAccount?[l.lookupTableAccount]:[],instructionTypes:[n.poolInfo[0].pooltype.includes("StablePool")?q.AmmV5SwapBaseIn:q.AmmV4SwapBaseIn],address:{}}}else if(n.routeType==="route"){let l=n.poolInfo[0],d=n.poolInfo[1],p=n.poolKey[0],f=n.poolKey[1];if(e.routeToken===void 0)throw Error("owner route token account check error");return{signers:[],instructions:[Yd(m,e.wallet,e.sourceToken,e.routeToken,e.destinationToken,t.toString(),n.middleToken.mint.toString(),n.outputMint.toString(),l,d,p,f,n.amountIn.amount.raw,n.minAmountOut.amount.raw.sub((c=(a=n.minAmountOut.fee)==null?void 0:a.raw)!=null?c:new to(0)),n.remainingAccounts)],instructionTypes:[q.RouteSwap],lookupTableAddress:[p.lookupTableAccount,f.lookupTableAccount].filter(y=>y!==void 0),address:{}}}else throw Error("route type error")}var An=new Rr(0),ki=class extends Ne{constructor(e){super(e)}async getWSolAccounts(){this.scope.checkOwner(),await this.scope.account.fetchWalletTokenAccounts();let e=this.scope.account.tokenAccounts.filter(t=>t.mint.equals(Y));return e.sort((t,n)=>t.isAssociated?1:n.isAssociated||t.amount.lt(n.amount)?-1:1),e}async unWrapWSol(e){let{amount:t,tokenProgram:n,txVersion:o=1,feePayer:r}=e,i=await this.getWSolAccounts(),s=this.createTxBuilder(r);s.addCustomComputeBudget(e.computeBudgetConfig);let u=$(t);for(let a=0;a<i.length;a++)u.gte(i[a].amount)?(s.addInstruction({instructions:[dn({tokenAccount:i[a].publicKey,payer:this.scope.ownerPubKey,owner:this.scope.ownerPubKey,programId:n})]}),u.sub(i[a].amount)):s.addInstruction({instructions:[dn({tokenAccount:i[a].publicKey,payer:this.scope.ownerPubKey,owner:this.scope.ownerPubKey,programId:n})]});return s.versionBuild({txVersion:o})}async wrapWSol(e,t,n,o){let r=this.createTxBuilder(o),i=await Bn({connection:this.scope.connection,owner:this.scope.ownerPubKey,payer:this.scope.ownerPubKey,amount:e,skipCloseAccount:!0});return r.addInstruction(i),r.versionBuild({txVersion:n!=null?n:1})}async swap({swapInfo:e,swapPoolKeys:t,ownerInfo:n,computeBudgetConfig:o,routeProgram:r,txVersion:i,feePayer:s}){let u=this.createTxBuilder(s),a=e.amountIn,c=e.amountOut,l=a.amount.token.mint.equals(Y),d=c.amount.token.mint.equals(Y),p=a.amount.token.mint,f=c.amount.token.mint,{account:y,instructionParams:b}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:a.amount.token.isToken2022?Cr:Qe,mint:p,notUseTokenAccount:l,owner:this.scope.ownerPubKey,skipCloseAccount:!l,createInfo:l?{payer:this.scope.ownerPubKey,amount:a.amount.raw}:void 0,associatedOnly:l?!1:n.associatedOnly,checkCreateATAOwner:n.checkCreateATAOwner});if(b&&u.addInstruction(b),y===void 0)throw Error("input account check error");let g;if(e.routeType==="route"&&!d)g=this.scope.account.getAssociatedTokenAccount(f,c.amount.token.isToken2022?Cr:Qe);else{let{account:k,instructionParams:w}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:c.amount.token.isToken2022?Cr:Qe,mint:f,notUseTokenAccount:d,owner:this.scope.ownerPubKey,skipCloseAccount:!0,createInfo:{payer:this.scope.ownerPubKey,amount:0},associatedOnly:d?!1:n.associatedOnly,checkCreateATAOwner:n.checkCreateATAOwner});g=k,w&&u.addInstruction(w)}d&&u.addInstruction({endInstructions:[dn({owner:this.scope.ownerPubKey,payer:this.scope.ownerPubKey,tokenAccount:g,programId:Qe})],endInstructionTypes:[q.CloseAccount]});let A;if(e.routeType==="route"){let k=e.middleToken;A=this.scope.account.getAssociatedTokenAccount(k.mint,k.isToken2022?Cr:Qe)}let h=t||await this.computePoolToPoolKeys({pools:e.poolInfoList}),T=Fc({routeProgram:r,inputMint:p,swapInfo:W(v({},e),{poolInfo:[...e.poolInfoList],poolKey:h,outputMint:f}),ownerInfo:{wallet:this.scope.ownerPubKey,sourceToken:y,routeToken:A,destinationToken:g}});if(e.feeConfig!==void 0){let k=this.createTxBuilder();k.addInstruction({instructions:[Vc(y,e.feeConfig.feeAccount,this.scope.ownerPubKey,e.feeConfig.feeAmount.toNumber())],instructionTypes:[q.TransferAmount]}),k.addInstruction(T);let{transactions:w}=i===0?await k.sizeCheckBuildV0():await k.sizeCheckBuild();w.length<2&&u.addInstruction({instructions:[Vc(y,e.feeConfig.feeAccount,this.scope.ownerPubKey,e.feeConfig.feeAmount.toNumber())],instructionTypes:[q.TransferAmount]})}return u.addInstruction(T),i===0?u.sizeCheckBuildV0({computeBudgetConfig:o,address:T.address}):u.sizeCheckBuild({computeBudgetConfig:o,address:T.address})}async fetchRoutePoolBasicInfo(e){let{amm:t=Di,clmm:n=Fn,cpmm:o=qi}=e||{},r=await this.scope.connection.getProgramAccounts(t,{dataSlice:{offset:ai.offsetOf("baseMint"),length:64}}),i=F([N("baseMint"),N("quoteMint")]),s=r.map(p=>({id:p.pubkey,version:4,mintA:i.decode(p.account.data).baseMint,mintB:i.decode(p.account.data).quoteMint})),u=F([N("mintA"),N("mintB")]),c=(await this.scope.connection.getProgramAccounts(n,{filters:[{dataSize:zn.span}],dataSlice:{offset:zn.offsetOf("mintA"),length:64}})).map(p=>{let f=u.decode(p.account.data);return{id:p.pubkey,version:6,mintA:f.mintA,mintB:f.mintB}}),d=(await this.scope.connection.getProgramAccounts(o,{dataSlice:{offset:Br.offsetOf("mintA"),length:64}})).map(p=>{let f=u.decode(p.account.data);return{id:p.pubkey,version:7,mintA:f.mintA,mintB:f.mintB}});return{clmmPools:c,ammPools:s,cpmmPools:d}}getAllRoute({inputMint:e,outputMint:t,clmmPools:n,ammPools:o,cpmmPools:r}){e=e.toString()===no.default.toString()?Y:e,t=t.toString()===no.default.toString()?Y:t;let i={},s={},u={},a=[],c={};for(let d of n!=null?n:[]){if((d.mintA.equals(e)&&d.mintB.equals(t)||d.mintA.equals(t)&&d.mintB.equals(e))&&(a.push(d),s[d.id.toString()]=d),d.mintA.equals(e)){let p=d.mintB.toString();c[p]===void 0&&(c[p]={mintProgram:Qe,in:[],out:[],mDecimals:0}),c[p].in.push(d)}if(d.mintB.equals(e)){let p=d.mintA.toString();c[p]===void 0&&(c[p]={mintProgram:Qe,in:[],out:[],mDecimals:0}),c[p].in.push(d)}if(d.mintA.equals(t)){let p=d.mintB.toString();c[p]===void 0&&(c[p]={mintProgram:Qe,in:[],out:[],mDecimals:0}),c[p].out.push(d)}if(d.mintB.equals(t)){let p=d.mintA.toString();c[p]===void 0&&(c[p]={mintProgram:Qe,in:[],out:[],mDecimals:0}),c[p].out.push(d)}}let l=[];for(let d of o)(d.mintA.equals(e)&&d.mintB.equals(t)||d.mintA.equals(t)&&d.mintB.equals(e))&&(a.push(d),i[d.id.toBase58()]=d,l.push(d)),d.mintA.equals(e)&&(c[d.mintB.toBase58()]===void 0&&(c[d.mintB.toBase58()]={mintProgram:Qe,in:[],out:[],mDecimals:0}),c[d.mintB.toBase58()].in.push(d)),d.mintB.equals(e)&&(c[d.mintA.toBase58()]===void 0&&(c[d.mintA.toBase58()]={mintProgram:Qe,in:[],out:[],mDecimals:0}),c[d.mintA.toBase58()].in.push(d)),d.mintA.equals(t)&&(c[d.mintB.toBase58()]===void 0&&(c[d.mintB.toBase58()]={mintProgram:Qe,in:[],out:[],mDecimals:0}),c[d.mintB.toBase58()].out.push(d)),d.mintB.equals(t)&&(c[d.mintA.toBase58()]===void 0&&(c[d.mintA.toBase58()]={mintProgram:Qe,in:[],out:[],mDecimals:0}),c[d.mintA.toBase58()].out.push(d));for(let d of r)(d.mintA.equals(e)&&d.mintB.equals(t)||d.mintA.equals(t)&&d.mintB.equals(e))&&(a.push(d),u[d.id.toBase58()]=d),d.mintA.equals(e)&&(c[d.mintB.toBase58()]===void 0&&(c[d.mintB.toBase58()]={mintProgram:Qe,in:[],out:[],mDecimals:0}),c[d.mintB.toBase58()].in.push(d)),d.mintB.equals(e)&&(c[d.mintA.toBase58()]===void 0&&(c[d.mintA.toBase58()]={mintProgram:Qe,in:[],out:[],mDecimals:0}),c[d.mintA.toBase58()].in.push(d)),d.mintA.equals(t)&&(c[d.mintB.toBase58()]===void 0&&(c[d.mintB.toBase58()]={mintProgram:Qe,in:[],out:[],mDecimals:0}),c[d.mintB.toBase58()].out.push(d)),d.mintB.equals(t)&&(c[d.mintA.toBase58()]===void 0&&(c[d.mintA.toBase58()]={mintProgram:Qe,in:[],out:[],mDecimals:0}),c[d.mintA.toBase58()].out.push(d));for(let d of Object.keys(c)){if(c[d].in.length===1&&c[d].out.length===1&&c[d].in[0].id.equals(c[d].out[0].id)){delete c[d];continue}if(c[d].in.length===0||c[d].out.length===0){delete c[d];continue}let p=c[d];for(let f of p.in)for(let y of p.out)f.version===6&&s[f.id.toString()]===void 0?s[f.id.toString()]=f:f.version===7&&u[f.id.toString()]===void 0?u[f.id.toString()]=f:(f.version===4||f.version===5)&&i[f.id.toString()]===void 0&&(i[f.id.toString()]=f),y.version===6&&s[y.id.toString()]===void 0?s[y.id.toString()]=y:y.version===7&&u[y.id.toString()]===void 0?u[y.id.toString()]=y:(y.version===4||y.version===5)&&i[y.id.toString()]===void 0&&(i[y.id.toString()]=y)}return{directPath:a,addLiquidityPools:l,routePathDict:c,needSimulate:Object.values(i),needTickArray:Object.values(s),cpmmPoolList:Object.values(u)}}async fetchSwapRoutesData({routes:e,inputMint:t,outputMint:n}){let o=new Set([...e.needTickArray.map(y=>[y.mintA.toBase58(),y.mintB.toBase58()]).flat(),t.toString(),n.toString()]);console.log("fetching amm pools info, total: ",e.needSimulate.length);let r=await this.scope.liquidity.getRpcPoolInfos(e.needSimulate.map(y=>y.id)),i=br(r),s={};Object.values(i).forEach(y=>{o.delete(y.mintA.address),s[y.mintA.address]={address:new no(y.mintA.address),programId:Qe,mintAuthority:null,supply:BigInt(0),decimals:y.mintA.decimals,isInitialized:!0,freezeAuthority:null,tlvData:Buffer.from("0","hex"),feeConfig:void 0},o.delete(y.mintB.address),s[y.mintB.address]={address:new no(y.mintB.address),programId:Qe,mintAuthority:null,supply:BigInt(0),decimals:y.mintB.decimals,isInitialized:!0,freezeAuthority:null,tlvData:Buffer.from("0","hex"),feeConfig:void 0}}),console.log("fetching cpmm pools info, total: ",e.cpmmPoolList.length);let u=await this.scope.cpmm.getRpcPoolInfos(e.cpmmPoolList.map(y=>y.id.toBase58()),!0);Object.values(u).forEach(y=>{let[b,g]=[y.mintA.toBase58(),y.mintB.toBase58()];y.mintProgramA.equals(Qe)?(o.delete(b),s[b]={address:y.mintA,programId:y.mintProgramA,mintAuthority:null,supply:BigInt(0),decimals:y.mintDecimalA,isInitialized:!0,freezeAuthority:null,tlvData:Buffer.from("0","hex"),feeConfig:void 0}):o.add(b),y.mintProgramB.equals(Qe)?(o.delete(g),s[g]={address:y.mintB,programId:y.mintProgramB,mintAuthority:null,supply:BigInt(0),decimals:y.mintDecimalB,isInitialized:!0,freezeAuthority:null,tlvData:Buffer.from("0","hex"),feeConfig:void 0}):o.add(g)}),console.log("fetching mints info, total: ",o.size);let a=await ao({connection:this.scope.connection,mints:Array.from(o).map(y=>new no(y))});s=v(v({},s),a);let c=this.scope.cpmm.toComputePoolInfos({pools:u,mintInfos:s});console.log("fetching clmm pools info, total:",e.needTickArray.length);let l=await this.scope.clmm.getRpcClmmPoolInfos({poolIds:e.needTickArray.map(y=>y.id)}),{computeClmmPoolInfo:d,computePoolTickData:p}=await this.scope.clmm.getComputeClmmPoolInfos({clmmPoolsRpcInfo:l,mintInfos:s}),f=Object.keys(e.routePathDict).reduce((y,b)=>W(v({},y),{[b]:W(v({},e.routePathDict[b]),{mintProgram:s[b].programId,mDecimals:s[b].decimals,in:e.routePathDict[b].in.map(g=>i[g.id.toBase58()]||d[g.id.toBase58()]||c[g.id.toBase58()]),out:e.routePathDict[b].out.map(g=>i[g.id.toBase58()]||d[g.id.toBase58()]||c[g.id.toBase58()])})}),{});return{mintInfos:s,ammPoolsRpcInfo:r,ammSimulateCache:i,clmmPoolsRpcInfo:l,computeClmmPoolInfo:d,computePoolTickData:p,computeCpmmData:c,routePathDict:f}}getAllRouteComputeAmountOut({inputTokenAmount:e,outputToken:t,directPath:n,routePathDict:o,simulateCache:r,tickCache:i,slippage:s,chainTime:u,epochInfo:a,feeConfig:c}){var g,A,h,T,k,w,S,B,K;let l=c===void 0?new Rr(0):e.raw.mul(new Rr(c.feeBps.toNumber())).div(new Rr(1e4)),d=e.raw.sub(l),p=new Ie(e.token,d),f=c===void 0?void 0:{feeAmount:l,feeAccount:c.feeAccount},y=W(v({},t),{address:ut(t.address).toString()}),b=[];for(let I of n)try{b.push(W(v({},this.computeAmountOut({itemPool:I,tickCache:i,simulateCache:r,chainTime:u,epochInfo:a,slippage:s,outputToken:y,amountIn:p})),{feeConfig:f}))}catch(C){this.logDebug("direct error",I.version,I.id.toString(),C.message)}this.logDebug("direct done");for(let[I,C]of Object.entries(o)){let O={chainId:101,address:I,programId:C.mintProgram.toBase58(),logoURI:"",symbol:"",name:"",decimals:C.mDecimals,tags:[],extensions:{}},M=C.in.map(L=>{try{return{pool:L,data:this.computeAmountOut({itemPool:L,tickCache:i,simulateCache:r,chainTime:u,epochInfo:a,slippage:s,outputToken:O,amountIn:p})}}catch(_){this.logDebug("route in error",L.version,L.id.toString(),_.message);return}}).sort((L,_)=>{var se,ce,ne,le;let G=L===void 0?An:L.data.amountOut.amount.raw.sub((ce=(se=L.data.amountOut.fee)==null?void 0:se.raw)!=null?ce:An),Q=_===void 0?An:_.data.amountOut.amount.raw.sub((le=(ne=_.data.amountOut.fee)==null?void 0:ne.raw)!=null?le:An);return G.lt(Q)?1:-1})[0];if(M===void 0)continue;let R=new Ie(mr(O),M.data.amountOut.amount.raw.sub((A=(g=M.data.amountOut.fee)==null?void 0:g.raw)!=null?A:An));for(let L of C.out)try{let _=this.computeAmountOut({itemPool:L,tickCache:i,simulateCache:r,chainTime:u,epochInfo:a,slippage:s,outputToken:y,amountIn:R});b.push(W(v({},_),{allTrade:!!(M.data.allTrade&&_.allTrade),amountIn:M.data.amountIn,amountOut:_.amountOut,minAmountOut:_.minAmountOut,currentPrice:void 0,executionPrice:new wi(new gt({baseToken:M.data.amountIn.amount.token,denominator:M.data.amountIn.amount.raw,quoteToken:_.amountOut.amount.token,numerator:_.amountOut.amount.raw.sub((T=(h=_.amountOut.fee)==null?void 0:h.raw)!=null?T:An)}).toFixed()),priceImpact:new wi(M.data.priceImpact.add(_.priceImpact).toFixed()),fee:[M.data.fee[0],_.fee[0]],routeType:"route",poolInfoList:[M.pool,L],remainingAccounts:[M.data.remainingAccounts[0],_.remainingAccounts[0]],minMiddleAmountFee:(k=_.amountOut.fee)!=null&&k.raw?new Ie(M.data.amountOut.amount.token,((S=(w=M.data.amountOut.fee)==null?void 0:w.raw)!=null?S:An).add((K=(B=_.amountOut.fee)==null?void 0:B.raw)!=null?K:An)):void 0,middleToken:M.data.amountOut.amount.token,poolReady:M.data.poolReady&&_.poolReady,poolType:[M.data.poolType,_.poolType],feeConfig:f,expirationTime:Qt(M.data.expirationTime,_.expirationTime)}))}catch(_){this.logDebug("route out error",L.version,L.id.toString(),_.message)}}return b.filter(I=>(I.allTrade||this.logDebug(`pool ${I.poolInfoList.map(C=>C.id.toString()).join(",")} filter out since not all trade`),I.allTrade)).sort((I,C)=>I.amountOut.amount.raw.sub(C.amountOut.amount.raw).gt(An)?-1:1)}computeAmountOut({itemPool:e,tickCache:t,simulateCache:n,chainTime:o,epochInfo:r,slippage:i,outputToken:s,amountIn:u}){if(e.version===6){let{allTrade:a,realAmountIn:c,amountOut:l,minAmountOut:d,expirationTime:p,currentPrice:f,executionPrice:y,priceImpact:b,fee:g,remainingAccounts:A,executionPriceX64:h}=Re.computeAmountOutFormat({poolInfo:e,tickArrayCache:t[e.id.toString()],amountIn:u.raw,tokenOut:s,slippage:i,epochInfo:r,catchLiquidityInsufficient:!0});return{allTrade:a,amountIn:c,amountOut:l,minAmountOut:d,currentPrice:new wi(f.toFixed()),executionPrice:new wi(y.toFixed()),priceImpact:new wi(b.toFixed()),fee:[g],remainingAccounts:[A],routeType:"amm",poolInfoList:[e],poolReady:e.startTime<o,poolType:"CLMM",slippage:i,clmmExPriceX64:[h],expirationTime:Qt(c.expirationTime,p)}}else if(e.version===7){let{allTrade:a,executionPrice:c,amountOut:l,minAmountOut:d,priceImpact:p,fee:f}=this.scope.cpmm.computeSwapAmount({pool:e,outputMint:s.address,amountIn:u.raw,slippage:i});return{allTrade:a,amountIn:{amount:u,fee:void 0,expirationTime:void 0},amountOut:{amount:si(W(v({},s),{amount:l})),fee:void 0,expirationTime:void 0},minAmountOut:{amount:si(W(v({},s),{amount:d})),fee:void 0,expirationTime:void 0},currentPrice:e.poolPrice,executionPrice:c,priceImpact:p,fee:[new Ie(u.token,f)],remainingAccounts:[],routeType:"amm",poolInfoList:[e],poolReady:e.openTime.toNumber()<o,poolType:"CPMM",slippage:i,clmmExPriceX64:[void 0],expirationTime:void 0}}else{if(![1,6,7].includes(n[e.id.toString()].status))throw Error("swap error");let{amountOut:a,minAmountOut:c,currentPrice:l,executionPrice:d,priceImpact:p,fee:f}=this.scope.liquidity.computeAmountOut({poolInfo:n[e.id.toString()],amountIn:u.raw,mintIn:u.token.mint,mintOut:s.address,slippage:i});return{amountIn:{amount:u,fee:void 0,expirationTime:void 0},amountOut:{amount:si(W(v({},s),{amount:a})),fee:void 0,expirationTime:void 0},minAmountOut:{amount:si(W(v({},s),{amount:c})),fee:void 0,expirationTime:void 0},currentPrice:l,executionPrice:d,priceImpact:p,fee:[new Ie(u.token,f)],routeType:"amm",poolInfoList:[e],remainingAccounts:[],poolReady:Number(n[e.id].openTime)<o,poolType:e.version===5?"STABLE":void 0,expirationTime:void 0,allTrade:!0,slippage:i,clmmExPriceX64:[void 0]}}}async computePoolToPoolKeys({pools:e,clmmRpcData:t={},ammRpcData:n={}}){let o=new Set(e.filter(a=>a.version===6&&!t[a.id.toString()]).map(a=>a.id.toString()));if(o.size>0){let a=await this.scope.clmm.getRpcClmmPoolInfos({poolIds:Array.from(o)});Object.keys(a).forEach(c=>{t[c]=a[c]})}let r=new Set(e.filter(a=>a.version===4&&!n[a.id.toString()]).map(a=>a.id.toString()));if(r.size>0){let a=await this.scope.liquidity.getRpcPoolInfos(Array.from(r));Object.keys(a).forEach(c=>{n[c]=a[c]})}let i=new Set(e.filter(a=>a.version===4).map(a=>a.marketId)),s={};i.size>0&&(await Ce(this.scope.connection,Array.from(i).map(c=>({pubkey:new no(c)})))).forEach(c=>{if(!c.accountInfo)return;let l=aa.decode(c.accountInfo.data);s[c.pubkey.toBase58()]={marketId:c.pubkey.toString(),marketProgramId:c.accountInfo.owner.toString(),marketAuthority:Kr.getAssociatedAuthority({programId:c.accountInfo.owner,marketId:c.pubkey}).publicKey.toString(),marketBaseVault:l.baseVault.toString(),marketQuoteVault:l.quoteVault.toString(),marketBids:l.bids.toString(),marketAsks:l.asks.toString(),marketEventQueue:l.eventQueue.toString()}});let u=[];return e.forEach(a=>{if(a.version===6){let c=t[a.id.toString()],l={programId:a.programId.toBase58(),id:a.id.toBase58(),mintA:a.mintA,mintB:a.mintB,openTime:String(a.startTime),vault:{A:c.vaultA.toBase58(),B:c.vaultB.toBase58()},config:W(v({},a.ammConfig),{id:a.ammConfig.id.toString(),defaultRange:0,defaultRangePoint:[]}),rewardInfos:[],observationId:a.observationId.toBase58(),exBitmapAccount:a.exBitmapAccount.toBase58()};u.push(l)}else if(a.version===4){let c=n[a.id.toString()],l=v({programId:a.programId,id:a.id,mintA:a.mintA,mintB:a.mintB,openTime:String(a.openTime),vault:{A:c.baseVault.toBase58(),B:c.quoteVault.toBase58()},authority:ea({programId:new no(a.programId)}).publicKey.toString(),openOrders:c.openOrders.toBase58(),targetOrders:c.targetOrders.toBase58(),mintLp:a.lpMint},s[a.marketId]);u.push(l)}else a.version===7&&u.push({observationId:a.observationId.toBase58(),programId:a.programId.toBase58(),id:a.id.toBase58(),mintA:a.mintA,mintB:a.mintB,openTime:String(a.openTime),authority:ko(a.programId).publicKey.toBase58(),vault:{A:a.vaultA.toBase58(),B:a.vaultB.toBase58()},mintLp:dt({address:a.mintLp.toBase58(),programId:Qe.toBase58(),decimals:a.lpDecimals}),config:W(v({id:a.configId.toBase58()},a.configInfo),{protocolFeeRate:a.configInfo.protocolFeeRate.toNumber(),tradeFeeRate:a.configInfo.tradeFeeRate.toNumber(),fundFeeRate:a.configInfo.fundFeeRate.toNumber(),createPoolFee:a.configInfo.createPoolFee.toString()})})}),u}};import{PublicKey as Zd,Transaction as ua,TransactionInstruction as $d}from"@solana/web3.js";import{TOKEN_PROGRAM_ID as Jd}from"@solana/spl-token";import Ec from"bn.js";var pt=class extends Ne{static getPdaPoolId(e,t){return ae([pt.SEED_CONFIG.pool.id,t.toBuffer()],e)}static getPdaOwnerId(e,t,n,o){return ae([pt.SEED_CONFIG.owner.id,t.toBuffer(),n.toBuffer(),Buffer.from(new Ec(o).toArray())],e)}static async getAllInfo({connection:e,programId:t,poolIds:n,wallet:o,chainTime:r}){if(n.length===0)return[];let i=n.map(c=>pt.getPdaPoolId(t,c).publicKey),s=[];for(let c=0;c<pt.VERSION_PROJECT.length;c++)s.push(...i.map(l=>pt.getPdaOwnerId(t,l,o,c).publicKey));let u=await Gt(e,[...i,...s]),a=[];for(let c=0;c<u.length;c++){let l=Math.floor(c/n.length),d=c%n.length,p=i[d],f=s[c],y=u[d],b=u[n.length+c];if(!(y&&b)||y.data.length!==pt.POOL_LAYOUT.span||b.data.length!==pt.OWNER_LAYOUT.span)continue;let g=pt.POOL_LAYOUT.decode(y.data),A=pt.OWNER_LAYOUT.decode(b.data),h=g.openTime.toNumber(),T=g.endTime.toNumber(),k=A.tokenInfo.map(B=>B.debtAmount.gt(new Ec(0))).filter(B=>!B).length!==3,w=r>h&&r<T&&g.status===1,S=k&&w;a.push({programId:t,poolId:p,ammId:g.ammId,ownerAccountId:f,snapshotLpAmount:A.lpAmount,project:pt.VERSION_PROJECT[l],openTime:h,endTime:T,canClaim:S,canClaimErrorType:k?w?void 0:"outOfOperationalTime":"alreadyClaimIt",tokenInfo:g.tokenInfo.map((B,K)=>({mintAddress:B.mintAddress,mintVault:B.mintVault,mintDecimals:B.mintDecimals,perLpLoss:B.perLpLoss,debtAmount:A.tokenInfo[K].debtAmount.add(A.tokenInfo[K].claimedAmount)}))})}return a}async makeClaimTransaction({poolInfo:e,ownerInfo:t,feePayer:n}){t.wallet||this.scope.checkOwner();let o=this.createTxBuilder(n),r=t.wallet||this.scope.ownerPubKey,i=[];for(let a of e.tokenInfo){let{account:c,instructionParams:l}=await this.scope.account.getOrCreateTokenAccount({mint:a.mintAddress,owner:this.scope.ownerPubKey,notUseTokenAccount:a.mintAddress.equals(Ve.WSOL.mint),createInfo:{payer:r,amount:0},skipCloseAccount:!a.mintAddress.equals(Ve.WSOL.mint),associatedOnly:a.mintAddress.equals(Ve.WSOL.mint)?!1:t.associatedOnly});l&&o.addInstruction(l),i.push(c)}o.addInstruction({instructions:[pt.makeClaimInstruction({programId:e.programId,poolInfo:e,ownerInfo:{wallet:r,ownerPda:e.ownerAccountId,claimAddress:i}})]});let{transaction:s,signers:u}=o.build();return[{transaction:s,signer:u}]}async makeClaimAllTransaction({poolInfos:e,ownerInfo:t,feePayer:n}){let o=this.createTxBuilder(n),r=t.wallet||this.scope.ownerPubKey,i={};for(let c of e){let l=[];for(let d of c.tokenInfo){let{account:p,instructionParams:f}=await this.scope.account.getOrCreateTokenAccount({mint:d.mintAddress,owner:this.scope.ownerPubKey,notUseTokenAccount:d.mintAddress.equals(Ve.WSOL.mint),createInfo:{payer:r,amount:0},skipCloseAccount:!d.mintAddress.equals(Ve.WSOL.mint),associatedOnly:d.mintAddress.equals(Ve.WSOL.mint)?!1:t.associatedOnly});f&&o.addInstruction(f),p&&(i[d.mintAddress.toString()]=p,l.push(p))}o.addInstruction({instructions:[pt.makeClaimInstruction({programId:c.programId,poolInfo:c,ownerInfo:{wallet:r,ownerPda:c.ownerAccountId,claimAddress:l}})]})}let{transaction:s,signers:u}=o.build(),a=o.allInstructions;return os(a,[r,...u.map(c=>c.publicKey)])?[{transaction:s,signer:u}]:[{transaction:new ua().add(...a.slice(0,o.AllTxData.instructions.length-1)),signer:u},{transaction:new ua().add(...a.slice(o.AllTxData.instructions.length-1)),signer:[]},{transaction:new ua().add(...o.AllTxData.endInstructions),signer:[]}]}static makeClaimInstruction({programId:e,poolInfo:t,ownerInfo:n}){let o=F([]),r=[{pubkey:n.wallet,isSigner:!0,isWritable:!0},{pubkey:t.poolId,isSigner:!1,isWritable:!0},{pubkey:n.ownerPda,isSigner:!1,isWritable:!0},...n.claimAddress.map(u=>({pubkey:u,isSigner:!1,isWritable:!0})),...t.tokenInfo.map(({mintVault:u})=>({pubkey:u,isSigner:!1,isWritable:!0})),{pubkey:Jd,isSigner:!1,isWritable:!1}],i=Buffer.alloc(o.span);o.encode({},i);let s=Buffer.from([10,66,208,184,161,6,191,98,...i]);return new $d({keys:r,programId:e,data:s})}},Vt=pt;Vt.CLAIMED_NUM=3,Vt.POOL_LAYOUT=F([ke(8),D("bump"),D("status"),P("openTime"),P("endTime"),N("ammId"),j(F([D("mintDecimals"),N("mintAddress"),N("mintVault"),P("perLpLoss"),P("totalClaimedAmount")]),pt.CLAIMED_NUM,"tokenInfo"),j(P(),10,"padding")]),Vt.OWNER_LAYOUT=F([ke(8),D("bump"),D("version"),N("poolId"),N("owner"),P("lpAmount"),j(F([N("mintAddress"),P("debtAmount"),P("claimedAmount")]),pt.CLAIMED_NUM,"tokenInfo"),j(P(),4,"padding")]),Vt.DEFAULT_POOL_ID=["58oQChx4yWmvKdwLLZzBi4ChoCc2fqCUWBkwMihLYQo2","6UmmUiYoBjSrhakAobJw8BvkmJtDVxaeBtbt7rxWo1mg","AVs9TA4nWDzfPJE9gGVNJMVhcQy3V9PGazuz33BfG2RA","DVa7Qmb5ct9RCpaU7UTpSaf3GVMYz17vNVU67XpdCRut","7XawhbbxtsRcQA8KTkHT9f9nc6d69UwqCDh6U5EEbEmX","6a1CsrpeZubDjEJE9s1CMVheB6HWM5d7m1cj2jkhyXhj","EoNrn8iUhwgJySD1pHu8Qxm5gSQqLK3za4m8xzD2RuEb","AceAyRTWt4PyB2pHqf2qhDgNZDtKVNaxgL8Ru3V4aN1P","6tmFJbMk5yVHFcFy7X2K8RwHjKLr6KVFLYXpgpBNeAxB"].map(e=>new Zd(e)),Vt.SEED_CONFIG={pool:{id:Buffer.from("pool_seed","utf8")},owner:{id:Buffer.from("user_claim_seed","utf8")}},Vt.VERSION_PROJECT=[void 0,"Francium","Tulip","Larix"];import{PublicKey as Ti}from"@solana/web3.js";import qc from"bn.js";import{SYSVAR_CLOCK_PUBKEY as tp,TransactionInstruction as Dc}from"@solana/web3.js";import{TOKEN_PROGRAM_ID as Wc}from"@solana/spl-token";var ep=F([D("instruction"),du("amount")]),hi=F([D("instruction")]);function Lr({programId:m},e){let t=[{pubkey:Wc,isSigner:!1,isWritable:!1},{pubkey:Ea,isSigner:!1,isWritable:!1},...Object.entries(e).map(([o,r])=>({pubkey:r,isSigner:o==="userOwner",isWritable:!["authority","userOwner"].includes(o)}))],n=Buffer.alloc(hi.span);return hi.encode({instruction:2},n),new Dc({keys:t,programId:m,data:n})}function ca(m){let{poolConfig:e,userKeys:t,side:n}=m,o=n==="base"?t.baseTokenAccount:t.quoteTokenAccount,r=n==="base"?e.baseVault:e.quoteVault,i=Buffer.alloc(hi.span);hi.encode({instruction:2},i);let s=[{pubkey:Wc,isWritable:!1,isSigner:!1},{pubkey:tp,isWritable:!1,isSigner:!1},{pubkey:e.id,isWritable:!0,isSigner:!1},{pubkey:e.authority,isWritable:!1,isSigner:!1},{pubkey:r,isWritable:!0,isSigner:!1},{pubkey:o,isWritable:!0,isSigner:!1},{pubkey:t.ledgerAccount,isWritable:!0,isSigner:!1},{pubkey:t.owner,isWritable:!1,isSigner:!0}];return new Dc({programId:e.programId,keys:s,data:i})}var np={[Vo.IDO_PROGRAM_ID_V1.toString()]:1,[Vo.IDO_PROGRAM_ID_V2.toString()]:2,[Vo.IDO_PROGRAM_ID_V3.toString()]:3,[Vo.IDO_PROGRAM_ID_V4.toString()]:4},ho=class extends Ne{async claim({ownerInfo:e,idoKeys:t,associatedOnly:n=!0,checkCreateATAOwner:o=!1,txVersion:r,feePayer:i}){let s=this.createTxBuilder(i),u=np[t.programId];u||this.logAndCreateError("invalid version",u);let a=rt(t),[c,l]=[!new qc(e.coin).isZero(),!new qc(e.pc).isZero()],d=a.projectInfo.mint.address.equals(Y),{account:p,instructionParams:f}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:a.projectInfo.mint.programId,mint:a.projectInfo.mint.address,owner:this.scope.ownerPubKey,createInfo:{payer:this.scope.ownerPubKey,amount:0},skipCloseAccount:!d,notUseTokenAccount:d,associatedOnly:d?!1:n,checkCreateATAOwner:o});!p&&c&&this.logAndCreateError("target token accounts not found","mint",t.projectInfo.mint.address),c&&f&&s.addInstruction(f);let y=a.buyInfo.mint.address.equals(Y),{account:b,instructionParams:g}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:a.buyInfo.mint.programId,mint:a.buyInfo.mint.address,owner:this.scope.ownerPubKey,createInfo:{payer:this.scope.ownerPubKey,amount:0},skipCloseAccount:!y,notUseTokenAccount:y,associatedOnly:y?!1:n,checkCreateATAOwner:o});if(!p&&l&&this.logAndCreateError("target token accounts not found","mint",t.projectInfo.mint.address),l&&g&&s.addInstruction(g),(!p||!b)&&this.logAndCreateError("target token accounts not found","mint",t.projectInfo.mint.address,t.buyInfo.mint.address),u===3)return s.addInstruction({instructions:[...c?[Lr({programId:a.programId},{idoId:a.id,authority:a.authority,poolTokenAccount:a.projectInfo.vault,userTokenAccount:p,userIdoInfo:new Ti(e.userIdoInfo),userOwner:this.scope.ownerPubKey})]:[],...l?[Lr({programId:new Ti(t.programId)},{idoId:a.id,authority:a.authority,poolTokenAccount:a.buyInfo.vault,userTokenAccount:b,userIdoInfo:new Ti(e.userIdoInfo),userOwner:this.scope.ownerPubKey})]:[]]}).versionBuild({txVersion:r});if(u<3)return!c&&!l&&this.logAndCreateError("no claimable rewards"),s.addInstruction({instructions:[Lr({programId:a.programId},{idoId:a.id,authority:a.authority,poolQuoteTokenAccount:a.buyInfo.vault,poolBaseTokenAccount:a.projectInfo.vault,userQuoteTokenAccount:b,userBaseTokenAccount:p,userIdoInfo:new Ti(e.userIdoInfo),userOwner:this.scope.ownerPubKey})]}).versionBuild({txVersion:r});let A={poolConfig:{id:a.id,programId:a.programId,authority:a.authority,baseVault:a.projectInfo.vault,quoteVault:a.buyInfo.vault,baseToken:t.projectInfo.mint,quoteToken:t.buyInfo.mint},userKeys:{baseTokenAccount:p,quoteTokenAccount:b,ledgerAccount:new Ti(e.userIdoInfo),owner:this.scope.ownerPubKey}};return s.addInstruction({instructions:[...c?[ca(W(v({},A),{side:"base"}))]:[],...l?[ca(W(v({},A),{side:"quote"}))]:[]]}).versionBuild({txVersion:r})}};var op=Buffer.from("vault_auth_seed","utf8"),rK=Buffer.from("global_config","utf8"),ip=Buffer.from("pool_vesting","utf8"),rp=Buffer.from("platform_config","utf8"),sp=Buffer.from("platform_fee_vault_auth_seed","utf8"),ap=Buffer.from("creator_fee_vault_auth_seed","utf8");function an(m){return ae([op],m)}function To(m,e,t){return ae([vs,e.toBuffer(),t.toBuffer()],m)}function la(m,e,t){return ae([_s,e.toBuffer(),t.toBuffer()],m)}function Io(m){return ae([Buffer.from("__event_authority","utf8")],m)}function ma(m,e){return ae([rp,e.toBuffer()],m)}function Ii(m,e,t){return ae([ip,e.toBuffer(),t.toBuffer()],m)}function Bo(m,e,t){return ae([e.toBuffer(),t.toBuffer()],m)}function da(m){return ae([sp],m)}function Bi(m,e,t){return ae([e.toBuffer(),t.toBuffer()],m)}function Uc(m){return ae([ap],m)}import{SystemProgram as Zt,TransactionInstruction as Et}from"@solana/web3.js";import{ASSOCIATED_TOKEN_PROGRAM_ID as Or,TOKEN_2022_PROGRAM_ID as up,TOKEN_PROGRAM_ID as pa}from"@solana/spl-token";import Nr from"bn.js";var Dt={initialize:Buffer.from([175,175,109,31,13,152,155,237]),buyExactIn:Buffer.from([250,234,13,123,213,156,19,236]),buyExactOut:Buffer.from([24,211,116,40,105,3,153,56]),sellExactIn:Buffer.from([149,39,222,155,211,124,152,26]),sellExactOut:Buffer.from([95,200,71,34,8,9,11,166]),createVestingAccount:Buffer.from([129,178,2,13,217,172,230,218]),claimVestedToken:Buffer.from([49,33,104,30,189,157,79,35]),createPlatformConfig:Buffer.from([176,90,196,175,253,113,220,20]),claimPlatformFee:Buffer.from([156,39,208,135,76,237,61,72]),updatePlaformConfig:Buffer.from([195,60,76,129,146,45,67,143]),initializeWithToken2022:Buffer.from([37,190,126,222,44,154,171,17]),claimPlatformFeeFromVault:Buffer.from([117,241,198,168,248,218,80,29]),claimCreatorFee:Buffer.from([26,97,138,203,132,171,141,252])};function Gc(m,e,t,n,o,r,i,s,u,a,c,l,d,p,f,y,b,g,A,h){let T=F([D("decimals"),Pt("name"),Pt("symbol"),Pt("uri")]),k=F([P("totalLockedAmount"),P("cliffPeriod"),P("unlockPeriod")]),w=F([D("index"),P("supply"),P("totalFundRaisingB"),D("migrateType")]),S=F([D("index"),P("supply"),P("totalSellA"),P("totalFundRaisingB"),D("migrateType")]),B=[{pubkey:e,isSigner:!0,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!1,isWritable:!1},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!0,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!1},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:pa,isSigner:!1,isWritable:!1},{pubkey:pa,isSigner:!1,isWritable:!1},{pubkey:Xt,isSigner:!1,isWritable:!1},{pubkey:Zt.programId,isSigner:!1,isWritable:!1},{pubkey:it,isSigner:!1,isWritable:!1},{pubkey:Io(m).publicKey,isSigner:!1,isWritable:!1},{pubkey:m,isSigner:!1,isWritable:!1}],K=Buffer.alloc(Buffer.from(p,"utf-8").length+Buffer.from(f,"utf-8").length+Buffer.from(y,"utf-8").length+4*3+1),I=Buffer.alloc(k.span),C=Buffer.alloc(b.type==="ConstantCurve"?S.span:w.span);return T.encode({decimals:d,name:p,symbol:f,uri:y},K),b.type==="ConstantCurve"?S.encode(W(v({index:0},b),{migrateType:b.migrateType==="amm"?0:1}),C):b.type==="FixedCurve"?w.encode(W(v({index:1},b),{migrateType:b.migrateType==="amm"?0:1}),C):b.type==="LinearCurve"&&w.encode(W(v({index:2},b),{migrateType:b.migrateType==="amm"?0:1}),C),k.encode({totalLockedAmount:g,cliffPeriod:A,unlockPeriod:h},I),new Et({keys:B,programId:m,data:Buffer.from([...Dt.initialize,...K,...C,...I])})}function Xc(m,e,t,n,o,r,i,s,u,a,c,l,d,p,f,y,b,g,A,h){let T=F([D("decimals"),Pt("name"),Pt("symbol"),Pt("uri")]),k=F([P("totalLockedAmount"),P("cliffPeriod"),P("unlockPeriod"),D("transferFeeExtensionParamsOption"),F([Tt("transferFeeBasePoints"),P("maxinumFee")]).replicate("transferFeeExtensionParams")]),w=F([D("index"),P("supply"),P("totalFundRaisingB"),D("migrateType")]),S=F([D("index"),P("supply"),P("totalSellA"),P("totalFundRaisingB"),D("migrateType")]),B=[{pubkey:e,isSigner:!0,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!1,isWritable:!1},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!0,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!1},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:up,isSigner:!1,isWritable:!1},{pubkey:pa,isSigner:!1,isWritable:!1},{pubkey:Zt.programId,isSigner:!1,isWritable:!1},{pubkey:Io(m).publicKey,isSigner:!1,isWritable:!1},{pubkey:m,isSigner:!1,isWritable:!1}],K=Buffer.alloc(Buffer.from(d,"utf-8").length+Buffer.from(p,"utf-8").length+Buffer.from(f,"utf-8").length+4*3+1),I=Buffer.alloc(k.span),C=Buffer.alloc(y.type==="ConstantCurve"?S.span:w.span);return T.encode({decimals:l,name:d,symbol:p,uri:f},K),y.type==="ConstantCurve"?S.encode(W(v({index:0},y),{migrateType:y.migrateType==="amm"?0:1}),C):y.type==="FixedCurve"?w.encode(W(v({index:1},y),{migrateType:y.migrateType==="amm"?0:1}),C):y.type==="LinearCurve"&&w.encode(W(v({index:2},y),{migrateType:y.migrateType==="amm"?0:1}),C),k.encode({totalLockedAmount:b,cliffPeriod:g,unlockPeriod:A,transferFeeExtensionParamsOption:h?1:0,transferFeeExtensionParams:h!=null?h:{transferFeeBasePoints:0,maxinumFee:new Nr(0)}},I),new Et({keys:B,programId:m,data:Buffer.from([...Dt.initializeWithToken2022,...K,...C,...I])})}function zc(m,e,t,n,o,r,i,s,u,a,c,l,d,p,f,y,b,g,A,h){let T=F([P("amountA"),P("maxAmountB"),P("shareFeeRate")]),k=[{pubkey:e,isSigner:!0,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!1},{pubkey:l,isSigner:!1,isWritable:!1},{pubkey:d,isSigner:!1,isWritable:!1},{pubkey:p,isSigner:!1,isWritable:!1},{pubkey:Io(m).publicKey,isSigner:!1,isWritable:!1},{pubkey:m,isSigner:!1,isWritable:!1}];h&&k.push({pubkey:h,isSigner:!1,isWritable:!0}),k.push({pubkey:Zt.programId,isSigner:!1,isWritable:!1}),k.push({pubkey:f,isSigner:!1,isWritable:!0}),k.push({pubkey:y,isSigner:!1,isWritable:!0});let w=Buffer.alloc(T.span);return T.encode({amountA:b,maxAmountB:g,shareFeeRate:A!=null?A:new Nr(0)},w),new Et({keys:k,programId:m,data:Buffer.from([...Dt.buyExactOut,...w])})}function Qc(m,e,t,n,o,r,i,s,u,a,c,l,d,p,f,y,b,g,A,h){let T=F([P("amountA"),P("minAmountB"),P("shareFeeRate")]),k=[{pubkey:e,isSigner:!0,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!1},{pubkey:l,isSigner:!1,isWritable:!1},{pubkey:d,isSigner:!1,isWritable:!1},{pubkey:p,isSigner:!1,isWritable:!1},{pubkey:Io(m).publicKey,isSigner:!1,isWritable:!1},{pubkey:m,isSigner:!1,isWritable:!1}];h&&k.push({pubkey:h,isSigner:!1,isWritable:!0}),k.push({pubkey:Zt.programId,isSigner:!1,isWritable:!1}),k.push({pubkey:f,isSigner:!1,isWritable:!0}),k.push({pubkey:y,isSigner:!1,isWritable:!0});let w=Buffer.alloc(T.span);return T.encode({amountA:b,minAmountB:g,shareFeeRate:A!=null?A:new Nr(0)},w),new Et({keys:k,programId:m,data:Buffer.from([...Dt.sellExactIn,...w])})}function jc(m,e,t,n,o,r,i,s,u,a,c,l,d,p,f,y,b,g,A,h){let T=F([P("amountB"),P("maxAmountA"),P("shareFeeRate")]),k=[{pubkey:e,isSigner:!0,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!1},{pubkey:l,isSigner:!1,isWritable:!1},{pubkey:d,isSigner:!1,isWritable:!1},{pubkey:p,isSigner:!1,isWritable:!1},{pubkey:Io(m).publicKey,isSigner:!1,isWritable:!1},{pubkey:m,isSigner:!1,isWritable:!1}];h&&k.push({pubkey:h,isSigner:!1,isWritable:!0}),k.push({pubkey:Zt.programId,isSigner:!1,isWritable:!1}),k.push({pubkey:f,isSigner:!1,isWritable:!0}),k.push({pubkey:y,isSigner:!1,isWritable:!0});let w=Buffer.alloc(T.span);return T.encode({amountB:b,maxAmountA:g,shareFeeRate:A!=null?A:new Nr(0)},w),new Et({keys:k,programId:m,data:Buffer.from([...Dt.sellExactOut,...w])})}function fa(m,e,t,n,o,r,i,s,u){let a=F([]),c=[{pubkey:e,isSigner:!0,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!1},{pubkey:u,isSigner:!1,isWritable:!1},{pubkey:Zt.programId,isSigner:!1,isWritable:!1},{pubkey:Or,isSigner:!1,isWritable:!1}],l=Buffer.alloc(a.span);return a.encode({},l),new Et({keys:c,programId:m,data:Buffer.from([...Dt.claimVestedToken,...l])})}function ya(m,e,t,n,o,r){let i=F([P("shareAmount")]),s=[{pubkey:e,isSigner:!0,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:Zt.programId,isSigner:!1,isWritable:!1}],u=Buffer.alloc(i.span);return i.encode({shareAmount:r},u),new Et({keys:s,programId:m,data:Buffer.from([...Dt.createVestingAccount,...u])})}function ba(m,e,t,n,o,r,i,s,u){let a=[{pubkey:e,isSigner:!0,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:Zt.programId,isSigner:!1,isWritable:!0},{pubkey:Or,isSigner:!1,isWritable:!0}];return new Et({keys:a,programId:m,data:Dt.claimPlatformFee})}function Yc(m,e,t,n,o,r,i,s,u,a,c,l,d){let p=F([P("platformScale"),P("creatorScale"),P("burnScale"),P("feeRate"),Pt("name"),Pt("web"),Pt("img"),P("creatorFeeRate")]),f=[{pubkey:e,isSigner:!0,isWritable:!0},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:Zt.programId,isSigner:!1,isWritable:!1},{pubkey:i,isSigner:!1,isWritable:!1}],y=Buffer.alloc(8*5+Buffer.from(c,"utf-8").length+Buffer.from(l,"utf-8").length+Buffer.from(d,"utf-8").length+4*3);return p.encode({platformScale:s.platformScale,creatorScale:s.creatorScale,burnScale:s.burnScale,feeRate:u,name:c,web:l,img:d,creatorFeeRate:a},y),new Et({keys:f,programId:m,data:Buffer.from([...Dt.createPlatformConfig,...y])})}function Hc(m,e,t,n){let o=[{pubkey:e,isSigner:!0,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!0}],r;if(n.type==="updateClaimFeeWallet"){let i=F([D("index"),N("value")]);r=Buffer.alloc(i.span),i.encode({index:0,value:n.value},r)}else if(n.type==="updateLockNftWallet"){let i=F([D("index"),N("value")]);r=Buffer.alloc(i.span),i.encode({index:1,value:n.value},r)}else if(n.type==="migrateCpLockNftScale"){let i=F([D("index"),P("platformScale"),P("creatorScale"),P("burnScale")]);r=Buffer.alloc(i.span),i.encode(v({index:2},n.value),r)}else if(n.type==="updateFeeRate"){let i=F([D("index"),P("value")]);r=Buffer.alloc(i.span),i.encode({index:3,value:n.value},r)}else if(n.type==="updateImg"||n.type==="updateName"||n.type==="updateWeb"){let i=F([D("index"),Pt("value")]);r=Buffer.alloc(Buffer.from(n.value,"utf-8").length+4+1*1),n.type==="updateName"?i.encode({index:4,value:n.value},r):n.type==="updateWeb"?i.encode({index:5,value:n.value},r):n.type==="updateImg"&&i.encode({index:6,value:n.value},r)}else if(n.type==="updateCpConfigId"){o.push({pubkey:n.value,isSigner:!1,isWritable:!1});let i=F([D("index")]);r=Buffer.alloc(i.span),i.encode({index:7},r)}else if(n.type==="updateAll"){o.push({pubkey:n.value.cpConfigId,isSigner:!1,isWritable:!1});let i=F([D("index"),N("platformClaimFeeWallet"),N("platformLockNftWallet"),P("platformScale"),P("creatorScale"),P("burnScale"),P("feeRate"),Pt("name"),Pt("web"),Pt("img"),N("transferFeeExtensionAuth"),P("creatorFeeRate")]);r=Buffer.alloc(1+32+32+8*4+4*3+Buffer.from(n.value.name,"utf-8").length+Buffer.from(n.value.web,"utf-8").length+Buffer.from(n.value.img,"utf-8").length),i.encode({index:8,platformClaimFeeWallet:n.value.platformClaimFeeWallet,platformLockNftWallet:n.value.platformLockNftWallet,platformScale:n.value.migrateCpLockNftScale.platformScale,creatorScale:n.value.migrateCpLockNftScale.creatorScale,burnScale:n.value.migrateCpLockNftScale.burnScale,feeRate:n.value.feeRate,name:n.value.name,web:n.value.web,img:n.value.img,transferFeeExtensionAuth:n.value.transferFeeExtensionAuth,creatorFeeRate:n.value.creatorFeeRate},r)}else throw Error("updateInfo params type error");return new Et({keys:o,programId:m,data:Buffer.from([...Dt.updatePlaformConfig,...r])})}function ga(m,e,t,n,o,r,i,s){let u=[{pubkey:t,isSigner:!0,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:e,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!1},{pubkey:s,isSigner:!1,isWritable:!1},{pubkey:Zt.programId,isSigner:!1,isWritable:!1},{pubkey:Or,isSigner:!1,isWritable:!1}];return new Et({keys:u,programId:m,data:Dt.claimPlatformFeeFromVault})}function Zc(m,e,t,n,o,r,i){let s=[{pubkey:e,isSigner:!0,isWritable:!0},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!1},{pubkey:i,isSigner:!1,isWritable:!1},{pubkey:Zt.programId,isSigner:!1,isWritable:!1},{pubkey:Or,isSigner:!1,isWritable:!1}];return new Et({keys:s,programId:m,data:Dt.claimCreatorFee})}import{NATIVE_MINT as Pn,TOKEN_2022_PROGRAM_ID as Mn,TOKEN_PROGRAM_ID as je,createAssociatedTokenAccountIdempotentInstruction as Jt,getTransferFeeConfig as Er,unpackMint as Dr}from"@solana/spl-token";import ie from"bn.js";import{PublicKey as el}from"@solana/web3.js";var On=F([P(),P("epoch"),D("curveType"),Tt("index"),P("migrateFee"),P("tradeFeeRate"),P("maxShareFeeRate"),P("minSupplyA"),P("maxLockRate"),P("minSellRateA"),P("minMigrateRateA"),P("minFundRaisingB"),N("mintB"),N("protocolFeeOwner"),N("migrateFeeOwner"),N("migrateToAmmWallet"),N("migrateToCpmmWallet"),j(P(),16)]),cp=F([P("totalLockedAmount"),P("cliffPeriod"),P("unlockPeriod"),P("startTime"),P("totalAllocatedShare")]),$t=F([P(),P("epoch"),D("bump"),D("status"),D("mintDecimalsA"),D("mintDecimalsB"),D("migrateType"),P("supply"),P("totalSellA"),P("virtualA"),P("virtualB"),P("realA"),P("realB"),P("totalFundRaisingB"),P("protocolFee"),P("platformFee"),P("migrateFee"),cp.replicate("vestingSchedule"),N("configId"),N("platformId"),N("mintA"),N("mintB"),N("vaultA"),N("vaultB"),N("creator"),D("mintProgramFlag"),j(D(),63)]),gK=F([P(),P("epoch"),N("poolId"),N("beneficiary"),P("claimedAmount"),P("tokenShareAmount"),j(P(),8)]),xo=F([P(),P("epoch"),N("platformClaimFeeWallet"),N("platformLockNftWallet"),P("platformScale"),P("creatorScale"),P("burnScale"),P("feeRate"),j(D(),64,"name"),j(D(),256,"web"),j(D(),256,"img"),N("cpConfigId"),P("creatorFeeRate"),N("transferFeeExtensionAuth"),j(D(),184)]);import Wt from"bn.js";import Jc from"decimal.js";import Mr from"bn.js";import xi from"decimal.js";var Nn=class{static getPoolInitPriceByPool({poolInfo:e,decimalA:t,decimalB:n}){throw Error()}static getPoolInitPriceByInit({a:e,b:t,decimalA:n,decimalB:o}){throw Error()}static getPoolPrice({poolInfo:e,decimalA:t,decimalB:n}){throw Error()}static getPoolEndPrice({supply:e,totalSell:t,totalLockedAmount:n,totalFundRaising:o,migrateFee:r,decimalA:i,decimalB:s}){throw Error()}static getPoolEndPriceReal({poolInfo:e,decimalA:t,decimalB:n}){throw Error()}static getInitParam({supply:e,totalFundRaising:t,totalSell:n,totalLockedAmount:o,migrateFee:r}){throw Error()}static buyExactIn({poolInfo:e,amount:t}){throw Error()}static buyExactOut({poolInfo:e,amount:t}){throw Error()}static sellExactIn({poolInfo:e,amount:t}){throw Error()}static sellExactOut({poolInfo:e,amount:t}){throw Error()}};var vr=class extends Nn{static getPoolInitPriceByPool({poolInfo:e,decimalA:t,decimalB:n}){return new xi(e.virtualB.toString()).div(e.virtualA.toString()).mul(10**(t-n))}static getPoolInitPriceByInit({a:e,b:t,decimalA:n,decimalB:o}){return new xi(t.toString()).div(e.toString()).mul(10**(n-o))}static getPoolPrice({poolInfo:e,decimalA:t,decimalB:n}){return new xi(e.virtualB.add(e.realB).toString()).div(e.virtualA.sub(e.realA).toString()).mul(10**(t-n))}static getPoolEndPrice({supply:e,totalSell:t,totalLockedAmount:n,totalFundRaising:o,migrateFee:r,decimalA:i,decimalB:s}){return new xi(o.sub(r).toString()).div(e.sub(t).sub(n).toString()).mul(10**(i-s))}static getPoolEndPriceReal({poolInfo:e,decimalA:t,decimalB:n}){let o=e.totalSellA.sub(e.realA),r=e.totalFundRaisingB.sub(e.realB);return new xi(e.virtualB.add(e.realB.add(r)).toString()).div(e.virtualA.sub(e.realA.add(o)).toString()).mul(10**(t-n))}static getInitParam({supply:e,totalFundRaising:t,totalSell:n,totalLockedAmount:o,migrateFee:r}){if(e.lte(n))throw Error("supply need gt total sell");let i=e.sub(n).sub(o);if(i.lte(new Mr(0)))throw Error("supplyMinusSellLocked <= 0");let s=t.sub(r);if(s.lte(new Mr(0)))throw Error("tfMinusMf <= 0");let u=s.mul(n).mul(n).div(i),a=s.mul(n).div(i).sub(t),c=u.div(a),l=t.mul(t).div(a);if(c.lt(new Mr(0))||l.lt(new Mr(0)))throw Error("invalid input 0");return{a:c,b:l,c:n}}static buyExactIn({poolInfo:e,amount:t}){return this.getAmountOut({amountIn:t,inputReserve:e.virtualB.add(e.realB),outputReserve:e.virtualA.sub(e.realA)})}static buyExactOut({poolInfo:e,amount:t}){return this.getAmountIn({amountOut:t,inputReserve:e.virtualB.add(e.realB),outputReserve:e.virtualA.sub(e.realA)})}static sellExactIn({poolInfo:e,amount:t}){return this.getAmountOut({amountIn:t,inputReserve:e.virtualA.sub(e.realA),outputReserve:e.virtualB.add(e.realB)})}static sellExactOut({poolInfo:e,amount:t}){return this.getAmountIn({amountOut:t,inputReserve:e.virtualA.sub(e.realA),outputReserve:e.virtualB.add(e.realB)})}static getAmountOut({amountIn:e,inputReserve:t,outputReserve:n}){let o=e.mul(n),r=t.add(e);return o.div(r)}static getAmountIn({amountOut:e,inputReserve:t,outputReserve:n}){let o=t.mul(e),r=n.sub(e);return En(o,r)}};import _r from"bn.js";import Si from"decimal.js";var Fr=class extends Nn{static getPoolInitPriceByPool({poolInfo:e,decimalA:t,decimalB:n}){return new Si(e.virtualB.toString()).div(e.virtualA.toString()).mul(10**(t-n))}static getPoolInitPriceByInit({a:e,b:t,decimalA:n,decimalB:o}){return new Si(t.toString()).div(e.toString()).mul(10**(n-o))}static getPoolPrice({poolInfo:e,decimalA:t,decimalB:n}){return new Si(e.virtualB.toString()).div(e.virtualA.toString()).mul(10**(t-n))}static getPoolEndPrice({supply:e,totalSell:t,totalLockedAmount:n,totalFundRaising:o,migrateFee:r,decimalA:i,decimalB:s}){return new Si(o.sub(r).toString()).div(e.sub(t).sub(n).toString()).mul(10**(i-s))}static getPoolEndPriceReal({poolInfo:e,decimalA:t,decimalB:n}){let o=e.totalSellA.sub(e.realA),r=e.totalFundRaisingB.sub(e.realB);return new Si(e.virtualB.add(e.realB).add(r).toString()).div(e.virtualA.sub(e.realA).add(o).toString()).mul(10**(t-n))}static getInitParam({supply:e,totalFundRaising:t,totalSell:n,totalLockedAmount:o,migrateFee:r}){let i=e.sub(o);if(i.lte(new _r(0)))throw Error("invalid input 1");let s=new _r(2).mul(t).sub(r),a=t.mul(i).div(s);if(a.lt(new _r(0))||t.lt(new _r(0)))throw Error("invalid input 0");return{a,b:t,c:a}}static buyExactIn({poolInfo:e,amount:t}){return this.getAmountOut({amountIn:t,initInput:e.virtualB,initOutput:e.virtualA})}static buyExactOut({poolInfo:e,amount:t}){return this.getAmountIn({amountOut:t,initInput:e.virtualB,initOutput:e.virtualA})}static sellExactIn({poolInfo:e,amount:t}){return this.getAmountOut({amountIn:t,initInput:e.virtualA,initOutput:e.virtualB})}static sellExactOut({poolInfo:e,amount:t}){return this.getAmountIn({amountOut:t,initInput:e.virtualA,initOutput:e.virtualB})}static getAmountOut({amountIn:e,initInput:t,initOutput:n}){return n.mul(e).div(t)}static getAmountIn({amountOut:e,initInput:t,initOutput:n}){let o=t.mul(e);return En(o,n)}};import wt from"bn.js";import oo from"decimal.js";import $c from"bn.js";import Aa from"decimal.js";var Ki=class{static _multipler(e){return new Aa(10).pow(e)}static getPrice({priceX64:e,decimalA:t,decimalB:n}){return new Aa(e.toString()).div(this._Q64).mul(this._multipler(t)).div(this._multipler(n))}static getPriceX64({price:e,decimalA:t,decimalB:n}){let o=e.mul(this._multipler(n)).div(this._multipler(t));return new $c(o.mul(this._Q64).toFixed(0))}};Ki._Q64=new Aa(new $c(1).shln(64).toString());var Vr=class extends Nn{static getPoolInitPriceByPool({poolInfo:e,decimalA:t,decimalB:n}){return new oo(0)}static getPoolInitPriceByInit({a:e,b:t,decimalA:n,decimalB:o}){return new oo(0)}static getPoolPrice({poolInfo:e,decimalA:t,decimalB:n}){return new oo(e.virtualA.mul(e.realA).toString()).div(Ki._Q64).mul(10**(t-n))}static getPoolEndPrice({supply:e,totalSell:t,totalLockedAmount:n,totalFundRaising:o,migrateFee:r,decimalA:i,decimalB:s}){return new oo(o.sub(r).toString()).div(e.sub(t).sub(n).toString()).mul(10**(i-s))}static getPoolEndPriceReal({poolInfo:e,decimalA:t,decimalB:n}){let o=e.totalSellA.sub(e.realA),r=e.totalFundRaisingB.sub(e.realB);return new oo(e.virtualB.add(e.realB).add(r).toString()).div(e.virtualA.sub(e.realA).add(o).toString()).mul(10**(t-n))}static getInitParam({supply:e,totalFundRaising:t,totalSell:n,totalLockedAmount:o,migrateFee:r}){let i=e.sub(o);if(i.lte(new wt(0)))throw Error("supplyMinusLocked need gt 0");let s=t.mul(new wt(3)).sub(r),a=t.mul(new wt(2)).mul(i).div(s),c=a.mul(a),l=t.mul(new wt(2)).mul(He).div(c);if(!l.gt(new wt(0)))throw Error("a need gt 0");if(!$o.gt(l))throw Error("a need lt u64 max");if(l.lt(new wt(0))||a.lt(new wt(0)))throw Error("invalid input 0");return{a:l,b:new wt(0),c:a}}static buyExactIn({poolInfo:e,amount:t}){let n=e.realB.add(t),o=new wt(2).mul(n).mul(He).div(e.virtualA);return new wt(new oo(o.toString()).sqrt().toFixed(0)).sub(e.realA)}static buyExactOut({poolInfo:e,amount:t}){let n=e.realA.add(t),o=n.mul(n);return En(e.virtualA.mul(o),new wt(2).mul(He)).sub(e.realB)}static sellExactIn({poolInfo:e,amount:t}){let n=e.realA.sub(t),o=n.mul(n),r=En(e.virtualA.mul(o),new wt(2).mul(He));return e.realB.sub(r)}static sellExactOut({poolInfo:e,amount:t}){let n=e.realB.sub(t),o=new wt(2).mul(n).mul(He).div(e.virtualA),r=new wt(new oo(o.toString()).sqrt().toFixed(0));return e.realA.sub(r)}};var qt=class{static getPoolCurvePointByPoolInfo({curveType:e,pointCount:t,poolInfo:n}){return this.getPoolCurvePointByInit({curveType:e,pointCount:t,supply:n.supply,totalFundRaising:n.totalFundRaisingB,totalSell:n.totalSellA,totalLockedAmount:n.vestingSchedule.totalLockedAmount,migrateFee:n.migrateFee,decimalA:n.mintDecimalsA,decimalB:n.mintDecimalsB})}static getPoolCurvePointByInit({curveType:e,pointCount:t,supply:n,totalFundRaising:o,totalSell:r,totalLockedAmount:i,migrateFee:s,decimalA:u,decimalB:a}){if(t<3)throw Error("point count < 3");let c=this.getCurve(e),l=c.getInitParam({supply:n,totalFundRaising:o,totalSell:r,totalLockedAmount:i,migrateFee:s}),d=c.getPoolInitPriceByInit(W(v({},l),{decimalA:u,decimalB:a})),p=o.div(new Wt(t-1)),f=new Wt(0),y=[{price:d,totalSellSupply:0}],{a:b,b:g}=l,A=f,h=f;for(let T=1;T<t;T++){let k=T!==t-1?p:o.sub(h),w=this.buyExactIn({poolInfo:{virtualA:b,virtualB:g,realA:A,realB:h,totalFundRaisingB:o,totalSellA:r},amountB:k,protocolFeeRate:f,platformFeeRate:f,curveType:e,shareFeeRate:f,creatorFeeRate:f,transferFeeConfigA:void 0,slot:0});A=A.add(w.amountA.amount),h=h.add(w.amountB);let S=this.getPrice({poolInfo:{virtualA:b,virtualB:g,realA:A,realB:h},decimalA:u,decimalB:a,curveType:e});y.push({price:S,totalSellSupply:new Jc(A.toString()).div(10**u).toNumber()})}return y}static getPoolInitPriceByPool({poolInfo:e,decimalA:t,decimalB:n,curveType:o}){return this.getCurve(o).getPoolInitPriceByPool({poolInfo:e,decimalA:t,decimalB:n})}static getPoolInitPriceByInit({a:e,b:t,decimalA:n,decimalB:o,curveType:r}){return this.getCurve(r).getPoolInitPriceByInit({a:e,b:t,decimalA:n,decimalB:o})}static getPrice({poolInfo:e,curveType:t,decimalA:n,decimalB:o}){return this.getCurve(t).getPoolPrice({poolInfo:e,decimalA:n,decimalB:o})}static getEndPrice({poolInfo:e,curveType:t,decimalA:n,decimalB:o}){return this.getCurve(t).getPoolPrice({poolInfo:e,decimalA:n,decimalB:o})}static getPoolEndPriceReal({poolInfo:e,curveType:t,decimalA:n,decimalB:o}){return this.getCurve(t).getPoolEndPriceReal({poolInfo:e,decimalA:n,decimalB:o})}static checkParam({supply:e,totalFundRaising:t,totalSell:n,totalLockedAmount:o,decimals:r,config:i,migrateType:s}){if(Number(r)!==6)throw Error("decimals = 6");if(e.mul(i.maxLockRate).div(jt).lt(o))throw Error("total lock amount gte max lock amount");if(e.lt(i.minSupplyA.mul(new Wt(10**r))))throw Error("supply lt min supply");let a=e.mul(i.minSellRateA).div(jt);if(n.lt(a))throw Error("invalid input");if(t.lt(i.minFundRaisingB))throw Error("total fund raising lt min fund raising");let c=e.sub(n).sub(o),l=e.mul(i.minMigrateRateA).div(jt);if(c.lt(l))throw Error("migrate lt min migrate amoount");let d=e.sub(n).sub(o),p=new Wt(new Jc(d.mul(t).toString()).sqrt().toFixed(0));if(s==="amm"){let f=new Wt(10).pow(new Wt(r));if(p.lte(f))throw Error("check migrate lp error")}else if(s==="cpmm"){let f=new Wt(100);if(p.lte(f))throw Error("check migrate lp error")}else throw Error("migrate type error")}static buyExactIn({poolInfo:e,amountB:t,protocolFeeRate:n,platformFeeRate:o,curveType:r,shareFeeRate:i,creatorFeeRate:s,transferFeeConfigA:u,slot:a}){let c=this.totalFeeRate({protocolFeeRate:n,platformFeeRate:o,shareFeeRate:i,creatorFeeRate:s}),l=this.calculateFee({amount:t,feeRate:c}),d=t.sub(l),p=this.getCurve(r),f=p.buyExactIn({poolInfo:e,amount:d}),y=e.totalSellA.sub(e.realA),b,g,A;if(f.gt(y)){b=y;let T=p.buyExactOut({poolInfo:e,amount:b});g=this.calculatePreFee({postFeeAmount:T,feeRate:c}),A=g.sub(T)}else b=f,g=t,A=l;let h=this.splitFee({totalFee:A,protocolFeeRate:n,platformFeeRate:o,shareFeeRate:i,creatorFeeRate:s});return{amountA:rs(b,u,a),amountB:g,splitFee:h}}static buyExactOut({poolInfo:e,amountA:t,protocolFeeRate:n,platformFeeRate:o,curveType:r,shareFeeRate:i,creatorFeeRate:s,transferFeeConfigA:u,slot:a}){let c=e.totalSellA.sub(e.realA),l=ss(t,u,a),d=l.fee?l.amount.add(l.fee):l.amount;t.gt(c)&&(d=c);let f=this.getCurve(r).buyExactOut({poolInfo:e,amount:d}),y=this.totalFeeRate({protocolFeeRate:n,platformFeeRate:o,shareFeeRate:i,creatorFeeRate:s}),b=this.calculatePreFee({postFeeAmount:f,feeRate:y}),g=b.sub(f),A=this.splitFee({totalFee:g,protocolFeeRate:n,platformFeeRate:o,shareFeeRate:i,creatorFeeRate:s});return{amountA:l,amountB:b,splitFee:A}}static sellExactIn({poolInfo:e,amountA:t,protocolFeeRate:n,platformFeeRate:o,curveType:r,shareFeeRate:i,creatorFeeRate:s,transferFeeConfigA:u,slot:a}){let c=this.getCurve(r),l=rs(t,u,a),d=l.fee?l.amount.sub(l.fee):l.amount,p=c.sellExactIn({poolInfo:e,amount:d}),f=this.calculateFee({amount:p,feeRate:this.totalFeeRate({protocolFeeRate:n,platformFeeRate:o,shareFeeRate:i,creatorFeeRate:s})}),y=this.splitFee({totalFee:f,protocolFeeRate:n,platformFeeRate:o,shareFeeRate:i,creatorFeeRate:s});return{amountA:l,amountB:p.sub(f),splitFee:y}}static sellExactOut({poolInfo:e,amountB:t,protocolFeeRate:n,platformFeeRate:o,curveType:r,shareFeeRate:i,creatorFeeRate:s,transferFeeConfigA:u,slot:a}){let c=this.totalFeeRate({protocolFeeRate:n,platformFeeRate:o,shareFeeRate:i,creatorFeeRate:s}),l=this.calculatePreFee({postFeeAmount:t,feeRate:c});if(e.realB.lt(l))throw Error("Insufficient liquidity");let d=l.sub(t),f=qt.getCurve(r).sellExactOut({poolInfo:e,amount:l});if(f.gt(e.realA))throw Error();let y=this.splitFee({totalFee:d,protocolFeeRate:n,platformFeeRate:o,shareFeeRate:i,creatorFeeRate:s});return{amountA:ss(f,u,a),amountB:t,splitFee:y}}static splitFee({totalFee:e,protocolFeeRate:t,platformFeeRate:n,shareFeeRate:o,creatorFeeRate:r}){let i=this.totalFeeRate({protocolFeeRate:t,platformFeeRate:n,shareFeeRate:o,creatorFeeRate:r}),s=i.isZero()?new Wt(0):e.mul(n).div(i),u=i.isZero()?new Wt(0):e.mul(o).div(i),a=i.isZero()?new Wt(0):e.mul(r).div(i),c=e.sub(s).sub(u).sub(a);return{platformFee:s,shareFee:u,protocolFee:c,creatorFee:a}}static calculateFee({amount:e,feeRate:t}){return Ei(e,t,jt)}static calculatePreFee({postFeeAmount:e,feeRate:t}){if(t.isZero())return e;let n=e.mul(jt),o=jt.sub(t);return n.add(o).sub(new Wt(1)).div(o)}static totalFeeRate({protocolFeeRate:e,platformFeeRate:t,shareFeeRate:n,creatorFeeRate:o}){if(e.add(t).add(n).add(o).gt(new Wt(1e6)))throw Error("total fee rate gt 1_000_000");return e.add(t).add(n).add(o)}static getCurve(e){switch(e){case 0:return vr;case 1:return Fr;case 2:return Vr}throw Error("find curve error")}};import Ct from"decimal.js";var io={initPriceX64:new ie("515752397214619"),supply:new ie(1e15),totalSellA:new ie(7931e11),totalFundRaisingB:new ie(85e9),totalLockedAmount:new ie("0"),cliffPeriod:new ie("0"),unlockPeriod:new ie("0"),decimals:6,virtualA:new ie("1073471847374405"),virtualB:new ie("30050573465"),realA:new ie(0),realB:new ie(0),protocolFee:new ie(0),platformId:new el("4Bu96XjU84XjPDSpveTVf6LYGCkfW5FK7SNkREWcEfV4"),vestingSchedule:{totalLockedAmount:new ie(0),cliffPeriod:new ie(0),unlockPeriod:new ie(0),startTime:new ie(0),totalAllocatedShare:new ie(0)}},vn=new ie(1e4),Ci=class extends Ne{constructor(e){super(e)}async sayHello(){console.log("hello")}async createLaunchpad(O){var M=O,{programId:e=st,authProgramId:t,platformId:n=io.platformId,mintA:o,decimals:r=6,mintBDecimals:i=9,name:s,symbol:u,uri:a,migrateType:c,configId:l,snipers:d,configInfo:p,platformFeeRate:f,txVersion:y,computeBudgetConfig:b,txTipConfig:g,feePayer:A,buyAmount:h,minMintAAmount:T,slippage:k,associatedOnly:w=!0,checkCreateATAOwner:S=!1,extraSigners:B,token2022:K,transferFeeExtensionParams:I}=M,C=_e(M,["programId","authProgramId","platformId","mintA","decimals","mintBDecimals","name","symbol","uri","migrateType","configId","snipers","configInfo","platformFeeRate","txVersion","computeBudgetConfig","txTipConfig","feePayer","buyAmount","minMintAAmount","slippage","associatedOnly","checkCreateATAOwner","extraSigners","token2022","transferFeeExtensionParams"]);var Co,kt,Li,ka,ha,Ta,Ia,Ba,xa,Sa;let R=[],L=this.createTxBuilder(A);t=t!=null?t:an(e).publicKey,K=!!I,K&&(c="cpmm");let _=p;if(!_&&l){let Ut=await this.scope.connection.getAccountInfo(l);Ut&&(_=On.decode(Ut.data))}_||this.logAndCreateError("config not found");let G=_.mintB,Q=_.curveType,{publicKey:se}=To(e,o,G),{publicKey:ce}=la(e,se,o),{publicKey:ne}=la(e,se,G),{publicKey:le}=yn(o);this.logDebug(`create token: ${o.toBase58()}, mintB: ${G.toBase58()}, decimals A:${r}/B:${i}, config:${l.toBase58()}`),u.length>10&&this.logAndCreateError("Symbol length should shorter than 11"),a||this.logAndCreateError("uri should not empty");let fe=(Co=C==null?void 0:C.supply)!=null?Co:io.supply,de=(kt=C==null?void 0:C.totalSellA)!=null?kt:io.totalSellA,J=(Li=C==null?void 0:C.totalFundRaisingB)!=null?Li:io.totalFundRaisingB,he=(ka=C==null?void 0:C.totalLockedAmount)!=null?ka:new ie(0),Ue=f;if(!f){let Ut=await this.scope.connection.getAccountInfo(n);Ut||this.logAndCreateError("platform id not found:",n.toString()),Ue=xo.decode(Ut.data).feeRate}let Rt=qt.getCurve(_.curveType).getInitParam({supply:fe,totalFundRaising:J,totalSell:de,totalLockedAmount:he,migrateFee:_.migrateFee}),$e={epoch:new ie(896),bump:254,status:0,mintDecimalsA:r,mintDecimalsB:i,supply:fe,totalSellA:de,mintA:new el(o),mintB:G,virtualA:Rt.a,virtualB:Rt.b,realA:io.realA,realB:io.realB,migrateFee:_.migrateFee,migrateType:c==="amm"?0:1,protocolFee:io.protocolFee,platformFee:Ue,platformId:n,configId:l,vaultA:ce,vaultB:ne,creator:this.scope.ownerPubKey,totalFundRaisingB:J,vestingSchedule:{totalLockedAmount:he,cliffPeriod:new ie(0),unlockPeriod:new ie(0),startTime:new ie(0),totalAllocatedShare:new ie(0)},mintProgramFlag:K?1:0},Je=qt.getCurve(_.curveType),{c:So}=Je.getInitParam({supply:$e.supply,totalFundRaising:$e.totalFundRaisingB,totalLockedAmount:he,totalSell:_.curveType===0?$e.totalSellA:new ie(0),migrateFee:_.migrateFee});try{qt.checkParam({supply:$e.supply,totalFundRaising:$e.totalFundRaisingB,totalSell:So,totalLockedAmount:he,decimals:$e.mintDecimalsA,config:_,migrateType:c}),this.logDebug("check init params success")}catch(Ut){this.logAndCreateError(`check create mint params failed, ${Ut.message}`)}L.addInstruction({instructions:[K?Xc(e,A!=null?A:this.scope.ownerPubKey,this.scope.ownerPubKey,l,n,t,se,o,G,ce,ne,r,s,u,a||"https://",{type:Q===0?"ConstantCurve":Q===1?"FixedCurve":Q===2?"LinearCurve":"ConstantCurve",totalSellA:de,migrateType:c,supply:fe,totalFundRaisingB:J},he,(ha=C==null?void 0:C.cliffPeriod)!=null?ha:new ie(0),(Ta=C==null?void 0:C.unlockPeriod)!=null?Ta:new ie(0),I):Gc(e,A!=null?A:this.scope.ownerPubKey,this.scope.ownerPubKey,l,n,t,se,o,G,ce,ne,le,r,s,u,a||"https://",{type:Q===0?"ConstantCurve":Q===1?"FixedCurve":Q===2?"LinearCurve":"ConstantCurve",totalSellA:de,migrateType:c,supply:fe,totalFundRaisingB:J},he,(Ia=C==null?void 0:C.cliffPeriod)!=null?Ia:new ie(0),(Ba=C==null?void 0:C.unlockPeriod)!=null?Ba:new ie(0))]});let Ko=K?await this.scope.connection.getEpochInfo():void 0,en=I?{epoch:BigInt((Ko==null?void 0:Ko.epoch)||0),maximumFee:BigInt((xa=I==null?void 0:I.maxinumFee.toString())!=null?xa:0),transferFeeBasisPoints:(Sa=I==null?void 0:I.transferFeeBasePoints)!=null?Sa:0}:void 0,ro={amountA:{amount:new ie(0),fee:void 0,expirationTime:void 0},amountB:new ie(0),splitFee:{platformFee:new ie(0),shareFee:new ie(0),protocolFee:new ie(0),creatorFee:new ie(0)}},so;if(B!=null&&B.length&&L.addInstruction({signers:B}),!C.createOnly){let{builder:Ut,extInfo:tl}=await this.buyToken({programId:e,authProgramId:t,mintAProgram:K?Mn:void 0,mintA:o,mintB:G,poolInfo:$e,buyAmount:h,minMintAAmount:T,shareFeeRate:C.shareFeeRate,shareFeeReceiver:C.shareFeeReceiver,configInfo:_,platformFeeRate:Ue,slippage:k,associatedOnly:w,checkCreateATAOwner:S,skipCheckMintA:!en,transferFeeConfigA:en?{transferFeeConfigAuthority:t,withdrawWithheldAuthority:t,withheldAmount:BigInt(0),olderTransferFee:en,newerTransferFee:en}:void 0});for(let Ka of d){let{builder:pp,extInfo:fp,transaction:nl}=await this.buyToken({programId:e,authProgramId:t,mintAProgram:K?Mn:void 0,mintA:o,mintB:G,poolInfo:$e,buyAmount:Ka.amount,minMintAAmount:T,shareFeeRate:C.shareFeeRate,shareFeeReceiver:C.shareFeeReceiver,configInfo:_,platformFeeRate:Ue,slippage:k,sniper:Ka,associatedOnly:w,checkCreateATAOwner:S,skipCheckMintA:!en,transferFeeConfigA:en?{transferFeeConfigAuthority:t,withdrawWithheldAuthority:t,withheldAmount:BigInt(0),olderTransferFee:en,newerTransferFee:en}:void 0});R.push(nl)}L.addInstruction(v({},Ut.AllTxData)),ro=v({},tl),so=(this.scope.cluster==="devnet"||y===1)&&C.shareFeeReceiver?[Ut.allInstructions[0]]:void 0}return L.addTipInstruction(g),y===0?{tx:await L.sizeCheckBuildV0({computeBudgetConfig:b,swapInfo:ro,splitIns:so,address:W(v({},$e),{poolId:se})}),txs:R}:{tx:await L.sizeCheckBuild({computeBudgetConfig:b,swapInfo:ro,splitIns:so,address:W(v({},$e),{poolId:se})}),txs:R}}async buyToken({programId:e=st,authProgramId:t,mintA:n,mintAProgram:o=je,mintB:r=Pn,poolInfo:i,configInfo:s,platformFeeRate:u,txVersion:a,computeBudgetConfig:c,txTipConfig:l,feePayer:d,buyAmount:p,minMintAAmount:f,slippage:y,shareFeeRate:b=new ie(0),shareFeeReceiver:g,sniper:A,associatedOnly:h=!0,checkCreateATAOwner:T=!1,transferFeeConfigA:k,skipCheckMintA:w=!1}){var J,he,Ue;p.lte(new ie(0))&&this.logAndCreateError("buy amount should gt 0:",p.toString());let S=A?this.createSniperTxBuilder(A.owner,A.owner.publicKey):this.createTxBuilder(d),{publicKey:B}=To(e,n,r);t=t!=null?t:an(e).publicKey;let K=k;if(!w)if(K)o=Mn;else{let Le=await this.scope.connection.getAccountInfo(n);if(Le&&Le.owner.equals(Mn)){o=Le.owner;let Rt=Dr(n,Le,o);K=Er(Rt)||void 0}}let I=A?this.scope.account.getAssociatedTokenAccountByOwner(A.owner.publicKey,n,o):this.scope.account.getAssociatedTokenAccount(n,o),C=null,O=r.equals(Pn);console.log("userTokenAccountA: ",I),S.addInstruction({instructions:[Jt((A==null?void 0:A.owner.publicKey)||this.scope.ownerPubKey,I,(A==null?void 0:A.owner.publicKey)||this.scope.ownerPubKey,n,o)]});let{account:M,instructionParams:R}=await this.scope.account.getOrCreateTokenAccount({mint:r,owner:(A==null?void 0:A.owner.publicKey)||this.scope.ownerPubKey,createInfo:O?{payer:(A==null?void 0:A.owner.publicKey)||this.scope.ownerPubKey,amount:p}:void 0,skipCloseAccount:!O,notUseTokenAccount:O,associatedOnly:O?!1:h,checkCreateATAOwner:T});M&&(C=M),C===void 0&&this.logAndCreateError(`cannot found mintB(${r.toBase58()}) token accounts`,"tokenAccounts",this.scope.account.tokenAccounts);let L=i;if(!L){let Le=await this.scope.connection.getAccountInfo(B,{commitment:"processed"});Le||this.logAndCreateError("cannot found pool:",B.toBase58()),L=$t.decode(Le.data)}let _=s,G=await Ce(this.scope.connection,[_?void 0:L.configId,L.platformId].filter(Boolean).map(Le=>({pubkey:Le})));if(!_){let Le=G.find(Rt=>Rt.pubkey.equals(L.configId));(!Le||!Le.accountInfo)&&this.logAndCreateError("config not found: ",L.configId.toBase58()),_=On.decode(Le.accountInfo.data)}let Q=G.find(Le=>Le.pubkey.equals(L.platformId));(!Q||!Q.accountInfo)&&this.logAndCreateError("platform info not found: ",L.configId.toBase58());let se=xo.decode(Q.accountInfo.data);u=u||se.feeRate;let ce=qt.buyExactIn({poolInfo:L,amountB:p,protocolFeeRate:_.tradeFeeRate,platformFeeRate:u,curveType:_.curveType,shareFeeRate:b,creatorFeeRate:se.creatorFeeRate,transferFeeConfigA:K,slot:await this.scope.connection.getSlot()}),ne=new Ct(ce.amountA.amount.toString()).sub((he=(J=ce.amountA.fee)==null?void 0:J.toString())!=null?he:0),le=y?new Ct(vn.sub(y).toNumber()/vn.toNumber()).clampedTo(0,1):new Ct(1),fe=f!=null?f:y?new ie(ne.mul(le).toFixed(0)):ce.amountA.amount.sub((Ue=ce.amountA.fee)!=null?Ue:new ie(0));ce.amountB.lt(p)&&console.log(`maximum ${n.toBase58()} amount can buy is ${ce.amountA.toString()}, input ${r.toBase58()} amount: ${ce.amountB.toString()}`);let de=g?Z(g,r,je).publicKey:void 0;return S.versionBuild({txVersion:a,extInfo:W(v({},ce),{decimalOutAmount:ne,minDecimalOutAmount:new Ct(fe.toString())})})}async buyTokenExactOut({programId:e=st,authProgramId:t,mintA:n,mintAProgram:o=je,mintB:r=Pn,poolInfo:i,configInfo:s,transferFeeConfigA:u,platformFeeRate:a,txVersion:c,computeBudgetConfig:l,txTipConfig:d,feePayer:p,maxBuyAmount:f,outAmount:y,slippage:b,shareFeeRate:g=new ie(0),shareFeeReceiver:A,associatedOnly:h=!0,checkCreateATAOwner:T=!1,skipCheckMintA:k=!1}){y.lte(new ie(0))&&this.logAndCreateError("out amount should gt 0:",y.toString());let w=this.createTxBuilder(p),{publicKey:S}=To(e,n,r);t=t!=null?t:an(e).publicKey;let B=i;if(!B){let de=await this.scope.connection.getAccountInfo(S,{commitment:"processed"});de||this.logAndCreateError("cannot found pool:",S.toBase58()),B=$t.decode(de.data)}let K=s,I=await Ce(this.scope.connection,[K?void 0:B.configId,B.platformId].filter(Boolean).map(de=>({pubkey:de})));if(!K){let de=I.find(J=>J.pubkey.equals(B.configId));(!de||!de.accountInfo)&&this.logAndCreateError("config not found: ",B.configId.toBase58()),K=On.decode(de.accountInfo.data)}let C=I.find(de=>de.pubkey.equals(B.platformId));(!C||!C.accountInfo)&&this.logAndCreateError("platform info not found: ",B.configId.toBase58());let O=xo.decode(C.accountInfo.data);a=a||O.feeRate;let M=u;if(!k)if(M)o=Mn;else{let de=await this.scope.connection.getAccountInfo(n);if(de&&de.owner.equals(Mn)){o=de.owner;let J=Dr(n,de,o);M=Er(J)||void 0}}let R=qt.buyExactOut({poolInfo:B,amountA:y,protocolFeeRate:K.tradeFeeRate,platformFeeRate:a,curveType:K.curveType,shareFeeRate:g,creatorFeeRate:O.creatorFeeRate,transferFeeConfigA:M,slot:await this.scope.connection.getSlot()}),L=new Ct(R.amountB.toString()),_=b?new Ct(vn.add(b).toNumber()/vn.toNumber()).clampedTo(0,Number.MIN_SAFE_INTEGER):new Ct(1),G=(f!=null?f:b)?new ie(L.mul(_).toFixed(0)):R.amountB,Q=this.scope.account.getAssociatedTokenAccount(n,o),se=null,ce=r.equals(Pn);w.addInstruction({instructions:[Jt(this.scope.ownerPubKey,Q,this.scope.ownerPubKey,n,o)]});let{account:ne,instructionParams:le}=await this.scope.account.getOrCreateTokenAccount({mint:r,owner:this.scope.ownerPubKey,createInfo:ce?{payer:this.scope.ownerPubKey,amount:R.amountB}:void 0,skipCloseAccount:!ce,notUseTokenAccount:ce,associatedOnly:ce?!1:h,checkCreateATAOwner:T});ne&&(se=ne),w.addInstruction(le||{}),se===void 0&&this.logAndCreateError(`cannot found mintB(${r.toBase58()}) token accounts`,"tokenAccounts",this.scope.account.tokenAccounts);let fe=A?Z(A,r,je).publicKey:void 0;return fe&&w.addInstruction({instructions:[Jt(this.scope.ownerPubKey,fe,A,r)]}),w.addInstruction({instructions:[zc(e,this.scope.ownerPubKey,t,B.configId,B.platformId,S,Q,se,B.vaultA,B.vaultB,n,r,o,je,Bo(e,B.platformId,r).publicKey,Bi(e,B.creator,r).publicKey,y,G,g,fe)]}),w.addCustomComputeBudget(l),w.addTipInstruction(d),w.versionBuild({txVersion:c,extInfo:{maxSpentAmount:G,outAmount:y}})}async sellToken({programId:e=st,authProgramId:t,mintAProgram:n=je,mintA:o,mintB:r=Pn,poolInfo:i,configInfo:s,platformFeeRate:u,txVersion:a,computeBudgetConfig:c,txTipConfig:l,feePayer:d,sellAmount:p,minAmountB:f,slippage:y,shareFeeRate:b=new ie(0),shareFeeReceiver:g,associatedOnly:A=!0,checkCreateATAOwner:h=!1,skipCheckMintA:T=!1}){t=t!=null?t:an(e).publicKey;let k=this.createTxBuilder(d);p.lte(new ie(0))&&this.logAndCreateError("sell amount should be gt 0");let{publicKey:w}=To(e,o,r),S;if(!T){let J=await this.scope.connection.getAccountInfo(o);if(J&&J.owner.equals(Mn)){n=J.owner;let he=Dr(o,J,n);S=Er(he)||void 0}}let B=null,K=null,I=r.equals(Pn),{account:C,instructionParams:O}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:n,mint:o,owner:this.scope.ownerPubKey,createInfo:void 0,skipCloseAccount:!0,notUseTokenAccount:!1,associatedOnly:A,checkCreateATAOwner:h});C&&(B=C),k.addInstruction(O||{}),B===void 0&&this.logAndCreateError("cannot found mintA token accounts","tokenAccounts",this.scope.account.tokenAccounts);let{account:M,instructionParams:R}=await this.scope.account.getOrCreateTokenAccount({mint:r,owner:this.scope.ownerPubKey,createInfo:I?{payer:this.scope.ownerPubKey,amount:0}:void 0,skipCloseAccount:!I,notUseTokenAccount:I,associatedOnly:I?!1:A,checkCreateATAOwner:h});M&&(K=M),k.addInstruction(R||{}),K===void 0&&this.logAndCreateError("cannot found mintB token accounts","tokenAccounts",this.scope.account.tokenAccounts);let L=i;if(!L){let J=await this.scope.connection.getAccountInfo(w,{commitment:"processed"});J||this.logAndCreateError("cannot found pool",w.toBase58()),L=$t.decode(J.data)}let _=s,G=await Ce(this.scope.connection,[_?void 0:L.configId,L.platformId].filter(Boolean).map(J=>({pubkey:J})));if(!_){let J=G.find(he=>he.pubkey.equals(L.configId));(!J||!J.accountInfo)&&this.logAndCreateError("config not found: ",L.configId.toBase58()),_=On.decode(J.accountInfo.data)}let Q=G.find(J=>J.pubkey.equals(L.platformId));(!Q||!Q.accountInfo)&&this.logAndCreateError("platform info not found: ",L.configId.toBase58());let se=xo.decode(Q.accountInfo.data);u=u||se.feeRate;let ce=qt.sellExactIn({poolInfo:L,amountA:p,protocolFeeRate:_.tradeFeeRate,platformFeeRate:u,curveType:_.curveType,shareFeeRate:b,creatorFeeRate:se.creatorFeeRate,transferFeeConfigA:S,slot:await this.scope.connection.getSlot()}),ne=new Ct(ce.amountB.toString()),le=y?new Ct(vn.sub(y).toNumber()/vn.toNumber()).clampedTo(0,1):new Ct(1),fe=f!=null?f:y?new ie(ne.mul(le).toFixed(0)):ce.amountB;fe.lte(new ie(0))&&this.logAndCreateError(`out ${r.toBase58()} amount should be gt 0`);let de=g?Z(g,r,je).publicKey:void 0;return de&&k.addInstruction({instructions:[Jt(this.scope.ownerPubKey,de,g,r)]}),k.addInstruction({instructions:[Qc(e,this.scope.ownerPubKey,t,L.configId,L.platformId,w,B,K,L.vaultA,L.vaultB,o,r,n,je,Bo(e,L.platformId,r).publicKey,Bi(e,L.creator,r).publicKey,ce.amountA.amount.lt(p)?ce.amountA.amount:p,fe,b,de)]}),k.addCustomComputeBudget(c),k.addTipInstruction(l),k.versionBuild({txVersion:a,extInfo:{outAmount:fe}})}async sellTokenExactOut({programId:e=st,authProgramId:t,mintAProgram:n=je,mintA:o,mintB:r=Pn,poolInfo:i,configInfo:s,platformFeeRate:u,txVersion:a,computeBudgetConfig:c,txTipConfig:l,feePayer:d,inAmount:p,maxSellAmount:f,slippage:y,shareFeeRate:b=new ie(0),shareFeeReceiver:g,associatedOnly:A=!0,checkCreateATAOwner:h=!1,skipCheckMintA:T=!1}){t=t!=null?t:an(e).publicKey;let k=this.createTxBuilder(d);f!=null&&f.lte(new ie(0))&&this.logAndCreateError("max sell amount should be gt 0");let{publicKey:w}=To(e,o,r),S;if(!T){let J=await this.scope.connection.getAccountInfo(o);if(J&&J.owner.equals(Mn)){n=J.owner;let he=Dr(o,J,n);S=Er(he)||void 0}}let B=null,K=null,I=r.equals(Pn),{account:C,instructionParams:O}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:n,mint:o,owner:this.scope.ownerPubKey,createInfo:void 0,skipCloseAccount:!0,notUseTokenAccount:!1,associatedOnly:A,checkCreateATAOwner:h});C&&(B=C),k.addInstruction(O||{}),B===void 0&&this.logAndCreateError("cannot found mintA token accounts","tokenAccounts",this.scope.account.tokenAccounts);let{account:M,instructionParams:R}=await this.scope.account.getOrCreateTokenAccount({mint:r,owner:this.scope.ownerPubKey,createInfo:I?{payer:this.scope.ownerPubKey,amount:0}:void 0,skipCloseAccount:!I,notUseTokenAccount:I,associatedOnly:I?!1:A,checkCreateATAOwner:h});M&&(K=M),k.addInstruction(R||{}),K===void 0&&this.logAndCreateError("cannot found mintB token accounts","tokenAccounts",this.scope.account.tokenAccounts);let L=i;if(!L){let J=await this.scope.connection.getAccountInfo(w,{commitment:"processed"});J||this.logAndCreateError("cannot found pool",w.toBase58()),L=$t.decode(J.data)}let _=s,G=await Ce(this.scope.connection,[_?void 0:L.configId,L.platformId].filter(Boolean).map(J=>({pubkey:J})));if(!_){let J=G.find(he=>he.pubkey.equals(L.configId));(!J||!J.accountInfo)&&this.logAndCreateError("config not found: ",L.configId.toBase58()),_=On.decode(J.accountInfo.data)}let Q=G.find(J=>J.pubkey.equals(L.platformId));(!Q||!Q.accountInfo)&&this.logAndCreateError("platform info not found: ",L.configId.toBase58());let se=xo.decode(Q.accountInfo.data);u=u||se.feeRate;let ce=qt.sellExactOut({poolInfo:L,amountB:p,protocolFeeRate:_.tradeFeeRate,platformFeeRate:u,curveType:_.curveType,shareFeeRate:b,creatorFeeRate:se.creatorFeeRate,transferFeeConfigA:S,slot:await this.scope.connection.getSlot()}),ne=new Ct(ce.amountA.amount.toString()),le=y?new Ct(vn.add(y).toNumber()/vn.toNumber()).clampedTo(0,Number.MAX_SAFE_INTEGER):new Ct(1),fe=(f!=null?f:y)?new ie(ne.mul(le).toFixed(0)):ce.amountA.amount,de=g?Z(g,r,je).publicKey:void 0;return de&&k.addInstruction({instructions:[Jt(this.scope.ownerPubKey,de,g,r)]}),k.addInstruction({instructions:[jc(e,this.scope.ownerPubKey,t,L.configId,L.platformId,w,B,K,L.vaultA,L.vaultB,o,r,n,je,Bo(e,L.platformId,r).publicKey,Bi(e,L.creator,r).publicKey,p,fe,b,de)]}),k.addCustomComputeBudget(c),k.addTipInstruction(l),k.versionBuild({txVersion:a,extInfo:{maxSellAmount:fe}})}async createPlatformConfig({programId:e=st,platformAdmin:t,platformClaimFeeWallet:n,platformLockNftWallet:o,cpConfigId:r,migrateCpLockNftScale:i,transferFeeExtensionAuth:s,creatorFeeRate:u,feeRate:a,name:c,web:l,img:d,txVersion:p,computeBudgetConfig:f,txTipConfig:y,feePayer:b}){let g=this.createTxBuilder(b),{publicKey:A}=ma(e,t);return g.addInstruction({instructions:[Yc(e,t,n,o,A,r,s,i,a,u,c,l,d)]}),g.addCustomComputeBudget(f),g.addTipInstruction(y),g.versionBuild({txVersion:p,extInfo:{platformId:A}})}async updatePlatformConfig({programId:e=st,platformAdmin:t,platformId:n,updateInfo:o,txVersion:r,computeBudgetConfig:i,txTipConfig:s,feePayer:u}){let a=this.createTxBuilder(u),c=n!=null?n:ma(e,t).publicKey;return a.addInstruction({instructions:[Hc(e,t,c,o)]}),a.addCustomComputeBudget(i),a.addTipInstruction(s),a.versionBuild({txVersion:r})}async claimPlatformFee({programId:e=st,authProgramId:t,platformId:n,poolId:o,platformClaimFeeWallet:r,mintB:i,vaultB:s,mintBProgram:u=je,txVersion:a,computeBudgetConfig:c,txTipConfig:l,feePayer:d}){var g;let p=this.createTxBuilder(d);t=t!=null?t:an(e).publicKey;let f=i,y=s;if(!f){let A=await this.scope.connection.getAccountInfo(o,{commitment:"processed"});A||this.logAndCreateError("cannot found pool:",o.toBase58());let h=$t.decode(A.data),T=await this.scope.connection.getAccountInfo(h.configId,{commitment:"processed"});T||this.logAndCreateError("cannot found config:",h.configId.toBase58()),f=On.decode(T.data).mintB,y=y!=null?y:h.vaultB}(!f||!y)&&this.logAndCreateError("cannot found mint info, mintB: ",f.toBase58(),", vaultB: ",(g=y==null?void 0:y.toBase58())!=null?g:"");let b=Z(this.scope.ownerPubKey,f,je).publicKey;return p.addInstruction({instructions:[Jt(this.scope.ownerPubKey,b,this.scope.ownerPubKey,f)]}),p.addInstruction({instructions:[ba(e,r,t,o,n,y,b,f,u)]}),p.addCustomComputeBudget(c),p.addTipInstruction(l),p.versionBuild({txVersion:a})}async claimAllPlatformFee({programId:e=st,authProgramId:t,platformId:n,platformClaimFeeWallet:o,txVersion:r,computeBudgetConfig:i,txTipConfig:s,feePayer:u}){let a=this.createTxBuilder(u);return t=t!=null?t:an(e).publicKey,(await this.scope.connection.getProgramAccounts(e,{filters:[{dataSize:$t.span},{memcmp:{offset:$t.offsetOf("platformId"),bytes:n.toString()}}]})).forEach(l=>{let d=$t.decode(l.account.data);if(d.platformFee.lte(new ie(0)))return;let p=Z(this.scope.ownerPubKey,d.mintB,je).publicKey;a.addInstruction({instructions:[Jt(this.scope.ownerPubKey,p,this.scope.ownerPubKey,d.mintB)]}),a.addInstruction({instructions:[ba(e,o,t,l.pubkey,n,d.vaultB,p,d.mintB,je)]})}),a.addTipInstruction(s),r===0?a.sizeCheckBuildV0({computeBudgetConfig:i}):a.sizeCheckBuild({computeBudgetConfig:i})}async createVesting({programId:e=st,poolId:t,beneficiary:n,shareAmount:o,txVersion:r,computeBudgetConfig:i,txTipConfig:s,feePayer:u}){let a=this.createTxBuilder(u),c=await this.getRpcPoolInfo({poolId:t});o.add(c.vestingSchedule.totalAllocatedShare).gt(c.vestingSchedule.totalLockedAmount)&&this.logAndCreateError("share amount exceed total locked amount");let l=Ii(e,t,n).publicKey;return a.addInstruction({instructions:[ya(e,this.scope.ownerPubKey,n,t,l,o)]}),a.addCustomComputeBudget(i),a.addTipInstruction(s),a.versionBuild({txVersion:r})}async createMultipleVesting({programId:e=st,poolId:t,beneficiaryList:n,txVersion:o,computeBudgetConfig:r,feePayer:i}){let s=this.createTxBuilder(i);n.length===0&&this.logAndCreateError("beneficiaryList is null");let u=await this.getRpcPoolInfo({poolId:t});return n.reduce((c,l)=>c.add(l.shareAmount),u.vestingSchedule.totalAllocatedShare).gt(u.vestingSchedule.totalLockedAmount)&&this.logAndCreateError("share amount exceed total locked amount"),n.forEach(c=>{let l=Ii(e,t,c.wallet).publicKey;s.addInstruction({instructions:[ya(e,this.scope.ownerPubKey,c.wallet,t,l,c.shareAmount)]})}),o===0?s.sizeCheckBuildV0({computeBudgetConfig:r}):s.sizeCheckBuild({computeBudgetConfig:r})}async claimVesting({programId:e=st,poolId:t,poolInfo:n,vestingRecord:o,txVersion:r,computeBudgetConfig:i,txTipConfig:s,feePayer:u}){let a=this.createTxBuilder(u),c=an(e).publicKey,l=o||Ii(e,t,this.scope.ownerPubKey).publicKey,d=n;if(!d){let f=await this.scope.connection.getAccountInfo(t);f||this.logAndCreateError("pool not found"),d=$t.decode(f.data)}let p=Z(this.scope.ownerPubKey,d.mintA,je).publicKey;return a.addInstruction({instructions:[Jt(this.scope.ownerPubKey,p,this.scope.ownerPubKey,d.mintA)]}),a.addInstruction({instructions:[fa(e,this.scope.ownerPubKey,c,t,l,p,d.vaultA,d.mintA,je)]}),a.addCustomComputeBudget(i),a.addTipInstruction(s),a.versionBuild({txVersion:r})}async claimMultiVesting({programId:e=st,poolIdList:t,poolsInfo:n={},vestingRecords:o={},txVersion:r,computeBudgetConfig:i,feePayer:s}){let u=this.createTxBuilder(s),a=v({},n),c=an(e).publicKey,l=t.filter(d=>!a[d.toBase58()]);if(l.length){let d=await this.getRpcPoolsInfo({poolIdList:l});a=v(v({},a),d.poolInfoMap)}return t.forEach(d=>{let p=d.toBase58(),f=a[p];f||this.logAndCreateError(`pool info not found: ${p}`);let y=o[p]||Ii(e,d,this.scope.ownerPubKey).publicKey,b=Z(this.scope.ownerPubKey,f.mintA,je).publicKey;u.addInstruction({instructions:[Jt(this.scope.ownerPubKey,b,this.scope.ownerPubKey,f.mintA)]}),u.addInstruction({instructions:[fa(e,this.scope.ownerPubKey,c,d,y,b,f.vaultA,f.mintA,je)]})}),r===0?u.sizeCheckBuildV0({computeBudgetConfig:i}):u.sizeCheckBuild({computeBudgetConfig:i})}async claimVaultPlatformFee({programId:e=st,platformId:t,mintB:n,mintBProgram:o=je,claimFeeWallet:r,txVersion:i,computeBudgetConfig:s,txTipConfig:u,feePayer:a}){let c=this.createTxBuilder(a),l=Bo(e,t,n).publicKey,d=da(e).publicKey,p=this.scope.account.getAssociatedTokenAccount(n,o);return c.addInstruction({instructions:[Jt(this.scope.ownerPubKey,p,this.scope.ownerPubKey,n,o),ga(e,t,r!=null?r:this.scope.ownerPubKey,d,l,p,n,o)]}),c.addCustomComputeBudget(s),c.addTipInstruction(u),c.versionBuild({txVersion:i})}async claimMultipleVaultPlatformFee({programId:e=st,platformList:t,unwrapSol:n=!0,txVersion:o,computeBudgetConfig:r,feePayer:i,associatedOnly:s=!0,checkCreateATAOwner:u=!1}){let a=this.createTxBuilder(i),c={};return t.forEach(async l=>{var b,g;let d=da(e).publicKey,p=Bo(e,l.id,l.mintB).publicKey,f=l.mintB.equals(Pn)&&n,y=c[l.mintB.toBase58()];if(!y){let{account:A,instructionParams:h}=await this.scope.account.getOrCreateTokenAccount({mint:l.mintB,owner:this.scope.ownerPubKey,createInfo:f?{payer:this.scope.ownerPubKey,amount:0}:void 0,skipCloseAccount:!f,notUseTokenAccount:f,associatedOnly:f?!1:s,checkCreateATAOwner:u});A&&(y=A),a.addInstruction(h||{}),y===void 0&&this.logAndCreateError(`cannot found platform ${l.id.toBase58()} mintB(${l.mintB.toBase58()}) token accounts`,"tokenAccounts",this.scope.account.tokenAccounts)}a.addInstruction({instructions:[ga(e,l.id,(b=l.claimFeeWallet)!=null?b:this.scope.ownerPubKey,p,d,y,l.mintB,(g=l.mintBProgram)!=null?g:je)]})}),o===0?a.sizeCheckBuildV0({computeBudgetConfig:r}):a.sizeCheckBuild({computeBudgetConfig:r})}async claimCreatorFee({programId:e=st,mintB:t,mintBProgram:n=je,txVersion:o,computeBudgetConfig:r,txTipConfig:i,feePayer:s}){let u=this.createTxBuilder(s),a=Bi(e,this.scope.ownerPubKey,t).publicKey,c=Uc(e).publicKey,l=this.scope.account.getAssociatedTokenAccount(t,n);return u.addInstruction({instructions:[Jt(this.scope.ownerPubKey,l,this.scope.ownerPubKey,t,n),Zc(e,this.scope.ownerPubKey,c,a,l,t,n)]}),u.addCustomComputeBudget(r),u.addTipInstruction(i),u.versionBuild({txVersion:o})}async getRpcPoolInfo({poolId:e}){return(await this.getRpcPoolsInfo({poolIdList:[e]})).poolInfoMap[e.toBase58()]}async getRpcPoolsInfo({poolIdList:e,config:t}){let n=await Ce(this.scope.connection,e.map(u=>({pubkey:u})),t),o={},r=[];for(let u=0;u<e.length;u++){let a=n[u];if(a===null||!a.accountInfo)throw Error("fetch pool info error: "+e[u].toBase58());let c=$t.decode(a.accountInfo.data);o[e[u].toBase58()]=W(v({},c),{poolId:a.accountInfo.owner}),r.push(c.configId)}let i=await Ce(this.scope.connection,r.map(u=>({pubkey:u})),t),s={};for(let u=0;u<r.length;u++){let a=i[u];if(a===null||!a.accountInfo)throw Error("fetch config info error: "+r[u].toBase58());let c=On.decode(a.accountInfo.data);s[r[u].toBase58()]=W(v({},c),{configId:a.accountInfo.owner})}return{poolInfoMap:Object.keys(o).reduce((u,a)=>W(v({},u),{[a]:W(v({},o[a]),{configInfo:s[o[a].configId.toBase58()]})}),{})}}};import{PublicKey as lp}from"@solana/web3.js";import{MintLayout as mp,TOKEN_2022_PROGRAM_ID as Pa,TOKEN_PROGRAM_ID as wa}from"@solana/spl-token";var Ri=class extends Ne{constructor(t){super(t);this._tokenList=[];this._tokenMap=new Map;this._blackTokenMap=new Set;this._mintGroup={official:new Set,jup:new Set,extra:new Set};this._whiteMap=new Set;this._extraTokenList=[]}async load(t){this.checkDisabled();let{forceUpdate:n=!1,type:o="strict"}=t||{},{mintList:r,blacklist:i,whiteList:s}=await this.scope.fetchV3TokenList(n),u=await this.scope.fetchJupTokenList(n);this._tokenList=[],this._tokenMap=new Map,this._blackTokenMap=new Set(i),this._mintGroup={official:new Set,jup:new Set,extra:new Set},this._whiteMap=new Set(s),this._tokenMap.set(wn.address,wn),this._mintGroup.official.add(wn.address),r.forEach(a=>{var c;this._blackTokenMap.has(a.address)||(this._tokenMap.set(a.address,W(v({},a),{type:"raydium",priority:2,programId:(c=a.programId)!=null?c:a.tags.includes("token-2022")?Pa.toBase58():wa.toBase58()})),this._mintGroup.official.add(a.address))}),u.forEach(a=>{var c;this._blackTokenMap.has(a.address)||this._tokenMap.has(a.address)||(this._tokenMap.set(a.address,W(v({},a),{type:"jupiter",priority:1,programId:(c=a.programId)!=null?c:a.tags.includes("token-2022")?Pa.toBase58():wa.toBase58(),tags:a.freezeAuthority?[...a.tags||[],"hasFreeze"]:a.tags})),this._mintGroup.jup.add(a.address))}),this._extraTokenList.forEach(a=>{this._blackTokenMap.has(a.address)||this._tokenMap.has(a.address)||(this._tokenMap.set(a.address,W(v({},a),{type:"extra",priority:1,programId:a.programId||a.tags.includes("token-2022")?Pa.toBase58():wa.toBase58()})),this._mintGroup.extra.add(a.address))}),this._tokenList=Array.from(this._tokenMap).map(a=>a[1])}get tokenList(){return this._tokenList}get tokenMap(){return this._tokenMap}get blackTokenMap(){return this._blackTokenMap}get mintGroup(){return this._mintGroup}get whiteListMap(){return this._whiteMap}async getTokenInfo(t){if(!t)throw new Error("please input mint");let n=t.toString(),o=this._tokenMap.get(n);if(o)return o;if(n.toLocaleUpperCase()==="SOL")return wn;let r=(await this.scope.api.getTokenInfo([n]))[0];if(r)return this._mintGroup.extra.add(n),this._tokenMap.set(n,W(v({},r),{priority:2})),r;let i=await this.scope.connection.getAccountInfo(new lp(n));if(!i)throw new Error(`mint address not found: ${n}`);let s=mp.decode(i.data),u=n.toString().substring(0,6),a={chainId:101,address:n,programId:i.owner.toBase58(),logoURI:"",symbol:u,name:u,decimals:s.decimals,tags:[],extensions:{},priority:0,type:"unknown"};return this._mintGroup.extra.add(n),this._tokenMap.set(n,a),a}};var Wr=class{constructor(e){this.rawBalances=new Map;let{connection:t,cluster:n,owner:o,api:r,defaultChainTime:i,defaultChainTimeOffset:s,apiCacheTime:u,blockhashCommitment:a="confirmed",loopMultiTxStatus:c}=e;this._connection=t,this.cluster=n||"mainnet",this._owner=o?new ht(o):void 0,this._signAllTransactions=e.signAllTransactions,this.blockhashCommitment=a,this.loopMultiTxStatus=c,this.api=r,this._apiCacheTime=u||5*60*1e3,this.logger=ye("Raydium"),this.farm=new Zo({scope:this,moduleName:"Raydium_Farm"}),this.account=new Uo({scope:this,moduleName:"Raydium_Account",tokenAccounts:e.tokenAccounts,tokenAccountRawInfos:e.tokenAccountRawInfos}),this.liquidity=new di({scope:this,moduleName:"Raydium_LiquidityV2"}),this.token=new Ri({scope:this,moduleName:"Raydium_tokenV2"}),this.tradeV2=new ki({scope:this,moduleName:"Raydium_tradeV2"}),this.clmm=new fi({scope:this,moduleName:"Raydium_clmm"}),this.cpmm=new Pi({scope:this,moduleName:"Raydium_cpmm"}),this.utils1216=new Vt({scope:this,moduleName:"Raydium_utils1216"}),this.marketV2=new Po({scope:this,moduleName:"Raydium_marketV2"}),this.ido=new ho({scope:this,moduleName:"Raydium_ido"}),this.launchpad=new Ci({scope:this,moduleName:"Raydium_lauchpad"}),this.availability={};let l=new Date().getTime();this.apiData={},s&&(this._chainTime={fetched:l,value:{chainTime:i||Date.now()-s,offset:s}})}static async load(e){var c;let t=dp({cluster:"mainnet",owner:null,apiRequestInterval:3e5,apiRequestTimeout:1e4},e),{cluster:n,apiRequestTimeout:o,logCount:r,logRequests:i,urlConfigs:s}=t,u=new Yi({cluster:n,timeout:o,urlConfigs:s,logCount:r,logRequests:i}),a=new Wr(W(v({},t),{api:u}));return await a.fetchAvailabilityStatus((c=e.disableFeatureCheck)!=null?c:!0),e.disableLoadToken||await a.token.load({type:e.jupTokenType}),a}get owner(){return this._owner}get ownerPubKey(){if(!this._owner)throw new Error(Hi);return this._owner.publicKey}setOwner(e){return this._owner=e?new ht(e):void 0,this.account.resetTokenAccounts(),this}get connection(){if(!this._connection)throw new Error(iu);return this._connection}setConnection(e){return this._connection=e,this}get signAllTransactions(){return this._signAllTransactions}setSignAllTransactions(e){return this._signAllTransactions=e,this}checkOwner(){if(!this.owner)throw console.error(Hi),new Error(Hi)}isCacheInvalidate(e){return new Date().getTime()-e>this._apiCacheTime}async fetchChainTime(){try{let e=await this.api.getChainTimeOffset();this._chainTime={fetched:Date.now(),value:{chainTime:Date.now()+e.offset*1e3,offset:e.offset*1e3}}}catch{this._chainTime=void 0}}async fetchV3TokenList(e){if(this.apiData.tokenList&&!this.isCacheInvalidate(this.apiData.tokenList.fetched)&&!e)return this.apiData.tokenList.data;try{let t=await this.api.getTokenList(),n={fetched:Date.now(),data:t};return this.apiData.tokenList=n,n.data}catch(t){return console.error(t),{mintList:[],blacklist:[],whiteList:[]}}}async fetchJupTokenList(e){if(this.cluster==="devnet")return[];let t=this.apiData.jupTokenList;if(t&&!this.isCacheInvalidate(t.fetched)&&!e)return t.data;try{let n=await this.api.getJupTokenList();return this.apiData.jupTokenList={fetched:Date.now(),data:n.map(o=>W(v({},o),{mintAuthority:o.mint_authority||void 0,freezeAuthority:o.freeze_authority||void 0}))},this.apiData.jupTokenList.data}catch(n){return console.error(n),[]}}get chainTimeData(){var e;return(e=this._chainTime)==null?void 0:e.value}async chainTimeOffset(){var e;return this._chainTime&&Date.now()-this._chainTime.fetched<=1e3*60*5?this._chainTime.value.offset:(await this.fetchChainTime(),((e=this._chainTime)==null?void 0:e.value.offset)||0)}async currentBlockChainTime(){var e;return this._chainTime&&Date.now()-this._chainTime.fetched<=1e3*60*5?this._chainTime.value.chainTime:(await this.fetchChainTime(),((e=this._chainTime)==null?void 0:e.value.chainTime)||Date.now())}async fetchEpochInfo(){return this._epochInfo&&Date.now()-this._epochInfo.fetched<=1e3*30?this._epochInfo.value:(this._epochInfo={fetched:Date.now(),value:await this.connection.getEpochInfo()},this._epochInfo.value)}async fetchAvailabilityStatus(e){if(e)return{};try{let t=await this.api.fetchAvailabilityStatus(),n=t.all===!1;return this.availability={all:t.all,swap:n?!1:t.swap,createConcentratedPosition:n?!1:t.createConcentratedPosition,addConcentratedPosition:n?!1:t.addConcentratedPosition,addStandardPosition:n?!1:t.addStandardPosition,removeConcentratedPosition:n?!1:t.removeConcentratedPosition,removeStandardPosition:n?!1:t.removeStandardPosition,addFarm:n?!1:t.addFarm,removeFarm:n?!1:t.removeFarm},t}catch{return{}}}};export{Wr as Raydium};
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
//# sourceMappingURL=raydium.mjs.map