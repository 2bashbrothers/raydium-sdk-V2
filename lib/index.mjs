var lm=Object.defineProperty,mm=Object.defineProperties;var dm=Object.getOwnPropertyDescriptors;var ir=Object.getOwnPropertySymbols;var Cu=Object.prototype.hasOwnProperty,Ru=Object.prototype.propertyIsEnumerable;var Ku=(s,e,t)=>e in s?lm(s,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):s[e]=t,N=(s,e)=>{for(var t in e||(e={}))Cu.call(e,t)&&Ku(s,t,e[t]);if(ir)for(var t of ir(e))Ru.call(e,t)&&Ku(s,t,e[t]);return s},q=(s,e)=>mm(s,dm(e));var qe=(s,e)=>{var t={};for(var n in s)Cu.call(s,n)&&e.indexOf(n)<0&&(t[n]=s[n]);if(s!=null&&ir)for(var n of ir(s))e.indexOf(n)<0&&Ru.call(s,n)&&(t[n]=s[n]);return t};import ic from"axios";import{PublicKey as Nu}from"@solana/web3.js";import{get as ga,set as Lu}from"lodash";var pm=(o=>(o[o.Error=0]="Error",o[o.Warning=1]="Warning",o[o.Info=2]="Info",o[o.Debug=3]="Debug",o))(pm||{}),Aa=class{constructor(e){this.logLevel=e.logLevel!==void 0?e.logLevel:0,this.name=e.name}set level(e){this.logLevel=e}get time(){return Date.now().toString()}get moduleName(){return this.name}isLogLevel(e){return e<=this.logLevel}error(...e){return this.isLogLevel(0)?(console.error(this.time,this.name,"sdk logger error",...e),this):this}logWithError(...e){let t=e.map(n=>typeof n=="object"?JSON.stringify(n):n).join(", ");throw new Error(t)}warning(...e){return this.isLogLevel(1)?(console.warn(this.time,this.name,"sdk logger warning",...e),this):this}info(...e){return this.isLogLevel(2)?(console.info(this.time,this.name,"sdk logger info",...e),this):this}debug(...e){return this.isLogLevel(3)?(console.debug(this.time,this.name,"sdk logger debug",...e),this):this}},Pa={},Ou={};function fe(s){let e=ga(Pa,s);if(!e){let t=ga(Ou,s);e=new Aa({name:s,logLevel:t}),Lu(Pa,s,e)}return e}function wy(s,e){Lu(Ou,s,e);let t=ga(Pa,s);t&&(t.level=e)}import{MINT_SIZE as fm,TOKEN_PROGRAM_ID as ym,getTransferFeeConfig as bm,unpackMint as gm}from"@solana/spl-token";var ka=fe("Raydium_accountInfo_util");async function $t(s,e,t){let{batchRequest:n,commitment:o="confirmed",chunkCount:r=100}=N({batchRequest:!1},t),i=wa(e,r),a=new Array(i.length).fill([]);if(n){let c=i.map(m=>{let p=s._buildArgs([m.map(d=>d.toBase58())],o,"base64");return{methodName:"getMultipleAccounts",args:p}}),u=wa(c,10);a=(await(await Promise.all(u.map(async m=>await s._rpcBatchRequest(m)))).flat()).map(m=>(m.error&&ka.logWithError(`failed to get info for multiple accounts, RPC_ERROR, ${m.error.message}`),m.result.value.map(p=>{if(p){let{data:d,executable:f,lamports:y,owner:b,rentEpoch:g}=p;return d.length!==2&&d[1]!=="base64"&&ka.logWithError("info must be base64 encoded, RPC_ERROR"),{data:Buffer.from(d[0],"base64"),executable:f,lamports:y,owner:new Nu(b),rentEpoch:g}}return null})))}else try{a=await Promise.all(i.map(c=>s.getMultipleAccountsInfo(c,o)))}catch(c){c instanceof Error&&ka.logWithError(`failed to get info for multiple accounts, RPC_ERROR, ${c.message}`)}return a.flat()}async function Me(s,e,t){let n=await $t(s,e.map(o=>o.pubkey),t);return e.map((o,r)=>q(N({},o),{accountInfo:n[r]}))}var Am=(n=>(n[n.Uninitialized=0]="Uninitialized",n[n.Mint=1]="Mint",n[n.Account=2]="Account",n))(Am||{}),Ry=1;async function Po({connection:s,mints:e,config:t}){var r,i,a;if(e.length===0)return{};let n=await Me(s,e.map(c=>({pubkey:yt(c)})),t),o={};for(let c of n){if(!c.accountInfo||c.accountInfo.data.length<fm){console.log("invalid mint account",c.pubkey.toBase58());continue}let u=gm(c.pubkey,c.accountInfo,(r=c.accountInfo)==null?void 0:r.owner);o[c.pubkey.toString()]=q(N({},u),{programId:((i=c.accountInfo)==null?void 0:i.owner)||ym,feeConfig:(a=bm(u))!=null?a:void 0})}return o[Nu.default.toBase58()]=o[H.toBase58()],o}import Qe from"bn.js";import Fm from"decimal.js";import Bm from"big.js";import Rn from"bn.js";import Pm from"toformat";var km=Pm,jo=km;import ar from"big.js";import wm from"bn.js";import Tm from"decimal.js-light";import Ho from"bn.js";var Ta=(n=>(n[n.ROUND_DOWN=0]="ROUND_DOWN",n[n.ROUND_HALF_UP=1]="ROUND_HALF_UP",n[n.ROUND_UP=2]="ROUND_UP",n))(Ta||{}),Mu=9007199254740991;function J(s){let e=fe("Raydium_parseBigNumberish");if(s instanceof Ho)return s;if(typeof s=="string"){if(s.match(/^-?[0-9]+$/))return new Ho(s);e.logWithError(`invalid BigNumberish string: ${s}`)}return typeof s=="number"?(s%1&&e.logWithError(`BigNumberish number underflow: ${s}`),(s>=Mu||s<=-Mu)&&e.logWithError(`BigNumberish number overflow: ${s}`),new Ho(String(s))):typeof s=="bigint"?new Ho(s.toString()):(e.error(`invalid BigNumberish value: ${s}`),new Ho(0))}var rr=fe("module/fraction"),ha=jo(ar),Zo=jo(Tm),hm={[0]:Zo.ROUND_DOWN,[1]:Zo.ROUND_HALF_UP,[2]:Zo.ROUND_UP},Im={[0]:ar.roundDown,[1]:ar.roundHalfUp,[2]:ar.roundUp},ce=class{constructor(e,t=new wm(1)){this.numerator=J(e),this.denominator=J(t)}get quotient(){return this.numerator.div(this.denominator)}invert(){return new ce(this.denominator,this.numerator)}add(e){let t=e instanceof ce?e:new ce(J(e));return this.denominator.eq(t.denominator)?new ce(this.numerator.add(t.numerator),this.denominator):new ce(this.numerator.mul(t.denominator).add(t.numerator.mul(this.denominator)),this.denominator.mul(t.denominator))}sub(e){let t=e instanceof ce?e:new ce(J(e));return this.denominator.eq(t.denominator)?new ce(this.numerator.sub(t.numerator),this.denominator):new ce(this.numerator.mul(t.denominator).sub(t.numerator.mul(this.denominator)),this.denominator.mul(t.denominator))}mul(e){let t=e instanceof ce?e:new ce(J(e));return new ce(this.numerator.mul(t.numerator),this.denominator.mul(t.denominator))}div(e){let t=e instanceof ce?e:new ce(J(e));return new ce(this.numerator.mul(t.denominator),this.denominator.mul(t.numerator))}toSignificant(e,t={groupSeparator:""},n=1){Number.isInteger(e)||rr.logWithError(`${e} is not an integer.`),e<=0&&rr.logWithError(`${e} is not positive.`),Zo.set({precision:e+1,rounding:hm[n]});let o=new Zo(this.numerator.toString()).div(this.denominator.toString()).toSignificantDigits(e);return o.toFormat(o.decimalPlaces(),t)}toFixed(e,t={groupSeparator:""},n=1){return Number.isInteger(e)||rr.logWithError(`${e} is not an integer.`),e<0&&rr.logWithError(`${e} is negative.`),ha.DP=e,ha.RM=Im[n]||1,new ha(this.numerator.toString()).div(this.denominator.toString()).toFormat(e,t)}isZero(){return this.numerator.isZero()}};var xm=fe("Raydium_amount"),sr=jo(Bm);function vu(s,e){let t="0",n="0";if(s.includes(".")){let o=s.split(".");o.length===2?([t,n]=o,n=n.padEnd(e,"0")):xm.logWithError(`invalid number string, num: ${s}`)}else t=s;return[t,n.slice(0,e)||n]}var he=class extends ce{constructor(t,n,o=!0,r){let i=new Rn(0),a=Yn.pow(new Rn(t.decimals));if(o)i=J(n);else{let c=new Rn(0),u=new Rn(0);if(typeof n=="string"||typeof n=="number"||typeof n=="bigint"){let[l,m]=vu(n.toString(),t.decimals);c=J(l),u=J(m)}c=c.mul(a),i=c.add(u)}super(i,a);this.logger=fe(r||"TokenAmount"),this.token=t}get raw(){return this.numerator}isZero(){return this.raw.isZero()}gt(t){return this.token.equals(t.token)||this.logger.logWithError("gt token not equals"),this.raw.gt(t.raw)}lt(t){return this.token.equals(t.token)||this.logger.logWithError("lt token not equals"),this.raw.lt(t.raw)}add(t){return this.token.equals(t.token)||this.logger.logWithError("add token not equals"),new he(this.token,this.raw.add(t.raw))}subtract(t){return this.token.equals(t.token)||this.logger.logWithError("sub token not equals"),new he(this.token,this.raw.sub(t.raw))}toSignificant(t=this.token.decimals,n,o=0){return super.toSignificant(t,n,o)}toFixed(t=this.token.decimals,n,o=0){return t>this.token.decimals&&this.logger.logWithError("decimals overflow"),super.toFixed(t,n,o)}toExact(t={groupSeparator:""}){return sr.DP=this.token.decimals,new sr(this.numerator.toString()).div(this.denominator.toString()).toFormat(t)}},Qn=class extends ce{constructor(t,n,o=!0,r){let i=new Rn(0),a=Yn.pow(new Rn(t.decimals));if(o)i=J(n);else{let c=new Rn(0),u=new Rn(0);if(typeof n=="string"||typeof n=="number"||typeof n=="bigint"){let[l,m]=vu(n.toString(),t.decimals);c=J(l),u=J(m)}c=c.mul(a),i=c.add(u)}super(i,a);this.logger=fe(r||"TokenAmount"),this.currency=t}get raw(){return this.numerator}isZero(){return this.raw.isZero()}gt(t){return this.currency.equals(t.currency)||this.logger.logWithError("gt currency not equals"),this.raw.gt(t.raw)}lt(t){return this.currency.equals(t.currency)||this.logger.logWithError("lt currency not equals"),this.raw.lt(t.raw)}add(t){return this.currency.equals(t.currency)||this.logger.logWithError("add currency not equals"),new Qn(this.currency,this.raw.add(t.raw))}sub(t){return this.currency.equals(t.currency)||this.logger.logWithError("sub currency not equals"),new Qn(this.currency,this.raw.sub(t.raw))}toSignificant(t=this.currency.decimals,n,o=0){return super.toSignificant(t,n,o)}toFixed(t=this.currency.decimals,n,o=0){return t>this.currency.decimals&&this.logger.logWithError("decimals overflow"),super.toFixed(t,n,o)}toExact(t={groupSeparator:""}){return sr.DP=this.currency.decimals,new sr(this.numerator.toString()).div(this.denominator.toString()).toFormat(t)}};import{PublicKey as Sm}from"@solana/web3.js";import{TOKEN_PROGRAM_ID as Fu}from"@solana/spl-token";var cn={chainId:101,address:Sm.default.toBase58(),programId:Fu.toBase58(),decimals:9,symbol:"SOL",name:"solana",logoURI:"https://img-v1.raydium.io/icon/So11111111111111111111111111111111111111112.png",tags:[],priority:2,type:"raydium",extensions:{coingeckoId:"solana"}},at={chainId:101,address:"So11111111111111111111111111111111111111112",programId:Fu.toBase58(),decimals:9,symbol:"WSOL",name:"Wrapped SOL",logoURI:"https://img-v1.raydium.io/icon/So11111111111111111111111111111111111111112.png",tags:[],priority:2,type:"raydium",extensions:{coingeckoId:"solana"}};import{PublicKey as Ka}from"@solana/web3.js";import{PublicKey as De,SystemProgram as Vu,SYSVAR_RENT_PUBKEY as Km}from"@solana/web3.js";import{TOKEN_PROGRAM_ID as Cm}from"@solana/spl-token";function A({pubkey:s,isSigner:e=!1,isWritable:t=!0}){return{pubkey:s,isWritable:t,isSigner:e}}var Ia=[A({pubkey:Cm,isWritable:!1}),A({pubkey:Vu.programId,isWritable:!1}),A({pubkey:Km,isWritable:!1})];function Ba({publicKey:s,transformSol:e}){let t=xa(s.toString());if(t instanceof De)return e&&t.equals(st)?H:t;if(e&&t.toString()===st.toBase58())return H;if(typeof t=="string"){if(t===De.default.toBase58())return De.default;try{return new De(t)}catch{throw new Error("invalid public key")}}throw new Error("invalid public key")}function xa(s){try{return new De(s)}catch{return s}}var ur=new De("MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr"),ln=new De("MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr"),tt=new De("SysvarRent111111111111111111111111111111111"),Sa=new De("SysvarC1ock11111111111111111111111111111111"),Jt=new De("metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s"),cr=new De("Sysvar1nstructions1111111111111111111111111"),lr=Vu.programId,ub=new De("4k3Dyjzvzp8eMZWUXbBCjEvwSkkk59S5iCNLY3QrkX6R"),cb=new De("Ea5SjE2Y6yvCeW5dYTn7PYMuW5ikXkvbGdcmSnXeaLjS"),lb=new De("SRMuApVNdxXokk5GT7XD5cUUgXMBCoAz2LHeuAoKWRt"),mb=new De("EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v"),db=new De("Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB"),pb=new De("mSoLzYCxHdYgdzU16g5QSh3i5K3z3KZK7ytfqcJm7So"),fb=new De("7dHbWXmci3dT8UFYWYZweBLXgycu7Y3iL6trKn1Y7ARj"),yb=new De("USDH1SM1ojwWUga67PGrgFWUHibbjqMvuMaDkRJTgkX"),bb=new De("NRVwhjBQiUPYtfDT5zRBVJajzFQHaBUNtC7SNVvqRFa"),gb=new De("ANAxByE6G2WjFp7A4NqtWYXb3mgruyzZYg3spfxe6Lbo"),Ab=new De("7vfCXTUXx5WJV5JADk17DUJ4ksgau7utNKj4b963voxs"),H=new De("So11111111111111111111111111111111111111112"),st=De.default;function yt(s){return Ba({publicKey:s,transformSol:!0})}var Ca=class{constructor({mint:e,decimals:t,symbol:n,name:o,skipMint:r=!1,isToken2022:i=!1}){if(e===st.toBase58()||e instanceof Ka&&st.equals(e)){this.decimals=at.decimals,this.symbol=at.symbol,this.name=at.name,this.mint=new Ka(at.address),this.isToken2022=!1;return}this.decimals=t,this.symbol=n||e.toString().substring(0,6),this.name=o||e.toString().substring(0,6),this.mint=r?Ka.default:Ba({publicKey:e}),this.isToken2022=i}equals(e){return this===e?!0:this.mint.equals(e.mint)}},Se=Ca;Se.WSOL=new Ca(q(N({},at),{mint:at.address}));var Ra=class{constructor({decimals:e,symbol:t="UNKNOWN",name:n="UNKNOWN"}){this.decimals=e,this.symbol=t,this.name=n}equals(e){return this===e}},$o=Ra;$o.SOL=new Ra(cn);function Sb(s,e){return s instanceof Se&&e instanceof Se?s.equals(e):s instanceof Se||e instanceof Se?!1:s===e}import Rm from"bn.js";var _u=new ce(new Rm(100)),ze=class extends ce{toSignificant(e=5,t,n){return this.mul(_u).toSignificant(e,t,n)}toFixed(e=2,t,n){return this.mul(_u).toFixed(e,t,n)}};var Lm=fe("Raydium_price"),ut=class extends ce{constructor(t){let{baseToken:n,quoteToken:o,numerator:r,denominator:i}=t;super(r,i);this.baseToken=n,this.quoteToken=o,this.scalar=new ce(La(n.decimals),La(o.decimals))}get raw(){return new ce(this.numerator,this.denominator)}get adjusted(){return super.mul(this.scalar)}invert(){return new ut({baseToken:this.quoteToken,quoteToken:this.baseToken,denominator:this.numerator,numerator:this.denominator})}mul(t){this.quoteToken!==t.baseToken&&Lm.logWithError("mul token not equals");let n=super.mul(t);return new ut({baseToken:this.baseToken,quoteToken:t.quoteToken,denominator:n.denominator,numerator:n.numerator})}toSignificant(t=this.quoteToken.decimals,n,o){return this.adjusted.toSignificant(t,n,o)}toFixed(t=this.quoteToken.decimals,n,o){return this.adjusted.toFixed(t,n,o)}};function $e(s){if(s instanceof ze)return new ce(s.numerator,s.denominator);if(s instanceof ut)return s.adjusted;if(s instanceof he)try{return $e(s.toExact())}catch{return new ce(Je)}if(s instanceof ce)return s;let e=String(s),t=jn(e);return new ce(t.numerator,t.denominator)}function Yb(s){var n;if(s instanceof ze)return{fr:new ce(s.numerator,s.denominator)};if(s instanceof ut)return{fr:s.adjusted};if(s instanceof he)return{fr:$e(s.toExact()),decimals:s.token.decimals};if(s instanceof ce)return{fr:s};let e=String(s),t=jn(e);return{fr:new ce(t.numerator,t.denominator),decimals:(n=t.dec)==null?void 0:n.length}}function jb(s,e){if(s==null||e==null)return!1;let t=$e(s),n=$e(e);return t.sub(n).numerator,t.sub(n).numerator.lt(Je)}function Om(s,e){if(s==null||e==null)return!1;let t=$e(s),n=$e(e);return t.sub(n).numerator.gt(Je)}function Hb(s,e){if(s==null||e==null)return!1;let t=$e(s),n=$e(e);return t.sub(n).numerator.lte(Je)}function Zb(s,e){if(s==null||e==null)return!1;let t=$e(s),n=$e(e);return t.sub(n).numerator.gte(Je)}function Nm(s,e){if(s==null||e==null)return!1;let t=$e(s),n=$e(e);return t.sub(n).numerator.eq(Je)}function $b(s,e){if(s==null||e==null)return;let t=$e(s),n=$e(e);try{return t.div(n)}catch{return t}}function Jb(s,e){if(s==null||e==null)return;let t=$e(s),n=$e(e);return t.sub(n)}function eg(s){return s==null?!1:!Nm(s,0)}function tg(s,e){return Om(e,s)?e:s}function Oa(s,e){if(s==null||e==null)return;let t=$e(s),n=$e(e);return t.mul(n)}function ng(s,e){if(s==null||e==null)return;let t=$e(s),n=$e(e);return t.add(n)}import{PublicKey as Mm}from"@solana/web3.js";import vm from"bn.js";async function Eu(s){new Promise(e=>setTimeout(e,s))}function ug(){return new Date().getTime()}function Na(s){return typeof s=="object"&&s!==null&&![Se,he,Mm,ce,vm,ut,ze].some(e=>typeof e=="object"&&s instanceof e)}function Fe(s){return typeof s=="string"?xa(s):Array.isArray(s)?s.map(e=>Fe(e)):Na(s)?Object.fromEntries(Object.entries(s).map(([e,t])=>[e,Fe(t)])):s}var Je=new Qe(0),qu=new Qe(1),wg=new Qe(2),Tg=new Qe(3),hg=new Qe(5),Yn=new Qe(10),Ig=new Qe(100),Bg=new Qe(1e3),xg=new Qe(1e4);function La(s){return Yn.pow(J(s))}function jn(s){var a;if(s===void 0)return{denominator:"1",numerator:"0"};if(s instanceof Qe)return{numerator:s.toString(),denominator:"1"};if(s instanceof ce)return{denominator:s.denominator.toString(),numerator:s.numerator.toString()};let e=String(s),[,t="",n="",o=""]=(a=e.replace(",","").match(/(-?)(\d*)\.?(\d*)/))!=null?a:[],r="1"+"0".repeat(o.length),i=t+(n==="0"?"":n)+o||"0";return{denominator:r,numerator:i,sign:t,int:n,dec:o}}function mr(s,e){let t=s.divmod(e);return t.mod.isZero()?t.div:t.div.isNeg()?t.div.isubn(1):t.div.iaddn(1)}function Vm(s){var n;let[,e="",t=""]=(n=s.toFixed(2).match(/(-?)(\d*)\.?(\d*)/))!=null?n:[];return`${e}${t}`}function _m(s,e=0){return s instanceof Qe?s:new Qe(Vm(Uu(s).mul(Yn.pow(new Qe(String(e))))))}function Uu(s){if(s instanceof ze)return new ce(s.numerator,s.denominator);if(s instanceof ut)return s.adjusted;if(s instanceof he)try{return Uu(s.toExact())}catch{return new ce(Je)}if(s instanceof ce)return s;let e=String(s),t=jn(e);return new ce(t.numerator,t.denominator)}function dr(s,e,t){return s.mul(e).add(t).sub(new Qe(1)).div(t)}function Ma(s,e,t){return s.mul(e).div(t)}function Sg(s,e){let{numerator:t,denominator:n}=jn(s);return new ze(new Qe(t),new Qe(n).mul(e!=null&&e.alreadyDecimaled?new Qe(100):new Qe(1)))}function Kg(s){let{token:e,numberPrice:t,decimalDone:n}=s,o=new Se({mint:"",decimals:6,symbol:"usd",name:"usd",skipMint:!0}),{numerator:r,denominator:i}=jn(t),a=n?new Qe(r).mul(Yn.pow(new Qe(e.decimals))):r,c=new Qe(i).mul(Yn.pow(new Qe(o.decimals)));return new ut({baseToken:o,denominator:c.toString(),quoteToken:new Se(q(N({},e),{skipMint:!0,mint:""})),numerator:a.toString()})}function Du(s){let e=new $o({decimals:6,symbol:"usd",name:"usd"}),t=_m(Oa(s,10**e.decimals));return new Qn(e,t)}function Cg(s,e){return Du(!e||!s?0:Oa(s,e))}function Em(s){if(s==null)return;let{numerator:e,denominator:t}=jn(s.toString());return new ce(e,t)}function Dm(s){return s instanceof Fm}function Wu(s){return Dm(s)?Em(s):Array.isArray(s)?s.map(e=>Wu(e)):Na(s)?Object.fromEntries(Object.entries(s).map(([e,t])=>[e,Wu(t)])):s}var Gu=s=>typeof s=="number",Xu=s=>s?new Date(s):new Date,Wm=s=>Xu(s).getTime();function zu(s,e,t){let n=Gu(e)?e*((t==null?void 0:t.unit)==="s"?1e3:1):e;return new Date(s).getTime()<=n}function Qu(s,e,t){let n=Gu(e)?e*((t==null?void 0:t.unit)==="s"?1e3:1):e;return new Date(s).getTime()>n}function Lg(s,e){let n=Wm(s)+(e.days?e.days*24*60*60*1e3:0)+(e.hours?e.hours*60*60*1e3:0)+(e.minutes?e.minutes*60*1e3:0)+(e.seconds?e.seconds*1e3:0)+(e.milliseconds?e.milliseconds:0);return Xu(n)}function wa(s,e=1,t=[]){let n=[...s];if(e<=0)return t;for(;n.length;)t.push(n.splice(0,e));return t}function Ng(s,...e){return s.filter(t=>e.every(n=>n.includes(t)))}function Mg(s,...e){return s.filter(t=>e.every(n=>!n.includes(t)))}function vg(s){return[...new Set(s)]}var en=class{constructor(e){this._owner=e}get publicKey(){return en.isKeyPair(this._owner)?this._owner.publicKey:this._owner}get signer(){return en.isKeyPair(this._owner)?this._owner:void 0}get isKeyPair(){return en.isKeyPair(this._owner)}get isPublicKey(){return en.isPublicKey(this._owner)}static isKeyPair(e){return e.secretKey!==void 0}static isPublicKey(e){return!en.isKeyPair(e)}};import{PublicKey as zm}from"@solana/web3.js";import{TOKEN_PROGRAM_ID as Qm}from"@solana/spl-token";import{ComputeBudgetProgram as Yu,Keypair as ju,PublicKey as Hu,Transaction as fr,TransactionMessage as qm,VersionedTransaction as va}from"@solana/web3.js";var bn=(t=>(t[t.V0=0]="V0",t[t.LEGACY=1]="LEGACY",t))(bn||{}),U={CreateAccount:"CreateAccount",InitAccount:"InitAccount",CreateATA:"CreateATA",CloseAccount:"CloseAccount",TransferAmount:"TransferAmount",InitMint:"InitMint",MintTo:"MintTo",InitMarket:"InitMarket",Util1216OwnerClaim:"Util1216OwnerClaim",SetComputeUnitPrice:"SetComputeUnitPrice",SetComputeUnitLimit:"SetComputeUnitLimit",ClmmCreatePool:"ClmmCreatePool",ClmmOpenPosition:"ClmmOpenPosition",ClmmIncreasePosition:"ClmmIncreasePosition",ClmmDecreasePosition:"ClmmDecreasePosition",ClmmClosePosition:"ClmmClosePosition",ClmmSwapBaseIn:"ClmmSwapBaseIn",ClmmSwapBaseOut:"ClmmSwapBaseOut",ClmmInitReward:"ClmmInitReward",ClmmSetReward:"ClmmSetReward",ClmmCollectReward:"ClmmCollectReward",ClmmLockPosition:"ClmmLockPosition",ClmmHarvestLockPosition:"ClmmHarvestLockPosition",AmmV4Swap:"AmmV4Swap",AmmV4AddLiquidity:"AmmV4AddLiquidity",AmmV4RemoveLiquidity:"AmmV4RemoveLiquidity",AmmV4SimulatePoolInfo:"AmmV4SimulatePoolInfo",AmmV4SwapBaseIn:"AmmV4SwapBaseIn",AmmV4SwapBaseOut:"AmmV4SwapBaseOut",AmmV4CreatePool:"AmmV4CreatePool",AmmV4InitPool:"AmmV4InitPool",AmmV5AddLiquidity:"AmmV5AddLiquidity",AmmV5RemoveLiquidity:"AmmV5RemoveLiquidity",AmmV5SimulatePoolInfo:"AmmV5SimulatePoolInfo",AmmV5SwapBaseIn:"AmmV5SwapBaseIn",AmmV5SwapBaseOut:"AmmV5SwapBaseOut",RouteSwap:"RouteSwap",RouteSwap1:"RouteSwap1",RouteSwap2:"RouteSwap2",FarmV3Deposit:"FarmV3Deposit",FarmV3Withdraw:"FarmV3Withdraw",FarmV3CreateLedger:"FarmV3CreateLedger",FarmV4Withdraw:"FarmV4Withdraw",FarmV5Deposit:"FarmV5Deposit",FarmV5Withdraw:"FarmV5Withdraw",FarmV5CreateLedger:"FarmV5CreateLedger",FarmV6Deposit:"FarmV6Deposit",FarmV6Withdraw:"FarmV6Withdraw",FarmV6Create:"FarmV6Create",FarmV6Restart:"FarmV6Restart",FarmV6CreatorAddReward:"FarmV6CreatorAddReward",FarmV6CreatorWithdraw:"FarmV6CreatorWithdraw",CpmmCreatePool:"CpmmCreatePool",CpmmAddLiquidity:"CpmmAddLiquidity",CpmmWithdrawLiquidity:"CpmmWithdrawLiquidity",CpmmSwapBaseIn:"CpmmSwapBaseIn",CpmmSwapBaseOut:"CpmmSwapBaseOut",CpmmLockLp:"CpmmLockLp",CpmmCollectLockFee:"CpmmCollectLockFee",TransferTip:"TransferTip"};import{TOKEN_PROGRAM_ID as Um}from"@solana/spl-token";var gn=fe("Raydium_txUtil"),Zu=1644;function yr(s){let e=[],t=[];return s.microLamports&&(e.push(Yu.setComputeUnitPrice({microLamports:s.microLamports})),t.push(U.SetComputeUnitPrice)),s.units&&(e.push(Yu.setComputeUnitLimit({units:s.units})),t.push(U.SetComputeUnitLimit)),{instructions:e,instructionTypes:t}}async function ko(s,e){var n,o;let t=e!=null?e:"confirmed";return(o=await((n=s.getLatestBlockhash)==null?void 0:n.call(s,{commitment:t})))==null?void 0:o.blockhash}async function br(s,e){return s.getSignatureStatuses([e]),new Promise((t,n)=>{let o=setTimeout(n,6e4);s.onSignature(e,r=>{if(clearTimeout(o),!r.err){t("");return}n(Object.assign(r.err,{txId:e}))},"confirmed")})}function gr(s,e){s.length<1&&gn.logWithError(`no instructions provided: ${s.toString()}`),e.length<1&&gn.logWithError(`no signers provided:, ${e.toString()}`);let t=new fr;t.recentBlockhash="11111111111111111111111111111111",t.feePayer=e[0],t.add(...s);try{return Buffer.from(t.serialize({verifySignatures:!1})).toString("base64").length<Zu}catch{return!1}}async function $u(s,e,t,n=!0){let o=new Hu("RaydiumSimuLateTransaction11111111111111111"),r=[],i=new fr;i.feePayer=o;for(let u of e)gr([...i.instructions,u],[o])||(r.push(i),i=new fr,i.feePayer=o),i.add(u);i.instructions.length>0&&r.push(i);let a=[];try{if(a=await Gm(s,r,n),a.find(u=>u.err!==null))throw Error("rpc simulateTransaction error")}catch(u){u instanceof Error&&gn.logWithError("failed to simulate for instructions","RPC_ERROR",{message:u.message})}let c=[];for(let u of a)if(gn.debug("simulate result:",u),u.logs){let l=u.logs.filter(m=>m&&m.includes(t));gn.debug("filteredLog:",c),l.length||gn.logWithError("simulate log not match keyword","keyword",t),c.push(...l)}return c}function Ju(s,e){let t=s.match(/{["\w:,]+}/g);return!t||t.length!==1?gn.logWithError(`simulate log fail to match json, keyword: ${e}`):t[0]}function An(s,e){let n=new RegExp(`"${e}":(\\d+)`,"g").exec(s);return!n||n.length!==2?gn.logWithError(`simulate log fail to match key", key: ${e}`):n[1]}function ne(s,e){let[t,n]=Hu.findProgramAddressSync(s,e);return{publicKey:t,nonce:n}}async function Gm(s,e,t){let n=[];if(t){let o=await s.getLatestBlockhash(),r=[];for(let u of e){u.recentBlockhash=o.blockhash,u.lastValidBlockHeight=o.lastValidBlockHeight;let m=u._compile().serialize(),d=u._serialize(m).toString("base64");r.push(d)}let i=r.map(u=>{let l=s._buildArgs([u],void 0,"base64");return{methodName:"simulateTransaction",args:l}}),a=[],c=20;for(let u=0;u<Math.ceil(i.length/c);u++)a.push(i.slice(u*c,(u+1)*c));n=await(await Promise.all(a.map(async u=>(await s._rpcBatchRequest(u)).map(l=>l.result.value)))).flat()}else try{n=await Promise.all(e.map(async o=>await(await s.simulateTransaction(o)).value))}catch(o){o instanceof Error&&gn.logWithError("failed to get info for multiple accounts","RPC_ERROR",{message:o.message})}return n}function Jo({instructions:s,payer:e,signers:t}){return gr(s,[e,...t])}function ei({instructions:s,payer:e,lookupTableAddressAccount:t,recentBlockhash:n=ju.generate().publicKey.toString()}){let r=new qm({payerKey:e,recentBlockhash:n,instructions:s}).compileToV0Message(Object.values(t!=null?t:{}));try{return Buffer.from(new va(r).serialize()).toString("base64").length<Zu}catch{return!1}}var pr={time:0,data:void 0};async function Yg(s){if(!pr.data||(Date.now()-pr.time)/1e3>30){let e=await s.getEpochInfo();return pr={time:Date.now(),data:e},e}else return pr.data}var ec=s=>Buffer.isBuffer(s)?s:s instanceof Uint8Array?Buffer.from(s.buffer,s.byteOffset,s.byteLength):Buffer.from(s),Xm=s=>{let e=s.serialize({requireAllSignatures:!1,verifySignatures:!1});s instanceof va&&(e=ec(e));try{return e instanceof Buffer?e.toString("base64"):Buffer.from(e).toString("base64")}catch{return e.toString("base64")}};function Hn(s){let e=[];return s.forEach(t=>{t instanceof fr&&(t.recentBlockhash||(t.recentBlockhash=Um.toBase58()),t.feePayer||(t.feePayer=ju.generate().publicKey)),e.push(Xm(t))}),console.log("simulate tx string:",e),e}function jg(s){let e=s.serialize({requireAllSignatures:!1,verifySignatures:!1});return s instanceof va&&(e=ec(e)),e.toString("base64")}function j(s,e,t){return ne([s.toBuffer(),(t!=null?t:Qm).toBuffer(),e.toBuffer()],new zm("ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL"))}import{PublicKey as oe}from"@solana/web3.js";var Fa=new oe("EhhTKczWMGQt46ynNeRX1WfeagwwJd7ufHvCDjRxjo5Q"),Va=new oe("CBuCnLe26faBpcBP2fktp4rp8abpcAnTWft6ZrP5Q4T"),_a=new oe("9KEPoZmtHUrBbhWN1v1KWLMkkvwY6WLtAVUCPRtRjP4z"),wo=new oe("FarmqiPv5eAj3j1GMdMCMUGXqPUvmquZtMy86QH6rzhG"),Ym=new oe("CLaimxFqjHzgTJtAGHU47NPhg6qrc5sCnpC4tBLyABQS"),Ea=new oe("srmqPvymJeFKQ4zGQed1GFppgkRHL9kaELCbyksJtPX"),Ar=new oe("9xQeWvG816bUx9EPjHmaT23yvVM2ZWbrrpZb9PusVFin"),ti=new oe("675kPX9MHTjS2zt1qfr1NYHuzeLXfQM9H24wFSUt1Mp8"),jm=new oe("5quBtoiQqxF9Jv6KYKctB59NT3gtJD2Y65kdnB1Uev3h"),Pr=new oe("CDSr3ssLcRB6XYPJwAfFt18MZvEZp4LjHcvzBVZ45duo"),Ln=new oe("CAMMCzo5YL8w4VFF8KVHrK22GGUsp5VTaW7grrKgrWqK"),To=new oe("LockrWmn6K5twhz3y9w1dQERbmgSaRkfnTeTKbpofwE"),ni=new oe("kN1kEznaF5Xbd8LYuqtEFcxzWSBk5Fv6ygX6SqEGJVy"),On=new oe("CDSr3ssLcRB6XYPJwAfFt18MZvEZp4LjHcvzBVZ45duo"),Hm=new oe("routeUGWgWzqBWFcrCfv8tritsqukccJPu3q5GPP3xS"),Da=new oe("7YttLkHDoNj9wyDur5pM1ejNaAvT9X4eqaYcHQqtj2G5"),Zm=new oe("6FJon3QE27qgPVggARueB22hLvoh22VzJpXv4rBEoSLF"),$m=new oe("CC12se5To1CdEuw7fDS27B7Geo5jJyL7t5UK2B44NgiH"),Jm=new oe("9HzJyW1qZsEiSfMUf6L2jo3CcTKAyBmSyKdwQeYisHrC"),ed=new oe("DropEU8AvevN3UrXWXTMuz3rqnMczQVNjq3kcSdW2SQi"),oi=new oe("CPMMoo8L3F4NbTegBCKVNunggL7H1ZpdTHKxQB5qKP1C"),Wa=new oe("GpMZbSM2GgvTKHJirzeGfMFoaZ8UR2X7F4v8vHTvxFbL"),td=new oe("DNXgeM9EiiaAbaWvwjHj9fQQLAX5ZsfHyvmYUNRAdNC8"),ii=new oe("LockrWmn6K5twhz3y9w1dQERbmgSaRkfnTeTKbpofwE"),ri=new oe("3f7GcQFG397GAaEnv51zR6tsTVihYRydnydDD1cXekxH"),ct=new oe("LanMV9sAd7wArD4vJFi2qDdfnVhFxYSUg6eADduJ3uj"),nd=new oe("WLHv2UAZm6z4KyaaELi5pjdbJh6RESMva1Rnn8pJVVh"),nA=new oe("DRay6fNdQ5J82H7xV6uq2aV3mNrUZ1J4PgSKsWgptcm6"),oA=new oe("5xqNaZXX5eUi4p5HU4oz9i5QnwRNT2y6oN7yyn4qENeq"),od=new oe("4Bu96XjU84XjPDSpveTVf6LYGCkfW5FK7SNkREWcEfV4"),id=new oe("6s1xP3hpbAfFoNtUNF8mfHsjr2Bd97JxFJRWLbL6aHuX"),ai={IDO_PROGRAM_ID_V1:Zm,IDO_PROGRAM_ID_V2:$m,IDO_PROGRAM_ID_V3:Jm,IDO_PROGRAM_ID_V4:ed},wt={AMM_V4:ti,AMM_STABLE:jm,CLMM_PROGRAM_ID:Ln,CLMM_LOCK_PROGRAM_ID:To,CLMM_LOCK_AUTH_ID:ni,FARM_PROGRAM_ID_V3:Fa,FARM_PROGRAM_ID_V4:Va,FARM_PROGRAM_ID_V5:_a,FARM_PROGRAM_ID_V6:wo,OPEN_BOOK_PROGRAM:Ea,SERUM_PROGRAM_ID_V3:Ar,UTIL1216:Ym,Router:Hm,CREATE_CPMM_POOL_PROGRAM:oi,CREATE_CPMM_POOL_AUTH:Wa,CREATE_CPMM_POOL_FEE_ACC:td,LOCK_CPMM_PROGRAM:ii,LOCK_CPMM_AUTH:ri,LAUNCHPAD_PROGRAM:ct,LAUNCHPAD_AUTH:nd,LAUNCHPAD_PLATFORM:od,LAUNCHPAD_CONFIG:id,FEE_DESTINATION_ID:Da,MODEL_DATA_PUBKEY:On},Pn={OPEN_BOOK_PROGRAM:new oe("EoTcMgcDRTJVZDMZWBoU6rhYHZfkNTVEAfz3uUJRcYGj"),SERUM_PROGRAM_ID_V3:new oe("Ray1111111111111111111111111111111111111111"),AMM_V4:new oe("DRaya7Kj3aMWQSy19kSjvmuwq9docCHofyP9kanQGaav"),AMM_STABLE:new oe("DRayDdXc1NZQ9C3hRWmoSf8zK4iapgMnjdNZWrfwsP8m"),CLMM_PROGRAM_ID:new oe("DRayAUgENGQBKVaX8owNhgzkEDyoHTGVEGHVJT1E9pfH"),CLMM_LOCK_PROGRAM_ID:new oe("DRay25Usp3YJAi7beckgpGUC7mGJ2cR1AVPxhYfwVCUX"),CLMM_LOCK_AUTH_ID:new oe("6Aoh8h2Lw2m5UGxYR8AdAL87jTWYeKoxM52mJRzfYwN"),CREATE_CPMM_POOL_PROGRAM:new oe("DRaycpLY18LhpbydsBWbVJtxpNv9oXPgjRSfpF2bWpYb"),CREATE_CPMM_POOL_AUTH:new oe("CXniRufdq5xL8t8jZAPxsPZDpuudwuJSPWnbcD5Y5Nxq"),CREATE_CPMM_POOL_FEE_ACC:new oe("3oE58BKVt8KuYkGxx8zBojugnymWmBiyafWgMrnb6eYy"),LOCK_CPMM_PROGRAM:new oe("DRay25Usp3YJAi7beckgpGUC7mGJ2cR1AVPxhYfwVCUX"),LOCK_CPMM_AUTH:new oe("7qWVV8UY2bRJfDLP4s37YzBPKUkVB46DStYJBpYbQzu3"),UTIL1216:oe.default,Router:new oe("DRaybByLpbUL57LJARs3j8BitTxVfzBg351EaMr5UTCd"),FARM_PROGRAM_ID_V3:new oe("DRayWyrLmEW5KEeqs8kdTMMaBabapqagaBC7KWpGtJeZ"),FARM_PROGRAM_ID_V4:new oe("Ray1111111111111111111111111111111111111111"),FARM_PROGRAM_ID_V5:new oe("DRayiCGSZgku1GTK6rXD6mVDdingXy6APAH1R6R5L2LC"),FARM_PROGRAM_ID_V6:new oe("DRayzbYakXs45ELHkzH6vC3fuhQqTAnv5A68gdFuvZyZ"),LAUNCHPAD_PROGRAM:new oe("DRay6fNdQ5J82H7xV6uq2aV3mNrUZ1J4PgSKsWgptcm6"),LAUNCHPAD_AUTH:new oe("5xqNaZXX5eUi4p5HU4oz9i5QnwRNT2y6oN7yyn4qENeq"),LAUNCHPAD_PLATFORM:new oe("2Jx4KTDrVSdWNazuGpcA8n3ZLTRGGBDxAWhuKe2Xcj2a"),LAUNCHPAD_CONFIG:new oe("7ZR4zD7PYfY2XxoG1Gxcy2EgEeGYrpxrwzPuwdUBssEt"),FEE_DESTINATION_ID:new oe("9y8ENuuZ3b19quffx9hQvRVygG5ky6snHfRvGpuSfeJy"),MODEL_DATA_PUBKEY:new oe("Ray1111111111111111111111111111111111111111")};import we from"bn.js";var Tt=1e4;function aA(s,e,t,n){if(e===void 0)return{amount:s,fee:void 0,expirationTime:void 0};let o=t.epoch<e.newerTransferFee.epoch?e.olderTransferFee:e.newerTransferFee,r=new we(o.maximumFee.toString()),i=t.epoch<e.newerTransferFee.epoch?(Number(e.newerTransferFee.epoch)*t.slotsInEpoch-t.absoluteSlot)*400/1e3:void 0;if(n)if(o.transferFeeBasisPoints===Tt){let a=new we(o.maximumFee.toString());return{amount:s.add(a),fee:a,expirationTime:i}}else{let a=Kt(s.mul(new we(Tt)),new we(Tt-o.transferFeeBasisPoints)),c=new we(o.maximumFee.toString()),u=a.sub(s).gt(c)?s.add(c):a,l=Kt(u.mul(new we(o.transferFeeBasisPoints)),new we(Tt)),m=l.gt(r)?r:l;return{amount:u,fee:m,expirationTime:i}}else{let a=Kt(s.mul(new we(o.transferFeeBasisPoints)),new we(Tt)),c=a.gt(r)?r:a;return{amount:s,fee:c,expirationTime:i}}}function Be(s,e,t,n){if(e===void 0)return{amount:s,fee:void 0,expirationTime:void 0};let o=q(N({},e),{olderTransferFee:{epoch:BigInt(e.olderTransferFee.epoch),maximumFee:BigInt(e.olderTransferFee.maximumFee),transferFeeBasisPoints:e.olderTransferFee.transferFeeBasisPoints},newerTransferFee:{epoch:BigInt(e.newerTransferFee.epoch),maximumFee:BigInt(e.newerTransferFee.maximumFee),transferFeeBasisPoints:e.newerTransferFee.transferFeeBasisPoints}}),r=t.epoch<o.newerTransferFee.epoch?o.olderTransferFee:o.newerTransferFee,i=new we(r.maximumFee.toString()),a=t.epoch<o.newerTransferFee.epoch?(Number(o.newerTransferFee.epoch)*t.slotsInEpoch-t.absoluteSlot)*400/1e3:void 0;if(n)if(r.transferFeeBasisPoints===Tt){let c=new we(r.maximumFee.toString());return{amount:s.add(c),fee:c,expirationTime:a}}else{let c=Kt(s.mul(new we(Tt)),new we(Tt-r.transferFeeBasisPoints)),u=new we(r.maximumFee.toString()),l=c.sub(s).gt(u)?s.add(u):c,m=Kt(l.mul(new we(r.transferFeeBasisPoints)),new we(Tt)),p=m.gt(i)?i:m;return{amount:l,fee:p,expirationTime:a}}else{let c=Kt(s.mul(new we(r.transferFeeBasisPoints)),new we(Tt)),u=c.gt(i)?i:c;return{amount:s,fee:u,expirationTime:a}}}function tn(s,e){return s===void 0?e:e===void 0?s:Math.min(s,e)}function Kt(s,e){let{div:t,mod:n}=s.divmod(e);return n.gt(new we(0))?t.add(new we(1)):t}function Zn(s,e){if(s.isZero())return new we(0);let t=s.div(e);return t.isZero()?new we(1):s.mod(e).gt(new we(0))?t.add(new we(1)):t}function qa(s,e,t){if(e===void 0)return{amount:s,fee:void 0,expirationTime:void 0};let n=Math.floor(t/432e3),o=n<e.newerTransferFee.epoch?e.olderTransferFee:e.newerTransferFee,r=new we(o.maximumFee.toString()),i=n<e.newerTransferFee.epoch?(Number(e.newerTransferFee.epoch)*432e3-t)*400/1e3:void 0,a=Kt(s.mul(new we(o.transferFeeBasisPoints)),new we(Tt)),c=a.gt(r)?r:a;return{amount:s,fee:c,expirationTime:i}}function Ua(s,e,t){if(e===void 0)return{amount:s,fee:void 0,expirationTime:void 0};let n=Math.floor(t/432e3),o=n<e.newerTransferFee.epoch?e.olderTransferFee:e.newerTransferFee,r=new we(o.maximumFee.toString()),i=n<e.newerTransferFee.epoch?(Number(e.newerTransferFee.epoch)*432e3-t)*400/1e3:void 0;if(o.transferFeeBasisPoints===Tt){let a=new we(o.maximumFee.toString());return{amount:s.add(a),fee:a,expirationTime:i}}else{let a=Kt(s.mul(new we(Tt)),new we(Tt-o.transferFeeBasisPoints)),c=new we(o.maximumFee.toString()),u=a.sub(s).gt(c)?s.add(c):a,l=Kt(u.mul(new we(o.transferFeeBasisPoints)),new we(Tt)),m=l.gt(r)?r:l;return{amount:u,fee:m,expirationTime:i}}}import{PublicKey as Ga,AddressLookupTableAccount as Io}from"@solana/web3.js";async function Xa({connection:s,address:e,cluster:t="mainnet"}){let n=await $t(s,[...new Set(e.map(r=>r.toString()))].map(r=>new Ga(r))),o={};for(let r=0;r<e.length;r++){let i=n[r],a=e[r];if(!i)continue;let c=new Io({key:a,state:Io.deserialize(i.data)});o[a.toString()]=c,t==="devnet"?ho[a.toString()]=c:kr[a.toString()]=c}return o}var kr={AcL1Vo8oy1ULiavEcjSUcwfBSForXMudcZvDZy5nzJkU:new Io({key:new Ga("AcL1Vo8oy1ULiavEcjSUcwfBSForXMudcZvDZy5nzJkU"),state:Io.deserialize(Buffer.from("AQAAAP//////////I1rcEwAAAAAvAQYwun9CU6c5Ikm2pAj+D9IEnCOR45nK+SFTGSdpd6J6AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAbd9uHXZaGT2cvhRs7reawctIXtX1s3kTqM9YV+/wCpBt324e51j94YQl285GzN2rYa/E2DuQ0n/r35KNihi/wFSlNQ+F3IgtYUpVZyeIopbd8eq6vQpgZ4iEky9O72oAVKU1qZKSEGTSTocWDaOHx8NbXdvJK7geQfqEBBBUSNBqfVFxksXFEhjMlMPUrxf1ja7gibof1E49vZigAAAAAGp9UXGMd0yShWY5hpHV62i164o5tLbVxzVVshAAAAAIyXJY9OJInxuz0QKRSODYMLWhOZ2v8QhASOe9jb6fhZC3BlsePRfEU4nVJ/awTDzVi4bHMaoP21SbbRvAP4KUbIScv+6Yw2LHF/6K0ZjUPibbSWXCirYPGuuVl7zT789IUPLW4CpHr4JNCatp3ELXDLKMv6JJ+37le50lbBJ2LvBkX2T9y7AHdNGviJAqQNtlDUDCnauQRWybsLji6nPM8Qkw5asQRvCdB3MbX6IEBwytOrpM32l4jQygKG9TKgR0vZScQ2AsM/IHeQ7RajUkyhuZdc8SGiqQz/7H34torNR/Wir3sl0ruUrVxJWEZfUg+QLNAxxODdBi53/OP7Ioil1cqeBM9dtZC3FLov4yyxWRM/wcGStyJX/QfTnLBAHqkqWotPKVlShCVQqpP9W5W1rOao65IMk5QuQ2kMIOxzDMKAy2vjGSxQODgBz0QwGA+eP4ZjIjrIAQaXENv31QfLlOdXSRCkaybRniDHF4C8YcwhcvsqrOVuTP4B2Na+9wLdtrB31uz2rtlFI5kahdsnp/d1SrASDInYCtTYtdoke4kX+hoKWcEWM4Tle8pTUkUVv4BxS6fje/EzKBE4Qu/YsA/yfEEFGcr8Z57VKDw8uQzpiru7g4lvjnfapW62W030syevD8k07SGoxUHiuT/ai7gAHWWhDsVmg/C63ajgpkH7Sn3GdutArDTfyqOkdqv4/IPC/EFFy7mGkfDd2C57N5a/4jC+BbmJy7wQaSEZr0CQU88lPtUxIVvzGjC95b8Ooss2TqmkrayGKofkPMGQn7Ux+9lfwBSNfxwH8NgbpqC/7LNlV4I7nCvsXf3p+ohQk9NrAJb2KAFpUqEIJ9ZBV7BYDzHF/ORKYlgtvPnXjudZQ6CEo5OzUDaNIomTCCsvhD16TxJjsbgne1kGnQPCFSoaxUbq2V1bPMFQ3VYP6wDZ9bKStCFKx9A3tNbwZFC5ZGAN83MFK7XoTy+OmmcFEr6rLOjfSuTfPvHJkSVxW6Qllwkl67XcBi5v00u2gQsbu+38sp+rd5pA/LvyWj4P94ZGZwc1tE2P88xekCLcAwZGb+UhFzL/7K26csOb57yM5bvF9xJrLEObOkAAAAAn+HWRkdcPKyFFMnVwEoD7vnD0jCKFIU1sImubYCxNTSVzsKpaQX+fzNxrLAI3L14JQnJx/D6Uk2LADIHGqnGELzjEbkBDAlaM77NkXMPfqXNLSveCkWI7UEgNs31WEWB6XHSYI/v5DklHOb4QTtDOR804PVbi3fjloZeLR2F8d4FuZmMMO7ck3Fnkn2zEMG5gOmqsygb6PjTitArVl52NhcSznTxVnguaIJxiZkAnurDmn3MWR0PC2GLghp2KJqHCc6QQ85odeIjFHKOlRlJyeSXVJmL8vb1UgOzsbJPVP8p6zM4M3C1Sd7uWIHP33G42AP2Zg8ucn/n6meQjjD266JgCWdxZD6PXs9CsnIeL7SSG0/6lGb9xfP0ZcWkCXB/3hjxHYVXjra/GPOeXGk0fLLKjCbk+mgs2w6d2oCwimBipTzuoZ30GiI8ij8VRzD5CzMWtu2m21eDBIfjGAEo4pQeNNonKcqzV/cleX8ySZLOHsz8PtBCrLqF+VkLm9hOzIT+6i/nIf6keR4GWKMOD4AvqfpjHoD4DuhBpz8P28+DxkGrDXXr/nr20x291VPvcTU/b+b+o2kC9G0kcXeTlLjU6a2TQXWlZ4gBUdBl1jgT7mObSTpLblNiXZsLkbmVXZwvFKXua5cUKlWed/w30skmEUraTuQqtqr5fHZPW9n57EmeTif6LjHL2YJFZkQU+TrJmFzqzmF4/b8OwrPQAprl8mX3q4LUIdAS/a+11B6DWD1Xk2++Sn94dLC4xjkO4Wtlw8c4XuzciVbepHOmnoWzVu/0y3KCrLCSfQxQ3br8DJCoVzhgtPsS2nZZjsBGIZgnU0QpMv+2MnRsnKwdp1VsrCX84j/qvaZn4WhKunippgTbN2EUs0tPTP55Qfgj+nKmjtWW5IYs72FrEwJKYoNfsmqaF4o5pf4v9zgPwVwY/5I4XJKUL2L25m9kAQcW/K+H1RTFEUoj8Z4ajpOmAB/dG0COmCphVMW2CCMvnxhcGiSgPnpDuWu6qiJ7NG7ye5kvHgefgqPLeicspNJ5EpL3XiRNLM2tmJLI1awAwOyd6iHv0dCkMYRKaa6rcaZeYwmKCkckm0kM2JNmnmmAaBQQ7mwmIM0IMxX4f5W6j9PqZWcJxF7r17T/lQBAmcjoupRiJifbnXCNUv9GhpRF19WcBdeKbivRJVlGop6I2RS6lGImJ9udcI1S/0aGlEXX1ZwF14puK9ElWUainojZFYVHLHD6dIP2ESjqBzg3ol1/wB7+/ylGwd9LS7wSZ2A630CJSVKwH47K9P4bB8PEQP8BwjMFa7xQHOqZFP1XqaQ==","base64"))})},ho={},za=async s=>{let e="EFhMuDw1PKEuckuFRW9PavNfTH4LKP5uKHgyXDmWpFCq";if(ho[e])return ho;let t=new Ga(e),n=await s.getAccountInfo(t);return n&&(ho[e]=new Io({key:t,state:Io.deserialize(n.data)})),ho};import{PublicKey as Bo,sendAndConfirmTransaction as Qa,SystemProgram as rd,Transaction as si,TransactionMessage as ui,VersionedTransaction as ci}from"@solana/web3.js";import ad from"axios";var wr=2e3,Tr=class{constructor(e){this.instructions=[];this.endInstructions=[];this.lookupTableAddress=[];this.signers=[];this.instructionTypes=[];this.endInstructionTypes=[];this.connection=e.connection,this.feePayer=e.feePayer,this.signAllTransactions=e.signAllTransactions,this.owner=e.owner,this.cluster=e.cluster,this.blockhashCommitment=e.blockhashCommitment,this.loopMultiTxStatus=!!e.loopMultiTxStatus}get AllTxData(){return{instructions:this.instructions,endInstructions:this.endInstructions,signers:this.signers,instructionTypes:this.instructionTypes,endInstructionTypes:this.endInstructionTypes,lookupTableAddress:this.lookupTableAddress}}get allInstructions(){return[...this.instructions,...this.endInstructions]}async getComputeBudgetConfig(){var n;let e=(await ad.get(`https://solanacompass.com/api/fees?cacheFreshTime=${3e5}`)).data,{avg:t}=(n=e==null?void 0:e[15])!=null?n:{};if(!!t)return{units:6e5,microLamports:Math.min(Math.ceil(t*1e6/6e5),25e3)}}addCustomComputeBudget(e){if(e){let{instructions:t,instructionTypes:n}=yr(e);return this.instructions.unshift(...t),this.instructionTypes.unshift(...n),!0}return!1}addTipInstruction(e){var t;return e?(this.endInstructions.push(rd.transfer({fromPubkey:(t=e.feePayer)!=null?t:this.feePayer,toPubkey:new Bo(e.address),lamports:BigInt(e.amount.toString())})),this.endInstructionTypes.push(U.TransferTip),!0):!1}async calComputeBudget({config:e,defaultIns:t}){try{let n=e||await this.getComputeBudgetConfig();if(this.addCustomComputeBudget(n))return;t&&this.instructions.unshift(...t)}catch{t&&this.instructions.unshift(...t)}}addInstruction({instructions:e=[],endInstructions:t=[],signers:n=[],instructionTypes:o=[],endInstructionTypes:r=[],lookupTableAddress:i=[]}){return this.instructions.push(...e),this.endInstructions.push(...t),this.signers.push(...n),this.instructionTypes.push(...o),this.endInstructionTypes.push(...r),this.lookupTableAddress.push(...i.filter(a=>a!==Bo.default.toString())),this}async versionBuild({txVersion:e,extInfo:t}){return e===0?await this.buildV0(N({},t||{})):this.build(t)}build(e){var n;let t=new si;return this.allInstructions.length&&t.add(...this.allInstructions),t.feePayer=this.feePayer,((n=this.owner)==null?void 0:n.signer)&&!this.signers.some(o=>o.publicKey.equals(this.owner.publicKey))&&this.signers.push(this.owner.signer),{builder:this,transaction:t,signers:this.signers,instructionTypes:[...this.instructionTypes,...this.endInstructionTypes],execute:async o=>{var l;let{recentBlockHash:r,skipPreflight:i=!0,sendAndConfirm:a,notSendToRpc:c}=o||{},u=r!=null?r:await ko(this.connection,this.blockhashCommitment);if(t.recentBlockhash=u,this.signers.length&&t.sign(...this.signers),Hn([t]),(l=this.owner)!=null&&l.isKeyPair)return{txId:a?await Qa(this.connection,t,this.signers.find(p=>p.publicKey.equals(this.owner.publicKey))?this.signers:[...this.signers,this.owner.signer],{skipPreflight:i}):await this.connection.sendRawTransaction(t.serialize(),{skipPreflight:i}),signedTx:t};if(this.signAllTransactions){let m=await this.signAllTransactions([t]);if(this.signers.length)for(let p of m)try{p.sign(...this.signers)}catch{}return{txId:c?"":await this.connection.sendRawTransaction(m[0].serialize(),{skipPreflight:i}),signedTx:m[0]}}throw new Error("please provide owner in keypair format or signAllTransactions function")},extInfo:e||{}}}buildMultiTx(e){var u;let{extraPreBuildData:t=[],extInfo:n}=e,{transaction:o}=this.build(n),r=t.filter(l=>l.transaction.instructions.length>0),i=[o,...r.map(l=>l.transaction)],a=[this.signers,...r.map(l=>l.signers)],c=[...this.instructionTypes,...r.map(l=>l.instructionTypes).flat()];return(u=this.owner)!=null&&u.signer&&a.forEach(l=>{l.some(m=>m.publicKey.equals(this.owner.publicKey))||this.signers.push(this.owner.signer)}),{builder:this,transactions:i,signers:a,instructionTypes:c,execute:async l=>{var g;let{sequentially:m,onTxUpdate:p,skipTxCount:d=0,recentBlockHash:f,skipPreflight:y=!0}=l||{},b=f!=null?f:await ko(this.connection,this.blockhashCommitment);if((g=this.owner)!=null&&g.isKeyPair){if(m){let P=[],h=0;for(let I of i){if(++h,h<=d)continue;let T=await Qa(this.connection,I,this.signers.find(w=>w.publicKey.equals(this.owner.publicKey))?this.signers:[...this.signers,this.owner.signer],{skipPreflight:y});P.push(T)}return{txIds:P,signedTxs:i}}return{txIds:await await Promise.all(i.map(async P=>(P.recentBlockhash=b,await this.connection.sendRawTransaction(P.serialize(),{skipPreflight:y})))),signedTxs:i}}if(this.signAllTransactions){let P=i.map((I,T)=>(I.recentBlockhash=b,a[T].length&&I.sign(...a[T]),I));Hn(P);let h=await this.signAllTransactions(P);if(m){let I=0,T=[],w=async()=>{if(!h[I])return;let x=await this.connection.sendRawTransaction(h[I].serialize(),{skipPreflight:y});T.push({txId:x,status:"sent",signedTx:h[I]}),p==null||p([...T]),I++;let S=!1,K=null,B=null,C=M=>{K!==null&&clearInterval(K),B!==null&&this.connection.removeSignatureListener(B);let V=T.findIndex(R=>R.txId===x);if(V>-1){if(T[V].status==="error"||T[V].status==="success")return;T[V].status=M.err?"error":"success"}p==null||p([...T]),M.err||w()};this.loopMultiTxStatus&&(K=setInterval(async()=>{var M;if(S){clearInterval(K);return}try{let V=await this.connection.getTransaction(x,{commitment:"confirmed",maxSupportedTransactionVersion:0});V&&(S=!0,clearInterval(K),C({err:((M=V.meta)==null?void 0:M.err)||null}),console.log("tx status from getTransaction:",x))}catch(V){S=!0,clearInterval(K),console.error("getTransaction timeout:",V,x)}},wr)),B=this.connection.onSignature(x,M=>{if(S){this.connection.removeSignatureListener(B);return}S=!0,C(M)},"confirmed"),this.connection.getSignatureStatus(x)};return await w(),{txIds:T.map(x=>x.txId),signedTxs:h}}else{let I=[];for(let T=0;T<h.length;T+=1){let w=await this.connection.sendRawTransaction(h[T].serialize(),{skipPreflight:y});I.push(w)}return{txIds:I,signedTxs:h}}}throw new Error("please provide owner in keypair format or signAllTransactions function")},extInfo:n||{}}}async versionMultiBuild({extraPreBuildData:e,txVersion:t,extInfo:n}){return t===0?await this.buildV0MultiTx({extraPreBuildData:e,buildProps:n||{}}):this.buildMultiTx({extraPreBuildData:e,extInfo:n})}async buildV0(e){var y;let f=e||{},{lookupTableCache:t={},lookupTableAddress:n=[],forerunCreate:o,recentBlockhash:r}=f,i=qe(f,["lookupTableCache","lookupTableAddress","forerunCreate","recentBlockhash"]),a=N(N({},this.cluster==="devnet"?await za(this.connection):kr),t),c=Array.from(new Set([...n,...this.lookupTableAddress])),u=[];for(let b of c)a[b]===void 0&&u.push(new Bo(b));let l=await Xa({connection:this.connection,address:u});for(let[b,g]of Object.entries(l))a[b]=g;let m=o?Bo.default.toBase58():r!=null?r:await ko(this.connection,this.blockhashCommitment),p=new ui({payerKey:this.feePayer,recentBlockhash:m,instructions:[...this.allInstructions]}).compileToV0Message(Object.values(a));((y=this.owner)==null?void 0:y.signer)&&!this.signers.some(b=>b.publicKey.equals(this.owner.publicKey))&&this.signers.push(this.owner.signer);let d=new ci(p);return d.sign(this.signers),{builder:this,transaction:d,signers:this.signers,instructionTypes:[...this.instructionTypes,...this.endInstructionTypes],execute:async b=>{var I;let{skipPreflight:g=!0,sendAndConfirm:P,notSendToRpc:h}=b||{};if(Hn([d]),(I=this.owner)!=null&&I.isKeyPair){let T=await this.connection.sendTransaction(d,{skipPreflight:g});return P&&await br(this.connection,T),{txId:T,signedTx:d}}if(this.signAllTransactions){let T=await this.signAllTransactions([d]);if(this.signers.length)for(let w of T)try{w.sign(this.signers)}catch{}return{txId:h?"":await this.connection.sendTransaction(T[0],{skipPreflight:g}),signedTx:T[0]}}throw new Error("please provide owner in keypair format or signAllTransactions function")},extInfo:i||{}}}async buildV0MultiTx(e){var u;let{extraPreBuildData:t=[],buildProps:n}=e,{transaction:o}=await this.buildV0(n),r=t.filter(l=>l.builder.instructions.length>0),i=[o,...r.map(l=>l.transaction)],a=[this.signers,...r.map(l=>l.signers)],c=[...this.instructionTypes,...r.map(l=>l.instructionTypes).flat()];return(u=this.owner)!=null&&u.signer&&a.forEach(l=>{l.some(m=>m.publicKey.equals(this.owner.publicKey))||this.signers.push(this.owner.signer)}),i.forEach(async(l,m)=>{l.sign(a[m])}),{builder:this,transactions:i,signers:a,instructionTypes:c,buildProps:n,execute:async l=>{var y;let{sequentially:m,onTxUpdate:p,recentBlockHash:d,skipPreflight:f=!0}=l||{};if(d&&i.forEach(b=>b.message.recentBlockhash=d),Hn(i),(y=this.owner)!=null&&y.isKeyPair){if(m){let b=[];for(let g of i){let P=await this.connection.sendTransaction(g,{skipPreflight:f});await br(this.connection,P),b.push(P)}return{txIds:b,signedTxs:i}}return{txIds:await Promise.all(i.map(async b=>await this.connection.sendTransaction(b,{skipPreflight:f}))),signedTxs:i}}if(this.signAllTransactions){let b=await this.signAllTransactions(i);if(m){let g=0,P=[],h=async()=>{if(!b[g])return;let I=await this.connection.sendTransaction(b[g],{skipPreflight:f});P.push({txId:I,status:"sent",signedTx:b[g]}),p==null||p([...P]),g++;let T=!1,w=null,x=null,S=K=>{w!==null&&clearInterval(w),x!==null&&this.connection.removeSignatureListener(x);let B=P.findIndex(C=>C.txId===I);if(B>-1){if(P[B].status==="error"||P[B].status==="success")return;P[B].status=K.err?"error":"success"}p==null||p([...P]),K.err||h()};this.loopMultiTxStatus&&(w=setInterval(async()=>{var K;if(T){clearInterval(w);return}try{let B=await this.connection.getTransaction(I,{commitment:"confirmed",maxSupportedTransactionVersion:0});B&&(T=!0,clearInterval(w),S({err:((K=B.meta)==null?void 0:K.err)||null}),console.log("tx status from getTransaction:",I))}catch(B){T=!0,clearInterval(w),console.error("getTransaction timeout:",B,I)}},wr)),x=this.connection.onSignature(I,K=>{if(T){this.connection.removeSignatureListener(x);return}T=!0,S(K)},"confirmed"),this.connection.getSignatureStatus(I)};return h(),{txIds:[],signedTxs:b}}else{let g=[];for(let P=0;P<b.length;P+=1){let h=await this.connection.sendTransaction(b[P],{skipPreflight:f});g.push(h)}return{txIds:g,signedTxs:b}}}throw new Error("please provide owner in keypair format or signAllTransactions function")},extInfo:n||{}}}async sizeCheckBuild(e){var p;let m=e||{},{splitIns:t=[],computeBudgetConfig:n}=m,o=qe(m,["splitIns","computeBudgetConfig"]),r=n?yr(n):{instructions:[],instructionTypes:[]},i=this.signers.reduce((d,f)=>q(N({},d),{[f.publicKey.toBase58()]:f}),{}),a=[],c=[],u=[],l=0;if(this.allInstructions.forEach(d=>{let f=[...u,d],y=n?[...r.instructions,...f]:f,g=[...new Set(f.map(P=>P.keys.filter(h=>h.isSigner).map(h=>h.pubkey.toString())).flat()).values()].map(P=>new Bo(P));if(d!==t[l]&&u.length<12&&(Jo({instructions:y,payer:this.feePayer,signers:g})||Jo({instructions:f,payer:this.feePayer,signers:g})))u.push(d);else{if(u.length===0)throw Error("item ins too big");l+=d===t[l]?1:0,Jo({instructions:n?[...r.instructions,...u]:[...u],payer:this.feePayer,signers:g})?a.push(new si().add(...r.instructions,...u)):a.push(new si().add(...u)),c.push(Array.from(new Set(u.map(P=>P.keys.filter(h=>h.isSigner).map(h=>h.pubkey.toString())).flat())).map(P=>i[P]).filter(P=>P!==void 0)),u=[d]}}),u.length>0){let f=[...new Set(u.map(y=>y.keys.filter(b=>b.isSigner).map(b=>b.pubkey.toString())).flat()).values()].map(y=>i[y]).filter(y=>y!==void 0);Jo({instructions:n?[...r.instructions,...u]:[...u],payer:this.feePayer,signers:f.map(y=>y.publicKey)})?a.push(new si().add(...r.instructions,...u)):a.push(new si().add(...u)),c.push(f)}return a.forEach(d=>d.feePayer=this.feePayer),(p=this.owner)!=null&&p.signer&&c.forEach(d=>{d.some(f=>f.publicKey.equals(this.owner.publicKey))||d.push(this.owner.signer)}),{builder:this,transactions:a,signers:c,instructionTypes:this.instructionTypes,execute:async d=>{var I;let{sequentially:f,onTxUpdate:y,skipTxCount:b=0,recentBlockHash:g,skipPreflight:P=!0}=d||{},h=g!=null?g:await ko(this.connection,this.blockhashCommitment);if(a.forEach(async(T,w)=>{T.recentBlockhash=h,c[w].length&&T.sign(...c[w])}),Hn(a),(I=this.owner)!=null&&I.isKeyPair){if(f){let T=0,w=[];for(let x of a){if(++T,T<=b){w.push("tx skipped");continue}let S=await Qa(this.connection,x,this.signers.find(K=>K.publicKey.equals(this.owner.publicKey))?this.signers:[...this.signers,this.owner.signer],{skipPreflight:P});w.push(S)}return{txIds:w,signedTxs:a}}return{txIds:await Promise.all(a.map(async T=>await this.connection.sendRawTransaction(T.serialize(),{skipPreflight:P}))),signedTxs:a}}if(this.signAllTransactions){let T=await this.signAllTransactions(a.slice(b,a.length)),w=[...a.slice(0,b),...T];if(f){let x=0,S=[],K=async()=>{if(!w[x])return;x<b&&(S.push({txId:"",status:"success",signedTx:w[x]}),y==null||y([...S]),x++,K());let B=await this.connection.sendRawTransaction(w[x].serialize(),{skipPreflight:P});S.push({txId:B,status:"sent",signedTx:w[x]}),y==null||y([...S]),x++;let C=!1,M=null,V=null,R=L=>{M!==null&&clearInterval(M),V!==null&&this.connection.removeSignatureListener(V);let W=S.findIndex(z=>z.txId===B);if(W>-1){if(S[W].status==="error"||S[W].status==="success")return;S[W].status=L.err?"error":"success"}y==null||y([...S]),L.err||K()};this.loopMultiTxStatus&&(M=setInterval(async()=>{var L;if(C){clearInterval(M);return}try{let W=await this.connection.getTransaction(B,{commitment:"confirmed",maxSupportedTransactionVersion:0});W&&(C=!0,clearInterval(M),R({err:((L=W.meta)==null?void 0:L.err)||null}),console.log("tx status from getTransaction:",B))}catch(W){C=!0,clearInterval(M),console.error("getTransaction timeout:",W,B)}},wr)),V=this.connection.onSignature(B,L=>{if(C){this.connection.removeSignatureListener(V);return}C=!0,R(L)},"confirmed"),this.connection.getSignatureStatus(B)};return await K(),{txIds:S.map(B=>B.txId),signedTxs:w}}else{let x=[];for(let S=0;S<w.length;S+=1){let K=await this.connection.sendRawTransaction(w[S].serialize(),{skipPreflight:P});x.push(K)}return{txIds:x,signedTxs:w}}}throw new Error("please provide owner in keypair format or signAllTransactions function")},extInfo:o||{}}}async sizeCheckBuildV0(e){var h;let P=e||{},{computeBudgetConfig:t,splitIns:n=[],lookupTableCache:o={},lookupTableAddress:r=[]}=P,i=qe(P,["computeBudgetConfig","splitIns","lookupTableCache","lookupTableAddress"]),a=N(N({},this.cluster==="devnet"?await za(this.connection):kr),o),c=Array.from(new Set([...this.lookupTableAddress,...r])),u=[];for(let I of c)a[I]===void 0&&u.push(new Bo(I));let l=await Xa({connection:this.connection,address:u});for(let[I,T]of Object.entries(l))a[I]=T;let m=t?yr(t):{instructions:[],instructionTypes:[]},p=await ko(this.connection,this.blockhashCommitment),d=this.signers.reduce((I,T)=>q(N({},I),{[T.publicKey.toBase58()]:T}),{}),f=[],y=[],b=[],g=0;if(this.allInstructions.forEach(I=>{let T=[...b,I],w=t?[...m.instructions,...T]:T;if(I!==n[g]&&b.length<12&&(ei({instructions:w,payer:this.feePayer,lookupTableAddressAccount:a})||ei({instructions:T,payer:this.feePayer,lookupTableAddressAccount:a})))b.push(I);else{if(b.length===0)throw Error("item ins too big");g+=I===n[g]?1:0;let x={};for(let S of[...new Set(c)])a[S]!==void 0&&(x[S]=a[S]);if(t&&ei({instructions:[...m.instructions,...b],payer:this.feePayer,lookupTableAddressAccount:a,recentBlockhash:p})){let S=new ui({payerKey:this.feePayer,recentBlockhash:p,instructions:[...m.instructions,...b]}).compileToV0Message(Object.values(a));f.push(new ci(S))}else{let S=new ui({payerKey:this.feePayer,recentBlockhash:p,instructions:[...b]}).compileToV0Message(Object.values(a));f.push(new ci(S))}y.push(Array.from(new Set(b.map(S=>S.keys.filter(K=>K.isSigner).map(K=>K.pubkey.toString())).flat())).map(S=>d[S]).filter(S=>S!==void 0)),b=[I]}}),b.length>0){let T=[...new Set(b.map(w=>w.keys.filter(x=>x.isSigner).map(x=>x.pubkey.toString())).flat()).values()].map(w=>d[w]).filter(w=>w!==void 0);if(t&&ei({instructions:[...m.instructions,...b],payer:this.feePayer,lookupTableAddressAccount:a,recentBlockhash:p})){let w=new ui({payerKey:this.feePayer,recentBlockhash:p,instructions:[...m.instructions,...b]}).compileToV0Message(Object.values(a));f.push(new ci(w))}else{let w=new ui({payerKey:this.feePayer,recentBlockhash:p,instructions:[...b]}).compileToV0Message(Object.values(a));f.push(new ci(w))}y.push(T)}return(h=this.owner)!=null&&h.signer&&y.forEach(I=>{I.some(T=>T.publicKey.equals(this.owner.publicKey))||I.push(this.owner.signer)}),f.forEach((I,T)=>{I.sign(y[T])}),{builder:this,transactions:f,buildProps:e,signers:y,instructionTypes:this.instructionTypes,execute:async I=>{var B;let{sequentially:T,onTxUpdate:w,skipTxCount:x=0,recentBlockHash:S,skipPreflight:K=!0}=I||{};if(f.map(async(C,M)=>{y[M].length&&C.sign(y[M]),S&&(C.message.recentBlockhash=S)}),Hn(f),(B=this.owner)!=null&&B.isKeyPair){if(T){let C=0,M=[];for(let V of f){if(++C,C<=x){console.log("skip tx: ",C),M.push("tx skipped");continue}let R=await this.connection.sendTransaction(V,{skipPreflight:K});await br(this.connection,R),M.push(R)}return{txIds:M,signedTxs:f}}return{txIds:await Promise.all(f.map(async C=>await this.connection.sendTransaction(C,{skipPreflight:K}))),signedTxs:f}}if(this.signAllTransactions){let C=await this.signAllTransactions(f.slice(x,f.length)),M=[...f.slice(0,x),...C];if(T){let V=0,R=[],L=async()=>{if(!M[V])return;if(V<x){R.push({txId:"",status:"success",signedTx:M[V]}),w==null||w([...R]),V++,L();return}let W=await this.connection.sendTransaction(M[V],{skipPreflight:K});R.push({txId:W,status:"sent",signedTx:M[V]}),w==null||w([...R]),V++;let z=!1,$=null,ae=null,be=le=>{$!==null&&clearInterval($),ae!==null&&this.connection.removeSignatureListener(ae);let pe=R.findIndex(ye=>ye.txId===W);if(pe>-1){if(R[pe].status==="error"||R[pe].status==="success")return;R[pe].status=le.err?"error":"success"}w==null||w([...R]),le.err||L()};this.loopMultiTxStatus&&($=setInterval(async()=>{var le;if(z){clearInterval($);return}try{let pe=await this.connection.getTransaction(W,{commitment:"confirmed",maxSupportedTransactionVersion:0});pe&&(z=!0,clearInterval($),be({err:((le=pe.meta)==null?void 0:le.err)||null}),console.log("tx status from getTransaction:",W))}catch(pe){z=!0,clearInterval($),console.error("getTransaction timeout:",pe,W)}},wr)),ae=this.connection.onSignature(W,le=>{if(z){this.connection.removeSignatureListener(ae);return}z=!0,be(le)},"confirmed"),this.connection.getSignatureStatus(W)};return L(),{txIds:[],signedTxs:M}}else{let V=[];for(let R=0;R<M.length;R+=1){let L=await this.connection.sendTransaction(M[R],{skipPreflight:K});V.push(L)}return{txIds:V,signedTxs:M}}}throw new Error("please provide owner in keypair format or signAllTransactions function")},extInfo:i||{}}}};import sd from"bn.js";var nn=new sd(1e6);var tc=(t=>(t.ALL="all",t.Strict="strict",t))(tc||{}),nc=(i=>(i.All="all",i.Standard="standard",i.Concentrated="concentrated",i.AllFarm="allFarm",i.StandardFarm="standardFarm",i.ConcentratedFarm="concentratedFarm",i))(nc||{});var lt={BASE_HOST:"https://api-v3.raydium.io",OWNER_BASE_HOST:"https://owner-v1.raydium.io",SERVICE_BASE_HOST:"https://service.raydium.io",MONITOR_BASE_HOST:"https://monitor.raydium.io",SERVICE_1_BASE_HOST:"https://service-v1.raydium.io",SEND_TRANSACTION:"/send-transaction",FARM_ARP:"/main/farm/info",FARM_ARP_LINE:"/main/farm-apr-tv",CLMM_CONFIG:"/main/clmm-config",CPMM_CONFIG:"/main/cpmm-config",VERSION:"/main/version",CHECK_AVAILABILITY:"/v3/main/AvailabilityCheckAPI",RPCS:"/main/rpcs",INFO:"/main/info",STAKE_POOLS:"/main/stake-pools",CHAIN_TIME:"/main/chain-time",TOKEN_LIST:"/mint/list",MINT_INFO_ID:"/mint/ids",JUP_TOKEN_LIST:"https://lite-api.jup.ag/tokens/v1/tagged/verified",POOL_LIST:"/pools/info/list",POOL_SEARCH_BY_ID:"/pools/info/ids",POOL_SEARCH_MINT:"/pools/info/mint",POOL_SEARCH_LP:"/pools/info/lps",POOL_KEY_BY_ID:"/pools/key/ids",POOL_LIQUIDITY_LINE:"/pools/line/liquidity",POOL_POSITION_LINE:"/pools/line/position",FARM_INFO:"/farms/info/ids",FARM_LP_INFO:"/farms/info/lp",FARM_KEYS:"/farms/key/ids",OWNER_CREATED_FARM:"/create-pool/{owner}",OWNER_IDO:"/main/ido/{owner}",OWNER_STAKE_FARMS:"/position/stake/{owner}",OWNER_LOCK_POSITION:"/position/clmm-lock/{owner}",IDO_KEYS:"/ido/key/ids",SWAP_HOST:"https://transaction-v1.raydium.io",SWAP_COMPUTE:"/compute/",SWAP_TX:"/transaction/",MINT_PRICE:"/mint/price",MIGRATE_CONFIG:"/main/migrate-lp",PRIORITY_FEE:"/main/auto-fee",CPMM_LOCK:"https://dynamic-ipfs.raydium.io/lock/cpmm/position"},zA=N({},lt);var oc="ray_tab_hash",Ya="ray_req_hash",ud=()=>{if(typeof window===void 0)return"";let s=sessionStorage.getItem(oc);return s||(s=`ray-${Date.now()}`,sessionStorage.setItem(oc,s)),s},hr=async n=>{var o=n,{logCount:s=1e3,removeLastLog:e}=o,t=qe(o,["logCount","removeLastLog"]);if(typeof window===void 0)return new Promise(i=>i());let r=JSON.parse(localStorage.getItem(Ya)||"[]").slice(0,s-1);e&&r.pop(),new Blob([JSON.stringify(t.data)]).size>1024&&(t.data=JSON.stringify(t.data).substring(0,200)+"..."),r.unshift(q(N({},t),{time:Date.now(),session:ud()}));try{localStorage.setItem(Ya,JSON.stringify(r))}catch{if(e){let i=!1,a=JSON.stringify(t.data).substring(0,100);for(r[0].data=a+(a.length>100?"...":"");!i;){r.pop();let c=JSON.stringify(t.data).substring(0,100);r[0].data=c+(c.length>100?"...":"");try{localStorage.setItem(Ya,JSON.stringify(r)),i=!0}catch{i=!1}}return new Promise(c=>c())}return hr(q(N({},t),{logCount:s,removeLastLog:!0}))}};import{TOKEN_2022_PROGRAM_ID as cd,TOKEN_PROGRAM_ID as ld}from"@solana/spl-token";var xo=fe("Raydium_Api"),ja=new Map;async function bP(s,e,t=1e3){let n;for(;n==null;)try{xo.debug(`Request ${s} through endlessRetry`),n=await e()}catch(o){xo.error(`Request ${s} failed, retry after ${t} ms`,o),await Eu(t)}return n}var Ir=class{constructor({cluster:e,timeout:t,logRequests:n,logCount:o,urlConfigs:r}){this.cluster=e,this.urlConfigs=r||{},this.logCount=o||1e3,this.api=ic.create({baseURL:this.urlConfigs.BASE_HOST||lt.BASE_HOST,timeout:t}),this.api.interceptors.request.use(i=>{let{method:a,baseURL:c,url:u}=i;return xo.debug(`${a==null?void 0:a.toUpperCase()} ${c}${u}`),i},i=>(xo.error("Request failed"),Promise.reject(i))),this.api.interceptors.response.use(i=>{let{config:a,data:c,status:u}=i,{method:l,baseURL:m,url:p}=a;return n&&hr({status:u,url:`${m}${p}`,params:a.params,data:c,logCount:this.logCount}),xo.debug(`${l==null?void 0:l.toUpperCase()} ${m}${p}  ${u}`),c},i=>{let{config:a,response:c={}}=i,{status:u}=c,{method:l,baseURL:m,url:p}=a;return n&&hr({status:u,url:`${m}${p}`,params:a.params,data:i.message,logCount:this.logCount}),xo.error(`${l.toUpperCase()} ${m}${p} ${u||i.message}`),Promise.reject(i)})}async getClmmConfigs(){return(await this.api.get(this.urlConfigs.CLMM_CONFIG||lt.CLMM_CONFIG)).data}async getCpmmConfigs(){return(await this.api.get(this.urlConfigs.CPMM_CONFIG||lt.CPMM_CONFIG)).data}async getClmmPoolLines(e){return(await this.api.get(`${this.urlConfigs.POOL_LIQUIDITY_LINE||lt.POOL_LIQUIDITY_LINE}?pool_id=${e}`)).data}async getBlockSlotCountForSecond(e){if(!e)return 2;let n=(await ic.post(e,{id:"getRecentPerformanceSamples",jsonrpc:"2.0",method:"getRecentPerformanceSamples",params:[4]})).result.map(o=>o.numSlots);return n.reduce((o,r)=>o+r,0)/n.length/60}async getChainTimeOffset(){return(await this.api.get(this.urlConfigs.CHAIN_TIME||lt.CHAIN_TIME)).data}async getRpcs(){return this.api.get(this.urlConfigs.RPCS||lt.RPCS)}async getTokenList(){return(await this.api.get(this.urlConfigs.TOKEN_LIST||lt.TOKEN_LIST)).data}async getJupTokenList(){return(await this.api.get("",{baseURL:this.urlConfigs.JUP_TOKEN_LIST||lt.JUP_TOKEN_LIST})).map(t=>q(N({},t),{chainId:101,programId:t.tags.includes("token-2022")?cd.toBase58():ld.toBase58()}))}async getTokenInfo(e){return(await this.api.get((this.urlConfigs.MINT_INFO_ID||lt.MINT_INFO_ID)+`?mints=${e.map(n=>n.toString()).join(",")}`)).data}async getPoolList(e={}){let{type:t="all",sort:n="liquidity",order:o="desc",page:r=0,pageSize:i=100}=e;return(await this.api.get((this.urlConfigs.POOL_LIST||lt.POOL_LIST)+`?poolType=${t}&poolSortField=${n}&sortType=${o}&page=${r}&pageSize=${i}`)).data}async fetchPoolById(e){let{ids:t}=e;return(await this.api.get((this.urlConfigs.POOL_SEARCH_BY_ID||lt.POOL_SEARCH_BY_ID)+`?ids=${t}`)).data}async fetchPoolKeysById(e){let{idList:t}=e,n=[],o=t.filter(i=>ja.has(i)?(n.push(ja.get(i)),!1):!0),r=[];return o.length&&(r=(await this.api.get((this.urlConfigs.POOL_KEY_BY_ID||lt.POOL_KEY_BY_ID)+`?ids=${o.join(",")}`)).data.filter(Boolean),r.forEach(a=>{ja.set(a.id,a)})),n.concat(r)}async fetchPoolByMints(e){let{mint1:t,mint2:n,type:o="all",sort:r="default",order:i="desc",page:a=1}=e,[c,u]=[t&&yt(t).toBase58(),n&&n!=="undefined"?yt(n).toBase58():""],[l,m]=u&&c>u?[u,c]:[c,u];return(await this.api.get((this.urlConfigs.POOL_SEARCH_MINT||lt.POOL_SEARCH_MINT)+`?mint1=${l}&mint2=${m}&poolType=${o}&poolSortField=${r}&sortType=${i}&pageSize=100&page=${a}`)).data}async fetchFarmInfoById(e){let{ids:t}=e;return(await this.api.get((this.urlConfigs.FARM_INFO||lt.FARM_INFO)+`?ids=${t}`)).data}async fetchFarmKeysById(e){let{ids:t}=e;return(await this.api.get((this.urlConfigs.FARM_KEYS||lt.FARM_KEYS)+`?ids=${t}`)).data}async fetchAvailabilityStatus(){return(await this.api.get(this.urlConfigs.CHECK_AVAILABILITY||lt.CHECK_AVAILABILITY)).data}};import{merge as fy}from"lodash";var Br="please provide owner in load() initialization or you can set by calling raydium.setOwner(owner)",rc="please provide connection in load() initialization or set it by raydium.setConnection(connection)";import{PublicKey as Lr,SystemProgram as kp}from"@solana/web3.js";import{AccountLayout as Co,createAssociatedTokenAccountIdempotentInstruction as cs,TOKEN_PROGRAM_ID as Fn,TOKEN_2022_PROGRAM_ID as wp}from"@solana/spl-token";var Ha=(...s)=>s.map(e=>{try{return typeof e=="object"?JSON.stringify(e):e}catch{return e}}).join(", "),Ve=class{constructor({scope:e,moduleName:t}){this.disabled=!1;this.scope=e,this.logger=fe(t)}createTxBuilder(e){return this.scope.checkOwner(),new Tr({connection:this.scope.connection,feePayer:e||this.scope.ownerPubKey,cluster:this.scope.cluster,owner:this.scope.owner,blockhashCommitment:this.scope.blockhashCommitment,loopMultiTxStatus:this.scope.loopMultiTxStatus,api:this.scope.api,signAllTransactions:this.scope.signAllTransactions})}logDebug(...e){this.logger.debug(Ha(e))}logInfo(...e){this.logger.info(Ha(e))}logAndCreateError(...e){let t=Ha(e);throw new Error(t)}checkDisabled(){(this.disabled||!this.scope)&&this.logAndCreateError("module not working")}};import{PublicKey as fp,SystemProgram as yp}from"@solana/web3.js";import bp from"bn.js";import{createCloseAccountInstruction as gp,createInitializeAccountInstruction as Ap,createTransferInstruction as Pp,TOKEN_PROGRAM_ID as Ko}from"@solana/spl-token";import{Keypair as lp,PublicKey as wc}from"@solana/web3.js";import mp from"bn.js";import{TOKEN_PROGRAM_ID as dp}from"@solana/spl-token";function md(s){return s instanceof Uint8Array||s!=null&&typeof s=="object"&&s.constructor.name==="Uint8Array"}function Za(s,...e){if(!md(s))throw new Error("Uint8Array expected");if(e.length>0&&!e.includes(s.length))throw new Error(`Uint8Array expected of length ${e}, not of length=${s.length}`)}function $a(s,e=!0){if(s.destroyed)throw new Error("Hash instance has been destroyed");if(e&&s.finished)throw new Error("Hash#digest() has already been called")}function ac(s,e){Za(s);let t=e.outputLen;if(s.length<t)throw new Error(`digestInto() expects output buffer of length at least ${t}`)}var Sr=s=>new DataView(s.buffer,s.byteOffset,s.byteLength),on=(s,e)=>s<<32-e|s>>>e;var RP=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;function dd(s){if(typeof s!="string")throw new Error(`utf8ToBytes expected string, got ${typeof s}`);return new Uint8Array(new TextEncoder().encode(s))}function Ja(s){return typeof s=="string"&&(s=dd(s)),Za(s),s}var xr=class{clone(){return this._cloneInto()}},LP={}.toString;function sc(s){let e=n=>s().update(Ja(n)).digest(),t=s();return e.outputLen=t.outputLen,e.blockLen=t.blockLen,e.create=()=>s(),e}function pd(s,e,t,n){if(typeof s.setBigUint64=="function")return s.setBigUint64(e,t,n);let o=BigInt(32),r=BigInt(4294967295),i=Number(t>>o&r),a=Number(t&r),c=n?4:0,u=n?0:4;s.setUint32(e+c,i,n),s.setUint32(e+u,a,n)}var uc=(s,e,t)=>s&e^~s&t,cc=(s,e,t)=>s&e^s&t^e&t,Kr=class extends xr{constructor(e,t,n,o){super(),this.blockLen=e,this.outputLen=t,this.padOffset=n,this.isLE=o,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(e),this.view=Sr(this.buffer)}update(e){$a(this);let{view:t,buffer:n,blockLen:o}=this;e=Ja(e);let r=e.length;for(let i=0;i<r;){let a=Math.min(o-this.pos,r-i);if(a===o){let c=Sr(e);for(;o<=r-i;i+=o)this.process(c,i);continue}n.set(e.subarray(i,i+a),this.pos),this.pos+=a,i+=a,this.pos===o&&(this.process(t,0),this.pos=0)}return this.length+=e.length,this.roundClean(),this}digestInto(e){$a(this),ac(e,this),this.finished=!0;let{buffer:t,view:n,blockLen:o,isLE:r}=this,{pos:i}=this;t[i++]=128,this.buffer.subarray(i).fill(0),this.padOffset>o-i&&(this.process(n,0),i=0);for(let m=i;m<o;m++)t[m]=0;pd(n,o-8,BigInt(this.length*8),r),this.process(n,0);let a=Sr(e),c=this.outputLen;if(c%4)throw new Error("_sha2: outputLen should be aligned to 32bit");let u=c/4,l=this.get();if(u>l.length)throw new Error("_sha2: outputLen bigger than state");for(let m=0;m<u;m++)a.setUint32(4*m,l[m],r)}digest(){let{buffer:e,outputLen:t}=this;this.digestInto(e);let n=e.slice(0,t);return this.destroy(),n}_cloneInto(e){e||(e=new this.constructor),e.set(...this.get());let{blockLen:t,buffer:n,length:o,finished:r,destroyed:i,pos:a}=this;return e.length=o,e.pos=a,e.finished=r,e.destroyed=i,o%t&&e.buffer.set(n),e}};var fd=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),Nn=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),Mn=new Uint32Array(64),es=class extends Kr{constructor(){super(64,32,8,!1),this.A=Nn[0]|0,this.B=Nn[1]|0,this.C=Nn[2]|0,this.D=Nn[3]|0,this.E=Nn[4]|0,this.F=Nn[5]|0,this.G=Nn[6]|0,this.H=Nn[7]|0}get(){let{A:e,B:t,C:n,D:o,E:r,F:i,G:a,H:c}=this;return[e,t,n,o,r,i,a,c]}set(e,t,n,o,r,i,a,c){this.A=e|0,this.B=t|0,this.C=n|0,this.D=o|0,this.E=r|0,this.F=i|0,this.G=a|0,this.H=c|0}process(e,t){for(let m=0;m<16;m++,t+=4)Mn[m]=e.getUint32(t,!1);for(let m=16;m<64;m++){let p=Mn[m-15],d=Mn[m-2],f=on(p,7)^on(p,18)^p>>>3,y=on(d,17)^on(d,19)^d>>>10;Mn[m]=y+Mn[m-7]+f+Mn[m-16]|0}let{A:n,B:o,C:r,D:i,E:a,F:c,G:u,H:l}=this;for(let m=0;m<64;m++){let p=on(a,6)^on(a,11)^on(a,25),d=l+p+uc(a,c,u)+fd[m]+Mn[m]|0,y=(on(n,2)^on(n,13)^on(n,22))+cc(n,o,r)|0;l=u,u=c,c=a,a=i+d|0,i=r,r=o,o=n,n=d+y|0}n=n+this.A|0,o=o+this.B|0,r=r+this.C|0,i=i+this.D|0,a=a+this.E|0,c=c+this.F|0,u=u+this.G|0,l=l+this.H|0,this.set(n,o,r,i,a,c,u,l)}roundClean(){Mn.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}};var lc=sc(()=>new es);import{PublicKey as ap}from"@solana/web3.js";import gc,{isBN as Ac}from"bn.js";import{bits as yd,BitStructure as bd,blob as gd,Blob as Ad,cstr as Pd,f32 as kd,f32be as wd,f64 as Td,f64be as hd,greedy as Id,Layout as Bd,ns64 as xd,ns64be as Sd,nu64 as Kd,nu64be as Cd,offset as Rd,s16 as Ld,s16be as Od,s24 as Nd,s24be as Md,s32 as vd,s32be as Fd,s40 as Vd,s40be as _d,s48 as Ed,s48be as Dd,s8 as Wd,seq as qd,struct as DP,Structure as Ud,u16 as Gd,u16be as Xd,u24 as zd,u24be as Qd,u32 as Yd,u32be as jd,u40 as Hd,u40be as Zd,u48 as $d,u48be as Jd,u8 as ep,UInt as tp,union as np,Union as op,unionLayoutDiscriminator as ip,utf8 as rp}from"@solana/buffer-layout";var li=Bd,mc=Ud,dc=op,WP=bd,ts=tp,pc=Ad,qP=Id,Cr=ep,Mt=Gd,UP=zd,mi=Yd,GP=Hd,XP=$d,fc=Kd,zP=Xd,QP=Qd,YP=jd,jP=Zd,HP=Jd,ZP=Cd,$P=Wd,JP=Ld,ek=Nd,_e=vd,tk=Vd,nk=Ed,ok=xd,ik=Od,rk=Md,ak=Fd,sk=_d,uk=Dd,ck=Sd,lk=kd,mk=wd,dk=Td,pk=hd;var yc=qd,bc=np,fk=ip,xe=gd,yk=Pd,bk=rp,ns=yd,os=Rd;var $n=class extends li{constructor(t,n,o){super(t,o);this.blob=xe(t),this.signed=n}decode(t,n=0){let o=new gc(this.blob.decode(t,n),10,"le");return this.signed?o.fromTwos(this.span*8).clone():o}encode(t,n,o=0){return typeof t=="number"&&(t=new gc(t)),this.signed&&(t=t.toTwos(this.span*8)),this.blob.encode(t.toArrayLike(Buffer,"le",this.span),n,o)}},Rr=class extends li{constructor(t){super(8,t);this._lower=ns(mi(),!1),this._upper=ns(mi(),!1)}addBoolean(t){this._lower.fields.length<32?this._lower.addBoolean(t):this._upper.addBoolean(t)}decode(t,n=0){let o=this._lower.decode(t,n),r=this._upper.decode(t,n+this._lower.span);return N(N({},o),r)}encode(t,n,o=0){return this._lower.encode(t,n,o)+this._upper.encode(t,n,o+this._lower.span)}};function D(s){return new ts(1,s)}function pt(s){return new ts(4,s)}function k(s){return new $n(8,!1,s)}function te(s){return new $n(16,!1,s)}function Pc(s){return new $n(1,!0,s)}function So(s){return new $n(8,!0,s)}function kc(s){return new $n(16,!0,s)}var kn=class extends li{constructor(t,n,o,r){super(t.span,r);this.layout=t,this.decoder=n,this.encoder=o}decode(t,n){return this.decoder(this.layout.decode(t,n))}encode(t,n,o){return this.layout.encode(this.encoder(t),n,o)}getSpan(t,n){return this.layout.getSpan(t,n)}};function O(s){return new kn(xe(32),e=>new ap(e),e=>e.toBuffer(),s)}var is=class extends li{constructor(t,n){super(-1,n);this.layout=t,this.discriminator=Cr()}encode(t,n,o=0){return t==null?this.discriminator.encode(0,n,o):(this.discriminator.encode(1,n,o),this.layout.encode(t,n,o+1)+1)}decode(t,n=0){let o=this.discriminator.decode(t,n);if(o===0)return null;if(o===1)return this.layout.decode(t,n+1);throw new Error("Invalid option "+this.property)}getSpan(t,n=0){let o=this.discriminator.decode(t,n);if(o===0)return 1;if(o===1)return this.layout.getSpan(t,n+1)+1;throw new Error("Invalid option "+this.property)}};function wk(s,e){return new is(s,e)}function We(s){return new kn(Cr(),sp,up,s)}function sp(s){if(s===0)return!1;if(s===1)return!0;throw new Error("Invalid bool: "+s)}function up(s){return s?1:0}function Tk(s,e){let t=mi("length"),n=v([t,Q(s,os(t,-t.span),"values")]);return new kn(n,({values:o})=>o,o=>({values:o}),e)}function hk(s,e,t){let n=v([k("tag"),e.replicate("data")]);function o({tag:r,data:i}){if(!r.eq(s))throw new Error("Invalid tag, expected: "+s.toString("hex")+", got: "+r.toString("hex"));return i}return new kn(n,o,r=>({tag:s,data:r}),t)}function cp(s){let e=mi("length"),t=v([e,xe(os(e,-e.span),"data")]);return new kn(t,({data:n})=>n,n=>({data:n}),s)}function Ct(s){return new kn(cp(),e=>e.toString("utf-8"),e=>Buffer.from(e,"utf-8"),s)}function Ik(s,e){let t=bc(Cr(),e);return s.forEach((n,o)=>t.addVariant(o,n,n.property)),t}function Bk(s,e,t){let n=v([Q(s,e,"values")]);return new kn(n,({values:o})=>o,o=>({values:o}),t)}var rs=class extends mc{decode(e,t){return super.decode(e,t)}};function v(s,e,t){return new rs(s,e,t)}var as=class extends dc{encodeInstruction(e){let t=Math.max(...Object.values(this.registry).map(o=>o.span)),n=Buffer.alloc(t);return n.slice(0,this.encode(e,n))}decodeInstruction(e){return this.decode(e)}};function xk(s,e,t){return new as(s,e,t)}var ss=class extends pc{decode(e,t){let n=super.decode(e,t);if(!n.every(o=>o===0))throw new Error("nonzero padding bytes");return n}};function Sk(s){return new ss(s)}function Q(s,e,t){let n,o=typeof e=="number"?e:Ac(e)?e.toNumber():new Proxy(e,{get(r,i){if(!n){let a=Reflect.get(r,"count");n=Ac(a)?a.toNumber():a,Reflect.set(r,"count",n)}return Reflect.get(r,i)},set(r,i,a){return i==="count"&&(n=a),Reflect.set(r,i,a)}});return yc(s,o,t)}var rn=v([O("mint"),O("owner"),k("amount"),pt("delegateOption"),O("delegate"),D("state"),pt("isNativeOption"),k("isNative"),k("delegatedAmount"),pt("closeAuthorityOption"),O("closeAuthority")]);var Wk=fe("Raydium_Util");function Tc({owner:s,solAccountResp:e,tokenAccountResp:t}){let n=[],o=[];for(let{pubkey:r,account:i}of t.value){let a=rn.decode(i.data),{mint:c,amount:u}=a;n.push({publicKey:r,mint:c,amount:u,isAssociated:j(s,c,i.owner).publicKey.equals(r),isNative:!1,programId:i.owner}),o.push({pubkey:r,accountInfo:a,programId:i.owner})}return e&&n.push({mint:wc.default,amount:new mp(String(e.lamports)),isNative:!0,programId:e.owner}),{tokenAccounts:n,tokenAccountRawInfos:o}}function Ye({fromPublicKey:s,programId:e=dp,assignSeed:t}){let n=t?btoa(t).slice(0,32):lp.generate().publicKey.toBase58().slice(0,32);return{publicKey:pp(s,n,e),seed:n}}function pp(s,e,t){let n=Buffer.concat([s.toBuffer(),Buffer.from(e),t.toBuffer()]),o=lc(n);return new wc(o)}function us(s){let{mint:e,tokenAccount:t,owner:n,programId:o=Ko}=s;return Ap(t,e,n,o)}function wn(s){let{tokenAccount:e,payer:t,multiSigners:n=[],owner:o,programId:r=Ko}=s;return gp(e,t,o,n,r)}async function vn(s){let{connection:e,amount:t,commitment:n,payer:o,owner:r,skipCloseAccount:i}=s,a=await e.getMinimumBalanceForRentExemption(rn.span,n),c=J(t).add(new bp(a)),u=Ye({fromPublicKey:o,programId:Ko});return{addresses:{newAccount:u.publicKey},signers:[],instructions:[yp.createAccountWithSeed({fromPubkey:o,basePubkey:o,seed:u.seed,newAccountPubkey:u.publicKey,lamports:c.toNumber(),space:rn.span,programId:Ko}),us({mint:new fp(at.address),tokenAccount:u.publicKey,owner:r,programId:Ko})],instructionTypes:[U.CreateAccount,U.InitAccount],endInstructionTypes:i?[]:[U.CloseAccount],endInstructions:i?[]:[wn({tokenAccount:u.publicKey,payer:o,owner:r})]}}function hc({source:s,destination:e,owner:t,amount:n,multiSigners:o=[],tokenProgram:r=Ko}){return Pp(s,e,t,BigInt(String(n)),o,r)}var di=class extends Ve{constructor(t){super(t);this._tokenAccounts=[];this._tokenAccountRawInfos=[];this._accountListener=[];this._clientOwnedToken=!1;this._notSubscribeAccountChange=!1;this._accountFetchTime=0;let{tokenAccounts:n,tokenAccountRawInfos:o,notSubscribeAccountChange:r}=t;this._tokenAccounts=n||[],this._tokenAccountRawInfos=o||[],this._notSubscribeAccountChange=r!=null?r:!0,this._clientOwnedToken=!!(n||o)}get tokenAccounts(){return this._tokenAccounts}get tokenAccountRawInfos(){return this._tokenAccountRawInfos}set notSubscribeAccountChange(t){this._notSubscribeAccountChange=t}updateTokenAccount({tokenAccounts:t,tokenAccountRawInfos:n}){return t&&(this._tokenAccounts=t),n&&(this._tokenAccountRawInfos=n),this._accountChangeListenerId&&this.scope.connection.removeAccountChangeListener(this._accountChangeListenerId),this._accountChangeListenerId=void 0,this._clientOwnedToken=!0,this}addAccountChangeListener(t){return this._accountListener.push(t),this}removeAccountChangeListener(t){return this._accountListener=this._accountListener.filter(n=>n!==t),this}getAssociatedTokenAccount(t,n){return j(this.scope.ownerPubKey,t,n).publicKey}resetTokenAccounts(){this._clientOwnedToken||(this._tokenAccounts=[],this._tokenAccountRawInfos=[])}async fetchWalletTokenAccounts(t){if(this._clientOwnedToken||!(t!=null&&t.forceUpdate)&&this._tokenAccounts.length&&Date.now()-this._accountFetchTime<(this._notSubscribeAccountChange?1e3*5:1e3*60*3))return{tokenAccounts:this._tokenAccounts,tokenAccountRawInfos:this._tokenAccountRawInfos};this.scope.checkOwner();let o=N(N({},{}),t),[r,i,a]=await Promise.all([this.scope.connection.getAccountInfo(this.scope.ownerPubKey,o.commitment),this.scope.connection.getTokenAccountsByOwner(this.scope.ownerPubKey,{programId:Fn},o.commitment),this.scope.connection.getTokenAccountsByOwner(this.scope.ownerPubKey,{programId:wp},o.commitment)]),{tokenAccounts:c,tokenAccountRawInfos:u}=Tc({owner:this.scope.ownerPubKey,solAccountResp:r,tokenAccountResp:{context:i.context,value:[...i.value,...a.value]}});return this._tokenAccounts=c,this._tokenAccountRawInfos=u,this._accountFetchTime=Date.now(),this._notSubscribeAccountChange||(this._accountChangeListenerId&&this.scope.connection.removeAccountChangeListener(this._accountChangeListenerId),this._accountChangeListenerId=this.scope.connection.onAccountChange(this.scope.ownerPubKey,()=>{this.fetchWalletTokenAccounts({forceUpdate:!0}),this._accountListener.forEach(l=>l({tokenAccounts:this._tokenAccounts,tokenAccountRawInfos:this._tokenAccountRawInfos}))},{commitment:t==null?void 0:t.commitment})),{tokenAccounts:c,tokenAccountRawInfos:u}}clearAccountChangeCkb(){this._accountChangeListenerId!==void 0&&this.scope.connection.removeAccountChangeListener(this._accountChangeListenerId)}async getCreatedTokenAccount({mint:t,programId:n=Fn,associatedOnly:o=!0}){await this.fetchWalletTokenAccounts();let r=this._tokenAccounts.filter(({mint:a})=>a==null?void 0:a.equals(t)).sort((a,c)=>a.amount.lt(c.amount)?1:-1),i=this.getAssociatedTokenAccount(t,n);for(let a of r){let{publicKey:c}=a;if(c&&(!o||o&&i.equals(c)))return c}}async getOrCreateTokenAccount(t){var y,b,g,P;await this.fetchWalletTokenAccounts();let{mint:n,createInfo:o,associatedOnly:r,owner:i,notUseTokenAccount:a=!1,skipCloseAccount:c=!1,checkCreateATAOwner:u=!1,assignSeed:l}=t,m=new Lr(t.tokenProgram||Fn),p=this.getAssociatedTokenAccount(n,new Lr(m)),d=(a?[]:this.tokenAccountRawInfos).filter(h=>h.accountInfo.mint.equals(n)&&(!r||h.pubkey.equals(p))).sort((h,I)=>h.accountInfo.amount.lt(I.accountInfo.amount)?1:-1);if(o===void 0||d.length>0)return d.length>0?{account:d[0].pubkey}:{};let f={instructions:[],endInstructions:[],signers:[],instructionTypes:[],endInstructionTypes:[]};if(r){let h=cs(i,p,i,n,m),I=this.tokenAccountRawInfos.find(T=>T.pubkey.equals(p));if(u){let T=await this.scope.connection.getAccountInfo(p);if(T===null)(y=f.instructions)==null||y.push(h),f.instructionTypes.push(U.CreateATA);else if(!(T.owner.equals(m)&&Co.decode(T.data).mint.equals(n)&&Co.decode(T.data).owner.equals(i)))throw Error(`create ata check error -> mint: ${n.toString()}, ata: ${p.toString()}`)}else I===void 0&&(f.instructions.push(h),f.instructionTypes.push(U.CreateATA));if(n.equals(H)&&o.amount){let T=await vn({connection:this.scope.connection,owner:this.scope.ownerPubKey,payer:o.payer||this.scope.ownerPubKey,amount:(b=o.amount)!=null?b:0,skipCloseAccount:c});f.instructions.push(...T.instructions||[]),f.endInstructions.push(...T.endInstructions||[]),f.instructionTypes.push(...T.instructionTypes||[]),f.endInstructionTypes.push(...T.endInstructionTypes||[]),o.amount&&(f.instructions.push(hc({source:T.addresses.newAccount,destination:p,owner:this.scope.ownerPubKey,amount:o.amount,tokenProgram:Fn})),f.instructionTypes.push(U.TransferAmount))}return!c&&I===void 0&&(f.endInstructions.push(wn({owner:i,payer:o.payer||i,tokenAccount:p,programId:m})),f.endInstructionTypes.push(U.CloseAccount)),{account:p,instructionParams:f}}else{let h=Ye({fromPublicKey:i,programId:m,assignSeed:l}),I=await this.scope.connection.getMinimumBalanceForRentExemption(Co.span),T=kp.createAccountWithSeed({fromPubkey:i,basePubkey:i,seed:h.seed,newAccountPubkey:h.publicKey,lamports:I+Number((P=(g=o.amount)==null?void 0:g.toString())!=null?P:0),space:Co.span,programId:m});return f.instructions.push(T,us({mint:n,tokenAccount:h.publicKey,owner:this.scope.ownerPubKey,programId:m})),f.instructionTypes.push(U.CreateAccount),f.instructionTypes.push(U.InitAccount),c||(f.endInstructions.push(wn({owner:i,payer:o.payer||i,tokenAccount:h.publicKey,programId:m})),f.endInstructionTypes.push(U.CloseAccount)),{account:h.publicKey,instructionParams:f}}}async checkOrCreateAta({mint:t,programId:n=Fn,autoUnwrapWSOLToSOL:o}){var c;await this.fetchWalletTokenAccounts();let r=(c=this.scope.account.tokenAccounts.find(({mint:u})=>(u==null?void 0:u.toBase58())===t.toBase58()))==null?void 0:c.publicKey,i=this.scope.ownerPubKey,a={};if(!r){let u=this.getAssociatedTokenAccount(t,n),l=await cs(i,u,i,t,n);a.instructions=[l],a.instructionTypes=[U.CreateATA],r=u}return o&&H.toBase58()===t.toBase58()&&(a.endInstructions=[wn({owner:i,payer:i,tokenAccount:r,programId:n})],a.endInstructionTypes=[U.CloseAccount]),{pubKey:r,newInstructions:a}}async handleTokenAccount(t){let{side:n,amount:o,mint:r,programId:i=Fn,tokenAccount:a,payer:c=this.scope.ownerPubKey,bypassAssociatedCheck:u,skipCloseAccount:l,checkCreateATAOwner:m}=t,p=this.getAssociatedTokenAccount(r,i);if(new Lr(H).equals(r)){let d=await vn({connection:this.scope.connection,owner:this.scope.ownerPubKey,payer:c,amount:o,skipCloseAccount:l});return N({tokenAccount:d.addresses.newAccount},d)}else if(!a||n==="out"&&!p.equals(a)&&!u){let d=[],f=cs(this.scope.ownerPubKey,p,this.scope.ownerPubKey,r,i);if(m){let y=await this.scope.connection.getAccountInfo(p);if(y===null)d.push(f);else if(!(y.owner.equals(Fn)&&Co.decode(y.data).mint.equals(r)&&Co.decode(y.data).owner.equals(this.scope.ownerPubKey)))throw Error(`create ata check error -> mint: ${r.toString()}, ata: ${p.toString()}`)}else d.push(f);return{tokenAccount:p,instructions:d,instructionTypes:[U.CreateATA]}}return{tokenAccount:a}}async processTokenAccount(t){let{mint:n,programId:o=Fn,amount:r,useSOLBalance:i,handleTokenAccount:a,feePayer:c}=t,u,l=this.createTxBuilder(c);if(n.equals(new Lr(H))&&i){let m=await this.handleTokenAccount({side:"in",amount:r||0,mint:n,bypassAssociatedCheck:!0,programId:o}),{tokenAccount:d}=m,f=qe(m,["tokenAccount"]);u=d,l.addInstruction(f)}else if(u=await this.getCreatedTokenAccount({mint:n,associatedOnly:!1,programId:o}),!u&&a){let p=await this.scope.account.handleTokenAccount({side:"in",amount:0,mint:n,bypassAssociatedCheck:!0,programId:o}),{tokenAccount:d}=p,f=qe(p,["tokenAccount"]);u=d,l.addInstruction(f)}return N({tokenAccount:u},l.AllTxData)}};import{PublicKey as Ke,SystemProgram as Up}from"@solana/web3.js";import{createAssociatedTokenAccountIdempotentInstruction as qc}from"@solana/spl-token";import Gp from"decimal.js";import{PublicKey as ys}from"@solana/web3.js";var ls=v([D("instruction")]),ms=v([D("instruction")]),Tp=v([k("rewardState"),k("rewardOpenTime"),k("rewardEndTime"),k("rewardLastUpdateTime"),k("totalReward"),k("totalRewardEmissioned"),k("rewardClaimed"),k("rewardPerSecond"),te("accRewardPerShare"),O("rewardVault"),O("rewardMint"),O("rewardSender"),k("rewardType"),Q(k(),15,"padding")]),hp=v([k("state"),k("nonce"),O("lpVault"),O("rewardVault"),O(),O(),k(),k(),k("totalReward"),te("perShareReward"),k("lastSlot"),k("perSlotReward")]),Ip=v([k("state"),k("nonce"),O("lpVault"),O("rewardVaultA"),k("totalRewardA"),te("perShareRewardA"),k("perSlotRewardA"),D("option"),O("rewardVaultB"),xe(7),k("totalRewardB"),te("perShareRewardB"),k("perSlotRewardB"),k("lastSlot"),O()]),Bp=v([k(),k("state"),k("nonce"),k("validRewardTokenNum"),te("rewardMultiplier"),k("rewardPeriodMax"),k("rewardPeriodMin"),k("rewardPeriodExtend"),O("lpMint"),O("lpVault"),Q(Tp,5,"rewardInfos"),O("creator"),O(),Q(k(),32,"padding")]),Ic=new Proxy(hp,{get(s,e,t){return e==="decode"?(...n)=>{let o=s.decode(...n);return q(N({},o),{version:3,rewardInfos:[{rewardVault:o.rewardVault,totalReward:o.totalReward,perSlotReward:o.perSlotReward,perShareReward:o.perShareReward}]})}:Reflect.get(s,e,t)}}),Bc=new Proxy(Ip,{get(s,e,t){return e==="decode"?(...n)=>{let o=s.decode(...n);return q(N({},o),{version:5,rewardInfos:[{rewardVault:o.rewardVaultA,totalReward:o.totalRewardA,perSlotReward:o.perSlotRewardA,perShareReward:o.perShareRewardA},{rewardVault:o.rewardVaultB,totalReward:o.totalRewardB,perSlotReward:o.perSlotRewardB,perShareReward:o.perShareRewardB}]})}:Reflect.get(s,e,t)}}),pi=new Proxy(Bp,{get(s,e,t){return e==="decode"?(...n)=>{let o=s.decode(...n);return q(N({},o),{version:6,rewardInfos:o.rewardInfos.map(r=>{var i;return q(N({},r),{rewardType:((i=Object.entries(Vn).find(a=>String(a[1])===r.rewardType.toString()))!=null?i:["Standard SPL"])[0]})})})}:Reflect.get(s,e,t)}}),xp=v([k("isSet"),k("rewardPerSecond"),k("rewardOpenTime"),k("rewardEndTime"),k("rewardType")]),ds=v([D("instruction"),k("nonce"),Q(xp,5,"rewardTimeInfo")]),ps=v([D("instruction"),k("rewardReopenTime"),k("rewardEndTime"),k("rewardPerSecond")]),fs=v([D("instruction"),k("isSet"),k("rewardPerSecond"),k("rewardOpenTime"),k("rewardEndTime"),k("rewardType")]),Pw=v([k("state"),O("id"),O("owner"),k("deposited"),Q(k(),1,"rewardDebts")]),fi=v([k("state"),O("id"),O("owner"),k("deposited"),Q(te(),1,"rewardDebts"),k(""),k("voteLockedBalance"),Q(k(),15)]),kw=v([k("state"),O("id"),O("owner"),k("deposited"),Q(k(),2,"rewardDebts")]),xc=v([k("state"),O("id"),O("owner"),k("deposited"),Q(te(),2,"rewardDebts"),Q(k(),17)]),Sc=v([k(),k("state"),O("id"),O("owner"),k("deposited"),Q(te(),5,"rewardDebts"),Q(k(),16)]),ht=v([D("instruction"),k("amount")]),Sp=v([O("mint"),O("grantAuthority"),k("baselineVoteWeightScaledFactor"),k("maxExtraLockupVoteWeightScaledFactor"),k("lockupSaturationSecs"),Pc("digitShift"),Q(D(),7,"reserved1"),Q(k(),7,"reserved2")]),Kc=v([xe(8),O("governanceProgramId"),O("realm"),O("realmGoverningTokenMint"),O("realmAuthority"),Q(D(),32,"reserved1"),Q(Sp,4,"votingMints"),So("timeOffset"),D("bump"),Q(D(),7,"reserved2"),Q(k(),11,"reserved3")]),Kp=v([So("startTime"),So("endTime"),D("kind"),Q(D(),15,"reserved")]),Cp=v([Q(Kp,1,"lockup"),k("amountDeposited_native"),k("amountInitiallyLockedNative"),We("isUsed"),We("allowClawback"),D("votingMintConfigIdx"),Q(D(),29,"reserved")]),Cc=v([xe(8),O("voterAuthority"),O("registrar"),Q(Cp,32,"deposits"),D("voterBump"),D("voterWweightRecordBump"),Q(D(),94,"reserved")]);import{NATIVE_MINT as Rp}from"@solana/spl-token";var Cw=fe("Raydium_farm_config"),Rc=new ys("4k3Dyjzvzp8eMZWUXbBCjEvwSkkk59S5iCNLY3QrkX6R"),Lc=new ys("FrspKwj8i3pNmKwXreTveC4fu7KL5ZbGeXdZBe2XViu1"),Rw=Rp,Lw=new ys("3TRTX4dXUpp2eqxi3tvQDFYUV7SdDJjcPE3Y4mbtftaX"),Oc={3:Ic,5:Bc,6:pi},Nc={3:fi,5:xc,6:Sc},bs=s=>[3,4,5,6].indexOf(s)!==-1,gs=s=>{var i;let{version:e,rewardInfos:t,rewardTokenAccountsPublicKeys:n}=s,o=`rewardInfo:${JSON.stringify(t)}, rewardAccount:${JSON.stringify(n)}`,r={3:()=>{if(t.length!==1||n.length!==1)return`rewardInfos or rewardTokenAccounts lengths not equal 1: ${o}`},5:()=>{if(t.length!==n.length)return`rewardInfos and rewardTokenAccounts lengths not equal: ${o}`},6:()=>{if(!n.length||t.length!==n.length)return`no rewardTokenAccounts or rewardInfos and rewardTokenAccounts lengths not equal: ${o}`}};return(i=r[e])==null?void 0:i.call(r)},Vn={"Standard SPL":0,"Option tokens":1},qt={[Fa.toString()]:3,[Va.toString()]:4,[_a.toString()]:5,[wo.toString()]:6,[Pn.FARM_PROGRAM_ID_V3.toString()]:3,[Pn.FARM_PROGRAM_ID_V4.toString()]:4,[Pn.FARM_PROGRAM_ID_V5.toString()]:5,[Pn.FARM_PROGRAM_ID_V6.toString()]:6};import{PublicKey as se,SystemProgram as Jn,SYSVAR_CLOCK_PUBKEY as Lo,SYSVAR_RENT_PUBKEY as Np,TransactionInstruction as nt}from"@solana/web3.js";import Or from"bn.js";import{ASSOCIATED_TOKEN_PROGRAM_ID as Mp,createAssociatedTokenAccountIdempotentInstruction as vp,TOKEN_PROGRAM_ID as Lt}from"@solana/spl-token";function As(s,e,t){return ne([e.toBuffer(),Buffer.from("registrar","utf8"),t.toBuffer()],s)}function Ps(s,e){return ne([e.toBuffer(),Buffer.from("voting_mint_seed","utf8")],s)}function ks(s,e){return ne([e.toBuffer()],s)}function ws(s,e,t){return ne([e.toBuffer(),Buffer.from("voter","utf8"),t.toBuffer()],s)}function Ts(s,e,t){return ne([e.toBuffer(),Buffer.from("voter-weight-record","utf8"),t.toBuffer()],s)}function hs(s,e,t,n){return ne([Buffer.from("governance","utf8"),e.toBuffer(),t.toBuffer(),n.toBuffer()],s)}import Rt from"bn.js";var yi=fe("Raydium.farm.util");function bi({programId:s,poolId:e,mint:t,type:n}){let{publicKey:o}=ne([e.toBuffer(),t.toBuffer(),Buffer.from(n==="lpVault"?"lp_vault_associated_seed":n==="rewardVault"?"reward_vault_associated_seed":"","utf-8")],s);return o}function bt({programId:s,poolId:e,owner:t,version:n}){let{publicKey:o}=ne([e.toBuffer(),t.toBuffer(),Buffer.from(n===6?"farmer_info_associated_seed":"staker_info_v2_associated_seed","utf-8")],s);return o}var Mc=({programId:s,poolId:e})=>ne([e.toBuffer()],s);function vc(s){return{isSet:new Rt(1),rewardPerSecond:J(s.perSecond),rewardOpenTime:J(s.openTime),rewardEndTime:J(s.endTime),rewardType:J(Vn[s.rewardType])}}function Is(s){return J(s.endTime).sub(J(s.openTime)).mul(J(s.perSecond))}function Ro(s){let e=Nc[s];return e||yi.logWithError("invalid version",s),e}function Lp(s){let e=Oc[s];return e||yi.logWithError("invalid version",s),e}function Op(s,e,t,n){if(s.version===3||s.version===5){if(s.lastSlot.gte(new Rt(t)))return s;let o=new Rt(t).sub(s.lastSlot);s.lastSlot=new Rt(t);for(let r of s.rewardInfos){if(e.amount.eq(new Rt(0)))continue;let i=r.perSlotReward.mul(o);r.perShareReward=r.perShareReward.add(i.mul(new Rt(10).pow(new Rt(s.version===3?9:15))).div(e.amount)),r.totalReward=r.totalReward.add(i)}}else if(s.version===6)for(let o of s.rewardInfos){if(o.rewardState.eq(new Rt(0)))continue;let r=Rt.min(new Rt(n),o.rewardEndTime);if(o.rewardOpenTime.gte(r))continue;let a=r.sub(o.rewardLastUpdateTime).mul(o.rewardPerSecond),c=o.totalReward.sub(o.totalRewardEmissioned);c.lt(a)?(a=c,o.rewardLastUpdateTime=o.rewardLastUpdateTime.add(c.div(o.rewardPerSecond))):o.rewardLastUpdateTime=r,!e.amount.eq(new Rt(0))&&(o.accRewardPerShare=o.accRewardPerShare.add(a.mul(s.rewardMultiplier).div(e.amount)),o.totalRewardEmissioned=o.totalRewardEmissioned.add(a))}return s}async function Yw({connection:s,farmPools:e,owner:t,config:n,chainTime:o}){let r=!1,i=!1,a=new Rt(10),c=[];for(let p of e){let d=Fe(p);d.version===6?i=!0:r=!0,c.push({pubkey:d.id,version:d.version,key:"state",poolId:d.id},{pubkey:d.lpVault,version:d.version,key:"lpVault",poolId:d.id}),t&&c.push({pubkey:bt({programId:d.programId,poolId:d.id,owner:t,version:p.version}),version:d.version,key:"ledger",poolId:d.id})}let u={},l=await Me(s,c,n);for(let{pubkey:p,version:d,key:f,poolId:y,accountInfo:b}of l){let g=y.toBase58();if(u[g]=N({},u[g]),f==="state"){let P=Lp(d);(!b||!b.data||b.data.length!==P.span)&&yi.logWithError(`invalid farm state account info, pools.id, ${p}`),u[g].state=P.decode(b.data)}else if(f==="lpVault")(!b||!b.data||b.data.length!==rn.span)&&yi.logWithError(`invalid farm lp vault account info, pools.lpVault, ${p}`),u[g].lpVault=rn.decode(b.data);else if(f==="ledger"){let P=Ro(d);b&&b.data&&(b.data.length!==P.span&&yi.logWithError(`invalid farm ledger account info, ledger, ${p}`),u[g].ledger=P.decode(b.data))}}let m=i||r?await s.getSlot():0;for(let p of Object.keys(u))u[p]!==void 0&&(u[p].state=Op(u[p].state,u[p].lpVault,m,o));for(let[p,{state:d,ledger:f}]of Object.entries(u))if(f){let y=d.version===6?d.rewardMultiplier:d.rewardInfos.length===1?a.pow(new Rt(9)):a.pow(new Rt(15)),b=d.rewardInfos.map((g,P)=>{let h=f.rewardDebts[P];return f.deposited.mul(d.version===6?g.accRewardPerShare:g.perShareReward).div(y).sub(h)});u[p].wrapped=q(N({},u[p].wrapped),{pendingRewards:b})}return u}function jw(s,e=Date.now()){if(s.version===6){let t=s.state.rewardInfos;if(t.every(({rewardOpenTime:n})=>zu(e,n.toNumber(),{unit:"s"})))return"upcoming pool";if(t.every(({rewardEndTime:n})=>Qu(e,n.toNumber(),{unit:"s"})))return"closed pool"}else{let t=s.state.rewardInfos.map(({perSlotReward:n})=>n);if(t.length===2){if(String(t[0])==="0"&&String(t[1])!=="0")return"normal fusion pool";if(String(t[0])!=="0"&&String(t[1])!=="0")return"dual fusion pool";if(String(t[0])==="0"&&String(t[1])==="0")return"closed pool"}else if(t.length===1&&String(t[0])==="0")return"closed pool"}}async function Bs(s,e,t,n){let o=await s.getAccountInfo(e);if(o===null)throw Error("registrar info check error");let i=Kc.decode(o.data).votingMints.findIndex(l=>l.mint.equals(n));if(i===-1)throw Error("find voter mint error");let a=await s.getAccountInfo(t);if(a===null)return{index:i,isInit:!1};let u=Cc.decode(a.data).deposits.findIndex(l=>l.isUsed&&l.votingMintConfigIdx===i);return u===-1?{index:i,isInit:!1}:{index:u,isInit:!0}}var Fp=fe("Raydium_farm_instruction"),gi={voterStakeRegistryCreateVoter:Buffer.from([6,24,245,52,243,255,148,25]),voterStakeRegistryCreateDepositEntry:Buffer.from([185,131,167,186,159,125,19,67]),voterStakeRegistryDeposit:Buffer.from([242,35,198,137,82,225,242,182]),voterStakeRegistryWithdraw:Buffer.from([183,18,70,156,148,109,161,34]),voterStakeRegistryUpdateVoterWeightRecord:Buffer.from([45,185,3,36,109,190,115,169])};function Ai(s){let{version:e,id:t,ledger:n,programId:o,owner:r}=s,i={3:9,5:10}[e];i||Fp.logWithError(`invalid farm pool version: ${e}`);let a=Buffer.alloc(ls.span);ls.encode({instruction:i},a);let c=[A({pubkey:t}),A({pubkey:n}),A({pubkey:r,isWritable:!1}),A({pubkey:Jn.programId,isWritable:!1}),A({pubkey:Np,isWritable:!1})];return{instruction:new nt({programId:o,keys:c,data:a}),instructionType:U.FarmV3CreateLedger}}function Fc(s){var n;let e=Buffer.alloc(ds.span);ds.encode({instruction:0,nonce:new Or(s.nonce),rewardTimeInfo:s.rewardInfoConfig},e);let t=[...Ia,A({pubkey:s.farmId}),A({pubkey:s.farmAuthority,isWritable:!1}),A({pubkey:s.lpVault}),A({pubkey:s.lpMint,isWritable:!1}),A({pubkey:s.lockVault}),A({pubkey:s.lockMint,isWritable:!1}),A({pubkey:(n=s.lockUserAccount)!=null?n:st}),A({pubkey:s.owner,isWritable:!1,isSigner:!0})];for(let o of s.rewardInfo)t.push(A({pubkey:o.rewardMint,isWritable:!1}),A({pubkey:o.rewardVault}),A({pubkey:o.userRewardToken}));return{instruction:new nt({programId:s.programId,keys:t,data:e}),instructionType:U.FarmV6Create}}function Vc(s){let e=Buffer.alloc(ms.span);ms.encode({instruction:5},e);let t=[A({pubkey:Lt,isWritable:!1}),A({pubkey:s.id}),A({pubkey:s.authority,isWritable:!1}),A({pubkey:s.lpVault,isWritable:!1}),A({pubkey:s.rewardVault}),A({pubkey:s.userRewardToken}),A({pubkey:s.owner,isWritable:!1,isSigner:!0})];return{instruction:new nt({programId:s.programId,keys:t,data:e}),instructionType:U.FarmV6CreatorWithdraw}}function Vp(s,e,t,n,o,r,i,a,c,u,l,m,p){let d=v([D("depositEntryIndex"),k("amount")]),f=[{pubkey:e,isSigner:!1,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!1},{pubkey:Lt,isSigner:!1,isWritable:!1},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!1},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!1},{pubkey:l,isSigner:!1,isWritable:!1},{pubkey:cr,isSigner:!1,isWritable:!1}],y=Buffer.alloc(d.span);d.encode({depositEntryIndex:m,amount:p},y);let b=Buffer.from([...gi.voterStakeRegistryDeposit,...y]);return new nt({keys:f,programId:s,data:b})}function _p(s,e,t,n){let o=v([]),r=[{pubkey:e,isSigner:!1,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:Jn.programId,isSigner:!1,isWritable:!1}],i=Buffer.alloc(o.span);o.encode({},i);let a=Buffer.from([...gi.voterStakeRegistryUpdateVoterWeightRecord,...i]);return new nt({keys:r,programId:s,data:a})}function Ep(s,e,t,n,o,r,i,a,c,u,l,m,p,d,f){let y=v([D("depositEntryIndex"),k("amount")]),b=[{pubkey:e,isSigner:!1,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!0,isWritable:!1},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:Lt,isSigner:!1,isWritable:!1},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!1},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:m,isSigner:!1,isWritable:!1},{pubkey:p,isSigner:!1,isWritable:!1},{pubkey:cr,isSigner:!1,isWritable:!1}],g=Buffer.alloc(y.span);y.encode({depositEntryIndex:d,amount:f},g);let P=Buffer.from([...gi.voterStakeRegistryWithdraw,...g]);return new nt({keys:b,programId:s,data:P})}function Dp(s,e,t,n,o,r){let i=v([D("ins")]),a=[{pubkey:e,isSigner:!1,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!0,isWritable:!0},{pubkey:Jn.programId,isSigner:!1,isWritable:!1}],c=Buffer.alloc(i.span);return i.encode({ins:23},c),new nt({keys:a,programId:s,data:c})}function Wp(s,e,t,n,o,r,i,a){let c=v([D("voterBump"),D("voterWeightRecordBump")]),u=[{pubkey:e,isSigner:!1,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!0,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!0,isWritable:!0},{pubkey:Jn.programId,isSigner:!1,isWritable:!1},{pubkey:tt,isSigner:!1,isWritable:!1},{pubkey:cr,isSigner:!1,isWritable:!1}],l=Buffer.alloc(c.span);c.encode({voterBump:i,voterWeightRecordBump:a},l);let m=Buffer.from([...gi.voterStakeRegistryCreateVoter,...l]);return new nt({keys:u,programId:s,data:m})}function qp(s,e,t,n,o,r,i,a,c,u,l,m){let p=v([D("depositEntryIndex"),D("kind"),D("option"),k("startTs"),pt("periods"),We("allowClawback")]),d=[{pubkey:e,isSigner:!1,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!0,isWritable:!1},{pubkey:r,isSigner:!0,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!1},{pubkey:Jn.programId,isSigner:!1,isWritable:!1},{pubkey:Lt,isSigner:!1,isWritable:!1},{pubkey:Mp,isSigner:!1,isWritable:!1},{pubkey:tt,isSigner:!1,isWritable:!1}],f=Buffer.alloc(p.span);p.encode({depositEntryIndex:a,kind:c,option:u===void 0?0:1,startTs:u,periods:l,allowClawback:m},f);let y=Buffer.from([...gi.voterStakeRegistryCreateDepositEntry,...f]);return new nt({keys:d,programId:s,data:y})}async function mT({connection:s,programId:e,governanceProgramId:t,voteWeightAddinProgramId:n,realm:o,communityTokenMint:r,owner:i,poolId:a,tokenProgram:c}){let u=As(n,o,r).publicKey,l=bt({programId:e,poolId:a,owner:i,version:3}),m=await s.getAccountInfo(l);if(m===null)throw Error("user is not staker");let p=fi.decode(m.data),d=p.deposited.sub(p.voteLockedBalance);if(console.log("amount",d.toString()),d.eq(new Or(0)))throw Error("user do not has new stake amount");let f=Ps(e,a).publicKey,y=ks(e,a).publicKey,{publicKey:b,nonce:g}=ws(n,u,i),P=j(b,f,c).publicKey,{publicKey:h,nonce:I}=Ts(n,u,i),T=hs(t,o,r,i).publicKey,w=[],x=j(i,f,c).publicKey;if(await s.getAccountInfo(x)===null&&w.push(vp(i,x,i,f)),await s.getAccountInfo(b)===null){let M=Dp(t,o,i,r,i,T);w.push(M,Wp(n,u,b,h,i,i,g,I))}let{index:B,isInit:C}=await Bs(s,u,b,f);return C||w.push(qp(n,u,b,P,i,i,f,B,0,void 0,0,!1)),w.push(Vp(n,u,b,P,x,i,l,a,f,y,e,B,d),_p(n,u,b,h)),w}async function dT({connection:s,programId:e,governanceProgramId:t,voteWeightAddinProgramId:n,realm:o,communityTokenMint:r,owner:i,poolId:a,tokenProgram:c}){let u=As(n,o,r).publicKey,l=bt({programId:e,poolId:a,owner:i,version:3}),m=await s.getAccountInfo(l);if(m===null)throw Error("user is not staker");let p=fi.decode(m.data);if(p.voteLockedBalance.eq(new Or(0)))throw Error("user has vote locked balance = 0");let d=Ps(e,a).publicKey,f=ks(e,a).publicKey,{publicKey:y}=ws(n,u,i),b=j(y,d,c).publicKey,{publicKey:g}=Ts(n,u,i),P=hs(t,o,r,i).publicKey,h=[],{index:I,isInit:T}=await Bs(s,u,y,d);if(!T)throw Error("deposit entry index check error");return h.push(Ep(n,u,y,i,P,g,b,j(i,d,c).publicKey,l,a,d,f,e,I,p.voteLockedBalance)),h}function xs({payer:s,rewardVault:e,userRewardTokenPub:t,farmKeys:n,rewardInfo:o}){let r=Buffer.alloc(ps.span);ps.encode({instruction:3,rewardReopenTime:J(o.openTime),rewardEndTime:J(o.endTime),rewardPerSecond:J(o.perSecond)},r);let i=[A({pubkey:Lt,isWritable:!1}),A({pubkey:n.id}),A({pubkey:n.lpVault,isWritable:!1}),A({pubkey:e}),A({pubkey:t}),A({pubkey:s,isWritable:!1,isSigner:!0})];return new nt({programId:n.programId,keys:i,data:r})}function Ss({payer:s,userRewardTokenPub:e,farmKeys:t,rewardVault:n,rewardInfo:o}){let r=Buffer.alloc(fs.span);fs.encode({instruction:4,isSet:new Or(1),rewardPerSecond:J(o.perSecond),rewardOpenTime:J(o.openTime),rewardEndTime:J(o.endTime),rewardType:J(Vn[o.rewardType])},r);let i=[...Ia,A({pubkey:t.id}),A({pubkey:t.authority,isWritable:!1}),A({pubkey:o.mint,isWritable:!1}),A({pubkey:n}),A({pubkey:e}),A({pubkey:s,isWritable:!1,isSigner:!0})];return new nt({programId:t.programId,keys:i,data:r})}function pT(s){let{farmInfo:e,farmKeys:t,version:n,lpAccount:o,rewardAccounts:r,owner:i,instruction:a,amount:c,deposit:u}=s,[l,m]=[new se(e.programId),new se(e.id)],p=bt({programId:l,poolId:m,owner:i,version:n}),d=Buffer.alloc(ht.span);ht.encode({instruction:a,amount:c},d);let f=n===6?[A({pubkey:Lt,isWritable:!1}),...u?[A({pubkey:Jn.programId,isWritable:!1})]:[],A({pubkey:m}),A({pubkey:new se(t.authority),isWritable:!1}),A({pubkey:new se(t.lpVault)}),A({pubkey:p}),A({pubkey:i,isWritable:!1,isSigner:!0}),A({pubkey:o})]:[A({pubkey:m}),A({pubkey:new se(t.authority),isWritable:!1}),A({pubkey:p}),A({pubkey:i,isWritable:!1,isSigner:!0}),A({pubkey:o}),A({pubkey:new se(t.lpVault)}),A({pubkey:r[0]}),A({pubkey:new se(t.rewardInfos[0].vault)}),A({pubkey:Lo,isWritable:!1}),A({pubkey:Lt,isWritable:!1})];if(n===5)for(let y=1;y<t.rewardInfos.length;y++)f.push(A({pubkey:r[y]})),f.push(A({pubkey:new se(t.rewardInfos[y].vault)}));if(n===6)for(let y=0;y<t.rewardInfos.length;y++)f.push(A({pubkey:new se(t.rewardInfos[y].vault)})),f.push(A({pubkey:r[y]}));return new nt({programId:l,keys:f,data:d})}function Pi(s){let{farmInfo:e,farmKeys:t,lpAccount:n,rewardAccounts:o,owner:r,amount:i}=s,[a,c]=[new se(e.programId),new se(e.id)],u=bt({programId:a,poolId:c,owner:r,version:6}),l=Buffer.alloc(ht.span);ht.encode({instruction:2,amount:J(i)},l);let m=[A({pubkey:Lt,isWritable:!1}),A({pubkey:c}),A({pubkey:new se(t.authority),isWritable:!1}),A({pubkey:new se(t.lpVault)}),A({pubkey:u}),A({pubkey:r,isWritable:!1,isSigner:!0}),A({pubkey:n})];for(let p=0;p<t.rewardInfos.length;p++)m.push(A({pubkey:new se(t.rewardInfos[p].vault)})),m.push(A({pubkey:o[p]}));return new nt({programId:a,keys:m,data:l})}function ki(s){let{farmInfo:e,farmKeys:t,lpAccount:n,rewardAccounts:o,owner:r,amount:i,userAuxiliaryLedgers:a}=s,[c,u]=[new se(e.programId),new se(e.id)],l=bt({programId:c,poolId:u,owner:r,version:5}),m=Buffer.alloc(ht.span);ht.encode({instruction:12,amount:J(i)},m);let p=[A({pubkey:u}),A({pubkey:new se(t.authority),isWritable:!1}),A({pubkey:l}),A({pubkey:r,isWritable:!1,isSigner:!0}),A({pubkey:n}),A({pubkey:new se(t.lpVault)}),A({pubkey:o[0]}),A({pubkey:new se(t.rewardInfos[0].vault)}),A({pubkey:Lo,isWritable:!1}),A({pubkey:Lt,isWritable:!1})];for(let d=1;d<t.rewardInfos.length;d++)p.push(A({pubkey:o[d]})),p.push(A({pubkey:new se(t.rewardInfos[d].vault)}));if(a)for(let d of a)p.push(A({pubkey:d}));return new nt({programId:c,keys:p,data:m})}function _c(s){let{farmInfo:e,farmKeys:t,lpAccount:n,rewardAccounts:o,owner:r,amount:i,userAuxiliaryLedgers:a}=s,[c,u]=[new se(e.programId),new se(e.id)],l=v([D("instruction"),k("amount")]),m=[A({pubkey:u}),A({pubkey:new se(t.authority),isWritable:!1}),A({pubkey:a[0]}),A({pubkey:r,isSigner:!0,isWritable:!1}),A({pubkey:n}),A({pubkey:new se(t.lpVault)}),A({pubkey:o[0]}),A({pubkey:new se(t.rewardInfos[0].vault)}),A({pubkey:Lo,isWritable:!1}),A({pubkey:Lt,isWritable:!1}),A({pubkey:o[1]}),A({pubkey:new se(t.rewardInfos[1].vault)})],p=Buffer.alloc(l.span);return l.encode({instruction:2,amount:i},p),new nt({keys:m,programId:c,data:p})}function wi(s){let{farmInfo:e,farmKeys:t,lpAccount:n,rewardAccounts:o,owner:r,amount:i,userAuxiliaryLedgers:a}=s,[c,u]=[new se(e.programId),new se(e.id)],l=bt({programId:c,poolId:u,owner:r,version:3}),m=Buffer.alloc(ht.span);ht.encode({instruction:11,amount:J(i)},m);let p=[A({pubkey:u}),A({pubkey:new se(t.authority),isWritable:!1}),A({pubkey:l}),A({pubkey:r,isWritable:!1,isSigner:!0}),A({pubkey:n}),A({pubkey:new se(t.lpVault)}),A({pubkey:o[0]}),A({pubkey:new se(t.rewardInfos[0].vault)}),A({pubkey:Lo,isWritable:!1}),A({pubkey:Lt,isWritable:!1})];if(a)for(let d of a)p.push(A({pubkey:d}));return new nt({programId:c,keys:p,data:m})}function Ec(s){let{farmInfo:e,farmKeys:t,lpAccount:n,rewardAccounts:o,owner:r,amount:i,userAuxiliaryLedgers:a}=s,[c,u]=[new se(e.programId),new se(e.id)],l=bt({programId:c,poolId:u,owner:r,version:3}),m=Buffer.alloc(ht.span);ht.encode({instruction:10,amount:J(i)},m);let p=[A({pubkey:u}),A({pubkey:new se(t.authority),isWritable:!1}),A({pubkey:l}),A({pubkey:r,isWritable:!1,isSigner:!0}),A({pubkey:n}),A({pubkey:new se(t.lpVault)}),A({pubkey:o[0]}),A({pubkey:new se(t.rewardInfos[0].vault)}),A({pubkey:Lo,isWritable:!1}),A({pubkey:Lt,isWritable:!1})];if(a)for(let d of a)p.push(A({pubkey:d}));return new nt({programId:c,keys:p,data:m})}function Dc(s){let{farmInfo:e,farmKeys:t,lpAccount:n,rewardAccounts:o,owner:r,amount:i,userAuxiliaryLedgers:a}=s,[c,u]=[new se(e.programId),new se(e.id)],l=bt({programId:c,poolId:u,owner:r,version:5}),m=Buffer.alloc(ht.span);ht.encode({instruction:11,amount:J(i)},m);let p=[A({pubkey:u}),A({pubkey:new se(t.authority),isWritable:!1}),A({pubkey:l}),A({pubkey:r,isWritable:!1,isSigner:!0}),A({pubkey:n}),A({pubkey:new se(t.lpVault)}),A({pubkey:o[0]}),A({pubkey:new se(t.rewardInfos[0].vault)}),A({pubkey:Lo,isWritable:!1}),A({pubkey:Lt,isWritable:!1})];for(let d=1;d<t.rewardInfos.length;d++)p.push(A({pubkey:o[d]})),p.push(A({pubkey:new se(t.rewardInfos[d].vault)}));if(a)for(let d of a)p.push(A({pubkey:d}));return new nt({programId:c,keys:p,data:m})}function Wc(s){let{farmInfo:e,farmKeys:t,lpAccount:n,rewardAccounts:o,owner:r,amount:i}=s,[a,c]=[new se(e.programId),new se(e.id)],u=bt({programId:a,poolId:c,owner:r,version:6}),l=Buffer.alloc(ht.span);ht.encode({instruction:1,amount:J(i)},l);let m=[A({pubkey:Lt,isWritable:!1}),A({pubkey:Jn.programId,isWritable:!1}),A({pubkey:c}),A({pubkey:new se(t.authority),isWritable:!1}),A({pubkey:new se(t.lpVault)}),A({pubkey:u}),A({pubkey:r,isWritable:!1,isSigner:!0}),A({pubkey:n})];for(let p=0;p<t.rewardInfos.length;p++)m.push(A({pubkey:new se(t.rewardInfos[p].vault)})),m.push(A({pubkey:o[p]}));return new nt({programId:a,keys:m,data:l})}var Ti=class extends Ve{async _getUserRewardInfo({payer:e,rewardInfo:t}){if(t.mint.equals(st)){let n=await vn({connection:this.scope.connection,owner:this.scope.ownerPubKey,payer:e,amount:Is(q(N({},t),{openTime:t.openTime.toString(),endTime:t.endTime.toString()}))});return{rewardPubKey:n.addresses.newAccount,newInstruction:n}}return{rewardPubKey:await this.scope.account.getCreatedTokenAccount({mint:t.mint,associatedOnly:!1})}}async create({poolInfo:e,rewardInfos:t,payer:n,programId:o=wo,txVersion:r,feePayer:i,lockProgram:a}){var x,S;this.checkDisabled(),this.scope.checkOwner();let u={lpMint:new Ke(e.lpMint.address),lockInfo:{lockMint:(x=a==null?void 0:a.mint)!=null?x:Rc,lockVault:(S=a==null?void 0:a.vault)!=null?S:Lc},version:6,rewardInfos:t,programId:o},l=this.createTxBuilder(i),m=n!=null?n:this.scope.ownerPubKey,p=Ye({fromPublicKey:m,programId:u.programId}),d=await this.scope.connection.getMinimumBalanceForRentExemption(pi.span);l.addInstruction({instructions:[Up.createAccountWithSeed({fromPubkey:m,basePubkey:m,seed:p.seed,newAccountPubkey:p.publicKey,lamports:d,space:pi.span,programId:u.programId})]});let{publicKey:f,nonce:y}=Mc({programId:new Ke(u.programId),poolId:p.publicKey}),b=bi({programId:u.programId,poolId:p.publicKey,mint:u.lpMint,type:"lpVault"}),g=[],P=[];for(let K of u.rewardInfos){K.openTime>=K.endTime&&this.logAndCreateError("start time error","rewardInfo.rewardOpenTime",K.openTime.toString()),isNaN(Vn[K.rewardType])&&this.logAndCreateError("rewardType error",K.rewardType),Number(K.perSecond)<=0&&this.logAndCreateError("rewardPerSecond error",K.perSecond),g.push(vc(K));let{rewardPubKey:B,newInstruction:C}=await this._getUserRewardInfo({rewardInfo:K,payer:m});C&&l.addInstruction(C),B||this.logAndCreateError("cannot found target token accounts",this.scope.account.tokenAccounts);let M=K.mint.equals(st)?new Ke(at.address):K.mint;P.push({rewardMint:M,rewardVault:bi({programId:u.programId,poolId:p.publicKey,mint:M,type:"rewardVault"}),userRewardToken:B})}let{account:h,instructionParams:I}=await this.scope.account.getOrCreateTokenAccount({mint:new Ke(u.lockInfo.lockMint),owner:this.scope.ownerPubKey,skipCloseAccount:!1,createInfo:{payer:this.scope.ownerPubKey,amount:0},associatedOnly:!1});I&&l.addInstruction(I),h||this.logAndCreateError("cannot found lock vault","tokenAccounts",this.scope.account.tokenAccounts);let{instruction:T,instructionType:w}=Fc({farmId:p.publicKey,owner:this.scope.ownerPubKey,farmAuthority:f,lpVault:b,lpMint:u.lpMint,lockVault:u.lockInfo.lockVault,lockMint:u.lockInfo.lockMint,lockUserAccount:h,programId:u.programId,rewardInfo:P,rewardInfoConfig:g,nonce:y});return l.addInstruction({instructions:[T],instructionTypes:[w]}).versionBuild({txVersion:r,extInfo:{farmId:p.publicKey,farmAuthority:f,lpVault:b,lockUserAccount:h,nonce:y}})}async restartReward({farmInfo:e,payer:t,newRewardInfo:n,txVersion:o,feePayer:r}){var g;let i=qt[e.programId];i!==6&&this.logAndCreateError("invalid farm version ",i);let a=Fe((await this.scope.api.fetchFarmKeysById({ids:e.id}))[0]),c={id:a.id,rewardInfos:e.rewardInfos,lpVault:a.lpVault,programId:a.programId};n.openTime>=n.endTime&&this.logAndCreateError("start time error","newRewardInfo",n);let u=t||this.scope.ownerPubKey,l=n.mint.equals(st)?new Ke(at.address):n.mint,m=c.rewardInfos.findIndex(P=>new Ke(P.mint.address).equals(l)),p=a.rewardInfos[m];p||this.logAndCreateError("configuration does not exist","rewardMint",l);let d=(g=p.vault)!=null?g:st,f=this.createTxBuilder(r),{rewardPubKey:y,newInstruction:b}=await this._getUserRewardInfo({rewardInfo:n,payer:u});return b&&f.addInstruction(b),y||this.logAndCreateError("cannot found target token accounts",this.scope.account.tokenAccounts),f.addInstruction({instructions:[xs({payer:this.scope.ownerPubKey,rewardVault:d,userRewardTokenPub:y,farmKeys:c,rewardInfo:n})],instructionTypes:[U.FarmV6Restart]}).versionBuild({txVersion:o})}async restartRewards({farmInfo:e,payer:t,newRewardInfos:n,txVersion:o,feePayer:r}){var m;let i=qt[e.programId];i!==6&&this.logAndCreateError("invalid farm version ",i);let a=Fe((await this.scope.api.fetchFarmKeysById({ids:e.id}))[0]),c={id:a.id,rewardInfos:e.rewardInfos,lpVault:a.lpVault,programId:a.programId};n.forEach(p=>{p.openTime>=p.endTime&&this.logAndCreateError("start time error","newRewardInfo",p)});let u=t||this.scope.ownerPubKey,l=this.createTxBuilder(r);for(let p of n){let d=p.mint.equals(st)?new Ke(at.address):p.mint,f=c.rewardInfos.findIndex(I=>new Ke(I.mint.address).equals(d)),y=a.rewardInfos[f];y||this.logAndCreateError("configuration does not exist","rewardMint",d);let b=(m=y.vault)!=null?m:st,{rewardPubKey:g,newInstruction:P}=await this._getUserRewardInfo({rewardInfo:p,payer:u});P&&l.addInstruction(P),g||this.logAndCreateError("cannot found target token accounts",this.scope.account.tokenAccounts);let h=xs({payer:this.scope.ownerPubKey,rewardVault:b,userRewardTokenPub:g,farmKeys:c,rewardInfo:p});l.addInstruction({instructions:[h],instructionTypes:[U.FarmV6Restart]})}return l.versionBuild({txVersion:o})}async addNewRewardToken(e){let{txVersion:t,farmInfo:n,newRewardInfo:o,payer:r,feePayer:i}=e,a=qt[n.programId];a!==6&&this.logAndCreateError("invalid farm version ",a);let c=Fe((await this.scope.api.fetchFarmKeysById({ids:n.id}))[0]),u=r!=null?r:this.scope.ownerPubKey,l=this.createTxBuilder(i),m=o.mint.equals(st)?new Ke(at.address):o.mint,p=bi({programId:new Ke(n.programId),poolId:new Ke(n.id),mint:m,type:"rewardVault"}),{rewardPubKey:d,newInstruction:f}=await this._getUserRewardInfo({rewardInfo:o,payer:u});return f&&l.addInstruction(f),d||this.logAndCreateError("annot found target token accounts",this.scope.account.tokenAccounts),o.mint=m,l.addInstruction({instructions:[Ss({payer:this.scope.ownerPubKey,userRewardTokenPub:d,farmKeys:c,rewardVault:p,rewardInfo:o})],instructionTypes:[U.FarmV6CreatorAddReward]}).versionBuild({txVersion:t})}async addNewRewardsToken(e){let{txVersion:t,farmInfo:n,newRewardInfos:o,payer:r,feePayer:i}=e,a=qt[n.programId];a!==6&&this.logAndCreateError("invalid farm version ",a);let c=Fe((await this.scope.api.fetchFarmKeysById({ids:n.id}))[0]),u=r!=null?r:this.scope.ownerPubKey,l=this.createTxBuilder(i);for(let m of o){let p=m.mint.equals(st)?new Ke(at.address):m.mint,d=bi({programId:new Ke(n.programId),poolId:new Ke(n.id),mint:p,type:"rewardVault"}),{rewardPubKey:f,newInstruction:y}=await this._getUserRewardInfo({rewardInfo:m,payer:u});y&&l.addInstruction(y),f||this.logAndCreateError("cannot found target token accounts",this.scope.account.tokenAccounts);let b=Ss({payer:this.scope.ownerPubKey,userRewardTokenPub:f,farmKeys:c,rewardVault:d,rewardInfo:q(N({},m),{mint:p})});l.addInstruction({instructions:[b],instructionTypes:[U.FarmV6CreatorAddReward]})}return l.versionBuild({txVersion:t})}async deposit(e){let{txVersion:t,farmInfo:n,amount:o,feePayer:r,useSOLBalance:i,associatedOnly:a=!0,checkCreateATAOwner:c=!1,userAuxiliaryLedgers:u,computeBudgetConfig:l,txTipConfig:m}=e;this.scope.availability.addFarm===!1&&this.logAndCreateError("farm deposit feature disabled in your region");let{rewardInfos:p,programId:d}=n,f=qt[d];f===4&&this.logAndCreateError("V4 has suspended deposits:",n.programId),bs(f)||this.logAndCreateError("invalid farm program:",n.programId);let[y,b]=[new Ke(n.programId),new Ke(n.id)],g=(await this.scope.api.fetchFarmKeysById({ids:n.id}))[0],P=bt({programId:y,poolId:b,owner:this.scope.ownerPubKey,version:f}),h=this.createTxBuilder(r);h.addCustomComputeBudget(l),h.addTipInstruction(m);let I={};for(let R of this.scope.account.tokenAccounts)if(a){let L=j(this.scope.ownerPubKey,R.mint,R.programId).publicKey;R.publicKey&&L.equals(R.publicKey)&&(I[R.mint.toString()]=R.publicKey)}else I[R.mint.toString()]=R.publicKey;let T=g.lpMint,w=I[T.address];w||this.logAndCreateError("you don't have any lp","lp zero",I);let x=[];for(let R of p){let L=i&&R.mint.address===H.toString(),W=I[R.mint.address];if(!W){let{account:z,instructionParams:$}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:R.mint.programId,mint:new Ke(R.mint.address),notUseTokenAccount:L,createInfo:{payer:r||this.scope.ownerPubKey,amount:0},owner:this.scope.ownerPubKey,skipCloseAccount:!L,associatedOnly:L?!1:a,checkCreateATAOwner:c});W=z,$&&h.addInstruction($)}I[R.mint.address]=W,x.push(W)}let S,K=await this.scope.connection.getAccountInfo(P);if(K&&(S=Ro(f).decode(K.data)),n.programId!==wo.toString()&&n.programId!==Pn.FARM_PROGRAM_ID_V6.toString()&&!S){let{instruction:R,instructionType:L}=Ai({id:b,programId:y,version:f,ledger:P,owner:this.scope.ownerPubKey});h.addInstruction({instructions:[R],instructionTypes:[L]})}let B=gs({version:f,rewardInfos:p,rewardTokenAccountsPublicKeys:x});B&&this.logAndCreateError(B);let C={amount:J(o),owner:this.scope.ownerPubKey,farmInfo:n,farmKeys:g,lpAccount:w,rewardAccounts:x,userAuxiliaryLedgers:u==null?void 0:u.map(R=>new Ke(R))},M=f===6?Wc(C):f===5?Dc(C):Ec(C),V={3:U.FarmV3Deposit,5:U.FarmV5Deposit,6:U.FarmV6Deposit};return h.addInstruction({instructions:[M],instructionTypes:[V[f]]}).versionBuild({txVersion:t})}async withdraw(e){let{txVersion:t,farmInfo:n,amount:o,deposited:r,useSOLBalance:i,feePayer:a,associatedOnly:c=!0,checkCreateATAOwner:u=!1,userAuxiliaryLedgers:l,computeBudgetConfig:m,txTipConfig:p}=e,{rewardInfos:d}=n;this.scope.availability.removeFarm===!1&&this.logAndCreateError("farm withdraw feature disabled in your region");let f=qt[n.programId];bs(f)||this.logAndCreateError("invalid farm program:",n.programId);let y=(await this.scope.api.fetchFarmKeysById({ids:n.id}))[0],b=this.createTxBuilder(a);b.addCustomComputeBudget(m),b.addTipInstruction(p);let g={};for(let B of this.scope.account.tokenAccounts)if(c){let C=j(this.scope.ownerPubKey,B.mint).publicKey;B.publicKey&&C.equals(B.publicKey)&&(g[B.mint.toString()]=B.publicKey)}else g[B.mint.toString()]=B.publicKey;if(f!==4){let B=bt({programId:new Ke(n.programId),poolId:new Ke(n.id),owner:this.scope.ownerPubKey,version:f}),C=await this.scope.connection.getAccountInfo(B);if(C)Ro(f).decode(C.data).deposited.isZero()&&this.logAndCreateError("no deposited lp",{farmId:n.id});else if(f!==6){let{instruction:M,instructionType:V}=Ai({id:new Ke(y.id),programId:new Ke(y.programId),version:f,ledger:B,owner:this.scope.ownerPubKey});b.addInstruction({instructions:[M],instructionTypes:[V]})}}r&&r.isZero()&&!(l||[]).length&&this.logAndCreateError("no deposited lp",{farmId:n.id});let P=y.lpMint.address,h=i&&P===H.toString(),I=g[P.toString()];if(!I){let{account:B,instructionParams:C}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:y.lpMint.programId,mint:new Ke(P),notUseTokenAccount:h,createInfo:{payer:a||this.scope.ownerPubKey,amount:0},owner:this.scope.ownerPubKey,skipCloseAccount:!0,associatedOnly:h?!1:c,checkCreateATAOwner:u});I=B,C&&b.addInstruction(C)}g[P.toString()]=I;let T=[];for(let B of d){let C=i&&B.mint.address===H.toString(),M=g[B.mint.address];if(!M){let{account:V,instructionParams:R}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:B.mint.programId,mint:new Ke(B.mint.address),notUseTokenAccount:C,createInfo:{payer:a||this.scope.ownerPubKey,amount:0},owner:this.scope.ownerPubKey,skipCloseAccount:!C,associatedOnly:C?!1:c,checkCreateATAOwner:u});M=V,R&&b.addInstruction(R)}g[B.mint.address]=M,T.push(M)}let w=gs({version:f,rewardInfos:d,rewardTokenAccountsPublicKeys:T});w&&this.logAndCreateError(w);let x={amount:J(o),owner:this.scope.ownerPubKey,farmInfo:n,farmKeys:y,lpAccount:I,rewardAccounts:T,userAuxiliaryLedgers:l==null?void 0:l.map(B=>new Ke(B))},S=f===6?Pi(x):f===5?ki(x):f===4?_c(x):wi(x),K={3:U.FarmV3Withdraw,4:U.FarmV4Withdraw,5:U.FarmV5Withdraw,6:U.FarmV6Withdraw};return b.addInstruction({instructions:[S],instructionTypes:[K[f]]}).versionBuild({txVersion:t})}async withdrawFarmReward({farmInfo:e,withdrawMint:t,txVersion:n,computeBudgetConfig:o,txTipConfig:r,feePayer:i}){var y;this.scope.checkOwner();let a=Fe((await this.scope.api.fetchFarmKeysById({ids:e.id}))[0]),c=qt[e.programId];c!==6&&this.logAndCreateError("invalid farm version",c);let u=a.rewardInfos.find(b=>yt(b.mint.address).equals(yt(t)));u||this.logAndCreateError("withdraw mint error","rewardInfos",e);let l=(y=u==null?void 0:u.vault)!=null?y:st,m=this.createTxBuilder(i),p;if(t.equals(st)||t.equals(Ke.default)){let b=await vn({connection:this.scope.connection,owner:this.scope.ownerPubKey,payer:this.scope.ownerPubKey,amount:Is(q(N({},u),{openTime:u.openTime,endTime:u.endTime,perSecond:new Gp(u.perSecond).mul(10**u.mint.decimals).toString()}))});p=b.addresses.newAccount,m.addInstruction(b)}else{let b=await this.scope.account.getCreatedTokenAccount({mint:t});b===null?(p=await this.scope.account.getAssociatedTokenAccount(t),m.addInstruction({instructions:[qc(this.scope.ownerPubKey,p,this.scope.ownerPubKey,t)],instructionTypes:[U.CreateATA]})):p=b}let{instruction:d,instructionType:f}=Vc({programId:a.programId,id:a.id,authority:a.authority,lpVault:a.lpVault,rewardVault:l,userRewardToken:p,owner:this.scope.ownerPubKey});return m.addCustomComputeBudget(o),m.addTipInstruction(r),m.addInstruction({instructions:[d],instructionTypes:[f]}).versionBuild({txVersion:n})}async harvestAllRewards(e){let{farmInfoList:t,useSOLBalance:n,feePayer:o,associatedOnly:r=!0,checkCreateATAOwner:i=!1,userAuxiliaryLedgers:a,txVersion:c,computeBudgetConfig:u}=e,l=this.createTxBuilder(o),m={};for(let f of this.scope.account.tokenAccounts)if(r){let y=j(this.scope.ownerPubKey,f.mint).publicKey;f.publicKey&&y.equals(f.publicKey)&&(m[f.mint.toString()]=f.publicKey)}else m[f.mint.toString()]=f.publicKey;let d=(await this.scope.api.fetchFarmKeysById({ids:Object.values(t).map(f=>f.id).join(",")})).reduce((f,y)=>q(N({},f),{[y.id]:y}),{});for(let f of Object.values(t)){let{programId:y,lpMint:b,rewardInfos:g,id:P}=f,h=qt[y],I=b.address,T=n&&I===H.toString(),w=m[I];if(!w){let{account:M,instructionParams:V}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:b.programId,mint:new Ke(I),notUseTokenAccount:T,createInfo:{payer:o||this.scope.ownerPubKey,amount:0},owner:this.scope.ownerPubKey,skipCloseAccount:!0,associatedOnly:T?!1:r,checkCreateATAOwner:i});w=M,V&&l.addInstruction(V)}m[I.toString()]=w;let x=[];for(let M of g){let V=n&&M.mint.address===H.toString(),R=m[M.mint.address];if(!R)if(V){let{account:L,instructionParams:W}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:M.mint.programId,mint:new Ke(M.mint.address),notUseTokenAccount:V,createInfo:{payer:o||this.scope.ownerPubKey,amount:0},owner:this.scope.ownerPubKey,skipCloseAccount:!V,associatedOnly:V?!1:r,checkCreateATAOwner:i});R=L,W&&l.addInstruction(W)}else{let L=new Ke(M.mint.address);R=this.scope.account.getAssociatedTokenAccount(L),l.addInstruction({instructions:[qc(this.scope.ownerPubKey,R,this.scope.ownerPubKey,L)]})}m[M.mint.address]=R,x.push(R)}let S=d[P],K={amount:Je,owner:this.scope.ownerPubKey,farmInfo:f,farmKeys:S,lpAccount:w,rewardAccounts:x,userAuxiliaryLedgers:a==null?void 0:a.map(M=>new Ke(M))},B=h===6?Pi(K):h===5?ki(K):wi(K),C={3:U.FarmV3Withdraw,5:U.FarmV5Withdraw,6:U.FarmV6Withdraw};l.addInstruction({instructions:[B],instructionTypes:[C[h]]})}return c===1?l.sizeCheckBuild({computeBudgetConfig:u}):l.sizeCheckBuildV0({computeBudgetConfig:u})}};import{PublicKey as et}from"@solana/web3.js";import{AccountLayout as Mf,NATIVE_MINT as Qr,TOKEN_PROGRAM_ID as En}from"@solana/spl-token";import{Keypair as Er,PublicKey as G,SystemProgram as Bn,TransactionInstruction as ft}from"@solana/web3.js";import Es from"bn.js";import{ASSOCIATED_TOKEN_PROGRAM_ID as Ri,TOKEN_2022_PROGRAM_ID as Ue,TOKEN_PROGRAM_ID as Re}from"@solana/spl-token";import tf from"bn.js";import Mo from"decimal.js";import Ut from"bn.js";var ge=new Ut(0),vt=new Ut(1),Tn=new Ut(-1),ot=new Ut(1).shln(64),Nr=new Ut(1).shln(128),hi=ot.sub(vt),Ii=64,Uc=Nr.subn(1),gt=-443636,It=-gt,Gt=new Ut("4295048016"),Xt=new Ut("79226673521066979257578248091"),Mr=new Ut("4295048017"),vr=new Ut("79226673521066979257578248090"),Gc=16,Xc="59543866431248",zc="184467440737095516",Qc="15793534762490258745",Fr=new Ut(10).pow(new Ut(6)),Xp=(n=>(n[n.rate_500=500]="rate_500",n[n.rate_3000=3e3]="rate_3000",n[n.rate_10000=1e4]="rate_10000",n))(Xp||{}),GT={[500]:10,[3e3]:60,[1e4]:200},XT={version:6,liquidity:ge,tickCurrent:0,feeGrowthGlobalX64A:ge,feeGrowthGlobalX64B:ge,protocolFeesTokenA:ge,protocolFeesTokenB:ge,swapInAmountTokenA:ge,swapOutAmountTokenB:ge,swapInAmountTokenB:ge,swapOutAmountTokenA:ge,tickArrayBitmap:[],rewardInfos:[],day:{volume:0,volumeFee:0,feeA:0,feeB:0,feeApr:0,rewardApr:{A:0,B:0,C:0},apr:0,priceMax:0,priceMin:0},week:{volume:0,volumeFee:0,feeA:0,feeB:0,feeApr:0,rewardApr:{A:0,B:0,C:0},apr:0,priceMax:0,priceMin:0},month:{volume:0,volumeFee:0,feeA:0,feeB:0,feeApr:0,rewardApr:{A:0,B:0,C:0},apr:0,priceMax:0,priceMin:0},tvl:0},Yc={tvl:0,volumeQuote:0,mintAmountA:0,mintAmountB:0,rewardDefaultInfos:[],farmUpcomingCount:0,farmOngoingCount:0,farmFinishedCount:0,day:{volume:0,volumeQuote:0,volumeFee:0,apr:0,feeApr:0,priceMin:0,priceMax:0,rewardApr:[0]},week:{volume:0,volumeQuote:0,volumeFee:0,apr:0,feeApr:0,priceMin:0,priceMax:0,rewardApr:[0]},month:{volume:0,volumeQuote:0,volumeFee:0,apr:0,feeApr:0,priceMin:0,priceMax:0,rewardApr:[0]},pooltype:[]},zT=new Ut("18446744073700000000");import de from"bn.js";import dn from"decimal.js";function Vr(s){let e=new ArrayBuffer(2);return new DataView(e).setUint16(0,s,!1),new Uint8Array(e)}function YT(s){let e=new ArrayBuffer(2);return new DataView(e).setInt16(0,s,!1),new Uint8Array(e)}function jT(s){let e=new ArrayBuffer(4);return new DataView(e).setUint32(0,s,!1),new Uint8Array(e)}function _r(s){let e=new ArrayBuffer(4);return new DataView(e).setInt32(0,s,!1),new Uint8Array(e)}function Ks(s,e){let t=0;for(let n=s-1;n>=0&&!e.testn(n);n--)t++;return t}function Cs(s,e){let t=0;for(let n=0;n<s&&!e.testn(n);n++)t++;return t}function Bi(s,e){for(let t=0;t<s;t++)if(e.testn(t))return!1;return!0}function jc(s,e){return Bi(s,e)?null:Ks(s,e)}function Hc(s,e){return Bi(s,e)?null:Cs(s,e)}var zp=Buffer.from("amm_config","utf8"),Rs=Buffer.from("pool","utf8"),Ls=Buffer.from("pool_vault","utf8"),Qp=Buffer.from("pool_reward_vault","utf8"),Zc=Buffer.from("position","utf8"),Yp=Buffer.from("tick_array","utf8"),jp=Buffer.from("operation","utf8"),Hp=Buffer.from("pool_tick_array_bitmap_extension","utf8"),Zp=Buffer.from("observation","utf8");function JT(s,e){return ne([zp,Vr(e)],s)}function $c(s,e,t,n){return ne([Rs,e.toBuffer(),t.toBuffer(),n.toBuffer()],s)}function Os(s,e,t){return ne([Ls,e.toBuffer(),t.toBuffer()],s)}function Jc(s,e,t){return ne([Qp,e.toBuffer(),t.toBuffer()],s)}function Ae(s,e,t){return ne([Yp,e.toBuffer(),_r(t)],s)}function an(s,e,t,n){return ne([Zc,e.toBuffer(),_r(t),_r(n)],s)}function Bt(s,e){return ne([Zc,e.toBuffer()],s)}function hn(s){return ne([Buffer.from("metadata","utf8"),Jt.toBuffer(),s.toBuffer()],Jt)}function xi(s){return ne([jp],s)}function je(s,e){return ne([Hp,e.toBuffer()],s)}function el(s,e){return ne([Zp,e.toBuffer()],s)}var tl=Buffer.from("locked_position","utf8");function Ns(s,e){return ne([tl,e.toBuffer()],s)}function Oo(s,e){return ne([tl,e.toBuffer()],s)}var $p=Buffer.from("support_mint","utf8");function Ms(s,e){return ne([$p,e.toBuffer()],s)}import{PublicKey as Ft}from"@solana/web3.js";import{TOKEN_2022_PROGRAM_ID as nl}from"@solana/spl-token";import Ee from"bn.js";import ke from"decimal.js";import mn from"bn.js";import vs from"decimal.js";var Si=class{static getfeeGrowthInside(e,t,n){let o=new mn(0),r=new mn(0);e.tickCurrent>=t.tick?(o=t.feeGrowthOutsideX64A,r=t.feeGrowthOutsideX64B):(o=e.feeGrowthGlobalX64A.sub(t.feeGrowthOutsideX64A),r=e.feeGrowthGlobalX64B.sub(t.feeGrowthOutsideX64B));let i=new mn(0),a=new mn(0);e.tickCurrent<n.tick?(i=n.feeGrowthOutsideX64A,a=n.feeGrowthOutsideX64B):(i=e.feeGrowthGlobalX64A.sub(n.feeGrowthOutsideX64A),a=e.feeGrowthGlobalX64B.sub(n.feeGrowthOutsideX64B));let c=ue.wrappingSubU128(ue.wrappingSubU128(e.feeGrowthGlobalX64A,o),i),u=ue.wrappingSubU128(ue.wrappingSubU128(e.feeGrowthGlobalX64B,r),a);return{feeGrowthInsideX64A:c,feeGrowthInsideBX64:u}}static GetPositionFees(e,t,n,o){let{feeGrowthInsideX64A:r,feeGrowthInsideBX64:i}=this.getfeeGrowthInside(e,n,o),a=ue.mulDivFloor(ue.wrappingSubU128(r,t.feeGrowthInsideLastX64A),t.liquidity,ot),c=t.tokenFeesOwedA.add(a),u=ue.mulDivFloor(ue.wrappingSubU128(i,t.feeGrowthInsideLastX64B),t.liquidity,ot),l=t.tokenFeesOwedB.add(u);return{tokenFeeAmountA:c,tokenFeeAmountB:l}}static GetPositionFeesV2(e,t,n,o){let{feeGrowthInsideX64A:r,feeGrowthInsideBX64:i}=this.getfeeGrowthInside(e,n,o),a=ue.mulDivFloor(ue.wrappingSubU128(r,t.feeGrowthInsideLastX64A),t.liquidity,ot),c=t.tokenFeesOwedA.add(a),u=ue.mulDivFloor(ue.wrappingSubU128(i,t.feeGrowthInsideLastX64B),t.liquidity,ot),l=t.tokenFeesOwedB.add(u);return{tokenFeeAmountA:c,tokenFeeAmountB:l}}static GetPositionRewardsV2(e,t,n,o){let r=[],i=this.getRewardGrowthInsideV2(e.tickCurrent,n,o,e.rewardInfos);for(let a=0;a<i.length;a++){let c=i[a],u=t.rewardInfos[a],l=ue.wrappingSubU128(c,u.growthInsideLastX64),m=ue.mulDivFloor(l,t.liquidity,ot),p=u.rewardAmountOwed.add(m);r.push(p)}return r}static GetPositionRewards(e,t,n,o){let r=[],i=this.getRewardGrowthInside(e.tickCurrent,n,o,e.rewardInfos);for(let a=0;a<i.length;a++){let c=i[a],u=t.rewardInfos[a],l=ue.wrappingSubU128(c,u.growthInsideLastX64),m=ue.mulDivFloor(l,t.liquidity,ot),p=u.rewardAmountOwed.add(m);r.push(p)}return r}static getRewardGrowthInside(e,t,n,o){let r=[];for(let i=0;i<o.length;i++){let a=new mn(0);t.liquidityGross.eqn(0)?a=o[i].rewardGrowthGlobalX64:e<t.tick?a=o[i].rewardGrowthGlobalX64.sub(t.rewardGrowthsOutsideX64[i]):a=t.rewardGrowthsOutsideX64[i];let c=new mn(0);n.liquidityGross.eqn(0)||(e<n.tick?c=n.rewardGrowthsOutsideX64[i]:c=o[i].rewardGrowthGlobalX64.sub(n.rewardGrowthsOutsideX64[i])),r.push(ue.wrappingSubU128(ue.wrappingSubU128(o[i].rewardGrowthGlobalX64,a),c))}return r}static getRewardGrowthInsideV2(e,t,n,o){let r=[];for(let i=0;i<o.length;i++){let a=new mn(0);t.liquidityGross.eqn(0)?a=o[i].rewardGrowthGlobalX64:e<t.tick?a=o[i].rewardGrowthGlobalX64.sub(t.rewardGrowthsOutsideX64[i]):a=t.rewardGrowthsOutsideX64[i];let c=new mn(0);n.liquidityGross.eqn(0)||(e<n.tick?c=n.rewardGrowthsOutsideX64[i]:c=o[i].rewardGrowthGlobalX64.sub(n.rewardGrowthsOutsideX64[i])),r.push(ue.wrappingSubU128(ue.wrappingSubU128(o[i].rewardGrowthGlobalX64,a),c))}return r}static getAmountsFromLiquidity({poolInfo:e,ownerPosition:t,liquidity:n,slippage:o,add:r,epochInfo:i}){var b,g,P,h;let a=ie.priceToSqrtPriceX64(new vs(e.price),e.mintA.decimals,e.mintB.decimals),c=ie.getSqrtPriceX64FromTick(t.tickLower),u=ie.getSqrtPriceX64FromTick(t.tickUpper),l=r?1+o:1-o,m=Pe.getAmountsFromLiquidity(a,c,u,n,r),[p,d]=[Be(m.amountA,(b=e.mintA.extensions)==null?void 0:b.feeConfig,i,!0),Be(m.amountB,(g=e.mintB.extensions)==null?void 0:g.feeConfig,i,!0)],[f,y]=[Be(new mn(new vs(m.amountA.toString()).mul(l).toFixed(0)),(P=e.mintA.extensions)==null?void 0:P.feeConfig,i,!0),Be(new mn(new vs(m.amountB.toString()).mul(l).toFixed(0)),(h=e.mintB.extensions)==null?void 0:h.feeConfig,i,!0)];return{liquidity:n,amountA:p,amountB:d,amountSlippageA:f,amountSlippageB:y,expirationTime:tn(p.expirationTime,d.expirationTime)}}};var Jp=15,Te=class{static async getTickArrays(e,t,n,o,r,i,a){let c=[],u=Z.getTickArrayStartIndexByTick(o,r),l=Z.getInitializedTickArrayInRange(i,a,r,u,Math.floor(Jp/2));for(let d=0;d<l.length;d++){let{publicKey:f}=Ae(t,n,l[d]);c.push(f)}let m=(await $t(e,c)).map(d=>d!==null?Ki.decode(d.data):null),p={};for(let d=0;d<c.length;d++){let f=m[d];f!==null&&(p[f.startTickIndex]=q(N({},f),{address:c[d]}))}return p}static nextInitializedTick(e,t,n,o,r,i){let{initializedTick:a,tickArrayAddress:c,tickArrayStartTickIndex:u}=this.nextInitializedTickInOneArray(e,t,n,o,r,i);for(;a==null||a.liquidityGross.lten(0);){if(u=Z.getNextTickArrayStartIndex(u,r,i),this.checkIsValidStartIndex(u,r))throw new Error("No enough initialized tickArray");let l=n[u];if(l===void 0)continue;let{nextTick:m,tickArrayAddress:p,tickArrayStartTickIndex:d}=this.firstInitializedTickInOneArray(e,t,l,i);[a,c,u]=[m,p,d]}if(a==null)throw new Error("No invaild tickArray cache");return{nextTick:a,tickArrayAddress:c,tickArrayStartTickIndex:u}}static nextInitializedTickArray(e,t,n,o,r){let i=Math.floor(e/Te.tickCount(t)),a=n?Z.searchLowBitFromStart(o,r,i-1,1,t):Z.searchHightBitFromStart(o,r,i+1,1,t);return a.length>0?{isExist:!0,nextStartIndex:a[0]}:{isExist:!1,nextStartIndex:0}}static firstInitializedTickInOneArray(e,t,n,o){let r;if(o){let a=it-1;for(;a>=0;){let c=n.ticks[a];if(c.liquidityGross.gtn(0)){r=c;break}a=a-1}}else{let a=0;for(;a<it;){let c=n.ticks[a];if(c.liquidityGross.gtn(0)){r=c;break}a=a+1}}let{publicKey:i}=Ae(e,t,n.startTickIndex);return{nextTick:r,tickArrayAddress:i,tickArrayStartTickIndex:n.startTickIndex}}static nextInitializedTickInOneArray(e,t,n,o,r,i){let a=Z.getTickArrayStartIndexByTick(o,r),c=Math.floor((o-a)/r),u=n[a];if(u==null)return{initializedTick:void 0,tickArrayAddress:void 0,tickArrayStartTickIndex:a};let l;if(i)for(;c>=0;){let p=u.ticks[c];if(p.liquidityGross.gtn(0)){l=p;break}c=c-1}else for(c=c+1;c<it;){let p=u.ticks[c];if(p.liquidityGross.gtn(0)){l=p;break}c=c+1}let{publicKey:m}=Ae(e,t,a);return{initializedTick:l,tickArrayAddress:m,tickArrayStartTickIndex:u.startTickIndex}}static getArrayStartIndex(e,t){let n=this.tickCount(t);return Math.floor(e/n)*n}static checkIsValidStartIndex(e,t){if(Z.checkIsOutOfBoundary(e)){if(e>It)return!1;let n=Z.getTickArrayStartIndexByTick(gt,t);return e==n}return e%this.tickCount(t)==0}static tickCount(e){return it*e}};var Fs=14,In=class{static maxTickInTickarrayBitmap(e){return e*it*eo}static getBitmapTickBoundary(e,t){let n=this.maxTickInTickarrayBitmap(t),o=Math.floor(Math.abs(e)/n);e<0&&Math.abs(e)%n!=0&&(o+=1);let r=n*o;return e<0?{minValue:-r,maxValue:-r+n}:{minValue:r,maxValue:r+n}}static nextInitializedTickArrayStartIndex(e,t,n,o){if(!Te.checkIsValidStartIndex(t,n))throw Error("nextInitializedTickArrayStartIndex check error");let r=this.maxTickInTickarrayBitmap(n),i=o?t-Te.tickCount(n):t+Te.tickCount(n);if(i<-r||i>=r)return{isInit:!1,tickIndex:t};let a=n*it,c=i/a+512;i<0&&i%a!=0&&c--;let u=Math.abs(c);if(o){let l=e.shln(1024-u-1),m=jc(1024,l);if(m!==null){let p=(u-m-512)*a;return{isInit:!0,tickIndex:p}}else return{isInit:!1,tickIndex:-r}}else{let l=e.shrn(u),m=Hc(1024,l);if(m!==null){let p=(u+m-512)*a;return{isInit:!0,tickIndex:p}}else return{isInit:!1,tickIndex:r-Te.tickCount(n)}}}},Ci=class{static getBitmapOffset(e,t){if(!Te.checkIsValidStartIndex(e,t))throw new Error("No enough initialized tickArray");this.checkExtensionBoundary(e,t);let n=In.maxTickInTickarrayBitmap(t),o=Math.floor(Math.abs(e)/n)-1;return e<0&&Math.abs(e)%n===0&&o--,o}static getBitmap(e,t,n){let o=this.getBitmapOffset(e,t);return e<0?{offset:o,tickarrayBitmap:n.negativeTickArrayBitmap[o]}:{offset:o,tickarrayBitmap:n.positiveTickArrayBitmap[o]}}static checkExtensionBoundary(e,t){let{positiveTickBoundary:n,negativeTickBoundary:o}=this.extensionTickBoundary(t);if(e>=o&&e<n)throw Error("checkExtensionBoundary -> InvalidTickArrayBoundary")}static extensionTickBoundary(e){let t=In.maxTickInTickarrayBitmap(e),n=-t;if(It<=t)throw Error(`extensionTickBoundary check error: ${It}, ${t}`);if(n<=gt)throw Error(`extensionTickBoundary check error: ${n}, ${gt}`);return{positiveTickBoundary:t,negativeTickBoundary:n}}static checkTickArrayIsInit(e,t,n){let{tickarrayBitmap:o}=this.getBitmap(e,t,n),r=this.tickArrayOffsetInBitmap(e,t);return{isInitialized:Z.mergeTickArrayBitmap(o).testn(r),startIndex:e}}static nextInitializedTickArrayFromOneBitmap(e,t,n,o){let r=Te.tickCount(t),i=n?e-r:e+r,{tickarrayBitmap:a}=this.getBitmap(i,t,o);return this.nextInitializedTickArrayInBitmap(a,i,t,n)}static nextInitializedTickArrayInBitmap(e,t,n,o){let{minValue:r,maxValue:i}=In.getBitmapTickBoundary(t,n),a=this.tickArrayOffsetInBitmap(t,n);if(o){let c=Z.mergeTickArrayBitmap(e).shln(eo-1-a),u=Bi(512,c)?null:Ks(512,c);if(u!==null){let l=t-u*Te.tickCount(n);return{isInit:!0,tickIndex:l}}else return{isInit:!1,tickIndex:r}}else{let c=Z.mergeTickArrayBitmap(e).shrn(a),u=Bi(512,c)?null:Cs(512,c);if(u!==null){let l=t+u*Te.tickCount(n);return{isInit:!0,tickIndex:l}}else return{isInit:!1,tickIndex:i-Te.tickCount(n)}}}static tickArrayOffsetInBitmap(e,t){let n=Math.abs(e)%In.maxTickInTickarrayBitmap(t),o=Math.floor(n/Te.tickCount(t));return e<0&&n!=0&&(o=eo-o),o}};var ve=class{static getOutputAmountAndRemainAccounts(e,t,n,o,r,i=!1){let a=n.toBase58()===e.mintA.address,c=[],{isExist:u,startIndex:l,nextAccountMeta:m}=this.getFirstInitializedTickArray(e,a);if(!u||l===void 0||!m)throw new Error("Invalid tick array");c.push(m);let{allTrade:p,amountCalculated:d,accounts:f,sqrtPriceX64:y,feeAmount:b}=to.swapCompute(e.programId,e.id,t,e.tickArrayBitmap,e.exBitmapInfo,a,e.ammConfig.tradeFeeRate,e.liquidity,e.tickCurrent,e.tickSpacing,e.sqrtPriceX64,o,l,r,i);return c.push(...f),{allTrade:p,expectedAmountOut:d.mul(Tn),remainingAccounts:c,executionPrice:y,feeAmount:b}}static getInputAmountAndRemainAccounts(e,t,n,o,r){let i=n.toBase58()===e.mintB.address,a=[],{isExist:c,startIndex:u,nextAccountMeta:l}=this.getFirstInitializedTickArray(e,i);if(!c||u===void 0||!l)throw new Error("Invalid tick array");try{let y=this.preInitializedTickArrayStartIndex(e,i);if(y.isExist){let{publicKey:b}=Ae(e.programId,e.id,y.nextStartIndex);a.push(b)}}catch{}a.push(l);let{amountCalculated:m,accounts:p,sqrtPriceX64:d,feeAmount:f}=to.swapCompute(e.programId,e.id,t,e.tickArrayBitmap,e.exBitmapInfo,i,e.ammConfig.tradeFeeRate,e.liquidity,e.tickCurrent,e.tickSpacing,e.sqrtPriceX64,o.mul(Tn),u,r);return a.push(...p),{expectedAmountIn:m,remainingAccounts:a,executionPrice:d,feeAmount:f}}static getFirstInitializedTickArray(e,t){let{isInitialized:n,startIndex:o}=ve.isOverflowDefaultTickarrayBitmap(e.tickSpacing,[e.tickCurrent])?Ci.checkTickArrayIsInit(Te.getArrayStartIndex(e.tickCurrent,e.tickSpacing),e.tickSpacing,e.exBitmapInfo):Z.checkTickArrayIsInitialized(Z.mergeTickArrayBitmap(e.tickArrayBitmap),e.tickCurrent,e.tickSpacing);if(n){let{publicKey:a}=Ae(e.programId,e.id,o);return{isExist:!0,startIndex:o,nextAccountMeta:a}}let{isExist:r,nextStartIndex:i}=this.nextInitializedTickArrayStartIndex(e,Te.getArrayStartIndex(e.tickCurrent,e.tickSpacing),t);if(r){let{publicKey:a}=Ae(e.programId,e.id,i);return{isExist:!0,startIndex:i,nextAccountMeta:a}}return{isExist:!1,nextAccountMeta:void 0,startIndex:void 0}}static preInitializedTickArrayStartIndex(e,t){let n=Math.floor(e.tickCurrent/Te.tickCount(e.tickSpacing)),o=t?Z.searchHightBitFromStart(e.tickArrayBitmap,e.exBitmapInfo,n+1,1,e.tickSpacing):Z.searchLowBitFromStart(e.tickArrayBitmap,e.exBitmapInfo,n-1,1,e.tickSpacing);return o.length>0?{isExist:!0,nextStartIndex:o[0]}:{isExist:!1,nextStartIndex:0}}static nextInitializedTickArrayStartIndex(e,t,n){for(t=Te.getArrayStartIndex(e.tickCurrent,e.tickSpacing);;){let{isInit:o,tickIndex:r}=In.nextInitializedTickArrayStartIndex(Z.mergeTickArrayBitmap(e.tickArrayBitmap),t,e.tickSpacing,n);if(o)return{isExist:!0,nextStartIndex:r};t=r;let{isInit:i,tickIndex:a}=Ci.nextInitializedTickArrayFromOneBitmap(t,e.tickSpacing,n,e.exBitmapInfo);if(i)return{isExist:!0,nextStartIndex:a};if(t=a,t<gt||t>It)return{isExist:!1,nextStartIndex:0}}}static async updatePoolRewardInfos({connection:e,apiPoolInfo:t,chainTime:n,poolLiquidity:o,rewardInfos:r}){var a,c,u;let i=[];for(let l=0;l<r.length;l++){let m=r[l],p=(u=(a=t.rewardDefaultInfos[l])==null?void 0:a.mint.programId)!=null?u:(c=await e.getAccountInfo(m.tokenMint))==null?void 0:c.owner;if(p===void 0)throw Error("get new reward mint info error");let d=q(N({},m),{perSecond:ue.x64ToDecimal(m.emissionsPerSecondX64),remainingRewards:void 0,tokenProgramId:new Ft(p)});if(d.tokenMint.equals(Ft.default))continue;if(n<=d.openTime.toNumber()||o.eq(ge)){i.push(d);continue}let f=new Ee(Math.min(d.endTime.toNumber(),n)),y=f.sub(d.lastUpdateTime),b=ue.mulDivFloor(y,d.emissionsPerSecondX64,o),g=d.rewardGrowthGlobalX64.add(b),P=ue.mulDivFloor(y,d.emissionsPerSecondX64,ot),h=d.rewardTotalEmissioned.add(P);i.push(q(N({},d),{rewardGrowthGlobalX64:g,rewardTotalEmissioned:h,lastUpdateTime:f}))}return i}static isOverflowDefaultTickarrayBitmap(e,t){let{maxTickBoundary:n,minTickBoundary:o}=this.tickRange(e);for(let r of t){let i=Z.getTickArrayStartIndexByTick(r,e);if(i>=n||i<o)return!0}return!1}static tickRange(e){let t=In.maxTickInTickarrayBitmap(e),n=-t;return t>It&&(t=Te.getArrayStartIndex(It,e)+Te.tickCount(e)),n<gt&&(n=Te.getArrayStartIndex(gt,e)),{maxTickBoundary:t,minTickBoundary:n}}static get_tick_array_offset(e,t){if(!Te.checkIsValidStartIndex(e,t))throw new Error("No enough initialized tickArray");return e/Te.tickCount(t)*eo}static async fetchExBitmaps({connection:e,exBitmapAddress:t,batchRequest:n}){let o=await Me(e,t.map(i=>({pubkey:i})),{batchRequest:n}),r={};for(let i of o)i.accountInfo!==null&&(r[i.pubkey.toString()]=il.decode(i.accountInfo.data));return r}static async fetchMultiplePoolTickArrays({connection:e,poolKeys:t,batchRequest:n}){let o={},r=[];for(let c of t){let u=Z.getTickArrayStartIndexByTick(c.tickCurrent,c.tickSpacing),l=Z.getInitializedTickArrayInRange(c.tickArrayBitmap,c.exBitmapInfo,c.tickSpacing,u,7);for(let m of l){let{publicKey:p}=Ae(c.programId,c.id,m);r.push({pubkey:p}),o[p.toString()]=c.id}}let i=await Me(e,r,{batchRequest:n}),a={};for(let c of i){if(!c.accountInfo)continue;let u=o[c.pubkey.toString()];if(!u)continue;a[u.toString()]===void 0&&(a[u.toString()]={});let l=Ki.decode(c.accountInfo.data);a[u.toString()][l.startTickIndex]=q(N({},l),{address:c.pubkey})}return a}static async fetchPoolsAccountPosition({pools:e,connection:t,ownerInfo:n,batchRequest:o=!1,updateOwnerRewardAndFee:r=!0}){var a;let i=[];for(let c=0;c<e.length;c++){let u=e[c];u!==null&&(i.find(l=>l.equals(u.state.programId))||i.push(u.state.programId))}if(n){let c=n.tokenAccounts.map(p=>p.accountInfo.mint),u=[];for(let p of c)for(let d of i)u.push(Bt(d,p).publicKey);let l=await $t(t,u,{batchRequest:o}),m={};for(let p of l){if(p===null)continue;let d=No.decode(p.data),f=d.poolId.toString(),y=e.find(S=>S.state.id.toBase58()===f);if(y===void 0)continue;let b=y.state,g=Z._getTickPriceLegacy({poolInfo:b,tick:d.tickLower,baseIn:!0}),P=Z._getTickPriceLegacy({poolInfo:b,tick:d.tickUpper,baseIn:!0}),{amountA:h,amountB:I}=Pe.getAmountsFromLiquidity(b.sqrtPriceX64,g.tickSqrtPriceX64,P.tickSqrtPriceX64,d.liquidity,!1),T=1/(1-Math.sqrt(Math.sqrt(g.price.div(P.price).toNumber())));y.positionAccount=[...(a=y.positionAccount)!=null?a:[],{poolId:d.poolId,nftMint:d.nftMint,priceLower:g.price,priceUpper:P.price,amountA:h,amountB:I,tickLower:d.tickLower,tickUpper:d.tickUpper,liquidity:d.liquidity,feeGrowthInsideLastX64A:d.feeGrowthInsideLastX64A,feeGrowthInsideLastX64B:d.feeGrowthInsideLastX64B,tokenFeesOwedA:d.tokenFeesOwedA,tokenFeesOwedB:d.tokenFeesOwedB,rewardInfos:d.rewardInfos.map(S=>q(N({},S),{pendingReward:new Ee(0)})),leverage:T,tokenFeeAmountA:new Ee(0),tokenFeeAmountB:new Ee(0)}];let w=await Z.getTickArrayAddressByTick(y.state.programId,d.poolId,d.tickLower,y.state.tickSpacing),x=await Z.getTickArrayAddressByTick(y.state.programId,d.poolId,d.tickUpper,y.state.tickSpacing);m[`${y.state.programId.toString()}-${d.poolId.toString()}-${d.tickLower}`]=w,m[`${y.state.programId.toString()}-${d.poolId.toString()}-${d.tickUpper}`]=x}if(r){let p=Object.values(m),d=await $t(t,p,{batchRequest:o}),f={};for(let y=0;y<p.length;y++){let b=d[y];if(b===null)continue;let g=p[y].toString();f[g]=Ki.decode(b.data)}for(let{state:y,positionAccount:b}of e)if(!!b)for(let g of b){let P=`${y.programId.toString()}-${y.id.toString()}-${g.tickLower}`,h=`${y.programId.toString()}-${y.id.toString()}-${g.tickUpper}`,I=f[m[P].toString()],T=f[m[h].toString()],w=I.ticks[Z.getTickOffsetInArray(g.tickLower,y.tickSpacing)],x=T.ticks[Z.getTickOffsetInArray(g.tickUpper,y.tickSpacing)],{tokenFeeAmountA:S,tokenFeeAmountB:K}=await Si.GetPositionFees(y,g,w,x),B=await Si.GetPositionRewards(y,g,w,x);g.tokenFeeAmountA=S.gte(new Ee(0))?S:new Ee(0),g.tokenFeeAmountB=K.gte(new Ee(0))?K:new Ee(0);for(let C=0;C<B.length;C++)g.rewardInfos[C].pendingReward=B[C].gte(new Ee(0))?B[C]:new Ee(0)}}}return e}static computeAmountOut({poolInfo:e,tickArrayCache:t,baseMint:n,epochInfo:o,amountIn:r,slippage:i,priceLimit:a=new ke(0),catchLiquidityInsufficient:c=!1}){var M;let u,l=n.toBase58()===e.mintA.address,[m,p]=l?[e.mintA.extensions.feeConfig,e.mintB.extensions.feeConfig]:[e.mintB.extensions.feeConfig,e.mintA.extensions.feeConfig];a.equals(new ke(0))?u=l?Gt.add(new Ee(1)):Xt.sub(new Ee(1)):u=ie.priceToSqrtPriceX64(a,e.mintA.decimals,e.mintB.decimals);let d=Be(r,m,o,!1),{allTrade:f,expectedAmountOut:y,remainingAccounts:b,executionPrice:g,feeAmount:P}=ve.getOutputAmountAndRemainAccounts(e,t,n,d.amount.sub((M=d.fee)!=null?M:ge),u,c),h=Be(y,p,o,!1),I=ie.sqrtPriceX64ToPrice(g,e.mintA.decimals,e.mintB.decimals),T=l?I:new ke(1).div(I),w=y.mul(new Ee(Math.floor((1-i)*1e10))).div(new Ee(1e10)),x=Be(w,p,o,!1),S=l?e.currentPrice:new ke(1).div(e.currentPrice),K=new ke(T).sub(S).abs(),B=S,C=new ze(new ke(K).mul(10**15).toFixed(0),new ke(B).mul(10**15).toFixed(0));return{allTrade:f,realAmountIn:d,amountOut:h,minAmountOut:x,expirationTime:tn(d.expirationTime,h.expirationTime),currentPrice:e.currentPrice,executionPrice:T,priceImpact:C,fee:P,remainingAccounts:b,executionPriceX64:g}}static computeAmountOutFormat({poolInfo:e,tickArrayCache:t,amountIn:n,tokenOut:o,slippage:r,epochInfo:i,catchLiquidityInsufficient:a=!1}){let c=o.address===e.mintB.address,[u,l]=c?[e.mintA,e.mintB]:[e.mintB,e.mintA],[m,p]=[new Se(q(N({},u),{mint:u.address,isToken2022:u.programId===nl.toBase58()})),new Se(q(N({},l),{mint:l.address,isToken2022:l.programId===nl.toBase58()}))],{allTrade:d,realAmountIn:f,amountOut:y,minAmountOut:b,expirationTime:g,currentPrice:P,executionPrice:h,priceImpact:I,fee:T,remainingAccounts:w,executionPriceX64:x}=ve.computeAmountOut({poolInfo:e,tickArrayCache:t,baseMint:new Ft(u.address),amountIn:n,slippage:r,epochInfo:i,catchLiquidityInsufficient:a}),S=q(N({},f),{amount:new he(m,f.amount),fee:f.fee===void 0?void 0:new he(m,f.fee)}),K=q(N({},y),{amount:new he(p,y.amount),fee:y.fee===void 0?void 0:new he(p,y.fee)}),B=q(N({},b),{amount:new he(p,b.amount),fee:b.fee===void 0?void 0:new he(p,b.fee)}),C=new ut({baseToken:m,denominator:new Ee(10).pow(new Ee(20+m.decimals)),quoteToken:p,numerator:P.mul(new ke(10**(20+p.decimals))).toFixed(0)}),M=new ut({baseToken:m,denominator:new Ee(10).pow(new Ee(20+m.decimals)),quoteToken:p,numerator:h.mul(new ke(10**(20+p.decimals))).toFixed(0)}),V=new he(m,T);return{allTrade:d,realAmountIn:S,amountOut:K,minAmountOut:B,expirationTime:g,currentPrice:C,executionPrice:M,priceImpact:I,fee:V,remainingAccounts:w,executionPriceX64:x}}static computeAmountIn({poolInfo:e,tickArrayCache:t,baseMint:n,epochInfo:o,amountOut:r,slippage:i,priceLimit:a=new ke(0)}){var B;let c=n.toBase58()===e.mintA.address,u={[e.mintA.address]:e.mintA.extensions.feeConfig,[e.mintB.address]:e.mintB.extensions.feeConfig},l;a.equals(new ke(0))?l=c?Xt.sub(new Ee(1)):Gt.add(new Ee(1)):l=ie.priceToSqrtPriceX64(a,e.mintA.decimals,e.mintB.decimals);let m=Be(r,u[n.toString()],o,!0),{expectedAmountIn:p,remainingAccounts:d,executionPrice:f,feeAmount:y}=ve.getInputAmountAndRemainAccounts(e,t,n,m.amount.sub((B=m.fee)!=null?B:ge),l),b=c?e.mintB.address:e.mintA.address,g=Be(p,u[b],o,!1),P=ie.sqrtPriceX64ToPrice(f,e.mintA.decimals,e.mintB.decimals),h=c?P:new ke(1).div(P),I=p.mul(new Ee(Math.floor((1+i)*1e10))).div(new Ee(1e10)),T=Be(I,u[b],o,!0),w=c?e.currentPrice:new ke(1).div(e.currentPrice),x=new ke(h).sub(w).abs(),S=w,K=new ze(new ke(x).mul(10**15).toFixed(0),new ke(S).mul(10**15).toFixed(0));return{amountIn:g,maxAmountIn:T,realAmountOut:m,expirationTime:tn(g.expirationTime,m.expirationTime),currentPrice:e.currentPrice,executionPrice:h,priceImpact:K,fee:y,remainingAccounts:d}}static estimateAprsForPriceRangeMultiplier({poolInfo:e,aprType:t,positionTickLowerIndex:n,positionTickUpperIndex:o}){var f,y,b;let r=e[t],i=Z.getTickPrice({poolInfo:e,tick:n,baseIn:!0}).price.toNumber(),a=Z.getTickPrice({poolInfo:e,tick:o,baseIn:!0}).price.toNumber(),c=Math.max(i,r.priceMin),l=Math.min(a,r.priceMax)-c,m=a-i,p=r.priceMax-r.priceMin,d;return l<=0?d=0:m===l?d=p/l:p===l?d=l/m:d=l/p*(l/m),{feeApr:r.feeApr*d,rewardsApr:[((f=r.rewardApr[0])!=null?f:0)*d,((y=r.rewardApr[1])!=null?y:0)*d,((b=r.rewardApr[2])!=null?b:0)*d],apr:r.apr*d}}static estimateAprsForPriceRangeDelta({poolInfo:e,poolLiquidity:t,aprType:n,mintPrice:o,liquidity:r,positionTickLowerIndex:i,positionTickUpperIndex:a,chainTime:c}){let u=n==="day"?1:n==="week"?7:n==="month"?30:0,l=e[n],m=o[yt(e.mintA.address).toString()],p=o[yt(e.mintB.address).toString()],d=e.mintA.decimals,f=e.mintB.decimals;if(!l||!m||!p)return{feeApr:0,rewardsApr:[0,0,0],apr:0};let y=ie.priceToSqrtPriceX64(new ke(e.price),e.mintA.decimals,e.mintB.decimals),b=ie.getSqrtPriceX64FromTick(i),g=ie.getSqrtPriceX64FromTick(a),{amountSlippageA:P,amountSlippageB:h}=Pe.getAmountsFromLiquidityWithSlippage(y,b,g,t,!1,!1,0),{amountSlippageA:I,amountSlippageB:T}=Pe.getAmountsFromLiquidityWithSlippage(y,b,g,r,!1,!1,0),w=new ke(P.toString()).div(new ke(10).pow(d)).mul(m.value).add(new ke(h.toString()).div(new ke(10).pow(f)).mul(p.value)),x=new ke(I.toString()).div(new ke(10).pow(d)).mul(m.value).add(new ke(T.toString()).div(new ke(10).pow(f)).mul(p.value)),S=new ke(1).div(w.add(x)),B=new ke(l.volumeFee).mul(365).div(u).mul(S).mul(100).toNumber(),C=3600*24*365,M=e.rewardDefaultInfos.map(V=>{var W,z;let R=V.mint.decimals,L=o[V.mint.address];return c<((W=V.startTime)!=null?W:0)||c>((z=V.endTime)!=null?z:0)||!V.perSecond||!L||R===void 0?0:new ke(L.value).mul(new ke(V.perSecond).mul(C)).div(new ke(10).pow(R)).mul(S).mul(100).toNumber()});return{feeApr:B,rewardsApr:M,apr:B+M.reduce((V,R)=>V+R,0)}}static async getLiquidityAmountOutFromAmountIn({poolInfo:e,inputA:t,tickLower:n,tickUpper:o,amount:r,slippage:i,add:a,epochInfo:c,amountHasFee:u}){var g,P;let l=ie.priceToSqrtPriceX64(new ke(e.price),e.mintA.decimals,e.mintB.decimals),m=ie.getSqrtPriceX64FromTick(n),p=ie.getSqrtPriceX64FromTick(o),d=Be(r,(g=e[t?"mintA":"mintB"].extensions)==null?void 0:g.feeConfig,c,!u),f=new Ee(new ke(d.amount.sub((P=d.fee)!=null?P:ge).toString()).toFixed(0)),y;if(l.lte(m))y=t?Pe.getLiquidityFromTokenAmountA(m,p,f,!a):new Ee(0);else if(l.lte(p)){let h=Pe.getLiquidityFromTokenAmountA(l,p,f,!a),I=Pe.getLiquidityFromTokenAmountB(m,l,f);y=t?h:I}else y=t?new Ee(0):Pe.getLiquidityFromTokenAmountB(m,p,f);let b=await ve.getAmountsFromLiquidity({epochInfo:c,poolInfo:e,tickLower:n,tickUpper:o,liquidity:y,slippage:i,add:a});return{liquidity:y,amountA:t?d:b.amountA,amountB:t?b.amountB:d,amountSlippageA:t?d:b.amountSlippageA,amountSlippageB:t?b.amountSlippageB:d,expirationTime:b.expirationTime}}static async getAmountsFromLiquidity({epochInfo:e,poolInfo:t,tickLower:n,tickUpper:o,liquidity:r,slippage:i,add:a}){var b,g,P,h;let c=ie.getSqrtPriceX64FromTick(n),u=ie.getSqrtPriceX64FromTick(o),l=a?1+i:1-i,m=Pe.getAmountsFromLiquidity(ie.priceToSqrtPriceX64(new ke(t.price),t.mintA.decimals,t.mintB.decimals),c,u,r,a),[p,d]=[Be(m.amountA,(b=t.mintA.extensions)==null?void 0:b.feeConfig,e,!0),Be(m.amountB,(g=t.mintB.extensions)==null?void 0:g.feeConfig,e,!0)],[f,y]=[Be(m.amountA.muln(l),(P=t.mintA.extensions)==null?void 0:P.feeConfig,e,!0),Be(m.amountB.muln(l),(h=t.mintB.extensions)==null?void 0:h.feeConfig,e,!0)];return{liquidity:r,amountA:p,amountB:d,amountSlippageA:f,amountSlippageB:y,expirationTime:tn(p.expirationTime,d.expirationTime)}}static async fetchComputeMultipleClmmInfo({connection:e,poolList:t,rpcDataMap:n={}}){let o=t.filter(c=>!n[c.id]).map(c=>new Ft(c.id));(await $t(e,o)).forEach((c,u)=>{!c||(n[o[u].toBase58()]=no.decode(c.data))});let i=t.map(c=>je(new Ft(c.programId),new Ft(c.id)).publicKey),a=await ve.fetchExBitmaps({connection:e,exBitmapAddress:i,batchRequest:!1});return t.reduce((c,u)=>q(N({},c),{[u.id]:q(N({},n[u.id]),{id:new Ft(u.id),version:6,programId:new Ft(u.programId),mintA:u.mintA,mintB:u.mintB,ammConfig:q(N({},u.config),{id:new Ft(u.config.id),fundOwner:""}),currentPrice:new ke(u.price),exBitmapAccount:je(new Ft(u.programId),new Ft(u.id)).publicKey,exBitmapInfo:a[je(new Ft(u.programId),new Ft(u.id)).publicKey.toBase58()],startTime:n[u.id].startTime.toNumber(),rewardInfos:n[u.id].rewardInfos})}),{})}static async fetchComputeClmmInfo({connection:e,poolInfo:t,rpcData:n}){return(await this.fetchComputeMultipleClmmInfo({connection:e,rpcDataMap:n?{[t.id]:n}:void 0,poolList:[t]}))[t.id]}};function _h({poolInfo:s,tickLower:e,tickUpper:t,amountA:n,amountB:o,slippage:r,add:i,epochInfo:a,amountHasFee:c}){var h,I,T,w;let[u,l,m,p]=e<t?[e,t,n,o]:[t,e,o,n],d=ie.priceToSqrtPriceX64(new ke(s.price),s.mintA.decimals,s.mintB.decimals),f=ie.getSqrtPriceX64FromTick(u),y=ie.getSqrtPriceX64FromTick(l),[b,g]=[Be(m,(h=s.mintA.extensions)==null?void 0:h.feeConfig,a,!c),Be(p,(I=s.mintB.extensions)==null?void 0:I.feeConfig,a,!c)],P=Pe.getLiquidityFromTokenAmounts(d,f,y,b.amount.sub((T=b.fee)!=null?T:ge),g.amount.sub((w=g.fee)!=null?w:ge));return Pe.getAmountsOutFromLiquidity({poolInfo:s,tickLower:e,tickUpper:t,liquidity:P,slippage:r,add:i,epochInfo:a,amountAddFee:!c})}var Vs={volume:0,volumeQuote:0,volumeFee:0,apr:0,feeApr:0,priceMin:0,priceMax:0,rewardApr:[]};function ol(s){return q(N({},s),{type:"Concentrated",programId:s.programId.toString(),id:s.id.toString(),rewardDefaultInfos:[],rewardDefaultPoolInfos:"Clmm",price:s.currentPrice.toNumber(),mintAmountA:0,mintAmountB:0,feeRate:s.ammConfig.tradeFeeRate,openTime:s.startTime.toString(),tvl:0,day:Vs,week:Vs,month:Vs,pooltype:[],farmUpcomingCount:0,farmOngoingCount:0,farmFinishedCount:0,burnPercent:0,config:q(N({},s.ammConfig),{id:s.ammConfig.id.toString(),defaultRange:0,defaultRangePoint:[]})})}var ue=class{static mulDivRoundingUp(e,t,n){let o=e.mul(t),r=o.div(n);return o.mod(n).eq(ge)||(r=r.add(vt)),r}static mulDivFloor(e,t,n){if(n.eq(ge))throw new Error("division by 0");return e.mul(t).div(n)}static mulDivCeil(e,t,n){if(n.eq(ge))throw new Error("division by 0");return e.mul(t).add(n.sub(vt)).div(n)}static x64ToDecimal(e,t){return new dn(e.toString()).div(dn.pow(2,64)).toDecimalPlaces(t)}static decimalToX64(e){return new de(e.mul(dn.pow(2,64)).floor().toFixed())}static wrappingSubU128(e,t){return e.add(Nr).sub(t).mod(Nr)}};function mt(s,e){return _s(s.mul(e),64,256)}function ef(s,e,t){let n=s.toTwos(t).shln(e);return n.imaskn(t+1),n.fromTwos(t)}function _s(s,e,t){let n=s.toTwos(t).shrn(e);return n.imaskn(t-e+1),n.fromTwos(t-e)}var ie=class{static sqrtPriceX64ToPrice(e,t,n){return ue.x64ToDecimal(e).pow(2).mul(dn.pow(10,t-n))}static priceToSqrtPriceX64(e,t,n){return ue.decimalToX64(e.mul(dn.pow(10,n-t)).sqrt())}static getNextSqrtPriceX64FromInput(e,t,n,o){if(!e.gt(ge))throw new Error("sqrtPriceX64 must greater than 0");if(!t.gt(ge))throw new Error("liquidity must greater than 0");return o?this.getNextSqrtPriceFromTokenAmountARoundingUp(e,t,n,!0):this.getNextSqrtPriceFromTokenAmountBRoundingDown(e,t,n,!0)}static getNextSqrtPriceX64FromOutput(e,t,n,o){if(!e.gt(ge))throw new Error("sqrtPriceX64 must greater than 0");if(!t.gt(ge))throw new Error("liquidity must greater than 0");return o?this.getNextSqrtPriceFromTokenAmountBRoundingDown(e,t,n,!1):this.getNextSqrtPriceFromTokenAmountARoundingUp(e,t,n,!1)}static getNextSqrtPriceFromTokenAmountARoundingUp(e,t,n,o){if(n.eq(ge))return e;let r=t.shln(Ii);if(o){let i=r,a=r.add(n.mul(e));return a.gte(i)?ue.mulDivCeil(i,e,a):ue.mulDivRoundingUp(i,vt,i.div(e).add(n))}else{let i=n.mul(e);if(!r.gt(i))throw new Error("getNextSqrtPriceFromTokenAmountARoundingUp,liquidityLeftShift must gt amountMulSqrtPrice");let a=r.sub(i);return ue.mulDivCeil(r,e,a)}}static getNextSqrtPriceFromTokenAmountBRoundingDown(e,t,n,o){let r=n.shln(Ii);if(o)return e.add(r.div(t));{let i=ue.mulDivRoundingUp(r,vt,t);if(!e.gt(i))throw new Error("getNextSqrtPriceFromTokenAmountBRoundingDown sqrtPriceX64 must gt amountDivLiquidity");return e.sub(i)}}static getSqrtPriceX64FromTick(e){if(!Number.isInteger(e))throw new Error("tick must be integer");if(e<gt||e>It)throw new Error("tick must be in MIN_TICK and MAX_TICK");let t=e<0?e*-1:e,n=(t&1)!=0?new de("18445821805675395072"):new de("18446744073709551616");return(t&2)!=0&&(n=mt(n,new de("18444899583751176192"))),(t&4)!=0&&(n=mt(n,new de("18443055278223355904"))),(t&8)!=0&&(n=mt(n,new de("18439367220385607680"))),(t&16)!=0&&(n=mt(n,new de("18431993317065453568"))),(t&32)!=0&&(n=mt(n,new de("18417254355718170624"))),(t&64)!=0&&(n=mt(n,new de("18387811781193609216"))),(t&128)!=0&&(n=mt(n,new de("18329067761203558400"))),(t&256)!=0&&(n=mt(n,new de("18212142134806163456"))),(t&512)!=0&&(n=mt(n,new de("17980523815641700352"))),(t&1024)!=0&&(n=mt(n,new de("17526086738831433728"))),(t&2048)!=0&&(n=mt(n,new de("16651378430235570176"))),(t&4096)!=0&&(n=mt(n,new de("15030750278694412288"))),(t&8192)!=0&&(n=mt(n,new de("12247334978884435968"))),(t&16384)!=0&&(n=mt(n,new de("8131365268886854656"))),(t&32768)!=0&&(n=mt(n,new de("3584323654725218816"))),(t&65536)!=0&&(n=mt(n,new de("696457651848324352"))),(t&131072)!=0&&(n=mt(n,new de("26294789957507116"))),(t&262144)!=0&&(n=mt(n,new de("37481735321082"))),e>0&&(n=Uc.div(n)),n}static getTickFromPrice(e,t,n){return ie.getTickFromSqrtPriceX64(ie.priceToSqrtPriceX64(e,t,n))}static getTickFromSqrtPriceX64(e){if(e.gt(Xt)||e.lt(Gt))throw new Error("Provided sqrtPrice is not within the supported sqrtPrice range.");let t=e.bitLength()-1,n=new de(t-64),o=ef(n,32,128),r=new de("8000000000000000","hex"),i=0,a=new de(0),c=t>=64?e.shrn(t-63):e.shln(63-t);for(;r.gt(new de(0))&&i<Gc;){c=c.mul(c);let f=c.shrn(127);c=c.shrn(63+f.toNumber()),a=a.add(r.mul(f)),r=r.shrn(1),i+=1}let u=a.shrn(32),m=o.add(u).mul(new de(Xc)),p=_s(m.sub(new de(zc)),64,128).toNumber(),d=_s(m.add(new de(Qc)),64,128).toNumber();return p==d?p:ie.getSqrtPriceX64FromTick(d).lte(e)?d:p}},oo=class{static getTickWithPriceAndTickspacing(e,t,n,o){let i=ie.getTickFromSqrtPriceX64(ie.priceToSqrtPriceX64(e,n,o))/t;return i<0?i=Math.floor(i):i=Math.ceil(i),i*t}static roundPriceWithTickspacing(e,t,n,o){let r=oo.getTickWithPriceAndTickspacing(e,t,n,o),i=ie.getSqrtPriceX64FromTick(r);return ie.sqrtPriceX64ToPrice(i,n,o)}},Pe=class{static addDelta(e,t){return e.add(t)}static getTokenAmountAFromLiquidity(e,t,n,o){if(e.gt(t)&&([e,t]=[t,e]),!e.gt(ge))throw new Error("sqrtPriceX64A must greater than 0");let r=n.ushln(Ii),i=t.sub(e);return o?ue.mulDivRoundingUp(ue.mulDivCeil(r,i,t),vt,e):ue.mulDivFloor(r,i,t).div(e)}static getTokenAmountBFromLiquidity(e,t,n,o){if(e.gt(t)&&([e,t]=[t,e]),!e.gt(ge))throw new Error("sqrtPriceX64A must greater than 0");return o?ue.mulDivCeil(n,t.sub(e),ot):ue.mulDivFloor(n,t.sub(e),ot)}static getLiquidityFromTokenAmountA(e,t,n,o){e.gt(t)&&([e,t]=[t,e]);let r=n.mul(e).mul(t),i=t.sub(e),a=r.div(i);return o?ue.mulDivRoundingUp(a,vt,hi):a.shrn(Ii)}static getLiquidityFromTokenAmountB(e,t,n){return e.gt(t)&&([e,t]=[t,e]),ue.mulDivFloor(n,hi,t.sub(e))}static getLiquidityFromTokenAmounts(e,t,n,o,r){if(t.gt(n)&&([t,n]=[n,t]),e.lte(t))return Pe.getLiquidityFromTokenAmountA(t,n,o,!1);if(e.lt(n)){let i=Pe.getLiquidityFromTokenAmountA(e,n,o,!1),a=Pe.getLiquidityFromTokenAmountB(t,e,r);return i.lt(a)?i:a}else return Pe.getLiquidityFromTokenAmountB(t,n,r)}static getAmountsFromLiquidity(e,t,n,o,r){if(t.gt(n)&&([t,n]=[n,t]),e.lte(t))return{amountA:Pe.getTokenAmountAFromLiquidity(t,n,o,r),amountB:new de(0)};if(e.lt(n)){let i=Pe.getTokenAmountAFromLiquidity(e,n,o,r),a=Pe.getTokenAmountBFromLiquidity(t,e,o,r);return{amountA:i,amountB:a}}else return{amountA:new de(0),amountB:Pe.getTokenAmountBFromLiquidity(t,n,o,r)}}static getAmountsFromLiquidityWithSlippage(e,t,n,o,r,i,a){let{amountA:c,amountB:u}=Pe.getAmountsFromLiquidity(e,t,n,o,i),l=r?1+a:1-a,m=new de(new dn(c.toString()).mul(l).toFixed(0)),p=new de(new dn(u.toString()).mul(l).toFixed(0));return{amountSlippageA:m,amountSlippageB:p}}static getAmountsOutFromLiquidity({poolInfo:e,tickLower:t,tickUpper:n,liquidity:o,slippage:r,add:i,epochInfo:a,amountAddFee:c}){var P,h,I,T;let u=ie.priceToSqrtPriceX64(new dn(e.price),e.mintA.decimals,e.mintB.decimals),l=ie.getSqrtPriceX64FromTick(t),m=ie.getSqrtPriceX64FromTick(n),p=i?1+r:1-r,d=Pe.getAmountsFromLiquidity(u,l,m,o,i),[f,y]=[Be(d.amountA,(P=e.mintA.extensions)==null?void 0:P.feeConfig,a,c),Be(d.amountB,(h=e.mintB.extensions)==null?void 0:h.feeConfig,a,c)],[b,g]=[Be(new de(new dn(d.amountA.toString()).mul(p).toFixed(0)),(I=e.mintA.extensions)==null?void 0:I.feeConfig,a,c),Be(new de(new dn(d.amountB.toString()).mul(p).toFixed(0)),(T=e.mintB.extensions)==null?void 0:T.feeConfig,a,c)];return{liquidity:o,amountA:f,amountB:y,amountSlippageA:b,amountSlippageB:g,expirationTime:tn(f.expirationTime,y.expirationTime)}}},to=class{static swapCompute(e,t,n,o,r,i,a,c,u,l,m,p,d,f,y=!1){if(p.eq(ge))throw new Error("amountSpecified must not be 0");if(f||(f=i?Gt.add(vt):Xt.sub(vt)),i){if(f.lt(Gt))throw new Error("sqrtPriceX64 must greater than MIN_SQRT_PRICE_X64");if(f.gte(m))throw new Error("sqrtPriceX64 must smaller than current")}else{if(f.gt(Xt))throw new Error("sqrtPriceX64 must smaller than MAX_SQRT_PRICE_X64");if(f.lte(m))throw new Error("sqrtPriceX64 must greater than current")}let b=p.gt(ge),g={amountSpecifiedRemaining:p,amountCalculated:ge,sqrtPriceX64:m,tick:u>d?Math.min(d+Te.tickCount(l)-1,u):d,accounts:[],liquidity:c,feeAmount:new de(0)},P=d,h=n[d],I=0,T=!i&&h.startTickIndex===g.tick;for(;!g.amountSpecifiedRemaining.eq(ge)&&!g.sqrtPriceX64.eq(f);){I>10;let w={};w.sqrtPriceStartX64=g.sqrtPriceX64;let x=Z.nextInitTick(h,g.tick,l,i,T),S=x||null,K=null;if(!(S!=null&&S.liquidityGross.gtn(0))){let C=ve.nextInitializedTickArrayStartIndex({tickCurrent:g.tick,tickSpacing:l,tickArrayBitmap:o,exBitmapInfo:r},P,i);if(!C.isExist){if(y)return{allTrade:!1,amountSpecifiedRemaining:g.amountSpecifiedRemaining,amountCalculated:g.amountCalculated,feeAmount:g.feeAmount,sqrtPriceX64:g.sqrtPriceX64,liquidity:g.liquidity,tickCurrent:g.tick,accounts:g.accounts};throw Error("swapCompute LiquidityInsufficient")}P=C.nextStartIndex;let{publicKey:M}=Ae(e,t,P);K=M,h=n[P];try{S=Z.firstInitializedTick(h,i)}catch{throw Error("not found next tick info")}}w.tickNext=S.tick,w.initialized=S.liquidityGross.gtn(0),d!==P&&K&&(g.accounts.push(K),d=P),w.tickNext<gt?w.tickNext=gt:w.tickNext>It&&(w.tickNext=It),w.sqrtPriceNextX64=ie.getSqrtPriceX64FromTick(w.tickNext);let B;if(i&&w.sqrtPriceNextX64.lt(f)||!i&&w.sqrtPriceNextX64.gt(f)?B=f:B=w.sqrtPriceNextX64,[g.sqrtPriceX64,w.amountIn,w.amountOut,w.feeAmount]=to.swapStepCompute(g.sqrtPriceX64,B,g.liquidity,g.amountSpecifiedRemaining,a,i),g.feeAmount=g.feeAmount.add(w.feeAmount),b?(g.amountSpecifiedRemaining=g.amountSpecifiedRemaining.sub(w.amountIn.add(w.feeAmount)),g.amountCalculated=g.amountCalculated.sub(w.amountOut)):(g.amountSpecifiedRemaining=g.amountSpecifiedRemaining.add(w.amountOut),g.amountCalculated=g.amountCalculated.add(w.amountIn.add(w.feeAmount))),g.sqrtPriceX64.eq(w.sqrtPriceNextX64)){if(w.initialized){let C=S.liquidityNet;i&&(C=C.mul(Tn)),g.liquidity=Pe.addDelta(g.liquidity,C)}T=w.tickNext!=g.tick&&!i&&h.startTickIndex===w.tickNext,g.tick=i?w.tickNext-1:w.tickNext}else if(g.sqrtPriceX64!=w.sqrtPriceStartX64){let C=ie.getTickFromSqrtPriceX64(g.sqrtPriceX64);T=C!=g.tick&&!i&&h.startTickIndex===C,g.tick=C}++I}try{let{nextStartIndex:w,isExist:x}=Te.nextInitializedTickArray(g.tick,l,i,o,r);x&&d!==w&&(g.accounts.push(Ae(e,t,w).publicKey),d=w)}catch{}return{allTrade:!0,amountSpecifiedRemaining:ge,amountCalculated:g.amountCalculated,feeAmount:g.feeAmount,sqrtPriceX64:g.sqrtPriceX64,liquidity:g.liquidity,tickCurrent:g.tick,accounts:g.accounts}}static swapStepCompute(e,t,n,o,r,i){let a={sqrtPriceX64Next:new de(0),amountIn:new de(0),amountOut:new de(0),feeAmount:new de(0)},c=o.gte(ge);if(c){let l=ue.mulDivFloor(o,Fr.sub(new de(r.toString())),Fr);a.amountIn=i?Pe.getTokenAmountAFromLiquidity(t,e,n,!0):Pe.getTokenAmountBFromLiquidity(e,t,n,!0),l.gte(a.amountIn)?a.sqrtPriceX64Next=t:a.sqrtPriceX64Next=ie.getNextSqrtPriceX64FromInput(e,n,l,i)}else a.amountOut=i?Pe.getTokenAmountBFromLiquidity(t,e,n,!1):Pe.getTokenAmountAFromLiquidity(e,t,n,!1),o.mul(Tn).gte(a.amountOut)?a.sqrtPriceX64Next=t:a.sqrtPriceX64Next=ie.getNextSqrtPriceX64FromOutput(e,n,o.mul(Tn),i);let u=t.eq(a.sqrtPriceX64Next);return i?(u&&c||(a.amountIn=Pe.getTokenAmountAFromLiquidity(a.sqrtPriceX64Next,e,n,!0)),u&&!c||(a.amountOut=Pe.getTokenAmountBFromLiquidity(a.sqrtPriceX64Next,e,n,!1))):(a.amountIn=u&&c?a.amountIn:Pe.getTokenAmountBFromLiquidity(e,a.sqrtPriceX64Next,n,!0),a.amountOut=u&&!c?a.amountOut:Pe.getTokenAmountAFromLiquidity(e,a.sqrtPriceX64Next,n,!1)),!c&&a.amountOut.gt(o.mul(Tn))&&(a.amountOut=o.mul(Tn)),c&&!a.sqrtPriceX64Next.eq(t)?a.feeAmount=o.sub(a.amountIn):a.feeAmount=ue.mulDivCeil(a.amountIn,new de(r),Fr.sub(new de(r))),[a.sqrtPriceX64Next,a.amountIn,a.amountOut,a.feeAmount]}};var it=60,eo=512,Z=class{static getTickArrayAddressByTick(e,t,n,o){let r=Z.getTickArrayStartIndexByTick(n,o),{publicKey:i}=Ae(e,t,r);return i}static getTickOffsetInArray(e,t){if(e%t!=0)throw new Error("tickIndex % tickSpacing not equal 0");let n=Z.getTickArrayStartIndexByTick(e,t),o=Math.floor((e-n)/t);if(o<0||o>=it)throw new Error("tick offset in array overflow");return o}static getTickArrayBitIndex(e,t){let n=Te.tickCount(t),o=e/n;return e<0&&e%n!=0?o=Math.ceil(o)-1:o=Math.floor(o),o}static getTickArrayStartIndexByTick(e,t){return this.getTickArrayBitIndex(e,t)*Te.tickCount(t)}static getTickArrayOffsetInBitmapByTick(e,t){let n=t*it,o=Math.floor(e/n)+512;return Math.abs(o)}static checkTickArrayIsInitialized(e,t,n){let o=n*it,r=Math.floor(t/o)+512,i=Math.abs(r);return{isInitialized:e.testn(i),startIndex:(i-512)*o}}static getNextTickArrayStartIndex(e,t,n){return n?e-t*it:e+t*it}static mergeTickArrayBitmap(e){let t=new tf(0);for(let n=0;n<e.length;n++)t=t.add(e[n].shln(64*n));return t}static getInitializedTickArrayInRange(e,t,n,o,r){let i=Math.floor(o/(n*it));return[...Z.searchLowBitFromStart(e,t,i-1,r,n),...Z.searchHightBitFromStart(e,t,i,r,n)]}static getAllInitializedTickArrayStartIndex(e,t,n){return Z.searchHightBitFromStart(e,t,-7680,eo,n)}static getAllInitializedTickArrayInfo(e,t,n,o,r){let i=[],a=Z.getAllInitializedTickArrayStartIndex(n,o,r);for(let c of a){let{publicKey:u}=Ae(e,t,c);i.push({tickArrayStartIndex:c,tickArrayAddress:u})}return i}static getAllInitializedTickInTickArray(e){return e.ticks.filter(t=>t.liquidityGross.gtn(0))}static searchLowBitFromStart(e,t,n,o,r){let i=[...[...t.negativeTickArrayBitmap].reverse(),e.slice(0,8),e.slice(8,16),...t.positiveTickArrayBitmap].map(u=>Z.mergeTickArrayBitmap(u)),a=[];for(;n>=-7680;){let u=Math.floor((n+7680)/512),l=(n+7680)%512;if(i[u].testn(l)&&a.push(n),n--,a.length===o)break}let c=Te.tickCount(r);return a.map(u=>u*c)}static searchHightBitFromStart(e,t,n,o,r){let i=[...[...t.negativeTickArrayBitmap].reverse(),e.slice(0,8),e.slice(8,16),...t.positiveTickArrayBitmap].map(u=>Z.mergeTickArrayBitmap(u)),a=[];for(;n<7680;){let u=Math.floor((n+7680)/512),l=(n+7680)%512;if(i[u].testn(l)&&a.push(n),n++,a.length===o)break}let c=Te.tickCount(r);return a.map(u=>u*c)}static checkIsOutOfBoundary(e){return e<gt||e>It}static nextInitTick(e,t,n,o,r){if(Te.getArrayStartIndex(t,n)!=e.startTickIndex)return null;let a=Math.floor((t-e.startTickIndex)/n);if(o)for(;a>=0;){if(e.ticks[a].liquidityGross.gtn(0))return e.ticks[a];a=a-1}else for(r||(a=a+1);a<it;){if(e.ticks[a].liquidityGross.gtn(0))return e.ticks[a];a=a+1}return null}static firstInitializedTick(e,t){if(t){let n=it-1;for(;n>=0;){if(e.ticks[n].liquidityGross.gtn(0))return e.ticks[n];n=n-1}}else{let n=0;for(;n<it;){if(e.ticks[n].liquidityGross.gtn(0))return e.ticks[n];n=n+1}}throw Error(`firstInitializedTick check error: ${e} - ${t}`)}static _getTickPriceLegacy({poolInfo:e,tick:t,baseIn:n}){let o=ie.getSqrtPriceX64FromTick(t),r=ie.sqrtPriceX64ToPrice(o,e.mintA.decimals,e.mintB.decimals);return n?{tick:t,price:r,tickSqrtPriceX64:o}:{tick:t,price:new Mo(1).div(r),tickSqrtPriceX64:o}}static _getPriceAndTickLegacy({poolInfo:e,price:t,baseIn:n}){let o=n?t:new Mo(1).div(t),r=oo.getTickWithPriceAndTickspacing(o,e.ammConfig.tickSpacing,e.mintA.decimals,e.mintB.decimals),i=ie.getSqrtPriceX64FromTick(r),a=ie.sqrtPriceX64ToPrice(i,e.mintA.decimals,e.mintB.decimals);return n?{tick:r,price:a}:{tick:r,price:new Mo(1).div(a)}}static getTickPrice({poolInfo:e,tick:t,baseIn:n}){let o=ie.getSqrtPriceX64FromTick(t),r=ie.sqrtPriceX64ToPrice(o,e.mintA.decimals,e.mintB.decimals);return n?{tick:t,price:r,tickSqrtPriceX64:o}:{tick:t,price:new Mo(1).div(r),tickSqrtPriceX64:o}}static getPriceAndTick({poolInfo:e,price:t,baseIn:n}){let o=n?t:new Mo(1).div(t),r=oo.getTickWithPriceAndTickspacing(o,e.config.tickSpacing,e.mintA.decimals,e.mintB.decimals),i=ie.getSqrtPriceX64FromTick(r),a=ie.sqrtPriceX64ToPrice(i,e.mintA.decimals,e.mintB.decimals);return n?{tick:r,price:a}:{tick:r,price:new Mo(1).div(a)}}};var rl=v([xe(8),D("bump"),Mt("index"),O(""),pt("protocolFeeRate"),pt("tradeFeeRate"),Mt("tickSpacing"),Q(k(),8,"")]),nf=v([pt("blockTimestamp"),So("tickCumulative"),Q(k(),4)]),al=v([xe(8),We("initialized"),k("recentEpoch"),Mt("observationIndex"),O("poolId"),Q(nf,100,"observations"),Q(k(),4)]),of=v([D("rewardState"),k("openTime"),k("endTime"),k("lastUpdateTime"),te("emissionsPerSecondX64"),k("rewardTotalEmissioned"),k("rewardClaimed"),O("tokenMint"),O("tokenVault"),O("creator"),te("rewardGrowthGlobalX64")]),no=v([xe(8),D("bump"),O("ammConfig"),O("creator"),O("mintA"),O("mintB"),O("vaultA"),O("vaultB"),O("observationId"),D("mintDecimalsA"),D("mintDecimalsB"),Mt("tickSpacing"),te("liquidity"),te("sqrtPriceX64"),_e("tickCurrent"),pt(),te("feeGrowthGlobalX64A"),te("feeGrowthGlobalX64B"),k("protocolFeesTokenA"),k("protocolFeesTokenB"),te("swapInAmountTokenA"),te("swapOutAmountTokenB"),te("swapInAmountTokenB"),te("swapOutAmountTokenA"),D("status"),Q(D(),7,""),Q(of,3,"rewardInfos"),Q(k(),16,"tickArrayBitmap"),k("totalFeesTokenA"),k("totalFeesClaimedTokenA"),k("totalFeesTokenB"),k("totalFeesClaimedTokenB"),k("fundFeesTokenA"),k("fundFeesTokenB"),k("startTime"),Q(k(),15*4-3,"padding")]),rf=v([te("growthInsideLastX64"),k("rewardAmountOwed")]),No=v([xe(8),D("bump"),O("nftMint"),O("poolId"),_e("tickLower"),_e("tickUpper"),te("liquidity"),te("feeGrowthInsideLastX64A"),te("feeGrowthInsideLastX64B"),k("tokenFeesOwedA"),k("tokenFeesOwedB"),Q(rf,3,"rewardInfos"),Q(k(),8,"")]),uI=v([xe(8),D("bump"),O("poolId"),_e("tickLowerIndex"),_e("tickUpperIndex"),te("liquidity"),te("feeGrowthInsideLastX64A"),te("feeGrowthInsideLastX64B"),k("tokenFeesOwedA"),k("tokenFeesOwedB"),Q(te(),3,"rewardGrowthInside"),Q(k(),8,"")]),af=v([_e("tick"),kc("liquidityNet"),te("liquidityGross"),te("feeGrowthOutsideX64A"),te("feeGrowthOutsideX64B"),Q(te(),3,"rewardGrowthsOutsideX64"),Q(pt(),13,"")]),Ki=v([xe(8),O("poolId"),_e("startTickIndex"),Q(af,it,"ticks"),D("initializedTickCount"),Q(D(),115,"")]),sl=v([xe(329),Q(O(),100,"whitelistMints")]),il=v([xe(8),O("poolId"),Q(Q(k(),8),Fs,"positiveTickArrayBitmap"),Q(Q(k(),8),Fs,"negativeTickArrayBitmap")]),cI=v([k(),D("bump"),O("owner"),O("poolId"),O("positionId"),O("nftAccount"),Q(k(),8)]),ul=v([xe(8),D("bump"),O("lockOwner"),O("poolId"),O("positionId"),O("nftAccount"),O("lockNftMint"),k("recentEpoch"),Q(k(),8)]);al.span;var cl=fe("Raydium_Clmm"),Vt={createPool:[233,146,209,142,207,104,64,188],initReward:[95,135,192,196,242,129,230,68],setRewardEmissions:[112,52,167,75,32,201,211,137],openPosition:[77,184,74,214,112,86,241,199],openPositionWithTokenEx:[77,255,174,82,125,29,201,46],closePosition:[123,134,81,0,49,68,98,98],increaseLiquidity:[133,29,89,223,69,238,176,10],decreaseLiquidity:[58,127,188,62,79,82,196,96],swap:[43,4,237,11,26,201,30,98],collectReward:[18,237,166,197,34,16,213,144]},ll=[188,37,179,131,82,150,84,73],ml=[16,72,250,198,14,162,212,19],Le=class{static createPoolInstruction(e,t,n,o,r,i,a,c,u,l,m,p,d,f){let y=v([te("sqrtPriceX64"),k("zero")]),b=[{pubkey:n,isSigner:!0,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!1},{pubkey:u,isSigner:!1,isWritable:!1},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:p,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!1},{pubkey:m,isSigner:!1,isWritable:!1},{pubkey:Bn.programId,isSigner:!1,isWritable:!1},{pubkey:tt,isSigner:!1,isWritable:!1},...(f==null?void 0:f.map(h=>({pubkey:h,isSigner:!1,isWritable:!1})))||[]],g=Buffer.alloc(y.span);y.encode({sqrtPriceX64:d,zero:ge},g);let P=Buffer.from([...Vt.createPool,...g]);return new ft({keys:b,programId:e,data:P})}static async createPoolInstructions(e){let{programId:t,owner:n,mintA:o,mintB:r,ammConfigId:i,initialPriceX64:a,extendMintAccount:c}=e,[u,l]=[new G(o.address),new G(r.address)],{publicKey:m}=$c(t,i,u,l),{publicKey:p}=el(t,m),{publicKey:d}=Os(t,m,u),{publicKey:f}=Os(t,m,l),y=je(t,m).publicKey,b=[this.createPoolInstruction(t,m,n,i,p,u,d,new G(o.programId||Re),l,f,new G(r.programId||Re),y,a,c)];return{signers:[],instructions:b,instructionTypes:[U.CreateAccount,U.ClmmCreatePool],address:{poolId:m,observationId:p,exBitmapAccount:y,mintAVault:d,mintBVault:f},lookupTableAddress:[]}}static openPositionFromLiquidityInstruction(e,t,n,o,r,i,a,c,u,l,m,p,d,f,y,b,g,P,h,I,T,w,x,S,K,B){let C=v([_e("tickLowerIndex"),_e("tickUpperIndex"),_e("tickArrayLowerStartIndex"),_e("tickArrayUpperStartIndex"),te("liquidity"),k("amountMaxA"),k("amountMaxB"),We("withMetadata"),D("optionBaseFlag"),We("baseFlag")]),M=[...B?[{pubkey:B,isSigner:!1,isWritable:!0}]:[]],V=[{pubkey:t,isSigner:!0,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!0,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:m,isSigner:!1,isWritable:!0},{pubkey:p,isSigner:!1,isWritable:!0},{pubkey:d,isSigner:!1,isWritable:!0},{pubkey:f,isSigner:!1,isWritable:!0},{pubkey:y,isSigner:!1,isWritable:!0},{pubkey:tt,isSigner:!1,isWritable:!1},{pubkey:Bn.programId,isSigner:!1,isWritable:!1},{pubkey:Re,isSigner:!1,isWritable:!1},{pubkey:Ri,isSigner:!1,isWritable:!1},{pubkey:Jt,isSigner:!1,isWritable:!1},{pubkey:Ue,isSigner:!1,isWritable:!1},{pubkey:b,isSigner:!1,isWritable:!1},{pubkey:g,isSigner:!1,isWritable:!1},...M],R=Buffer.alloc(C.span);C.encode({tickLowerIndex:P,tickUpperIndex:h,tickArrayLowerStartIndex:I,tickArrayUpperStartIndex:T,liquidity:w,amountMaxA:x,amountMaxB:S,withMetadata:K==="create",baseFlag:!1,optionBaseFlag:0},R);let L=Buffer.from([...Vt.openPosition,...R]);return new ft({keys:V,programId:e,data:L})}static openPositionFromLiquidityInstruction22(e,t,n,o,r,i,a,c,u,l,m,p,d,f,y,b,g,P,h,I,T,w,x,S,K){let B=v([_e("tickLowerIndex"),_e("tickUpperIndex"),_e("tickArrayLowerStartIndex"),_e("tickArrayUpperStartIndex"),te("liquidity"),k("amountMaxA"),k("amountMaxB"),We("withMetadata"),D("optionBaseFlag"),We("baseFlag")]),C=[...K?[{pubkey:K,isSigner:!1,isWritable:!0}]:[]],M=[{pubkey:t,isSigner:!0,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!0,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:m,isSigner:!1,isWritable:!0},{pubkey:p,isSigner:!1,isWritable:!0},{pubkey:d,isSigner:!1,isWritable:!0},{pubkey:f,isSigner:!1,isWritable:!0},{pubkey:tt,isSigner:!1,isWritable:!1},{pubkey:Bn.programId,isSigner:!1,isWritable:!1},{pubkey:Re,isSigner:!1,isWritable:!1},{pubkey:Ri,isSigner:!1,isWritable:!1},{pubkey:Ue,isSigner:!1,isWritable:!1},{pubkey:y,isSigner:!1,isWritable:!1},{pubkey:b,isSigner:!1,isWritable:!1},...C],V=Buffer.alloc(B.span);B.encode({tickLowerIndex:g,tickUpperIndex:P,tickArrayLowerStartIndex:h,tickArrayUpperStartIndex:I,liquidity:T,amountMaxA:w,amountMaxB:x,withMetadata:S==="create",baseFlag:!1,optionBaseFlag:0},V);let R=Buffer.from([...Vt.openPositionWithTokenEx,...V]);return new ft({keys:M,programId:e,data:R})}static async openPositionInstructions({poolInfo:e,poolKeys:t,ownerInfo:n,tickLower:o,tickUpper:r,liquidity:i,amountMaxA:a,amountMaxB:c,withMetadata:u,getEphemeralSigners:l,nft2022:m}){let p=[],[d,f]=[new G(e.programId),new G(e.id)],y;if(l)y=new G((await l(1))[0]);else{let K=Er.generate();p.push(K),y=K.publicKey}let b=Z.getTickArrayStartIndexByTick(o,e.config.tickSpacing),g=Z.getTickArrayStartIndexByTick(r,e.config.tickSpacing),{publicKey:P}=Ae(d,f,b),{publicKey:h}=Ae(d,f,g),{publicKey:I}=m?j(n.wallet,y,Ue):j(n.wallet,y,Re),{publicKey:T}=hn(y),{publicKey:w}=Bt(d,y),{publicKey:x}=an(d,f,o,r),S=m?this.openPositionFromLiquidityInstruction22(d,n.feePayer,f,n.wallet,y,I,x,P,h,w,n.tokenAccountA,n.tokenAccountB,new G(t.vault.A),new G(t.vault.B),new G(e.mintA.address),new G(e.mintB.address),o,r,b,g,i,a,c,u,ve.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing,[b,g])?je(d,f).publicKey:void 0):this.openPositionFromLiquidityInstruction(d,n.feePayer,f,n.wallet,y,I,T,x,P,h,w,n.tokenAccountA,n.tokenAccountB,new G(t.vault.A),new G(t.vault.B),new G(e.mintA.address),new G(e.mintB.address),o,r,b,g,i,a,c,u,ve.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing,[b,g])?je(d,f).publicKey:void 0);return{signers:p,instructions:[S],instructionTypes:[U.ClmmOpenPosition],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[],address:{nftMint:y,tickArrayLower:P,tickArrayUpper:h,positionNftAccount:I,metadataAccount:T,personalPosition:w,protocolPosition:x}}}static async openPositionFromBaseInstructions({poolInfo:e,poolKeys:t,ownerInfo:n,tickLower:o,tickUpper:r,base:i,baseAmount:a,otherAmountMax:c,withMetadata:u,getEphemeralSigners:l,nft2022:m}){let p=[],[d,f]=[new G(e.programId),new G(e.id)],y;if(l)y=new G((await l(1))[0]);else{let K=Er.generate();p.push(K),y=K.publicKey}let b=Z.getTickArrayStartIndexByTick(o,e.config.tickSpacing),g=Z.getTickArrayStartIndexByTick(r,e.config.tickSpacing),{publicKey:P}=Ae(d,f,b),{publicKey:h}=Ae(d,f,g),{publicKey:I}=m?j(n.wallet,y,Ue):j(n.wallet,y,Re),{publicKey:T}=hn(y),{publicKey:w}=Bt(d,y),{publicKey:x}=an(d,f,o,r),S=m?this.openPositionFromBaseInstruction22(d,n.feePayer,f,n.wallet,y,I,x,P,h,w,n.tokenAccountA,n.tokenAccountB,new G(t.vault.A),new G(t.vault.B),new G(e.mintA.address),new G(e.mintB.address),o,r,b,g,u,i,a,c,ve.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing,[b,g])?je(d,f).publicKey:void 0):this.openPositionFromBaseInstruction(d,n.feePayer,f,n.wallet,y,I,T,x,P,h,w,n.tokenAccountA,n.tokenAccountB,new G(t.vault.A),new G(t.vault.B),new G(e.mintA.address),new G(e.mintB.address),o,r,b,g,u,i,a,c,ve.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing,[b,g])?je(d,f).publicKey:void 0);return{address:{nftMint:y,tickArrayLower:P,tickArrayUpper:h,positionNftAccount:I,metadataAccount:T,personalPosition:w,protocolPosition:x},instructions:[S],signers:p,instructionTypes:[U.ClmmOpenPosition],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[]}}static openPositionFromBaseInstruction(e,t,n,o,r,i,a,c,u,l,m,p,d,f,y,b,g,P,h,I,T,w,x,S,K,B){let C=v([_e("tickLowerIndex"),_e("tickUpperIndex"),_e("tickArrayLowerStartIndex"),_e("tickArrayUpperStartIndex"),te("liquidity"),k("amountMaxA"),k("amountMaxB"),We("withMetadata"),D("optionBaseFlag"),We("baseFlag")]),M=[...B?[{pubkey:B,isSigner:!1,isWritable:!0}]:[]],V=[{pubkey:t,isSigner:!0,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!0,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:m,isSigner:!1,isWritable:!0},{pubkey:p,isSigner:!1,isWritable:!0},{pubkey:d,isSigner:!1,isWritable:!0},{pubkey:f,isSigner:!1,isWritable:!0},{pubkey:y,isSigner:!1,isWritable:!0},{pubkey:tt,isSigner:!1,isWritable:!1},{pubkey:Bn.programId,isSigner:!1,isWritable:!1},{pubkey:Re,isSigner:!1,isWritable:!1},{pubkey:Ri,isSigner:!1,isWritable:!1},{pubkey:Jt,isSigner:!1,isWritable:!1},{pubkey:Ue,isSigner:!1,isWritable:!1},{pubkey:b,isSigner:!1,isWritable:!1},{pubkey:g,isSigner:!1,isWritable:!1},...M],R=Buffer.alloc(C.span);C.encode({tickLowerIndex:P,tickUpperIndex:h,tickArrayLowerStartIndex:I,tickArrayUpperStartIndex:T,liquidity:new Es(0),amountMaxA:x==="MintA"?S:K,amountMaxB:x==="MintA"?K:S,withMetadata:w==="create",baseFlag:x==="MintA",optionBaseFlag:1},R);let L=Buffer.from([...Vt.openPosition,...R]);return new ft({keys:V,programId:e,data:L})}static openPositionFromBaseInstruction22(e,t,n,o,r,i,a,c,u,l,m,p,d,f,y,b,g,P,h,I,T,w,x,S,K){let B=v([_e("tickLowerIndex"),_e("tickUpperIndex"),_e("tickArrayLowerStartIndex"),_e("tickArrayUpperStartIndex"),te("liquidity"),k("amountMaxA"),k("amountMaxB"),We("withMetadata"),D("optionBaseFlag"),We("baseFlag")]),C=[...K?[{pubkey:K,isSigner:!1,isWritable:!0}]:[]],M=[{pubkey:t,isSigner:!0,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!0,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:m,isSigner:!1,isWritable:!0},{pubkey:p,isSigner:!1,isWritable:!0},{pubkey:d,isSigner:!1,isWritable:!0},{pubkey:f,isSigner:!1,isWritable:!0},{pubkey:tt,isSigner:!1,isWritable:!1},{pubkey:Bn.programId,isSigner:!1,isWritable:!1},{pubkey:Re,isSigner:!1,isWritable:!1},{pubkey:Ri,isSigner:!1,isWritable:!1},{pubkey:Ue,isSigner:!1,isWritable:!1},{pubkey:y,isSigner:!1,isWritable:!1},{pubkey:b,isSigner:!1,isWritable:!1},...C],V=Buffer.alloc(B.span);B.encode({tickLowerIndex:g,tickUpperIndex:P,tickArrayLowerStartIndex:h,tickArrayUpperStartIndex:I,liquidity:new Es(0),amountMaxA:w==="MintA"?x:S,amountMaxB:w==="MintA"?S:x,withMetadata:T==="create",baseFlag:w==="MintA",optionBaseFlag:1},V);let R=Buffer.from([...Vt.openPositionWithTokenEx,...V]);return new ft({keys:M,programId:e,data:R})}static async openPositionFromLiquidityInstructions({poolInfo:e,poolKeys:t,ownerInfo:n,tickLower:o,tickUpper:r,liquidity:i,amountMaxA:a,amountMaxB:c,withMetadata:u,getEphemeralSigners:l,nft2022:m}){let p,d=[];if(l)p=new G((await l(1))[0]);else{let K=Er.generate();d.push(K),p=K.publicKey}let[f,y]=[new G(e.programId),new G(e.id)],b=Z.getTickArrayStartIndexByTick(o,e.config.tickSpacing),g=Z.getTickArrayStartIndexByTick(r,e.config.tickSpacing),{publicKey:P}=Ae(f,y,b),{publicKey:h}=Ae(f,y,g),{publicKey:I}=m?j(n.wallet,p,Ue):j(n.wallet,p,Re),{publicKey:T}=hn(p),{publicKey:w}=Bt(f,p),{publicKey:x}=an(f,y,o,r),S=m?this.openPositionFromLiquidityInstruction22(f,n.wallet,y,n.wallet,p,I,x,P,h,w,n.tokenAccountA,n.tokenAccountB,new G(t.vault.A),new G(t.vault.B),new G(t.mintA.address),new G(t.mintB.address),o,r,b,g,i,a,c,u,ve.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing,[b,g])?je(f,y).publicKey:void 0):this.openPositionFromLiquidityInstruction(f,n.wallet,y,n.wallet,p,I,T,x,P,h,w,n.tokenAccountA,n.tokenAccountB,new G(t.vault.A),new G(t.vault.B),new G(t.mintA.address),new G(t.mintB.address),o,r,b,g,i,a,c,u,ve.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing,[b,g])?je(f,y).publicKey:void 0);return{address:{nftMint:p,tickArrayLower:P,tickArrayUpper:h,positionNftAccount:I,metadataAccount:T,personalPosition:w,protocolPosition:x},instructions:[S],signers:d,instructionTypes:[U.ClmmOpenPosition],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[]}}static closePositionInstruction(e,t,n,o,r,i){let a=v([]),c=[{pubkey:t,isSigner:!0,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:Bn.programId,isSigner:!1,isWritable:!1},{pubkey:i?Ue:Re,isSigner:!1,isWritable:!1}],u=Buffer.alloc(a.span);a.encode({},u);let l=Buffer.from([...Vt.closePosition,...u]);return new ft({keys:c,programId:e,data:l})}static closePositionInstructions({poolInfo:e,poolKeys:t,ownerInfo:n,ownerPosition:o,nft2022:r}){let i=new G(e.programId),a=r?j(n.wallet,o.nftMint,Ue).publicKey:j(n.wallet,o.nftMint,Re).publicKey,{publicKey:c}=Bt(i,o.nftMint),u=[];return u.push(this.closePositionInstruction(i,n.wallet,o.nftMint,a,c,r)),{address:{positionNftAccount:a,personalPosition:c},signers:[],instructions:u,instructionTypes:[U.ClmmClosePosition],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[]}}static increasePositionFromLiquidityInstruction(e,t,n,o,r,i,a,c,u,l,m,p,d,f,y,b,g,P){let h=v([te("liquidity"),k("amountMaxA"),k("amountMaxB"),D("optionBaseFlag"),We("baseFlag")]),I=[...P?[{pubkey:P,isSigner:!1,isWritable:!0}]:[]],T=[{pubkey:t,isSigner:!0,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:m,isSigner:!1,isWritable:!0},{pubkey:p,isSigner:!1,isWritable:!0},{pubkey:Re,isSigner:!1,isWritable:!1},{pubkey:Ue,isSigner:!1,isWritable:!1},{pubkey:d,isSigner:!1,isWritable:!1},{pubkey:f,isSigner:!1,isWritable:!1},...I],w=Buffer.alloc(h.span);h.encode({liquidity:y,amountMaxA:b,amountMaxB:g,optionBaseFlag:0,baseFlag:!1},w);let x=Buffer.from([...Vt.increaseLiquidity,...w]);return new ft({keys:T,programId:e,data:x})}static increasePositionFromLiquidityInstructions({poolInfo:e,poolKeys:t,ownerPosition:n,ownerInfo:o,liquidity:r,amountMaxA:i,amountMaxB:a,nft2022:c}){let[u,l]=[new G(e.programId),new G(e.id)],m=Z.getTickArrayStartIndexByTick(n.tickLower,e.config.tickSpacing),p=Z.getTickArrayStartIndexByTick(n.tickUpper,e.config.tickSpacing),{publicKey:d}=Ae(u,l,m),{publicKey:f}=Ae(u,l,p),{publicKey:y}=c?j(o.wallet,n.nftMint,Ue):j(o.wallet,n.nftMint,Re),{publicKey:b}=Bt(u,n.nftMint),{publicKey:g}=an(u,l,n.tickLower,n.tickUpper),P=this.increasePositionFromLiquidityInstruction(u,o.wallet,y,b,l,g,d,f,o.tokenAccountA,o.tokenAccountB,new G(t.vault.A),new G(t.vault.B),new G(e.mintA.address),new G(e.mintB.address),r,i,a,ve.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing,[m,p])?je(u,l).publicKey:void 0);return{address:{tickArrayLower:d,tickArrayUpper:f,positionNftAccount:y,personalPosition:b,protocolPosition:g},signers:[],instructions:[P],instructionTypes:[U.ClmmIncreasePosition],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[]}}static increasePositionFromBaseInstructions({poolInfo:e,poolKeys:t,ownerPosition:n,ownerInfo:o,base:r,baseAmount:i,otherAmountMax:a,nft2022:c}){let[u,l]=[new G(e.programId),new G(e.id)],m=Z.getTickArrayStartIndexByTick(n.tickLower,e.config.tickSpacing),p=Z.getTickArrayStartIndexByTick(n.tickUpper,e.config.tickSpacing),{publicKey:d}=Ae(u,l,m),{publicKey:f}=Ae(u,l,p),{publicKey:y}=c?j(o.wallet,n.nftMint,Ue):j(o.wallet,n.nftMint,Re),{publicKey:b}=Bt(u,n.nftMint),{publicKey:g}=an(u,l,n.tickLower,n.tickUpper);return{address:{tickArrayLower:d,tickArrayUpper:f,positionNftAccount:y,personalPosition:b,protocolPosition:g},instructions:[this.increasePositionFromBaseInstruction(u,o.wallet,y,b,l,g,d,f,o.tokenAccountA,o.tokenAccountB,new G(t.vault.A),new G(t.vault.B),new G(e.mintA.address),new G(e.mintB.address),r,i,a,ve.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing,[m,p])?je(u,l).publicKey:void 0)],signers:[],instructionTypes:[U.ClmmIncreasePosition],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[]}}static increasePositionFromBaseInstruction(e,t,n,o,r,i,a,c,u,l,m,p,d,f,y,b,g,P){let h=v([te("liquidity"),k("amountMaxA"),k("amountMaxB"),D("optionBaseFlag"),We("baseFlag")]),I=[...P?[{pubkey:P,isSigner:!1,isWritable:!0}]:[]],T=[{pubkey:t,isSigner:!0,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:m,isSigner:!1,isWritable:!0},{pubkey:p,isSigner:!1,isWritable:!0},{pubkey:Re,isSigner:!1,isWritable:!1},{pubkey:Ue,isSigner:!1,isWritable:!1},{pubkey:d,isSigner:!1,isWritable:!1},{pubkey:f,isSigner:!1,isWritable:!1},...I],w=Buffer.alloc(h.span);h.encode({liquidity:new Es(0),amountMaxA:y==="MintA"?b:g,amountMaxB:y==="MintA"?g:b,baseFlag:y==="MintA",optionBaseFlag:1},w);let x=Buffer.from([...Vt.increaseLiquidity,...w]);return new ft({keys:T,programId:e,data:x})}static decreaseLiquidityInstruction(e,t,n,o,r,i,a,c,u,l,m,p,d,f,y,b,g,P,h){let I=v([te("liquidity"),k("amountMinA"),k("amountMinB")]),T=[...h?[{pubkey:h,isSigner:!1,isWritable:!0}]:[],...y.map(K=>[{pubkey:K.poolRewardVault,isSigner:!1,isWritable:!0},{pubkey:K.ownerRewardVault,isSigner:!1,isWritable:!0},{pubkey:K.rewardMint,isSigner:!1,isWritable:!1}]).flat()],w=[{pubkey:t,isSigner:!0,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:m,isSigner:!1,isWritable:!0},{pubkey:p,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:Re,isSigner:!1,isWritable:!1},{pubkey:Ue,isSigner:!1,isWritable:!1},{pubkey:ur,isSigner:!1,isWritable:!1},{pubkey:d,isSigner:!1,isWritable:!1},{pubkey:f,isSigner:!1,isWritable:!1},...T],x=Buffer.alloc(I.span);I.encode({liquidity:b,amountMinA:g,amountMinB:P},x);let S=Buffer.from([...Vt.decreaseLiquidity,...x]);return new ft({keys:w,programId:e,data:S})}static decreaseLiquidityInstructions({poolInfo:e,poolKeys:t,ownerPosition:n,ownerInfo:o,liquidity:r,amountMinA:i,amountMinB:a,programId:c,nft2022:u}){let[l,m]=[new G(e.programId),new G(e.id)],p=Z.getTickArrayStartIndexByTick(n.tickLower,e.config.tickSpacing),d=Z.getTickArrayStartIndexByTick(n.tickUpper,e.config.tickSpacing),{publicKey:f}=Ae(l,m,p),{publicKey:y}=Ae(l,m,d),{publicKey:b}=u?j(o.wallet,n.nftMint,Ue):j(o.wallet,n.nftMint,c),{publicKey:g}=Bt(l,n.nftMint),{publicKey:P}=an(l,m,n.tickLower,n.tickUpper),h=[];for(let w=0;w<e.rewardDefaultInfos.length;w++)h.push({poolRewardVault:new G(t.rewardInfos[w].vault),ownerRewardVault:o.rewardAccounts[w],rewardMint:new G(e.rewardDefaultInfos[w].mint.address)});let I=[],T=this.decreaseLiquidityInstruction(l,o.wallet,b,g,m,P,f,y,o.tokenAccountA,o.tokenAccountB,new G(t.vault.A),new G(t.vault.B),new G(e.mintA.address),new G(e.mintB.address),h,r,i,a,ve.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing,[p,d])?je(l,m).publicKey:void 0);return I.push(T),{address:{tickArrayLower:f,tickArrayUpper:y,positionNftAccount:b,personalPosition:g,protocolPosition:P},signers:[],instructions:I,instructionTypes:[U.ClmmDecreasePosition],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[]}}static swapInstruction(e,t,n,o,r,i,a,c,u,l,m,p,d,f,y,b,g){let P=v([k("amount"),k("otherAmountThreshold"),te("sqrtPriceLimitX64"),We("isBaseInput")]),h=[...g?[{pubkey:g,isSigner:!1,isWritable:!0}]:[],...m.map(x=>({pubkey:x,isSigner:!1,isWritable:!0}))],I=[{pubkey:t,isSigner:!0,isWritable:!1},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:p,isSigner:!1,isWritable:!0},{pubkey:Re,isSigner:!1,isWritable:!1},{pubkey:Ue,isSigner:!1,isWritable:!1},{pubkey:ur,isSigner:!1,isWritable:!1},{pubkey:u,isSigner:!1,isWritable:!1},{pubkey:l,isSigner:!1,isWritable:!1},...h],T=Buffer.alloc(P.span);P.encode({amount:d,otherAmountThreshold:f,sqrtPriceLimitX64:y,isBaseInput:b},T);let w=Buffer.from([...Vt.swap,...T]);return new ft({keys:I,programId:e,data:w})}static makeSwapBaseInInstructions({poolInfo:e,poolKeys:t,observationId:n,ownerInfo:o,inputMint:r,amountIn:i,amountOutMin:a,sqrtPriceLimitX64:c,remainingAccounts:u}){let[l,m]=[new G(e.programId),new G(e.id)],[p,d]=[new G(t.vault.A),new G(t.vault.B)],[f,y]=[new G(e.mintA.address),new G(e.mintB.address)],b=e.mintA.address===r.toString(),g=[this.swapInstruction(l,o.wallet,m,new G(e.config.id),b?o.tokenAccountA:o.tokenAccountB,b?o.tokenAccountB:o.tokenAccountA,b?p:d,b?d:p,b?f:y,b?y:f,u,n,i,a,c,!0,je(l,m).publicKey)];return{signers:[],instructions:g,instructionTypes:[U.ClmmSwapBaseIn],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[],address:{}}}static makeSwapBaseOutInstructions({poolInfo:e,poolKeys:t,observationId:n,ownerInfo:o,outputMint:r,amountOut:i,amountInMax:a,sqrtPriceLimitX64:c,remainingAccounts:u}){let[l,m]=[new G(e.programId),new G(e.id)],[p,d]=[new G(t.vault.A),new G(t.vault.B)],[f,y]=[new G(e.mintA.address),new G(e.mintB.address)],b=e.mintA.address===r.toBase58(),g=[this.swapInstruction(l,o.wallet,m,new G(e.config.id),b?o.tokenAccountB:o.tokenAccountA,b?o.tokenAccountA:o.tokenAccountB,b?d:p,b?p:d,b?y:f,b?f:y,u,n,i,a,c,!1,je(l,m).publicKey)];return{signers:[],instructions:g,instructionTypes:[U.ClmmSwapBaseOut],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[],address:{}}}static initRewardInstruction(e,t,n,o,r,i,a,c,u,l,m,p){let d=v([k("openTime"),k("endTime"),te("emissionsPerSecondX64")]),f=[{pubkey:t,isSigner:!0,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!1},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!1},{pubkey:Bn.programId,isSigner:!1,isWritable:!1},{pubkey:tt,isSigner:!1,isWritable:!1}],y=Buffer.alloc(d.span);d.encode({openTime:J(l),endTime:J(m),emissionsPerSecondX64:p},y);let b=Buffer.from([...Vt.initReward,...y]);return new ft({keys:f,programId:e,data:b})}static initRewardInstructions({poolInfo:e,poolKeys:t,ownerInfo:n,rewardInfo:o}){let[r,i]=[new G(e.programId),new G(e.id)],a=Jc(r,i,o.mint).publicKey,c=xi(r).publicKey,u=[this.initRewardInstruction(r,n.wallet,i,c,new G(e.config.id),n.tokenAccount,o.programId,o.mint,a,o.openTime,o.endTime,o.emissionsPerSecondX64)];return{address:{poolRewardVault:a,operationId:c},signers:[],instructions:u,instructionTypes:[U.ClmmInitReward],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[]}}static setRewardInstruction(e,t,n,o,r,i,a,c,u,l,m,p){let d=v([D("rewardIndex"),te("emissionsPerSecondX64"),k("openTime"),k("endTime")]),f=[{pubkey:t,isSigner:!0,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:Re,isSigner:!1,isWritable:!1},{pubkey:Ue,isSigner:!1,isWritable:!1},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0}],y=Buffer.alloc(d.span);d.encode({rewardIndex:u,emissionsPerSecondX64:p,openTime:J(l),endTime:J(m)},y);let b=Buffer.from([...Vt.setRewardEmissions,...y]);return new ft({keys:f,programId:e,data:b})}static setRewardInstructions({poolInfo:e,poolKeys:t,ownerInfo:n,rewardInfo:o}){let[r,i]=[new G(e.programId),new G(e.id)],a,c,u;for(let p=0;p<e.rewardDefaultInfos.length;p++)e.rewardDefaultInfos[p].mint.address===o.mint.toString()&&(a=p,c=new G(t.rewardInfos[p].vault),u=new G(t.rewardInfos[p].mint.address));(a===void 0||c===void 0)&&cl.logWithError("reward mint check error","no reward mint",e.rewardDefaultInfos);let l=xi(r).publicKey,m=[this.setRewardInstruction(r,n.wallet,i,l,new G(e.config.id),n.tokenAccount,c,u,a,o.openTime,o.endTime,o.emissionsPerSecondX64)];return{address:{rewardVault:c,operationId:l},signers:[],instructions:m,instructionTypes:[U.ClmmSetReward],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[]}}static collectRewardInstruction(e,t,n,o,r,i,a){let c=v([D("rewardIndex")]),u=[{pubkey:t,isSigner:!0,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!1},{pubkey:Re,isSigner:!1,isWritable:!1},{pubkey:Ue,isSigner:!1,isWritable:!1},{pubkey:ur,isSigner:!1,isWritable:!1}],l=Buffer.alloc(c.span);c.encode({rewardIndex:a},l);let m=Buffer.from([...Vt.collectReward,...l]);return new ft({keys:u,programId:e,data:m})}static collectRewardInstructions({poolInfo:e,poolKeys:t,ownerInfo:n,rewardMint:o}){let[r,i]=[new G(e.programId),new G(e.id)],a,c;for(let l=0;l<e.rewardDefaultInfos.length;l++)e.rewardDefaultInfos[l].mint.address===o.toString()&&(a=l,c=new G(t.rewardInfos[l].vault));(a===void 0||c===void 0)&&cl.logWithError("reward mint check error","no reward mint",e.rewardDefaultInfos);let u=[this.collectRewardInstruction(r,n.wallet,i,n.tokenAccount,c,o,a)];return{address:{rewardVault:c},signers:[],instructions:u,instructionTypes:[U.ClmmCollectReward],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[]}}static async makeLockPositions({programId:e,authProgramId:t,poolProgramId:n,payer:o,wallet:r,nftMint:i,nft2022:a,getEphemeralSigners:c}){let u=[],l;if(c)l=new G((await c(1))[0]);else{let g=Er.generate();u.push(g),l=g.publicKey}let m=a?j(r,i,Ue).publicKey:j(r,i,Re).publicKey,{publicKey:p}=Bt(n,i),d=Oo(e,l).publicKey,f=j(r,l,Re).publicKey,y=hn(l).publicKey,b=Le.lockPositionInstructionV2({programId:e,auth:t,payer:o,positionOwner:r,lockOwner:r,positionNftAccount:m,positionId:p,lockPositionId:d,lockNftMint:l,lockNftAccount:f,metadataAccount:y,withMetadata:!0,nft2022:a,positionNftMint:i,authPositionNftAccount:j(t,i,a?Ue:Re).publicKey,positionNftProgram:a?Ue:Re});return{address:{positionId:p,lockPositionId:d,lockNftAccount:f,lockNftMint:l,positionNftAccount:m,metadataAccount:y},instructions:[b],signers:u,instructionTypes:[U.ClmmLockPosition],lookupTableAddress:[]}}static lockPositionInstructionV2({programId:e,auth:t,payer:n,positionOwner:o,lockOwner:r,positionNftAccount:i,positionId:a,positionNftMint:c,authPositionNftAccount:u,positionNftProgram:l,lockPositionId:m,lockNftMint:p,lockNftAccount:d,metadataAccount:f,withMetadata:y}){let b=[{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!0,isWritable:!0},{pubkey:o,isSigner:!0,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!1},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!1},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:m,isSigner:!1,isWritable:!0},{pubkey:p,isSigner:!0,isWritable:!0},{pubkey:d,isSigner:!1,isWritable:!0},{pubkey:f,isSigner:!1,isWritable:!0},{pubkey:Jt,isSigner:!1,isWritable:!1},{pubkey:Ri,isSigner:!1,isWritable:!1},{pubkey:tt,isSigner:!1,isWritable:!1},{pubkey:Re,isSigner:!1,isWritable:!1},{pubkey:l,isSigner:!1,isWritable:!1},{pubkey:Bn.programId,isSigner:!1,isWritable:!1}],g=v([We("withMetadata")]),P=Buffer.alloc(g.span);g.encode({withMetadata:y},P);let h=Buffer.from([...ll,...P]);return new ft({keys:b,programId:e,data:h})}static lockPositionInstruction({programId:e,authProgramId:t,poolProgramId:n,owner:o,positionNft:r}){let{publicKey:i}=j(o,r,Re),{publicKey:a}=Bt(n,r),c=[{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!0,isWritable:!1},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!1},{pubkey:Ns(e,a).publicKey,isSigner:!1,isWritable:!0},{pubkey:Re,isSigner:!1,isWritable:!1},{pubkey:Bn.programId,isSigner:!1,isWritable:!1}];return new ft({keys:c,programId:e,data:Buffer.from(ll)})}static harvestLockPositionInstruction(e){let[t,n]=[new G(e.poolKeys.programId),new G(e.poolKeys.id)],o=Z.getTickArrayStartIndexByTick(e.ownerPosition.tickLower,e.poolKeys.config.tickSpacing),r=Z.getTickArrayStartIndexByTick(e.ownerPosition.tickUpper,e.poolKeys.config.tickSpacing),{publicKey:i}=Ae(t,n,o),{publicKey:a}=Ae(t,n,r),{publicKey:c}=j(e.owner,e.ownerPosition.nftMint,Re),{publicKey:u}=Bt(t,e.ownerPosition.nftMint),{publicKey:l}=an(t,n,e.ownerPosition.tickLower,e.ownerPosition.tickUpper),m=[];for(let f=0;f<e.poolKeys.rewardInfos.length;f++)m.push({poolRewardVault:new G(e.poolKeys.rewardInfos[f].vault),ownerRewardVault:e.ownerRewardAccounts[f],rewardMint:new G(e.poolKeys.rewardInfos[f].mint.address)});let p=[...m.map(f=>[{pubkey:f.poolRewardVault,isSigner:!1,isWritable:!0},{pubkey:f.ownerRewardVault,isSigner:!1,isWritable:!0},{pubkey:f.rewardMint,isSigner:!1,isWritable:!1}]).flat()],d=[{pubkey:e.authProgramId,isSigner:!1,isWritable:!1},{pubkey:Ns(e.programId,u).publicKey,isSigner:!1,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:e.owner,isSigner:!0,isWritable:!1},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:new G(e.poolKeys.vault.A),isSigner:!1,isWritable:!0},{pubkey:new G(e.poolKeys.vault.B),isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:e.userVaultA,isSigner:!1,isWritable:!0},{pubkey:e.userVaultB,isSigner:!1,isWritable:!0},{pubkey:Re,isSigner:!1,isWritable:!1},{pubkey:Ue,isSigner:!1,isWritable:!1},{pubkey:ln,isSigner:!1,isWritable:!1},{pubkey:new G(e.poolKeys.mintA.address),isSigner:!1,isWritable:!1},{pubkey:new G(e.poolKeys.mintB.address),isSigner:!1,isWritable:!1},...p];return new ft({keys:d,programId:e.programId,data:Buffer.from(ml)})}static harvestLockPositionInstructionV2({programId:e,auth:t,lockPositionId:n,clmmProgram:o,lockOwner:r,lockNftMint:i,lockNftAccount:a,positionNftAccount:c,positionId:u,poolId:l,protocolPosition:m,vaultA:p,vaultB:d,tickArrayLower:f,tickArrayUpper:y,userVaultA:b,userVaultB:g,mintA:P,mintB:h,rewardAccounts:I,exTickArrayBitmap:T}){let w=[...T?[{pubkey:T,isSigner:!1,isWritable:!0}]:[],...I.map(S=>[{pubkey:S.poolRewardVault,isSigner:!1,isWritable:!0},{pubkey:S.ownerRewardVault,isSigner:!1,isWritable:!0},{pubkey:S.rewardMint,isSigner:!1,isWritable:!1}]).flat()],x=[{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!0,isWritable:!1},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:m,isSigner:!1,isWritable:!0},{pubkey:p,isSigner:!1,isWritable:!0},{pubkey:d,isSigner:!1,isWritable:!0},{pubkey:f,isSigner:!1,isWritable:!0},{pubkey:y,isSigner:!1,isWritable:!0},{pubkey:b,isSigner:!1,isWritable:!0},{pubkey:g,isSigner:!1,isWritable:!0},{pubkey:Re,isSigner:!1,isWritable:!1},{pubkey:Ue,isSigner:!1,isWritable:!1},{pubkey:ln,isSigner:!1,isWritable:!1},{pubkey:P,isSigner:!1,isWritable:!1},{pubkey:h,isSigner:!1,isWritable:!1},...w];return new ft({keys:x,programId:e,data:Buffer.from(ml)})}};var dl=v([pt("mintAuthorityOption"),O("mintAuthority"),k("supply"),D("decimals"),D("isInitialized"),pt("freezeAuthorityOption"),O("freezeAuthority")]);import{PublicKey as sf}from"@solana/web3.js";import{MintLayout as pl,TOKEN_PROGRAM_ID as uf}from"@solana/spl-token";var FI=async({connection:s,mint:e})=>{let t=await s.getAccountInfo(new sf(e));return!t||t.data.length!==pl.span?void 0:pl.decode(t.data)},VI=({mint:s,decimals:e,programId:t=uf,logoURI:n="",priority:o=3})=>{let r=s.toBase58().substring(0,6);return{address:s.toBase58(),decimals:e,symbol:r,logoURI:n,extensions:{},chainId:101,programId:t.toString(),name:r,tags:[],priority:o}},Dr=s=>new Se({mint:s.address,decimals:s.decimals,symbol:s.symbol,name:s.name}),Li=o=>{var r=o,{amount:s,isRaw:e,name:t}=r,n=qe(r,["amount","isRaw","name"]);return new he(new Se({mint:yt(n.address).toBase58(),decimals:n.decimals,symbol:n.symbol,name:t}),s,e,t)};function _I(s){return s.address===cn.address?at:s}function EI(s){return s.address===at.address?cn:s}var At=o=>{var r=o,{address:s,programId:e,decimals:t}=r,n=qe(r,["address","programId","decimals"]);return N({chainId:101,address:yt(s).toBase58(),programId:e,logoURI:"",symbol:"",name:"",decimals:t,tags:[],extensions:n.extensions||{}},n)},_n=s=>s?q(N({},s),{transferFeeConfigAuthority:s.transferFeeConfigAuthority.toBase58(),withdrawWithheldAuthority:s.withdrawWithheldAuthority.toBase58(),withheldAmount:s.withheldAmount.toString(),olderTransferFee:q(N({},s.olderTransferFee),{epoch:s.olderTransferFee.epoch.toString(),maximumFee:s.olderTransferFee.maximumFee.toString()}),newerTransferFee:q(N({},s.newerTransferFee),{epoch:s.newerTransferFee.epoch.toString(),maximumFee:s.newerTransferFee.maximumFee.toString()})}):void 0;import fl from"bn.js";var Ds=new fl(25),Wr=new fl(1e4),cf={4:3,5:3};import{PublicKey as Oe,SystemProgram as gl,SYSVAR_RENT_PUBKEY as mf,TransactionInstruction as xn}from"@solana/web3.js";import{ASSOCIATED_TOKEN_PROGRAM_ID as df,TOKEN_PROGRAM_ID as vo}from"@solana/spl-token";var Ws=v([D("instruction"),k("amountIn"),k("minAmountOut")]),qs=v([D("instruction"),k("maxAmountIn"),k("amountOut")]),HI=v([D("instruction"),D("nonce")]),Us=v([D("instruction"),D("nonce"),k("startTime")]),io=v([k("status"),k("nonce"),k("maxOrder"),k("depth"),k("baseDecimal"),k("quoteDecimal"),k("state"),k("resetFlag"),k("minSize"),k("volMaxCutRatio"),k("amountWaveRatio"),k("baseLotSize"),k("quoteLotSize"),k("minPriceMultiplier"),k("maxPriceMultiplier"),k("systemDecimalValue"),k("minSeparateNumerator"),k("minSeparateDenominator"),k("tradeFeeNumerator"),k("tradeFeeDenominator"),k("pnlNumerator"),k("pnlDenominator"),k("swapFeeNumerator"),k("swapFeeDenominator"),k("baseNeedTakePnl"),k("quoteNeedTakePnl"),k("quoteTotalPnl"),k("baseTotalPnl"),k("poolOpenTime"),k("punishPcAmount"),k("punishCoinAmount"),k("orderbookToInitTime"),te("swapBaseInAmount"),te("swapQuoteOutAmount"),k("swapBase2QuoteFee"),te("swapQuoteInAmount"),te("swapBaseOutAmount"),k("swapQuote2BaseFee"),O("baseVault"),O("quoteVault"),O("baseMint"),O("quoteMint"),O("lpMint"),O("openOrders"),O("marketId"),O("marketProgramId"),O("targetOrders"),O("withdrawQueue"),O("lpVault"),O("owner"),k("lpReserve"),Q(k(),3,"padding")]),lf=v([k("accountType"),k("status"),k("nonce"),k("maxOrder"),k("depth"),k("baseDecimal"),k("quoteDecimal"),k("state"),k("resetFlag"),k("minSize"),k("volMaxCutRatio"),k("amountWaveRatio"),k("baseLotSize"),k("quoteLotSize"),k("minPriceMultiplier"),k("maxPriceMultiplier"),k("systemDecimalsValue"),k("abortTradeFactor"),k("priceTickMultiplier"),k("priceTick"),k("minSeparateNumerator"),k("minSeparateDenominator"),k("tradeFeeNumerator"),k("tradeFeeDenominator"),k("pnlNumerator"),k("pnlDenominator"),k("swapFeeNumerator"),k("swapFeeDenominator"),k("baseNeedTakePnl"),k("quoteNeedTakePnl"),k("quoteTotalPnl"),k("baseTotalPnl"),k("poolOpenTime"),k("punishPcAmount"),k("punishCoinAmount"),k("orderbookToInitTime"),te("swapBaseInAmount"),te("swapQuoteOutAmount"),te("swapQuoteInAmount"),te("swapBaseOutAmount"),k("swapQuote2BaseFee"),k("swapBase2QuoteFee"),O("baseVault"),O("quoteVault"),O("baseMint"),O("quoteMint"),O("lpMint"),O("modelDataAccount"),O("openOrders"),O("marketId"),O("marketProgramId"),O("targetOrders"),O("owner"),Q(k(),64,"padding")]),Gs=v([D("instruction"),k("baseAmountIn"),k("quoteAmountIn"),k("fixedSide"),k("otherAmountMin")]),Xs=v([D("instruction"),k("lpAmount"),k("baseAmountMin"),k("quoteAmountMin")]),ZI={4:io,5:lf},yl=v([k("fee")]);var bl=fe("Raydium_liquidity_instruction");function Al(s){let{poolInfo:e,poolKeys:t,userKeys:n,baseAmountIn:o,quoteAmountIn:r,fixedSide:i,otherAmountMin:a,modelDataPubKey:c=On}=s,u=Buffer.alloc(Gs.span);Gs.encode({instruction:3,baseAmountIn:J(o),quoteAmountIn:J(r),otherAmountMin:J(a),fixedSide:i==="base"?Je:qu},u);let l=[A({pubkey:vo,isWritable:!1}),A({pubkey:new Oe(e.id)}),A({pubkey:new Oe(t.authority),isWritable:!1}),A({pubkey:new Oe(t.openOrders),isWritable:!1}),A({pubkey:new Oe(t.targetOrders)}),A({pubkey:new Oe(e.lpMint.address)}),A({pubkey:new Oe(t.vault.A)}),A({pubkey:new Oe(t.vault.B)})];return e.pooltype.includes("StablePool")&&l.push(A({pubkey:c})),l.push(A({pubkey:new Oe(e.marketId),isWritable:!1}),A({pubkey:n.baseTokenAccount}),A({pubkey:n.quoteTokenAccount}),A({pubkey:n.lpTokenAccount}),A({pubkey:n.owner,isWritable:!1,isSigner:!0}),A({pubkey:new Oe(t.marketEventQueue),isWritable:!1})),new xn({programId:new Oe(e.programId),keys:l,data:u})}function zs(s){let{poolInfo:e,poolKeys:t,userKeys:n,lpAmount:o,baseAmountMin:r,quoteAmountMin:i,modelDataPubKey:a=On}=s,c=Fe(t),u=4;if(e.pooltype.includes("StablePool")&&(u=5),u===4||u===5){let l=Buffer.alloc(Xs.span);Xs.encode({instruction:4,lpAmount:J(o),baseAmountMin:J(r),quoteAmountMin:J(i)},l);let m=[A({pubkey:vo,isWritable:!1}),A({pubkey:c.id}),A({pubkey:c.authority,isWritable:!1}),A({pubkey:c.openOrders}),A({pubkey:c.targetOrders}),A({pubkey:c.mintLp.address}),A({pubkey:c.vault.A}),A({pubkey:c.vault.B})];return u===5?m.push(A({pubkey:a})):(m.push(A({pubkey:c.id})),m.push(A({pubkey:c.id}))),m.push(A({pubkey:c.marketProgramId,isWritable:!1}),A({pubkey:c.marketId}),A({pubkey:c.marketBaseVault}),A({pubkey:c.marketQuoteVault}),A({pubkey:c.marketAuthority,isWritable:!1}),A({pubkey:n.lpTokenAccount}),A({pubkey:n.baseTokenAccount}),A({pubkey:n.quoteTokenAccount}),A({pubkey:n.owner,isWritable:!1,isSigner:!0}),A({pubkey:c.marketEventQueue}),A({pubkey:c.marketBids}),A({pubkey:c.marketAsks})),new xn({programId:c.programId,keys:m,data:l})}return new xn({programId:c.programId,keys:[]})}function Qs({programId:s,ammId:e,ammAuthority:t,ammOpenOrders:n,lpMint:o,coinMint:r,pcMint:i,coinVault:a,pcVault:c,withdrawQueue:u,ammTargetOrders:l,poolTempLp:m,marketProgramId:p,marketId:d,userWallet:f,userCoinVault:y,userPcVault:b,userLpVault:g,nonce:P,openTime:h,coinAmount:I,pcAmount:T,ammConfigId:w,feeDestinationId:x}){let S=v([D("instruction"),D("nonce"),k("openTime"),k("pcAmount"),k("coinAmount")]),K=[{pubkey:vo,isSigner:!1,isWritable:!1},{pubkey:df,isSigner:!1,isWritable:!1},{pubkey:gl.programId,isSigner:!1,isWritable:!1},{pubkey:tt,isSigner:!1,isWritable:!1},{pubkey:e,isSigner:!1,isWritable:!0},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!1},{pubkey:i,isSigner:!1,isWritable:!1},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:w,isSigner:!1,isWritable:!1},{pubkey:x,isSigner:!1,isWritable:!0},{pubkey:p,isSigner:!1,isWritable:!1},{pubkey:d,isSigner:!1,isWritable:!1},{pubkey:f,isSigner:!0,isWritable:!0},{pubkey:y,isSigner:!1,isWritable:!0},{pubkey:b,isSigner:!1,isWritable:!0},{pubkey:g,isSigner:!1,isWritable:!0}],B=Buffer.alloc(S.span);return S.encode({instruction:1,nonce:P,openTime:h,coinAmount:I,pcAmount:T},B),{instruction:new xn({keys:K,programId:s,data:B}),instructionType:U.AmmV4CreatePool}}function uB(s){let e=v([D("instruction"),D("simulateType")]),t=Buffer.alloc(e.span);e.encode({instruction:12,simulateType:0},t);let n=[A({pubkey:new Oe(s.id),isWritable:!1}),A({pubkey:new Oe(s.authority),isWritable:!1}),A({pubkey:new Oe(s.openOrders),isWritable:!1}),A({pubkey:new Oe(s.vault.A),isWritable:!1}),A({pubkey:new Oe(s.vault.B),isWritable:!1}),A({pubkey:new Oe(s.mintLp.address),isWritable:!1}),A({pubkey:new Oe(s.marketId),isWritable:!1}),A({pubkey:new Oe(s.marketEventQueue),isWritable:!1})];return new xn({programId:new Oe(s.programId),keys:n,data:t})}function pf({poolKeys:s,userKeys:e,amountIn:t,minAmountOut:n,modelDataPubKey:o=On},r){let i=Fe(s),a=Buffer.alloc(Ws.span);Ws.encode({instruction:9,amountIn:J(t),minAmountOut:J(n)},a);let c=[A({pubkey:vo,isWritable:!1}),A({pubkey:i.id}),A({pubkey:i.authority,isWritable:!1}),A({pubkey:i.openOrders})];return r===4&&c.push(A({pubkey:i.targetOrders})),c.push(A({pubkey:i.vault.A}),A({pubkey:i.vault.B})),r===5&&c.push(A({pubkey:o})),c.push(A({pubkey:i.marketProgramId,isWritable:!1}),A({pubkey:i.marketId}),A({pubkey:i.marketBids}),A({pubkey:i.marketAsks}),A({pubkey:i.marketEventQueue}),A({pubkey:i.marketBaseVault}),A({pubkey:i.marketQuoteVault}),A({pubkey:i.marketAuthority,isWritable:!1}),A({pubkey:e.tokenAccountIn}),A({pubkey:e.tokenAccountOut}),A({pubkey:e.owner,isWritable:!1,isSigner:!0})),new xn({programId:i.programId,keys:c,data:a})}function ff({poolKeys:s,userKeys:e,maxAmountIn:t,amountOut:n,modelDataPubKey:o=On},r){let i=Fe(s),a=Buffer.alloc(qs.span);qs.encode({instruction:11,maxAmountIn:J(t),amountOut:J(n)},a);let c=[A({pubkey:vo,isWritable:!1}),A({pubkey:i.id}),A({pubkey:i.authority,isWritable:!1}),A({pubkey:i.openOrders}),A({pubkey:i.targetOrders}),A({pubkey:i.vault.A}),A({pubkey:i.vault.B})];return r===5&&c.push(A({pubkey:o})),c.push(A({pubkey:i.marketProgramId,isWritable:!1}),A({pubkey:i.marketId}),A({pubkey:i.marketBids}),A({pubkey:i.marketAsks}),A({pubkey:i.marketEventQueue}),A({pubkey:i.marketBaseVault}),A({pubkey:i.marketQuoteVault}),A({pubkey:i.marketAuthority,isWritable:!1}),A({pubkey:e.tokenAccountIn}),A({pubkey:e.tokenAccountOut}),A({pubkey:e.owner,isWritable:!1,isSigner:!0})),new xn({programId:i.programId,keys:c,data:a})}function qr(s){let{poolKeys:e,version:t,userKeys:n,amountIn:o,amountOut:r,fixedSide:i}=s;if(t===4||t===5){let a={poolKeys:e,userKeys:n};if(i==="in")return pf(q(N({},a),{amountIn:o,minAmountOut:r}),t);if(i==="out")return ff(q(N({},a),{maxAmountIn:o,amountOut:r}),t);bl.logWithError("invalid params","params",s)}throw bl.logWithError("invalid version","poolKeys.version",t),new Error("invalid version")}function cB({poolKeys:s,userKeys:e,startTime:t}){let n=Buffer.alloc(Us.span);Us.encode({instruction:0,nonce:5,startTime:J(t)},n);let o=Fe(s),r=[A({pubkey:vo,isWritable:!1}),A({pubkey:gl.programId,isWritable:!1}),A({pubkey:mf,isWritable:!1}),A({pubkey:o.id}),A({pubkey:o.authority,isWritable:!1}),A({pubkey:o.openOrders}),A({pubkey:o.mintLp.address}),A({pubkey:o.mintA.address,isWritable:!1}),A({pubkey:o.mintB.address,isWritable:!1}),A({pubkey:o.vault.A,isWritable:!1}),A({pubkey:o.vault.B,isWritable:!1}),A({pubkey:o.id}),A({pubkey:o.targetOrders}),A({pubkey:e.lpTokenAccount}),A({pubkey:o.id,isWritable:!1}),A({pubkey:o.marketProgramId,isWritable:!1}),A({pubkey:o.marketId,isWritable:!1}),A({pubkey:e.payer,isSigner:!0})];return new xn({programId:o.programId,keys:r,data:n})}function Pl({poolKeys:s}){let e=v([D("instruction"),D("simulateType")]),t=Buffer.alloc(e.span);e.encode({instruction:12,simulateType:0},t);let n=[A({pubkey:new Oe(s.id),isWritable:!1}),A({pubkey:new Oe(s.authority),isWritable:!1}),A({pubkey:new Oe(s.openOrders),isWritable:!1}),A({pubkey:new Oe(s.vault.A),isWritable:!1}),A({pubkey:new Oe(s.vault.B),isWritable:!1}),A({pubkey:new Oe(s.mintLp.address),isWritable:!1}),A({pubkey:new Oe(s.marketId),isWritable:!1}),A({pubkey:new Oe(s.marketEventQueue),isWritable:!1})];return{instruction:new xn({programId:new Oe(s.programId),keys:n,data:t})}}var ao=5e4,yf=v([k("x"),k("y"),k("price")]),bf=v([k("accountType"),k("status"),k("multiplier"),k("validDataCount"),Q(yf,ao,"DataElement")]);function gf(s,e){return[0,ao-2]}function Af(s){return[0,ao-2]}function Pf(s){return[0,ao-2]}function kf(s,e,t){let[n,o]=gf(e,t),r=n,i=o,a=0,c=e*s.multiplier/t;for(;r<=i;){if(a=Math.floor((i+r)/2),a===0||a>=ao-2)return[a,a,!1];let u=s.DataElement[a].x*s.multiplier/s.DataElement[a].y,l=s.DataElement[a-1].x*s.multiplier/s.DataElement[a-1].y,m=s.DataElement[a+1].x*s.multiplier/s.DataElement[a+1].y;if(c===u)return[a,a,!0];if(c===l)return[a-1,a-1,!0];if(c===m)return[a+1,a+1,!0];if(c<l)i=a-1;else{if(c>l&&c<u)return[a-1,a,!0];if(c>u&&c<m)return[a,a+1,!0];r=a+1}}return[a,a,!1]}function Ys(s,e,t){let[n,o,r]=kf(s,e,t);if(!r)return 0;if(n===o){let i=s.DataElement[n].x;return e*s.multiplier/i}else{let i=s.DataElement[n].x,a=s.DataElement[n].y,c=s.DataElement[o].x,u=s.DataElement[o].y,l=t*(c*a-i*u),m=i*l,p=(c-i)*(e*a-i*t)*u,d=m+p;return e*s.multiplier*l/d}}function ro(s,e,t){return e*s.multiplier/t}function kl(s,e,t){return e*t/s.multiplier}function wf(s,e){let[t,n]=Af(e),o=t,r=n,i=0,a=e;for(;o<r;){if(i=Math.floor((r+o)/2),i<=0||i>ao-2)return[i,i,!1];let c=s.DataElement[i].x,u=s.DataElement[i-1].x,l=s.DataElement[i+1].x;if(a===c)return[i,i,!0];if(a===u)return[i-1,i-1,!0];if(a===l)return[i+1,i+1,!0];if(a<u)r=i-1;else{if(a>u&&a<c)return[i-1,i,!0];if(a>c&&a<l)return[i,i+1,!0];o=i+1}}return[i,i,!1]}function Tf(s,e){let[t,n]=Pf(e),o=t,r=n,i=0,a=e;for(;o<=r;){if(i=Math.floor((r+o)/2),i<=0||i>=ao-2)return[i,i,!1];let c=s.DataElement[i].y,u=s.DataElement[i-1].y,l=s.DataElement[i+1].y;if(a===c)return[i,i,!0];if(a===u)return[i-1,i-1,!0];if(a===l)return[i+1,i+1,!0];if(a<l)o=i+1;else{if(a<u&&a>c)return[i-1,i,!0];if(a<c&&a>l)return[i,i+1,!0];r=i-1}}return[i,i,!1]}function wl(s,e,t,n){let o=n?e+t:e-t,[r,i,a]=wf(s,o);if(!a)return[0,0,!1,a];if(r===i)return[s.DataElement[i].price,s.DataElement[i].y,!1,a];{let c=s.DataElement[r].x,u=s.DataElement[i].x,l=s.DataElement[r].price,m=s.DataElement[i].price,p=s.DataElement[r].y,d=s.DataElement[i].y;if(e>=c&&e<=u)return n?[m,d,!0,a]:[l,p,!0,a];{let f,y;return n?(f=l+(m-l)*(e-c)/(u-c),y=p-(o-c)*s.multiplier/m):(f=l+(m-l)*(e-c)/(u-c),y=d+(u-o)*s.multiplier/l),[f,y,!1,a]}}}function hf(s,e,t,n){let o=n?e-t:e+t,[r,i,a]=Tf(s,o);if(!a)return[0,0,!1,a];if(r===i)return[s.DataElement[i].price,s.DataElement[i].x,!1,a];{let c=s.DataElement[r].x,u=s.DataElement[i].x,l=s.DataElement[r].price,m=s.DataElement[i].price,p=s.DataElement[r].y,d=s.DataElement[i].y;if(e>=d&&e<=p)return n?[m,u,!0,a]:[l,c,!0,a];{let f,y;return n?(f=l+(m-l)*(p-e)/(p-d),y=c+m*(p-o)/s.multiplier):(f=l+(m-l)*(p-e)/(p-d),y=u-l*(o-d)/s.multiplier),[f,y,!1,a]}}}function If(s,e){let t=wl(s,e,0,!1);return t[3]?t[0]:0}function Tl(s,e,t,n){let o=Ys(s,e,t),r=ro(s,e,o),i=ro(s,t,o),a=ro(s,n,o),c=!0,[u,l,m,p]=wl(s,r,a,c);if(!p)return 0;if(m)return n*s.multiplier/u;{let d=i-l;return kl(s,d,o)}}function hl(s,e,t,n){let o=Ys(s,e,t),r=ro(s,e,o),i=ro(s,t,o),a=ro(s,n,o),c=!1,[u,l,m,p]=hf(s,i,a,c);if(!p)return 0;if(m)return n*u/s.multiplier;{let d=r-l;return kl(s,d,o)}}function Bf(s){let e=bf.decode(s);return{accountType:e.accountType.toNumber(),status:e.status.toNumber(),multiplier:e.multiplier.toNumber(),validDataCount:e.validDataCount.toNumber(),DataElement:e.DataElement.map(t=>({x:t.x.toNumber(),y:t.y.toNumber(),price:t.price.toNumber()}))}}function Il(s,e,t,n){let o=If(s,ro(s,e,Ys(s,e,t)))/s.multiplier;return n?o:1/o}var Fo=class{constructor({connection:e,modelDataPubKey:t=On}){this._layoutData={accountType:0,status:0,multiplier:0,validDataCount:0,DataElement:[]};this.connection=e,this.modelDataPubKey=t}get stableModelData(){return this._layoutData}async initStableModelLayout(){if(this._layoutData.validDataCount===0&&this.connection){let e=await this.connection.getAccountInfo(this.modelDataPubKey);e&&(this._layoutData=Bf(e==null?void 0:e.data))}}};import{PublicKey as Ni}from"@solana/web3.js";import Oi from"bn.js";import Ur from"decimal.js";import{TOKEN_PROGRAM_ID as Kf}from"@solana/spl-token";import{PublicKey as xf}from"@solana/web3.js";var Sf=fe("Raydium_liquidity_serum");function Bl({programId:s,marketId:e}){let t=[e.toBuffer()],n=0,o;for(;n<100;){try{let r=t.concat(Buffer.from([n]),Buffer.alloc(7));o=xf.createProgramAddressSync(r,s)}catch(r){if(r instanceof TypeError)throw r;n++;continue}return{publicKey:o,nonce:n}}throw Sf.logWithError("unable to find a viable program address nonce","params",{programId:s,marketId:e}),new Error("unable to find a viable program address nonce")}function Gr({programId:s}){let{publicKey:e}=ne([Buffer.from("amm_config_account_seed","utf-8")],s);return e}function so({name:s,programId:e,marketId:t}){let{publicKey:n}=ne([e.toBuffer(),t.toBuffer(),Buffer.from(s,"utf-8")],e);return n}function Cf({programId:s,marketId:e}){let{publicKey:t}=ne([s.toBuffer(),e.toBuffer(),Buffer.from("open_order_associated_seed","utf-8")],s);return t}function Zs({programId:s}){return ne([Buffer.from([97,109,109,32,97,117,116,104,111,114,105,116,121])],s)}function $s({version:s,marketVersion:e,marketId:t,baseMint:n,quoteMint:o,baseDecimals:r,quoteDecimals:i,programId:a,marketProgramId:c}){let u=so({name:"amm_associated_seed",programId:a,marketId:t}),l=so({name:"lp_mint_associated_seed",programId:a,marketId:t}),{publicKey:m,nonce:p}=Zs({programId:a}),d=so({name:"coin_vault_associated_seed",programId:a,marketId:t}),f=so({name:"pc_vault_associated_seed",programId:a,marketId:t}),y=so({name:"temp_lp_token_associated_seed",programId:a,marketId:t}),b=Cf({programId:a,marketId:t}),g=so({name:"target_associated_seed",programId:a,marketId:t}),P=so({name:"withdraw_associated_seed",programId:a,marketId:t}),{publicKey:h}=Bl({programId:c,marketId:t});return{id:u,baseMint:n,quoteMint:o,lpMint:l,baseDecimals:r,quoteDecimals:i,lpDecimals:r,version:s,programId:a,authority:m,nonce:p,baseVault:d,quoteVault:f,lpVault:y,openOrders:b,targetOrders:g,withdrawQueue:P,marketVersion:e,marketProgramId:c,marketId:t,marketAuthority:h,lookupTableAccount:Ni.default,configId:Gr({programId:a})}}var js;async function FB({connection:s,poolKeysList:e,config:t,modelDataPubKey:n}){return e.find(r=>r.modelDataAccount)&&(js||(js=new Fo({connection:s,modelDataPubKey:n}),await js.initStableModelLayout())),await Promise.all(e.map(async r=>{if(r.modelDataAccount){let i=Pl({poolKeys:r});return(await $u(s,[i.instruction],"GetPoolData")).map(u=>{let l=Ju(u,"GetPoolData"),m=new Oi(An(l,"status")),p=Number(An(l,"coin_decimals")),d=Number(An(l,"pc_decimals")),f=Number(An(l,"lp_decimals")),y=new Oi(An(l,"pool_coin_amount")),b=new Oi(An(l,"pool_pc_amount")),g=new Oi(An(l,"pool_lp_supply")),P="0";try{P=An(l,"pool_open_time")}catch{}return{status:m,baseDecimals:p,quoteDecimals:d,lpDecimals:f,baseReserve:y,quoteReserve:b,lpSupply:g,startTime:new Oi(P)}})[0]}else{let[i,a,c,u]=await s.getMultipleAccountsInfo([new Ni(r.id),new Ni(r.vault.A),new Ni(r.vault.B),new Ni(r.mintLp.address)]);if(i===null)throw Error("fetch pool error");if(a===null)throw Error("fetch vaultAccA error");if(c===null)throw Error("fetch vaultAccB error");if(u===null)throw Error("fetch mintAccLp error");let l=io.decode(i.data),m=rn.decode(a.data),p=rn.decode(c.data),d=dl.decode(u.data);return{status:l.status,baseDecimals:l.baseDecimal.toNumber(),quoteDecimals:l.quoteDecimal.toNumber(),lpDecimals:d.decimals,baseReserve:m.amount.sub(l.baseNeedTakePnl),quoteReserve:p.amount.sub(l.quoteNeedTakePnl),lpSupply:l.lpReserve,startTime:l.poolOpenTime}}}))}var Hs={volume:0,volumeQuote:0,volumeFee:0,apr:0,feeApr:0,priceMin:0,priceMax:0,rewardApr:[]},Xr=s=>{let e={},t=Kf.toBase58();return Object.keys(s).map(n=>{let o=s[n],[r,i]=[o.baseMint.toBase58(),o.quoteMint.toBase58()];e[n]={id:n,version:4,status:o.status.toNumber(),programId:o.programId.toBase58(),mintA:At({address:r,programId:t,decimals:o.baseDecimal.toNumber()}),mintB:At({address:i,programId:t,decimals:o.quoteDecimal.toNumber()}),rewardDefaultInfos:[],rewardDefaultPoolInfos:"Ecosystem",price:o.poolPrice.toNumber(),mintAmountA:new Ur(o.mintAAmount.toString()).div(10**o.baseDecimal.toNumber()).toNumber(),mintAmountB:new Ur(o.mintBAmount.toString()).div(10**o.quoteDecimal.toNumber()).toNumber(),baseReserve:o.baseReserve,quoteReserve:o.quoteReserve,feeRate:new Ur(o.tradeFeeNumerator.toString()).div(o.tradeFeeDenominator.toString()).toNumber(),openTime:o.poolOpenTime.toString(),tvl:0,day:Hs,week:Hs,month:Hs,pooltype:[],farmUpcomingCount:0,farmOngoingCount:0,farmFinishedCount:0,type:"Standard",marketId:o.marketId.toBase58(),configId:Gr({programId:o.programId}).toBase58(),lpPrice:0,lpAmount:new Ur(o.lpReserve.toString()).div(10**Math.min(o.baseDecimal.toNumber(),o.quoteDecimal.toNumber())).toNumber(),lpMint:At({address:o.lpMint.toBase58(),programId:t,decimals:Math.min(o.baseDecimal.toNumber(),o.quoteDecimal.toNumber())}),burnPercent:0}}),e};import Ge from"bn.js";import Ne from"decimal.js";import{PublicKey as Mi}from"@solana/web3.js";import vi from"bn.js";import{TOKEN_PROGRAM_ID as Cl}from"@solana/spl-token";import{SystemProgram as uo,SYSVAR_RENT_PUBKEY as Lf,Transaction as xl,TransactionInstruction as Of}from"@solana/web3.js";import{createInitializeAccountInstruction as Sl,TOKEN_PROGRAM_ID as Kl}from"@solana/spl-token";function Rf(s="accountFlags"){let e=new Rr(s);return e.addBoolean("initialized"),e.addBoolean("market"),e.addBoolean("openOrders"),e.addBoolean("requestQueue"),e.addBoolean("eventQueue"),e.addBoolean("bids"),e.addBoolean("asks"),e}var Js=v([xe(5),Rf("accountFlags"),O("ownAddress"),k("vaultSignerNonce"),O("baseMint"),O("quoteMint"),O("baseVault"),k("baseDepositsTotal"),k("baseFeesAccrued"),O("quoteVault"),k("quoteDepositsTotal"),k("quoteFeesAccrued"),k("quoteDustThreshold"),O("requestQueue"),O("eventQueue"),O("bids"),O("asks"),k("baseLotSize"),k("quoteLotSize"),k("feeRateBps"),k("referrerRebatesAccrued"),xe(7)]);function Nf({programId:s,marketInfo:e}){let t=v([D("version"),pt("instruction"),k("baseLotSize"),k("quoteLotSize"),Mt("feeRateBps"),k("vaultSignerNonce"),k("quoteDustThreshold")]),n=[{pubkey:e.id,isSigner:!1,isWritable:!0},{pubkey:e.requestQueue,isSigner:!1,isWritable:!0},{pubkey:e.eventQueue,isSigner:!1,isWritable:!0},{pubkey:e.bids,isSigner:!1,isWritable:!0},{pubkey:e.asks,isSigner:!1,isWritable:!0},{pubkey:e.baseVault,isSigner:!1,isWritable:!0},{pubkey:e.quoteVault,isSigner:!1,isWritable:!0},{pubkey:e.baseMint,isSigner:!1,isWritable:!1},{pubkey:e.quoteMint,isSigner:!1,isWritable:!1},{pubkey:e.authority?e.quoteMint:Lf,isSigner:!1,isWritable:!1}].concat(e.authority?{pubkey:e.authority,isSigner:!1,isWritable:!1}:[]).concat(e.authority&&e.pruneAuthority?{pubkey:e.pruneAuthority,isSigner:!1,isWritable:!1}:[]),o=Buffer.alloc(t.span);return t.encode({version:0,instruction:0,baseLotSize:e.baseLotSize,quoteLotSize:e.quoteLotSize,feeRateBps:e.feeRateBps,vaultSignerNonce:e.vaultSignerNonce,quoteDustThreshold:e.quoteDustThreshold},o),new Of({keys:n,programId:s,data:o})}async function zr({connection:s,wallet:e,marketInfo:t}){var i,a,c,u,l,m,p,d;let n=new xl,o=await s.getMinimumBalanceForRentExemption(165);n.add(uo.createAccountWithSeed({fromPubkey:e,basePubkey:e,seed:t.baseVault.seed,newAccountPubkey:t.baseVault.publicKey,lamports:o,space:165,programId:Kl}),uo.createAccountWithSeed({fromPubkey:e,basePubkey:e,seed:t.quoteVault.seed,newAccountPubkey:t.quoteVault.publicKey,lamports:o,space:165,programId:Kl}),Sl(t.baseVault.publicKey,t.baseMint,t.vaultOwner),Sl(t.quoteVault.publicKey,t.quoteMint,t.vaultOwner),uo.createAccountWithSeed({fromPubkey:e,basePubkey:e,seed:t.id.seed,newAccountPubkey:t.id.publicKey,lamports:await s.getMinimumBalanceForRentExemption(Js.span),space:Js.span,programId:t.programId}));let r=new xl;return r.add(uo.createAccountWithSeed({fromPubkey:e,basePubkey:e,seed:t.requestQueue.seed,newAccountPubkey:t.requestQueue.publicKey,lamports:t.lowestFeeMarket?6208320:await s.getMinimumBalanceForRentExemption((i=t.requestQueueSpace)!=null?i:5120+12),space:t.lowestFeeMarket?764:(a=t.requestQueueSpace)!=null?a:5120+12,programId:t.programId}),uo.createAccountWithSeed({fromPubkey:e,basePubkey:e,seed:t.eventQueue.seed,newAccountPubkey:t.eventQueue.publicKey,lamports:t.lowestFeeMarket?79594560:await s.getMinimumBalanceForRentExemption((c=t.eventQueueSpace)!=null?c:262144+12),space:t.lowestFeeMarket?11308:(u=t.eventQueueSpace)!=null?u:262144+12,programId:t.programId}),uo.createAccountWithSeed({fromPubkey:e,basePubkey:e,seed:t.bids.seed,newAccountPubkey:t.bids.publicKey,lamports:t.lowestFeeMarket?101977920:await s.getMinimumBalanceForRentExemption((l=t.orderbookQueueSpace)!=null?l:65536+12),space:t.lowestFeeMarket?14524:(m=t.orderbookQueueSpace)!=null?m:65536+12,programId:t.programId}),uo.createAccountWithSeed({fromPubkey:e,basePubkey:e,seed:t.asks.seed,newAccountPubkey:t.asks.publicKey,lamports:t.lowestFeeMarket?101977920:await s.getMinimumBalanceForRentExemption((p=t.orderbookQueueSpace)!=null?p:65536+12),space:t.lowestFeeMarket?14524:(d=t.orderbookQueueSpace)!=null?d:65536+12,programId:t.programId}),Nf({programId:t.programId,marketInfo:{id:t.id.publicKey,requestQueue:t.requestQueue.publicKey,eventQueue:t.eventQueue.publicKey,bids:t.bids.publicKey,asks:t.asks.publicKey,baseVault:t.baseVault.publicKey,quoteVault:t.quoteVault.publicKey,baseMint:t.baseMint,quoteMint:t.quoteMint,baseLotSize:t.baseLotSize,quoteLotSize:t.quoteLotSize,feeRateBps:t.feeRateBps,vaultSignerNonce:t.vaultSignerNonce,quoteDustThreshold:t.quoteDustThreshold}})),[{transaction:n,signer:[],instructionTypes:[U.CreateAccount,U.CreateAccount,U.InitAccount,U.InitAccount]},{transaction:r,signer:[],instructionTypes:[U.CreateAccount,U.CreateAccount,U.CreateAccount,U.CreateAccount,U.CreateAccount,U.InitMarket]}]}var Vo=class extends Ve{async create({baseInfo:e,quoteInfo:t,lotSize:n,tickSize:o,dexProgramId:r,requestQueueSpace:i,eventQueueSpace:a,orderbookQueueSpace:c,lowestFeeMarket:u,assignSeed:l,txVersion:m,computeBudgetConfig:p,txTipConfig:d,feePayer:f}){let y=this.scope.ownerPubKey,b=l?`${e.mint.toBase58().slice(0,10)}-${t.mint.toBase58().slice(0,10)}-${l}`:void 0,g=Ye({fromPublicKey:y,programId:r,assignSeed:b&&`${b}-market`}),P=Ye({fromPublicKey:y,programId:r,assignSeed:b&&`${b}-request`}),h=Ye({fromPublicKey:y,programId:r,assignSeed:b&&`${b}-event`}),I=Ye({fromPublicKey:y,programId:r,assignSeed:b&&`${b}-bids`}),T=Ye({fromPublicKey:y,programId:r,assignSeed:b&&`${b}-asks`}),w=Ye({fromPublicKey:y,programId:Cl,assignSeed:b&&`${b}-baseVault`}),x=Ye({fromPublicKey:y,programId:Cl,assignSeed:b&&`${b}-quoteVault`}),S=0,K=new vi(100);function B(){let z=new vi(0);for(;;)try{return{vaultOwner:Mi.createProgramAddressSync([g.publicKey.toBuffer(),z.toArrayLike(Buffer,"le",8)],r),vaultSignerNonce:z}}catch{if(z.iaddn(1),z.gt(new vi(25555)))throw Error("find vault owner error")}}let{vaultOwner:C,vaultSignerNonce:M}=B(),V=new vi(Math.round(10**e.decimals*n)),R=new vi(Math.round(n*10**t.decimals*o));if(V.eq(Je))throw Error("lot size is too small");if(R.eq(Je))throw Error("tick size or lot size is too small");let L=await zr({connection:this.scope.connection,wallet:this.scope.ownerPubKey,marketInfo:{programId:r,id:g,baseMint:e.mint,quoteMint:t.mint,baseVault:w,quoteVault:x,vaultOwner:C,requestQueue:P,eventQueue:h,bids:I,asks:T,feeRateBps:S,quoteDustThreshold:K,vaultSignerNonce:M,baseLotSize:V,quoteLotSize:R,requestQueueSpace:i,eventQueueSpace:a,orderbookQueueSpace:c,lowestFeeMarket:u}}),W=this.createTxBuilder(f);W.addInstruction({instructions:L[0].transaction.instructions,signers:L[0].signer});for await(let z of L.slice(1,L.length))W.addInstruction({instructions:z.transaction.instructions,signers:z.signer,instructionTypes:z.instructionTypes});return m===0?W.sizeCheckBuildV0({computeBudgetConfig:p,address:{marketId:g.publicKey,requestQueue:P.publicKey,eventQueue:h.publicKey,bids:I.publicKey,asks:T.publicKey,baseVault:w.publicKey,quoteVault:x.publicKey,baseMint:new Mi(e.mint),quoteMint:new Mi(t.mint)}}):W.sizeCheckBuild({computeBudgetConfig:p,address:{marketId:g.publicKey,requestQueue:P.publicKey,eventQueue:h.publicKey,bids:I.publicKey,asks:T.publicKey,baseVault:w.publicKey,quoteVault:x.publicKey,baseMint:new Mi(e.mint),quoteMint:new Mi(t.mint)}})}};var Fi=class extends Ve{constructor(t){super(t);this.stableLayout=new Fo({connection:this.scope.connection,modelDataPubKey:this.scope.cluster==="mainnet"?void 0:Pn.MODEL_DATA_PUBKEY})}async initLayout(){await this.stableLayout.initStableModelLayout()}async load(){this.checkDisabled()}computePairAmount({poolInfo:t,amount:n,slippage:o,baseIn:r}){let i=new Ge(new Ne(n).mul(10**t[r?"mintA":"mintB"].decimals).toFixed(0)),a=Dr(t[r?"mintB":"mintA"]),[c,u]=[new Ge(new Ne(t.mintAmountA).mul(10**t.mintA.decimals).toString()),new Ge(new Ne(t.mintAmountB).mul(10**t.mintB.decimals).toString())],l=new Ge(new Ne(t.lpAmount).mul(10**t.lpMint.decimals).toFixed(0,Ne.ROUND_DOWN));this.logDebug("baseReserve:",c.toString(),"quoteReserve:",u.toString()),this.logDebug("tokenIn:",r?t.mintA.symbol:t.mintB.symbol,"amountIn:",i.toString(),"anotherToken:",r?t.mintB.symbol:t.mintA.symbol,"slippage:",`${o.toSignificant()}%`,"baseReserve",c.toString(),"quoteReserve",u.toString());let m=r?"base":"quote";this.logDebug("input side:",m);let p=Je;i.isZero()||(p=m==="base"?mr(i.mul(u),c):mr(i.mul(c),u)),this.logDebug("amountRaw:",p.toString(),"lpAmount:",l.toString());let d=mr(i.mul(l),m==="base"?c:u);this.logDebug("liquidity:",d.toString());let f=new ze(new Ge(1)).add(o),y=new ze(new Ge(1)).sub(o),b=f.mul(p).quotient,g=y.mul(p).quotient,P=new he(a,p),h=new he(a,b),I=new he(a,g);return this.logDebug("anotherAmount:",P.toFixed(),"maxAnotherAmount:",h.toFixed()),{anotherAmount:P,maxAnotherAmount:h,minAnotherAmount:I,liquidity:d}}async getAmmPoolKeys(t){return(await this.scope.api.fetchPoolKeysById({idList:[t]}))[0]}async addLiquidity(t){let{poolInfo:n,poolKeys:o,amountInA:r,amountInB:i,otherAmountMin:a,fixedSide:c,config:u,txVersion:l,computeBudgetConfig:m,txTipConfig:p,feePayer:d}=t;this.scope.availability.addStandardPosition===!1&&this.logAndCreateError("add liquidity feature disabled in your region"),this.logDebug("amountInA:",r,"amountInB:",i),(r.isZero()||i.isZero())&&this.logAndCreateError("amounts must greater than zero","amountInA & amountInB",{amountInA:r.toFixed(),amountInB:i.toFixed()});let{account:f}=this.scope,{bypassAssociatedCheck:y,checkCreateATAOwner:b}=N({bypassAssociatedCheck:!1,checkCreateATAOwner:!1},u),[g,P]=[r.token,i.token],h=await f.getCreatedTokenAccount({mint:g.mint,associatedOnly:!1}),I=await f.getCreatedTokenAccount({mint:P.mint,associatedOnly:!1});!h&&!I&&this.logAndCreateError("cannot found target token accounts","tokenAccounts",f.tokenAccounts);let T=await f.getCreatedTokenAccount({mint:new et(n.lpMint.address)}),w=[g,P],x=[h,I],S=[r.raw,i.raw],K=r.token.mint.toBase58()===n.mintA.address?"base":"quote",B="base";["quote","base"].includes(K)||this.logAndCreateError("invalid fixedSide","fixedSide",c),K==="quote"?(w.reverse(),x.reverse(),S.reverse(),B=c==="a"?"quote":"base"):K==="base"&&(B=c==="a"?"base":"quote");let[C,M]=w,[V,R]=x,[L,W]=S,z=o!=null?o:await this.getAmmPoolKeys(n.id),$=this.createTxBuilder(d),ee=await f.handleTokenAccount({side:"in",amount:L,mint:C.mint,tokenAccount:V,bypassAssociatedCheck:y,checkCreateATAOwner:b}),{tokenAccount:ae}=ee,be=qe(ee,["tokenAccount"]);$.addInstruction(be);let Ce=await f.handleTokenAccount({side:"in",amount:W,mint:M.mint,tokenAccount:R,bypassAssociatedCheck:y,checkCreateATAOwner:b}),{tokenAccount:le}=Ce,pe=qe(Ce,["tokenAccount"]);$.addInstruction(pe);let Ie=await f.handleTokenAccount({side:"out",amount:0,mint:new et(n.lpMint.address),tokenAccount:T,bypassAssociatedCheck:y,checkCreateATAOwner:b}),{tokenAccount:ye}=Ie,me=qe(Ie,["tokenAccount"]);return $.addInstruction(me),$.addInstruction({instructions:[Al({poolInfo:n,poolKeys:z,userKeys:{baseTokenAccount:ae,quoteTokenAccount:le,lpTokenAccount:ye,owner:this.scope.ownerPubKey},baseAmountIn:L,quoteAmountIn:W,otherAmountMin:a.raw,fixedSide:B})],instructionTypes:[n.pooltype.includes("StablePool")?U.AmmV5AddLiquidity:U.AmmV4AddLiquidity],lookupTableAddress:z.lookupTableAccount?[z.lookupTableAccount]:[]}),$.addCustomComputeBudget(m),$.addTipInstruction(p),l===0?await $.buildV0():$.build()}async removeLiquidity(t){this.scope.availability.removeStandardPosition===!1&&this.logAndCreateError("remove liquidity feature disabled in your region");let{poolInfo:n,poolKeys:o,lpAmount:r,baseAmountMin:i,quoteAmountMin:a,config:c,txVersion:u,computeBudgetConfig:l,txTipConfig:m,feePayer:p}=t,d=o!=null?o:await this.getAmmPoolKeys(n.id),[f,y,b]=[new et(n.mintA.address),new et(n.mintB.address),new et(n.lpMint.address)];this.logDebug("lpAmount:",r),this.logDebug("baseAmountMin:",i),this.logDebug("quoteAmountMin:",a),r.isZero()&&this.logAndCreateError("amount must greater than zero","lpAmount",r.toString());let{account:g}=this.scope,P=await g.getCreatedTokenAccount({mint:b,associatedOnly:!1});P||this.logAndCreateError("cannot found lpTokenAccount","tokenAccounts",g.tokenAccounts);let h=await g.getCreatedTokenAccount({mint:f}),I=await g.getCreatedTokenAccount({mint:y}),T=this.createTxBuilder(p),{bypassAssociatedCheck:w,checkCreateATAOwner:x}=N({bypassAssociatedCheck:!1,checkCreateATAOwner:!1},c),M=await g.handleTokenAccount({side:"out",amount:0,mint:f,tokenAccount:h,bypassAssociatedCheck:w,checkCreateATAOwner:x}),{tokenAccount:S}=M,K=qe(M,["tokenAccount"]);T.addInstruction(K);let V=await g.handleTokenAccount({side:"out",amount:0,mint:y,tokenAccount:I,bypassAssociatedCheck:w,checkCreateATAOwner:x}),{tokenAccount:B}=V,C=qe(V,["tokenAccount"]);return T.addInstruction(C),T.addInstruction({instructions:[zs({poolInfo:n,poolKeys:d,userKeys:{lpTokenAccount:P,baseTokenAccount:S,quoteTokenAccount:B,owner:this.scope.ownerPubKey},lpAmount:r,baseAmountMin:i,quoteAmountMin:a})],lookupTableAddress:d.lookupTableAccount?[d.lookupTableAccount]:[],instructionTypes:[n.pooltype.includes("StablePool")?U.AmmV5RemoveLiquidity:U.AmmV4RemoveLiquidity]}),T.addCustomComputeBudget(l),T.addTipInstruction(m),u===0?await T.buildV0():T.build()}async removeAllLpAndCreateClmmPosition({poolInfo:t,clmmPoolInfo:n,removeLpAmount:o,createPositionInfo:r,farmInfo:i,userFarmLpAmount:a,base:c,computeBudgetConfig:u,payer:l,userAuxiliaryLedgers:m,tokenProgram:p=En,checkCreateATAOwner:d=!0,getEphemeralSigners:f,txVersion:y,feePayer:b}){if((this.scope.availability.removeStandardPosition===!1||this.scope.availability.createConcentratedPosition===!1)&&this.logAndCreateError("remove liquidity or create position feature disabled in your region"),!(t.mintA.address===n.mintA.address||t.mintA.address===n.mintB.address)||!(t.mintB.address===n.mintA.address||t.mintB.address===n.mintB.address))throw Error("mint check error");let g=this.createTxBuilder(b),P={};for(let z of this.scope.account.tokenAccountRawInfos)(P[z.accountInfo.mint.toString()]===void 0||j(this.scope.ownerPubKey,z.accountInfo.mint,En).publicKey.equals(z.pubkey))&&(P[z.accountInfo.mint.toString()]=z.pubkey);let h=P[t.lpMint.address];if(h===void 0)throw Error("find lp account error in trade accounts");let I=o.add(a!=null?a:new Ge(0)),T=t.mintA.address===Se.WSOL.mint.toString(),w=t.mintB.address===Se.WSOL.mint.toString(),{account:x,instructionParams:S}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:En,mint:new et(t.mintA.address),owner:this.scope.ownerPubKey,createInfo:T?{payer:this.scope.ownerPubKey}:void 0,skipCloseAccount:!T,notUseTokenAccount:T,associatedOnly:!0,checkCreateATAOwner:d});if(g.addInstruction(S||{}),x===void 0)throw new Error("base token account not found");let{account:K,instructionParams:B}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:En,mint:new et(t.mintB.address),owner:this.scope.ownerPubKey,createInfo:w?{payer:this.scope.ownerPubKey,amount:0}:void 0,skipCloseAccount:!w,notUseTokenAccount:w,associatedOnly:!0,checkCreateATAOwner:d});if(g.addInstruction(B||{}),K===void 0)throw new Error("quote token account not found");if(P[t.mintA.address]=x,P[t.mintB.address]=K,i!==void 0&&!(a!=null&&a.isZero())){let z=qt[i.programId],$=bt({programId:new et(i.programId),poolId:new et(i.id),owner:this.scope.ownerPubKey,version:z}),ae,be=await this.scope.connection.getAccountInfo($);if(be&&(ae=Ro(z).decode(be.data)),z!==6&&!ae){let{instruction:Ie,instructionType:kt}=Ai({id:new et(i.id),programId:new et(i.programId),version:z,ledger:$,owner:this.scope.ownerPubKey});g.addInstruction({instructions:[Ie],instructionTypes:[kt]})}let le=[];for(let Ie of i.rewardInfos){let kt=Ie.mint.address===Se.WSOL.mint.toString();if(P[Ie.mint.address])le.push(P[Ie.mint.address]);else{let{account:dt,instructionParams:yn}=await this.scope.account.getOrCreateTokenAccount({mint:new et(Ie.mint.address),tokenProgram:p,owner:this.scope.ownerPubKey,skipCloseAccount:!kt,createInfo:{payer:l||this.scope.ownerPubKey},associatedOnly:!0,checkCreateATAOwner:d});dt||this.logAndCreateError("farm reward account not found:",Ie.mint.address),yn&&g.addInstruction(yn),le.push(dt)}}let pe=(await this.scope.api.fetchFarmKeysById({ids:i.id}))[0],ye={userAuxiliaryLedgers:m,amount:a,owner:this.scope.ownerPubKey,farmInfo:i,farmKeys:pe,lpAccount:h,rewardAccounts:le},me=qt[i.programId],ee=me===6?Pi(ye):me===5?ki(ye):wi(ye),Ce={3:U.FarmV3Withdraw,5:U.FarmV5Withdraw,6:U.FarmV6Withdraw};g.addInstruction({instructions:[ee],instructionTypes:[Ce[me]]})}let C=await this.getAmmPoolKeys(t.id),M=zs({poolInfo:t,poolKeys:C,userKeys:{lpTokenAccount:h,baseTokenAccount:x,quoteTokenAccount:K,owner:this.scope.ownerPubKey},lpAmount:I,baseAmountMin:0,quoteAmountMin:0});g.addInstruction({instructions:[M],instructionTypes:[t.pooltype.includes("StablePool")?U.AmmV5RemoveLiquidity:U.AmmV4RemoveLiquidity],lookupTableAddress:C.lookupTableAccount?[C.lookupTableAccount]:[]});let[V,R]=t.mintA.address===n.mintA.address?[x,K]:[K,x],L=await this.scope.clmm.getClmmPoolKeys(n.id),W=await Le.openPositionFromBaseInstructions(q(N({poolInfo:n,poolKeys:L,ownerInfo:{feePayer:this.scope.ownerPubKey,wallet:this.scope.ownerPubKey,tokenAccountA:V,tokenAccountB:R},withMetadata:"create"},r),{base:c,getEphemeralSigners:f}));return g.addInstruction({instructions:[...W.instructions],signers:W.signers,instructionTypes:[...W.instructionTypes],lookupTableAddress:L.lookupTableAccount?[L.lookupTableAccount]:[]}),y===0?g.sizeCheckBuildV0({computeBudgetConfig:u}):g.sizeCheckBuild({computeBudgetConfig:u})}async createPoolV4({programId:t,marketInfo:n,baseMintInfo:o,quoteMintInfo:r,baseAmount:i,quoteAmount:a,startTime:c,ownerInfo:u,associatedOnly:l=!1,checkCreateATAOwner:m=!1,tokenProgram:p,txVersion:d,feeDestinationId:f,computeBudgetConfig:y,txTipConfig:b,feePayer:g}){var R;let P=u.feePayer||((R=this.scope.owner)==null?void 0:R.publicKey),h=u.useSOLBalance&&o.mint.equals(Qr),I=u.useSOLBalance&&r.mint.equals(Qr),T=this.createTxBuilder(g),{account:w,instructionParams:x}=await this.scope.account.getOrCreateTokenAccount({mint:o.mint,owner:this.scope.ownerPubKey,createInfo:h?{payer:P,amount:i}:void 0,notUseTokenAccount:h,skipCloseAccount:!h,associatedOnly:h?!1:l,checkCreateATAOwner:m});T.addInstruction(x||{});let{account:S,instructionParams:K}=await this.scope.account.getOrCreateTokenAccount({mint:r.mint,owner:this.scope.ownerPubKey,createInfo:I?{payer:P,amount:a}:void 0,notUseTokenAccount:I,skipCloseAccount:!I,associatedOnly:I?!1:l,checkCreateATAOwner:m});if(T.addInstruction(K||{}),w===void 0||S===void 0)throw Error("you don't has some token account");let B=$s({version:4,marketVersion:3,marketId:n.marketId,baseMint:o.mint,quoteMint:r.mint,baseDecimals:o.decimals,quoteDecimals:r.decimals,programId:t,marketProgramId:n.programId}),C={programId:t,ammId:B.id,ammAuthority:B.authority,ammOpenOrders:B.openOrders,lpMint:B.lpMint,coinMint:B.baseMint,pcMint:B.quoteMint,coinVault:B.baseVault,pcVault:B.quoteVault,withdrawQueue:B.withdrawQueue,ammTargetOrders:B.targetOrders,poolTempLp:B.lpVault,marketProgramId:B.marketProgramId,marketId:B.marketId,ammConfigId:B.configId,feeDestinationId:f},{instruction:M,instructionType:V}=Qs(q(N({},C),{userWallet:this.scope.ownerPubKey,userCoinVault:w,userPcVault:S,userLpVault:j(this.scope.ownerPubKey,B.lpMint,p).publicKey,nonce:B.nonce,openTime:c,coinAmount:i,pcAmount:a}));return T.addInstruction({instructions:[M],instructionTypes:[V]}),T.addCustomComputeBudget(y),T.addTipInstruction(b),T.versionBuild({txVersion:d,extInfo:{address:C}})}async createMarketAndPoolV4({programId:t=ti,marketProgram:n=Ea,feeDestinationId:o=Da,tokenProgram:r,baseMintInfo:i,quoteMintInfo:a,baseAmount:c,quoteAmount:u,startTime:l,ownerInfo:m,lowestFeeMarket:p,assignSeed:d,associatedOnly:f=!1,checkCreateATAOwner:y=!1,lotSize:b=1,tickSize:g=.01,txVersion:P,computeBudgetConfig:h,txTipConfig:I,feePayer:T}){var zo,Qo,Yo;let w=this.scope.ownerPubKey,x=m.feePayer||((zo=this.scope.owner)==null?void 0:zo.publicKey),S=m.useSOLBalance&&i.mint.equals(Qr),K=m.useSOLBalance&&a.mint.equals(Qr),B=d?`${i.mint.toBase58().slice(0,7)}-${a.mint.toBase58().slice(0,7)}-${d}`:void 0,C=Ye({fromPublicKey:w,programId:n,assignSeed:B&&`${B}-market`}),M=Ye({fromPublicKey:w,programId:n,assignSeed:B&&`${B}-request`}),V=Ye({fromPublicKey:w,programId:n,assignSeed:B&&`${B}-event`}),R=Ye({fromPublicKey:w,programId:n,assignSeed:B&&`${B}-bids`}),L=Ye({fromPublicKey:w,programId:n,assignSeed:B&&`${B}-asks`}),W=Ye({fromPublicKey:w,programId:En,assignSeed:B&&`${B}-baseVault`}),z=Ye({fromPublicKey:w,programId:En,assignSeed:B&&`${B}-quoteVault`}),$=0,ae=new Ge(100);function be(){let Nt=new Ge(0);for(;;)try{return{vaultOwner:et.createProgramAddressSync([C.publicKey.toBuffer(),Nt.toArrayLike(Buffer,"le",8)],n),vaultSignerNonce:Nt}}catch{if(Nt.iaddn(1),Nt.gt(new Ge(25555)))throw Error("find vault owner error")}}let{vaultOwner:le,vaultSignerNonce:pe}=be(),ye=new Ge(Math.round(10**i.decimals*b)),me=new Ge(Math.round(b*10**a.decimals*g));if(ye.eq(Je))throw Error("lot size is too small");if(me.eq(Je))throw Error("tick size or lot size is too small");let ee=await zr({connection:this.scope.connection,wallet:this.scope.ownerPubKey,marketInfo:{programId:n,vaultOwner:le,baseMint:i.mint,quoteMint:a.mint,id:C,baseVault:W,quoteVault:z,requestQueue:M,eventQueue:V,bids:R,asks:L,feeRateBps:$,quoteDustThreshold:ae,vaultSignerNonce:pe,baseLotSize:ye,quoteLotSize:me,lowestFeeMarket:p}}),Ce=this.createTxBuilder(T);Ce.addInstruction({instructions:ee[0].transaction.instructions,signers:ee[0].signer});for await(let Nt of ee.slice(1,ee.length))Ce.addInstruction({instructions:Nt.transaction.instructions,signers:Nt.signer,instructionTypes:Nt.instructionTypes});let{account:Ie,instructionParams:kt}=await this.scope.account.getOrCreateTokenAccount({mint:i.mint,owner:this.scope.ownerPubKey,createInfo:S?{payer:x,amount:c}:void 0,notUseTokenAccount:S,skipCloseAccount:!S,associatedOnly:S?!1:f,checkCreateATAOwner:y,assignSeed:S&&B?`${B}-wsol`:void 0});Ce.addInstruction(kt||{});let{account:dt,instructionParams:yn}=await this.scope.account.getOrCreateTokenAccount({mint:a.mint,owner:this.scope.ownerPubKey,createInfo:K?{payer:x,amount:u}:void 0,notUseTokenAccount:K,skipCloseAccount:!K,associatedOnly:K?!1:f,checkCreateATAOwner:y,assignSeed:K&&B?`${B}-wsol`:void 0});if(Ce.addInstruction(yn||{}),Ie===void 0)throw Error("you don't has base token account");if(dt===void 0)throw Error("you don't has quote token account");let rt=$s({version:4,marketVersion:3,marketId:C.publicKey,baseMint:i.mint,quoteMint:a.mint,baseDecimals:i.decimals,quoteDecimals:a.decimals,programId:t,marketProgramId:n}),zn={programId:t,ammId:rt.id,ammAuthority:rt.authority,ammOpenOrders:rt.openOrders,lpMint:rt.lpMint,coinMint:rt.baseMint,pcMint:rt.quoteMint,coinVault:rt.baseVault,pcVault:rt.quoteVault,withdrawQueue:rt.withdrawQueue,ammTargetOrders:rt.targetOrders,poolTempLp:rt.lpVault,marketProgramId:rt.marketProgramId,marketId:rt.marketId,ammConfigId:rt.configId,feeDestinationId:o},{instruction:St,instructionType:Xo}=Qs(q(N({},zn),{userWallet:this.scope.ownerPubKey,userCoinVault:Ie,userPcVault:dt,userLpVault:j(this.scope.ownerPubKey,rt.lpMint,r).publicKey,nonce:rt.nonce,openTime:l,coinAmount:c,pcAmount:u}));Ce.addInstruction({instructions:[St],instructionTypes:[Xo]});let Ao=S||K?[((Qo=kt==null?void 0:kt.instructions)==null?void 0:Qo[0])||((Yo=yn==null?void 0:yn.instructions)==null?void 0:Yo[0])].filter(Nt=>!!Nt):void 0;return P===0?Ce.sizeCheckBuildV0({computeBudgetConfig:h,splitIns:Ao,address:N({requestQueue:M.publicKey,eventQueue:V.publicKey,bids:R.publicKey,asks:L.publicKey,baseVault:W.publicKey,quoteVault:z.publicKey,baseMint:new et(i.mint),quoteMint:new et(a.mint)},zn)}):Ce.sizeCheckBuild({computeBudgetConfig:h,splitIns:Ao,address:N({requestQueue:M.publicKey,eventQueue:V.publicKey,bids:R.publicKey,asks:L.publicKey,baseVault:W.publicKey,quoteVault:z.publicKey,baseMint:new et(i.mint),quoteMint:new et(a.mint)},zn)})}async getCreatePoolFee({programId:t}){let n=Gr({programId:t}),o=await this.scope.connection.getAccountInfo(n,{dataSlice:{offset:536,length:8}});if(o===null)throw Error("get config account error");return yl.decode(o.data).fee}computeAmountOut({poolInfo:t,amountIn:n,mintIn:o,mintOut:r,slippage:i}){let[a,c]=[o.toString(),r.toString()];if(a!==t.mintA.address&&a!==t.mintB.address)throw new Error("toke not match");if(c!==t.mintA.address&&c!==t.mintB.address)throw new Error("toke not match");let{baseReserve:u,quoteReserve:l}=t,m=[u,l],p=[t.mintA.decimals,t.mintB.decimals],d=a==t.mintA.address?"base":"quote";d==="quote"&&(m.reverse(),p.reverse());let[f,y]=m,[b,g]=p,P=t.version===4,h;if(P)h=new Ne(y.toString()).div(10**g).div(new Ne(f.toString()).div(10**b));else{let V=Il(this.stableLayout.stableModelData,u.toNumber(),l.toNumber(),!1);d==="quote"?h=new Ne(1e6).div(V*1e6):h=new Ne(V*1e6).div(1e6)}let I=n,T=new Ge(0),w=new Ge(0);if(!I.isZero())if(P){w=Kt(I.mul(Ds),Wr);let V=I.sub(w),R=f.add(V);T=y.mul(V).div(R)}else{w=I.mul(new Ge(2)).div(new Ge(1e4));let V=I.sub(w);d==="quote"?T=new Ge(Tl(this.stableLayout.stableModelData,l.toNumber(),u.toNumber(),V.toNumber())):T=new Ge(hl(this.stableLayout.stableModelData,l.toNumber(),u.toNumber(),V.toNumber()))}let x=new Ge(new Ne(T.toString()).mul(1-i).toFixed(0)),S=T,K=x,B=new Ne(T.toString()).div(new Ne(I.sub(w).toString()).toFixed(0));!I.isZero()&&!T.isZero()&&(B=new Ne(T.toString()).div(10**g).div(new Ne(I.sub(w).toString()).div(10**b)));let C=h.sub(B).div(h).mul(100);return{amountOut:S,minAmountOut:K,currentPrice:h,executionPrice:B,priceImpact:C,fee:w}}computeAmountIn({poolInfo:t,amountOut:n,mintIn:o,mintOut:r,slippage:i}){let{baseReserve:a,quoteReserve:c}=t;o.toString()!==t.mintA.address&&o.toString()!==t.mintB.address&&this.logAndCreateError("mintIn does not match pool"),r.toString()!==t.mintA.address&&r.toString()!==t.mintB.address&&this.logAndCreateError("mintOut does not match pool"),this.logDebug("baseReserve:",a.toString()),this.logDebug("quoteReserve:",c.toString());let u=o.toString()===t.mintA.address,[l,m]=u?[t.mintA,t.mintB]:[t.mintB,t.mintA];this.logDebug("currencyOut:",m.symbol||m.address),this.logDebug("amountOut:",new Ne(n.toString()).div(10**m.decimals).toDecimalPlaces(m.decimals).toString(),l.symbol||l.address),this.logDebug("slippage:",`${i*100}%`);let p=[a,c],d=u?"quote":"base";d==="base"&&p.reverse(),this.logDebug("output side:",d);let[f,y]=p,b=new Ne(y.toString()).div(10**t[u?"mintB":"mintA"].decimals).div(new Ne(f.toString()).div(10**t[u?"mintA":"mintB"].decimals));this.logDebug("currentPrice:",`1 ${l.symbol||l.address} \u2248 ${b.toString()} ${m.symbol||m.address}`),this.logDebug("currentPrice invert:",`1 ${m.symbol||m.address} \u2248 ${new Ne(1).div(b).toString()} ${l.symbol||l.address}`);let g=new Ge(0),P=n;if(!P.isZero()){P.gt(y)&&(P=y.sub(new Ge(1)));let K=y.sub(P);g=f.mul(P).div(K).mul(Wr).div(Wr.sub(Ds))}let h=new Ge(new Ne(g.toString()).mul(1+i).toFixed(0)),I=g,T=h;this.logDebug("amountIn:",new Ne(I.toString()).div(10**l.decimals).toDecimalPlaces(l.decimals).toString()),this.logDebug("maxAmountIn:",new Ne(T.toString()).div(10**l.decimals).toDecimalPlaces(l.decimals).toString());let w=null;!g.isZero()&&!P.isZero()&&(w=new Ne(P.toString()).div(10**m.decimals).div(new Ne(g.toString()).div(10**l.decimals)),this.logDebug("executionPrice:",`1 ${m.symbol||m.address} \u2248 ${w.toDecimalPlaces(Math.max(t.mintA.decimals,t.mintB.decimals)).toString()} ${l.symbol||l.address}`),this.logDebug("executionPrice invert:",`1 ${m.symbol||m.address} \u2248 ${new Ne(1).div(w).toDecimalPlaces(Math.max(t.mintA.decimals,t.mintB.decimals)).toString()} ${l.symbol||l.address}`));let x=b.mul(I.toString()),S=x.sub(n.toString()).abs().div(x);return this.logDebug("priceImpact:",`${S.toString()}%`),{amountIn:I,maxAmountIn:T,currentPrice:b,executionPrice:w,priceImpact:S}}async swap({poolInfo:t,poolKeys:n,amountIn:o,amountOut:r,inputMint:i,fixedSide:a,txVersion:c,config:u,computeBudgetConfig:l,txTipConfig:m,feePayer:p}){let d=this.createTxBuilder(p),{associatedOnly:f=!0,inputUseSolBalance:y=!0,outputUseSolBalance:b=!0}=u||{},[g,P]=i===t.mintA.address?[t.mintA,t.mintB]:[t.mintB,t.mintA],h=y&&g.address===H.toBase58(),I=b&&P.address===H.toBase58(),{account:T,instructionParams:w}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:En,mint:new et(g.address),owner:this.scope.ownerPubKey,createInfo:h?{payer:this.scope.ownerPubKey,amount:o}:void 0,skipCloseAccount:!h,notUseTokenAccount:h,associatedOnly:f});d.addInstruction(w||{}),T||this.logAndCreateError("input token account not found",{token:g.symbol||g.address,tokenAccountIn:T,inputTokenUseSolBalance:h,associatedOnly:f});let{account:x,instructionParams:S}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:En,mint:new et(P.address),owner:this.scope.ownerPubKey,createInfo:{payer:this.scope.ownerPubKey,amount:0},skipCloseAccount:!I,notUseTokenAccount:I,associatedOnly:I?!1:f});d.addInstruction(S||{}),x===void 0&&this.logAndCreateError("output token account not found",{token:P.symbol||P.address,tokenAccountOut:x,outputTokenUseSolBalance:I,associatedOnly:f});let K=n||await this.getAmmPoolKeys(t.id),B=4;return t.pooltype.includes("StablePool")&&(B=5),d.addInstruction({instructions:[qr({version:B,poolKeys:K,userKeys:{tokenAccountIn:T,tokenAccountOut:x,owner:this.scope.ownerPubKey},amountIn:o,amountOut:r,fixedSide:a})],instructionTypes:[B===4?U.AmmV4SwapBaseIn:U.AmmV5SwapBaseIn]}),d.addCustomComputeBudget(l),d.addTipInstruction(m),d.versionBuild({txVersion:c})}async getRpcPoolInfo(t){return(await this.getRpcPoolInfos([t]))[t]}async getRpcPoolInfos(t,n){let o=await Me(this.scope.connection,t.map(l=>({pubkey:new et(l)})),n),r={},i=[];for(let l=0;l<t.length;l++){let m=o[l];if(m===null||!m.accountInfo)throw Error("fetch pool info error: "+String(t[l]));let p=io.decode(m.accountInfo.data);r[String(t[l])]=q(N({},p),{programId:m.accountInfo.owner}),i.push(p.baseVault,p.quoteVault)}let a={},c=await Me(this.scope.connection,i.map(l=>({pubkey:new et(l)})),n);for(let l=0;l<i.length;l++){let m=c[l].accountInfo;if(m===null)throw Error("fetch vault info error: "+i[l]);a[String(i[l])]=new Ge(Mf.decode(m.data).amount.toString())}let u={};for(let[l,m]of Object.entries(r)){let p=a[m.baseVault.toString()].sub(m.baseNeedTakePnl),d=a[m.quoteVault.toString()].sub(m.quoteNeedTakePnl);u[l]=q(N({},m),{baseReserve:p,mintAAmount:a[m.baseVault.toString()],mintBAmount:a[m.quoteVault.toString()],quoteReserve:d,poolPrice:new Ne(d.toString()).div(new Ne(10).pow(m.quoteDecimal.toString())).div(new Ne(p.toString()).div(new Ne(10).pow(m.baseDecimal.toString())))})}return u}async getPoolInfoFromRpc({poolId:t}){let n=await this.getRpcPoolInfo(t),o=Xr({[t]:n}),r=o[t],i=await this.scope.tradeV2.computePoolToPoolKeys({pools:[o[t]],ammRpcData:{[t]:n}});return{poolRpcData:n,poolInfo:r,poolKeys:i[0]}}};import{PublicKey as Y}from"@solana/web3.js";import xt from"bn.js";import co from"decimal.js";import{AccountLayout as Rl,createAssociatedTokenAccountIdempotentInstruction as Ll,TOKEN_2022_PROGRAM_ID as Dn,TOKEN_PROGRAM_ID as Vi}from"@solana/spl-token";var _i=class extends Ve{constructor(e){super(e)}async getClmmPoolKeys(e){return(await this.scope.api.fetchPoolKeysById({idList:[e]}))[0]}async createPool(e){var x;let{programId:t,owner:n=((x=this.scope.owner)==null?void 0:x.publicKey)||Y.default,mint1:o,mint2:r,ammConfig:i,initialPrice:a,computeBudgetConfig:c,forerunCreate:u,getObserveState:l,txVersion:m,txTipConfig:p,feePayer:d}=e,f=this.createTxBuilder(d),[y,b,g]=new xt(new Y(o.address).toBuffer()).gt(new xt(new Y(r.address).toBuffer()))?[r,o,new co(1).div(a)]:[o,r,a],P=ie.priceToSqrtPriceX64(g,y.decimals,b.decimals),h=[],I=[];y.programId===Dn.toBase58()&&I.push(Ms(t,new Y(y.address)).publicKey),b.programId===Dn.toBase58()&&I.push(Ms(t,new Y(b.address)).publicKey),(await this.scope.connection.getMultipleAccountsInfo(I)).forEach((S,K)=>{S&&h.push(I[K])});let w=await Le.createPoolInstructions({connection:this.scope.connection,programId:t,owner:n,mintA:y,mintB:b,ammConfigId:i.id,initialPriceX64:P,forerunCreate:!l&&u,extendMintAccount:h});return f.addInstruction(w),f.addCustomComputeBudget(c),f.addTipInstruction(p),f.versionBuild({txVersion:m,extInfo:{address:q(N({},w.address),{observationId:w.address.observationId.toBase58(),exBitmapAccount:w.address.exBitmapAccount.toBase58(),programId:t.toString(),id:w.address.poolId.toString(),mintA:y,mintB:b,openTime:"0",vault:{A:w.address.mintAVault.toString(),B:w.address.mintBVault.toString()},rewardInfos:[],config:{id:i.id.toString(),index:i.index,protocolFeeRate:i.protocolFeeRate,tradeFeeRate:i.tradeFeeRate,tickSpacing:i.tickSpacing,fundFeeRate:i.fundFeeRate,description:i.description,defaultRange:0,defaultRangePoint:[]}}),mockPoolInfo:N({type:"Concentrated",rewardDefaultPoolInfos:"Clmm",id:w.address.poolId.toString(),mintA:y,mintB:b,feeRate:i.tradeFeeRate,openTime:"0",programId:t.toString(),price:g.toNumber(),config:{id:i.id.toString(),index:i.index,protocolFeeRate:i.protocolFeeRate,tradeFeeRate:i.tradeFeeRate,tickSpacing:i.tickSpacing,fundFeeRate:i.fundFeeRate,description:i.description,defaultRange:0,defaultRangePoint:[]},burnPercent:0},Yc),forerunCreate:u}})}async openPositionFromBase({poolInfo:e,poolKeys:t,ownerInfo:n,tickLower:o,tickUpper:r,base:i,baseAmount:a,otherAmountMax:c,nft2022:u,associatedOnly:l=!0,checkCreateATAOwner:m=!1,withMetadata:p="create",getEphemeralSigners:d,computeBudgetConfig:f,txTipConfig:y,txVersion:b,feePayer:g}){this.scope.availability.addConcentratedPosition===!1&&this.logAndCreateError("add position feature disabled in your region"),this.scope.checkOwner();let P=this.createTxBuilder(g),h=null,I=null,T=n.useSOLBalance&&e.mintA.address===H.toString(),w=n.useSOLBalance&&e.mintB.address===H.toString(),[x,S]=i==="MintA"?[a,c]:[c,a],{account:K,instructionParams:B}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:e.mintA.programId,mint:new Y(e.mintA.address),owner:this.scope.ownerPubKey,createInfo:T||x.isZero()?{payer:this.scope.ownerPubKey,amount:x}:void 0,skipCloseAccount:!T,notUseTokenAccount:T,associatedOnly:T?!1:l,checkCreateATAOwner:m});K&&(h=K),P.addInstruction(B||{});let{account:C,instructionParams:M}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:e.mintB.programId,mint:new Y(e.mintB.address),owner:this.scope.ownerPubKey,createInfo:w||S.isZero()?{payer:this.scope.ownerPubKey,amount:S}:void 0,skipCloseAccount:!w,notUseTokenAccount:w,associatedOnly:w?!1:l,checkCreateATAOwner:m});C&&(I=C),P.addInstruction(M||{}),(!h||!I)&&this.logAndCreateError("cannot found target token accounts","tokenAccounts",{ownerTokenAccountA:h==null?void 0:h.toBase58(),ownerTokenAccountB:I==null?void 0:I.toBase58()});let V=t||await this.getClmmPoolKeys(e.id),R=await Le.openPositionFromBaseInstructions({poolInfo:e,poolKeys:V,ownerInfo:q(N({},n),{feePayer:this.scope.ownerPubKey,wallet:this.scope.ownerPubKey,tokenAccountA:h,tokenAccountB:I}),tickLower:o,tickUpper:r,base:i,baseAmount:a,otherAmountMax:c,withMetadata:p,getEphemeralSigners:d,nft2022:u});return P.addInstruction(R),P.addCustomComputeBudget(f),P.addTipInstruction(y),P.versionBuild({txVersion:b,extInfo:N({},R.address)})}async openPositionFromLiquidity({poolInfo:e,poolKeys:t,ownerInfo:n,amountMaxA:o,amountMaxB:r,tickLower:i,tickUpper:a,liquidity:c,associatedOnly:u=!0,checkCreateATAOwner:l=!1,withMetadata:m="create",txVersion:p,computeBudgetConfig:d,txTipConfig:f,getEphemeralSigners:y,nft2022:b,feePayer:g}){this.scope.availability.createConcentratedPosition===!1&&this.logAndCreateError("open position feature disabled in your region");let P=this.createTxBuilder(g),h=null,I=null,T=n.useSOLBalance&&e.mintA.address===H.toBase58(),w=n.useSOLBalance&&e.mintB.address===H.toBase58(),{account:x,instructionParams:S}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:e.mintA.programId,mint:new Y(e.mintA.address),owner:this.scope.ownerPubKey,createInfo:T||o.isZero()?{payer:this.scope.ownerPubKey,amount:o}:void 0,skipCloseAccount:!T,notUseTokenAccount:T,associatedOnly:T?!1:u,checkCreateATAOwner:l});x&&(h=x),P.addInstruction(S||{});let{account:K,instructionParams:B}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:e.mintB.programId,mint:new Y(e.mintB.address),owner:this.scope.ownerPubKey,createInfo:w||r.isZero()?{payer:this.scope.ownerPubKey,amount:r}:void 0,skipCloseAccount:!w,notUseTokenAccount:w,associatedOnly:w?!1:u,checkCreateATAOwner:l});K&&(I=K),P.addInstruction(B||{}),(h===void 0||I===void 0)&&this.logAndCreateError("cannot found target token accounts","tokenAccounts",this.scope.account.tokenAccounts);let C=t||await this.getClmmPoolKeys(e.id),M=await Le.openPositionFromLiquidityInstructions({poolInfo:e,poolKeys:C,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccountA:h,tokenAccountB:I},tickLower:i,tickUpper:a,liquidity:c,amountMaxA:o,amountMaxB:r,withMetadata:m,getEphemeralSigners:y,nft2022:b});return P.addInstruction(M),P.addCustomComputeBudget(d),P.addTipInstruction(f),P.versionBuild({txVersion:p,extInfo:{address:M.address}})}async increasePositionFromLiquidity(e){var B;let{poolInfo:t,poolKeys:n,ownerPosition:o,amountMaxA:r,amountMaxB:i,liquidity:a,ownerInfo:c,associatedOnly:u=!0,checkCreateATAOwner:l=!1,computeBudgetConfig:m,txTipConfig:p,txVersion:d,feePayer:f}=e,y=this.createTxBuilder(f),b,g,P=c.useSOLBalance&&t.mintA.address===H.toString(),h=c.useSOLBalance&&t.mintB.address===H.toString(),{account:I,instructionParams:T}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:t.mintA.programId,mint:new Y(t.mintA.address),notUseTokenAccount:P,owner:this.scope.ownerPubKey,createInfo:P||r.isZero()?{payer:this.scope.ownerPubKey,amount:r}:void 0,skipCloseAccount:!P,associatedOnly:P?!1:u,checkCreateATAOwner:l});I&&(b=I),y.addInstruction(T||{});let{account:w,instructionParams:x}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:t.mintB.programId,mint:new Y(t.mintB.address),owner:this.scope.ownerPubKey,createInfo:h||i.isZero()?{payer:this.scope.ownerPubKey,amount:i}:void 0,notUseTokenAccount:h,skipCloseAccount:!h,associatedOnly:h?!1:u,checkCreateATAOwner:l});w&&(g=w),y.addInstruction(x||{}),!b&&!g&&this.logAndCreateError("cannot found target token accounts","tokenAccounts",this.scope.account.tokenAccounts);let S=n!=null?n:await this.getClmmPoolKeys(t.id),K=Le.increasePositionFromLiquidityInstructions({poolInfo:t,poolKeys:S,ownerPosition:o,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccountA:b,tokenAccountB:g},liquidity:a,amountMaxA:r,amountMaxB:i,nft2022:(B=await this.scope.connection.getAccountInfo(o.nftMint))==null?void 0:B.owner.equals(Dn)});return y.addInstruction(K),y.addCustomComputeBudget(m),y.addTipInstruction(p),y.versionBuild({txVersion:d,extInfo:{address:K.address}})}async increasePositionFromBase(e){var K;let{poolInfo:t,ownerPosition:n,base:o,baseAmount:r,otherAmountMax:i,ownerInfo:a,associatedOnly:c=!0,checkCreateATAOwner:u=!1,computeBudgetConfig:l,txTipConfig:m,txVersion:p,feePayer:d}=e,f=this.createTxBuilder(d),y,b,g=a.useSOLBalance&&t.mintA.address===H.toString(),P=a.useSOLBalance&&t.mintB.address===H.toString(),{account:h,instructionParams:I}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:t.mintA.programId,mint:new Y(t.mintA.address),notUseTokenAccount:g,owner:this.scope.ownerPubKey,createInfo:g||(o==="MintA"?r:i).isZero()?{payer:this.scope.ownerPubKey,amount:o==="MintA"?r:i}:void 0,skipCloseAccount:!g,associatedOnly:g?!1:c,checkCreateATAOwner:u});h&&(y=h),f.addInstruction(I||{});let{account:T,instructionParams:w}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:t.mintB.programId,mint:new Y(t.mintB.address),owner:this.scope.ownerPubKey,createInfo:P||(o==="MintA"?i:r).isZero()?{payer:this.scope.ownerPubKey,amount:o==="MintA"?i:r}:void 0,notUseTokenAccount:P,skipCloseAccount:!P,associatedOnly:P?!1:c,checkCreateATAOwner:u});T&&(b=T),f.addInstruction(w||{}),!y&&!b&&this.logAndCreateError("cannot found target token accounts","tokenAccounts",this.scope.account.tokenAccounts);let x=await this.getClmmPoolKeys(t.id),S=Le.increasePositionFromBaseInstructions({poolInfo:t,poolKeys:x,ownerPosition:n,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccountA:y,tokenAccountB:b},base:o,baseAmount:r,otherAmountMax:i,nft2022:(K=await this.scope.connection.getAccountInfo(n.nftMint))==null?void 0:K.owner.equals(Dn)});return f.addInstruction(S),f.addCustomComputeBudget(l),f.addTipInstruction(m),f.versionBuild({txVersion:p,extInfo:{address:S.address}})}async decreaseLiquidity(e){var V;let{poolInfo:t,poolKeys:n,ownerPosition:o,ownerInfo:r,amountMinA:i,amountMinB:a,liquidity:c,associatedOnly:u=!0,checkCreateATAOwner:l=!1,computeBudgetConfig:m,txTipConfig:p,txVersion:d,feePayer:f}=e;this.scope.availability.removeConcentratedPosition===!1&&this.logAndCreateError("remove position feature disabled in your region");let y=this.createTxBuilder(f),b=r.useSOLBalance&&t.mintA.address===H.toString(),g=r.useSOLBalance&&t.mintB.address===H.toString(),P,h,{account:I,instructionParams:T}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:t.mintA.programId,mint:new Y(t.mintA.address),notUseTokenAccount:b,owner:this.scope.ownerPubKey,createInfo:{payer:this.scope.ownerPubKey,amount:0},skipCloseAccount:!b,associatedOnly:b?!1:u,checkCreateATAOwner:l});P=I,T&&y.addInstruction(T);let{account:w,instructionParams:x}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:t.mintB.programId,mint:new Y(t.mintB.address),notUseTokenAccount:g,owner:this.scope.ownerPubKey,createInfo:{payer:this.scope.ownerPubKey,amount:0},skipCloseAccount:!g,associatedOnly:g?!1:u,checkCreateATAOwner:l});h=w,x&&y.addInstruction(x);let S=[];for(let R of t.rewardDefaultInfos){let L=r.useSOLBalance&&R.mint.address===H.toString(),W;if(R.mint.address===t.mintA.address)W=P;else if(R.mint.address===t.mintB.address)W=h;else{let{account:z,instructionParams:$}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:new Y(R.mint.programId),mint:new Y(R.mint.address),notUseTokenAccount:L,owner:this.scope.ownerPubKey,createInfo:{payer:this.scope.ownerPubKey,amount:0},skipCloseAccount:!L,associatedOnly:L?!1:u,checkCreateATAOwner:l});W=z,$&&y.addInstruction($)}S.push(W)}!P&&!h&&this.logAndCreateError("cannot found target token accounts","tokenAccounts",this.scope.account.tokenAccountRawInfos);let K=n!=null?n:await this.getClmmPoolKeys(t.id),B=(V=await this.scope.connection.getAccountInfo(o.nftMint))==null?void 0:V.owner.equals(Dn),C=await Le.decreaseLiquidityInstructions({poolInfo:t,poolKeys:K,ownerPosition:o,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccountA:P,tokenAccountB:h,rewardAccounts:S},liquidity:c,amountMinA:i,amountMinB:a,nft2022:B});y.addInstruction({instructions:C.instructions,instructionTypes:[U.ClmmDecreasePosition]});let M=N({},C.address);if(r.closePosition){let R=await Le.closePositionInstructions({poolInfo:t,poolKeys:K,ownerInfo:{wallet:this.scope.ownerPubKey},ownerPosition:o,nft2022:B});y.addInstruction({endInstructions:R.instructions,endInstructionTypes:R.instructionTypes}),M=N(N({},M),R.address)}return y.addCustomComputeBudget(m),y.addTipInstruction(p),y.versionBuild({txVersion:d,extInfo:{address:M}})}async lockPosition(e){var f;let{programId:t=To,authProgramId:n=ni,poolProgramId:o=Ln,ownerPosition:r,payer:i,computeBudgetConfig:a,txTipConfig:c,txVersion:u,getEphemeralSigners:l,feePayer:m}=e,p=this.createTxBuilder(m),d=await Le.makeLockPositions({programId:t,authProgramId:n,poolProgramId:o,wallet:this.scope.ownerPubKey,payer:i!=null?i:this.scope.ownerPubKey,nftMint:r.nftMint,getEphemeralSigners:l,nft2022:(f=await this.scope.connection.getAccountInfo(r.nftMint))==null?void 0:f.owner.equals(Dn)});return p.addInstruction(d),p.addCustomComputeBudget(a),p.addTipInstruction(c),p.versionBuild({txVersion:u,extInfo:d.address})}async harvestLockPosition(e){let{programId:t=To,authProgramId:n=ni,clmmProgram:o=Ln,poolKeys:r,lockData:i,ownerInfo:a={useSOLBalance:!0},associatedOnly:c=!0,checkCreateATAOwner:u=!1,computeBudgetConfig:l,txTipConfig:m,txVersion:p,feePayer:d}=e,f=r||await this.getClmmPoolKeys(i.poolId.toString()),y=this.createTxBuilder(d),b=await this.scope.connection.getAccountInfo(i.positionId);b||this.logger.logWithError("position not found",i.positionId);let g=No.decode(b.data),P=a.useSOLBalance&&f.mintA.address===H.toString(),h=a.useSOLBalance&&f.mintB.address===H.toString(),I,T,{account:w,instructionParams:x}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:f.mintA.programId,mint:new Y(f.mintA.address),notUseTokenAccount:P,owner:this.scope.ownerPubKey,createInfo:{payer:this.scope.ownerPubKey,amount:0},skipCloseAccount:!P,associatedOnly:P?!1:c,checkCreateATAOwner:u});I=w,x&&y.addInstruction(x);let{account:S,instructionParams:K}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:f.mintB.programId,mint:new Y(f.mintB.address),notUseTokenAccount:h,owner:this.scope.ownerPubKey,createInfo:{payer:this.scope.ownerPubKey,amount:0},skipCloseAccount:!h,associatedOnly:h?!1:c,checkCreateATAOwner:u});T=S,K&&y.addInstruction(K);let B={},C=[];for(let le of f.rewardInfos){let pe=a.useSOLBalance&&le.mint.address===H.toString(),ye=B[le.mint.address];if(!ye){let{account:me,instructionParams:ee}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:new Y(le.mint.programId),mint:new Y(le.mint.address),notUseTokenAccount:pe,owner:this.scope.ownerPubKey,skipCloseAccount:!pe,createInfo:{payer:this.scope.ownerPubKey,amount:0},associatedOnly:pe?!1:c});ye=me,ee&&y.addInstruction(ee)}B[le.mint.address]=ye,C.push(ye)}let M=Oo(t,i.lockNftMint).publicKey,V=j(this.scope.ownerPubKey,i.lockNftMint,Vi).publicKey,R=Z.getTickArrayStartIndexByTick(g.tickLower,f.config.tickSpacing),L=Z.getTickArrayStartIndexByTick(g.tickUpper,f.config.tickSpacing),{publicKey:W}=Ae(new Y(f.programId),i.poolId,R),{publicKey:z}=Ae(new Y(f.programId),i.poolId,L),{publicKey:$}=an(new Y(f.programId),i.poolId,g.tickLower,g.tickUpper),ae=[];for(let le=0;le<f.rewardInfos.length;le++)ae.push({poolRewardVault:new Y(f.rewardInfos[le].vault),ownerRewardVault:C[le],rewardMint:new Y(f.rewardInfos[le].mint.address)});let be=await Le.harvestLockPositionInstructionV2({programId:t,auth:n,lockPositionId:M,clmmProgram:o,lockOwner:this.scope.ownerPubKey,lockNftMint:i.lockNftMint,lockNftAccount:V,positionNftAccount:i.nftAccount,positionId:i.positionId,poolId:i.poolId,protocolPosition:$,vaultA:new Y(f.vault.A),vaultB:new Y(f.vault.B),tickArrayLower:W,tickArrayUpper:z,userVaultA:I,userVaultB:T,mintA:new Y(f.mintA.address),mintB:new Y(f.mintB.address),rewardAccounts:ae,exTickArrayBitmap:je(o,i.poolId).publicKey});return y.addInstruction({instructions:[be],instructionTypes:[U.ClmmHarvestLockPosition]}),y.addCustomComputeBudget(l),y.addTipInstruction(m),y.versionBuild({txVersion:p})}async closePosition({poolInfo:e,poolKeys:t,ownerPosition:n,txVersion:o,computeBudgetConfig:r,txTipConfig:i,feePayer:a}){var m;this.scope.availability.removeConcentratedPosition===!1&&this.logAndCreateError("remove position feature disabled in your region");let c=this.createTxBuilder(a),u=t!=null?t:await this.getClmmPoolKeys(e.id),l=Le.closePositionInstructions({poolInfo:e,poolKeys:u,ownerInfo:{wallet:this.scope.ownerPubKey},ownerPosition:n,nft2022:(m=await this.scope.connection.getAccountInfo(n.nftMint))==null?void 0:m.owner.equals(Dn)});return c.addCustomComputeBudget(r),c.addTipInstruction(i),c.addInstruction(l).versionBuild({txVersion:o,extInfo:{address:l.address}})}async initReward({poolInfo:e,ownerInfo:t,rewardInfo:n,associatedOnly:o=!0,checkCreateATAOwner:r=!1,computeBudgetConfig:i,txVersion:a,feePayer:c}){n.endTime<=n.openTime&&this.logAndCreateError("reward time error","rewardInfo",n);let u=this.createTxBuilder(c),l=t.useSOLBalance&&n.mint.address.toString()===H.toString(),m=n.perSecond.mul(n.endTime-n.openTime),{account:p,instructionParams:d}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:new Y(n.mint.address),mint:new Y(n.mint.address),notUseTokenAccount:!!l,skipCloseAccount:!l,owner:this.scope.ownerPubKey,createInfo:l?{payer:t.feePayer||this.scope.ownerPubKey,amount:new xt(new co(m.toFixed(0)).gte(m)?m.toFixed(0):m.add(1).toFixed(0))}:void 0,associatedOnly:l?!1:o,checkCreateATAOwner:r});d&&u.addInstruction(d),p||this.logAndCreateError("no money","ownerRewardAccount",this.scope.account.tokenAccountRawInfos);let f=await this.getClmmPoolKeys(e.id),y=Le.initRewardInstructions({poolInfo:e,poolKeys:f,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccount:p},rewardInfo:{programId:new Y(n.mint.programId),mint:new Y(n.mint.address),openTime:n.openTime,endTime:n.endTime,emissionsPerSecondX64:ue.decimalToX64(n.perSecond)}});return u.addInstruction(y),u.addCustomComputeBudget(i),u.versionBuild({txVersion:a,extInfo:{address:y.address}})}async initRewards({poolInfo:e,poolKeys:t,ownerInfo:n,rewardInfos:o,associatedOnly:r=!0,checkCreateATAOwner:i=!1,computeBudgetConfig:a,txTipConfig:c,txVersion:u,feePayer:l}){for(let d of o)d.endTime<=d.openTime&&this.logAndCreateError("reward time error","rewardInfo",d);let m=this.createTxBuilder(l),p={};for(let d of o){let f=n.useSOLBalance&&d.mint.address===H.toString(),y=d.perSecond.mul(d.endTime-d.openTime),{account:b,instructionParams:g}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:new Y(d.mint.programId),mint:new Y(d.mint.address),notUseTokenAccount:!!f,skipCloseAccount:!f,owner:this.scope.ownerPubKey,createInfo:f?{payer:n.feePayer||this.scope.ownerPubKey,amount:new xt(new co(y.toFixed(0)).gte(y)?y.toFixed(0):y.add(1).toFixed(0))}:void 0,associatedOnly:f?!1:r,checkCreateATAOwner:i});g&&m.addInstruction(g),b||this.logAndCreateError("no money","ownerRewardAccount",this.scope.account.tokenAccountRawInfos);let P=t!=null?t:await this.getClmmPoolKeys(e.id),h=Le.initRewardInstructions({poolInfo:e,poolKeys:P,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccount:b},rewardInfo:{programId:new Y(d.mint.programId),mint:new Y(d.mint.address),openTime:d.openTime,endTime:d.endTime,emissionsPerSecondX64:ue.decimalToX64(d.perSecond)}});p=N(N({},p),h.address),m.addInstruction(h)}return m.addCustomComputeBudget(a),m.addTipInstruction(c),m.versionBuild({txVersion:u,extInfo:{address:p}})}async setReward({poolInfo:e,ownerInfo:t,rewardInfo:n,associatedOnly:o=!0,checkCreateATAOwner:r=!1,computeBudgetConfig:i,txTipConfig:a,txVersion:c,feePayer:u}){n.endTime<=n.openTime&&this.logAndCreateError("reward time error","rewardInfo",n);let l=this.createTxBuilder(u),m=t.useSOLBalance&&n.mint.equals(H),{account:p,instructionParams:d}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:n.programId,mint:n.mint,notUseTokenAccount:m,owner:this.scope.ownerPubKey,createInfo:m?{payer:t.feePayer||this.scope.ownerPubKey,amount:new xt(new co(n.perSecond.mul(n.endTime-n.openTime).toFixed(0)).gte(n.perSecond.mul(n.endTime-n.openTime))?n.perSecond.mul(n.endTime-n.openTime).toFixed(0):n.perSecond.mul(n.endTime-n.openTime).add(1).toFixed(0))}:void 0,associatedOnly:m?!1:o,checkCreateATAOwner:r});d&&l.addInstruction(d),p||this.logAndCreateError("no money","ownerRewardAccount",this.scope.account.tokenAccountRawInfos);let f=await this.getClmmPoolKeys(e.id),y=Le.setRewardInstructions({poolInfo:e,poolKeys:f,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccount:p},rewardInfo:{mint:n.mint,openTime:n.openTime,endTime:n.endTime,emissionsPerSecondX64:ue.decimalToX64(n.perSecond)}});return l.addInstruction(y),l.addCustomComputeBudget(i),l.addTipInstruction(a),l.versionBuild({txVersion:c,extInfo:{address:y.address}})}async setRewards({poolInfo:e,poolKeys:t,ownerInfo:n,rewardInfos:o,associatedOnly:r=!0,checkCreateATAOwner:i=!1,computeBudgetConfig:a,txTipConfig:c,txVersion:u,feePayer:l}){let m=this.createTxBuilder(l),p={};for(let d of o){d.endTime<=d.openTime&&this.logAndCreateError("reward time error","rewardInfo",d);let f=n.useSOLBalance&&d.mint.address===H.toString(),{account:y,instructionParams:b}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:new Y(d.mint.programId),mint:new Y(d.mint.address),notUseTokenAccount:f,owner:this.scope.ownerPubKey,createInfo:f?{payer:n.feePayer||this.scope.ownerPubKey,amount:new xt(new co(d.perSecond.mul(d.endTime-d.openTime).toFixed(0)).gte(d.perSecond.mul(d.endTime-d.openTime))?d.perSecond.mul(d.endTime-d.openTime).toFixed(0):d.perSecond.mul(d.endTime-d.openTime).add(1).toFixed(0))}:void 0,associatedOnly:f?!1:r,checkCreateATAOwner:i});b&&m.addInstruction(b),y||this.logAndCreateError("no money","ownerRewardAccount",this.scope.account.tokenAccountRawInfos);let g=t!=null?t:await this.getClmmPoolKeys(e.id),P=Le.setRewardInstructions({poolInfo:e,poolKeys:g,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccount:y},rewardInfo:{mint:new Y(d.mint.address),openTime:d.openTime,endTime:d.endTime,emissionsPerSecondX64:ue.decimalToX64(d.perSecond)}});m.addInstruction(P),p=N(N({},p),P.address)}return m.addCustomComputeBudget(a),m.addTipInstruction(c),m.versionBuild({txVersion:u,extInfo:{address:p}})}async collectReward({poolInfo:e,ownerInfo:t,rewardMint:n,associatedOnly:o=!0,checkCreateATAOwner:r=!1,computeBudgetConfig:i,txTipConfig:a,txVersion:c,feePayer:u}){let l=e.rewardDefaultInfos.find(g=>g.mint.address===n.toString());l||this.logAndCreateError("reward mint error","not found reward mint",n);let m=this.createTxBuilder(u),p=t.useSOLBalance&&n.equals(H),{account:d,instructionParams:f}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:new Y(l.mint.programId),mint:n,notUseTokenAccount:p,owner:this.scope.ownerPubKey,skipCloseAccount:!p,createInfo:{payer:t.feePayer||this.scope.ownerPubKey,amount:0},associatedOnly:p?!1:o,checkCreateATAOwner:r});f&&m.addInstruction(f),d||this.logAndCreateError("no money","ownerRewardAccount",this.scope.account.tokenAccountRawInfos);let y=await this.getClmmPoolKeys(e.id),b=Le.collectRewardInstructions({poolInfo:e,poolKeys:y,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccount:d},rewardMint:n});return m.addInstruction(b),m.addCustomComputeBudget(i),m.addTipInstruction(a),m.versionBuild({txVersion:c,extInfo:{address:b.address}})}async collectRewards({poolInfo:e,ownerInfo:t,rewardMints:n,associatedOnly:o=!0,checkCreateATAOwner:r=!1,computeBudgetConfig:i,txTipConfig:a,feePayer:c}){let u=this.createTxBuilder(c),l={};for(let m of n){let p=e.rewardDefaultInfos.find(P=>P.mint.address===m.toString());if(!p){this.logAndCreateError("reward mint error","not found reward mint",m);continue}let d=t.useSOLBalance&&m.equals(H),{account:f,instructionParams:y}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:new Y(p.mint.programId),mint:m,notUseTokenAccount:d,owner:this.scope.ownerPubKey,skipCloseAccount:!d,createInfo:{payer:t.feePayer||this.scope.ownerPubKey,amount:0},associatedOnly:d?!1:o,checkCreateATAOwner:r});f||this.logAndCreateError("no money","ownerRewardAccount",this.scope.account.tokenAccountRawInfos),y&&u.addInstruction(y);let b=await this.getClmmPoolKeys(e.id),g=Le.collectRewardInstructions({poolInfo:e,poolKeys:b,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccount:f},rewardMint:m});u.addInstruction(g),l=N(N({},l),g.address)}return u.addCustomComputeBudget(i),u.addTipInstruction(a),u.build({address:l})}async swap({poolInfo:e,poolKeys:t,inputMint:n,amountIn:o,amountOutMin:r,priceLimit:i,observationId:a,ownerInfo:c,remainingAccounts:u,associatedOnly:l=!0,checkCreateATAOwner:m=!1,txVersion:p,computeBudgetConfig:d,txTipConfig:f,feePayer:y}){let b=this.createTxBuilder(y),g=n.toString()===e.mintA.address,P=c.useSOLBalance&&e.mintA.address===H.toBase58(),h=c.useSOLBalance&&e.mintB.address===H.toBase58(),I;!i||i.equals(new co(0))?I=g?Gt.add(new xt(1)):Xt.sub(new xt(1)):I=ie.priceToSqrtPriceX64(i,e.mintA.decimals,e.mintB.decimals);let T;if(!T){let{account:S,instructionParams:K}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:e.mintA.programId,mint:new Y(e.mintA.address),notUseTokenAccount:P,owner:this.scope.ownerPubKey,skipCloseAccount:!P,createInfo:P||!g?{payer:c.feePayer||this.scope.ownerPubKey,amount:g?o:0}:void 0,associatedOnly:P?!1:l,checkCreateATAOwner:m});T=S,K&&b.addInstruction(K)}let w;if(!w){let{account:S,instructionParams:K}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:e.mintB.programId,mint:new Y(e.mintB.address),notUseTokenAccount:h,owner:this.scope.ownerPubKey,skipCloseAccount:!h,createInfo:h||g?{payer:c.feePayer||this.scope.ownerPubKey,amount:g?0:o}:void 0,associatedOnly:h?!1:l,checkCreateATAOwner:m});w=S,K&&b.addInstruction(K)}(!T||!w)&&this.logAndCreateError("user do not have token account",{tokenA:e.mintA.symbol||e.mintA.address,tokenB:e.mintB.symbol||e.mintB.address,ownerTokenAccountA:T,ownerTokenAccountB:w,mintAUseSOLBalance:P,mintBUseSOLBalance:h,associatedOnly:l});let x=t!=null?t:await this.getClmmPoolKeys(e.id);return b.addInstruction(Le.makeSwapBaseInInstructions({poolInfo:e,poolKeys:x,observationId:a,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccountA:T,tokenAccountB:w},inputMint:new Y(n),amountIn:o,amountOutMin:r,sqrtPriceLimitX64:I,remainingAccounts:u})),b.addCustomComputeBudget(d),b.addTipInstruction(f),b.versionBuild({txVersion:p})}async swapBaseOut({poolInfo:e,poolKeys:t,outputMint:n,amountOut:o,amountInMax:r,priceLimit:i,observationId:a,ownerInfo:c,remainingAccounts:u,associatedOnly:l=!0,checkCreateATAOwner:m=!1,txVersion:p,computeBudgetConfig:d,txTipConfig:f,feePayer:y}){let b=this.createTxBuilder(y),g=n.toString()===e.mintB.address,P=c.useSOLBalance&&e.mintA.address===H.toBase58(),h=c.useSOLBalance&&e.mintB.address===H.toBase58(),I;!i||i.equals(new co(0))?I=n.toString()===e.mintB.address?Gt.add(new xt(1)):Xt.sub(new xt(1)):I=ie.priceToSqrtPriceX64(i,e.mintA.decimals,e.mintB.decimals);let T;if(!T){let{account:S,instructionParams:K}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:e.mintA.programId,mint:new Y(e.mintA.address),notUseTokenAccount:P,owner:this.scope.ownerPubKey,skipCloseAccount:!P,createInfo:P||!g?{payer:c.feePayer||this.scope.ownerPubKey,amount:g?r:0}:void 0,associatedOnly:P?!1:l,checkCreateATAOwner:m});T=S,K&&b.addInstruction(K)}let w;if(!w){let{account:S,instructionParams:K}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:e.mintB.programId,mint:new Y(e.mintB.address),notUseTokenAccount:h,owner:this.scope.ownerPubKey,skipCloseAccount:!h,createInfo:h||g?{payer:c.feePayer||this.scope.ownerPubKey,amount:g?0:r}:void 0,associatedOnly:h?!1:l,checkCreateATAOwner:m});w=S,K&&b.addInstruction(K)}(!T||!w)&&this.logAndCreateError("user do not have token account",{tokenA:e.mintA.symbol||e.mintA.address,tokenB:e.mintB.symbol||e.mintB.address,ownerTokenAccountA:T,ownerTokenAccountB:w,mintAUseSOLBalance:P,mintBUseSOLBalance:h,associatedOnly:l});let x=t!=null?t:await this.getClmmPoolKeys(e.id);return b.addInstruction(Le.makeSwapBaseOutInstructions({poolInfo:e,poolKeys:x,observationId:a,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccountA:T,tokenAccountB:w},outputMint:new Y(n),amountOut:o,amountInMax:r,sqrtPriceLimitX64:I,remainingAccounts:u})),b.addCustomComputeBudget(d),b.addTipInstruction(f),b.versionBuild({txVersion:p})}async harvestAllRewards({allPoolInfo:e,allPositions:t,lockInfo:n,ownerInfo:o,associatedOnly:r=!0,checkCreateATAOwner:i=!1,programId:a,txVersion:c,computeBudgetConfig:u,feePayer:l,lockProgram:m=To,lockAuth:p=ni,clmmProgram:d=Ln}){var h,I;let f={};for(let T of this.scope.account.tokenAccountRawInfos)r?j(this.scope.ownerPubKey,T.accountInfo.mint,a).publicKey.equals(T.pubkey)&&(f[T.accountInfo.mint.toString()]=T.pubkey):f[T.accountInfo.mint.toString()]=T.pubkey;let y=Object.values(t).flat().map(T=>T.nftMint),b=await Me(this.scope.connection,y.map(T=>({pubkey:T}))),g={};b.forEach(T=>{var w,x;g[T.pubkey.toBase58()]=(x=(w=T==null?void 0:T.accountInfo)==null?void 0:w.owner)!=null?x:null});let P=this.createTxBuilder(l);for(let T of Object.values(e)){if(t[T.id]===void 0||!t[T.id].find(R=>!R.liquidity.isZero()||R.rewardInfos.find(L=>!L.rewardAmountOwed.isZero())))continue;let w=T,x=o.useSOLBalance&&w.mintA.address===H.toString(),S=o.useSOLBalance&&w.mintB.address===H.toString(),K=f[w.mintA.address];if(!K)if(x){let{account:R,instructionParams:L}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:w.mintA.programId,mint:new Y(w.mintA.address),notUseTokenAccount:x,owner:this.scope.ownerPubKey,skipCloseAccount:!x,createInfo:{payer:o.feePayer||this.scope.ownerPubKey,amount:0},associatedOnly:x?!1:r,checkCreateATAOwner:i});K=R,L&&P.addInstruction(L)}else{let R=new Y(w.mintA.address);K=this.scope.account.getAssociatedTokenAccount(R,new Y(w.mintA.programId)),P.addInstruction({instructions:[Ll(this.scope.ownerPubKey,K,this.scope.ownerPubKey,R,new Y(w.mintA.programId))]})}let B=f[w.mintB.address];if(!B)if(S){let{account:R,instructionParams:L}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:w.mintB.programId,mint:new Y(w.mintB.address),notUseTokenAccount:S,owner:this.scope.ownerPubKey,skipCloseAccount:!S,createInfo:{payer:o.feePayer||this.scope.ownerPubKey,amount:0},associatedOnly:S?!1:r,checkCreateATAOwner:i});B=R,L&&P.addInstruction(L)}else{let R=new Y(w.mintB.address);B=this.scope.account.getAssociatedTokenAccount(R,new Y(w.mintB.programId)),P.addInstruction({instructions:[Ll(this.scope.ownerPubKey,B,this.scope.ownerPubKey,R,new Y(w.mintB.programId))]})}f[w.mintA.address]=K,f[w.mintB.address]=B;let C=[];for(let R of w.rewardDefaultInfos){let L=o.useSOLBalance&&R.mint.address===H.toString(),W=f[R.mint.address];if(!W){let{account:z,instructionParams:$}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:new Y(R.mint.programId),mint:new Y(R.mint.address),notUseTokenAccount:L,owner:this.scope.ownerPubKey,skipCloseAccount:!L,createInfo:{payer:o.feePayer||this.scope.ownerPubKey,amount:0},associatedOnly:L?!1:r});W=z,$&&P.addInstruction($)}f[R.mint.address]=W,C.push(W)}let M=await this.getClmmPoolKeys(w.id),V=[];for(let R=0;R<M.rewardInfos.length;R++)V.push({poolRewardVault:new Y(M.rewardInfos[R].vault),ownerRewardVault:C[R],rewardMint:new Y(M.rewardInfos[R].mint.address)});for(let R of t[T.id]){let L=(h=n==null?void 0:n[T.id])==null?void 0:h[R.nftMint.toBase58()];if(L){let W=j(this.scope.ownerPubKey,L.lockNftMint,Vi).publicKey,z=Z.getTickArrayStartIndexByTick(R.tickLower,M.config.tickSpacing),$=Z.getTickArrayStartIndexByTick(R.tickUpper,M.config.tickSpacing),{publicKey:ae}=Ae(new Y(M.programId),L.poolId,z),{publicKey:be}=Ae(new Y(M.programId),L.poolId,$),{publicKey:le}=an(new Y(M.programId),L.poolId,R.tickLower,R.tickUpper),pe=Oo(m,L.lockNftMint).publicKey,ye=Le.harvestLockPositionInstructionV2({programId:m,auth:p,lockPositionId:pe,clmmProgram:d,lockOwner:this.scope.ownerPubKey,lockNftMint:L.lockNftMint,lockNftAccount:W,positionNftAccount:L.nftAccount,positionId:L.positionId,poolId:L.poolId,protocolPosition:le,vaultA:new Y(M.vault.A),vaultB:new Y(M.vault.B),tickArrayLower:ae,tickArrayUpper:be,userVaultA:K,userVaultB:B,mintA:new Y(M.mintA.address),mintB:new Y(M.mintB.address),rewardAccounts:V,exTickArrayBitmap:je(d,L.poolId).publicKey});P.addInstruction({instructions:[ye],instructionTypes:[U.ClmmHarvestLockPosition],lookupTableAddress:M.lookupTableAccount?[M.lookupTableAccount]:[]})}else{let W=Le.decreaseLiquidityInstructions({poolInfo:w,poolKeys:M,ownerPosition:R,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccountA:K,tokenAccountB:B,rewardAccounts:C},liquidity:new xt(0),amountMinA:new xt(0),amountMinB:new xt(0),nft2022:(I=g[R.nftMint.toBase58()])==null?void 0:I.equals(Dn)});P.addInstruction(W)}}}return c===0?P.sizeCheckBuildV0({computeBudgetConfig:u}):P.sizeCheckBuild({computeBudgetConfig:u})}async getWhiteListMint({programId:e}){let t=await this.scope.connection.getAccountInfo(xi(e).publicKey);return t?sl.decode(t.data).whitelistMints.filter(o=>!o.equals(Y.default)):[]}async getOwnerPositionInfo({programId:e=Ln}){await this.scope.account.fetchWalletTokenAccounts();let n=this.scope.account.tokenAccountRawInfos.filter(i=>i.accountInfo.amount.eq(new xt(1))).map(i=>Bt(new Y(e),i.accountInfo.mint).publicKey),o=await this.scope.connection.getMultipleAccountsInfo(n),r=[];return o.forEach(i=>{if(!i)return;let a=No.decode(i.data);r.push(a)}),r}async getOwnerLockedPositionInfo({programId:e=To}){await this.scope.account.fetchWalletTokenAccounts();let n=this.scope.account.tokenAccountRawInfos.filter(c=>c.accountInfo.amount.eq(new xt(1))).map(c=>Oo(new Y(e),c.accountInfo.mint).publicKey),o=await this.scope.connection.getMultipleAccountsInfo(n),r=[];o.forEach(c=>{if(!c)return;let u=ul.decode(c.data);r.push(u)});let i=await this.scope.connection.getMultipleAccountsInfo(r.map(c=>c.positionId)),a=[];return i.forEach(c=>{if(!c)return;let u=No.decode(c.data);a.push(u)}),r.map((c,u)=>({position:a[u],lockInfo:c}))}async getRpcClmmPoolInfo({poolId:e}){return(await this.getRpcClmmPoolInfos({poolIds:[e]}))[String(e)]}async getRpcClmmPoolInfos({poolIds:e,config:t}){let n=await Me(this.scope.connection,e.map(r=>({pubkey:new Y(r)})),t),o={};for(let r=0;r<e.length;r++){let i=n[r];if(i===null||!i.accountInfo)throw Error("fetch pool info error: "+String(e[r]));let a=no.decode(i.accountInfo.data),c=ie.sqrtPriceX64ToPrice(a.sqrtPriceX64,a.mintDecimalsA,a.mintDecimalsB).toNumber();o[String(e[r])]=q(N({},a),{currentPrice:c,programId:i.accountInfo.owner})}return o}async getComputeClmmPoolInfos({clmmPoolsRpcInfo:e,mintInfos:t}){let n=new Set(Object.keys(e).map(c=>e[c].ammConfig.toBase58())),o=await Me(this.scope.connection,Array.from(n).map(c=>({pubkey:new Y(c)}))),r={};o.forEach(c=>{!c.accountInfo||(r[c.pubkey.toBase58()]=rl.decode(c.accountInfo.data))});let i=await ve.fetchComputeMultipleClmmInfo({connection:this.scope.connection,rpcDataMap:e,poolList:Object.keys(e).map(c=>{var m,p,d,f;let[u,l]=[e[c].mintA.toBase58(),e[c].mintB.toBase58()];return{id:c,programId:e[c].programId.toBase58(),mintA:At({address:u,decimals:e[c].mintDecimalsA,programId:t[u].programId.toBase58()||Vi.toBase58(),extensions:{feeConfig:(m=t[u])!=null&&m.feeConfig?_n((p=t[u])==null?void 0:p.feeConfig):void 0}}),mintB:At({address:l,decimals:e[c].mintDecimalsB,programId:t[l].programId.toBase58()||Vi.toBase58(),extensions:{feeConfig:(d=t[l])!=null&&d.feeConfig?_n((f=t[l])==null?void 0:f.feeConfig):void 0}}),price:e[c].currentPrice,config:q(N({},r[e[c].ammConfig.toBase58()]),{id:e[c].ammConfig.toBase58(),fundFeeRate:0,description:"",defaultRange:0,defaultRangePoint:[]})}})}),a=await ve.fetchMultiplePoolTickArrays({connection:this.scope.connection,poolKeys:Object.values(i)});return{computeClmmPoolInfo:i,computePoolTickData:a}}async getPoolInfoFromRpc(e){var l;let t=await this.getRpcClmmPoolInfo({poolId:e}),n=new Set([t.mintA.toBase58(),t.mintB.toBase58()]),o=await Po({connection:this.scope.connection,mints:Array.from(n).map(m=>new Y(m))}),{computeClmmPoolInfo:r,computePoolTickData:i}=await this.scope.clmm.getComputeClmmPoolInfos({clmmPoolsRpcInfo:{[e]:t},mintInfos:o}),a=await Me(this.scope.connection,[{pubkey:t.vaultA},{pubkey:t.vaultB}]),c=ol(r[e]);if(!a[0].accountInfo||!a[1].accountInfo)throw new Error("pool vault data not found");c.mintAmountA=Number(Rl.decode(a[0].accountInfo.data).amount.toString()),c.mintAmountB=Number(Rl.decode((l=a[1].accountInfo)==null?void 0:l.data).amount.toString());let u=q(N({},r[e]),{exBitmapAccount:r[e].exBitmapAccount.toBase58(),observationId:r[e].observationId.toBase58(),id:e,programId:t.programId.toBase58(),openTime:t.startTime.toString(),vault:{A:t.vaultA.toBase58(),B:t.vaultB.toBase58()},config:c.config,rewardInfos:r[e].rewardInfos.filter(m=>!m.tokenVault.equals(Y.default)).map(m=>({mint:At({address:m.tokenMint.toBase58(),programId:Vi.toBase58(),decimals:10}),vault:m.tokenVault.toBase58()}))});return{poolInfo:c,poolKeys:u,computePoolInfo:r[e],tickData:i}}};import{PublicKey as X}from"@solana/web3.js";import{AccountLayout as jf,NATIVE_MINT as ta,TOKEN_PROGRAM_ID as _t,createAssociatedTokenAccountIdempotentInstruction as ql}from"@solana/spl-token";import eu from"bn.js";import Zr from"decimal.js-light";import Ei from"bn.js";function Yr(s,e){if(e.isZero())throw Error("divisor is zero");return s.mod(e)}function vf(s,e){if(e.isZero())throw Error("rhs is zero");let t=s.div(e);if(t.isZero())throw Error("quotient is zero");let n=Yr(s,e);return n.gt(_o)&&(t=t.add(new Ei(1)),e=s.div(t),n=Yr(s,t),n.gt(_o)&&(e=e.add(new Ei(1)))),[t,e]}var _o=new Ei(0),jr=class{static swapWithoutFees(e,t,n){let o=t.mul(n),r=t.add(e),[i]=vf(o,r),a=n.sub(i);if(a.isZero())throw Error("destinationAmountSwapped is zero");return{destinationAmountSwapped:a}}static lpTokensToTradingTokens(e,t,n,o,r){let i=e.mul(n).div(t),a=e.mul(o).div(t);if(r===0)return{tokenAmount0:i,tokenAmount1:a};if(r===1)return Yr(e.mul(n),t).gt(_o)&&i.gt(_o)&&(i=i.add(new Ei(1))),Yr(e.mul(o),t).gt(_o)&&a.gt(_o)&&(a=a.add(new Ei(1))),{tokenAmount0:i,tokenAmount1:a};throw Error("roundDirection value error")}};var Hr=class{static tradingFee(e,t){return dr(e,t,nn)}static protocolFee(e,t){return Ma(e,t,nn)}static fundFee(e,t){return Ma(e,t,nn)}};var Ol=(t=>(t[t.Floor=0]="Floor",t[t.Ceiling=1]="Ceiling",t))(Ol||{}),$r=class{static validate_supply(e,t){if(e.isZero())throw Error("tokenAmount0 is zero");if(t.isZero())throw Error("tokenAmount1 is zero")}static swap(e,t,n,o){let r=Hr.tradingFee(e,o),i=e.sub(r),{destinationAmountSwapped:a}=jr.swapWithoutFees(i,t,n);return{newSwapDestinationAmount:n.sub(a),sourceAmountSwapped:e,destinationAmountSwapped:a,tradeFee:r}}static swapBaseOut({poolMintA:e,poolMintB:t,tradeFeeRate:n,baseReserve:o,quoteReserve:r,outputMint:i,outputAmount:a}){let[c,u,l,m,p]=t.address===i.toString()?[o,r,e.decimals,t.decimals,e.address]:[r,o,t.decimals,e.decimals,t.address],d=new Zr(u.toString()).div(10**m).div(new Zr(c.toString()).div(10**l)),f=a.gte(u)?u.sub(new eu(1)):a,y=u.sub(f),b=Kt(c.mul(f),y),g=Kt(b.mul(new eu(1e6)),new eu(1e6).sub(n)),P=g.sub(b),h=new Zr(f.toString()).div(10**m).div(new Zr(g.toString()).div(10**l)),I=d.isZero()?0:h.sub(d).div(d).abs().toNumber();return{amountRealOut:f,amountIn:g,amountInWithoutFee:b,tradeFee:P,priceImpact:I}}};import He from"bn.js";import zt from"decimal.js";import{PublicKey as qi,TransactionInstruction as lo,Keypair as Xf,SystemProgram as zf}from"@solana/web3.js";import{ASSOCIATED_TOKEN_PROGRAM_ID as vl,TOKEN_2022_PROGRAM_ID as nu,TOKEN_PROGRAM_ID as Wn}from"@solana/spl-token";var Ff=Buffer.from("vault_and_lp_mint_auth_seed","utf8"),Vf=Buffer.from("amm_config","utf8"),_f=Buffer.from("pool","utf8"),Ef=Buffer.from("pool_lp_mint","utf8"),Df=Buffer.from("pool_vault","utf8"),Wf=Buffer.from("observation","utf8");function Eo(s){return ne([Ff],s)}function vS(s,e){return ne([Vf,Uf(e)],s)}function tu(s,e,t,n){return ne([_f,e.toBuffer(),t.toBuffer(),n.toBuffer()],s)}function qf(s,e){return ne([Ef,e.toBuffer()],s)}function Nl(s,e,t){return ne([Df,e.toBuffer(),t.toBuffer()],s)}function Di(s,e){return ne([Wf,e.toBuffer()],s)}function Uf(s){let e=new ArrayBuffer(2);return new DataView(e).setUint16(0,s,!1),new Uint8Array(e)}function Ml({poolId:s,programId:e,configId:t,mintA:n,mintB:o}){let r=Eo(e).publicKey,i=s||tu(e,t,n,o).publicKey,a=qf(e,i).publicKey,c=Nl(e,i,n).publicKey,u=Nl(e,i,o).publicKey,l=Di(e,i).publicKey;return{poolId:i,configId:t,authority:r,lpMint:a,vaultA:c,vaultB:u,observationId:l}}var Gf=Buffer.from("locked_liquidity","utf8");function Wi(s,e){return ne([Gf,e.toBuffer()],s)}var Qf=fe("Raydium_cpmm"),mo={initialize:[175,175,109,31,13,152,155,237],deposit:[242,35,198,137,82,225,242,182],withdraw:[183,18,70,156,148,109,161,34],swapBaseInput:[143,190,90,218,196,30,51,222],swapBaseOutput:[55,217,98,86,163,74,180,173],lockCpLiquidity:[216,157,29,78,38,51,31,26],collectCpFee:[8,30,51,199,209,184,247,133]};function Fl(s,e,t,n,o,r,i,a,c,u,l,m,p,d,f,y,b,g,P,h){let I=v([k("amountMaxA"),k("amountMaxB"),k("openTime")]),T=tu(s,t,r,i).publicKey,w=[{pubkey:e,isSigner:!0,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!o.equals(T),isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!1},{pubkey:i,isSigner:!1,isWritable:!1},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:m,isSigner:!1,isWritable:!0},{pubkey:p,isSigner:!1,isWritable:!0},{pubkey:d,isSigner:!1,isWritable:!0},{pubkey:b,isSigner:!1,isWritable:!0},{pubkey:Wn,isSigner:!1,isWritable:!1},{pubkey:f,isSigner:!1,isWritable:!1},{pubkey:y,isSigner:!1,isWritable:!1},{pubkey:vl,isSigner:!1,isWritable:!1},{pubkey:lr,isSigner:!1,isWritable:!1},{pubkey:tt,isSigner:!1,isWritable:!1}],x=Buffer.alloc(I.span);return I.encode({amountMaxA:g,amountMaxB:P,openTime:h},x),new lo({keys:w,programId:s,data:Buffer.from([...mo.initialize,...x])})}function Vl(s,e,t,n,o,r,i,a,c,u,l,m,p,d,f){let y=v([k("lpAmount"),k("amountMaxA"),k("amountMaxB")]),b=[{pubkey:e,isSigner:!0,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:Wn,isSigner:!1,isWritable:!1},{pubkey:nu,isSigner:!1,isWritable:!1},{pubkey:u,isSigner:!1,isWritable:!1},{pubkey:l,isSigner:!1,isWritable:!1},{pubkey:m,isSigner:!1,isWritable:!0}],g=Buffer.alloc(y.span);return Qf.debug("cpmm deposit data",{lpAmount:p.toString(),amountMaxA:d.toString(),amountMaxB:f.toString()}),y.encode({lpAmount:p,amountMaxA:d,amountMaxB:f},g),new lo({keys:b,programId:s,data:Buffer.from([...mo.deposit,...g])})}function _l(s,e,t,n,o,r,i,a,c,u,l,m,p,d,f){let y=v([k("lpAmount"),k("amountMinA"),k("amountMinB")]),b=[{pubkey:e,isSigner:!0,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:Wn,isSigner:!1,isWritable:!1},{pubkey:nu,isSigner:!1,isWritable:!1},{pubkey:u,isSigner:!1,isWritable:!1},{pubkey:l,isSigner:!1,isWritable:!1},{pubkey:m,isSigner:!1,isWritable:!0},{pubkey:ln,isSigner:!1,isWritable:!1}],g=Buffer.alloc(y.span);return y.encode({lpAmount:p,amountMinA:d,amountMinB:f},g),new lo({keys:b,programId:s,data:Buffer.from([...mo.withdraw,...g])})}function Jr(s,e,t,n,o,r,i,a,c,u,l,m,p,d,f,y){let b=v([k("amountIn"),k("amounOutMin")]),g=[{pubkey:e,isSigner:!0,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!1},{pubkey:l,isSigner:!1,isWritable:!1},{pubkey:m,isSigner:!1,isWritable:!1},{pubkey:p,isSigner:!1,isWritable:!1},{pubkey:d,isSigner:!1,isWritable:!0}],P=Buffer.alloc(b.span);return b.encode({amountIn:f,amounOutMin:y},P),new lo({keys:g,programId:s,data:Buffer.from([...mo.swapBaseInput,...P])})}function El(s,e,t,n,o,r,i,a,c,u,l,m,p,d,f,y){let b=v([k("amountInMax"),k("amountOut")]),g=[{pubkey:e,isSigner:!0,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!1},{pubkey:l,isSigner:!1,isWritable:!1},{pubkey:m,isSigner:!1,isWritable:!1},{pubkey:p,isSigner:!1,isWritable:!1},{pubkey:d,isSigner:!1,isWritable:!0}],P=Buffer.alloc(b.span);return b.encode({amountInMax:f,amountOut:y},P),new lo({keys:g,programId:s,data:Buffer.from([...mo.swapBaseOutput,...P])})}async function Dl(s){var b;let{ownerInfo:e,poolInfo:t,poolKeys:n,feeNftOwner:o,getEphemeralSigners:r}=s,i=[],[a,c]=[new qi(t.id),new qi(t.lpMint.address)],u;if(r)u=new qi((await r(1))[0]);else{let g=Xf.generate();i.push(g),u=g.publicKey}let{publicKey:l}=j(o,u,Wn),{publicKey:m}=hn(u),{publicKey:p}=Wi(s.lockProgram,u),{publicKey:d}=j(e.wallet,c,Wn),{publicKey:f}=j(s.lockAuthProgram,c,Wn),y=Yf({programId:s.lockProgram,auth:s.lockAuthProgram,payer:e.feePayer,liquidityOwner:e.wallet,nftOwner:o,nftMint:u,nftAccount:l,poolId:a,lockPda:p,mintLp:c,userLpVault:d,lockLpVault:f,poolVaultA:new qi(n.vault.A),poolVaultB:new qi(n.vault.B),metadataAccount:m,lpAmount:s.lpAmount,withMetadata:(b=s.withMetadata)!=null?b:!0});return{address:{nftMint:u,nftAccount:l,metadataAccount:m,lockPda:p,userLpVault:d,lockLpVault:f},instructions:[y],signers:i,instructionTypes:[U.CpmmLockLp],lookupTableAddress:[]}}function Yf({programId:s,auth:e,payer:t,liquidityOwner:n,nftOwner:o,nftMint:r,nftAccount:i,poolId:a,lockPda:c,mintLp:u,userLpVault:l,lockLpVault:m,poolVaultA:p,poolVaultB:d,metadataAccount:f,lpAmount:y,withMetadata:b}){let g=[{pubkey:e,isSigner:!1,isWritable:!1},{pubkey:t,isSigner:!0,isWritable:!0},{pubkey:n,isSigner:!0,isWritable:!1},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!0,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!1},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!1},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:m,isSigner:!1,isWritable:!0},{pubkey:p,isSigner:!1,isWritable:!0},{pubkey:d,isSigner:!1,isWritable:!0},{pubkey:f,isSigner:!1,isWritable:!0},{pubkey:tt,isSigner:!1,isWritable:!1},{pubkey:zf.programId,isSigner:!1,isWritable:!1},{pubkey:Wn,isSigner:!1,isWritable:!1},{pubkey:vl,isSigner:!1,isWritable:!1},{pubkey:Jt,isSigner:!1,isWritable:!1}],P=v([k("lpAmount"),We("withMetadata")]),h=Buffer.alloc(P.span);P.encode({lpAmount:y,withMetadata:b},h);let I=Buffer.from([...mo.lockCpLiquidity,...h]);return new lo({keys:g,programId:s,data:I})}function ou({programId:s,nftOwner:e,auth:t,nftAccount:n,lockPda:o,poolId:r,mintLp:i,userVaultA:a,userVaultB:c,poolVaultA:u,poolVaultB:l,mintA:m,mintB:p,lockLpVault:d,lpFeeAmount:f,cpmmProgram:y,cpmmAuthProgram:b}){let g=[{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:e,isSigner:!0,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:y!=null?y:oi,isSigner:!1,isWritable:!1},{pubkey:b!=null?b:Wa,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:m,isSigner:!1,isWritable:!1},{pubkey:p,isSigner:!1,isWritable:!1},{pubkey:d,isSigner:!1,isWritable:!0},{pubkey:Wn,isSigner:!1,isWritable:!1},{pubkey:nu,isSigner:!1,isWritable:!1},{pubkey:ln,isSigner:!1,isWritable:!1}],P=v([k("lpFeeAmount")]),h=Buffer.alloc(P.span);P.encode({lpFeeAmount:f},h);let I=Buffer.from([...mo.collectCpFee,...h]);return new lo({keys:g,programId:s,data:I})}var Wl=v([xe(8),D("bump"),We("disableCreatePool"),Mt("index"),k("tradeFeeRate"),k("protocolFeeRate"),k("fundFeeRate"),k("createPoolFee"),O("protocolOwner"),O("fundOwner"),Q(k(),16)]),ea=v([xe(8),O("configId"),O("poolCreator"),O("vaultA"),O("vaultB"),O("mintLp"),O("mintA"),O("mintB"),O("mintProgramA"),O("mintProgramB"),O("observationId"),D("bump"),D("status"),D("lpDecimals"),D("mintDecimalA"),D("mintDecimalB"),k("lpAmount"),k("protocolFeesMintA"),k("protocolFeesMintB"),k("fundFeesMintA"),k("fundFeesMintB"),k("openTime"),Q(k(),32)]);var Ui=class extends Ve{constructor(e){super(e)}async load(){this.checkDisabled()}async getCpmmPoolKeys(e){return(await this.scope.api.fetchPoolKeysById({idList:[e]}))[0]}async getRpcPoolInfo(e,t){return(await this.getRpcPoolInfos([e],t))[e]}async getRpcPoolInfos(e,t){let n=await Me(this.scope.connection,e.map(m=>({pubkey:new X(m)}))),o={},r=new Set,i=[];for(let m=0;m<e.length;m++){let p=n[m];if(p.accountInfo===null)throw Error("fetch pool info error: "+String(e[m]));let d=ea.decode(p.accountInfo.data);o[String(e[m])]=q(N({},d),{programId:p.accountInfo.owner}),r.add(String(d.configId)),i.push(d.vaultA,d.vaultB)}let a={};if(t){let m=[...r],p=await Me(this.scope.connection,m.map(d=>({pubkey:new X(d)})));for(let d=0;d<m.length;d++){let f=p[d].accountInfo;if(f===null)throw Error("fetch pool config error: "+m[d]);a[m[d]]=Wl.decode(f.data)}}let c={},u=await Me(this.scope.connection,i.map(m=>({pubkey:new X(m)})));for(let m=0;m<i.length;m++){let p=u[m].accountInfo;if(p===null)throw Error("fetch vault info error: "+i[m]);c[String(i[m])]=new He(jf.decode(p.data).amount.toString())}let l={};for(let[m,p]of Object.entries(o)){let d=c[p.vaultA.toString()].sub(p.protocolFeesMintA).sub(p.fundFeesMintA),f=c[p.vaultB.toString()].sub(p.protocolFeesMintB).sub(p.fundFeesMintB);l[m]=q(N({},p),{baseReserve:d,quoteReserve:f,vaultAAmount:c[p.vaultA.toString()],vaultBAmount:c[p.vaultB.toString()],configInfo:a[p.configId.toString()],poolPrice:new zt(f.toString()).div(new zt(10).pow(p.mintDecimalB)).div(new zt(d.toString()).div(new zt(10).pow(p.mintDecimalA)))})}return l}toComputePoolInfos({pools:e,mintInfos:t}){return Object.keys(e).reduce((n,o)=>{var c,u,l,m;let r=e[o],[i,a]=[r.mintA.toBase58(),r.mintB.toBase58()];return q(N({},n),{[o]:q(N({},r),{id:new X(o),configInfo:r.configInfo,version:7,authority:Eo(r.programId).publicKey,mintA:At({address:i,decimals:r.mintDecimalA,programId:r.mintProgramA.toBase58(),extensions:{feeConfig:(c=t[i])!=null&&c.feeConfig?_n((u=t[i])==null?void 0:u.feeConfig):void 0}}),mintB:At({address:a,decimals:r.mintDecimalB,programId:r.mintProgramB.toBase58(),extensions:{feeConfig:(l=t[a])!=null&&l.feeConfig?_n((m=t[a])==null?void 0:m.feeConfig):void 0}})})})},{})}async getPoolInfoFromRpc(e){let t=await this.getRpcPoolInfo(e,!0),n=await Po({connection:this.scope.connection,mints:[t.mintA,t.mintB]}),o=At({address:t.mintA.toBase58(),decimals:t.mintDecimalA,programId:t.mintProgramA.toBase58(),extensions:{feeConfig:n[t.mintA.toBase58()].feeConfig?_n(n[t.mintA.toBase58()].feeConfig):void 0}}),r=At({address:t.mintB.toBase58(),decimals:t.mintDecimalB,programId:t.mintProgramB.toBase58(),extensions:{feeConfig:n[t.mintB.toBase58()].feeConfig?_n(n[t.mintB.toBase58()].feeConfig):void 0}}),i=At({address:t.mintLp.toBase58(),decimals:t.lpDecimals,programId:_t.toBase58()}),a={id:t.configId.toBase58(),index:t.configInfo.index,protocolFeeRate:t.configInfo.protocolFeeRate.toNumber(),tradeFeeRate:t.configInfo.tradeFeeRate.toNumber(),fundFeeRate:t.configInfo.fundFeeRate.toNumber(),createPoolFee:t.configInfo.createPoolFee.toString()},c={volume:0,volumeQuote:0,volumeFee:0,apr:0,feeApr:0,priceMin:0,priceMax:0,rewardApr:[]};return{poolInfo:{programId:t.programId.toBase58(),id:e,type:"Standard",lpMint:i,lpPrice:0,lpAmount:t.lpAmount.toNumber(),config:a,mintA:o,mintB:r,rewardDefaultInfos:[],rewardDefaultPoolInfos:"Ecosystem",price:t.poolPrice.toNumber(),mintAmountA:new zt(t.vaultAAmount.toString()).div(10**o.decimals).toNumber(),mintAmountB:new zt(t.vaultBAmount.toString()).div(10**r.decimals).toNumber(),feeRate:t.configInfo.tradeFeeRate.toNumber(),openTime:t.openTime.toString(),tvl:0,burnPercent:0,day:c,week:c,month:c,pooltype:[],farmUpcomingCount:0,farmOngoingCount:0,farmFinishedCount:0},poolKeys:{programId:t.programId.toBase58(),id:e,mintA:o,mintB:r,openTime:t.openTime.toString(),vault:{A:t.vaultA.toBase58(),B:t.vaultB.toBase58()},authority:Eo(t.programId).publicKey.toBase58(),mintLp:i,config:a,observationId:Di(t.programId,new X(e)).publicKey.toBase58()},rpcData:t}}async createPool(f){var y=f,{poolId:e,programId:t,poolFeeAccount:n,startTime:o,ownerInfo:r,associatedOnly:i=!1,checkCreateATAOwner:a=!1,txVersion:c,feeConfig:u,computeBudgetConfig:l,txTipConfig:m,feePayer:p}=y,d=qe(y,["poolId","programId","poolFeeAccount","startTime","ownerInfo","associatedOnly","checkCreateATAOwner","txVersion","feeConfig","computeBudgetConfig","txTipConfig","feePayer"]);var W,z,$;let b=r.feePayer||((W=this.scope.owner)==null?void 0:W.publicKey),g=new He(new X(d.mintA.address).toBuffer()).lte(new He(new X(d.mintB.address).toBuffer())),[P,h]=g?[d.mintA,d.mintB]:[d.mintB,d.mintA],[I,T]=g?[d.mintAAmount,d.mintBAmount]:[d.mintBAmount,d.mintAAmount],w=r.useSOLBalance&&P.address===ta.toBase58(),x=r.useSOLBalance&&h.address===ta.toBase58(),[S,K]=[new X(P.address),new X(h.address)],B=this.createTxBuilder(p),{account:C,instructionParams:M}=await this.scope.account.getOrCreateTokenAccount({mint:S,tokenProgram:P.programId,owner:this.scope.ownerPubKey,createInfo:w?{payer:b,amount:I}:void 0,notUseTokenAccount:w,skipCloseAccount:!w,associatedOnly:w?!1:i,checkCreateATAOwner:a});B.addInstruction(M||{});let{account:V,instructionParams:R}=await this.scope.account.getOrCreateTokenAccount({mint:new X(h.address),tokenProgram:h.programId,owner:this.scope.ownerPubKey,createInfo:x?{payer:b,amount:T}:void 0,notUseTokenAccount:x,skipCloseAccount:!x,associatedOnly:x?!1:i,checkCreateATAOwner:a});if(B.addInstruction(R||{}),C===void 0||V===void 0)throw Error("you don't has some token account");let L=Ml({poolId:e,programId:t,configId:new X(u.id),mintA:S,mintB:K});return B.addInstruction({instructions:[Fl(t,this.scope.ownerPubKey,new X(u.id),L.authority,L.poolId,S,K,L.lpMint,C,V,j(this.scope.ownerPubKey,L.lpMint).publicKey,L.vaultA,L.vaultB,n,new X((z=P.programId)!=null?z:_t),new X(($=h.programId)!=null?$:_t),L.observationId,I,T,o)],instructionTypes:[U.CpmmCreatePool]}),B.addCustomComputeBudget(l),B.addTipInstruction(m),B.versionBuild({txVersion:c,extInfo:{address:q(N({},L),{mintA:P,mintB:h,programId:t,poolFeeAccount:n,feeConfig:u})}})}async addLiquidity(e){let{poolInfo:t,poolKeys:n,inputAmount:o,baseIn:r,slippage:i,computeResult:a,computeBudgetConfig:c,txTipConfig:u,config:l,txVersion:m,feePayer:p}=e;this.scope.availability.addStandardPosition===!1&&this.logAndCreateError("add liquidity feature disabled in your region"),o.isZero()&&this.logAndCreateError("amounts must greater than zero","amountInA",{amountInA:o.toString()});let{account:d}=this.scope,{bypassAssociatedCheck:f,checkCreateATAOwner:y}=N({bypassAssociatedCheck:!1,checkCreateATAOwner:!1},l),b=a?void 0:await this.getRpcPoolInfo(t.id),{liquidity:g,inputAmountFee:P,anotherAmount:h}=a||this.computePairAmount({poolInfo:q(N({},t),{lpAmount:new zt(b.lpAmount.toString()).div(10**t.lpMint.decimals).toNumber()}),baseReserve:b.baseReserve,quoteReserve:b.quoteReserve,slippage:new ze(0),baseIn:r,epochInfo:await this.scope.fetchEpochInfo(),amount:new zt(o.toString()).div(10**(r?t.mintA.decimals:t.mintB.decimals))}),I=h.amount,T=t.mintA.address===ta.toString(),w=t.mintB.address===ta.toString(),x=this.createTxBuilder(p),[S,K]=[new X(t.mintA.address),new X(t.mintB.address)],{account:B,instructionParams:C}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:t.mintA.programId,mint:new X(t.mintA.address),owner:this.scope.ownerPubKey,createInfo:T||(r?o:I).isZero()?{payer:this.scope.ownerPubKey,amount:r?o:I}:void 0,skipCloseAccount:!T,notUseTokenAccount:T,associatedOnly:!1,checkCreateATAOwner:y});x.addInstruction(C||{});let{account:M,instructionParams:V}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:t.mintB.programId,mint:new X(t.mintB.address),owner:this.scope.ownerPubKey,createInfo:w||(r?I:o).isZero()?{payer:this.scope.ownerPubKey,amount:r?I:o}:void 0,skipCloseAccount:!w,notUseTokenAccount:w,associatedOnly:!1,checkCreateATAOwner:y});x.addInstruction(V||{}),!B&&!M&&this.logAndCreateError("cannot found target token accounts","tokenAccounts",d.tokenAccounts);let R=await d.getCreatedTokenAccount({mint:new X(t.lpMint.address)}),ae=await d.handleTokenAccount({side:"out",amount:0,mint:new X(t.lpMint.address),tokenAccount:R,bypassAssociatedCheck:f,checkCreateATAOwner:y}),{tokenAccount:L}=ae,W=qe(ae,["tokenAccount"]);x.addInstruction(W);let z=n!=null?n:await this.getCpmmPoolKeys(t.id),$=new ze(new He(1)).sub(i);return x.addInstruction({instructions:[Vl(new X(t.programId),this.scope.ownerPubKey,new X(z.authority),new X(t.id),L,B,M,new X(z.vault.A),new X(z.vault.B),S,K,new X(t.lpMint.address),a?a==null?void 0:a.liquidity:$.mul(g).quotient,r?P.amount:I,r?I:P.amount)],instructionTypes:[U.CpmmAddLiquidity],lookupTableAddress:z.lookupTableAccount?[z.lookupTableAccount]:[]}),x.addCustomComputeBudget(c),x.addTipInstruction(u),x.versionBuild({txVersion:m})}async withdrawLiquidity(e){var W,z;let{poolInfo:t,poolKeys:n,lpAmount:o,slippage:r,computeBudgetConfig:i,txTipConfig:a,txVersion:c,feePayer:u,closeWsol:l=!0}=e;this.scope.availability.addStandardPosition===!1&&this.logAndCreateError("add liquidity feature disabled in your region");let m=new ze(new He(1)).sub(r),p=await this.getRpcPoolInfo(t.id),[d,f]=[m.mul(o.mul(p.baseReserve).div(p.lpAmount)).quotient,m.mul(o.mul(p.quoteReserve).div(p.lpAmount)).quotient],y=await this.scope.fetchEpochInfo(),[b,g]=[Be(d,t.mintA.extensions.feeConfig,y,!1),Be(f,t.mintB.extensions.feeConfig,y,!1)],{account:P}=this.scope,h=this.createTxBuilder(u),[I,T]=[new X(t.mintA.address),new X(t.mintB.address)],w=I.equals(H),x=T.equals(H),S,K,{account:B,instructionParams:C}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:t.mintA.programId,mint:new X(t.mintA.address),notUseTokenAccount:w,owner:this.scope.ownerPubKey,createInfo:{payer:this.scope.ownerPubKey,amount:0},skipCloseAccount:!(w&&l),associatedOnly:!w,checkCreateATAOwner:!1});S=B,C&&h.addInstruction(C);let{account:M,instructionParams:V}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:t.mintB.programId,mint:new X(t.mintB.address),notUseTokenAccount:x,owner:this.scope.ownerPubKey,createInfo:{payer:this.scope.ownerPubKey,amount:0},skipCloseAccount:!(x&&l),associatedOnly:!x,checkCreateATAOwner:!1});K=M,V&&h.addInstruction(V),(!S||!K)&&this.logAndCreateError("cannot found target token accounts","tokenAccounts",P.tokenAccounts);let R=await P.getCreatedTokenAccount({mint:new X(t.lpMint.address)});R||this.logAndCreateError("cannot found lp token account","tokenAccounts",P.tokenAccounts);let L=n!=null?n:await this.getCpmmPoolKeys(t.id);return h.addInstruction({instructions:[_l(new X(t.programId),this.scope.ownerPubKey,new X(L.authority),new X(t.id),R,S,K,new X(L.vault.A),new X(L.vault.B),I,T,new X(t.lpMint.address),o,d.sub((W=b.fee)!=null?W:new He(0)),f.sub((z=g.fee)!=null?z:new He(0)))],instructionTypes:[U.CpmmWithdrawLiquidity],lookupTableAddress:L.lookupTableAccount?[L.lookupTableAccount]:[]}),h.addCustomComputeBudget(i),h.addTipInstruction(a),h.versionBuild({txVersion:c})}async swap(e){var C,M,V,R,L,W;let{poolInfo:t,poolKeys:n,baseIn:o,fixedOut:r,inputAmount:i,swapResult:a,slippage:c=0,config:u,computeBudgetConfig:l,txTipConfig:m,txVersion:p,feePayer:d}=e,{bypassAssociatedCheck:f,checkCreateATAOwner:y,associatedOnly:b}=N({bypassAssociatedCheck:!1,checkCreateATAOwner:!1,associatedOnly:!0},u),g=this.createTxBuilder(d),[P,h]=[new X(t.mintA.address),new X(t.mintB.address)];r?a.sourceAmountSwapped=a.sourceAmountSwapped.mul(new He((1+c)*1e4)).div(new He(1e4)):a.destinationAmountSwapped=a.destinationAmountSwapped.mul(new He((1-c)*1e4)).div(new He(1e4));let I=t.mintA.address===H.toBase58(),T=t.mintB.address===H.toBase58(),{account:w,instructionParams:x}=await this.scope.account.getOrCreateTokenAccount({mint:P,tokenProgram:new X((C=t.mintA.programId)!=null?C:_t),owner:this.scope.ownerPubKey,createInfo:I||!o?{payer:this.scope.ownerPubKey,amount:o?a.sourceAmountSwapped:0}:void 0,notUseTokenAccount:I,skipCloseAccount:!I,associatedOnly:I?!1:b,checkCreateATAOwner:y});x&&g.addInstruction(x);let{account:S,instructionParams:K}=await this.scope.account.getOrCreateTokenAccount({mint:h,tokenProgram:new X((M=t.mintB.programId)!=null?M:_t),owner:this.scope.ownerPubKey,createInfo:T||o?{payer:this.scope.ownerPubKey,amount:o?0:a.sourceAmountSwapped}:void 0,notUseTokenAccount:T,skipCloseAccount:!T,associatedOnly:T?!1:b,checkCreateATAOwner:y});K&&g.addInstruction(K),(!w||!S)&&this.logAndCreateError("user do not have token account",{mintA:t.mintA.symbol||t.mintA.address,mintB:t.mintB.symbol||t.mintB.address,mintATokenAcc:w,mintBTokenAcc:S,mintAUseSOLBalance:I,mintBUseSOLBalance:T,associatedOnly:b});let B=n!=null?n:await this.getCpmmPoolKeys(t.id);return g.addInstruction({instructions:[r?El(new X(t.programId),this.scope.ownerPubKey,new X(B.authority),new X(B.config.id),new X(t.id),o?w:S,o?S:w,new X(B.vault[o?"A":"B"]),new X(B.vault[o?"B":"A"]),new X((L=t[o?"mintA":"mintB"].programId)!=null?L:_t),new X((W=t[o?"mintB":"mintA"].programId)!=null?W:_t),o?P:h,o?h:P,Di(new X(t.programId),new X(t.id)).publicKey,a.sourceAmountSwapped,a.destinationAmountSwapped):Jr(new X(t.programId),this.scope.ownerPubKey,new X(B.authority),new X(B.config.id),new X(t.id),o?w:S,o?S:w,new X(B.vault[o?"A":"B"]),new X(B.vault[o?"B":"A"]),new X((V=t[o?"mintA":"mintB"].programId)!=null?V:_t),new X((R=t[o?"mintB":"mintA"].programId)!=null?R:_t),o?P:h,o?h:P,Di(new X(t.programId),new X(t.id)).publicKey,i,a.destinationAmountSwapped)],instructionTypes:[r?U.CpmmSwapBaseOut:U.ClmmSwapBaseIn]}),g.addCustomComputeBudget(l),g.addTipInstruction(m),g.versionBuild({txVersion:p})}async lockLp(e){var p,d,f,y,b;let{poolInfo:t,lpAmount:n,computeBudgetConfig:o,txTipConfig:r,txVersion:i,feePayer:a,feeNftOwner:c}=e;n.isZero()&&this.logAndCreateError("lpAmount must greater than zero",{lpAmount:n.toString()});let u=this.createTxBuilder(a),l=(p=e.poolKeys)!=null?p:await this.getCpmmPoolKeys(t.id),m=await Dl({poolInfo:t,poolKeys:l,ownerInfo:{wallet:this.scope.ownerPubKey,feePayer:(d=e.feePayer)!=null?d:this.scope.ownerPubKey},feeNftOwner:c!=null?c:this.scope.ownerPubKey,lockProgram:(f=e.programId)!=null?f:ii,lockAuthProgram:(y=e.authProgram)!=null?y:ri,lpAmount:n,withMetadata:(b=e.withMetadata)!=null?b:!0,getEphemeralSigners:e.getEphemeralSigners});return u.addInstruction(m),u.addCustomComputeBudget(o),u.addTipInstruction(r),u.versionBuild({txVersion:i,extInfo:m.address})}async harvestLockLp(e){var M;let{poolInfo:t,lpFeeAmount:n,nftMint:o,programId:r=ii,authProgram:i=ri,cpmmProgram:a,computeBudgetConfig:c,txTipConfig:u,txVersion:l,closeWsol:m=!0}=e;n.isZero()&&this.logAndCreateError("lpFeeAmount must greater than zero",{lpAmount:n.toString()});let p=e.feePayer||this.scope.ownerPubKey,d=this.createTxBuilder(p),[f,y]=[new X(t.mintA.address),new X(t.mintB.address)],b=f.equals(H),g=y.equals(H),P,h,{account:I,instructionParams:T}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:t.mintA.programId,mint:new X(t.mintA.address),notUseTokenAccount:b,owner:this.scope.ownerPubKey,createInfo:{payer:this.scope.ownerPubKey,amount:0},skipCloseAccount:!(b&&m),associatedOnly:!b,checkCreateATAOwner:!1});P=I,T&&d.addInstruction(T);let{account:w,instructionParams:x}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:t.mintB.programId,mint:new X(t.mintB.address),notUseTokenAccount:g,owner:this.scope.ownerPubKey,createInfo:{payer:this.scope.ownerPubKey,amount:0},skipCloseAccount:!(g&&m),associatedOnly:!g,checkCreateATAOwner:!1});h=w,x&&d.addInstruction(x),(!P||!h)&&this.logAndCreateError("cannot found target token accounts",{tokenAccountA:P,tokenAccountB:h});let S=(M=e.poolKeys)!=null?M:await this.getCpmmPoolKeys(t.id),{publicKey:K}=j(p,o,_t),{publicKey:B}=Wi(r,o),{publicKey:C}=j(i,new X(t.lpMint.address),_t);return d.addInstruction({instructions:[ou({programId:r,nftOwner:this.scope.ownerPubKey,auth:i,nftMint:o,nftAccount:K,lockPda:B,poolId:new X(t.id),mintLp:new X(S.mintLp.address),userVaultA:P,userVaultB:h,poolVaultA:new X(S.vault.A),poolVaultB:new X(S.vault.B),mintA:f,mintB:y,lockLpVault:C,lpFeeAmount:n,cpmmProgram:a==null?void 0:a.programId,cpmmAuthProgram:a==null?void 0:a.authProgram})],instructionTypes:[U.CpmmCollectLockFee]}),d.addCustomComputeBudget(c),d.addTipInstruction(u),d.versionBuild({txVersion:l})}async harvestMultiLockLp(e){let{lockInfo:t,programId:n=ii,authProgram:o=ri,cpmmProgram:r,computeBudgetConfig:i,txVersion:a,closeWsol:c=!0}=e,u=e.feePayer||this.scope.ownerPubKey,l=this.createTxBuilder(u),m={};return t.forEach(async p=>{var B;let{poolInfo:d,lpFeeAmount:f,nftMint:y}=p;if(f.isZero())return;let[b,g]=[new X(d.mintA.address),new X(d.mintB.address)],P=b.equals(H),h=g.equals(H),I=m[d.mintA.address],T=m[d.mintB.address];if(!I)if(P){let{account:C,instructionParams:M}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:d.mintA.programId,mint:new X(d.mintA.address),notUseTokenAccount:!0,owner:this.scope.ownerPubKey,createInfo:{payer:this.scope.ownerPubKey,amount:0},skipCloseAccount:!c,associatedOnly:!1,checkCreateATAOwner:!1});I=C,M&&l.addInstruction(M),m[d.mintA.address]=C}else{let C=new X(d.mintA.address);I=this.scope.account.getAssociatedTokenAccount(C,new X(d.mintA.programId)),l.addInstruction({instructions:[ql(this.scope.ownerPubKey,I,this.scope.ownerPubKey,C)]}),m[d.mintA.address]=I}if(!T)if(h){let{account:C,instructionParams:M}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:d.mintB.programId,mint:new X(d.mintB.address),notUseTokenAccount:!0,owner:this.scope.ownerPubKey,createInfo:{payer:this.scope.ownerPubKey,amount:0},skipCloseAccount:!c,associatedOnly:!1,checkCreateATAOwner:!1});T=C,M&&l.addInstruction(M),m[d.mintB.address]=C}else{let C=new X(d.mintB.address);T=this.scope.account.getAssociatedTokenAccount(C,new X(d.mintB.programId)),l.addInstruction({instructions:[ql(this.scope.ownerPubKey,T,this.scope.ownerPubKey,C)]}),m[d.mintB.address]=T}(!I||!T)&&this.logAndCreateError("cannot found target token accounts",{tokenAccountA:I,tokenAccountB:T});let w=(B=p.poolKeys)!=null?B:await this.getCpmmPoolKeys(d.id),{publicKey:x}=j(u,y,_t),{publicKey:S}=Wi(n,y),{publicKey:K}=j(o,new X(d.lpMint.address),_t);l.addInstruction({instructions:[ou({programId:n,nftOwner:this.scope.ownerPubKey,auth:o,nftMint:y,nftAccount:x,lockPda:S,poolId:new X(d.id),mintLp:new X(w.mintLp.address),userVaultA:I,userVaultB:T,poolVaultA:new X(w.vault.A),poolVaultB:new X(w.vault.B),mintA:b,mintB:g,lockLpVault:K,lpFeeAmount:f,cpmmProgram:r==null?void 0:r.programId,cpmmAuthProgram:r==null?void 0:r.authProgram})],instructionTypes:[U.CpmmCollectLockFee]})}),a===0?l.sizeCheckBuildV0({computeBudgetConfig:i}):l.sizeCheckBuild({computeBudgetConfig:i})}computeSwapAmount({pool:e,amountIn:t,outputMint:n,slippage:o}){let r=n.toString()===e.mintB.address,i=$r.swap(t,r?e.baseReserve:e.quoteReserve,r?e.quoteReserve:e.baseReserve,e.configInfo.tradeFeeRate),a=new zt(i.destinationAmountSwapped.toString()).div(i.sourceAmountSwapped.toString()),c=i.destinationAmountSwapped.mul(new He((1-o)*1e4)).div(new He(1e4));return{allTrade:i.sourceAmountSwapped.eq(t),amountIn:t,amountOut:i.destinationAmountSwapped,minAmountOut:c,executionPrice:a,fee:i.tradeFee,priceImpact:e.poolPrice.sub(a).div(e.poolPrice)}}computePairAmount({poolInfo:e,baseReserve:t,quoteReserve:n,amount:o,slippage:r,epochInfo:i,baseIn:a}){var I,T,w,x,S,K,B,C,M;let c=1-Number(r.toSignificant())/100,u=new He(new zt(o).mul(10**e[a?"mintA":"mintB"].decimals).mul(c).toFixed(0)),l=Be(u,e[a?"mintA":"mintB"].extensions.feeConfig,i,!1),m=u.sub((I=l.fee)!=null?I:new He(0)),p=new He(new zt(e.lpAmount).mul(10**e.lpMint.decimals).toFixed(0,zt.ROUND_DOWN));this.logDebug("baseReserve:",t.toString(),"quoteReserve:",n.toString()),this.logDebug("tokenIn:",a?e.mintA.symbol:e.mintB.symbol,"amountIn:",u.toString(),"amountInFee:",(w=(T=l.fee)==null?void 0:T.toString())!=null?w:0,"anotherToken:",a?e.mintB.symbol:e.mintA.symbol,"slippage:",`${r.toSignificant()}%`);let d=a?"base":"quote";this.logDebug("input side:",d);let f=m.mul(p).div(d==="base"?t:n),y={amount:Je,fee:void 0,expirationTime:void 0};if(!m.isZero()){let V=Hf(f,t,n,p);this.logDebug("lpAmountData:",{amountA:V.amountA.toString(),amountB:V.amountB.toString()}),y=Be(V[a?"amountB":"amountA"],e[a?"mintB":"mintA"].extensions.feeConfig,i,!0)}let b=new ze(new He(1)).add(r),g=new ze(new He(1)).sub(r),P=Be(b.mul(y.amount.sub((x=y.fee)!=null?x:new He(0))).quotient,e[a?"mintB":"mintA"].extensions.feeConfig,i,!0),h=Be(g.mul(y.amount.sub((S=y.fee)!=null?S:new He(0))).quotient,e[a?"mintB":"mintA"].extensions.feeConfig,i,!0);return this.logDebug("anotherAmount:",y.amount.toString(),"anotherAmountFee:",(B=(K=y.fee)==null?void 0:K.toString())!=null?B:0,"maxAnotherAmount:",P.amount.toString(),"maxAnotherAmountFee:",(M=(C=P.fee)==null?void 0:C.toString())!=null?M:0),{inputAmountFee:l,anotherAmount:y,maxAnotherAmount:P,minAnotherAmount:h,liquidity:f}}};function Hf(s,e,t,n){let o=s.mul(e).div(n);!o.isZero()&&!s.mul(e).mod(n).isZero()&&(o=o.add(new He(1)));let r=s.mul(t).div(n);return!r.isZero()&&!s.mul(t).mod(n).isZero()&&(r=r.add(new He(1))),{amountA:o,amountB:r}}import{PublicKey as po}from"@solana/web3.js";import{createTransferInstruction as Yl,TOKEN_PROGRAM_ID as Ze,TOKEN_2022_PROGRAM_ID as ia}from"@solana/spl-token";import ra from"bn.js";import zi from"decimal.js";var Ul={[Ar.toBase58()]:3},Gl={3:Ar};var iu=v([xe(5),xe(8),O("ownAddress"),k("vaultSignerNonce"),O("baseMint"),O("quoteMint"),O("baseVault"),k("baseDepositsTotal"),k("baseFeesAccrued"),O("quoteVault"),k("quoteDepositsTotal"),k("quoteFeesAccrued"),k("quoteDustThreshold"),O("requestQueue"),O("eventQueue"),O("bids"),O("asks"),k("baseLotSize"),k("quoteLotSize"),k("feeRateBps"),k("referrerRebatesAccrued"),xe(7)]),Xl={3:iu};import{PublicKey as zl}from"@solana/web3.js";var na=fe("Serum"),oa=class{static getProgramId(e){let t=Gl[e];return t||na.logWithError("invalid version","version",e),t}static getVersion(e){let t=e.toBase58(),n=Ul[t];return n||na.logWithError("invalid program id","programId",t),n}static getStateLayout(e){let t=Xl[e];return t||na.logWithError(!!t,"invalid version","version",e),t}static getLayouts(e){return{state:this.getStateLayout(e)}}static getAssociatedAuthority({programId:e,marketId:t}){let n=[t.toBuffer()],o=0,r;for(;o<100;){try{let i=n.concat(Buffer.from([o]),Buffer.alloc(7));r=zl.createProgramAddressSync(i,e)}catch(i){if(i instanceof TypeError)throw i;o++;continue}return{publicKey:r,nonce:o}}return na.logWithError("unable to find a viable program address nonce","params",{programId:e,marketId:t}),{publicKey:zl.default,nonce:o}}};import{PublicKey as F,SystemProgram as Gi,TransactionInstruction as Xi}from"@solana/web3.js";import pn from"bn.js";import{ASSOCIATED_TOKEN_PROGRAM_ID as ru,TOKEN_2022_PROGRAM_ID as au,TOKEN_PROGRAM_ID as qn}from"@solana/spl-token";function tC(s,e,t,n,o,r,i,a,c,u,l,m){let p=v([D("instruction"),k("amountIn"),k("amountOut")]),d=[{pubkey:Gi.programId,isSigner:!1,isWritable:!1},{pubkey:qn,isSigner:!1,isWritable:!1},{pubkey:new F(t.programId),isSigner:!1,isWritable:!1},{pubkey:new F(t.id),isSigner:!1,isWritable:!0},{pubkey:new F(n.id),isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!0,isWritable:!1}];if(e.type==="Concentrated"){let y=Fe(t);d.push({pubkey:y.config.id,isSigner:!1,isWritable:!1},{pubkey:y.id,isSigner:!1,isWritable:!0},{pubkey:y.mintA.address.equals(c)?y.vault.A:y.vault.B,isSigner:!1,isWritable:!0},{pubkey:y.mintA.address.equals(c)?y.vault.B:y.vault.A,isSigner:!1,isWritable:!0},{pubkey:y.id,isSigner:!1,isWritable:!0},...m.map(b=>({pubkey:b,isSigner:!1,isWritable:!0})))}else if(e.pooltype.includes("StablePool")){let y=Fe(t);d.push({pubkey:y.authority,isSigner:!1,isWritable:!1},{pubkey:y.marketProgramId,isSigner:!1,isWritable:!1},{pubkey:y.id,isSigner:!1,isWritable:!0},{pubkey:new F("CDSr3ssLcRB6XYPJwAfFt18MZvEZp4LjHcvzBVZ45duo"),isSigner:!1,isWritable:!1},{pubkey:y.openOrders,isSigner:!1,isWritable:!0},{pubkey:y.vault.A,isSigner:!1,isWritable:!0},{pubkey:y.vault.B,isSigner:!1,isWritable:!0},{pubkey:y.marketId,isSigner:!1,isWritable:!0},{pubkey:y.marketBids,isSigner:!1,isWritable:!0},{pubkey:y.marketAsks,isSigner:!1,isWritable:!0},{pubkey:y.marketEventQueue,isSigner:!1,isWritable:!0},{pubkey:y.id,isSigner:!1,isWritable:!0},{pubkey:y.id,isSigner:!1,isWritable:!0})}else{let y=Fe(t);d.push({pubkey:y.authority,isSigner:!1,isWritable:!1},{pubkey:y.marketProgramId,isSigner:!1,isWritable:!1},{pubkey:y.marketAuthority,isSigner:!1,isWritable:!1},{pubkey:y.openOrders,isSigner:!1,isWritable:!0},{pubkey:y.vault.A,isSigner:!1,isWritable:!0},{pubkey:y.vault.B,isSigner:!1,isWritable:!0},{pubkey:y.marketId,isSigner:!1,isWritable:!0},{pubkey:y.marketBids,isSigner:!1,isWritable:!0},{pubkey:y.marketAsks,isSigner:!1,isWritable:!0},{pubkey:y.marketEventQueue,isSigner:!1,isWritable:!0},...y.marketProgramId.toString()==="srmqPvymJeFKQ4zGQed1GFppgkRHL9kaELCbyksJtPX"?[{pubkey:y.marketBaseVault,isSigner:!1,isWritable:!0},{pubkey:y.marketQuoteVault,isSigner:!1,isWritable:!0}]:[{pubkey:y.id,isSigner:!1,isWritable:!0},{pubkey:y.id,isSigner:!1,isWritable:!0}])}let f=Buffer.alloc(p.span);return p.encode({instruction:4,amountIn:u,amountOut:l},f),new Xi({keys:d,programId:s,data:f})}function nC(s,e,t,n,o,r,i,a,c,u){let l=v([D("instruction")]),m=[{pubkey:Gi.programId,isSigner:!1,isWritable:!1},{pubkey:qn,isSigner:!1,isWritable:!1},{pubkey:new F(String(n.programId)),isSigner:!1,isWritable:!1},{pubkey:new F(String(n.id)),isSigner:!1,isWritable:!0},{pubkey:new F(String(t.id)),isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!0,isWritable:!1}];if(e.type==="Concentrated"){let d=Fe(n);m.push({pubkey:d.config.id,isSigner:!1,isWritable:!1},{pubkey:d.id,isSigner:!1,isWritable:!0},{pubkey:d.mintA.address.equals(c)?d.vault.A:d.vault.B,isSigner:!1,isWritable:!0},{pubkey:d.mintA.address.equals(c)?d.vault.B:d.vault.A,isSigner:!1,isWritable:!0},{pubkey:d.id,isSigner:!1,isWritable:!0},...u.map(f=>({pubkey:f,isSigner:!1,isWritable:!0})))}else if(e.pooltype.includes("StablePool")){let d=Fe(n);m.push({pubkey:d.authority,isSigner:!1,isWritable:!1},{pubkey:d.marketProgramId,isSigner:!1,isWritable:!1},{pubkey:d.id,isSigner:!1,isWritable:!0},{pubkey:new F("CDSr3ssLcRB6XYPJwAfFt18MZvEZp4LjHcvzBVZ45duo"),isSigner:!1,isWritable:!1},{pubkey:d.openOrders,isSigner:!1,isWritable:!0},{pubkey:d.vault.A,isSigner:!1,isWritable:!0},{pubkey:d.vault.B,isSigner:!1,isWritable:!0},{pubkey:d.marketId,isSigner:!1,isWritable:!0},{pubkey:d.marketBids,isSigner:!1,isWritable:!0},{pubkey:d.marketAsks,isSigner:!1,isWritable:!0},{pubkey:d.marketEventQueue,isSigner:!1,isWritable:!0},{pubkey:d.id,isSigner:!1,isWritable:!0},{pubkey:d.id,isSigner:!1,isWritable:!0})}else{let d=Fe(n);m.push({pubkey:d.authority,isSigner:!1,isWritable:!1},{pubkey:d.marketProgramId,isSigner:!1,isWritable:!1},{pubkey:d.marketAuthority,isSigner:!1,isWritable:!1},{pubkey:d.openOrders,isSigner:!1,isWritable:!0},{pubkey:d.vault.A,isSigner:!1,isWritable:!0},{pubkey:d.vault.B,isSigner:!1,isWritable:!0},{pubkey:d.marketId,isSigner:!1,isWritable:!0},{pubkey:d.marketBids,isSigner:!1,isWritable:!0},{pubkey:d.marketAsks,isSigner:!1,isWritable:!0},{pubkey:d.marketEventQueue,isSigner:!1,isWritable:!0},...d.marketProgramId.toString()==="srmqPvymJeFKQ4zGQed1GFppgkRHL9kaELCbyksJtPX"?[{pubkey:d.marketBaseVault,isSigner:!1,isWritable:!0},{pubkey:d.marketQuoteVault,isSigner:!1,isWritable:!0}]:[{pubkey:d.id,isSigner:!1,isWritable:!0},{pubkey:d.id,isSigner:!1,isWritable:!0}])}let p=Buffer.alloc(l.span);return l.encode({instruction:5},p),new Xi({keys:m,programId:s,data:p})}function Zf(s,e,t,n,o,r,i,a,c,u,l,m,p,d,f){var w;let y=[],b=[A({pubkey:qn,isWritable:!1}),A({pubkey:au,isWritable:!1}),A({pubkey:ru,isWritable:!1}),A({pubkey:Gi.programId,isWritable:!1}),A({pubkey:e,isSigner:!0})];b.push(A({pubkey:t})),b.push(A({pubkey:o}));let g=[c,u],P=[l,m],h=[r,i,a];for(let x=0;x<g.length;x++){let S=g[x],K=h[x]===S.mintA.address;if(b.push(A({pubkey:new F(S.programId),isWritable:!1})),x===g.length-1?b.push(A({pubkey:o})):b.push(A({pubkey:n})),b.push(A({pubkey:new F(h[x])})),b.push(A({pubkey:new F(h[x+1])})),S.version===6){let B=P[x];b.push(A({pubkey:new F(B.config.id)})),b.push(A({pubkey:new F(B.id)})),b.push(A({pubkey:new F(K?B.vault.A:B.vault.B)})),b.push(A({pubkey:new F(K?B.vault.B:B.vault.A)})),b.push(A({pubkey:new F(S.observationId)})),b.push(A({pubkey:ln})),b.push(A({pubkey:je(new F(S.programId),new F(S.id)).publicKey})),y.push(su(S.sqrtPriceX64.toString(),K));for(let C of(w=f[x])!=null?w:[])b.push(A({pubkey:new F(C)}))}else if(S.version===5){let B=P[x];b.push(A({pubkey:new F(B.id)})),b.push(A({pubkey:new F(B.authority),isWritable:!1})),b.push(A({pubkey:new F(B.marketProgramId)})),b.push(A({pubkey:new F(B.marketAuthority)})),b.push(A({pubkey:Pr,isWritable:!1})),b.push(A({pubkey:new F(B.openOrders)})),b.push(A({pubkey:new F(B.vault.A)})),b.push(A({pubkey:new F(B.vault.B)})),b.push(A({pubkey:new F(B.id)})),b.push(A({pubkey:new F(B.id)})),b.push(A({pubkey:new F(B.id)})),b.push(A({pubkey:new F(B.id)})),b.push(A({pubkey:new F(B.id)})),b.push(A({pubkey:new F(B.id)})),b.push(A({pubkey:new F(B.marketId)})),b.push(A({pubkey:new F(B.marketBids)})),b.push(A({pubkey:new F(B.marketAsks)})),b.push(A({pubkey:new F(B.marketEventQueue)})),b.push(A({pubkey:new F(B.marketBaseVault)})),b.push(A({pubkey:new F(B.marketQuoteVault)}))}else if(S.version===4){let B=P[x],C=S.status!==1;b.push(A({pubkey:new F(B.id)})),b.push(A({pubkey:new F(B.authority),isWritable:!1})),b.push(A({pubkey:new F(C?B.id:B.marketProgramId)})),b.push(A({pubkey:new F(C?B.id:B.marketAuthority)})),b.push(A({pubkey:new F(C?B.id:B.openOrders)})),b.push(A({pubkey:new F(B.vault.A)})),b.push(A({pubkey:new F(B.vault.B)})),b.push(A({pubkey:new F(C?B.id:B.marketId)})),b.push(A({pubkey:new F(C?B.id:B.marketBids)})),b.push(A({pubkey:new F(C?B.id:B.marketAsks)})),b.push(A({pubkey:new F(C?B.id:B.marketEventQueue)})),b.push(A({pubkey:new F(C?B.id:B.marketBaseVault)})),b.push(A({pubkey:new F(C?B.id:B.marketQuoteVault)}))}else if(S.version===7){let B=P[x];b.push(A({pubkey:new F(B.authority)})),b.push(A({pubkey:new F(B.config.id)})),b.push(A({pubkey:new F(B.id)})),b.push(A({pubkey:new F(K?B.vault.A:B.vault.B)})),b.push(A({pubkey:new F(K?B.vault.B:B.vault.A)})),b.push(A({pubkey:new F(S.observationId)}))}else throw Error("pool type error")}let I=v([D("insId"),k("amountIn"),k("amountOut"),Q(te(),y.length,"clmmPriceLimit")]),T=Buffer.alloc(I.span);return I.encode({insId:0,amountIn:p,amountOut:d,clmmPriceLimit:y},T),new Xi({keys:b,programId:s,data:T})}function su(s,e){if(s)if(e){let t=new pn(s).div(new pn(25));return t.gt(Mr)?t:Mr}else{let t=new pn(s).mul(new pn(25));return t.lt(vr)?t:vr}else return e?Mr:vr}function Ql({routeProgram:s,ownerInfo:e,inputMint:t,swapInfo:n}){var o,r,i,a,c,u,l;if(n.routeType==="amm")if(n.poolInfo[0].version===6){let m=n.poolKey[0],p=Fe(m),d=t.equals(p.mintA.address)?Gt.add(vt):Xt.sub(vt);return Le.makeSwapBaseInInstructions({poolInfo:m,poolKeys:m,observationId:n.poolInfo[0].observationId,ownerInfo:{wallet:e.wallet,tokenAccountA:p.mintA.address.equals(t)?e.sourceToken:e.destinationToken,tokenAccountB:p.mintA.address.equals(t)?e.destinationToken:e.sourceToken},inputMint:t,amountIn:n.amountIn.amount.raw,amountOutMin:n.minAmountOut.amount.raw.sub((r=(o=n.minAmountOut.fee)==null?void 0:o.raw)!=null?r:new pn(0)),sqrtPriceLimitX64:d,remainingAccounts:(i=n.remainingAccounts[0])!=null?i:[]})}else if(n.poolInfo[0].version===7){let m=n.poolInfo[0],p=t.toString()===n.poolInfo[0].mintA.address;return{signers:[],instructions:[Jr(m.programId,e.wallet,m.authority,m.configId,m.id,e.sourceToken,e.destinationToken,p?m.vaultA:m.vaultB,p?m.vaultB:m.vaultA,p?m.mintProgramA:m.mintProgramB,p?m.mintProgramB:m.mintProgramA,new F(m[p?"mintA":"mintB"].address),new F(m[p?"mintB":"mintA"].address),m.observationId,n.amountIn.amount.raw,n.minAmountOut.amount.raw)],lookupTableAddress:[],instructionTypes:[p?U.CpmmSwapBaseIn:U.CpmmSwapBaseOut],address:{}}}else{let m=n.poolKey[0];return{signers:[],instructions:[qr({poolKeys:m,version:n.poolInfo[0].pooltype.includes("StablePool")?5:4,userKeys:{tokenAccountIn:e.sourceToken,tokenAccountOut:e.destinationToken,owner:e.wallet},amountIn:n.amountIn.amount.raw,amountOut:n.minAmountOut.amount.raw.sub((c=(a=n.minAmountOut.fee)==null?void 0:a.raw)!=null?c:new pn(0)),fixedSide:"in"})],lookupTableAddress:m.lookupTableAccount?[m.lookupTableAccount]:[],instructionTypes:[n.poolInfo[0].pooltype.includes("StablePool")?U.AmmV5SwapBaseIn:U.AmmV4SwapBaseIn],address:{}}}else if(n.routeType==="route"){let m=n.poolInfo[0],p=n.poolInfo[1],d=n.poolKey[0],f=n.poolKey[1];if(e.routeToken===void 0)throw Error("owner route token account check error");return{signers:[],instructions:[Zf(s,e.wallet,e.sourceToken,e.routeToken,e.destinationToken,t.toString(),n.middleToken.mint.toString(),n.outputMint.toString(),m,p,d,f,n.amountIn.amount.raw,n.minAmountOut.amount.raw.sub((l=(u=n.minAmountOut.fee)==null?void 0:u.raw)!=null?l:new pn(0)),n.remainingAccounts)],instructionTypes:[U.RouteSwap],lookupTableAddress:[d.lookupTableAccount,f.lookupTableAccount].filter(y=>y!==void 0),address:{}}}else throw Error("route type error")}function oC({programId:s,wallet:e,amount:t,inputAccount:n,outputAccount:o,routeInfo:r,poolKeys:i}){var p;if(r.success===!1)throw Error("route info error");let a=[],c=[A({pubkey:qn,isWritable:!1}),A({pubkey:au,isWritable:!1}),A({pubkey:ru,isWritable:!1}),A({pubkey:Gi.programId,isWritable:!1}),A({pubkey:e,isSigner:!0})],u={[r.data.inputMint]:n,[r.data.outputMint]:o};c.push(A({pubkey:u[r.data.inputMint]})),c.push(A({pubkey:u[r.data.outputMint]}));for(let d=0;d<i.length;d++){let f=r.data.routePlan[d],y=i[d],b=f.inputMint===y.mintA.address;if(c.push(A({pubkey:new F(y.programId),isWritable:!1})),d===i.length-1)c.push(A({pubkey:u[f.outputMint]}));else{let g=f.outputMint;if(u[g]===void 0){let P=j(e,new F(g),y.programId===wt.CLMM_PROGRAM_ID.toBase58()||y.programId===wt.CREATE_CPMM_POOL_PROGRAM.toBase58()?new F(b?y.mintB.programId:y.mintA.programId):qn).publicKey;u[g]=P}c.push(A({pubkey:u[g]}))}if(c.push(A({pubkey:new F(f.inputMint)})),c.push(A({pubkey:new F(f.outputMint)})),y.programId===wt.CLMM_PROGRAM_ID.toBase58()){let g=y;c.push(A({pubkey:new F(g.config.id)})),c.push(A({pubkey:new F(g.id)})),c.push(A({pubkey:new F(b?g.vault.A:g.vault.B)})),c.push(A({pubkey:new F(b?g.vault.B:g.vault.A)})),c.push(A({pubkey:new F(g.observationId)})),c.push(A({pubkey:ln,isWritable:!1})),c.push(A({pubkey:new F(g.exBitmapAccount)})),a.push(su(f.lastPoolPriceX64,b));for(let P of(p=f.remainingAccounts)!=null?p:[])c.push(A({pubkey:new F(P)}))}else if(y.programId===wt.AMM_STABLE.toBase58()){let g=y;c.push(A({pubkey:new F(g.id)})),c.push(A({pubkey:new F(g.authority),isWritable:!1})),c.push(A({pubkey:new F(g.marketProgramId),isWritable:!1})),c.push(A({pubkey:new F(g.marketAuthority),isWritable:!1})),c.push(A({pubkey:Pr,isWritable:!1})),c.push(A({pubkey:new F(g.openOrders)})),c.push(A({pubkey:new F(g.vault.A)})),c.push(A({pubkey:new F(g.vault.B)})),c.push(A({pubkey:new F(g.marketId)})),c.push(A({pubkey:new F(g.marketBids)})),c.push(A({pubkey:new F(g.marketAsks)})),c.push(A({pubkey:new F(g.marketEventQueue)})),c.push(A({pubkey:new F(g.marketBaseVault)})),c.push(A({pubkey:new F(g.marketQuoteVault)}))}else if(y.programId===wt.AMM_V4.toBase58()){let g=y;c.push(A({pubkey:new F(g.id)})),c.push(A({pubkey:new F(g.authority),isWritable:!1})),c.push(A({pubkey:new F(g.id)})),c.push(A({pubkey:new F(g.id)})),c.push(A({pubkey:new F(g.id)})),c.push(A({pubkey:new F(g.vault.A)})),c.push(A({pubkey:new F(g.vault.B)})),c.push(A({pubkey:new F(g.id)})),c.push(A({pubkey:new F(g.id)})),c.push(A({pubkey:new F(g.id)})),c.push(A({pubkey:new F(g.id)})),c.push(A({pubkey:new F(g.id)})),c.push(A({pubkey:new F(g.id)}))}else if(y.programId===wt.CREATE_CPMM_POOL_PROGRAM.toBase58()){let g=y;c.push(A({pubkey:new F(g.authority)})),c.push(A({pubkey:new F(g.config.id)})),c.push(A({pubkey:new F(g.id)})),c.push(A({pubkey:new F(b?g.vault.A:g.vault.B)})),c.push(A({pubkey:new F(b?g.vault.B:g.vault.A)})),c.push(A({pubkey:new F(g.observationId)}))}else throw Error("pool type error")}let l=v([D("insId"),k("amountIn"),k("amountOut"),Q(te(),a.length,"clmmPriceLimit")]),m=Buffer.alloc(l.span);return l.encode({insId:0,amountIn:t,amountOut:new pn(r.data.otherAmountThreshold),clmmPriceLimit:a},m),new Xi({keys:c,programId:s,data:m})}function iC({programId:s,wallet:e,inputAccount:t,outputAccount:n,routeInfo:o,poolKeys:r}){var m;if(o.success===!1)throw Error("route info error");let i=[],a=[A({pubkey:qn,isWritable:!1}),A({pubkey:au,isWritable:!1}),A({pubkey:ru,isWritable:!1}),A({pubkey:Gi.programId,isWritable:!1}),A({pubkey:e,isSigner:!0})],c={[o.data.inputMint]:t,[o.data.outputMint]:n};for(let p=r.length-1;p>=0;p--){let d=o.data.routePlan[p],f=r[p],y=d.inputMint===f.mintA.address;if(a.push(A({pubkey:new F(f.programId)})),p===0)a.push(A({pubkey:c[d.inputMint]}));else{let b=d.inputMint;if(c[b]===void 0){let g=j(e,new F(b),f.programId===wt.CLMM_PROGRAM_ID.toBase58()||f.programId===wt.CREATE_CPMM_POOL_PROGRAM.toBase58()?new F(y?f.mintA.programId:f.mintB.programId):qn).publicKey;c[b]=g}a.push(A({pubkey:c[b]}))}if(p===r.length-1)a.push(A({pubkey:c[d.outputMint]}));else{let b=d.outputMint;if(c[b]===void 0){let g=j(e,new F(b),f.programId===wt.CLMM_PROGRAM_ID.toBase58()||f.programId===wt.CREATE_CPMM_POOL_PROGRAM.toBase58()?new F(y?f.mintB.programId:f.mintA.programId):qn).publicKey;c[b]=g}a.push(A({pubkey:c[b]}))}if(a.push(A({pubkey:new F(d.inputMint)})),a.push(A({pubkey:new F(d.outputMint)})),f.programId===wt.CLMM_PROGRAM_ID.toBase58()){let b=f;a.push(A({pubkey:new F(b.config.id)})),a.push(A({pubkey:new F(b.id)})),a.push(A({pubkey:new F(y?b.vault.A:b.vault.B)})),a.push(A({pubkey:new F(y?b.vault.B:b.vault.A)})),a.push(A({pubkey:new F(b.observationId)})),a.push(A({pubkey:ln,isWritable:!1})),a.push(A({pubkey:new F(b.exBitmapAccount)})),i.push(su(d.lastPoolPriceX64,y));for(let g of(m=d.remainingAccounts)!=null?m:[])a.push(A({pubkey:new F(g)}))}else if(f.programId===wt.AMM_STABLE.toBase58()){let b=f;a.push(A({pubkey:new F(b.id)})),a.push(A({pubkey:new F(b.authority),isWritable:!1})),a.push(A({pubkey:new F(b.marketProgramId),isWritable:!1})),a.push(A({pubkey:new F(b.marketAuthority),isWritable:!1})),a.push(A({pubkey:Pr,isWritable:!1})),a.push(A({pubkey:new F(b.openOrders)})),a.push(A({pubkey:new F(b.vault.A)})),a.push(A({pubkey:new F(b.vault.B)})),a.push(A({pubkey:new F(b.marketId)})),a.push(A({pubkey:new F(b.marketBids)})),a.push(A({pubkey:new F(b.marketAsks)})),a.push(A({pubkey:new F(b.marketEventQueue)})),a.push(A({pubkey:new F(b.marketBaseVault)})),a.push(A({pubkey:new F(b.marketQuoteVault)}))}else if(f.programId===wt.AMM_V4.toBase58()){let b=f;a.push(A({pubkey:new F(b.id)})),a.push(A({pubkey:new F(b.authority),isWritable:!1})),a.push(A({pubkey:new F(b.id)})),a.push(A({pubkey:new F(b.id)})),a.push(A({pubkey:new F(b.id)})),a.push(A({pubkey:new F(b.vault.A)})),a.push(A({pubkey:new F(b.vault.B)})),a.push(A({pubkey:new F(b.id)})),a.push(A({pubkey:new F(b.id)})),a.push(A({pubkey:new F(b.id)})),a.push(A({pubkey:new F(b.id)})),a.push(A({pubkey:new F(b.id)})),a.push(A({pubkey:new F(b.id)}))}else if(f.programId===wt.CREATE_CPMM_POOL_PROGRAM.toBase58()){let b=f;a.push(A({pubkey:new F(b.authority)})),a.push(A({pubkey:new F(b.config.id)})),a.push(A({pubkey:new F(b.id)})),a.push(A({pubkey:new F(y?b.vault.A:b.vault.B)})),a.push(A({pubkey:new F(y?b.vault.B:b.vault.A)})),a.push(A({pubkey:new F(b.observationId)}))}else throw Error("pool type error")}let u=v([D("insId"),k("amountIn"),k("amountOut"),Q(te(),i.length,"clmmPriceLimit")]),l=Buffer.alloc(u.span);return u.encode({insId:1,amountIn:new pn(o.data.otherAmountThreshold),amountOut:new pn(o.data.outputAmount),clmmPriceLimit:i},l),new Xi({keys:a,programId:s,data:l})}var Sn=new ra(0),Qi=class extends Ve{constructor(e){super(e)}async getWSolAccounts(){this.scope.checkOwner(),await this.scope.account.fetchWalletTokenAccounts();let e=this.scope.account.tokenAccounts.filter(t=>t.mint.equals(H));return e.sort((t,n)=>t.isAssociated?1:n.isAssociated||t.amount.lt(n.amount)?-1:1),e}async unWrapWSol(e){let{amount:t,tokenProgram:n,txVersion:o=1,feePayer:r}=e,i=await this.getWSolAccounts(),a=this.createTxBuilder(r);a.addCustomComputeBudget(e.computeBudgetConfig);let c=J(t);for(let u=0;u<i.length;u++)c.gte(i[u].amount)?(a.addInstruction({instructions:[wn({tokenAccount:i[u].publicKey,payer:this.scope.ownerPubKey,owner:this.scope.ownerPubKey,programId:n})]}),c.sub(i[u].amount)):a.addInstruction({instructions:[wn({tokenAccount:i[u].publicKey,payer:this.scope.ownerPubKey,owner:this.scope.ownerPubKey,programId:n})]});return a.versionBuild({txVersion:o})}async wrapWSol(e,t,n,o){let r=this.createTxBuilder(o),i=await vn({connection:this.scope.connection,owner:this.scope.ownerPubKey,payer:this.scope.ownerPubKey,amount:e,skipCloseAccount:!0});return r.addInstruction(i),r.versionBuild({txVersion:n!=null?n:1})}async swap({swapInfo:e,swapPoolKeys:t,ownerInfo:n,computeBudgetConfig:o,routeProgram:r,txVersion:i,feePayer:a}){let c=this.createTxBuilder(a),u=e.amountIn,l=e.amountOut,m=u.amount.token.mint.equals(H),p=l.amount.token.mint.equals(H),d=u.amount.token.mint,f=l.amount.token.mint,{account:y,instructionParams:b}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:u.amount.token.isToken2022?ia:Ze,mint:d,notUseTokenAccount:m,owner:this.scope.ownerPubKey,skipCloseAccount:!m,createInfo:m?{payer:this.scope.ownerPubKey,amount:u.amount.raw}:void 0,associatedOnly:m?!1:n.associatedOnly,checkCreateATAOwner:n.checkCreateATAOwner});if(b&&c.addInstruction(b),y===void 0)throw Error("input account check error");let g;if(e.routeType==="route"&&!p)g=this.scope.account.getAssociatedTokenAccount(f,l.amount.token.isToken2022?ia:Ze);else{let{account:T,instructionParams:w}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:l.amount.token.isToken2022?ia:Ze,mint:f,notUseTokenAccount:p,owner:this.scope.ownerPubKey,skipCloseAccount:!0,createInfo:{payer:this.scope.ownerPubKey,amount:0},associatedOnly:p?!1:n.associatedOnly,checkCreateATAOwner:n.checkCreateATAOwner});g=T,w&&c.addInstruction(w)}p&&c.addInstruction({endInstructions:[wn({owner:this.scope.ownerPubKey,payer:this.scope.ownerPubKey,tokenAccount:g,programId:Ze})],endInstructionTypes:[U.CloseAccount]});let P;if(e.routeType==="route"){let T=e.middleToken;P=this.scope.account.getAssociatedTokenAccount(T.mint,T.isToken2022?ia:Ze)}let h=t||await this.computePoolToPoolKeys({pools:e.poolInfoList}),I=Ql({routeProgram:r,inputMint:d,swapInfo:q(N({},e),{poolInfo:[...e.poolInfoList],poolKey:h,outputMint:f}),ownerInfo:{wallet:this.scope.ownerPubKey,sourceToken:y,routeToken:P,destinationToken:g}});if(e.feeConfig!==void 0){let T=this.createTxBuilder();T.addInstruction({instructions:[Yl(y,e.feeConfig.feeAccount,this.scope.ownerPubKey,e.feeConfig.feeAmount.toNumber())],instructionTypes:[U.TransferAmount]}),T.addInstruction(I);let{transactions:w}=i===0?await T.sizeCheckBuildV0():await T.sizeCheckBuild();w.length<2&&c.addInstruction({instructions:[Yl(y,e.feeConfig.feeAccount,this.scope.ownerPubKey,e.feeConfig.feeAmount.toNumber())],instructionTypes:[U.TransferAmount]})}return c.addInstruction(I),i===0?c.sizeCheckBuildV0({computeBudgetConfig:o,address:I.address}):c.sizeCheckBuild({computeBudgetConfig:o,address:I.address})}async fetchRoutePoolBasicInfo(e){let{amm:t=ti,clmm:n=Ln,cpmm:o=oi}=e||{},r=await this.scope.connection.getProgramAccounts(t,{dataSlice:{offset:io.offsetOf("baseMint"),length:64}}),i=v([O("baseMint"),O("quoteMint")]),a=r.map(d=>({id:d.pubkey,version:4,mintA:i.decode(d.account.data).baseMint,mintB:i.decode(d.account.data).quoteMint})),c=v([O("mintA"),O("mintB")]),l=(await this.scope.connection.getProgramAccounts(n,{filters:[{dataSize:no.span}],dataSlice:{offset:no.offsetOf("mintA"),length:64}})).map(d=>{let f=c.decode(d.account.data);return{id:d.pubkey,version:6,mintA:f.mintA,mintB:f.mintB}}),p=(await this.scope.connection.getProgramAccounts(o,{dataSlice:{offset:ea.offsetOf("mintA"),length:64}})).map(d=>{let f=c.decode(d.account.data);return{id:d.pubkey,version:7,mintA:f.mintA,mintB:f.mintB}});return{clmmPools:l,ammPools:a,cpmmPools:p}}getAllRoute({inputMint:e,outputMint:t,clmmPools:n,ammPools:o,cpmmPools:r}){e=e.toString()===po.default.toString()?H:e,t=t.toString()===po.default.toString()?H:t;let i={},a={},c={},u=[],l={};for(let p of n!=null?n:[]){if((p.mintA.equals(e)&&p.mintB.equals(t)||p.mintA.equals(t)&&p.mintB.equals(e))&&(u.push(p),a[p.id.toString()]=p),p.mintA.equals(e)){let d=p.mintB.toString();l[d]===void 0&&(l[d]={mintProgram:Ze,in:[],out:[],mDecimals:0}),l[d].in.push(p)}if(p.mintB.equals(e)){let d=p.mintA.toString();l[d]===void 0&&(l[d]={mintProgram:Ze,in:[],out:[],mDecimals:0}),l[d].in.push(p)}if(p.mintA.equals(t)){let d=p.mintB.toString();l[d]===void 0&&(l[d]={mintProgram:Ze,in:[],out:[],mDecimals:0}),l[d].out.push(p)}if(p.mintB.equals(t)){let d=p.mintA.toString();l[d]===void 0&&(l[d]={mintProgram:Ze,in:[],out:[],mDecimals:0}),l[d].out.push(p)}}let m=[];for(let p of o)(p.mintA.equals(e)&&p.mintB.equals(t)||p.mintA.equals(t)&&p.mintB.equals(e))&&(u.push(p),i[p.id.toBase58()]=p,m.push(p)),p.mintA.equals(e)&&(l[p.mintB.toBase58()]===void 0&&(l[p.mintB.toBase58()]={mintProgram:Ze,in:[],out:[],mDecimals:0}),l[p.mintB.toBase58()].in.push(p)),p.mintB.equals(e)&&(l[p.mintA.toBase58()]===void 0&&(l[p.mintA.toBase58()]={mintProgram:Ze,in:[],out:[],mDecimals:0}),l[p.mintA.toBase58()].in.push(p)),p.mintA.equals(t)&&(l[p.mintB.toBase58()]===void 0&&(l[p.mintB.toBase58()]={mintProgram:Ze,in:[],out:[],mDecimals:0}),l[p.mintB.toBase58()].out.push(p)),p.mintB.equals(t)&&(l[p.mintA.toBase58()]===void 0&&(l[p.mintA.toBase58()]={mintProgram:Ze,in:[],out:[],mDecimals:0}),l[p.mintA.toBase58()].out.push(p));for(let p of r)(p.mintA.equals(e)&&p.mintB.equals(t)||p.mintA.equals(t)&&p.mintB.equals(e))&&(u.push(p),c[p.id.toBase58()]=p),p.mintA.equals(e)&&(l[p.mintB.toBase58()]===void 0&&(l[p.mintB.toBase58()]={mintProgram:Ze,in:[],out:[],mDecimals:0}),l[p.mintB.toBase58()].in.push(p)),p.mintB.equals(e)&&(l[p.mintA.toBase58()]===void 0&&(l[p.mintA.toBase58()]={mintProgram:Ze,in:[],out:[],mDecimals:0}),l[p.mintA.toBase58()].in.push(p)),p.mintA.equals(t)&&(l[p.mintB.toBase58()]===void 0&&(l[p.mintB.toBase58()]={mintProgram:Ze,in:[],out:[],mDecimals:0}),l[p.mintB.toBase58()].out.push(p)),p.mintB.equals(t)&&(l[p.mintA.toBase58()]===void 0&&(l[p.mintA.toBase58()]={mintProgram:Ze,in:[],out:[],mDecimals:0}),l[p.mintA.toBase58()].out.push(p));for(let p of Object.keys(l)){if(l[p].in.length===1&&l[p].out.length===1&&l[p].in[0].id.equals(l[p].out[0].id)){delete l[p];continue}if(l[p].in.length===0||l[p].out.length===0){delete l[p];continue}let d=l[p];for(let f of d.in)for(let y of d.out)f.version===6&&a[f.id.toString()]===void 0?a[f.id.toString()]=f:f.version===7&&c[f.id.toString()]===void 0?c[f.id.toString()]=f:(f.version===4||f.version===5)&&i[f.id.toString()]===void 0&&(i[f.id.toString()]=f),y.version===6&&a[y.id.toString()]===void 0?a[y.id.toString()]=y:y.version===7&&c[y.id.toString()]===void 0?c[y.id.toString()]=y:(y.version===4||y.version===5)&&i[y.id.toString()]===void 0&&(i[y.id.toString()]=y)}return{directPath:u,addLiquidityPools:m,routePathDict:l,needSimulate:Object.values(i),needTickArray:Object.values(a),cpmmPoolList:Object.values(c)}}async fetchSwapRoutesData({routes:e,inputMint:t,outputMint:n}){let o=new Set([...e.needTickArray.map(y=>[y.mintA.toBase58(),y.mintB.toBase58()]).flat(),t.toString(),n.toString()]);console.log("fetching amm pools info, total: ",e.needSimulate.length);let r=await this.scope.liquidity.getRpcPoolInfos(e.needSimulate.map(y=>y.id)),i=Xr(r),a={};Object.values(i).forEach(y=>{o.delete(y.mintA.address),a[y.mintA.address]={address:new po(y.mintA.address),programId:Ze,mintAuthority:null,supply:BigInt(0),decimals:y.mintA.decimals,isInitialized:!0,freezeAuthority:null,tlvData:Buffer.from("0","hex"),feeConfig:void 0},o.delete(y.mintB.address),a[y.mintB.address]={address:new po(y.mintB.address),programId:Ze,mintAuthority:null,supply:BigInt(0),decimals:y.mintB.decimals,isInitialized:!0,freezeAuthority:null,tlvData:Buffer.from("0","hex"),feeConfig:void 0}}),console.log("fetching cpmm pools info, total: ",e.cpmmPoolList.length);let c=await this.scope.cpmm.getRpcPoolInfos(e.cpmmPoolList.map(y=>y.id.toBase58()),!0);Object.values(c).forEach(y=>{let[b,g]=[y.mintA.toBase58(),y.mintB.toBase58()];y.mintProgramA.equals(Ze)?(o.delete(b),a[b]={address:y.mintA,programId:y.mintProgramA,mintAuthority:null,supply:BigInt(0),decimals:y.mintDecimalA,isInitialized:!0,freezeAuthority:null,tlvData:Buffer.from("0","hex"),feeConfig:void 0}):o.add(b),y.mintProgramB.equals(Ze)?(o.delete(g),a[g]={address:y.mintB,programId:y.mintProgramB,mintAuthority:null,supply:BigInt(0),decimals:y.mintDecimalB,isInitialized:!0,freezeAuthority:null,tlvData:Buffer.from("0","hex"),feeConfig:void 0}):o.add(g)}),console.log("fetching mints info, total: ",o.size);let u=await Po({connection:this.scope.connection,mints:Array.from(o).map(y=>new po(y))});a=N(N({},a),u);let l=this.scope.cpmm.toComputePoolInfos({pools:c,mintInfos:a});console.log("fetching clmm pools info, total:",e.needTickArray.length);let m=await this.scope.clmm.getRpcClmmPoolInfos({poolIds:e.needTickArray.map(y=>y.id)}),{computeClmmPoolInfo:p,computePoolTickData:d}=await this.scope.clmm.getComputeClmmPoolInfos({clmmPoolsRpcInfo:m,mintInfos:a}),f=Object.keys(e.routePathDict).reduce((y,b)=>q(N({},y),{[b]:q(N({},e.routePathDict[b]),{mintProgram:a[b].programId,mDecimals:a[b].decimals,in:e.routePathDict[b].in.map(g=>i[g.id.toBase58()]||p[g.id.toBase58()]||l[g.id.toBase58()]),out:e.routePathDict[b].out.map(g=>i[g.id.toBase58()]||p[g.id.toBase58()]||l[g.id.toBase58()])})}),{});return{mintInfos:a,ammPoolsRpcInfo:r,ammSimulateCache:i,clmmPoolsRpcInfo:m,computeClmmPoolInfo:p,computePoolTickData:d,computeCpmmData:l,routePathDict:f}}getAllRouteComputeAmountOut({inputTokenAmount:e,outputToken:t,directPath:n,routePathDict:o,simulateCache:r,tickCache:i,slippage:a,chainTime:c,epochInfo:u,feeConfig:l}){var g,P,h,I,T,w,x,S,K;let m=l===void 0?new ra(0):e.raw.mul(new ra(l.feeBps.toNumber())).div(new ra(1e4)),p=e.raw.sub(m),d=new he(e.token,p),f=l===void 0?void 0:{feeAmount:m,feeAccount:l.feeAccount},y=q(N({},t),{address:yt(t.address).toString()}),b=[];for(let B of n)try{b.push(q(N({},this.computeAmountOut({itemPool:B,tickCache:i,simulateCache:r,chainTime:c,epochInfo:u,slippage:a,outputToken:y,amountIn:d})),{feeConfig:f}))}catch(C){this.logDebug("direct error",B.version,B.id.toString(),C.message)}this.logDebug("direct done");for(let[B,C]of Object.entries(o)){let M={chainId:101,address:B,programId:C.mintProgram.toBase58(),logoURI:"",symbol:"",name:"",decimals:C.mDecimals,tags:[],extensions:{}},V=C.in.map(L=>{try{return{pool:L,data:this.computeAmountOut({itemPool:L,tickCache:i,simulateCache:r,chainTime:c,epochInfo:u,slippage:a,outputToken:M,amountIn:d})}}catch(W){this.logDebug("route in error",L.version,L.id.toString(),W.message);return}}).sort((L,W)=>{var ae,be,le,pe;let z=L===void 0?Sn:L.data.amountOut.amount.raw.sub((be=(ae=L.data.amountOut.fee)==null?void 0:ae.raw)!=null?be:Sn),$=W===void 0?Sn:W.data.amountOut.amount.raw.sub((pe=(le=W.data.amountOut.fee)==null?void 0:le.raw)!=null?pe:Sn);return z.lt($)?1:-1})[0];if(V===void 0)continue;let R=new he(Dr(M),V.data.amountOut.amount.raw.sub((P=(g=V.data.amountOut.fee)==null?void 0:g.raw)!=null?P:Sn));for(let L of C.out)try{let W=this.computeAmountOut({itemPool:L,tickCache:i,simulateCache:r,chainTime:c,epochInfo:u,slippage:a,outputToken:y,amountIn:R});b.push(q(N({},W),{allTrade:!!(V.data.allTrade&&W.allTrade),amountIn:V.data.amountIn,amountOut:W.amountOut,minAmountOut:W.minAmountOut,currentPrice:void 0,executionPrice:new zi(new ut({baseToken:V.data.amountIn.amount.token,denominator:V.data.amountIn.amount.raw,quoteToken:W.amountOut.amount.token,numerator:W.amountOut.amount.raw.sub((I=(h=W.amountOut.fee)==null?void 0:h.raw)!=null?I:Sn)}).toFixed()),priceImpact:new zi(V.data.priceImpact.add(W.priceImpact).toFixed()),fee:[V.data.fee[0],W.fee[0]],routeType:"route",poolInfoList:[V.pool,L],remainingAccounts:[V.data.remainingAccounts[0],W.remainingAccounts[0]],minMiddleAmountFee:(T=W.amountOut.fee)!=null&&T.raw?new he(V.data.amountOut.amount.token,((x=(w=V.data.amountOut.fee)==null?void 0:w.raw)!=null?x:Sn).add((K=(S=W.amountOut.fee)==null?void 0:S.raw)!=null?K:Sn)):void 0,middleToken:V.data.amountOut.amount.token,poolReady:V.data.poolReady&&W.poolReady,poolType:[V.data.poolType,W.poolType],feeConfig:f,expirationTime:tn(V.data.expirationTime,W.expirationTime)}))}catch(W){this.logDebug("route out error",L.version,L.id.toString(),W.message)}}return b.filter(B=>(B.allTrade||this.logDebug(`pool ${B.poolInfoList.map(C=>C.id.toString()).join(",")} filter out since not all trade`),B.allTrade)).sort((B,C)=>B.amountOut.amount.raw.sub(C.amountOut.amount.raw).gt(Sn)?-1:1)}computeAmountOut({itemPool:e,tickCache:t,simulateCache:n,chainTime:o,epochInfo:r,slippage:i,outputToken:a,amountIn:c}){if(e.version===6){let{allTrade:u,realAmountIn:l,amountOut:m,minAmountOut:p,expirationTime:d,currentPrice:f,executionPrice:y,priceImpact:b,fee:g,remainingAccounts:P,executionPriceX64:h}=ve.computeAmountOutFormat({poolInfo:e,tickArrayCache:t[e.id.toString()],amountIn:c.raw,tokenOut:a,slippage:i,epochInfo:r,catchLiquidityInsufficient:!0});return{allTrade:u,amountIn:l,amountOut:m,minAmountOut:p,currentPrice:new zi(f.toFixed()),executionPrice:new zi(y.toFixed()),priceImpact:new zi(b.toFixed()),fee:[g],remainingAccounts:[P],routeType:"amm",poolInfoList:[e],poolReady:e.startTime<o,poolType:"CLMM",slippage:i,clmmExPriceX64:[h],expirationTime:tn(l.expirationTime,d)}}else if(e.version===7){let{allTrade:u,executionPrice:l,amountOut:m,minAmountOut:p,priceImpact:d,fee:f}=this.scope.cpmm.computeSwapAmount({pool:e,outputMint:a.address,amountIn:c.raw,slippage:i});return{allTrade:u,amountIn:{amount:c,fee:void 0,expirationTime:void 0},amountOut:{amount:Li(q(N({},a),{amount:m})),fee:void 0,expirationTime:void 0},minAmountOut:{amount:Li(q(N({},a),{amount:p})),fee:void 0,expirationTime:void 0},currentPrice:e.poolPrice,executionPrice:l,priceImpact:d,fee:[new he(c.token,f)],remainingAccounts:[],routeType:"amm",poolInfoList:[e],poolReady:e.openTime.toNumber()<o,poolType:"CPMM",slippage:i,clmmExPriceX64:[void 0],expirationTime:void 0}}else{if(![1,6,7].includes(n[e.id.toString()].status))throw Error("swap error");let{amountOut:u,minAmountOut:l,currentPrice:m,executionPrice:p,priceImpact:d,fee:f}=this.scope.liquidity.computeAmountOut({poolInfo:n[e.id.toString()],amountIn:c.raw,mintIn:c.token.mint,mintOut:a.address,slippage:i});return{amountIn:{amount:c,fee:void 0,expirationTime:void 0},amountOut:{amount:Li(q(N({},a),{amount:u})),fee:void 0,expirationTime:void 0},minAmountOut:{amount:Li(q(N({},a),{amount:l})),fee:void 0,expirationTime:void 0},currentPrice:m,executionPrice:p,priceImpact:d,fee:[new he(c.token,f)],routeType:"amm",poolInfoList:[e],remainingAccounts:[],poolReady:Number(n[e.id].openTime)<o,poolType:e.version===5?"STABLE":void 0,expirationTime:void 0,allTrade:!0,slippage:i,clmmExPriceX64:[void 0]}}}async computePoolToPoolKeys({pools:e,clmmRpcData:t={},ammRpcData:n={}}){let o=new Set(e.filter(u=>u.version===6&&!t[u.id.toString()]).map(u=>u.id.toString()));if(o.size>0){let u=await this.scope.clmm.getRpcClmmPoolInfos({poolIds:Array.from(o)});Object.keys(u).forEach(l=>{t[l]=u[l]})}let r=new Set(e.filter(u=>u.version===4&&!n[u.id.toString()]).map(u=>u.id.toString()));if(r.size>0){let u=await this.scope.liquidity.getRpcPoolInfos(Array.from(r));Object.keys(u).forEach(l=>{n[l]=u[l]})}let i=new Set(e.filter(u=>u.version===4).map(u=>u.marketId)),a={};i.size>0&&(await Me(this.scope.connection,Array.from(i).map(l=>({pubkey:new po(l)})))).forEach(l=>{if(!l.accountInfo)return;let m=iu.decode(l.accountInfo.data);a[l.pubkey.toBase58()]={marketId:l.pubkey.toString(),marketProgramId:l.accountInfo.owner.toString(),marketAuthority:oa.getAssociatedAuthority({programId:l.accountInfo.owner,marketId:l.pubkey}).publicKey.toString(),marketBaseVault:m.baseVault.toString(),marketQuoteVault:m.quoteVault.toString(),marketBids:m.bids.toString(),marketAsks:m.asks.toString(),marketEventQueue:m.eventQueue.toString()}});let c=[];return e.forEach(u=>{if(u.version===6){let l=t[u.id.toString()],m={programId:u.programId.toBase58(),id:u.id.toBase58(),mintA:u.mintA,mintB:u.mintB,openTime:String(u.startTime),vault:{A:l.vaultA.toBase58(),B:l.vaultB.toBase58()},config:q(N({},u.ammConfig),{id:u.ammConfig.id.toString(),defaultRange:0,defaultRangePoint:[]}),rewardInfos:[],observationId:u.observationId.toBase58(),exBitmapAccount:u.exBitmapAccount.toBase58()};c.push(m)}else if(u.version===4){let l=n[u.id.toString()],m=N({programId:u.programId,id:u.id,mintA:u.mintA,mintB:u.mintB,openTime:String(u.openTime),vault:{A:l.baseVault.toBase58(),B:l.quoteVault.toBase58()},authority:Zs({programId:new po(u.programId)}).publicKey.toString(),openOrders:l.openOrders.toBase58(),targetOrders:l.targetOrders.toBase58(),mintLp:u.lpMint},a[u.marketId]);c.push(m)}else u.version===7&&c.push({observationId:u.observationId.toBase58(),programId:u.programId.toBase58(),id:u.id.toBase58(),mintA:u.mintA,mintB:u.mintB,openTime:String(u.openTime),authority:Eo(u.programId).publicKey.toBase58(),vault:{A:u.vaultA.toBase58(),B:u.vaultB.toBase58()},mintLp:At({address:u.mintLp.toBase58(),programId:Ze.toBase58(),decimals:u.lpDecimals}),config:q(N({id:u.configId.toBase58()},u.configInfo),{protocolFeeRate:u.configInfo.protocolFeeRate.toNumber(),tradeFeeRate:u.configInfo.tradeFeeRate.toNumber(),fundFeeRate:u.configInfo.fundFeeRate.toNumber(),createPoolFee:u.configInfo.createPoolFee.toString()})})}),c}};import{PublicKey as $f,Transaction as uu,TransactionInstruction as Jf}from"@solana/web3.js";import{TOKEN_PROGRAM_ID as ey}from"@solana/spl-token";import jl from"bn.js";var Pt=class extends Ve{static getPdaPoolId(e,t){return ne([Pt.SEED_CONFIG.pool.id,t.toBuffer()],e)}static getPdaOwnerId(e,t,n,o){return ne([Pt.SEED_CONFIG.owner.id,t.toBuffer(),n.toBuffer(),Buffer.from(new jl(o).toArray())],e)}static async getAllInfo({connection:e,programId:t,poolIds:n,wallet:o,chainTime:r}){if(n.length===0)return[];let i=n.map(l=>Pt.getPdaPoolId(t,l).publicKey),a=[];for(let l=0;l<Pt.VERSION_PROJECT.length;l++)a.push(...i.map(m=>Pt.getPdaOwnerId(t,m,o,l).publicKey));let c=await $t(e,[...i,...a]),u=[];for(let l=0;l<c.length;l++){let m=Math.floor(l/n.length),p=l%n.length,d=i[p],f=a[l],y=c[p],b=c[n.length+l];if(!(y&&b)||y.data.length!==Pt.POOL_LAYOUT.span||b.data.length!==Pt.OWNER_LAYOUT.span)continue;let g=Pt.POOL_LAYOUT.decode(y.data),P=Pt.OWNER_LAYOUT.decode(b.data),h=g.openTime.toNumber(),I=g.endTime.toNumber(),T=P.tokenInfo.map(S=>S.debtAmount.gt(new jl(0))).filter(S=>!S).length!==3,w=r>h&&r<I&&g.status===1,x=T&&w;u.push({programId:t,poolId:d,ammId:g.ammId,ownerAccountId:f,snapshotLpAmount:P.lpAmount,project:Pt.VERSION_PROJECT[m],openTime:h,endTime:I,canClaim:x,canClaimErrorType:T?w?void 0:"outOfOperationalTime":"alreadyClaimIt",tokenInfo:g.tokenInfo.map((S,K)=>({mintAddress:S.mintAddress,mintVault:S.mintVault,mintDecimals:S.mintDecimals,perLpLoss:S.perLpLoss,debtAmount:P.tokenInfo[K].debtAmount.add(P.tokenInfo[K].claimedAmount)}))})}return u}async makeClaimTransaction({poolInfo:e,ownerInfo:t,feePayer:n}){t.wallet||this.scope.checkOwner();let o=this.createTxBuilder(n),r=t.wallet||this.scope.ownerPubKey,i=[];for(let u of e.tokenInfo){let{account:l,instructionParams:m}=await this.scope.account.getOrCreateTokenAccount({mint:u.mintAddress,owner:this.scope.ownerPubKey,notUseTokenAccount:u.mintAddress.equals(Se.WSOL.mint),createInfo:{payer:r,amount:0},skipCloseAccount:!u.mintAddress.equals(Se.WSOL.mint),associatedOnly:u.mintAddress.equals(Se.WSOL.mint)?!1:t.associatedOnly});m&&o.addInstruction(m),i.push(l)}o.addInstruction({instructions:[Pt.makeClaimInstruction({programId:e.programId,poolInfo:e,ownerInfo:{wallet:r,ownerPda:e.ownerAccountId,claimAddress:i}})]});let{transaction:a,signers:c}=o.build();return[{transaction:a,signer:c}]}async makeClaimAllTransaction({poolInfos:e,ownerInfo:t,feePayer:n}){let o=this.createTxBuilder(n),r=t.wallet||this.scope.ownerPubKey,i={};for(let l of e){let m=[];for(let p of l.tokenInfo){let{account:d,instructionParams:f}=await this.scope.account.getOrCreateTokenAccount({mint:p.mintAddress,owner:this.scope.ownerPubKey,notUseTokenAccount:p.mintAddress.equals(Se.WSOL.mint),createInfo:{payer:r,amount:0},skipCloseAccount:!p.mintAddress.equals(Se.WSOL.mint),associatedOnly:p.mintAddress.equals(Se.WSOL.mint)?!1:t.associatedOnly});f&&o.addInstruction(f),d&&(i[p.mintAddress.toString()]=d,m.push(d))}o.addInstruction({instructions:[Pt.makeClaimInstruction({programId:l.programId,poolInfo:l,ownerInfo:{wallet:r,ownerPda:l.ownerAccountId,claimAddress:m}})]})}let{transaction:a,signers:c}=o.build(),u=o.allInstructions;return gr(u,[r,...c.map(l=>l.publicKey)])?[{transaction:a,signer:c}]:[{transaction:new uu().add(...u.slice(0,o.AllTxData.instructions.length-1)),signer:c},{transaction:new uu().add(...u.slice(o.AllTxData.instructions.length-1)),signer:[]},{transaction:new uu().add(...o.AllTxData.endInstructions),signer:[]}]}static makeClaimInstruction({programId:e,poolInfo:t,ownerInfo:n}){let o=v([]),r=[{pubkey:n.wallet,isSigner:!0,isWritable:!0},{pubkey:t.poolId,isSigner:!1,isWritable:!0},{pubkey:n.ownerPda,isSigner:!1,isWritable:!0},...n.claimAddress.map(c=>({pubkey:c,isSigner:!1,isWritable:!0})),...t.tokenInfo.map(({mintVault:c})=>({pubkey:c,isSigner:!1,isWritable:!0})),{pubkey:ey,isSigner:!1,isWritable:!1}],i=Buffer.alloc(o.span);o.encode({},i);let a=Buffer.from([10,66,208,184,161,6,191,98,...i]);return new Jf({keys:r,programId:e,data:a})}},Qt=Pt;Qt.CLAIMED_NUM=3,Qt.POOL_LAYOUT=v([xe(8),D("bump"),D("status"),k("openTime"),k("endTime"),O("ammId"),Q(v([D("mintDecimals"),O("mintAddress"),O("mintVault"),k("perLpLoss"),k("totalClaimedAmount")]),Pt.CLAIMED_NUM,"tokenInfo"),Q(k(),10,"padding")]),Qt.OWNER_LAYOUT=v([xe(8),D("bump"),D("version"),O("poolId"),O("owner"),k("lpAmount"),Q(v([O("mintAddress"),k("debtAmount"),k("claimedAmount")]),Pt.CLAIMED_NUM,"tokenInfo"),Q(k(),4,"padding")]),Qt.DEFAULT_POOL_ID=["58oQChx4yWmvKdwLLZzBi4ChoCc2fqCUWBkwMihLYQo2","6UmmUiYoBjSrhakAobJw8BvkmJtDVxaeBtbt7rxWo1mg","AVs9TA4nWDzfPJE9gGVNJMVhcQy3V9PGazuz33BfG2RA","DVa7Qmb5ct9RCpaU7UTpSaf3GVMYz17vNVU67XpdCRut","7XawhbbxtsRcQA8KTkHT9f9nc6d69UwqCDh6U5EEbEmX","6a1CsrpeZubDjEJE9s1CMVheB6HWM5d7m1cj2jkhyXhj","EoNrn8iUhwgJySD1pHu8Qxm5gSQqLK3za4m8xzD2RuEb","AceAyRTWt4PyB2pHqf2qhDgNZDtKVNaxgL8Ru3V4aN1P","6tmFJbMk5yVHFcFy7X2K8RwHjKLr6KVFLYXpgpBNeAxB"].map(e=>new $f(e)),Qt.SEED_CONFIG={pool:{id:Buffer.from("pool_seed","utf8")},owner:{id:Buffer.from("user_claim_seed","utf8")}},Qt.VERSION_PROJECT=[void 0,"Francium","Tulip","Larix"];import{PublicKey as ji}from"@solana/web3.js";import Hl from"bn.js";import{SYSVAR_CLOCK_PUBKEY as ty,TransactionInstruction as lu}from"@solana/web3.js";import{TOKEN_PROGRAM_ID as mu}from"@solana/spl-token";var cu=v([D("instruction"),fc("amount")]),Yi=v([D("instruction")]);function ZC({programId:s,amount:e,instructionKeys:t}){let n=[{pubkey:lr,isSigner:!1,isWritable:!1},{pubkey:mu,isSigner:!1,isWritable:!1},{pubkey:tt,isSigner:!1,isWritable:!1},{pubkey:Sa,isSigner:!1,isWritable:!1},...Object.entries(t).map(([r,i])=>({pubkey:i,isSigner:r==="userOwner",isWritable:!["authority","userOwner","userIdoCheck","userStakeInfo"].includes(r)}))],o=Buffer.alloc(cu.span);return cu.encode({instruction:1,amount:Number(e)},o),new lu({keys:n,programId:s,data:o})}function aa({programId:s},e){let t=[{pubkey:mu,isSigner:!1,isWritable:!1},{pubkey:Sa,isSigner:!1,isWritable:!1},...Object.entries(e).map(([o,r])=>({pubkey:r,isSigner:o==="userOwner",isWritable:!["authority","userOwner"].includes(o)}))],n=Buffer.alloc(Yi.span);return Yi.encode({instruction:2},n),new lu({keys:t,programId:s,data:n})}function du(s){let{poolConfig:e,userKeys:t,side:n}=s,o=n==="base"?t.baseTokenAccount:t.quoteTokenAccount,r=n==="base"?e.baseVault:e.quoteVault,i=Buffer.alloc(Yi.span);Yi.encode({instruction:2},i);let a=[{pubkey:mu,isWritable:!1,isSigner:!1},{pubkey:ty,isWritable:!1,isSigner:!1},{pubkey:e.id,isWritable:!0,isSigner:!1},{pubkey:e.authority,isWritable:!1,isSigner:!1},{pubkey:r,isWritable:!0,isSigner:!1},{pubkey:o,isWritable:!0,isSigner:!1},{pubkey:t.ledgerAccount,isWritable:!0,isSigner:!1},{pubkey:t.owner,isWritable:!1,isSigner:!0}];return new lu({programId:e.programId,keys:a,data:i})}var ny={[ai.IDO_PROGRAM_ID_V1.toString()]:1,[ai.IDO_PROGRAM_ID_V2.toString()]:2,[ai.IDO_PROGRAM_ID_V3.toString()]:3,[ai.IDO_PROGRAM_ID_V4.toString()]:4},Do=class extends Ve{async claim({ownerInfo:e,idoKeys:t,associatedOnly:n=!0,checkCreateATAOwner:o=!1,txVersion:r,feePayer:i}){let a=this.createTxBuilder(i),c=ny[t.programId];c||this.logAndCreateError("invalid version",c);let u=Fe(t),[l,m]=[!new Hl(e.coin).isZero(),!new Hl(e.pc).isZero()],p=u.projectInfo.mint.address.equals(H),{account:d,instructionParams:f}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:u.projectInfo.mint.programId,mint:u.projectInfo.mint.address,owner:this.scope.ownerPubKey,createInfo:{payer:this.scope.ownerPubKey,amount:0},skipCloseAccount:!p,notUseTokenAccount:p,associatedOnly:p?!1:n,checkCreateATAOwner:o});!d&&l&&this.logAndCreateError("target token accounts not found","mint",t.projectInfo.mint.address),l&&f&&a.addInstruction(f);let y=u.buyInfo.mint.address.equals(H),{account:b,instructionParams:g}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:u.buyInfo.mint.programId,mint:u.buyInfo.mint.address,owner:this.scope.ownerPubKey,createInfo:{payer:this.scope.ownerPubKey,amount:0},skipCloseAccount:!y,notUseTokenAccount:y,associatedOnly:y?!1:n,checkCreateATAOwner:o});if(!d&&m&&this.logAndCreateError("target token accounts not found","mint",t.projectInfo.mint.address),m&&g&&a.addInstruction(g),(!d||!b)&&this.logAndCreateError("target token accounts not found","mint",t.projectInfo.mint.address,t.buyInfo.mint.address),c===3)return a.addInstruction({instructions:[...l?[aa({programId:u.programId},{idoId:u.id,authority:u.authority,poolTokenAccount:u.projectInfo.vault,userTokenAccount:d,userIdoInfo:new ji(e.userIdoInfo),userOwner:this.scope.ownerPubKey})]:[],...m?[aa({programId:new ji(t.programId)},{idoId:u.id,authority:u.authority,poolTokenAccount:u.buyInfo.vault,userTokenAccount:b,userIdoInfo:new ji(e.userIdoInfo),userOwner:this.scope.ownerPubKey})]:[]]}).versionBuild({txVersion:r});if(c<3)return!l&&!m&&this.logAndCreateError("no claimable rewards"),a.addInstruction({instructions:[aa({programId:u.programId},{idoId:u.id,authority:u.authority,poolQuoteTokenAccount:u.buyInfo.vault,poolBaseTokenAccount:u.projectInfo.vault,userQuoteTokenAccount:b,userBaseTokenAccount:d,userIdoInfo:new ji(e.userIdoInfo),userOwner:this.scope.ownerPubKey})]}).versionBuild({txVersion:r});let P={poolConfig:{id:u.id,programId:u.programId,authority:u.authority,baseVault:u.projectInfo.vault,quoteVault:u.buyInfo.vault,baseToken:t.projectInfo.mint,quoteToken:t.buyInfo.mint},userKeys:{baseTokenAccount:d,quoteTokenAccount:b,ledgerAccount:new ji(e.userIdoInfo),owner:this.scope.ownerPubKey}};return a.addInstruction({instructions:[...l?[du(q(N({},P),{side:"base"}))]:[],...m?[du(q(N({},P),{side:"quote"}))]:[]]}).versionBuild({txVersion:r})}};var oy=Buffer.from("vault_auth_seed","utf8"),iy=Buffer.from("global_config","utf8"),ry=Buffer.from("pool_vesting","utf8"),ay=Buffer.from("platform_config","utf8"),sy=Buffer.from("platform_fee_vault_auth_seed","utf8"),uy=Buffer.from("creator_fee_vault_auth_seed","utf8");function fn(s){return ne([oy],s)}function bR(s,e,t,n){return ne([iy,e.toBuffer(),cy(t),Vr(n)],s)}function Wo(s,e,t){return ne([Rs,e.toBuffer(),t.toBuffer()],s)}function pu(s,e,t){return ne([Ls,e.toBuffer(),t.toBuffer()],s)}function fo(s){return ne([Buffer.from("__event_authority","utf8")],s)}function cy(s){let e=new ArrayBuffer(1);return new DataView(e).setUint8(0,s),new Uint8Array(e)}function fu(s,e){return ne([ay,e.toBuffer()],s)}function Hi(s,e,t){return ne([ry,e.toBuffer(),t.toBuffer()],s)}function yo(s,e,t){return ne([e.toBuffer(),t.toBuffer()],s)}function yu(s){return ne([sy],s)}function qo(s,e,t){return ne([e.toBuffer(),t.toBuffer()],s)}function Zl(s){return ne([uy],s)}import{SystemProgram as Yt,TransactionInstruction as Et}from"@solana/web3.js";import{ASSOCIATED_TOKEN_PROGRAM_ID as sa,TOKEN_2022_PROGRAM_ID as ly,TOKEN_PROGRAM_ID as bu}from"@solana/spl-token";import Zi from"bn.js";var Dt={initialize:Buffer.from([175,175,109,31,13,152,155,237]),buyExactIn:Buffer.from([250,234,13,123,213,156,19,236]),buyExactOut:Buffer.from([24,211,116,40,105,3,153,56]),sellExactIn:Buffer.from([149,39,222,155,211,124,152,26]),sellExactOut:Buffer.from([95,200,71,34,8,9,11,166]),createVestingAccount:Buffer.from([129,178,2,13,217,172,230,218]),claimVestedToken:Buffer.from([49,33,104,30,189,157,79,35]),createPlatformConfig:Buffer.from([176,90,196,175,253,113,220,20]),claimPlatformFee:Buffer.from([156,39,208,135,76,237,61,72]),updatePlaformConfig:Buffer.from([195,60,76,129,146,45,67,143]),initializeWithToken2022:Buffer.from([37,190,126,222,44,154,171,17]),claimPlatformFeeFromVault:Buffer.from([117,241,198,168,248,218,80,29]),claimCreatorFee:Buffer.from([26,97,138,203,132,171,141,252])};function $l(s,e,t,n,o,r,i,a,c,u,l,m,p,d,f,y,b,g,P,h){let I=v([D("decimals"),Ct("name"),Ct("symbol"),Ct("uri")]),T=v([k("totalLockedAmount"),k("cliffPeriod"),k("unlockPeriod")]),w=v([D("index"),k("supply"),k("totalFundRaisingB"),D("migrateType")]),x=v([D("index"),k("supply"),k("totalSellA"),k("totalFundRaisingB"),D("migrateType")]),S=[{pubkey:e,isSigner:!0,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!1,isWritable:!1},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!0,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!1},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:m,isSigner:!1,isWritable:!0},{pubkey:bu,isSigner:!1,isWritable:!1},{pubkey:bu,isSigner:!1,isWritable:!1},{pubkey:Jt,isSigner:!1,isWritable:!1},{pubkey:Yt.programId,isSigner:!1,isWritable:!1},{pubkey:tt,isSigner:!1,isWritable:!1},{pubkey:fo(s).publicKey,isSigner:!1,isWritable:!1},{pubkey:s,isSigner:!1,isWritable:!1}],K=Buffer.alloc(Buffer.from(d,"utf-8").length+Buffer.from(f,"utf-8").length+Buffer.from(y,"utf-8").length+4*3+1),B=Buffer.alloc(T.span),C=Buffer.alloc(b.type==="ConstantCurve"?x.span:w.span);return I.encode({decimals:p,name:d,symbol:f,uri:y},K),b.type==="ConstantCurve"?x.encode(q(N({index:0},b),{migrateType:b.migrateType==="amm"?0:1}),C):b.type==="FixedCurve"?w.encode(q(N({index:1},b),{migrateType:b.migrateType==="amm"?0:1}),C):b.type==="LinearCurve"&&w.encode(q(N({index:2},b),{migrateType:b.migrateType==="amm"?0:1}),C),T.encode({totalLockedAmount:g,cliffPeriod:P,unlockPeriod:h},B),new Et({keys:S,programId:s,data:Buffer.from([...Dt.initialize,...K,...C,...B])})}function Jl(s,e,t,n,o,r,i,a,c,u,l,m,p,d,f,y,b,g,P,h){let I=v([D("decimals"),Ct("name"),Ct("symbol"),Ct("uri")]),T=v([k("totalLockedAmount"),k("cliffPeriod"),k("unlockPeriod"),D("transferFeeExtensionParamsOption"),v([Mt("transferFeeBasePoints"),k("maxinumFee")]).replicate("transferFeeExtensionParams")]),w=v([D("index"),k("supply"),k("totalFundRaisingB"),D("migrateType")]),x=v([D("index"),k("supply"),k("totalSellA"),k("totalFundRaisingB"),D("migrateType")]),S=[{pubkey:e,isSigner:!0,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!1,isWritable:!1},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!0,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!1},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:ly,isSigner:!1,isWritable:!1},{pubkey:bu,isSigner:!1,isWritable:!1},{pubkey:Yt.programId,isSigner:!1,isWritable:!1},{pubkey:fo(s).publicKey,isSigner:!1,isWritable:!1},{pubkey:s,isSigner:!1,isWritable:!1}],K=Buffer.alloc(Buffer.from(p,"utf-8").length+Buffer.from(d,"utf-8").length+Buffer.from(f,"utf-8").length+4*3+1),B=Buffer.alloc(T.span),C=Buffer.alloc(y.type==="ConstantCurve"?x.span:w.span);return I.encode({decimals:m,name:p,symbol:d,uri:f},K),y.type==="ConstantCurve"?x.encode(q(N({index:0},y),{migrateType:y.migrateType==="amm"?0:1}),C):y.type==="FixedCurve"?w.encode(q(N({index:1},y),{migrateType:y.migrateType==="amm"?0:1}),C):y.type==="LinearCurve"&&w.encode(q(N({index:2},y),{migrateType:y.migrateType==="amm"?0:1}),C),T.encode({totalLockedAmount:b,cliffPeriod:g,unlockPeriod:P,transferFeeExtensionParamsOption:h?1:0,transferFeeExtensionParams:h!=null?h:{transferFeeBasePoints:0,maxinumFee:new Zi(0)}},B),new Et({keys:S,programId:s,data:Buffer.from([...Dt.initializeWithToken2022,...K,...C,...B])})}function em(s,e,t,n,o,r,i,a,c,u,l,m,p,d,f,y,b,g,P,h){let I=v([k("amountB"),k("minAmountA"),k("shareFeeRate")]),T=[{pubkey:e,isSigner:!0,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!1},{pubkey:m,isSigner:!1,isWritable:!1},{pubkey:p,isSigner:!1,isWritable:!1},{pubkey:d,isSigner:!1,isWritable:!1},{pubkey:fo(s).publicKey,isSigner:!1,isWritable:!1},{pubkey:s,isSigner:!1,isWritable:!1}];h&&T.push({pubkey:h,isSigner:!1,isWritable:!0}),T.push({pubkey:Yt.programId,isSigner:!1,isWritable:!1}),T.push({pubkey:f,isSigner:!1,isWritable:!0}),T.push({pubkey:y,isSigner:!1,isWritable:!0});let w=Buffer.alloc(I.span);return I.encode({amountB:b,minAmountA:g,shareFeeRate:P!=null?P:new Zi(0)},w),new Et({keys:T,programId:s,data:Buffer.from([...Dt.buyExactIn,...w])})}function tm(s,e,t,n,o,r,i,a,c,u,l,m,p,d,f,y,b,g,P,h){let I=v([k("amountA"),k("maxAmountB"),k("shareFeeRate")]),T=[{pubkey:e,isSigner:!0,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!1},{pubkey:m,isSigner:!1,isWritable:!1},{pubkey:p,isSigner:!1,isWritable:!1},{pubkey:d,isSigner:!1,isWritable:!1},{pubkey:fo(s).publicKey,isSigner:!1,isWritable:!1},{pubkey:s,isSigner:!1,isWritable:!1}];h&&T.push({pubkey:h,isSigner:!1,isWritable:!0}),T.push({pubkey:Yt.programId,isSigner:!1,isWritable:!1}),T.push({pubkey:f,isSigner:!1,isWritable:!0}),T.push({pubkey:y,isSigner:!1,isWritable:!0});let w=Buffer.alloc(I.span);return I.encode({amountA:b,maxAmountB:g,shareFeeRate:P!=null?P:new Zi(0)},w),new Et({keys:T,programId:s,data:Buffer.from([...Dt.buyExactOut,...w])})}function nm(s,e,t,n,o,r,i,a,c,u,l,m,p,d,f,y,b,g,P,h){let I=v([k("amountA"),k("minAmountB"),k("shareFeeRate")]),T=[{pubkey:e,isSigner:!0,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!1},{pubkey:m,isSigner:!1,isWritable:!1},{pubkey:p,isSigner:!1,isWritable:!1},{pubkey:d,isSigner:!1,isWritable:!1},{pubkey:fo(s).publicKey,isSigner:!1,isWritable:!1},{pubkey:s,isSigner:!1,isWritable:!1}];h&&T.push({pubkey:h,isSigner:!1,isWritable:!0}),T.push({pubkey:Yt.programId,isSigner:!1,isWritable:!1}),T.push({pubkey:f,isSigner:!1,isWritable:!0}),T.push({pubkey:y,isSigner:!1,isWritable:!0});let w=Buffer.alloc(I.span);return I.encode({amountA:b,minAmountB:g,shareFeeRate:P!=null?P:new Zi(0)},w),new Et({keys:T,programId:s,data:Buffer.from([...Dt.sellExactIn,...w])})}function om(s,e,t,n,o,r,i,a,c,u,l,m,p,d,f,y,b,g,P,h){let I=v([k("amountB"),k("maxAmountA"),k("shareFeeRate")]),T=[{pubkey:e,isSigner:!0,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!1},{pubkey:m,isSigner:!1,isWritable:!1},{pubkey:p,isSigner:!1,isWritable:!1},{pubkey:d,isSigner:!1,isWritable:!1},{pubkey:fo(s).publicKey,isSigner:!1,isWritable:!1},{pubkey:s,isSigner:!1,isWritable:!1}];h&&T.push({pubkey:h,isSigner:!1,isWritable:!0}),T.push({pubkey:Yt.programId,isSigner:!1,isWritable:!1}),T.push({pubkey:f,isSigner:!1,isWritable:!0}),T.push({pubkey:y,isSigner:!1,isWritable:!0});let w=Buffer.alloc(I.span);return I.encode({amountB:b,maxAmountA:g,shareFeeRate:P!=null?P:new Zi(0)},w),new Et({keys:T,programId:s,data:Buffer.from([...Dt.sellExactOut,...w])})}function gu(s,e,t,n,o,r,i,a,c){let u=v([]),l=[{pubkey:e,isSigner:!0,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!1},{pubkey:c,isSigner:!1,isWritable:!1},{pubkey:Yt.programId,isSigner:!1,isWritable:!1},{pubkey:sa,isSigner:!1,isWritable:!1}],m=Buffer.alloc(u.span);return u.encode({},m),new Et({keys:l,programId:s,data:Buffer.from([...Dt.claimVestedToken,...m])})}function Au(s,e,t,n,o,r){let i=v([k("shareAmount")]),a=[{pubkey:e,isSigner:!0,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:Yt.programId,isSigner:!1,isWritable:!1}],c=Buffer.alloc(i.span);return i.encode({shareAmount:r},c),new Et({keys:a,programId:s,data:Buffer.from([...Dt.createVestingAccount,...c])})}function Pu(s,e,t,n,o,r,i,a,c){let u=[{pubkey:e,isSigner:!0,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:Yt.programId,isSigner:!1,isWritable:!0},{pubkey:sa,isSigner:!1,isWritable:!0}];return new Et({keys:u,programId:s,data:Dt.claimPlatformFee})}function im(s,e,t,n,o,r,i,a,c,u,l,m,p){let d=v([k("platformScale"),k("creatorScale"),k("burnScale"),k("feeRate"),Ct("name"),Ct("web"),Ct("img"),k("creatorFeeRate")]),f=[{pubkey:e,isSigner:!0,isWritable:!0},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:Yt.programId,isSigner:!1,isWritable:!1},{pubkey:i,isSigner:!1,isWritable:!1}],y=Buffer.alloc(8*5+Buffer.from(l,"utf-8").length+Buffer.from(m,"utf-8").length+Buffer.from(p,"utf-8").length+4*3);return d.encode({platformScale:a.platformScale,creatorScale:a.creatorScale,burnScale:a.burnScale,feeRate:c,name:l,web:m,img:p,creatorFeeRate:u},y),new Et({keys:f,programId:s,data:Buffer.from([...Dt.createPlatformConfig,...y])})}function rm(s,e,t,n){let o=[{pubkey:e,isSigner:!0,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!0}],r;if(n.type==="updateClaimFeeWallet"){let i=v([D("index"),O("value")]);r=Buffer.alloc(i.span),i.encode({index:0,value:n.value},r)}else if(n.type==="updateLockNftWallet"){let i=v([D("index"),O("value")]);r=Buffer.alloc(i.span),i.encode({index:1,value:n.value},r)}else if(n.type==="migrateCpLockNftScale"){let i=v([D("index"),k("platformScale"),k("creatorScale"),k("burnScale")]);r=Buffer.alloc(i.span),i.encode(N({index:2},n.value),r)}else if(n.type==="updateFeeRate"){let i=v([D("index"),k("value")]);r=Buffer.alloc(i.span),i.encode({index:3,value:n.value},r)}else if(n.type==="updateImg"||n.type==="updateName"||n.type==="updateWeb"){let i=v([D("index"),Ct("value")]);r=Buffer.alloc(Buffer.from(n.value,"utf-8").length+4+1*1),n.type==="updateName"?i.encode({index:4,value:n.value},r):n.type==="updateWeb"?i.encode({index:5,value:n.value},r):n.type==="updateImg"&&i.encode({index:6,value:n.value},r)}else if(n.type==="updateCpConfigId"){o.push({pubkey:n.value,isSigner:!1,isWritable:!1});let i=v([D("index")]);r=Buffer.alloc(i.span),i.encode({index:7},r)}else if(n.type==="updateAll"){o.push({pubkey:n.value.cpConfigId,isSigner:!1,isWritable:!1});let i=v([D("index"),O("platformClaimFeeWallet"),O("platformLockNftWallet"),k("platformScale"),k("creatorScale"),k("burnScale"),k("feeRate"),Ct("name"),Ct("web"),Ct("img"),O("transferFeeExtensionAuth"),k("creatorFeeRate")]);r=Buffer.alloc(1+32+32+8*4+4*3+Buffer.from(n.value.name,"utf-8").length+Buffer.from(n.value.web,"utf-8").length+Buffer.from(n.value.img,"utf-8").length),i.encode({index:8,platformClaimFeeWallet:n.value.platformClaimFeeWallet,platformLockNftWallet:n.value.platformLockNftWallet,platformScale:n.value.migrateCpLockNftScale.platformScale,creatorScale:n.value.migrateCpLockNftScale.creatorScale,burnScale:n.value.migrateCpLockNftScale.burnScale,feeRate:n.value.feeRate,name:n.value.name,web:n.value.web,img:n.value.img,transferFeeExtensionAuth:n.value.transferFeeExtensionAuth,creatorFeeRate:n.value.creatorFeeRate},r)}else throw Error("updateInfo params type error");return new Et({keys:o,programId:s,data:Buffer.from([...Dt.updatePlaformConfig,...r])})}function ku(s,e,t,n,o,r,i,a){let c=[{pubkey:t,isSigner:!0,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:e,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!1},{pubkey:a,isSigner:!1,isWritable:!1},{pubkey:Yt.programId,isSigner:!1,isWritable:!1},{pubkey:sa,isSigner:!1,isWritable:!1}];return new Et({keys:c,programId:s,data:Dt.claimPlatformFeeFromVault})}function am(s,e,t,n,o,r,i){let a=[{pubkey:e,isSigner:!0,isWritable:!0},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!1},{pubkey:i,isSigner:!1,isWritable:!1},{pubkey:Yt.programId,isSigner:!1,isWritable:!1},{pubkey:sa,isSigner:!1,isWritable:!1}];return new Et({keys:a,programId:s,data:Dt.claimCreatorFee})}import{NATIVE_MINT as Kn,TOKEN_2022_PROGRAM_ID as Cn,TOKEN_PROGRAM_ID as Xe,createAssociatedTokenAccountIdempotentInstruction as Zt,getTransferFeeConfig as fa,unpackMint as ya}from"@solana/spl-token";import re from"bn.js";import{PublicKey as um}from"@solana/web3.js";var Un=v([k(),k("epoch"),D("curveType"),Mt("index"),k("migrateFee"),k("tradeFeeRate"),k("maxShareFeeRate"),k("minSupplyA"),k("maxLockRate"),k("minSellRateA"),k("minMigrateRateA"),k("minFundRaisingB"),O("mintB"),O("protocolFeeOwner"),O("migrateFeeOwner"),O("migrateToAmmWallet"),O("migrateToCpmmWallet"),Q(k(),16)]),my=v([k("totalLockedAmount"),k("cliffPeriod"),k("unlockPeriod"),k("startTime"),k("totalAllocatedShare")]),sn=v([k(),k("epoch"),D("bump"),D("status"),D("mintDecimalsA"),D("mintDecimalsB"),D("migrateType"),k("supply"),k("totalSellA"),k("virtualA"),k("virtualB"),k("realA"),k("realB"),k("totalFundRaisingB"),k("protocolFee"),k("platformFee"),k("migrateFee"),my.replicate("vestingSchedule"),O("configId"),O("platformId"),O("mintA"),O("mintB"),O("vaultA"),O("vaultB"),O("creator"),D("mintProgramFlag"),Q(D(),63)]),KR=v([k(),k("epoch"),O("poolId"),O("beneficiary"),k("claimedAmount"),k("tokenShareAmount"),Q(k(),8)]),Uo=v([k(),k("epoch"),O("platformClaimFeeWallet"),O("platformLockNftWallet"),k("platformScale"),k("creatorScale"),k("burnScale"),k("feeRate"),Q(D(),64,"name"),Q(D(),256,"web"),Q(D(),256,"img"),O("cpConfigId"),k("creatorFeeRate"),O("transferFeeExtensionAuth"),Q(D(),184)]);import jt from"bn.js";import sm from"decimal.js";import ua from"bn.js";import $i from"decimal.js";var Gn=class{static getPoolInitPriceByPool({poolInfo:e,decimalA:t,decimalB:n}){throw Error()}static getPoolInitPriceByInit({a:e,b:t,decimalA:n,decimalB:o}){throw Error()}static getPoolPrice({poolInfo:e,decimalA:t,decimalB:n}){throw Error()}static getPoolEndPrice({supply:e,totalSell:t,totalLockedAmount:n,totalFundRaising:o,migrateFee:r,decimalA:i,decimalB:a}){throw Error()}static getPoolEndPriceReal({poolInfo:e,decimalA:t,decimalB:n}){throw Error()}static getInitParam({supply:e,totalFundRaising:t,totalSell:n,totalLockedAmount:o,migrateFee:r}){throw Error()}static buyExactIn({poolInfo:e,amount:t}){throw Error()}static buyExactOut({poolInfo:e,amount:t}){throw Error()}static sellExactIn({poolInfo:e,amount:t}){throw Error()}static sellExactOut({poolInfo:e,amount:t}){throw Error()}};var ca=class extends Gn{static getPoolInitPriceByPool({poolInfo:e,decimalA:t,decimalB:n}){return new $i(e.virtualB.toString()).div(e.virtualA.toString()).mul(10**(t-n))}static getPoolInitPriceByInit({a:e,b:t,decimalA:n,decimalB:o}){return new $i(t.toString()).div(e.toString()).mul(10**(n-o))}static getPoolPrice({poolInfo:e,decimalA:t,decimalB:n}){return new $i(e.virtualB.add(e.realB).toString()).div(e.virtualA.sub(e.realA).toString()).mul(10**(t-n))}static getPoolEndPrice({supply:e,totalSell:t,totalLockedAmount:n,totalFundRaising:o,migrateFee:r,decimalA:i,decimalB:a}){return new $i(o.sub(r).toString()).div(e.sub(t).sub(n).toString()).mul(10**(i-a))}static getPoolEndPriceReal({poolInfo:e,decimalA:t,decimalB:n}){let o=e.totalSellA.sub(e.realA),r=e.totalFundRaisingB.sub(e.realB);return new $i(e.virtualB.add(e.realB.add(r)).toString()).div(e.virtualA.sub(e.realA.add(o)).toString()).mul(10**(t-n))}static getInitParam({supply:e,totalFundRaising:t,totalSell:n,totalLockedAmount:o,migrateFee:r}){if(e.lte(n))throw Error("supply need gt total sell");let i=e.sub(n).sub(o);if(i.lte(new ua(0)))throw Error("supplyMinusSellLocked <= 0");let a=t.sub(r);if(a.lte(new ua(0)))throw Error("tfMinusMf <= 0");let c=a.mul(n).mul(n).div(i),u=a.mul(n).div(i).sub(t),l=c.div(u),m=t.mul(t).div(u);if(l.lt(new ua(0))||m.lt(new ua(0)))throw Error("invalid input 0");return{a:l,b:m,c:n}}static buyExactIn({poolInfo:e,amount:t}){return this.getAmountOut({amountIn:t,inputReserve:e.virtualB.add(e.realB),outputReserve:e.virtualA.sub(e.realA)})}static buyExactOut({poolInfo:e,amount:t}){return this.getAmountIn({amountOut:t,inputReserve:e.virtualB.add(e.realB),outputReserve:e.virtualA.sub(e.realA)})}static sellExactIn({poolInfo:e,amount:t}){return this.getAmountOut({amountIn:t,inputReserve:e.virtualA.sub(e.realA),outputReserve:e.virtualB.add(e.realB)})}static sellExactOut({poolInfo:e,amount:t}){return this.getAmountIn({amountOut:t,inputReserve:e.virtualA.sub(e.realA),outputReserve:e.virtualB.add(e.realB)})}static getAmountOut({amountIn:e,inputReserve:t,outputReserve:n}){let o=e.mul(n),r=t.add(e);return o.div(r)}static getAmountIn({amountOut:e,inputReserve:t,outputReserve:n}){let o=t.mul(e),r=n.sub(e);return Zn(o,r)}};import la from"bn.js";import Ji from"decimal.js";var ma=class extends Gn{static getPoolInitPriceByPool({poolInfo:e,decimalA:t,decimalB:n}){return new Ji(e.virtualB.toString()).div(e.virtualA.toString()).mul(10**(t-n))}static getPoolInitPriceByInit({a:e,b:t,decimalA:n,decimalB:o}){return new Ji(t.toString()).div(e.toString()).mul(10**(n-o))}static getPoolPrice({poolInfo:e,decimalA:t,decimalB:n}){return new Ji(e.virtualB.toString()).div(e.virtualA.toString()).mul(10**(t-n))}static getPoolEndPrice({supply:e,totalSell:t,totalLockedAmount:n,totalFundRaising:o,migrateFee:r,decimalA:i,decimalB:a}){return new Ji(o.sub(r).toString()).div(e.sub(t).sub(n).toString()).mul(10**(i-a))}static getPoolEndPriceReal({poolInfo:e,decimalA:t,decimalB:n}){let o=e.totalSellA.sub(e.realA),r=e.totalFundRaisingB.sub(e.realB);return new Ji(e.virtualB.add(e.realB).add(r).toString()).div(e.virtualA.sub(e.realA).add(o).toString()).mul(10**(t-n))}static getInitParam({supply:e,totalFundRaising:t,totalSell:n,totalLockedAmount:o,migrateFee:r}){let i=e.sub(o);if(i.lte(new la(0)))throw Error("invalid input 1");let a=new la(2).mul(t).sub(r),u=t.mul(i).div(a);if(u.lt(new la(0))||t.lt(new la(0)))throw Error("invalid input 0");return{a:u,b:t,c:u}}static buyExactIn({poolInfo:e,amount:t}){return this.getAmountOut({amountIn:t,initInput:e.virtualB,initOutput:e.virtualA})}static buyExactOut({poolInfo:e,amount:t}){return this.getAmountIn({amountOut:t,initInput:e.virtualB,initOutput:e.virtualA})}static sellExactIn({poolInfo:e,amount:t}){return this.getAmountOut({amountIn:t,initInput:e.virtualA,initOutput:e.virtualB})}static sellExactOut({poolInfo:e,amount:t}){return this.getAmountIn({amountOut:t,initInput:e.virtualA,initOutput:e.virtualB})}static getAmountOut({amountIn:e,initInput:t,initOutput:n}){return n.mul(e).div(t)}static getAmountIn({amountOut:e,initInput:t,initOutput:n}){let o=t.mul(e);return Zn(o,n)}};import Ot from"bn.js";import bo from"decimal.js";import Go from"bn.js";import da from"decimal.js";var er=class{static _multipler(e){return new da(10).pow(e)}static getPrice({priceX64:e,decimalA:t,decimalB:n}){return new da(e.toString()).div(this._Q64).mul(this._multipler(t)).div(this._multipler(n))}static getPriceX64({price:e,decimalA:t,decimalB:n}){let o=e.mul(this._multipler(n)).div(this._multipler(t));return new Go(o.mul(this._Q64).toFixed(0))}};er._Q64=new da(new Go(1).shln(64).toString());function XR({supply:s,totalFundRaisingB:e,totalLockedAmount:t,totalSellA:n,migrateType:o,decimalsA:r}){let i=s.sub(n).sub(t),a=new Go(new da(i.mul(e).toString()).sqrt().toFixed(0));if(o==="amm"){if(a.gt(new Go(10).pow(new Go(r))))return!0}else if(o==="cpmm"){if(a.gt(new Go(100)))return!0}else throw Error("migrate type error");return!1}var pa=class extends Gn{static getPoolInitPriceByPool({poolInfo:e,decimalA:t,decimalB:n}){return new bo(0)}static getPoolInitPriceByInit({a:e,b:t,decimalA:n,decimalB:o}){return new bo(0)}static getPoolPrice({poolInfo:e,decimalA:t,decimalB:n}){return new bo(e.virtualA.mul(e.realA).toString()).div(er._Q64).mul(10**(t-n))}static getPoolEndPrice({supply:e,totalSell:t,totalLockedAmount:n,totalFundRaising:o,migrateFee:r,decimalA:i,decimalB:a}){return new bo(o.sub(r).toString()).div(e.sub(t).sub(n).toString()).mul(10**(i-a))}static getPoolEndPriceReal({poolInfo:e,decimalA:t,decimalB:n}){let o=e.totalSellA.sub(e.realA),r=e.totalFundRaisingB.sub(e.realB);return new bo(e.virtualB.add(e.realB).add(r).toString()).div(e.virtualA.sub(e.realA).add(o).toString()).mul(10**(t-n))}static getInitParam({supply:e,totalFundRaising:t,totalSell:n,totalLockedAmount:o,migrateFee:r}){let i=e.sub(o);if(i.lte(new Ot(0)))throw Error("supplyMinusLocked need gt 0");let a=t.mul(new Ot(3)).sub(r),u=t.mul(new Ot(2)).mul(i).div(a),l=u.mul(u),m=t.mul(new Ot(2)).mul(ot).div(l);if(!m.gt(new Ot(0)))throw Error("a need gt 0");if(!hi.gt(m))throw Error("a need lt u64 max");if(m.lt(new Ot(0))||u.lt(new Ot(0)))throw Error("invalid input 0");return{a:m,b:new Ot(0),c:u}}static buyExactIn({poolInfo:e,amount:t}){let n=e.realB.add(t),o=new Ot(2).mul(n).mul(ot).div(e.virtualA);return new Ot(new bo(o.toString()).sqrt().toFixed(0)).sub(e.realA)}static buyExactOut({poolInfo:e,amount:t}){let n=e.realA.add(t),o=n.mul(n);return Zn(e.virtualA.mul(o),new Ot(2).mul(ot)).sub(e.realB)}static sellExactIn({poolInfo:e,amount:t}){let n=e.realA.sub(t),o=n.mul(n),r=Zn(e.virtualA.mul(o),new Ot(2).mul(ot));return e.realB.sub(r)}static sellExactOut({poolInfo:e,amount:t}){let n=e.realB.sub(t),o=new Ot(2).mul(n).mul(ot).div(e.virtualA),r=new Ot(new bo(o.toString()).sqrt().toFixed(0));return e.realA.sub(r)}};var Ht=class{static getPoolCurvePointByPoolInfo({curveType:e,pointCount:t,poolInfo:n}){return this.getPoolCurvePointByInit({curveType:e,pointCount:t,supply:n.supply,totalFundRaising:n.totalFundRaisingB,totalSell:n.totalSellA,totalLockedAmount:n.vestingSchedule.totalLockedAmount,migrateFee:n.migrateFee,decimalA:n.mintDecimalsA,decimalB:n.mintDecimalsB})}static getPoolCurvePointByInit({curveType:e,pointCount:t,supply:n,totalFundRaising:o,totalSell:r,totalLockedAmount:i,migrateFee:a,decimalA:c,decimalB:u}){if(t<3)throw Error("point count < 3");let l=this.getCurve(e),m=l.getInitParam({supply:n,totalFundRaising:o,totalSell:r,totalLockedAmount:i,migrateFee:a}),p=l.getPoolInitPriceByInit(q(N({},m),{decimalA:c,decimalB:u})),d=o.div(new jt(t-1)),f=new jt(0),y=[{price:p,totalSellSupply:0}],{a:b,b:g}=m,P=f,h=f;for(let I=1;I<t;I++){let T=I!==t-1?d:o.sub(h),w=this.buyExactIn({poolInfo:{virtualA:b,virtualB:g,realA:P,realB:h,totalFundRaisingB:o,totalSellA:r},amountB:T,protocolFeeRate:f,platformFeeRate:f,curveType:e,shareFeeRate:f,creatorFeeRate:f,transferFeeConfigA:void 0,slot:0});P=P.add(w.amountA.amount),h=h.add(w.amountB);let x=this.getPrice({poolInfo:{virtualA:b,virtualB:g,realA:P,realB:h},decimalA:c,decimalB:u,curveType:e});y.push({price:x,totalSellSupply:new sm(P.toString()).div(10**c).toNumber()})}return y}static getPoolInitPriceByPool({poolInfo:e,decimalA:t,decimalB:n,curveType:o}){return this.getCurve(o).getPoolInitPriceByPool({poolInfo:e,decimalA:t,decimalB:n})}static getPoolInitPriceByInit({a:e,b:t,decimalA:n,decimalB:o,curveType:r}){return this.getCurve(r).getPoolInitPriceByInit({a:e,b:t,decimalA:n,decimalB:o})}static getPrice({poolInfo:e,curveType:t,decimalA:n,decimalB:o}){return this.getCurve(t).getPoolPrice({poolInfo:e,decimalA:n,decimalB:o})}static getEndPrice({poolInfo:e,curveType:t,decimalA:n,decimalB:o}){return this.getCurve(t).getPoolPrice({poolInfo:e,decimalA:n,decimalB:o})}static getPoolEndPriceReal({poolInfo:e,curveType:t,decimalA:n,decimalB:o}){return this.getCurve(t).getPoolEndPriceReal({poolInfo:e,decimalA:n,decimalB:o})}static checkParam({supply:e,totalFundRaising:t,totalSell:n,totalLockedAmount:o,decimals:r,config:i,migrateType:a}){if(Number(r)!==6)throw Error("decimals = 6");if(e.mul(i.maxLockRate).div(nn).lt(o))throw Error("total lock amount gte max lock amount");if(e.lt(i.minSupplyA.mul(new jt(10**r))))throw Error("supply lt min supply");let u=e.mul(i.minSellRateA).div(nn);if(n.lt(u))throw Error("invalid input");if(t.lt(i.minFundRaisingB))throw Error("total fund raising lt min fund raising");let l=e.sub(n).sub(o),m=e.mul(i.minMigrateRateA).div(nn);if(l.lt(m))throw Error("migrate lt min migrate amoount");let p=e.sub(n).sub(o),d=new jt(new sm(p.mul(t).toString()).sqrt().toFixed(0));if(a==="amm"){let f=new jt(10).pow(new jt(r));if(d.lte(f))throw Error("check migrate lp error")}else if(a==="cpmm"){let f=new jt(100);if(d.lte(f))throw Error("check migrate lp error")}else throw Error("migrate type error")}static buyExactIn({poolInfo:e,amountB:t,protocolFeeRate:n,platformFeeRate:o,curveType:r,shareFeeRate:i,creatorFeeRate:a,transferFeeConfigA:c,slot:u}){let l=this.totalFeeRate({protocolFeeRate:n,platformFeeRate:o,shareFeeRate:i,creatorFeeRate:a}),m=this.calculateFee({amount:t,feeRate:l}),p=t.sub(m),d=this.getCurve(r),f=d.buyExactIn({poolInfo:e,amount:p}),y=e.totalSellA.sub(e.realA),b,g,P;if(f.gt(y)){b=y;let I=d.buyExactOut({poolInfo:e,amount:b});g=this.calculatePreFee({postFeeAmount:I,feeRate:l}),P=g.sub(I)}else b=f,g=t,P=m;let h=this.splitFee({totalFee:P,protocolFeeRate:n,platformFeeRate:o,shareFeeRate:i,creatorFeeRate:a});return{amountA:qa(b,c,u),amountB:g,splitFee:h}}static buyExactOut({poolInfo:e,amountA:t,protocolFeeRate:n,platformFeeRate:o,curveType:r,shareFeeRate:i,creatorFeeRate:a,transferFeeConfigA:c,slot:u}){let l=e.totalSellA.sub(e.realA),m=Ua(t,c,u),p=m.fee?m.amount.add(m.fee):m.amount;t.gt(l)&&(p=l);let f=this.getCurve(r).buyExactOut({poolInfo:e,amount:p}),y=this.totalFeeRate({protocolFeeRate:n,platformFeeRate:o,shareFeeRate:i,creatorFeeRate:a}),b=this.calculatePreFee({postFeeAmount:f,feeRate:y}),g=b.sub(f),P=this.splitFee({totalFee:g,protocolFeeRate:n,platformFeeRate:o,shareFeeRate:i,creatorFeeRate:a});return{amountA:m,amountB:b,splitFee:P}}static sellExactIn({poolInfo:e,amountA:t,protocolFeeRate:n,platformFeeRate:o,curveType:r,shareFeeRate:i,creatorFeeRate:a,transferFeeConfigA:c,slot:u}){let l=this.getCurve(r),m=qa(t,c,u),p=m.fee?m.amount.sub(m.fee):m.amount,d=l.sellExactIn({poolInfo:e,amount:p}),f=this.calculateFee({amount:d,feeRate:this.totalFeeRate({protocolFeeRate:n,platformFeeRate:o,shareFeeRate:i,creatorFeeRate:a})}),y=this.splitFee({totalFee:f,protocolFeeRate:n,platformFeeRate:o,shareFeeRate:i,creatorFeeRate:a});return{amountA:m,amountB:d.sub(f),splitFee:y}}static sellExactOut({poolInfo:e,amountB:t,protocolFeeRate:n,platformFeeRate:o,curveType:r,shareFeeRate:i,creatorFeeRate:a,transferFeeConfigA:c,slot:u}){let l=this.totalFeeRate({protocolFeeRate:n,platformFeeRate:o,shareFeeRate:i,creatorFeeRate:a}),m=this.calculatePreFee({postFeeAmount:t,feeRate:l});if(e.realB.lt(m))throw Error("Insufficient liquidity");let p=m.sub(t),f=Ht.getCurve(r).sellExactOut({poolInfo:e,amount:m});if(f.gt(e.realA))throw Error();let y=this.splitFee({totalFee:p,protocolFeeRate:n,platformFeeRate:o,shareFeeRate:i,creatorFeeRate:a});return{amountA:Ua(f,c,u),amountB:t,splitFee:y}}static splitFee({totalFee:e,protocolFeeRate:t,platformFeeRate:n,shareFeeRate:o,creatorFeeRate:r}){let i=this.totalFeeRate({protocolFeeRate:t,platformFeeRate:n,shareFeeRate:o,creatorFeeRate:r}),a=i.isZero()?new jt(0):e.mul(n).div(i),c=i.isZero()?new jt(0):e.mul(o).div(i),u=i.isZero()?new jt(0):e.mul(r).div(i),l=e.sub(a).sub(c).sub(u);return{platformFee:a,shareFee:c,protocolFee:l,creatorFee:u}}static calculateFee({amount:e,feeRate:t}){return dr(e,t,nn)}static calculatePreFee({postFeeAmount:e,feeRate:t}){if(t.isZero())return e;let n=e.mul(nn),o=nn.sub(t);return n.add(o).sub(new jt(1)).div(o)}static totalFeeRate({protocolFeeRate:e,platformFeeRate:t,shareFeeRate:n,creatorFeeRate:o}){if(e.add(t).add(n).add(o).gt(new jt(1e6)))throw Error("total fee rate gt 1_000_000");return e.add(t).add(n).add(o)}static getCurve(e){switch(e){case 0:return ca;case 1:return ma;case 2:return pa}throw Error("find curve error")}};import Wt from"decimal.js";var go={initPriceX64:new re("515752397214619"),supply:new re(1e15),totalSellA:new re(7931e11),totalFundRaisingB:new re(85e9),totalLockedAmount:new re("0"),cliffPeriod:new re("0"),unlockPeriod:new re("0"),decimals:6,virtualA:new re("1073471847374405"),virtualB:new re("30050573465"),realA:new re(0),realB:new re(0),protocolFee:new re(0),platformId:new um("4Bu96XjU84XjPDSpveTVf6LYGCkfW5FK7SNkREWcEfV4"),vestingSchedule:{totalLockedAmount:new re(0),cliffPeriod:new re(0),unlockPeriod:new re(0),startTime:new re(0),totalAllocatedShare:new re(0)}},Xn=new re(1e4),tr=class extends Ve{constructor(e){super(e)}async createLaunchpad(M){var V=M,{programId:e=ct,authProgramId:t,platformId:n=go.platformId,mintA:o,decimals:r=6,mintBDecimals:i=9,name:a,symbol:c,uri:u,migrateType:l,configId:m,snipers:p,configInfo:d,platformFeeRate:f,txVersion:y,computeBudgetConfig:b,txTipConfig:g,feePayer:P,buyAmount:h,minMintAAmount:I,slippage:T,associatedOnly:w=!0,checkCreateATAOwner:x=!1,extraSigners:S,token2022:K,transferFeeExtensionParams:B}=V,C=qe(V,["programId","authProgramId","platformId","mintA","decimals","mintBDecimals","name","symbol","uri","migrateType","configId","snipers","configInfo","platformFeeRate","txVersion","computeBudgetConfig","txTipConfig","feePayer","buyAmount","minMintAAmount","slippage","associatedOnly","checkCreateATAOwner","extraSigners","token2022","transferFeeExtensionParams"]);var zo,Qo,Yo,Nt,or,hu,Iu,Bu,xu,Su;let R=this.createTxBuilder(P);t=t!=null?t:fn(e).publicKey,console.log("snipers: ",p),K=!!B,K&&(l="cpmm");let L=d;if(!L&&m){let un=await this.scope.connection.getAccountInfo(m);un&&(L=Un.decode(un.data))}L||this.logAndCreateError("config not found");let W=L.mintB,z=L.curveType,{publicKey:$}=Wo(e,o,W),{publicKey:ae}=pu(e,$,o),{publicKey:be}=pu(e,$,W),{publicKey:le}=hn(o);this.logDebug(`create token: ${o.toBase58()}, mintB: ${W.toBase58()}, decimals A:${r}/B:${i}, config:${m.toBase58()}`),c.length>10&&this.logAndCreateError("Symbol length should shorter than 11"),u||this.logAndCreateError("uri should not empty");let pe=(zo=C==null?void 0:C.supply)!=null?zo:go.supply,ye=(Qo=C==null?void 0:C.totalSellA)!=null?Qo:go.totalSellA,me=(Yo=C==null?void 0:C.totalFundRaisingB)!=null?Yo:go.totalFundRaisingB,ee=(Nt=C==null?void 0:C.totalLockedAmount)!=null?Nt:new re(0),Ce=f;if(!f){let un=await this.scope.connection.getAccountInfo(n);un||this.logAndCreateError("platform id not found:",n.toString()),Ce=Uo.decode(un.data).feeRate}let kt=Ht.getCurve(L.curveType).getInitParam({supply:pe,totalFundRaising:me,totalSell:ye,totalLockedAmount:ee,migrateFee:L.migrateFee}),dt={epoch:new re(896),bump:254,status:0,mintDecimalsA:r,mintDecimalsB:i,supply:pe,totalSellA:ye,mintA:new um(o),mintB:W,virtualA:kt.a,virtualB:kt.b,realA:go.realA,realB:go.realB,migrateFee:L.migrateFee,migrateType:l==="amm"?0:1,protocolFee:go.protocolFee,platformFee:Ce,platformId:n,configId:m,vaultA:ae,vaultB:be,creator:this.scope.ownerPubKey,totalFundRaisingB:me,vestingSchedule:{totalLockedAmount:ee,cliffPeriod:new re(0),unlockPeriod:new re(0),startTime:new re(0),totalAllocatedShare:new re(0)},mintProgramFlag:K?1:0},yn=Ht.getCurve(L.curveType),{c:rt}=yn.getInitParam({supply:dt.supply,totalFundRaising:dt.totalFundRaisingB,totalLockedAmount:ee,totalSell:L.curveType===0?dt.totalSellA:new re(0),migrateFee:L.migrateFee});try{Ht.checkParam({supply:dt.supply,totalFundRaising:dt.totalFundRaisingB,totalSell:rt,totalLockedAmount:ee,decimals:dt.mintDecimalsA,config:L,migrateType:l}),this.logDebug("check init params success")}catch(un){this.logAndCreateError(`check create mint params failed, ${un.message}`)}R.addInstruction({instructions:[K?Jl(e,P!=null?P:this.scope.ownerPubKey,this.scope.ownerPubKey,m,n,t,$,o,W,ae,be,r,a,c,u||"https://",{type:z===0?"ConstantCurve":z===1?"FixedCurve":z===2?"LinearCurve":"ConstantCurve",totalSellA:ye,migrateType:l,supply:pe,totalFundRaisingB:me},ee,(or=C==null?void 0:C.cliffPeriod)!=null?or:new re(0),(hu=C==null?void 0:C.unlockPeriod)!=null?hu:new re(0),B):$l(e,P!=null?P:this.scope.ownerPubKey,this.scope.ownerPubKey,m,n,t,$,o,W,ae,be,le,r,a,c,u||"https://",{type:z===0?"ConstantCurve":z===1?"FixedCurve":z===2?"LinearCurve":"ConstantCurve",totalSellA:ye,migrateType:l,supply:pe,totalFundRaisingB:me},ee,(Iu=C==null?void 0:C.cliffPeriod)!=null?Iu:new re(0),(Bu=C==null?void 0:C.unlockPeriod)!=null?Bu:new re(0))]});let zn=K?await this.scope.connection.getEpochInfo():void 0,St=B?{epoch:BigInt((zn==null?void 0:zn.epoch)||0),maximumFee:BigInt((xu=B==null?void 0:B.maxinumFee.toString())!=null?xu:0),transferFeeBasisPoints:(Su=B==null?void 0:B.transferFeeBasePoints)!=null?Su:0}:void 0,Xo={amountA:{amount:new re(0),fee:void 0,expirationTime:void 0},amountB:new re(0),splitFee:{platformFee:new re(0),shareFee:new re(0),protocolFee:new re(0),creatorFee:new re(0)}},Ao;if(S!=null&&S.length&&R.addInstruction({signers:S}),!C.createOnly){let{builder:un,extInfo:cm}=await this.buyToken({programId:e,authProgramId:t,mintAProgram:K?Cn:void 0,mintA:o,mintB:W,poolInfo:dt,buyAmount:h,minMintAAmount:I,shareFeeRate:C.shareFeeRate,shareFeeReceiver:C.shareFeeReceiver,configInfo:L,platformFeeRate:Ce,slippage:T,associatedOnly:w,checkCreateATAOwner:x,skipCheckMintA:!St,transferFeeConfigA:St?{transferFeeConfigAuthority:t,withdrawWithheldAuthority:t,withheldAmount:BigInt(0),olderTransferFee:St,newerTransferFee:St}:void 0}),{builder:yy,extInfo:by}=await this.buyToken({programId:e,authProgramId:t,mintAProgram:K?Cn:void 0,mintA:o,mintB:W,poolInfo:dt,buyAmount:h,minMintAAmount:I,shareFeeRate:C.shareFeeRate,shareFeeReceiver:C.shareFeeReceiver,configInfo:L,platformFeeRate:Ce,slippage:T,associatedOnly:w,checkCreateATAOwner:x,skipCheckMintA:!St,transferFeeConfigA:St?{transferFeeConfigAuthority:t,withdrawWithheldAuthority:t,withheldAmount:BigInt(0),olderTransferFee:St,newerTransferFee:St}:void 0}),{builder:gy,extInfo:Ay}=await this.buyToken({programId:e,authProgramId:t,mintAProgram:K?Cn:void 0,mintA:o,mintB:W,poolInfo:dt,buyAmount:h,minMintAAmount:I,shareFeeRate:C.shareFeeRate,shareFeeReceiver:C.shareFeeReceiver,configInfo:L,platformFeeRate:Ce,slippage:T,associatedOnly:w,checkCreateATAOwner:x,skipCheckMintA:!St,transferFeeConfigA:St?{transferFeeConfigAuthority:t,withdrawWithheldAuthority:t,withheldAmount:BigInt(0),olderTransferFee:St,newerTransferFee:St}:void 0});R.addInstruction(N({},un.AllTxData)),Xo=N({},cm),Ao=(this.scope.cluster==="devnet"||y===1)&&C.shareFeeReceiver?[un.allInstructions[0]]:void 0}return R.addTipInstruction(g),y===0?R.sizeCheckBuildV0({computeBudgetConfig:b,swapInfo:Xo,splitIns:Ao,address:q(N({},dt),{poolId:$})}):R.sizeCheckBuild({computeBudgetConfig:b,swapInfo:Xo,splitIns:Ao,address:q(N({},dt),{poolId:$})})}async buyToken({programId:e=ct,authProgramId:t,mintA:n,mintAProgram:o=Xe,mintB:r=Kn,poolInfo:i,configInfo:a,platformFeeRate:c,txVersion:u,computeBudgetConfig:l,txTipConfig:m,feePayer:p,buyAmount:d,minMintAAmount:f,slippage:y,shareFeeRate:b=new re(0),shareFeeReceiver:g,associatedOnly:P=!0,checkCreateATAOwner:h=!1,transferFeeConfigA:I,skipCheckMintA:T=!1}){var me,ee,Ce;d.lte(new re(0))&&this.logAndCreateError("buy amount should gt 0:",d.toString());let w=this.createTxBuilder(p),{publicKey:x}=Wo(e,n,r);t=t!=null?t:fn(e).publicKey;let S=I;if(!T)if(S)o=Cn;else{let Ie=await this.scope.connection.getAccountInfo(n);if(Ie&&Ie.owner.equals(Cn)){o=Ie.owner;let kt=ya(n,Ie,o);S=fa(kt)||void 0}}let K=this.scope.account.getAssociatedTokenAccount(n,o),B=null,C=r.equals(Kn);w.addInstruction({instructions:[Zt(this.scope.ownerPubKey,K,this.scope.ownerPubKey,n,o)]});let{account:M,instructionParams:V}=await this.scope.account.getOrCreateTokenAccount({mint:r,owner:this.scope.ownerPubKey,createInfo:C?{payer:this.scope.ownerPubKey,amount:d}:void 0,skipCloseAccount:!C,notUseTokenAccount:C,associatedOnly:C?!1:P,checkCreateATAOwner:h});M&&(B=M),w.addInstruction(V||{}),B===void 0&&this.logAndCreateError(`cannot found mintB(${r.toBase58()}) token accounts`,"tokenAccounts",this.scope.account.tokenAccounts);let R=i;if(!R){let Ie=await this.scope.connection.getAccountInfo(x,{commitment:"processed"});Ie||this.logAndCreateError("cannot found pool:",x.toBase58()),R=sn.decode(Ie.data)}let L=a,W=await Me(this.scope.connection,[L?void 0:R.configId,R.platformId].filter(Boolean).map(Ie=>({pubkey:Ie})));if(!L){let Ie=W.find(kt=>kt.pubkey.equals(R.configId));(!Ie||!Ie.accountInfo)&&this.logAndCreateError("config not found: ",R.configId.toBase58()),L=Un.decode(Ie.accountInfo.data)}let z=W.find(Ie=>Ie.pubkey.equals(R.platformId));(!z||!z.accountInfo)&&this.logAndCreateError("platform info not found: ",R.configId.toBase58());let $=Uo.decode(z.accountInfo.data);c=c||$.feeRate;let ae=Ht.buyExactIn({poolInfo:R,amountB:d,protocolFeeRate:L.tradeFeeRate,platformFeeRate:c,curveType:L.curveType,shareFeeRate:b,creatorFeeRate:$.creatorFeeRate,transferFeeConfigA:S,slot:await this.scope.connection.getSlot()}),be=new Wt(ae.amountA.amount.toString()).sub((ee=(me=ae.amountA.fee)==null?void 0:me.toString())!=null?ee:0),le=y?new Wt(Xn.sub(y).toNumber()/Xn.toNumber()).clampedTo(0,1):new Wt(1),pe=f!=null?f:y?new re(be.mul(le).toFixed(0)):ae.amountA.amount.sub((Ce=ae.amountA.fee)!=null?Ce:new re(0));ae.amountB.lt(d)&&console.log(`maximum ${n.toBase58()} amount can buy is ${ae.amountA.toString()}, input ${r.toBase58()} amount: ${ae.amountB.toString()}`);let ye=g?j(g,r,Xe).publicKey:void 0;return ye&&w.addInstruction({instructions:[Zt(this.scope.ownerPubKey,ye,g,r)]}),w.addInstruction({instructions:[em(e,this.scope.ownerPubKey,t,R.configId,R.platformId,x,K,B,R.vaultA,R.vaultB,n,r,o,Xe,yo(e,R.platformId,r).publicKey,qo(e,R.creator,r).publicKey,ae.amountB.lt(d)?ae.amountB:d,pe,b,ye)]}),w.addCustomComputeBudget(l),w.addTipInstruction(m),w.versionBuild({txVersion:u,extInfo:q(N({},ae),{decimalOutAmount:be,minDecimalOutAmount:new Wt(pe.toString())})})}async buyTokenExactOut({programId:e=ct,authProgramId:t,mintA:n,mintAProgram:o=Xe,mintB:r=Kn,poolInfo:i,configInfo:a,transferFeeConfigA:c,platformFeeRate:u,txVersion:l,computeBudgetConfig:m,txTipConfig:p,feePayer:d,maxBuyAmount:f,outAmount:y,slippage:b,shareFeeRate:g=new re(0),shareFeeReceiver:P,associatedOnly:h=!0,checkCreateATAOwner:I=!1,skipCheckMintA:T=!1}){y.lte(new re(0))&&this.logAndCreateError("out amount should gt 0:",y.toString());let w=this.createTxBuilder(d),{publicKey:x}=Wo(e,n,r);t=t!=null?t:fn(e).publicKey;let S=i;if(!S){let me=await this.scope.connection.getAccountInfo(x,{commitment:"processed"});me||this.logAndCreateError("cannot found pool:",x.toBase58()),S=sn.decode(me.data)}let K=a,B=await Me(this.scope.connection,[K?void 0:S.configId,S.platformId].filter(Boolean).map(me=>({pubkey:me})));if(!K){let me=B.find(ee=>ee.pubkey.equals(S.configId));(!me||!me.accountInfo)&&this.logAndCreateError("config not found: ",S.configId.toBase58()),K=Un.decode(me.accountInfo.data)}let C=B.find(me=>me.pubkey.equals(S.platformId));(!C||!C.accountInfo)&&this.logAndCreateError("platform info not found: ",S.configId.toBase58());let M=Uo.decode(C.accountInfo.data);u=u||M.feeRate;let V=c;if(!T)if(V)o=Cn;else{let me=await this.scope.connection.getAccountInfo(n);if(me&&me.owner.equals(Cn)){o=me.owner;let ee=ya(n,me,o);V=fa(ee)||void 0}}let R=Ht.buyExactOut({poolInfo:S,amountA:y,protocolFeeRate:K.tradeFeeRate,platformFeeRate:u,curveType:K.curveType,shareFeeRate:g,creatorFeeRate:M.creatorFeeRate,transferFeeConfigA:V,slot:await this.scope.connection.getSlot()}),L=new Wt(R.amountB.toString()),W=b?new Wt(Xn.add(b).toNumber()/Xn.toNumber()).clampedTo(0,Number.MIN_SAFE_INTEGER):new Wt(1),z=(f!=null?f:b)?new re(L.mul(W).toFixed(0)):R.amountB,$=this.scope.account.getAssociatedTokenAccount(n,o),ae=null,be=r.equals(Kn);w.addInstruction({instructions:[Zt(this.scope.ownerPubKey,$,this.scope.ownerPubKey,n,o)]});let{account:le,instructionParams:pe}=await this.scope.account.getOrCreateTokenAccount({mint:r,owner:this.scope.ownerPubKey,createInfo:be?{payer:this.scope.ownerPubKey,amount:R.amountB}:void 0,skipCloseAccount:!be,notUseTokenAccount:be,associatedOnly:be?!1:h,checkCreateATAOwner:I});le&&(ae=le),w.addInstruction(pe||{}),ae===void 0&&this.logAndCreateError(`cannot found mintB(${r.toBase58()}) token accounts`,"tokenAccounts",this.scope.account.tokenAccounts);let ye=P?j(P,r,Xe).publicKey:void 0;return ye&&w.addInstruction({instructions:[Zt(this.scope.ownerPubKey,ye,P,r)]}),w.addInstruction({instructions:[tm(e,this.scope.ownerPubKey,t,S.configId,S.platformId,x,$,ae,S.vaultA,S.vaultB,n,r,o,Xe,yo(e,S.platformId,r).publicKey,qo(e,S.creator,r).publicKey,y,z,g,ye)]}),w.addCustomComputeBudget(m),w.addTipInstruction(p),w.versionBuild({txVersion:l,extInfo:{maxSpentAmount:z,outAmount:y}})}async sellToken({programId:e=ct,authProgramId:t,mintAProgram:n=Xe,mintA:o,mintB:r=Kn,poolInfo:i,configInfo:a,platformFeeRate:c,txVersion:u,computeBudgetConfig:l,txTipConfig:m,feePayer:p,sellAmount:d,minAmountB:f,slippage:y,shareFeeRate:b=new re(0),shareFeeReceiver:g,associatedOnly:P=!0,checkCreateATAOwner:h=!1,skipCheckMintA:I=!1}){t=t!=null?t:fn(e).publicKey;let T=this.createTxBuilder(p);d.lte(new re(0))&&this.logAndCreateError("sell amount should be gt 0");let{publicKey:w}=Wo(e,o,r),x;if(!I){let ee=await this.scope.connection.getAccountInfo(o);if(ee&&ee.owner.equals(Cn)){n=ee.owner;let Ce=ya(o,ee,n);x=fa(Ce)||void 0}}let S=null,K=null,B=r.equals(Kn),{account:C,instructionParams:M}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:n,mint:o,owner:this.scope.ownerPubKey,createInfo:void 0,skipCloseAccount:!0,notUseTokenAccount:!1,associatedOnly:P,checkCreateATAOwner:h});C&&(S=C),T.addInstruction(M||{}),S===void 0&&this.logAndCreateError("cannot found mintA token accounts","tokenAccounts",this.scope.account.tokenAccounts);let{account:V,instructionParams:R}=await this.scope.account.getOrCreateTokenAccount({mint:r,owner:this.scope.ownerPubKey,createInfo:B?{payer:this.scope.ownerPubKey,amount:0}:void 0,skipCloseAccount:!B,notUseTokenAccount:B,associatedOnly:B?!1:P,checkCreateATAOwner:h});V&&(K=V),T.addInstruction(R||{}),K===void 0&&this.logAndCreateError("cannot found mintB token accounts","tokenAccounts",this.scope.account.tokenAccounts);let L=i;if(!L){let ee=await this.scope.connection.getAccountInfo(w,{commitment:"processed"});ee||this.logAndCreateError("cannot found pool",w.toBase58()),L=sn.decode(ee.data)}let W=a,z=await Me(this.scope.connection,[W?void 0:L.configId,L.platformId].filter(Boolean).map(ee=>({pubkey:ee})));if(!W){let ee=z.find(Ce=>Ce.pubkey.equals(L.configId));(!ee||!ee.accountInfo)&&this.logAndCreateError("config not found: ",L.configId.toBase58()),W=Un.decode(ee.accountInfo.data)}let $=z.find(ee=>ee.pubkey.equals(L.platformId));(!$||!$.accountInfo)&&this.logAndCreateError("platform info not found: ",L.configId.toBase58());let ae=Uo.decode($.accountInfo.data);c=c||ae.feeRate;let be=Ht.sellExactIn({poolInfo:L,amountA:d,protocolFeeRate:W.tradeFeeRate,platformFeeRate:c,curveType:W.curveType,shareFeeRate:b,creatorFeeRate:ae.creatorFeeRate,transferFeeConfigA:x,slot:await this.scope.connection.getSlot()}),le=new Wt(be.amountB.toString()),pe=y?new Wt(Xn.sub(y).toNumber()/Xn.toNumber()).clampedTo(0,1):new Wt(1),ye=f!=null?f:y?new re(le.mul(pe).toFixed(0)):be.amountB;ye.lte(new re(0))&&this.logAndCreateError(`out ${r.toBase58()} amount should be gt 0`);let me=g?j(g,r,Xe).publicKey:void 0;return me&&T.addInstruction({instructions:[Zt(this.scope.ownerPubKey,me,g,r)]}),T.addInstruction({instructions:[nm(e,this.scope.ownerPubKey,t,L.configId,L.platformId,w,S,K,L.vaultA,L.vaultB,o,r,n,Xe,yo(e,L.platformId,r).publicKey,qo(e,L.creator,r).publicKey,be.amountA.amount.lt(d)?be.amountA.amount:d,ye,b,me)]}),T.addCustomComputeBudget(l),T.addTipInstruction(m),T.versionBuild({txVersion:u,extInfo:{outAmount:ye}})}async sellTokenExactOut({programId:e=ct,authProgramId:t,mintAProgram:n=Xe,mintA:o,mintB:r=Kn,poolInfo:i,configInfo:a,platformFeeRate:c,txVersion:u,computeBudgetConfig:l,txTipConfig:m,feePayer:p,inAmount:d,maxSellAmount:f,slippage:y,shareFeeRate:b=new re(0),shareFeeReceiver:g,associatedOnly:P=!0,checkCreateATAOwner:h=!1,skipCheckMintA:I=!1}){t=t!=null?t:fn(e).publicKey;let T=this.createTxBuilder(p);f!=null&&f.lte(new re(0))&&this.logAndCreateError("max sell amount should be gt 0");let{publicKey:w}=Wo(e,o,r),x;if(!I){let ee=await this.scope.connection.getAccountInfo(o);if(ee&&ee.owner.equals(Cn)){n=ee.owner;let Ce=ya(o,ee,n);x=fa(Ce)||void 0}}let S=null,K=null,B=r.equals(Kn),{account:C,instructionParams:M}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:n,mint:o,owner:this.scope.ownerPubKey,createInfo:void 0,skipCloseAccount:!0,notUseTokenAccount:!1,associatedOnly:P,checkCreateATAOwner:h});C&&(S=C),T.addInstruction(M||{}),S===void 0&&this.logAndCreateError("cannot found mintA token accounts","tokenAccounts",this.scope.account.tokenAccounts);let{account:V,instructionParams:R}=await this.scope.account.getOrCreateTokenAccount({mint:r,owner:this.scope.ownerPubKey,createInfo:B?{payer:this.scope.ownerPubKey,amount:0}:void 0,skipCloseAccount:!B,notUseTokenAccount:B,associatedOnly:B?!1:P,checkCreateATAOwner:h});V&&(K=V),T.addInstruction(R||{}),K===void 0&&this.logAndCreateError("cannot found mintB token accounts","tokenAccounts",this.scope.account.tokenAccounts);let L=i;if(!L){let ee=await this.scope.connection.getAccountInfo(w,{commitment:"processed"});ee||this.logAndCreateError("cannot found pool",w.toBase58()),L=sn.decode(ee.data)}let W=a,z=await Me(this.scope.connection,[W?void 0:L.configId,L.platformId].filter(Boolean).map(ee=>({pubkey:ee})));if(!W){let ee=z.find(Ce=>Ce.pubkey.equals(L.configId));(!ee||!ee.accountInfo)&&this.logAndCreateError("config not found: ",L.configId.toBase58()),W=Un.decode(ee.accountInfo.data)}let $=z.find(ee=>ee.pubkey.equals(L.platformId));(!$||!$.accountInfo)&&this.logAndCreateError("platform info not found: ",L.configId.toBase58());let ae=Uo.decode($.accountInfo.data);c=c||ae.feeRate;let be=Ht.sellExactOut({poolInfo:L,amountB:d,protocolFeeRate:W.tradeFeeRate,platformFeeRate:c,curveType:W.curveType,shareFeeRate:b,creatorFeeRate:ae.creatorFeeRate,transferFeeConfigA:x,slot:await this.scope.connection.getSlot()}),le=new Wt(be.amountA.amount.toString()),pe=y?new Wt(Xn.add(y).toNumber()/Xn.toNumber()).clampedTo(0,Number.MAX_SAFE_INTEGER):new Wt(1),ye=(f!=null?f:y)?new re(le.mul(pe).toFixed(0)):be.amountA.amount,me=g?j(g,r,Xe).publicKey:void 0;return me&&T.addInstruction({instructions:[Zt(this.scope.ownerPubKey,me,g,r)]}),T.addInstruction({instructions:[om(e,this.scope.ownerPubKey,t,L.configId,L.platformId,w,S,K,L.vaultA,L.vaultB,o,r,n,Xe,yo(e,L.platformId,r).publicKey,qo(e,L.creator,r).publicKey,d,ye,b,me)]}),T.addCustomComputeBudget(l),T.addTipInstruction(m),T.versionBuild({txVersion:u,extInfo:{maxSellAmount:ye}})}async createPlatformConfig({programId:e=ct,platformAdmin:t,platformClaimFeeWallet:n,platformLockNftWallet:o,cpConfigId:r,migrateCpLockNftScale:i,transferFeeExtensionAuth:a,creatorFeeRate:c,feeRate:u,name:l,web:m,img:p,txVersion:d,computeBudgetConfig:f,txTipConfig:y,feePayer:b}){let g=this.createTxBuilder(b),{publicKey:P}=fu(e,t);return g.addInstruction({instructions:[im(e,t,n,o,P,r,a,i,u,c,l,m,p)]}),g.addCustomComputeBudget(f),g.addTipInstruction(y),g.versionBuild({txVersion:d,extInfo:{platformId:P}})}async updatePlatformConfig({programId:e=ct,platformAdmin:t,platformId:n,updateInfo:o,txVersion:r,computeBudgetConfig:i,txTipConfig:a,feePayer:c}){let u=this.createTxBuilder(c),l=n!=null?n:fu(e,t).publicKey;return u.addInstruction({instructions:[rm(e,t,l,o)]}),u.addCustomComputeBudget(i),u.addTipInstruction(a),u.versionBuild({txVersion:r})}async claimPlatformFee({programId:e=ct,authProgramId:t,platformId:n,poolId:o,platformClaimFeeWallet:r,mintB:i,vaultB:a,mintBProgram:c=Xe,txVersion:u,computeBudgetConfig:l,txTipConfig:m,feePayer:p}){var g;let d=this.createTxBuilder(p);t=t!=null?t:fn(e).publicKey;let f=i,y=a;if(!f){let P=await this.scope.connection.getAccountInfo(o,{commitment:"processed"});P||this.logAndCreateError("cannot found pool:",o.toBase58());let h=sn.decode(P.data),I=await this.scope.connection.getAccountInfo(h.configId,{commitment:"processed"});I||this.logAndCreateError("cannot found config:",h.configId.toBase58()),f=Un.decode(I.data).mintB,y=y!=null?y:h.vaultB}(!f||!y)&&this.logAndCreateError("cannot found mint info, mintB: ",f.toBase58(),", vaultB: ",(g=y==null?void 0:y.toBase58())!=null?g:"");let b=j(this.scope.ownerPubKey,f,Xe).publicKey;return d.addInstruction({instructions:[Zt(this.scope.ownerPubKey,b,this.scope.ownerPubKey,f)]}),d.addInstruction({instructions:[Pu(e,r,t,o,n,y,b,f,c)]}),d.addCustomComputeBudget(l),d.addTipInstruction(m),d.versionBuild({txVersion:u})}async claimAllPlatformFee({programId:e=ct,authProgramId:t,platformId:n,platformClaimFeeWallet:o,txVersion:r,computeBudgetConfig:i,txTipConfig:a,feePayer:c}){let u=this.createTxBuilder(c);return t=t!=null?t:fn(e).publicKey,(await this.scope.connection.getProgramAccounts(e,{filters:[{dataSize:sn.span},{memcmp:{offset:sn.offsetOf("platformId"),bytes:n.toString()}}]})).forEach(m=>{let p=sn.decode(m.account.data);if(p.platformFee.lte(new re(0)))return;let d=j(this.scope.ownerPubKey,p.mintB,Xe).publicKey;u.addInstruction({instructions:[Zt(this.scope.ownerPubKey,d,this.scope.ownerPubKey,p.mintB)]}),u.addInstruction({instructions:[Pu(e,o,t,m.pubkey,n,p.vaultB,d,p.mintB,Xe)]})}),u.addTipInstruction(a),r===0?u.sizeCheckBuildV0({computeBudgetConfig:i}):u.sizeCheckBuild({computeBudgetConfig:i})}async createVesting({programId:e=ct,poolId:t,beneficiary:n,shareAmount:o,txVersion:r,computeBudgetConfig:i,txTipConfig:a,feePayer:c}){let u=this.createTxBuilder(c),l=await this.getRpcPoolInfo({poolId:t});o.add(l.vestingSchedule.totalAllocatedShare).gt(l.vestingSchedule.totalLockedAmount)&&this.logAndCreateError("share amount exceed total locked amount");let m=Hi(e,t,n).publicKey;return u.addInstruction({instructions:[Au(e,this.scope.ownerPubKey,n,t,m,o)]}),u.addCustomComputeBudget(i),u.addTipInstruction(a),u.versionBuild({txVersion:r})}async createMultipleVesting({programId:e=ct,poolId:t,beneficiaryList:n,txVersion:o,computeBudgetConfig:r,feePayer:i}){let a=this.createTxBuilder(i);n.length===0&&this.logAndCreateError("beneficiaryList is null");let c=await this.getRpcPoolInfo({poolId:t});return n.reduce((l,m)=>l.add(m.shareAmount),c.vestingSchedule.totalAllocatedShare).gt(c.vestingSchedule.totalLockedAmount)&&this.logAndCreateError("share amount exceed total locked amount"),n.forEach(l=>{let m=Hi(e,t,l.wallet).publicKey;a.addInstruction({instructions:[Au(e,this.scope.ownerPubKey,l.wallet,t,m,l.shareAmount)]})}),o===0?a.sizeCheckBuildV0({computeBudgetConfig:r}):a.sizeCheckBuild({computeBudgetConfig:r})}async claimVesting({programId:e=ct,poolId:t,poolInfo:n,vestingRecord:o,txVersion:r,computeBudgetConfig:i,txTipConfig:a,feePayer:c}){let u=this.createTxBuilder(c),l=fn(e).publicKey,m=o||Hi(e,t,this.scope.ownerPubKey).publicKey,p=n;if(!p){let f=await this.scope.connection.getAccountInfo(t);f||this.logAndCreateError("pool not found"),p=sn.decode(f.data)}let d=j(this.scope.ownerPubKey,p.mintA,Xe).publicKey;return u.addInstruction({instructions:[Zt(this.scope.ownerPubKey,d,this.scope.ownerPubKey,p.mintA)]}),u.addInstruction({instructions:[gu(e,this.scope.ownerPubKey,l,t,m,d,p.vaultA,p.mintA,Xe)]}),u.addCustomComputeBudget(i),u.addTipInstruction(a),u.versionBuild({txVersion:r})}async claimMultiVesting({programId:e=ct,poolIdList:t,poolsInfo:n={},vestingRecords:o={},txVersion:r,computeBudgetConfig:i,feePayer:a}){let c=this.createTxBuilder(a),u=N({},n),l=fn(e).publicKey,m=t.filter(p=>!u[p.toBase58()]);if(m.length){let p=await this.getRpcPoolsInfo({poolIdList:m});u=N(N({},u),p.poolInfoMap)}return t.forEach(p=>{let d=p.toBase58(),f=u[d];f||this.logAndCreateError(`pool info not found: ${d}`);let y=o[d]||Hi(e,p,this.scope.ownerPubKey).publicKey,b=j(this.scope.ownerPubKey,f.mintA,Xe).publicKey;c.addInstruction({instructions:[Zt(this.scope.ownerPubKey,b,this.scope.ownerPubKey,f.mintA)]}),c.addInstruction({instructions:[gu(e,this.scope.ownerPubKey,l,p,y,b,f.vaultA,f.mintA,Xe)]})}),r===0?c.sizeCheckBuildV0({computeBudgetConfig:i}):c.sizeCheckBuild({computeBudgetConfig:i})}async claimVaultPlatformFee({programId:e=ct,platformId:t,mintB:n,mintBProgram:o=Xe,claimFeeWallet:r,txVersion:i,computeBudgetConfig:a,txTipConfig:c,feePayer:u}){let l=this.createTxBuilder(u),m=yo(e,t,n).publicKey,p=yu(e).publicKey,d=this.scope.account.getAssociatedTokenAccount(n,o);return l.addInstruction({instructions:[Zt(this.scope.ownerPubKey,d,this.scope.ownerPubKey,n,o),ku(e,t,r!=null?r:this.scope.ownerPubKey,p,m,d,n,o)]}),l.addCustomComputeBudget(a),l.addTipInstruction(c),l.versionBuild({txVersion:i})}async claimMultipleVaultPlatformFee({programId:e=ct,platformList:t,unwrapSol:n=!0,txVersion:o,computeBudgetConfig:r,feePayer:i,associatedOnly:a=!0,checkCreateATAOwner:c=!1}){let u=this.createTxBuilder(i),l={};return t.forEach(async m=>{var b,g;let p=yu(e).publicKey,d=yo(e,m.id,m.mintB).publicKey,f=m.mintB.equals(Kn)&&n,y=l[m.mintB.toBase58()];if(!y){let{account:P,instructionParams:h}=await this.scope.account.getOrCreateTokenAccount({mint:m.mintB,owner:this.scope.ownerPubKey,createInfo:f?{payer:this.scope.ownerPubKey,amount:0}:void 0,skipCloseAccount:!f,notUseTokenAccount:f,associatedOnly:f?!1:a,checkCreateATAOwner:c});P&&(y=P),u.addInstruction(h||{}),y===void 0&&this.logAndCreateError(`cannot found platform ${m.id.toBase58()} mintB(${m.mintB.toBase58()}) token accounts`,"tokenAccounts",this.scope.account.tokenAccounts)}u.addInstruction({instructions:[ku(e,m.id,(b=m.claimFeeWallet)!=null?b:this.scope.ownerPubKey,d,p,y,m.mintB,(g=m.mintBProgram)!=null?g:Xe)]})}),o===0?u.sizeCheckBuildV0({computeBudgetConfig:r}):u.sizeCheckBuild({computeBudgetConfig:r})}async claimCreatorFee({programId:e=ct,mintB:t,mintBProgram:n=Xe,txVersion:o,computeBudgetConfig:r,txTipConfig:i,feePayer:a}){let c=this.createTxBuilder(a),u=qo(e,this.scope.ownerPubKey,t).publicKey,l=Zl(e).publicKey,m=this.scope.account.getAssociatedTokenAccount(t,n);return c.addInstruction({instructions:[Zt(this.scope.ownerPubKey,m,this.scope.ownerPubKey,t,n),am(e,this.scope.ownerPubKey,l,u,m,t,n)]}),c.addCustomComputeBudget(r),c.addTipInstruction(i),c.versionBuild({txVersion:o})}async getRpcPoolInfo({poolId:e}){return(await this.getRpcPoolsInfo({poolIdList:[e]})).poolInfoMap[e.toBase58()]}async getRpcPoolsInfo({poolIdList:e,config:t}){let n=await Me(this.scope.connection,e.map(c=>({pubkey:c})),t),o={},r=[];for(let c=0;c<e.length;c++){let u=n[c];if(u===null||!u.accountInfo)throw Error("fetch pool info error: "+e[c].toBase58());let l=sn.decode(u.accountInfo.data);o[e[c].toBase58()]=q(N({},l),{poolId:u.accountInfo.owner}),r.push(l.configId)}let i=await Me(this.scope.connection,r.map(c=>({pubkey:c})),t),a={};for(let c=0;c<r.length;c++){let u=i[c];if(u===null||!u.accountInfo)throw Error("fetch config info error: "+r[c].toBase58());let l=Un.decode(u.accountInfo.data);a[r[c].toBase58()]=q(N({},l),{configId:u.accountInfo.owner})}return{poolInfoMap:Object.keys(o).reduce((c,u)=>q(N({},c),{[u]:q(N({},o[u]),{configInfo:a[o[u].configId.toBase58()]})}),{})}}};import{PublicKey as dy}from"@solana/web3.js";import{MintLayout as py,TOKEN_2022_PROGRAM_ID as wu,TOKEN_PROGRAM_ID as Tu}from"@solana/spl-token";var nr=class extends Ve{constructor(t){super(t);this._tokenList=[];this._tokenMap=new Map;this._blackTokenMap=new Set;this._mintGroup={official:new Set,jup:new Set,extra:new Set};this._whiteMap=new Set;this._extraTokenList=[]}async load(t){this.checkDisabled();let{forceUpdate:n=!1,type:o="strict"}=t||{},{mintList:r,blacklist:i,whiteList:a}=await this.scope.fetchV3TokenList(n),c=await this.scope.fetchJupTokenList(n);this._tokenList=[],this._tokenMap=new Map,this._blackTokenMap=new Set(i),this._mintGroup={official:new Set,jup:new Set,extra:new Set},this._whiteMap=new Set(a),this._tokenMap.set(cn.address,cn),this._mintGroup.official.add(cn.address),r.forEach(u=>{var l;this._blackTokenMap.has(u.address)||(this._tokenMap.set(u.address,q(N({},u),{type:"raydium",priority:2,programId:(l=u.programId)!=null?l:u.tags.includes("token-2022")?wu.toBase58():Tu.toBase58()})),this._mintGroup.official.add(u.address))}),c.forEach(u=>{var l;this._blackTokenMap.has(u.address)||this._tokenMap.has(u.address)||(this._tokenMap.set(u.address,q(N({},u),{type:"jupiter",priority:1,programId:(l=u.programId)!=null?l:u.tags.includes("token-2022")?wu.toBase58():Tu.toBase58(),tags:u.freezeAuthority?[...u.tags||[],"hasFreeze"]:u.tags})),this._mintGroup.jup.add(u.address))}),this._extraTokenList.forEach(u=>{this._blackTokenMap.has(u.address)||this._tokenMap.has(u.address)||(this._tokenMap.set(u.address,q(N({},u),{type:"extra",priority:1,programId:u.programId||u.tags.includes("token-2022")?wu.toBase58():Tu.toBase58()})),this._mintGroup.extra.add(u.address))}),this._tokenList=Array.from(this._tokenMap).map(u=>u[1])}get tokenList(){return this._tokenList}get tokenMap(){return this._tokenMap}get blackTokenMap(){return this._blackTokenMap}get mintGroup(){return this._mintGroup}get whiteListMap(){return this._whiteMap}async getTokenInfo(t){if(!t)throw new Error("please input mint");let n=t.toString(),o=this._tokenMap.get(n);if(o)return o;if(n.toLocaleUpperCase()==="SOL")return cn;let r=(await this.scope.api.getTokenInfo([n]))[0];if(r)return this._mintGroup.extra.add(n),this._tokenMap.set(n,q(N({},r),{priority:2})),r;let i=await this.scope.connection.getAccountInfo(new dy(n));if(!i)throw new Error(`mint address not found: ${n}`);let a=py.decode(i.data),c=n.toString().substring(0,6),u={chainId:101,address:n,programId:i.owner.toBase58(),logoURI:"",symbol:c,name:c,decimals:a.decimals,tags:[],extensions:{},priority:0,type:"unknown"};return this._mintGroup.extra.add(n),this._tokenMap.set(n,u),u}};var ba=class{constructor(e){this.rawBalances=new Map;let{connection:t,cluster:n,owner:o,api:r,defaultChainTime:i,defaultChainTimeOffset:a,apiCacheTime:c,blockhashCommitment:u="confirmed",loopMultiTxStatus:l}=e;this._connection=t,this.cluster=n||"mainnet",this._owner=o?new en(o):void 0,this._signAllTransactions=e.signAllTransactions,this.blockhashCommitment=u,this.loopMultiTxStatus=l,this.api=r,this._apiCacheTime=c||5*60*1e3,this.logger=fe("Raydium"),this.farm=new Ti({scope:this,moduleName:"Raydium_Farm"}),this.account=new di({scope:this,moduleName:"Raydium_Account",tokenAccounts:e.tokenAccounts,tokenAccountRawInfos:e.tokenAccountRawInfos}),this.liquidity=new Fi({scope:this,moduleName:"Raydium_LiquidityV2"}),this.token=new nr({scope:this,moduleName:"Raydium_tokenV2"}),this.tradeV2=new Qi({scope:this,moduleName:"Raydium_tradeV2"}),this.clmm=new _i({scope:this,moduleName:"Raydium_clmm"}),this.cpmm=new Ui({scope:this,moduleName:"Raydium_cpmm"}),this.utils1216=new Qt({scope:this,moduleName:"Raydium_utils1216"}),this.marketV2=new Vo({scope:this,moduleName:"Raydium_marketV2"}),this.ido=new Do({scope:this,moduleName:"Raydium_ido"}),this.launchpad=new tr({scope:this,moduleName:"Raydium_lauchpad"}),this.availability={};let m=new Date().getTime();this.apiData={},a&&(this._chainTime={fetched:m,value:{chainTime:i||Date.now()-a,offset:a}})}static async load(e){var l;let t=fy({cluster:"mainnet",owner:null,apiRequestInterval:3e5,apiRequestTimeout:1e4},e),{cluster:n,apiRequestTimeout:o,logCount:r,logRequests:i,urlConfigs:a}=t,c=new Ir({cluster:n,timeout:o,urlConfigs:a,logCount:r,logRequests:i}),u=new ba(q(N({},t),{api:c}));return await u.fetchAvailabilityStatus((l=e.disableFeatureCheck)!=null?l:!0),e.disableLoadToken||await u.token.load({type:e.jupTokenType}),u}get owner(){return this._owner}get ownerPubKey(){if(!this._owner)throw new Error(Br);return this._owner.publicKey}setOwner(e){return this._owner=e?new en(e):void 0,this.account.resetTokenAccounts(),this}get connection(){if(!this._connection)throw new Error(rc);return this._connection}setConnection(e){return this._connection=e,this}get signAllTransactions(){return this._signAllTransactions}setSignAllTransactions(e){return this._signAllTransactions=e,this}checkOwner(){if(!this.owner)throw console.error(Br),new Error(Br)}isCacheInvalidate(e){return new Date().getTime()-e>this._apiCacheTime}async fetchChainTime(){try{let e=await this.api.getChainTimeOffset();this._chainTime={fetched:Date.now(),value:{chainTime:Date.now()+e.offset*1e3,offset:e.offset*1e3}}}catch{this._chainTime=void 0}}async fetchV3TokenList(e){if(this.apiData.tokenList&&!this.isCacheInvalidate(this.apiData.tokenList.fetched)&&!e)return this.apiData.tokenList.data;try{let t=await this.api.getTokenList(),n={fetched:Date.now(),data:t};return this.apiData.tokenList=n,n.data}catch(t){return console.error(t),{mintList:[],blacklist:[],whiteList:[]}}}async fetchJupTokenList(e){if(this.cluster==="devnet")return[];let t=this.apiData.jupTokenList;if(t&&!this.isCacheInvalidate(t.fetched)&&!e)return t.data;try{let n=await this.api.getJupTokenList();return this.apiData.jupTokenList={fetched:Date.now(),data:n.map(o=>q(N({},o),{mintAuthority:o.mint_authority||void 0,freezeAuthority:o.freeze_authority||void 0}))},this.apiData.jupTokenList.data}catch(n){return console.error(n),[]}}get chainTimeData(){var e;return(e=this._chainTime)==null?void 0:e.value}async chainTimeOffset(){var e;return this._chainTime&&Date.now()-this._chainTime.fetched<=1e3*60*5?this._chainTime.value.offset:(await this.fetchChainTime(),((e=this._chainTime)==null?void 0:e.value.offset)||0)}async currentBlockChainTime(){var e;return this._chainTime&&Date.now()-this._chainTime.fetched<=1e3*60*5?this._chainTime.value.chainTime:(await this.fetchChainTime(),((e=this._chainTime)==null?void 0:e.value.chainTime)||Date.now())}async fetchEpochInfo(){return this._epochInfo&&Date.now()-this._epochInfo.fetched<=1e3*30?this._epochInfo.value:(this._epochInfo={fetched:Date.now(),value:await this.connection.getEpochInfo()},this._epochInfo.value)}async fetchAvailabilityStatus(e){if(e)return{};try{let t=await this.api.fetchAvailabilityStatus(),n=t.all===!1;return this.availability={all:t.all,swap:n?!1:t.swap,createConcentratedPosition:n?!1:t.createConcentratedPosition,addConcentratedPosition:n?!1:t.addConcentratedPosition,addStandardPosition:n?!1:t.addStandardPosition,removeConcentratedPosition:n?!1:t.removeConcentratedPosition,removeStandardPosition:n?!1:t.removeStandardPosition,addFarm:n?!1:t.addFarm,removeFarm:n?!1:t.removeFarm},t}catch{return{}}}};var c0=s=>s;export{Ry as ACCOUNT_TYPE_SIZE,wt as ALL_PROGRAM_ID,zp as AMM_CONFIG_SEED,jm as AMM_STABLE,ti as AMM_V4,gb as ANAMint,lt as API_URLS,oy as AUTH_SEED,Am as AccountType,Ir as Api,Gc as BIT_PRECISION,Kt as BNDivCeil,$n as BNLayout,Ig as BN_100,Bg as BN_1000,xg as BN_10000,hg as BN_FIVE,qu as BN_ONE,Yn as BN_TEN,Tg as BN_THREE,wg as BN_TWO,Je as BN_ZERO,WP as BitStructure,pc as Blob,ni as CLMM_LOCK_AUTH_ID,To as CLMM_LOCK_PROGRAM_ID,Ln as CLMM_PROGRAM_ID,Sa as CLOCK_PROGRAM_ID,iy as CONFIG_SEED,Wa as CREATE_CPMM_POOL_AUTH,td as CREATE_CPMM_POOL_FEE_ACC,oi as CREATE_CPMM_POOL_PROGRAM,uy as CREATOR_FEE_VAULT_AUTH_SEED,_i as Clmm,rl as ClmmConfigLayout,Le as ClmmInstrument,jr as ConstantProductCurve,Wl as CpmmConfigInfoLayout,Hr as CpmmFee,ea as CpmmPoolInfoLayout,$o as Currency,Qn as CurrencyAmount,Ht as Curve,Gn as CurveBase,$r as CurveCalculator,Pn as DEVNET_PROGRAM_ID,zA as DEV_API_URLS,Rw as DEV_FARM_LOCK_MINT,Lw as DEV_FARM_LOCK_VAULT,oA as DEV_LAUNCHPAD_AUTH,nA as DEV_LAUNCHPAD_PROGRAM,ho as DEV_LOOKUP_TABLE_CACHE,yf as DataElement,Ab as ETHMint,Fs as EXTENSION_TICKARRAY_BITMAP_SIZE,Rc as FARM_LOCK_MINT,Lc as FARM_LOCK_VAULT,Fa as FARM_PROGRAM_ID_V3,Va as FARM_PROGRAM_ID_V4,_a as FARM_PROGRAM_ID_V5,wo as FARM_PROGRAM_ID_V6,qt as FARM_PROGRAM_TO_VERSION,Nc as FARM_VERSION_TO_LEDGER_LAYOUT,Oc as FARM_VERSION_TO_STATE_LAYOUT,Da as FEE_DESTINATION_ID,Fr as FEE_RATE_DENOMINATOR,nn as FEE_RATE_DENOMINATOR_VALUE,Jp as FETCH_TICKARRAY_COUNT,Xp as Fee,ma as FixedPriceCurve,ce as Fraction,ai as IDO_ALL_PROGRAM,Zm as IDO_PROGRAM_ID_V1,$m as IDO_PROGRAM_ID_V2,Jm as IDO_PROGRAM_ID_V3,ed as IDO_PROGRAM_ID_V4,cr as INSTRUCTION_PROGRAM_ID,U as InstructionType,tc as JupTokenType,nd as LAUNCHPAD_AUTH,id as LAUNCHPAD_CONFIG,od as LAUNCHPAD_PLATFORM,ct as LAUNCHPAD_PROGRAM,Wr as LIQUIDITY_FEES_DENOMINATOR,Ds as LIQUIDITY_FEES_NUMERATOR,Pr as LIQUIDITY_POOL_PROGRAM_ID_V5_MODEL,cf as LIQUIDITY_VERSION_TO_SERUM_VERSION,ZI as LIQUIDITY_VERSION_TO_STATE_LAYOUT,ri as LOCK_CPMM_AUTH,ii as LOCK_CPMM_PROGRAM,Gf as LOCK_LIQUIDITY_SEED,Xc as LOG_B_2_X32,zc as LOG_B_P_ERR_MARGIN_LOWER_X64,Qc as LOG_B_P_ERR_MARGIN_UPPER_X64,kr as LOOKUP_TABLE_CACHE,ca as LaunchConstantProductCurve,Un as LaunchpadConfig,sn as LaunchpadPool,go as LaunchpadPoolInitParam,KR as LaunchpadVesting,li as Layout,pa as LinearPriceCurve,Pe as LiquidityMath,ul as LockClPositionLayoutV2,cI as LockPositionLayout,pm as LogLevel,Aa as Logger,Js as MARKET_STATE_LAYOUT_V2,iu as MARKET_STATE_LAYOUT_V3,Xl as MARKET_VERSION_TO_STATE_LAYOUT,Zu as MAX_BASE64_SIZE,Xt as MAX_SQRT_PRICE_X64,vr as MAX_SQRT_PRICE_X64_SUB_ONE,It as MAX_TICK,ur as MEMO_PROGRAM_ID,ln as MEMO_PROGRAM_ID2,Jt as METADATA_PROGRAM_ID,Gt as MIN_SQRT_PRICE_X64,Mr as MIN_SQRT_PRICE_X64_ADD_ONE,gt as MIN_TICK,On as MODEL_DATA_PUBKEY,oa as Market,er as MathLaunch,ue as MathUtil,hi as MaxU64,Uc as MaxUint128,Tn as NEGATIVE_ONE,bb as NRVMint,Zp as OBSERVATION_SEED,vt as ONE,Ea as OPEN_BOOK_PROGRAM,jp as OPERATION_SEED,al as ObservationInfoLayout,nf as ObservationLayout,sl as OperationLayout,is as OptionLayout,en as Owner,cb as PAIMint,sy as PLATFORM_FEE_VAULT_AUTH_SEED,ay as PLATFORM_SEED,tl as POOL_LOCK_ID_SEED,Qp as POOL_REWARD_VAULT_SEED,Rs as POOL_SEED,Hp as POOL_TICK_ARRAY_BITMAP_SEED,Ls as POOL_VAULT_SEED,ry as POOL_VESTING_SEED,Zc as POSITION_SEED,ze as Percent,Uo as PlatformConfig,nc as PoolFetchType,no as PoolInfoLayout,ve as PoolUtils,No as PositionInfoLayout,rf as PositionRewardInfoLayout,Si as PositionUtils,ut as Price,uI as ProtocolPositionLayout,Nr as Q128,ot as Q64,ub as RAYMint,tt as RENT_PROGRAM_ID,ba as Raydium,of as RewardInfo,Ol as RoundDirection,Ta as Rounding,Hm as Router,Ul as SERUM_PROGRAMID_TO_VERSION,Ar as SERUM_PROGRAM_ID_V3,Gl as SERUM_VERSION_TO_PROGRAMID,oc as SESSION_KEY,st as SOLMint,cn as SOL_INFO,dl as SPL_MINT_LAYOUT,lb as SRMMint,Ya as STORAGE_KEY,$p as SUPPORT_MINT_SEED,lr as SYSTEM_PROGRAM_ID,ie as SqrtPriceMath,Fo as StableLayout,rs as Structure,to as SwapMath,eo as TICK_ARRAY_BITMAP_SIZE,Yp as TICK_ARRAY_SEED,it as TICK_ARRAY_SIZE,GT as TICK_SPACINGS,at as TOKEN_WSOL,In as TickArrayBitmap,il as TickArrayBitmapExtensionLayout,Ci as TickArrayBitmapExtensionUtils,Ki as TickArrayLayout,af as TickLayout,oo as TickMath,Te as TickQuery,Z as TickUtils,Se as Token,he as TokenAmount,Tr as TxBuilder,bn as TxVersion,Ii as U64Resolution,zT as U64_IGNORE_RANGE,ts as UInt,mb as USDCMint,yb as USDHMint,db as USDTMint,Ym as UTIL1216,as as Union,my as VestingSchedule,Cc as Voter,Cp as VoterDepositEntry,Kp as VoterLockup,Kc as VoterRegistrar,Sp as VoterVotingMintConfig,H as WSOLMint,Rr as WideBits,kn as WrappedLayout,ge as ZERO,_u as _100_PERCENT,A as accountMeta,ng as add,yr as addComputeBudget,Gs as addLiquidityLayout,Dt as anchorDataBuf,Bk as array,ls as associatedLedgerAccountLayout,ns as bits,xe as blob,We as bool,em as buyExactInInstruction,tm as buyExactOutInstruction,Is as calFarmRewardAmount,dr as ceilDiv,Zn as ceilDivBN,Jo as checkLegacyTxSize,XR as checkPoolToAmm,ei as checkV0TxSize,wa as chunkArray,am as claimCreatorFee,Yi as claimLayout,Pu as claimPlatformFee,ku as claimPlatformFeeFromVault,gu as claimVestedToken,ol as clmmComputeInfoToApiInfo,wn as closeAccountInstruction,ou as collectCpFeeInstruction,Ia as commonSystemAccountMeta,br as confirmTransaction,Yf as cpmmLockPositionInstruction,Ai as createAssociatedLedgerAccountInstruction,fe as createLogger,im as createPlatformConfig,yl as createPoolFeeLayout,Qs as createPoolV4InstructionV2,HI as createPoolV4Layout,Au as createVestingAccount,vn as createWSolAccountInstructions,yk as cstr,Sb as currencyEquals,Em as decimalToFraction,sp as decodeBool,$b as div,mr as divCeil,ht as dwLayout,up as encodeBool,bP as endlessRetry,Nm as eq,lk as f32,mk as f32be,dk as f64,pk as f64be,fs as farmAddRewardLayout,Pw as farmLedgerLayoutV3_1,fi as farmLedgerLayoutV3_2,kw as farmLedgerLayoutV5_1,xc as farmLedgerLayoutV5_2,Sc as farmLedgerLayoutV6_1,vc as farmRewardInfoToConfig,ds as farmRewardLayout,ps as farmRewardRestartLayout,xp as farmRewardTimeInfoLayout,Ic as farmStateV3Layout,Bc as farmStateV5Layout,pi as farmStateV6Layout,Yw as fetchMultipleFarmInfoAndUpdate,FB as fetchMultipleInfo,Po as fetchMultipleMintInfos,ne as findProgramAddress,Ws as fixedSwapInLayout,qs as fixedSwapOutLayout,Ma as floorDiv,gr as forecastTransactionSize,Bf as formatLayout,Ye as generatePubKey,j as getATAAddress,Mc as getAssociatedAuthority,Gr as getAssociatedConfigId,bt as getAssociatedLedgerAccount,bi as getAssociatedLedgerPoolAccount,Cf as getAssociatedOpenOrders,$s as getAssociatedPoolKeys,Wi as getCpLockPda,vS as getCpmmPdaAmmConfigId,tu as getCpmmPdaPoolId,Ml as getCreatePoolKeys,Xu as getDate,Bs as getDepositEntryIndex,za as getDevLookupTableCache,hl as getDxByDyBaseIn,Tl as getDyByDxBaseIn,Yg as getEpochInfo,Ro as getFarmLedgerLayout,Lp as getFarmStateLayout,Zs as getLiquidityAssociatedAuthority,so as getLiquidityAssociatedId,_h as getLiquidityFromAmounts,tg as getMax,$t as getMultipleAccountsInfo,Me as getMultipleAccountsInfoWithCustomFlags,Xa as getMultipleLookupTableInfo,JT as getPdaAmmConfigId,fo as getPdaCpiEvent,Zl as getPdaCreatorFeeVaultAuth,qo as getPdaCreatorVault,je as getPdaExBitmapAccount,fn as getPdaLaunchpadAuth,bR as getPdaLaunchpadConfigId,Wo as getPdaLaunchpadPoolId,pu as getPdaLaunchpadVaultId,Oo as getPdaLockClPositionIdV2,Ns as getPdaLockPositionId,qf as getPdaLpMint,hn as getPdaMetadataKey,Ms as getPdaMintExAccount,el as getPdaObservationAccount,Di as getPdaObservationId,xi as getPdaOperationAccount,Bt as getPdaPersonalPositionAddress,yu as getPdaPlatformFeeVaultAuth,fu as getPdaPlatformId,yo as getPdaPlatformVault,Eo as getPdaPoolAuthority,$c as getPdaPoolId,Jc as getPdaPoolRewardVaulId,Os as getPdaPoolVaultId,an as getPdaProtocolPositionAddress,Ae as getPdaTickArrayAddress,Nl as getPdaVault,Hi as getPdaVestId,ko as getRecentBlockHash,As as getRegistrarAddress,ud as getSessionKey,Il as getStablePrice,Wm as getTime,ug as getTimestamp,hs as getTokenOwnerRecordAddress,aA as getTransferAmountFee,Ua as getTransferAmountFeeFromPost,qa as getTransferAmountFeeFromPre,Be as getTransferAmountFeeV2,ws as getVoterAddress,Ts as getVoterWeightRecordAddress,ks as getVotingMintAuthority,Ps as getVotingTokenMint,Dp as governanceCreateTokenOwnerRecord,qP as greedy,Om as gt,Zb as gte,kc as i128,YT as i16ToBytes,_r as i32ToBytes,So as i64,Pc as i8,Us as initPoolLayout,us as initTokenAccountInstruction,$l as initialize,Nf as initializeMarket,Jl as initializeWithToken2022,Ng as intersection,Qu as isDateAfter,zu as isDateBefore,Dm as isDecimal,eg as isMeaningfulNumber,Gu as isNumber,bs as isValidFarmVersion,Bi as isZero,Fe as jsonInfo2PoolKeys,jw as judgeFarmType,Ks as leadingZeros,Hc as leastSignificantBit,io as liquidityStateV4Layout,lf as liquidityStateV5Layout,jb as lt,Hb as lte,pb as mSOLMint,qr as makeAMMSwapInstruction,Al as makeAddLiquidityInstruction,Ss as makeAddNewRewardInstruction,aa as makeClaimInstruction,du as makeClaimInstructionV4,Dl as makeCpmmLockInstruction,Fl as makeCreateCpmmPoolInInstruction,Fc as makeCreateFarmInstruction,zr as makeCreateMarketInstruction,Vc as makeCreatorWithdrawFarmRewardInstruction,Vl as makeDepositCpmmInInstruction,Ec as makeDepositInstructionV3,Dc as makeDepositInstructionV5,Wc as makeDepositInstructionV6,mT as makeDepositTokenInstruction,pT as makeDepositWithdrawInstruction,cB as makeInitPoolInstructionV4,ZC as makePurchaseInstruction,xs as makeRestartRewardInstruction,Pl as makeSimulatePoolInfoInstruction,Jr as makeSwapCpmmBaseInInstruction,El as makeSwapCpmmBaseOutInstruction,pf as makeSwapFixedInInstruction,ff as makeSwapFixedOutInstruction,Ql as makeSwapInstruction,hc as makeTransferInstruction,_l as makeWithdrawCpmmInInstruction,wi as makeWithdrawInstructionV3,_c as makeWithdrawInstructionV4,ki as makeWithdrawInstructionV5,Pi as makeWithdrawInstructionV6,dT as makeWithdrawTokenInstruction,tn as minExpirationTime,XT as mockCreatePoolInfo,Yc as mockV3CreatePoolInfo,bf as modelDataInfoLayout,jc as mostSignificantBit,Oa as mul,Na as notInnerObject,ok as ns64,ck as ns64be,fc as nu64,ZP as nu64be,os as offset,Lg as offsetDateTime,wk as option,J as parseBigNumberish,jn as parseNumberInfo,Ju as parseSimulateLogToJson,An as parseSimulateValue,Tc as parseTokenAccountResp,FI as parseTokenInfo,Vn as poolTypeV6,Hn as printSimulate,O as publicKey,cu as purchaseLayout,hp as realFarmStateV3Layout,Ip as realFarmStateV5Layout,Bp as realFarmV6Layout,Wu as recursivelyDecimalToFraction,zs as removeLiquidityInstruction,Xs as removeLiquidityLayout,tC as route1Instruction,nC as route2Instruction,Zf as routeInstruction,Ik as rustEnum,JP as s16,ik as s16be,ek as s24,rk as s24be,_e as s32,ak as s32be,tk as s40,sk as s40be,nk as s48,uk as s48be,$P as s8,nm as sellExactInInstruction,om as sellExactOut,Q as seq,wy as setLoggerLevel,Vm as shakeFractionDecimal,$u as simulateMultipleInstruction,uB as simulatePoolInfoInstruction,Gm as simulateTransaction,Eu as sleep,yt as solToWSol,_I as solToWSolToken,rn as splAccountLayout,vu as splitNumber,fb as stSOLMint,Ct as str,v as struct,Jb as sub,oC as swapBaseInAutoAccount,iC as swapBaseOutAutoAccount,hk as tagged,La as tenExponential,Xr as toAmmComputePoolInfo,At as toApiV3Token,_m as toBN,ec as toBuffer,_n as toFeeConfig,Uu as toFraction,Yb as toFractionWithDecimals,Sg as toPercent,Dr as toToken,Li as toTokenAmount,VI as toTokenInfo,Kg as toTokenPrice,Cg as toTotalPrice,Du as toUsdCurrency,Cs as trailingZeros,jg as transformTxToBase64,xa as tryParsePublicKey,Xm as txToBase64,te as u128,Mt as u16,Vr as u16ToBytes,zP as u16be,UP as u24,QP as u24be,pt as u32,jT as u32ToBytes,YP as u32be,GP as u40,jP as u40be,XP as u48,HP as u48be,k as u64,D as u8,cy as u8ToBytes,xk as union,c0 as unionArr,fk as unionLayoutDiscriminator,vg as uniq,Op as updateFarmPoolInfo,rm as updatePlatformConfig,hr as updateReqHistory,bk as utf8,Ba as validateAndParsePublicKey,gs as validateFarmRewards,Tk as vec,cp as vecU8,qp as voterStakeRegistryCreateDepositEntry,Wp as voterStakeRegistryCreateVoter,Vp as voterStakeRegistryDeposit,_p as voterStakeRegistryUpdateVoterWeightRecord,Ep as voterStakeRegistryWithdraw,EI as wSolToSolToken,ms as withdrawRewardLayout,Mg as xor,Sk as zeros};
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
//# sourceMappingURL=index.mjs.map