var hm=Object.defineProperty,Im=Object.defineProperties;var Bm=Object.getOwnPropertyDescriptors;var pr=Object.getOwnPropertySymbols;var Wu=Object.prototype.hasOwnProperty,Du=Object.prototype.propertyIsEnumerable;var Eu=(a,e,t)=>e in a?hm(a,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):a[e]=t,M=(a,e)=>{for(var t in e||(e={}))Wu.call(e,t)&&Eu(a,t,e[t]);if(pr)for(var t of pr(e))Du.call(e,t)&&Eu(a,t,e[t]);return a},q=(a,e)=>Im(a,Bm(e));var _e=(a,e)=>{var t={};for(var n in a)Wu.call(a,n)&&e.indexOf(n)<0&&(t[n]=a[n]);if(a!=null&&pr)for(var n of pr(a))e.indexOf(n)<0&&Du.call(a,n)&&(t[n]=a[n]);return t};import fc from"axios";import{PublicKey as Gu}from"@solana/web3.js";import{get as ws,set as qu}from"lodash";var xm=(o=>(o[o.Error=0]="Error",o[o.Warning=1]="Warning",o[o.Info=2]="Info",o[o.Debug=3]="Debug",o))(xm||{}),Ts=class{constructor(e){this.logLevel=e.logLevel!==void 0?e.logLevel:0,this.name=e.name}set level(e){this.logLevel=e}get time(){return Date.now().toString()}get moduleName(){return this.name}isLogLevel(e){return e<=this.logLevel}error(...e){return this.isLogLevel(0)?(console.error(this.time,this.name,"sdk logger error",...e),this):this}logWithError(...e){let t=e.map(n=>typeof n=="object"?JSON.stringify(n):n).join(", ");throw new Error(t)}warning(...e){return this.isLogLevel(1)?(console.warn(this.time,this.name,"sdk logger warning",...e),this):this}info(...e){return this.isLogLevel(2)?(console.info(this.time,this.name,"sdk logger info",...e),this):this}debug(...e){return this.isLogLevel(3)?(console.debug(this.time,this.name,"sdk logger debug",...e),this):this}},hs={},Uu={};function be(a){let e=ws(hs,a);if(!e){let t=ws(Uu,a);e=new Ts({name:a,logLevel:t}),qu(hs,a,e)}return e}function Fy(a,e){qu(Uu,a,e);let t=ws(hs,a);t&&(t.level=e)}import{MINT_SIZE as Km,TOKEN_PROGRAM_ID as Sm,getTransferFeeConfig as Cm,unpackMint as Rm}from"@solana/spl-token";var Is=be("Raydium_accountInfo_util");async function tn(a,e,t){let{batchRequest:n,commitment:o="confirmed",chunkCount:r=100}=M({batchRequest:!1},t),i=Bs(e,r),s=new Array(i.length).fill([]);if(n){let c=i.map(m=>{let p=a._buildArgs([m.map(d=>d.toBase58())],o,"base64");return{methodName:"getMultipleAccounts",args:p}}),u=Bs(c,10);s=(await(await Promise.all(u.map(async m=>await a._rpcBatchRequest(m)))).flat()).map(m=>(m.error&&Is.logWithError(`failed to get info for multiple accounts, RPC_ERROR, ${m.error.message}`),m.result.value.map(p=>{if(p){let{data:d,executable:f,lamports:y,owner:b,rentEpoch:g}=p;return d.length!==2&&d[1]!=="base64"&&Is.logWithError("info must be base64 encoded, RPC_ERROR"),{data:Buffer.from(d[0],"base64"),executable:f,lamports:y,owner:new Gu(b),rentEpoch:g}}return null})))}else try{s=await Promise.all(i.map(c=>a.getMultipleAccountsInfo(c,o)))}catch(c){c instanceof Error&&Is.logWithError(`failed to get info for multiple accounts, RPC_ERROR, ${c.message}`)}return s.flat()}async function ve(a,e,t){let n=await tn(a,e.map(o=>o.pubkey),t);return e.map((o,r)=>q(M({},o),{accountInfo:n[r]}))}var Lm=(n=>(n[n.Uninitialized=0]="Uninitialized",n[n.Mint=1]="Mint",n[n.Account=2]="Account",n))(Lm||{}),Xy=1;async function Co({connection:a,mints:e,config:t}){var r,i,s;if(e.length===0)return{};let n=await ve(a,e.map(c=>({pubkey:bt(c)})),t),o={};for(let c of n){if(!c.accountInfo||c.accountInfo.data.length<Km){console.log("invalid mint account",c.pubkey.toBase58());continue}let u=Rm(c.pubkey,c.accountInfo,(r=c.accountInfo)==null?void 0:r.owner);o[c.pubkey.toString()]=q(M({},u),{programId:((i=c.accountInfo)==null?void 0:i.owner)||Sm,feeConfig:(s=Cm(u))!=null?s:void 0})}return o[Gu.default.toBase58()]=o[$.toBase58()],o}import He from"bn.js";import Ym from"decimal.js";import _m from"big.js";import Fn from"bn.js";import Om from"toformat";var Nm=Om,ti=Nm;import yr from"big.js";import Mm from"bn.js";import vm from"decimal.js-light";import ni from"bn.js";var xs=(n=>(n[n.ROUND_DOWN=0]="ROUND_DOWN",n[n.ROUND_HALF_UP=1]="ROUND_HALF_UP",n[n.ROUND_UP=2]="ROUND_UP",n))(xs||{}),Xu=9007199254740991;function J(a){let e=be("Raydium_parseBigNumberish");if(a instanceof ni)return a;if(typeof a=="string"){if(a.match(/^-?[0-9]+$/))return new ni(a);e.logWithError(`invalid BigNumberish string: ${a}`)}return typeof a=="number"?(a%1&&e.logWithError(`BigNumberish number underflow: ${a}`),(a>=Xu||a<=-Xu)&&e.logWithError(`BigNumberish number overflow: ${a}`),new ni(String(a))):typeof a=="bigint"?new ni(a.toString()):(e.error(`invalid BigNumberish value: ${a}`),new ni(0))}var fr=be("module/fraction"),Ks=ti(yr),oi=ti(vm),Fm={[0]:oi.ROUND_DOWN,[1]:oi.ROUND_HALF_UP,[2]:oi.ROUND_UP},Vm={[0]:yr.roundDown,[1]:yr.roundHalfUp,[2]:yr.roundUp},me=class{constructor(e,t=new Mm(1)){this.numerator=J(e),this.denominator=J(t)}get quotient(){return this.numerator.div(this.denominator)}invert(){return new me(this.denominator,this.numerator)}add(e){let t=e instanceof me?e:new me(J(e));return this.denominator.eq(t.denominator)?new me(this.numerator.add(t.numerator),this.denominator):new me(this.numerator.mul(t.denominator).add(t.numerator.mul(this.denominator)),this.denominator.mul(t.denominator))}sub(e){let t=e instanceof me?e:new me(J(e));return this.denominator.eq(t.denominator)?new me(this.numerator.sub(t.numerator),this.denominator):new me(this.numerator.mul(t.denominator).sub(t.numerator.mul(this.denominator)),this.denominator.mul(t.denominator))}mul(e){let t=e instanceof me?e:new me(J(e));return new me(this.numerator.mul(t.numerator),this.denominator.mul(t.denominator))}div(e){let t=e instanceof me?e:new me(J(e));return new me(this.numerator.mul(t.denominator),this.denominator.mul(t.numerator))}toSignificant(e,t={groupSeparator:""},n=1){Number.isInteger(e)||fr.logWithError(`${e} is not an integer.`),e<=0&&fr.logWithError(`${e} is not positive.`),oi.set({precision:e+1,rounding:Fm[n]});let o=new oi(this.numerator.toString()).div(this.denominator.toString()).toSignificantDigits(e);return o.toFormat(o.decimalPlaces(),t)}toFixed(e,t={groupSeparator:""},n=1){return Number.isInteger(e)||fr.logWithError(`${e} is not an integer.`),e<0&&fr.logWithError(`${e} is negative.`),Ks.DP=e,Ks.RM=Vm[n]||1,new Ks(this.numerator.toString()).div(this.denominator.toString()).toFormat(e,t)}isZero(){return this.numerator.isZero()}};var Em=be("Raydium_amount"),br=ti(_m);function zu(a,e){let t="0",n="0";if(a.includes(".")){let o=a.split(".");o.length===2?([t,n]=o,n=n.padEnd(e,"0")):Em.logWithError(`invalid number string, num: ${a}`)}else t=a;return[t,n.slice(0,e)||n]}var Ie=class extends me{constructor(t,n,o=!0,r){let i=new Fn(0),s=oo.pow(new Fn(t.decimals));if(o)i=J(n);else{let c=new Fn(0),u=new Fn(0);if(typeof n=="string"||typeof n=="number"||typeof n=="bigint"){let[l,m]=zu(n.toString(),t.decimals);c=J(l),u=J(m)}c=c.mul(s),i=c.add(u)}super(i,s);this.logger=be(r||"TokenAmount"),this.token=t}get raw(){return this.numerator}isZero(){return this.raw.isZero()}gt(t){return this.token.equals(t.token)||this.logger.logWithError("gt token not equals"),this.raw.gt(t.raw)}lt(t){return this.token.equals(t.token)||this.logger.logWithError("lt token not equals"),this.raw.lt(t.raw)}add(t){return this.token.equals(t.token)||this.logger.logWithError("add token not equals"),new Ie(this.token,this.raw.add(t.raw))}subtract(t){return this.token.equals(t.token)||this.logger.logWithError("sub token not equals"),new Ie(this.token,this.raw.sub(t.raw))}toSignificant(t=this.token.decimals,n,o=0){return super.toSignificant(t,n,o)}toFixed(t=this.token.decimals,n,o=0){return t>this.token.decimals&&this.logger.logWithError("decimals overflow"),super.toFixed(t,n,o)}toExact(t={groupSeparator:""}){return br.DP=this.token.decimals,new br(this.numerator.toString()).div(this.denominator.toString()).toFormat(t)}},no=class extends me{constructor(t,n,o=!0,r){let i=new Fn(0),s=oo.pow(new Fn(t.decimals));if(o)i=J(n);else{let c=new Fn(0),u=new Fn(0);if(typeof n=="string"||typeof n=="number"||typeof n=="bigint"){let[l,m]=zu(n.toString(),t.decimals);c=J(l),u=J(m)}c=c.mul(s),i=c.add(u)}super(i,s);this.logger=be(r||"TokenAmount"),this.currency=t}get raw(){return this.numerator}isZero(){return this.raw.isZero()}gt(t){return this.currency.equals(t.currency)||this.logger.logWithError("gt currency not equals"),this.raw.gt(t.raw)}lt(t){return this.currency.equals(t.currency)||this.logger.logWithError("lt currency not equals"),this.raw.lt(t.raw)}add(t){return this.currency.equals(t.currency)||this.logger.logWithError("add currency not equals"),new no(this.currency,this.raw.add(t.raw))}sub(t){return this.currency.equals(t.currency)||this.logger.logWithError("sub currency not equals"),new no(this.currency,this.raw.sub(t.raw))}toSignificant(t=this.currency.decimals,n,o=0){return super.toSignificant(t,n,o)}toFixed(t=this.currency.decimals,n,o=0){return t>this.currency.decimals&&this.logger.logWithError("decimals overflow"),super.toFixed(t,n,o)}toExact(t={groupSeparator:""}){return br.DP=this.currency.decimals,new br(this.numerator.toString()).div(this.denominator.toString()).toFormat(t)}};import{PublicKey as Wm}from"@solana/web3.js";import{TOKEN_PROGRAM_ID as Yu}from"@solana/spl-token";var ln={chainId:101,address:Wm.default.toBase58(),programId:Yu.toBase58(),decimals:9,symbol:"SOL",name:"solana",logoURI:"https://img-v1.raydium.io/icon/So11111111111111111111111111111111111111112.png",tags:[],priority:2,type:"raydium",extensions:{coingeckoId:"solana"}},ut={chainId:101,address:"So11111111111111111111111111111111111111112",programId:Yu.toBase58(),decimals:9,symbol:"WSOL",name:"Wrapped SOL",logoURI:"https://img-v1.raydium.io/icon/So11111111111111111111111111111111111111112.png",tags:[],priority:2,type:"raydium",extensions:{coingeckoId:"solana"}};import{PublicKey as Os}from"@solana/web3.js";import{PublicKey as Ge,SystemProgram as Qu,SYSVAR_RENT_PUBKEY as Dm}from"@solana/web3.js";import{TOKEN_PROGRAM_ID as qm}from"@solana/spl-token";function k({pubkey:a,isSigner:e=!1,isWritable:t=!0}){return{pubkey:a,isWritable:t,isSigner:e}}var Ss=[k({pubkey:qm,isWritable:!1}),k({pubkey:Qu.programId,isWritable:!1}),k({pubkey:Dm,isWritable:!1})];function Cs({publicKey:a,transformSol:e}){let t=Rs(a.toString());if(t instanceof Ge)return e&&t.equals(ct)?$:t;if(e&&t.toString()===ct.toBase58())return $;if(typeof t=="string"){if(t===Ge.default.toBase58())return Ge.default;try{return new Ge(t)}catch{throw new Error("invalid public key")}}throw new Error("invalid public key")}function Rs(a){try{return new Ge(a)}catch{return a}}var gr=new Ge("MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr"),mn=new Ge("MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr"),Je=new Ge("SysvarRent111111111111111111111111111111111"),Ls=new Ge("SysvarC1ock11111111111111111111111111111111"),Gt=new Ge("metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s"),Pr=new Ge("Sysvar1nstructions1111111111111111111111111"),Ar=Qu.programId,hb=new Ge("4k3Dyjzvzp8eMZWUXbBCjEvwSkkk59S5iCNLY3QrkX6R"),Ib=new Ge("Ea5SjE2Y6yvCeW5dYTn7PYMuW5ikXkvbGdcmSnXeaLjS"),Bb=new Ge("SRMuApVNdxXokk5GT7XD5cUUgXMBCoAz2LHeuAoKWRt"),xb=new Ge("EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v"),Kb=new Ge("Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB"),Sb=new Ge("mSoLzYCxHdYgdzU16g5QSh3i5K3z3KZK7ytfqcJm7So"),Cb=new Ge("7dHbWXmci3dT8UFYWYZweBLXgycu7Y3iL6trKn1Y7ARj"),Rb=new Ge("USDH1SM1ojwWUga67PGrgFWUHibbjqMvuMaDkRJTgkX"),Lb=new Ge("NRVwhjBQiUPYtfDT5zRBVJajzFQHaBUNtC7SNVvqRFa"),Ob=new Ge("ANAxByE6G2WjFp7A4NqtWYXb3mgruyzZYg3spfxe6Lbo"),Nb=new Ge("7vfCXTUXx5WJV5JADk17DUJ4ksgau7utNKj4b963voxs"),$=new Ge("So11111111111111111111111111111111111111112"),ct=Ge.default;function bt(a){return Cs({publicKey:a,transformSol:!0})}var Ns=class{constructor({mint:e,decimals:t,symbol:n,name:o,skipMint:r=!1,isToken2022:i=!1}){if(e===ct.toBase58()||e instanceof Os&&ct.equals(e)){this.decimals=ut.decimals,this.symbol=ut.symbol,this.name=ut.name,this.mint=new Os(ut.address),this.isToken2022=!1;return}this.decimals=t,this.symbol=n||e.toString().substring(0,6),this.name=o||e.toString().substring(0,6),this.mint=r?Os.default:Cs({publicKey:e}),this.isToken2022=i}equals(e){return this===e?!0:this.mint.equals(e.mint)}},Ke=Ns;Ke.WSOL=new Ns(q(M({},ut),{mint:ut.address}));var Ms=class{constructor({decimals:e,symbol:t="UNKNOWN",name:n="UNKNOWN"}){this.decimals=e,this.symbol=t,this.name=n}equals(e){return this===e}},ii=Ms;ii.SOL=new Ms(ln);function qb(a,e){return a instanceof Ke&&e instanceof Ke?a.equals(e):a instanceof Ke||e instanceof Ke?!1:a===e}import Um from"bn.js";var Hu=new me(new Um(100)),Qe=class extends me{toSignificant(e=5,t,n){return this.mul(Hu).toSignificant(e,t,n)}toFixed(e=2,t,n){return this.mul(Hu).toFixed(e,t,n)}};var Gm=be("Raydium_price"),lt=class extends me{constructor(t){let{baseToken:n,quoteToken:o,numerator:r,denominator:i}=t;super(r,i);this.baseToken=n,this.quoteToken=o,this.scalar=new me(vs(n.decimals),vs(o.decimals))}get raw(){return new me(this.numerator,this.denominator)}get adjusted(){return super.mul(this.scalar)}invert(){return new lt({baseToken:this.quoteToken,quoteToken:this.baseToken,denominator:this.numerator,numerator:this.denominator})}mul(t){this.quoteToken!==t.baseToken&&Gm.logWithError("mul token not equals");let n=super.mul(t);return new lt({baseToken:this.baseToken,quoteToken:t.quoteToken,denominator:n.denominator,numerator:n.numerator})}toSignificant(t=this.quoteToken.decimals,n,o){return this.adjusted.toSignificant(t,n,o)}toFixed(t=this.quoteToken.decimals,n,o){return this.adjusted.toFixed(t,n,o)}};function et(a){if(a instanceof Qe)return new me(a.numerator,a.denominator);if(a instanceof lt)return a.adjusted;if(a instanceof Ie)try{return et(a.toExact())}catch{return new me(tt)}if(a instanceof me)return a;let e=String(a),t=io(e);return new me(t.numerator,t.denominator)}function cg(a){var n;if(a instanceof Qe)return{fr:new me(a.numerator,a.denominator)};if(a instanceof lt)return{fr:a.adjusted};if(a instanceof Ie)return{fr:et(a.toExact()),decimals:a.token.decimals};if(a instanceof me)return{fr:a};let e=String(a),t=io(e);return{fr:new me(t.numerator,t.denominator),decimals:(n=t.dec)==null?void 0:n.length}}function lg(a,e){if(a==null||e==null)return!1;let t=et(a),n=et(e);return t.sub(n).numerator,t.sub(n).numerator.lt(tt)}function Xm(a,e){if(a==null||e==null)return!1;let t=et(a),n=et(e);return t.sub(n).numerator.gt(tt)}function mg(a,e){if(a==null||e==null)return!1;let t=et(a),n=et(e);return t.sub(n).numerator.lte(tt)}function dg(a,e){if(a==null||e==null)return!1;let t=et(a),n=et(e);return t.sub(n).numerator.gte(tt)}function zm(a,e){if(a==null||e==null)return!1;let t=et(a),n=et(e);return t.sub(n).numerator.eq(tt)}function pg(a,e){if(a==null||e==null)return;let t=et(a),n=et(e);try{return t.div(n)}catch{return t}}function fg(a,e){if(a==null||e==null)return;let t=et(a),n=et(e);return t.sub(n)}function yg(a){return a==null?!1:!zm(a,0)}function bg(a,e){return Xm(e,a)?e:a}function Fs(a,e){if(a==null||e==null)return;let t=et(a),n=et(e);return t.mul(n)}function gg(a,e){if(a==null||e==null)return;let t=et(a),n=et(e);return t.add(n)}var tt=new He(0),$u=new He(1),Cg=new He(2),Rg=new He(3),Lg=new He(5),oo=new He(10),Og=new He(100),Ng=new He(1e3),Mg=new He(1e4);function vs(a){return oo.pow(J(a))}function io(a){var s;if(a===void 0)return{denominator:"1",numerator:"0"};if(a instanceof He)return{numerator:a.toString(),denominator:"1"};if(a instanceof me)return{denominator:a.denominator.toString(),numerator:a.numerator.toString()};let e=String(a),[,t="",n="",o=""]=(s=e.replace(",","").match(/(-?)(\d*)\.?(\d*)/))!=null?s:[],r="1"+"0".repeat(o.length),i=t+(n==="0"?"":n)+o||"0";return{denominator:r,numerator:i,sign:t,int:n,dec:o}}function kr(a,e){let t=a.divmod(e);return t.mod.isZero()?t.div:t.div.isNeg()?t.div.isubn(1):t.div.iaddn(1)}function Qm(a){var n;let[,e="",t=""]=(n=a.toFixed(2).match(/(-?)(\d*)\.?(\d*)/))!=null?n:[];return`${e}${t}`}function Hm(a,e=0){return a instanceof He?a:new He(Qm(Zu(a).mul(oo.pow(new He(String(e))))))}function Zu(a){if(a instanceof Qe)return new me(a.numerator,a.denominator);if(a instanceof lt)return a.adjusted;if(a instanceof Ie)try{return Zu(a.toExact())}catch{return new me(tt)}if(a instanceof me)return a;let e=String(a),t=io(e);return new me(t.numerator,t.denominator)}function ri(a,e,t){return a.mul(e).add(t).sub(new He(1)).div(t)}function wr(a,e,t){return a.mul(e).div(t)}function vg(a,e){let{numerator:t,denominator:n}=io(a);return new Qe(new He(t),new He(n).mul(e!=null&&e.alreadyDecimaled?new He(100):new He(1)))}function Fg(a){let{token:e,numberPrice:t,decimalDone:n}=a,o=new Ke({mint:"",decimals:6,symbol:"usd",name:"usd",skipMint:!0}),{numerator:r,denominator:i}=io(t),s=n?new He(r).mul(oo.pow(new He(e.decimals))):r,c=new He(i).mul(oo.pow(new He(o.decimals)));return new lt({baseToken:o,denominator:c.toString(),quoteToken:new Ke(q(M({},e),{skipMint:!0,mint:""})),numerator:s.toString()})}function ju(a){let e=new ii({decimals:6,symbol:"usd",name:"usd"}),t=Hm(Fs(a,10**e.decimals));return new no(e,t)}function Vg(a,e){return ju(!e||!a?0:Fs(a,e))}function _g(a){if(a==null)return;let{numerator:e,denominator:t}=io(a.toString());return new me(e,t)}function Eg(a){return a instanceof Ym}var Ju=a=>typeof a=="number",ec=a=>a?new Date(a):new Date,jm=a=>ec(a).getTime();function tc(a,e,t){let n=Ju(e)?e*((t==null?void 0:t.unit)==="s"?1e3:1):e;return new Date(a).getTime()<=n}function nc(a,e,t){let n=Ju(e)?e*((t==null?void 0:t.unit)==="s"?1e3:1):e;return new Date(a).getTime()>n}function Dg(a,e){let n=jm(a)+(e.days?e.days*24*60*60*1e3:0)+(e.hours?e.hours*60*60*1e3:0)+(e.minutes?e.minutes*60*1e3:0)+(e.seconds?e.seconds*1e3:0)+(e.milliseconds?e.milliseconds:0);return ec(n)}function Bs(a,e=1,t=[]){let n=[...a];if(e<=0)return t;for(;n.length;)t.push(n.splice(0,e));return t}function Ug(a,...e){return a.filter(t=>e.every(n=>n.includes(t)))}function Gg(a,...e){return a.filter(t=>e.every(n=>!n.includes(t)))}function Xg(a){return[...new Set(a)]}var _t=class{constructor(e){this._owner=e}get publicKey(){return _t.isKeyPair(this._owner)?this._owner.publicKey:this._owner}get signer(){return _t.isKeyPair(this._owner)?this._owner:void 0}get isKeyPair(){return _t.isKeyPair(this._owner)}get isPublicKey(){return _t.isPublicKey(this._owner)}static isKeyPair(e){return e.secretKey!==void 0}static isPublicKey(e){return!_t.isKeyPair(e)}};import{PublicKey as td}from"@solana/web3.js";import{TOKEN_PROGRAM_ID as nd}from"@solana/spl-token";import{ComputeBudgetProgram as oc,Keypair as ic,PublicKey as rc,Transaction as hr,TransactionMessage as $m,VersionedTransaction as Vs}from"@solana/web3.js";var bn=(t=>(t[t.V0=0]="V0",t[t.LEGACY=1]="LEGACY",t))(bn||{}),G={CreateAccount:"CreateAccount",InitAccount:"InitAccount",CreateATA:"CreateATA",CloseAccount:"CloseAccount",TransferAmount:"TransferAmount",InitMint:"InitMint",MintTo:"MintTo",InitMarket:"InitMarket",Util1216OwnerClaim:"Util1216OwnerClaim",SetComputeUnitPrice:"SetComputeUnitPrice",SetComputeUnitLimit:"SetComputeUnitLimit",ClmmCreatePool:"ClmmCreatePool",ClmmOpenPosition:"ClmmOpenPosition",ClmmIncreasePosition:"ClmmIncreasePosition",ClmmDecreasePosition:"ClmmDecreasePosition",ClmmClosePosition:"ClmmClosePosition",ClmmSwapBaseIn:"ClmmSwapBaseIn",ClmmSwapBaseOut:"ClmmSwapBaseOut",ClmmInitReward:"ClmmInitReward",ClmmSetReward:"ClmmSetReward",ClmmCollectReward:"ClmmCollectReward",ClmmLockPosition:"ClmmLockPosition",ClmmHarvestLockPosition:"ClmmHarvestLockPosition",AmmV4Swap:"AmmV4Swap",AmmV4AddLiquidity:"AmmV4AddLiquidity",AmmV4RemoveLiquidity:"AmmV4RemoveLiquidity",AmmV4SimulatePoolInfo:"AmmV4SimulatePoolInfo",AmmV4SwapBaseIn:"AmmV4SwapBaseIn",AmmV4SwapBaseOut:"AmmV4SwapBaseOut",AmmV4CreatePool:"AmmV4CreatePool",AmmV4InitPool:"AmmV4InitPool",AmmV5AddLiquidity:"AmmV5AddLiquidity",AmmV5RemoveLiquidity:"AmmV5RemoveLiquidity",AmmV5SimulatePoolInfo:"AmmV5SimulatePoolInfo",AmmV5SwapBaseIn:"AmmV5SwapBaseIn",AmmV5SwapBaseOut:"AmmV5SwapBaseOut",RouteSwap:"RouteSwap",RouteSwap1:"RouteSwap1",RouteSwap2:"RouteSwap2",FarmV3Deposit:"FarmV3Deposit",FarmV3Withdraw:"FarmV3Withdraw",FarmV3CreateLedger:"FarmV3CreateLedger",FarmV4Withdraw:"FarmV4Withdraw",FarmV5Deposit:"FarmV5Deposit",FarmV5Withdraw:"FarmV5Withdraw",FarmV5CreateLedger:"FarmV5CreateLedger",FarmV6Deposit:"FarmV6Deposit",FarmV6Withdraw:"FarmV6Withdraw",FarmV6Create:"FarmV6Create",FarmV6Restart:"FarmV6Restart",FarmV6CreatorAddReward:"FarmV6CreatorAddReward",FarmV6CreatorWithdraw:"FarmV6CreatorWithdraw",CpmmCreatePool:"CpmmCreatePool",CpmmAddLiquidity:"CpmmAddLiquidity",CpmmWithdrawLiquidity:"CpmmWithdrawLiquidity",CpmmSwapBaseIn:"CpmmSwapBaseIn",CpmmSwapBaseOut:"CpmmSwapBaseOut",CpmmLockLp:"CpmmLockLp",CpmmCollectLockFee:"CpmmCollectLockFee",TransferTip:"TransferTip"};import{TOKEN_PROGRAM_ID as Zm}from"@solana/spl-token";var gn=be("Raydium_txUtil"),sc=1644;function si(a){let e=[],t=[];return a.microLamports&&(e.push(oc.setComputeUnitPrice({microLamports:a.microLamports})),t.push(G.SetComputeUnitPrice)),a.units&&(e.push(oc.setComputeUnitLimit({units:a.units})),t.push(G.SetComputeUnitLimit)),{instructions:e,instructionTypes:t}}async function ro(a,e){var n,o;let t=e!=null?e:"confirmed";return(o=await((n=a.getLatestBlockhash)==null?void 0:n.call(a,{commitment:t})))==null?void 0:o.blockhash}async function ai(a,e){return a.getSignatureStatuses([e]),new Promise((t,n)=>{let o=setTimeout(n,6e4);a.onSignature(e,r=>{if(clearTimeout(o),!r.err){t("");return}n(Object.assign(r.err,{txId:e}))},"confirmed")})}function Ir(a,e){a.length<1&&gn.logWithError(`no instructions provided: ${a.toString()}`),e.length<1&&gn.logWithError(`no signers provided:, ${e.toString()}`);let t=new hr;t.recentBlockhash="11111111111111111111111111111111",t.feePayer=e[0],t.add(...a);try{return Buffer.from(t.serialize({verifySignatures:!1})).toString("base64").length<sc}catch{return!1}}async function ac(a,e,t,n=!0){let o=new rc("RaydiumSimuLateTransaction11111111111111111"),r=[],i=new hr;i.feePayer=o;for(let u of e)Ir([...i.instructions,u],[o])||(r.push(i),i=new hr,i.feePayer=o),i.add(u);i.instructions.length>0&&r.push(i);let s=[];try{if(s=await Jm(a,r,n),s.find(u=>u.err!==null))throw Error("rpc simulateTransaction error")}catch(u){u instanceof Error&&gn.logWithError("failed to simulate for instructions","RPC_ERROR",{message:u.message})}let c=[];for(let u of s)if(gn.debug("simulate result:",u),u.logs){let l=u.logs.filter(m=>m&&m.includes(t));gn.debug("filteredLog:",c),l.length||gn.logWithError("simulate log not match keyword","keyword",t),c.push(...l)}return c}function uc(a,e){let t=a.match(/{["\w:,]+}/g);return!t||t.length!==1?gn.logWithError(`simulate log fail to match json, keyword: ${e}`):t[0]}function Pn(a,e){let n=new RegExp(`"${e}":(\\d+)`,"g").exec(a);return!n||n.length!==2?gn.logWithError(`simulate log fail to match key", key: ${e}`):n[1]}function te(a,e){let[t,n]=rc.findProgramAddressSync(a,e);return{publicKey:t,nonce:n}}async function Jm(a,e,t){let n=[];if(t){let o=await a.getLatestBlockhash(),r=[];for(let u of e){u.recentBlockhash=o.blockhash,u.lastValidBlockHeight=o.lastValidBlockHeight;let m=u._compile().serialize(),d=u._serialize(m).toString("base64");r.push(d)}let i=r.map(u=>{let l=a._buildArgs([u],void 0,"base64");return{methodName:"simulateTransaction",args:l}}),s=[],c=20;for(let u=0;u<Math.ceil(i.length/c);u++)s.push(i.slice(u*c,(u+1)*c));n=await(await Promise.all(s.map(async u=>(await a._rpcBatchRequest(u)).map(l=>l.result.value)))).flat()}else try{n=await Promise.all(e.map(async o=>await(await a.simulateTransaction(o)).value))}catch(o){o instanceof Error&&gn.logWithError("failed to get info for multiple accounts","RPC_ERROR",{message:o.message})}return n}function ui({instructions:a,payer:e,signers:t}){return Ir(a,[e,...t])}function An({instructions:a,payer:e,lookupTableAddressAccount:t,recentBlockhash:n=ic.generate().publicKey.toString()}){let r=new $m({payerKey:e,recentBlockhash:n,instructions:a}).compileToV0Message(Object.values(t!=null?t:{}));try{return Buffer.from(new Vs(r).serialize()).toString("base64").length<sc}catch{return!1}}var Tr={time:0,data:void 0};async function iP(a){if(!Tr.data||(Date.now()-Tr.time)/1e3>30){let e=await a.getEpochInfo();return Tr={time:Date.now(),data:e},e}else return Tr.data}var cc=a=>Buffer.isBuffer(a)?a:a instanceof Uint8Array?Buffer.from(a.buffer,a.byteOffset,a.byteLength):Buffer.from(a),ed=a=>{let e=a.serialize({requireAllSignatures:!1,verifySignatures:!1});a instanceof Vs&&(e=cc(e));try{return e instanceof Buffer?e.toString("base64"):Buffer.from(e).toString("base64")}catch{return e.toString("base64")}};function Vn(a){let e=[];return a.forEach(t=>{t instanceof hr&&(t.recentBlockhash||(t.recentBlockhash=Zm.toBase58()),t.feePayer||(t.feePayer=ic.generate().publicKey)),e.push(ed(t))}),console.log("simulate tx string:",e),e}function rP(a){let e=a.serialize({requireAllSignatures:!1,verifySignatures:!1});return a instanceof Vs&&(e=cc(e)),e.toString("base64")}function j(a,e,t){return te([a.toBuffer(),(t!=null?t:nd).toBuffer(),e.toBuffer()],new td("ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL"))}import{PublicKey as ie}from"@solana/web3.js";var _s=new ie("EhhTKczWMGQt46ynNeRX1WfeagwwJd7ufHvCDjRxjo5Q"),Es=new ie("CBuCnLe26faBpcBP2fktp4rp8abpcAnTWft6ZrP5Q4T"),Ws=new ie("9KEPoZmtHUrBbhWN1v1KWLMkkvwY6WLtAVUCPRtRjP4z"),Ro=new ie("FarmqiPv5eAj3j1GMdMCMUGXqPUvmquZtMy86QH6rzhG"),od=new ie("CLaimxFqjHzgTJtAGHU47NPhg6qrc5sCnpC4tBLyABQS"),Ds=new ie("srmqPvymJeFKQ4zGQed1GFppgkRHL9kaELCbyksJtPX"),Br=new ie("9xQeWvG816bUx9EPjHmaT23yvVM2ZWbrrpZb9PusVFin"),ci=new ie("675kPX9MHTjS2zt1qfr1NYHuzeLXfQM9H24wFSUt1Mp8"),id=new ie("5quBtoiQqxF9Jv6KYKctB59NT3gtJD2Y65kdnB1Uev3h"),xr=new ie("CDSr3ssLcRB6XYPJwAfFt18MZvEZp4LjHcvzBVZ45duo"),_n=new ie("CAMMCzo5YL8w4VFF8KVHrK22GGUsp5VTaW7grrKgrWqK"),Lo=new ie("LockrWmn6K5twhz3y9w1dQERbmgSaRkfnTeTKbpofwE"),li=new ie("kN1kEznaF5Xbd8LYuqtEFcxzWSBk5Fv6ygX6SqEGJVy"),En=new ie("CDSr3ssLcRB6XYPJwAfFt18MZvEZp4LjHcvzBVZ45duo"),rd=new ie("routeUGWgWzqBWFcrCfv8tritsqukccJPu3q5GPP3xS"),qs=new ie("7YttLkHDoNj9wyDur5pM1ejNaAvT9X4eqaYcHQqtj2G5"),sd=new ie("6FJon3QE27qgPVggARueB22hLvoh22VzJpXv4rBEoSLF"),ad=new ie("CC12se5To1CdEuw7fDS27B7Geo5jJyL7t5UK2B44NgiH"),ud=new ie("9HzJyW1qZsEiSfMUf6L2jo3CcTKAyBmSyKdwQeYisHrC"),cd=new ie("DropEU8AvevN3UrXWXTMuz3rqnMczQVNjq3kcSdW2SQi"),Wn=new ie("CPMMoo8L3F4NbTegBCKVNunggL7H1ZpdTHKxQB5qKP1C"),Us=new ie("GpMZbSM2GgvTKHJirzeGfMFoaZ8UR2X7F4v8vHTvxFbL"),ld=new ie("DNXgeM9EiiaAbaWvwjHj9fQQLAX5ZsfHyvmYUNRAdNC8"),mi=new ie("LockrWmn6K5twhz3y9w1dQERbmgSaRkfnTeTKbpofwE"),di=new ie("3f7GcQFG397GAaEnv51zR6tsTVihYRydnydDD1cXekxH"),it=new ie("LanMV9sAd7wArD4vJFi2qDdfnVhFxYSUg6eADduJ3uj"),md=new ie("WLHv2UAZm6z4KyaaELi5pjdbJh6RESMva1Rnn8pJVVh"),dP=new ie("DRay6fNdQ5J82H7xV6uq2aV3mNrUZ1J4PgSKsWgptcm6"),pP=new ie("5xqNaZXX5eUi4p5HU4oz9i5QnwRNT2y6oN7yyn4qENeq"),dd=new ie("4Bu96XjU84XjPDSpveTVf6LYGCkfW5FK7SNkREWcEfV4"),pd=new ie("6s1xP3hpbAfFoNtUNF8mfHsjr2Bd97JxFJRWLbL6aHuX"),pi={IDO_PROGRAM_ID_V1:sd,IDO_PROGRAM_ID_V2:ad,IDO_PROGRAM_ID_V3:ud,IDO_PROGRAM_ID_V4:cd},ht={AMM_V4:ci,AMM_STABLE:id,CLMM_PROGRAM_ID:_n,CLMM_LOCK_PROGRAM_ID:Lo,CLMM_LOCK_AUTH_ID:li,FARM_PROGRAM_ID_V3:_s,FARM_PROGRAM_ID_V4:Es,FARM_PROGRAM_ID_V5:Ws,FARM_PROGRAM_ID_V6:Ro,OPEN_BOOK_PROGRAM:Ds,SERUM_PROGRAM_ID_V3:Br,UTIL1216:od,Router:rd,CREATE_CPMM_POOL_PROGRAM:Wn,CREATE_CPMM_POOL_AUTH:Us,CREATE_CPMM_POOL_FEE_ACC:ld,LOCK_CPMM_PROGRAM:mi,LOCK_CPMM_AUTH:di,LAUNCHPAD_PROGRAM:it,LAUNCHPAD_AUTH:md,LAUNCHPAD_PLATFORM:dd,LAUNCHPAD_CONFIG:pd,FEE_DESTINATION_ID:qs,MODEL_DATA_PUBKEY:En},kn={OPEN_BOOK_PROGRAM:new ie("EoTcMgcDRTJVZDMZWBoU6rhYHZfkNTVEAfz3uUJRcYGj"),SERUM_PROGRAM_ID_V3:new ie("Ray1111111111111111111111111111111111111111"),AMM_V4:new ie("DRaya7Kj3aMWQSy19kSjvmuwq9docCHofyP9kanQGaav"),AMM_STABLE:new ie("DRayDdXc1NZQ9C3hRWmoSf8zK4iapgMnjdNZWrfwsP8m"),CLMM_PROGRAM_ID:new ie("DRayAUgENGQBKVaX8owNhgzkEDyoHTGVEGHVJT1E9pfH"),CLMM_LOCK_PROGRAM_ID:new ie("DRay25Usp3YJAi7beckgpGUC7mGJ2cR1AVPxhYfwVCUX"),CLMM_LOCK_AUTH_ID:new ie("6Aoh8h2Lw2m5UGxYR8AdAL87jTWYeKoxM52mJRzfYwN"),CREATE_CPMM_POOL_PROGRAM:new ie("DRaycpLY18LhpbydsBWbVJtxpNv9oXPgjRSfpF2bWpYb"),CREATE_CPMM_POOL_AUTH:new ie("CXniRufdq5xL8t8jZAPxsPZDpuudwuJSPWnbcD5Y5Nxq"),CREATE_CPMM_POOL_FEE_ACC:new ie("3oE58BKVt8KuYkGxx8zBojugnymWmBiyafWgMrnb6eYy"),LOCK_CPMM_PROGRAM:new ie("DRay25Usp3YJAi7beckgpGUC7mGJ2cR1AVPxhYfwVCUX"),LOCK_CPMM_AUTH:new ie("7qWVV8UY2bRJfDLP4s37YzBPKUkVB46DStYJBpYbQzu3"),UTIL1216:ie.default,Router:new ie("DRaybByLpbUL57LJARs3j8BitTxVfzBg351EaMr5UTCd"),FARM_PROGRAM_ID_V3:new ie("DRayWyrLmEW5KEeqs8kdTMMaBabapqagaBC7KWpGtJeZ"),FARM_PROGRAM_ID_V4:new ie("Ray1111111111111111111111111111111111111111"),FARM_PROGRAM_ID_V5:new ie("DRayiCGSZgku1GTK6rXD6mVDdingXy6APAH1R6R5L2LC"),FARM_PROGRAM_ID_V6:new ie("DRayzbYakXs45ELHkzH6vC3fuhQqTAnv5A68gdFuvZyZ"),LAUNCHPAD_PROGRAM:new ie("DRay6fNdQ5J82H7xV6uq2aV3mNrUZ1J4PgSKsWgptcm6"),LAUNCHPAD_AUTH:new ie("5xqNaZXX5eUi4p5HU4oz9i5QnwRNT2y6oN7yyn4qENeq"),LAUNCHPAD_PLATFORM:new ie("2Jx4KTDrVSdWNazuGpcA8n3ZLTRGGBDxAWhuKe2Xcj2a"),LAUNCHPAD_CONFIG:new ie("7ZR4zD7PYfY2XxoG1Gxcy2EgEeGYrpxrwzPuwdUBssEt"),FEE_DESTINATION_ID:new ie("9y8ENuuZ3b19quffx9hQvRVygG5ky6snHfRvGpuSfeJy"),MODEL_DATA_PUBKEY:new ie("Ray1111111111111111111111111111111111111111")};import Te from"bn.js";var It=1e4;function bP(a,e,t,n){if(e===void 0)return{amount:a,fee:void 0,expirationTime:void 0};let o=t.epoch<e.newerTransferFee.epoch?e.olderTransferFee:e.newerTransferFee,r=new Te(o.maximumFee.toString()),i=t.epoch<e.newerTransferFee.epoch?(Number(e.newerTransferFee.epoch)*t.slotsInEpoch-t.absoluteSlot)*400/1e3:void 0;if(n)if(o.transferFeeBasisPoints===It){let s=new Te(o.maximumFee.toString());return{amount:a.add(s),fee:s,expirationTime:i}}else{let s=nn(a.mul(new Te(It)),new Te(It-o.transferFeeBasisPoints)),c=new Te(o.maximumFee.toString()),u=s.sub(a).gt(c)?a.add(c):s,l=nn(u.mul(new Te(o.transferFeeBasisPoints)),new Te(It)),m=l.gt(r)?r:l;return{amount:u,fee:m,expirationTime:i}}else{let s=nn(a.mul(new Te(o.transferFeeBasisPoints)),new Te(It)),c=s.gt(r)?r:s;return{amount:a,fee:c,expirationTime:i}}}function xe(a,e,t,n){if(e===void 0)return{amount:a,fee:void 0,expirationTime:void 0};let o=q(M({},e),{olderTransferFee:{epoch:BigInt(e.olderTransferFee.epoch),maximumFee:BigInt(e.olderTransferFee.maximumFee),transferFeeBasisPoints:e.olderTransferFee.transferFeeBasisPoints},newerTransferFee:{epoch:BigInt(e.newerTransferFee.epoch),maximumFee:BigInt(e.newerTransferFee.maximumFee),transferFeeBasisPoints:e.newerTransferFee.transferFeeBasisPoints}}),r=t.epoch<o.newerTransferFee.epoch?o.olderTransferFee:o.newerTransferFee,i=new Te(r.maximumFee.toString()),s=t.epoch<o.newerTransferFee.epoch?(Number(o.newerTransferFee.epoch)*t.slotsInEpoch-t.absoluteSlot)*400/1e3:void 0;if(n)if(r.transferFeeBasisPoints===It){let c=new Te(r.maximumFee.toString());return{amount:a.add(c),fee:c,expirationTime:s}}else{let c=nn(a.mul(new Te(It)),new Te(It-r.transferFeeBasisPoints)),u=new Te(r.maximumFee.toString()),l=c.sub(a).gt(u)?a.add(u):c,m=nn(l.mul(new Te(r.transferFeeBasisPoints)),new Te(It)),p=m.gt(i)?i:m;return{amount:l,fee:p,expirationTime:s}}else{let c=nn(a.mul(new Te(r.transferFeeBasisPoints)),new Te(It)),u=c.gt(i)?i:c;return{amount:a,fee:u,expirationTime:s}}}function on(a,e){return a===void 0?e:e===void 0?a:Math.min(a,e)}function nn(a,e){let{div:t,mod:n}=a.divmod(e);return n.gt(new Te(0))?t.add(new Te(1)):t}function so(a,e){if(a.isZero())return new Te(0);let t=a.div(e);return t.isZero()?new Te(1):a.mod(e).gt(new Te(0))?t.add(new Te(1)):t}function Gs(a,e,t){if(e===void 0)return{amount:a,fee:void 0,expirationTime:void 0};let n=Math.floor(t/432e3),o=n<e.newerTransferFee.epoch?e.olderTransferFee:e.newerTransferFee,r=new Te(o.maximumFee.toString()),i=n<e.newerTransferFee.epoch?(Number(e.newerTransferFee.epoch)*432e3-t)*400/1e3:void 0,s=nn(a.mul(new Te(o.transferFeeBasisPoints)),new Te(It)),c=s.gt(r)?r:s;return{amount:a,fee:c,expirationTime:i}}function Xs(a,e,t){if(e===void 0)return{amount:a,fee:void 0,expirationTime:void 0};let n=Math.floor(t/432e3),o=n<e.newerTransferFee.epoch?e.olderTransferFee:e.newerTransferFee,r=new Te(o.maximumFee.toString()),i=n<e.newerTransferFee.epoch?(Number(e.newerTransferFee.epoch)*432e3-t)*400/1e3:void 0;if(o.transferFeeBasisPoints===It){let s=new Te(o.maximumFee.toString());return{amount:a.add(s),fee:s,expirationTime:i}}else{let s=nn(a.mul(new Te(It)),new Te(It-o.transferFeeBasisPoints)),c=new Te(o.maximumFee.toString()),u=s.sub(a).gt(c)?a.add(c):s,l=nn(u.mul(new Te(o.transferFeeBasisPoints)),new Te(It)),m=l.gt(r)?r:l;return{amount:u,fee:m,expirationTime:i}}}import{PublicKey as zs,AddressLookupTableAccount as No}from"@solana/web3.js";async function Kr({connection:a,address:e,cluster:t="mainnet"}){let n=await tn(a,[...new Set(e.map(r=>r.toString()))].map(r=>new zs(r))),o={};for(let r=0;r<e.length;r++){let i=n[r],s=e[r];if(!i)continue;let c=new No({key:s,state:No.deserialize(i.data)});o[s.toString()]=c,t==="devnet"?Oo[s.toString()]=c:Dn[s.toString()]=c}return o}var Dn={},Ys=async a=>{let e="AcL1Vo8oy1ULiavEcjSUcwfBSForXMudcZvDZy5nzJkU";if(Dn[e])return Dn;let t=new zs(e),n=await a.getAccountInfo(t);return n&&(Dn[e]=new No({key:t,state:No.deserialize(n.data)})),Dn},Oo={},Sr=async a=>{let e="EFhMuDw1PKEuckuFRW9PavNfTH4LKP5uKHgyXDmWpFCq";if(Oo[e])return Oo;let t=new zs(e),n=await a.getAccountInfo(t);return n&&(Oo[e]=new No({key:t,state:No.deserialize(n.data)})),Oo};import{PublicKey as ao,sendAndConfirmTransaction as Qs,SystemProgram as fd,Transaction as fi,TransactionMessage as wn,VersionedTransaction as Tn}from"@solana/web3.js";import yd from"axios";var yi=2e3,bi=class{constructor(e){this.instructions=[];this.endInstructions=[];this.lookupTableAddress=[];this.signers=[];this.instructionTypes=[];this.endInstructionTypes=[];this.connection=e.connection,this.feePayer=e.feePayer,this.signAllTransactions=e.signAllTransactions,this.owner=e.owner,this.cluster=e.cluster,this.blockhashCommitment=e.blockhashCommitment,this.loopMultiTxStatus=!!e.loopMultiTxStatus}get AllTxData(){return{instructions:this.instructions,endInstructions:this.endInstructions,signers:this.signers,instructionTypes:this.instructionTypes,endInstructionTypes:this.endInstructionTypes,lookupTableAddress:this.lookupTableAddress}}get allInstructions(){return[...this.instructions,...this.endInstructions]}async getComputeBudgetConfig(){var n;let e=(await yd.get(`https://solanacompass.com/api/fees?cacheFreshTime=${3e5}`)).data,{avg:t}=(n=e==null?void 0:e[15])!=null?n:{};if(!!t)return{units:6e5,microLamports:Math.min(Math.ceil(t*1e6/6e5),25e3)}}addCustomComputeBudget(e){if(e){let{instructions:t,instructionTypes:n}=si(e);return this.instructions.unshift(...t),this.instructionTypes.unshift(...n),!0}return!1}addTipInstruction(e){var t;return e?(this.endInstructions.push(fd.transfer({fromPubkey:(t=e.feePayer)!=null?t:this.feePayer,toPubkey:new ao(e.address),lamports:BigInt(e.amount.toString())})),this.endInstructionTypes.push(G.TransferTip),!0):!1}async calComputeBudget({config:e,defaultIns:t}){try{let n=e||await this.getComputeBudgetConfig();if(this.addCustomComputeBudget(n))return;t&&this.instructions.unshift(...t)}catch{t&&this.instructions.unshift(...t)}}addInstruction({instructions:e=[],endInstructions:t=[],signers:n=[],instructionTypes:o=[],endInstructionTypes:r=[],lookupTableAddress:i=[]}){return this.instructions.push(...e),this.endInstructions.push(...t),this.signers.push(...n),this.instructionTypes.push(...o),this.endInstructionTypes.push(...r),this.lookupTableAddress.push(...i.filter(s=>s!==ao.default.toString())),this}async versionBuild({txVersion:e,extInfo:t}){return e===0?await this.buildV0(M({},t||{})):this.build(t)}build(e){var n;let t=new fi;return this.allInstructions.length&&t.add(...this.allInstructions),t.feePayer=this.feePayer,((n=this.owner)==null?void 0:n.signer)&&!this.signers.some(o=>o.publicKey.equals(this.owner.publicKey))&&this.signers.push(this.owner.signer),{builder:this,transaction:t,signers:this.signers,instructionTypes:[...this.instructionTypes,...this.endInstructionTypes],execute:async o=>{var l;let{recentBlockHash:r,skipPreflight:i=!0,sendAndConfirm:s,notSendToRpc:c}=o||{},u=r!=null?r:await ro(this.connection,this.blockhashCommitment);if(t.recentBlockhash=u,this.signers.length&&t.sign(...this.signers),Vn([t]),(l=this.owner)!=null&&l.isKeyPair)return{txId:s?await Qs(this.connection,t,this.signers.find(p=>p.publicKey.equals(this.owner.publicKey))?this.signers:[...this.signers,this.owner.signer],{skipPreflight:i}):await this.connection.sendRawTransaction(t.serialize(),{skipPreflight:i}),signedTx:t};if(this.signAllTransactions){let m=await this.signAllTransactions([t]);if(this.signers.length)for(let p of m)try{p.sign(...this.signers)}catch{}return{txId:c?"":await this.connection.sendRawTransaction(m[0].serialize(),{skipPreflight:i}),signedTx:m[0]}}throw new Error("please provide owner in keypair format or signAllTransactions function")},extInfo:e||{}}}buildMultiTx(e){var u;let{extraPreBuildData:t=[],extInfo:n}=e,{transaction:o}=this.build(n),r=t.filter(l=>l.transaction.instructions.length>0),i=[o,...r.map(l=>l.transaction)],s=[this.signers,...r.map(l=>l.signers)],c=[...this.instructionTypes,...r.map(l=>l.instructionTypes).flat()];return(u=this.owner)!=null&&u.signer&&s.forEach(l=>{l.some(m=>m.publicKey.equals(this.owner.publicKey))||this.signers.push(this.owner.signer)}),{builder:this,transactions:i,signers:s,instructionTypes:c,execute:async l=>{var g;let{sequentially:m,onTxUpdate:p,skipTxCount:d=0,recentBlockHash:f,skipPreflight:y=!0}=l||{},b=f!=null?f:await ro(this.connection,this.blockhashCommitment);if((g=this.owner)!=null&&g.isKeyPair){if(m){let P=[],h=0;for(let I of i){if(++h,h<=d)continue;let T=await Qs(this.connection,I,this.signers.find(w=>w.publicKey.equals(this.owner.publicKey))?this.signers:[...this.signers,this.owner.signer],{skipPreflight:y});P.push(T)}return{txIds:P,signedTxs:i}}return{txIds:await await Promise.all(i.map(async P=>(P.recentBlockhash=b,await this.connection.sendRawTransaction(P.serialize(),{skipPreflight:y})))),signedTxs:i}}if(this.signAllTransactions){let P=i.map((I,T)=>(I.recentBlockhash=b,s[T].length&&I.sign(...s[T]),I));Vn(P);let h=await this.signAllTransactions(P);if(m){let I=0,T=[],w=async()=>{if(!h[I])return;let K=await this.connection.sendRawTransaction(h[I].serialize(),{skipPreflight:y});T.push({txId:K,status:"sent",signedTx:h[I]}),p==null||p([...T]),I++;let x=!1,S=null,B=null,R=C=>{S!==null&&clearInterval(S),B!==null&&this.connection.removeSignatureListener(B);let v=T.findIndex(L=>L.txId===K);if(v>-1){if(T[v].status==="error"||T[v].status==="success")return;T[v].status=C.err?"error":"success"}p==null||p([...T]),C.err||w()};this.loopMultiTxStatus&&(S=setInterval(async()=>{var C;if(x){clearInterval(S);return}try{let v=await this.connection.getTransaction(K,{commitment:"confirmed",maxSupportedTransactionVersion:0});v&&(x=!0,clearInterval(S),R({err:((C=v.meta)==null?void 0:C.err)||null}),console.log("tx status from getTransaction:",K))}catch(v){x=!0,clearInterval(S),console.error("getTransaction timeout:",v,K)}},yi)),B=this.connection.onSignature(K,C=>{if(x){this.connection.removeSignatureListener(B);return}x=!0,R(C)},"confirmed"),this.connection.getSignatureStatus(K)};return await w(),{txIds:T.map(K=>K.txId),signedTxs:h}}else{let I=[];for(let T=0;T<h.length;T+=1){let w=await this.connection.sendRawTransaction(h[T].serialize(),{skipPreflight:y});I.push(w)}return{txIds:I,signedTxs:h}}}throw new Error("please provide owner in keypair format or signAllTransactions function")},extInfo:n||{}}}async versionMultiBuild({extraPreBuildData:e,txVersion:t,extInfo:n}){return t===0?await this.buildV0MultiTx({extraPreBuildData:e,buildProps:n||{}}):this.buildMultiTx({extraPreBuildData:e,extInfo:n})}async buildV0(e){var y;let f=e||{},{lookupTableCache:t={},lookupTableAddress:n=[],forerunCreate:o,recentBlockhash:r}=f,i=_e(f,["lookupTableCache","lookupTableAddress","forerunCreate","recentBlockhash"]),s=M(M({},this.cluster==="devnet"?await Sr(this.connection):await Ys(this.connection)),t),c=Array.from(new Set([...n,...this.lookupTableAddress])),u=[];for(let b of c)s[b]===void 0&&u.push(new ao(b));let l=await Kr({connection:this.connection,address:u});for(let[b,g]of Object.entries(l))s[b]=g;let m=o?ao.default.toBase58():r!=null?r:await ro(this.connection,this.blockhashCommitment),p=new wn({payerKey:this.feePayer,recentBlockhash:m,instructions:[...this.allInstructions]}).compileToV0Message(Object.values(s));((y=this.owner)==null?void 0:y.signer)&&!this.signers.some(b=>b.publicKey.equals(this.owner.publicKey))&&this.signers.push(this.owner.signer);let d=new Tn(p);return d.sign(this.signers),{builder:this,transaction:d,signers:this.signers,instructionTypes:[...this.instructionTypes,...this.endInstructionTypes],execute:async b=>{var I;let{skipPreflight:g=!0,sendAndConfirm:P,notSendToRpc:h}=b||{};if(Vn([d]),(I=this.owner)!=null&&I.isKeyPair){let T=await this.connection.sendTransaction(d,{skipPreflight:g});return P&&await ai(this.connection,T),{txId:T,signedTx:d}}if(this.signAllTransactions){let T=await this.signAllTransactions([d]);if(this.signers.length)for(let w of T)try{w.sign(this.signers)}catch{}return{txId:h?"":await this.connection.sendTransaction(T[0],{skipPreflight:g}),signedTx:T[0]}}throw new Error("please provide owner in keypair format or signAllTransactions function")},extInfo:i||{}}}async buildV0MultiTx(e){var u;let{extraPreBuildData:t=[],buildProps:n}=e,{transaction:o}=await this.buildV0(n),r=t.filter(l=>l.builder.instructions.length>0),i=[o,...r.map(l=>l.transaction)],s=[this.signers,...r.map(l=>l.signers)],c=[...this.instructionTypes,...r.map(l=>l.instructionTypes).flat()];return(u=this.owner)!=null&&u.signer&&s.forEach(l=>{l.some(m=>m.publicKey.equals(this.owner.publicKey))||this.signers.push(this.owner.signer)}),i.forEach(async(l,m)=>{l.sign(s[m])}),{builder:this,transactions:i,signers:s,instructionTypes:c,buildProps:n,execute:async l=>{var y;let{sequentially:m,onTxUpdate:p,recentBlockHash:d,skipPreflight:f=!0}=l||{};if(d&&i.forEach(b=>b.message.recentBlockhash=d),Vn(i),(y=this.owner)!=null&&y.isKeyPair){if(m){let b=[];for(let g of i){let P=await this.connection.sendTransaction(g,{skipPreflight:f});await ai(this.connection,P),b.push(P)}return{txIds:b,signedTxs:i}}return{txIds:await Promise.all(i.map(async b=>await this.connection.sendTransaction(b,{skipPreflight:f}))),signedTxs:i}}if(this.signAllTransactions){let b=await this.signAllTransactions(i);if(m){let g=0,P=[],h=async()=>{if(!b[g])return;let I=await this.connection.sendTransaction(b[g],{skipPreflight:f});P.push({txId:I,status:"sent",signedTx:b[g]}),p==null||p([...P]),g++;let T=!1,w=null,K=null,x=S=>{w!==null&&clearInterval(w),K!==null&&this.connection.removeSignatureListener(K);let B=P.findIndex(R=>R.txId===I);if(B>-1){if(P[B].status==="error"||P[B].status==="success")return;P[B].status=S.err?"error":"success"}p==null||p([...P]),S.err||h()};this.loopMultiTxStatus&&(w=setInterval(async()=>{var S;if(T){clearInterval(w);return}try{let B=await this.connection.getTransaction(I,{commitment:"confirmed",maxSupportedTransactionVersion:0});B&&(T=!0,clearInterval(w),x({err:((S=B.meta)==null?void 0:S.err)||null}),console.log("tx status from getTransaction:",I))}catch(B){T=!0,clearInterval(w),console.error("getTransaction timeout:",B,I)}},yi)),K=this.connection.onSignature(I,S=>{if(T){this.connection.removeSignatureListener(K);return}T=!0,x(S)},"confirmed"),this.connection.getSignatureStatus(I)};return h(),{txIds:[],signedTxs:b}}else{let g=[];for(let P=0;P<b.length;P+=1){let h=await this.connection.sendTransaction(b[P],{skipPreflight:f});g.push(h)}return{txIds:g,signedTxs:b}}}throw new Error("please provide owner in keypair format or signAllTransactions function")},extInfo:n||{}}}async sizeCheckBuild(e){var p;let m=e||{},{splitIns:t=[],computeBudgetConfig:n}=m,o=_e(m,["splitIns","computeBudgetConfig"]),r=n?si(n):{instructions:[],instructionTypes:[]},i=this.signers.reduce((d,f)=>q(M({},d),{[f.publicKey.toBase58()]:f}),{}),s=[],c=[],u=[],l=0;if(this.allInstructions.forEach(d=>{let f=[...u,d],y=n?[...r.instructions,...f]:f,g=[...new Set(f.map(P=>P.keys.filter(h=>h.isSigner).map(h=>h.pubkey.toString())).flat()).values()].map(P=>new ao(P));if(d!==t[l]&&u.length<12&&(ui({instructions:y,payer:this.feePayer,signers:g})||ui({instructions:f,payer:this.feePayer,signers:g})))u.push(d);else{if(u.length===0)throw Error("item ins too big");l+=d===t[l]?1:0,ui({instructions:n?[...r.instructions,...u]:[...u],payer:this.feePayer,signers:g})?s.push(new fi().add(...r.instructions,...u)):s.push(new fi().add(...u)),c.push(Array.from(new Set(u.map(P=>P.keys.filter(h=>h.isSigner).map(h=>h.pubkey.toString())).flat())).map(P=>i[P]).filter(P=>P!==void 0)),u=[d]}}),u.length>0){let f=[...new Set(u.map(y=>y.keys.filter(b=>b.isSigner).map(b=>b.pubkey.toString())).flat()).values()].map(y=>i[y]).filter(y=>y!==void 0);ui({instructions:n?[...r.instructions,...u]:[...u],payer:this.feePayer,signers:f.map(y=>y.publicKey)})?s.push(new fi().add(...r.instructions,...u)):s.push(new fi().add(...u)),c.push(f)}return s.forEach(d=>d.feePayer=this.feePayer),(p=this.owner)!=null&&p.signer&&c.forEach(d=>{d.some(f=>f.publicKey.equals(this.owner.publicKey))||d.push(this.owner.signer)}),{builder:this,transactions:s,signers:c,instructionTypes:this.instructionTypes,execute:async d=>{var I;let{sequentially:f,onTxUpdate:y,skipTxCount:b=0,recentBlockHash:g,skipPreflight:P=!0}=d||{},h=g!=null?g:await ro(this.connection,this.blockhashCommitment);if(s.forEach(async(T,w)=>{T.recentBlockhash=h,c[w].length&&T.sign(...c[w])}),Vn(s),(I=this.owner)!=null&&I.isKeyPair){if(f){let T=0,w=[];for(let K of s){if(++T,T<=b){w.push("tx skipped");continue}let x=await Qs(this.connection,K,this.signers.find(S=>S.publicKey.equals(this.owner.publicKey))?this.signers:[...this.signers,this.owner.signer],{skipPreflight:P});w.push(x)}return{txIds:w,signedTxs:s}}return{txIds:await Promise.all(s.map(async T=>await this.connection.sendRawTransaction(T.serialize(),{skipPreflight:P}))),signedTxs:s}}if(this.signAllTransactions){let T=await this.signAllTransactions(s.slice(b,s.length)),w=[...s.slice(0,b),...T];if(f){let K=0,x=[],S=async()=>{if(!w[K])return;K<b&&(x.push({txId:"",status:"success",signedTx:w[K]}),y==null||y([...x]),K++,S());let B=await this.connection.sendRawTransaction(w[K].serialize(),{skipPreflight:P});x.push({txId:B,status:"sent",signedTx:w[K]}),y==null||y([...x]),K++;let R=!1,C=null,v=null,L=N=>{C!==null&&clearInterval(C),v!==null&&this.connection.removeSignatureListener(v);let E=x.findIndex(X=>X.txId===B);if(E>-1){if(x[E].status==="error"||x[E].status==="success")return;x[E].status=N.err?"error":"success"}y==null||y([...x]),N.err||S()};this.loopMultiTxStatus&&(C=setInterval(async()=>{var N;if(R){clearInterval(C);return}try{let E=await this.connection.getTransaction(B,{commitment:"confirmed",maxSupportedTransactionVersion:0});E&&(R=!0,clearInterval(C),L({err:((N=E.meta)==null?void 0:N.err)||null}),console.log("tx status from getTransaction:",B))}catch(E){R=!0,clearInterval(C),console.error("getTransaction timeout:",E,B)}},yi)),v=this.connection.onSignature(B,N=>{if(R){this.connection.removeSignatureListener(v);return}R=!0,L(N)},"confirmed"),this.connection.getSignatureStatus(B)};return await S(),{txIds:x.map(B=>B.txId),signedTxs:w}}else{let K=[];for(let x=0;x<w.length;x+=1){let S=await this.connection.sendRawTransaction(w[x].serialize(),{skipPreflight:P});K.push(S)}return{txIds:K,signedTxs:w}}}throw new Error("please provide owner in keypair format or signAllTransactions function")},extInfo:o||{}}}async sizeCheckBuildV0(e){var h;let P=e||{},{computeBudgetConfig:t,splitIns:n=[],lookupTableCache:o={},lookupTableAddress:r=[]}=P,i=_e(P,["computeBudgetConfig","splitIns","lookupTableCache","lookupTableAddress"]),s=M(M({},this.cluster==="devnet"?await Sr(this.connection):Dn),o),c=Array.from(new Set([...this.lookupTableAddress,...r])),u=[];for(let I of c)s[I]===void 0&&u.push(new ao(I));let l=await Kr({connection:this.connection,address:u});for(let[I,T]of Object.entries(l))s[I]=T;let m=t?si(t):{instructions:[],instructionTypes:[]},p=await ro(this.connection,this.blockhashCommitment),d=this.signers.reduce((I,T)=>q(M({},I),{[T.publicKey.toBase58()]:T}),{}),f=[],y=[],b=[],g=0;if(this.allInstructions.forEach(I=>{let T=[...b,I],w=t?[...m.instructions,...T]:T;if(I!==n[g]&&b.length<12&&(An({instructions:w,payer:this.feePayer,lookupTableAddressAccount:s})||An({instructions:T,payer:this.feePayer,lookupTableAddressAccount:s})))b.push(I);else{if(b.length===0)throw Error("item ins too big");g+=I===n[g]?1:0;let K={};for(let x of[...new Set(c)])s[x]!==void 0&&(K[x]=s[x]);if(t&&An({instructions:[...m.instructions,...b],payer:this.feePayer,lookupTableAddressAccount:s,recentBlockhash:p})){let x=new wn({payerKey:this.feePayer,recentBlockhash:p,instructions:[...m.instructions,...b]}).compileToV0Message(Object.values(s));f.push(new Tn(x))}else{let x=new wn({payerKey:this.feePayer,recentBlockhash:p,instructions:[...b]}).compileToV0Message(Object.values(s));f.push(new Tn(x))}y.push(Array.from(new Set(b.map(x=>x.keys.filter(S=>S.isSigner).map(S=>S.pubkey.toString())).flat())).map(x=>d[x]).filter(x=>x!==void 0)),b=[I]}}),b.length>0){let T=[...new Set(b.map(w=>w.keys.filter(K=>K.isSigner).map(K=>K.pubkey.toString())).flat()).values()].map(w=>d[w]).filter(w=>w!==void 0);if(t&&An({instructions:[...m.instructions,...b],payer:this.feePayer,lookupTableAddressAccount:s,recentBlockhash:p})){let w=new wn({payerKey:this.feePayer,recentBlockhash:p,instructions:[...m.instructions,...b]}).compileToV0Message(Object.values(s));f.push(new Tn(w))}else{let w=new wn({payerKey:this.feePayer,recentBlockhash:p,instructions:[...b]}).compileToV0Message(Object.values(s));f.push(new Tn(w))}y.push(T)}return(h=this.owner)!=null&&h.signer&&y.forEach(I=>{I.some(T=>T.publicKey.equals(this.owner.publicKey))||I.push(this.owner.signer)}),f.forEach((I,T)=>{I.sign(y[T])}),{builder:this,transactions:f,buildProps:e,signers:y,blockHash:p,instructionTypes:this.instructionTypes,execute:async I=>{var B;let{sequentially:T,onTxUpdate:w,skipTxCount:K=0,recentBlockHash:x,skipPreflight:S=!0}=I||{};if(f.map(async(R,C)=>{y[C].length&&R.sign(y[C]),x&&(R.message.recentBlockhash=x)}),Vn(f),(B=this.owner)!=null&&B.isKeyPair){if(T){let R=0,C=[];for(let v of f){if(++R,R<=K){console.log("skip tx: ",R),C.push("tx skipped");continue}let L=await this.connection.sendTransaction(v,{skipPreflight:S});await ai(this.connection,L),C.push(L)}return{txIds:C,signedTxs:f}}return{txIds:await Promise.all(f.map(async R=>await this.connection.sendTransaction(R,{skipPreflight:S}))),signedTxs:f}}if(this.signAllTransactions){let R=await this.signAllTransactions(f.slice(K,f.length)),C=[...f.slice(0,K),...R];if(T){let v=0,L=[],N=async()=>{if(!C[v])return;if(v<K){L.push({txId:"",status:"success",signedTx:C[v]}),w==null||w([...L]),v++,N();return}let E=await this.connection.sendTransaction(C[v],{skipPreflight:S});L.push({txId:E,status:"sent",signedTx:C[v]}),w==null||w([...L]),v++;let X=!1,Q=null,ee=null,de=re=>{Q!==null&&clearInterval(Q),ee!==null&&this.connection.removeSignatureListener(ee);let ue=L.findIndex(ge=>ge.txId===E);if(ue>-1){if(L[ue].status==="error"||L[ue].status==="success")return;L[ue].status=re.err?"error":"success"}w==null||w([...L]),re.err||N()};this.loopMultiTxStatus&&(Q=setInterval(async()=>{var re;if(X){clearInterval(Q);return}try{let ue=await this.connection.getTransaction(E,{commitment:"confirmed",maxSupportedTransactionVersion:0});ue&&(X=!0,clearInterval(Q),de({err:((re=ue.meta)==null?void 0:re.err)||null}),console.log("tx status from getTransaction:",E))}catch(ue){X=!0,clearInterval(Q),console.error("getTransaction timeout:",ue,E)}},yi)),ee=this.connection.onSignature(E,re=>{if(X){this.connection.removeSignatureListener(ee);return}X=!0,de(re)},"confirmed"),this.connection.getSignatureStatus(E)};return N(),{txIds:[],signedTxs:C}}else{let v=[];for(let L=0;L<C.length;L+=1){let N=await this.connection.sendTransaction(C[L],{skipPreflight:S});v.push(N)}return{txIds:v,signedTxs:C}}}throw new Error("please provide owner in keypair format or signAllTransactions function")},extInfo:i||{}}}async buildSniperTransaction(e){var h;let P=e||{},{computeBudgetConfig:t,splitIns:n=[],lookupTableCache:o={},lookupTableAddress:r=[]}=P,i=_e(P,["computeBudgetConfig","splitIns","lookupTableCache","lookupTableAddress"]),s=M(M({},this.cluster==="devnet"?await Sr(this.connection):await Ys(this.connection)),o),c=Array.from(new Set([...this.lookupTableAddress,...r])),u=[];for(let I of c)s[I]===void 0&&u.push(new ao(I));let l=await Kr({connection:this.connection,address:u});for(let[I,T]of Object.entries(l))s[I]=T;let m=t?si(t):{instructions:[],instructionTypes:[]},p=await ro(this.connection,this.blockhashCommitment),d=this.signers.reduce((I,T)=>q(M({},I),{[T.publicKey.toBase58()]:T}),{}),f=[],y=[],b=[],g=0;if(this.allInstructions.forEach(I=>{let T=[...b,I],w=t?[...m.instructions,...T]:T;if(I!==n[g]&&b.length<12&&(An({instructions:w,payer:this.feePayer,lookupTableAddressAccount:s})||An({instructions:T,payer:this.feePayer,lookupTableAddressAccount:s})))b.push(I);else{if(b.length===0)throw Error("item ins too big");g+=I===n[g]?1:0;let K={};for(let x of[...new Set(c)])s[x]!==void 0&&(K[x]=s[x]);if(t&&An({instructions:[...m.instructions,...b],payer:this.feePayer,lookupTableAddressAccount:s,recentBlockhash:p})){let x=new wn({payerKey:this.feePayer,recentBlockhash:p,instructions:[...m.instructions,...b]}).compileToV0Message(Object.values(s));f.push(new Tn(x))}else{let x=new wn({payerKey:this.feePayer,recentBlockhash:p,instructions:[...b]}).compileToV0Message(Object.values(s));f.push(new Tn(x))}y.push(Array.from(new Set(b.map(x=>x.keys.filter(S=>S.isSigner).map(S=>S.pubkey.toString())).flat())).map(x=>d[x]).filter(x=>x!==void 0)),b=[I]}}),b.length>0){let T=[...new Set(b.map(w=>w.keys.filter(K=>K.isSigner).map(K=>K.pubkey.toString())).flat()).values()].map(w=>d[w]).filter(w=>w!==void 0);if(t&&An({instructions:[...m.instructions,...b],payer:this.feePayer,lookupTableAddressAccount:s,recentBlockhash:p})){let w=new wn({payerKey:this.feePayer,recentBlockhash:p,instructions:[...m.instructions,...b]}).compileToV0Message(Object.values(s));f.push(new Tn(w))}else{let w=new wn({payerKey:this.feePayer,recentBlockhash:p,instructions:[...b]}).compileToV0Message(Object.values(s));f.push(new Tn(w))}y.push(T)}return(h=this.owner)!=null&&h.signer&&y.forEach(I=>{I.some(T=>T.publicKey.equals(this.owner.publicKey))||I.push(this.owner.signer)}),f.forEach((I,T)=>{I.sign(y[T])}),{builder:this,transactions:f,buildProps:e,signers:y,instructionTypes:this.instructionTypes,execute:async I=>{var B;let{sequentially:T,onTxUpdate:w,skipTxCount:K=0,recentBlockHash:x,skipPreflight:S=!0}=I||{};if(f.map(async(R,C)=>{y[C].length&&R.sign(y[C]),x&&(R.message.recentBlockhash=x)}),Vn(f),(B=this.owner)!=null&&B.isKeyPair){if(T){let R=0,C=[];for(let v of f){if(++R,R<=K){console.log("skip tx: ",R),C.push("tx skipped");continue}let L=await this.connection.sendTransaction(v,{skipPreflight:S});await ai(this.connection,L),C.push(L)}return{txIds:C,signedTxs:f}}return{txIds:await Promise.all(f.map(async R=>await this.connection.sendTransaction(R,{skipPreflight:S}))),signedTxs:f}}if(this.signAllTransactions){let R=await this.signAllTransactions(f.slice(K,f.length)),C=[...f.slice(0,K),...R];if(T){let v=0,L=[],N=async()=>{if(!C[v])return;if(v<K){L.push({txId:"",status:"success",signedTx:C[v]}),w==null||w([...L]),v++,N();return}let E=await this.connection.sendTransaction(C[v],{skipPreflight:S});L.push({txId:E,status:"sent",signedTx:C[v]}),w==null||w([...L]),v++;let X=!1,Q=null,ee=null,de=re=>{Q!==null&&clearInterval(Q),ee!==null&&this.connection.removeSignatureListener(ee);let ue=L.findIndex(ge=>ge.txId===E);if(ue>-1){if(L[ue].status==="error"||L[ue].status==="success")return;L[ue].status=re.err?"error":"success"}w==null||w([...L]),re.err||N()};this.loopMultiTxStatus&&(Q=setInterval(async()=>{var re;if(X){clearInterval(Q);return}try{let ue=await this.connection.getTransaction(E,{commitment:"confirmed",maxSupportedTransactionVersion:0});ue&&(X=!0,clearInterval(Q),de({err:((re=ue.meta)==null?void 0:re.err)||null}),console.log("tx status from getTransaction:",E))}catch(ue){X=!0,clearInterval(Q),console.error("getTransaction timeout:",ue,E)}},yi)),ee=this.connection.onSignature(E,re=>{if(X){this.connection.removeSignatureListener(ee);return}X=!0,de(re)},"confirmed"),this.connection.getSignatureStatus(E)};return N(),{txIds:[],signedTxs:C}}else{let v=[];for(let L=0;L<C.length;L+=1){let N=await this.connection.sendTransaction(C[L],{skipPreflight:S});v.push(N)}return{txIds:v,signedTxs:C}}}throw new Error("please provide owner in keypair format or signAllTransactions function")},extInfo:i||{}}}};import{PublicKey as bd}from"@solana/web3.js";import gd from"bn.js";async function lc(a){new Promise(e=>setTimeout(e,a))}function EP(){return new Date().getTime()}function Pd(a){return typeof a=="object"&&a!==null&&![Ke,Ie,bd,me,gd,lt,Qe].some(e=>typeof e=="object"&&a instanceof e)}function Ee(a){return typeof a=="string"?Rs(a):Array.isArray(a)?a.map(e=>Ee(e)):Pd(a)?Object.fromEntries(Object.entries(a).map(([e,t])=>[e,Ee(t)])):a}import Ad from"bn.js";var Rt=new Ad(1e6);var mc=(t=>(t.ALL="all",t.Strict="strict",t))(mc||{}),dc=(i=>(i.All="all",i.Standard="standard",i.Concentrated="concentrated",i.AllFarm="allFarm",i.StandardFarm="standardFarm",i.ConcentratedFarm="concentratedFarm",i))(dc||{});var mt={BASE_HOST:"https://api-v3.raydium.io",OWNER_BASE_HOST:"https://owner-v1.raydium.io",SERVICE_BASE_HOST:"https://service.raydium.io",MONITOR_BASE_HOST:"https://monitor.raydium.io",SERVICE_1_BASE_HOST:"https://service-v1.raydium.io",SEND_TRANSACTION:"/send-transaction",FARM_ARP:"/main/farm/info",FARM_ARP_LINE:"/main/farm-apr-tv",CLMM_CONFIG:"/main/clmm-config",CPMM_CONFIG:"/main/cpmm-config",VERSION:"/main/version",CHECK_AVAILABILITY:"/v3/main/AvailabilityCheckAPI",RPCS:"/main/rpcs",INFO:"/main/info",STAKE_POOLS:"/main/stake-pools",CHAIN_TIME:"/main/chain-time",TOKEN_LIST:"/mint/list",MINT_INFO_ID:"/mint/ids",JUP_TOKEN_LIST:"https://lite-api.jup.ag/tokens/v1/tagged/verified",POOL_LIST:"/pools/info/list",POOL_SEARCH_BY_ID:"/pools/info/ids",POOL_SEARCH_MINT:"/pools/info/mint",POOL_SEARCH_LP:"/pools/info/lps",POOL_KEY_BY_ID:"/pools/key/ids",POOL_LIQUIDITY_LINE:"/pools/line/liquidity",POOL_POSITION_LINE:"/pools/line/position",FARM_INFO:"/farms/info/ids",FARM_LP_INFO:"/farms/info/lp",FARM_KEYS:"/farms/key/ids",OWNER_CREATED_FARM:"/create-pool/{owner}",OWNER_IDO:"/main/ido/{owner}",OWNER_STAKE_FARMS:"/position/stake/{owner}",OWNER_LOCK_POSITION:"/position/clmm-lock/{owner}",IDO_KEYS:"/ido/key/ids",SWAP_HOST:"https://transaction-v1.raydium.io",SWAP_COMPUTE:"/compute/",SWAP_TX:"/transaction/",MINT_PRICE:"/mint/price",MIGRATE_CONFIG:"/main/migrate-lp",PRIORITY_FEE:"/main/auto-fee",CPMM_LOCK:"https://dynamic-ipfs.raydium.io/lock/cpmm/position"},cA=M({},mt);var pc="ray_tab_hash",Hs="ray_req_hash",kd=()=>{if(typeof window===void 0)return"";let a=sessionStorage.getItem(pc);return a||(a=`ray-${Date.now()}`,sessionStorage.setItem(pc,a)),a},Cr=async n=>{var o=n,{logCount:a=1e3,removeLastLog:e}=o,t=_e(o,["logCount","removeLastLog"]);if(typeof window===void 0)return new Promise(i=>i());let r=JSON.parse(localStorage.getItem(Hs)||"[]").slice(0,a-1);e&&r.pop(),new Blob([JSON.stringify(t.data)]).size>1024&&(t.data=JSON.stringify(t.data).substring(0,200)+"..."),r.unshift(q(M({},t),{time:Date.now(),session:kd()}));try{localStorage.setItem(Hs,JSON.stringify(r))}catch{if(e){let i=!1,s=JSON.stringify(t.data).substring(0,100);for(r[0].data=s+(s.length>100?"...":"");!i;){r.pop();let c=JSON.stringify(t.data).substring(0,100);r[0].data=c+(c.length>100?"...":"");try{localStorage.setItem(Hs,JSON.stringify(r)),i=!0}catch{i=!1}}return new Promise(c=>c())}return Cr(q(M({},t),{logCount:a,removeLastLog:!0}))}};import{TOKEN_2022_PROGRAM_ID as wd,TOKEN_PROGRAM_ID as Td}from"@solana/spl-token";var Mo=be("Raydium_Api"),js=new Map;async function OA(a,e,t=1e3){let n;for(;n==null;)try{Mo.debug(`Request ${a} through endlessRetry`),n=await e()}catch(o){Mo.error(`Request ${a} failed, retry after ${t} ms`,o),await lc(t)}return n}var Rr=class{constructor({cluster:e,timeout:t,logRequests:n,logCount:o,urlConfigs:r}){this.cluster=e,this.urlConfigs=r||{},this.logCount=o||1e3,this.api=fc.create({baseURL:this.urlConfigs.BASE_HOST||mt.BASE_HOST,timeout:t}),this.api.interceptors.request.use(i=>{let{method:s,baseURL:c,url:u}=i;return Mo.debug(`${s==null?void 0:s.toUpperCase()} ${c}${u}`),i},i=>(Mo.error("Request failed"),Promise.reject(i))),this.api.interceptors.response.use(i=>{let{config:s,data:c,status:u}=i,{method:l,baseURL:m,url:p}=s;return n&&Cr({status:u,url:`${m}${p}`,params:s.params,data:c,logCount:this.logCount}),Mo.debug(`${l==null?void 0:l.toUpperCase()} ${m}${p}  ${u}`),c},i=>{let{config:s,response:c={}}=i,{status:u}=c,{method:l,baseURL:m,url:p}=s;return n&&Cr({status:u,url:`${m}${p}`,params:s.params,data:i.message,logCount:this.logCount}),Mo.error(`${l.toUpperCase()} ${m}${p} ${u||i.message}`),Promise.reject(i)})}async getClmmConfigs(){return(await this.api.get(this.urlConfigs.CLMM_CONFIG||mt.CLMM_CONFIG)).data}async getCpmmConfigs(){return(await this.api.get(this.urlConfigs.CPMM_CONFIG||mt.CPMM_CONFIG)).data}async getClmmPoolLines(e){return(await this.api.get(`${this.urlConfigs.POOL_LIQUIDITY_LINE||mt.POOL_LIQUIDITY_LINE}?pool_id=${e}`)).data}async getBlockSlotCountForSecond(e){if(!e)return 2;let n=(await fc.post(e,{id:"getRecentPerformanceSamples",jsonrpc:"2.0",method:"getRecentPerformanceSamples",params:[4]})).result.map(o=>o.numSlots);return n.reduce((o,r)=>o+r,0)/n.length/60}async getChainTimeOffset(){return(await this.api.get(this.urlConfigs.CHAIN_TIME||mt.CHAIN_TIME)).data}async getRpcs(){return this.api.get(this.urlConfigs.RPCS||mt.RPCS)}async getTokenList(){return(await this.api.get(this.urlConfigs.TOKEN_LIST||mt.TOKEN_LIST)).data}async getJupTokenList(){return(await this.api.get("",{baseURL:this.urlConfigs.JUP_TOKEN_LIST||mt.JUP_TOKEN_LIST})).map(t=>q(M({},t),{chainId:101,programId:t.tags.includes("token-2022")?wd.toBase58():Td.toBase58()}))}async getTokenInfo(e){return(await this.api.get((this.urlConfigs.MINT_INFO_ID||mt.MINT_INFO_ID)+`?mints=${e.map(n=>n.toString()).join(",")}`)).data}async getPoolList(e={}){let{type:t="all",sort:n="liquidity",order:o="desc",page:r=0,pageSize:i=100}=e;return(await this.api.get((this.urlConfigs.POOL_LIST||mt.POOL_LIST)+`?poolType=${t}&poolSortField=${n}&sortType=${o}&page=${r}&pageSize=${i}`)).data}async fetchPoolById(e){let{ids:t}=e;return(await this.api.get((this.urlConfigs.POOL_SEARCH_BY_ID||mt.POOL_SEARCH_BY_ID)+`?ids=${t}`)).data}async fetchPoolKeysById(e){let{idList:t}=e,n=[],o=t.filter(i=>js.has(i)?(n.push(js.get(i)),!1):!0),r=[];return o.length&&(r=(await this.api.get((this.urlConfigs.POOL_KEY_BY_ID||mt.POOL_KEY_BY_ID)+`?ids=${o.join(",")}`)).data.filter(Boolean),r.forEach(s=>{js.set(s.id,s)})),n.concat(r)}async fetchPoolByMints(e){let{mint1:t,mint2:n,type:o="all",sort:r="default",order:i="desc",page:s=1}=e,[c,u]=[t&&bt(t).toBase58(),n&&n!=="undefined"?bt(n).toBase58():""],[l,m]=u&&c>u?[u,c]:[c,u];return(await this.api.get((this.urlConfigs.POOL_SEARCH_MINT||mt.POOL_SEARCH_MINT)+`?mint1=${l}&mint2=${m}&poolType=${o}&poolSortField=${r}&sortType=${i}&pageSize=100&page=${s}`)).data}async fetchFarmInfoById(e){let{ids:t}=e;return(await this.api.get((this.urlConfigs.FARM_INFO||mt.FARM_INFO)+`?ids=${t}`)).data}async fetchFarmKeysById(e){let{ids:t}=e;return(await this.api.get((this.urlConfigs.FARM_KEYS||mt.FARM_KEYS)+`?ids=${t}`)).data}async fetchAvailabilityStatus(){return(await this.api.get(this.urlConfigs.CHECK_AVAILABILITY||mt.CHECK_AVAILABILITY)).data}};import{merge as Oy}from"lodash";var Lr="please provide owner in load() initialization or you can set by calling raydium.setOwner(owner)",yc="please provide connection in load() initialization or set it by raydium.setConnection(connection)";import{PublicKey as Vr,SystemProgram as Op}from"@solana/web3.js";import{AccountLayout as Vo,createAssociatedTokenAccountIdempotentInstruction as la,TOKEN_PROGRAM_ID as Xn,TOKEN_2022_PROGRAM_ID as Np}from"@solana/spl-token";var $s=(...a)=>a.map(e=>{try{return typeof e=="object"?JSON.stringify(e):e}catch{return e}}).join(", "),We=class{constructor({scope:e,moduleName:t}){this.disabled=!1;this.scope=e,this.logger=be(t)}createTxBuilder(e){return this.scope.checkOwner(),new bi({connection:this.scope.connection,feePayer:e||this.scope.ownerPubKey,cluster:this.scope.cluster,owner:this.scope.owner,blockhashCommitment:this.scope.blockhashCommitment,loopMultiTxStatus:this.scope.loopMultiTxStatus,api:this.scope.api,signAllTransactions:this.scope.signAllTransactions})}createSniperTxBuilder(e,t){let n=new _t(e);return new bi({connection:this.scope.connection,feePayer:t,cluster:this.scope.cluster,owner:n,blockhashCommitment:this.scope.blockhashCommitment,loopMultiTxStatus:this.scope.loopMultiTxStatus,api:this.scope.api,signAllTransactions:this.scope.signAllTransactions})}logDebug(...e){this.logger.debug($s(e))}logInfo(...e){this.logger.info($s(e))}logAndCreateError(...e){let t=$s(e);throw new Error(t)}checkDisabled(){(this.disabled||!this.scope)&&this.logAndCreateError("module not working")}};import{PublicKey as xp,SystemProgram as Kp}from"@solana/web3.js";import Sp from"bn.js";import{createCloseAccountInstruction as Cp,createInitializeAccountInstruction as Rp,createTransferInstruction as Lp,TOKEN_PROGRAM_ID as Fo}from"@solana/spl-token";import{Keypair as Tp,PublicKey as Oc}from"@solana/web3.js";import hp from"bn.js";import{TOKEN_PROGRAM_ID as Ip}from"@solana/spl-token";function hd(a){return a instanceof Uint8Array||a!=null&&typeof a=="object"&&a.constructor.name==="Uint8Array"}function Zs(a,...e){if(!hd(a))throw new Error("Uint8Array expected");if(e.length>0&&!e.includes(a.length))throw new Error(`Uint8Array expected of length ${e}, not of length=${a.length}`)}function Js(a,e=!0){if(a.destroyed)throw new Error("Hash instance has been destroyed");if(e&&a.finished)throw new Error("Hash#digest() has already been called")}function bc(a,e){Zs(a);let t=e.outputLen;if(a.length<t)throw new Error(`digestInto() expects output buffer of length at least ${t}`)}var Nr=a=>new DataView(a.buffer,a.byteOffset,a.byteLength),rn=(a,e)=>a<<32-e|a>>>e;var YA=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;function Id(a){if(typeof a!="string")throw new Error(`utf8ToBytes expected string, got ${typeof a}`);return new Uint8Array(new TextEncoder().encode(a))}function ea(a){return typeof a=="string"&&(a=Id(a)),Zs(a),a}var Or=class{clone(){return this._cloneInto()}},QA={}.toString;function gc(a){let e=n=>a().update(ea(n)).digest(),t=a();return e.outputLen=t.outputLen,e.blockLen=t.blockLen,e.create=()=>a(),e}function Bd(a,e,t,n){if(typeof a.setBigUint64=="function")return a.setBigUint64(e,t,n);let o=BigInt(32),r=BigInt(4294967295),i=Number(t>>o&r),s=Number(t&r),c=n?4:0,u=n?0:4;a.setUint32(e+c,i,n),a.setUint32(e+u,s,n)}var Pc=(a,e,t)=>a&e^~a&t,Ac=(a,e,t)=>a&e^a&t^e&t,Mr=class extends Or{constructor(e,t,n,o){super(),this.blockLen=e,this.outputLen=t,this.padOffset=n,this.isLE=o,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(e),this.view=Nr(this.buffer)}update(e){Js(this);let{view:t,buffer:n,blockLen:o}=this;e=ea(e);let r=e.length;for(let i=0;i<r;){let s=Math.min(o-this.pos,r-i);if(s===o){let c=Nr(e);for(;o<=r-i;i+=o)this.process(c,i);continue}n.set(e.subarray(i,i+s),this.pos),this.pos+=s,i+=s,this.pos===o&&(this.process(t,0),this.pos=0)}return this.length+=e.length,this.roundClean(),this}digestInto(e){Js(this),bc(e,this),this.finished=!0;let{buffer:t,view:n,blockLen:o,isLE:r}=this,{pos:i}=this;t[i++]=128,this.buffer.subarray(i).fill(0),this.padOffset>o-i&&(this.process(n,0),i=0);for(let m=i;m<o;m++)t[m]=0;Bd(n,o-8,BigInt(this.length*8),r),this.process(n,0);let s=Nr(e),c=this.outputLen;if(c%4)throw new Error("_sha2: outputLen should be aligned to 32bit");let u=c/4,l=this.get();if(u>l.length)throw new Error("_sha2: outputLen bigger than state");for(let m=0;m<u;m++)s.setUint32(4*m,l[m],r)}digest(){let{buffer:e,outputLen:t}=this;this.digestInto(e);let n=e.slice(0,t);return this.destroy(),n}_cloneInto(e){e||(e=new this.constructor),e.set(...this.get());let{blockLen:t,buffer:n,length:o,finished:r,destroyed:i,pos:s}=this;return e.length=o,e.pos=s,e.finished=r,e.destroyed=i,o%t&&e.buffer.set(n),e}};var xd=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),qn=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),Un=new Uint32Array(64),ta=class extends Mr{constructor(){super(64,32,8,!1),this.A=qn[0]|0,this.B=qn[1]|0,this.C=qn[2]|0,this.D=qn[3]|0,this.E=qn[4]|0,this.F=qn[5]|0,this.G=qn[6]|0,this.H=qn[7]|0}get(){let{A:e,B:t,C:n,D:o,E:r,F:i,G:s,H:c}=this;return[e,t,n,o,r,i,s,c]}set(e,t,n,o,r,i,s,c){this.A=e|0,this.B=t|0,this.C=n|0,this.D=o|0,this.E=r|0,this.F=i|0,this.G=s|0,this.H=c|0}process(e,t){for(let m=0;m<16;m++,t+=4)Un[m]=e.getUint32(t,!1);for(let m=16;m<64;m++){let p=Un[m-15],d=Un[m-2],f=rn(p,7)^rn(p,18)^p>>>3,y=rn(d,17)^rn(d,19)^d>>>10;Un[m]=y+Un[m-7]+f+Un[m-16]|0}let{A:n,B:o,C:r,D:i,E:s,F:c,G:u,H:l}=this;for(let m=0;m<64;m++){let p=rn(s,6)^rn(s,11)^rn(s,25),d=l+p+Pc(s,c,u)+xd[m]+Un[m]|0,y=(rn(n,2)^rn(n,13)^rn(n,22))+Ac(n,o,r)|0;l=u,u=c,c=s,s=i+d|0,i=r,r=o,o=n,n=d+y|0}n=n+this.A|0,o=o+this.B|0,r=r+this.C|0,i=i+this.D|0,s=s+this.E|0,c=c+this.F|0,u=u+this.G|0,l=l+this.H|0,this.set(n,o,r,i,s,c,u,l)}roundClean(){Un.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}};var kc=gc(()=>new ta);import{PublicKey as Pp}from"@solana/web3.js";import Kc,{isBN as Sc}from"bn.js";import{bits as Kd,BitStructure as Sd,blob as Cd,Blob as Rd,cstr as Ld,f32 as Od,f32be as Nd,f64 as Md,f64be as vd,greedy as Fd,Layout as Vd,ns64 as _d,ns64be as Ed,nu64 as Wd,nu64be as Dd,offset as qd,s16 as Ud,s16be as Gd,s24 as Xd,s24be as zd,s32 as Yd,s32be as Qd,s40 as Hd,s40be as jd,s48 as $d,s48be as Zd,s8 as Jd,seq as ep,struct as ok,Structure as tp,u16 as np,u16be as op,u24 as ip,u24be as rp,u32 as sp,u32be as ap,u40 as up,u40be as cp,u48 as lp,u48be as mp,u8 as dp,UInt as pp,union as fp,Union as yp,unionLayoutDiscriminator as bp,utf8 as gp}from"@solana/buffer-layout";var gi=Vd,wc=tp,Tc=yp,ik=Sd,na=pp,hc=Rd,rk=Fd,vr=dp,Et=np,sk=ip,Pi=sp,ak=up,uk=lp,Ic=Wd,ck=op,lk=rp,mk=ap,dk=cp,pk=mp,fk=Dd,yk=Jd,bk=Ud,gk=Xd,De=Yd,Pk=Hd,Ak=$d,kk=_d,wk=Gd,Tk=zd,hk=Qd,Ik=jd,Bk=Zd,xk=Ed,Kk=Od,Sk=Nd,Ck=Md,Rk=vd;var Bc=ep,xc=fp,Lk=bp,Be=Cd,Ok=Ld,Nk=gp,oa=Kd,ia=qd;var uo=class extends gi{constructor(t,n,o){super(t,o);this.blob=Be(t),this.signed=n}decode(t,n=0){let o=new Kc(this.blob.decode(t,n),10,"le");return this.signed?o.fromTwos(this.span*8).clone():o}encode(t,n,o=0){return typeof t=="number"&&(t=new Kc(t)),this.signed&&(t=t.toTwos(this.span*8)),this.blob.encode(t.toArrayLike(Buffer,"le",this.span),n,o)}},Fr=class extends gi{constructor(t){super(8,t);this._lower=oa(Pi(),!1),this._upper=oa(Pi(),!1)}addBoolean(t){this._lower.fields.length<32?this._lower.addBoolean(t):this._upper.addBoolean(t)}decode(t,n=0){let o=this._lower.decode(t,n),r=this._upper.decode(t,n+this._lower.span);return M(M({},o),r)}encode(t,n,o=0){return this._lower.encode(t,n,o)+this._upper.encode(t,n,o+this._lower.span)}};function _(a){return new na(1,a)}function pt(a){return new na(4,a)}function A(a){return new uo(8,!1,a)}function ne(a){return new uo(16,!1,a)}function Cc(a){return new uo(1,!0,a)}function vo(a){return new uo(8,!0,a)}function Rc(a){return new uo(16,!0,a)}var hn=class extends gi{constructor(t,n,o,r){super(t.span,r);this.layout=t,this.decoder=n,this.encoder=o}decode(t,n){return this.decoder(this.layout.decode(t,n))}encode(t,n,o){return this.layout.encode(this.encoder(t),n,o)}getSpan(t,n){return this.layout.getSpan(t,n)}};function O(a){return new hn(Be(32),e=>new Pp(e),e=>e.toBuffer(),a)}var ra=class extends gi{constructor(t,n){super(-1,n);this.layout=t,this.discriminator=vr()}encode(t,n,o=0){return t==null?this.discriminator.encode(0,n,o):(this.discriminator.encode(1,n,o),this.layout.encode(t,n,o+1)+1)}decode(t,n=0){let o=this.discriminator.decode(t,n);if(o===0)return null;if(o===1)return this.layout.decode(t,n+1);throw new Error("Invalid option "+this.property)}getSpan(t,n=0){let o=this.discriminator.decode(t,n);if(o===0)return 1;if(o===1)return this.layout.getSpan(t,n+1)+1;throw new Error("Invalid option "+this.property)}};function _k(a,e){return new ra(a,e)}function qe(a){return new hn(vr(),Ap,kp,a)}function Ap(a){if(a===0)return!1;if(a===1)return!0;throw new Error("Invalid bool: "+a)}function kp(a){return a?1:0}function Lc(a,e){let t=Pi("length"),n=F([t,Y(a,ia(t,-t.span),"values")]);return new hn(n,({values:o})=>o,o=>({values:o}),e)}function Ek(a,e,t){let n=F([A("tag"),e.replicate("data")]);function o({tag:r,data:i}){if(!r.eq(a))throw new Error("Invalid tag, expected: "+a.toString("hex")+", got: "+r.toString("hex"));return i}return new hn(n,o,r=>({tag:a,data:r}),t)}function wp(a){let e=Pi("length"),t=F([e,Be(ia(e,-e.span),"data")]);return new hn(t,({data:n})=>n,n=>({data:n}),a)}function ft(a){return new hn(wp(),e=>e.toString("utf-8"),e=>Buffer.from(e,"utf-8"),a)}function Wk(a,e){let t=xc(vr(),e);return a.forEach((n,o)=>t.addVariant(o,n,n.property)),t}function Dk(a,e,t){let n=F([Y(a,e,"values")]);return new hn(n,({values:o})=>o,o=>({values:o}),t)}var sa=class extends wc{decode(e,t){return super.decode(e,t)}};function F(a,e,t){return new sa(a,e,t)}var aa=class extends Tc{encodeInstruction(e){let t=Math.max(...Object.values(this.registry).map(o=>o.span)),n=Buffer.alloc(t);return n.slice(0,this.encode(e,n))}decodeInstruction(e){return this.decode(e)}};function qk(a,e,t){return new aa(a,e,t)}var ua=class extends hc{decode(e,t){let n=super.decode(e,t);if(!n.every(o=>o===0))throw new Error("nonzero padding bytes");return n}};function Uk(a){return new ua(a)}function Y(a,e,t){let n,o=typeof e=="number"?e:Sc(e)?e.toNumber():new Proxy(e,{get(r,i){if(!n){let s=Reflect.get(r,"count");n=Sc(s)?s.toNumber():s,Reflect.set(r,"count",n)}return Reflect.get(r,i)},set(r,i,s){return i==="count"&&(n=s),Reflect.set(r,i,s)}});return Bc(a,o,t)}var sn=F([O("mint"),O("owner"),A("amount"),pt("delegateOption"),O("delegate"),_("state"),pt("isNativeOption"),A("isNative"),A("delegatedAmount"),pt("closeAuthorityOption"),O("closeAuthority")]);var ow=be("Raydium_Util");function Nc({owner:a,solAccountResp:e,tokenAccountResp:t}){let n=[],o=[];for(let{pubkey:r,account:i}of t.value){let s=sn.decode(i.data),{mint:c,amount:u}=s;n.push({publicKey:r,mint:c,amount:u,isAssociated:j(a,c,i.owner).publicKey.equals(r),isNative:!1,programId:i.owner}),o.push({pubkey:r,accountInfo:s,programId:i.owner})}return e&&n.push({mint:Oc.default,amount:new hp(String(e.lamports)),isNative:!0,programId:e.owner}),{tokenAccounts:n,tokenAccountRawInfos:o}}function je({fromPublicKey:a,programId:e=Ip,assignSeed:t}){let n=t?btoa(t).slice(0,32):Tp.generate().publicKey.toBase58().slice(0,32);return{publicKey:Bp(a,n,e),seed:n}}function Bp(a,e,t){let n=Buffer.concat([a.toBuffer(),Buffer.from(e),t.toBuffer()]),o=kc(n);return new Oc(o)}function ca(a){let{mint:e,tokenAccount:t,owner:n,programId:o=Fo}=a;return Rp(t,e,n,o)}function In(a){let{tokenAccount:e,payer:t,multiSigners:n=[],owner:o,programId:r=Fo}=a;return Cp(e,t,o,n,r)}async function Gn(a){let{connection:e,amount:t,commitment:n,payer:o,owner:r,skipCloseAccount:i}=a,s=await e.getMinimumBalanceForRentExemption(sn.span,n),c=J(t).add(new Sp(s)),u=je({fromPublicKey:o,programId:Fo});return{addresses:{newAccount:u.publicKey},signers:[],instructions:[Kp.createAccountWithSeed({fromPubkey:o,basePubkey:o,seed:u.seed,newAccountPubkey:u.publicKey,lamports:c.toNumber(),space:sn.span,programId:Fo}),ca({mint:new xp(ut.address),tokenAccount:u.publicKey,owner:r,programId:Fo})],instructionTypes:[G.CreateAccount,G.InitAccount],endInstructionTypes:i?[]:[G.CloseAccount],endInstructions:i?[]:[In({tokenAccount:u.publicKey,payer:o,owner:r})]}}function Mc({source:a,destination:e,owner:t,amount:n,multiSigners:o=[],tokenProgram:r=Fo}){return Lp(a,e,t,BigInt(String(n)),o,r)}var Ai=class extends We{constructor(t){super(t);this._tokenAccounts=[];this._tokenAccountRawInfos=[];this._accountListener=[];this._clientOwnedToken=!1;this._notSubscribeAccountChange=!1;this._accountFetchTime=0;let{tokenAccounts:n,tokenAccountRawInfos:o,notSubscribeAccountChange:r}=t;this._tokenAccounts=n||[],this._tokenAccountRawInfos=o||[],this._notSubscribeAccountChange=r!=null?r:!0,this._clientOwnedToken=!!(n||o)}get tokenAccounts(){return this._tokenAccounts}get tokenAccountRawInfos(){return this._tokenAccountRawInfos}set notSubscribeAccountChange(t){this._notSubscribeAccountChange=t}updateTokenAccount({tokenAccounts:t,tokenAccountRawInfos:n}){return t&&(this._tokenAccounts=t),n&&(this._tokenAccountRawInfos=n),this._accountChangeListenerId&&this.scope.connection.removeAccountChangeListener(this._accountChangeListenerId),this._accountChangeListenerId=void 0,this._clientOwnedToken=!0,this}addAccountChangeListener(t){return this._accountListener.push(t),this}removeAccountChangeListener(t){return this._accountListener=this._accountListener.filter(n=>n!==t),this}getAssociatedTokenAccount(t,n){return j(this.scope.ownerPubKey,t,n).publicKey}getAssociatedTokenAccountByOwner(t,n,o){return j(t,n,o).publicKey}resetTokenAccounts(){this._clientOwnedToken||(this._tokenAccounts=[],this._tokenAccountRawInfos=[])}async fetchWalletTokenAccounts(t){if(this._clientOwnedToken||!(t!=null&&t.forceUpdate)&&this._tokenAccounts.length&&Date.now()-this._accountFetchTime<(this._notSubscribeAccountChange?1e3*5:1e3*60*3))return{tokenAccounts:this._tokenAccounts,tokenAccountRawInfos:this._tokenAccountRawInfos};this.scope.checkOwner();let o=M(M({},{}),t),[r,i,s]=await Promise.all([this.scope.connection.getAccountInfo(this.scope.ownerPubKey,o.commitment),this.scope.connection.getTokenAccountsByOwner(this.scope.ownerPubKey,{programId:Xn},o.commitment),this.scope.connection.getTokenAccountsByOwner(this.scope.ownerPubKey,{programId:Np},o.commitment)]),{tokenAccounts:c,tokenAccountRawInfos:u}=Nc({owner:this.scope.ownerPubKey,solAccountResp:r,tokenAccountResp:{context:i.context,value:[...i.value,...s.value]}});return this._tokenAccounts=c,this._tokenAccountRawInfos=u,this._accountFetchTime=Date.now(),this._notSubscribeAccountChange||(this._accountChangeListenerId&&this.scope.connection.removeAccountChangeListener(this._accountChangeListenerId),this._accountChangeListenerId=this.scope.connection.onAccountChange(this.scope.ownerPubKey,()=>{this.fetchWalletTokenAccounts({forceUpdate:!0}),this._accountListener.forEach(l=>l({tokenAccounts:this._tokenAccounts,tokenAccountRawInfos:this._tokenAccountRawInfos}))},{commitment:t==null?void 0:t.commitment})),{tokenAccounts:c,tokenAccountRawInfos:u}}clearAccountChangeCkb(){this._accountChangeListenerId!==void 0&&this.scope.connection.removeAccountChangeListener(this._accountChangeListenerId)}async getCreatedTokenAccount({mint:t,programId:n=Xn,associatedOnly:o=!0}){await this.fetchWalletTokenAccounts();let r=this._tokenAccounts.filter(({mint:s})=>s==null?void 0:s.equals(t)).sort((s,c)=>s.amount.lt(c.amount)?1:-1),i=this.getAssociatedTokenAccount(t,n);for(let s of r){let{publicKey:c}=s;if(c&&(!o||o&&i.equals(c)))return c}}async getOrCreateTokenAccount(t){var y,b,g,P;await this.fetchWalletTokenAccounts();let{mint:n,createInfo:o,associatedOnly:r,owner:i,notUseTokenAccount:s=!1,skipCloseAccount:c=!1,checkCreateATAOwner:u=!1,assignSeed:l}=t;console.log("******************associatedOnly: ",r);let m=new Vr(t.tokenProgram||Xn),p=this.getAssociatedTokenAccount(n,new Vr(m)),d=(s?[]:this.tokenAccountRawInfos).filter(h=>h.accountInfo.mint.equals(n)&&(!r||h.pubkey.equals(p))).sort((h,I)=>h.accountInfo.amount.lt(I.accountInfo.amount)?1:-1);if(o===void 0||d.length>0)return d.length>0?{account:d[0].pubkey}:{};let f={instructions:[],endInstructions:[],signers:[],instructionTypes:[],endInstructionTypes:[]};if(r){let h=la(i,p,i,n,m),I=this.tokenAccountRawInfos.find(T=>T.pubkey.equals(p));if(u){console.log("******************checkCreateATAOwner: ",u);let T=await this.scope.connection.getAccountInfo(p);if(T===null)console.log("******************ataInfo == null: ",u),(y=f.instructions)==null||y.push(h),f.instructionTypes.push(G.CreateATA);else if(T.owner.equals(m)&&Vo.decode(T.data).mint.equals(n)&&Vo.decode(T.data).owner.equals(i))console.log("******************else empty: ");else throw Error(`create ata check error -> mint: ${n.toString()}, ata: ${p.toString()}`)}else I===void 0&&(console.log("******************_ataInTokenAcc undefined"),f.instructions.push(h),f.instructionTypes.push(G.CreateATA));if(n.equals($)&&o.amount){console.log("createWSolAccountInstructions*********************************");let T=await Gn({connection:this.scope.connection,owner:i||this.scope.ownerPubKey,payer:o.payer||this.scope.ownerPubKey,amount:(b=o.amount)!=null?b:0,skipCloseAccount:c});f.instructions.push(...T.instructions||[]),f.endInstructions.push(...T.endInstructions||[]),f.instructionTypes.push(...T.instructionTypes||[]),f.endInstructionTypes.push(...T.endInstructionTypes||[]),o.amount&&(console.log("******************createInfo.amount"),f.instructions.push(Mc({source:T.addresses.newAccount,destination:p,owner:i||this.scope.ownerPubKey,amount:o.amount,tokenProgram:Xn})),f.instructionTypes.push(G.TransferAmount))}return!c&&I===void 0&&(console.log("******************skipCloseAccount"),f.endInstructions.push(In({owner:i,payer:o.payer||i,tokenAccount:p,programId:m})),f.endInstructionTypes.push(G.CloseAccount)),{account:p,instructionParams:f}}else{console.log("******************newTokenAccount");let h=je({fromPublicKey:i,programId:m,assignSeed:l}),I=await this.scope.connection.getMinimumBalanceForRentExemption(Vo.span),T=Op.createAccountWithSeed({fromPubkey:i,basePubkey:i,seed:h.seed,newAccountPubkey:h.publicKey,lamports:I+Number((P=(g=o.amount)==null?void 0:g.toString())!=null?P:0),space:Vo.span,programId:m});return f.instructions.push(T,ca({mint:n,tokenAccount:h.publicKey,owner:i||this.scope.ownerPubKey,programId:m})),f.instructionTypes.push(G.CreateAccount),f.instructionTypes.push(G.InitAccount),c||(f.endInstructions.push(In({owner:i,payer:o.payer||i,tokenAccount:h.publicKey,programId:m})),f.endInstructionTypes.push(G.CloseAccount)),{account:h.publicKey,instructionParams:f}}}async checkOrCreateAta({mint:t,programId:n=Xn,autoUnwrapWSOLToSOL:o}){var c;await this.fetchWalletTokenAccounts();let r=(c=this.scope.account.tokenAccounts.find(({mint:u})=>(u==null?void 0:u.toBase58())===t.toBase58()))==null?void 0:c.publicKey,i=this.scope.ownerPubKey,s={};if(!r){let u=this.getAssociatedTokenAccount(t,n),l=await la(i,u,i,t,n);s.instructions=[l],s.instructionTypes=[G.CreateATA],r=u}return o&&$.toBase58()===t.toBase58()&&(s.endInstructions=[In({owner:i,payer:i,tokenAccount:r,programId:n})],s.endInstructionTypes=[G.CloseAccount]),{pubKey:r,newInstructions:s}}async handleTokenAccount(t){let{side:n,amount:o,mint:r,programId:i=Xn,tokenAccount:s,payer:c=this.scope.ownerPubKey,bypassAssociatedCheck:u,skipCloseAccount:l,checkCreateATAOwner:m}=t,p=this.getAssociatedTokenAccount(r,i);if(new Vr($).equals(r)){let d=await Gn({connection:this.scope.connection,owner:this.scope.ownerPubKey,payer:c,amount:o,skipCloseAccount:l});return M({tokenAccount:d.addresses.newAccount},d)}else if(!s||n==="out"&&!p.equals(s)&&!u){let d=[],f=la(this.scope.ownerPubKey,p,this.scope.ownerPubKey,r,i);if(m){let y=await this.scope.connection.getAccountInfo(p);if(y===null)d.push(f);else if(!(y.owner.equals(Xn)&&Vo.decode(y.data).mint.equals(r)&&Vo.decode(y.data).owner.equals(this.scope.ownerPubKey)))throw Error(`create ata check error -> mint: ${r.toString()}, ata: ${p.toString()}`)}else d.push(f);return{tokenAccount:p,instructions:d,instructionTypes:[G.CreateATA]}}return{tokenAccount:s}}async processTokenAccount(t){let{mint:n,programId:o=Xn,amount:r,useSOLBalance:i,handleTokenAccount:s,feePayer:c}=t,u,l=this.createTxBuilder(c);if(n.equals(new Vr($))&&i){let m=await this.handleTokenAccount({side:"in",amount:r||0,mint:n,bypassAssociatedCheck:!0,programId:o}),{tokenAccount:d}=m,f=_e(m,["tokenAccount"]);u=d,l.addInstruction(f)}else if(u=await this.getCreatedTokenAccount({mint:n,associatedOnly:!1,programId:o}),!u&&s){let p=await this.scope.account.handleTokenAccount({side:"in",amount:0,mint:n,bypassAssociatedCheck:!0,programId:o}),{tokenAccount:d}=p,f=_e(p,["tokenAccount"]);u=d,l.addInstruction(f)}return M({tokenAccount:u},l.AllTxData)}};import{PublicKey as Se,SystemProgram as tf}from"@solana/web3.js";import{createAssociatedTokenAccountIdempotentInstruction as Jc}from"@solana/spl-token";import nf from"decimal.js";import{PublicKey as ba}from"@solana/web3.js";var ma=F([_("instruction")]),da=F([_("instruction")]),Mp=F([A("rewardState"),A("rewardOpenTime"),A("rewardEndTime"),A("rewardLastUpdateTime"),A("totalReward"),A("totalRewardEmissioned"),A("rewardClaimed"),A("rewardPerSecond"),ne("accRewardPerShare"),O("rewardVault"),O("rewardMint"),O("rewardSender"),A("rewardType"),Y(A(),15,"padding")]),vp=F([A("state"),A("nonce"),O("lpVault"),O("rewardVault"),O(),O(),A(),A(),A("totalReward"),ne("perShareReward"),A("lastSlot"),A("perSlotReward")]),Fp=F([A("state"),A("nonce"),O("lpVault"),O("rewardVaultA"),A("totalRewardA"),ne("perShareRewardA"),A("perSlotRewardA"),_("option"),O("rewardVaultB"),Be(7),A("totalRewardB"),ne("perShareRewardB"),A("perSlotRewardB"),A("lastSlot"),O()]),Vp=F([A(),A("state"),A("nonce"),A("validRewardTokenNum"),ne("rewardMultiplier"),A("rewardPeriodMax"),A("rewardPeriodMin"),A("rewardPeriodExtend"),O("lpMint"),O("lpVault"),Y(Mp,5,"rewardInfos"),O("creator"),O(),Y(A(),32,"padding")]),vc=new Proxy(vp,{get(a,e,t){return e==="decode"?(...n)=>{let o=a.decode(...n);return q(M({},o),{version:3,rewardInfos:[{rewardVault:o.rewardVault,totalReward:o.totalReward,perSlotReward:o.perSlotReward,perShareReward:o.perShareReward}]})}:Reflect.get(a,e,t)}}),Fc=new Proxy(Fp,{get(a,e,t){return e==="decode"?(...n)=>{let o=a.decode(...n);return q(M({},o),{version:5,rewardInfos:[{rewardVault:o.rewardVaultA,totalReward:o.totalRewardA,perSlotReward:o.perSlotRewardA,perShareReward:o.perShareRewardA},{rewardVault:o.rewardVaultB,totalReward:o.totalRewardB,perSlotReward:o.perSlotRewardB,perShareReward:o.perShareRewardB}]})}:Reflect.get(a,e,t)}}),ki=new Proxy(Vp,{get(a,e,t){return e==="decode"?(...n)=>{let o=a.decode(...n);return q(M({},o),{version:6,rewardInfos:o.rewardInfos.map(r=>{var i;return q(M({},r),{rewardType:((i=Object.entries(zn).find(s=>String(s[1])===r.rewardType.toString()))!=null?i:["Standard SPL"])[0]})})})}:Reflect.get(a,e,t)}}),_p=F([A("isSet"),A("rewardPerSecond"),A("rewardOpenTime"),A("rewardEndTime"),A("rewardType")]),pa=F([_("instruction"),A("nonce"),Y(_p,5,"rewardTimeInfo")]),fa=F([_("instruction"),A("rewardReopenTime"),A("rewardEndTime"),A("rewardPerSecond")]),ya=F([_("instruction"),A("isSet"),A("rewardPerSecond"),A("rewardOpenTime"),A("rewardEndTime"),A("rewardType")]),vw=F([A("state"),O("id"),O("owner"),A("deposited"),Y(A(),1,"rewardDebts")]),wi=F([A("state"),O("id"),O("owner"),A("deposited"),Y(ne(),1,"rewardDebts"),A(""),A("voteLockedBalance"),Y(A(),15)]),Fw=F([A("state"),O("id"),O("owner"),A("deposited"),Y(A(),2,"rewardDebts")]),Vc=F([A("state"),O("id"),O("owner"),A("deposited"),Y(ne(),2,"rewardDebts"),Y(A(),17)]),_c=F([A(),A("state"),O("id"),O("owner"),A("deposited"),Y(ne(),5,"rewardDebts"),Y(A(),16)]),Bt=F([_("instruction"),A("amount")]),Ep=F([O("mint"),O("grantAuthority"),A("baselineVoteWeightScaledFactor"),A("maxExtraLockupVoteWeightScaledFactor"),A("lockupSaturationSecs"),Cc("digitShift"),Y(_(),7,"reserved1"),Y(A(),7,"reserved2")]),Ec=F([Be(8),O("governanceProgramId"),O("realm"),O("realmGoverningTokenMint"),O("realmAuthority"),Y(_(),32,"reserved1"),Y(Ep,4,"votingMints"),vo("timeOffset"),_("bump"),Y(_(),7,"reserved2"),Y(A(),11,"reserved3")]),Wp=F([vo("startTime"),vo("endTime"),_("kind"),Y(_(),15,"reserved")]),Dp=F([Y(Wp,1,"lockup"),A("amountDeposited_native"),A("amountInitiallyLockedNative"),qe("isUsed"),qe("allowClawback"),_("votingMintConfigIdx"),Y(_(),29,"reserved")]),Wc=F([Be(8),O("voterAuthority"),O("registrar"),Y(Dp,32,"deposits"),_("voterBump"),_("voterWweightRecordBump"),Y(_(),94,"reserved")]);import{NATIVE_MINT as qp}from"@solana/spl-token";var Xw=be("Raydium_farm_config"),Dc=new ba("4k3Dyjzvzp8eMZWUXbBCjEvwSkkk59S5iCNLY3QrkX6R"),qc=new ba("FrspKwj8i3pNmKwXreTveC4fu7KL5ZbGeXdZBe2XViu1"),zw=qp,Yw=new ba("3TRTX4dXUpp2eqxi3tvQDFYUV7SdDJjcPE3Y4mbtftaX"),Uc={3:vc,5:Fc,6:ki},Gc={3:wi,5:Vc,6:_c},ga=a=>[3,4,5,6].indexOf(a)!==-1,Pa=a=>{var i;let{version:e,rewardInfos:t,rewardTokenAccountsPublicKeys:n}=a,o=`rewardInfo:${JSON.stringify(t)}, rewardAccount:${JSON.stringify(n)}`,r={3:()=>{if(t.length!==1||n.length!==1)return`rewardInfos or rewardTokenAccounts lengths not equal 1: ${o}`},5:()=>{if(t.length!==n.length)return`rewardInfos and rewardTokenAccounts lengths not equal: ${o}`},6:()=>{if(!n.length||t.length!==n.length)return`no rewardTokenAccounts or rewardInfos and rewardTokenAccounts lengths not equal: ${o}`}};return(i=r[e])==null?void 0:i.call(r)},zn={"Standard SPL":0,"Option tokens":1},Xt={[_s.toString()]:3,[Es.toString()]:4,[Ws.toString()]:5,[Ro.toString()]:6,[kn.FARM_PROGRAM_ID_V3.toString()]:3,[kn.FARM_PROGRAM_ID_V4.toString()]:4,[kn.FARM_PROGRAM_ID_V5.toString()]:5,[kn.FARM_PROGRAM_ID_V6.toString()]:6};import{PublicKey as ce,SystemProgram as co,SYSVAR_CLOCK_PUBKEY as Eo,SYSVAR_RENT_PUBKEY as Xp,TransactionInstruction as rt}from"@solana/web3.js";import _r from"bn.js";import{ASSOCIATED_TOKEN_PROGRAM_ID as zp,createAssociatedTokenAccountIdempotentInstruction as Yp,TOKEN_PROGRAM_ID as Ot}from"@solana/spl-token";function Aa(a,e,t){return te([e.toBuffer(),Buffer.from("registrar","utf8"),t.toBuffer()],a)}function ka(a,e){return te([e.toBuffer(),Buffer.from("voting_mint_seed","utf8")],a)}function wa(a,e){return te([e.toBuffer()],a)}function Ta(a,e,t){return te([e.toBuffer(),Buffer.from("voter","utf8"),t.toBuffer()],a)}function ha(a,e,t){return te([e.toBuffer(),Buffer.from("voter-weight-record","utf8"),t.toBuffer()],a)}function Ia(a,e,t,n){return te([Buffer.from("governance","utf8"),e.toBuffer(),t.toBuffer(),n.toBuffer()],a)}import Lt from"bn.js";var Ti=be("Raydium.farm.util");function hi({programId:a,poolId:e,mint:t,type:n}){let{publicKey:o}=te([e.toBuffer(),t.toBuffer(),Buffer.from(n==="lpVault"?"lp_vault_associated_seed":n==="rewardVault"?"reward_vault_associated_seed":"","utf-8")],a);return o}function gt({programId:a,poolId:e,owner:t,version:n}){let{publicKey:o}=te([e.toBuffer(),t.toBuffer(),Buffer.from(n===6?"farmer_info_associated_seed":"staker_info_v2_associated_seed","utf-8")],a);return o}var Xc=({programId:a,poolId:e})=>te([e.toBuffer()],a);function zc(a){return{isSet:new Lt(1),rewardPerSecond:J(a.perSecond),rewardOpenTime:J(a.openTime),rewardEndTime:J(a.endTime),rewardType:J(zn[a.rewardType])}}function Ba(a){return J(a.endTime).sub(J(a.openTime)).mul(J(a.perSecond))}function _o(a){let e=Gc[a];return e||Ti.logWithError("invalid version",a),e}function Up(a){let e=Uc[a];return e||Ti.logWithError("invalid version",a),e}function Gp(a,e,t,n){if(a.version===3||a.version===5){if(a.lastSlot.gte(new Lt(t)))return a;let o=new Lt(t).sub(a.lastSlot);a.lastSlot=new Lt(t);for(let r of a.rewardInfos){if(e.amount.eq(new Lt(0)))continue;let i=r.perSlotReward.mul(o);r.perShareReward=r.perShareReward.add(i.mul(new Lt(10).pow(new Lt(a.version===3?9:15))).div(e.amount)),r.totalReward=r.totalReward.add(i)}}else if(a.version===6)for(let o of a.rewardInfos){if(o.rewardState.eq(new Lt(0)))continue;let r=Lt.min(new Lt(n),o.rewardEndTime);if(o.rewardOpenTime.gte(r))continue;let s=r.sub(o.rewardLastUpdateTime).mul(o.rewardPerSecond),c=o.totalReward.sub(o.totalRewardEmissioned);c.lt(s)?(s=c,o.rewardLastUpdateTime=o.rewardLastUpdateTime.add(c.div(o.rewardPerSecond))):o.rewardLastUpdateTime=r,!e.amount.eq(new Lt(0))&&(o.accRewardPerShare=o.accRewardPerShare.add(s.mul(a.rewardMultiplier).div(e.amount)),o.totalRewardEmissioned=o.totalRewardEmissioned.add(s))}return a}async function lT({connection:a,farmPools:e,owner:t,config:n,chainTime:o}){let r=!1,i=!1,s=new Lt(10),c=[];for(let p of e){let d=Ee(p);d.version===6?i=!0:r=!0,c.push({pubkey:d.id,version:d.version,key:"state",poolId:d.id},{pubkey:d.lpVault,version:d.version,key:"lpVault",poolId:d.id}),t&&c.push({pubkey:gt({programId:d.programId,poolId:d.id,owner:t,version:p.version}),version:d.version,key:"ledger",poolId:d.id})}let u={},l=await ve(a,c,n);for(let{pubkey:p,version:d,key:f,poolId:y,accountInfo:b}of l){let g=y.toBase58();if(u[g]=M({},u[g]),f==="state"){let P=Up(d);(!b||!b.data||b.data.length!==P.span)&&Ti.logWithError(`invalid farm state account info, pools.id, ${p}`),u[g].state=P.decode(b.data)}else if(f==="lpVault")(!b||!b.data||b.data.length!==sn.span)&&Ti.logWithError(`invalid farm lp vault account info, pools.lpVault, ${p}`),u[g].lpVault=sn.decode(b.data);else if(f==="ledger"){let P=_o(d);b&&b.data&&(b.data.length!==P.span&&Ti.logWithError(`invalid farm ledger account info, ledger, ${p}`),u[g].ledger=P.decode(b.data))}}let m=i||r?await a.getSlot():0;for(let p of Object.keys(u))u[p]!==void 0&&(u[p].state=Gp(u[p].state,u[p].lpVault,m,o));for(let[p,{state:d,ledger:f}]of Object.entries(u))if(f){let y=d.version===6?d.rewardMultiplier:d.rewardInfos.length===1?s.pow(new Lt(9)):s.pow(new Lt(15)),b=d.rewardInfos.map((g,P)=>{let h=f.rewardDebts[P];return f.deposited.mul(d.version===6?g.accRewardPerShare:g.perShareReward).div(y).sub(h)});u[p].wrapped=q(M({},u[p].wrapped),{pendingRewards:b})}return u}function mT(a,e=Date.now()){if(a.version===6){let t=a.state.rewardInfos;if(t.every(({rewardOpenTime:n})=>tc(e,n.toNumber(),{unit:"s"})))return"upcoming pool";if(t.every(({rewardEndTime:n})=>nc(e,n.toNumber(),{unit:"s"})))return"closed pool"}else{let t=a.state.rewardInfos.map(({perSlotReward:n})=>n);if(t.length===2){if(String(t[0])==="0"&&String(t[1])!=="0")return"normal fusion pool";if(String(t[0])!=="0"&&String(t[1])!=="0")return"dual fusion pool";if(String(t[0])==="0"&&String(t[1])==="0")return"closed pool"}else if(t.length===1&&String(t[0])==="0")return"closed pool"}}async function xa(a,e,t,n){let o=await a.getAccountInfo(e);if(o===null)throw Error("registrar info check error");let i=Ec.decode(o.data).votingMints.findIndex(l=>l.mint.equals(n));if(i===-1)throw Error("find voter mint error");let s=await a.getAccountInfo(t);if(s===null)return{index:i,isInit:!1};let u=Wc.decode(s.data).deposits.findIndex(l=>l.isUsed&&l.votingMintConfigIdx===i);return u===-1?{index:i,isInit:!1}:{index:u,isInit:!0}}var Qp=be("Raydium_farm_instruction"),Ii={voterStakeRegistryCreateVoter:Buffer.from([6,24,245,52,243,255,148,25]),voterStakeRegistryCreateDepositEntry:Buffer.from([185,131,167,186,159,125,19,67]),voterStakeRegistryDeposit:Buffer.from([242,35,198,137,82,225,242,182]),voterStakeRegistryWithdraw:Buffer.from([183,18,70,156,148,109,161,34]),voterStakeRegistryUpdateVoterWeightRecord:Buffer.from([45,185,3,36,109,190,115,169])};function Bi(a){let{version:e,id:t,ledger:n,programId:o,owner:r}=a,i={3:9,5:10}[e];i||Qp.logWithError(`invalid farm pool version: ${e}`);let s=Buffer.alloc(ma.span);ma.encode({instruction:i},s);let c=[k({pubkey:t}),k({pubkey:n}),k({pubkey:r,isWritable:!1}),k({pubkey:co.programId,isWritable:!1}),k({pubkey:Xp,isWritable:!1})];return{instruction:new rt({programId:o,keys:c,data:s}),instructionType:G.FarmV3CreateLedger}}function Yc(a){var n;let e=Buffer.alloc(pa.span);pa.encode({instruction:0,nonce:new _r(a.nonce),rewardTimeInfo:a.rewardInfoConfig},e);let t=[...Ss,k({pubkey:a.farmId}),k({pubkey:a.farmAuthority,isWritable:!1}),k({pubkey:a.lpVault}),k({pubkey:a.lpMint,isWritable:!1}),k({pubkey:a.lockVault}),k({pubkey:a.lockMint,isWritable:!1}),k({pubkey:(n=a.lockUserAccount)!=null?n:ct}),k({pubkey:a.owner,isWritable:!1,isSigner:!0})];for(let o of a.rewardInfo)t.push(k({pubkey:o.rewardMint,isWritable:!1}),k({pubkey:o.rewardVault}),k({pubkey:o.userRewardToken}));return{instruction:new rt({programId:a.programId,keys:t,data:e}),instructionType:G.FarmV6Create}}function Qc(a){let e=Buffer.alloc(da.span);da.encode({instruction:5},e);let t=[k({pubkey:Ot,isWritable:!1}),k({pubkey:a.id}),k({pubkey:a.authority,isWritable:!1}),k({pubkey:a.lpVault,isWritable:!1}),k({pubkey:a.rewardVault}),k({pubkey:a.userRewardToken}),k({pubkey:a.owner,isWritable:!1,isSigner:!0})];return{instruction:new rt({programId:a.programId,keys:t,data:e}),instructionType:G.FarmV6CreatorWithdraw}}function Hp(a,e,t,n,o,r,i,s,c,u,l,m,p){let d=F([_("depositEntryIndex"),A("amount")]),f=[{pubkey:e,isSigner:!1,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!1},{pubkey:Ot,isSigner:!1,isWritable:!1},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!1},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!1},{pubkey:l,isSigner:!1,isWritable:!1},{pubkey:Pr,isSigner:!1,isWritable:!1}],y=Buffer.alloc(d.span);d.encode({depositEntryIndex:m,amount:p},y);let b=Buffer.from([...Ii.voterStakeRegistryDeposit,...y]);return new rt({keys:f,programId:a,data:b})}function jp(a,e,t,n){let o=F([]),r=[{pubkey:e,isSigner:!1,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:co.programId,isSigner:!1,isWritable:!1}],i=Buffer.alloc(o.span);o.encode({},i);let s=Buffer.from([...Ii.voterStakeRegistryUpdateVoterWeightRecord,...i]);return new rt({keys:r,programId:a,data:s})}function $p(a,e,t,n,o,r,i,s,c,u,l,m,p,d,f){let y=F([_("depositEntryIndex"),A("amount")]),b=[{pubkey:e,isSigner:!1,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!0,isWritable:!1},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:Ot,isSigner:!1,isWritable:!1},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!1},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:m,isSigner:!1,isWritable:!1},{pubkey:p,isSigner:!1,isWritable:!1},{pubkey:Pr,isSigner:!1,isWritable:!1}],g=Buffer.alloc(y.span);y.encode({depositEntryIndex:d,amount:f},g);let P=Buffer.from([...Ii.voterStakeRegistryWithdraw,...g]);return new rt({keys:b,programId:a,data:P})}function Zp(a,e,t,n,o,r){let i=F([_("ins")]),s=[{pubkey:e,isSigner:!1,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!0,isWritable:!0},{pubkey:co.programId,isSigner:!1,isWritable:!1}],c=Buffer.alloc(i.span);return i.encode({ins:23},c),new rt({keys:s,programId:a,data:c})}function Jp(a,e,t,n,o,r,i,s){let c=F([_("voterBump"),_("voterWeightRecordBump")]),u=[{pubkey:e,isSigner:!1,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!0,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!0,isWritable:!0},{pubkey:co.programId,isSigner:!1,isWritable:!1},{pubkey:Je,isSigner:!1,isWritable:!1},{pubkey:Pr,isSigner:!1,isWritable:!1}],l=Buffer.alloc(c.span);c.encode({voterBump:i,voterWeightRecordBump:s},l);let m=Buffer.from([...Ii.voterStakeRegistryCreateVoter,...l]);return new rt({keys:u,programId:a,data:m})}function ef(a,e,t,n,o,r,i,s,c,u,l,m){let p=F([_("depositEntryIndex"),_("kind"),_("option"),A("startTs"),pt("periods"),qe("allowClawback")]),d=[{pubkey:e,isSigner:!1,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!0,isWritable:!1},{pubkey:r,isSigner:!0,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!1},{pubkey:co.programId,isSigner:!1,isWritable:!1},{pubkey:Ot,isSigner:!1,isWritable:!1},{pubkey:zp,isSigner:!1,isWritable:!1},{pubkey:Je,isSigner:!1,isWritable:!1}],f=Buffer.alloc(p.span);p.encode({depositEntryIndex:s,kind:c,option:u===void 0?0:1,startTs:u,periods:l,allowClawback:m},f);let y=Buffer.from([...Ii.voterStakeRegistryCreateDepositEntry,...f]);return new rt({keys:d,programId:a,data:y})}async function KT({connection:a,programId:e,governanceProgramId:t,voteWeightAddinProgramId:n,realm:o,communityTokenMint:r,owner:i,poolId:s,tokenProgram:c}){let u=Aa(n,o,r).publicKey,l=gt({programId:e,poolId:s,owner:i,version:3}),m=await a.getAccountInfo(l);if(m===null)throw Error("user is not staker");let p=wi.decode(m.data),d=p.deposited.sub(p.voteLockedBalance);if(console.log("amount",d.toString()),d.eq(new _r(0)))throw Error("user do not has new stake amount");let f=ka(e,s).publicKey,y=wa(e,s).publicKey,{publicKey:b,nonce:g}=Ta(n,u,i),P=j(b,f,c).publicKey,{publicKey:h,nonce:I}=ha(n,u,i),T=Ia(t,o,r,i).publicKey,w=[],K=j(i,f,c).publicKey;if(await a.getAccountInfo(K)===null&&w.push(Yp(i,K,i,f)),await a.getAccountInfo(b)===null){let C=Zp(t,o,i,r,i,T);w.push(C,Jp(n,u,b,h,i,i,g,I))}let{index:B,isInit:R}=await xa(a,u,b,f);return R||w.push(ef(n,u,b,P,i,i,f,B,0,void 0,0,!1)),w.push(Hp(n,u,b,P,K,i,l,s,f,y,e,B,d),jp(n,u,b,h)),w}async function ST({connection:a,programId:e,governanceProgramId:t,voteWeightAddinProgramId:n,realm:o,communityTokenMint:r,owner:i,poolId:s,tokenProgram:c}){let u=Aa(n,o,r).publicKey,l=gt({programId:e,poolId:s,owner:i,version:3}),m=await a.getAccountInfo(l);if(m===null)throw Error("user is not staker");let p=wi.decode(m.data);if(p.voteLockedBalance.eq(new _r(0)))throw Error("user has vote locked balance = 0");let d=ka(e,s).publicKey,f=wa(e,s).publicKey,{publicKey:y}=Ta(n,u,i),b=j(y,d,c).publicKey,{publicKey:g}=ha(n,u,i),P=Ia(t,o,r,i).publicKey,h=[],{index:I,isInit:T}=await xa(a,u,y,d);if(!T)throw Error("deposit entry index check error");return h.push($p(n,u,y,i,P,g,b,j(i,d,c).publicKey,l,s,d,f,e,I,p.voteLockedBalance)),h}function Ka({payer:a,rewardVault:e,userRewardTokenPub:t,farmKeys:n,rewardInfo:o}){let r=Buffer.alloc(fa.span);fa.encode({instruction:3,rewardReopenTime:J(o.openTime),rewardEndTime:J(o.endTime),rewardPerSecond:J(o.perSecond)},r);let i=[k({pubkey:Ot,isWritable:!1}),k({pubkey:n.id}),k({pubkey:n.lpVault,isWritable:!1}),k({pubkey:e}),k({pubkey:t}),k({pubkey:a,isWritable:!1,isSigner:!0})];return new rt({programId:n.programId,keys:i,data:r})}function Sa({payer:a,userRewardTokenPub:e,farmKeys:t,rewardVault:n,rewardInfo:o}){let r=Buffer.alloc(ya.span);ya.encode({instruction:4,isSet:new _r(1),rewardPerSecond:J(o.perSecond),rewardOpenTime:J(o.openTime),rewardEndTime:J(o.endTime),rewardType:J(zn[o.rewardType])},r);let i=[...Ss,k({pubkey:t.id}),k({pubkey:t.authority,isWritable:!1}),k({pubkey:o.mint,isWritable:!1}),k({pubkey:n}),k({pubkey:e}),k({pubkey:a,isWritable:!1,isSigner:!0})];return new rt({programId:t.programId,keys:i,data:r})}function CT(a){let{farmInfo:e,farmKeys:t,version:n,lpAccount:o,rewardAccounts:r,owner:i,instruction:s,amount:c,deposit:u}=a,[l,m]=[new ce(e.programId),new ce(e.id)],p=gt({programId:l,poolId:m,owner:i,version:n}),d=Buffer.alloc(Bt.span);Bt.encode({instruction:s,amount:c},d);let f=n===6?[k({pubkey:Ot,isWritable:!1}),...u?[k({pubkey:co.programId,isWritable:!1})]:[],k({pubkey:m}),k({pubkey:new ce(t.authority),isWritable:!1}),k({pubkey:new ce(t.lpVault)}),k({pubkey:p}),k({pubkey:i,isWritable:!1,isSigner:!0}),k({pubkey:o})]:[k({pubkey:m}),k({pubkey:new ce(t.authority),isWritable:!1}),k({pubkey:p}),k({pubkey:i,isWritable:!1,isSigner:!0}),k({pubkey:o}),k({pubkey:new ce(t.lpVault)}),k({pubkey:r[0]}),k({pubkey:new ce(t.rewardInfos[0].vault)}),k({pubkey:Eo,isWritable:!1}),k({pubkey:Ot,isWritable:!1})];if(n===5)for(let y=1;y<t.rewardInfos.length;y++)f.push(k({pubkey:r[y]})),f.push(k({pubkey:new ce(t.rewardInfos[y].vault)}));if(n===6)for(let y=0;y<t.rewardInfos.length;y++)f.push(k({pubkey:new ce(t.rewardInfos[y].vault)})),f.push(k({pubkey:r[y]}));return new rt({programId:l,keys:f,data:d})}function xi(a){let{farmInfo:e,farmKeys:t,lpAccount:n,rewardAccounts:o,owner:r,amount:i}=a,[s,c]=[new ce(e.programId),new ce(e.id)],u=gt({programId:s,poolId:c,owner:r,version:6}),l=Buffer.alloc(Bt.span);Bt.encode({instruction:2,amount:J(i)},l);let m=[k({pubkey:Ot,isWritable:!1}),k({pubkey:c}),k({pubkey:new ce(t.authority),isWritable:!1}),k({pubkey:new ce(t.lpVault)}),k({pubkey:u}),k({pubkey:r,isWritable:!1,isSigner:!0}),k({pubkey:n})];for(let p=0;p<t.rewardInfos.length;p++)m.push(k({pubkey:new ce(t.rewardInfos[p].vault)})),m.push(k({pubkey:o[p]}));return new rt({programId:s,keys:m,data:l})}function Ki(a){let{farmInfo:e,farmKeys:t,lpAccount:n,rewardAccounts:o,owner:r,amount:i,userAuxiliaryLedgers:s}=a,[c,u]=[new ce(e.programId),new ce(e.id)],l=gt({programId:c,poolId:u,owner:r,version:5}),m=Buffer.alloc(Bt.span);Bt.encode({instruction:12,amount:J(i)},m);let p=[k({pubkey:u}),k({pubkey:new ce(t.authority),isWritable:!1}),k({pubkey:l}),k({pubkey:r,isWritable:!1,isSigner:!0}),k({pubkey:n}),k({pubkey:new ce(t.lpVault)}),k({pubkey:o[0]}),k({pubkey:new ce(t.rewardInfos[0].vault)}),k({pubkey:Eo,isWritable:!1}),k({pubkey:Ot,isWritable:!1})];for(let d=1;d<t.rewardInfos.length;d++)p.push(k({pubkey:o[d]})),p.push(k({pubkey:new ce(t.rewardInfos[d].vault)}));if(s)for(let d of s)p.push(k({pubkey:d}));return new rt({programId:c,keys:p,data:m})}function Hc(a){let{farmInfo:e,farmKeys:t,lpAccount:n,rewardAccounts:o,owner:r,amount:i,userAuxiliaryLedgers:s}=a,[c,u]=[new ce(e.programId),new ce(e.id)],l=F([_("instruction"),A("amount")]),m=[k({pubkey:u}),k({pubkey:new ce(t.authority),isWritable:!1}),k({pubkey:s[0]}),k({pubkey:r,isSigner:!0,isWritable:!1}),k({pubkey:n}),k({pubkey:new ce(t.lpVault)}),k({pubkey:o[0]}),k({pubkey:new ce(t.rewardInfos[0].vault)}),k({pubkey:Eo,isWritable:!1}),k({pubkey:Ot,isWritable:!1}),k({pubkey:o[1]}),k({pubkey:new ce(t.rewardInfos[1].vault)})],p=Buffer.alloc(l.span);return l.encode({instruction:2,amount:i},p),new rt({keys:m,programId:c,data:p})}function Si(a){let{farmInfo:e,farmKeys:t,lpAccount:n,rewardAccounts:o,owner:r,amount:i,userAuxiliaryLedgers:s}=a,[c,u]=[new ce(e.programId),new ce(e.id)],l=gt({programId:c,poolId:u,owner:r,version:3}),m=Buffer.alloc(Bt.span);Bt.encode({instruction:11,amount:J(i)},m);let p=[k({pubkey:u}),k({pubkey:new ce(t.authority),isWritable:!1}),k({pubkey:l}),k({pubkey:r,isWritable:!1,isSigner:!0}),k({pubkey:n}),k({pubkey:new ce(t.lpVault)}),k({pubkey:o[0]}),k({pubkey:new ce(t.rewardInfos[0].vault)}),k({pubkey:Eo,isWritable:!1}),k({pubkey:Ot,isWritable:!1})];if(s)for(let d of s)p.push(k({pubkey:d}));return new rt({programId:c,keys:p,data:m})}function jc(a){let{farmInfo:e,farmKeys:t,lpAccount:n,rewardAccounts:o,owner:r,amount:i,userAuxiliaryLedgers:s}=a,[c,u]=[new ce(e.programId),new ce(e.id)],l=gt({programId:c,poolId:u,owner:r,version:3}),m=Buffer.alloc(Bt.span);Bt.encode({instruction:10,amount:J(i)},m);let p=[k({pubkey:u}),k({pubkey:new ce(t.authority),isWritable:!1}),k({pubkey:l}),k({pubkey:r,isWritable:!1,isSigner:!0}),k({pubkey:n}),k({pubkey:new ce(t.lpVault)}),k({pubkey:o[0]}),k({pubkey:new ce(t.rewardInfos[0].vault)}),k({pubkey:Eo,isWritable:!1}),k({pubkey:Ot,isWritable:!1})];if(s)for(let d of s)p.push(k({pubkey:d}));return new rt({programId:c,keys:p,data:m})}function $c(a){let{farmInfo:e,farmKeys:t,lpAccount:n,rewardAccounts:o,owner:r,amount:i,userAuxiliaryLedgers:s}=a,[c,u]=[new ce(e.programId),new ce(e.id)],l=gt({programId:c,poolId:u,owner:r,version:5}),m=Buffer.alloc(Bt.span);Bt.encode({instruction:11,amount:J(i)},m);let p=[k({pubkey:u}),k({pubkey:new ce(t.authority),isWritable:!1}),k({pubkey:l}),k({pubkey:r,isWritable:!1,isSigner:!0}),k({pubkey:n}),k({pubkey:new ce(t.lpVault)}),k({pubkey:o[0]}),k({pubkey:new ce(t.rewardInfos[0].vault)}),k({pubkey:Eo,isWritable:!1}),k({pubkey:Ot,isWritable:!1})];for(let d=1;d<t.rewardInfos.length;d++)p.push(k({pubkey:o[d]})),p.push(k({pubkey:new ce(t.rewardInfos[d].vault)}));if(s)for(let d of s)p.push(k({pubkey:d}));return new rt({programId:c,keys:p,data:m})}function Zc(a){let{farmInfo:e,farmKeys:t,lpAccount:n,rewardAccounts:o,owner:r,amount:i}=a,[s,c]=[new ce(e.programId),new ce(e.id)],u=gt({programId:s,poolId:c,owner:r,version:6}),l=Buffer.alloc(Bt.span);Bt.encode({instruction:1,amount:J(i)},l);let m=[k({pubkey:Ot,isWritable:!1}),k({pubkey:co.programId,isWritable:!1}),k({pubkey:c}),k({pubkey:new ce(t.authority),isWritable:!1}),k({pubkey:new ce(t.lpVault)}),k({pubkey:u}),k({pubkey:r,isWritable:!1,isSigner:!0}),k({pubkey:n})];for(let p=0;p<t.rewardInfos.length;p++)m.push(k({pubkey:new ce(t.rewardInfos[p].vault)})),m.push(k({pubkey:o[p]}));return new rt({programId:s,keys:m,data:l})}var Ci=class extends We{async _getUserRewardInfo({payer:e,rewardInfo:t}){if(t.mint.equals(ct)){let n=await Gn({connection:this.scope.connection,owner:this.scope.ownerPubKey,payer:e,amount:Ba(q(M({},t),{openTime:t.openTime.toString(),endTime:t.endTime.toString()}))});return{rewardPubKey:n.addresses.newAccount,newInstruction:n}}return{rewardPubKey:await this.scope.account.getCreatedTokenAccount({mint:t.mint,associatedOnly:!1})}}async create({poolInfo:e,rewardInfos:t,payer:n,programId:o=Ro,txVersion:r,feePayer:i,lockProgram:s}){var K,x;this.checkDisabled(),this.scope.checkOwner();let u={lpMint:new Se(e.lpMint.address),lockInfo:{lockMint:(K=s==null?void 0:s.mint)!=null?K:Dc,lockVault:(x=s==null?void 0:s.vault)!=null?x:qc},version:6,rewardInfos:t,programId:o},l=this.createTxBuilder(i),m=n!=null?n:this.scope.ownerPubKey,p=je({fromPublicKey:m,programId:u.programId}),d=await this.scope.connection.getMinimumBalanceForRentExemption(ki.span);l.addInstruction({instructions:[tf.createAccountWithSeed({fromPubkey:m,basePubkey:m,seed:p.seed,newAccountPubkey:p.publicKey,lamports:d,space:ki.span,programId:u.programId})]});let{publicKey:f,nonce:y}=Xc({programId:new Se(u.programId),poolId:p.publicKey}),b=hi({programId:u.programId,poolId:p.publicKey,mint:u.lpMint,type:"lpVault"}),g=[],P=[];for(let S of u.rewardInfos){S.openTime>=S.endTime&&this.logAndCreateError("start time error","rewardInfo.rewardOpenTime",S.openTime.toString()),isNaN(zn[S.rewardType])&&this.logAndCreateError("rewardType error",S.rewardType),Number(S.perSecond)<=0&&this.logAndCreateError("rewardPerSecond error",S.perSecond),g.push(zc(S));let{rewardPubKey:B,newInstruction:R}=await this._getUserRewardInfo({rewardInfo:S,payer:m});R&&l.addInstruction(R),B||this.logAndCreateError("cannot found target token accounts",this.scope.account.tokenAccounts);let C=S.mint.equals(ct)?new Se(ut.address):S.mint;P.push({rewardMint:C,rewardVault:hi({programId:u.programId,poolId:p.publicKey,mint:C,type:"rewardVault"}),userRewardToken:B})}let{account:h,instructionParams:I}=await this.scope.account.getOrCreateTokenAccount({mint:new Se(u.lockInfo.lockMint),owner:this.scope.ownerPubKey,skipCloseAccount:!1,createInfo:{payer:this.scope.ownerPubKey,amount:0},associatedOnly:!1});I&&l.addInstruction(I),h||this.logAndCreateError("cannot found lock vault","tokenAccounts",this.scope.account.tokenAccounts);let{instruction:T,instructionType:w}=Yc({farmId:p.publicKey,owner:this.scope.ownerPubKey,farmAuthority:f,lpVault:b,lpMint:u.lpMint,lockVault:u.lockInfo.lockVault,lockMint:u.lockInfo.lockMint,lockUserAccount:h,programId:u.programId,rewardInfo:P,rewardInfoConfig:g,nonce:y});return l.addInstruction({instructions:[T],instructionTypes:[w]}).versionBuild({txVersion:r,extInfo:{farmId:p.publicKey,farmAuthority:f,lpVault:b,lockUserAccount:h,nonce:y}})}async restartReward({farmInfo:e,payer:t,newRewardInfo:n,txVersion:o,feePayer:r}){var g;let i=Xt[e.programId];i!==6&&this.logAndCreateError("invalid farm version ",i);let s=Ee((await this.scope.api.fetchFarmKeysById({ids:e.id}))[0]),c={id:s.id,rewardInfos:e.rewardInfos,lpVault:s.lpVault,programId:s.programId};n.openTime>=n.endTime&&this.logAndCreateError("start time error","newRewardInfo",n);let u=t||this.scope.ownerPubKey,l=n.mint.equals(ct)?new Se(ut.address):n.mint,m=c.rewardInfos.findIndex(P=>new Se(P.mint.address).equals(l)),p=s.rewardInfos[m];p||this.logAndCreateError("configuration does not exist","rewardMint",l);let d=(g=p.vault)!=null?g:ct,f=this.createTxBuilder(r),{rewardPubKey:y,newInstruction:b}=await this._getUserRewardInfo({rewardInfo:n,payer:u});return b&&f.addInstruction(b),y||this.logAndCreateError("cannot found target token accounts",this.scope.account.tokenAccounts),f.addInstruction({instructions:[Ka({payer:this.scope.ownerPubKey,rewardVault:d,userRewardTokenPub:y,farmKeys:c,rewardInfo:n})],instructionTypes:[G.FarmV6Restart]}).versionBuild({txVersion:o})}async restartRewards({farmInfo:e,payer:t,newRewardInfos:n,txVersion:o,feePayer:r}){var m;let i=Xt[e.programId];i!==6&&this.logAndCreateError("invalid farm version ",i);let s=Ee((await this.scope.api.fetchFarmKeysById({ids:e.id}))[0]),c={id:s.id,rewardInfos:e.rewardInfos,lpVault:s.lpVault,programId:s.programId};n.forEach(p=>{p.openTime>=p.endTime&&this.logAndCreateError("start time error","newRewardInfo",p)});let u=t||this.scope.ownerPubKey,l=this.createTxBuilder(r);for(let p of n){let d=p.mint.equals(ct)?new Se(ut.address):p.mint,f=c.rewardInfos.findIndex(I=>new Se(I.mint.address).equals(d)),y=s.rewardInfos[f];y||this.logAndCreateError("configuration does not exist","rewardMint",d);let b=(m=y.vault)!=null?m:ct,{rewardPubKey:g,newInstruction:P}=await this._getUserRewardInfo({rewardInfo:p,payer:u});P&&l.addInstruction(P),g||this.logAndCreateError("cannot found target token accounts",this.scope.account.tokenAccounts);let h=Ka({payer:this.scope.ownerPubKey,rewardVault:b,userRewardTokenPub:g,farmKeys:c,rewardInfo:p});l.addInstruction({instructions:[h],instructionTypes:[G.FarmV6Restart]})}return l.versionBuild({txVersion:o})}async addNewRewardToken(e){let{txVersion:t,farmInfo:n,newRewardInfo:o,payer:r,feePayer:i}=e,s=Xt[n.programId];s!==6&&this.logAndCreateError("invalid farm version ",s);let c=Ee((await this.scope.api.fetchFarmKeysById({ids:n.id}))[0]),u=r!=null?r:this.scope.ownerPubKey,l=this.createTxBuilder(i),m=o.mint.equals(ct)?new Se(ut.address):o.mint,p=hi({programId:new Se(n.programId),poolId:new Se(n.id),mint:m,type:"rewardVault"}),{rewardPubKey:d,newInstruction:f}=await this._getUserRewardInfo({rewardInfo:o,payer:u});return f&&l.addInstruction(f),d||this.logAndCreateError("annot found target token accounts",this.scope.account.tokenAccounts),o.mint=m,l.addInstruction({instructions:[Sa({payer:this.scope.ownerPubKey,userRewardTokenPub:d,farmKeys:c,rewardVault:p,rewardInfo:o})],instructionTypes:[G.FarmV6CreatorAddReward]}).versionBuild({txVersion:t})}async addNewRewardsToken(e){let{txVersion:t,farmInfo:n,newRewardInfos:o,payer:r,feePayer:i}=e,s=Xt[n.programId];s!==6&&this.logAndCreateError("invalid farm version ",s);let c=Ee((await this.scope.api.fetchFarmKeysById({ids:n.id}))[0]),u=r!=null?r:this.scope.ownerPubKey,l=this.createTxBuilder(i);for(let m of o){let p=m.mint.equals(ct)?new Se(ut.address):m.mint,d=hi({programId:new Se(n.programId),poolId:new Se(n.id),mint:p,type:"rewardVault"}),{rewardPubKey:f,newInstruction:y}=await this._getUserRewardInfo({rewardInfo:m,payer:u});y&&l.addInstruction(y),f||this.logAndCreateError("cannot found target token accounts",this.scope.account.tokenAccounts);let b=Sa({payer:this.scope.ownerPubKey,userRewardTokenPub:f,farmKeys:c,rewardVault:d,rewardInfo:q(M({},m),{mint:p})});l.addInstruction({instructions:[b],instructionTypes:[G.FarmV6CreatorAddReward]})}return l.versionBuild({txVersion:t})}async deposit(e){let{txVersion:t,farmInfo:n,amount:o,feePayer:r,useSOLBalance:i,associatedOnly:s=!0,checkCreateATAOwner:c=!1,userAuxiliaryLedgers:u,computeBudgetConfig:l,txTipConfig:m}=e;this.scope.availability.addFarm===!1&&this.logAndCreateError("farm deposit feature disabled in your region");let{rewardInfos:p,programId:d}=n,f=Xt[d];f===4&&this.logAndCreateError("V4 has suspended deposits:",n.programId),ga(f)||this.logAndCreateError("invalid farm program:",n.programId);let[y,b]=[new Se(n.programId),new Se(n.id)],g=(await this.scope.api.fetchFarmKeysById({ids:n.id}))[0],P=gt({programId:y,poolId:b,owner:this.scope.ownerPubKey,version:f}),h=this.createTxBuilder(r);h.addCustomComputeBudget(l),h.addTipInstruction(m);let I={};for(let L of this.scope.account.tokenAccounts)if(s){let N=j(this.scope.ownerPubKey,L.mint,L.programId).publicKey;L.publicKey&&N.equals(L.publicKey)&&(I[L.mint.toString()]=L.publicKey)}else I[L.mint.toString()]=L.publicKey;let T=g.lpMint,w=I[T.address];w||this.logAndCreateError("you don't have any lp","lp zero",I);let K=[];for(let L of p){let N=i&&L.mint.address===$.toString(),E=I[L.mint.address];if(!E){let{account:X,instructionParams:Q}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:L.mint.programId,mint:new Se(L.mint.address),notUseTokenAccount:N,createInfo:{payer:r||this.scope.ownerPubKey,amount:0},owner:this.scope.ownerPubKey,skipCloseAccount:!N,associatedOnly:N?!1:s,checkCreateATAOwner:c});E=X,Q&&h.addInstruction(Q)}I[L.mint.address]=E,K.push(E)}let x,S=await this.scope.connection.getAccountInfo(P);if(S&&(x=_o(f).decode(S.data)),n.programId!==Ro.toString()&&n.programId!==kn.FARM_PROGRAM_ID_V6.toString()&&!x){let{instruction:L,instructionType:N}=Bi({id:b,programId:y,version:f,ledger:P,owner:this.scope.ownerPubKey});h.addInstruction({instructions:[L],instructionTypes:[N]})}let B=Pa({version:f,rewardInfos:p,rewardTokenAccountsPublicKeys:K});B&&this.logAndCreateError(B);let R={amount:J(o),owner:this.scope.ownerPubKey,farmInfo:n,farmKeys:g,lpAccount:w,rewardAccounts:K,userAuxiliaryLedgers:u==null?void 0:u.map(L=>new Se(L))},C=f===6?Zc(R):f===5?$c(R):jc(R),v={3:G.FarmV3Deposit,5:G.FarmV5Deposit,6:G.FarmV6Deposit};return h.addInstruction({instructions:[C],instructionTypes:[v[f]]}).versionBuild({txVersion:t})}async withdraw(e){let{txVersion:t,farmInfo:n,amount:o,deposited:r,useSOLBalance:i,feePayer:s,associatedOnly:c=!0,checkCreateATAOwner:u=!1,userAuxiliaryLedgers:l,computeBudgetConfig:m,txTipConfig:p}=e,{rewardInfos:d}=n;this.scope.availability.removeFarm===!1&&this.logAndCreateError("farm withdraw feature disabled in your region");let f=Xt[n.programId];ga(f)||this.logAndCreateError("invalid farm program:",n.programId);let y=(await this.scope.api.fetchFarmKeysById({ids:n.id}))[0],b=this.createTxBuilder(s);b.addCustomComputeBudget(m),b.addTipInstruction(p);let g={};for(let B of this.scope.account.tokenAccounts)if(c){let R=j(this.scope.ownerPubKey,B.mint).publicKey;B.publicKey&&R.equals(B.publicKey)&&(g[B.mint.toString()]=B.publicKey)}else g[B.mint.toString()]=B.publicKey;if(f!==4){let B=gt({programId:new Se(n.programId),poolId:new Se(n.id),owner:this.scope.ownerPubKey,version:f}),R=await this.scope.connection.getAccountInfo(B);if(R)_o(f).decode(R.data).deposited.isZero()&&this.logAndCreateError("no deposited lp",{farmId:n.id});else if(f!==6){let{instruction:C,instructionType:v}=Bi({id:new Se(y.id),programId:new Se(y.programId),version:f,ledger:B,owner:this.scope.ownerPubKey});b.addInstruction({instructions:[C],instructionTypes:[v]})}}r&&r.isZero()&&!(l||[]).length&&this.logAndCreateError("no deposited lp",{farmId:n.id});let P=y.lpMint.address,h=i&&P===$.toString(),I=g[P.toString()];if(!I){let{account:B,instructionParams:R}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:y.lpMint.programId,mint:new Se(P),notUseTokenAccount:h,createInfo:{payer:s||this.scope.ownerPubKey,amount:0},owner:this.scope.ownerPubKey,skipCloseAccount:!0,associatedOnly:h?!1:c,checkCreateATAOwner:u});I=B,R&&b.addInstruction(R)}g[P.toString()]=I;let T=[];for(let B of d){let R=i&&B.mint.address===$.toString(),C=g[B.mint.address];if(!C){let{account:v,instructionParams:L}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:B.mint.programId,mint:new Se(B.mint.address),notUseTokenAccount:R,createInfo:{payer:s||this.scope.ownerPubKey,amount:0},owner:this.scope.ownerPubKey,skipCloseAccount:!R,associatedOnly:R?!1:c,checkCreateATAOwner:u});C=v,L&&b.addInstruction(L)}g[B.mint.address]=C,T.push(C)}let w=Pa({version:f,rewardInfos:d,rewardTokenAccountsPublicKeys:T});w&&this.logAndCreateError(w);let K={amount:J(o),owner:this.scope.ownerPubKey,farmInfo:n,farmKeys:y,lpAccount:I,rewardAccounts:T,userAuxiliaryLedgers:l==null?void 0:l.map(B=>new Se(B))},x=f===6?xi(K):f===5?Ki(K):f===4?Hc(K):Si(K),S={3:G.FarmV3Withdraw,4:G.FarmV4Withdraw,5:G.FarmV5Withdraw,6:G.FarmV6Withdraw};return b.addInstruction({instructions:[x],instructionTypes:[S[f]]}).versionBuild({txVersion:t})}async withdrawFarmReward({farmInfo:e,withdrawMint:t,txVersion:n,computeBudgetConfig:o,txTipConfig:r,feePayer:i}){var y;this.scope.checkOwner();let s=Ee((await this.scope.api.fetchFarmKeysById({ids:e.id}))[0]),c=Xt[e.programId];c!==6&&this.logAndCreateError("invalid farm version",c);let u=s.rewardInfos.find(b=>bt(b.mint.address).equals(bt(t)));u||this.logAndCreateError("withdraw mint error","rewardInfos",e);let l=(y=u==null?void 0:u.vault)!=null?y:ct,m=this.createTxBuilder(i),p;if(t.equals(ct)||t.equals(Se.default)){let b=await Gn({connection:this.scope.connection,owner:this.scope.ownerPubKey,payer:this.scope.ownerPubKey,amount:Ba(q(M({},u),{openTime:u.openTime,endTime:u.endTime,perSecond:new nf(u.perSecond).mul(10**u.mint.decimals).toString()}))});p=b.addresses.newAccount,m.addInstruction(b)}else{let b=await this.scope.account.getCreatedTokenAccount({mint:t});b===null?(p=await this.scope.account.getAssociatedTokenAccount(t),m.addInstruction({instructions:[Jc(this.scope.ownerPubKey,p,this.scope.ownerPubKey,t)],instructionTypes:[G.CreateATA]})):p=b}let{instruction:d,instructionType:f}=Qc({programId:s.programId,id:s.id,authority:s.authority,lpVault:s.lpVault,rewardVault:l,userRewardToken:p,owner:this.scope.ownerPubKey});return m.addCustomComputeBudget(o),m.addTipInstruction(r),m.addInstruction({instructions:[d],instructionTypes:[f]}).versionBuild({txVersion:n})}async harvestAllRewards(e){let{farmInfoList:t,useSOLBalance:n,feePayer:o,associatedOnly:r=!0,checkCreateATAOwner:i=!1,userAuxiliaryLedgers:s,txVersion:c,computeBudgetConfig:u}=e,l=this.createTxBuilder(o),m={};for(let f of this.scope.account.tokenAccounts)if(r){let y=j(this.scope.ownerPubKey,f.mint).publicKey;f.publicKey&&y.equals(f.publicKey)&&(m[f.mint.toString()]=f.publicKey)}else m[f.mint.toString()]=f.publicKey;let d=(await this.scope.api.fetchFarmKeysById({ids:Object.values(t).map(f=>f.id).join(",")})).reduce((f,y)=>q(M({},f),{[y.id]:y}),{});for(let f of Object.values(t)){let{programId:y,lpMint:b,rewardInfos:g,id:P}=f,h=Xt[y],I=b.address,T=n&&I===$.toString(),w=m[I];if(!w){let{account:C,instructionParams:v}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:b.programId,mint:new Se(I),notUseTokenAccount:T,createInfo:{payer:o||this.scope.ownerPubKey,amount:0},owner:this.scope.ownerPubKey,skipCloseAccount:!0,associatedOnly:T?!1:r,checkCreateATAOwner:i});w=C,v&&l.addInstruction(v)}m[I.toString()]=w;let K=[];for(let C of g){let v=n&&C.mint.address===$.toString(),L=m[C.mint.address];if(!L)if(v){let{account:N,instructionParams:E}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:C.mint.programId,mint:new Se(C.mint.address),notUseTokenAccount:v,createInfo:{payer:o||this.scope.ownerPubKey,amount:0},owner:this.scope.ownerPubKey,skipCloseAccount:!v,associatedOnly:v?!1:r,checkCreateATAOwner:i});L=N,E&&l.addInstruction(E)}else{let N=new Se(C.mint.address);L=this.scope.account.getAssociatedTokenAccount(N),l.addInstruction({instructions:[Jc(this.scope.ownerPubKey,L,this.scope.ownerPubKey,N)]})}m[C.mint.address]=L,K.push(L)}let x=d[P],S={amount:tt,owner:this.scope.ownerPubKey,farmInfo:f,farmKeys:x,lpAccount:w,rewardAccounts:K,userAuxiliaryLedgers:s==null?void 0:s.map(C=>new Se(C))},B=h===6?xi(S):h===5?Ki(S):Si(S),R={3:G.FarmV3Withdraw,5:G.FarmV5Withdraw,6:G.FarmV6Withdraw};l.addInstruction({instructions:[B],instructionTypes:[R[h]]})}return c===1?l.sizeCheckBuild({computeBudgetConfig:u}):l.sizeCheckBuildV0({computeBudgetConfig:u})}};import{PublicKey as nt}from"@solana/web3.js";import{AccountLayout as zf,NATIVE_MINT as Jr,TOKEN_PROGRAM_ID as Qn}from"@solana/spl-token";import{Keypair as Xr,PublicKey as z,SystemProgram as Sn,TransactionInstruction as yt}from"@solana/web3.js";import Wa from"bn.js";import{ASSOCIATED_TOKEN_PROGRAM_ID as Vi,TOKEN_2022_PROGRAM_ID as ze,TOKEN_PROGRAM_ID as Ce}from"@solana/spl-token";import ff from"bn.js";import qo from"decimal.js";import zt from"bn.js";var Pe=new zt(0),Wt=new zt(1),Bn=new zt(-1),st=new zt(1).shln(64),Er=new zt(1).shln(128),Ri=st.sub(Wt),Li=64,el=Er.subn(1),Pt=-443636,xt=-Pt,Yt=new zt("4295048016"),Qt=new zt("79226673521066979257578248091"),Wr=new zt("4295048017"),Dr=new zt("79226673521066979257578248090"),tl=16,nl="59543866431248",ol="184467440737095516",il="15793534762490258745",qr=new zt(10).pow(new zt(6)),of=(n=>(n[n.rate_500=500]="rate_500",n[n.rate_3000=3e3]="rate_3000",n[n.rate_10000=1e4]="rate_10000",n))(of||{}),sh={[500]:10,[3e3]:60,[1e4]:200},ah={version:6,liquidity:Pe,tickCurrent:0,feeGrowthGlobalX64A:Pe,feeGrowthGlobalX64B:Pe,protocolFeesTokenA:Pe,protocolFeesTokenB:Pe,swapInAmountTokenA:Pe,swapOutAmountTokenB:Pe,swapInAmountTokenB:Pe,swapOutAmountTokenA:Pe,tickArrayBitmap:[],rewardInfos:[],day:{volume:0,volumeFee:0,feeA:0,feeB:0,feeApr:0,rewardApr:{A:0,B:0,C:0},apr:0,priceMax:0,priceMin:0},week:{volume:0,volumeFee:0,feeA:0,feeB:0,feeApr:0,rewardApr:{A:0,B:0,C:0},apr:0,priceMax:0,priceMin:0},month:{volume:0,volumeFee:0,feeA:0,feeB:0,feeApr:0,rewardApr:{A:0,B:0,C:0},apr:0,priceMax:0,priceMin:0},tvl:0},rl={tvl:0,volumeQuote:0,mintAmountA:0,mintAmountB:0,rewardDefaultInfos:[],farmUpcomingCount:0,farmOngoingCount:0,farmFinishedCount:0,day:{volume:0,volumeQuote:0,volumeFee:0,apr:0,feeApr:0,priceMin:0,priceMax:0,rewardApr:[0]},week:{volume:0,volumeQuote:0,volumeFee:0,apr:0,feeApr:0,priceMin:0,priceMax:0,rewardApr:[0]},month:{volume:0,volumeQuote:0,volumeFee:0,apr:0,feeApr:0,priceMin:0,priceMax:0,rewardApr:[0]},pooltype:[]},uh=new zt("18446744073700000000");import fe from"bn.js";import pn from"decimal.js";function Ur(a){let e=new ArrayBuffer(2);return new DataView(e).setUint16(0,a,!1),new Uint8Array(e)}function lh(a){let e=new ArrayBuffer(2);return new DataView(e).setInt16(0,a,!1),new Uint8Array(e)}function mh(a){let e=new ArrayBuffer(4);return new DataView(e).setUint32(0,a,!1),new Uint8Array(e)}function Gr(a){let e=new ArrayBuffer(4);return new DataView(e).setInt32(0,a,!1),new Uint8Array(e)}function Ca(a,e){let t=0;for(let n=a-1;n>=0&&!e.testn(n);n--)t++;return t}function Ra(a,e){let t=0;for(let n=0;n<a&&!e.testn(n);n++)t++;return t}function Oi(a,e){for(let t=0;t<a;t++)if(e.testn(t))return!1;return!0}function sl(a,e){return Oi(a,e)?null:Ca(a,e)}function al(a,e){return Oi(a,e)?null:Ra(a,e)}var rf=Buffer.from("amm_config","utf8"),La=Buffer.from("pool","utf8"),Oa=Buffer.from("pool_vault","utf8"),sf=Buffer.from("pool_reward_vault","utf8"),ul=Buffer.from("position","utf8"),af=Buffer.from("tick_array","utf8"),uf=Buffer.from("operation","utf8"),cf=Buffer.from("pool_tick_array_bitmap_extension","utf8"),lf=Buffer.from("observation","utf8");function yh(a,e){return te([rf,Ur(e)],a)}function cl(a,e,t,n){return te([La,e.toBuffer(),t.toBuffer(),n.toBuffer()],a)}function Na(a,e,t){return te([Oa,e.toBuffer(),t.toBuffer()],a)}function ll(a,e,t){return te([sf,e.toBuffer(),t.toBuffer()],a)}function Ae(a,e,t){return te([af,e.toBuffer(),Gr(t)],a)}function an(a,e,t,n){return te([ul,e.toBuffer(),Gr(t),Gr(n)],a)}function Kt(a,e){return te([ul,e.toBuffer()],a)}function xn(a){return te([Buffer.from("metadata","utf8"),Gt.toBuffer(),a.toBuffer()],Gt)}function Ni(a){return te([uf],a)}function $e(a,e){return te([cf,e.toBuffer()],a)}function ml(a,e){return te([lf,e.toBuffer()],a)}var dl=Buffer.from("locked_position","utf8");function Ma(a,e){return te([dl,e.toBuffer()],a)}function Wo(a,e){return te([dl,e.toBuffer()],a)}var mf=Buffer.from("support_mint","utf8");function va(a,e){return te([mf,e.toBuffer()],a)}import{PublicKey as Dt}from"@solana/web3.js";import{TOKEN_2022_PROGRAM_ID as pl}from"@solana/spl-token";import Ue from"bn.js";import we from"decimal.js";import dn from"bn.js";import Fa from"decimal.js";var Mi=class{static getfeeGrowthInside(e,t,n){let o=new dn(0),r=new dn(0);e.tickCurrent>=t.tick?(o=t.feeGrowthOutsideX64A,r=t.feeGrowthOutsideX64B):(o=e.feeGrowthGlobalX64A.sub(t.feeGrowthOutsideX64A),r=e.feeGrowthGlobalX64B.sub(t.feeGrowthOutsideX64B));let i=new dn(0),s=new dn(0);e.tickCurrent<n.tick?(i=n.feeGrowthOutsideX64A,s=n.feeGrowthOutsideX64B):(i=e.feeGrowthGlobalX64A.sub(n.feeGrowthOutsideX64A),s=e.feeGrowthGlobalX64B.sub(n.feeGrowthOutsideX64B));let c=le.wrappingSubU128(le.wrappingSubU128(e.feeGrowthGlobalX64A,o),i),u=le.wrappingSubU128(le.wrappingSubU128(e.feeGrowthGlobalX64B,r),s);return{feeGrowthInsideX64A:c,feeGrowthInsideBX64:u}}static GetPositionFees(e,t,n,o){let{feeGrowthInsideX64A:r,feeGrowthInsideBX64:i}=this.getfeeGrowthInside(e,n,o),s=le.mulDivFloor(le.wrappingSubU128(r,t.feeGrowthInsideLastX64A),t.liquidity,st),c=t.tokenFeesOwedA.add(s),u=le.mulDivFloor(le.wrappingSubU128(i,t.feeGrowthInsideLastX64B),t.liquidity,st),l=t.tokenFeesOwedB.add(u);return{tokenFeeAmountA:c,tokenFeeAmountB:l}}static GetPositionFeesV2(e,t,n,o){let{feeGrowthInsideX64A:r,feeGrowthInsideBX64:i}=this.getfeeGrowthInside(e,n,o),s=le.mulDivFloor(le.wrappingSubU128(r,t.feeGrowthInsideLastX64A),t.liquidity,st),c=t.tokenFeesOwedA.add(s),u=le.mulDivFloor(le.wrappingSubU128(i,t.feeGrowthInsideLastX64B),t.liquidity,st),l=t.tokenFeesOwedB.add(u);return{tokenFeeAmountA:c,tokenFeeAmountB:l}}static GetPositionRewardsV2(e,t,n,o){let r=[],i=this.getRewardGrowthInsideV2(e.tickCurrent,n,o,e.rewardInfos);for(let s=0;s<i.length;s++){let c=i[s],u=t.rewardInfos[s],l=le.wrappingSubU128(c,u.growthInsideLastX64),m=le.mulDivFloor(l,t.liquidity,st),p=u.rewardAmountOwed.add(m);r.push(p)}return r}static GetPositionRewards(e,t,n,o){let r=[],i=this.getRewardGrowthInside(e.tickCurrent,n,o,e.rewardInfos);for(let s=0;s<i.length;s++){let c=i[s],u=t.rewardInfos[s],l=le.wrappingSubU128(c,u.growthInsideLastX64),m=le.mulDivFloor(l,t.liquidity,st),p=u.rewardAmountOwed.add(m);r.push(p)}return r}static getRewardGrowthInside(e,t,n,o){let r=[];for(let i=0;i<o.length;i++){let s=new dn(0);t.liquidityGross.eqn(0)?s=o[i].rewardGrowthGlobalX64:e<t.tick?s=o[i].rewardGrowthGlobalX64.sub(t.rewardGrowthsOutsideX64[i]):s=t.rewardGrowthsOutsideX64[i];let c=new dn(0);n.liquidityGross.eqn(0)||(e<n.tick?c=n.rewardGrowthsOutsideX64[i]:c=o[i].rewardGrowthGlobalX64.sub(n.rewardGrowthsOutsideX64[i])),r.push(le.wrappingSubU128(le.wrappingSubU128(o[i].rewardGrowthGlobalX64,s),c))}return r}static getRewardGrowthInsideV2(e,t,n,o){let r=[];for(let i=0;i<o.length;i++){let s=new dn(0);t.liquidityGross.eqn(0)?s=o[i].rewardGrowthGlobalX64:e<t.tick?s=o[i].rewardGrowthGlobalX64.sub(t.rewardGrowthsOutsideX64[i]):s=t.rewardGrowthsOutsideX64[i];let c=new dn(0);n.liquidityGross.eqn(0)||(e<n.tick?c=n.rewardGrowthsOutsideX64[i]:c=o[i].rewardGrowthGlobalX64.sub(n.rewardGrowthsOutsideX64[i])),r.push(le.wrappingSubU128(le.wrappingSubU128(o[i].rewardGrowthGlobalX64,s),c))}return r}static getAmountsFromLiquidity({poolInfo:e,ownerPosition:t,liquidity:n,slippage:o,add:r,epochInfo:i}){var b,g,P,h;let s=se.priceToSqrtPriceX64(new Fa(e.price),e.mintA.decimals,e.mintB.decimals),c=se.getSqrtPriceX64FromTick(t.tickLower),u=se.getSqrtPriceX64FromTick(t.tickUpper),l=r?1+o:1-o,m=ke.getAmountsFromLiquidity(s,c,u,n,r),[p,d]=[xe(m.amountA,(b=e.mintA.extensions)==null?void 0:b.feeConfig,i,!0),xe(m.amountB,(g=e.mintB.extensions)==null?void 0:g.feeConfig,i,!0)],[f,y]=[xe(new dn(new Fa(m.amountA.toString()).mul(l).toFixed(0)),(P=e.mintA.extensions)==null?void 0:P.feeConfig,i,!0),xe(new dn(new Fa(m.amountB.toString()).mul(l).toFixed(0)),(h=e.mintB.extensions)==null?void 0:h.feeConfig,i,!0)];return{liquidity:n,amountA:p,amountB:d,amountSlippageA:f,amountSlippageB:y,expirationTime:on(p.expirationTime,d.expirationTime)}}};var df=15,he=class{static async getTickArrays(e,t,n,o,r,i,s){let c=[],u=Z.getTickArrayStartIndexByTick(o,r),l=Z.getInitializedTickArrayInRange(i,s,r,u,Math.floor(df/2));for(let d=0;d<l.length;d++){let{publicKey:f}=Ae(t,n,l[d]);c.push(f)}let m=(await tn(e,c)).map(d=>d!==null?vi.decode(d.data):null),p={};for(let d=0;d<c.length;d++){let f=m[d];f!==null&&(p[f.startTickIndex]=q(M({},f),{address:c[d]}))}return p}static nextInitializedTick(e,t,n,o,r,i){let{initializedTick:s,tickArrayAddress:c,tickArrayStartTickIndex:u}=this.nextInitializedTickInOneArray(e,t,n,o,r,i);for(;s==null||s.liquidityGross.lten(0);){if(u=Z.getNextTickArrayStartIndex(u,r,i),this.checkIsValidStartIndex(u,r))throw new Error("No enough initialized tickArray");let l=n[u];if(l===void 0)continue;let{nextTick:m,tickArrayAddress:p,tickArrayStartTickIndex:d}=this.firstInitializedTickInOneArray(e,t,l,i);[s,c,u]=[m,p,d]}if(s==null)throw new Error("No invaild tickArray cache");return{nextTick:s,tickArrayAddress:c,tickArrayStartTickIndex:u}}static nextInitializedTickArray(e,t,n,o,r){let i=Math.floor(e/he.tickCount(t)),s=n?Z.searchLowBitFromStart(o,r,i-1,1,t):Z.searchHightBitFromStart(o,r,i+1,1,t);return s.length>0?{isExist:!0,nextStartIndex:s[0]}:{isExist:!1,nextStartIndex:0}}static firstInitializedTickInOneArray(e,t,n,o){let r;if(o){let s=at-1;for(;s>=0;){let c=n.ticks[s];if(c.liquidityGross.gtn(0)){r=c;break}s=s-1}}else{let s=0;for(;s<at;){let c=n.ticks[s];if(c.liquidityGross.gtn(0)){r=c;break}s=s+1}}let{publicKey:i}=Ae(e,t,n.startTickIndex);return{nextTick:r,tickArrayAddress:i,tickArrayStartTickIndex:n.startTickIndex}}static nextInitializedTickInOneArray(e,t,n,o,r,i){let s=Z.getTickArrayStartIndexByTick(o,r),c=Math.floor((o-s)/r),u=n[s];if(u==null)return{initializedTick:void 0,tickArrayAddress:void 0,tickArrayStartTickIndex:s};let l;if(i)for(;c>=0;){let p=u.ticks[c];if(p.liquidityGross.gtn(0)){l=p;break}c=c-1}else for(c=c+1;c<at;){let p=u.ticks[c];if(p.liquidityGross.gtn(0)){l=p;break}c=c+1}let{publicKey:m}=Ae(e,t,s);return{initializedTick:l,tickArrayAddress:m,tickArrayStartTickIndex:u.startTickIndex}}static getArrayStartIndex(e,t){let n=this.tickCount(t);return Math.floor(e/n)*n}static checkIsValidStartIndex(e,t){if(Z.checkIsOutOfBoundary(e)){if(e>xt)return!1;let n=Z.getTickArrayStartIndexByTick(Pt,t);return e==n}return e%this.tickCount(t)==0}static tickCount(e){return at*e}};var Va=14,Kn=class{static maxTickInTickarrayBitmap(e){return e*at*lo}static getBitmapTickBoundary(e,t){let n=this.maxTickInTickarrayBitmap(t),o=Math.floor(Math.abs(e)/n);e<0&&Math.abs(e)%n!=0&&(o+=1);let r=n*o;return e<0?{minValue:-r,maxValue:-r+n}:{minValue:r,maxValue:r+n}}static nextInitializedTickArrayStartIndex(e,t,n,o){if(!he.checkIsValidStartIndex(t,n))throw Error("nextInitializedTickArrayStartIndex check error");let r=this.maxTickInTickarrayBitmap(n),i=o?t-he.tickCount(n):t+he.tickCount(n);if(i<-r||i>=r)return{isInit:!1,tickIndex:t};let s=n*at,c=i/s+512;i<0&&i%s!=0&&c--;let u=Math.abs(c);if(o){let l=e.shln(1024-u-1),m=sl(1024,l);if(m!==null){let p=(u-m-512)*s;return{isInit:!0,tickIndex:p}}else return{isInit:!1,tickIndex:-r}}else{let l=e.shrn(u),m=al(1024,l);if(m!==null){let p=(u+m-512)*s;return{isInit:!0,tickIndex:p}}else return{isInit:!1,tickIndex:r-he.tickCount(n)}}}},Fi=class{static getBitmapOffset(e,t){if(!he.checkIsValidStartIndex(e,t))throw new Error("No enough initialized tickArray");this.checkExtensionBoundary(e,t);let n=Kn.maxTickInTickarrayBitmap(t),o=Math.floor(Math.abs(e)/n)-1;return e<0&&Math.abs(e)%n===0&&o--,o}static getBitmap(e,t,n){let o=this.getBitmapOffset(e,t);return e<0?{offset:o,tickarrayBitmap:n.negativeTickArrayBitmap[o]}:{offset:o,tickarrayBitmap:n.positiveTickArrayBitmap[o]}}static checkExtensionBoundary(e,t){let{positiveTickBoundary:n,negativeTickBoundary:o}=this.extensionTickBoundary(t);if(e>=o&&e<n)throw Error("checkExtensionBoundary -> InvalidTickArrayBoundary")}static extensionTickBoundary(e){let t=Kn.maxTickInTickarrayBitmap(e),n=-t;if(xt<=t)throw Error(`extensionTickBoundary check error: ${xt}, ${t}`);if(n<=Pt)throw Error(`extensionTickBoundary check error: ${n}, ${Pt}`);return{positiveTickBoundary:t,negativeTickBoundary:n}}static checkTickArrayIsInit(e,t,n){let{tickarrayBitmap:o}=this.getBitmap(e,t,n),r=this.tickArrayOffsetInBitmap(e,t);return{isInitialized:Z.mergeTickArrayBitmap(o).testn(r),startIndex:e}}static nextInitializedTickArrayFromOneBitmap(e,t,n,o){let r=he.tickCount(t),i=n?e-r:e+r,{tickarrayBitmap:s}=this.getBitmap(i,t,o);return this.nextInitializedTickArrayInBitmap(s,i,t,n)}static nextInitializedTickArrayInBitmap(e,t,n,o){let{minValue:r,maxValue:i}=Kn.getBitmapTickBoundary(t,n),s=this.tickArrayOffsetInBitmap(t,n);if(o){let c=Z.mergeTickArrayBitmap(e).shln(lo-1-s),u=Oi(512,c)?null:Ca(512,c);if(u!==null){let l=t-u*he.tickCount(n);return{isInit:!0,tickIndex:l}}else return{isInit:!1,tickIndex:r}}else{let c=Z.mergeTickArrayBitmap(e).shrn(s),u=Oi(512,c)?null:Ra(512,c);if(u!==null){let l=t+u*he.tickCount(n);return{isInit:!0,tickIndex:l}}else return{isInit:!1,tickIndex:i-he.tickCount(n)}}}static tickArrayOffsetInBitmap(e,t){let n=Math.abs(e)%Kn.maxTickInTickarrayBitmap(t),o=Math.floor(n/he.tickCount(t));return e<0&&n!=0&&(o=lo-o),o}};var Fe=class{static getOutputAmountAndRemainAccounts(e,t,n,o,r,i=!1){let s=n.toBase58()===e.mintA.address,c=[],{isExist:u,startIndex:l,nextAccountMeta:m}=this.getFirstInitializedTickArray(e,s);if(!u||l===void 0||!m)throw new Error("Invalid tick array");c.push(m);let{allTrade:p,amountCalculated:d,accounts:f,sqrtPriceX64:y,feeAmount:b}=mo.swapCompute(e.programId,e.id,t,e.tickArrayBitmap,e.exBitmapInfo,s,e.ammConfig.tradeFeeRate,e.liquidity,e.tickCurrent,e.tickSpacing,e.sqrtPriceX64,o,l,r,i);return c.push(...f),{allTrade:p,expectedAmountOut:d.mul(Bn),remainingAccounts:c,executionPrice:y,feeAmount:b}}static getInputAmountAndRemainAccounts(e,t,n,o,r){let i=n.toBase58()===e.mintB.address,s=[],{isExist:c,startIndex:u,nextAccountMeta:l}=this.getFirstInitializedTickArray(e,i);if(!c||u===void 0||!l)throw new Error("Invalid tick array");try{let y=this.preInitializedTickArrayStartIndex(e,i);if(y.isExist){let{publicKey:b}=Ae(e.programId,e.id,y.nextStartIndex);s.push(b)}}catch{}s.push(l);let{amountCalculated:m,accounts:p,sqrtPriceX64:d,feeAmount:f}=mo.swapCompute(e.programId,e.id,t,e.tickArrayBitmap,e.exBitmapInfo,i,e.ammConfig.tradeFeeRate,e.liquidity,e.tickCurrent,e.tickSpacing,e.sqrtPriceX64,o.mul(Bn),u,r);return s.push(...p),{expectedAmountIn:m,remainingAccounts:s,executionPrice:d,feeAmount:f}}static getFirstInitializedTickArray(e,t){let{isInitialized:n,startIndex:o}=Fe.isOverflowDefaultTickarrayBitmap(e.tickSpacing,[e.tickCurrent])?Fi.checkTickArrayIsInit(he.getArrayStartIndex(e.tickCurrent,e.tickSpacing),e.tickSpacing,e.exBitmapInfo):Z.checkTickArrayIsInitialized(Z.mergeTickArrayBitmap(e.tickArrayBitmap),e.tickCurrent,e.tickSpacing);if(n){let{publicKey:s}=Ae(e.programId,e.id,o);return{isExist:!0,startIndex:o,nextAccountMeta:s}}let{isExist:r,nextStartIndex:i}=this.nextInitializedTickArrayStartIndex(e,he.getArrayStartIndex(e.tickCurrent,e.tickSpacing),t);if(r){let{publicKey:s}=Ae(e.programId,e.id,i);return{isExist:!0,startIndex:i,nextAccountMeta:s}}return{isExist:!1,nextAccountMeta:void 0,startIndex:void 0}}static preInitializedTickArrayStartIndex(e,t){let n=Math.floor(e.tickCurrent/he.tickCount(e.tickSpacing)),o=t?Z.searchHightBitFromStart(e.tickArrayBitmap,e.exBitmapInfo,n+1,1,e.tickSpacing):Z.searchLowBitFromStart(e.tickArrayBitmap,e.exBitmapInfo,n-1,1,e.tickSpacing);return o.length>0?{isExist:!0,nextStartIndex:o[0]}:{isExist:!1,nextStartIndex:0}}static nextInitializedTickArrayStartIndex(e,t,n){for(t=he.getArrayStartIndex(e.tickCurrent,e.tickSpacing);;){let{isInit:o,tickIndex:r}=Kn.nextInitializedTickArrayStartIndex(Z.mergeTickArrayBitmap(e.tickArrayBitmap),t,e.tickSpacing,n);if(o)return{isExist:!0,nextStartIndex:r};t=r;let{isInit:i,tickIndex:s}=Fi.nextInitializedTickArrayFromOneBitmap(t,e.tickSpacing,n,e.exBitmapInfo);if(i)return{isExist:!0,nextStartIndex:s};if(t=s,t<Pt||t>xt)return{isExist:!1,nextStartIndex:0}}}static async updatePoolRewardInfos({connection:e,apiPoolInfo:t,chainTime:n,poolLiquidity:o,rewardInfos:r}){var s,c,u;let i=[];for(let l=0;l<r.length;l++){let m=r[l],p=(u=(s=t.rewardDefaultInfos[l])==null?void 0:s.mint.programId)!=null?u:(c=await e.getAccountInfo(m.tokenMint))==null?void 0:c.owner;if(p===void 0)throw Error("get new reward mint info error");let d=q(M({},m),{perSecond:le.x64ToDecimal(m.emissionsPerSecondX64),remainingRewards:void 0,tokenProgramId:new Dt(p)});if(d.tokenMint.equals(Dt.default))continue;if(n<=d.openTime.toNumber()||o.eq(Pe)){i.push(d);continue}let f=new Ue(Math.min(d.endTime.toNumber(),n)),y=f.sub(d.lastUpdateTime),b=le.mulDivFloor(y,d.emissionsPerSecondX64,o),g=d.rewardGrowthGlobalX64.add(b),P=le.mulDivFloor(y,d.emissionsPerSecondX64,st),h=d.rewardTotalEmissioned.add(P);i.push(q(M({},d),{rewardGrowthGlobalX64:g,rewardTotalEmissioned:h,lastUpdateTime:f}))}return i}static isOverflowDefaultTickarrayBitmap(e,t){let{maxTickBoundary:n,minTickBoundary:o}=this.tickRange(e);for(let r of t){let i=Z.getTickArrayStartIndexByTick(r,e);if(i>=n||i<o)return!0}return!1}static tickRange(e){let t=Kn.maxTickInTickarrayBitmap(e),n=-t;return t>xt&&(t=he.getArrayStartIndex(xt,e)+he.tickCount(e)),n<Pt&&(n=he.getArrayStartIndex(Pt,e)),{maxTickBoundary:t,minTickBoundary:n}}static get_tick_array_offset(e,t){if(!he.checkIsValidStartIndex(e,t))throw new Error("No enough initialized tickArray");return e/he.tickCount(t)*lo}static async fetchExBitmaps({connection:e,exBitmapAddress:t,batchRequest:n}){let o=await ve(e,t.map(i=>({pubkey:i})),{batchRequest:n}),r={};for(let i of o)i.accountInfo!==null&&(r[i.pubkey.toString()]=yl.decode(i.accountInfo.data));return r}static async fetchMultiplePoolTickArrays({connection:e,poolKeys:t,batchRequest:n}){let o={},r=[];for(let c of t){let u=Z.getTickArrayStartIndexByTick(c.tickCurrent,c.tickSpacing),l=Z.getInitializedTickArrayInRange(c.tickArrayBitmap,c.exBitmapInfo,c.tickSpacing,u,7);for(let m of l){let{publicKey:p}=Ae(c.programId,c.id,m);r.push({pubkey:p}),o[p.toString()]=c.id}}let i=await ve(e,r,{batchRequest:n}),s={};for(let c of i){if(!c.accountInfo)continue;let u=o[c.pubkey.toString()];if(!u)continue;s[u.toString()]===void 0&&(s[u.toString()]={});let l=vi.decode(c.accountInfo.data);s[u.toString()][l.startTickIndex]=q(M({},l),{address:c.pubkey})}return s}static async fetchPoolsAccountPosition({pools:e,connection:t,ownerInfo:n,batchRequest:o=!1,updateOwnerRewardAndFee:r=!0}){var s;let i=[];for(let c=0;c<e.length;c++){let u=e[c];u!==null&&(i.find(l=>l.equals(u.state.programId))||i.push(u.state.programId))}if(n){let c=n.tokenAccounts.map(p=>p.accountInfo.mint),u=[];for(let p of c)for(let d of i)u.push(Kt(d,p).publicKey);let l=await tn(t,u,{batchRequest:o}),m={};for(let p of l){if(p===null)continue;let d=Do.decode(p.data),f=d.poolId.toString(),y=e.find(x=>x.state.id.toBase58()===f);if(y===void 0)continue;let b=y.state,g=Z._getTickPriceLegacy({poolInfo:b,tick:d.tickLower,baseIn:!0}),P=Z._getTickPriceLegacy({poolInfo:b,tick:d.tickUpper,baseIn:!0}),{amountA:h,amountB:I}=ke.getAmountsFromLiquidity(b.sqrtPriceX64,g.tickSqrtPriceX64,P.tickSqrtPriceX64,d.liquidity,!1),T=1/(1-Math.sqrt(Math.sqrt(g.price.div(P.price).toNumber())));y.positionAccount=[...(s=y.positionAccount)!=null?s:[],{poolId:d.poolId,nftMint:d.nftMint,priceLower:g.price,priceUpper:P.price,amountA:h,amountB:I,tickLower:d.tickLower,tickUpper:d.tickUpper,liquidity:d.liquidity,feeGrowthInsideLastX64A:d.feeGrowthInsideLastX64A,feeGrowthInsideLastX64B:d.feeGrowthInsideLastX64B,tokenFeesOwedA:d.tokenFeesOwedA,tokenFeesOwedB:d.tokenFeesOwedB,rewardInfos:d.rewardInfos.map(x=>q(M({},x),{pendingReward:new Ue(0)})),leverage:T,tokenFeeAmountA:new Ue(0),tokenFeeAmountB:new Ue(0)}];let w=await Z.getTickArrayAddressByTick(y.state.programId,d.poolId,d.tickLower,y.state.tickSpacing),K=await Z.getTickArrayAddressByTick(y.state.programId,d.poolId,d.tickUpper,y.state.tickSpacing);m[`${y.state.programId.toString()}-${d.poolId.toString()}-${d.tickLower}`]=w,m[`${y.state.programId.toString()}-${d.poolId.toString()}-${d.tickUpper}`]=K}if(r){let p=Object.values(m),d=await tn(t,p,{batchRequest:o}),f={};for(let y=0;y<p.length;y++){let b=d[y];if(b===null)continue;let g=p[y].toString();f[g]=vi.decode(b.data)}for(let{state:y,positionAccount:b}of e)if(!!b)for(let g of b){let P=`${y.programId.toString()}-${y.id.toString()}-${g.tickLower}`,h=`${y.programId.toString()}-${y.id.toString()}-${g.tickUpper}`,I=f[m[P].toString()],T=f[m[h].toString()],w=I.ticks[Z.getTickOffsetInArray(g.tickLower,y.tickSpacing)],K=T.ticks[Z.getTickOffsetInArray(g.tickUpper,y.tickSpacing)],{tokenFeeAmountA:x,tokenFeeAmountB:S}=await Mi.GetPositionFees(y,g,w,K),B=await Mi.GetPositionRewards(y,g,w,K);g.tokenFeeAmountA=x.gte(new Ue(0))?x:new Ue(0),g.tokenFeeAmountB=S.gte(new Ue(0))?S:new Ue(0);for(let R=0;R<B.length;R++)g.rewardInfos[R].pendingReward=B[R].gte(new Ue(0))?B[R]:new Ue(0)}}}return e}static computeAmountOut({poolInfo:e,tickArrayCache:t,baseMint:n,epochInfo:o,amountIn:r,slippage:i,priceLimit:s=new we(0),catchLiquidityInsufficient:c=!1}){var C;let u,l=n.toBase58()===e.mintA.address,[m,p]=l?[e.mintA.extensions.feeConfig,e.mintB.extensions.feeConfig]:[e.mintB.extensions.feeConfig,e.mintA.extensions.feeConfig];s.equals(new we(0))?u=l?Yt.add(new Ue(1)):Qt.sub(new Ue(1)):u=se.priceToSqrtPriceX64(s,e.mintA.decimals,e.mintB.decimals);let d=xe(r,m,o,!1),{allTrade:f,expectedAmountOut:y,remainingAccounts:b,executionPrice:g,feeAmount:P}=Fe.getOutputAmountAndRemainAccounts(e,t,n,d.amount.sub((C=d.fee)!=null?C:Pe),u,c),h=xe(y,p,o,!1),I=se.sqrtPriceX64ToPrice(g,e.mintA.decimals,e.mintB.decimals),T=l?I:new we(1).div(I),w=y.mul(new Ue(Math.floor((1-i)*1e10))).div(new Ue(1e10)),K=xe(w,p,o,!1),x=l?e.currentPrice:new we(1).div(e.currentPrice),S=new we(T).sub(x).abs(),B=x,R=new Qe(new we(S).mul(10**15).toFixed(0),new we(B).mul(10**15).toFixed(0));return{allTrade:f,realAmountIn:d,amountOut:h,minAmountOut:K,expirationTime:on(d.expirationTime,h.expirationTime),currentPrice:e.currentPrice,executionPrice:T,priceImpact:R,fee:P,remainingAccounts:b,executionPriceX64:g}}static computeAmountOutFormat({poolInfo:e,tickArrayCache:t,amountIn:n,tokenOut:o,slippage:r,epochInfo:i,catchLiquidityInsufficient:s=!1}){let c=o.address===e.mintB.address,[u,l]=c?[e.mintA,e.mintB]:[e.mintB,e.mintA],[m,p]=[new Ke(q(M({},u),{mint:u.address,isToken2022:u.programId===pl.toBase58()})),new Ke(q(M({},l),{mint:l.address,isToken2022:l.programId===pl.toBase58()}))],{allTrade:d,realAmountIn:f,amountOut:y,minAmountOut:b,expirationTime:g,currentPrice:P,executionPrice:h,priceImpact:I,fee:T,remainingAccounts:w,executionPriceX64:K}=Fe.computeAmountOut({poolInfo:e,tickArrayCache:t,baseMint:new Dt(u.address),amountIn:n,slippage:r,epochInfo:i,catchLiquidityInsufficient:s}),x=q(M({},f),{amount:new Ie(m,f.amount),fee:f.fee===void 0?void 0:new Ie(m,f.fee)}),S=q(M({},y),{amount:new Ie(p,y.amount),fee:y.fee===void 0?void 0:new Ie(p,y.fee)}),B=q(M({},b),{amount:new Ie(p,b.amount),fee:b.fee===void 0?void 0:new Ie(p,b.fee)}),R=new lt({baseToken:m,denominator:new Ue(10).pow(new Ue(20+m.decimals)),quoteToken:p,numerator:P.mul(new we(10**(20+p.decimals))).toFixed(0)}),C=new lt({baseToken:m,denominator:new Ue(10).pow(new Ue(20+m.decimals)),quoteToken:p,numerator:h.mul(new we(10**(20+p.decimals))).toFixed(0)}),v=new Ie(m,T);return{allTrade:d,realAmountIn:x,amountOut:S,minAmountOut:B,expirationTime:g,currentPrice:R,executionPrice:C,priceImpact:I,fee:v,remainingAccounts:w,executionPriceX64:K}}static computeAmountIn({poolInfo:e,tickArrayCache:t,baseMint:n,epochInfo:o,amountOut:r,slippage:i,priceLimit:s=new we(0)}){var B;let c=n.toBase58()===e.mintA.address,u={[e.mintA.address]:e.mintA.extensions.feeConfig,[e.mintB.address]:e.mintB.extensions.feeConfig},l;s.equals(new we(0))?l=c?Qt.sub(new Ue(1)):Yt.add(new Ue(1)):l=se.priceToSqrtPriceX64(s,e.mintA.decimals,e.mintB.decimals);let m=xe(r,u[n.toString()],o,!0),{expectedAmountIn:p,remainingAccounts:d,executionPrice:f,feeAmount:y}=Fe.getInputAmountAndRemainAccounts(e,t,n,m.amount.sub((B=m.fee)!=null?B:Pe),l),b=c?e.mintB.address:e.mintA.address,g=xe(p,u[b],o,!1),P=se.sqrtPriceX64ToPrice(f,e.mintA.decimals,e.mintB.decimals),h=c?P:new we(1).div(P),I=p.mul(new Ue(Math.floor((1+i)*1e10))).div(new Ue(1e10)),T=xe(I,u[b],o,!0),w=c?e.currentPrice:new we(1).div(e.currentPrice),K=new we(h).sub(w).abs(),x=w,S=new Qe(new we(K).mul(10**15).toFixed(0),new we(x).mul(10**15).toFixed(0));return{amountIn:g,maxAmountIn:T,realAmountOut:m,expirationTime:on(g.expirationTime,m.expirationTime),currentPrice:e.currentPrice,executionPrice:h,priceImpact:S,fee:y,remainingAccounts:d}}static estimateAprsForPriceRangeMultiplier({poolInfo:e,aprType:t,positionTickLowerIndex:n,positionTickUpperIndex:o}){var f,y,b;let r=e[t],i=Z.getTickPrice({poolInfo:e,tick:n,baseIn:!0}).price.toNumber(),s=Z.getTickPrice({poolInfo:e,tick:o,baseIn:!0}).price.toNumber(),c=Math.max(i,r.priceMin),l=Math.min(s,r.priceMax)-c,m=s-i,p=r.priceMax-r.priceMin,d;return l<=0?d=0:m===l?d=p/l:p===l?d=l/m:d=l/p*(l/m),{feeApr:r.feeApr*d,rewardsApr:[((f=r.rewardApr[0])!=null?f:0)*d,((y=r.rewardApr[1])!=null?y:0)*d,((b=r.rewardApr[2])!=null?b:0)*d],apr:r.apr*d}}static estimateAprsForPriceRangeDelta({poolInfo:e,poolLiquidity:t,aprType:n,mintPrice:o,liquidity:r,positionTickLowerIndex:i,positionTickUpperIndex:s,chainTime:c}){let u=n==="day"?1:n==="week"?7:n==="month"?30:0,l=e[n],m=o[bt(e.mintA.address).toString()],p=o[bt(e.mintB.address).toString()],d=e.mintA.decimals,f=e.mintB.decimals;if(!l||!m||!p)return{feeApr:0,rewardsApr:[0,0,0],apr:0};let y=se.priceToSqrtPriceX64(new we(e.price),e.mintA.decimals,e.mintB.decimals),b=se.getSqrtPriceX64FromTick(i),g=se.getSqrtPriceX64FromTick(s),{amountSlippageA:P,amountSlippageB:h}=ke.getAmountsFromLiquidityWithSlippage(y,b,g,t,!1,!1,0),{amountSlippageA:I,amountSlippageB:T}=ke.getAmountsFromLiquidityWithSlippage(y,b,g,r,!1,!1,0),w=new we(P.toString()).div(new we(10).pow(d)).mul(m.value).add(new we(h.toString()).div(new we(10).pow(f)).mul(p.value)),K=new we(I.toString()).div(new we(10).pow(d)).mul(m.value).add(new we(T.toString()).div(new we(10).pow(f)).mul(p.value)),x=new we(1).div(w.add(K)),B=new we(l.volumeFee).mul(365).div(u).mul(x).mul(100).toNumber(),R=3600*24*365,C=e.rewardDefaultInfos.map(v=>{var E,X;let L=v.mint.decimals,N=o[v.mint.address];return c<((E=v.startTime)!=null?E:0)||c>((X=v.endTime)!=null?X:0)||!v.perSecond||!N||L===void 0?0:new we(N.value).mul(new we(v.perSecond).mul(R)).div(new we(10).pow(L)).mul(x).mul(100).toNumber()});return{feeApr:B,rewardsApr:C,apr:B+C.reduce((v,L)=>v+L,0)}}static async getLiquidityAmountOutFromAmountIn({poolInfo:e,inputA:t,tickLower:n,tickUpper:o,amount:r,slippage:i,add:s,epochInfo:c,amountHasFee:u}){var g,P;let l=se.priceToSqrtPriceX64(new we(e.price),e.mintA.decimals,e.mintB.decimals),m=se.getSqrtPriceX64FromTick(n),p=se.getSqrtPriceX64FromTick(o),d=xe(r,(g=e[t?"mintA":"mintB"].extensions)==null?void 0:g.feeConfig,c,!u),f=new Ue(new we(d.amount.sub((P=d.fee)!=null?P:Pe).toString()).toFixed(0)),y;if(l.lte(m))y=t?ke.getLiquidityFromTokenAmountA(m,p,f,!s):new Ue(0);else if(l.lte(p)){let h=ke.getLiquidityFromTokenAmountA(l,p,f,!s),I=ke.getLiquidityFromTokenAmountB(m,l,f);y=t?h:I}else y=t?new Ue(0):ke.getLiquidityFromTokenAmountB(m,p,f);let b=await Fe.getAmountsFromLiquidity({epochInfo:c,poolInfo:e,tickLower:n,tickUpper:o,liquidity:y,slippage:i,add:s});return{liquidity:y,amountA:t?d:b.amountA,amountB:t?b.amountB:d,amountSlippageA:t?d:b.amountSlippageA,amountSlippageB:t?b.amountSlippageB:d,expirationTime:b.expirationTime}}static async getAmountsFromLiquidity({epochInfo:e,poolInfo:t,tickLower:n,tickUpper:o,liquidity:r,slippage:i,add:s}){var b,g,P,h;let c=se.getSqrtPriceX64FromTick(n),u=se.getSqrtPriceX64FromTick(o),l=s?1+i:1-i,m=ke.getAmountsFromLiquidity(se.priceToSqrtPriceX64(new we(t.price),t.mintA.decimals,t.mintB.decimals),c,u,r,s),[p,d]=[xe(m.amountA,(b=t.mintA.extensions)==null?void 0:b.feeConfig,e,!0),xe(m.amountB,(g=t.mintB.extensions)==null?void 0:g.feeConfig,e,!0)],[f,y]=[xe(m.amountA.muln(l),(P=t.mintA.extensions)==null?void 0:P.feeConfig,e,!0),xe(m.amountB.muln(l),(h=t.mintB.extensions)==null?void 0:h.feeConfig,e,!0)];return{liquidity:r,amountA:p,amountB:d,amountSlippageA:f,amountSlippageB:y,expirationTime:on(p.expirationTime,d.expirationTime)}}static async fetchComputeMultipleClmmInfo({connection:e,poolList:t,rpcDataMap:n={}}){let o=t.filter(c=>!n[c.id]).map(c=>new Dt(c.id));(await tn(e,o)).forEach((c,u)=>{!c||(n[o[u].toBase58()]=po.decode(c.data))});let i=t.map(c=>$e(new Dt(c.programId),new Dt(c.id)).publicKey),s=await Fe.fetchExBitmaps({connection:e,exBitmapAddress:i,batchRequest:!1});return t.reduce((c,u)=>q(M({},c),{[u.id]:q(M({},n[u.id]),{id:new Dt(u.id),version:6,programId:new Dt(u.programId),mintA:u.mintA,mintB:u.mintB,ammConfig:q(M({},u.config),{id:new Dt(u.config.id),fundOwner:""}),currentPrice:new we(u.price),exBitmapAccount:$e(new Dt(u.programId),new Dt(u.id)).publicKey,exBitmapInfo:s[$e(new Dt(u.programId),new Dt(u.id)).publicKey.toBase58()],startTime:n[u.id].startTime.toNumber(),rewardInfos:n[u.id].rewardInfos})}),{})}static async fetchComputeClmmInfo({connection:e,poolInfo:t,rpcData:n}){return(await this.fetchComputeMultipleClmmInfo({connection:e,rpcDataMap:n?{[t.id]:n}:void 0,poolList:[t]}))[t.id]}};function tI({poolInfo:a,tickLower:e,tickUpper:t,amountA:n,amountB:o,slippage:r,add:i,epochInfo:s,amountHasFee:c}){var h,I,T,w;let[u,l,m,p]=e<t?[e,t,n,o]:[t,e,o,n],d=se.priceToSqrtPriceX64(new we(a.price),a.mintA.decimals,a.mintB.decimals),f=se.getSqrtPriceX64FromTick(u),y=se.getSqrtPriceX64FromTick(l),[b,g]=[xe(m,(h=a.mintA.extensions)==null?void 0:h.feeConfig,s,!c),xe(p,(I=a.mintB.extensions)==null?void 0:I.feeConfig,s,!c)],P=ke.getLiquidityFromTokenAmounts(d,f,y,b.amount.sub((T=b.fee)!=null?T:Pe),g.amount.sub((w=g.fee)!=null?w:Pe));return ke.getAmountsOutFromLiquidity({poolInfo:a,tickLower:e,tickUpper:t,liquidity:P,slippage:r,add:i,epochInfo:s,amountAddFee:!c})}var _a={volume:0,volumeQuote:0,volumeFee:0,apr:0,feeApr:0,priceMin:0,priceMax:0,rewardApr:[]};function fl(a){return q(M({},a),{type:"Concentrated",programId:a.programId.toString(),id:a.id.toString(),rewardDefaultInfos:[],rewardDefaultPoolInfos:"Clmm",price:a.currentPrice.toNumber(),mintAmountA:0,mintAmountB:0,feeRate:a.ammConfig.tradeFeeRate,openTime:a.startTime.toString(),tvl:0,day:_a,week:_a,month:_a,pooltype:[],farmUpcomingCount:0,farmOngoingCount:0,farmFinishedCount:0,burnPercent:0,config:q(M({},a.ammConfig),{id:a.ammConfig.id.toString(),defaultRange:0,defaultRangePoint:[]})})}var le=class{static mulDivRoundingUp(e,t,n){let o=e.mul(t),r=o.div(n);return o.mod(n).eq(Pe)||(r=r.add(Wt)),r}static mulDivFloor(e,t,n){if(n.eq(Pe))throw new Error("division by 0");return e.mul(t).div(n)}static mulDivCeil(e,t,n){if(n.eq(Pe))throw new Error("division by 0");return e.mul(t).add(n.sub(Wt)).div(n)}static x64ToDecimal(e,t){return new pn(e.toString()).div(pn.pow(2,64)).toDecimalPlaces(t)}static decimalToX64(e){return new fe(e.mul(pn.pow(2,64)).floor().toFixed())}static wrappingSubU128(e,t){return e.add(Er).sub(t).mod(Er)}};function dt(a,e){return Ea(a.mul(e),64,256)}function pf(a,e,t){let n=a.toTwos(t).shln(e);return n.imaskn(t+1),n.fromTwos(t)}function Ea(a,e,t){let n=a.toTwos(t).shrn(e);return n.imaskn(t-e+1),n.fromTwos(t-e)}var se=class{static sqrtPriceX64ToPrice(e,t,n){return le.x64ToDecimal(e).pow(2).mul(pn.pow(10,t-n))}static priceToSqrtPriceX64(e,t,n){return le.decimalToX64(e.mul(pn.pow(10,n-t)).sqrt())}static getNextSqrtPriceX64FromInput(e,t,n,o){if(!e.gt(Pe))throw new Error("sqrtPriceX64 must greater than 0");if(!t.gt(Pe))throw new Error("liquidity must greater than 0");return o?this.getNextSqrtPriceFromTokenAmountARoundingUp(e,t,n,!0):this.getNextSqrtPriceFromTokenAmountBRoundingDown(e,t,n,!0)}static getNextSqrtPriceX64FromOutput(e,t,n,o){if(!e.gt(Pe))throw new Error("sqrtPriceX64 must greater than 0");if(!t.gt(Pe))throw new Error("liquidity must greater than 0");return o?this.getNextSqrtPriceFromTokenAmountBRoundingDown(e,t,n,!1):this.getNextSqrtPriceFromTokenAmountARoundingUp(e,t,n,!1)}static getNextSqrtPriceFromTokenAmountARoundingUp(e,t,n,o){if(n.eq(Pe))return e;let r=t.shln(Li);if(o){let i=r,s=r.add(n.mul(e));return s.gte(i)?le.mulDivCeil(i,e,s):le.mulDivRoundingUp(i,Wt,i.div(e).add(n))}else{let i=n.mul(e);if(!r.gt(i))throw new Error("getNextSqrtPriceFromTokenAmountARoundingUp,liquidityLeftShift must gt amountMulSqrtPrice");let s=r.sub(i);return le.mulDivCeil(r,e,s)}}static getNextSqrtPriceFromTokenAmountBRoundingDown(e,t,n,o){let r=n.shln(Li);if(o)return e.add(r.div(t));{let i=le.mulDivRoundingUp(r,Wt,t);if(!e.gt(i))throw new Error("getNextSqrtPriceFromTokenAmountBRoundingDown sqrtPriceX64 must gt amountDivLiquidity");return e.sub(i)}}static getSqrtPriceX64FromTick(e){if(!Number.isInteger(e))throw new Error("tick must be integer");if(e<Pt||e>xt)throw new Error("tick must be in MIN_TICK and MAX_TICK");let t=e<0?e*-1:e,n=(t&1)!=0?new fe("18445821805675395072"):new fe("18446744073709551616");return(t&2)!=0&&(n=dt(n,new fe("18444899583751176192"))),(t&4)!=0&&(n=dt(n,new fe("18443055278223355904"))),(t&8)!=0&&(n=dt(n,new fe("18439367220385607680"))),(t&16)!=0&&(n=dt(n,new fe("18431993317065453568"))),(t&32)!=0&&(n=dt(n,new fe("18417254355718170624"))),(t&64)!=0&&(n=dt(n,new fe("18387811781193609216"))),(t&128)!=0&&(n=dt(n,new fe("18329067761203558400"))),(t&256)!=0&&(n=dt(n,new fe("18212142134806163456"))),(t&512)!=0&&(n=dt(n,new fe("17980523815641700352"))),(t&1024)!=0&&(n=dt(n,new fe("17526086738831433728"))),(t&2048)!=0&&(n=dt(n,new fe("16651378430235570176"))),(t&4096)!=0&&(n=dt(n,new fe("15030750278694412288"))),(t&8192)!=0&&(n=dt(n,new fe("12247334978884435968"))),(t&16384)!=0&&(n=dt(n,new fe("8131365268886854656"))),(t&32768)!=0&&(n=dt(n,new fe("3584323654725218816"))),(t&65536)!=0&&(n=dt(n,new fe("696457651848324352"))),(t&131072)!=0&&(n=dt(n,new fe("26294789957507116"))),(t&262144)!=0&&(n=dt(n,new fe("37481735321082"))),e>0&&(n=el.div(n)),n}static getTickFromPrice(e,t,n){return se.getTickFromSqrtPriceX64(se.priceToSqrtPriceX64(e,t,n))}static getTickFromSqrtPriceX64(e){if(e.gt(Qt)||e.lt(Yt))throw new Error("Provided sqrtPrice is not within the supported sqrtPrice range.");let t=e.bitLength()-1,n=new fe(t-64),o=pf(n,32,128),r=new fe("8000000000000000","hex"),i=0,s=new fe(0),c=t>=64?e.shrn(t-63):e.shln(63-t);for(;r.gt(new fe(0))&&i<tl;){c=c.mul(c);let f=c.shrn(127);c=c.shrn(63+f.toNumber()),s=s.add(r.mul(f)),r=r.shrn(1),i+=1}let u=s.shrn(32),m=o.add(u).mul(new fe(nl)),p=Ea(m.sub(new fe(ol)),64,128).toNumber(),d=Ea(m.add(new fe(il)),64,128).toNumber();return p==d?p:se.getSqrtPriceX64FromTick(d).lte(e)?d:p}},fo=class{static getTickWithPriceAndTickspacing(e,t,n,o){let i=se.getTickFromSqrtPriceX64(se.priceToSqrtPriceX64(e,n,o))/t;return i<0?i=Math.floor(i):i=Math.ceil(i),i*t}static roundPriceWithTickspacing(e,t,n,o){let r=fo.getTickWithPriceAndTickspacing(e,t,n,o),i=se.getSqrtPriceX64FromTick(r);return se.sqrtPriceX64ToPrice(i,n,o)}},ke=class{static addDelta(e,t){return e.add(t)}static getTokenAmountAFromLiquidity(e,t,n,o){if(e.gt(t)&&([e,t]=[t,e]),!e.gt(Pe))throw new Error("sqrtPriceX64A must greater than 0");let r=n.ushln(Li),i=t.sub(e);return o?le.mulDivRoundingUp(le.mulDivCeil(r,i,t),Wt,e):le.mulDivFloor(r,i,t).div(e)}static getTokenAmountBFromLiquidity(e,t,n,o){if(e.gt(t)&&([e,t]=[t,e]),!e.gt(Pe))throw new Error("sqrtPriceX64A must greater than 0");return o?le.mulDivCeil(n,t.sub(e),st):le.mulDivFloor(n,t.sub(e),st)}static getLiquidityFromTokenAmountA(e,t,n,o){e.gt(t)&&([e,t]=[t,e]);let r=n.mul(e).mul(t),i=t.sub(e),s=r.div(i);return o?le.mulDivRoundingUp(s,Wt,Ri):s.shrn(Li)}static getLiquidityFromTokenAmountB(e,t,n){return e.gt(t)&&([e,t]=[t,e]),le.mulDivFloor(n,Ri,t.sub(e))}static getLiquidityFromTokenAmounts(e,t,n,o,r){if(t.gt(n)&&([t,n]=[n,t]),e.lte(t))return ke.getLiquidityFromTokenAmountA(t,n,o,!1);if(e.lt(n)){let i=ke.getLiquidityFromTokenAmountA(e,n,o,!1),s=ke.getLiquidityFromTokenAmountB(t,e,r);return i.lt(s)?i:s}else return ke.getLiquidityFromTokenAmountB(t,n,r)}static getAmountsFromLiquidity(e,t,n,o,r){if(t.gt(n)&&([t,n]=[n,t]),e.lte(t))return{amountA:ke.getTokenAmountAFromLiquidity(t,n,o,r),amountB:new fe(0)};if(e.lt(n)){let i=ke.getTokenAmountAFromLiquidity(e,n,o,r),s=ke.getTokenAmountBFromLiquidity(t,e,o,r);return{amountA:i,amountB:s}}else return{amountA:new fe(0),amountB:ke.getTokenAmountBFromLiquidity(t,n,o,r)}}static getAmountsFromLiquidityWithSlippage(e,t,n,o,r,i,s){let{amountA:c,amountB:u}=ke.getAmountsFromLiquidity(e,t,n,o,i),l=r?1+s:1-s,m=new fe(new pn(c.toString()).mul(l).toFixed(0)),p=new fe(new pn(u.toString()).mul(l).toFixed(0));return{amountSlippageA:m,amountSlippageB:p}}static getAmountsOutFromLiquidity({poolInfo:e,tickLower:t,tickUpper:n,liquidity:o,slippage:r,add:i,epochInfo:s,amountAddFee:c}){var P,h,I,T;let u=se.priceToSqrtPriceX64(new pn(e.price),e.mintA.decimals,e.mintB.decimals),l=se.getSqrtPriceX64FromTick(t),m=se.getSqrtPriceX64FromTick(n),p=i?1+r:1-r,d=ke.getAmountsFromLiquidity(u,l,m,o,i),[f,y]=[xe(d.amountA,(P=e.mintA.extensions)==null?void 0:P.feeConfig,s,c),xe(d.amountB,(h=e.mintB.extensions)==null?void 0:h.feeConfig,s,c)],[b,g]=[xe(new fe(new pn(d.amountA.toString()).mul(p).toFixed(0)),(I=e.mintA.extensions)==null?void 0:I.feeConfig,s,c),xe(new fe(new pn(d.amountB.toString()).mul(p).toFixed(0)),(T=e.mintB.extensions)==null?void 0:T.feeConfig,s,c)];return{liquidity:o,amountA:f,amountB:y,amountSlippageA:b,amountSlippageB:g,expirationTime:on(f.expirationTime,y.expirationTime)}}},mo=class{static swapCompute(e,t,n,o,r,i,s,c,u,l,m,p,d,f,y=!1){if(p.eq(Pe))throw new Error("amountSpecified must not be 0");if(f||(f=i?Yt.add(Wt):Qt.sub(Wt)),i){if(f.lt(Yt))throw new Error("sqrtPriceX64 must greater than MIN_SQRT_PRICE_X64");if(f.gte(m))throw new Error("sqrtPriceX64 must smaller than current")}else{if(f.gt(Qt))throw new Error("sqrtPriceX64 must smaller than MAX_SQRT_PRICE_X64");if(f.lte(m))throw new Error("sqrtPriceX64 must greater than current")}let b=p.gt(Pe),g={amountSpecifiedRemaining:p,amountCalculated:Pe,sqrtPriceX64:m,tick:u>d?Math.min(d+he.tickCount(l)-1,u):d,accounts:[],liquidity:c,feeAmount:new fe(0)},P=d,h=n[d],I=0,T=!i&&h.startTickIndex===g.tick;for(;!g.amountSpecifiedRemaining.eq(Pe)&&!g.sqrtPriceX64.eq(f);){I>10;let w={};w.sqrtPriceStartX64=g.sqrtPriceX64;let K=Z.nextInitTick(h,g.tick,l,i,T),x=K||null,S=null;if(!(x!=null&&x.liquidityGross.gtn(0))){let R=Fe.nextInitializedTickArrayStartIndex({tickCurrent:g.tick,tickSpacing:l,tickArrayBitmap:o,exBitmapInfo:r},P,i);if(!R.isExist){if(y)return{allTrade:!1,amountSpecifiedRemaining:g.amountSpecifiedRemaining,amountCalculated:g.amountCalculated,feeAmount:g.feeAmount,sqrtPriceX64:g.sqrtPriceX64,liquidity:g.liquidity,tickCurrent:g.tick,accounts:g.accounts};throw Error("swapCompute LiquidityInsufficient")}P=R.nextStartIndex;let{publicKey:C}=Ae(e,t,P);S=C,h=n[P];try{x=Z.firstInitializedTick(h,i)}catch{throw Error("not found next tick info")}}w.tickNext=x.tick,w.initialized=x.liquidityGross.gtn(0),d!==P&&S&&(g.accounts.push(S),d=P),w.tickNext<Pt?w.tickNext=Pt:w.tickNext>xt&&(w.tickNext=xt),w.sqrtPriceNextX64=se.getSqrtPriceX64FromTick(w.tickNext);let B;if(i&&w.sqrtPriceNextX64.lt(f)||!i&&w.sqrtPriceNextX64.gt(f)?B=f:B=w.sqrtPriceNextX64,[g.sqrtPriceX64,w.amountIn,w.amountOut,w.feeAmount]=mo.swapStepCompute(g.sqrtPriceX64,B,g.liquidity,g.amountSpecifiedRemaining,s,i),g.feeAmount=g.feeAmount.add(w.feeAmount),b?(g.amountSpecifiedRemaining=g.amountSpecifiedRemaining.sub(w.amountIn.add(w.feeAmount)),g.amountCalculated=g.amountCalculated.sub(w.amountOut)):(g.amountSpecifiedRemaining=g.amountSpecifiedRemaining.add(w.amountOut),g.amountCalculated=g.amountCalculated.add(w.amountIn.add(w.feeAmount))),g.sqrtPriceX64.eq(w.sqrtPriceNextX64)){if(w.initialized){let R=x.liquidityNet;i&&(R=R.mul(Bn)),g.liquidity=ke.addDelta(g.liquidity,R)}T=w.tickNext!=g.tick&&!i&&h.startTickIndex===w.tickNext,g.tick=i?w.tickNext-1:w.tickNext}else if(g.sqrtPriceX64!=w.sqrtPriceStartX64){let R=se.getTickFromSqrtPriceX64(g.sqrtPriceX64);T=R!=g.tick&&!i&&h.startTickIndex===R,g.tick=R}++I}try{let{nextStartIndex:w,isExist:K}=he.nextInitializedTickArray(g.tick,l,i,o,r);K&&d!==w&&(g.accounts.push(Ae(e,t,w).publicKey),d=w)}catch{}return{allTrade:!0,amountSpecifiedRemaining:Pe,amountCalculated:g.amountCalculated,feeAmount:g.feeAmount,sqrtPriceX64:g.sqrtPriceX64,liquidity:g.liquidity,tickCurrent:g.tick,accounts:g.accounts}}static swapStepCompute(e,t,n,o,r,i){let s={sqrtPriceX64Next:new fe(0),amountIn:new fe(0),amountOut:new fe(0),feeAmount:new fe(0)},c=o.gte(Pe);if(c){let l=le.mulDivFloor(o,qr.sub(new fe(r.toString())),qr);s.amountIn=i?ke.getTokenAmountAFromLiquidity(t,e,n,!0):ke.getTokenAmountBFromLiquidity(e,t,n,!0),l.gte(s.amountIn)?s.sqrtPriceX64Next=t:s.sqrtPriceX64Next=se.getNextSqrtPriceX64FromInput(e,n,l,i)}else s.amountOut=i?ke.getTokenAmountBFromLiquidity(t,e,n,!1):ke.getTokenAmountAFromLiquidity(e,t,n,!1),o.mul(Bn).gte(s.amountOut)?s.sqrtPriceX64Next=t:s.sqrtPriceX64Next=se.getNextSqrtPriceX64FromOutput(e,n,o.mul(Bn),i);let u=t.eq(s.sqrtPriceX64Next);return i?(u&&c||(s.amountIn=ke.getTokenAmountAFromLiquidity(s.sqrtPriceX64Next,e,n,!0)),u&&!c||(s.amountOut=ke.getTokenAmountBFromLiquidity(s.sqrtPriceX64Next,e,n,!1))):(s.amountIn=u&&c?s.amountIn:ke.getTokenAmountBFromLiquidity(e,s.sqrtPriceX64Next,n,!0),s.amountOut=u&&!c?s.amountOut:ke.getTokenAmountAFromLiquidity(e,s.sqrtPriceX64Next,n,!1)),!c&&s.amountOut.gt(o.mul(Bn))&&(s.amountOut=o.mul(Bn)),c&&!s.sqrtPriceX64Next.eq(t)?s.feeAmount=o.sub(s.amountIn):s.feeAmount=le.mulDivCeil(s.amountIn,new fe(r),qr.sub(new fe(r))),[s.sqrtPriceX64Next,s.amountIn,s.amountOut,s.feeAmount]}};var at=60,lo=512,Z=class{static getTickArrayAddressByTick(e,t,n,o){let r=Z.getTickArrayStartIndexByTick(n,o),{publicKey:i}=Ae(e,t,r);return i}static getTickOffsetInArray(e,t){if(e%t!=0)throw new Error("tickIndex % tickSpacing not equal 0");let n=Z.getTickArrayStartIndexByTick(e,t),o=Math.floor((e-n)/t);if(o<0||o>=at)throw new Error("tick offset in array overflow");return o}static getTickArrayBitIndex(e,t){let n=he.tickCount(t),o=e/n;return e<0&&e%n!=0?o=Math.ceil(o)-1:o=Math.floor(o),o}static getTickArrayStartIndexByTick(e,t){return this.getTickArrayBitIndex(e,t)*he.tickCount(t)}static getTickArrayOffsetInBitmapByTick(e,t){let n=t*at,o=Math.floor(e/n)+512;return Math.abs(o)}static checkTickArrayIsInitialized(e,t,n){let o=n*at,r=Math.floor(t/o)+512,i=Math.abs(r);return{isInitialized:e.testn(i),startIndex:(i-512)*o}}static getNextTickArrayStartIndex(e,t,n){return n?e-t*at:e+t*at}static mergeTickArrayBitmap(e){let t=new ff(0);for(let n=0;n<e.length;n++)t=t.add(e[n].shln(64*n));return t}static getInitializedTickArrayInRange(e,t,n,o,r){let i=Math.floor(o/(n*at));return[...Z.searchLowBitFromStart(e,t,i-1,r,n),...Z.searchHightBitFromStart(e,t,i,r,n)]}static getAllInitializedTickArrayStartIndex(e,t,n){return Z.searchHightBitFromStart(e,t,-7680,lo,n)}static getAllInitializedTickArrayInfo(e,t,n,o,r){let i=[],s=Z.getAllInitializedTickArrayStartIndex(n,o,r);for(let c of s){let{publicKey:u}=Ae(e,t,c);i.push({tickArrayStartIndex:c,tickArrayAddress:u})}return i}static getAllInitializedTickInTickArray(e){return e.ticks.filter(t=>t.liquidityGross.gtn(0))}static searchLowBitFromStart(e,t,n,o,r){let i=[...[...t.negativeTickArrayBitmap].reverse(),e.slice(0,8),e.slice(8,16),...t.positiveTickArrayBitmap].map(u=>Z.mergeTickArrayBitmap(u)),s=[];for(;n>=-7680;){let u=Math.floor((n+7680)/512),l=(n+7680)%512;if(i[u].testn(l)&&s.push(n),n--,s.length===o)break}let c=he.tickCount(r);return s.map(u=>u*c)}static searchHightBitFromStart(e,t,n,o,r){let i=[...[...t.negativeTickArrayBitmap].reverse(),e.slice(0,8),e.slice(8,16),...t.positiveTickArrayBitmap].map(u=>Z.mergeTickArrayBitmap(u)),s=[];for(;n<7680;){let u=Math.floor((n+7680)/512),l=(n+7680)%512;if(i[u].testn(l)&&s.push(n),n++,s.length===o)break}let c=he.tickCount(r);return s.map(u=>u*c)}static checkIsOutOfBoundary(e){return e<Pt||e>xt}static nextInitTick(e,t,n,o,r){if(he.getArrayStartIndex(t,n)!=e.startTickIndex)return null;let s=Math.floor((t-e.startTickIndex)/n);if(o)for(;s>=0;){if(e.ticks[s].liquidityGross.gtn(0))return e.ticks[s];s=s-1}else for(r||(s=s+1);s<at;){if(e.ticks[s].liquidityGross.gtn(0))return e.ticks[s];s=s+1}return null}static firstInitializedTick(e,t){if(t){let n=at-1;for(;n>=0;){if(e.ticks[n].liquidityGross.gtn(0))return e.ticks[n];n=n-1}}else{let n=0;for(;n<at;){if(e.ticks[n].liquidityGross.gtn(0))return e.ticks[n];n=n+1}}throw Error(`firstInitializedTick check error: ${e} - ${t}`)}static _getTickPriceLegacy({poolInfo:e,tick:t,baseIn:n}){let o=se.getSqrtPriceX64FromTick(t),r=se.sqrtPriceX64ToPrice(o,e.mintA.decimals,e.mintB.decimals);return n?{tick:t,price:r,tickSqrtPriceX64:o}:{tick:t,price:new qo(1).div(r),tickSqrtPriceX64:o}}static _getPriceAndTickLegacy({poolInfo:e,price:t,baseIn:n}){let o=n?t:new qo(1).div(t),r=fo.getTickWithPriceAndTickspacing(o,e.ammConfig.tickSpacing,e.mintA.decimals,e.mintB.decimals),i=se.getSqrtPriceX64FromTick(r),s=se.sqrtPriceX64ToPrice(i,e.mintA.decimals,e.mintB.decimals);return n?{tick:r,price:s}:{tick:r,price:new qo(1).div(s)}}static getTickPrice({poolInfo:e,tick:t,baseIn:n}){let o=se.getSqrtPriceX64FromTick(t),r=se.sqrtPriceX64ToPrice(o,e.mintA.decimals,e.mintB.decimals);return n?{tick:t,price:r,tickSqrtPriceX64:o}:{tick:t,price:new qo(1).div(r),tickSqrtPriceX64:o}}static getPriceAndTick({poolInfo:e,price:t,baseIn:n}){let o=n?t:new qo(1).div(t),r=fo.getTickWithPriceAndTickspacing(o,e.config.tickSpacing,e.mintA.decimals,e.mintB.decimals),i=se.getSqrtPriceX64FromTick(r),s=se.sqrtPriceX64ToPrice(i,e.mintA.decimals,e.mintB.decimals);return n?{tick:r,price:s}:{tick:r,price:new qo(1).div(s)}}};var bl=F([Be(8),_("bump"),Et("index"),O(""),pt("protocolFeeRate"),pt("tradeFeeRate"),Et("tickSpacing"),Y(A(),8,"")]),yf=F([pt("blockTimestamp"),vo("tickCumulative"),Y(A(),4)]),gl=F([Be(8),qe("initialized"),A("recentEpoch"),Et("observationIndex"),O("poolId"),Y(yf,100,"observations"),Y(A(),4)]),bf=F([_("rewardState"),A("openTime"),A("endTime"),A("lastUpdateTime"),ne("emissionsPerSecondX64"),A("rewardTotalEmissioned"),A("rewardClaimed"),O("tokenMint"),O("tokenVault"),O("creator"),ne("rewardGrowthGlobalX64")]),po=F([Be(8),_("bump"),O("ammConfig"),O("creator"),O("mintA"),O("mintB"),O("vaultA"),O("vaultB"),O("observationId"),_("mintDecimalsA"),_("mintDecimalsB"),Et("tickSpacing"),ne("liquidity"),ne("sqrtPriceX64"),De("tickCurrent"),pt(),ne("feeGrowthGlobalX64A"),ne("feeGrowthGlobalX64B"),A("protocolFeesTokenA"),A("protocolFeesTokenB"),ne("swapInAmountTokenA"),ne("swapOutAmountTokenB"),ne("swapInAmountTokenB"),ne("swapOutAmountTokenA"),_("status"),Y(_(),7,""),Y(bf,3,"rewardInfos"),Y(A(),16,"tickArrayBitmap"),A("totalFeesTokenA"),A("totalFeesClaimedTokenA"),A("totalFeesTokenB"),A("totalFeesClaimedTokenB"),A("fundFeesTokenA"),A("fundFeesTokenB"),A("startTime"),Y(A(),15*4-3,"padding")]),gf=F([ne("growthInsideLastX64"),A("rewardAmountOwed")]),Do=F([Be(8),_("bump"),O("nftMint"),O("poolId"),De("tickLower"),De("tickUpper"),ne("liquidity"),ne("feeGrowthInsideLastX64A"),ne("feeGrowthInsideLastX64B"),A("tokenFeesOwedA"),A("tokenFeesOwedB"),Y(gf,3,"rewardInfos"),Y(A(),8,"")]),BI=F([Be(8),_("bump"),O("poolId"),De("tickLowerIndex"),De("tickUpperIndex"),ne("liquidity"),ne("feeGrowthInsideLastX64A"),ne("feeGrowthInsideLastX64B"),A("tokenFeesOwedA"),A("tokenFeesOwedB"),Y(ne(),3,"rewardGrowthInside"),Y(A(),8,"")]),Pf=F([De("tick"),Rc("liquidityNet"),ne("liquidityGross"),ne("feeGrowthOutsideX64A"),ne("feeGrowthOutsideX64B"),Y(ne(),3,"rewardGrowthsOutsideX64"),Y(pt(),13,"")]),vi=F([Be(8),O("poolId"),De("startTickIndex"),Y(Pf,at,"ticks"),_("initializedTickCount"),Y(_(),115,"")]),Pl=F([Be(329),Y(O(),100,"whitelistMints")]),yl=F([Be(8),O("poolId"),Y(Y(A(),8),Va,"positiveTickArrayBitmap"),Y(Y(A(),8),Va,"negativeTickArrayBitmap")]),xI=F([A(),_("bump"),O("owner"),O("poolId"),O("positionId"),O("nftAccount"),Y(A(),8)]),Al=F([Be(8),_("bump"),O("lockOwner"),O("poolId"),O("positionId"),O("nftAccount"),O("lockNftMint"),A("recentEpoch"),Y(A(),8)]);gl.span;var kl=be("Raydium_Clmm"),qt={createPool:[233,146,209,142,207,104,64,188],initReward:[95,135,192,196,242,129,230,68],setRewardEmissions:[112,52,167,75,32,201,211,137],openPosition:[77,184,74,214,112,86,241,199],openPositionWithTokenEx:[77,255,174,82,125,29,201,46],closePosition:[123,134,81,0,49,68,98,98],increaseLiquidity:[133,29,89,223,69,238,176,10],decreaseLiquidity:[58,127,188,62,79,82,196,96],swap:[43,4,237,11,26,201,30,98],collectReward:[18,237,166,197,34,16,213,144]},wl=[188,37,179,131,82,150,84,73],Tl=[16,72,250,198,14,162,212,19],Re=class{static createPoolInstruction(e,t,n,o,r,i,s,c,u,l,m,p,d,f){let y=F([ne("sqrtPriceX64"),A("zero")]),b=[{pubkey:n,isSigner:!0,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!1},{pubkey:u,isSigner:!1,isWritable:!1},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:p,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!1},{pubkey:m,isSigner:!1,isWritable:!1},{pubkey:Sn.programId,isSigner:!1,isWritable:!1},{pubkey:Je,isSigner:!1,isWritable:!1},...(f==null?void 0:f.map(h=>({pubkey:h,isSigner:!1,isWritable:!1})))||[]],g=Buffer.alloc(y.span);y.encode({sqrtPriceX64:d,zero:Pe},g);let P=Buffer.from([...qt.createPool,...g]);return new yt({keys:b,programId:e,data:P})}static async createPoolInstructions(e){let{programId:t,owner:n,mintA:o,mintB:r,ammConfigId:i,initialPriceX64:s,extendMintAccount:c}=e,[u,l]=[new z(o.address),new z(r.address)],{publicKey:m}=cl(t,i,u,l),{publicKey:p}=ml(t,m),{publicKey:d}=Na(t,m,u),{publicKey:f}=Na(t,m,l),y=$e(t,m).publicKey,b=[this.createPoolInstruction(t,m,n,i,p,u,d,new z(o.programId||Ce),l,f,new z(r.programId||Ce),y,s,c)];return{signers:[],instructions:b,instructionTypes:[G.CreateAccount,G.ClmmCreatePool],address:{poolId:m,observationId:p,exBitmapAccount:y,mintAVault:d,mintBVault:f},lookupTableAddress:[]}}static openPositionFromLiquidityInstruction(e,t,n,o,r,i,s,c,u,l,m,p,d,f,y,b,g,P,h,I,T,w,K,x,S,B){let R=F([De("tickLowerIndex"),De("tickUpperIndex"),De("tickArrayLowerStartIndex"),De("tickArrayUpperStartIndex"),ne("liquidity"),A("amountMaxA"),A("amountMaxB"),qe("withMetadata"),_("optionBaseFlag"),qe("baseFlag")]),C=[...B?[{pubkey:B,isSigner:!1,isWritable:!0}]:[]],v=[{pubkey:t,isSigner:!0,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!0,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:m,isSigner:!1,isWritable:!0},{pubkey:p,isSigner:!1,isWritable:!0},{pubkey:d,isSigner:!1,isWritable:!0},{pubkey:f,isSigner:!1,isWritable:!0},{pubkey:y,isSigner:!1,isWritable:!0},{pubkey:Je,isSigner:!1,isWritable:!1},{pubkey:Sn.programId,isSigner:!1,isWritable:!1},{pubkey:Ce,isSigner:!1,isWritable:!1},{pubkey:Vi,isSigner:!1,isWritable:!1},{pubkey:Gt,isSigner:!1,isWritable:!1},{pubkey:ze,isSigner:!1,isWritable:!1},{pubkey:b,isSigner:!1,isWritable:!1},{pubkey:g,isSigner:!1,isWritable:!1},...C],L=Buffer.alloc(R.span);R.encode({tickLowerIndex:P,tickUpperIndex:h,tickArrayLowerStartIndex:I,tickArrayUpperStartIndex:T,liquidity:w,amountMaxA:K,amountMaxB:x,withMetadata:S==="create",baseFlag:!1,optionBaseFlag:0},L);let N=Buffer.from([...qt.openPosition,...L]);return new yt({keys:v,programId:e,data:N})}static openPositionFromLiquidityInstruction22(e,t,n,o,r,i,s,c,u,l,m,p,d,f,y,b,g,P,h,I,T,w,K,x,S){let B=F([De("tickLowerIndex"),De("tickUpperIndex"),De("tickArrayLowerStartIndex"),De("tickArrayUpperStartIndex"),ne("liquidity"),A("amountMaxA"),A("amountMaxB"),qe("withMetadata"),_("optionBaseFlag"),qe("baseFlag")]),R=[...S?[{pubkey:S,isSigner:!1,isWritable:!0}]:[]],C=[{pubkey:t,isSigner:!0,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!0,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:m,isSigner:!1,isWritable:!0},{pubkey:p,isSigner:!1,isWritable:!0},{pubkey:d,isSigner:!1,isWritable:!0},{pubkey:f,isSigner:!1,isWritable:!0},{pubkey:Je,isSigner:!1,isWritable:!1},{pubkey:Sn.programId,isSigner:!1,isWritable:!1},{pubkey:Ce,isSigner:!1,isWritable:!1},{pubkey:Vi,isSigner:!1,isWritable:!1},{pubkey:ze,isSigner:!1,isWritable:!1},{pubkey:y,isSigner:!1,isWritable:!1},{pubkey:b,isSigner:!1,isWritable:!1},...R],v=Buffer.alloc(B.span);B.encode({tickLowerIndex:g,tickUpperIndex:P,tickArrayLowerStartIndex:h,tickArrayUpperStartIndex:I,liquidity:T,amountMaxA:w,amountMaxB:K,withMetadata:x==="create",baseFlag:!1,optionBaseFlag:0},v);let L=Buffer.from([...qt.openPositionWithTokenEx,...v]);return new yt({keys:C,programId:e,data:L})}static async openPositionInstructions({poolInfo:e,poolKeys:t,ownerInfo:n,tickLower:o,tickUpper:r,liquidity:i,amountMaxA:s,amountMaxB:c,withMetadata:u,getEphemeralSigners:l,nft2022:m}){let p=[],[d,f]=[new z(e.programId),new z(e.id)],y;if(l)y=new z((await l(1))[0]);else{let S=Xr.generate();p.push(S),y=S.publicKey}let b=Z.getTickArrayStartIndexByTick(o,e.config.tickSpacing),g=Z.getTickArrayStartIndexByTick(r,e.config.tickSpacing),{publicKey:P}=Ae(d,f,b),{publicKey:h}=Ae(d,f,g),{publicKey:I}=m?j(n.wallet,y,ze):j(n.wallet,y,Ce),{publicKey:T}=xn(y),{publicKey:w}=Kt(d,y),{publicKey:K}=an(d,f,o,r),x=m?this.openPositionFromLiquidityInstruction22(d,n.feePayer,f,n.wallet,y,I,K,P,h,w,n.tokenAccountA,n.tokenAccountB,new z(t.vault.A),new z(t.vault.B),new z(e.mintA.address),new z(e.mintB.address),o,r,b,g,i,s,c,u,Fe.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing,[b,g])?$e(d,f).publicKey:void 0):this.openPositionFromLiquidityInstruction(d,n.feePayer,f,n.wallet,y,I,T,K,P,h,w,n.tokenAccountA,n.tokenAccountB,new z(t.vault.A),new z(t.vault.B),new z(e.mintA.address),new z(e.mintB.address),o,r,b,g,i,s,c,u,Fe.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing,[b,g])?$e(d,f).publicKey:void 0);return{signers:p,instructions:[x],instructionTypes:[G.ClmmOpenPosition],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[],address:{nftMint:y,tickArrayLower:P,tickArrayUpper:h,positionNftAccount:I,metadataAccount:T,personalPosition:w,protocolPosition:K}}}static async openPositionFromBaseInstructions({poolInfo:e,poolKeys:t,ownerInfo:n,tickLower:o,tickUpper:r,base:i,baseAmount:s,otherAmountMax:c,withMetadata:u,getEphemeralSigners:l,nft2022:m}){let p=[],[d,f]=[new z(e.programId),new z(e.id)],y;if(l)y=new z((await l(1))[0]);else{let S=Xr.generate();p.push(S),y=S.publicKey}let b=Z.getTickArrayStartIndexByTick(o,e.config.tickSpacing),g=Z.getTickArrayStartIndexByTick(r,e.config.tickSpacing),{publicKey:P}=Ae(d,f,b),{publicKey:h}=Ae(d,f,g),{publicKey:I}=m?j(n.wallet,y,ze):j(n.wallet,y,Ce),{publicKey:T}=xn(y),{publicKey:w}=Kt(d,y),{publicKey:K}=an(d,f,o,r),x=m?this.openPositionFromBaseInstruction22(d,n.feePayer,f,n.wallet,y,I,K,P,h,w,n.tokenAccountA,n.tokenAccountB,new z(t.vault.A),new z(t.vault.B),new z(e.mintA.address),new z(e.mintB.address),o,r,b,g,u,i,s,c,Fe.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing,[b,g])?$e(d,f).publicKey:void 0):this.openPositionFromBaseInstruction(d,n.feePayer,f,n.wallet,y,I,T,K,P,h,w,n.tokenAccountA,n.tokenAccountB,new z(t.vault.A),new z(t.vault.B),new z(e.mintA.address),new z(e.mintB.address),o,r,b,g,u,i,s,c,Fe.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing,[b,g])?$e(d,f).publicKey:void 0);return{address:{nftMint:y,tickArrayLower:P,tickArrayUpper:h,positionNftAccount:I,metadataAccount:T,personalPosition:w,protocolPosition:K},instructions:[x],signers:p,instructionTypes:[G.ClmmOpenPosition],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[]}}static openPositionFromBaseInstruction(e,t,n,o,r,i,s,c,u,l,m,p,d,f,y,b,g,P,h,I,T,w,K,x,S,B){let R=F([De("tickLowerIndex"),De("tickUpperIndex"),De("tickArrayLowerStartIndex"),De("tickArrayUpperStartIndex"),ne("liquidity"),A("amountMaxA"),A("amountMaxB"),qe("withMetadata"),_("optionBaseFlag"),qe("baseFlag")]),C=[...B?[{pubkey:B,isSigner:!1,isWritable:!0}]:[]],v=[{pubkey:t,isSigner:!0,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!0,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:m,isSigner:!1,isWritable:!0},{pubkey:p,isSigner:!1,isWritable:!0},{pubkey:d,isSigner:!1,isWritable:!0},{pubkey:f,isSigner:!1,isWritable:!0},{pubkey:y,isSigner:!1,isWritable:!0},{pubkey:Je,isSigner:!1,isWritable:!1},{pubkey:Sn.programId,isSigner:!1,isWritable:!1},{pubkey:Ce,isSigner:!1,isWritable:!1},{pubkey:Vi,isSigner:!1,isWritable:!1},{pubkey:Gt,isSigner:!1,isWritable:!1},{pubkey:ze,isSigner:!1,isWritable:!1},{pubkey:b,isSigner:!1,isWritable:!1},{pubkey:g,isSigner:!1,isWritable:!1},...C],L=Buffer.alloc(R.span);R.encode({tickLowerIndex:P,tickUpperIndex:h,tickArrayLowerStartIndex:I,tickArrayUpperStartIndex:T,liquidity:new Wa(0),amountMaxA:K==="MintA"?x:S,amountMaxB:K==="MintA"?S:x,withMetadata:w==="create",baseFlag:K==="MintA",optionBaseFlag:1},L);let N=Buffer.from([...qt.openPosition,...L]);return new yt({keys:v,programId:e,data:N})}static openPositionFromBaseInstruction22(e,t,n,o,r,i,s,c,u,l,m,p,d,f,y,b,g,P,h,I,T,w,K,x,S){let B=F([De("tickLowerIndex"),De("tickUpperIndex"),De("tickArrayLowerStartIndex"),De("tickArrayUpperStartIndex"),ne("liquidity"),A("amountMaxA"),A("amountMaxB"),qe("withMetadata"),_("optionBaseFlag"),qe("baseFlag")]),R=[...S?[{pubkey:S,isSigner:!1,isWritable:!0}]:[]],C=[{pubkey:t,isSigner:!0,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!0,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:m,isSigner:!1,isWritable:!0},{pubkey:p,isSigner:!1,isWritable:!0},{pubkey:d,isSigner:!1,isWritable:!0},{pubkey:f,isSigner:!1,isWritable:!0},{pubkey:Je,isSigner:!1,isWritable:!1},{pubkey:Sn.programId,isSigner:!1,isWritable:!1},{pubkey:Ce,isSigner:!1,isWritable:!1},{pubkey:Vi,isSigner:!1,isWritable:!1},{pubkey:ze,isSigner:!1,isWritable:!1},{pubkey:y,isSigner:!1,isWritable:!1},{pubkey:b,isSigner:!1,isWritable:!1},...R],v=Buffer.alloc(B.span);B.encode({tickLowerIndex:g,tickUpperIndex:P,tickArrayLowerStartIndex:h,tickArrayUpperStartIndex:I,liquidity:new Wa(0),amountMaxA:w==="MintA"?K:x,amountMaxB:w==="MintA"?x:K,withMetadata:T==="create",baseFlag:w==="MintA",optionBaseFlag:1},v);let L=Buffer.from([...qt.openPositionWithTokenEx,...v]);return new yt({keys:C,programId:e,data:L})}static async openPositionFromLiquidityInstructions({poolInfo:e,poolKeys:t,ownerInfo:n,tickLower:o,tickUpper:r,liquidity:i,amountMaxA:s,amountMaxB:c,withMetadata:u,getEphemeralSigners:l,nft2022:m}){let p,d=[];if(l)p=new z((await l(1))[0]);else{let S=Xr.generate();d.push(S),p=S.publicKey}let[f,y]=[new z(e.programId),new z(e.id)],b=Z.getTickArrayStartIndexByTick(o,e.config.tickSpacing),g=Z.getTickArrayStartIndexByTick(r,e.config.tickSpacing),{publicKey:P}=Ae(f,y,b),{publicKey:h}=Ae(f,y,g),{publicKey:I}=m?j(n.wallet,p,ze):j(n.wallet,p,Ce),{publicKey:T}=xn(p),{publicKey:w}=Kt(f,p),{publicKey:K}=an(f,y,o,r),x=m?this.openPositionFromLiquidityInstruction22(f,n.wallet,y,n.wallet,p,I,K,P,h,w,n.tokenAccountA,n.tokenAccountB,new z(t.vault.A),new z(t.vault.B),new z(t.mintA.address),new z(t.mintB.address),o,r,b,g,i,s,c,u,Fe.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing,[b,g])?$e(f,y).publicKey:void 0):this.openPositionFromLiquidityInstruction(f,n.wallet,y,n.wallet,p,I,T,K,P,h,w,n.tokenAccountA,n.tokenAccountB,new z(t.vault.A),new z(t.vault.B),new z(t.mintA.address),new z(t.mintB.address),o,r,b,g,i,s,c,u,Fe.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing,[b,g])?$e(f,y).publicKey:void 0);return{address:{nftMint:p,tickArrayLower:P,tickArrayUpper:h,positionNftAccount:I,metadataAccount:T,personalPosition:w,protocolPosition:K},instructions:[x],signers:d,instructionTypes:[G.ClmmOpenPosition],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[]}}static closePositionInstruction(e,t,n,o,r,i){let s=F([]),c=[{pubkey:t,isSigner:!0,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:Sn.programId,isSigner:!1,isWritable:!1},{pubkey:i?ze:Ce,isSigner:!1,isWritable:!1}],u=Buffer.alloc(s.span);s.encode({},u);let l=Buffer.from([...qt.closePosition,...u]);return new yt({keys:c,programId:e,data:l})}static closePositionInstructions({poolInfo:e,poolKeys:t,ownerInfo:n,ownerPosition:o,nft2022:r}){let i=new z(e.programId),s=r?j(n.wallet,o.nftMint,ze).publicKey:j(n.wallet,o.nftMint,Ce).publicKey,{publicKey:c}=Kt(i,o.nftMint),u=[];return u.push(this.closePositionInstruction(i,n.wallet,o.nftMint,s,c,r)),{address:{positionNftAccount:s,personalPosition:c},signers:[],instructions:u,instructionTypes:[G.ClmmClosePosition],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[]}}static increasePositionFromLiquidityInstruction(e,t,n,o,r,i,s,c,u,l,m,p,d,f,y,b,g,P){let h=F([ne("liquidity"),A("amountMaxA"),A("amountMaxB"),_("optionBaseFlag"),qe("baseFlag")]),I=[...P?[{pubkey:P,isSigner:!1,isWritable:!0}]:[]],T=[{pubkey:t,isSigner:!0,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:m,isSigner:!1,isWritable:!0},{pubkey:p,isSigner:!1,isWritable:!0},{pubkey:Ce,isSigner:!1,isWritable:!1},{pubkey:ze,isSigner:!1,isWritable:!1},{pubkey:d,isSigner:!1,isWritable:!1},{pubkey:f,isSigner:!1,isWritable:!1},...I],w=Buffer.alloc(h.span);h.encode({liquidity:y,amountMaxA:b,amountMaxB:g,optionBaseFlag:0,baseFlag:!1},w);let K=Buffer.from([...qt.increaseLiquidity,...w]);return new yt({keys:T,programId:e,data:K})}static increasePositionFromLiquidityInstructions({poolInfo:e,poolKeys:t,ownerPosition:n,ownerInfo:o,liquidity:r,amountMaxA:i,amountMaxB:s,nft2022:c}){let[u,l]=[new z(e.programId),new z(e.id)],m=Z.getTickArrayStartIndexByTick(n.tickLower,e.config.tickSpacing),p=Z.getTickArrayStartIndexByTick(n.tickUpper,e.config.tickSpacing),{publicKey:d}=Ae(u,l,m),{publicKey:f}=Ae(u,l,p),{publicKey:y}=c?j(o.wallet,n.nftMint,ze):j(o.wallet,n.nftMint,Ce),{publicKey:b}=Kt(u,n.nftMint),{publicKey:g}=an(u,l,n.tickLower,n.tickUpper),P=this.increasePositionFromLiquidityInstruction(u,o.wallet,y,b,l,g,d,f,o.tokenAccountA,o.tokenAccountB,new z(t.vault.A),new z(t.vault.B),new z(e.mintA.address),new z(e.mintB.address),r,i,s,Fe.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing,[m,p])?$e(u,l).publicKey:void 0);return{address:{tickArrayLower:d,tickArrayUpper:f,positionNftAccount:y,personalPosition:b,protocolPosition:g},signers:[],instructions:[P],instructionTypes:[G.ClmmIncreasePosition],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[]}}static increasePositionFromBaseInstructions({poolInfo:e,poolKeys:t,ownerPosition:n,ownerInfo:o,base:r,baseAmount:i,otherAmountMax:s,nft2022:c}){let[u,l]=[new z(e.programId),new z(e.id)],m=Z.getTickArrayStartIndexByTick(n.tickLower,e.config.tickSpacing),p=Z.getTickArrayStartIndexByTick(n.tickUpper,e.config.tickSpacing),{publicKey:d}=Ae(u,l,m),{publicKey:f}=Ae(u,l,p),{publicKey:y}=c?j(o.wallet,n.nftMint,ze):j(o.wallet,n.nftMint,Ce),{publicKey:b}=Kt(u,n.nftMint),{publicKey:g}=an(u,l,n.tickLower,n.tickUpper);return{address:{tickArrayLower:d,tickArrayUpper:f,positionNftAccount:y,personalPosition:b,protocolPosition:g},instructions:[this.increasePositionFromBaseInstruction(u,o.wallet,y,b,l,g,d,f,o.tokenAccountA,o.tokenAccountB,new z(t.vault.A),new z(t.vault.B),new z(e.mintA.address),new z(e.mintB.address),r,i,s,Fe.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing,[m,p])?$e(u,l).publicKey:void 0)],signers:[],instructionTypes:[G.ClmmIncreasePosition],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[]}}static increasePositionFromBaseInstruction(e,t,n,o,r,i,s,c,u,l,m,p,d,f,y,b,g,P){let h=F([ne("liquidity"),A("amountMaxA"),A("amountMaxB"),_("optionBaseFlag"),qe("baseFlag")]),I=[...P?[{pubkey:P,isSigner:!1,isWritable:!0}]:[]],T=[{pubkey:t,isSigner:!0,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:m,isSigner:!1,isWritable:!0},{pubkey:p,isSigner:!1,isWritable:!0},{pubkey:Ce,isSigner:!1,isWritable:!1},{pubkey:ze,isSigner:!1,isWritable:!1},{pubkey:d,isSigner:!1,isWritable:!1},{pubkey:f,isSigner:!1,isWritable:!1},...I],w=Buffer.alloc(h.span);h.encode({liquidity:new Wa(0),amountMaxA:y==="MintA"?b:g,amountMaxB:y==="MintA"?g:b,baseFlag:y==="MintA",optionBaseFlag:1},w);let K=Buffer.from([...qt.increaseLiquidity,...w]);return new yt({keys:T,programId:e,data:K})}static decreaseLiquidityInstruction(e,t,n,o,r,i,s,c,u,l,m,p,d,f,y,b,g,P,h){let I=F([ne("liquidity"),A("amountMinA"),A("amountMinB")]),T=[...h?[{pubkey:h,isSigner:!1,isWritable:!0}]:[],...y.map(S=>[{pubkey:S.poolRewardVault,isSigner:!1,isWritable:!0},{pubkey:S.ownerRewardVault,isSigner:!1,isWritable:!0},{pubkey:S.rewardMint,isSigner:!1,isWritable:!1}]).flat()],w=[{pubkey:t,isSigner:!0,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:m,isSigner:!1,isWritable:!0},{pubkey:p,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:Ce,isSigner:!1,isWritable:!1},{pubkey:ze,isSigner:!1,isWritable:!1},{pubkey:gr,isSigner:!1,isWritable:!1},{pubkey:d,isSigner:!1,isWritable:!1},{pubkey:f,isSigner:!1,isWritable:!1},...T],K=Buffer.alloc(I.span);I.encode({liquidity:b,amountMinA:g,amountMinB:P},K);let x=Buffer.from([...qt.decreaseLiquidity,...K]);return new yt({keys:w,programId:e,data:x})}static decreaseLiquidityInstructions({poolInfo:e,poolKeys:t,ownerPosition:n,ownerInfo:o,liquidity:r,amountMinA:i,amountMinB:s,programId:c,nft2022:u}){let[l,m]=[new z(e.programId),new z(e.id)],p=Z.getTickArrayStartIndexByTick(n.tickLower,e.config.tickSpacing),d=Z.getTickArrayStartIndexByTick(n.tickUpper,e.config.tickSpacing),{publicKey:f}=Ae(l,m,p),{publicKey:y}=Ae(l,m,d),{publicKey:b}=u?j(o.wallet,n.nftMint,ze):j(o.wallet,n.nftMint,c),{publicKey:g}=Kt(l,n.nftMint),{publicKey:P}=an(l,m,n.tickLower,n.tickUpper),h=[];for(let w=0;w<e.rewardDefaultInfos.length;w++)h.push({poolRewardVault:new z(t.rewardInfos[w].vault),ownerRewardVault:o.rewardAccounts[w],rewardMint:new z(e.rewardDefaultInfos[w].mint.address)});let I=[],T=this.decreaseLiquidityInstruction(l,o.wallet,b,g,m,P,f,y,o.tokenAccountA,o.tokenAccountB,new z(t.vault.A),new z(t.vault.B),new z(e.mintA.address),new z(e.mintB.address),h,r,i,s,Fe.isOverflowDefaultTickarrayBitmap(e.config.tickSpacing,[p,d])?$e(l,m).publicKey:void 0);return I.push(T),{address:{tickArrayLower:f,tickArrayUpper:y,positionNftAccount:b,personalPosition:g,protocolPosition:P},signers:[],instructions:I,instructionTypes:[G.ClmmDecreasePosition],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[]}}static swapInstruction(e,t,n,o,r,i,s,c,u,l,m,p,d,f,y,b,g){let P=F([A("amount"),A("otherAmountThreshold"),ne("sqrtPriceLimitX64"),qe("isBaseInput")]),h=[...g?[{pubkey:g,isSigner:!1,isWritable:!0}]:[],...m.map(K=>({pubkey:K,isSigner:!1,isWritable:!0}))],I=[{pubkey:t,isSigner:!0,isWritable:!1},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:p,isSigner:!1,isWritable:!0},{pubkey:Ce,isSigner:!1,isWritable:!1},{pubkey:ze,isSigner:!1,isWritable:!1},{pubkey:gr,isSigner:!1,isWritable:!1},{pubkey:u,isSigner:!1,isWritable:!1},{pubkey:l,isSigner:!1,isWritable:!1},...h],T=Buffer.alloc(P.span);P.encode({amount:d,otherAmountThreshold:f,sqrtPriceLimitX64:y,isBaseInput:b},T);let w=Buffer.from([...qt.swap,...T]);return new yt({keys:I,programId:e,data:w})}static makeSwapBaseInInstructions({poolInfo:e,poolKeys:t,observationId:n,ownerInfo:o,inputMint:r,amountIn:i,amountOutMin:s,sqrtPriceLimitX64:c,remainingAccounts:u}){let[l,m]=[new z(e.programId),new z(e.id)],[p,d]=[new z(t.vault.A),new z(t.vault.B)],[f,y]=[new z(e.mintA.address),new z(e.mintB.address)],b=e.mintA.address===r.toString(),g=[this.swapInstruction(l,o.wallet,m,new z(e.config.id),b?o.tokenAccountA:o.tokenAccountB,b?o.tokenAccountB:o.tokenAccountA,b?p:d,b?d:p,b?f:y,b?y:f,u,n,i,s,c,!0,$e(l,m).publicKey)];return{signers:[],instructions:g,instructionTypes:[G.ClmmSwapBaseIn],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[],address:{}}}static makeSwapBaseOutInstructions({poolInfo:e,poolKeys:t,observationId:n,ownerInfo:o,outputMint:r,amountOut:i,amountInMax:s,sqrtPriceLimitX64:c,remainingAccounts:u}){let[l,m]=[new z(e.programId),new z(e.id)],[p,d]=[new z(t.vault.A),new z(t.vault.B)],[f,y]=[new z(e.mintA.address),new z(e.mintB.address)],b=e.mintA.address===r.toBase58(),g=[this.swapInstruction(l,o.wallet,m,new z(e.config.id),b?o.tokenAccountB:o.tokenAccountA,b?o.tokenAccountA:o.tokenAccountB,b?d:p,b?p:d,b?y:f,b?f:y,u,n,i,s,c,!1,$e(l,m).publicKey)];return{signers:[],instructions:g,instructionTypes:[G.ClmmSwapBaseOut],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[],address:{}}}static initRewardInstruction(e,t,n,o,r,i,s,c,u,l,m,p){let d=F([A("openTime"),A("endTime"),ne("emissionsPerSecondX64")]),f=[{pubkey:t,isSigner:!0,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!1},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!1},{pubkey:Sn.programId,isSigner:!1,isWritable:!1},{pubkey:Je,isSigner:!1,isWritable:!1}],y=Buffer.alloc(d.span);d.encode({openTime:J(l),endTime:J(m),emissionsPerSecondX64:p},y);let b=Buffer.from([...qt.initReward,...y]);return new yt({keys:f,programId:e,data:b})}static initRewardInstructions({poolInfo:e,poolKeys:t,ownerInfo:n,rewardInfo:o}){let[r,i]=[new z(e.programId),new z(e.id)],s=ll(r,i,o.mint).publicKey,c=Ni(r).publicKey,u=[this.initRewardInstruction(r,n.wallet,i,c,new z(e.config.id),n.tokenAccount,o.programId,o.mint,s,o.openTime,o.endTime,o.emissionsPerSecondX64)];return{address:{poolRewardVault:s,operationId:c},signers:[],instructions:u,instructionTypes:[G.ClmmInitReward],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[]}}static setRewardInstruction(e,t,n,o,r,i,s,c,u,l,m,p){let d=F([_("rewardIndex"),ne("emissionsPerSecondX64"),A("openTime"),A("endTime")]),f=[{pubkey:t,isSigner:!0,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:Ce,isSigner:!1,isWritable:!1},{pubkey:ze,isSigner:!1,isWritable:!1},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0}],y=Buffer.alloc(d.span);d.encode({rewardIndex:u,emissionsPerSecondX64:p,openTime:J(l),endTime:J(m)},y);let b=Buffer.from([...qt.setRewardEmissions,...y]);return new yt({keys:f,programId:e,data:b})}static setRewardInstructions({poolInfo:e,poolKeys:t,ownerInfo:n,rewardInfo:o}){let[r,i]=[new z(e.programId),new z(e.id)],s,c,u;for(let p=0;p<e.rewardDefaultInfos.length;p++)e.rewardDefaultInfos[p].mint.address===o.mint.toString()&&(s=p,c=new z(t.rewardInfos[p].vault),u=new z(t.rewardInfos[p].mint.address));(s===void 0||c===void 0)&&kl.logWithError("reward mint check error","no reward mint",e.rewardDefaultInfos);let l=Ni(r).publicKey,m=[this.setRewardInstruction(r,n.wallet,i,l,new z(e.config.id),n.tokenAccount,c,u,s,o.openTime,o.endTime,o.emissionsPerSecondX64)];return{address:{rewardVault:c,operationId:l},signers:[],instructions:m,instructionTypes:[G.ClmmSetReward],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[]}}static collectRewardInstruction(e,t,n,o,r,i,s){let c=F([_("rewardIndex")]),u=[{pubkey:t,isSigner:!0,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!1},{pubkey:Ce,isSigner:!1,isWritable:!1},{pubkey:ze,isSigner:!1,isWritable:!1},{pubkey:gr,isSigner:!1,isWritable:!1}],l=Buffer.alloc(c.span);c.encode({rewardIndex:s},l);let m=Buffer.from([...qt.collectReward,...l]);return new yt({keys:u,programId:e,data:m})}static collectRewardInstructions({poolInfo:e,poolKeys:t,ownerInfo:n,rewardMint:o}){let[r,i]=[new z(e.programId),new z(e.id)],s,c;for(let l=0;l<e.rewardDefaultInfos.length;l++)e.rewardDefaultInfos[l].mint.address===o.toString()&&(s=l,c=new z(t.rewardInfos[l].vault));(s===void 0||c===void 0)&&kl.logWithError("reward mint check error","no reward mint",e.rewardDefaultInfos);let u=[this.collectRewardInstruction(r,n.wallet,i,n.tokenAccount,c,o,s)];return{address:{rewardVault:c},signers:[],instructions:u,instructionTypes:[G.ClmmCollectReward],lookupTableAddress:t.lookupTableAccount?[t.lookupTableAccount]:[]}}static async makeLockPositions({programId:e,authProgramId:t,poolProgramId:n,payer:o,wallet:r,nftMint:i,nft2022:s,getEphemeralSigners:c}){let u=[],l;if(c)l=new z((await c(1))[0]);else{let g=Xr.generate();u.push(g),l=g.publicKey}let m=s?j(r,i,ze).publicKey:j(r,i,Ce).publicKey,{publicKey:p}=Kt(n,i),d=Wo(e,l).publicKey,f=j(r,l,Ce).publicKey,y=xn(l).publicKey,b=Re.lockPositionInstructionV2({programId:e,auth:t,payer:o,positionOwner:r,lockOwner:r,positionNftAccount:m,positionId:p,lockPositionId:d,lockNftMint:l,lockNftAccount:f,metadataAccount:y,withMetadata:!0,nft2022:s,positionNftMint:i,authPositionNftAccount:j(t,i,s?ze:Ce).publicKey,positionNftProgram:s?ze:Ce});return{address:{positionId:p,lockPositionId:d,lockNftAccount:f,lockNftMint:l,positionNftAccount:m,metadataAccount:y},instructions:[b],signers:u,instructionTypes:[G.ClmmLockPosition],lookupTableAddress:[]}}static lockPositionInstructionV2({programId:e,auth:t,payer:n,positionOwner:o,lockOwner:r,positionNftAccount:i,positionId:s,positionNftMint:c,authPositionNftAccount:u,positionNftProgram:l,lockPositionId:m,lockNftMint:p,lockNftAccount:d,metadataAccount:f,withMetadata:y}){let b=[{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!0,isWritable:!0},{pubkey:o,isSigner:!0,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!1},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!1},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:m,isSigner:!1,isWritable:!0},{pubkey:p,isSigner:!0,isWritable:!0},{pubkey:d,isSigner:!1,isWritable:!0},{pubkey:f,isSigner:!1,isWritable:!0},{pubkey:Gt,isSigner:!1,isWritable:!1},{pubkey:Vi,isSigner:!1,isWritable:!1},{pubkey:Je,isSigner:!1,isWritable:!1},{pubkey:Ce,isSigner:!1,isWritable:!1},{pubkey:l,isSigner:!1,isWritable:!1},{pubkey:Sn.programId,isSigner:!1,isWritable:!1}],g=F([qe("withMetadata")]),P=Buffer.alloc(g.span);g.encode({withMetadata:y},P);let h=Buffer.from([...wl,...P]);return new yt({keys:b,programId:e,data:h})}static lockPositionInstruction({programId:e,authProgramId:t,poolProgramId:n,owner:o,positionNft:r}){let{publicKey:i}=j(o,r,Ce),{publicKey:s}=Kt(n,r),c=[{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!0,isWritable:!1},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!1},{pubkey:Ma(e,s).publicKey,isSigner:!1,isWritable:!0},{pubkey:Ce,isSigner:!1,isWritable:!1},{pubkey:Sn.programId,isSigner:!1,isWritable:!1}];return new yt({keys:c,programId:e,data:Buffer.from(wl)})}static harvestLockPositionInstruction(e){let[t,n]=[new z(e.poolKeys.programId),new z(e.poolKeys.id)],o=Z.getTickArrayStartIndexByTick(e.ownerPosition.tickLower,e.poolKeys.config.tickSpacing),r=Z.getTickArrayStartIndexByTick(e.ownerPosition.tickUpper,e.poolKeys.config.tickSpacing),{publicKey:i}=Ae(t,n,o),{publicKey:s}=Ae(t,n,r),{publicKey:c}=j(e.owner,e.ownerPosition.nftMint,Ce),{publicKey:u}=Kt(t,e.ownerPosition.nftMint),{publicKey:l}=an(t,n,e.ownerPosition.tickLower,e.ownerPosition.tickUpper),m=[];for(let f=0;f<e.poolKeys.rewardInfos.length;f++)m.push({poolRewardVault:new z(e.poolKeys.rewardInfos[f].vault),ownerRewardVault:e.ownerRewardAccounts[f],rewardMint:new z(e.poolKeys.rewardInfos[f].mint.address)});let p=[...m.map(f=>[{pubkey:f.poolRewardVault,isSigner:!1,isWritable:!0},{pubkey:f.ownerRewardVault,isSigner:!1,isWritable:!0},{pubkey:f.rewardMint,isSigner:!1,isWritable:!1}]).flat()],d=[{pubkey:e.authProgramId,isSigner:!1,isWritable:!1},{pubkey:Ma(e.programId,u).publicKey,isSigner:!1,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:e.owner,isSigner:!0,isWritable:!1},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:new z(e.poolKeys.vault.A),isSigner:!1,isWritable:!0},{pubkey:new z(e.poolKeys.vault.B),isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:e.userVaultA,isSigner:!1,isWritable:!0},{pubkey:e.userVaultB,isSigner:!1,isWritable:!0},{pubkey:Ce,isSigner:!1,isWritable:!1},{pubkey:ze,isSigner:!1,isWritable:!1},{pubkey:mn,isSigner:!1,isWritable:!1},{pubkey:new z(e.poolKeys.mintA.address),isSigner:!1,isWritable:!1},{pubkey:new z(e.poolKeys.mintB.address),isSigner:!1,isWritable:!1},...p];return new yt({keys:d,programId:e.programId,data:Buffer.from(Tl)})}static harvestLockPositionInstructionV2({programId:e,auth:t,lockPositionId:n,clmmProgram:o,lockOwner:r,lockNftMint:i,lockNftAccount:s,positionNftAccount:c,positionId:u,poolId:l,protocolPosition:m,vaultA:p,vaultB:d,tickArrayLower:f,tickArrayUpper:y,userVaultA:b,userVaultB:g,mintA:P,mintB:h,rewardAccounts:I,exTickArrayBitmap:T}){let w=[...T?[{pubkey:T,isSigner:!1,isWritable:!0}]:[],...I.map(x=>[{pubkey:x.poolRewardVault,isSigner:!1,isWritable:!0},{pubkey:x.ownerRewardVault,isSigner:!1,isWritable:!0},{pubkey:x.rewardMint,isSigner:!1,isWritable:!1}]).flat()],K=[{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!0,isWritable:!1},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:m,isSigner:!1,isWritable:!0},{pubkey:p,isSigner:!1,isWritable:!0},{pubkey:d,isSigner:!1,isWritable:!0},{pubkey:f,isSigner:!1,isWritable:!0},{pubkey:y,isSigner:!1,isWritable:!0},{pubkey:b,isSigner:!1,isWritable:!0},{pubkey:g,isSigner:!1,isWritable:!0},{pubkey:Ce,isSigner:!1,isWritable:!1},{pubkey:ze,isSigner:!1,isWritable:!1},{pubkey:mn,isSigner:!1,isWritable:!1},{pubkey:P,isSigner:!1,isWritable:!1},{pubkey:h,isSigner:!1,isWritable:!1},...w];return new yt({keys:K,programId:e,data:Buffer.from(Tl)})}};var hl=F([pt("mintAuthorityOption"),O("mintAuthority"),A("supply"),_("decimals"),_("isInitialized"),pt("freezeAuthorityOption"),O("freezeAuthority")]);import{PublicKey as Af}from"@solana/web3.js";import{MintLayout as Il,TOKEN_PROGRAM_ID as kf}from"@solana/spl-token";var JI=async({connection:a,mint:e})=>{let t=await a.getAccountInfo(new Af(e));return!t||t.data.length!==Il.span?void 0:Il.decode(t.data)},eB=({mint:a,decimals:e,programId:t=kf,logoURI:n="",priority:o=3})=>{let r=a.toBase58().substring(0,6);return{address:a.toBase58(),decimals:e,symbol:r,logoURI:n,extensions:{},chainId:101,programId:t.toString(),name:r,tags:[],priority:o}},zr=a=>new Ke({mint:a.address,decimals:a.decimals,symbol:a.symbol,name:a.name}),_i=o=>{var r=o,{amount:a,isRaw:e,name:t}=r,n=_e(r,["amount","isRaw","name"]);return new Ie(new Ke({mint:bt(n.address).toBase58(),decimals:n.decimals,symbol:n.symbol,name:t}),a,e,t)};function tB(a){return a.address===ln.address?ut:a}function nB(a){return a.address===ut.address?ln:a}var At=o=>{var r=o,{address:a,programId:e,decimals:t}=r,n=_e(r,["address","programId","decimals"]);return M({chainId:101,address:bt(a).toBase58(),programId:e,logoURI:"",symbol:"",name:"",decimals:t,tags:[],extensions:n.extensions||{}},n)},Yn=a=>a?q(M({},a),{transferFeeConfigAuthority:a.transferFeeConfigAuthority.toBase58(),withdrawWithheldAuthority:a.withdrawWithheldAuthority.toBase58(),withheldAmount:a.withheldAmount.toString(),olderTransferFee:q(M({},a.olderTransferFee),{epoch:a.olderTransferFee.epoch.toString(),maximumFee:a.olderTransferFee.maximumFee.toString()}),newerTransferFee:q(M({},a.newerTransferFee),{epoch:a.newerTransferFee.epoch.toString(),maximumFee:a.newerTransferFee.maximumFee.toString()})}):void 0;import Bl from"bn.js";var Da=new Bl(25),Yr=new Bl(1e4),wf={4:3,5:3};import{PublicKey as Oe,SystemProgram as Sl,SYSVAR_RENT_PUBKEY as hf,TransactionInstruction as Cn}from"@solana/web3.js";import{ASSOCIATED_TOKEN_PROGRAM_ID as If,TOKEN_PROGRAM_ID as Uo}from"@solana/spl-token";var qa=F([_("instruction"),A("amountIn"),A("minAmountOut")]),Ua=F([_("instruction"),A("maxAmountIn"),A("amountOut")]),pB=F([_("instruction"),_("nonce")]),Ga=F([_("instruction"),_("nonce"),A("startTime")]),yo=F([A("status"),A("nonce"),A("maxOrder"),A("depth"),A("baseDecimal"),A("quoteDecimal"),A("state"),A("resetFlag"),A("minSize"),A("volMaxCutRatio"),A("amountWaveRatio"),A("baseLotSize"),A("quoteLotSize"),A("minPriceMultiplier"),A("maxPriceMultiplier"),A("systemDecimalValue"),A("minSeparateNumerator"),A("minSeparateDenominator"),A("tradeFeeNumerator"),A("tradeFeeDenominator"),A("pnlNumerator"),A("pnlDenominator"),A("swapFeeNumerator"),A("swapFeeDenominator"),A("baseNeedTakePnl"),A("quoteNeedTakePnl"),A("quoteTotalPnl"),A("baseTotalPnl"),A("poolOpenTime"),A("punishPcAmount"),A("punishCoinAmount"),A("orderbookToInitTime"),ne("swapBaseInAmount"),ne("swapQuoteOutAmount"),A("swapBase2QuoteFee"),ne("swapQuoteInAmount"),ne("swapBaseOutAmount"),A("swapQuote2BaseFee"),O("baseVault"),O("quoteVault"),O("baseMint"),O("quoteMint"),O("lpMint"),O("openOrders"),O("marketId"),O("marketProgramId"),O("targetOrders"),O("withdrawQueue"),O("lpVault"),O("owner"),A("lpReserve"),Y(A(),3,"padding")]),Tf=F([A("accountType"),A("status"),A("nonce"),A("maxOrder"),A("depth"),A("baseDecimal"),A("quoteDecimal"),A("state"),A("resetFlag"),A("minSize"),A("volMaxCutRatio"),A("amountWaveRatio"),A("baseLotSize"),A("quoteLotSize"),A("minPriceMultiplier"),A("maxPriceMultiplier"),A("systemDecimalsValue"),A("abortTradeFactor"),A("priceTickMultiplier"),A("priceTick"),A("minSeparateNumerator"),A("minSeparateDenominator"),A("tradeFeeNumerator"),A("tradeFeeDenominator"),A("pnlNumerator"),A("pnlDenominator"),A("swapFeeNumerator"),A("swapFeeDenominator"),A("baseNeedTakePnl"),A("quoteNeedTakePnl"),A("quoteTotalPnl"),A("baseTotalPnl"),A("poolOpenTime"),A("punishPcAmount"),A("punishCoinAmount"),A("orderbookToInitTime"),ne("swapBaseInAmount"),ne("swapQuoteOutAmount"),ne("swapQuoteInAmount"),ne("swapBaseOutAmount"),A("swapQuote2BaseFee"),A("swapBase2QuoteFee"),O("baseVault"),O("quoteVault"),O("baseMint"),O("quoteMint"),O("lpMint"),O("modelDataAccount"),O("openOrders"),O("marketId"),O("marketProgramId"),O("targetOrders"),O("owner"),Y(A(),64,"padding")]),Xa=F([_("instruction"),A("baseAmountIn"),A("quoteAmountIn"),A("fixedSide"),A("otherAmountMin")]),za=F([_("instruction"),A("lpAmount"),A("baseAmountMin"),A("quoteAmountMin")]),fB={4:yo,5:Tf},xl=F([A("fee")]);var Kl=be("Raydium_liquidity_instruction");function Cl(a){let{poolInfo:e,poolKeys:t,userKeys:n,baseAmountIn:o,quoteAmountIn:r,fixedSide:i,otherAmountMin:s,modelDataPubKey:c=En}=a,u=Buffer.alloc(Xa.span);Xa.encode({instruction:3,baseAmountIn:J(o),quoteAmountIn:J(r),otherAmountMin:J(s),fixedSide:i==="base"?tt:$u},u);let l=[k({pubkey:Uo,isWritable:!1}),k({pubkey:new Oe(e.id)}),k({pubkey:new Oe(t.authority),isWritable:!1}),k({pubkey:new Oe(t.openOrders),isWritable:!1}),k({pubkey:new Oe(t.targetOrders)}),k({pubkey:new Oe(e.lpMint.address)}),k({pubkey:new Oe(t.vault.A)}),k({pubkey:new Oe(t.vault.B)})];return e.pooltype.includes("StablePool")&&l.push(k({pubkey:c})),l.push(k({pubkey:new Oe(e.marketId),isWritable:!1}),k({pubkey:n.baseTokenAccount}),k({pubkey:n.quoteTokenAccount}),k({pubkey:n.lpTokenAccount}),k({pubkey:n.owner,isWritable:!1,isSigner:!0}),k({pubkey:new Oe(t.marketEventQueue),isWritable:!1})),new Cn({programId:new Oe(e.programId),keys:l,data:u})}function Ya(a){let{poolInfo:e,poolKeys:t,userKeys:n,lpAmount:o,baseAmountMin:r,quoteAmountMin:i,modelDataPubKey:s=En}=a,c=Ee(t),u=4;if(e.pooltype.includes("StablePool")&&(u=5),u===4||u===5){let l=Buffer.alloc(za.span);za.encode({instruction:4,lpAmount:J(o),baseAmountMin:J(r),quoteAmountMin:J(i)},l);let m=[k({pubkey:Uo,isWritable:!1}),k({pubkey:c.id}),k({pubkey:c.authority,isWritable:!1}),k({pubkey:c.openOrders}),k({pubkey:c.targetOrders}),k({pubkey:c.mintLp.address}),k({pubkey:c.vault.A}),k({pubkey:c.vault.B})];return u===5?m.push(k({pubkey:s})):(m.push(k({pubkey:c.id})),m.push(k({pubkey:c.id}))),m.push(k({pubkey:c.marketProgramId,isWritable:!1}),k({pubkey:c.marketId}),k({pubkey:c.marketBaseVault}),k({pubkey:c.marketQuoteVault}),k({pubkey:c.marketAuthority,isWritable:!1}),k({pubkey:n.lpTokenAccount}),k({pubkey:n.baseTokenAccount}),k({pubkey:n.quoteTokenAccount}),k({pubkey:n.owner,isWritable:!1,isSigner:!0}),k({pubkey:c.marketEventQueue}),k({pubkey:c.marketBids}),k({pubkey:c.marketAsks})),new Cn({programId:c.programId,keys:m,data:l})}return new Cn({programId:c.programId,keys:[]})}function Qa({programId:a,ammId:e,ammAuthority:t,ammOpenOrders:n,lpMint:o,coinMint:r,pcMint:i,coinVault:s,pcVault:c,withdrawQueue:u,ammTargetOrders:l,poolTempLp:m,marketProgramId:p,marketId:d,userWallet:f,userCoinVault:y,userPcVault:b,userLpVault:g,nonce:P,openTime:h,coinAmount:I,pcAmount:T,ammConfigId:w,feeDestinationId:K}){let x=F([_("instruction"),_("nonce"),A("openTime"),A("pcAmount"),A("coinAmount")]),S=[{pubkey:Uo,isSigner:!1,isWritable:!1},{pubkey:If,isSigner:!1,isWritable:!1},{pubkey:Sl.programId,isSigner:!1,isWritable:!1},{pubkey:Je,isSigner:!1,isWritable:!1},{pubkey:e,isSigner:!1,isWritable:!0},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!1},{pubkey:i,isSigner:!1,isWritable:!1},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:w,isSigner:!1,isWritable:!1},{pubkey:K,isSigner:!1,isWritable:!0},{pubkey:p,isSigner:!1,isWritable:!1},{pubkey:d,isSigner:!1,isWritable:!1},{pubkey:f,isSigner:!0,isWritable:!0},{pubkey:y,isSigner:!1,isWritable:!0},{pubkey:b,isSigner:!1,isWritable:!0},{pubkey:g,isSigner:!1,isWritable:!0}],B=Buffer.alloc(x.span);return x.encode({instruction:1,nonce:P,openTime:h,coinAmount:I,pcAmount:T},B),{instruction:new Cn({keys:S,programId:a,data:B}),instructionType:G.AmmV4CreatePool}}function BB(a){let e=F([_("instruction"),_("simulateType")]),t=Buffer.alloc(e.span);e.encode({instruction:12,simulateType:0},t);let n=[k({pubkey:new Oe(a.id),isWritable:!1}),k({pubkey:new Oe(a.authority),isWritable:!1}),k({pubkey:new Oe(a.openOrders),isWritable:!1}),k({pubkey:new Oe(a.vault.A),isWritable:!1}),k({pubkey:new Oe(a.vault.B),isWritable:!1}),k({pubkey:new Oe(a.mintLp.address),isWritable:!1}),k({pubkey:new Oe(a.marketId),isWritable:!1}),k({pubkey:new Oe(a.marketEventQueue),isWritable:!1})];return new Cn({programId:new Oe(a.programId),keys:n,data:t})}function Bf({poolKeys:a,userKeys:e,amountIn:t,minAmountOut:n,modelDataPubKey:o=En},r){let i=Ee(a),s=Buffer.alloc(qa.span);qa.encode({instruction:9,amountIn:J(t),minAmountOut:J(n)},s);let c=[k({pubkey:Uo,isWritable:!1}),k({pubkey:i.id}),k({pubkey:i.authority,isWritable:!1}),k({pubkey:i.openOrders})];return r===4&&c.push(k({pubkey:i.targetOrders})),c.push(k({pubkey:i.vault.A}),k({pubkey:i.vault.B})),r===5&&c.push(k({pubkey:o})),c.push(k({pubkey:i.marketProgramId,isWritable:!1}),k({pubkey:i.marketId}),k({pubkey:i.marketBids}),k({pubkey:i.marketAsks}),k({pubkey:i.marketEventQueue}),k({pubkey:i.marketBaseVault}),k({pubkey:i.marketQuoteVault}),k({pubkey:i.marketAuthority,isWritable:!1}),k({pubkey:e.tokenAccountIn}),k({pubkey:e.tokenAccountOut}),k({pubkey:e.owner,isWritable:!1,isSigner:!0})),new Cn({programId:i.programId,keys:c,data:s})}function xf({poolKeys:a,userKeys:e,maxAmountIn:t,amountOut:n,modelDataPubKey:o=En},r){let i=Ee(a),s=Buffer.alloc(Ua.span);Ua.encode({instruction:11,maxAmountIn:J(t),amountOut:J(n)},s);let c=[k({pubkey:Uo,isWritable:!1}),k({pubkey:i.id}),k({pubkey:i.authority,isWritable:!1}),k({pubkey:i.openOrders}),k({pubkey:i.targetOrders}),k({pubkey:i.vault.A}),k({pubkey:i.vault.B})];return r===5&&c.push(k({pubkey:o})),c.push(k({pubkey:i.marketProgramId,isWritable:!1}),k({pubkey:i.marketId}),k({pubkey:i.marketBids}),k({pubkey:i.marketAsks}),k({pubkey:i.marketEventQueue}),k({pubkey:i.marketBaseVault}),k({pubkey:i.marketQuoteVault}),k({pubkey:i.marketAuthority,isWritable:!1}),k({pubkey:e.tokenAccountIn}),k({pubkey:e.tokenAccountOut}),k({pubkey:e.owner,isWritable:!1,isSigner:!0})),new Cn({programId:i.programId,keys:c,data:s})}function Qr(a){let{poolKeys:e,version:t,userKeys:n,amountIn:o,amountOut:r,fixedSide:i}=a;if(t===4||t===5){let s={poolKeys:e,userKeys:n};if(i==="in")return Bf(q(M({},s),{amountIn:o,minAmountOut:r}),t);if(i==="out")return xf(q(M({},s),{maxAmountIn:o,amountOut:r}),t);Kl.logWithError("invalid params","params",a)}throw Kl.logWithError("invalid version","poolKeys.version",t),new Error("invalid version")}function xB({poolKeys:a,userKeys:e,startTime:t}){let n=Buffer.alloc(Ga.span);Ga.encode({instruction:0,nonce:5,startTime:J(t)},n);let o=Ee(a),r=[k({pubkey:Uo,isWritable:!1}),k({pubkey:Sl.programId,isWritable:!1}),k({pubkey:hf,isWritable:!1}),k({pubkey:o.id}),k({pubkey:o.authority,isWritable:!1}),k({pubkey:o.openOrders}),k({pubkey:o.mintLp.address}),k({pubkey:o.mintA.address,isWritable:!1}),k({pubkey:o.mintB.address,isWritable:!1}),k({pubkey:o.vault.A,isWritable:!1}),k({pubkey:o.vault.B,isWritable:!1}),k({pubkey:o.id}),k({pubkey:o.targetOrders}),k({pubkey:e.lpTokenAccount}),k({pubkey:o.id,isWritable:!1}),k({pubkey:o.marketProgramId,isWritable:!1}),k({pubkey:o.marketId,isWritable:!1}),k({pubkey:e.payer,isSigner:!0})];return new Cn({programId:o.programId,keys:r,data:n})}function Rl({poolKeys:a}){let e=F([_("instruction"),_("simulateType")]),t=Buffer.alloc(e.span);e.encode({instruction:12,simulateType:0},t);let n=[k({pubkey:new Oe(a.id),isWritable:!1}),k({pubkey:new Oe(a.authority),isWritable:!1}),k({pubkey:new Oe(a.openOrders),isWritable:!1}),k({pubkey:new Oe(a.vault.A),isWritable:!1}),k({pubkey:new Oe(a.vault.B),isWritable:!1}),k({pubkey:new Oe(a.mintLp.address),isWritable:!1}),k({pubkey:new Oe(a.marketId),isWritable:!1}),k({pubkey:new Oe(a.marketEventQueue),isWritable:!1})];return{instruction:new Cn({programId:new Oe(a.programId),keys:n,data:t})}}var go=5e4,Kf=F([A("x"),A("y"),A("price")]),Sf=F([A("accountType"),A("status"),A("multiplier"),A("validDataCount"),Y(Kf,go,"DataElement")]);function Cf(a,e){return[0,go-2]}function Rf(a){return[0,go-2]}function Lf(a){return[0,go-2]}function Of(a,e,t){let[n,o]=Cf(e,t),r=n,i=o,s=0,c=e*a.multiplier/t;for(;r<=i;){if(s=Math.floor((i+r)/2),s===0||s>=go-2)return[s,s,!1];let u=a.DataElement[s].x*a.multiplier/a.DataElement[s].y,l=a.DataElement[s-1].x*a.multiplier/a.DataElement[s-1].y,m=a.DataElement[s+1].x*a.multiplier/a.DataElement[s+1].y;if(c===u)return[s,s,!0];if(c===l)return[s-1,s-1,!0];if(c===m)return[s+1,s+1,!0];if(c<l)i=s-1;else{if(c>l&&c<u)return[s-1,s,!0];if(c>u&&c<m)return[s,s+1,!0];r=s+1}}return[s,s,!1]}function Ha(a,e,t){let[n,o,r]=Of(a,e,t);if(!r)return 0;if(n===o){let i=a.DataElement[n].x;return e*a.multiplier/i}else{let i=a.DataElement[n].x,s=a.DataElement[n].y,c=a.DataElement[o].x,u=a.DataElement[o].y,l=t*(c*s-i*u),m=i*l,p=(c-i)*(e*s-i*t)*u,d=m+p;return e*a.multiplier*l/d}}function bo(a,e,t){return e*a.multiplier/t}function Ll(a,e,t){return e*t/a.multiplier}function Nf(a,e){let[t,n]=Rf(e),o=t,r=n,i=0,s=e;for(;o<r;){if(i=Math.floor((r+o)/2),i<=0||i>go-2)return[i,i,!1];let c=a.DataElement[i].x,u=a.DataElement[i-1].x,l=a.DataElement[i+1].x;if(s===c)return[i,i,!0];if(s===u)return[i-1,i-1,!0];if(s===l)return[i+1,i+1,!0];if(s<u)r=i-1;else{if(s>u&&s<c)return[i-1,i,!0];if(s>c&&s<l)return[i,i+1,!0];o=i+1}}return[i,i,!1]}function Mf(a,e){let[t,n]=Lf(e),o=t,r=n,i=0,s=e;for(;o<=r;){if(i=Math.floor((r+o)/2),i<=0||i>=go-2)return[i,i,!1];let c=a.DataElement[i].y,u=a.DataElement[i-1].y,l=a.DataElement[i+1].y;if(s===c)return[i,i,!0];if(s===u)return[i-1,i-1,!0];if(s===l)return[i+1,i+1,!0];if(s<l)o=i+1;else{if(s<u&&s>c)return[i-1,i,!0];if(s<c&&s>l)return[i,i+1,!0];r=i-1}}return[i,i,!1]}function Ol(a,e,t,n){let o=n?e+t:e-t,[r,i,s]=Nf(a,o);if(!s)return[0,0,!1,s];if(r===i)return[a.DataElement[i].price,a.DataElement[i].y,!1,s];{let c=a.DataElement[r].x,u=a.DataElement[i].x,l=a.DataElement[r].price,m=a.DataElement[i].price,p=a.DataElement[r].y,d=a.DataElement[i].y;if(e>=c&&e<=u)return n?[m,d,!0,s]:[l,p,!0,s];{let f,y;return n?(f=l+(m-l)*(e-c)/(u-c),y=p-(o-c)*a.multiplier/m):(f=l+(m-l)*(e-c)/(u-c),y=d+(u-o)*a.multiplier/l),[f,y,!1,s]}}}function vf(a,e,t,n){let o=n?e-t:e+t,[r,i,s]=Mf(a,o);if(!s)return[0,0,!1,s];if(r===i)return[a.DataElement[i].price,a.DataElement[i].x,!1,s];{let c=a.DataElement[r].x,u=a.DataElement[i].x,l=a.DataElement[r].price,m=a.DataElement[i].price,p=a.DataElement[r].y,d=a.DataElement[i].y;if(e>=d&&e<=p)return n?[m,u,!0,s]:[l,c,!0,s];{let f,y;return n?(f=l+(m-l)*(p-e)/(p-d),y=c+m*(p-o)/a.multiplier):(f=l+(m-l)*(p-e)/(p-d),y=u-l*(o-d)/a.multiplier),[f,y,!1,s]}}}function Ff(a,e){let t=Ol(a,e,0,!1);return t[3]?t[0]:0}function Nl(a,e,t,n){let o=Ha(a,e,t),r=bo(a,e,o),i=bo(a,t,o),s=bo(a,n,o),c=!0,[u,l,m,p]=Ol(a,r,s,c);if(!p)return 0;if(m)return n*a.multiplier/u;{let d=i-l;return Ll(a,d,o)}}function Ml(a,e,t,n){let o=Ha(a,e,t),r=bo(a,e,o),i=bo(a,t,o),s=bo(a,n,o),c=!1,[u,l,m,p]=vf(a,i,s,c);if(!p)return 0;if(m)return n*u/a.multiplier;{let d=r-l;return Ll(a,d,o)}}function Vf(a){let e=Sf.decode(a);return{accountType:e.accountType.toNumber(),status:e.status.toNumber(),multiplier:e.multiplier.toNumber(),validDataCount:e.validDataCount.toNumber(),DataElement:e.DataElement.map(t=>({x:t.x.toNumber(),y:t.y.toNumber(),price:t.price.toNumber()}))}}function vl(a,e,t,n){let o=Ff(a,bo(a,e,Ha(a,e,t)))/a.multiplier;return n?o:1/o}var Go=class{constructor({connection:e,modelDataPubKey:t=En}){this._layoutData={accountType:0,status:0,multiplier:0,validDataCount:0,DataElement:[]};this.connection=e,this.modelDataPubKey=t}get stableModelData(){return this._layoutData}async initStableModelLayout(){if(this._layoutData.validDataCount===0&&this.connection){let e=await this.connection.getAccountInfo(this.modelDataPubKey);e&&(this._layoutData=Vf(e==null?void 0:e.data))}}};import{PublicKey as Wi}from"@solana/web3.js";import Ei from"bn.js";import Hr from"decimal.js";import{TOKEN_PROGRAM_ID as Wf}from"@solana/spl-token";import{PublicKey as _f}from"@solana/web3.js";var Ef=be("Raydium_liquidity_serum");function Fl({programId:a,marketId:e}){let t=[e.toBuffer()],n=0,o;for(;n<100;){try{let r=t.concat(Buffer.from([n]),Buffer.alloc(7));o=_f.createProgramAddressSync(r,a)}catch(r){if(r instanceof TypeError)throw r;n++;continue}return{publicKey:o,nonce:n}}throw Ef.logWithError("unable to find a viable program address nonce","params",{programId:a,marketId:e}),new Error("unable to find a viable program address nonce")}function jr({programId:a}){let{publicKey:e}=te([Buffer.from("amm_config_account_seed","utf-8")],a);return e}function Po({name:a,programId:e,marketId:t}){let{publicKey:n}=te([e.toBuffer(),t.toBuffer(),Buffer.from(a,"utf-8")],e);return n}function Df({programId:a,marketId:e}){let{publicKey:t}=te([a.toBuffer(),e.toBuffer(),Buffer.from("open_order_associated_seed","utf-8")],a);return t}function Za({programId:a}){return te([Buffer.from([97,109,109,32,97,117,116,104,111,114,105,116,121])],a)}function Ja({version:a,marketVersion:e,marketId:t,baseMint:n,quoteMint:o,baseDecimals:r,quoteDecimals:i,programId:s,marketProgramId:c}){let u=Po({name:"amm_associated_seed",programId:s,marketId:t}),l=Po({name:"lp_mint_associated_seed",programId:s,marketId:t}),{publicKey:m,nonce:p}=Za({programId:s}),d=Po({name:"coin_vault_associated_seed",programId:s,marketId:t}),f=Po({name:"pc_vault_associated_seed",programId:s,marketId:t}),y=Po({name:"temp_lp_token_associated_seed",programId:s,marketId:t}),b=Df({programId:s,marketId:t}),g=Po({name:"target_associated_seed",programId:s,marketId:t}),P=Po({name:"withdraw_associated_seed",programId:s,marketId:t}),{publicKey:h}=Fl({programId:c,marketId:t});return{id:u,baseMint:n,quoteMint:o,lpMint:l,baseDecimals:r,quoteDecimals:i,lpDecimals:r,version:a,programId:s,authority:m,nonce:p,baseVault:d,quoteVault:f,lpVault:y,openOrders:b,targetOrders:g,withdrawQueue:P,marketVersion:e,marketProgramId:c,marketId:t,marketAuthority:h,lookupTableAccount:Wi.default,configId:jr({programId:s})}}var ja;async function JB({connection:a,poolKeysList:e,config:t,modelDataPubKey:n}){return e.find(r=>r.modelDataAccount)&&(ja||(ja=new Go({connection:a,modelDataPubKey:n}),await ja.initStableModelLayout())),await Promise.all(e.map(async r=>{if(r.modelDataAccount){let i=Rl({poolKeys:r});return(await ac(a,[i.instruction],"GetPoolData")).map(u=>{let l=uc(u,"GetPoolData"),m=new Ei(Pn(l,"status")),p=Number(Pn(l,"coin_decimals")),d=Number(Pn(l,"pc_decimals")),f=Number(Pn(l,"lp_decimals")),y=new Ei(Pn(l,"pool_coin_amount")),b=new Ei(Pn(l,"pool_pc_amount")),g=new Ei(Pn(l,"pool_lp_supply")),P="0";try{P=Pn(l,"pool_open_time")}catch{}return{status:m,baseDecimals:p,quoteDecimals:d,lpDecimals:f,baseReserve:y,quoteReserve:b,lpSupply:g,startTime:new Ei(P)}})[0]}else{let[i,s,c,u]=await a.getMultipleAccountsInfo([new Wi(r.id),new Wi(r.vault.A),new Wi(r.vault.B),new Wi(r.mintLp.address)]);if(i===null)throw Error("fetch pool error");if(s===null)throw Error("fetch vaultAccA error");if(c===null)throw Error("fetch vaultAccB error");if(u===null)throw Error("fetch mintAccLp error");let l=yo.decode(i.data),m=sn.decode(s.data),p=sn.decode(c.data),d=hl.decode(u.data);return{status:l.status,baseDecimals:l.baseDecimal.toNumber(),quoteDecimals:l.quoteDecimal.toNumber(),lpDecimals:d.decimals,baseReserve:m.amount.sub(l.baseNeedTakePnl),quoteReserve:p.amount.sub(l.quoteNeedTakePnl),lpSupply:l.lpReserve,startTime:l.poolOpenTime}}}))}var $a={volume:0,volumeQuote:0,volumeFee:0,apr:0,feeApr:0,priceMin:0,priceMax:0,rewardApr:[]},$r=a=>{let e={},t=Wf.toBase58();return Object.keys(a).map(n=>{let o=a[n],[r,i]=[o.baseMint.toBase58(),o.quoteMint.toBase58()];e[n]={id:n,version:4,status:o.status.toNumber(),programId:o.programId.toBase58(),mintA:At({address:r,programId:t,decimals:o.baseDecimal.toNumber()}),mintB:At({address:i,programId:t,decimals:o.quoteDecimal.toNumber()}),rewardDefaultInfos:[],rewardDefaultPoolInfos:"Ecosystem",price:o.poolPrice.toNumber(),mintAmountA:new Hr(o.mintAAmount.toString()).div(10**o.baseDecimal.toNumber()).toNumber(),mintAmountB:new Hr(o.mintBAmount.toString()).div(10**o.quoteDecimal.toNumber()).toNumber(),baseReserve:o.baseReserve,quoteReserve:o.quoteReserve,feeRate:new Hr(o.tradeFeeNumerator.toString()).div(o.tradeFeeDenominator.toString()).toNumber(),openTime:o.poolOpenTime.toString(),tvl:0,day:$a,week:$a,month:$a,pooltype:[],farmUpcomingCount:0,farmOngoingCount:0,farmFinishedCount:0,type:"Standard",marketId:o.marketId.toBase58(),configId:jr({programId:o.programId}).toBase58(),lpPrice:0,lpAmount:new Hr(o.lpReserve.toString()).div(10**Math.min(o.baseDecimal.toNumber(),o.quoteDecimal.toNumber())).toNumber(),lpMint:At({address:o.lpMint.toBase58(),programId:t,decimals:Math.min(o.baseDecimal.toNumber(),o.quoteDecimal.toNumber())}),burnPercent:0}}),e};import Ye from"bn.js";import Ne from"decimal.js";import{PublicKey as Di}from"@solana/web3.js";import qi from"bn.js";import{TOKEN_PROGRAM_ID as Wl}from"@solana/spl-token";import{SystemProgram as Ao,SYSVAR_RENT_PUBKEY as Uf,Transaction as Vl,TransactionInstruction as Gf}from"@solana/web3.js";import{createInitializeAccountInstruction as _l,TOKEN_PROGRAM_ID as El}from"@solana/spl-token";function qf(a="accountFlags"){let e=new Fr(a);return e.addBoolean("initialized"),e.addBoolean("market"),e.addBoolean("openOrders"),e.addBoolean("requestQueue"),e.addBoolean("eventQueue"),e.addBoolean("bids"),e.addBoolean("asks"),e}var eu=F([Be(5),qf("accountFlags"),O("ownAddress"),A("vaultSignerNonce"),O("baseMint"),O("quoteMint"),O("baseVault"),A("baseDepositsTotal"),A("baseFeesAccrued"),O("quoteVault"),A("quoteDepositsTotal"),A("quoteFeesAccrued"),A("quoteDustThreshold"),O("requestQueue"),O("eventQueue"),O("bids"),O("asks"),A("baseLotSize"),A("quoteLotSize"),A("feeRateBps"),A("referrerRebatesAccrued"),Be(7)]);function Xf({programId:a,marketInfo:e}){let t=F([_("version"),pt("instruction"),A("baseLotSize"),A("quoteLotSize"),Et("feeRateBps"),A("vaultSignerNonce"),A("quoteDustThreshold")]),n=[{pubkey:e.id,isSigner:!1,isWritable:!0},{pubkey:e.requestQueue,isSigner:!1,isWritable:!0},{pubkey:e.eventQueue,isSigner:!1,isWritable:!0},{pubkey:e.bids,isSigner:!1,isWritable:!0},{pubkey:e.asks,isSigner:!1,isWritable:!0},{pubkey:e.baseVault,isSigner:!1,isWritable:!0},{pubkey:e.quoteVault,isSigner:!1,isWritable:!0},{pubkey:e.baseMint,isSigner:!1,isWritable:!1},{pubkey:e.quoteMint,isSigner:!1,isWritable:!1},{pubkey:e.authority?e.quoteMint:Uf,isSigner:!1,isWritable:!1}].concat(e.authority?{pubkey:e.authority,isSigner:!1,isWritable:!1}:[]).concat(e.authority&&e.pruneAuthority?{pubkey:e.pruneAuthority,isSigner:!1,isWritable:!1}:[]),o=Buffer.alloc(t.span);return t.encode({version:0,instruction:0,baseLotSize:e.baseLotSize,quoteLotSize:e.quoteLotSize,feeRateBps:e.feeRateBps,vaultSignerNonce:e.vaultSignerNonce,quoteDustThreshold:e.quoteDustThreshold},o),new Gf({keys:n,programId:a,data:o})}async function Zr({connection:a,wallet:e,marketInfo:t}){var i,s,c,u,l,m,p,d;let n=new Vl,o=await a.getMinimumBalanceForRentExemption(165);n.add(Ao.createAccountWithSeed({fromPubkey:e,basePubkey:e,seed:t.baseVault.seed,newAccountPubkey:t.baseVault.publicKey,lamports:o,space:165,programId:El}),Ao.createAccountWithSeed({fromPubkey:e,basePubkey:e,seed:t.quoteVault.seed,newAccountPubkey:t.quoteVault.publicKey,lamports:o,space:165,programId:El}),_l(t.baseVault.publicKey,t.baseMint,t.vaultOwner),_l(t.quoteVault.publicKey,t.quoteMint,t.vaultOwner),Ao.createAccountWithSeed({fromPubkey:e,basePubkey:e,seed:t.id.seed,newAccountPubkey:t.id.publicKey,lamports:await a.getMinimumBalanceForRentExemption(eu.span),space:eu.span,programId:t.programId}));let r=new Vl;return r.add(Ao.createAccountWithSeed({fromPubkey:e,basePubkey:e,seed:t.requestQueue.seed,newAccountPubkey:t.requestQueue.publicKey,lamports:t.lowestFeeMarket?6208320:await a.getMinimumBalanceForRentExemption((i=t.requestQueueSpace)!=null?i:5120+12),space:t.lowestFeeMarket?764:(s=t.requestQueueSpace)!=null?s:5120+12,programId:t.programId}),Ao.createAccountWithSeed({fromPubkey:e,basePubkey:e,seed:t.eventQueue.seed,newAccountPubkey:t.eventQueue.publicKey,lamports:t.lowestFeeMarket?79594560:await a.getMinimumBalanceForRentExemption((c=t.eventQueueSpace)!=null?c:262144+12),space:t.lowestFeeMarket?11308:(u=t.eventQueueSpace)!=null?u:262144+12,programId:t.programId}),Ao.createAccountWithSeed({fromPubkey:e,basePubkey:e,seed:t.bids.seed,newAccountPubkey:t.bids.publicKey,lamports:t.lowestFeeMarket?101977920:await a.getMinimumBalanceForRentExemption((l=t.orderbookQueueSpace)!=null?l:65536+12),space:t.lowestFeeMarket?14524:(m=t.orderbookQueueSpace)!=null?m:65536+12,programId:t.programId}),Ao.createAccountWithSeed({fromPubkey:e,basePubkey:e,seed:t.asks.seed,newAccountPubkey:t.asks.publicKey,lamports:t.lowestFeeMarket?101977920:await a.getMinimumBalanceForRentExemption((p=t.orderbookQueueSpace)!=null?p:65536+12),space:t.lowestFeeMarket?14524:(d=t.orderbookQueueSpace)!=null?d:65536+12,programId:t.programId}),Xf({programId:t.programId,marketInfo:{id:t.id.publicKey,requestQueue:t.requestQueue.publicKey,eventQueue:t.eventQueue.publicKey,bids:t.bids.publicKey,asks:t.asks.publicKey,baseVault:t.baseVault.publicKey,quoteVault:t.quoteVault.publicKey,baseMint:t.baseMint,quoteMint:t.quoteMint,baseLotSize:t.baseLotSize,quoteLotSize:t.quoteLotSize,feeRateBps:t.feeRateBps,vaultSignerNonce:t.vaultSignerNonce,quoteDustThreshold:t.quoteDustThreshold}})),[{transaction:n,signer:[],instructionTypes:[G.CreateAccount,G.CreateAccount,G.InitAccount,G.InitAccount]},{transaction:r,signer:[],instructionTypes:[G.CreateAccount,G.CreateAccount,G.CreateAccount,G.CreateAccount,G.CreateAccount,G.InitMarket]}]}var Xo=class extends We{async create({baseInfo:e,quoteInfo:t,lotSize:n,tickSize:o,dexProgramId:r,requestQueueSpace:i,eventQueueSpace:s,orderbookQueueSpace:c,lowestFeeMarket:u,assignSeed:l,txVersion:m,computeBudgetConfig:p,txTipConfig:d,feePayer:f}){let y=this.scope.ownerPubKey,b=l?`${e.mint.toBase58().slice(0,10)}-${t.mint.toBase58().slice(0,10)}-${l}`:void 0,g=je({fromPublicKey:y,programId:r,assignSeed:b&&`${b}-market`}),P=je({fromPublicKey:y,programId:r,assignSeed:b&&`${b}-request`}),h=je({fromPublicKey:y,programId:r,assignSeed:b&&`${b}-event`}),I=je({fromPublicKey:y,programId:r,assignSeed:b&&`${b}-bids`}),T=je({fromPublicKey:y,programId:r,assignSeed:b&&`${b}-asks`}),w=je({fromPublicKey:y,programId:Wl,assignSeed:b&&`${b}-baseVault`}),K=je({fromPublicKey:y,programId:Wl,assignSeed:b&&`${b}-quoteVault`}),x=0,S=new qi(100);function B(){let X=new qi(0);for(;;)try{return{vaultOwner:Di.createProgramAddressSync([g.publicKey.toBuffer(),X.toArrayLike(Buffer,"le",8)],r),vaultSignerNonce:X}}catch{if(X.iaddn(1),X.gt(new qi(25555)))throw Error("find vault owner error")}}let{vaultOwner:R,vaultSignerNonce:C}=B(),v=new qi(Math.round(10**e.decimals*n)),L=new qi(Math.round(n*10**t.decimals*o));if(v.eq(tt))throw Error("lot size is too small");if(L.eq(tt))throw Error("tick size or lot size is too small");let N=await Zr({connection:this.scope.connection,wallet:this.scope.ownerPubKey,marketInfo:{programId:r,id:g,baseMint:e.mint,quoteMint:t.mint,baseVault:w,quoteVault:K,vaultOwner:R,requestQueue:P,eventQueue:h,bids:I,asks:T,feeRateBps:x,quoteDustThreshold:S,vaultSignerNonce:C,baseLotSize:v,quoteLotSize:L,requestQueueSpace:i,eventQueueSpace:s,orderbookQueueSpace:c,lowestFeeMarket:u}}),E=this.createTxBuilder(f);E.addInstruction({instructions:N[0].transaction.instructions,signers:N[0].signer});for await(let X of N.slice(1,N.length))E.addInstruction({instructions:X.transaction.instructions,signers:X.signer,instructionTypes:X.instructionTypes});return m===0?E.sizeCheckBuildV0({computeBudgetConfig:p,address:{marketId:g.publicKey,requestQueue:P.publicKey,eventQueue:h.publicKey,bids:I.publicKey,asks:T.publicKey,baseVault:w.publicKey,quoteVault:K.publicKey,baseMint:new Di(e.mint),quoteMint:new Di(t.mint)}}):E.sizeCheckBuild({computeBudgetConfig:p,address:{marketId:g.publicKey,requestQueue:P.publicKey,eventQueue:h.publicKey,bids:I.publicKey,asks:T.publicKey,baseVault:w.publicKey,quoteVault:K.publicKey,baseMint:new Di(e.mint),quoteMint:new Di(t.mint)}})}};var Ui=class extends We{constructor(t){super(t);this.stableLayout=new Go({connection:this.scope.connection,modelDataPubKey:this.scope.cluster==="mainnet"?void 0:kn.MODEL_DATA_PUBKEY})}async initLayout(){await this.stableLayout.initStableModelLayout()}async load(){this.checkDisabled()}computePairAmount({poolInfo:t,amount:n,slippage:o,baseIn:r}){let i=new Ye(new Ne(n).mul(10**t[r?"mintA":"mintB"].decimals).toFixed(0)),s=zr(t[r?"mintB":"mintA"]),[c,u]=[new Ye(new Ne(t.mintAmountA).mul(10**t.mintA.decimals).toString()),new Ye(new Ne(t.mintAmountB).mul(10**t.mintB.decimals).toString())],l=new Ye(new Ne(t.lpAmount).mul(10**t.lpMint.decimals).toFixed(0,Ne.ROUND_DOWN));this.logDebug("baseReserve:",c.toString(),"quoteReserve:",u.toString()),this.logDebug("tokenIn:",r?t.mintA.symbol:t.mintB.symbol,"amountIn:",i.toString(),"anotherToken:",r?t.mintB.symbol:t.mintA.symbol,"slippage:",`${o.toSignificant()}%`,"baseReserve",c.toString(),"quoteReserve",u.toString());let m=r?"base":"quote";this.logDebug("input side:",m);let p=tt;i.isZero()||(p=m==="base"?kr(i.mul(u),c):kr(i.mul(c),u)),this.logDebug("amountRaw:",p.toString(),"lpAmount:",l.toString());let d=kr(i.mul(l),m==="base"?c:u);this.logDebug("liquidity:",d.toString());let f=new Qe(new Ye(1)).add(o),y=new Qe(new Ye(1)).sub(o),b=f.mul(p).quotient,g=y.mul(p).quotient,P=new Ie(s,p),h=new Ie(s,b),I=new Ie(s,g);return this.logDebug("anotherAmount:",P.toFixed(),"maxAnotherAmount:",h.toFixed()),{anotherAmount:P,maxAnotherAmount:h,minAnotherAmount:I,liquidity:d}}async getAmmPoolKeys(t){return(await this.scope.api.fetchPoolKeysById({idList:[t]}))[0]}async addLiquidity(t){let{poolInfo:n,poolKeys:o,amountInA:r,amountInB:i,otherAmountMin:s,fixedSide:c,config:u,txVersion:l,computeBudgetConfig:m,txTipConfig:p,feePayer:d}=t;this.scope.availability.addStandardPosition===!1&&this.logAndCreateError("add liquidity feature disabled in your region"),this.logDebug("amountInA:",r,"amountInB:",i),(r.isZero()||i.isZero())&&this.logAndCreateError("amounts must greater than zero","amountInA & amountInB",{amountInA:r.toFixed(),amountInB:i.toFixed()});let{account:f}=this.scope,{bypassAssociatedCheck:y,checkCreateATAOwner:b}=M({bypassAssociatedCheck:!1,checkCreateATAOwner:!1},u),[g,P]=[r.token,i.token],h=await f.getCreatedTokenAccount({mint:g.mint,associatedOnly:!1}),I=await f.getCreatedTokenAccount({mint:P.mint,associatedOnly:!1});!h&&!I&&this.logAndCreateError("cannot found target token accounts","tokenAccounts",f.tokenAccounts);let T=await f.getCreatedTokenAccount({mint:new nt(n.lpMint.address)}),w=[g,P],K=[h,I],x=[r.raw,i.raw],S=r.token.mint.toBase58()===n.mintA.address?"base":"quote",B="base";["quote","base"].includes(S)||this.logAndCreateError("invalid fixedSide","fixedSide",c),S==="quote"?(w.reverse(),K.reverse(),x.reverse(),B=c==="a"?"quote":"base"):S==="base"&&(B=c==="a"?"base":"quote");let[R,C]=w,[v,L]=K,[N,E]=x,X=o!=null?o:await this.getAmmPoolKeys(n.id),Q=this.createTxBuilder(d),oe=await f.handleTokenAccount({side:"in",amount:N,mint:R.mint,tokenAccount:v,bypassAssociatedCheck:y,checkCreateATAOwner:b}),{tokenAccount:ee}=oe,de=_e(oe,["tokenAccount"]);Q.addInstruction(de);let Le=await f.handleTokenAccount({side:"in",amount:E,mint:C.mint,tokenAccount:L,bypassAssociatedCheck:y,checkCreateATAOwner:b}),{tokenAccount:re}=Le,ue=_e(Le,["tokenAccount"]);Q.addInstruction(ue);let ye=await f.handleTokenAccount({side:"out",amount:0,mint:new nt(n.lpMint.address),tokenAccount:T,bypassAssociatedCheck:y,checkCreateATAOwner:b}),{tokenAccount:ge}=ye,pe=_e(ye,["tokenAccount"]);return Q.addInstruction(pe),Q.addInstruction({instructions:[Cl({poolInfo:n,poolKeys:X,userKeys:{baseTokenAccount:ee,quoteTokenAccount:re,lpTokenAccount:ge,owner:this.scope.ownerPubKey},baseAmountIn:N,quoteAmountIn:E,otherAmountMin:s.raw,fixedSide:B})],instructionTypes:[n.pooltype.includes("StablePool")?G.AmmV5AddLiquidity:G.AmmV4AddLiquidity],lookupTableAddress:X.lookupTableAccount?[X.lookupTableAccount]:[]}),Q.addCustomComputeBudget(m),Q.addTipInstruction(p),l===0?await Q.buildV0():Q.build()}async removeLiquidity(t){this.scope.availability.removeStandardPosition===!1&&this.logAndCreateError("remove liquidity feature disabled in your region");let{poolInfo:n,poolKeys:o,lpAmount:r,baseAmountMin:i,quoteAmountMin:s,config:c,txVersion:u,computeBudgetConfig:l,txTipConfig:m,feePayer:p}=t,d=o!=null?o:await this.getAmmPoolKeys(n.id),[f,y,b]=[new nt(n.mintA.address),new nt(n.mintB.address),new nt(n.lpMint.address)];this.logDebug("lpAmount:",r),this.logDebug("baseAmountMin:",i),this.logDebug("quoteAmountMin:",s),r.isZero()&&this.logAndCreateError("amount must greater than zero","lpAmount",r.toString());let{account:g}=this.scope,P=await g.getCreatedTokenAccount({mint:b,associatedOnly:!1});P||this.logAndCreateError("cannot found lpTokenAccount","tokenAccounts",g.tokenAccounts);let h=await g.getCreatedTokenAccount({mint:f}),I=await g.getCreatedTokenAccount({mint:y}),T=this.createTxBuilder(p),{bypassAssociatedCheck:w,checkCreateATAOwner:K}=M({bypassAssociatedCheck:!1,checkCreateATAOwner:!1},c),C=await g.handleTokenAccount({side:"out",amount:0,mint:f,tokenAccount:h,bypassAssociatedCheck:w,checkCreateATAOwner:K}),{tokenAccount:x}=C,S=_e(C,["tokenAccount"]);T.addInstruction(S);let v=await g.handleTokenAccount({side:"out",amount:0,mint:y,tokenAccount:I,bypassAssociatedCheck:w,checkCreateATAOwner:K}),{tokenAccount:B}=v,R=_e(v,["tokenAccount"]);return T.addInstruction(R),T.addInstruction({instructions:[Ya({poolInfo:n,poolKeys:d,userKeys:{lpTokenAccount:P,baseTokenAccount:x,quoteTokenAccount:B,owner:this.scope.ownerPubKey},lpAmount:r,baseAmountMin:i,quoteAmountMin:s})],lookupTableAddress:d.lookupTableAccount?[d.lookupTableAccount]:[],instructionTypes:[n.pooltype.includes("StablePool")?G.AmmV5RemoveLiquidity:G.AmmV4RemoveLiquidity]}),T.addCustomComputeBudget(l),T.addTipInstruction(m),u===0?await T.buildV0():T.build()}async removeAllLpAndCreateClmmPosition({poolInfo:t,clmmPoolInfo:n,removeLpAmount:o,createPositionInfo:r,farmInfo:i,userFarmLpAmount:s,base:c,computeBudgetConfig:u,payer:l,userAuxiliaryLedgers:m,tokenProgram:p=Qn,checkCreateATAOwner:d=!0,getEphemeralSigners:f,txVersion:y,feePayer:b}){if((this.scope.availability.removeStandardPosition===!1||this.scope.availability.createConcentratedPosition===!1)&&this.logAndCreateError("remove liquidity or create position feature disabled in your region"),!(t.mintA.address===n.mintA.address||t.mintA.address===n.mintB.address)||!(t.mintB.address===n.mintA.address||t.mintB.address===n.mintB.address))throw Error("mint check error");let g=this.createTxBuilder(b),P={};for(let X of this.scope.account.tokenAccountRawInfos)(P[X.accountInfo.mint.toString()]===void 0||j(this.scope.ownerPubKey,X.accountInfo.mint,Qn).publicKey.equals(X.pubkey))&&(P[X.accountInfo.mint.toString()]=X.pubkey);let h=P[t.lpMint.address];if(h===void 0)throw Error("find lp account error in trade accounts");let I=o.add(s!=null?s:new Ye(0)),T=t.mintA.address===Ke.WSOL.mint.toString(),w=t.mintB.address===Ke.WSOL.mint.toString(),{account:K,instructionParams:x}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:Qn,mint:new nt(t.mintA.address),owner:this.scope.ownerPubKey,createInfo:T?{payer:this.scope.ownerPubKey}:void 0,skipCloseAccount:!T,notUseTokenAccount:T,associatedOnly:!0,checkCreateATAOwner:d});if(g.addInstruction(x||{}),K===void 0)throw new Error("base token account not found");let{account:S,instructionParams:B}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:Qn,mint:new nt(t.mintB.address),owner:this.scope.ownerPubKey,createInfo:w?{payer:this.scope.ownerPubKey,amount:0}:void 0,skipCloseAccount:!w,notUseTokenAccount:w,associatedOnly:!0,checkCreateATAOwner:d});if(g.addInstruction(B||{}),S===void 0)throw new Error("quote token account not found");if(P[t.mintA.address]=K,P[t.mintB.address]=S,i!==void 0&&!(s!=null&&s.isZero())){let X=Xt[i.programId],Q=gt({programId:new nt(i.programId),poolId:new nt(i.id),owner:this.scope.ownerPubKey,version:X}),ee,de=await this.scope.connection.getAccountInfo(Q);if(de&&(ee=_o(X).decode(de.data)),X!==6&&!ee){let{instruction:ye,instructionType:ot}=Bi({id:new nt(i.id),programId:new nt(i.programId),version:X,ledger:Q,owner:this.scope.ownerPubKey});g.addInstruction({instructions:[ye],instructionTypes:[ot]})}let re=[];for(let ye of i.rewardInfos){let ot=ye.mint.address===Ke.WSOL.mint.toString();if(P[ye.mint.address])re.push(P[ye.mint.address]);else{let{account:xo,instructionParams:cn}=await this.scope.account.getOrCreateTokenAccount({mint:new nt(ye.mint.address),tokenProgram:p,owner:this.scope.ownerPubKey,skipCloseAccount:!ot,createInfo:{payer:l||this.scope.ownerPubKey},associatedOnly:!0,checkCreateATAOwner:d});xo||this.logAndCreateError("farm reward account not found:",ye.mint.address),cn&&g.addInstruction(cn),re.push(xo)}}let ue=(await this.scope.api.fetchFarmKeysById({ids:i.id}))[0],ge={userAuxiliaryLedgers:m,amount:s,owner:this.scope.ownerPubKey,farmInfo:i,farmKeys:ue,lpAccount:h,rewardAccounts:re},pe=Xt[i.programId],oe=pe===6?xi(ge):pe===5?Ki(ge):Si(ge),Le={3:G.FarmV3Withdraw,5:G.FarmV5Withdraw,6:G.FarmV6Withdraw};g.addInstruction({instructions:[oe],instructionTypes:[Le[pe]]})}let R=await this.getAmmPoolKeys(t.id),C=Ya({poolInfo:t,poolKeys:R,userKeys:{lpTokenAccount:h,baseTokenAccount:K,quoteTokenAccount:S,owner:this.scope.ownerPubKey},lpAmount:I,baseAmountMin:0,quoteAmountMin:0});g.addInstruction({instructions:[C],instructionTypes:[t.pooltype.includes("StablePool")?G.AmmV5RemoveLiquidity:G.AmmV4RemoveLiquidity],lookupTableAddress:R.lookupTableAccount?[R.lookupTableAccount]:[]});let[v,L]=t.mintA.address===n.mintA.address?[K,S]:[S,K],N=await this.scope.clmm.getClmmPoolKeys(n.id),E=await Re.openPositionFromBaseInstructions(q(M({poolInfo:n,poolKeys:N,ownerInfo:{feePayer:this.scope.ownerPubKey,wallet:this.scope.ownerPubKey,tokenAccountA:v,tokenAccountB:L},withMetadata:"create"},r),{base:c,getEphemeralSigners:f}));return g.addInstruction({instructions:[...E.instructions],signers:E.signers,instructionTypes:[...E.instructionTypes],lookupTableAddress:N.lookupTableAccount?[N.lookupTableAccount]:[]}),y===0?g.sizeCheckBuildV0({computeBudgetConfig:u}):g.sizeCheckBuild({computeBudgetConfig:u})}async createPoolV4({programId:t,marketInfo:n,baseMintInfo:o,quoteMintInfo:r,baseAmount:i,quoteAmount:s,startTime:c,ownerInfo:u,associatedOnly:l=!1,checkCreateATAOwner:m=!1,tokenProgram:p,txVersion:d,feeDestinationId:f,computeBudgetConfig:y,txTipConfig:b,feePayer:g}){var L;let P=u.feePayer||((L=this.scope.owner)==null?void 0:L.publicKey),h=u.useSOLBalance&&o.mint.equals(Jr),I=u.useSOLBalance&&r.mint.equals(Jr),T=this.createTxBuilder(g),{account:w,instructionParams:K}=await this.scope.account.getOrCreateTokenAccount({mint:o.mint,owner:this.scope.ownerPubKey,createInfo:h?{payer:P,amount:i}:void 0,notUseTokenAccount:h,skipCloseAccount:!h,associatedOnly:h?!1:l,checkCreateATAOwner:m});T.addInstruction(K||{});let{account:x,instructionParams:S}=await this.scope.account.getOrCreateTokenAccount({mint:r.mint,owner:this.scope.ownerPubKey,createInfo:I?{payer:P,amount:s}:void 0,notUseTokenAccount:I,skipCloseAccount:!I,associatedOnly:I?!1:l,checkCreateATAOwner:m});if(T.addInstruction(S||{}),w===void 0||x===void 0)throw Error("you don't has some token account");let B=Ja({version:4,marketVersion:3,marketId:n.marketId,baseMint:o.mint,quoteMint:r.mint,baseDecimals:o.decimals,quoteDecimals:r.decimals,programId:t,marketProgramId:n.programId}),R={programId:t,ammId:B.id,ammAuthority:B.authority,ammOpenOrders:B.openOrders,lpMint:B.lpMint,coinMint:B.baseMint,pcMint:B.quoteMint,coinVault:B.baseVault,pcVault:B.quoteVault,withdrawQueue:B.withdrawQueue,ammTargetOrders:B.targetOrders,poolTempLp:B.lpVault,marketProgramId:B.marketProgramId,marketId:B.marketId,ammConfigId:B.configId,feeDestinationId:f},{instruction:C,instructionType:v}=Qa(q(M({},R),{userWallet:this.scope.ownerPubKey,userCoinVault:w,userPcVault:x,userLpVault:j(this.scope.ownerPubKey,B.lpMint,p).publicKey,nonce:B.nonce,openTime:c,coinAmount:i,pcAmount:s}));return T.addInstruction({instructions:[C],instructionTypes:[v]}),T.addCustomComputeBudget(y),T.addTipInstruction(b),T.versionBuild({txVersion:d,extInfo:{address:R}})}async createMarketAndPoolV4({programId:t=ci,marketProgram:n=Ds,feeDestinationId:o=qs,tokenProgram:r,baseMintInfo:i,quoteMintInfo:s,baseAmount:c,quoteAmount:u,startTime:l,ownerInfo:m,lowestFeeMarket:p,assignSeed:d,associatedOnly:f=!1,checkCreateATAOwner:y=!1,lotSize:b=1,tickSize:g=.01,txVersion:P,computeBudgetConfig:h,txTipConfig:I,feePayer:T}){var Ko,So,ks;let w=this.scope.ownerPubKey,K=m.feePayer||((Ko=this.scope.owner)==null?void 0:Ko.publicKey),x=m.useSOLBalance&&i.mint.equals(Jr),S=m.useSOLBalance&&s.mint.equals(Jr),B=d?`${i.mint.toBase58().slice(0,7)}-${s.mint.toBase58().slice(0,7)}-${d}`:void 0,R=je({fromPublicKey:w,programId:n,assignSeed:B&&`${B}-market`}),C=je({fromPublicKey:w,programId:n,assignSeed:B&&`${B}-request`}),v=je({fromPublicKey:w,programId:n,assignSeed:B&&`${B}-event`}),L=je({fromPublicKey:w,programId:n,assignSeed:B&&`${B}-bids`}),N=je({fromPublicKey:w,programId:n,assignSeed:B&&`${B}-asks`}),E=je({fromPublicKey:w,programId:Qn,assignSeed:B&&`${B}-baseVault`}),X=je({fromPublicKey:w,programId:Qn,assignSeed:B&&`${B}-quoteVault`}),Q=0,ee=new Ye(100);function de(){let Vt=new Ye(0);for(;;)try{return{vaultOwner:nt.createProgramAddressSync([R.publicKey.toBuffer(),Vt.toArrayLike(Buffer,"le",8)],n),vaultSignerNonce:Vt}}catch{if(Vt.iaddn(1),Vt.gt(new Ye(25555)))throw Error("find vault owner error")}}let{vaultOwner:re,vaultSignerNonce:ue}=de(),ge=new Ye(Math.round(10**i.decimals*b)),pe=new Ye(Math.round(b*10**s.decimals*g));if(ge.eq(tt))throw Error("lot size is too small");if(pe.eq(tt))throw Error("tick size or lot size is too small");let oe=await Zr({connection:this.scope.connection,wallet:this.scope.ownerPubKey,marketInfo:{programId:n,vaultOwner:re,baseMint:i.mint,quoteMint:s.mint,id:R,baseVault:E,quoteVault:X,requestQueue:C,eventQueue:v,bids:L,asks:N,feeRateBps:Q,quoteDustThreshold:ee,vaultSignerNonce:ue,baseLotSize:ge,quoteLotSize:pe,lowestFeeMarket:p}}),Le=this.createTxBuilder(T);Le.addInstruction({instructions:oe[0].transaction.instructions,signers:oe[0].signer});for await(let Vt of oe.slice(1,oe.length))Le.addInstruction({instructions:Vt.transaction.instructions,signers:Vt.signer,instructionTypes:Vt.instructionTypes});let{account:ye,instructionParams:ot}=await this.scope.account.getOrCreateTokenAccount({mint:i.mint,owner:this.scope.ownerPubKey,createInfo:x?{payer:K,amount:c}:void 0,notUseTokenAccount:x,skipCloseAccount:!x,associatedOnly:x?!1:f,checkCreateATAOwner:y,assignSeed:x&&B?`${B}-wsol`:void 0});Le.addInstruction(ot||{});let{account:xo,instructionParams:cn}=await this.scope.account.getOrCreateTokenAccount({mint:s.mint,owner:this.scope.ownerPubKey,createInfo:S?{payer:K,amount:u}:void 0,notUseTokenAccount:S,skipCloseAccount:!S,associatedOnly:S?!1:f,checkCreateATAOwner:y,assignSeed:S&&B?`${B}-wsol`:void 0});if(Le.addInstruction(cn||{}),ye===void 0)throw Error("you don't has base token account");if(xo===void 0)throw Error("you don't has quote token account");let Me=Ja({version:4,marketVersion:3,marketId:R.publicKey,baseMint:i.mint,quoteMint:s.mint,baseDecimals:i.decimals,quoteDecimals:s.decimals,programId:t,marketProgramId:n}),Jo={programId:t,ammId:Me.id,ammAuthority:Me.authority,ammOpenOrders:Me.openOrders,lpMint:Me.lpMint,coinMint:Me.baseMint,pcMint:Me.quoteMint,coinVault:Me.baseVault,pcVault:Me.quoteVault,withdrawQueue:Me.withdrawQueue,ammTargetOrders:Me.targetOrders,poolTempLp:Me.lpVault,marketProgramId:Me.marketProgramId,marketId:Me.marketId,ammConfigId:Me.configId,feeDestinationId:o},{instruction:As,instructionType:ei}=Qa(q(M({},Jo),{userWallet:this.scope.ownerPubKey,userCoinVault:ye,userPcVault:xo,userLpVault:j(this.scope.ownerPubKey,Me.lpMint,r).publicKey,nonce:Me.nonce,openTime:l,coinAmount:c,pcAmount:u}));Le.addInstruction({instructions:[As],instructionTypes:[ei]});let Jt=x||S?[((So=ot==null?void 0:ot.instructions)==null?void 0:So[0])||((ks=cn==null?void 0:cn.instructions)==null?void 0:ks[0])].filter(Vt=>!!Vt):void 0;return P===0?Le.sizeCheckBuildV0({computeBudgetConfig:h,splitIns:Jt,address:M({requestQueue:C.publicKey,eventQueue:v.publicKey,bids:L.publicKey,asks:N.publicKey,baseVault:E.publicKey,quoteVault:X.publicKey,baseMint:new nt(i.mint),quoteMint:new nt(s.mint)},Jo)}):Le.sizeCheckBuild({computeBudgetConfig:h,splitIns:Jt,address:M({requestQueue:C.publicKey,eventQueue:v.publicKey,bids:L.publicKey,asks:N.publicKey,baseVault:E.publicKey,quoteVault:X.publicKey,baseMint:new nt(i.mint),quoteMint:new nt(s.mint)},Jo)})}async getCreatePoolFee({programId:t}){let n=jr({programId:t}),o=await this.scope.connection.getAccountInfo(n,{dataSlice:{offset:536,length:8}});if(o===null)throw Error("get config account error");return xl.decode(o.data).fee}computeAmountOut({poolInfo:t,amountIn:n,mintIn:o,mintOut:r,slippage:i}){let[s,c]=[o.toString(),r.toString()];if(s!==t.mintA.address&&s!==t.mintB.address)throw new Error("toke not match");if(c!==t.mintA.address&&c!==t.mintB.address)throw new Error("toke not match");let{baseReserve:u,quoteReserve:l}=t,m=[u,l],p=[t.mintA.decimals,t.mintB.decimals],d=s==t.mintA.address?"base":"quote";d==="quote"&&(m.reverse(),p.reverse());let[f,y]=m,[b,g]=p,P=t.version===4,h;if(P)h=new Ne(y.toString()).div(10**g).div(new Ne(f.toString()).div(10**b));else{let v=vl(this.stableLayout.stableModelData,u.toNumber(),l.toNumber(),!1);d==="quote"?h=new Ne(1e6).div(v*1e6):h=new Ne(v*1e6).div(1e6)}let I=n,T=new Ye(0),w=new Ye(0);if(!I.isZero())if(P){w=nn(I.mul(Da),Yr);let v=I.sub(w),L=f.add(v);T=y.mul(v).div(L)}else{w=I.mul(new Ye(2)).div(new Ye(1e4));let v=I.sub(w);d==="quote"?T=new Ye(Nl(this.stableLayout.stableModelData,l.toNumber(),u.toNumber(),v.toNumber())):T=new Ye(Ml(this.stableLayout.stableModelData,l.toNumber(),u.toNumber(),v.toNumber()))}let K=new Ye(new Ne(T.toString()).mul(1-i).toFixed(0)),x=T,S=K,B=new Ne(T.toString()).div(new Ne(I.sub(w).toString()).toFixed(0));!I.isZero()&&!T.isZero()&&(B=new Ne(T.toString()).div(10**g).div(new Ne(I.sub(w).toString()).div(10**b)));let R=h.sub(B).div(h).mul(100);return{amountOut:x,minAmountOut:S,currentPrice:h,executionPrice:B,priceImpact:R,fee:w}}computeAmountIn({poolInfo:t,amountOut:n,mintIn:o,mintOut:r,slippage:i}){let{baseReserve:s,quoteReserve:c}=t;o.toString()!==t.mintA.address&&o.toString()!==t.mintB.address&&this.logAndCreateError("mintIn does not match pool"),r.toString()!==t.mintA.address&&r.toString()!==t.mintB.address&&this.logAndCreateError("mintOut does not match pool"),this.logDebug("baseReserve:",s.toString()),this.logDebug("quoteReserve:",c.toString());let u=o.toString()===t.mintA.address,[l,m]=u?[t.mintA,t.mintB]:[t.mintB,t.mintA];this.logDebug("currencyOut:",m.symbol||m.address),this.logDebug("amountOut:",new Ne(n.toString()).div(10**m.decimals).toDecimalPlaces(m.decimals).toString(),l.symbol||l.address),this.logDebug("slippage:",`${i*100}%`);let p=[s,c],d=u?"quote":"base";d==="base"&&p.reverse(),this.logDebug("output side:",d);let[f,y]=p,b=new Ne(y.toString()).div(10**t[u?"mintB":"mintA"].decimals).div(new Ne(f.toString()).div(10**t[u?"mintA":"mintB"].decimals));this.logDebug("currentPrice:",`1 ${l.symbol||l.address} \u2248 ${b.toString()} ${m.symbol||m.address}`),this.logDebug("currentPrice invert:",`1 ${m.symbol||m.address} \u2248 ${new Ne(1).div(b).toString()} ${l.symbol||l.address}`);let g=new Ye(0),P=n;if(!P.isZero()){P.gt(y)&&(P=y.sub(new Ye(1)));let S=y.sub(P);g=f.mul(P).div(S).mul(Yr).div(Yr.sub(Da))}let h=new Ye(new Ne(g.toString()).mul(1+i).toFixed(0)),I=g,T=h;this.logDebug("amountIn:",new Ne(I.toString()).div(10**l.decimals).toDecimalPlaces(l.decimals).toString()),this.logDebug("maxAmountIn:",new Ne(T.toString()).div(10**l.decimals).toDecimalPlaces(l.decimals).toString());let w=null;!g.isZero()&&!P.isZero()&&(w=new Ne(P.toString()).div(10**m.decimals).div(new Ne(g.toString()).div(10**l.decimals)),this.logDebug("executionPrice:",`1 ${m.symbol||m.address} \u2248 ${w.toDecimalPlaces(Math.max(t.mintA.decimals,t.mintB.decimals)).toString()} ${l.symbol||l.address}`),this.logDebug("executionPrice invert:",`1 ${m.symbol||m.address} \u2248 ${new Ne(1).div(w).toDecimalPlaces(Math.max(t.mintA.decimals,t.mintB.decimals)).toString()} ${l.symbol||l.address}`));let K=b.mul(I.toString()),x=K.sub(n.toString()).abs().div(K);return this.logDebug("priceImpact:",`${x.toString()}%`),{amountIn:I,maxAmountIn:T,currentPrice:b,executionPrice:w,priceImpact:x}}async swap({poolInfo:t,poolKeys:n,amountIn:o,amountOut:r,inputMint:i,fixedSide:s,txVersion:c,config:u,computeBudgetConfig:l,txTipConfig:m,feePayer:p}){let d=this.createTxBuilder(p),{associatedOnly:f=!0,inputUseSolBalance:y=!0,outputUseSolBalance:b=!0}=u||{},[g,P]=i===t.mintA.address?[t.mintA,t.mintB]:[t.mintB,t.mintA],h=y&&g.address===$.toBase58(),I=b&&P.address===$.toBase58(),{account:T,instructionParams:w}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:Qn,mint:new nt(g.address),owner:this.scope.ownerPubKey,createInfo:h?{payer:this.scope.ownerPubKey,amount:o}:void 0,skipCloseAccount:!h,notUseTokenAccount:h,associatedOnly:f});d.addInstruction(w||{}),T||this.logAndCreateError("input token account not found",{token:g.symbol||g.address,tokenAccountIn:T,inputTokenUseSolBalance:h,associatedOnly:f});let{account:K,instructionParams:x}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:Qn,mint:new nt(P.address),owner:this.scope.ownerPubKey,createInfo:{payer:this.scope.ownerPubKey,amount:0},skipCloseAccount:!I,notUseTokenAccount:I,associatedOnly:I?!1:f});d.addInstruction(x||{}),K===void 0&&this.logAndCreateError("output token account not found",{token:P.symbol||P.address,tokenAccountOut:K,outputTokenUseSolBalance:I,associatedOnly:f});let S=n||await this.getAmmPoolKeys(t.id),B=4;return t.pooltype.includes("StablePool")&&(B=5),d.addInstruction({instructions:[Qr({version:B,poolKeys:S,userKeys:{tokenAccountIn:T,tokenAccountOut:K,owner:this.scope.ownerPubKey},amountIn:o,amountOut:r,fixedSide:s})],instructionTypes:[B===4?G.AmmV4SwapBaseIn:G.AmmV5SwapBaseIn]}),d.addCustomComputeBudget(l),d.addTipInstruction(m),d.versionBuild({txVersion:c})}async getRpcPoolInfo(t){return(await this.getRpcPoolInfos([t]))[t]}async getRpcPoolInfos(t,n){let o=await ve(this.scope.connection,t.map(l=>({pubkey:new nt(l)})),n),r={},i=[];for(let l=0;l<t.length;l++){let m=o[l];if(m===null||!m.accountInfo)throw Error("fetch pool info error: "+String(t[l]));let p=yo.decode(m.accountInfo.data);r[String(t[l])]=q(M({},p),{programId:m.accountInfo.owner}),i.push(p.baseVault,p.quoteVault)}let s={},c=await ve(this.scope.connection,i.map(l=>({pubkey:new nt(l)})),n);for(let l=0;l<i.length;l++){let m=c[l].accountInfo;if(m===null)throw Error("fetch vault info error: "+i[l]);s[String(i[l])]=new Ye(zf.decode(m.data).amount.toString())}let u={};for(let[l,m]of Object.entries(r)){let p=s[m.baseVault.toString()].sub(m.baseNeedTakePnl),d=s[m.quoteVault.toString()].sub(m.quoteNeedTakePnl);u[l]=q(M({},m),{baseReserve:p,mintAAmount:s[m.baseVault.toString()],mintBAmount:s[m.quoteVault.toString()],quoteReserve:d,poolPrice:new Ne(d.toString()).div(new Ne(10).pow(m.quoteDecimal.toString())).div(new Ne(p.toString()).div(new Ne(10).pow(m.baseDecimal.toString())))})}return u}async getPoolInfoFromRpc({poolId:t}){let n=await this.getRpcPoolInfo(t),o=$r({[t]:n}),r=o[t],i=await this.scope.tradeV2.computePoolToPoolKeys({pools:[o[t]],ammRpcData:{[t]:n}});return{poolRpcData:n,poolInfo:r,poolKeys:i[0]}}};import{PublicKey as H}from"@solana/web3.js";import St from"bn.js";import ko from"decimal.js";import{AccountLayout as Dl,createAssociatedTokenAccountIdempotentInstruction as ql,TOKEN_2022_PROGRAM_ID as Hn,TOKEN_PROGRAM_ID as Gi}from"@solana/spl-token";var Xi=class extends We{constructor(e){super(e)}async getClmmPoolKeys(e){return(await this.scope.api.fetchPoolKeysById({idList:[e]}))[0]}async createPool(e){var K;let{programId:t,owner:n=((K=this.scope.owner)==null?void 0:K.publicKey)||H.default,mint1:o,mint2:r,ammConfig:i,initialPrice:s,computeBudgetConfig:c,forerunCreate:u,getObserveState:l,txVersion:m,txTipConfig:p,feePayer:d}=e,f=this.createTxBuilder(d),[y,b,g]=new St(new H(o.address).toBuffer()).gt(new St(new H(r.address).toBuffer()))?[r,o,new ko(1).div(s)]:[o,r,s],P=se.priceToSqrtPriceX64(g,y.decimals,b.decimals),h=[],I=[];y.programId===Hn.toBase58()&&I.push(va(t,new H(y.address)).publicKey),b.programId===Hn.toBase58()&&I.push(va(t,new H(b.address)).publicKey),(await this.scope.connection.getMultipleAccountsInfo(I)).forEach((x,S)=>{x&&h.push(I[S])});let w=await Re.createPoolInstructions({connection:this.scope.connection,programId:t,owner:n,mintA:y,mintB:b,ammConfigId:i.id,initialPriceX64:P,forerunCreate:!l&&u,extendMintAccount:h});return f.addInstruction(w),f.addCustomComputeBudget(c),f.addTipInstruction(p),f.versionBuild({txVersion:m,extInfo:{address:q(M({},w.address),{observationId:w.address.observationId.toBase58(),exBitmapAccount:w.address.exBitmapAccount.toBase58(),programId:t.toString(),id:w.address.poolId.toString(),mintA:y,mintB:b,openTime:"0",vault:{A:w.address.mintAVault.toString(),B:w.address.mintBVault.toString()},rewardInfos:[],config:{id:i.id.toString(),index:i.index,protocolFeeRate:i.protocolFeeRate,tradeFeeRate:i.tradeFeeRate,tickSpacing:i.tickSpacing,fundFeeRate:i.fundFeeRate,description:i.description,defaultRange:0,defaultRangePoint:[]}}),mockPoolInfo:M({type:"Concentrated",rewardDefaultPoolInfos:"Clmm",id:w.address.poolId.toString(),mintA:y,mintB:b,feeRate:i.tradeFeeRate,openTime:"0",programId:t.toString(),price:g.toNumber(),config:{id:i.id.toString(),index:i.index,protocolFeeRate:i.protocolFeeRate,tradeFeeRate:i.tradeFeeRate,tickSpacing:i.tickSpacing,fundFeeRate:i.fundFeeRate,description:i.description,defaultRange:0,defaultRangePoint:[]},burnPercent:0},rl),forerunCreate:u}})}async openPositionFromBase({poolInfo:e,poolKeys:t,ownerInfo:n,tickLower:o,tickUpper:r,base:i,baseAmount:s,otherAmountMax:c,nft2022:u,associatedOnly:l=!0,checkCreateATAOwner:m=!1,withMetadata:p="create",getEphemeralSigners:d,computeBudgetConfig:f,txTipConfig:y,txVersion:b,feePayer:g}){this.scope.availability.addConcentratedPosition===!1&&this.logAndCreateError("add position feature disabled in your region"),this.scope.checkOwner();let P=this.createTxBuilder(g),h=null,I=null,T=n.useSOLBalance&&e.mintA.address===$.toString(),w=n.useSOLBalance&&e.mintB.address===$.toString(),[K,x]=i==="MintA"?[s,c]:[c,s],{account:S,instructionParams:B}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:e.mintA.programId,mint:new H(e.mintA.address),owner:this.scope.ownerPubKey,createInfo:T||K.isZero()?{payer:this.scope.ownerPubKey,amount:K}:void 0,skipCloseAccount:!T,notUseTokenAccount:T,associatedOnly:T?!1:l,checkCreateATAOwner:m});S&&(h=S),P.addInstruction(B||{});let{account:R,instructionParams:C}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:e.mintB.programId,mint:new H(e.mintB.address),owner:this.scope.ownerPubKey,createInfo:w||x.isZero()?{payer:this.scope.ownerPubKey,amount:x}:void 0,skipCloseAccount:!w,notUseTokenAccount:w,associatedOnly:w?!1:l,checkCreateATAOwner:m});R&&(I=R),P.addInstruction(C||{}),(!h||!I)&&this.logAndCreateError("cannot found target token accounts","tokenAccounts",{ownerTokenAccountA:h==null?void 0:h.toBase58(),ownerTokenAccountB:I==null?void 0:I.toBase58()});let v=t||await this.getClmmPoolKeys(e.id),L=await Re.openPositionFromBaseInstructions({poolInfo:e,poolKeys:v,ownerInfo:q(M({},n),{feePayer:this.scope.ownerPubKey,wallet:this.scope.ownerPubKey,tokenAccountA:h,tokenAccountB:I}),tickLower:o,tickUpper:r,base:i,baseAmount:s,otherAmountMax:c,withMetadata:p,getEphemeralSigners:d,nft2022:u});return P.addInstruction(L),P.addCustomComputeBudget(f),P.addTipInstruction(y),P.versionBuild({txVersion:b,extInfo:M({},L.address)})}async openPositionFromLiquidity({poolInfo:e,poolKeys:t,ownerInfo:n,amountMaxA:o,amountMaxB:r,tickLower:i,tickUpper:s,liquidity:c,associatedOnly:u=!0,checkCreateATAOwner:l=!1,withMetadata:m="create",txVersion:p,computeBudgetConfig:d,txTipConfig:f,getEphemeralSigners:y,nft2022:b,feePayer:g}){this.scope.availability.createConcentratedPosition===!1&&this.logAndCreateError("open position feature disabled in your region");let P=this.createTxBuilder(g),h=null,I=null,T=n.useSOLBalance&&e.mintA.address===$.toBase58(),w=n.useSOLBalance&&e.mintB.address===$.toBase58(),{account:K,instructionParams:x}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:e.mintA.programId,mint:new H(e.mintA.address),owner:this.scope.ownerPubKey,createInfo:T||o.isZero()?{payer:this.scope.ownerPubKey,amount:o}:void 0,skipCloseAccount:!T,notUseTokenAccount:T,associatedOnly:T?!1:u,checkCreateATAOwner:l});K&&(h=K),P.addInstruction(x||{});let{account:S,instructionParams:B}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:e.mintB.programId,mint:new H(e.mintB.address),owner:this.scope.ownerPubKey,createInfo:w||r.isZero()?{payer:this.scope.ownerPubKey,amount:r}:void 0,skipCloseAccount:!w,notUseTokenAccount:w,associatedOnly:w?!1:u,checkCreateATAOwner:l});S&&(I=S),P.addInstruction(B||{}),(h===void 0||I===void 0)&&this.logAndCreateError("cannot found target token accounts","tokenAccounts",this.scope.account.tokenAccounts);let R=t||await this.getClmmPoolKeys(e.id),C=await Re.openPositionFromLiquidityInstructions({poolInfo:e,poolKeys:R,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccountA:h,tokenAccountB:I},tickLower:i,tickUpper:s,liquidity:c,amountMaxA:o,amountMaxB:r,withMetadata:m,getEphemeralSigners:y,nft2022:b});return P.addInstruction(C),P.addCustomComputeBudget(d),P.addTipInstruction(f),P.versionBuild({txVersion:p,extInfo:{address:C.address}})}async increasePositionFromLiquidity(e){var B;let{poolInfo:t,poolKeys:n,ownerPosition:o,amountMaxA:r,amountMaxB:i,liquidity:s,ownerInfo:c,associatedOnly:u=!0,checkCreateATAOwner:l=!1,computeBudgetConfig:m,txTipConfig:p,txVersion:d,feePayer:f}=e,y=this.createTxBuilder(f),b,g,P=c.useSOLBalance&&t.mintA.address===$.toString(),h=c.useSOLBalance&&t.mintB.address===$.toString(),{account:I,instructionParams:T}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:t.mintA.programId,mint:new H(t.mintA.address),notUseTokenAccount:P,owner:this.scope.ownerPubKey,createInfo:P||r.isZero()?{payer:this.scope.ownerPubKey,amount:r}:void 0,skipCloseAccount:!P,associatedOnly:P?!1:u,checkCreateATAOwner:l});I&&(b=I),y.addInstruction(T||{});let{account:w,instructionParams:K}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:t.mintB.programId,mint:new H(t.mintB.address),owner:this.scope.ownerPubKey,createInfo:h||i.isZero()?{payer:this.scope.ownerPubKey,amount:i}:void 0,notUseTokenAccount:h,skipCloseAccount:!h,associatedOnly:h?!1:u,checkCreateATAOwner:l});w&&(g=w),y.addInstruction(K||{}),!b&&!g&&this.logAndCreateError("cannot found target token accounts","tokenAccounts",this.scope.account.tokenAccounts);let x=n!=null?n:await this.getClmmPoolKeys(t.id),S=Re.increasePositionFromLiquidityInstructions({poolInfo:t,poolKeys:x,ownerPosition:o,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccountA:b,tokenAccountB:g},liquidity:s,amountMaxA:r,amountMaxB:i,nft2022:(B=await this.scope.connection.getAccountInfo(o.nftMint))==null?void 0:B.owner.equals(Hn)});return y.addInstruction(S),y.addCustomComputeBudget(m),y.addTipInstruction(p),y.versionBuild({txVersion:d,extInfo:{address:S.address}})}async increasePositionFromBase(e){var S;let{poolInfo:t,ownerPosition:n,base:o,baseAmount:r,otherAmountMax:i,ownerInfo:s,associatedOnly:c=!0,checkCreateATAOwner:u=!1,computeBudgetConfig:l,txTipConfig:m,txVersion:p,feePayer:d}=e,f=this.createTxBuilder(d),y,b,g=s.useSOLBalance&&t.mintA.address===$.toString(),P=s.useSOLBalance&&t.mintB.address===$.toString(),{account:h,instructionParams:I}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:t.mintA.programId,mint:new H(t.mintA.address),notUseTokenAccount:g,owner:this.scope.ownerPubKey,createInfo:g||(o==="MintA"?r:i).isZero()?{payer:this.scope.ownerPubKey,amount:o==="MintA"?r:i}:void 0,skipCloseAccount:!g,associatedOnly:g?!1:c,checkCreateATAOwner:u});h&&(y=h),f.addInstruction(I||{});let{account:T,instructionParams:w}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:t.mintB.programId,mint:new H(t.mintB.address),owner:this.scope.ownerPubKey,createInfo:P||(o==="MintA"?i:r).isZero()?{payer:this.scope.ownerPubKey,amount:o==="MintA"?i:r}:void 0,notUseTokenAccount:P,skipCloseAccount:!P,associatedOnly:P?!1:c,checkCreateATAOwner:u});T&&(b=T),f.addInstruction(w||{}),!y&&!b&&this.logAndCreateError("cannot found target token accounts","tokenAccounts",this.scope.account.tokenAccounts);let K=await this.getClmmPoolKeys(t.id),x=Re.increasePositionFromBaseInstructions({poolInfo:t,poolKeys:K,ownerPosition:n,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccountA:y,tokenAccountB:b},base:o,baseAmount:r,otherAmountMax:i,nft2022:(S=await this.scope.connection.getAccountInfo(n.nftMint))==null?void 0:S.owner.equals(Hn)});return f.addInstruction(x),f.addCustomComputeBudget(l),f.addTipInstruction(m),f.versionBuild({txVersion:p,extInfo:{address:x.address}})}async decreaseLiquidity(e){var v;let{poolInfo:t,poolKeys:n,ownerPosition:o,ownerInfo:r,amountMinA:i,amountMinB:s,liquidity:c,associatedOnly:u=!0,checkCreateATAOwner:l=!1,computeBudgetConfig:m,txTipConfig:p,txVersion:d,feePayer:f}=e;this.scope.availability.removeConcentratedPosition===!1&&this.logAndCreateError("remove position feature disabled in your region");let y=this.createTxBuilder(f),b=r.useSOLBalance&&t.mintA.address===$.toString(),g=r.useSOLBalance&&t.mintB.address===$.toString(),P,h,{account:I,instructionParams:T}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:t.mintA.programId,mint:new H(t.mintA.address),notUseTokenAccount:b,owner:this.scope.ownerPubKey,createInfo:{payer:this.scope.ownerPubKey,amount:0},skipCloseAccount:!b,associatedOnly:b?!1:u,checkCreateATAOwner:l});P=I,T&&y.addInstruction(T);let{account:w,instructionParams:K}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:t.mintB.programId,mint:new H(t.mintB.address),notUseTokenAccount:g,owner:this.scope.ownerPubKey,createInfo:{payer:this.scope.ownerPubKey,amount:0},skipCloseAccount:!g,associatedOnly:g?!1:u,checkCreateATAOwner:l});h=w,K&&y.addInstruction(K);let x=[];for(let L of t.rewardDefaultInfos){let N=r.useSOLBalance&&L.mint.address===$.toString(),E;if(L.mint.address===t.mintA.address)E=P;else if(L.mint.address===t.mintB.address)E=h;else{let{account:X,instructionParams:Q}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:new H(L.mint.programId),mint:new H(L.mint.address),notUseTokenAccount:N,owner:this.scope.ownerPubKey,createInfo:{payer:this.scope.ownerPubKey,amount:0},skipCloseAccount:!N,associatedOnly:N?!1:u,checkCreateATAOwner:l});E=X,Q&&y.addInstruction(Q)}x.push(E)}!P&&!h&&this.logAndCreateError("cannot found target token accounts","tokenAccounts",this.scope.account.tokenAccountRawInfos);let S=n!=null?n:await this.getClmmPoolKeys(t.id),B=(v=await this.scope.connection.getAccountInfo(o.nftMint))==null?void 0:v.owner.equals(Hn),R=await Re.decreaseLiquidityInstructions({poolInfo:t,poolKeys:S,ownerPosition:o,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccountA:P,tokenAccountB:h,rewardAccounts:x},liquidity:c,amountMinA:i,amountMinB:s,nft2022:B});y.addInstruction({instructions:R.instructions,instructionTypes:[G.ClmmDecreasePosition]});let C=M({},R.address);if(r.closePosition){let L=await Re.closePositionInstructions({poolInfo:t,poolKeys:S,ownerInfo:{wallet:this.scope.ownerPubKey},ownerPosition:o,nft2022:B});y.addInstruction({endInstructions:L.instructions,endInstructionTypes:L.instructionTypes}),C=M(M({},C),L.address)}return y.addCustomComputeBudget(m),y.addTipInstruction(p),y.versionBuild({txVersion:d,extInfo:{address:C}})}async lockPosition(e){var f;let{programId:t=Lo,authProgramId:n=li,poolProgramId:o=_n,ownerPosition:r,payer:i,computeBudgetConfig:s,txTipConfig:c,txVersion:u,getEphemeralSigners:l,feePayer:m}=e,p=this.createTxBuilder(m),d=await Re.makeLockPositions({programId:t,authProgramId:n,poolProgramId:o,wallet:this.scope.ownerPubKey,payer:i!=null?i:this.scope.ownerPubKey,nftMint:r.nftMint,getEphemeralSigners:l,nft2022:(f=await this.scope.connection.getAccountInfo(r.nftMint))==null?void 0:f.owner.equals(Hn)});return p.addInstruction(d),p.addCustomComputeBudget(s),p.addTipInstruction(c),p.versionBuild({txVersion:u,extInfo:d.address})}async harvestLockPosition(e){let{programId:t=Lo,authProgramId:n=li,clmmProgram:o=_n,poolKeys:r,lockData:i,ownerInfo:s={useSOLBalance:!0},associatedOnly:c=!0,checkCreateATAOwner:u=!1,computeBudgetConfig:l,txTipConfig:m,txVersion:p,feePayer:d}=e,f=r||await this.getClmmPoolKeys(i.poolId.toString()),y=this.createTxBuilder(d),b=await this.scope.connection.getAccountInfo(i.positionId);b||this.logger.logWithError("position not found",i.positionId);let g=Do.decode(b.data),P=s.useSOLBalance&&f.mintA.address===$.toString(),h=s.useSOLBalance&&f.mintB.address===$.toString(),I,T,{account:w,instructionParams:K}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:f.mintA.programId,mint:new H(f.mintA.address),notUseTokenAccount:P,owner:this.scope.ownerPubKey,createInfo:{payer:this.scope.ownerPubKey,amount:0},skipCloseAccount:!P,associatedOnly:P?!1:c,checkCreateATAOwner:u});I=w,K&&y.addInstruction(K);let{account:x,instructionParams:S}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:f.mintB.programId,mint:new H(f.mintB.address),notUseTokenAccount:h,owner:this.scope.ownerPubKey,createInfo:{payer:this.scope.ownerPubKey,amount:0},skipCloseAccount:!h,associatedOnly:h?!1:c,checkCreateATAOwner:u});T=x,S&&y.addInstruction(S);let B={},R=[];for(let re of f.rewardInfos){let ue=s.useSOLBalance&&re.mint.address===$.toString(),ge=B[re.mint.address];if(!ge){let{account:pe,instructionParams:oe}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:new H(re.mint.programId),mint:new H(re.mint.address),notUseTokenAccount:ue,owner:this.scope.ownerPubKey,skipCloseAccount:!ue,createInfo:{payer:this.scope.ownerPubKey,amount:0},associatedOnly:ue?!1:c});ge=pe,oe&&y.addInstruction(oe)}B[re.mint.address]=ge,R.push(ge)}let C=Wo(t,i.lockNftMint).publicKey,v=j(this.scope.ownerPubKey,i.lockNftMint,Gi).publicKey,L=Z.getTickArrayStartIndexByTick(g.tickLower,f.config.tickSpacing),N=Z.getTickArrayStartIndexByTick(g.tickUpper,f.config.tickSpacing),{publicKey:E}=Ae(new H(f.programId),i.poolId,L),{publicKey:X}=Ae(new H(f.programId),i.poolId,N),{publicKey:Q}=an(new H(f.programId),i.poolId,g.tickLower,g.tickUpper),ee=[];for(let re=0;re<f.rewardInfos.length;re++)ee.push({poolRewardVault:new H(f.rewardInfos[re].vault),ownerRewardVault:R[re],rewardMint:new H(f.rewardInfos[re].mint.address)});let de=await Re.harvestLockPositionInstructionV2({programId:t,auth:n,lockPositionId:C,clmmProgram:o,lockOwner:this.scope.ownerPubKey,lockNftMint:i.lockNftMint,lockNftAccount:v,positionNftAccount:i.nftAccount,positionId:i.positionId,poolId:i.poolId,protocolPosition:Q,vaultA:new H(f.vault.A),vaultB:new H(f.vault.B),tickArrayLower:E,tickArrayUpper:X,userVaultA:I,userVaultB:T,mintA:new H(f.mintA.address),mintB:new H(f.mintB.address),rewardAccounts:ee,exTickArrayBitmap:$e(o,i.poolId).publicKey});return y.addInstruction({instructions:[de],instructionTypes:[G.ClmmHarvestLockPosition]}),y.addCustomComputeBudget(l),y.addTipInstruction(m),y.versionBuild({txVersion:p})}async closePosition({poolInfo:e,poolKeys:t,ownerPosition:n,txVersion:o,computeBudgetConfig:r,txTipConfig:i,feePayer:s}){var m;this.scope.availability.removeConcentratedPosition===!1&&this.logAndCreateError("remove position feature disabled in your region");let c=this.createTxBuilder(s),u=t!=null?t:await this.getClmmPoolKeys(e.id),l=Re.closePositionInstructions({poolInfo:e,poolKeys:u,ownerInfo:{wallet:this.scope.ownerPubKey},ownerPosition:n,nft2022:(m=await this.scope.connection.getAccountInfo(n.nftMint))==null?void 0:m.owner.equals(Hn)});return c.addCustomComputeBudget(r),c.addTipInstruction(i),c.addInstruction(l).versionBuild({txVersion:o,extInfo:{address:l.address}})}async initReward({poolInfo:e,ownerInfo:t,rewardInfo:n,associatedOnly:o=!0,checkCreateATAOwner:r=!1,computeBudgetConfig:i,txVersion:s,feePayer:c}){n.endTime<=n.openTime&&this.logAndCreateError("reward time error","rewardInfo",n);let u=this.createTxBuilder(c),l=t.useSOLBalance&&n.mint.address.toString()===$.toString(),m=n.perSecond.mul(n.endTime-n.openTime),{account:p,instructionParams:d}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:new H(n.mint.address),mint:new H(n.mint.address),notUseTokenAccount:!!l,skipCloseAccount:!l,owner:this.scope.ownerPubKey,createInfo:l?{payer:t.feePayer||this.scope.ownerPubKey,amount:new St(new ko(m.toFixed(0)).gte(m)?m.toFixed(0):m.add(1).toFixed(0))}:void 0,associatedOnly:l?!1:o,checkCreateATAOwner:r});d&&u.addInstruction(d),p||this.logAndCreateError("no money","ownerRewardAccount",this.scope.account.tokenAccountRawInfos);let f=await this.getClmmPoolKeys(e.id),y=Re.initRewardInstructions({poolInfo:e,poolKeys:f,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccount:p},rewardInfo:{programId:new H(n.mint.programId),mint:new H(n.mint.address),openTime:n.openTime,endTime:n.endTime,emissionsPerSecondX64:le.decimalToX64(n.perSecond)}});return u.addInstruction(y),u.addCustomComputeBudget(i),u.versionBuild({txVersion:s,extInfo:{address:y.address}})}async initRewards({poolInfo:e,poolKeys:t,ownerInfo:n,rewardInfos:o,associatedOnly:r=!0,checkCreateATAOwner:i=!1,computeBudgetConfig:s,txTipConfig:c,txVersion:u,feePayer:l}){for(let d of o)d.endTime<=d.openTime&&this.logAndCreateError("reward time error","rewardInfo",d);let m=this.createTxBuilder(l),p={};for(let d of o){let f=n.useSOLBalance&&d.mint.address===$.toString(),y=d.perSecond.mul(d.endTime-d.openTime),{account:b,instructionParams:g}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:new H(d.mint.programId),mint:new H(d.mint.address),notUseTokenAccount:!!f,skipCloseAccount:!f,owner:this.scope.ownerPubKey,createInfo:f?{payer:n.feePayer||this.scope.ownerPubKey,amount:new St(new ko(y.toFixed(0)).gte(y)?y.toFixed(0):y.add(1).toFixed(0))}:void 0,associatedOnly:f?!1:r,checkCreateATAOwner:i});g&&m.addInstruction(g),b||this.logAndCreateError("no money","ownerRewardAccount",this.scope.account.tokenAccountRawInfos);let P=t!=null?t:await this.getClmmPoolKeys(e.id),h=Re.initRewardInstructions({poolInfo:e,poolKeys:P,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccount:b},rewardInfo:{programId:new H(d.mint.programId),mint:new H(d.mint.address),openTime:d.openTime,endTime:d.endTime,emissionsPerSecondX64:le.decimalToX64(d.perSecond)}});p=M(M({},p),h.address),m.addInstruction(h)}return m.addCustomComputeBudget(s),m.addTipInstruction(c),m.versionBuild({txVersion:u,extInfo:{address:p}})}async setReward({poolInfo:e,ownerInfo:t,rewardInfo:n,associatedOnly:o=!0,checkCreateATAOwner:r=!1,computeBudgetConfig:i,txTipConfig:s,txVersion:c,feePayer:u}){n.endTime<=n.openTime&&this.logAndCreateError("reward time error","rewardInfo",n);let l=this.createTxBuilder(u),m=t.useSOLBalance&&n.mint.equals($),{account:p,instructionParams:d}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:n.programId,mint:n.mint,notUseTokenAccount:m,owner:this.scope.ownerPubKey,createInfo:m?{payer:t.feePayer||this.scope.ownerPubKey,amount:new St(new ko(n.perSecond.mul(n.endTime-n.openTime).toFixed(0)).gte(n.perSecond.mul(n.endTime-n.openTime))?n.perSecond.mul(n.endTime-n.openTime).toFixed(0):n.perSecond.mul(n.endTime-n.openTime).add(1).toFixed(0))}:void 0,associatedOnly:m?!1:o,checkCreateATAOwner:r});d&&l.addInstruction(d),p||this.logAndCreateError("no money","ownerRewardAccount",this.scope.account.tokenAccountRawInfos);let f=await this.getClmmPoolKeys(e.id),y=Re.setRewardInstructions({poolInfo:e,poolKeys:f,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccount:p},rewardInfo:{mint:n.mint,openTime:n.openTime,endTime:n.endTime,emissionsPerSecondX64:le.decimalToX64(n.perSecond)}});return l.addInstruction(y),l.addCustomComputeBudget(i),l.addTipInstruction(s),l.versionBuild({txVersion:c,extInfo:{address:y.address}})}async setRewards({poolInfo:e,poolKeys:t,ownerInfo:n,rewardInfos:o,associatedOnly:r=!0,checkCreateATAOwner:i=!1,computeBudgetConfig:s,txTipConfig:c,txVersion:u,feePayer:l}){let m=this.createTxBuilder(l),p={};for(let d of o){d.endTime<=d.openTime&&this.logAndCreateError("reward time error","rewardInfo",d);let f=n.useSOLBalance&&d.mint.address===$.toString(),{account:y,instructionParams:b}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:new H(d.mint.programId),mint:new H(d.mint.address),notUseTokenAccount:f,owner:this.scope.ownerPubKey,createInfo:f?{payer:n.feePayer||this.scope.ownerPubKey,amount:new St(new ko(d.perSecond.mul(d.endTime-d.openTime).toFixed(0)).gte(d.perSecond.mul(d.endTime-d.openTime))?d.perSecond.mul(d.endTime-d.openTime).toFixed(0):d.perSecond.mul(d.endTime-d.openTime).add(1).toFixed(0))}:void 0,associatedOnly:f?!1:r,checkCreateATAOwner:i});b&&m.addInstruction(b),y||this.logAndCreateError("no money","ownerRewardAccount",this.scope.account.tokenAccountRawInfos);let g=t!=null?t:await this.getClmmPoolKeys(e.id),P=Re.setRewardInstructions({poolInfo:e,poolKeys:g,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccount:y},rewardInfo:{mint:new H(d.mint.address),openTime:d.openTime,endTime:d.endTime,emissionsPerSecondX64:le.decimalToX64(d.perSecond)}});m.addInstruction(P),p=M(M({},p),P.address)}return m.addCustomComputeBudget(s),m.addTipInstruction(c),m.versionBuild({txVersion:u,extInfo:{address:p}})}async collectReward({poolInfo:e,ownerInfo:t,rewardMint:n,associatedOnly:o=!0,checkCreateATAOwner:r=!1,computeBudgetConfig:i,txTipConfig:s,txVersion:c,feePayer:u}){let l=e.rewardDefaultInfos.find(g=>g.mint.address===n.toString());l||this.logAndCreateError("reward mint error","not found reward mint",n);let m=this.createTxBuilder(u),p=t.useSOLBalance&&n.equals($),{account:d,instructionParams:f}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:new H(l.mint.programId),mint:n,notUseTokenAccount:p,owner:this.scope.ownerPubKey,skipCloseAccount:!p,createInfo:{payer:t.feePayer||this.scope.ownerPubKey,amount:0},associatedOnly:p?!1:o,checkCreateATAOwner:r});f&&m.addInstruction(f),d||this.logAndCreateError("no money","ownerRewardAccount",this.scope.account.tokenAccountRawInfos);let y=await this.getClmmPoolKeys(e.id),b=Re.collectRewardInstructions({poolInfo:e,poolKeys:y,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccount:d},rewardMint:n});return m.addInstruction(b),m.addCustomComputeBudget(i),m.addTipInstruction(s),m.versionBuild({txVersion:c,extInfo:{address:b.address}})}async collectRewards({poolInfo:e,ownerInfo:t,rewardMints:n,associatedOnly:o=!0,checkCreateATAOwner:r=!1,computeBudgetConfig:i,txTipConfig:s,feePayer:c}){let u=this.createTxBuilder(c),l={};for(let m of n){let p=e.rewardDefaultInfos.find(P=>P.mint.address===m.toString());if(!p){this.logAndCreateError("reward mint error","not found reward mint",m);continue}let d=t.useSOLBalance&&m.equals($),{account:f,instructionParams:y}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:new H(p.mint.programId),mint:m,notUseTokenAccount:d,owner:this.scope.ownerPubKey,skipCloseAccount:!d,createInfo:{payer:t.feePayer||this.scope.ownerPubKey,amount:0},associatedOnly:d?!1:o,checkCreateATAOwner:r});f||this.logAndCreateError("no money","ownerRewardAccount",this.scope.account.tokenAccountRawInfos),y&&u.addInstruction(y);let b=await this.getClmmPoolKeys(e.id),g=Re.collectRewardInstructions({poolInfo:e,poolKeys:b,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccount:f},rewardMint:m});u.addInstruction(g),l=M(M({},l),g.address)}return u.addCustomComputeBudget(i),u.addTipInstruction(s),u.build({address:l})}async swap({poolInfo:e,poolKeys:t,inputMint:n,amountIn:o,amountOutMin:r,priceLimit:i,observationId:s,ownerInfo:c,remainingAccounts:u,associatedOnly:l=!0,checkCreateATAOwner:m=!1,txVersion:p,computeBudgetConfig:d,txTipConfig:f,feePayer:y}){let b=this.createTxBuilder(y),g=n.toString()===e.mintA.address,P=c.useSOLBalance&&e.mintA.address===$.toBase58(),h=c.useSOLBalance&&e.mintB.address===$.toBase58(),I;!i||i.equals(new ko(0))?I=g?Yt.add(new St(1)):Qt.sub(new St(1)):I=se.priceToSqrtPriceX64(i,e.mintA.decimals,e.mintB.decimals);let T;if(!T){let{account:x,instructionParams:S}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:e.mintA.programId,mint:new H(e.mintA.address),notUseTokenAccount:P,owner:this.scope.ownerPubKey,skipCloseAccount:!P,createInfo:P||!g?{payer:c.feePayer||this.scope.ownerPubKey,amount:g?o:0}:void 0,associatedOnly:P?!1:l,checkCreateATAOwner:m});T=x,S&&b.addInstruction(S)}let w;if(!w){let{account:x,instructionParams:S}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:e.mintB.programId,mint:new H(e.mintB.address),notUseTokenAccount:h,owner:this.scope.ownerPubKey,skipCloseAccount:!h,createInfo:h||g?{payer:c.feePayer||this.scope.ownerPubKey,amount:g?0:o}:void 0,associatedOnly:h?!1:l,checkCreateATAOwner:m});w=x,S&&b.addInstruction(S)}(!T||!w)&&this.logAndCreateError("user do not have token account",{tokenA:e.mintA.symbol||e.mintA.address,tokenB:e.mintB.symbol||e.mintB.address,ownerTokenAccountA:T,ownerTokenAccountB:w,mintAUseSOLBalance:P,mintBUseSOLBalance:h,associatedOnly:l});let K=t!=null?t:await this.getClmmPoolKeys(e.id);return b.addInstruction(Re.makeSwapBaseInInstructions({poolInfo:e,poolKeys:K,observationId:s,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccountA:T,tokenAccountB:w},inputMint:new H(n),amountIn:o,amountOutMin:r,sqrtPriceLimitX64:I,remainingAccounts:u})),b.addCustomComputeBudget(d),b.addTipInstruction(f),b.versionBuild({txVersion:p})}async swapBaseOut({poolInfo:e,poolKeys:t,outputMint:n,amountOut:o,amountInMax:r,priceLimit:i,observationId:s,ownerInfo:c,remainingAccounts:u,associatedOnly:l=!0,checkCreateATAOwner:m=!1,txVersion:p,computeBudgetConfig:d,txTipConfig:f,feePayer:y}){let b=this.createTxBuilder(y),g=n.toString()===e.mintB.address,P=c.useSOLBalance&&e.mintA.address===$.toBase58(),h=c.useSOLBalance&&e.mintB.address===$.toBase58(),I;!i||i.equals(new ko(0))?I=n.toString()===e.mintB.address?Yt.add(new St(1)):Qt.sub(new St(1)):I=se.priceToSqrtPriceX64(i,e.mintA.decimals,e.mintB.decimals);let T;if(!T){let{account:x,instructionParams:S}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:e.mintA.programId,mint:new H(e.mintA.address),notUseTokenAccount:P,owner:this.scope.ownerPubKey,skipCloseAccount:!P,createInfo:P||!g?{payer:c.feePayer||this.scope.ownerPubKey,amount:g?r:0}:void 0,associatedOnly:P?!1:l,checkCreateATAOwner:m});T=x,S&&b.addInstruction(S)}let w;if(!w){let{account:x,instructionParams:S}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:e.mintB.programId,mint:new H(e.mintB.address),notUseTokenAccount:h,owner:this.scope.ownerPubKey,skipCloseAccount:!h,createInfo:h||g?{payer:c.feePayer||this.scope.ownerPubKey,amount:g?0:r}:void 0,associatedOnly:h?!1:l,checkCreateATAOwner:m});w=x,S&&b.addInstruction(S)}(!T||!w)&&this.logAndCreateError("user do not have token account",{tokenA:e.mintA.symbol||e.mintA.address,tokenB:e.mintB.symbol||e.mintB.address,ownerTokenAccountA:T,ownerTokenAccountB:w,mintAUseSOLBalance:P,mintBUseSOLBalance:h,associatedOnly:l});let K=t!=null?t:await this.getClmmPoolKeys(e.id);return b.addInstruction(Re.makeSwapBaseOutInstructions({poolInfo:e,poolKeys:K,observationId:s,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccountA:T,tokenAccountB:w},outputMint:new H(n),amountOut:o,amountInMax:r,sqrtPriceLimitX64:I,remainingAccounts:u})),b.addCustomComputeBudget(d),b.addTipInstruction(f),b.versionBuild({txVersion:p})}async harvestAllRewards({allPoolInfo:e,allPositions:t,lockInfo:n,ownerInfo:o,associatedOnly:r=!0,checkCreateATAOwner:i=!1,programId:s,txVersion:c,computeBudgetConfig:u,feePayer:l,lockProgram:m=Lo,lockAuth:p=li,clmmProgram:d=_n}){var h,I;let f={};for(let T of this.scope.account.tokenAccountRawInfos)r?j(this.scope.ownerPubKey,T.accountInfo.mint,s).publicKey.equals(T.pubkey)&&(f[T.accountInfo.mint.toString()]=T.pubkey):f[T.accountInfo.mint.toString()]=T.pubkey;let y=Object.values(t).flat().map(T=>T.nftMint),b=await ve(this.scope.connection,y.map(T=>({pubkey:T}))),g={};b.forEach(T=>{var w,K;g[T.pubkey.toBase58()]=(K=(w=T==null?void 0:T.accountInfo)==null?void 0:w.owner)!=null?K:null});let P=this.createTxBuilder(l);for(let T of Object.values(e)){if(t[T.id]===void 0||!t[T.id].find(L=>!L.liquidity.isZero()||L.rewardInfos.find(N=>!N.rewardAmountOwed.isZero())))continue;let w=T,K=o.useSOLBalance&&w.mintA.address===$.toString(),x=o.useSOLBalance&&w.mintB.address===$.toString(),S=f[w.mintA.address];if(!S)if(K){let{account:L,instructionParams:N}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:w.mintA.programId,mint:new H(w.mintA.address),notUseTokenAccount:K,owner:this.scope.ownerPubKey,skipCloseAccount:!K,createInfo:{payer:o.feePayer||this.scope.ownerPubKey,amount:0},associatedOnly:K?!1:r,checkCreateATAOwner:i});S=L,N&&P.addInstruction(N)}else{let L=new H(w.mintA.address);S=this.scope.account.getAssociatedTokenAccount(L,new H(w.mintA.programId)),P.addInstruction({instructions:[ql(this.scope.ownerPubKey,S,this.scope.ownerPubKey,L,new H(w.mintA.programId))]})}let B=f[w.mintB.address];if(!B)if(x){let{account:L,instructionParams:N}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:w.mintB.programId,mint:new H(w.mintB.address),notUseTokenAccount:x,owner:this.scope.ownerPubKey,skipCloseAccount:!x,createInfo:{payer:o.feePayer||this.scope.ownerPubKey,amount:0},associatedOnly:x?!1:r,checkCreateATAOwner:i});B=L,N&&P.addInstruction(N)}else{let L=new H(w.mintB.address);B=this.scope.account.getAssociatedTokenAccount(L,new H(w.mintB.programId)),P.addInstruction({instructions:[ql(this.scope.ownerPubKey,B,this.scope.ownerPubKey,L,new H(w.mintB.programId))]})}f[w.mintA.address]=S,f[w.mintB.address]=B;let R=[];for(let L of w.rewardDefaultInfos){let N=o.useSOLBalance&&L.mint.address===$.toString(),E=f[L.mint.address];if(!E){let{account:X,instructionParams:Q}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:new H(L.mint.programId),mint:new H(L.mint.address),notUseTokenAccount:N,owner:this.scope.ownerPubKey,skipCloseAccount:!N,createInfo:{payer:o.feePayer||this.scope.ownerPubKey,amount:0},associatedOnly:N?!1:r});E=X,Q&&P.addInstruction(Q)}f[L.mint.address]=E,R.push(E)}let C=await this.getClmmPoolKeys(w.id),v=[];for(let L=0;L<C.rewardInfos.length;L++)v.push({poolRewardVault:new H(C.rewardInfos[L].vault),ownerRewardVault:R[L],rewardMint:new H(C.rewardInfos[L].mint.address)});for(let L of t[T.id]){let N=(h=n==null?void 0:n[T.id])==null?void 0:h[L.nftMint.toBase58()];if(N){let E=j(this.scope.ownerPubKey,N.lockNftMint,Gi).publicKey,X=Z.getTickArrayStartIndexByTick(L.tickLower,C.config.tickSpacing),Q=Z.getTickArrayStartIndexByTick(L.tickUpper,C.config.tickSpacing),{publicKey:ee}=Ae(new H(C.programId),N.poolId,X),{publicKey:de}=Ae(new H(C.programId),N.poolId,Q),{publicKey:re}=an(new H(C.programId),N.poolId,L.tickLower,L.tickUpper),ue=Wo(m,N.lockNftMint).publicKey,ge=Re.harvestLockPositionInstructionV2({programId:m,auth:p,lockPositionId:ue,clmmProgram:d,lockOwner:this.scope.ownerPubKey,lockNftMint:N.lockNftMint,lockNftAccount:E,positionNftAccount:N.nftAccount,positionId:N.positionId,poolId:N.poolId,protocolPosition:re,vaultA:new H(C.vault.A),vaultB:new H(C.vault.B),tickArrayLower:ee,tickArrayUpper:de,userVaultA:S,userVaultB:B,mintA:new H(C.mintA.address),mintB:new H(C.mintB.address),rewardAccounts:v,exTickArrayBitmap:$e(d,N.poolId).publicKey});P.addInstruction({instructions:[ge],instructionTypes:[G.ClmmHarvestLockPosition],lookupTableAddress:C.lookupTableAccount?[C.lookupTableAccount]:[]})}else{let E=Re.decreaseLiquidityInstructions({poolInfo:w,poolKeys:C,ownerPosition:L,ownerInfo:{wallet:this.scope.ownerPubKey,tokenAccountA:S,tokenAccountB:B,rewardAccounts:R},liquidity:new St(0),amountMinA:new St(0),amountMinB:new St(0),nft2022:(I=g[L.nftMint.toBase58()])==null?void 0:I.equals(Hn)});P.addInstruction(E)}}}return c===0?P.sizeCheckBuildV0({computeBudgetConfig:u}):P.sizeCheckBuild({computeBudgetConfig:u})}async getWhiteListMint({programId:e}){let t=await this.scope.connection.getAccountInfo(Ni(e).publicKey);return t?Pl.decode(t.data).whitelistMints.filter(o=>!o.equals(H.default)):[]}async getOwnerPositionInfo({programId:e=_n}){await this.scope.account.fetchWalletTokenAccounts();let n=this.scope.account.tokenAccountRawInfos.filter(i=>i.accountInfo.amount.eq(new St(1))).map(i=>Kt(new H(e),i.accountInfo.mint).publicKey),o=await this.scope.connection.getMultipleAccountsInfo(n),r=[];return o.forEach(i=>{if(!i)return;let s=Do.decode(i.data);r.push(s)}),r}async getOwnerLockedPositionInfo({programId:e=Lo}){await this.scope.account.fetchWalletTokenAccounts();let n=this.scope.account.tokenAccountRawInfos.filter(c=>c.accountInfo.amount.eq(new St(1))).map(c=>Wo(new H(e),c.accountInfo.mint).publicKey),o=await this.scope.connection.getMultipleAccountsInfo(n),r=[];o.forEach(c=>{if(!c)return;let u=Al.decode(c.data);r.push(u)});let i=await this.scope.connection.getMultipleAccountsInfo(r.map(c=>c.positionId)),s=[];return i.forEach(c=>{if(!c)return;let u=Do.decode(c.data);s.push(u)}),r.map((c,u)=>({position:s[u],lockInfo:c}))}async getRpcClmmPoolInfo({poolId:e}){return(await this.getRpcClmmPoolInfos({poolIds:[e]}))[String(e)]}async getRpcClmmPoolInfos({poolIds:e,config:t}){let n=await ve(this.scope.connection,e.map(r=>({pubkey:new H(r)})),t),o={};for(let r=0;r<e.length;r++){let i=n[r];if(i===null||!i.accountInfo)throw Error("fetch pool info error: "+String(e[r]));let s=po.decode(i.accountInfo.data),c=se.sqrtPriceX64ToPrice(s.sqrtPriceX64,s.mintDecimalsA,s.mintDecimalsB).toNumber();o[String(e[r])]=q(M({},s),{currentPrice:c,programId:i.accountInfo.owner})}return o}async getComputeClmmPoolInfos({clmmPoolsRpcInfo:e,mintInfos:t}){let n=new Set(Object.keys(e).map(c=>e[c].ammConfig.toBase58())),o=await ve(this.scope.connection,Array.from(n).map(c=>({pubkey:new H(c)}))),r={};o.forEach(c=>{!c.accountInfo||(r[c.pubkey.toBase58()]=bl.decode(c.accountInfo.data))});let i=await Fe.fetchComputeMultipleClmmInfo({connection:this.scope.connection,rpcDataMap:e,poolList:Object.keys(e).map(c=>{var m,p,d,f;let[u,l]=[e[c].mintA.toBase58(),e[c].mintB.toBase58()];return{id:c,programId:e[c].programId.toBase58(),mintA:At({address:u,decimals:e[c].mintDecimalsA,programId:t[u].programId.toBase58()||Gi.toBase58(),extensions:{feeConfig:(m=t[u])!=null&&m.feeConfig?Yn((p=t[u])==null?void 0:p.feeConfig):void 0}}),mintB:At({address:l,decimals:e[c].mintDecimalsB,programId:t[l].programId.toBase58()||Gi.toBase58(),extensions:{feeConfig:(d=t[l])!=null&&d.feeConfig?Yn((f=t[l])==null?void 0:f.feeConfig):void 0}}),price:e[c].currentPrice,config:q(M({},r[e[c].ammConfig.toBase58()]),{id:e[c].ammConfig.toBase58(),fundFeeRate:0,description:"",defaultRange:0,defaultRangePoint:[]})}})}),s=await Fe.fetchMultiplePoolTickArrays({connection:this.scope.connection,poolKeys:Object.values(i)});return{computeClmmPoolInfo:i,computePoolTickData:s}}async getPoolInfoFromRpc(e){var l;let t=await this.getRpcClmmPoolInfo({poolId:e}),n=new Set([t.mintA.toBase58(),t.mintB.toBase58()]),o=await Co({connection:this.scope.connection,mints:Array.from(n).map(m=>new H(m))}),{computeClmmPoolInfo:r,computePoolTickData:i}=await this.scope.clmm.getComputeClmmPoolInfos({clmmPoolsRpcInfo:{[e]:t},mintInfos:o}),s=await ve(this.scope.connection,[{pubkey:t.vaultA},{pubkey:t.vaultB}]),c=fl(r[e]);if(!s[0].accountInfo||!s[1].accountInfo)throw new Error("pool vault data not found");c.mintAmountA=Number(Dl.decode(s[0].accountInfo.data).amount.toString()),c.mintAmountB=Number(Dl.decode((l=s[1].accountInfo)==null?void 0:l.data).amount.toString());let u=q(M({},r[e]),{exBitmapAccount:r[e].exBitmapAccount.toBase58(),observationId:r[e].observationId.toBase58(),id:e,programId:t.programId.toBase58(),openTime:t.startTime.toString(),vault:{A:t.vaultA.toBase58(),B:t.vaultB.toBase58()},config:c.config,rewardInfos:r[e].rewardInfos.filter(m=>!m.tokenVault.equals(H.default)).map(m=>({mint:At({address:m.tokenMint.toBase58(),programId:Gi.toBase58(),decimals:10}),vault:m.tokenVault.toBase58()}))});return{poolInfo:c,poolKeys:u,computePoolInfo:r[e],tickData:i}}};import{PublicKey as U}from"@solana/web3.js";import{AccountLayout as ly,NATIVE_MINT as Yo,TOKEN_PROGRAM_ID as Ct,createAssociatedTokenAccountIdempotentInstruction as Qo}from"@solana/spl-token";import Gl from"bn.js";import es from"bn.js";function tu(a,e){if(e.isZero())throw Error("divisor is zero");return a.mod(e)}function Yf(a,e){if(e.isZero())throw Error("rhs is zero");let t=a.div(e);return tu(a,e).gt(zi)&&(t=t.add(new es(1))),[t,e]}var zi=new es(0),Yi=class{static swapBaseInputWithoutFees(e,t,n){let o=e.mul(n),r=t.add(e);return o.div(r)}static swapBaseOutputWithoutFees(e,t,n){let o=t.mul(e),r=n.sub(e),[i]=Yf(o,r);return i}static lpTokensToTradingTokens(e,t,n,o,r){let i=e.mul(n).div(t),s=e.mul(o).div(t);if(r===0)return{tokenAmount0:i,tokenAmount1:s};if(r===1)return tu(e.mul(n),t).gt(zi)&&i.gt(zi)&&(i=i.add(new es(1))),tu(e.mul(o),t).gt(zi)&&s.gt(zi)&&(s=s.add(new es(1))),{tokenAmount0:i,tokenAmount1:s};throw Error("roundDirection value error")}};import Qf from"bn.js";var Nt=class{static tradingFee(e,t){return ri(e,t,Rt)}static protocolFee(e,t){return wr(e,t,Rt)}static fundFee(e,t){return wr(e,t,Rt)}static creatorFee(e,t){return ri(e,t,Rt)}static splitCreatorFee(e,t,n){return wr(e,n,t.add(n))}static calculatePreFeeAmount(e,t){if(t.isZero())return e;let n=e.mul(Rt),o=Rt.sub(t);return n.add(o).sub(new Qf(1)).div(o)}};var Ul=(t=>(t[t.Floor=0]="Floor",t[t.Ceiling=1]="Ceiling",t))(Ul||{}),Hf=(t=>(t[t.ZeroForOne=0]="ZeroForOne",t[t.OneForZero=1]="OneForZero",t))(Hf||{}),jf=(t=>(t[t.OneForZero=0]="OneForZero",t[t.ZeroForOne=1]="ZeroForOne",t))(jf||{}),Qi=class{static validate_supply(e,t){if(e.isZero())throw Error("tokenAmount0 is zero");if(t.isZero())throw Error("tokenAmount1 is zero")}static swapBaseInput(e,t,n,o,r,i,s,c){let u=new Gl(0),l=Nt.tradingFee(e,o),m;c?(u=Nt.creatorFee(e,r),m=e.sub(l).sub(u)):m=e.sub(l);let p=Nt.protocolFee(l,i),d=Nt.protocolFee(l,s),f=Yi.swapBaseInputWithoutFees(m,t,n),y;return c?y=f:(u=Nt.creatorFee(f,r),y=f.sub(u)),{newInputVaultAmount:t.add(m),newOutputVaultAmount:n.sub(f),inputAmount:e,outputAmount:y,tradeFee:l,protocolFee:p,fundFee:d,creatorFee:u}}static swapBaseOutput(e,t,n,o,r,i,s,c){let u,l=new Gl(0),m;if(c)m=e;else{let b=Nt.calculatePreFeeAmount(e,r);l=b.sub(e),m=b}let p=Yi.swapBaseOutputWithoutFees(m,t,n),d;if(c){let b=Nt.calculatePreFeeAmount(p,o.add(r)),g=b.sub(p);l=Nt.splitCreatorFee(g,o,r),u=g.sub(l),d=b}else{let b=Nt.calculatePreFeeAmount(p,o);u=b.sub(p),d=b}let f=Nt.protocolFee(u,i),y=Nt.fundFee(u,s);return{newInputVaultAmount:t.add(p),newOutputVaultAmount:e.sub(m),inputAmount:d,outputAmount:e,tradeFee:u,protocolFee:f,fundFee:y,creatorFee:l}}};import Xe from"bn.js";import Ht from"decimal.js";import{PublicKey as $i,TransactionInstruction as Ln,Keypair as ay,SystemProgram as iu}from"@solana/web3.js";import{ASSOCIATED_TOKEN_PROGRAM_ID as ts,TOKEN_2022_PROGRAM_ID as ru,TOKEN_PROGRAM_ID as Rn}from"@solana/spl-token";var $f=Buffer.from("vault_and_lp_mint_auth_seed","utf8"),Zf=Buffer.from("amm_config","utf8"),Jf=Buffer.from("pool","utf8"),ey=Buffer.from("pool_lp_mint","utf8"),ty=Buffer.from("pool_vault","utf8"),ny=Buffer.from("observation","utf8"),oy=Buffer.from("permission","utf8");function zo(a){return te([$f],a)}function jK(a,e){return te([Zf,ry(e)],a)}function nu(a,e,t,n){return te([Jf,e.toBuffer(),t.toBuffer(),n.toBuffer()],a)}function iy(a,e){return te([ey,e.toBuffer()],a)}function Xl(a,e,t){return te([ty,e.toBuffer(),t.toBuffer()],a)}function Hi(a,e){return te([ny,e.toBuffer()],a)}function ry(a){let e=new ArrayBuffer(2);return new DataView(e).setUint16(0,a,!1),new Uint8Array(e)}function ou({poolId:a,programId:e,configId:t,mintA:n,mintB:o}){let r=zo(e).publicKey,i=a||nu(e,t,n,o).publicKey,s=iy(e,i).publicKey,c=Xl(e,i,n).publicKey,u=Xl(e,i,o).publicKey,l=Hi(e,i).publicKey;return{poolId:i,configId:t,authority:r,lpMint:s,vaultA:c,vaultB:u,observationId:l}}var sy=Buffer.from("locked_liquidity","utf8");function ji(a,e){return te([sy,e.toBuffer()],a)}function zl(a,e){return te([oy,e.toBuffer()],a)}var uy=be("Raydium_cpmm"),On={initialize:[175,175,109,31,13,152,155,237],deposit:[242,35,198,137,82,225,242,182],withdraw:[183,18,70,156,148,109,161,34],swapBaseInput:[143,190,90,218,196,30,51,222],swapBaseOutput:[55,217,98,86,163,74,180,173],lockCpLiquidity:[216,157,29,78,38,51,31,26],collectCpFee:[8,30,51,199,209,184,247,133],createPermissionPda:Buffer.from([135,136,2,216,137,169,181,202]),closePermissionPda:Buffer.from([156,84,32,118,69,135,70,123]),initializeWithPermission:Buffer.from([63,55,254,65,49,178,89,121]),collectCreatorFee:Buffer.from([20,22,86,123,198,28,219,132])};function Yl(a,e,t,n,o,r,i,s,c,u,l,m,p,d,f,y,b,g,P,h){let I=F([A("amountMaxA"),A("amountMaxB"),A("openTime")]),T=nu(a,t,r,i).publicKey,w=[{pubkey:e,isSigner:!0,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!o.equals(T),isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!1},{pubkey:i,isSigner:!1,isWritable:!1},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:m,isSigner:!1,isWritable:!0},{pubkey:p,isSigner:!1,isWritable:!0},{pubkey:d,isSigner:!1,isWritable:!0},{pubkey:b,isSigner:!1,isWritable:!0},{pubkey:Rn,isSigner:!1,isWritable:!1},{pubkey:f,isSigner:!1,isWritable:!1},{pubkey:y,isSigner:!1,isWritable:!1},{pubkey:ts,isSigner:!1,isWritable:!1},{pubkey:Ar,isSigner:!1,isWritable:!1},{pubkey:Je,isSigner:!1,isWritable:!1}],K=Buffer.alloc(I.span);return I.encode({amountMaxA:g,amountMaxB:P,openTime:h},K),new Ln({keys:w,programId:a,data:Buffer.from([...On.initialize,...K])})}function Ql(a,e,t,n,o,r,i,s,c,u,l,m,p,d,f){let y=F([A("lpAmount"),A("amountMaxA"),A("amountMaxB")]),b=[{pubkey:e,isSigner:!0,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:Rn,isSigner:!1,isWritable:!1},{pubkey:ru,isSigner:!1,isWritable:!1},{pubkey:u,isSigner:!1,isWritable:!1},{pubkey:l,isSigner:!1,isWritable:!1},{pubkey:m,isSigner:!1,isWritable:!0}],g=Buffer.alloc(y.span);return uy.debug("cpmm deposit data",{lpAmount:p.toString(),amountMaxA:d.toString(),amountMaxB:f.toString()}),y.encode({lpAmount:p,amountMaxA:d,amountMaxB:f},g),new Ln({keys:b,programId:a,data:Buffer.from([...On.deposit,...g])})}function Hl(a,e,t,n,o,r,i,s,c,u,l,m,p,d,f){let y=F([A("lpAmount"),A("amountMinA"),A("amountMinB")]),b=[{pubkey:e,isSigner:!0,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:Rn,isSigner:!1,isWritable:!1},{pubkey:ru,isSigner:!1,isWritable:!1},{pubkey:u,isSigner:!1,isWritable:!1},{pubkey:l,isSigner:!1,isWritable:!1},{pubkey:m,isSigner:!1,isWritable:!0},{pubkey:mn,isSigner:!1,isWritable:!1}],g=Buffer.alloc(y.span);return y.encode({lpAmount:p,amountMinA:d,amountMinB:f},g),new Ln({keys:b,programId:a,data:Buffer.from([...On.withdraw,...g])})}function ns(a,e,t,n,o,r,i,s,c,u,l,m,p,d,f,y){let b=F([A("amountIn"),A("amounOutMin")]),g=[{pubkey:e,isSigner:!0,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!1},{pubkey:l,isSigner:!1,isWritable:!1},{pubkey:m,isSigner:!1,isWritable:!1},{pubkey:p,isSigner:!1,isWritable:!1},{pubkey:d,isSigner:!1,isWritable:!0}],P=Buffer.alloc(b.span);return b.encode({amountIn:f,amounOutMin:y},P),new Ln({keys:g,programId:a,data:Buffer.from([...On.swapBaseInput,...P])})}function jl(a,e,t,n,o,r,i,s,c,u,l,m,p,d,f,y){let b=F([A("amountInMax"),A("amountOut")]),g=[{pubkey:e,isSigner:!0,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!1},{pubkey:l,isSigner:!1,isWritable:!1},{pubkey:m,isSigner:!1,isWritable:!1},{pubkey:p,isSigner:!1,isWritable:!1},{pubkey:d,isSigner:!1,isWritable:!0}],P=Buffer.alloc(b.span);return b.encode({amountInMax:f,amountOut:y},P),new Ln({keys:g,programId:a,data:Buffer.from([...On.swapBaseOutput,...P])})}async function $l(a){var b;let{ownerInfo:e,poolInfo:t,poolKeys:n,feeNftOwner:o,getEphemeralSigners:r}=a,i=[],[s,c]=[new $i(t.id),new $i(t.lpMint.address)],u;if(r)u=new $i((await r(1))[0]);else{let g=ay.generate();i.push(g),u=g.publicKey}let{publicKey:l}=j(o,u,Rn),{publicKey:m}=xn(u),{publicKey:p}=ji(a.lockProgram,u),{publicKey:d}=j(e.wallet,c,Rn),{publicKey:f}=j(a.lockAuthProgram,c,Rn),y=cy({programId:a.lockProgram,auth:a.lockAuthProgram,payer:e.feePayer,liquidityOwner:e.wallet,nftOwner:o,nftMint:u,nftAccount:l,poolId:s,lockPda:p,mintLp:c,userLpVault:d,lockLpVault:f,poolVaultA:new $i(n.vault.A),poolVaultB:new $i(n.vault.B),metadataAccount:m,lpAmount:a.lpAmount,withMetadata:(b=a.withMetadata)!=null?b:!0});return{address:{nftMint:u,nftAccount:l,metadataAccount:m,lockPda:p,userLpVault:d,lockLpVault:f},instructions:[y],signers:i,instructionTypes:[G.CpmmLockLp],lookupTableAddress:[]}}function cy({programId:a,auth:e,payer:t,liquidityOwner:n,nftOwner:o,nftMint:r,nftAccount:i,poolId:s,lockPda:c,mintLp:u,userLpVault:l,lockLpVault:m,poolVaultA:p,poolVaultB:d,metadataAccount:f,lpAmount:y,withMetadata:b}){let g=[{pubkey:e,isSigner:!1,isWritable:!1},{pubkey:t,isSigner:!0,isWritable:!0},{pubkey:n,isSigner:!0,isWritable:!1},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!0,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!1},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!1},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:m,isSigner:!1,isWritable:!0},{pubkey:p,isSigner:!1,isWritable:!0},{pubkey:d,isSigner:!1,isWritable:!0},{pubkey:f,isSigner:!1,isWritable:!0},{pubkey:Je,isSigner:!1,isWritable:!1},{pubkey:iu.programId,isSigner:!1,isWritable:!1},{pubkey:Rn,isSigner:!1,isWritable:!1},{pubkey:ts,isSigner:!1,isWritable:!1},{pubkey:Gt,isSigner:!1,isWritable:!1}],P=F([A("lpAmount"),qe("withMetadata")]),h=Buffer.alloc(P.span);P.encode({lpAmount:y,withMetadata:b},h);let I=Buffer.from([...On.lockCpLiquidity,...h]);return new Ln({keys:g,programId:a,data:I})}function su({programId:a,nftOwner:e,auth:t,nftAccount:n,lockPda:o,poolId:r,mintLp:i,userVaultA:s,userVaultB:c,poolVaultA:u,poolVaultB:l,mintA:m,mintB:p,lockLpVault:d,lpFeeAmount:f,cpmmProgram:y,cpmmAuthProgram:b}){let g=[{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:e,isSigner:!0,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:y!=null?y:Wn,isSigner:!1,isWritable:!1},{pubkey:b!=null?b:Us,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:m,isSigner:!1,isWritable:!1},{pubkey:p,isSigner:!1,isWritable:!1},{pubkey:d,isSigner:!1,isWritable:!0},{pubkey:Rn,isSigner:!1,isWritable:!1},{pubkey:ru,isSigner:!1,isWritable:!1},{pubkey:mn,isSigner:!1,isWritable:!1}],P=F([A("lpFeeAmount")]),h=Buffer.alloc(P.span);P.encode({lpFeeAmount:f},h);let I=Buffer.from([...On.collectCpFee,...h]);return new Ln({keys:g,programId:a,data:I})}function au(a,e,t,n,o,r,i,s,c,u,l,m,p){let d=[{pubkey:e,isSigner:!0,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!1},{pubkey:c,isSigner:!1,isWritable:!1},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:m,isSigner:!1,isWritable:!1},{pubkey:p,isSigner:!1,isWritable:!1},{pubkey:ts,isSigner:!1,isWritable:!1},{pubkey:iu.programId,isSigner:!1,isWritable:!1}];return new Ln({keys:d,programId:a,data:On.collectCreatorFee})}function Zl(a,e,t,n,o,r,i,s,c,u,l,m,p,d,f,y,b,g,P,h,I,T,w){let K=F([A("amountA"),A("amountB"),A("openTime"),_("feeOn")]),x=[{pubkey:e,isSigner:!0,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!1},{pubkey:s,isSigner:!1,isWritable:!1},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:m,isSigner:!1,isWritable:!0},{pubkey:p,isSigner:!1,isWritable:!0},{pubkey:d,isSigner:!1,isWritable:!0},{pubkey:f,isSigner:!1,isWritable:!0},{pubkey:g,isSigner:!1,isWritable:!0},{pubkey:P,isSigner:!1,isWritable:!0},{pubkey:Rn,isSigner:!1,isWritable:!1},{pubkey:y,isSigner:!1,isWritable:!1},{pubkey:b,isSigner:!1,isWritable:!1},{pubkey:ts,isSigner:!1,isWritable:!1},{pubkey:iu.programId,isSigner:!1,isWritable:!1}],S=Buffer.alloc(K.span);return K.encode({amountA:h,amountB:I,openTime:T,feeOn:w},S),new Ln({keys:x,programId:a,data:Buffer.from([...On.initializeWithPermission,...S])})}var Jl=F([Be(8),_("bump"),qe("disableCreatePool"),Et("index"),A("tradeFeeRate"),A("protocolFeeRate"),A("fundFeeRate"),A("createPoolFee"),O("protocolOwner"),O("fundOwner"),A("creatorFeeRate"),Y(A(),15)]),os=F([Be(8),O("configId"),O("poolCreator"),O("vaultA"),O("vaultB"),O("mintLp"),O("mintA"),O("mintB"),O("mintProgramA"),O("mintProgramB"),O("observationId"),_("bump"),_("status"),_("lpDecimals"),_("mintDecimalA"),_("mintDecimalB"),A("lpAmount"),A("protocolFeesMintA"),A("protocolFeesMintB"),A("fundFeesMintA"),A("fundFeesMintB"),A("openTime"),A("epoch"),_("feeOn"),qe("enableCreatorFee"),Y(_(),6),A("creatorFeesMintA"),A("creatorFeesMintB"),Y(A(),28)]),cS=F([Be(8),O("configId"),Y(A(),30)]);var em=(n=>(n[n.BothToken=0]="BothToken",n[n.OnlyTokenA=1]="OnlyTokenA",n[n.OnlyTokenB=2]="OnlyTokenB",n))(em||{});var Zi=class extends We{constructor(e){super(e)}async load(){this.checkDisabled()}async getCpmmPoolKeys(e){return(await this.scope.api.fetchPoolKeysById({idList:[e]}))[0]}async getRpcPoolInfo(e,t){return(await this.getRpcPoolInfos([e],t))[e]}async getRpcPoolInfos(e,t){let n=await ve(this.scope.connection,e.map(m=>({pubkey:new U(m)}))),o={},r=new Set,i=[];for(let m=0;m<e.length;m++){let p=n[m];if(p.accountInfo===null)throw Error("fetch pool info error: "+String(e[m]));let d=os.decode(p.accountInfo.data);o[String(e[m])]=q(M({},d),{programId:p.accountInfo.owner}),r.add(String(d.configId)),i.push(d.vaultA,d.vaultB)}let s={};if(t){let m=[...r],p=await ve(this.scope.connection,m.map(d=>({pubkey:new U(d)})));for(let d=0;d<m.length;d++){let f=p[d].accountInfo;if(f===null)throw Error("fetch pool config error: "+m[d]);s[m[d]]=Jl.decode(f.data)}}let c={},u=await ve(this.scope.connection,i.map(m=>({pubkey:new U(m)})));for(let m=0;m<i.length;m++){let p=u[m].accountInfo;if(p===null)throw Error("fetch vault info error: "+i[m]);c[String(i[m])]=new Xe(ly.decode(p.data).amount.toString())}let l={};for(let[m,p]of Object.entries(o)){let d=c[p.vaultA.toString()].sub(p.protocolFeesMintA).sub(p.fundFeesMintA).sub(p.creatorFeesMintA),f=c[p.vaultB.toString()].sub(p.protocolFeesMintB).sub(p.fundFeesMintB).sub(p.creatorFeesMintB);l[m]=q(M({},p),{baseReserve:d,quoteReserve:f,vaultAAmount:c[p.vaultA.toString()],vaultBAmount:c[p.vaultB.toString()],configInfo:s[p.configId.toString()],poolPrice:new Ht(f.toString()).div(new Ht(10).pow(p.mintDecimalB)).div(new Ht(d.toString()).div(new Ht(10).pow(p.mintDecimalA)))})}return l}toComputePoolInfos({pools:e,mintInfos:t}){return Object.keys(e).reduce((n,o)=>{var c,u,l,m;let r=e[o],[i,s]=[r.mintA.toBase58(),r.mintB.toBase58()];return q(M({},n),{[o]:q(M({},r),{id:new U(o),configInfo:r.configInfo,version:7,authority:zo(r.programId).publicKey,mintA:At({address:i,decimals:r.mintDecimalA,programId:r.mintProgramA.toBase58(),extensions:{feeConfig:(c=t[i])!=null&&c.feeConfig?Yn((u=t[i])==null?void 0:u.feeConfig):void 0}}),mintB:At({address:s,decimals:r.mintDecimalB,programId:r.mintProgramB.toBase58(),extensions:{feeConfig:(l=t[s])!=null&&l.feeConfig?Yn((m=t[s])==null?void 0:m.feeConfig):void 0}})})})},{})}async getPoolInfoFromRpc(e){let t=await this.getRpcPoolInfo(e,!0),n=await Co({connection:this.scope.connection,mints:[t.mintA,t.mintB]}),o=At({address:t.mintA.toBase58(),decimals:t.mintDecimalA,programId:t.mintProgramA.toBase58(),extensions:{feeConfig:n[t.mintA.toBase58()].feeConfig?Yn(n[t.mintA.toBase58()].feeConfig):void 0}}),r=At({address:t.mintB.toBase58(),decimals:t.mintDecimalB,programId:t.mintProgramB.toBase58(),extensions:{feeConfig:n[t.mintB.toBase58()].feeConfig?Yn(n[t.mintB.toBase58()].feeConfig):void 0}}),i=At({address:t.mintLp.toBase58(),decimals:t.lpDecimals,programId:Ct.toBase58()}),s={id:t.configId.toBase58(),index:t.configInfo.index,protocolFeeRate:t.configInfo.protocolFeeRate.toNumber(),tradeFeeRate:t.configInfo.tradeFeeRate.toNumber(),fundFeeRate:t.configInfo.fundFeeRate.toNumber(),createPoolFee:t.configInfo.createPoolFee.toString()},c={volume:0,volumeQuote:0,volumeFee:0,apr:0,feeApr:0,priceMin:0,priceMax:0,rewardApr:[]};return{poolInfo:{programId:t.programId.toBase58(),id:e,type:"Standard",lpMint:i,lpPrice:0,lpAmount:t.lpAmount.toNumber(),config:s,mintA:o,mintB:r,rewardDefaultInfos:[],rewardDefaultPoolInfos:"Ecosystem",price:t.poolPrice.toNumber(),mintAmountA:new Ht(t.vaultAAmount.toString()).div(10**o.decimals).toNumber(),mintAmountB:new Ht(t.vaultBAmount.toString()).div(10**r.decimals).toNumber(),feeRate:t.configInfo.tradeFeeRate.toNumber(),openTime:t.openTime.toString(),tvl:0,burnPercent:0,day:c,week:c,month:c,pooltype:[],farmUpcomingCount:0,farmOngoingCount:0,farmFinishedCount:0},poolKeys:{programId:t.programId.toBase58(),id:e,mintA:o,mintB:r,openTime:t.openTime.toString(),vault:{A:t.vaultA.toBase58(),B:t.vaultB.toBase58()},authority:zo(t.programId).publicKey.toBase58(),mintLp:i,config:s,observationId:Hi(t.programId,new U(e)).publicKey.toBase58()},rpcData:t}}async createPool(f){var y=f,{poolId:e,programId:t,poolFeeAccount:n,startTime:o,ownerInfo:r,associatedOnly:i=!1,checkCreateATAOwner:s=!1,txVersion:c,feeConfig:u,computeBudgetConfig:l,txTipConfig:m,feePayer:p}=y,d=_e(y,["poolId","programId","poolFeeAccount","startTime","ownerInfo","associatedOnly","checkCreateATAOwner","txVersion","feeConfig","computeBudgetConfig","txTipConfig","feePayer"]);var E,X,Q;let b=r.feePayer||((E=this.scope.owner)==null?void 0:E.publicKey),g=new Xe(new U(d.mintA.address).toBuffer()).lte(new Xe(new U(d.mintB.address).toBuffer())),[P,h]=g?[d.mintA,d.mintB]:[d.mintB,d.mintA],[I,T]=g?[d.mintAAmount,d.mintBAmount]:[d.mintBAmount,d.mintAAmount],w=r.useSOLBalance&&P.address===Yo.toBase58(),K=r.useSOLBalance&&h.address===Yo.toBase58(),[x,S]=[new U(P.address),new U(h.address)],B=this.createTxBuilder(p),{account:R,instructionParams:C}=await this.scope.account.getOrCreateTokenAccount({mint:x,tokenProgram:P.programId,owner:this.scope.ownerPubKey,createInfo:w?{payer:b,amount:I}:void 0,notUseTokenAccount:w,skipCloseAccount:!w,associatedOnly:w?!1:i,checkCreateATAOwner:s});B.addInstruction(C||{});let{account:v,instructionParams:L}=await this.scope.account.getOrCreateTokenAccount({mint:new U(h.address),tokenProgram:h.programId,owner:this.scope.ownerPubKey,createInfo:K?{payer:b,amount:T}:void 0,notUseTokenAccount:K,skipCloseAccount:!K,associatedOnly:K?!1:i,checkCreateATAOwner:s});if(B.addInstruction(L||{}),R===void 0||v===void 0)throw Error("you don't has some token account");let N=ou({poolId:e,programId:t,configId:new U(u.id),mintA:x,mintB:S});return B.addInstruction({instructions:[Yl(t,this.scope.ownerPubKey,new U(u.id),N.authority,N.poolId,x,S,N.lpMint,R,v,j(this.scope.ownerPubKey,N.lpMint).publicKey,N.vaultA,N.vaultB,n,new U((X=P.programId)!=null?X:Ct),new U((Q=h.programId)!=null?Q:Ct),N.observationId,I,T,o)],instructionTypes:[G.CpmmCreatePool]}),B.addCustomComputeBudget(l),B.addTipInstruction(m),B.versionBuild({txVersion:c,extInfo:{address:q(M({},N),{mintA:P,mintB:h,programId:t,poolFeeAccount:n,feeConfig:u})}})}async addLiquidity(e){let{poolInfo:t,poolKeys:n,inputAmount:o,baseIn:r,slippage:i,computeResult:s,computeBudgetConfig:c,txTipConfig:u,config:l,txVersion:m,feePayer:p}=e;this.scope.availability.addStandardPosition===!1&&this.logAndCreateError("add liquidity feature disabled in your region"),o.isZero()&&this.logAndCreateError("amounts must greater than zero","amountInA",{amountInA:o.toString()});let{account:d}=this.scope,{bypassAssociatedCheck:f,checkCreateATAOwner:y}=M({bypassAssociatedCheck:!1,checkCreateATAOwner:!1},l),b=s?void 0:await this.getRpcPoolInfo(t.id),{liquidity:g,inputAmountFee:P,anotherAmount:h}=s||this.computePairAmount({poolInfo:q(M({},t),{lpAmount:new Ht(b.lpAmount.toString()).div(10**t.lpMint.decimals).toNumber()}),baseReserve:b.baseReserve,quoteReserve:b.quoteReserve,slippage:new Qe(0),baseIn:r,epochInfo:await this.scope.fetchEpochInfo(),amount:new Ht(o.toString()).div(10**(r?t.mintA.decimals:t.mintB.decimals))}),I=h.amount,T=t.mintA.address===Yo.toString(),w=t.mintB.address===Yo.toString(),K=this.createTxBuilder(p),[x,S]=[new U(t.mintA.address),new U(t.mintB.address)],{account:B,instructionParams:R}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:t.mintA.programId,mint:new U(t.mintA.address),owner:this.scope.ownerPubKey,createInfo:T||(r?o:I).isZero()?{payer:this.scope.ownerPubKey,amount:r?o:I}:void 0,skipCloseAccount:!T,notUseTokenAccount:T,associatedOnly:!1,checkCreateATAOwner:y});K.addInstruction(R||{});let{account:C,instructionParams:v}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:t.mintB.programId,mint:new U(t.mintB.address),owner:this.scope.ownerPubKey,createInfo:w||(r?I:o).isZero()?{payer:this.scope.ownerPubKey,amount:r?I:o}:void 0,skipCloseAccount:!w,notUseTokenAccount:w,associatedOnly:!1,checkCreateATAOwner:y});K.addInstruction(v||{}),!B&&!C&&this.logAndCreateError("cannot found target token accounts","tokenAccounts",d.tokenAccounts);let L=await d.getCreatedTokenAccount({mint:new U(t.lpMint.address)}),ee=await d.handleTokenAccount({side:"out",amount:0,mint:new U(t.lpMint.address),tokenAccount:L,bypassAssociatedCheck:f,checkCreateATAOwner:y}),{tokenAccount:N}=ee,E=_e(ee,["tokenAccount"]);K.addInstruction(E);let X=n!=null?n:await this.getCpmmPoolKeys(t.id),Q=new Qe(new Xe(1)).sub(i);return K.addInstruction({instructions:[Ql(new U(t.programId),this.scope.ownerPubKey,new U(X.authority),new U(t.id),N,B,C,new U(X.vault.A),new U(X.vault.B),x,S,new U(t.lpMint.address),s?s==null?void 0:s.liquidity:Q.mul(g).quotient,r?P.amount:I,r?I:P.amount)],instructionTypes:[G.CpmmAddLiquidity],lookupTableAddress:X.lookupTableAccount?[X.lookupTableAccount]:[]}),K.addCustomComputeBudget(c),K.addTipInstruction(u),K.versionBuild({txVersion:m})}async withdrawLiquidity(e){var E,X;let{poolInfo:t,poolKeys:n,lpAmount:o,slippage:r,computeBudgetConfig:i,txTipConfig:s,txVersion:c,feePayer:u,closeWsol:l=!0}=e;this.scope.availability.addStandardPosition===!1&&this.logAndCreateError("add liquidity feature disabled in your region");let m=new Qe(new Xe(1)).sub(r),p=await this.getRpcPoolInfo(t.id),[d,f]=[m.mul(o.mul(p.baseReserve).div(p.lpAmount)).quotient,m.mul(o.mul(p.quoteReserve).div(p.lpAmount)).quotient],y=await this.scope.fetchEpochInfo(),[b,g]=[xe(d,t.mintA.extensions.feeConfig,y,!1),xe(f,t.mintB.extensions.feeConfig,y,!1)],{account:P}=this.scope,h=this.createTxBuilder(u),[I,T]=[new U(t.mintA.address),new U(t.mintB.address)],w=I.equals($),K=T.equals($),x,S,{account:B,instructionParams:R}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:t.mintA.programId,mint:new U(t.mintA.address),notUseTokenAccount:w,owner:this.scope.ownerPubKey,createInfo:{payer:this.scope.ownerPubKey,amount:0},skipCloseAccount:!(w&&l),associatedOnly:!w,checkCreateATAOwner:!1});x=B,R&&h.addInstruction(R);let{account:C,instructionParams:v}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:t.mintB.programId,mint:new U(t.mintB.address),notUseTokenAccount:K,owner:this.scope.ownerPubKey,createInfo:{payer:this.scope.ownerPubKey,amount:0},skipCloseAccount:!(K&&l),associatedOnly:!K,checkCreateATAOwner:!1});S=C,v&&h.addInstruction(v),(!x||!S)&&this.logAndCreateError("cannot found target token accounts","tokenAccounts",P.tokenAccounts);let L=await P.getCreatedTokenAccount({mint:new U(t.lpMint.address)});L||this.logAndCreateError("cannot found lp token account","tokenAccounts",P.tokenAccounts);let N=n!=null?n:await this.getCpmmPoolKeys(t.id);return h.addInstruction({instructions:[Hl(new U(t.programId),this.scope.ownerPubKey,new U(N.authority),new U(t.id),L,x,S,new U(N.vault.A),new U(N.vault.B),I,T,new U(t.lpMint.address),o,d.sub((E=b.fee)!=null?E:new Xe(0)),f.sub((X=g.fee)!=null?X:new Xe(0)))],instructionTypes:[G.CpmmWithdrawLiquidity],lookupTableAddress:N.lookupTableAccount?[N.lookupTableAccount]:[]}),h.addCustomComputeBudget(i),h.addTipInstruction(s),h.versionBuild({txVersion:c})}async swap(e){var R,C,v,L,N,E;let{poolInfo:t,poolKeys:n,baseIn:o,fixedOut:r,inputAmount:i,swapResult:s,slippage:c=0,config:u,computeBudgetConfig:l,txTipConfig:m,txVersion:p,feePayer:d}=e,{bypassAssociatedCheck:f,checkCreateATAOwner:y,associatedOnly:b}=M({bypassAssociatedCheck:!1,checkCreateATAOwner:!1,associatedOnly:!0},u),g=this.createTxBuilder(d),[P,h]=[new U(t.mintA.address),new U(t.mintB.address)];r?s.inputAmount=s.inputAmount.mul(new Xe((1+c)*1e4)).div(new Xe(1e4)):s.outputAmount=s.outputAmount.mul(new Xe((1-c)*1e4)).div(new Xe(1e4));let I=t.mintA.address===$.toBase58(),T=t.mintB.address===$.toBase58(),{account:w,instructionParams:K}=await this.scope.account.getOrCreateTokenAccount({mint:P,tokenProgram:new U((R=t.mintA.programId)!=null?R:Ct),owner:this.scope.ownerPubKey,createInfo:I||!o?{payer:this.scope.ownerPubKey,amount:o?s.inputAmount:0}:void 0,notUseTokenAccount:I,skipCloseAccount:!I,associatedOnly:I?!1:b,checkCreateATAOwner:y});K&&g.addInstruction(K);let{account:x,instructionParams:S}=await this.scope.account.getOrCreateTokenAccount({mint:h,tokenProgram:new U((C=t.mintB.programId)!=null?C:Ct),owner:this.scope.ownerPubKey,createInfo:T||o?{payer:this.scope.ownerPubKey,amount:o?0:s.inputAmount}:void 0,notUseTokenAccount:T,skipCloseAccount:!T,associatedOnly:T?!1:b,checkCreateATAOwner:y});S&&g.addInstruction(S),(!w||!x)&&this.logAndCreateError("user do not have token account",{mintA:t.mintA.symbol||t.mintA.address,mintB:t.mintB.symbol||t.mintB.address,mintATokenAcc:w,mintBTokenAcc:x,mintAUseSOLBalance:I,mintBUseSOLBalance:T,associatedOnly:b});let B=n!=null?n:await this.getCpmmPoolKeys(t.id);return g.addInstruction({instructions:[r?jl(new U(t.programId),this.scope.ownerPubKey,new U(B.authority),new U(B.config.id),new U(t.id),o?w:x,o?x:w,new U(B.vault[o?"A":"B"]),new U(B.vault[o?"B":"A"]),new U((N=t[o?"mintA":"mintB"].programId)!=null?N:Ct),new U((E=t[o?"mintB":"mintA"].programId)!=null?E:Ct),o?P:h,o?h:P,Hi(new U(t.programId),new U(t.id)).publicKey,s.inputAmount,s.outputAmount):ns(new U(t.programId),this.scope.ownerPubKey,new U(B.authority),new U(B.config.id),new U(t.id),o?w:x,o?x:w,new U(B.vault[o?"A":"B"]),new U(B.vault[o?"B":"A"]),new U((v=t[o?"mintA":"mintB"].programId)!=null?v:Ct),new U((L=t[o?"mintB":"mintA"].programId)!=null?L:Ct),o?P:h,o?h:P,Hi(new U(t.programId),new U(t.id)).publicKey,i,s.outputAmount)],instructionTypes:[r?G.CpmmSwapBaseOut:G.ClmmSwapBaseIn]}),g.addCustomComputeBudget(l),g.addTipInstruction(m),g.versionBuild({txVersion:p})}async lockLp(e){var p,d,f,y,b;let{poolInfo:t,lpAmount:n,computeBudgetConfig:o,txTipConfig:r,txVersion:i,feePayer:s,feeNftOwner:c}=e;n.isZero()&&this.logAndCreateError("lpAmount must greater than zero",{lpAmount:n.toString()});let u=this.createTxBuilder(s),l=(p=e.poolKeys)!=null?p:await this.getCpmmPoolKeys(t.id),m=await $l({poolInfo:t,poolKeys:l,ownerInfo:{wallet:this.scope.ownerPubKey,feePayer:(d=e.feePayer)!=null?d:this.scope.ownerPubKey},feeNftOwner:c!=null?c:this.scope.ownerPubKey,lockProgram:(f=e.programId)!=null?f:mi,lockAuthProgram:(y=e.authProgram)!=null?y:di,lpAmount:n,withMetadata:(b=e.withMetadata)!=null?b:!0,getEphemeralSigners:e.getEphemeralSigners});return u.addInstruction(m),u.addCustomComputeBudget(o),u.addTipInstruction(r),u.versionBuild({txVersion:i,extInfo:m.address})}async harvestLockLp(e){var C;let{poolInfo:t,lpFeeAmount:n,nftMint:o,programId:r=mi,authProgram:i=di,cpmmProgram:s,computeBudgetConfig:c,txTipConfig:u,txVersion:l,closeWsol:m=!0}=e;n.isZero()&&this.logAndCreateError("lpFeeAmount must greater than zero",{lpAmount:n.toString()});let p=e.feePayer||this.scope.ownerPubKey,d=this.createTxBuilder(p),[f,y]=[new U(t.mintA.address),new U(t.mintB.address)],b=f.equals($),g=y.equals($),P,h,{account:I,instructionParams:T}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:t.mintA.programId,mint:new U(t.mintA.address),notUseTokenAccount:b,owner:this.scope.ownerPubKey,createInfo:{payer:this.scope.ownerPubKey,amount:0},skipCloseAccount:!(b&&m),associatedOnly:!b,checkCreateATAOwner:!1});P=I,T&&d.addInstruction(T);let{account:w,instructionParams:K}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:t.mintB.programId,mint:new U(t.mintB.address),notUseTokenAccount:g,owner:this.scope.ownerPubKey,createInfo:{payer:this.scope.ownerPubKey,amount:0},skipCloseAccount:!(g&&m),associatedOnly:!g,checkCreateATAOwner:!1});h=w,K&&d.addInstruction(K),(!P||!h)&&this.logAndCreateError("cannot found target token accounts",{tokenAccountA:P,tokenAccountB:h});let x=(C=e.poolKeys)!=null?C:await this.getCpmmPoolKeys(t.id),{publicKey:S}=j(p,o,Ct),{publicKey:B}=ji(r,o),{publicKey:R}=j(i,new U(t.lpMint.address),Ct);return d.addInstruction({instructions:[su({programId:r,nftOwner:this.scope.ownerPubKey,auth:i,nftMint:o,nftAccount:S,lockPda:B,poolId:new U(t.id),mintLp:new U(x.mintLp.address),userVaultA:P,userVaultB:h,poolVaultA:new U(x.vault.A),poolVaultB:new U(x.vault.B),mintA:f,mintB:y,lockLpVault:R,lpFeeAmount:n,cpmmProgram:s==null?void 0:s.programId,cpmmAuthProgram:s==null?void 0:s.authProgram})],instructionTypes:[G.CpmmCollectLockFee]}),d.addCustomComputeBudget(c),d.addTipInstruction(u),d.versionBuild({txVersion:l})}async harvestMultiLockLp(e){var p;let{lockInfo:t,programId:n=mi,authProgram:o=di,cpmmProgram:r,computeBudgetConfig:i,txVersion:s,closeWsol:c=!0}=e,u=e.feePayer||this.scope.ownerPubKey,l=this.createTxBuilder(u),m={};for(let d of t){let{poolInfo:f,lpFeeAmount:y,nftMint:b}=d;if(y.isZero())continue;let[g,P]=[new U(f.mintA.address),new U(f.mintB.address)],h=g.equals($),I=P.equals($),T=m[f.mintA.address],w=m[f.mintB.address];if(!T)if(h){let{account:R,instructionParams:C}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:f.mintA.programId,mint:new U(f.mintA.address),notUseTokenAccount:!0,owner:this.scope.ownerPubKey,createInfo:{payer:this.scope.ownerPubKey,amount:0},skipCloseAccount:!c,associatedOnly:!1,checkCreateATAOwner:!1});T=R,C&&l.addInstruction(C),m[f.mintA.address]=R}else{let R=new U(f.mintA.address);T=this.scope.account.getAssociatedTokenAccount(R,new U(f.mintA.programId)),l.addInstruction({instructions:[Qo(this.scope.ownerPubKey,T,this.scope.ownerPubKey,R,new U(f.mintA.programId))]}),m[f.mintA.address]=T}if(!w)if(I){let{account:R,instructionParams:C}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:f.mintB.programId,mint:new U(f.mintB.address),notUseTokenAccount:!0,owner:this.scope.ownerPubKey,createInfo:{payer:this.scope.ownerPubKey,amount:0},skipCloseAccount:!c,associatedOnly:!1,checkCreateATAOwner:!1});w=R,C&&l.addInstruction(C),m[f.mintB.address]=R}else{let R=new U(f.mintB.address);w=this.scope.account.getAssociatedTokenAccount(R,new U(f.mintB.programId)),l.addInstruction({instructions:[Qo(this.scope.ownerPubKey,w,this.scope.ownerPubKey,R,new U(f.mintB.programId))]}),m[f.mintB.address]=w}(!T||!w)&&this.logAndCreateError("cannot found target token accounts",{tokenAccountA:T,tokenAccountB:w});let K=(p=d.poolKeys)!=null?p:await this.getCpmmPoolKeys(f.id),{publicKey:x}=j(u,b,Ct),{publicKey:S}=ji(n,b),{publicKey:B}=j(o,new U(f.lpMint.address),Ct);l.addInstruction({instructions:[su({programId:n,nftOwner:this.scope.ownerPubKey,auth:o,nftMint:b,nftAccount:x,lockPda:S,poolId:new U(f.id),mintLp:new U(K.mintLp.address),userVaultA:T,userVaultB:w,poolVaultA:new U(K.vault.A),poolVaultB:new U(K.vault.B),mintA:g,mintB:P,lockLpVault:B,lpFeeAmount:y,cpmmProgram:r==null?void 0:r.programId,cpmmAuthProgram:r==null?void 0:r.authProgram})],instructionTypes:[G.CpmmCollectLockFee]})}return s===0?l.sizeCheckBuildV0({computeBudgetConfig:i}):l.sizeCheckBuild({computeBudgetConfig:i})}async createPoolWithPermission(y){var b=y,{poolId:e,programId:t,poolFeeAccount:n,startTime:o,ownerInfo:r,associatedOnly:i=!1,checkCreateATAOwner:s=!1,txVersion:c,feeConfig:u,computeBudgetConfig:l,txTipConfig:m,feePayer:p,feeOn:d}=b,f=_e(b,["poolId","programId","poolFeeAccount","startTime","ownerInfo","associatedOnly","checkCreateATAOwner","txVersion","feeConfig","computeBudgetConfig","txTipConfig","feePayer","feeOn"]);var X,Q,ee;console.log("***this method only available for wallet with permissions***");let g=r.feePayer||((X=this.scope.owner)==null?void 0:X.publicKey),P=new Xe(new U(f.mintA.address).toBuffer()).lte(new Xe(new U(f.mintB.address).toBuffer())),[h,I]=P?[f.mintA,f.mintB]:[f.mintB,f.mintA],[T,w]=P?[f.mintAAmount,f.mintBAmount]:[f.mintBAmount,f.mintAAmount],K=r.useSOLBalance&&h.address===Yo.toBase58(),x=r.useSOLBalance&&I.address===Yo.toBase58(),[S,B]=[new U(h.address),new U(I.address)],R=this.createTxBuilder(p),{account:C,instructionParams:v}=await this.scope.account.getOrCreateTokenAccount({mint:S,tokenProgram:h.programId,owner:this.scope.ownerPubKey,createInfo:K?{payer:g,amount:T}:void 0,notUseTokenAccount:K,skipCloseAccount:!K,associatedOnly:K?!1:i,checkCreateATAOwner:s});R.addInstruction(v||{});let{account:L,instructionParams:N}=await this.scope.account.getOrCreateTokenAccount({mint:new U(I.address),tokenProgram:I.programId,owner:this.scope.ownerPubKey,createInfo:x?{payer:g,amount:w}:void 0,notUseTokenAccount:x,skipCloseAccount:!x,associatedOnly:x?!1:i,checkCreateATAOwner:s});if(R.addInstruction(N||{}),C===void 0||L===void 0)throw Error("you don't has some token account");let E=ou({poolId:e,programId:t,configId:new U(u.id),mintA:S,mintB:B});return R.addInstruction({instructions:[Zl(t,this.scope.ownerPubKey,this.scope.ownerPubKey,new U(u.id),E.authority,E.poolId,S,B,E.lpMint,C,L,j(this.scope.ownerPubKey,E.lpMint).publicKey,E.vaultA,E.vaultB,n,new U((Q=h.programId)!=null?Q:Ct),new U((ee=I.programId)!=null?ee:Ct),E.observationId,zl(t,this.scope.ownerPubKey).publicKey,T,w,o,d)],instructionTypes:[G.CpmmCreatePool]}),R.addCustomComputeBudget(l),R.addTipInstruction(m),R.versionBuild({txVersion:c,extInfo:{address:q(M({},E),{mintA:h,mintB:I,programId:t,poolFeeAccount:n,feeConfig:u})}})}async collectCreatorFees({poolInfo:e,poolKeys:t,programId:n=Wn,txVersion:o,computeBudgetConfig:r,txTipConfig:i,feePayer:s}){let c=s||this.scope.ownerPubKey,u=this.createTxBuilder(c),l=t!=null?t:await this.getCpmmPoolKeys(e.id),[m,p,d,f]=[new U(e.mintA.address),new U(e.mintB.address),new U(e.mintA.programId),new U(e.mintB.programId)],y=this.scope.account.getAssociatedTokenAccount(m,d),b=this.scope.account.getAssociatedTokenAccount(p,f);return u.addInstruction({instructions:[Qo(this.scope.ownerPubKey,y,this.scope.ownerPubKey,m,new U(e.mintA.programId)),Qo(this.scope.ownerPubKey,b,this.scope.ownerPubKey,p,new U(e.mintB.programId))]}),u.addInstruction({instructions:[au(n,this.scope.ownerPubKey,new U(l.authority),new U(l.id),new U(l.config.id),new U(l.vault.A),new U(l.vault.B),m,p,y,b,d,f)],instructionTypes:[]}),u.addCustomComputeBudget(r),u.addTipInstruction(i),u.versionBuild({txVersion:o})}async collectMultiCreatorFees({poolInfoList:e,programId:t=Wn,txVersion:n,computeBudgetConfig:o,feePayer:r}){let i=r||this.scope.ownerPubKey,s=this.createTxBuilder(i),c={},u=await this.scope.api.fetchPoolKeysById({idList:e.map(l=>l.id)});for(let l of e){let m=u.find(P=>P.id===l.id)||await this.getCpmmPoolKeys(l.id),[p,d,f,y]=[new U(l.mintA.address),new U(l.mintB.address),new U(l.mintA.programId),new U(l.mintB.programId)],b=c[l.mintA.address]||this.scope.account.getAssociatedTokenAccount(p,f),g=c[l.mintB.address]||this.scope.account.getAssociatedTokenAccount(d,y);c[l.mintA.address]||s.addInstruction({instructions:[Qo(this.scope.ownerPubKey,b,this.scope.ownerPubKey,p,f)]}),c[l.mintB.address]||s.addInstruction({instructions:[Qo(this.scope.ownerPubKey,g,this.scope.ownerPubKey,d,y)]}),c[l.mintA.address]=b,c[l.mintB.address]=g,s.addInstruction({instructions:[au(t,this.scope.ownerPubKey,new U(m.authority),new U(m.id),new U(m.config.id),new U(m.vault.A),new U(m.vault.B),p,d,b,g,f,y)],instructionTypes:[]})}return n===0?s.sizeCheckBuildV0({computeBudgetConfig:o}):s.sizeCheckBuild({computeBudgetConfig:o})}computeSwapAmount({pool:e,amountIn:t,outputMint:n,slippage:o}){let r=n.toString()===e.mintB.address,i=e.feeOn===0||e.feeOn===2,s=r?Qi.swapBaseInput(t,r?e.baseReserve:e.quoteReserve,r?e.quoteReserve:e.baseReserve,e.configInfo.tradeFeeRate,e.configInfo.creatorFeeRate,e.configInfo.protocolFeeRate,e.configInfo.fundFeeRate,i):Qi.swapBaseOutput(t,r?e.baseReserve:e.quoteReserve,r?e.quoteReserve:e.baseReserve,e.configInfo.tradeFeeRate,e.configInfo.creatorFeeRate,e.configInfo.protocolFeeRate,e.configInfo.fundFeeRate,i),c=new Ht(s.outputAmount.toString()).div(s.inputAmount.toString()),u=s.outputAmount.mul(new Xe((1-o)*1e4)).div(new Xe(1e4));return{allTrade:s.inputAmount.eq(t),amountIn:t,amountOut:s.outputAmount,minAmountOut:u,executionPrice:c,fee:s.tradeFee,priceImpact:e.poolPrice.sub(c).div(e.poolPrice)}}computePairAmount({poolInfo:e,baseReserve:t,quoteReserve:n,amount:o,slippage:r,epochInfo:i,baseIn:s}){var I,T,w,K,x,S,B,R,C;let c=1-Number(r.toSignificant())/100,u=new Xe(new Ht(o).mul(10**e[s?"mintA":"mintB"].decimals).mul(c).toFixed(0)),l=xe(u,e[s?"mintA":"mintB"].extensions.feeConfig,i,!1),m=u.sub((I=l.fee)!=null?I:new Xe(0)),p=new Xe(new Ht(e.lpAmount).mul(10**e.lpMint.decimals).toFixed(0,Ht.ROUND_DOWN));this.logDebug("baseReserve:",t.toString(),"quoteReserve:",n.toString()),this.logDebug("tokenIn:",s?e.mintA.symbol:e.mintB.symbol,"amountIn:",u.toString(),"amountInFee:",(w=(T=l.fee)==null?void 0:T.toString())!=null?w:0,"anotherToken:",s?e.mintB.symbol:e.mintA.symbol,"slippage:",`${r.toSignificant()}%`);let d=s?"base":"quote";this.logDebug("input side:",d);let f=m.mul(p).div(d==="base"?t:n),y={amount:tt,fee:void 0,expirationTime:void 0};if(!m.isZero()){let v=my(f,t,n,p);this.logDebug("lpAmountData:",{amountA:v.amountA.toString(),amountB:v.amountB.toString()}),y=xe(v[s?"amountB":"amountA"],e[s?"mintB":"mintA"].extensions.feeConfig,i,!0)}let b=new Qe(new Xe(1)).add(r),g=new Qe(new Xe(1)).sub(r),P=xe(b.mul(y.amount.sub((K=y.fee)!=null?K:new Xe(0))).quotient,e[s?"mintB":"mintA"].extensions.feeConfig,i,!0),h=xe(g.mul(y.amount.sub((x=y.fee)!=null?x:new Xe(0))).quotient,e[s?"mintB":"mintA"].extensions.feeConfig,i,!0);return this.logDebug("anotherAmount:",y.amount.toString(),"anotherAmountFee:",(B=(S=y.fee)==null?void 0:S.toString())!=null?B:0,"maxAnotherAmount:",P.amount.toString(),"maxAnotherAmountFee:",(C=(R=P.fee)==null?void 0:R.toString())!=null?C:0),{inputAmountFee:l,anotherAmount:y,maxAnotherAmount:P,minAnotherAmount:h,liquidity:f}}};function my(a,e,t,n){let o=a.mul(e).div(n);!o.isZero()&&!a.mul(e).mod(n).isZero()&&(o=o.add(new Xe(1)));let r=a.mul(t).div(n);return!r.isZero()&&!a.mul(t).mod(n).isZero()&&(r=r.add(new Xe(1))),{amountA:o,amountB:r}}import{PublicKey as wo}from"@solana/web3.js";import{createTransferInstruction as sm,TOKEN_PROGRAM_ID as Ze,TOKEN_2022_PROGRAM_ID as ss}from"@solana/spl-token";import as from"bn.js";import tr from"decimal.js";var tm={[Br.toBase58()]:3},nm={3:Br};var uu=F([Be(5),Be(8),O("ownAddress"),A("vaultSignerNonce"),O("baseMint"),O("quoteMint"),O("baseVault"),A("baseDepositsTotal"),A("baseFeesAccrued"),O("quoteVault"),A("quoteDepositsTotal"),A("quoteFeesAccrued"),A("quoteDustThreshold"),O("requestQueue"),O("eventQueue"),O("bids"),O("asks"),A("baseLotSize"),A("quoteLotSize"),A("feeRateBps"),A("referrerRebatesAccrued"),Be(7)]),om={3:uu};import{PublicKey as im}from"@solana/web3.js";var is=be("Serum"),rs=class{static getProgramId(e){let t=nm[e];return t||is.logWithError("invalid version","version",e),t}static getVersion(e){let t=e.toBase58(),n=tm[t];return n||is.logWithError("invalid program id","programId",t),n}static getStateLayout(e){let t=om[e];return t||is.logWithError(!!t,"invalid version","version",e),t}static getLayouts(e){return{state:this.getStateLayout(e)}}static getAssociatedAuthority({programId:e,marketId:t}){let n=[t.toBuffer()],o=0,r;for(;o<100;){try{let i=n.concat(Buffer.from([o]),Buffer.alloc(7));r=im.createProgramAddressSync(i,e)}catch(i){if(i instanceof TypeError)throw i;o++;continue}return{publicKey:r,nonce:o}}return is.logWithError("unable to find a viable program address nonce","params",{programId:e,marketId:t}),{publicKey:im.default,nonce:o}}};import{PublicKey as V,SystemProgram as Ji,TransactionInstruction as er}from"@solana/web3.js";import fn from"bn.js";import{ASSOCIATED_TOKEN_PROGRAM_ID as cu,TOKEN_2022_PROGRAM_ID as lu,TOKEN_PROGRAM_ID as jn}from"@solana/spl-token";function NC(a,e,t,n,o,r,i,s,c,u,l,m){let p=F([_("instruction"),A("amountIn"),A("amountOut")]),d=[{pubkey:Ji.programId,isSigner:!1,isWritable:!1},{pubkey:jn,isSigner:!1,isWritable:!1},{pubkey:new V(t.programId),isSigner:!1,isWritable:!1},{pubkey:new V(t.id),isSigner:!1,isWritable:!0},{pubkey:new V(n.id),isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!0,isWritable:!1}];if(e.type==="Concentrated"){let y=Ee(t);d.push({pubkey:y.config.id,isSigner:!1,isWritable:!1},{pubkey:y.id,isSigner:!1,isWritable:!0},{pubkey:y.mintA.address.equals(c)?y.vault.A:y.vault.B,isSigner:!1,isWritable:!0},{pubkey:y.mintA.address.equals(c)?y.vault.B:y.vault.A,isSigner:!1,isWritable:!0},{pubkey:y.id,isSigner:!1,isWritable:!0},...m.map(b=>({pubkey:b,isSigner:!1,isWritable:!0})))}else if(e.pooltype.includes("StablePool")){let y=Ee(t);d.push({pubkey:y.authority,isSigner:!1,isWritable:!1},{pubkey:y.marketProgramId,isSigner:!1,isWritable:!1},{pubkey:y.id,isSigner:!1,isWritable:!0},{pubkey:new V("CDSr3ssLcRB6XYPJwAfFt18MZvEZp4LjHcvzBVZ45duo"),isSigner:!1,isWritable:!1},{pubkey:y.openOrders,isSigner:!1,isWritable:!0},{pubkey:y.vault.A,isSigner:!1,isWritable:!0},{pubkey:y.vault.B,isSigner:!1,isWritable:!0},{pubkey:y.marketId,isSigner:!1,isWritable:!0},{pubkey:y.marketBids,isSigner:!1,isWritable:!0},{pubkey:y.marketAsks,isSigner:!1,isWritable:!0},{pubkey:y.marketEventQueue,isSigner:!1,isWritable:!0},{pubkey:y.id,isSigner:!1,isWritable:!0},{pubkey:y.id,isSigner:!1,isWritable:!0})}else{let y=Ee(t);d.push({pubkey:y.authority,isSigner:!1,isWritable:!1},{pubkey:y.marketProgramId,isSigner:!1,isWritable:!1},{pubkey:y.marketAuthority,isSigner:!1,isWritable:!1},{pubkey:y.openOrders,isSigner:!1,isWritable:!0},{pubkey:y.vault.A,isSigner:!1,isWritable:!0},{pubkey:y.vault.B,isSigner:!1,isWritable:!0},{pubkey:y.marketId,isSigner:!1,isWritable:!0},{pubkey:y.marketBids,isSigner:!1,isWritable:!0},{pubkey:y.marketAsks,isSigner:!1,isWritable:!0},{pubkey:y.marketEventQueue,isSigner:!1,isWritable:!0},...y.marketProgramId.toString()==="srmqPvymJeFKQ4zGQed1GFppgkRHL9kaELCbyksJtPX"?[{pubkey:y.marketBaseVault,isSigner:!1,isWritable:!0},{pubkey:y.marketQuoteVault,isSigner:!1,isWritable:!0}]:[{pubkey:y.id,isSigner:!1,isWritable:!0},{pubkey:y.id,isSigner:!1,isWritable:!0}])}let f=Buffer.alloc(p.span);return p.encode({instruction:4,amountIn:u,amountOut:l},f),new er({keys:d,programId:a,data:f})}function MC(a,e,t,n,o,r,i,s,c,u){let l=F([_("instruction")]),m=[{pubkey:Ji.programId,isSigner:!1,isWritable:!1},{pubkey:jn,isSigner:!1,isWritable:!1},{pubkey:new V(String(n.programId)),isSigner:!1,isWritable:!1},{pubkey:new V(String(n.id)),isSigner:!1,isWritable:!0},{pubkey:new V(String(t.id)),isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!0,isWritable:!1}];if(e.type==="Concentrated"){let d=Ee(n);m.push({pubkey:d.config.id,isSigner:!1,isWritable:!1},{pubkey:d.id,isSigner:!1,isWritable:!0},{pubkey:d.mintA.address.equals(c)?d.vault.A:d.vault.B,isSigner:!1,isWritable:!0},{pubkey:d.mintA.address.equals(c)?d.vault.B:d.vault.A,isSigner:!1,isWritable:!0},{pubkey:d.id,isSigner:!1,isWritable:!0},...u.map(f=>({pubkey:f,isSigner:!1,isWritable:!0})))}else if(e.pooltype.includes("StablePool")){let d=Ee(n);m.push({pubkey:d.authority,isSigner:!1,isWritable:!1},{pubkey:d.marketProgramId,isSigner:!1,isWritable:!1},{pubkey:d.id,isSigner:!1,isWritable:!0},{pubkey:new V("CDSr3ssLcRB6XYPJwAfFt18MZvEZp4LjHcvzBVZ45duo"),isSigner:!1,isWritable:!1},{pubkey:d.openOrders,isSigner:!1,isWritable:!0},{pubkey:d.vault.A,isSigner:!1,isWritable:!0},{pubkey:d.vault.B,isSigner:!1,isWritable:!0},{pubkey:d.marketId,isSigner:!1,isWritable:!0},{pubkey:d.marketBids,isSigner:!1,isWritable:!0},{pubkey:d.marketAsks,isSigner:!1,isWritable:!0},{pubkey:d.marketEventQueue,isSigner:!1,isWritable:!0},{pubkey:d.id,isSigner:!1,isWritable:!0},{pubkey:d.id,isSigner:!1,isWritable:!0})}else{let d=Ee(n);m.push({pubkey:d.authority,isSigner:!1,isWritable:!1},{pubkey:d.marketProgramId,isSigner:!1,isWritable:!1},{pubkey:d.marketAuthority,isSigner:!1,isWritable:!1},{pubkey:d.openOrders,isSigner:!1,isWritable:!0},{pubkey:d.vault.A,isSigner:!1,isWritable:!0},{pubkey:d.vault.B,isSigner:!1,isWritable:!0},{pubkey:d.marketId,isSigner:!1,isWritable:!0},{pubkey:d.marketBids,isSigner:!1,isWritable:!0},{pubkey:d.marketAsks,isSigner:!1,isWritable:!0},{pubkey:d.marketEventQueue,isSigner:!1,isWritable:!0},...d.marketProgramId.toString()==="srmqPvymJeFKQ4zGQed1GFppgkRHL9kaELCbyksJtPX"?[{pubkey:d.marketBaseVault,isSigner:!1,isWritable:!0},{pubkey:d.marketQuoteVault,isSigner:!1,isWritable:!0}]:[{pubkey:d.id,isSigner:!1,isWritable:!0},{pubkey:d.id,isSigner:!1,isWritable:!0}])}let p=Buffer.alloc(l.span);return l.encode({instruction:5},p),new er({keys:m,programId:a,data:p})}function dy(a,e,t,n,o,r,i,s,c,u,l,m,p,d,f){var w;let y=[],b=[k({pubkey:jn,isWritable:!1}),k({pubkey:lu,isWritable:!1}),k({pubkey:cu,isWritable:!1}),k({pubkey:Ji.programId,isWritable:!1}),k({pubkey:e,isSigner:!0})];b.push(k({pubkey:t})),b.push(k({pubkey:o}));let g=[c,u],P=[l,m],h=[r,i,s];for(let K=0;K<g.length;K++){let x=g[K],S=h[K]===x.mintA.address;if(b.push(k({pubkey:new V(x.programId),isWritable:!1})),K===g.length-1?b.push(k({pubkey:o})):b.push(k({pubkey:n})),b.push(k({pubkey:new V(h[K])})),b.push(k({pubkey:new V(h[K+1])})),x.version===6){let B=P[K];b.push(k({pubkey:new V(B.config.id)})),b.push(k({pubkey:new V(B.id)})),b.push(k({pubkey:new V(S?B.vault.A:B.vault.B)})),b.push(k({pubkey:new V(S?B.vault.B:B.vault.A)})),b.push(k({pubkey:new V(x.observationId)})),b.push(k({pubkey:mn})),b.push(k({pubkey:$e(new V(x.programId),new V(x.id)).publicKey})),y.push(mu(x.sqrtPriceX64.toString(),S));for(let R of(w=f[K])!=null?w:[])b.push(k({pubkey:new V(R)}))}else if(x.version===5){let B=P[K];b.push(k({pubkey:new V(B.id)})),b.push(k({pubkey:new V(B.authority),isWritable:!1})),b.push(k({pubkey:new V(B.marketProgramId)})),b.push(k({pubkey:new V(B.marketAuthority)})),b.push(k({pubkey:xr,isWritable:!1})),b.push(k({pubkey:new V(B.openOrders)})),b.push(k({pubkey:new V(B.vault.A)})),b.push(k({pubkey:new V(B.vault.B)})),b.push(k({pubkey:new V(B.id)})),b.push(k({pubkey:new V(B.id)})),b.push(k({pubkey:new V(B.id)})),b.push(k({pubkey:new V(B.id)})),b.push(k({pubkey:new V(B.id)})),b.push(k({pubkey:new V(B.id)})),b.push(k({pubkey:new V(B.marketId)})),b.push(k({pubkey:new V(B.marketBids)})),b.push(k({pubkey:new V(B.marketAsks)})),b.push(k({pubkey:new V(B.marketEventQueue)})),b.push(k({pubkey:new V(B.marketBaseVault)})),b.push(k({pubkey:new V(B.marketQuoteVault)}))}else if(x.version===4){let B=P[K],R=x.status!==1;b.push(k({pubkey:new V(B.id)})),b.push(k({pubkey:new V(B.authority),isWritable:!1})),b.push(k({pubkey:new V(R?B.id:B.marketProgramId)})),b.push(k({pubkey:new V(R?B.id:B.marketAuthority)})),b.push(k({pubkey:new V(R?B.id:B.openOrders)})),b.push(k({pubkey:new V(B.vault.A)})),b.push(k({pubkey:new V(B.vault.B)})),b.push(k({pubkey:new V(R?B.id:B.marketId)})),b.push(k({pubkey:new V(R?B.id:B.marketBids)})),b.push(k({pubkey:new V(R?B.id:B.marketAsks)})),b.push(k({pubkey:new V(R?B.id:B.marketEventQueue)})),b.push(k({pubkey:new V(R?B.id:B.marketBaseVault)})),b.push(k({pubkey:new V(R?B.id:B.marketQuoteVault)}))}else if(x.version===7){let B=P[K];b.push(k({pubkey:new V(B.authority)})),b.push(k({pubkey:new V(B.config.id)})),b.push(k({pubkey:new V(B.id)})),b.push(k({pubkey:new V(S?B.vault.A:B.vault.B)})),b.push(k({pubkey:new V(S?B.vault.B:B.vault.A)})),b.push(k({pubkey:new V(x.observationId)}))}else throw Error("pool type error")}let I=F([_("insId"),A("amountIn"),A("amountOut"),Y(ne(),y.length,"clmmPriceLimit")]),T=Buffer.alloc(I.span);return I.encode({insId:0,amountIn:p,amountOut:d,clmmPriceLimit:y},T),new er({keys:b,programId:a,data:T})}function mu(a,e){if(a)if(e){let t=new fn(a).div(new fn(25));return t.gt(Wr)?t:Wr}else{let t=new fn(a).mul(new fn(25));return t.lt(Dr)?t:Dr}else return e?Wr:Dr}function rm({routeProgram:a,ownerInfo:e,inputMint:t,swapInfo:n}){var o,r,i,s,c,u,l;if(n.routeType==="amm")if(n.poolInfo[0].version===6){let m=n.poolKey[0],p=Ee(m),d=t.equals(p.mintA.address)?Yt.add(Wt):Qt.sub(Wt);return Re.makeSwapBaseInInstructions({poolInfo:m,poolKeys:m,observationId:n.poolInfo[0].observationId,ownerInfo:{wallet:e.wallet,tokenAccountA:p.mintA.address.equals(t)?e.sourceToken:e.destinationToken,tokenAccountB:p.mintA.address.equals(t)?e.destinationToken:e.sourceToken},inputMint:t,amountIn:n.amountIn.amount.raw,amountOutMin:n.minAmountOut.amount.raw.sub((r=(o=n.minAmountOut.fee)==null?void 0:o.raw)!=null?r:new fn(0)),sqrtPriceLimitX64:d,remainingAccounts:(i=n.remainingAccounts[0])!=null?i:[]})}else if(n.poolInfo[0].version===7){let m=n.poolInfo[0],p=t.toString()===n.poolInfo[0].mintA.address;return{signers:[],instructions:[ns(m.programId,e.wallet,m.authority,m.configId,m.id,e.sourceToken,e.destinationToken,p?m.vaultA:m.vaultB,p?m.vaultB:m.vaultA,p?m.mintProgramA:m.mintProgramB,p?m.mintProgramB:m.mintProgramA,new V(m[p?"mintA":"mintB"].address),new V(m[p?"mintB":"mintA"].address),m.observationId,n.amountIn.amount.raw,n.minAmountOut.amount.raw)],lookupTableAddress:[],instructionTypes:[p?G.CpmmSwapBaseIn:G.CpmmSwapBaseOut],address:{}}}else{let m=n.poolKey[0];return{signers:[],instructions:[Qr({poolKeys:m,version:n.poolInfo[0].pooltype.includes("StablePool")?5:4,userKeys:{tokenAccountIn:e.sourceToken,tokenAccountOut:e.destinationToken,owner:e.wallet},amountIn:n.amountIn.amount.raw,amountOut:n.minAmountOut.amount.raw.sub((c=(s=n.minAmountOut.fee)==null?void 0:s.raw)!=null?c:new fn(0)),fixedSide:"in"})],lookupTableAddress:m.lookupTableAccount?[m.lookupTableAccount]:[],instructionTypes:[n.poolInfo[0].pooltype.includes("StablePool")?G.AmmV5SwapBaseIn:G.AmmV4SwapBaseIn],address:{}}}else if(n.routeType==="route"){let m=n.poolInfo[0],p=n.poolInfo[1],d=n.poolKey[0],f=n.poolKey[1];if(e.routeToken===void 0)throw Error("owner route token account check error");return{signers:[],instructions:[dy(a,e.wallet,e.sourceToken,e.routeToken,e.destinationToken,t.toString(),n.middleToken.mint.toString(),n.outputMint.toString(),m,p,d,f,n.amountIn.amount.raw,n.minAmountOut.amount.raw.sub((l=(u=n.minAmountOut.fee)==null?void 0:u.raw)!=null?l:new fn(0)),n.remainingAccounts)],instructionTypes:[G.RouteSwap],lookupTableAddress:[d.lookupTableAccount,f.lookupTableAccount].filter(y=>y!==void 0),address:{}}}else throw Error("route type error")}function vC({programId:a,wallet:e,amount:t,inputAccount:n,outputAccount:o,routeInfo:r,poolKeys:i}){var p;if(r.success===!1)throw Error("route info error");let s=[],c=[k({pubkey:jn,isWritable:!1}),k({pubkey:lu,isWritable:!1}),k({pubkey:cu,isWritable:!1}),k({pubkey:Ji.programId,isWritable:!1}),k({pubkey:e,isSigner:!0})],u={[r.data.inputMint]:n,[r.data.outputMint]:o};c.push(k({pubkey:u[r.data.inputMint]})),c.push(k({pubkey:u[r.data.outputMint]}));for(let d=0;d<i.length;d++){let f=r.data.routePlan[d],y=i[d],b=f.inputMint===y.mintA.address;if(c.push(k({pubkey:new V(y.programId),isWritable:!1})),d===i.length-1)c.push(k({pubkey:u[f.outputMint]}));else{let g=f.outputMint;if(u[g]===void 0){let P=j(e,new V(g),y.programId===ht.CLMM_PROGRAM_ID.toBase58()||y.programId===ht.CREATE_CPMM_POOL_PROGRAM.toBase58()?new V(b?y.mintB.programId:y.mintA.programId):jn).publicKey;u[g]=P}c.push(k({pubkey:u[g]}))}if(c.push(k({pubkey:new V(f.inputMint)})),c.push(k({pubkey:new V(f.outputMint)})),y.programId===ht.CLMM_PROGRAM_ID.toBase58()){let g=y;c.push(k({pubkey:new V(g.config.id)})),c.push(k({pubkey:new V(g.id)})),c.push(k({pubkey:new V(b?g.vault.A:g.vault.B)})),c.push(k({pubkey:new V(b?g.vault.B:g.vault.A)})),c.push(k({pubkey:new V(g.observationId)})),c.push(k({pubkey:mn,isWritable:!1})),c.push(k({pubkey:new V(g.exBitmapAccount)})),s.push(mu(f.lastPoolPriceX64,b));for(let P of(p=f.remainingAccounts)!=null?p:[])c.push(k({pubkey:new V(P)}))}else if(y.programId===ht.AMM_STABLE.toBase58()){let g=y;c.push(k({pubkey:new V(g.id)})),c.push(k({pubkey:new V(g.authority),isWritable:!1})),c.push(k({pubkey:new V(g.marketProgramId),isWritable:!1})),c.push(k({pubkey:new V(g.marketAuthority),isWritable:!1})),c.push(k({pubkey:xr,isWritable:!1})),c.push(k({pubkey:new V(g.openOrders)})),c.push(k({pubkey:new V(g.vault.A)})),c.push(k({pubkey:new V(g.vault.B)})),c.push(k({pubkey:new V(g.marketId)})),c.push(k({pubkey:new V(g.marketBids)})),c.push(k({pubkey:new V(g.marketAsks)})),c.push(k({pubkey:new V(g.marketEventQueue)})),c.push(k({pubkey:new V(g.marketBaseVault)})),c.push(k({pubkey:new V(g.marketQuoteVault)}))}else if(y.programId===ht.AMM_V4.toBase58()){let g=y;c.push(k({pubkey:new V(g.id)})),c.push(k({pubkey:new V(g.authority),isWritable:!1})),c.push(k({pubkey:new V(g.id)})),c.push(k({pubkey:new V(g.id)})),c.push(k({pubkey:new V(g.id)})),c.push(k({pubkey:new V(g.vault.A)})),c.push(k({pubkey:new V(g.vault.B)})),c.push(k({pubkey:new V(g.id)})),c.push(k({pubkey:new V(g.id)})),c.push(k({pubkey:new V(g.id)})),c.push(k({pubkey:new V(g.id)})),c.push(k({pubkey:new V(g.id)})),c.push(k({pubkey:new V(g.id)}))}else if(y.programId===ht.CREATE_CPMM_POOL_PROGRAM.toBase58()){let g=y;c.push(k({pubkey:new V(g.authority)})),c.push(k({pubkey:new V(g.config.id)})),c.push(k({pubkey:new V(g.id)})),c.push(k({pubkey:new V(b?g.vault.A:g.vault.B)})),c.push(k({pubkey:new V(b?g.vault.B:g.vault.A)})),c.push(k({pubkey:new V(g.observationId)}))}else throw Error("pool type error")}let l=F([_("insId"),A("amountIn"),A("amountOut"),Y(ne(),s.length,"clmmPriceLimit")]),m=Buffer.alloc(l.span);return l.encode({insId:0,amountIn:t,amountOut:new fn(r.data.otherAmountThreshold),clmmPriceLimit:s},m),new er({keys:c,programId:a,data:m})}function FC({programId:a,wallet:e,inputAccount:t,outputAccount:n,routeInfo:o,poolKeys:r}){var m;if(o.success===!1)throw Error("route info error");let i=[],s=[k({pubkey:jn,isWritable:!1}),k({pubkey:lu,isWritable:!1}),k({pubkey:cu,isWritable:!1}),k({pubkey:Ji.programId,isWritable:!1}),k({pubkey:e,isSigner:!0})],c={[o.data.inputMint]:t,[o.data.outputMint]:n};for(let p=r.length-1;p>=0;p--){let d=o.data.routePlan[p],f=r[p],y=d.inputMint===f.mintA.address;if(s.push(k({pubkey:new V(f.programId)})),p===0)s.push(k({pubkey:c[d.inputMint]}));else{let b=d.inputMint;if(c[b]===void 0){let g=j(e,new V(b),f.programId===ht.CLMM_PROGRAM_ID.toBase58()||f.programId===ht.CREATE_CPMM_POOL_PROGRAM.toBase58()?new V(y?f.mintA.programId:f.mintB.programId):jn).publicKey;c[b]=g}s.push(k({pubkey:c[b]}))}if(p===r.length-1)s.push(k({pubkey:c[d.outputMint]}));else{let b=d.outputMint;if(c[b]===void 0){let g=j(e,new V(b),f.programId===ht.CLMM_PROGRAM_ID.toBase58()||f.programId===ht.CREATE_CPMM_POOL_PROGRAM.toBase58()?new V(y?f.mintB.programId:f.mintA.programId):jn).publicKey;c[b]=g}s.push(k({pubkey:c[b]}))}if(s.push(k({pubkey:new V(d.inputMint)})),s.push(k({pubkey:new V(d.outputMint)})),f.programId===ht.CLMM_PROGRAM_ID.toBase58()){let b=f;s.push(k({pubkey:new V(b.config.id)})),s.push(k({pubkey:new V(b.id)})),s.push(k({pubkey:new V(y?b.vault.A:b.vault.B)})),s.push(k({pubkey:new V(y?b.vault.B:b.vault.A)})),s.push(k({pubkey:new V(b.observationId)})),s.push(k({pubkey:mn,isWritable:!1})),s.push(k({pubkey:new V(b.exBitmapAccount)})),i.push(mu(d.lastPoolPriceX64,y));for(let g of(m=d.remainingAccounts)!=null?m:[])s.push(k({pubkey:new V(g)}))}else if(f.programId===ht.AMM_STABLE.toBase58()){let b=f;s.push(k({pubkey:new V(b.id)})),s.push(k({pubkey:new V(b.authority),isWritable:!1})),s.push(k({pubkey:new V(b.marketProgramId),isWritable:!1})),s.push(k({pubkey:new V(b.marketAuthority),isWritable:!1})),s.push(k({pubkey:xr,isWritable:!1})),s.push(k({pubkey:new V(b.openOrders)})),s.push(k({pubkey:new V(b.vault.A)})),s.push(k({pubkey:new V(b.vault.B)})),s.push(k({pubkey:new V(b.marketId)})),s.push(k({pubkey:new V(b.marketBids)})),s.push(k({pubkey:new V(b.marketAsks)})),s.push(k({pubkey:new V(b.marketEventQueue)})),s.push(k({pubkey:new V(b.marketBaseVault)})),s.push(k({pubkey:new V(b.marketQuoteVault)}))}else if(f.programId===ht.AMM_V4.toBase58()){let b=f;s.push(k({pubkey:new V(b.id)})),s.push(k({pubkey:new V(b.authority),isWritable:!1})),s.push(k({pubkey:new V(b.id)})),s.push(k({pubkey:new V(b.id)})),s.push(k({pubkey:new V(b.id)})),s.push(k({pubkey:new V(b.vault.A)})),s.push(k({pubkey:new V(b.vault.B)})),s.push(k({pubkey:new V(b.id)})),s.push(k({pubkey:new V(b.id)})),s.push(k({pubkey:new V(b.id)})),s.push(k({pubkey:new V(b.id)})),s.push(k({pubkey:new V(b.id)})),s.push(k({pubkey:new V(b.id)}))}else if(f.programId===ht.CREATE_CPMM_POOL_PROGRAM.toBase58()){let b=f;s.push(k({pubkey:new V(b.authority)})),s.push(k({pubkey:new V(b.config.id)})),s.push(k({pubkey:new V(b.id)})),s.push(k({pubkey:new V(y?b.vault.A:b.vault.B)})),s.push(k({pubkey:new V(y?b.vault.B:b.vault.A)})),s.push(k({pubkey:new V(b.observationId)}))}else throw Error("pool type error")}let u=F([_("insId"),A("amountIn"),A("amountOut"),Y(ne(),i.length,"clmmPriceLimit")]),l=Buffer.alloc(u.span);return u.encode({insId:1,amountIn:new fn(o.data.otherAmountThreshold),amountOut:new fn(o.data.outputAmount),clmmPriceLimit:i},l),new er({keys:s,programId:a,data:l})}var Nn=new as(0),nr=class extends We{constructor(e){super(e)}async getWSolAccounts(){this.scope.checkOwner(),await this.scope.account.fetchWalletTokenAccounts();let e=this.scope.account.tokenAccounts.filter(t=>t.mint.equals($));return e.sort((t,n)=>t.isAssociated?1:n.isAssociated||t.amount.lt(n.amount)?-1:1),e}async unWrapWSol(e){let{amount:t,tokenProgram:n,txVersion:o=1,feePayer:r}=e,i=await this.getWSolAccounts(),s=this.createTxBuilder(r);s.addCustomComputeBudget(e.computeBudgetConfig);let c=J(t);for(let u=0;u<i.length;u++)c.gte(i[u].amount)?(s.addInstruction({instructions:[In({tokenAccount:i[u].publicKey,payer:this.scope.ownerPubKey,owner:this.scope.ownerPubKey,programId:n})]}),c.sub(i[u].amount)):s.addInstruction({instructions:[In({tokenAccount:i[u].publicKey,payer:this.scope.ownerPubKey,owner:this.scope.ownerPubKey,programId:n})]});return s.versionBuild({txVersion:o})}async wrapWSol(e,t,n,o){let r=this.createTxBuilder(o),i=await Gn({connection:this.scope.connection,owner:this.scope.ownerPubKey,payer:this.scope.ownerPubKey,amount:e,skipCloseAccount:!0});return r.addInstruction(i),r.versionBuild({txVersion:n!=null?n:1})}async swap({swapInfo:e,swapPoolKeys:t,ownerInfo:n,computeBudgetConfig:o,routeProgram:r,txVersion:i,feePayer:s}){let c=this.createTxBuilder(s),u=e.amountIn,l=e.amountOut,m=u.amount.token.mint.equals($),p=l.amount.token.mint.equals($),d=u.amount.token.mint,f=l.amount.token.mint,{account:y,instructionParams:b}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:u.amount.token.isToken2022?ss:Ze,mint:d,notUseTokenAccount:m,owner:this.scope.ownerPubKey,skipCloseAccount:!m,createInfo:m?{payer:this.scope.ownerPubKey,amount:u.amount.raw}:void 0,associatedOnly:m?!1:n.associatedOnly,checkCreateATAOwner:n.checkCreateATAOwner});if(b&&c.addInstruction(b),y===void 0)throw Error("input account check error");let g;if(e.routeType==="route"&&!p)g=this.scope.account.getAssociatedTokenAccount(f,l.amount.token.isToken2022?ss:Ze);else{let{account:T,instructionParams:w}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:l.amount.token.isToken2022?ss:Ze,mint:f,notUseTokenAccount:p,owner:this.scope.ownerPubKey,skipCloseAccount:!0,createInfo:{payer:this.scope.ownerPubKey,amount:0},associatedOnly:p?!1:n.associatedOnly,checkCreateATAOwner:n.checkCreateATAOwner});g=T,w&&c.addInstruction(w)}p&&c.addInstruction({endInstructions:[In({owner:this.scope.ownerPubKey,payer:this.scope.ownerPubKey,tokenAccount:g,programId:Ze})],endInstructionTypes:[G.CloseAccount]});let P;if(e.routeType==="route"){let T=e.middleToken;P=this.scope.account.getAssociatedTokenAccount(T.mint,T.isToken2022?ss:Ze)}let h=t||await this.computePoolToPoolKeys({pools:e.poolInfoList}),I=rm({routeProgram:r,inputMint:d,swapInfo:q(M({},e),{poolInfo:[...e.poolInfoList],poolKey:h,outputMint:f}),ownerInfo:{wallet:this.scope.ownerPubKey,sourceToken:y,routeToken:P,destinationToken:g}});if(e.feeConfig!==void 0){let T=this.createTxBuilder();T.addInstruction({instructions:[sm(y,e.feeConfig.feeAccount,this.scope.ownerPubKey,e.feeConfig.feeAmount.toNumber())],instructionTypes:[G.TransferAmount]}),T.addInstruction(I);let{transactions:w}=i===0?await T.sizeCheckBuildV0():await T.sizeCheckBuild();w.length<2&&c.addInstruction({instructions:[sm(y,e.feeConfig.feeAccount,this.scope.ownerPubKey,e.feeConfig.feeAmount.toNumber())],instructionTypes:[G.TransferAmount]})}return c.addInstruction(I),i===0?c.sizeCheckBuildV0({computeBudgetConfig:o,address:I.address}):c.sizeCheckBuild({computeBudgetConfig:o,address:I.address})}async fetchRoutePoolBasicInfo(e){let{amm:t=ci,clmm:n=_n,cpmm:o=Wn}=e||{},r=await this.scope.connection.getProgramAccounts(t,{dataSlice:{offset:yo.offsetOf("baseMint"),length:64}}),i=F([O("baseMint"),O("quoteMint")]),s=r.map(d=>({id:d.pubkey,version:4,mintA:i.decode(d.account.data).baseMint,mintB:i.decode(d.account.data).quoteMint})),c=F([O("mintA"),O("mintB")]),l=(await this.scope.connection.getProgramAccounts(n,{filters:[{dataSize:po.span}],dataSlice:{offset:po.offsetOf("mintA"),length:64}})).map(d=>{let f=c.decode(d.account.data);return{id:d.pubkey,version:6,mintA:f.mintA,mintB:f.mintB}}),p=(await this.scope.connection.getProgramAccounts(o,{dataSlice:{offset:os.offsetOf("mintA"),length:64}})).map(d=>{let f=c.decode(d.account.data);return{id:d.pubkey,version:7,mintA:f.mintA,mintB:f.mintB}});return{clmmPools:l,ammPools:s,cpmmPools:p}}getAllRoute({inputMint:e,outputMint:t,clmmPools:n,ammPools:o,cpmmPools:r}){e=e.toString()===wo.default.toString()?$:e,t=t.toString()===wo.default.toString()?$:t;let i={},s={},c={},u=[],l={};for(let p of n!=null?n:[]){if((p.mintA.equals(e)&&p.mintB.equals(t)||p.mintA.equals(t)&&p.mintB.equals(e))&&(u.push(p),s[p.id.toString()]=p),p.mintA.equals(e)){let d=p.mintB.toString();l[d]===void 0&&(l[d]={mintProgram:Ze,in:[],out:[],mDecimals:0}),l[d].in.push(p)}if(p.mintB.equals(e)){let d=p.mintA.toString();l[d]===void 0&&(l[d]={mintProgram:Ze,in:[],out:[],mDecimals:0}),l[d].in.push(p)}if(p.mintA.equals(t)){let d=p.mintB.toString();l[d]===void 0&&(l[d]={mintProgram:Ze,in:[],out:[],mDecimals:0}),l[d].out.push(p)}if(p.mintB.equals(t)){let d=p.mintA.toString();l[d]===void 0&&(l[d]={mintProgram:Ze,in:[],out:[],mDecimals:0}),l[d].out.push(p)}}let m=[];for(let p of o)(p.mintA.equals(e)&&p.mintB.equals(t)||p.mintA.equals(t)&&p.mintB.equals(e))&&(u.push(p),i[p.id.toBase58()]=p,m.push(p)),p.mintA.equals(e)&&(l[p.mintB.toBase58()]===void 0&&(l[p.mintB.toBase58()]={mintProgram:Ze,in:[],out:[],mDecimals:0}),l[p.mintB.toBase58()].in.push(p)),p.mintB.equals(e)&&(l[p.mintA.toBase58()]===void 0&&(l[p.mintA.toBase58()]={mintProgram:Ze,in:[],out:[],mDecimals:0}),l[p.mintA.toBase58()].in.push(p)),p.mintA.equals(t)&&(l[p.mintB.toBase58()]===void 0&&(l[p.mintB.toBase58()]={mintProgram:Ze,in:[],out:[],mDecimals:0}),l[p.mintB.toBase58()].out.push(p)),p.mintB.equals(t)&&(l[p.mintA.toBase58()]===void 0&&(l[p.mintA.toBase58()]={mintProgram:Ze,in:[],out:[],mDecimals:0}),l[p.mintA.toBase58()].out.push(p));for(let p of r)(p.mintA.equals(e)&&p.mintB.equals(t)||p.mintA.equals(t)&&p.mintB.equals(e))&&(u.push(p),c[p.id.toBase58()]=p),p.mintA.equals(e)&&(l[p.mintB.toBase58()]===void 0&&(l[p.mintB.toBase58()]={mintProgram:Ze,in:[],out:[],mDecimals:0}),l[p.mintB.toBase58()].in.push(p)),p.mintB.equals(e)&&(l[p.mintA.toBase58()]===void 0&&(l[p.mintA.toBase58()]={mintProgram:Ze,in:[],out:[],mDecimals:0}),l[p.mintA.toBase58()].in.push(p)),p.mintA.equals(t)&&(l[p.mintB.toBase58()]===void 0&&(l[p.mintB.toBase58()]={mintProgram:Ze,in:[],out:[],mDecimals:0}),l[p.mintB.toBase58()].out.push(p)),p.mintB.equals(t)&&(l[p.mintA.toBase58()]===void 0&&(l[p.mintA.toBase58()]={mintProgram:Ze,in:[],out:[],mDecimals:0}),l[p.mintA.toBase58()].out.push(p));for(let p of Object.keys(l)){if(l[p].in.length===1&&l[p].out.length===1&&l[p].in[0].id.equals(l[p].out[0].id)){delete l[p];continue}if(l[p].in.length===0||l[p].out.length===0){delete l[p];continue}let d=l[p];for(let f of d.in)for(let y of d.out)f.version===6&&s[f.id.toString()]===void 0?s[f.id.toString()]=f:f.version===7&&c[f.id.toString()]===void 0?c[f.id.toString()]=f:(f.version===4||f.version===5)&&i[f.id.toString()]===void 0&&(i[f.id.toString()]=f),y.version===6&&s[y.id.toString()]===void 0?s[y.id.toString()]=y:y.version===7&&c[y.id.toString()]===void 0?c[y.id.toString()]=y:(y.version===4||y.version===5)&&i[y.id.toString()]===void 0&&(i[y.id.toString()]=y)}return{directPath:u,addLiquidityPools:m,routePathDict:l,needSimulate:Object.values(i),needTickArray:Object.values(s),cpmmPoolList:Object.values(c)}}async fetchSwapRoutesData({routes:e,inputMint:t,outputMint:n}){let o=new Set([...e.needTickArray.map(y=>[y.mintA.toBase58(),y.mintB.toBase58()]).flat(),t.toString(),n.toString()]);console.log("fetching amm pools info, total: ",e.needSimulate.length);let r=await this.scope.liquidity.getRpcPoolInfos(e.needSimulate.map(y=>y.id)),i=$r(r),s={};Object.values(i).forEach(y=>{o.delete(y.mintA.address),s[y.mintA.address]={address:new wo(y.mintA.address),programId:Ze,mintAuthority:null,supply:BigInt(0),decimals:y.mintA.decimals,isInitialized:!0,freezeAuthority:null,tlvData:Buffer.from("0","hex"),feeConfig:void 0},o.delete(y.mintB.address),s[y.mintB.address]={address:new wo(y.mintB.address),programId:Ze,mintAuthority:null,supply:BigInt(0),decimals:y.mintB.decimals,isInitialized:!0,freezeAuthority:null,tlvData:Buffer.from("0","hex"),feeConfig:void 0}}),console.log("fetching cpmm pools info, total: ",e.cpmmPoolList.length);let c=await this.scope.cpmm.getRpcPoolInfos(e.cpmmPoolList.map(y=>y.id.toBase58()),!0);Object.values(c).forEach(y=>{let[b,g]=[y.mintA.toBase58(),y.mintB.toBase58()];y.mintProgramA.equals(Ze)?(o.delete(b),s[b]={address:y.mintA,programId:y.mintProgramA,mintAuthority:null,supply:BigInt(0),decimals:y.mintDecimalA,isInitialized:!0,freezeAuthority:null,tlvData:Buffer.from("0","hex"),feeConfig:void 0}):o.add(b),y.mintProgramB.equals(Ze)?(o.delete(g),s[g]={address:y.mintB,programId:y.mintProgramB,mintAuthority:null,supply:BigInt(0),decimals:y.mintDecimalB,isInitialized:!0,freezeAuthority:null,tlvData:Buffer.from("0","hex"),feeConfig:void 0}):o.add(g)}),console.log("fetching mints info, total: ",o.size);let u=await Co({connection:this.scope.connection,mints:Array.from(o).map(y=>new wo(y))});s=M(M({},s),u);let l=this.scope.cpmm.toComputePoolInfos({pools:c,mintInfos:s});console.log("fetching clmm pools info, total:",e.needTickArray.length);let m=await this.scope.clmm.getRpcClmmPoolInfos({poolIds:e.needTickArray.map(y=>y.id)}),{computeClmmPoolInfo:p,computePoolTickData:d}=await this.scope.clmm.getComputeClmmPoolInfos({clmmPoolsRpcInfo:m,mintInfos:s}),f=Object.keys(e.routePathDict).reduce((y,b)=>q(M({},y),{[b]:q(M({},e.routePathDict[b]),{mintProgram:s[b].programId,mDecimals:s[b].decimals,in:e.routePathDict[b].in.map(g=>i[g.id.toBase58()]||p[g.id.toBase58()]||l[g.id.toBase58()]),out:e.routePathDict[b].out.map(g=>i[g.id.toBase58()]||p[g.id.toBase58()]||l[g.id.toBase58()])})}),{});return{mintInfos:s,ammPoolsRpcInfo:r,ammSimulateCache:i,clmmPoolsRpcInfo:m,computeClmmPoolInfo:p,computePoolTickData:d,computeCpmmData:l,routePathDict:f}}getAllRouteComputeAmountOut({inputTokenAmount:e,outputToken:t,directPath:n,routePathDict:o,simulateCache:r,tickCache:i,slippage:s,chainTime:c,epochInfo:u,feeConfig:l}){var g,P,h,I,T,w,K,x,S;let m=l===void 0?new as(0):e.raw.mul(new as(l.feeBps.toNumber())).div(new as(1e4)),p=e.raw.sub(m),d=new Ie(e.token,p),f=l===void 0?void 0:{feeAmount:m,feeAccount:l.feeAccount},y=q(M({},t),{address:bt(t.address).toString()}),b=[];for(let B of n)try{b.push(q(M({},this.computeAmountOut({itemPool:B,tickCache:i,simulateCache:r,chainTime:c,epochInfo:u,slippage:s,outputToken:y,amountIn:d})),{feeConfig:f}))}catch(R){this.logDebug("direct error",B.version,B.id.toString(),R.message)}this.logDebug("direct done");for(let[B,R]of Object.entries(o)){let C={chainId:101,address:B,programId:R.mintProgram.toBase58(),logoURI:"",symbol:"",name:"",decimals:R.mDecimals,tags:[],extensions:{}},v=R.in.map(N=>{try{return{pool:N,data:this.computeAmountOut({itemPool:N,tickCache:i,simulateCache:r,chainTime:c,epochInfo:u,slippage:s,outputToken:C,amountIn:d})}}catch(E){this.logDebug("route in error",N.version,N.id.toString(),E.message);return}}).sort((N,E)=>{var ee,de,re,ue;let X=N===void 0?Nn:N.data.amountOut.amount.raw.sub((de=(ee=N.data.amountOut.fee)==null?void 0:ee.raw)!=null?de:Nn),Q=E===void 0?Nn:E.data.amountOut.amount.raw.sub((ue=(re=E.data.amountOut.fee)==null?void 0:re.raw)!=null?ue:Nn);return X.lt(Q)?1:-1})[0];if(v===void 0)continue;let L=new Ie(zr(C),v.data.amountOut.amount.raw.sub((P=(g=v.data.amountOut.fee)==null?void 0:g.raw)!=null?P:Nn));for(let N of R.out)try{let E=this.computeAmountOut({itemPool:N,tickCache:i,simulateCache:r,chainTime:c,epochInfo:u,slippage:s,outputToken:y,amountIn:L});b.push(q(M({},E),{allTrade:!!(v.data.allTrade&&E.allTrade),amountIn:v.data.amountIn,amountOut:E.amountOut,minAmountOut:E.minAmountOut,currentPrice:void 0,executionPrice:new tr(new lt({baseToken:v.data.amountIn.amount.token,denominator:v.data.amountIn.amount.raw,quoteToken:E.amountOut.amount.token,numerator:E.amountOut.amount.raw.sub((I=(h=E.amountOut.fee)==null?void 0:h.raw)!=null?I:Nn)}).toFixed()),priceImpact:new tr(v.data.priceImpact.add(E.priceImpact).toFixed()),fee:[v.data.fee[0],E.fee[0]],routeType:"route",poolInfoList:[v.pool,N],remainingAccounts:[v.data.remainingAccounts[0],E.remainingAccounts[0]],minMiddleAmountFee:(T=E.amountOut.fee)!=null&&T.raw?new Ie(v.data.amountOut.amount.token,((K=(w=v.data.amountOut.fee)==null?void 0:w.raw)!=null?K:Nn).add((S=(x=E.amountOut.fee)==null?void 0:x.raw)!=null?S:Nn)):void 0,middleToken:v.data.amountOut.amount.token,poolReady:v.data.poolReady&&E.poolReady,poolType:[v.data.poolType,E.poolType],feeConfig:f,expirationTime:on(v.data.expirationTime,E.expirationTime)}))}catch(E){this.logDebug("route out error",N.version,N.id.toString(),E.message)}}return b.filter(B=>(B.allTrade||this.logDebug(`pool ${B.poolInfoList.map(R=>R.id.toString()).join(",")} filter out since not all trade`),B.allTrade)).sort((B,R)=>B.amountOut.amount.raw.sub(R.amountOut.amount.raw).gt(Nn)?-1:1)}computeAmountOut({itemPool:e,tickCache:t,simulateCache:n,chainTime:o,epochInfo:r,slippage:i,outputToken:s,amountIn:c}){if(e.version===6){let{allTrade:u,realAmountIn:l,amountOut:m,minAmountOut:p,expirationTime:d,currentPrice:f,executionPrice:y,priceImpact:b,fee:g,remainingAccounts:P,executionPriceX64:h}=Fe.computeAmountOutFormat({poolInfo:e,tickArrayCache:t[e.id.toString()],amountIn:c.raw,tokenOut:s,slippage:i,epochInfo:r,catchLiquidityInsufficient:!0});return{allTrade:u,amountIn:l,amountOut:m,minAmountOut:p,currentPrice:new tr(f.toFixed()),executionPrice:new tr(y.toFixed()),priceImpact:new tr(b.toFixed()),fee:[g],remainingAccounts:[P],routeType:"amm",poolInfoList:[e],poolReady:e.startTime<o,poolType:"CLMM",slippage:i,clmmExPriceX64:[h],expirationTime:on(l.expirationTime,d)}}else if(e.version===7){let{allTrade:u,executionPrice:l,amountOut:m,minAmountOut:p,priceImpact:d,fee:f}=this.scope.cpmm.computeSwapAmount({pool:e,outputMint:s.address,amountIn:c.raw,slippage:i});return{allTrade:u,amountIn:{amount:c,fee:void 0,expirationTime:void 0},amountOut:{amount:_i(q(M({},s),{amount:m})),fee:void 0,expirationTime:void 0},minAmountOut:{amount:_i(q(M({},s),{amount:p})),fee:void 0,expirationTime:void 0},currentPrice:e.poolPrice,executionPrice:l,priceImpact:d,fee:[new Ie(c.token,f)],remainingAccounts:[],routeType:"amm",poolInfoList:[e],poolReady:e.openTime.toNumber()<o,poolType:"CPMM",slippage:i,clmmExPriceX64:[void 0],expirationTime:void 0}}else{if(![1,6,7].includes(n[e.id.toString()].status))throw Error("swap error");let{amountOut:u,minAmountOut:l,currentPrice:m,executionPrice:p,priceImpact:d,fee:f}=this.scope.liquidity.computeAmountOut({poolInfo:n[e.id.toString()],amountIn:c.raw,mintIn:c.token.mint,mintOut:s.address,slippage:i});return{amountIn:{amount:c,fee:void 0,expirationTime:void 0},amountOut:{amount:_i(q(M({},s),{amount:u})),fee:void 0,expirationTime:void 0},minAmountOut:{amount:_i(q(M({},s),{amount:l})),fee:void 0,expirationTime:void 0},currentPrice:m,executionPrice:p,priceImpact:d,fee:[new Ie(c.token,f)],routeType:"amm",poolInfoList:[e],remainingAccounts:[],poolReady:Number(n[e.id].openTime)<o,poolType:e.version===5?"STABLE":void 0,expirationTime:void 0,allTrade:!0,slippage:i,clmmExPriceX64:[void 0]}}}async computePoolToPoolKeys({pools:e,clmmRpcData:t={},ammRpcData:n={}}){let o=new Set(e.filter(u=>u.version===6&&!t[u.id.toString()]).map(u=>u.id.toString()));if(o.size>0){let u=await this.scope.clmm.getRpcClmmPoolInfos({poolIds:Array.from(o)});Object.keys(u).forEach(l=>{t[l]=u[l]})}let r=new Set(e.filter(u=>u.version===4&&!n[u.id.toString()]).map(u=>u.id.toString()));if(r.size>0){let u=await this.scope.liquidity.getRpcPoolInfos(Array.from(r));Object.keys(u).forEach(l=>{n[l]=u[l]})}let i=new Set(e.filter(u=>u.version===4).map(u=>u.marketId)),s={};i.size>0&&(await ve(this.scope.connection,Array.from(i).map(l=>({pubkey:new wo(l)})))).forEach(l=>{if(!l.accountInfo)return;let m=uu.decode(l.accountInfo.data);s[l.pubkey.toBase58()]={marketId:l.pubkey.toString(),marketProgramId:l.accountInfo.owner.toString(),marketAuthority:rs.getAssociatedAuthority({programId:l.accountInfo.owner,marketId:l.pubkey}).publicKey.toString(),marketBaseVault:m.baseVault.toString(),marketQuoteVault:m.quoteVault.toString(),marketBids:m.bids.toString(),marketAsks:m.asks.toString(),marketEventQueue:m.eventQueue.toString()}});let c=[];return e.forEach(u=>{if(u.version===6){let l=t[u.id.toString()],m={programId:u.programId.toBase58(),id:u.id.toBase58(),mintA:u.mintA,mintB:u.mintB,openTime:String(u.startTime),vault:{A:l.vaultA.toBase58(),B:l.vaultB.toBase58()},config:q(M({},u.ammConfig),{id:u.ammConfig.id.toString(),defaultRange:0,defaultRangePoint:[]}),rewardInfos:[],observationId:u.observationId.toBase58(),exBitmapAccount:u.exBitmapAccount.toBase58()};c.push(m)}else if(u.version===4){let l=n[u.id.toString()],m=M({programId:u.programId,id:u.id,mintA:u.mintA,mintB:u.mintB,openTime:String(u.openTime),vault:{A:l.baseVault.toBase58(),B:l.quoteVault.toBase58()},authority:Za({programId:new wo(u.programId)}).publicKey.toString(),openOrders:l.openOrders.toBase58(),targetOrders:l.targetOrders.toBase58(),mintLp:u.lpMint},s[u.marketId]);c.push(m)}else u.version===7&&c.push({observationId:u.observationId.toBase58(),programId:u.programId.toBase58(),id:u.id.toBase58(),mintA:u.mintA,mintB:u.mintB,openTime:String(u.openTime),authority:zo(u.programId).publicKey.toBase58(),vault:{A:u.vaultA.toBase58(),B:u.vaultB.toBase58()},mintLp:At({address:u.mintLp.toBase58(),programId:Ze.toBase58(),decimals:u.lpDecimals}),config:q(M({id:u.configId.toBase58()},u.configInfo),{protocolFeeRate:u.configInfo.protocolFeeRate.toNumber(),tradeFeeRate:u.configInfo.tradeFeeRate.toNumber(),fundFeeRate:u.configInfo.fundFeeRate.toNumber(),createPoolFee:u.configInfo.createPoolFee.toString()})})}),c}};import{PublicKey as py,Transaction as du,TransactionInstruction as fy}from"@solana/web3.js";import{TOKEN_PROGRAM_ID as yy}from"@solana/spl-token";import am from"bn.js";var kt=class extends We{static getPdaPoolId(e,t){return te([kt.SEED_CONFIG.pool.id,t.toBuffer()],e)}static getPdaOwnerId(e,t,n,o){return te([kt.SEED_CONFIG.owner.id,t.toBuffer(),n.toBuffer(),Buffer.from(new am(o).toArray())],e)}static async getAllInfo({connection:e,programId:t,poolIds:n,wallet:o,chainTime:r}){if(n.length===0)return[];let i=n.map(l=>kt.getPdaPoolId(t,l).publicKey),s=[];for(let l=0;l<kt.VERSION_PROJECT.length;l++)s.push(...i.map(m=>kt.getPdaOwnerId(t,m,o,l).publicKey));let c=await tn(e,[...i,...s]),u=[];for(let l=0;l<c.length;l++){let m=Math.floor(l/n.length),p=l%n.length,d=i[p],f=s[l],y=c[p],b=c[n.length+l];if(!(y&&b)||y.data.length!==kt.POOL_LAYOUT.span||b.data.length!==kt.OWNER_LAYOUT.span)continue;let g=kt.POOL_LAYOUT.decode(y.data),P=kt.OWNER_LAYOUT.decode(b.data),h=g.openTime.toNumber(),I=g.endTime.toNumber(),T=P.tokenInfo.map(x=>x.debtAmount.gt(new am(0))).filter(x=>!x).length!==3,w=r>h&&r<I&&g.status===1,K=T&&w;u.push({programId:t,poolId:d,ammId:g.ammId,ownerAccountId:f,snapshotLpAmount:P.lpAmount,project:kt.VERSION_PROJECT[m],openTime:h,endTime:I,canClaim:K,canClaimErrorType:T?w?void 0:"outOfOperationalTime":"alreadyClaimIt",tokenInfo:g.tokenInfo.map((x,S)=>({mintAddress:x.mintAddress,mintVault:x.mintVault,mintDecimals:x.mintDecimals,perLpLoss:x.perLpLoss,debtAmount:P.tokenInfo[S].debtAmount.add(P.tokenInfo[S].claimedAmount)}))})}return u}async makeClaimTransaction({poolInfo:e,ownerInfo:t,feePayer:n}){t.wallet||this.scope.checkOwner();let o=this.createTxBuilder(n),r=t.wallet||this.scope.ownerPubKey,i=[];for(let u of e.tokenInfo){let{account:l,instructionParams:m}=await this.scope.account.getOrCreateTokenAccount({mint:u.mintAddress,owner:this.scope.ownerPubKey,notUseTokenAccount:u.mintAddress.equals(Ke.WSOL.mint),createInfo:{payer:r,amount:0},skipCloseAccount:!u.mintAddress.equals(Ke.WSOL.mint),associatedOnly:u.mintAddress.equals(Ke.WSOL.mint)?!1:t.associatedOnly});m&&o.addInstruction(m),i.push(l)}o.addInstruction({instructions:[kt.makeClaimInstruction({programId:e.programId,poolInfo:e,ownerInfo:{wallet:r,ownerPda:e.ownerAccountId,claimAddress:i}})]});let{transaction:s,signers:c}=o.build();return[{transaction:s,signer:c}]}async makeClaimAllTransaction({poolInfos:e,ownerInfo:t,feePayer:n}){let o=this.createTxBuilder(n),r=t.wallet||this.scope.ownerPubKey,i={};for(let l of e){let m=[];for(let p of l.tokenInfo){let{account:d,instructionParams:f}=await this.scope.account.getOrCreateTokenAccount({mint:p.mintAddress,owner:this.scope.ownerPubKey,notUseTokenAccount:p.mintAddress.equals(Ke.WSOL.mint),createInfo:{payer:r,amount:0},skipCloseAccount:!p.mintAddress.equals(Ke.WSOL.mint),associatedOnly:p.mintAddress.equals(Ke.WSOL.mint)?!1:t.associatedOnly});f&&o.addInstruction(f),d&&(i[p.mintAddress.toString()]=d,m.push(d))}o.addInstruction({instructions:[kt.makeClaimInstruction({programId:l.programId,poolInfo:l,ownerInfo:{wallet:r,ownerPda:l.ownerAccountId,claimAddress:m}})]})}let{transaction:s,signers:c}=o.build(),u=o.allInstructions;return Ir(u,[r,...c.map(l=>l.publicKey)])?[{transaction:s,signer:c}]:[{transaction:new du().add(...u.slice(0,o.AllTxData.instructions.length-1)),signer:c},{transaction:new du().add(...u.slice(o.AllTxData.instructions.length-1)),signer:[]},{transaction:new du().add(...o.AllTxData.endInstructions),signer:[]}]}static makeClaimInstruction({programId:e,poolInfo:t,ownerInfo:n}){let o=F([]),r=[{pubkey:n.wallet,isSigner:!0,isWritable:!0},{pubkey:t.poolId,isSigner:!1,isWritable:!0},{pubkey:n.ownerPda,isSigner:!1,isWritable:!0},...n.claimAddress.map(c=>({pubkey:c,isSigner:!1,isWritable:!0})),...t.tokenInfo.map(({mintVault:c})=>({pubkey:c,isSigner:!1,isWritable:!0})),{pubkey:yy,isSigner:!1,isWritable:!1}],i=Buffer.alloc(o.span);o.encode({},i);let s=Buffer.from([10,66,208,184,161,6,191,98,...i]);return new fy({keys:r,programId:e,data:s})}},jt=kt;jt.CLAIMED_NUM=3,jt.POOL_LAYOUT=F([Be(8),_("bump"),_("status"),A("openTime"),A("endTime"),O("ammId"),Y(F([_("mintDecimals"),O("mintAddress"),O("mintVault"),A("perLpLoss"),A("totalClaimedAmount")]),kt.CLAIMED_NUM,"tokenInfo"),Y(A(),10,"padding")]),jt.OWNER_LAYOUT=F([Be(8),_("bump"),_("version"),O("poolId"),O("owner"),A("lpAmount"),Y(F([O("mintAddress"),A("debtAmount"),A("claimedAmount")]),kt.CLAIMED_NUM,"tokenInfo"),Y(A(),4,"padding")]),jt.DEFAULT_POOL_ID=["58oQChx4yWmvKdwLLZzBi4ChoCc2fqCUWBkwMihLYQo2","6UmmUiYoBjSrhakAobJw8BvkmJtDVxaeBtbt7rxWo1mg","AVs9TA4nWDzfPJE9gGVNJMVhcQy3V9PGazuz33BfG2RA","DVa7Qmb5ct9RCpaU7UTpSaf3GVMYz17vNVU67XpdCRut","7XawhbbxtsRcQA8KTkHT9f9nc6d69UwqCDh6U5EEbEmX","6a1CsrpeZubDjEJE9s1CMVheB6HWM5d7m1cj2jkhyXhj","EoNrn8iUhwgJySD1pHu8Qxm5gSQqLK3za4m8xzD2RuEb","AceAyRTWt4PyB2pHqf2qhDgNZDtKVNaxgL8Ru3V4aN1P","6tmFJbMk5yVHFcFy7X2K8RwHjKLr6KVFLYXpgpBNeAxB"].map(e=>new py(e)),jt.SEED_CONFIG={pool:{id:Buffer.from("pool_seed","utf8")},owner:{id:Buffer.from("user_claim_seed","utf8")}},jt.VERSION_PROJECT=[void 0,"Francium","Tulip","Larix"];import{PublicKey as ir}from"@solana/web3.js";import um from"bn.js";import{SYSVAR_CLOCK_PUBKEY as by,TransactionInstruction as fu}from"@solana/web3.js";import{TOKEN_PROGRAM_ID as yu}from"@solana/spl-token";var pu=F([_("instruction"),Ic("amount")]),or=F([_("instruction")]);function CR({programId:a,amount:e,instructionKeys:t}){let n=[{pubkey:Ar,isSigner:!1,isWritable:!1},{pubkey:yu,isSigner:!1,isWritable:!1},{pubkey:Je,isSigner:!1,isWritable:!1},{pubkey:Ls,isSigner:!1,isWritable:!1},...Object.entries(t).map(([r,i])=>({pubkey:i,isSigner:r==="userOwner",isWritable:!["authority","userOwner","userIdoCheck","userStakeInfo"].includes(r)}))],o=Buffer.alloc(pu.span);return pu.encode({instruction:1,amount:Number(e)},o),new fu({keys:n,programId:a,data:o})}function us({programId:a},e){let t=[{pubkey:yu,isSigner:!1,isWritable:!1},{pubkey:Ls,isSigner:!1,isWritable:!1},...Object.entries(e).map(([o,r])=>({pubkey:r,isSigner:o==="userOwner",isWritable:!["authority","userOwner"].includes(o)}))],n=Buffer.alloc(or.span);return or.encode({instruction:2},n),new fu({keys:t,programId:a,data:n})}function bu(a){let{poolConfig:e,userKeys:t,side:n}=a,o=n==="base"?t.baseTokenAccount:t.quoteTokenAccount,r=n==="base"?e.baseVault:e.quoteVault,i=Buffer.alloc(or.span);or.encode({instruction:2},i);let s=[{pubkey:yu,isWritable:!1,isSigner:!1},{pubkey:by,isWritable:!1,isSigner:!1},{pubkey:e.id,isWritable:!0,isSigner:!1},{pubkey:e.authority,isWritable:!1,isSigner:!1},{pubkey:r,isWritable:!0,isSigner:!1},{pubkey:o,isWritable:!0,isSigner:!1},{pubkey:t.ledgerAccount,isWritable:!0,isSigner:!1},{pubkey:t.owner,isWritable:!1,isSigner:!0}];return new fu({programId:e.programId,keys:s,data:i})}var gy={[pi.IDO_PROGRAM_ID_V1.toString()]:1,[pi.IDO_PROGRAM_ID_V2.toString()]:2,[pi.IDO_PROGRAM_ID_V3.toString()]:3,[pi.IDO_PROGRAM_ID_V4.toString()]:4},Ho=class extends We{async claim({ownerInfo:e,idoKeys:t,associatedOnly:n=!0,checkCreateATAOwner:o=!1,txVersion:r,feePayer:i}){let s=this.createTxBuilder(i),c=gy[t.programId];c||this.logAndCreateError("invalid version",c);let u=Ee(t),[l,m]=[!new um(e.coin).isZero(),!new um(e.pc).isZero()],p=u.projectInfo.mint.address.equals($),{account:d,instructionParams:f}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:u.projectInfo.mint.programId,mint:u.projectInfo.mint.address,owner:this.scope.ownerPubKey,createInfo:{payer:this.scope.ownerPubKey,amount:0},skipCloseAccount:!p,notUseTokenAccount:p,associatedOnly:p?!1:n,checkCreateATAOwner:o});!d&&l&&this.logAndCreateError("target token accounts not found","mint",t.projectInfo.mint.address),l&&f&&s.addInstruction(f);let y=u.buyInfo.mint.address.equals($),{account:b,instructionParams:g}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:u.buyInfo.mint.programId,mint:u.buyInfo.mint.address,owner:this.scope.ownerPubKey,createInfo:{payer:this.scope.ownerPubKey,amount:0},skipCloseAccount:!y,notUseTokenAccount:y,associatedOnly:y?!1:n,checkCreateATAOwner:o});if(!d&&m&&this.logAndCreateError("target token accounts not found","mint",t.projectInfo.mint.address),m&&g&&s.addInstruction(g),(!d||!b)&&this.logAndCreateError("target token accounts not found","mint",t.projectInfo.mint.address,t.buyInfo.mint.address),c===3)return s.addInstruction({instructions:[...l?[us({programId:u.programId},{idoId:u.id,authority:u.authority,poolTokenAccount:u.projectInfo.vault,userTokenAccount:d,userIdoInfo:new ir(e.userIdoInfo),userOwner:this.scope.ownerPubKey})]:[],...m?[us({programId:new ir(t.programId)},{idoId:u.id,authority:u.authority,poolTokenAccount:u.buyInfo.vault,userTokenAccount:b,userIdoInfo:new ir(e.userIdoInfo),userOwner:this.scope.ownerPubKey})]:[]]}).versionBuild({txVersion:r});if(c<3)return!l&&!m&&this.logAndCreateError("no claimable rewards"),s.addInstruction({instructions:[us({programId:u.programId},{idoId:u.id,authority:u.authority,poolQuoteTokenAccount:u.buyInfo.vault,poolBaseTokenAccount:u.projectInfo.vault,userQuoteTokenAccount:b,userBaseTokenAccount:d,userIdoInfo:new ir(e.userIdoInfo),userOwner:this.scope.ownerPubKey})]}).versionBuild({txVersion:r});let P={poolConfig:{id:u.id,programId:u.programId,authority:u.authority,baseVault:u.projectInfo.vault,quoteVault:u.buyInfo.vault,baseToken:t.projectInfo.mint,quoteToken:t.buyInfo.mint},userKeys:{baseTokenAccount:d,quoteTokenAccount:b,ledgerAccount:new ir(e.userIdoInfo),owner:this.scope.ownerPubKey}};return s.addInstruction({instructions:[...l?[bu(q(M({},P),{side:"base"}))]:[],...m?[bu(q(M({},P),{side:"quote"}))]:[]]}).versionBuild({txVersion:r})}};var cm=(t=>(t[t.OnlyTokenB=0]="OnlyTokenB",t[t.BothToken=1]="BothToken",t))(cm||{});var Py=Buffer.from("vault_auth_seed","utf8"),Ay=Buffer.from("global_config","utf8"),ky=Buffer.from("pool_vesting","utf8"),wy=Buffer.from("platform_config","utf8"),Ty=Buffer.from("platform_fee_vault_auth_seed","utf8"),hy=Buffer.from("creator_fee_vault_auth_seed","utf8");function yn(a){return te([Py],a)}function HR(a,e,t,n){return te([Ay,e.toBuffer(),Iy(t),Ur(n)],a)}function jo(a,e,t){return te([La,e.toBuffer(),t.toBuffer()],a)}function gu(a,e,t){return te([Oa,e.toBuffer(),t.toBuffer()],a)}function $n(a){return te([Buffer.from("__event_authority","utf8")],a)}function Iy(a){let e=new ArrayBuffer(1);return new DataView(e).setUint8(0,a),new Uint8Array(e)}function Pu(a,e){return te([wy,e.toBuffer()],a)}function rr(a,e,t){return te([ky,e.toBuffer(),t.toBuffer()],a)}function To(a,e,t){return te([e.toBuffer(),t.toBuffer()],a)}function Au(a){return te([Ty],a)}function ho(a,e,t){return te([e.toBuffer(),t.toBuffer()],a)}function ku(a){return te([hy],a)}import{ASSOCIATED_TOKEN_PROGRAM_ID as cs,TOKEN_2022_PROGRAM_ID as Ky,TOKEN_PROGRAM_ID as sr}from"@solana/spl-token";import{SystemProgram as Mt,TransactionInstruction as wt}from"@solana/web3.js";import Mn from"bn.js";var Zn=F([A(),A("epoch"),_("curveType"),Et("index"),A("migrateFee"),A("tradeFeeRate"),A("maxShareFeeRate"),A("minSupplyA"),A("maxLockRate"),A("minSellRateA"),A("minMigrateRateA"),A("minFundRaisingB"),O("mintB"),O("protocolFeeOwner"),O("migrateFeeOwner"),O("migrateToAmmWallet"),O("migrateToCpmmWallet"),Y(A(),16)]),By=F([A("totalLockedAmount"),A("cliffPeriod"),A("unlockPeriod"),A("startTime"),A("totalAllocatedShare")]),un=F([A(),A("epoch"),_("bump"),_("status"),_("mintDecimalsA"),_("mintDecimalsB"),_("migrateType"),A("supply"),A("totalSellA"),A("virtualA"),A("virtualB"),A("realA"),A("realB"),A("totalFundRaisingB"),A("protocolFee"),A("platformFee"),A("migrateFee"),By.replicate("vestingSchedule"),O("configId"),O("platformId"),O("mintA"),O("mintB"),O("vaultA"),O("vaultB"),O("creator"),_("mintProgramFlag"),_("cpmmCreatorFeeOn"),Y(_(),62)]),ZR=F([A(),A("epoch"),O("poolId"),O("beneficiary"),A("claimedAmount"),A("tokenShareAmount"),Y(A(),8)]),wu=F([_("migrateType"),_("migrateCpmmFeeOn"),A("supply"),A("totalSellA"),A("totalFundRaisingB"),A("totalLockedAmount"),A("cliffPeriod"),A("unlockPeriod")]),xy=F([A("epoch"),_("index"),O("configId"),wu.replicate("bondingCurveParam"),Y(A(),50)]),$o=F([A(),A("epoch"),O("platformClaimFeeWallet"),O("platformLockNftWallet"),A("platformScale"),A("creatorScale"),A("burnScale"),A("feeRate"),Y(_(),64,"name"),Y(_(),256,"web"),Y(_(),256,"img"),O("cpConfigId"),A("creatorFeeRate"),O("transferFeeExtensionAuth"),Y(_(),180),Lc(xy,"platformCurve")]);var Tt={initialize:Buffer.from([175,175,109,31,13,152,155,237]),initializeV2:Buffer.from([67,153,175,39,218,16,38,32]),buyExactIn:Buffer.from([250,234,13,123,213,156,19,236]),buyExactOut:Buffer.from([24,211,116,40,105,3,153,56]),sellExactIn:Buffer.from([149,39,222,155,211,124,152,26]),sellExactOut:Buffer.from([95,200,71,34,8,9,11,166]),createVestingAccount:Buffer.from([129,178,2,13,217,172,230,218]),claimVestedToken:Buffer.from([49,33,104,30,189,157,79,35]),createPlatformConfig:Buffer.from([176,90,196,175,253,113,220,20]),claimPlatformFee:Buffer.from([156,39,208,135,76,237,61,72]),updatePlaformConfig:Buffer.from([195,60,76,129,146,45,67,143]),initializeWithToken2022:Buffer.from([37,190,126,222,44,154,171,17]),claimPlatformFeeFromVault:Buffer.from([117,241,198,168,248,218,80,29]),claimCreatorFee:Buffer.from([26,97,138,203,132,171,141,252]),updatePlatformCurveParam:Buffer.from([138,144,138,250,220,128,4,57]),removePlatformCurveParam:Buffer.from([27,30,62,169,93,224,24,145])};function lL(a,e,t,n,o,r,i,s,c,u,l,m,p,d,f,y,b,g,P,h){throw new Error("*** launchlab initialize has been deprecated, please use initializeV2 instead! ***")}function mm(a,e,t,n,o,r,i,s,c,u,l,m,p,d,f,y,b,g,P,h,I){let T=F([_("decimals"),ft("name"),ft("symbol"),ft("uri")]),w=F([A("totalLockedAmount"),A("cliffPeriod"),A("unlockPeriod"),_("cpmmCreatorFeeOn")]),K=F([_("index"),A("supply"),A("totalFundRaisingB"),_("migrateType")]),x=F([_("index"),A("supply"),A("totalSellA"),A("totalFundRaisingB"),_("migrateType")]),S=[{pubkey:e,isSigner:!0,isWritable:!0},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!1,isWritable:!1},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!0,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!1},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:m,isSigner:!1,isWritable:!0},{pubkey:sr,isSigner:!1,isWritable:!1},{pubkey:sr,isSigner:!1,isWritable:!1},{pubkey:Gt,isSigner:!1,isWritable:!1},{pubkey:Mt.programId,isSigner:!1,isWritable:!1},{pubkey:Je,isSigner:!1,isWritable:!1},{pubkey:$n(a).publicKey,isSigner:!1,isWritable:!1},{pubkey:a,isSigner:!1,isWritable:!1}],B=Buffer.alloc(Buffer.from(d,"utf-8").length+Buffer.from(f,"utf-8").length+Buffer.from(y,"utf-8").length+4*3+1),R=Buffer.alloc(w.span),C=Buffer.alloc(b.type==="ConstantCurve"?x.span:K.span);return T.encode({decimals:p,name:d,symbol:f,uri:y},B),b.type==="ConstantCurve"?x.encode(q(M({index:0},b),{migrateType:b.migrateType==="amm"?0:1}),C):b.type==="FixedCurve"?K.encode(q(M({index:1},b),{migrateType:b.migrateType==="amm"?0:1}),C):b.type==="LinearCurve"&&K.encode(q(M({index:2},b),{migrateType:b.migrateType==="amm"?0:1}),C),w.encode({totalLockedAmount:g,cliffPeriod:P,unlockPeriod:h,cpmmCreatorFeeOn:I},R),new wt({keys:S,programId:a,data:Buffer.from([...Tt.initializeV2,...B,...C,...R])})}function dm(a,e,t,n,o,r,i,s,c,u,l,m,p,d,f,y,b,g,P,h,I){let T=F([_("decimals"),ft("name"),ft("symbol"),ft("uri")]),w=F([A("totalLockedAmount"),A("cliffPeriod"),A("unlockPeriod"),_("cpmmCreatorFeeOn"),_("transferFeeExtensionParamsOption"),F([Et("transferFeeBasePoints"),A("maxinumFee")]).replicate("transferFeeExtensionParams")]),K=F([_("index"),A("supply"),A("totalFundRaisingB"),_("migrateType")]),x=F([_("index"),A("supply"),A("totalSellA"),A("totalFundRaisingB"),_("migrateType")]),S=[{pubkey:e,isSigner:!0,isWritable:!0},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!1,isWritable:!1},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!0,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!1},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:Ky,isSigner:!1,isWritable:!1},{pubkey:sr,isSigner:!1,isWritable:!1},{pubkey:Mt.programId,isSigner:!1,isWritable:!1},{pubkey:$n(a).publicKey,isSigner:!1,isWritable:!1},{pubkey:a,isSigner:!1,isWritable:!1}],B=Buffer.alloc(Buffer.from(p,"utf-8").length+Buffer.from(d,"utf-8").length+Buffer.from(f,"utf-8").length+4*3+1),R=Buffer.alloc(w.span),C=Buffer.alloc(y.type==="ConstantCurve"?x.span:K.span);return T.encode({decimals:m,name:p,symbol:d,uri:f},B),y.type==="ConstantCurve"?x.encode(q(M({index:0},y),{migrateType:y.migrateType==="amm"?0:1}),C):y.type==="FixedCurve"?K.encode(q(M({index:1},y),{migrateType:y.migrateType==="amm"?0:1}),C):y.type==="LinearCurve"&&K.encode(q(M({index:2},y),{migrateType:y.migrateType==="amm"?0:1}),C),w.encode({totalLockedAmount:b,cliffPeriod:g,unlockPeriod:P,cpmmCreatorFeeOn:h,transferFeeExtensionParamsOption:I?1:0,transferFeeExtensionParams:I!=null?I:{transferFeeBasePoints:0,maxinumFee:new Mn(0)}},R),new wt({keys:S,programId:a,data:Buffer.from([...Tt.initializeWithToken2022,...B,...C,...R])})}function pm(a,e,t,n,o,r,i,s,c,u,l,m,p,d,f,y,b,g,P,h){let I=F([A("amountB"),A("minAmountA"),A("shareFeeRate")]),T=[{pubkey:e,isSigner:!0,isWritable:!0},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!1},{pubkey:m,isSigner:!1,isWritable:!1},{pubkey:p,isSigner:!1,isWritable:!1},{pubkey:d,isSigner:!1,isWritable:!1},{pubkey:$n(a).publicKey,isSigner:!1,isWritable:!1},{pubkey:a,isSigner:!1,isWritable:!1}];h&&T.push({pubkey:h,isSigner:!1,isWritable:!0}),T.push({pubkey:Mt.programId,isSigner:!1,isWritable:!1}),T.push({pubkey:f,isSigner:!1,isWritable:!0}),T.push({pubkey:y,isSigner:!1,isWritable:!0});let w=Buffer.alloc(I.span);return I.encode({amountB:b,minAmountA:g,shareFeeRate:P!=null?P:new Mn(0)},w),new wt({keys:T,programId:a,data:Buffer.from([...Tt.buyExactIn,...w])})}function fm(a,e,t,n,o,r,i,s,c,u,l,m,p,d,f,y,b,g,P,h){let I=F([A("amountA"),A("maxAmountB"),A("shareFeeRate")]),T=[{pubkey:e,isSigner:!0,isWritable:!0},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!1},{pubkey:m,isSigner:!1,isWritable:!1},{pubkey:p,isSigner:!1,isWritable:!1},{pubkey:d,isSigner:!1,isWritable:!1},{pubkey:$n(a).publicKey,isSigner:!1,isWritable:!1},{pubkey:a,isSigner:!1,isWritable:!1}];h&&T.push({pubkey:h,isSigner:!1,isWritable:!0}),T.push({pubkey:Mt.programId,isSigner:!1,isWritable:!1}),T.push({pubkey:f,isSigner:!1,isWritable:!0}),T.push({pubkey:y,isSigner:!1,isWritable:!0});let w=Buffer.alloc(I.span);return I.encode({amountA:b,maxAmountB:g,shareFeeRate:P!=null?P:new Mn(0)},w),new wt({keys:T,programId:a,data:Buffer.from([...Tt.buyExactOut,...w])})}function ym(a,e,t,n,o,r,i,s,c,u,l,m,p,d,f,y,b,g,P,h){let I=F([A("amountA"),A("minAmountB"),A("shareFeeRate")]),T=[{pubkey:e,isSigner:!0,isWritable:!0},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!1},{pubkey:m,isSigner:!1,isWritable:!1},{pubkey:p,isSigner:!1,isWritable:!1},{pubkey:d,isSigner:!1,isWritable:!1},{pubkey:$n(a).publicKey,isSigner:!1,isWritable:!1},{pubkey:a,isSigner:!1,isWritable:!1}];h&&T.push({pubkey:h,isSigner:!1,isWritable:!0}),T.push({pubkey:Mt.programId,isSigner:!1,isWritable:!1}),T.push({pubkey:f,isSigner:!1,isWritable:!0}),T.push({pubkey:y,isSigner:!1,isWritable:!0});let w=Buffer.alloc(I.span);return I.encode({amountA:b,minAmountB:g,shareFeeRate:P!=null?P:new Mn(0)},w),new wt({keys:T,programId:a,data:Buffer.from([...Tt.sellExactIn,...w])})}function bm(a,e,t,n,o,r,i,s,c,u,l,m,p,d,f,y,b,g,P,h){let I=F([A("amountB"),A("maxAmountA"),A("shareFeeRate")]),T=[{pubkey:e,isSigner:!0,isWritable:!0},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!1},{pubkey:m,isSigner:!1,isWritable:!1},{pubkey:p,isSigner:!1,isWritable:!1},{pubkey:d,isSigner:!1,isWritable:!1},{pubkey:$n(a).publicKey,isSigner:!1,isWritable:!1},{pubkey:a,isSigner:!1,isWritable:!1}];h&&T.push({pubkey:h,isSigner:!1,isWritable:!0}),T.push({pubkey:Mt.programId,isSigner:!1,isWritable:!1}),T.push({pubkey:f,isSigner:!1,isWritable:!0}),T.push({pubkey:y,isSigner:!1,isWritable:!0});let w=Buffer.alloc(I.span);return I.encode({amountB:b,maxAmountA:g,shareFeeRate:P!=null?P:new Mn(0)},w),new wt({keys:T,programId:a,data:Buffer.from([...Tt.sellExactOut,...w])})}function hu(a,e,t,n,o,r,i,s,c){let u=F([]),l=[{pubkey:e,isSigner:!0,isWritable:!0},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!1},{pubkey:c,isSigner:!1,isWritable:!1},{pubkey:Mt.programId,isSigner:!1,isWritable:!1},{pubkey:cs,isSigner:!1,isWritable:!1}],m=Buffer.alloc(u.span);return u.encode({},m),new wt({keys:l,programId:a,data:Buffer.from([...Tt.claimVestedToken,...m])})}function Iu(a,e,t,n,o,r){let i=F([A("shareAmount")]),s=[{pubkey:e,isSigner:!0,isWritable:!0},{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:Mt.programId,isSigner:!1,isWritable:!1}],c=Buffer.alloc(i.span);return i.encode({shareAmount:r},c),new wt({keys:s,programId:a,data:Buffer.from([...Tt.createVestingAccount,...c])})}function Bu(a,e,t,n,o,r,i,s,c){let u=[{pubkey:e,isSigner:!0,isWritable:!0},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:Mt.programId,isSigner:!1,isWritable:!0},{pubkey:cs,isSigner:!1,isWritable:!0}];return new wt({keys:u,programId:a,data:Tt.claimPlatformFee})}function gm(a,e,t,n,o,r,i,s,c,u,l,m,p){let d=F([A("platformScale"),A("creatorScale"),A("burnScale"),A("feeRate"),ft("name"),ft("web"),ft("img"),A("creatorFeeRate")]),f=[{pubkey:e,isSigner:!0,isWritable:!0},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:Mt.programId,isSigner:!1,isWritable:!1},{pubkey:i,isSigner:!1,isWritable:!1}],y=Buffer.alloc(8*5+Buffer.from(l,"utf-8").length+Buffer.from(m,"utf-8").length+Buffer.from(p,"utf-8").length+4*3);return d.encode({platformScale:s.platformScale,creatorScale:s.creatorScale,burnScale:s.burnScale,feeRate:c,name:l,web:m,img:p,creatorFeeRate:u},y),new wt({keys:f,programId:a,data:Buffer.from([...Tt.createPlatformConfig,...y])})}function Pm(a,e,t,n){let o=[{pubkey:e,isSigner:!0,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!0}],r;if(n.type==="updateClaimFeeWallet"){let i=F([_("index"),O("value")]);r=Buffer.alloc(i.span),i.encode({index:0,value:n.value},r)}else if(n.type==="updateLockNftWallet"){let i=F([_("index"),O("value")]);r=Buffer.alloc(i.span),i.encode({index:1,value:n.value},r)}else if(n.type==="migrateCpLockNftScale"){let i=F([_("index"),A("platformScale"),A("creatorScale"),A("burnScale")]);r=Buffer.alloc(i.span),i.encode(M({index:2},n.value),r)}else if(n.type==="updateFeeRate"){let i=F([_("index"),A("value")]);r=Buffer.alloc(i.span),i.encode({index:3,value:n.value},r)}else if(n.type==="updateImg"||n.type==="updateName"||n.type==="updateWeb"){let i=F([_("index"),ft("value")]);r=Buffer.alloc(Buffer.from(n.value,"utf-8").length+4+1*1),n.type==="updateName"?i.encode({index:4,value:n.value},r):n.type==="updateWeb"?i.encode({index:5,value:n.value},r):n.type==="updateImg"&&i.encode({index:6,value:n.value},r)}else if(n.type==="updateCpConfigId"){o.push({pubkey:n.value,isSigner:!1,isWritable:!1});let i=F([_("index")]);r=Buffer.alloc(i.span),i.encode({index:7},r)}else if(n.type==="updateAll"){o.push({pubkey:n.value.cpConfigId,isSigner:!1,isWritable:!1});let i=F([_("index"),O("platformClaimFeeWallet"),O("platformLockNftWallet"),A("platformScale"),A("creatorScale"),A("burnScale"),A("feeRate"),ft("name"),ft("web"),ft("img"),O("transferFeeExtensionAuth"),A("creatorFeeRate")]);r=Buffer.alloc(1+32+32+8*4+4*3+Buffer.from(n.value.name,"utf-8").length+Buffer.from(n.value.web,"utf-8").length+Buffer.from(n.value.img,"utf-8").length+32+8),i.encode({index:8,platformClaimFeeWallet:n.value.platformClaimFeeWallet,platformLockNftWallet:n.value.platformLockNftWallet,platformScale:n.value.migrateCpLockNftScale.platformScale,creatorScale:n.value.migrateCpLockNftScale.creatorScale,burnScale:n.value.migrateCpLockNftScale.burnScale,feeRate:n.value.feeRate,name:n.value.name,web:n.value.web,img:n.value.img,transferFeeExtensionAuth:n.value.transferFeeExtensionAuth,creatorFeeRate:n.value.creatorFeeRate},r)}else throw Error("updateInfo params type error");return new wt({keys:o,programId:a,data:Buffer.from([...Tt.updatePlaformConfig,...r])})}function xu(a,e,t,n,o,r,i,s){let c=[{pubkey:t,isSigner:!0,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:e,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!1},{pubkey:s,isSigner:!1,isWritable:!1},{pubkey:Mt.programId,isSigner:!1,isWritable:!1},{pubkey:cs,isSigner:!1,isWritable:!1}];return new wt({keys:c,programId:a,data:Tt.claimPlatformFeeFromVault})}function Ku(a,e,t,n,o,r,i){let s=[{pubkey:e,isSigner:!0,isWritable:!0},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!1},{pubkey:i,isSigner:!1,isWritable:!1},{pubkey:Mt.programId,isSigner:!1,isWritable:!1},{pubkey:cs,isSigner:!1,isWritable:!1}];return new wt({keys:s,programId:a,data:Tt.claimCreatorFee})}var lm=255,Tu=new Mn("18446744073709551615");function mL(a,e,t,n,o,r){let i=[{pubkey:e,isSigner:!0,isWritable:!0},{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:Mt.programId,isSigner:!1,isWritable:!1}],s=Buffer.alloc(1*2+8*6+_().span);return _().encode(o,s),wu.encode({migrateType:r.migrateType?r.migrateType:lm,migrateCpmmFeeOn:r.migrateCpmmFeeOn?r.migrateCpmmFeeOn:lm,supply:r.supply?r.supply:new Mn(0),totalSellA:r.totalSellA?r.totalSellA:new Mn(0),totalFundRaisingB:r.totalFundRaisingB?r.totalFundRaisingB:new Mn(0),totalLockedAmount:r.totalLockedAmount?r.totalLockedAmount:Tu,cliffPeriod:r.cliffPeriod?r.cliffPeriod:Tu,unlockPeriod:r.unlockPeriod?r.unlockPeriod:Tu},s,1),new wt({keys:i,programId:a,data:Buffer.from([...Tt.updatePlatformCurveParam,...s])})}function dL(a,e,t,n){let o=[{pubkey:e,isSigner:!0,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!0}],r=Buffer.alloc(_().span);return _().encode(n,r),new wt({keys:o,programId:a,data:Buffer.from([...Tt.removePlatformCurveParam,...r,1,2])})}import{NATIVE_MINT as vn,TOKEN_2022_PROGRAM_ID as eo,TOKEN_PROGRAM_ID as Ve,createAssociatedTokenAccountIdempotentInstruction as Ft,createSyncNativeInstruction as Sy,getTransferFeeConfig as bs,unpackMint as gs}from"@solana/spl-token";import ae from"bn.js";import{PublicKey as km,SystemProgram as Cy}from"@solana/web3.js";import $t from"bn.js";import Am from"decimal.js";import ls from"bn.js";import ar from"decimal.js";var Jn=class{static getPoolInitPriceByPool({poolInfo:e,decimalA:t,decimalB:n}){throw Error()}static getPoolInitPriceByInit({a:e,b:t,decimalA:n,decimalB:o}){throw Error()}static getPoolPrice({poolInfo:e,decimalA:t,decimalB:n}){throw Error()}static getPoolEndPrice({supply:e,totalSell:t,totalLockedAmount:n,totalFundRaising:o,migrateFee:r,decimalA:i,decimalB:s}){throw Error()}static getPoolEndPriceReal({poolInfo:e,decimalA:t,decimalB:n}){throw Error()}static getInitParam({supply:e,totalFundRaising:t,totalSell:n,totalLockedAmount:o,migrateFee:r}){throw Error()}static buyExactIn({poolInfo:e,amount:t}){throw Error()}static buyExactOut({poolInfo:e,amount:t}){throw Error()}static sellExactIn({poolInfo:e,amount:t}){throw Error()}static sellExactOut({poolInfo:e,amount:t}){throw Error()}};var ms=class extends Jn{static getPoolInitPriceByPool({poolInfo:e,decimalA:t,decimalB:n}){return new ar(e.virtualB.toString()).div(e.virtualA.toString()).mul(10**(t-n))}static getPoolInitPriceByInit({a:e,b:t,decimalA:n,decimalB:o}){return new ar(t.toString()).div(e.toString()).mul(10**(n-o))}static getPoolPrice({poolInfo:e,decimalA:t,decimalB:n}){return new ar(e.virtualB.add(e.realB).toString()).div(e.virtualA.sub(e.realA).toString()).mul(10**(t-n))}static getPoolEndPrice({supply:e,totalSell:t,totalLockedAmount:n,totalFundRaising:o,migrateFee:r,decimalA:i,decimalB:s}){return new ar(o.sub(r).toString()).div(e.sub(t).sub(n).toString()).mul(10**(i-s))}static getPoolEndPriceReal({poolInfo:e,decimalA:t,decimalB:n}){let o=e.totalSellA.sub(e.realA),r=e.totalFundRaisingB.sub(e.realB);return new ar(e.virtualB.add(e.realB.add(r)).toString()).div(e.virtualA.sub(e.realA.add(o)).toString()).mul(10**(t-n))}static getInitParam({supply:e,totalFundRaising:t,totalSell:n,totalLockedAmount:o,migrateFee:r}){if(e.lte(n))throw Error("supply need gt total sell");let i=e.sub(n).sub(o);if(i.lte(new ls(0)))throw Error("supplyMinusSellLocked <= 0");let s=t.sub(r);if(s.lte(new ls(0)))throw Error("tfMinusMf <= 0");let c=s.mul(n).mul(n).div(i),u=s.mul(n).div(i).sub(t),l=c.div(u),m=t.mul(t).div(u);if(l.lt(new ls(0))||m.lt(new ls(0)))throw Error("invalid input 0");return{a:l,b:m,c:n}}static buyExactIn({poolInfo:e,amount:t}){return this.getAmountOut({amountIn:t,inputReserve:e.virtualB.add(e.realB),outputReserve:e.virtualA.sub(e.realA)})}static buyExactOut({poolInfo:e,amount:t}){return this.getAmountIn({amountOut:t,inputReserve:e.virtualB.add(e.realB),outputReserve:e.virtualA.sub(e.realA)})}static sellExactIn({poolInfo:e,amount:t}){return this.getAmountOut({amountIn:t,inputReserve:e.virtualA.sub(e.realA),outputReserve:e.virtualB.add(e.realB)})}static sellExactOut({poolInfo:e,amount:t}){return this.getAmountIn({amountOut:t,inputReserve:e.virtualA.sub(e.realA),outputReserve:e.virtualB.add(e.realB)})}static getAmountOut({amountIn:e,inputReserve:t,outputReserve:n}){let o=e.mul(n),r=t.add(e);return o.div(r)}static getAmountIn({amountOut:e,inputReserve:t,outputReserve:n}){let o=t.mul(e),r=n.sub(e);return so(o,r)}};import ds from"bn.js";import ur from"decimal.js";var ps=class extends Jn{static getPoolInitPriceByPool({poolInfo:e,decimalA:t,decimalB:n}){return new ur(e.virtualB.toString()).div(e.virtualA.toString()).mul(10**(t-n))}static getPoolInitPriceByInit({a:e,b:t,decimalA:n,decimalB:o}){return new ur(t.toString()).div(e.toString()).mul(10**(n-o))}static getPoolPrice({poolInfo:e,decimalA:t,decimalB:n}){return new ur(e.virtualB.toString()).div(e.virtualA.toString()).mul(10**(t-n))}static getPoolEndPrice({supply:e,totalSell:t,totalLockedAmount:n,totalFundRaising:o,migrateFee:r,decimalA:i,decimalB:s}){return new ur(o.sub(r).toString()).div(e.sub(t).sub(n).toString()).mul(10**(i-s))}static getPoolEndPriceReal({poolInfo:e,decimalA:t,decimalB:n}){let o=e.totalSellA.sub(e.realA),r=e.totalFundRaisingB.sub(e.realB);return new ur(e.virtualB.add(e.realB).add(r).toString()).div(e.virtualA.sub(e.realA).add(o).toString()).mul(10**(t-n))}static getInitParam({supply:e,totalFundRaising:t,totalSell:n,totalLockedAmount:o,migrateFee:r}){let i=e.sub(o);if(i.lte(new ds(0)))throw Error("invalid input 1");let s=new ds(2).mul(t).sub(r),u=t.mul(i).div(s);if(u.lt(new ds(0))||t.lt(new ds(0)))throw Error("invalid input 0");return{a:u,b:t,c:u}}static buyExactIn({poolInfo:e,amount:t}){return this.getAmountOut({amountIn:t,initInput:e.virtualB,initOutput:e.virtualA})}static buyExactOut({poolInfo:e,amount:t}){return this.getAmountIn({amountOut:t,initInput:e.virtualB,initOutput:e.virtualA})}static sellExactIn({poolInfo:e,amount:t}){return this.getAmountOut({amountIn:t,initInput:e.virtualA,initOutput:e.virtualB})}static sellExactOut({poolInfo:e,amount:t}){return this.getAmountIn({amountOut:t,initInput:e.virtualA,initOutput:e.virtualB})}static getAmountOut({amountIn:e,initInput:t,initOutput:n}){return n.mul(e).div(t)}static getAmountIn({amountOut:e,initInput:t,initOutput:n}){let o=t.mul(e);return so(o,n)}};import vt from"bn.js";import Io from"decimal.js";import Zo from"bn.js";import fs from"decimal.js";var cr=class{static _multipler(e){return new fs(10).pow(e)}static getPrice({priceX64:e,decimalA:t,decimalB:n}){return new fs(e.toString()).div(this._Q64).mul(this._multipler(t)).div(this._multipler(n))}static getPriceX64({price:e,decimalA:t,decimalB:n}){let o=e.mul(this._multipler(n)).div(this._multipler(t));return new Zo(o.mul(this._Q64).toFixed(0))}};cr._Q64=new fs(new Zo(1).shln(64).toString());function CL({supply:a,totalFundRaisingB:e,totalLockedAmount:t,totalSellA:n,migrateType:o,decimalsA:r}){let i=a.sub(n).sub(t),s=new Zo(new fs(i.mul(e).toString()).sqrt().toFixed(0));if(o==="amm"){if(s.gt(new Zo(10).pow(new Zo(r))))return!0}else if(o==="cpmm"){if(s.gt(new Zo(100)))return!0}else throw Error("migrate type error");return!1}var ys=class extends Jn{static getPoolInitPriceByPool({poolInfo:e,decimalA:t,decimalB:n}){return new Io(0)}static getPoolInitPriceByInit({a:e,b:t,decimalA:n,decimalB:o}){return new Io(0)}static getPoolPrice({poolInfo:e,decimalA:t,decimalB:n}){return new Io(e.virtualA.mul(e.realA).toString()).div(cr._Q64).mul(10**(t-n))}static getPoolEndPrice({supply:e,totalSell:t,totalLockedAmount:n,totalFundRaising:o,migrateFee:r,decimalA:i,decimalB:s}){return new Io(o.sub(r).toString()).div(e.sub(t).sub(n).toString()).mul(10**(i-s))}static getPoolEndPriceReal({poolInfo:e,decimalA:t,decimalB:n}){let o=e.totalSellA.sub(e.realA),r=e.totalFundRaisingB.sub(e.realB);return new Io(e.virtualB.add(e.realB).add(r).toString()).div(e.virtualA.sub(e.realA).add(o).toString()).mul(10**(t-n))}static getInitParam({supply:e,totalFundRaising:t,totalSell:n,totalLockedAmount:o,migrateFee:r}){let i=e.sub(o);if(i.lte(new vt(0)))throw Error("supplyMinusLocked need gt 0");let s=t.mul(new vt(3)).sub(r),u=t.mul(new vt(2)).mul(i).div(s),l=u.mul(u),m=t.mul(new vt(2)).mul(st).div(l);if(!m.gt(new vt(0)))throw Error("a need gt 0");if(!Ri.gt(m))throw Error("a need lt u64 max");if(m.lt(new vt(0))||u.lt(new vt(0)))throw Error("invalid input 0");return{a:m,b:new vt(0),c:u}}static buyExactIn({poolInfo:e,amount:t}){let n=e.realB.add(t),o=new vt(2).mul(n).mul(st).div(e.virtualA);return new vt(new Io(o.toString()).sqrt().toFixed(0)).sub(e.realA)}static buyExactOut({poolInfo:e,amount:t}){let n=e.realA.add(t),o=n.mul(n);return so(e.virtualA.mul(o),new vt(2).mul(st)).sub(e.realB)}static sellExactIn({poolInfo:e,amount:t}){let n=e.realA.sub(t),o=n.mul(n),r=so(e.virtualA.mul(o),new vt(2).mul(st));return e.realB.sub(r)}static sellExactOut({poolInfo:e,amount:t}){let n=e.realB.sub(t),o=new vt(2).mul(n).mul(st).div(e.virtualA),r=new vt(new Io(o.toString()).sqrt().toFixed(0));return e.realA.sub(r)}};var Zt=class{static getPoolCurvePointByPoolInfo({curveType:e,pointCount:t,poolInfo:n}){return this.getPoolCurvePointByInit({curveType:e,pointCount:t,supply:n.supply,totalFundRaising:n.totalFundRaisingB,totalSell:n.totalSellA,totalLockedAmount:n.vestingSchedule.totalLockedAmount,migrateFee:n.migrateFee,decimalA:n.mintDecimalsA,decimalB:n.mintDecimalsB})}static getPoolCurvePointByInit({curveType:e,pointCount:t,supply:n,totalFundRaising:o,totalSell:r,totalLockedAmount:i,migrateFee:s,decimalA:c,decimalB:u}){if(t<3)throw Error("point count < 3");let l=this.getCurve(e),m=l.getInitParam({supply:n,totalFundRaising:o,totalSell:r,totalLockedAmount:i,migrateFee:s}),p=l.getPoolInitPriceByInit(q(M({},m),{decimalA:c,decimalB:u})),d=o.div(new $t(t-1)),f=new $t(0),y=[{price:p,totalSellSupply:0}],{a:b,b:g}=m,P=f,h=f;for(let I=1;I<t;I++){let T=I!==t-1?d:o.sub(h),w=this.buyExactIn({poolInfo:{virtualA:b,virtualB:g,realA:P,realB:h,totalFundRaisingB:o,totalSellA:r},amountB:T,protocolFeeRate:f,platformFeeRate:f,curveType:e,shareFeeRate:f,creatorFeeRate:f,transferFeeConfigA:void 0,slot:0});P=P.add(w.amountA.amount),h=h.add(w.amountB);let K=this.getPrice({poolInfo:{virtualA:b,virtualB:g,realA:P,realB:h},decimalA:c,decimalB:u,curveType:e});y.push({price:K,totalSellSupply:new Am(P.toString()).div(10**c).toNumber()})}return y}static getPoolInitPriceByPool({poolInfo:e,decimalA:t,decimalB:n,curveType:o}){return this.getCurve(o).getPoolInitPriceByPool({poolInfo:e,decimalA:t,decimalB:n})}static getPoolInitPriceByInit({a:e,b:t,decimalA:n,decimalB:o,curveType:r}){return this.getCurve(r).getPoolInitPriceByInit({a:e,b:t,decimalA:n,decimalB:o})}static getPrice({poolInfo:e,curveType:t,decimalA:n,decimalB:o}){return this.getCurve(t).getPoolPrice({poolInfo:e,decimalA:n,decimalB:o})}static getEndPrice({poolInfo:e,curveType:t,decimalA:n,decimalB:o}){return this.getCurve(t).getPoolPrice({poolInfo:e,decimalA:n,decimalB:o})}static getPoolEndPriceReal({poolInfo:e,curveType:t,decimalA:n,decimalB:o}){return this.getCurve(t).getPoolEndPriceReal({poolInfo:e,decimalA:n,decimalB:o})}static checkParam({supply:e,totalFundRaising:t,totalSell:n,totalLockedAmount:o,decimals:r,config:i,migrateType:s}){if(Number(r)!==6)throw Error("decimals = 6");if(e.mul(i.maxLockRate).div(Rt).lt(o))throw Error("total lock amount gte max lock amount");if(e.lt(i.minSupplyA.mul(new $t(10**r))))throw Error("supply lt min supply");let u=e.mul(i.minSellRateA).div(Rt);if(n.lt(u))throw Error("invalid input");if(t.lt(i.minFundRaisingB))throw Error("total fund raising lt min fund raising");let l=e.sub(n).sub(o),m=e.mul(i.minMigrateRateA).div(Rt);if(l.lt(m))throw Error("migrate lt min migrate amoount");let p=e.sub(n).sub(o),d=new $t(new Am(p.mul(t).toString()).sqrt().toFixed(0));if(s==="amm"){let f=new $t(10).pow(new $t(r));if(d.lte(f))throw Error("check migrate lp error")}else if(s==="cpmm"){let f=new $t(100);if(d.lte(f))throw Error("check migrate lp error")}else throw Error("migrate type error")}static buyExactIn({poolInfo:e,amountB:t,protocolFeeRate:n,platformFeeRate:o,curveType:r,shareFeeRate:i,creatorFeeRate:s,transferFeeConfigA:c,slot:u}){let l=this.totalFeeRate({protocolFeeRate:n,platformFeeRate:o,shareFeeRate:i,creatorFeeRate:s}),m=this.calculateFee({amount:t,feeRate:l}),p=t.sub(m),d=this.getCurve(r),f=d.buyExactIn({poolInfo:e,amount:p}),y=e.totalSellA.sub(e.realA),b,g,P;if(f.gt(y)){b=y;let I=d.buyExactOut({poolInfo:e,amount:b});g=this.calculatePreFee({postFeeAmount:I,feeRate:l}),P=g.sub(I)}else b=f,g=t,P=m;let h=this.splitFee({totalFee:P,protocolFeeRate:n,platformFeeRate:o,shareFeeRate:i,creatorFeeRate:s});return{amountA:Gs(b,c,u),amountB:g,splitFee:h}}static buyExactOut({poolInfo:e,amountA:t,protocolFeeRate:n,platformFeeRate:o,curveType:r,shareFeeRate:i,creatorFeeRate:s,transferFeeConfigA:c,slot:u}){let l=e.totalSellA.sub(e.realA),m=Xs(t,c,u),p=m.fee?m.amount.add(m.fee):m.amount;t.gt(l)&&(p=l);let f=this.getCurve(r).buyExactOut({poolInfo:e,amount:p}),y=this.totalFeeRate({protocolFeeRate:n,platformFeeRate:o,shareFeeRate:i,creatorFeeRate:s}),b=this.calculatePreFee({postFeeAmount:f,feeRate:y}),g=b.sub(f),P=this.splitFee({totalFee:g,protocolFeeRate:n,platformFeeRate:o,shareFeeRate:i,creatorFeeRate:s});return{amountA:m,amountB:b,splitFee:P}}static sellExactIn({poolInfo:e,amountA:t,protocolFeeRate:n,platformFeeRate:o,curveType:r,shareFeeRate:i,creatorFeeRate:s,transferFeeConfigA:c,slot:u}){let l=this.getCurve(r),m=Gs(t,c,u),p=m.fee?m.amount.sub(m.fee):m.amount,d=l.sellExactIn({poolInfo:e,amount:p}),f=this.calculateFee({amount:d,feeRate:this.totalFeeRate({protocolFeeRate:n,platformFeeRate:o,shareFeeRate:i,creatorFeeRate:s})}),y=this.splitFee({totalFee:f,protocolFeeRate:n,platformFeeRate:o,shareFeeRate:i,creatorFeeRate:s});return{amountA:m,amountB:d.sub(f),splitFee:y}}static sellExactOut({poolInfo:e,amountB:t,protocolFeeRate:n,platformFeeRate:o,curveType:r,shareFeeRate:i,creatorFeeRate:s,transferFeeConfigA:c,slot:u}){let l=this.totalFeeRate({protocolFeeRate:n,platformFeeRate:o,shareFeeRate:i,creatorFeeRate:s}),m=this.calculatePreFee({postFeeAmount:t,feeRate:l});if(e.realB.lt(m))throw Error("Insufficient liquidity");let p=m.sub(t),f=Zt.getCurve(r).sellExactOut({poolInfo:e,amount:m});if(f.gt(e.realA))throw Error();let y=this.splitFee({totalFee:p,protocolFeeRate:n,platformFeeRate:o,shareFeeRate:i,creatorFeeRate:s});return{amountA:Xs(f,c,u),amountB:t,splitFee:y}}static splitFee({totalFee:e,protocolFeeRate:t,platformFeeRate:n,shareFeeRate:o,creatorFeeRate:r}){let i=this.totalFeeRate({protocolFeeRate:t,platformFeeRate:n,shareFeeRate:o,creatorFeeRate:r}),s=i.isZero()?new $t(0):e.mul(n).div(i),c=i.isZero()?new $t(0):e.mul(o).div(i),u=i.isZero()?new $t(0):e.mul(r).div(i),l=e.sub(s).sub(c).sub(u);return{platformFee:s,shareFee:c,protocolFee:l,creatorFee:u}}static calculateFee({amount:e,feeRate:t}){return ri(e,t,Rt)}static calculatePreFee({postFeeAmount:e,feeRate:t}){if(t.isZero())return e;let n=e.mul(Rt),o=Rt.sub(t);return n.add(o).sub(new $t(1)).div(o)}static totalFeeRate({protocolFeeRate:e,platformFeeRate:t,shareFeeRate:n,creatorFeeRate:o}){if(e.add(t).add(n).add(o).gt(new $t(1e6)))throw Error("total fee rate gt 1_000_000");return e.add(t).add(n).add(o)}static getCurve(e){switch(e){case 0:return ms;case 1:return ps;case 2:return ys}throw Error("find curve error")}};import Ut from"decimal.js";var Bo={initPriceX64:new ae("515752397214619"),supply:new ae(1e15),totalSellA:new ae(7931e11),totalFundRaisingB:new ae(85e9),totalLockedAmount:new ae("0"),cliffPeriod:new ae("0"),unlockPeriod:new ae("0"),decimals:6,virtualA:new ae("1073471847374405"),virtualB:new ae("30050573465"),realA:new ae(0),realB:new ae(0),protocolFee:new ae(0),platformId:new km("4Bu96XjU84XjPDSpveTVf6LYGCkfW5FK7SNkREWcEfV4"),vestingSchedule:{totalLockedAmount:new ae(0),cliffPeriod:new ae(0),unlockPeriod:new ae(0),startTime:new ae(0),totalAllocatedShare:new ae(0)}},to=new ae(1e4),lr=class extends We{constructor(e){super(e)}async sayHello(){console.log("hello")}async createLaunchpad(v){var L=v,{programId:e=it,authProgramId:t,platformId:n=Bo.platformId,mintA:o,decimals:r=6,mintBDecimals:i=9,name:s,symbol:c,uri:u,migrateType:l,configId:m,snipers:p,configInfo:d,platformFeeRate:f,txVersion:y,computeBudgetConfig:b,txTipConfig:g,feePayer:P,buyAmount:h,minMintAAmount:I,slippage:T,associatedOnly:w=!0,checkCreateATAOwner:K=!1,extraSigners:x,token2022:S,transferFeeExtensionParams:B,creatorFeeOn:R=0}=L,C=_e(L,["programId","authProgramId","platformId","mintA","decimals","mintBDecimals","name","symbol","uri","migrateType","configId","snipers","configInfo","platformFeeRate","txVersion","computeBudgetConfig","txTipConfig","feePayer","buyAmount","minMintAAmount","slippage","associatedOnly","checkCreateATAOwner","extraSigners","token2022","transferFeeExtensionParams","creatorFeeOn"]);var Vt,dr,Ru,Lu,Ou,Nu,Mu,vu,Fu,Vu;let N=[],E=this.createTxBuilder(P);t=t!=null?t:yn(e).publicKey,S=!!B,S&&(l="cpmm");let X=d;if(!X&&m){let en=await this.scope.connection.getAccountInfo(m);en&&(X=Zn.decode(en.data))}X||this.logAndCreateError("config not found");let Q=X.mintB,ee=X.curveType,{publicKey:de}=jo(e,o,Q),{publicKey:re}=gu(e,de,o),{publicKey:ue}=gu(e,de,Q),{publicKey:ge}=xn(o);this.logDebug(`create token: ${o.toBase58()}, mintB: ${Q.toBase58()}, decimals A:${r}/B:${i}, config:${m.toBase58()}`),c.length>10&&this.logAndCreateError("Symbol length should shorter than 11"),u||this.logAndCreateError("uri should not empty");let pe=(Vt=C==null?void 0:C.supply)!=null?Vt:Bo.supply,oe=(dr=C==null?void 0:C.totalSellA)!=null?dr:Bo.totalSellA,Le=(Ru=C==null?void 0:C.totalFundRaisingB)!=null?Ru:Bo.totalFundRaisingB,ye=(Lu=C==null?void 0:C.totalLockedAmount)!=null?Lu:new ae(0),ot=f;if(!f){let en=await this.scope.connection.getAccountInfo(n);en||this.logAndCreateError("platform id not found:",n.toString()),ot=$o.decode(en.data).feeRate}let cn=Zt.getCurve(X.curveType).getInitParam({supply:pe,totalFundRaising:Le,totalSell:oe,totalLockedAmount:ye,migrateFee:X.migrateFee}),Me={epoch:new ae(896),bump:254,status:0,mintDecimalsA:r,mintDecimalsB:i,supply:pe,totalSellA:oe,mintA:new km(o),mintB:Q,virtualA:cn.a,virtualB:cn.b,realA:Bo.realA,realB:Bo.realB,migrateFee:X.migrateFee,migrateType:l==="amm"?0:1,protocolFee:Bo.protocolFee,platformFee:ot,platformId:n,configId:m,vaultA:re,vaultB:ue,creator:this.scope.ownerPubKey,totalFundRaisingB:Le,vestingSchedule:{totalLockedAmount:ye,cliffPeriod:new ae(0),unlockPeriod:new ae(0),startTime:new ae(0),totalAllocatedShare:new ae(0)},mintProgramFlag:S?1:0,cpmmCreatorFeeOn:R},Jo=Zt.getCurve(X.curveType),{c:As}=Jo.getInitParam({supply:Me.supply,totalFundRaising:Me.totalFundRaisingB,totalLockedAmount:ye,totalSell:X.curveType===0?Me.totalSellA:new ae(0),migrateFee:X.migrateFee});try{Zt.checkParam({supply:Me.supply,totalFundRaising:Me.totalFundRaisingB,totalSell:As,totalLockedAmount:ye,decimals:Me.mintDecimalsA,config:X,migrateType:l}),this.logDebug("check init params success")}catch(en){this.logAndCreateError(`check create mint params failed, ${en.message}`)}E.addInstruction({instructions:[S?dm(e,P!=null?P:this.scope.ownerPubKey,this.scope.ownerPubKey,m,n,t,de,o,Q,re,ue,r,s,c,u||"https://",{type:ee===0?"ConstantCurve":ee===1?"FixedCurve":ee===2?"LinearCurve":"ConstantCurve",totalSellA:oe,migrateType:l,supply:pe,totalFundRaisingB:Le},ye,(Ou=C==null?void 0:C.cliffPeriod)!=null?Ou:new ae(0),(Nu=C==null?void 0:C.unlockPeriod)!=null?Nu:new ae(0),R,B):mm(e,P!=null?P:this.scope.ownerPubKey,this.scope.ownerPubKey,m,n,t,de,o,Q,re,ue,ge,r,s,c,u||"https://",{type:ee===0?"ConstantCurve":ee===1?"FixedCurve":ee===2?"LinearCurve":"ConstantCurve",totalSellA:oe,migrateType:l,supply:pe,totalFundRaisingB:Le},ye,(Mu=C==null?void 0:C.cliffPeriod)!=null?Mu:new ae(0),(vu=C==null?void 0:C.unlockPeriod)!=null?vu:new ae(0),R)]});let ei=S?await this.scope.connection.getEpochInfo():void 0,Jt=B?{epoch:BigInt((ei==null?void 0:ei.epoch)||0),maximumFee:BigInt((Fu=B==null?void 0:B.maxinumFee.toString())!=null?Fu:0),transferFeeBasisPoints:(Vu=B==null?void 0:B.transferFeeBasePoints)!=null?Vu:0}:void 0,Ko={amountA:{amount:new ae(0),fee:void 0,expirationTime:void 0},amountB:new ae(0),splitFee:{platformFee:new ae(0),shareFee:new ae(0),protocolFee:new ae(0),creatorFee:new ae(0)}},So;if(x!=null&&x.length&&E.addInstruction({signers:x}),!C.createOnly){let{builder:en,extInfo:wm}=await this.buyToken({programId:e,authProgramId:t,mintAProgram:S?eo:void 0,mintA:o,mintB:Q,poolInfo:Me,buyAmount:h,minMintAAmount:I,shareFeeRate:C.shareFeeRate,shareFeeReceiver:C.shareFeeReceiver,configInfo:X,platformFeeRate:ot,slippage:T,txTipConfig:g,associatedOnly:w,checkCreateATAOwner:K,skipCheckMintA:!Jt,transferFeeConfigA:Jt?{transferFeeConfigAuthority:t,withdrawWithheldAuthority:t,withheldAmount:BigInt(0),olderTransferFee:Jt,newerTransferFee:Jt}:void 0,fromCreate:!0});console.log("PREPARING SNIPER TRANSACTIONS");for(let _u of p){let{builder:Tm,extInfo:Ny}=await this.buyToken({programId:e,authProgramId:t,mintAProgram:S?eo:void 0,mintA:o,mintB:Q,poolInfo:Me,buyAmount:_u.amount,minMintAAmount:I,shareFeeRate:C.shareFeeRate,shareFeeReceiver:C.shareFeeReceiver,configInfo:X,platformFeeRate:ot,slippage:T,sniper:_u,associatedOnly:w,checkCreateATAOwner:K,skipCheckMintA:!Jt,transferFeeConfigA:Jt?{transferFeeConfigAuthority:t,withdrawWithheldAuthority:t,withheldAmount:BigInt(0),olderTransferFee:Jt,newerTransferFee:Jt}:void 0,fromCreate:!0});N.push(q(M({},Tm.AllTxData),{blockHash:this.scope.blockhashCommitment}))}E.addInstruction(M({},en.AllTxData)),Ko=M({},wm),So=(this.scope.cluster==="devnet"||y===1)&&C.shareFeeReceiver?[en.allInstructions[0]]:void 0}return E.addTipInstruction(g),y===0?(console.log("VERSION V0"),{tx:await E.sizeCheckBuildV0({computeBudgetConfig:b,swapInfo:Ko,splitIns:So,address:q(M({},Me),{poolId:de})}),txs:N}):(console.log("VERSION PLAIN"),{tx:await E.sizeCheckBuild({computeBudgetConfig:b,swapInfo:Ko,splitIns:So,address:q(M({},Me),{poolId:de})}),txs:N})}async buyToken({programId:e=it,authProgramId:t,mintA:n,mintAProgram:o=Ve,mintB:r=vn,poolInfo:i,configInfo:s,platformFeeRate:c,txVersion:u,computeBudgetConfig:l,txTipConfig:m,feePayer:p,buyAmount:d,minMintAAmount:f,slippage:y,shareFeeRate:b=new ae(0),shareFeeReceiver:g,sniper:P,associatedOnly:h=!0,checkCreateATAOwner:I=!1,fromCreate:T=!1,transferFeeConfigA:w,skipCheckMintA:K=!1}){var pe,oe,Le;d.lte(new ae(0))&&this.logAndCreateError("buy amount should gt 0:",d.toString());let x=P?this.createSniperTxBuilder(P.owner,P.owner.publicKey):this.createTxBuilder(p),{publicKey:S}=jo(e,n,r);t=t!=null?t:yn(e).publicKey;let B=w;if(!K)if(B)o=eo;else{let ye=await this.scope.connection.getAccountInfo(n);if(ye&&ye.owner.equals(eo)){o=ye.owner;let ot=gs(n,ye,o);B=bs(ot)||void 0}}let R=P?this.scope.account.getAssociatedTokenAccountByOwner(P.owner.publicKey,n,o):this.scope.account.getAssociatedTokenAccount(n,o),C=T?this.scope.account.getAssociatedTokenAccount(r,Ve):null,v=r.equals(vn);if(console.log("userTokenAccountA: ",R),console.log("mintAProgram: ",o),x.addInstruction({instructions:[Ft((P==null?void 0:P.owner.publicKey)||this.scope.ownerPubKey,R,(P==null?void 0:P.owner.publicKey)||this.scope.ownerPubKey,n,o),...T?[Ft(this.scope.ownerPubKey,C,this.scope.ownerPubKey,r,Ve),Cy.transfer({fromPubkey:this.scope.ownerPubKey,toPubkey:C,lamports:BigInt(d.toString())}),Sy(C)]:[]]}),!T){let{account:ye,instructionParams:ot}=await this.scope.account.getOrCreateTokenAccount({mint:r,owner:this.scope.ownerPubKey,createInfo:v?{payer:this.scope.ownerPubKey,amount:d}:void 0,skipCloseAccount:!v,notUseTokenAccount:v,associatedOnly:v?!1:h,checkCreateATAOwner:I});ye&&(C=ye),x.addInstruction(ot||{})}C===void 0&&this.logAndCreateError(`cannot found mintB(${r.toBase58()}) token accounts`,"tokenAccounts",this.scope.account.tokenAccounts);let L=i;if(!L){let ye=await this.scope.connection.getAccountInfo(S,{commitment:"processed"});ye||this.logAndCreateError("cannot found pool:",S.toBase58()),L=un.decode(ye.data)}let N=s,E=await ve(this.scope.connection,[N?void 0:L.configId,L.platformId].filter(Boolean).map(ye=>({pubkey:ye})));if(!N){let ye=E.find(ot=>ot.pubkey.equals(L.configId));(!ye||!ye.accountInfo)&&this.logAndCreateError("config not found: ",L.configId.toBase58()),N=Zn.decode(ye.accountInfo.data)}let X=E.find(ye=>ye.pubkey.equals(L.platformId));(!X||!X.accountInfo)&&this.logAndCreateError("platform info not found: ",L.configId.toBase58());let Q=$o.decode(X.accountInfo.data);c=c||Q.feeRate;let ee=Zt.buyExactIn({poolInfo:L,amountB:d,protocolFeeRate:N.tradeFeeRate,platformFeeRate:c,curveType:N.curveType,shareFeeRate:b,creatorFeeRate:Q.creatorFeeRate,transferFeeConfigA:B,slot:await this.scope.connection.getSlot()}),de=new Ut(ee.amountA.amount.toString()).sub((oe=(pe=ee.amountA.fee)==null?void 0:pe.toString())!=null?oe:0),re=y?new Ut(to.sub(y).toNumber()/to.toNumber()).clampedTo(0,1):new Ut(1),ue=f!=null?f:y?new ae(de.mul(re).toFixed(0)):ee.amountA.amount.sub((Le=ee.amountA.fee)!=null?Le:new ae(0));ee.amountB.lt(d)&&console.log(`maximum ${n.toBase58()} amount can buy is ${ee.amountA.toString()}, input ${r.toBase58()} amount: ${ee.amountB.toString()}`);let ge=g?j(g,r,Ve).publicKey:void 0;return ge&&x.addInstruction({instructions:[Ft((P==null?void 0:P.owner.publicKey)||this.scope.ownerPubKey,ge,g,r)]}),x.addInstruction({instructions:[pm(e,(P==null?void 0:P.owner.publicKey)||this.scope.ownerPubKey,t,L.configId,L.platformId,S,R,C,L.vaultA,L.vaultB,n,r,o,Ve,To(e,L.platformId,r).publicKey,ho(e,L.creator,r).publicKey,ee.amountB.lt(d)?ee.amountB:d,ue,b,ge)]}),x.addCustomComputeBudget(l),console.log("Adding Tip Config: ",m),x.addTipInstruction(m),x.versionBuild({txVersion:u,extInfo:q(M({},ee),{decimalOutAmount:de,minDecimalOutAmount:new Ut(ue.toString())})})}async buyTokenExactOut({programId:e=it,authProgramId:t,mintA:n,mintAProgram:o=Ve,mintB:r=vn,poolInfo:i,configInfo:s,transferFeeConfigA:c,platformFeeRate:u,txVersion:l,computeBudgetConfig:m,txTipConfig:p,feePayer:d,maxBuyAmount:f,outAmount:y,slippage:b,shareFeeRate:g=new ae(0),shareFeeReceiver:P,associatedOnly:h=!0,checkCreateATAOwner:I=!1,skipCheckMintA:T=!1}){y.lte(new ae(0))&&this.logAndCreateError("out amount should gt 0:",y.toString());let w=this.createTxBuilder(d),{publicKey:K}=jo(e,n,r);t=t!=null?t:yn(e).publicKey;let x=i;if(!x){let pe=await this.scope.connection.getAccountInfo(K,{commitment:"processed"});pe||this.logAndCreateError("cannot found pool:",K.toBase58()),x=un.decode(pe.data)}let S=s,B=await ve(this.scope.connection,[S?void 0:x.configId,x.platformId].filter(Boolean).map(pe=>({pubkey:pe})));if(!S){let pe=B.find(oe=>oe.pubkey.equals(x.configId));(!pe||!pe.accountInfo)&&this.logAndCreateError("config not found: ",x.configId.toBase58()),S=Zn.decode(pe.accountInfo.data)}let R=B.find(pe=>pe.pubkey.equals(x.platformId));(!R||!R.accountInfo)&&this.logAndCreateError("platform info not found: ",x.configId.toBase58());let C=$o.decode(R.accountInfo.data);u=u||C.feeRate;let v=c;if(!T)if(v)o=eo;else{let pe=await this.scope.connection.getAccountInfo(n);if(pe&&pe.owner.equals(eo)){o=pe.owner;let oe=gs(n,pe,o);v=bs(oe)||void 0}}let L=Zt.buyExactOut({poolInfo:x,amountA:y,protocolFeeRate:S.tradeFeeRate,platformFeeRate:u,curveType:S.curveType,shareFeeRate:g,creatorFeeRate:C.creatorFeeRate,transferFeeConfigA:v,slot:await this.scope.connection.getSlot()}),N=new Ut(L.amountB.toString()),E=b?new Ut(to.add(b).toNumber()/to.toNumber()).clampedTo(0,Number.MIN_SAFE_INTEGER):new Ut(1),X=(f!=null?f:b)?new ae(N.mul(E).toFixed(0)):L.amountB,Q=this.scope.account.getAssociatedTokenAccount(n,o),ee=null,de=r.equals(vn);w.addInstruction({instructions:[Ft(this.scope.ownerPubKey,Q,this.scope.ownerPubKey,n,o)]});let{account:re,instructionParams:ue}=await this.scope.account.getOrCreateTokenAccount({mint:r,owner:this.scope.ownerPubKey,createInfo:de?{payer:this.scope.ownerPubKey,amount:L.amountB}:void 0,skipCloseAccount:!de,notUseTokenAccount:de,associatedOnly:de?!1:h,checkCreateATAOwner:I});re&&(ee=re),w.addInstruction(ue||{}),ee===void 0&&this.logAndCreateError(`cannot found mintB(${r.toBase58()}) token accounts`,"tokenAccounts",this.scope.account.tokenAccounts);let ge=P?j(P,r,Ve).publicKey:void 0;return ge&&w.addInstruction({instructions:[Ft(this.scope.ownerPubKey,ge,P,r)]}),w.addInstruction({instructions:[fm(e,this.scope.ownerPubKey,t,x.configId,x.platformId,K,Q,ee,x.vaultA,x.vaultB,n,r,o,Ve,To(e,x.platformId,r).publicKey,ho(e,x.creator,r).publicKey,y,X,g,ge)]}),w.addCustomComputeBudget(m),w.addTipInstruction(p),w.versionBuild({txVersion:l,extInfo:{maxSpentAmount:X,outAmount:y}})}async sellToken({programId:e=it,authProgramId:t,mintAProgram:n=Ve,mintA:o,mintB:r=vn,poolInfo:i,configInfo:s,platformFeeRate:c,txVersion:u,computeBudgetConfig:l,txTipConfig:m,feePayer:p,sellAmount:d,minAmountB:f,slippage:y,shareFeeRate:b=new ae(0),shareFeeReceiver:g,associatedOnly:P=!0,checkCreateATAOwner:h=!1,skipCheckMintA:I=!1}){t=t!=null?t:yn(e).publicKey;let T=this.createTxBuilder(p);d.lte(new ae(0))&&this.logAndCreateError("sell amount should be gt 0");let{publicKey:w}=jo(e,o,r),K;if(!I){let oe=await this.scope.connection.getAccountInfo(o);if(oe&&oe.owner.equals(eo)){n=oe.owner;let Le=gs(o,oe,n);K=bs(Le)||void 0}}let x=null,S=null,B=r.equals(vn),{account:R,instructionParams:C}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:n,mint:o,owner:this.scope.ownerPubKey,createInfo:void 0,skipCloseAccount:!0,notUseTokenAccount:!1,associatedOnly:P,checkCreateATAOwner:h});R&&(x=R),T.addInstruction(C||{}),x===void 0&&this.logAndCreateError("cannot found mintA token accounts","tokenAccounts",this.scope.account.tokenAccounts);let{account:v,instructionParams:L}=await this.scope.account.getOrCreateTokenAccount({mint:r,owner:this.scope.ownerPubKey,createInfo:B?{payer:this.scope.ownerPubKey,amount:0}:void 0,skipCloseAccount:!B,notUseTokenAccount:B,associatedOnly:B?!1:P,checkCreateATAOwner:h});v&&(S=v),T.addInstruction(L||{}),S===void 0&&this.logAndCreateError("cannot found mintB token accounts","tokenAccounts",this.scope.account.tokenAccounts);let N=i;if(!N){let oe=await this.scope.connection.getAccountInfo(w,{commitment:"processed"});oe||this.logAndCreateError("cannot found pool",w.toBase58()),N=un.decode(oe.data)}let E=s,X=await ve(this.scope.connection,[E?void 0:N.configId,N.platformId].filter(Boolean).map(oe=>({pubkey:oe})));if(!E){let oe=X.find(Le=>Le.pubkey.equals(N.configId));(!oe||!oe.accountInfo)&&this.logAndCreateError("config not found: ",N.configId.toBase58()),E=Zn.decode(oe.accountInfo.data)}let Q=X.find(oe=>oe.pubkey.equals(N.platformId));(!Q||!Q.accountInfo)&&this.logAndCreateError("platform info not found: ",N.configId.toBase58());let ee=$o.decode(Q.accountInfo.data);c=c||ee.feeRate;let de=Zt.sellExactIn({poolInfo:N,amountA:d,protocolFeeRate:E.tradeFeeRate,platformFeeRate:c,curveType:E.curveType,shareFeeRate:b,creatorFeeRate:ee.creatorFeeRate,transferFeeConfigA:K,slot:await this.scope.connection.getSlot()}),re=new Ut(de.amountB.toString()),ue=y?new Ut(to.sub(y).toNumber()/to.toNumber()).clampedTo(0,1):new Ut(1),ge=f!=null?f:y?new ae(re.mul(ue).toFixed(0)):de.amountB;ge.lte(new ae(0))&&this.logAndCreateError(`out ${r.toBase58()} amount should be gt 0`);let pe=g?j(g,r,Ve).publicKey:void 0;return pe&&T.addInstruction({instructions:[Ft(this.scope.ownerPubKey,pe,g,r)]}),T.addInstruction({instructions:[ym(e,this.scope.ownerPubKey,t,N.configId,N.platformId,w,x,S,N.vaultA,N.vaultB,o,r,n,Ve,To(e,N.platformId,r).publicKey,ho(e,N.creator,r).publicKey,de.amountA.amount.lt(d)?de.amountA.amount:d,ge,b,pe)]}),T.addCustomComputeBudget(l),T.addTipInstruction(m),T.versionBuild({txVersion:u,extInfo:{outAmount:ge}})}async sellTokenExactOut({programId:e=it,authProgramId:t,mintAProgram:n=Ve,mintA:o,mintB:r=vn,poolInfo:i,configInfo:s,platformFeeRate:c,txVersion:u,computeBudgetConfig:l,txTipConfig:m,feePayer:p,inAmount:d,maxSellAmount:f,slippage:y,shareFeeRate:b=new ae(0),shareFeeReceiver:g,associatedOnly:P=!0,checkCreateATAOwner:h=!1,skipCheckMintA:I=!1}){t=t!=null?t:yn(e).publicKey;let T=this.createTxBuilder(p);f!=null&&f.lte(new ae(0))&&this.logAndCreateError("max sell amount should be gt 0");let{publicKey:w}=jo(e,o,r),K;if(!I){let oe=await this.scope.connection.getAccountInfo(o);if(oe&&oe.owner.equals(eo)){n=oe.owner;let Le=gs(o,oe,n);K=bs(Le)||void 0}}let x=null,S=null,B=r.equals(vn),{account:R,instructionParams:C}=await this.scope.account.getOrCreateTokenAccount({tokenProgram:n,mint:o,owner:this.scope.ownerPubKey,createInfo:void 0,skipCloseAccount:!0,notUseTokenAccount:!1,associatedOnly:P,checkCreateATAOwner:h});R&&(x=R),T.addInstruction(C||{}),x===void 0&&this.logAndCreateError("cannot found mintA token accounts","tokenAccounts",this.scope.account.tokenAccounts);let{account:v,instructionParams:L}=await this.scope.account.getOrCreateTokenAccount({mint:r,owner:this.scope.ownerPubKey,createInfo:B?{payer:this.scope.ownerPubKey,amount:0}:void 0,skipCloseAccount:!B,notUseTokenAccount:B,associatedOnly:B?!1:P,checkCreateATAOwner:h});v&&(S=v),T.addInstruction(L||{}),S===void 0&&this.logAndCreateError("cannot found mintB token accounts","tokenAccounts",this.scope.account.tokenAccounts);let N=i;if(!N){let oe=await this.scope.connection.getAccountInfo(w,{commitment:"processed"});oe||this.logAndCreateError("cannot found pool",w.toBase58()),N=un.decode(oe.data)}let E=s,X=await ve(this.scope.connection,[E?void 0:N.configId,N.platformId].filter(Boolean).map(oe=>({pubkey:oe})));if(!E){let oe=X.find(Le=>Le.pubkey.equals(N.configId));(!oe||!oe.accountInfo)&&this.logAndCreateError("config not found: ",N.configId.toBase58()),E=Zn.decode(oe.accountInfo.data)}let Q=X.find(oe=>oe.pubkey.equals(N.platformId));(!Q||!Q.accountInfo)&&this.logAndCreateError("platform info not found: ",N.configId.toBase58());let ee=$o.decode(Q.accountInfo.data);c=c||ee.feeRate;let de=Zt.sellExactOut({poolInfo:N,amountB:d,protocolFeeRate:E.tradeFeeRate,platformFeeRate:c,curveType:E.curveType,shareFeeRate:b,creatorFeeRate:ee.creatorFeeRate,transferFeeConfigA:K,slot:await this.scope.connection.getSlot()}),re=new Ut(de.amountA.amount.toString()),ue=y?new Ut(to.add(y).toNumber()/to.toNumber()).clampedTo(0,Number.MAX_SAFE_INTEGER):new Ut(1),ge=(f!=null?f:y)?new ae(re.mul(ue).toFixed(0)):de.amountA.amount,pe=g?j(g,r,Ve).publicKey:void 0;return pe&&T.addInstruction({instructions:[Ft(this.scope.ownerPubKey,pe,g,r)]}),T.addInstruction({instructions:[bm(e,this.scope.ownerPubKey,t,N.configId,N.platformId,w,x,S,N.vaultA,N.vaultB,o,r,n,Ve,To(e,N.platformId,r).publicKey,ho(e,N.creator,r).publicKey,d,ge,b,pe)]}),T.addCustomComputeBudget(l),T.addTipInstruction(m),T.versionBuild({txVersion:u,extInfo:{maxSellAmount:ge}})}async createPlatformConfig({programId:e=it,platformAdmin:t,platformClaimFeeWallet:n,platformLockNftWallet:o,cpConfigId:r,migrateCpLockNftScale:i,transferFeeExtensionAuth:s,creatorFeeRate:c,feeRate:u,name:l,web:m,img:p,txVersion:d,computeBudgetConfig:f,txTipConfig:y,feePayer:b}){let g=this.createTxBuilder(b),{publicKey:P}=Pu(e,t);return g.addInstruction({instructions:[gm(e,t,n,o,P,r,s,i,u,c,l,m,p)]}),g.addCustomComputeBudget(f),g.addTipInstruction(y),g.versionBuild({txVersion:d,extInfo:{platformId:P}})}async updatePlatformConfig({programId:e=it,platformAdmin:t,platformId:n,updateInfo:o,txVersion:r,computeBudgetConfig:i,txTipConfig:s,feePayer:c}){let u=this.createTxBuilder(c),l=n!=null?n:Pu(e,t).publicKey;return u.addInstruction({instructions:[Pm(e,t,l,o)]}),u.addCustomComputeBudget(i),u.addTipInstruction(s),u.versionBuild({txVersion:r})}async claimPlatformFee({programId:e=it,authProgramId:t,platformId:n,poolId:o,platformClaimFeeWallet:r,mintB:i,vaultB:s,mintBProgram:c=Ve,txVersion:u,computeBudgetConfig:l,txTipConfig:m,feePayer:p}){var g;let d=this.createTxBuilder(p);t=t!=null?t:yn(e).publicKey;let f=i,y=s;if(!f){let P=await this.scope.connection.getAccountInfo(o,{commitment:"processed"});P||this.logAndCreateError("cannot found pool:",o.toBase58());let h=un.decode(P.data),I=await this.scope.connection.getAccountInfo(h.configId,{commitment:"processed"});I||this.logAndCreateError("cannot found config:",h.configId.toBase58()),f=Zn.decode(I.data).mintB,y=y!=null?y:h.vaultB}(!f||!y)&&this.logAndCreateError("cannot found mint info, mintB: ",f.toBase58(),", vaultB: ",(g=y==null?void 0:y.toBase58())!=null?g:"");let b=j(this.scope.ownerPubKey,f,Ve).publicKey;return d.addInstruction({instructions:[Ft(this.scope.ownerPubKey,b,this.scope.ownerPubKey,f)]}),d.addInstruction({instructions:[Bu(e,r,t,o,n,y,b,f,c)]}),d.addCustomComputeBudget(l),d.addTipInstruction(m),d.versionBuild({txVersion:u})}async claimAllPlatformFee({programId:e=it,authProgramId:t,platformId:n,platformClaimFeeWallet:o,txVersion:r,computeBudgetConfig:i,txTipConfig:s,feePayer:c}){let u=this.createTxBuilder(c);return t=t!=null?t:yn(e).publicKey,(await this.scope.connection.getProgramAccounts(e,{filters:[{dataSize:un.span},{memcmp:{offset:un.offsetOf("platformId"),bytes:n.toString()}}]})).forEach(m=>{let p=un.decode(m.account.data);if(p.platformFee.lte(new ae(0)))return;let d=j(this.scope.ownerPubKey,p.mintB,Ve).publicKey;u.addInstruction({instructions:[Ft(this.scope.ownerPubKey,d,this.scope.ownerPubKey,p.mintB)]}),u.addInstruction({instructions:[Bu(e,o,t,m.pubkey,n,p.vaultB,d,p.mintB,Ve)]})}),u.addTipInstruction(s),r===0?u.sizeCheckBuildV0({computeBudgetConfig:i}):u.sizeCheckBuild({computeBudgetConfig:i})}async createVesting({programId:e=it,poolId:t,beneficiary:n,shareAmount:o,txVersion:r,computeBudgetConfig:i,txTipConfig:s,feePayer:c}){let u=this.createTxBuilder(c),l=await this.getRpcPoolInfo({poolId:t});o.add(l.vestingSchedule.totalAllocatedShare).gt(l.vestingSchedule.totalLockedAmount)&&this.logAndCreateError("share amount exceed total locked amount");let m=rr(e,t,n).publicKey;return u.addInstruction({instructions:[Iu(e,this.scope.ownerPubKey,n,t,m,o)]}),u.addCustomComputeBudget(i),u.addTipInstruction(s),u.versionBuild({txVersion:r})}async createMultipleVesting({programId:e=it,poolId:t,beneficiaryList:n,txVersion:o,computeBudgetConfig:r,feePayer:i}){let s=this.createTxBuilder(i);n.length===0&&this.logAndCreateError("beneficiaryList is null");let c=await this.getRpcPoolInfo({poolId:t});return n.reduce((l,m)=>l.add(m.shareAmount),c.vestingSchedule.totalAllocatedShare).gt(c.vestingSchedule.totalLockedAmount)&&this.logAndCreateError("share amount exceed total locked amount"),n.forEach(l=>{let m=rr(e,t,l.wallet).publicKey;s.addInstruction({instructions:[Iu(e,this.scope.ownerPubKey,l.wallet,t,m,l.shareAmount)]})}),o===0?s.sizeCheckBuildV0({computeBudgetConfig:r}):s.sizeCheckBuild({computeBudgetConfig:r})}async claimVesting({programId:e=it,poolId:t,poolInfo:n,vestingRecord:o,txVersion:r,computeBudgetConfig:i,txTipConfig:s,feePayer:c}){let u=this.createTxBuilder(c),l=yn(e).publicKey,m=o||rr(e,t,this.scope.ownerPubKey).publicKey,p=n;if(!p){let f=await this.scope.connection.getAccountInfo(t);f||this.logAndCreateError("pool not found"),p=un.decode(f.data)}let d=j(this.scope.ownerPubKey,p.mintA,Ve).publicKey;return u.addInstruction({instructions:[Ft(this.scope.ownerPubKey,d,this.scope.ownerPubKey,p.mintA)]}),u.addInstruction({instructions:[hu(e,this.scope.ownerPubKey,l,t,m,d,p.vaultA,p.mintA,Ve)]}),u.addCustomComputeBudget(i),u.addTipInstruction(s),u.versionBuild({txVersion:r})}async claimMultiVesting({programId:e=it,poolIdList:t,poolsInfo:n={},vestingRecords:o={},txVersion:r,computeBudgetConfig:i,feePayer:s}){let c=this.createTxBuilder(s),u=M({},n),l=yn(e).publicKey,m=t.filter(p=>!u[p.toBase58()]);if(m.length){let p=await this.getRpcPoolsInfo({poolIdList:m});u=M(M({},u),p.poolInfoMap)}return t.forEach(p=>{let d=p.toBase58(),f=u[d];f||this.logAndCreateError(`pool info not found: ${d}`);let y=o[d]||rr(e,p,this.scope.ownerPubKey).publicKey,b=j(this.scope.ownerPubKey,f.mintA,Ve).publicKey;c.addInstruction({instructions:[Ft(this.scope.ownerPubKey,b,this.scope.ownerPubKey,f.mintA)]}),c.addInstruction({instructions:[hu(e,this.scope.ownerPubKey,l,p,y,b,f.vaultA,f.mintA,Ve)]})}),r===0?c.sizeCheckBuildV0({computeBudgetConfig:i}):c.sizeCheckBuild({computeBudgetConfig:i})}async claimVaultPlatformFee({programId:e=it,platformId:t,mintB:n,mintBProgram:o=Ve,claimFeeWallet:r,txVersion:i,computeBudgetConfig:s,txTipConfig:c,feePayer:u}){let l=this.createTxBuilder(u),m=To(e,t,n).publicKey,p=Au(e).publicKey,d=this.scope.account.getAssociatedTokenAccount(n,o);return l.addInstruction({instructions:[Ft(this.scope.ownerPubKey,d,this.scope.ownerPubKey,n,o),xu(e,t,r!=null?r:this.scope.ownerPubKey,p,m,d,n,o)]}),l.addCustomComputeBudget(s),l.addTipInstruction(c),l.versionBuild({txVersion:i})}async claimMultipleVaultPlatformFee({programId:e=it,platformList:t,unwrapSol:n=!0,txVersion:o,computeBudgetConfig:r,feePayer:i,associatedOnly:s=!0,checkCreateATAOwner:c=!1}){let u=this.createTxBuilder(i),l={};return t.forEach(async m=>{var b,g;let p=Au(e).publicKey,d=To(e,m.id,m.mintB).publicKey,f=m.mintB.equals(vn)&&n,y=l[m.mintB.toBase58()];if(!y){let{account:P,instructionParams:h}=await this.scope.account.getOrCreateTokenAccount({mint:m.mintB,owner:this.scope.ownerPubKey,createInfo:f?{payer:this.scope.ownerPubKey,amount:0}:void 0,skipCloseAccount:!f,notUseTokenAccount:f,associatedOnly:f?!1:s,checkCreateATAOwner:c});P&&(y=P),u.addInstruction(h||{}),y===void 0&&this.logAndCreateError(`cannot found platform ${m.id.toBase58()} mintB(${m.mintB.toBase58()}) token accounts`,"tokenAccounts",this.scope.account.tokenAccounts)}u.addInstruction({instructions:[xu(e,m.id,(b=m.claimFeeWallet)!=null?b:this.scope.ownerPubKey,d,p,y,m.mintB,(g=m.mintBProgram)!=null?g:Ve)]})}),o===0?u.sizeCheckBuildV0({computeBudgetConfig:r}):u.sizeCheckBuild({computeBudgetConfig:r})}async claimCreatorFee({programId:e=it,mintB:t,mintBProgram:n=Ve,txVersion:o,computeBudgetConfig:r,txTipConfig:i,feePayer:s}){let c=this.createTxBuilder(s),u=ho(e,this.scope.ownerPubKey,t).publicKey,l=ku(e).publicKey,m=this.scope.account.getAssociatedTokenAccount(t,n);return c.addInstruction({instructions:[Ft(this.scope.ownerPubKey,m,this.scope.ownerPubKey,t,n),Ku(e,this.scope.ownerPubKey,l,u,m,t,n)]}),c.addCustomComputeBudget(r),c.addTipInstruction(i),c.versionBuild({txVersion:o})}async claimMultipleCreatorFee({programId:e=it,mintBList:t,txVersion:n,computeBudgetConfig:o,feePayer:r}){let i=this.createTxBuilder(r);return t.forEach(s=>{var d;let c=s.pubKey,u=(d=s.programId)!=null?d:Ve,l=ho(e,this.scope.ownerPubKey,c).publicKey,m=ku(e).publicKey,p=this.scope.account.getAssociatedTokenAccount(c,u);i.addInstruction({instructions:[Ft(this.scope.ownerPubKey,p,this.scope.ownerPubKey,c,u),Ku(e,this.scope.ownerPubKey,m,l,p,c,u)]})}),n==0?i.sizeCheckBuildV0({computeBudgetConfig:o}):i.sizeCheckBuild({computeBudgetConfig:o})}async getRpcPoolInfo({poolId:e}){return(await this.getRpcPoolsInfo({poolIdList:[e]})).poolInfoMap[e.toBase58()]}async getRpcPoolsInfo({poolIdList:e,config:t}){let n=await ve(this.scope.connection,e.map(c=>({pubkey:c})),t),o={},r=[];for(let c=0;c<e.length;c++){let u=n[c];if(u===null||!u.accountInfo)throw Error("fetch pool info error: "+e[c].toBase58());let l=un.decode(u.accountInfo.data);o[e[c].toBase58()]=q(M({},l),{poolId:u.accountInfo.owner}),r.push(l.configId)}let i=await ve(this.scope.connection,r.map(c=>({pubkey:c})),t),s={};for(let c=0;c<r.length;c++){let u=i[c];if(u===null||!u.accountInfo)throw Error("fetch config info error: "+r[c].toBase58());let l=Zn.decode(u.accountInfo.data);s[r[c].toBase58()]=q(M({},l),{configId:u.accountInfo.owner})}return{poolInfoMap:Object.keys(o).reduce((c,u)=>q(M({},c),{[u]:q(M({},o[u]),{configInfo:s[o[u].configId.toBase58()]})}),{})}}};import{PublicKey as Ry}from"@solana/web3.js";import{MintLayout as Ly,TOKEN_2022_PROGRAM_ID as Su,TOKEN_PROGRAM_ID as Cu}from"@solana/spl-token";var mr=class extends We{constructor(t){super(t);this._tokenList=[];this._tokenMap=new Map;this._blackTokenMap=new Set;this._mintGroup={official:new Set,jup:new Set,extra:new Set};this._whiteMap=new Set;this._extraTokenList=[]}async load(t){this.checkDisabled();let{forceUpdate:n=!1,type:o="strict"}=t||{},{mintList:r,blacklist:i,whiteList:s}=await this.scope.fetchV3TokenList(n),c=await this.scope.fetchJupTokenList(n);this._tokenList=[],this._tokenMap=new Map,this._blackTokenMap=new Set(i),this._mintGroup={official:new Set,jup:new Set,extra:new Set},this._whiteMap=new Set(s),this._tokenMap.set(ln.address,ln),this._mintGroup.official.add(ln.address),r.forEach(u=>{var l;this._blackTokenMap.has(u.address)||(this._tokenMap.set(u.address,q(M({},u),{type:"raydium",priority:2,programId:(l=u.programId)!=null?l:u.tags.includes("token-2022")?Su.toBase58():Cu.toBase58()})),this._mintGroup.official.add(u.address))}),c.forEach(u=>{var l;this._blackTokenMap.has(u.address)||this._tokenMap.has(u.address)||(this._tokenMap.set(u.address,q(M({},u),{type:"jupiter",priority:1,programId:(l=u.programId)!=null?l:u.tags.includes("token-2022")?Su.toBase58():Cu.toBase58(),tags:u.freezeAuthority?[...u.tags||[],"hasFreeze"]:u.tags})),this._mintGroup.jup.add(u.address))}),this._extraTokenList.forEach(u=>{this._blackTokenMap.has(u.address)||this._tokenMap.has(u.address)||(this._tokenMap.set(u.address,q(M({},u),{type:"extra",priority:1,programId:u.programId||u.tags.includes("token-2022")?Su.toBase58():Cu.toBase58()})),this._mintGroup.extra.add(u.address))}),this._tokenList=Array.from(this._tokenMap).map(u=>u[1])}get tokenList(){return this._tokenList}get tokenMap(){return this._tokenMap}get blackTokenMap(){return this._blackTokenMap}get mintGroup(){return this._mintGroup}get whiteListMap(){return this._whiteMap}async getTokenInfo(t){if(!t)throw new Error("please input mint");let n=t.toString(),o=this._tokenMap.get(n);if(o)return o;if(n.toLocaleUpperCase()==="SOL")return ln;let r=(await this.scope.api.getTokenInfo([n]))[0];if(r)return this._mintGroup.extra.add(n),this._tokenMap.set(n,q(M({},r),{priority:2})),r;let i=await this.scope.connection.getAccountInfo(new Ry(n));if(!i)throw new Error(`mint address not found: ${n}`);let s=Ly.decode(i.data),c=n.toString().substring(0,6),u={chainId:101,address:n,programId:i.owner.toBase58(),logoURI:"",symbol:c,name:c,decimals:s.decimals,tags:[],extensions:{},priority:0,type:"unknown"};return this._mintGroup.extra.add(n),this._tokenMap.set(n,u),u}};var Ps=class{constructor(e){this.rawBalances=new Map;let{connection:t,cluster:n,owner:o,api:r,defaultChainTime:i,defaultChainTimeOffset:s,apiCacheTime:c,blockhashCommitment:u="confirmed",loopMultiTxStatus:l}=e;this._connection=t,this.cluster=n||"mainnet",this._owner=o?new _t(o):void 0,this._signAllTransactions=e.signAllTransactions,this.blockhashCommitment=u,this.loopMultiTxStatus=l,this.api=r,this._apiCacheTime=c||5*60*1e3,this.logger=be("Raydium"),this.farm=new Ci({scope:this,moduleName:"Raydium_Farm"}),this.account=new Ai({scope:this,moduleName:"Raydium_Account",tokenAccounts:e.tokenAccounts,tokenAccountRawInfos:e.tokenAccountRawInfos}),this.liquidity=new Ui({scope:this,moduleName:"Raydium_LiquidityV2"}),this.token=new mr({scope:this,moduleName:"Raydium_tokenV2"}),this.tradeV2=new nr({scope:this,moduleName:"Raydium_tradeV2"}),this.clmm=new Xi({scope:this,moduleName:"Raydium_clmm"}),this.cpmm=new Zi({scope:this,moduleName:"Raydium_cpmm"}),this.utils1216=new jt({scope:this,moduleName:"Raydium_utils1216"}),this.marketV2=new Xo({scope:this,moduleName:"Raydium_marketV2"}),this.ido=new Ho({scope:this,moduleName:"Raydium_ido"}),this.launchpad=new lr({scope:this,moduleName:"Raydium_lauchpad"}),this.availability={};let m=new Date().getTime();this.apiData={},s&&(this._chainTime={fetched:m,value:{chainTime:i||Date.now()-s,offset:s}})}static async load(e){var l;let t=Oy({cluster:"mainnet",owner:null,apiRequestInterval:3e5,apiRequestTimeout:1e4},e),{cluster:n,apiRequestTimeout:o,logCount:r,logRequests:i,urlConfigs:s}=t,c=new Rr({cluster:n,timeout:o,urlConfigs:s,logCount:r,logRequests:i}),u=new Ps(q(M({},t),{api:c}));return await u.fetchAvailabilityStatus((l=e.disableFeatureCheck)!=null?l:!0),e.disableLoadToken||await u.token.load({type:e.jupTokenType}),u}get owner(){return this._owner}get ownerPubKey(){if(!this._owner)throw new Error(Lr);return this._owner.publicKey}setOwner(e){return this._owner=e?new _t(e):void 0,this.account.resetTokenAccounts(),this}get connection(){if(!this._connection)throw new Error(yc);return this._connection}setConnection(e){return this._connection=e,this}get signAllTransactions(){return this._signAllTransactions}setSignAllTransactions(e){return this._signAllTransactions=e,this}checkOwner(){if(!this.owner)throw console.error(Lr),new Error(Lr)}isCacheInvalidate(e){return new Date().getTime()-e>this._apiCacheTime}async fetchChainTime(){try{let e=await this.api.getChainTimeOffset();this._chainTime={fetched:Date.now(),value:{chainTime:Date.now()+e.offset*1e3,offset:e.offset*1e3}}}catch{this._chainTime=void 0}}async fetchV3TokenList(e){if(this.apiData.tokenList&&!this.isCacheInvalidate(this.apiData.tokenList.fetched)&&!e)return this.apiData.tokenList.data;try{let t=await this.api.getTokenList(),n={fetched:Date.now(),data:t};return this.apiData.tokenList=n,n.data}catch(t){return console.error(t),{mintList:[],blacklist:[],whiteList:[]}}}async fetchJupTokenList(e){if(this.cluster==="devnet")return[];let t=this.apiData.jupTokenList;if(t&&!this.isCacheInvalidate(t.fetched)&&!e)return t.data;try{let n=await this.api.getJupTokenList();return this.apiData.jupTokenList={fetched:Date.now(),data:n.map(o=>q(M({},o),{mintAuthority:o.mint_authority||void 0,freezeAuthority:o.freeze_authority||void 0}))},this.apiData.jupTokenList.data}catch(n){return console.error(n),[]}}get chainTimeData(){var e;return(e=this._chainTime)==null?void 0:e.value}async chainTimeOffset(){var e;return this._chainTime&&Date.now()-this._chainTime.fetched<=1e3*60*5?this._chainTime.value.offset:(await this.fetchChainTime(),((e=this._chainTime)==null?void 0:e.value.offset)||0)}async currentBlockChainTime(){var e;return this._chainTime&&Date.now()-this._chainTime.fetched<=1e3*60*5?this._chainTime.value.chainTime:(await this.fetchChainTime(),((e=this._chainTime)==null?void 0:e.value.chainTime)||Date.now())}async fetchEpochInfo(){return this._epochInfo&&Date.now()-this._epochInfo.fetched<=1e3*30?this._epochInfo.value:(this._epochInfo={fetched:Date.now(),value:await this.connection.getEpochInfo()},this._epochInfo.value)}async fetchAvailabilityStatus(e){if(e)return{};try{let t=await this.api.fetchAvailabilityStatus(),n=t.all===!1;return this.availability={all:t.all,swap:n?!1:t.swap,createConcentratedPosition:n?!1:t.createConcentratedPosition,addConcentratedPosition:n?!1:t.addConcentratedPosition,addStandardPosition:n?!1:t.addStandardPosition,removeConcentratedPosition:n?!1:t.removeConcentratedPosition,removeStandardPosition:n?!1:t.removeStandardPosition,addFarm:n?!1:t.addFarm,removeFarm:n?!1:t.removeFarm},t}catch{return{}}}};var bO=a=>a;export{Xy as ACCOUNT_TYPE_SIZE,ht as ALL_PROGRAM_ID,rf as AMM_CONFIG_SEED,id as AMM_STABLE,ci as AMM_V4,Ob as ANAMint,mt as API_URLS,Py as AUTH_SEED,Lm as AccountType,Rr as Api,tl as BIT_PRECISION,nn as BNDivCeil,uo as BNLayout,Og as BN_100,Ng as BN_1000,Mg as BN_10000,Lg as BN_FIVE,$u as BN_ONE,oo as BN_TEN,Rg as BN_THREE,Cg as BN_TWO,tt as BN_ZERO,ik as BitStructure,hc as Blob,wu as BondingCurveParam,li as CLMM_LOCK_AUTH_ID,Lo as CLMM_LOCK_PROGRAM_ID,_n as CLMM_PROGRAM_ID,Ls as CLOCK_PROGRAM_ID,Ay as CONFIG_SEED,Us as CREATE_CPMM_POOL_AUTH,ld as CREATE_CPMM_POOL_FEE_ACC,Wn as CREATE_CPMM_POOL_PROGRAM,hy as CREATOR_FEE_VAULT_AUTH_SEED,Xi as Clmm,bl as ClmmConfigLayout,Re as ClmmInstrument,Yi as ConstantProductCurve,Jl as CpmmConfigInfoLayout,cm as CpmmCreatorFeeOn,Nt as CpmmFee,cS as CpmmPermission,os as CpmmPoolInfoLayout,ii as Currency,no as CurrencyAmount,Zt as Curve,Jn as CurveBase,Qi as CurveCalculator,kn as DEVNET_PROGRAM_ID,cA as DEV_API_URLS,zw as DEV_FARM_LOCK_MINT,Yw as DEV_FARM_LOCK_VAULT,pP as DEV_LAUNCHPAD_AUTH,dP as DEV_LAUNCHPAD_PROGRAM,Oo as DEV_LOOKUP_TABLE_CACHE,Kf as DataElement,Nb as ETHMint,Va as EXTENSION_TICKARRAY_BITMAP_SIZE,Dc as FARM_LOCK_MINT,qc as FARM_LOCK_VAULT,_s as FARM_PROGRAM_ID_V3,Es as FARM_PROGRAM_ID_V4,Ws as FARM_PROGRAM_ID_V5,Ro as FARM_PROGRAM_ID_V6,Xt as FARM_PROGRAM_TO_VERSION,Gc as FARM_VERSION_TO_LEDGER_LAYOUT,Uc as FARM_VERSION_TO_STATE_LAYOUT,qs as FEE_DESTINATION_ID,qr as FEE_RATE_DENOMINATOR,Rt as FEE_RATE_DENOMINATOR_VALUE,df as FETCH_TICKARRAY_COUNT,of as Fee,em as FeeOn,ps as FixedPriceCurve,me as Fraction,pi as IDO_ALL_PROGRAM,sd as IDO_PROGRAM_ID_V1,ad as IDO_PROGRAM_ID_V2,ud as IDO_PROGRAM_ID_V3,cd as IDO_PROGRAM_ID_V4,Pr as INSTRUCTION_PROGRAM_ID,G as InstructionType,mc as JupTokenType,md as LAUNCHPAD_AUTH,pd as LAUNCHPAD_CONFIG,dd as LAUNCHPAD_PLATFORM,it as LAUNCHPAD_PROGRAM,Yr as LIQUIDITY_FEES_DENOMINATOR,Da as LIQUIDITY_FEES_NUMERATOR,xr as LIQUIDITY_POOL_PROGRAM_ID_V5_MODEL,wf as LIQUIDITY_VERSION_TO_SERUM_VERSION,fB as LIQUIDITY_VERSION_TO_STATE_LAYOUT,di as LOCK_CPMM_AUTH,mi as LOCK_CPMM_PROGRAM,sy as LOCK_LIQUIDITY_SEED,nl as LOG_B_2_X32,ol as LOG_B_P_ERR_MARGIN_LOWER_X64,il as LOG_B_P_ERR_MARGIN_UPPER_X64,Dn as LOOKUP_TABLE_CACHE,ms as LaunchConstantProductCurve,Zn as LaunchpadConfig,un as LaunchpadPool,Bo as LaunchpadPoolInitParam,ZR as LaunchpadVesting,gi as Layout,ys as LinearPriceCurve,ke as LiquidityMath,Al as LockClPositionLayoutV2,xI as LockPositionLayout,xm as LogLevel,Ts as Logger,eu as MARKET_STATE_LAYOUT_V2,uu as MARKET_STATE_LAYOUT_V3,om as MARKET_VERSION_TO_STATE_LAYOUT,sc as MAX_BASE64_SIZE,Qt as MAX_SQRT_PRICE_X64,Dr as MAX_SQRT_PRICE_X64_SUB_ONE,xt as MAX_TICK,gr as MEMO_PROGRAM_ID,mn as MEMO_PROGRAM_ID2,Gt as METADATA_PROGRAM_ID,Yt as MIN_SQRT_PRICE_X64,Wr as MIN_SQRT_PRICE_X64_ADD_ONE,Pt as MIN_TICK,En as MODEL_DATA_PUBKEY,rs as Market,cr as MathLaunch,le as MathUtil,Ri as MaxU64,el as MaxUint128,Bn as NEGATIVE_ONE,Lb as NRVMint,lf as OBSERVATION_SEED,Wt as ONE,Ds as OPEN_BOOK_PROGRAM,uf as OPERATION_SEED,gl as ObservationInfoLayout,yf as ObservationLayout,Pl as OperationLayout,ra as OptionLayout,_t as Owner,Ib as PAIMint,Ty as PLATFORM_FEE_VAULT_AUTH_SEED,wy as PLATFORM_SEED,dl as POOL_LOCK_ID_SEED,sf as POOL_REWARD_VAULT_SEED,La as POOL_SEED,cf as POOL_TICK_ARRAY_BITMAP_SEED,Oa as POOL_VAULT_SEED,ky as POOL_VESTING_SEED,ul as POSITION_SEED,Qe as Percent,$o as PlatformConfig,xy as PlatformCurveParam,dc as PoolFetchType,po as PoolInfoLayout,Fe as PoolUtils,Do as PositionInfoLayout,gf as PositionRewardInfoLayout,Mi as PositionUtils,lt as Price,BI as ProtocolPositionLayout,Er as Q128,st as Q64,hb as RAYMint,Je as RENT_PROGRAM_ID,Ps as Raydium,bf as RewardInfo,Ul as RoundDirection,xs as Rounding,rd as Router,tm as SERUM_PROGRAMID_TO_VERSION,Br as SERUM_PROGRAM_ID_V3,nm as SERUM_VERSION_TO_PROGRAMID,pc as SESSION_KEY,ct as SOLMint,ln as SOL_INFO,hl as SPL_MINT_LAYOUT,Bb as SRMMint,Hs as STORAGE_KEY,mf as SUPPORT_MINT_SEED,Ar as SYSTEM_PROGRAM_ID,se as SqrtPriceMath,Go as StableLayout,sa as Structure,mo as SwapMath,lo as TICK_ARRAY_BITMAP_SIZE,af as TICK_ARRAY_SEED,at as TICK_ARRAY_SIZE,sh as TICK_SPACINGS,ut as TOKEN_WSOL,Kn as TickArrayBitmap,yl as TickArrayBitmapExtensionLayout,Fi as TickArrayBitmapExtensionUtils,vi as TickArrayLayout,Pf as TickLayout,fo as TickMath,he as TickQuery,Z as TickUtils,Ke as Token,Ie as TokenAmount,Hf as TradeDirection,jf as TradeDirectionOpposite,bi as TxBuilder,bn as TxVersion,Li as U64Resolution,uh as U64_IGNORE_RANGE,na as UInt,xb as USDCMint,Rb as USDHMint,Kb as USDTMint,od as UTIL1216,aa as Union,By as VestingSchedule,Wc as Voter,Dp as VoterDepositEntry,Wp as VoterLockup,Ec as VoterRegistrar,Ep as VoterVotingMintConfig,$ as WSOLMint,Fr as WideBits,hn as WrappedLayout,Pe as ZERO,Hu as _100_PERCENT,k as accountMeta,gg as add,si as addComputeBudget,Xa as addLiquidityLayout,Tt as anchorDataBuf,Dk as array,ma as associatedLedgerAccountLayout,oa as bits,Be as blob,qe as bool,pm as buyExactInInstruction,fm as buyExactOutInstruction,Ba as calFarmRewardAmount,ri as ceilDiv,so as ceilDivBN,ui as checkLegacyTxSize,CL as checkPoolToAmm,An as checkV0TxSize,Bs as chunkArray,Ku as claimCreatorFee,or as claimLayout,Bu as claimPlatformFee,xu as claimPlatformFeeFromVault,hu as claimVestedToken,fl as clmmComputeInfoToApiInfo,In as closeAccountInstruction,su as collectCpFeeInstruction,Ss as commonSystemAccountMeta,ai as confirmTransaction,cy as cpmmLockPositionInstruction,Bi as createAssociatedLedgerAccountInstruction,be as createLogger,gm as createPlatformConfig,xl as createPoolFeeLayout,Qa as createPoolV4InstructionV2,pB as createPoolV4Layout,Iu as createVestingAccount,Gn as createWSolAccountInstructions,Ok as cstr,qb as currencyEquals,_g as decimalToFraction,Ap as decodeBool,pg as div,kr as divCeil,Bt as dwLayout,kp as encodeBool,OA as endlessRetry,zm as eq,Kk as f32,Sk as f32be,Ck as f64,Rk as f64be,ya as farmAddRewardLayout,vw as farmLedgerLayoutV3_1,wi as farmLedgerLayoutV3_2,Fw as farmLedgerLayoutV5_1,Vc as farmLedgerLayoutV5_2,_c as farmLedgerLayoutV6_1,zc as farmRewardInfoToConfig,pa as farmRewardLayout,fa as farmRewardRestartLayout,_p as farmRewardTimeInfoLayout,vc as farmStateV3Layout,Fc as farmStateV5Layout,ki as farmStateV6Layout,lT as fetchMultipleFarmInfoAndUpdate,JB as fetchMultipleInfo,Co as fetchMultipleMintInfos,te as findProgramAddress,qa as fixedSwapInLayout,Ua as fixedSwapOutLayout,wr as floorDiv,Ir as forecastTransactionSize,Vf as formatLayout,je as generatePubKey,j as getATAAddress,Xc as getAssociatedAuthority,jr as getAssociatedConfigId,gt as getAssociatedLedgerAccount,hi as getAssociatedLedgerPoolAccount,Df as getAssociatedOpenOrders,Ja as getAssociatedPoolKeys,ji as getCpLockPda,jK as getCpmmPdaAmmConfigId,nu as getCpmmPdaPoolId,ou as getCreatePoolKeys,ec as getDate,xa as getDepositEntryIndex,Sr as getDevLookupTableCache,Ml as getDxByDyBaseIn,Nl as getDyByDxBaseIn,iP as getEpochInfo,_o as getFarmLedgerLayout,Up as getFarmStateLayout,Za as getLiquidityAssociatedAuthority,Po as getLiquidityAssociatedId,tI as getLiquidityFromAmounts,Ys as getMainLookupTableCache,bg as getMax,tn as getMultipleAccountsInfo,ve as getMultipleAccountsInfoWithCustomFlags,Kr as getMultipleLookupTableInfo,yh as getPdaAmmConfigId,$n as getPdaCpiEvent,ku as getPdaCreatorFeeVaultAuth,ho as getPdaCreatorVault,$e as getPdaExBitmapAccount,yn as getPdaLaunchpadAuth,HR as getPdaLaunchpadConfigId,jo as getPdaLaunchpadPoolId,gu as getPdaLaunchpadVaultId,Wo as getPdaLockClPositionIdV2,Ma as getPdaLockPositionId,iy as getPdaLpMint,xn as getPdaMetadataKey,va as getPdaMintExAccount,ml as getPdaObservationAccount,Hi as getPdaObservationId,Ni as getPdaOperationAccount,zl as getPdaPermissionId,Kt as getPdaPersonalPositionAddress,Au as getPdaPlatformFeeVaultAuth,Pu as getPdaPlatformId,To as getPdaPlatformVault,zo as getPdaPoolAuthority,cl as getPdaPoolId,ll as getPdaPoolRewardVaulId,Na as getPdaPoolVaultId,an as getPdaProtocolPositionAddress,Ae as getPdaTickArrayAddress,Xl as getPdaVault,rr as getPdaVestId,ro as getRecentBlockHash,Aa as getRegistrarAddress,kd as getSessionKey,vl as getStablePrice,jm as getTime,EP as getTimestamp,Ia as getTokenOwnerRecordAddress,bP as getTransferAmountFee,Xs as getTransferAmountFeeFromPost,Gs as getTransferAmountFeeFromPre,xe as getTransferAmountFeeV2,Ta as getVoterAddress,ha as getVoterWeightRecordAddress,wa as getVotingMintAuthority,ka as getVotingTokenMint,Zp as governanceCreateTokenOwnerRecord,rk as greedy,Xm as gt,dg as gte,Rc as i128,lh as i16ToBytes,Gr as i32ToBytes,vo as i64,Cc as i8,Ga as initPoolLayout,ca as initTokenAccountInstruction,lL as initialize,Xf as initializeMarket,mm as initializeV2,Zl as initializeWithPermission,dm as initializeWithToken2022,Ug as intersection,nc as isDateAfter,tc as isDateBefore,Eg as isDecimal,yg as isMeaningfulNumber,Ju as isNumber,ga as isValidFarmVersion,Oi as isZero,Ee as jsonInfo2PoolKeys,mT as judgeFarmType,Ca as leadingZeros,al as leastSignificantBit,yo as liquidityStateV4Layout,Tf as liquidityStateV5Layout,lg as lt,mg as lte,Sb as mSOLMint,Qr as makeAMMSwapInstruction,Cl as makeAddLiquidityInstruction,Sa as makeAddNewRewardInstruction,us as makeClaimInstruction,bu as makeClaimInstructionV4,au as makeCollectCreatorFeeInstruction,$l as makeCpmmLockInstruction,Yl as makeCreateCpmmPoolInInstruction,Yc as makeCreateFarmInstruction,Zr as makeCreateMarketInstruction,Qc as makeCreatorWithdrawFarmRewardInstruction,Ql as makeDepositCpmmInInstruction,jc as makeDepositInstructionV3,$c as makeDepositInstructionV5,Zc as makeDepositInstructionV6,KT as makeDepositTokenInstruction,CT as makeDepositWithdrawInstruction,xB as makeInitPoolInstructionV4,CR as makePurchaseInstruction,Ka as makeRestartRewardInstruction,Rl as makeSimulatePoolInfoInstruction,ns as makeSwapCpmmBaseInInstruction,jl as makeSwapCpmmBaseOutInstruction,Bf as makeSwapFixedInInstruction,xf as makeSwapFixedOutInstruction,rm as makeSwapInstruction,Mc as makeTransferInstruction,Hl as makeWithdrawCpmmInInstruction,Si as makeWithdrawInstructionV3,Hc as makeWithdrawInstructionV4,Ki as makeWithdrawInstructionV5,xi as makeWithdrawInstructionV6,ST as makeWithdrawTokenInstruction,on as minExpirationTime,ah as mockCreatePoolInfo,rl as mockV3CreatePoolInfo,Sf as modelDataInfoLayout,sl as mostSignificantBit,Fs as mul,Pd as notInnerObject,kk as ns64,xk as ns64be,Ic as nu64,fk as nu64be,ia as offset,Dg as offsetDateTime,_k as option,J as parseBigNumberish,io as parseNumberInfo,uc as parseSimulateLogToJson,Pn as parseSimulateValue,Nc as parseTokenAccountResp,JI as parseTokenInfo,zn as poolTypeV6,Vn as printSimulate,O as publicKey,pu as purchaseLayout,vp as realFarmStateV3Layout,Fp as realFarmStateV5Layout,Vp as realFarmV6Layout,Ya as removeLiquidityInstruction,za as removeLiquidityLayout,dL as removePlatformCurveParamInstruction,NC as route1Instruction,MC as route2Instruction,dy as routeInstruction,Wk as rustEnum,bk as s16,wk as s16be,gk as s24,Tk as s24be,De as s32,hk as s32be,Pk as s40,Ik as s40be,Ak as s48,Bk as s48be,yk as s8,ym as sellExactInInstruction,bm as sellExactOut,Y as seq,Fy as setLoggerLevel,Qm as shakeFractionDecimal,ac as simulateMultipleInstruction,BB as simulatePoolInfoInstruction,Jm as simulateTransaction,lc as sleep,bt as solToWSol,tB as solToWSolToken,sn as splAccountLayout,zu as splitNumber,Cb as stSOLMint,ft as str,F as struct,fg as sub,vC as swapBaseInAutoAccount,FC as swapBaseOutAutoAccount,Ek as tagged,vs as tenExponential,$r as toAmmComputePoolInfo,At as toApiV3Token,Hm as toBN,cc as toBuffer,Yn as toFeeConfig,Zu as toFraction,cg as toFractionWithDecimals,vg as toPercent,zr as toToken,_i as toTokenAmount,eB as toTokenInfo,Fg as toTokenPrice,Vg as toTotalPrice,ju as toUsdCurrency,Ra as trailingZeros,rP as transformTxToBase64,Rs as tryParsePublicKey,ed as txToBase64,ne as u128,Et as u16,Ur as u16ToBytes,ck as u16be,sk as u24,lk as u24be,pt as u32,mh as u32ToBytes,mk as u32be,ak as u40,dk as u40be,uk as u48,pk as u48be,A as u64,_ as u8,Iy as u8ToBytes,qk as union,bO as unionArr,Lk as unionLayoutDiscriminator,Xg as uniq,Gp as updateFarmPoolInfo,Pm as updatePlatformConfig,mL as updatePlatformCurveParamInstruction,Cr as updateReqHistory,Nk as utf8,Cs as validateAndParsePublicKey,Pa as validateFarmRewards,Lc as vec,wp as vecU8,ef as voterStakeRegistryCreateDepositEntry,Jp as voterStakeRegistryCreateVoter,Hp as voterStakeRegistryDeposit,jp as voterStakeRegistryUpdateVoterWeightRecord,$p as voterStakeRegistryWithdraw,nB as wSolToSolToken,da as withdrawRewardLayout,Gg as xor,Uk as zeros};
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
//# sourceMappingURL=index.mjs.map